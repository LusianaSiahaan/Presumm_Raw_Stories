Ansible for DevOps  Server and configuration management for humans    Jeff Geerling    This book is for sale at http:  leanpub.com ansible-for-devops  This version was published on 2015-05-17  *   *   *   *   *  This is a Leanpub book. Leanpub empowers authors and publishers with the Lean Publishing process. Lean Publishing is the act of publishing an in- progress ebook using lightweight tools and many iterations to get reader feedback, pivot until you have the right book and build traction once you do.  *   *   *   *   *    2014 - 2015 Jeff Geerling   To my wife and children.  Cover photograph and illustration   2011 Jeff Geerling  Ansible is a software product distributed under the GNU GPLv3 open source license.  Editing by Margie Newman and Katie Geerling.   Table of Contents  Preface  Who is this book for? Typographic conventions Please help improve this book! About the Author  Introduction  In the beginning, there were sysadmins Modern infrastructure management Ansible and Ansible, Inc. Ansible Examples Other resources  Chapter 1 - Getting Started with Ansible  Ansible and Infrastructure Management  On snowflakes and shell scripts Configuration management  Installing Ansible Creating a basic inventory file Running your first Ad-Hoc Ansible command Summary  Chapter 2 - Local Infrastructure Development: Ansible and Vagrant  Prototyping and testing with local virtual machines Your first local server: Setting up Vagrant Using Ansible with Vagrant Your first Ansible playbook Summary  Chapter 3 - Ad-Hoc Commands  Conducting an orchestra Build infrastructure with Vagrant for testing Inventory file for multiple servers   Configure groups of servers, or individual servers  Your first ad-hoc commands Discover Ansible’s parallel nature Learning about your environment Make changes using Ansible modules  Configure the Application servers Configure the Database servers Make changes to just one server Manage users and groups Manage files and directories  Get information about a file Copy a file to the servers Retrieve a file from the servers Create directories and files Delete directories and files  Run operations in the background  Update servers asynchronously, monitoring progress Fire-and-forget tasks  Check log files Manage cron jobs Deploy a version-controlled application Ansible’s SSH connection history  Paramiko OpenSSH  default  Accelerated Mode Faster OpenSSH in Ansible 1.5+  Summary  Chapter 4 - Ansible Playbooks  Power plays Running Playbooks with ansible-playbook  Limiting playbooks to particular hosts and groups Setting user and sudo options with ansible-playbook Other options for ansible-playbook  Real-world playbook: CentOS Node.js app server  Add extra repositories Deploy a Node.js app Launch a Node.js app Node.js app server summary  Real-world playbook: Ubuntu LAMP server with Drupal  Include a variables file, and discover pre_tasks and handlers Basic LAMP server setup Configure Apache   Configure PHP with lineinfile Configure MySQL Install Composer and Drush Install Drupal with Git and Drush Drupal LAMP server summary  Real-world playbook: Ubuntu Apache Tomcat server with Solr  Include a variables file, and discover pre_tasks and handlers Install Apache Tomcat 7 Install Apache Solr Apache Solr server summary  Summary  Chapter 5 - Ansible Playbooks - Beyond the Basics  Handlers Environment variables  Per-play environment variables  Variables  Playbook Variables Inventory variables Registered Variables Accessing Variables Host and Group variables  group_vars and host_vars Magic variables with host and group variables and information  Facts  Variables derived from system information   Local Facts  Facts.d   Variable Precedence  If then when - Conditionals  Jinja2 Expressions, Python built-ins, and Logic register when changed_when and failed_when ignore_errors  Delegation, Local Actions, and Pauses  Pausing playbook execution with wait_for Running an entire playbook locally  Prompts Tags Summary  Includes  Handler includes Playbook includes  Chapter 6 - Playbook Organization - Roles and Includes   Complete includes example  Roles  Role scaffolding Building your first role More flexibility with role vars and defaults Other role parts: handlers, files, and templates  Organizing more complex and cross-platform roles  Handlers Files and Templates  Ansible Galaxy  Getting roles from Galaxy  Using role requirements files to manage dependencies  A LAMP server in six lines of YAML A Solr server in six lines of YAML Helpful Galaxy commands Contributing to Ansible Galaxy  Summary  Chapter 7 - Inventories  A real-world web application server inventory  Non-prod environments, separate inventory files  Inventory variables  host_vars group_vars  Ephemeral infrastructure: Dynamic inventory  Dynamic inventory with DigitalOcean DigitalOcean account prerequisites Connecting to your DigitalOcean account Creating a droplet with Ansible DigitalOcean dynamic inventory with digital_ocean.py  Dynamic inventory with AWS Inventory on-the-fly: add_host and group_by Multiple inventory sources - mixing static and dynamic inventories Creating custom dynamic inventories  Summary  Chapter 8 - Ansible Cookbooks  Highly-Available Infrastructure with Ansible  Directory Structure Individual Server Playbooks Main Playbook for Configuring All Servers Getting the required roles Vagrantfile for Local Infrastructure via VirtualBox Provisioner Configuration: DigitalOcean Provisioner Configuration: Amazon Web Services  EC2    GlusterFS Distributed File System Configuration with Ansible  Summary  ELK Logging with Ansible  ELK Playbook Forwarding Logs from Other Servers Summary  Configuring Gluster - Basic Overview Configuring Gluster with Ansible Summary  Mac Provisioning with Ansible and Homebrew  Running Ansible playbooks locally Automating Homebrew package and app management Configuring Mac OS X through dotfiles Summary  Docker-based Infrastructure with Ansible  A brief introduction to Docker containers Using Ansible to build and manage containers Building a Flask app with Ansible and Docker  Data storage container Flask container MySQL container  Ship it! Summary  Chapter 9 - Deployments with Ansible  Deployment strategies Simple single-server deployments Provisioning a simple Ruby on Rails server Deploying a Rails app to the server Provisioning and Deploying the Rails App Deploying application updates  Zero-downtime multi-server deployments  Ensuring zero downtime with serial and integration tests Deploying to app servers behind a load balancer  Capistrano-style and blue-green deployments Additional Deployment Scenarios Summary  Chapter 10 - Server Security and Ansible  A brief history of SSH and remote access  Telnet rlogin, rsh and rcp SSH The evolution of SSH and the future of remote access   Use secure and encrypted communication Disable root login and use sudo Remove unused software, open only required ports Use the principle of least privilege  User account configuration File permissions  Update the OS and installed software  Automating updates Automating updates for RedHat-based systems Automating updates for Debian-based systems  Use a properly-configured firewall  Configuring a firewall with ufw on Debian or Ubuntu Configuring a firewall with firewalld on RedHat, Fedora, or CentOS  Make sure log files are populated and rotated Monitor logins and block suspect IP addresses Use SELinux  Security-Enhanced Linux  or AppArmor Summary and further reading  Chapter 11 - Automating Your Automation - Ansible Tower and CI CD  Ansible Tower  Getting and Installing Ansible Tower Using Ansible Tower Other Tower Features of Note Tower Alternatives  Jenkins CI Unit, Integration, and Functional Testing  Debugging and Asserting Checking syntax and performing dry runs Automated testing on GitHub using Travis CI  Setting up a role for testing Testing the role’s syntax Role success - first run Role idempotence Role success - final result Some notes about Travis CI Real-world examples  Automated testing with test-runner Functional testing using serverspec  Summary  Appendix A - Using Ansible on Windows workstations   Appendix B - Ansible Best Practices and Conventions  Prerequisites Set up an Ubuntu Linux Virtual Machine Log into the Virtual Machine Install Ansible Summary  Playbook Organization  Write comments and use name liberally Include related variables and tasks Use Roles to bundle logical groupings of configuration  YAML Conventions and Best Practices  YAML for Ansible tasks Three ways to format Ansible tasks Shorthand one-line  key=value  Structured map multi-line  key:value  Folded scalars multi-line  >   Using  to format multiline variables  Using ansible-playbook Use Ansible Tower Specify --forks for playbooks running on > 5 servers Use Ansible’s Configuration file Summary  Appendix C - Jinja2 and Ansible  Summary Changelog  Version 0.94  2015-05-16  Version 0.92  2015-04-09  Version 0.90  2015-03-16  Version 0.89  2015-02-26  Version 0.88  2015-02-13  Version 0.87  2015-02-01  Version 0.84  2015-01-27  Version 0.81  2015-01-11  Version 0.75  2014-12-23  Version 0.73  2014-12-09  Version 0.71  2014-11-27    Version 0.70  2014-11-16  Version 0.64  2014-10-24  Version 0.62  2014-10-07  Version 0.60  2014-09-30  Version 0.58  2014-08-01  Version 0.56  2014-07-20  Version 0.54  2014-07-02  Version 0.53  2014-06-28  Version 0.52  2014-06-14  Version 0.50  2014-05-05  Version 0.49  2014-04-24  Version 0.47  2014-04-13  Version 0.44  2014-04-04  Version 0.42  2014-03-25  Version 0.38  2014-03-11  Version 0.35  2014-02-25  Version 0.33  2014-02-20    Preface  Growing up, I had access to a world that not many kids ever get to enter. At the local radio stations where my dad was chief engineer, I was fortunate to get to see networks and IT infrastructure up close: Novell servers and old Mac and Windows workstations in the ’90s; Microsoft and Linux-based servers; and everything in between. Best of all, he brought home decommissioned servers and copies of Linux burned to CD.  I began working with Linux and small-scale infrastructures before I started high school, and my passion for infrastructure grew as I built a Cat5 wired network and a small rack of networking equipment for a local grade school. When I started developing full-time, what was once a hobby became a necessary part of my job, so I invested more time in managing infrastructure efficiently. Over the past ten years, I’ve gone from manually booting and configuring physical and virtual servers; to using relatively complex shell scripts to provision and configure servers; to using configuration management tools to manage many cloud-based servers.  When I began converting my infrastructure to code, some of the best tools for testing, provisioning, and managing my servers were still in their infancy, but they have since matured into fully-featured, robust tools that I use every day. Vagrant is an excellent tool for managing local virtual machines to mimic real-world infrastructure locally  or in the cloud , and Ansible — the subject of this book — is an excellent tool for provisioning servers, managing their configuration, and deploying applications, even on my local workstation!  These tools are still improving rapidly, and I’m excited for what the future holds. New tools like Docker that are nearing production-ready status also excite me, and I know the time I invest in learning to use these tools well will be helpful for years to come.  Ansible, Docker, and Vagrant seem a potent combination for both local and production infrastructure, but that’s a little outside of this book’s scope.    In these pages, I’ll share with you all I’ve learned about Ansible: my favorite tool for server provisioning, configuration management, and application deployment. I hope you enjoy reading this book as much as I did writing it!  — Jeff Geerling, 2015  Who is this book for? Many of the developers and sysadmins I work with are at least moderately comfortable administering a Linux server via SSH, and manage between 1- 100 servers.  Some of these people have a little experience with configuration management tools  usually with Puppet or Chef , and maybe a little experience with deployments and continuous integration using tools like Jenkins, Capistrano, or Fabric. I am writing this book for these friends who, I think, are representative of most people who have heard of and or are beginning to use Ansible.  If you are interested in both development and operations, and have at least a passing familiarity with managing a server via the command line, this book should provide you with an intermediate- to expert-level understanding of Ansible and how you can use it to manage your infrastructure.  Typographic conventions Ansible uses a simple syntax  YAML  and simple command-line tools  using common POSIX conventions  for all its powerful abilities. Code samples and commands will be highlighted throughout the book either inline  for example: ansible [command] , or in a code block  with or without line numbers  like:  1 ---  2  This is the beginning of a YAML file.   Some lines of YAML and other code examples require more than 80 characters per line, resulting in the code wrapping to a new line. Wrapping code is indicated by a \ at the end of the line of code. For example:   1  The line of code wraps due to the extremely long URL.  2 wget  http:  www.example.com really really really long path in the url ca uses the\  3  line to wrap   When using the code, don’t copy the \ character, and make sure you don’t use a newline between the first line with the trailing \ and the next line.  Links to pertinent resources and websites are added inline, like the following link to Ansible, and can be viewed directly by clicking on them in eBook formats, or by following the URL in the footnotes.  Sometimes, asides are added to highlight further information about a specific topic:  Informational asides will provide extra information.  Warning asides will warn about common pitfalls and how they can be avoided.  Tip asides will give tips for deepening your understanding or optimizing your use of Ansible.  When displaying commands run in a terminal session, if the commands are run under your normal non-root user account, the commands will be prefixed by the dollar sign  $ . If the commands are run as the root user, they will be prefixed with the pound sign   .  Please help improve this book! This book is a work in progress, and is being expanded and updated on LeanPub at a rather rapid clip. If you think a particular section needs improvement or find something missing, please contact me via Twitter    @geerlingguy , Google+, a comment on this book’s Feedback page on LeanPub, or whatever method is convenient for you.  Please note that, since the book is still being written and proofread, the book contains certain imperfections and oddities. I’ve tried to ensure every line of code, at least, works perfectly, but I may have an occasional typo. You’ve been warned!  About the Author Jeff Geerling is a developer who has worked in programming and devops for companies with anywhere between one to thousands of servers. He also manages many virtual servers for services offered by Midwestern Mac, LLC and has been using Ansible to manage infrastructure since early 2013.   Introduction  In the beginning, there were sysadmins Since the beginning of networked computing, deploying and managing servers reliably and efficiently has been a challenge. Historically, system administrators have typically been walled off from the developers and users who interact with the systems they administer, and so they have had to manage servers by hand, installing software, changing configurations, and administering services on individual servers.  As data centers grew, and hosted applications became more complex, administrators realized they couldn’t scale their manual systems management as fast as the applications they were enabling. That’s why server provisioning and configuration management tools came to flourish.  Server virtualization brought large-scale infrastructure management to the fore, and the number of servers managed by one admin  or by a small team of admins , has grown by an order of magnitude. Instead of deploying, patching, and destroying every server by hand, admins now are expected to bring up new servers, either automatically or with minimal intervention. Large-scale IT deployments now may involve hundreds or thousands of servers; in many of the largest environments, server provisioning, configuration, and decommissioning are all entirely automated.  Modern infrastructure management As the systems that run applications become an ever more complex and integral part of the software they run, application developers themselves have begun to integrate their work more fully with operations personnel. In many companies, development and operations work is almost fully integrated. Indeed, this integration can be a requirement for modern test- driven application design.   As a software developer by trade, and a sysadmin by necessity, I have seen the power in uniting development and operations—more commonly referred to now as DevOps. When developers begin to think of infrastructure as part of their application, stability and performance become normative. When sysadmins  most of whom have intermediate to advanced knowledge of the applications and languages being used on servers they manage  work tightly with developers, development velocity is improved, and more time can be spent doing ‘fun’ activities like performance tuning, experimentation, and getting things done, and less time putting out fires.  DevOps is a loaded word; some people argue that using the word to identify both the movement of development and operations working more closely to automate infrastructure-related processes, and the personnel who skew slightly more towards the system administration side of the equation, dilutes the word’s meaning. I think the word has come to be a rallying cry for the employees who are dragging their startups, small businesses, and enterprises into a new era of infrastructure growth and stability. I’m not too concerned that the term has become more of a catch-all for modern infrastructure management. My advice: spend less time arguing over the definition of the word, and more time making it mean something to you.  Ansible and Ansible, Inc. Ansible was released in 2012 by Michael DeHaan  @laserllama on Twitter , a developer who has been working with configuration management and infrastructure orchestration in one form or another for many years. Through his work with Puppet Labs and RedHat  where he worked on Cobbler, a configuration management tool and Func, a tool for communicating commands to remote servers , and some other projects, he experienced the trials and tribulations of many different organizations and individual sysadmins on their quest to simplify and automate their infrastructure management operations.  Additionally, Michael found many shops were using separate tools for configuration management  Puppet, Chef, cfengine , server deployment  Capistrano, Fabric , and ad-hoc task execution  Func, plain SSH , and wanted to see if there was a better way. Ansible wraps up all three of these features into one tool, and does it in a way that’s actually simpler and more consistent than any of the other task-specific tools!   Ansible aims to be:  1. Clear - Ansible uses a simple syntax  YAML  and is easy for anyone  developers, sysadmins, managers  to understand. APIs are simple and sensible.  2. Fast - Fast to learn, fast to set up—especially considering you don’t  need to install extra agents or daemons on all your servers!  3. Complete - Ansible does three things in one, and does them very well.  Ansible’s ‘batteries included’ approach means you have everything you need in one complete package.  4. Efficient - No extra software on your servers means more resources for your applications. Also, since Ansible modules work via JSON, you can easily extend Ansible with modules in a programming language you already know.  5. Secure - Ansible uses SSH, and requires no extra open ports or  potentially-vulnerable daemons on your servers.  Ansible also has a lighter side that gives the project a little personality. As an example, Ansible’s major releases are named after Van Halen songs  e.g. 1.4 was named after 1980’s “Could This Be Magic”, and 1.5 after 1986’s “Love Walks In” . Additionally, Ansible will use cowsay, if installed, to wrap output in an ASCII cow’s speech bubble  this behavior can be disabled in Ansible’s configuration .  Ansible, Inc. was founded by Saïd Ziouani  @SaidZiouani on Twitter  and Michael DeHaan, and oversees core Ansible development and provides support  such as Ansible Guru  and extra tooling  such as Ansible Tower  to organizations using Ansible. Hundreds of individual developers have contributed patches to Ansible, and Ansible is the most starred infrastructure management tool on GitHub  with over 10,000 stars as of this writing . Ansible, Inc. has proven itself to be a good steward and promoter of Ansible so far, and I see no indication of this changing in the future.  Ansible Examples There are many Ansible examples  playbooks, roles, infrastructure, configuration, etc.  throughout this book. Most of the examples are in the Ansible for DevOps GitHub repository, so you can browse the code in its   final state while you’re reading the book. Some of the line numbering may not match the book exactly  especially if you’re reading an older version of the book! , but I will try my best to keep everything synchronized over time.  Other resources We’ll explore all aspects of using Ansible to provision and manage your infrastructure in this book, but there’s no substitute for the wealth of documentation and community interaction that make Ansible great. Check out the links below to find out more about Ansible and discover the community:  Ansible Documentation - Covers all Ansible options in depth. There are few open source projects with documentation as clear and thorough. Ansible Glossary - If there’s ever a term in this book you don’t seem to fully understand, check the glossary. Ansible Mailing List - Discuss Ansible and submit questions with Ansible’s community via this Google group. Ansible on GitHub - The official Ansible code repository, where the magic happens. Ansible Example Playbooks on GitHub - Many examples for common server configurations. Getting Started with Ansible - A simple guide to Ansible’s community and resources. Ansible Blog Ansible Weekly - A newsletter about Ansible, including notable cowsay quotes!  I’d like to especially highlight Ansible’s documentation  the first resource listed above ; one of Ansible’s greatest strengths is its well-written and extremely relevant documentation, containing a large number of relevant examples and continously-updated guides. Very few projects—open source or not—have documentation as thorough, yet easy-to-read. This book is meant as a supplement to, not a replacement for, Ansible’s documentation!   Chapter 1 - Getting Started with Ansible  Ansible and Infrastructure Management On snowflakes and shell scripts Many developers and system administrators manage servers by logging into them via SSH, making changes, and logging off. Some of these changes would be documented, some would not. If an admin needed to make the same change to many servers  for example, changing one value in a config file , the admin would manually log into each server and repeatedly make this change.  If there were only one or two changes in the course of a server’s lifetime, and if the server were extremely simple  running only one process, with one configuration, and a very simple firewall , and if every change were thoroughly documented, this process wouldn’t be a problem.  But for almost every company in existence, servers are more complex— most run tens, sometimes hundreds of different applications. Most servers have complicated firewalls and dozens of tweaked configuration files. And even with change documentation, the manual process usually results in some servers or some steps being forgotten.  If the admins at these companies wanted to set up a new server exactly like one that is currently running, they would need to spend a good deal of time going through all of the installed packages, documenting configurations, versions, and settings; and they would spend a lot of unnecessary time manually reinstalling, updating, and tweaking everything to get the new server to run close to how the old server did.  Some admins may use shell scripts to try to reach some level of sanity, but I’ve yet to see a complex shell script that handles all edge cases correctly while synchronizing multiple servers’ configuration and deploying new code.   Configuration management Lucky for you, there are tools to help you avoid having these snowflake servers—servers that are uniquely configured and impossible to recreate from scratch because they were hand-configured without documentation. Tools like CFEngine, Puppet and Chef became very popular in the mid-to- late 2000s.  But there’s a reason why many developers and sysadmins stick to shell scripting and command-line configuration: it’s simple and easy-to-use, and they’ve had years of experience using bash and command-line tools. Why throw all that out the window and learn a new configuration language and methodology?  Enter Ansible. Ansible was built  and continues to be improved  by developers and sysadmins who know the command line—and want to make a tool that helps them manage their servers exactly the same as they have in the past, but in a repeatable and centrally managed way. Ansible also has other tricks up its sleeve, making it a true Swiss Army knife for people involved in DevOps  not just the operations side .  One of Ansible’s greatest strengths is its ability to run regular shell commands verbatim, so you can take existing scripts and commands and work on converting them into idempotent playbooks as time allows. For someone  like me  who was comfortable with the command line, but never became proficient in more complicated tools like Puppet or Chef  which both required at least a slight understanding of Ruby and or a custom language just to get started , Ansible was a breath of fresh air.  Ansible works by pushing changes out to all your servers  by default , and requires no extra software to be installed on your servers  thus no extra memory footprint, and no extra daemon to manage , unlike most other configuration management tools.   Idempotence is the ability to run an operation which produces the same result whether run once or multiple times  source .  An important feature of a configuration management tool is its ability to ensure the same configuration is maintained whether you run it once or a thousand times. Many shell scripts have unintended consequences if run more than once, but Ansible can deploy the same configuration to a server over and over again without making any changes after the first deployment.  In fact, almost every aspect of Ansible modules and commands is idempotent, and for those that aren’t, Ansible allows you to define when the given command should be run, and what constitutes a changed or failed command, so you can easily maintain an idempotent configuration on all your servers.  Installing Ansible Ansible’s only real dependency is Python. Once Python is installed, the simplest way to get Ansible running is to use pip, a simple package manager for Python.  If you’re on a Mac, installing Ansible is a piece of cake:  1. Install Homebrew  get the installation command from the Homebrew  website .  2. Install Python 2.7.x  brew install python . 3. Install Ansible  sudo pip install ansible .  You could also install Ansible via Homebrew with brew install ansible. Either way  pip or brew  is fine, but make sure you update Ansible using the same system with which it was installed!  If you’re running Windows  i.e. you work for a large company that forces you to use Windows , it will take a little extra work to everything set up. There are two ways you can go about using Ansible if you use Windows:  1. The easiest solution would be to use a Linux virtual machine  with  something like VirtualBox  to do your work. For detailed instructions, see Appendix A - Using Ansible on Windows workstations.   2. Ansible runs  somewhat  within an appropriately-configured Cygwin environment. For setup instructions, please see my blog post Running Ansible within Windows , and note that running Ansible directly within Windows is unsupported and prone to breaking.  If you’re running Linux, chances are you already have Ansible’s dependencies installed, but we’ll cover the most common installation methods.  Primarily, if you have python-pip and python-devel  python-dev on Debian Ubuntu  installed, you can just use pip to install Ansible  this assumes you also have the ‘Development Tools’ package installed, so you have gcc, make, etc. available :  $ sudo pip install ansible   Using pip allows you to upgrade Ansible with pip install --upgrade ansible.  Fedora RHEL CentOS:  The easiest way to install Ansible on a Fedora-like system is to use the official yum package, available via EPEL. Install EPEL’s RPM if it’s not already installed  see the info section below for instructions , then install Ansible:  $ yum -y install ansible   On Fedora RHEL CentOS systems, python-pip and ansible are available via the EPEL repository. If you run the command yum repolist  grep epel  to see if the EPEL repo is already available  and there are no results, you need to install it with the following command:  $ rpm -ivh http:  dl.fedoraproject.org pub epel 6 x86_64 \  epel-release-6-8.noarch.rpm   Debian Ubuntu:   The easiest way to install Ansible on a Debian or Ubuntu system is to use the official apt package.  $ sudo apt-add-repository -y ppa:ansible ansible  $ sudo apt-get update  $ sudo apt-get install -y ansible   If you get an error like “sudo: add-apt-repository: command not found”, you’re probably missing the python-software-properties package. Install it with the command:  $ sudo apt-get install python-software-properties   Once Ansible is installed, make sure it’s working properly by entering ansible --version on the command line. You should see the currently- installed version:  $ ansible --version  ansible 1.9.0   Creating a basic inventory file Ansible uses an inventory file  basically, a list of servers  to communicate with your servers. Like a hosts file  at  etc hosts  that matches IP addresses to domain names, an Ansible inventory file matches servers  IP addresses or domain names  to groups. Inventory files can do a lot more, but for now, we’ll just create a simple file with one server. Create a file at  etc ansible hosts  the default location for Ansible’s inventory file , and add one server to it:  $ sudo mkdir  etc ansible  $ sudo touch  etc ansible hosts   Edit this hosts file with nano, vim, or whatever editor you’d like, but note you’ll need to edit it with sudo as root. Put the following into the file:  1 [example]  2 www.example.com    …where example is the group of servers you’re managing and www.example.com is the domain name  or IP address  of a server in that group. If you’re not using port 22 for SSH on this server, you will need to add it to the address, like www.example.com:2222, since Ansible defaults to port 22 and won’t get this value from your ssh config file.  This first example assumes you have a server set up that you can test with; if you don’t already have a spare server somewhere that you can connect to, you might want to create a small VM using DigitalOcean, Amazon Web Services, Linode, or some other service that bills by the hour. That way you can have a full server environment to work with when learning Ansible—and when you’re finished testing, you can delete the server and you’ll only be billed a few pennies!  Replace the www.example.com in the above example with the name or IP address of your server.  Running your first Ad-Hoc Ansible command Now that you’ve installed Ansible and created an inventory file, it’s time to run a command to see if everything works! Enter the following in the terminal  we’ll do something safe so it doesn’t make any changes on the server :  $ ansible example -m ping -u [username]   …where [username] is the user you use to log into the server. If everything worked, you should see a message that shows www.example.com  success >>, then the result of your ping. If it didn’t work, run the command again with -vvvv on the end to see verbose output. Chances are you don’t have SSH keys configured properly—if you login with ssh username@www.example.com and that works, the above Ansible command should work, too.   Ansible assumes you’re using passwordless  key-based  login for SSH  e.g. you login by entering ssh username@example.com and don’t have to type a password . If you’re still logging into your remote servers with a username and password, or if you need a primer on Linux remote authentication and security best practices, please read Chapter 10 - Server Security and Ansible. If you insist on using passwords, you can add the -- ask-pass  -k  flag to Ansible commands, but this entire book is written assuming passwordless authentication, so you’ll need to keep this in mind every time you run a command or playbook.  Let’s run a more useful command:  $ ansible example -a "free -m" -u [username]   In this example, we can quickly see memory usage  in a human readable format  on all the servers  for now, just one  in the example group. Commands like this can be helpful in quickly finding a server that has a value out of a normal range. I often use commands like free -m  to see memory statistics , df -h  to see disk usage statistics , and the like to make sure none of my servers is behaving erratically. While it’s good to track these details in an external tool like Nagios, Munin, or Cacti, it’s also nice to check these stats on all your servers with one simple command and one terminal window!  Summary That’s it! You’ve just learned about configuration management and Ansible, installed it, told it about your server, and ran a couple commands on that server through Ansible. If you’re not impressed yet, that’s okay—you’ve only seen the tip of the iceberg.   _______________________________________    A doctor can bury his mistakes but an \   architect can only advise his clients   \ to plant vines.  Frank Lloyd Wright       ---------------------------------------          \   ^__^           \   oo \_______               __ \        \ \                  ----w                            Chapter 2 - Local Infrastructure Development: Ansible and Vagrant  Prototyping and testing with local virtual machines Ansible works well with any server to which you can connect—remote or local. For speedier testing and development of Ansible playbooks, and for testing in general, it’s a very good idea to work locally. Local development and testing of infrastructure is both safer and faster than doing it on remote live machines—especially in production environments!  In the past decade, test-driven development  TDD , in one form or another, has become the norm for much of the software industry. Infrastructure development hasn’t been as organized until recently, and best practices dictate that infrastructure  which is becoming more and more important to the software that runs on it  should be thoroughly tested as well.  Changes to software are tested either manually or in some automated fashion; there are now systems that integrate both with Ansible and with other deployment and configuration management tools, to allow some amount of infrastructure testing as well. Even if it’s just testing a configuration change locally before applying it to production, that approach is a thousand times better than what, in the software development world, would be called ‘cowboy coding’—working directly in a production environment, not documenting or encapsulating changes in code, and not having a way to roll back to a previous version.  The past decade has seen the growth of many virtualization tools that allow for flexible and very powerful infrastructure emulation, all from your local workstation! It’s empowering to be able to play around with a config file, or to tweak the order of a server update to perfection, over and over again, with no fear of breaking an important server. If you use a local virtual machine, there’s no downtime for a server rebuild; just re-run the provisioning on a new VM, and you’re back up and running in minutes— with no one the wiser.   Vagrant, a server provisioning tool, and VirtualBox, a local virtualization environment, make a potent combination for testing infrastructure and individual server configurations locally. Both applications are free and open source, and work well on Mac, Linux, or Windows hosts.  We’re going to set up Vagrant and VirtualBox so we can work on using Ansible to provision a new server.  Your first local server: Setting up Vagrant To get started with your first local virtual server, you need to download and install Vagrant and VirtualBox, and set up a simple Vagrantfile, which will describe the virtual server.  1. Download and install Vagrant and VirtualBox  whichever version is  appropriate for your OS : - Download Vagrant - Download VirtualBox  when installing, make sure the command line tools are installed, so Vagrant can work with it   2. Create a new folder somewhere on your hard drive where you will  keep your Vagrantfile and provisioning instructions.  3. Open a Terminal or PowerShell window, then navigate to the folder  you just created.  4. Add a CentOS 7.x 64-bit ‘box’ using the vagrant box add command:  vagrant box add geerlingguy centos7  note: You can find a comprehensive list of different pre-made Linux boxes at HashiCorp’s Atlas site, or check out the ‘official’ Vagrant Ubuntu boxes on the Vagrant wiki.  5. Create a default virtual server configuration using the box you just  downloaded: vagrant init geerlingguy centos7  6. Boot your CentOS server: vagrant up  Vagrant has downloaded a pre-built 64-bit CentOS 7 virtual machine  you can build your own virtual machine ‘boxes’, if you so desire , loaded it into VirtualBox with the configuration defined in the default Vagrantfile  which is now in the folder you created earlier , and booted the virtual machine.  Managing this virtual server is extremely easy: vagrant halt will shut down the VM, vagrant up will bring it back up, and vagrant destroy will   completely delete the machine from VirtualBox. A simple vagrant up again will re-create it from the base box you originally downloaded.  Now that you have a running server, you can use it just like you would any other server, and you can connect via SSH. To connect, enter vagrant ssh from the folder where the Vagrantfile is located. If you want to connect manually, or connect from another application, enter vagrant ssh-config to get the required SSH details.  Using Ansible with Vagrant Vagrant’s ability to bring up preconfigured boxes is convenient on its own, but you could do similar things with the same efficiency using VirtualBox’s  or VMWare’s, or Parallels’  GUI. Vagrant has some other tricks up its sleeve:  Network interface management: You can forward ports to a VM, share the public network connection, or use private networking for inter-VM and host-only communication. Shared folder management: VirtualBox can set up shares between your host machine and VMs using NFS or  much slower  native folder sharing in VirtualBox. Multi-machine management: Vagrant is able to configure and control multiple VMs within one Vagrantfile. This is important because, as stated in the documentation, “Historically, running complex environments was done by flattening them onto a single machine. The problem with that is that it is an inaccurate model of the production setup, which can behave far differently.” Provisioning: When running vagrant up the first time, Vagrant automatically provisions the newly-minted VM using whatever provisioner you have configured in the Vagrantfile. You can also run vagrant provision after the VM has been created to explicitly run the provisioner again.  It’s this last feature that is most important for us. Ansible is one of many provisioners integrated with Vagrant  others include basic shell scripts, Chef, Docker, Puppet, and Salt . When you call vagrant provision  or vagrant up  the first time, Vagrant passes off the VM to Ansible, and tells   Ansible to run a defined Ansible playbook. We’ll get into the details of Ansible playbooks later, but for now, we’re going to edit our Vagrantfile to use Ansible to provision our virtual machine.  Open the Vagrantfile that was created when we used the vagrant init command earlier. Add the following lines just before the final ‘end’  Vagrantfiles use Ruby syntax, in case you’re wondering :  1  Provisioning configuration for Ansible. 2 config.vm.provision "ansible" do ansible 3   ansible.playbook = "playbook.yml" 4    Run commands as root. 5   ansible.sudo = true 6 end  This is a very basic configuration to get you started using Ansible with Vagrant. There are many other Ansible options you can use once we get deeper into using Ansible. For now, we just want to set up a very basic playbook—a simple file you create to tell Ansible how to configure your VM.  Your first Ansible playbook Let’s create the Ansible playbook.yml file now. Create an empty text file in the same folder as your Vagrantfile, and put in the following contents:  1 ---  2 - hosts: all  3   tasks:  4   - name: Ensure NTP  for time synchronization  is installed.  5     yum: name=ntp state=installed  6   - name: Ensure NTP is running.  7     service: name=ntpd state=started enabled=yes   I’ll get into what this playbook is doing in a minute. For now, let’s run the playbook on our VM. Make sure you’re in the same directory as the Vagrantfile and new playbook.yml file, and enter vagrant provision. You should see status messages for each of the ‘tasks’ you defined, and then a recap showing what Ansible did on your VM—something like the following:   1 ---   2 - hosts: all   3   tasks:   PLAY RECAP  ******************************************************************* *  default                    : ok=3    changed=1    unreachable=0     failed=0   Ansible just took the simple playbook you defined, parsed the YAML syntax, and ran a bunch of commands via SSH to configure the server as you specified. Let’s go through the playbook, step by step:  This first line is a marker showing that the rest of the document will be formatted in YAML  read a getting started guide for YAML .  This line tells Ansible to which hosts this playbook applies. all works here, since Vagrant is invisibly using its own Ansible inventory file  instead of the one we created earlier in  etc ansible hosts , which just defines the Vagrant VM.  All the tasks after this line will be run on all hosts  or, in our case, our one VM .  4   - name: Ensure NTP daemon  for time synchronization  is  installed.  5     yum: name=ntp state=installed   This command is the equivalent of running yum install ntp, but is much more intelligent; it will check if ntp is installed, and, if not, install it. This is the equivalent of the following shell script:  if ! rpm -qa  grep -qw ntp; then      yum install ntp  fi   However, the above script is still not quite as robust as Ansible’s yum command. What if ntpdate is installed, but not ntp? This script would require extra tweaking and complexity to match the simple Ansible yum   command, especially after we explore the yum module more intimately  or the apt module, when using Ubuntu and Debian-flavored Linux .  6   - name: Ensure NTP is running.  7     service: name=ntpd state=started enabled=yes   This final task both checks and ensures that the ntpd service is started and running, and sets it to start at system boot. A shell script with the same effect would be:   Start ntpd if it's not already running.  if ps aux  grep -v grep  grep "[n]tpd" >  dev null  then      echo "ntpd is running." >  dev null  else       sbin service ntpd restart >  dev null      echo "Started ntpd."  fi   Make sure ntpd is enabled on system startup.  chkconfig ntpd on   You can see how things start getting complex in the land of shell scripts! And this shell script is still not as robust as what you get with Ansible. To maintain idempotency and handle error conditions, you’ll have to do a lot more extra work with basic shell scripts than you do with Ansible.  We could be even more terse  and really demonstrate Ansible’s powerful simplicity  and not use Ansible’s name module to give human-readable names to each command, resulting in the following playbook:  1 ---  2 - hosts: all  3   tasks:  4   - yum: name=ntp state=installed  5   - service: name=ntpd state=started enabled=yes    Just as with code and configuration files, documentation in Ansible  e.g. using the name function and or adding comments to the YAML for complicated tasks  is not absolutely necessary. However, I’m a firm believer in thorough  but concise  documentation, so I almost always document what my tasks will do by providing a name for each one. This also helps when you’re running the playbooks, so you can see what’s going on in a human-readable format.  Summary Your workstation is on the path to becoming an “infrastructure-in-a-box,” and you can now ensure your infrastructure is as well-tested as the code that runs on top if it. With one small example, you’ve got a glimpse at the simple-yet-powerful Ansible playbook. We’ll dive deeper into Ansible playbooks later, and we’ll also explore Vagrant a little more as we go.   ______________________________________    I have not failed, I've just found   \   10,000 ways that won't work.  Thomas   \ Edison                                   --------------------------------------          \   ^__^           \   oo \_______               __ \        \ \                  ----w                            Chapter 3 - Ad-Hoc Commands  In the previous chapter, we ended our exploration of local infrastructure testing with Vagrant by creating a very simple Ansible playbook. Earlier still, we used a simple ansible ad-hoc command to run a one-off command on a remote server.  We’ll dive deeper into playbooks in coming chapters; for now, we’ll explore how Ansible can help you quickly perform common tasks on, and gather data from, one or many servers with ad-hoc commands.  Conducting an orchestra The number of servers managed by an individual administrator has risen dramatically in the past decade, especially as virtualization and growing cloud application usage has become standard fare. As a result, admins have had to find new ways of managing servers in a streamlined fashion.  On any given day, a systems administrator has many tasks:  Apply patches and updates via yum, apt, and other package managers. Check resource usage  disk space, memory, CPU, swap space, network . Check log files. Manage system users and groups. Manage DNS settings, hosts files, etc. Copy files to and from servers. Deploy applications or run application maintenance. Reboot servers. Manage cron jobs.  Nearly all of these tasks can be  and usually are  at least partially automated —but some often need a human touch, especially when it comes to diagnosing issues in real time. And in today’s complex multi-server environments, logging into servers individually is not a workable solution.   Ansible allows admins to run ad-hoc commands on one or hundreds of machines at the same time, using the ansible command. In Chapter 1, we ran a couple of commands  ping and free -m  on a server that we added to our Ansible inventory file. This chapter will explore ad-hoc commands and multi-server environments in much greater detail. Even if you decide to ignore the rest of Ansible’s powerful features, you will be able to manage your servers much more efficiently after reading this chapter.  Some of the examples in this chapter will display how you can configure certain aspects of a server with ad-hoc commands. It is usually more appropriate to contain all configuration within playbooks and templates, so it’s easier to provision your servers  running the playbook the first time  and then ensure their configuration is idempotent  you can run the playbooks over and over again, and your servers will be in the correct state .  The examples in this chapter are for illustration purposes only, and all might not be applicable to your environment. But even if you only used Ansible for server management and running individual tasks against groups of servers, and didn’t use Ansible’s playbook functionality at all, you’d still have a great orchestration and deployment tool in Ansible!  Build infrastructure with Vagrant for testing For the rest of this chapter, since we want to do a bunch of experimentation without damaging any production servers, we’re going to use Vagrant’s powerful multi-machine capabilities to configure a few servers which we’ll manage with Ansible.  Earlier, we used Vagrant to boot up one virtual machine running CentOS 7. In that example, we used all of Vagrant’s default configuration defined in the Vagrantfile. In this example, we’ll use Vagrant’s powerful multi- machine management features.   Three servers: two application, one database.  We’re going to manage three VMs: two app servers and a database server. Many simple web applications and websites have a similar architecture, and even though this may not reflect the vast realm of infrastructure combinations that exist, it will be enough to highlight Ansible’s server management abilities.  To begin, create a new folder somewhere on your local drive  I like using ~ VMs [dir] , and create a new blank file named Vagrantfile  this is how we describe our virtual machines to Vagrant . Open the file in your favorite editor, and add the following, then save the file:   1  -*- mode: ruby -*-  2  vi: set ft=ruby :  3    4 VAGRANTFILE_API_VERSION = "2"  5    6 Vagrant.configure VAGRANTFILE_API_VERSION  do config  7   config.ssh.insert_key = false  8   config.vm.provider :virtualbox do vb  9     vb.customize ["modifyvm", :id, "--memory", "256"] 10   end 11   12    Application server 1. 13   config.vm.define "app1" do app   14     app.vm.hostname = "orc-app1.dev" 15     app.vm.box = "geerlingguy centos7" 16     app.vm.network :private_network, ip: "192.168.60.4" 17   end 18   19    Application server 2. 20   config.vm.define "app2" do app 21     app.vm.hostname = "orc-app2.dev" 22     app.vm.box = "geerlingguy centos7" 23     app.vm.network :private_network, ip: "192.168.60.5" 24   end 25   26    Database server. 27   config.vm.define "db" do db 28     db.vm.hostname = "orc-db.dev" 29     db.vm.box = "geerlingguy centos7" 30     db.vm.network :private_network, ip: "192.168.60.6" 31   end 32 end  This Vagrantfile defines the three servers we want to manage, and gives each one a unique hostname, machine name  for VirtualBox , and IP address. For simplicity’s sake, all three servers will be running CentOS 7.  Open up a terminal window and change directory to the same folder where the Vagrantfile you just created exists. Enter vagrant up to let Vagrant begin building the three VMs. If you already downloaded the box while building the example from Chapter 2, this process shouldn’t take too long— maybe 5-10 minutes.  While that’s going on, we’ll work on telling Ansible about the servers, so we can start managing them right away.  Inventory file for multiple servers There are many ways you can tell Ansible about the servers you manage, but the most standard, and simplest, is to add them to your system’s main Ansible inventory file, which is located at  etc ansible hosts. If you didn’t create the file in the previous chapter, go ahead and create the file now; make sure your user account has read permissions for the file.  Add the following to the file:    1  Lines beginning with a  are comments, and are only included  for   2  illustration. These comments are overkill for most inventory  files.   3    4  Application servers   5 [app]   6 192.168.60.4   7 192.168.60.5   8    9  Database server  10 [db]  11 192.168.60.6  12   13  Group 'multi' with all servers  14 [multi:children]  15 app  16 db  17   18  Variables that will be applied to all servers  19 [multi:vars]  20 ansible_ssh_user=vagrant  21 ansible_ssh_private_key_file=~ .vagrant.d insecure_private_key   Let’s step through this example, group by group:  1. The first block puts both of our application servers into an ‘app’ group. 2. The second block puts the database server into a ‘db’ group. 3. The third block tells ansible to define a new group ‘multi’, with child  groups, and we add in both the ‘app’ and ‘db’ groups.  4. The fourth block adds variables to the multi group that will be applied  to all servers within multi and all its children.  We’ll dive deeper into variables, group definitions, group hierarchy, and other Inventory file topics later. For now, we just want Ansible to know about our servers, so we can start managing them quickly.  Save the updated inventory file, and then check to see if Vagrant has finished building the three VMs. Once Vagrant has finished, we can start managing the servers with Ansible.  Your first ad-hoc commands   One of the first things you need to do is to check in on your servers. Let’s make sure they’re configured correctly, have the right time and date  we don’t want any time synchronization-related errors in our application! , and have enough free resources to run an application.  Many of the things we’re manually checking here should also be monitored by an automated system on production servers; the best way to prevent disaster is to know when it could be coming, and to fix the problem before it happens. You should use tools like Munin, Nagios, Cacti, Hyperic, etc. to ensure you have a good idea of your servers’ past and present resource usage! If you’re running a website or web application available over the Internet, you should probably also use an external monitoring solution like Pingdom or Server Check.in.  Discover Ansible’s parallel nature First, I want to make sure Vagrant configured the VMs with the right hostnames. Use ansible with the -a argument ‘hostname’ to run hostname against all the servers:  $ ansible multi -a "hostname"   Ansible will run this command against all three of the servers, and return the results  if Ansible can’t reach one a server, it will show an error for that server, but continue running the command on the others .  If Ansible reports No hosts matched or returns some other inventory-related error, try setting the ANSIBLE_HOSTS environment variable explicitly: export ANSIBLE_HOSTS= etc ansible hosts. Generally Ansible will read the file in  etc ansible hosts automatically, but depending on how you installed Ansible, you may need to explicitly set ANSIBLE_HOSTS for the ansible command to work correctly.  You may have noticed that the command was not run on each server in the order you’d expect. Go ahead and run the command a few more times, and see the order:   First run results:                 Second run results:  192.168.60.5  success  rc=0 >>    192.168.60.6  success  rc=0  >>    orc-app2.dev                        orc-db.dev    192.168.60.6  success  rc=0 >>    192.168.60.5  success  rc=0  >>  orc-db.dev                          orc-app2.dev    192.168.60.4  success  rc=0 >>    192.168.60.4  success  rc=0  >>  orc-app1.dev                        orc-app1.dev   By default, Ansible will run your commands in parallel, using multiple process forks, so the command will complete more quickly. If you’re managing a few servers, this may not be much quicker than running the command serially, on one server after the other, but even managing 5-10 servers, you’ll notice a dramatic speedup if you use Ansible’s parallelism  which is enabled by default .  Run the same command again, but this time, add the argument -f 1 to tell Ansible to use only one fork  basically, to perform the command on each server in sequence :  $ ansible multi -a "hostname" -f 1  192.168.60.4  success  rc=0 >>  orc-app1.dev    192.168.60.5  success  rc=0 >>  orc-app2.dev    192.168.60.6  success  rc=0 >>  orc-db.dev   You can run the same command over and over again, and it will always return results in the same order. It’s fairly rare that you will ever need to do this, but it’s much more frequent that you’ll want to increase the value  like -f 10, or -f 25… depending on how much your system and network connection can handle  to speed up the process of running commands on tens or hundreds of servers.   Most people place the target of the action  multi  before the command action itself  “on X servers, run Y command” , but if your brain works in the reverse order  “run Y command on X servers” , you could put the target after the other arguments  ansible -a "hostname" multi —the commands are equivalent.  Learning about your environment Now that we know we can trust Vagrant’s ability to set hostnames correctly, let’s make sure everything else is in order.  First, let’s make sure the servers have disk space available for our application:  $ ansible multi -a "df -h"  192.168.60.6  success  rc=0 >>  Filesystem               Size  Used Avail Use% Mounted on   dev mapper centos-root   19G 1014M   18G   6%    devtmpfs                 111M     0  111M   0%  dev  tmpfs                    120M     0  120M   0%  dev shm  tmpfs                    120M  4.3M  115M   4%  run  tmpfs                    120M     0  120M   0%  sys fs cgroup   dev sda1                497M  124M  374M  25%  boot  none                     233G  217G   17G  94%  vagrant    192.168.60.5  success  rc=0 >>  Filesystem               Size  Used Avail Use% Mounted on   dev mapper centos-root   19G 1014M   18G   6%    devtmpfs                 111M     0  111M   0%  dev  tmpfs                    120M     0  120M   0%  dev shm  tmpfs                    120M  4.3M  115M   4%  run  tmpfs                    120M     0  120M   0%  sys fs cgroup   dev sda1                497M  124M  374M  25%  boot  none                     233G  217G   17G  94%  vagrant    192.168.60.4  success  rc=0 >>  Filesystem               Size  Used Avail Use% Mounted on   dev mapper centos-root   19G 1014M   18G   6%    devtmpfs                 111M     0  111M   0%  dev  tmpfs                    120M     0  120M   0%  dev shm  tmpfs                    120M  4.3M  115M   4%  run  tmpfs                    120M     0  120M   0%  sys fs cgroup   dev sda1                497M  124M  374M  25%  boot  none                     233G  217G   17G  94%  vagrant    It looks like we have plenty of room for now; our application is pretty lightweight.  Second, let’s also make sure there is enough memory on our servers:  $ ansible multi -a "free -m"  192.168.60.4  success  rc=0 >>               total       used       free     shared    buffers      cached  Mem:           238        187         50          4          1        69  - + buffers cache:        116        121  Swap:         1055          0       1055    192.168.60.6  success  rc=0 >>               total       used       free     shared    buffers      cached  Mem:           238        190         47          4          1        72  - + buffers cache:        116        121  Swap:         1055          0       1055    192.168.60.5  success  rc=0 >>               total       used       free     shared    buffers      cached  Mem:           238        186         52          4          1        67  - + buffers cache:        116        121  Swap:         1055          0       1055   Memory is pretty tight, but since we’re running three VMs on our localhost, we need to be a little conservative.  Third, let’s make sure the date and time on each server is in sync:  $ ansible multi -a "date"  192.168.60.5  success  rc=0 >>  Sat Feb  1 20:23:08 UTC 2021    192.168.60.4  success  rc=0 >>  Sat Feb  1 20:23:08 UTC 2021    192.168.60.6  success  rc=0 >>  Sat Feb  1 20:23:08 UTC 2021    Most applications are written with slight tolerances for per-server time jitter, but it’s always a good idea to make sure the times on the different servers are as close as possible, and the simplest way to do that is to use the Network Time Protocol, which is easy enough to configure. We’ll do that next, using Ansible’s modules to make the process painless.  To get an exhaustive list of all the environment details  ‘facts’, in Ansible’s lingo  for a particular server  or for a group of servers , use the command ansible [host-or- group] -m setup. This will provide a list of every minute bit of detail about the server  including file systems, memory, OS, network interfaces… you name it, it’s in the list .  Make changes using Ansible modules We want to install the NTP daemon on the server so it can keep the time in sync. Instead of running the command yum install -y ntp on each of the servers, we’ll use ansible’s yum module to do the same  just like we did in the playbook example earlier, but this time using an ad-hoc command .  $ ansible multi -s -m yum -a "name=ntp state=installed"   You should see three simple ‘success’ messages, reporting no change, since NTP was already installed on the three machines; this confirms everything is in working order.  The -s option  alias for --sudo  tells Ansible to run the command with sudo. This will work fine with our Vagrant VMs, but if you’re running commands against a server where your user account requires a sudo password, you should also pass in -k  alias for --ask-sudo-pass , so you can enter your sudo password when Ansible needs it.  Now we’ll make sure the NTP daemon is started and set to run on boot. We could use two separate commands, service ntpd start and chkconfig ntpd on, but we’ll use Ansible’s service module instead.  $ ansible multi -s -m service -a "name=ntpd state=started  enabled=yes"   All three servers should show a success message like:   "changed": true,  "enabled": true,  "name": "ntpd",  "state": "started"   If you run the exact same command again, everything will be the same, but Ansible will report that nothing has changed, so the "changed" value becomes false.  When you use Ansible’s modules instead of plain shell commands, you can use the powers of abstraction and idempotency offered by Ansible. Even if you’re running shell commands, you could wrap them in Ansible’s shell or command modules  like ansible -m shell -a "date" multi , but for these kind of commands, there’s usually no need to use an Ansible module when running them ad-hoc.  The last thing we should do is check to make sure our servers are synced closely to the official time on the NTP server:  $ ansible multi -s -a "service ntpd stop"  $ ansible multi -s -a "ntpdate -q 0.rhel.pool.ntp.org"  $ ansible multi -s -a "service ntpd start"   For the ntpdate command to work, the ntpd service has to be stopped, so we stop the service, run the command to check our jitter, then start the service again.  In my test, I was within three one-hundredths of a second on all three servers—close enough for my purposes.  Configure groups of servers, or individual servers Now that we’ve been able to get all our servers to a solid baseline  e.g. all of them at least have the correct time , we need to set up the application servers, then the database server.  Since we set up two separate groups in our inventory file, app and db, we can target commands to just the servers in those groups.  Configure the Application servers   Our hypothetical web application uses Django, so we need to make sure Django and its dependencies are installed. Django is not in the official CentOS yum repository, but we can install it using Python’s easy_install  which, conveniently, has an Ansible module .  $ ansible app -s -m yum -a "name=MySQL-python state=present"  $ ansible app -s -m yum -a "name=python-setuptools state=present"  $ ansible app -s -m easy_install -a "name=django"   You could also install django using pip, which can be installed via easy_install  since Ansible’s easy_install module doesn’t allow you to uninstall packages like pip can , but for simplicity’s sake, we’ve installed it with easy_install.  Check to make sure Django is installed and working correctly.  $ ansible app -a "python -c 'import django; print  django.get_version  '"  192.168.60.4  success  rc=0 >>  1.8    192.168.60.5  success  rc=0 >>  1.8   Things look like they’re working correctly on our app servers. We can now move on to our database server.  Almost all of the configuration we’ve done in this chapter would be much better off in an Ansible playbook  which will be explored in greater depth throughout the rest of this book . This chapter demonstrates how easy it is to manage multiple servers—for whatever purpose—using Ansible. Even if you set up and configure servers by hand using shell commands, using Ansible will save you a ton of time and help you do everything in the most secure and efficient manner possible.  Configure the Database servers We configured the application servers using the app group defined in Ansible’s main inventory, and we can configure the database server  currently the only server in the db group  using the similarly-defined db group.   Let’s install MariaDB, start it, and configure the server’s firewall to allow access on MariaDB’s default port, 3306.  $ ansible db -s -m yum -a "name=mariadb-server state=present"  $ ansible db -s -m service -a "name=mariadb state=started  enabled=yes"  $ ansible db -s -a "iptables -F"  $ ansible db -s -a "iptables -A INPUT -s 192.168.60.0 24 -p tcp \  -m tcp --dport 3306 -j ACCEPT"   If you try connecting to the database from the app servers  or your host machine  at this point, you won’t be able to connect, since MariaDB still needs to be set up. Typically, you’d do this by logging into the server and running mysql_secure_installation. Luckily, though, Ansible can control a MariaDB server with its assorted mysql_* modules. For now, we need to allow MySQL access for one user from our app servers. The MySQL modules require the MySQL-python module to be present on the managed server.  Why MariaDB and not MySQL? RHEL 7 and CentOS 7 have MariaDB as the default supported MySQL-compatible database server. Some of the tooling around MariaDB still uses the old ‘MySQL*’ naming syntax, but if you’re used to MySQL, things work similarly with MariaDB.  $ ansible db -s -m yum -a "name=MySQL-python state=present"  $ ansible db -s -m mysql_user -a "name=django host=% password=12345  \  priv=*.*:ALL state=present"   At this point, you should be able to create or deploy a Django application on the app servers, then point it at the database server with the username django and password 12345.   The MySQL configuration used here is for example development purposes only! There are a few other things you should do to secure a production MySQL server, including removing the test database, adding a password for the root user account, restricting the IP addresses allowed to access port 3306 more closely, and some other minor cleanups. Some of these things will be covered later in this book, but, as always, you are responsible for securing your servers—make sure you’re doing it correctly!  Make changes to just one server Congratulations! You now have a small web application environment running Django and MySQL. It’s not much, and there’s not even a load balancer in front of the app servers to spread out the requests; but we’ve configured everything pretty quickly, and without ever having to log into a server. What’s even more impressive is that you could run any of the ansible commands again  besides a couple of the simple shell commands , and they wouldn’t change anything—they would return "changed": false, giving you peace of mind that the original configuration is intact.  Now that your local infrastructure has been running a while, you notice  hypothetically, of course  that the logs indicate one of the two app servers’ time has gotten way out of sync with the others, likely because the NTP daemon has crashed or somehow been stopped. Quickly, you enter the following command to check the status of ntpd:  $ ansible app -s -a "service ntpd status"   Then, you restart the service on the affected app server:  $ ansible app -s -a "service ntpd restart" --limit "192.168.60.4"   In this command, we used the --limit argument to limit the command to a specific host in the specified group. --limit will match either an exact string or a regular expression  prefixed with ~ . The above command could be stated more simply if you want to apply the command to only the .4 server  assuming you know there are no other servers with the an IP address ending in .4 , the following would work exactly the same:   Limit hosts with a simple pattern  asterisk is a wildcard .  $ ansible app -s -a "service ntpd restart" --limit "*.4"       Limit hosts with a regular expression  prefix with a tilde .  $ ansible app -s -a "service ntpd restart" --limit ~".*\.4"   In these examples, we’ve been using IP addresses instead of hostnames, but in many real-world scenarios, you’ll probably be using hostnames like nyc- dev-1.example.com; being able to match on regular expressions can be helpful.  Try to reserve the --limit option for running commands on single servers. If you often find yourself running commands on the same set of servers using --limit, consider instead adding them to a group in your inventory file. That way you can just enter ansible [my-new-group-name] [command], and save yourself a few keystrokes.  Manage users and groups One of the most common uses for Ansible’s ad-hoc commands in my day- to-day usage is user and group management. I don’t know how many times I’ve had to re-read the man pages or do a Google search just to remember which arguments I need to create a user with or without a home folder, add the user to certain groups, etc.  Ansible’s user and group modules make things pretty simple and standard across any Linux flavor.  First, add an admin group on the app servers for the server administrators:  $ ansible app -s -m group -a "name=admin state=present"   The group module is pretty simple; you can remove a group by setting state=absent, set a group id with gid=[gid], and indicate that the group is a system group with system=yes.  Now add the user johndoe to the app servers with the group I just created and give him a home folder in  home johndoe  the default location for most Linux distributions . Simple:  $ ansible app -s -m user -a "name=johndoe group=admin  createhome=yes"    If you want to automatically create an SSH key for the new user  if one doesn’t already exist , you can run the same command with the additional parameter generate_ssh_key=yes. You can also set the UID of the user by passing in uid=[uid], set the user’s shell with shell=[shell], and the password with password=[encrypted-password].  What if you want to delete the account?  $ ansible app -s -m user -a "name=johndoe state=absent remove=yes"   You can do just about anything you could do with useradd, userdel, and usermod using Ansible’s user module, except you can do it more easily. The official documentation of the User module explains all the possibilities in great detail.  Manage files and directories Another common use for ad-hoc commands is remote file management. Ansible makes it easy to copy files from your host to remote servers, create directories, manage file and directory permissions and ownership, and delete files or directories.  Get information about a file If you need to check a file’s permissions, MD5, or owner, use Ansible’s stat module:  $ ansible multi -m stat -a "path= etc environment"   This gives the same information you’d get when running the stat command, but passes back information in JSON, which can be parsed a little more easily  or, later, used in playbooks to conditionally do or not do certain tasks .  Copy a file to the servers You probably use scp and or rsync to copy files and directories to remote servers, and while Ansible has recently gained an rsync module, most file copy operations can be completed with Ansible’s copy module:   $ ansible multi -m copy -a "src= etc hosts dest= tmp hosts"   The src can be a file or a directory. If you include a trailing slash, only the contents of the directory will be copied into the dest. If you omit the trailing slash, the contents and the directory itself will be copied into the dest.  The copy module is perfect for single-file copies, and works very well with small directories. When you want to copy hundreds of files, especially in very deeply-nested directory structures, you should consider either copying then expanding an archive of the files with Ansible’s unarchive module, or using Ansible’s synchronize module.  Retrieve a file from the servers The fetch module works almost exactly the same as the copy module, except in reverse. The major difference is that files will be copied down to the local dest in a directory structure that matches the host from which you copied them. For example, use the following command to grab the hosts file from the servers:  $ ansible multi -s -m fetch -a "src= etc hosts dest= tmp"   Fetch will, by default, put the  etc hosts file from each server into a folder in the destination with the name of the host  in our case, the three IP addresses , then in the location defined by src. So, the db server’s hosts file will end up in  tmp 192.168.60.6 etc hosts.  You can add the parameter flat=yes, and set the dest to dest= tmp   add a trailing slash , to make Ansible fetch the files directly into the  tmp directory. However, filenames must be unique for this to work, so it’s not as useful when copying down files from multiple hosts. Only use flat=yes if you’re copying files from a single host.  Create directories and files You can use the file module to create files and directories  like touch , manage permissions and ownership on files and directories, modify SELinux properties, and create symlinks.   Here’s how to create a directory:  $ ansible multi -m file -a "dest= tmp test mode=644  state=directory"   Here’s how to create a symlink  set state=link :  $ ansible multi -m file -a "src= src symlink dest= dest symlink \  owner=root group=root state=link"   Delete directories and files You can set the state to absent to delete a file or directory.  $ ansible multi -m file -a "dest= tmp test state=absent"   There are many simple ways to manage files remotely using Ansible. We’ve briefly covered the copy and file modules here, but be sure to read the documentation for the other file-management modules like lineinfile, ini_file, and unarchive. This book will cover these additional modules in depth in later chapters  when dealing with playbooks .  Run operations in the background Some operations take quite a while  minutes or even hours . For example, when you run yum update or apt-get update && apt-get dist-upgrade, it could be a few minutes before all the packages on your servers are updated.  In these situations, you can tell Ansible to run the commands asynchronously, and poll the servers to see when the commands finish. When you’re only managing one server, this is not really helpful, but if you have many servers, Ansible can very quickly  especially if you set a higher --forks value  start the command on all your servers, then sit and poll the servers for status until they’re all up to date.  To run a command in the background, you set the following options:  -B  : the maximum amount of time  in seconds  to let the job run.   -P  : the amount of time  in seconds  to wait between polling the servers for an updated job status.  Update servers asynchronously, monitoring progress Let’s run yum -y update on all our servers to get them up to date. If we leave out -P, Ansible defaults to polling every 10 seconds:  $ ansible multi -s -B 3600 -a "yum -y update"  background launch...      192.168.60.6  success >> {      "ansible_job_id": "763350539037",      "results_file": " root .ansible_async 763350539037",      "started": 1  }    ... [other hosts] ...   Wait a little while  or a long while, depending on how old the system image is we used to build our example VMs! , and eventually, you should see something like:    finished on 192.168.60.6 => {      "ansible_job_id": "763350539037",      "changed": true,      "cmd": [          "yum",          "-y",          "update"      ],      "delta": "0:13:13.973892",      "end": "2021-02-09 04:47:58.259723",      "finished": 1,    ... [more info and stdout from job] ...   While a background task is running, you can also check on the status elsewhere using Ansible’s async_status module, as long as you have the ansible_job_id value to pass in as jid:  $ ansible multi -m async_status -a "jid=763350539037"   Fire-and-forget tasks   You may also need to run occasional long-running maintenance scripts, or other tasks that take many minutes or hours to complete, and you’d rather not babysit the task. In these cases, you can set the -B value as high as you want  be generous, so your task will complete before Ansible kills it! , and set -P to ‘0’, so Ansible fires off the command then forgets about it:  $ ansible multi -B 3600 -P 0 -a " path to fire-and-forget- script.sh"  background launch...      192.168.60.5  success >> {      "ansible_job_id": "204960925196",      "results_file": " root .ansible_async 204960925196",      "started": 1  }    ... [other hosts] ...    $   You won’t be able to track progress using the jid anymore, but it’s helpful for ‘fire-and-forget’ tasks.  For tasks you don’t track remotely, it’s usually a good idea to log the progress of the task somewhere, and also send some sort of alert on failure—especially, for example, when running backgrounded tasks that perform backup operations, or when running business-critical database maintenance tasks.  You can also run tasks in Ansible playbooks in the background, asynchronously, by defining an async and poll parameter on the play. We’ll discuss playbook task backgrounding more in later chapters.  Check log files Sometimes, when debugging application errors, or diagnosing outages or other problems, you need to check server log files. Any common log file operation  like using tail, cat, grep, etc.  works through the ansible command, with a few caveats:   1. Operations that continuously monitor a file, like tail -f, won’t work via Ansible, because Ansible only displays output after the operation is complete, and you won’t be able to send the Control-C command to stop following the file. Someday, the async module might have this feature, but for now, it’s not possible.  2. It’s not a good idea to run a command that returns a huge amount of data via stdout via Ansible. If you’re going to cat a file larger than a few KB, you should probably log into the server s  individually.  3. If you redirect and filter output from a command run via Ansible, you  need to use the shell module instead of Ansible’s default command module  add -m shell to your commands .  As a simple example, let’s view the last few lines of the messages log file on each of our servers:  $ ansible multi -s -a "tail  var log messages"   As stated in the caveats, if you want to filter the messages log with something like grep, you can’t use Ansible’s default command module, but instead, shell:  $ ansible multi -s -m shell -a "tail  var log messages  \  grep ansible-command  wc -l"    192.168.60.5  success  rc=0 >>  12    192.168.60.4  success  rc=0 >>  12    192.168.60.6  success  rc=0 >>  14   This command shows how many ansible commands have been run on each server  the numbers you get may be different .  Manage cron jobs Periodic tasks run via cron are managed by a system’s crontab. Normally, to change cron job settings on a server, you would log into the server, use   crontab -e under the account where the cron jobs reside, and type in an entry with the interval and job.  Ansible makes managing cron jobs easy with its cron module. If you want to run a shell script on all the servers every day at 4 a.m., you can add the cron job with:  $ ansible multi -s -m cron -a "name='daily-cron-all-servers' \  hour=4 job=' path to daily-script.sh'"   Ansible will assume * for all values you don’t specify  valid values are day, hour, minute, month, and weekday . You could also specify special time values like reboot, yearly, or monthly using special_time=[value]. You can also set the user the job will run under via user=[user], and you can create a backup of the current crontab by passing backup=yes.  What if we want to remove the cron job? Simple enough, use the same cron command, and pass the name of the cron job you want to delete, and state=absent:  $ ansible multi -s -m cron -a "name='daily-cron-all-servers'  state=absent"   You can also use Ansible to manage custom crontab files; use the same syntax as you used earlier, but specify the location to the cron file with: cron_file=cron_file_name  where cron_file_name is a cron file located in  etc cron.d .  Ansible denotes Ansible-managed crontab entries by adding a comment on the line above the entry like Ansible: daily-cron-all-servers. It’s best to leave things be in the crontab itself, and always manage entries via ad-hoc commands or playbooks using Ansible’s cron module.  Deploy a version-controlled application For simple application deployments, where you may need to update a git checkout, or copy a new bit of code to a group of servers, then run a command to finish the deployment, Ansible’s ad-hoc mode can help. For   more complicated deployments, you can use Ansible playbooks and rolling update features  which will be discussed in later chapters  to ensure successful deployments with zero downtime.  In the example below, I’ll assume we’re running a simple application on one or two servers, in the directory  opt myapp. This directory is a git repository cloned from a central server or a service like GitHub, and application deployments and updates are done by updating the clone, then running a shell script at  opt myapp scripts update.sh.  First, update the git checkout to the application’s new version branch, 1.2.4, on all the app servers:  $ ansible app -s -m git -a "repo=git:  example.com path to repo.git  \  dest= opt myapp update=yes version=1.2.4"   Ansible’s git module lets you specify a branch, tag, or even a specific commit with the version parameter  in this case, we chose to checkout tag 1.2.4, but if you run the command again with a branch name, like prod, Ansible will happily do that instead . To force Ansible to update the checked-out copy, we passed in update=yes. The repo and dest options should be self-explanatory.  Then, run the application’s update.sh shell script:  $ ansible app -s -a " opt myapp update.sh"   Ad-hoc commands are fine for the simple deployments  like our example above , but you should use Ansible’s more powerful and flexible application deployment features described later in this book if you have complex application or infrastructure needs. See especially the ‘Rolling Updates’ section later in this book.  Ansible’s SSH connection history One of Ansible’s greatest features is its ability to function without running any extra applications or daemons on the servers it manages. Instead of using a proprietary protocol to communicate with the servers, Ansible uses   the standard and secure SSH connection that is commonly used for basic administration on almost every Linux server running today.  Since a stable, fast, and secure SSH connection is the heart of Ansible’s communication abilities, Ansible’s implementation of SSH has continually improved throughout the past few years—and is still improving today.  One thing that is universal to all of Ansible’s SSH connection methods is that Ansible uses the connection to transfer one or a few files defining a play or command to the remote server, then runs the play command, then deletes the transferred file s , and reports back the results. This sequence of events may change and become more simple direct with later versions of Ansible  see the notes on Ansible 1.5 below , but a fast, stable, and secure SSH connection is of paramount importance to Ansible.  Paramiko In the beginning, Ansible used paramiko—an open source SSH2 implementation for Python—exclusively. However, as a single library for a single language  Python , development of paramiko doesn’t keep pace with development of OpenSSH  the standard implementation of SSH used almost everywhere , and its performance and security is slightly worse than OpenSSH—at least to this writer’s eyes.  Ansible continues to support the use of paramiko, and even chooses it as the default for systems  like RHEL 5 6  which don’t support ControlPersist— an option present only in OpenSSH 5.6 or newer.  ControlPersist allows SSH connections to persist so frequent commands run over SSH don’t have to go through the initial handshake over and over again until the ControlPersist timeout set in the server’s SSH config is reached.   OpenSSH  default  Beginning in Ansible 1.3, Ansible defaulted to using native OpenSSH connections to connect to servers supporting ControlPersist. Ansible had this ability since version 0.5, but didn’t default to it until 1.3.  Most local SSH configuration parameters  like hosts, key files, etc.  are respected, but if you need to connect via a port other than port 22  the   default SSH port , you need to specify the port in an inventory file  ansible_ssh_port option  or when running ansible commands.  OpenSSH is faster, and a little more reliable, than paramiko, but there are ways to make Ansible faster still.  Accelerated Mode While not too helpful for ad-hoc commands, Ansible’s Accelerated mode can achieve greater performance for playbooks. Instead of connecting repeatedly via SSH, Ansible connects via SSH initially, then uses the AES key used in the initial connection to communicate further commands and transfers via a separate port  5099 by default, but this is configurable .  The only extra package required to use accelerated mode is python- keyczar, and almost everything you can do in normal OpenSSH Paramiko mode works in Accelerated mode, with two exceptions when using sudo:  Your sudoers file needs to have requiretty disabled  comment out the line with it, or set it per user by changing the line to Defaults:username !requiretty . You must disable sudo passwords by setting NOPASSWD in the sudoers file.  Accelerated mode can offer 2-4 times faster performance  especially for things like file transfers  compared to OpenSSH, and you can enable it for a playbook by adding the option accelerate: true to your playbook, like so:  ---  - hosts: all    accelerate: true    ...   It goes without saying, if you use accelerated mode, you need to have the port through which it communicates open in your firewall  port 5099 by default, or whatever port you set with the accelerate_port option after accelerate .   Accelerate mode is a spiritual descendant of the now-deprecated ‘Fireball’ mode, which used a similar method for accelerating Ansible communications, but required ZeroMQ to be installed on the controlled server  which is at odds with Ansible’s simple no-dependency, no-daemon philosophy , and didn’t work with sudo commands at all.  Faster OpenSSH in Ansible 1.5+ Ansible 1.5 and later contains a very nice improvement to Ansible’s default OpenSSH implementation.  Instead of copying files, running them on the remote server, then removing them, the new method of OpenSSH transfer will send and execute commands for most Ansible modules directly over the SSH connection.  This method of connection is only available in Ansible 1.5+, and it can be enabled by adding pipelining=True under the [ssh_connection] section of the Ansible configuration file  ansible.cfg, which will be covered in more detail later .  The pipelining=True configuration option won’t help much unless you have removed or commented the Defaults requiretty option in  etc sudoers. This is commented out in the default configuration for most OSes, but you might want to double-check this setting to make sure you’re getting the fastest connection possible!  If you’re running a recent version of Mac OS X, Ubuntu, Windows with Cygwin, or most other OS for the host from which you run ansible and ansible-playbook, you should be running OpenSSH version 5.6 or later, which works perfectly with the ControlPersist setting used with all of Ansible’s SSH connections settings.  If the host on which Ansible runs has RHEL or CentOS, however, you might need to update your version of OpenSSH so it supports the faster persistent connection method. Any OpenSSH version 5.6 or greater should work. To install a later version, you can either compile from source, or use a different repository  like CentALT and yum update openssh.  Summary   In this chapter, you learned how to build a multi-server infrastructure for testing on your local workstation using Vagrant, and you configured, monitored, and managed the infrastructure without ever logging in to an individual server. You also learned how Ansible connects to remote servers, and how we can use the ansible command to perform tasks on many servers quickly in parallel, or one by one.  By now, you should be getting familiar with the basics of Ansible, and you should be able to start managing your own infrastructure more efficiently.   ______________________________________    It's easier to seek forgiveness than \  \ ask for permission.  Proverb             --------------------------------------          \   ^__^           \   oo \_______               __ \        \ \                  ----w                            Chapter 4 - Ansible Playbooks  Power plays Like many other configuration management solutions, Ansible uses a metaphor to describe its configuration files. They are called ‘playbooks’, and they list a set of tasks  ‘plays’ in Ansible parlance  that will be run against a particular server or set of servers.  Playbooks are written in YAML, a human-readable data format that is very popular for defining configuration in a simple text format. They can be included within other playbooks, and certain metadata and options can cause different plays or playbooks to be run in different scenarios on different servers. Think of a football  American, not the game played with your feet  playbook; there are many different plays that can be run, and the coaches will pick the plays appropriate for a given situation. You will write many different plays, and you can use some on all servers, some on a few types of servers, and some on just one or two servers—as the current situation requires.  Ad-hoc commands alone can make Ansible a powerful tool; playbooks turn Ansible into a top-notch server provisioning and configuration management tool.  What attracts most DevOps personnel to Ansible is the fact that it is easy to convert shell scripts  or one-off shell commands  directly into Ansible plays. Consider the following script, which installs Apache on a RHEL CentOS server:  Shell Script  1  Install Apache. 2 yum install --quiet -y httpd httpd-devel  3  Copy configuration files. 4 cp  path to config httpd.conf  etc httpd conf httpd.conf  5 cp  path to config httpd-vhosts.conf  etc httpd conf httpd-   vhosts.conf  6  Start Apache and configure it to run at boot. 7 service httpd start  8 chkconfig httpd on   To run the shell script  in this case, a file named shell-script.sh with the contents as above , you would call it directly from the command line:    From the same directory in which the shell script resides .  $ . shell-script.sh   Ansible Playbook   1 ---   2 - hosts: all   3   tasks:   4   - name: Install Apache.   5     command: yum install --quiet -y httpd httpd-devel   6   - name: Copy configuration files.   7     command: >   8       cp  path to config httpd.conf  etc httpd conf httpd.conf   9   - command: >  10       cp  path to config httpd-vhosts.conf  etc httpd conf httpd- vhosts.conf  11   - name: Start Apache and configure it to run at boot.  12     command: service httpd start  13   - command: chkconfig httpd on   To run the Ansible Playbook  in this case, a file named playbook.yml with the contents as above , you would call it using the ansible-playbook command:    From the same directory in which the playbook resides .  $ ansible-playbook playbook.yml   Ansible is powerful in that you can quickly transition to using playbooks if you know how to write standard shell commands—the same commands you’ve been using for years—and then rebuild your configuration to be more robust and take advantage of Ansible’s features as you get time.  In the above playbook, we use Ansible’s command module to run standard shell commands. We’re also giving each play a ‘name’, so when we run the playbook, the play has human-readable output on the screen or in the logs.   The command module has some other tricks up its sleeve  which we’ll see later , but for now, you can be assured that shell scripts can be translated directly into Ansible playbooks without much hassle.  The greater-than sign  >  immediately following the command: module directive tells YAML “automatically quote the next set of indented lines as one long string, with each line separated by a space”. It helps improve task readability in some cases. There are different ways of describing configuration using valid YAML syntax, and these methods are discussed in-depth in the YAML Conventions and Best Practices section in Appendix B.  This book uses three different task-formatting techniques: For tasks which require one or two simple parameters, Ansible’s shorthand syntax  e.g. yum: name=apache2 state=installed  is used. For most uses of command or shell, where longer commands are entered, the > technique mentioned above is used. For tasks which require many parameters, YAML object notation is used—placing each key and variable on its own line. This assists with readability and allows for version control systems to easily distinguish changes line-by-line.  The above playbook will perform exactly like the shell script, but we can improve things greatly by using some of Ansible’s built-in modules to handle the heavy lifting:  Revised Ansible Playbook - Now with idempotence!   1 ---   2 - hosts: all   3   sudo: yes   4   tasks:   5   - name: Install Apache.   6     yum: name={{ item }} state=present   7     with_items:   8     - httpd   9     - httpd-devel  10   - name: Copy configuration files.  11     copy:  12       src: "{{ item.src }}"  13       dest: "{{ item.dest }}"  14       owner: root  15       group: root  16       mode: 644  17     with_items:  18     - {  19       src: " path to config httpd.conf",    20       dest: " etc httpd conf httpd.conf"  21     }  22     - {  23       src: " path to config httpd-vhosts.conf",  24       dest: " etc httpd conf httpd-vhosts.conf"  25     }  26   - name: Make sure Apache is started and configure it to run at  boot.  27     service: name=httpd state=started enabled=yes   Now we’re getting somewhere. Let me walk you through this simple playbook:  1. The first line, ---, is how we mark this document as using YAML  syntax  like using   at the top of an HTML document, or <?php at the top of a block of PHP code .  2. The second line, - hosts: all defines the first  and in this case, only  play, and tells Ansible to run the play on all hosts that it knows about.  3. The third line, sudo: yes tells Ansible to run all the commands  through sudo, so the commands will be run as the root user.  4. The fourth line, tasks:, tells Ansible that what follows is a list of tasks  to run as part of this playbook.  5. The first task begins with name: Install Apache.. name is not a  module that does something to your server; rather, it’s a way of giving a human-readable description to the play that follows. Seeing “Install Apache” is more relevant than seeing “yum name=httpd state=installed”… but if you drop the name line completely, that won’t cause any problem.  We use the yum module to install Apache. Instead of the command yum -y install httpd httpd-devel, we can describe to Ansible exactly what we want. Ansible will take the items array we pass in  {{ variable }} references a variable in Ansible’s playbooks . We tell yum to make sure the packages we define are installed with state=present, but we could also use state=latest to ensure the latest version is installed, or state=absent if we want to make sure the package is not installed. Ansible allows simple lists to be passed into tasks using with_items: Define a list of items below, and each line will be   passed into the play, one by one. In this case, each of the items will be substituted for the {{ item }} variable.  6. The second task again starts with a human-readable name  which  could be left out if you’d like .  We use the copy module to copy files from a source  on our local workstation  to a destination  the server being managed . We can also pass in more variables, like file metadata including ownership and permissions  owner, group, and mode . In this case, we are using an array with multiple elements for variable substitution; you use the syntax {var1: value, var2: value} to define each element  it can have as many variables as you want within, or even nested levels of variables! . When you reference the variables in the play, you use a dot to access the variable within the item, so {{ item.var1 }} would access the first variable. In our example, item.src accesses the src in each item.  7. The third task also uses a name to describe it in a human-readable  format.  We use the service module to describe the desired state of a particular service, in this case httpd, Apache’s http daemon. We want it to be running, so we set state=started, and we want it to run at system startup, so we say enabled=yes  the equivalent of running chkconfig httpd on .  The great thing about the way we’ve reformatted this list of commands Ansible can keep track of the state of everything on all our servers. If you run the playbook the first time, it will provision the server by ensuring Apache is installed and running, and your custom configuration is in place.  Even better, the second time you run it, it won’t actually do anything— besides telling you nothing has changed—as long as the server is in the correct state. So, with this one short playbook, we’re able to provision and ensure the proper configuration for an Apache web server. Additionally, you will could run the playbook with the --check option  see the next section below  to ensure that the configuration matches what’s defined in the playbook, without actually running the tasks on the server.   If you ever want to update your configuration, or install another httpd package, you can update the file locally, or add the package to the with_items list, and run the playbook again. Whether you have one or a thousand servers, all of their configurations will be updated to match your playbook—and Ansible will tell you if anything ever changes  you’re not making ad-hoc changes on individual production servers, are you? .  Running Playbooks with ansible-playbook If we run the playbooks in the examples above  which are set to run on all hosts , then the playbook would be run against every host defined in your Ansible inventory file  see Chapter 1’s basic inventory file example .  Limiting playbooks to particular hosts and groups You can limit a playbook to specific groups or individual hosts by changing the hosts: definition. It can be set to a all hosts, a group of hosts defined in your inventory, multiple groups of hosts  e.g. webservers,dbservers , individual hosts  e.g. atl.example.com , or a mixture of hosts. You can even do wildcard matches, like *.example.com, to match all subdomains of a top-level domain.  You can also limit the hosts on which the playbook is run via the ansible- playbook command:  $ ansible-playbook playbook.yml --limit webservers   In this case  assuming your inventory file contains a webservers group , even if the playbook is set to hosts: all, or includes hosts in addition to what’s defined in the webservers group, it will only be run on the hosts defined in webservers.  You could also limit the playbook to one particular host:  $ ansible-playbook playbook.yml --limit xyz.example.com   If you want to see a list of hosts that would be affected by your playbook before you actually run it, use --list-hosts:  $ ansible-playbook playbook.yml --list-hosts    Running this should give output like:  playbook: playbook.yml      play 1  all : host count=4      127.0.0.1      192.168.24.2      foo.example.com      bar.example.com    Where count is the count of servers defined in your inventory, and following is a list of all the hosts defined in your inventory .  Setting user and sudo options with ansible-playbook If no user is defined alongside the hosts in a playbook, Ansible assumes you’ll connect as the user defined in your inventory file for a particular host, and then will fall back to your local user account name. You can explicitly define a remote user to use for remote plays using the --remote- user  -u  option:  $ ansible-playbook playbook.yml --remote-user=johndoe   In some situations, you will need to pass along your sudo password to the remote server to perform commands via sudo. In these situations, you’ll need use the --ask-sudo-pass  -K  option. You can also explicitly force all tasks in a playbook to use sudo with --sudo. Finally, you can define the sudo user for tasks run via sudo  the default is root  with the --sudo-user  -U  option.  For example, the following command will run our example playbook with sudo, performing the tasks as the sudo user janedoe, and Ansible will prompt you for the sudo password:  $ ansible-playbook playbook.yml --sudo --sudo-user=janedoe --ask- sudo-pass   If you’re not using key-based authentication to connect to your servers  read my warning about the security implications of doing so in Chapter 1 , you can use --ask-pass.   Other options for ansible-playbook The ansible-playbook command also allows for some other common options:  --inventory=PATH  -i PATH : Define a custom inventory file  default is the default Ansible inventory file, usually located at  etc ansible hosts . --verbose  -v : Verbose mode  show all output, including output from successful options . You can pass in -vvvv to give every minute detail. --extra-vars=VARS  -e VARS : Define variables to be used in the playbook, in "key=value,key=value" format. --forks=NUM  -f NUM : Number for forks  integer . Set this to a number higher than 5 to increase the number of servers on which Ansible will run tasks concurrently. --connection=TYPE  -c TYPE : The type of connection which will be used  this defaults to ssh; you might sometimes want to use local to run a playbook on your local machine, or on a remote server via cron . --check: Run the playbook in Check Mode  ‘Dry Run’ ; all tasks defined in the playbook will be checked against all hosts, but none will actually be run.  There are some other options and configuration variables that are important to get the most out of ansible-playbook, but this should be enough to get you started running the playbooks in this chapter on your own servers or virtual machines.  The rest of this chapter uses more realistic Ansible playbooks. All the examples in this chapter can be found in Jeff Geerling’s Ansible for DevOps GitHub repository, and you can clone that repository to your computer  or browse the code online  to follow along more easily.  Real-world playbook: CentOS Node.js app server The first example, while being helpful for someone who might want to post a simple static web page to a clunky old Apache server, is not a good representation of a real-world scenario. I’m going to run through some   more complex playbooks that do many different things, most of which are actually being used to manage production infrastructure today.  The first playbook will configure a CentOS server with Node.js, and install and start a simple Node.js application. The server will have a very simple architecture:  Node.js app on CentOS.  To start things off, we need to create a YAML file  playbook.yml in this example  to contain our playbook. Let’s keep things simple:  1 - hosts: all  2   3   tasks:   First, define a set of hosts  all  on which this playbook will be run  see the section above about limiting the playbook to particular groups and hosts , then tell ansible that what follows will be a list of tasks to run on the hosts.  Add extra repositories Adding extra package repositories  yum or apt  is one thing many admins will do before any other work on a server to ensure that certain packages are available, or are at a later version than the ones in the base installation.  In the shell script below, we want to add both the EPEL and Remi repositories, so we can get some packages like Node.js or later versions of   other necessary software  these examples presume you’re running RHEL CentOS 6.x :   1  Import EPEL GPG Key - see: https:  fedoraproject.org keys  2 wget https:  fedoraproject.org static 0608B895.txt \  3   -O  etc pki rpm-gpg RPM-GPG-KEY-EPEL-6   4 rpm --import  etc pki rpm-gpg RPM-GPG-KEY-EPEL-6   5    6  Import Remi GPG key - see: http:  rpms.famillecollet.com RPM-GPG-KEY-remi  7 wget http:  rpms.famillecollet.com RPM-GPG-KEY-remi \  8   -O  etc pki rpm-gpg RPM-GPG-KEY-remi   9 rpm --import  etc pki rpm-gpg RPM-GPG-KEY-remi  10   11  Install EPEL and Remi repos. 12 rpm -Uvh --quiet \ 13   http:  dl.fedoraproject.org pub epel 6 x86_64 epel-release-6- 8.noarch.rpm  14 rpm -Uvh --quiet \ 15   http:  rpms.famillecollet.com enterprise remi-release-6.rpm  16   17  Install Node.js  npm plus all its dependencies . 18 yum --enablerepo=epel install node   This shell script uses the rpm command to import the EPEL and Remi repository GPG keys, then adds the repositories, and finally installs Node.js. It works okay for a simple deployment  or by hand , but it’s silly to run all these commands  some of which could take time or stop your script entirely if your connection is flaky or bad  if the result has already been achieved  namely, two repositories and their GPG keys have been added .  If you wanted to skip a couple steps, you could skip adding the GPG keys, and just run your commands with --nogpgcheck  or, in Ansible, set the disable_gpg_check parameter of the yum module to yes , but it’s a good idea to leave this enabled. GPG stands for GNU Privacy Guard, and it’s a way that developers and package distributors can sign their packages  so you know it’s from the original author, and hasn’t been modified or corrupted . Unless you really know what you’re doing, don’t disable security settings like GPG key checks.  Ansible can make things a little more robust. Even though the following is slightly more verbose, it performs the same actions in a more structured way, which is simpler to understand, and can work with variables other nifty Ansible features we’ll discuss later:    4 - name: Import EPEL and Remi GPG keys.   5   rpm_key: "key={{ item }} state=present"   6   with_items:   7   - "https:  fedoraproject.org static 0608B895.txt"   8   - "http:  rpms.famillecollet.com RPM-GPG-KEY-remi"   9   10 - name: Install EPEL and Remi repos.  11   command: "rpm -Uvh --force {{ item.href }} creates={{  item.creates }}"  12   with_items:  13   - {  14     href:  "http:  download.fedoraproject.org pub epel 6 i386 epel-release-6- 8.no\  15 arch.rpm",  16     creates: " etc yum.repos.d epel.repo"  17   }  18   - {  19     href: "http:  rpms.famillecollet.com enterprise remi-release- 6.rpm",  20     creates: " etc yum.repos.d remi.repo"  21   }  22   23 - name: Disable firewall  since this is a dev environment .  24   service: name=iptables state=stopped enabled=no  25   26 - name: Install Node.js and npm.  27   yum: name=npm state=present enablerepo=epel  28   29 - name: Install forever  to run our Node.js app .  30   npm: name=forever global=yes state=latest   Let’s walk through this playbook step-by-step:  1. rpm_key is a very simple Ansible module that takes and imports an RPM key from a URL or file, or the keyid of an key that is already present, and can ensure the key is either present or absent  the state parameter . We want to import two keys—one for EPEL from the Fedora project, and one for the Remi Repository.  2. Since Ansible doesn’t have a built-in rpm module, we use the rpm  command, but we use Ansible’s command module, which allows us to do two things:  1. Use the creates parameter to tell Ansible when to not run the command  in this case, we tell Ansible what file is present after the rpm command successfully completes .   2. Use an multidimensional array of items  with_items  so we can  define URLs and the resulting file that can be checked with creates.  3. yum installs Node.js  along with all the required packages for npm,  Node’s package manager  if it’s not present, and allows the EPEL repo to be searched via the enablerepo parameter  you could also explicitly disable a repository using disablerepo .  4. Since NPM is now installed, we can use Ansible’s npm module to  install a Node.js utility, forever, so we can easily launch our app and keep it running. Setting global to yes tells NPM to install the forever node module in  usr lib node_modules  so it will be available to all users and Node.js apps on the system.  We’re beginning to have a nice little Node.js app server set up. Let’s set up a little Node.js app that responds to HTTP requests on port 80.  Deploy a Node.js app The next step is to install a simple Node.js app on our server. First, we’ll create a really simple Node.js app by creating a new folder, app, in the same folder as your playbook.yml. Create a new file, app.js, in this folder, with the following contents:   1    Load the express module.  2 var express = require 'express' ,  3 app = express.createServer  ;  4    5    Respond to requests for   with 'Hello World'.  6 app.get ' ', function req, res {  7     res.send 'Hello World!' ;  8 } ;  9   10    Listen on port 80  like a true web server . 11 app.listen 80 ; 12 console.log 'Express server started successfully.' ;  Don’t worry about the syntax or the fact that this is Node.js. We just need a quick example to deploy. This example could’ve been written in Python, Perl, Java, PHP, or another language, but since Node is a very simple language  JavaScript  that runs in a very simple and lightweight   environment, it’s a nice  and easy  language to use when testing things or prodding your server.  Since this little app is dependent on Express  a simple http framework for Node , we also need to tell NPM about this dependency via a package.json file in the same folder as app.js:  1 { 2   "name": "examplenodeapp", 3   "description": "Example Express Node.js app.", 4   "author": "Jeff Geerling  ", 5   "dependencies": { 6     "express": "3.x.x" 7   }, 8   "engine": "node >= 0.10.6" 9 }  Now, add the following to your playbook, to copy the entire app to the server, and then have NPM download the required dependencies  in this case, express :  31 - name: Ensure Node.js app folder exists.  32   file: "path={{ node_apps_location }} state=directory"  33   34 - name: Copy example Node.js app to server.  35   copy: "src=app dest={{ node_apps_location }}"  36   37 - name: Install app dependencies defined in package.json.  38   npm: path={{ node_apps_location }} app   First, we ensure the directory where our app will be installed exists, using the file module. The {{ node_apps_location }} variable used in each command can be defined under a vars section at the top of our playbook, in your inventory, or on the command line when calling ansible-playbook.  Second, we copy the entire app folder up to the server, using Ansible’s copy command, which intelligently distinguishes between a single file or a directory of files, and recurses through the directory, similar to recursive scp or rsync.   Ansible’s copy module works very well for single or small groups of files, and recurses through directories automatically. If you are copying hundreds of files, or deeply-nested directory structures, copy will get bogged down. In these situations, consider using the synchronize module if you need to copy a full directory, or unarchive if you want to copy up an archive and have it expanded in place on the server.  Third, we use npm again, this time, with no extra arguments besides the path to the app. This tells NPM to parse the package.json file and ensure all the dependencies are present.  We’re almost finished! The last step is to start the app.  Launch a Node.js app We’ll now use forever  which we installed earlier  to start the app.  39 - name: Check list of running Node.js apps.  40   command: forever list  41   register: forever_list  42   changed_when: false  43   44 - name: Start example Node.js app.  45   command: "forever start {{ node_apps_location }} app app.js"  46   when: "forever_list.stdout.find '{{  node_apps_location}} app app.js'  == -1"   In the first play, we’re doing two new things:  1. register creates a new variable, forever_list, to be used in the next  play to determine when to run the play. register stashes the output  stdout, stderr  of the defined command in the variable name passed to it.  2. changed_when tells Ansible explicitly when this play results in a  change to the server. In this case, we know the forever list command will never change the server, so we just say false—the server will never be changed when the command is run.  The second play actually starts the app, using forever. We could also start the app by calling node {{ node_apps_location }} app app.js, but we   would not be able to control the process easily, and we would also need to use nohup and & to avoid Ansible hanging on this play.  Forever tracks the Node apps it manages, and we use Forever’s list option to print a list of running apps. The first time we run this playbook, the list will obviously be empty—but on future runs, if the app is running, we don’t want to start another instance of it. To avoid that situation, we tell Ansible when we want to start the app with when. Specifically, we tell Ansible to start the app only when the app’s path in not in the forever list output.  Node.js app server summary At this point, you have a complete playbook that will install a simple Node.js app which responds to HTTP requests on port 80 with “Hello World!”.  To run the playbook on a server  in our case, we could just set up a new VirtualBox VM for testing, either via Vagrant or manually , use the following command  pass in the node_apps_location variable via the command :  $ ansible-playbook playbook.yml \  --extra-vars="node_apps_location= usr local opt node"   Once the playbook has finished configuring the server and deploying your app, visit http:  hostname  in a browser  or use curl or wget to request the site , and you should see the following:  Node.js Application home page.  Simple, but very powerful. We’ve configured an entire Node.js application server In fewer than fifty lines of YAML!  You can find the entire example Node.js app server playbook in this book’s code repository at https:  github.com geerlingguy ansible-for-devops, in the nodejs directory.   Real-world playbook: Ubuntu LAMP server with Drupal At this point, you should be getting comfortable with Ansible playbooks and the YAML syntax used to define them. Up to this point, most examples have assumed you’re working with a CentOS, RHEL, or Fedora server. Ansible plays nicely with other flavors of Linux and BSD-like systems as well. In the following example, we’re going to set up a traditional LAMP  Linux, Apache, MySQL, and PHP  server using Ubuntu 12.04 to run a Drupal website.  Drupal LAMP server.  Include a variables file, and discover pre_tasks and handlers For this playbook, we’re going to start organizing our playbook a little more efficiently. Instead of defining any requiring variables be passed in via the command line, let’s begin the playbook by telling Ansible our variables are stored in a separate vars.yml file:  1 - hosts: all  2   3   vars_files:  4   - vars.yml   Using one or more variable files, rather than defining everything inline, cleans up your main playbook file, and lets you organize all your configurable variables in one place. For now, we don’t have any variables to   add; we’ll define the contents of vars.yml later. For now, create the empty file, and continue on to the next section of the playbook, pre_tasks:  5   pre_tasks:  6   - name: Update apt cache if needed.  7     apt: update_cache=yes cache_valid_time=3600   Ansible lets you run tasks before or after the main set of tasks using pre_tasks and post_tasks. In this case, we need to ensure that our apt cache is updated before we run the rest of the playbook, so we have the latest package versions on our server. We use Ansible’s apt module and tell it to update the cache if it’s been more than 3600 seconds  1 hour  since the last update.  With that out of the way, we’ll add another new section to our playbook, handlers:   8   handlers:   9   - name: restart apache  10     service: name=apache2 state=restarted   handlers are special kinds of tasks that you can run at the end of a group of tasks by adding the notify option to any of the tasks in that group. The handler will only be called if one of the tasks notifying the handler makes a change to the server  and doesn’t fail , and it will only be notified at the end of the group of tasks.  To call this handler, add the option notify: restart apache after defining the rest of a play. We’ve defined this handler so we can restart the apache2 service after a configuration change, which will be explained below.  Just like variables, handlers and tasks may be placed in separate files and included in your playbook to keep things tidy  we’ll discuss this in chapter 6 . For simplicity’s sake, though, the examples in this chapter are shown as in a single playbook file. We’ll discuss different playbook organization methods later.   By default, Ansible will stop all playbook execution when a task fails, and won’t even notify any handlers that may need to be triggered. In some cases, this can lead to unintended side effects. If you want to make sure handlers always run after a task uses notify to call the handler, even in case of playbook failure, add --force-handlers to your ansible-playbook command.  Basic LAMP server setup The first step towards building an application server that depends on the LAMP stack is to build the actual LAMP part of it. This is the simplest process, but still requires a little extra work for our particular server. We want to install Apache, MySQL and PHP, but we’ll also need a couple other dependencies, and we want a particular version of PHP  5.5 , which is only available in an extra apt repository.  11   tasks:  12   - name: Get software for apt repository management.  13     apt: name={{ item }} state=installed  14     with_items:  15       - python-apt  16       - python-pycurl  17     18   - name: Add ondrej repository for later versions of PHP.  19     apt_repository: repo='ppa:ondrej php5' update_cache=yes  20     21   - name: "Install Apache, MySQL, PHP, and other dependencies."  22     apt: name={{ item }} state=installed  23     with_items:  24       - git  25       - curl  26       - sendmail  27       - apache2  28       - php5  29       - php5-common  30       - php5-mysql  31       - php5-cli  32       - php5-curl  33       - php5-gd  34       - php5-dev  35       - php5-mcrypt  36       - php-apc  37       - php-pear  38       - python-mysqldb  39       - mysql-server  40       41   - name: Disable the firewall  since this is for local dev  only .  42     service: name=ufw state=stopped  43     44   - name: "Start Apache, MySQL, and PHP."  45     service: "name={{ item }} state=started enabled=yes"  46     with_items:  47       - apache2  48       - mysql   In this playbook, I’ve decided to add a simple prefix to each named play, so I can more easily follow the playbook’s progress when it’s running. I’ve begun with the common LAMP setup:  1. Install a couple helper libraries which allow Python to manage apt  more precisely  python-apt and python-pycurl are required for the apt_repository module to do its work .  2. Since the default apt repositories for Ubuntu 12.04 don’t include PHP  5.4.x  or any later versions , install ondrej’s PHP5-oldstable repository, containing PHP 5.4.25  at the time of this writing  and other associated PHP packages.  3. Install all the required packages for our LAMP server  including all the  php5 extensions we need to run Drupal .  4. Disable the firewall entirely, for testing purposes. If on a production  server or any server exposed to the Internet, you should instead have a restrictive firewall only allowing access on ports 22, 80, 443, and other necessary ports.  5. Start up all the required services, and make sure they’re enabled to  start on system boot.  Configure Apache The next step is configuring Apache so it will work correctly with Drupal. Out of the box, Apache doesn’t have mod_rewrite enabled on Ubuntu 12.04. To remedy that situation, you can use the command sudo a2enmod rewrite, but Ansible has a handy apache2_module module that will simplify the task.  Additionally, we need to add a VirtualHost entry to tell Apache where the site’s document root is, and any other options for the site.   50   - name: Enable Apache rewrite module  required for Drupal .  51     apache2_module: name=rewrite state=present  52     notify: restart apache  53     54   - name: Add Apache virtualhost for Drupal 8 development.  55     template:  56       src: "templates drupal.dev.conf.j2"  57       dest: " etc apache2 sites-available {{ domain }}.dev.conf"  58       owner: root  59       group: root  60       mode: 0644  61     notify: restart apache  62     63   - name: Symlink Drupal virtualhost to sites-enabled.  64     file:  65       src: " etc apache2 sites-available {{ domain }}.dev.conf"  66       dest: " etc apache2 sites-enabled {{ domain }}.dev.conf"  67       state: link  68     notify: restart apache  69     70   - name: Remove default virtualhost file.  71     file:  72       path: " etc apache2 sites-enabled 000-default"  73       state: absent  74     notify: restart apache   The first command enables all the required Apache modules by symlinking them from  etc apache2 mods-available to  etc apache2 mods- enabled.  The second command copies a Jinja2 template we define inside the templates folder to Apache’s sites-available folder, with the correct owner and permissions. Additionally, we notify the restart apache handler, because copying in a new VirtualHost means Apache needs to be restarted to pick up the change.  Let’s look at our Jinja2 template  denoted by the extra .j2 on the end of the filename , drupal.dev.conf.j2:   1    2     ServerAdmin webmaster@localhost  3     ServerName {{ domain }}.dev  4     ServerAlias www.{{ domain }}.dev  5     DocumentRoot {{ drupal_core_path }}  6        7         Options FollowSymLinks Indexes    8         AllowOverride All  9       10    This is a fairly standard Apache VirtualHost definition, but we have a few Jinja2 template variables mixed in. The syntax for printing a variable in a Jinja2 template is the same syntax we use in our Ansible playbooks—two brackets around the variable’s name  like so: {{ variable }} .  There are three variables we will need  drupal_core_version, drupal_core_path, and domain , so we can add them to the empty vars.yml file we created earlier:  1 ---  2  The core version you want to use  e.g. 6.x, 7.x, 8.0.x .  3 drupal_core_version: "8.0.x"  4   5  The path where Drupal will be downloaded and installed.  6 drupal_core_path: " var www drupal-{{ drupal_core_version }}-dev"  7   8  The resulting domain will be [domain].dev  with .dev appended .  9 domain: "drupaltest"   Now, when Ansible reaches the play that copies this template into place, the Jinja2 template will have the variable names replaced with the values 8.0.x and drupaltest  or whatever values you’d like! .  The last two tasks  lines 12-19  enable the VirtualHost we just added, and remove the default VirtualHost definition, which we no longer need.  At this point, you could start the server, but Apache will likely throw an error since the VirtualHost you’ve defined doesn’t yet exist  there’s no directory at {{ drupal_core_path }} yet! . This is why using notify is important—instead of adding a play after these three steps to restart Apache, which will fail the first time you run the playbook, notify will wait until after we’ve finished all the other steps in our main group of tasks  giving us time to finish setting up the server , then restart Apache.  Configure PHP with lineinfile   We briefly mentioned lineinfile earlier in the book, when discussing file management and ad-hoc task execution. Modifying PHP’s configuration is a perfect way to demonstrate lineinfile’s simplicity and usefulness:  74   - name: Enable upload progress via APC.  75     lineinfile:  76       dest: " etc php5 apache2 conf.d 20-apcu.ini"  77       regexp: "^apc\.rfc1867"  78       line: "apc.rfc1867 = 1"  79       state: present  80     notify: restart apache   Ansible’s lineinfile module does a simple task: ensures that a particular line of text exists  or doesn’t exist  in a file.  In this example, we need to enable APC’s rfc1867 option so Drupal can use APC’s file upload progress tracking  there are better ways of doing this, but for our simple server, this will suffice .  First, we tell lineinfile the location of the file, in the dest parameter. Then, we give a regular expression  Python-style  to define what the line looks like  in this case, the line starts with the exact phrase “apc.rfc1867”— we had to escape the period since it is a special character in regular expressions . Next, we tell lineinfile exactly how the resulting line should look. Finally, we explicitly state that we want this line to be present  with the state parameter .  Ansible will take the regular expression, and see if there’s a matching line. If there is, Ansible will make sure the line matches the line parameter. If not, Ansible will add the line as defined in the line parameter. Ansible will only report a change if it had to add or change the line to match line.  Configure MySQL The next step is to remove MySQL’s default test database, and create a database  named for the domain we specified earlier  for our Drupal installation to use.  80   - name: Remove the MySQL test database.  81     mysql_db: db=test state=absent  82       83   - name: Create a database for Drupal.  84     mysql_db: "db={{ domain }} state=present"   MySQL installs a database named test by default, and it is recommended that you remove the database as part of MySQL’s included mysql_secure_installation tool. The first step in configuring MySQL is removing this database. Next, we create a database named {{ domain }}— the database is named the same as the domain we’re using for the Drupal site.  Ansible works with many databases out of the box  MongoDB, MySQL, PostgreSQL, Redis and Riak as of this writing . In MySQL’s case, Ansible uses the MySQLdb Python package  python-mysqldb  to manage a connection to the database server, and assumes the default root account credentials  ‘root’ as the username with no password . Obviously, leaving this default would be a bad idea! On a production server, one of the first steps should be to change the root account password, limit the root account to localhost, and delete any nonessential database users.  If you use different credentials, you can add a .my.cnf file to your remote user’s home directory containing the database credentials so Ansible can connect to the MySQL database without leaving passwords in your Ansible playbooks or variable files. Otherwise, you can prompt the user running the Ansible playbook for a MySQL username and password. This option, using prompts, will be discussed later in the book.  Install Composer and Drush Drupal has a command-line companion in the form of Drush. Drush is developed independently of Drupal, and provides a full suite of CLI commands to manage Drupal. Drush, like most modern PHP tools, integrates with external dependencies defined in a composer.json file which describes the dependencies to Composer.  We could just download Drupal and perform some setup in the browser by hand at this point, but the goal of this playbook is to have a fully-automated and idempotent Drupal installation. So, we need to install Composer, then Drush:  85   - name: Install Composer into the current directory.  86     shell: >  87       curl -sS https:  getcomposer.org installer  php    88       creates= usr local bin composer  89     90   - name: Move Composer into globally-accessible location.  91     shell: >  92       mv composer.phar  usr local bin composer  93       creates= usr local bin composer   The first command runs Composer’s php-based installer, which generates a ‘composer.phar’ PHP application archive. This archive is then copied  using the mv shell command  to the location  usr local bin composer so we can use the simple composer command to install all of Drush’s dependencies. Both commands are set to only run if the  usr local bin composer file doesn’t already exist  using the creates parameter .  Why use shell instead of command? Ansible’s command module is the preferred option for running commands on a host  when an Ansible module won’t suffice , and it works in most scenarios. However, command doesn’t run the command via the remote shell  bin sh, so options like  , , and &, and local environment variables like $HOME won’t work. shell allows you to pipe command output to other commands, access the local environment, etc.  There are two other modules which assist in executing shell commands remotely: script executes shell scripts  though it’s almost always a better idea to convert shell scripts into idempotent Ansible playbooks! , and raw executes raw commands via SSH  it should only be used in circumstances where you can’t use one of the other options .  It’s best to use an Ansible module for every task. If you have to resort to a regular command-line command, try the the command module first. If you require the options mentioned above, use shell. Use of script or raw should be exceedingly rare, and won’t be covered in this book.  Now, we’ll install Drush using the latest version from GitHub:   94   - name: Check out drush master branch.   95     git:   96       repo: https:  github.com drush-ops drush.git   97       dest:  opt drush   98      99   - name: Install Drush dependencies with Composer.  100     shell: >  101        usr local bin composer install  102       chdir= opt drush  103       creates= opt drush vendor autoload.php    104     105   - name: Create drush bin symlink.  106     file:  107       src:  opt drush drush  108       dest:  usr local bin drush  109       state: link   Earlier in the book, we cloned a git repository using an ad-hoc command. In this case, we’re defining a play that uses the git module to clone Drush from its repository URL on GitHub. Since we want the master branch, pass in the repo  repository URL  and dest  destination path  parameters.  After drush is downloaded to  opt drush, we use Composer to install all the required dependencies. In this case, we want Ansible to run composer install in the directory  opt drush  this is so Composer can find drush’s composer.json file automatically , so we pass along the parameter chdir= opt drush. Once Composer is finished, the file  opt drush vendor autoload.php will be created, so we use the creates parameter to tell Ansible to skip this step if the file already exists  for idempotency .  Finally, we create a symlink from  usr local bin drush to the executable at  opt drush drush, so we can call the drush command anywhere on the system.  Install Drupal with Git and Drush We’ll use git again to clone Drupal to the apache document root we defined earlier in our virtual host configuration, then we’ll run Drupal’s installation via drush, and fix a couple other file permissions issues so Drupal loads correctly within our VM.  108   - name: Check out Drupal Core to the Apache docroot.  109     git:  110       repo: http:  git.drupal.org project drupal.git  111       version: "{{ drupal_core_version }}"  112       dest: "{{ drupal_core_path }}"  113     114   - name: Install Drupal.  115     command: >  116       drush si -y --site-name="{{ drupal_site_name }}" -- account-name=admin  117       --account-pass=admin --db-url=mysql:  root@localhost {{    domain }}  118       chdir={{ drupal_core_path }}  119       creates={{ drupal_core_path }} sites default settings.php  120     notify: restart apache  121     122    SEE: https:  drupal.org node 2121849comment-8413637  123   - name: Set permissions properly on settings.php.  124     file:  125       path: "{{ drupal_core_path }} sites default settings.php"  126       mode: 0744  127     128   - name: Set permissions on files directory.  129     file:  130       path: "{{ drupal_core_path }} sites default files"  131       mode: 0777  132       state: directory  133       recurse: yes   First, we cloned Drupal’s git repository, using the version defined in our vars.yml file as drupal_core_version. The git module’s version parameter defines the branch  master, 8.0.x, etc. , tag  1.0.1, 7.24, etc. , or individual commit hash  50a1877, etc.  to clone.  Next, we used Drush’s si command  short for site-install  to run Drupal’s installation  which configures the database, runs some maintenance, and sets some default configuration settings for the site . We passed in a few variables, like the drupal_core_version and domain; we also added a drupal_site_name, so add that variable to your vars.yml file:  10  Your Drupal site name.  11 drupal_site_name: "D8 Test"   Also, Drupal’s installation process results in the creation of a ‘settings.php’ file, so we use the location of that file with the creates parameter to let Ansible know if the site’s already installed  so we don’t accidentally try installing it again! . Once the site is installed, we also restart Apache for good measure  using notify again, like we did when updating Apache’s configuration .  The final two tasks set permissions on Drupal’s settings.php and files folder to 744 and 777, respectively.  Drupal LAMP server summary   At this point, if you access the server at http:  drupaltest.dev   assuming you’ve pointed drupaltest.dev to your server or VM’s IP address , you’ll see Drupal’s default home page, and you could login with ‘admin’ ’admin’.  Obviously, you’d set a secure password on a production server! .  A similar server configuration, running Apache, MySQL, and PHP, can be used to run many popular web frameworks and CMSes besides Drupal, including Symfony, Wordpress, Joomla, Laravel, etc.  You can find the entire example Drupal LAMP server playbook in this book’s code repository at https:  github.com geerlingguy ansible-for-devops, in the drupal directory.  Real-world playbook: Ubuntu Apache Tomcat server with Solr Apache Solr is a fast and scalable search server optimized for full-text search, word highlighting, faceted search, fast indexing, and more. It’s a very popular search server, and it’s pretty easy to install and configure using Ansible. In the following example, we’re going to set up Apache Solr using Ubuntu 12.04 and Apache Tomcat.  Include a variables file, and discover pre_tasks and handlers  Apache Solr Server.   Just like the previous LAMP server example, we’ll begin this playbook by telling Ansible our variables will be in a separate vars.yml file:  1 - hosts: all  2   3   vars_files:  4   - vars.yml   1 download_dir:  tmp  2 solr_dir:  opt solr   Let’s quickly create the vars.yml file, while we’re thinking about it. Create the file in the same folder as your Solr playbook, and add the following contents:  These two variables define two paths we’ll use while downloading and installing Apache Solr.  Back in our playbook, after the vars_files, we also need to make sure the apt cache is up to date, using pre_tasks like the previous example:  5   pre_tasks:  6   - name: Update apt cache if needed.  7     apt: update_cache=yes cache_valid_time=3600   Like the Drupal playbook, we again use handlers to define certain tasks that are notified by tasks in the tasks section. This time, we just need a handler to restart tomcat7, the Java servlet container that powers Apache Solr:   8   handlers:   9   - name: restart tomcat  10     service: name=tomcat7 state=restarted   We can call this handler with the option notify: restart tomcat in any play in our playbook.  Install Apache Tomcat 7 It’s easy enough to install Tomcat 7 on an Ubuntu Precise server; there are packages in the default apt repositories, so we just need to make sure they’re installed, and that the tomcat7 service is enabled and started:   11   tasks:  12   - name: Install Tomcat 7.  13     apt: "name={{ item }} state=installed"  14     with_items:  15       - tomcat7  16       - tomcat7-admin  17     18   - name: Ensure Tomcat 7 is started and enabled on boot.  19     service: name=tomcat7 state=started enabled=yes   That was easy enough! We used the apt module to install two packages, tomcat7 and tomcat7-admin  so we can log into Tomcat’s administrative backend , then started tomcat7 and set it to start when the system boots.  Install Apache Solr Ubuntu 12.04 includes a package for Apache Solr, but it installs a very old version, so we’ll install the latest version of Solr from source. The first step is downloading the source:  20 - name: Download Solr.  21   get_url:  22     url: http:  apache.osuosl.org lucene solr 4.9.1 solr- 4.9.1.tgz  23     dest: "{{ download_dir }} solr-4.9.1.tgz"  24     sha256sum:  4a546369a31d34b15bc4b99188984716bf4c0c158c0e337f3c1f98088aec70ee   We’re installing Apache Solr 4.9.1, a recent stable version. When downloading files from remote servers, the get_url module provides more flexibility and convenience than raw wget or curl commands.  You have to pass get_url a url  the source of the file to be downloaded , and a dest  the location where the file will be downloaded . If you pass a directory to the dest parameter, Ansible will place the file inside, but will always re-download the file on subsequent runs of the playbook  and overwrite the existing download if it has changed . To avoid this extra overhead, we give the full path to the downloaded file.  We also use sha256sum, an optional parameter, for peace of mind; if you are downloading a file or archive that’s critical to the functionality and security of your application, it’s a good idea to check the file to make sure it is   exactly what you’re expecting. sha256sum compares a hash of the data in the downloaded file to a 256-bit hash that you specify  use shasum -a 256  path to file to get the sha256sum of a file . If the checksum doesn’t match the supplied hash, Ansible will fail and discard the freshly- downloaded  and invalid  file.  25 - name: Expand Solr.  26   command: >  27     tar -C  tmp -xvzf {{ download_dir }} solr-4.9.1.tgz  28     creates={{ download_dir }} solr-4.9.1 dist solr-4.9.1.war  29   30 - name: Copy Solr into place.  31   command: >  32     cp -r {{ download_dir }} solr-4.9.1 {{ solr_dir }}  33     creates={{ solr_dir }} dist solr-4.9.1.war   We need to expand the Apache Solr archive, then copy it into place. For both of these steps, use the built-in tar and cp utilities  with the appropriate options  to do the work. Setting creates tells Ansible to skip these steps in subsequent runs, since the Solr war file will already be in place.  34  Use shell so commands are passed in correctly.  35 - name: Copy Solr components into place.  36   shell: >  37     cp -r {{ item.src }} {{ item.dest }}  38     creates={{ item.creates }}  39   with_items:  40      Solr example configuration and war file.  41     - {  42       src: "{{ solr_dir }} example webapps solr.war",  43       dest: "{{ solr_dir }} solr.war",  44       creates: "{{ solr_dir }} solr.war"  45     }  46     - {  47       src: "{{ solr_dir }} example solr *",  48       dest: "{{ solr_dir }} ",  49       creates: "{{ solr_dir }} solr.xml"  50     }  51      Solr log4j logging configuration.  52     - {  53       src: "{{ solr_dir }} example lib ext *",  54       dest: " var lib tomcat7 shared ",  55       creates: " var lib tomcat7 shared log4j-1.2.16.jar"  56     }  57     - {  58       src: "{{ solr_dir }} example resources log4j.properties",    59       dest: " var lib tomcat7 shared classes",  60       creates: " var lib tomcat7 shared classes log4j.properties"  61     }  62   notify: restart tomcat   The next task copies into place certain directories and files required to run Apache Solr.  Nothing too special here, but this example illustrates how you can use comments within with_items lists to help clarify the items in the list. We could’ve added each command as its own task, but doing it this way reduces the total number of Ansible tasks and allows us to move the with_items list to an external variable if desired.  63 - name: Ensure solr example directory is absent.  64   file:  65     path: "{{ solr_dir }} example"  66     state: absent  67   68 - name: Set up solr data directory.  69   file:  70     path: "{{ solr_dir }} data"  71     state: directory  72     owner: tomcat7  73     group: tomcat7   The latest version of Apache Solr searches through all the directories inside {{ solr_dir }} recursively, loading any potential search configuration it finds. Since we copied over one of the examples to use as the server’s default search core, Solr would see it as a duplicate of one of the examples and crash. So, we can use the file module with a path to the example directory to make sure the directory is gone  state=absent .  After removing the example directory  and in future runs, ensuring it’s still gone , we set up the data directory where Solr will store index data, ensuring it exists as a directory, and is owned by the tomcat7 user and group.  73 - name: Configure solrconfig.xml for new data directory.  74   lineinfile:  75     dest: "{{ solr_dir }} collection1 conf solrconfig.xml"  76     regexp: "^.*<dataDir.+$"  77     line: " ${solr.data.dir:{{ solr_dir }} data}    "  78     state: present   As we found earlier, lineinfile is a helpful module for ensuring consistent configuration file settings with idempotence. In this case, we need to make sure the   line in our default search core’s configuration file is set to a specific value.  79 - name: Set permissions for solr home.  80   file:  81     path: "{{ solr_dir }}"  82     recurse: yes  83     owner: tomcat7  84     group: tomcat7   To set ownership options on the entire contents of the {{ solr_dir }} correctly, we use the file module with the recurse parameter set to yes. This is equivalent to the shell command chown -R tomcat7:tomcat7 {{ solr_dir }}.  84 - name: Add Catalina configuration for solr.  85   template:  86     src: templates solr.xml.j2  87     dest:  etc tomcat7 Catalina localhost solr.xml  88     owner: root  89     group: tomcat7  90     mode: 0644  91   notify: restart tomcat   The final task copies a template file  solr.xml.j2  to the remote host, substituting variables via Jinja2 syntax, and sets the file’s ownership and permissions as needed for Tomcat.  Before the task can run, the local template file will need to be created. Create a ‘templates’ folder in the same directory as your Apache Solr playbook, and create a new file named solr.xml.j2 inside, with the following contents:  1   2   3   <Environment name="solr home" type="java.lang.String" \ 4   value="{{ solr_dir }}" override="true" > 5     You can run the playbook with $ ansible-playbook [playbook- name.yml], and after a few minutes  depending on your server’s Internet connection speed , you should be able to access the Solr admin interface at http:  example.com:8080 solr  where ‘example.com’ is your server’s hostname or IP address .  Apache Solr server summary The configuration we used when deploying Apache Solr allows for a multicore setup, so you could add more ‘search cores’ via the admin interface  as long as the directories and core schema configuration is in place in the filesystem , and have multiple indexes for multiple websites and applications.  A playbook similar to the one above is used as part of the infrastructure for Hosted Apache Solr, a service run by the author which runs a hosted version of Apache Solr particularly for Drupal search indexes.  You can find the entire example Apache Solr server playbook in this book’s code repository at https:  github.com geerlingguy ansible-for-devops, in the solr directory.  Summary At this point, you should be getting comfortable with Ansible’s modus operandi. Playbooks are the heart of Ansible’s configuration management and provisioning functionality, and the same modules and similar syntax can be used with ad-hoc commands for deployments and general server management.  Now that you’re familiar with playbooks, we’ll explore more advanced concepts in building playbooks, like organization of tasks, conditionals, variables, and more. Later, we’ll explore how we can use playbooks within roles to make them infinitely more flexible, and save time setting up and configuring your infrastructure.   _________________________________________    If everything is under control, you are \  \ going too slow.  Mario Andretti               -----------------------------------------          \   ^__^           \   oo \_______               __ \        \ \                  ----w                            Chapter 5 - Ansible Playbooks - Beyond the Basics  The playbooks and simple playbook organization we used in the previous chapter cover many common use cases, but when discussing the breadth of system administration needs, there are thousands more little features of Ansible that you need to know.  We’ll cover things like how to run plays with more granularity, how to organize your tasks and playbooks for simplicity and usability, and other advanced playbook topics that will help you manage your infrastructure with even more confidence.  Handlers In chapter 4, the Ubuntu LAMP server example used a simple handler to restart Apache, and certain tasks that affected Apache’s configuration would notify the handler with the option notify: restart apache:  handlers:    - name: restart apache      service: name=apache2 state=restarted    tasks:    - name: Enable Apache rewrite module.      apache2_module: name=rewrite state=present      notify: restart apache   In some circumstances, you may want to notify more than one handler, or even have handlers notify other handlers. Both are easy to do with Ansible. To notify multiple handlers from one task, use a list for the notify option:  - name: Rebuild application configuration.    command:  opt app rebuild.sh    notify:      - restart apache      - restart memcached    To have one handler notify another, just add a notify option onto the handler—handlers are basically glorified tasks that can be called by the notify option, but since they act as tasks themselves, they can chain themselves to other handlers as well:  handlers:    - name: restart apache      service: name=apache2 state=restarted      notify: restart memcached      - name: restart memcached      service: name=memcached state=restarted   There are a few other considerations when dealing with handlers:  Handlers will only be run if a task notifies the handler; if a task that would’ve notified the handlers is skipped due to a when condition or something of the like, the handler will not be run. Handlers will run once, and only once, at the end of a play. If you absolutely need to override this behavior and run handlers in the middle of a playbook, you can use the meta module to do so  e.g. - meta: flush_handlers . If the play fails on a particular host  or all hosts  before handlers are notified, the handlers will never be run. If it’s desirable to always run handlers, even after the playbook has failed, you can use the meta module as described above as a separate task in the playbook, or you use the command line flag --force-handlers when running your playbook. Handlers won’t run on any hosts that became unreachable during the playbook’s run.  Environment variables Ansible allows you to work with environment variables in a variety of ways. First of all, if you need to set some environment variables for your remote user account, you can do that by adding lines to the remote user’s .bash_profile, like so:  - name: Add an environment variable to the remote user's shell.    lineinfile: dest=~ .bash_profile regexp=^ENV_VAR=  line=ENV_VAR=value    All subsequent tasks would then have access to this environment variable  remember, of course, only the shell module will understand shell commands that use environment variables! . To use an environment variable in further tasks, it’s recommended you use a task’s register option to store the environment variable in a variable Ansible can use later, for example:  1 - name: Add an environment variable to the remote user's shell.  2   lineinfile: dest=~ .bash_profile regexp=^ENV_VAR=  line=ENV_VAR=value  3   4 - name: Get the value of the environment variable we just added.  5   shell: 'source ~ .bash_profile && echo $ENV_VAR'  6   register: foo  7   8 - name: Print the value of the environment variable.  9   debug: msg="The variable is {{ foo.stdout }}"   We use source ~ .bash_profile in line 4 because Ansible needs to make sure it’s using the latest environment configuration for the remote user. In some situations, the tasks all run over a persistent or quasi-cached SSH session, over which $ENV_VAR wouldn’t yet be defined.   This is also the first time the debug module has made an appearance. It will be explored more in-depth along with other debugging techniques later. .  Why ~ .bash_profile? There are many different places you can store environment variables, including .bashrc, .profile, and .bash_profile in a user’s home folder. In our case, since we want the environment variable to be available to Ansible, which runs a pseudo-TTY shell session, in which case .bash_profile is used to configure the environment. You can read more about shell session configuration and these dotfiles here: Configuring your login sessions with dotfiles.  Linux will also read global environment variables added to  etc environment, so you can add your variable there:  - name: Add a global environment variable.    lineinfile: dest= etc environment regexp=^ENV_VAR=  line=ENV_VAR=value    sudo: yes    In any case, it’s pretty simple to manage environment variables on the server with lineinfile. If your application requires many environment variables  as is the case in many Java applications , you might consider using copy or template with a local file instead of using lineinfile with a large list of items.  Per-play environment variables You can also set the environment for just one play, using the environment option for that play. As an example, let’s say you need to set an http proxy for a certain file download. This can be done with:  - name: Download a file, using example-proxy as a proxy.    get_url: url=http:  www.example.com file.tar.gz dest=~ Downloads     environment:      http_proxy: http:  example-proxy:80    That could be rather cumbersome, though, especially if you have many tasks that require a proxy or some other environment variable. In this case, you can pass an environment in via a variable in your playbook’s vars section  or via an included variables file , like so:  vars:    var_proxy:      http_proxy: http:  example-proxy:80       https_proxy: https:  example-proxy:443       [etc...]    tasks:  - name: Download a file, using example-proxy as a proxy.    get_url: url=http:  www.example.com file.tar.gz dest=~ Downloads     environment: var_proxy   If a proxy needs to be set system-wide  as is the case behind many corporate firewalls , I like to do so using the global  etc environment file:   1  In the 'vars' section of the playbook  set to 'absent' to  disable proxy :   2 proxy_state: present   3    4  In the 'tasks' section of the playbook:   5 - name: Configure the proxy.   6   lineinfile:   7     dest:  etc environment     8     regexp: "{{ item.regexp }}"   9     line: "{{ item.line }}"  10     state: "{{ proxy_state }}"  11   with_items:  12     - { regexp: "^http_proxy=", line: "http_proxy=http:  example- proxy:80 " }  13     - { regexp: "^https_proxy=", line:  "https_proxy=https:  example-proxy:443 " }  14     - { regexp: "^ftp_proxy=", line: "ftp_proxy=http:  example- proxy:80 " }   Doing it this way allows me to configure whether the proxy is enabled per- server  using the proxy_state variable , and with one play, set the http, https, and ftp proxies. You can use a similar kind of play for any other types of environment variables you need to set system-wide.  You can test remote environment variables using the ansible command: ansible test -m shell -a 'echo $TEST'. When doing so, be careful with your use of quotes and escaping—you might end up using double quotes where you meant to use single quotes, or vice-versa, and end up printing a local environment variable instead of one from the remote server!  Variables Variables in Ansible work just like variables in most other systems. Variables always begin with a letter  [A-Za-z] , and can include any number of underscores  _  or numbers  [0-9] .  Valid variable names include foo, foo_bar, foo_bar_5, and fooBar, though the standard is to use all lowercase letters, and typically avoid numbers in variable names  no camelCase or UpperCamelCase .  Invalid variable names include _foo, foo-bar, 5_foo_bar, foo.bar and foo bar.  In an inventory file, a variable’s value is assigned using an equals sign, like so:  foo=bar    In a playbook or variables include file, a variable’s value is assigned using a colon, like so:  foo: bar   Playbook Variables There are many different ways you can define variables to use in tasks.  Variables can be passed in via the command line, when calling ansible- playbook, with the --extra-vars option:  ansible-playbook example.yml --extra-vars "foo=bar"   You can also pass in extra variables using quoted JSON, YAML, or even by passing a JSON or YAML file directly, like --extra-vars "@even_more_vars.json" or --extra-vars "@even_more_vars.yml, but at this point, you might be better off using one of the other methods below.  Variables may be included inline with the rest of a playbook, in a vars section:  1 ---  2 - hosts: example  3   vars:  4     foo: bar  5   tasks:  6      Prints "Variable 'foo' is set to bar".  7     - debug: msg="Variable 'foo' is set to {{ foo }}"   Variables may also be included in a separate file, using the vars_files section:  1 ---  2  Main playbook file.  3 - hosts: example  4   vars_files:  5     - vars.yml  6   tasks:  7     - debug: msg="Variable 'foo' is set to {{ foo }}"   1 ---  2  Variables file 'vars.yml' in the same folder as the playbook.    3 foo: bar   Notice how the variables are all at the root level of the YAML file. They don’t need to be under any kind of vars heading when they are included as a standalone file.  Variable files can also be imported conditionally. Say, for instance, you have one set of variables for your CentOS servers  where the Apache service is named httpd , and another for your Debian servers  where the Apache service is named apache2 . In this case, you could use a conditional vars_files include:  1 ---  2 - hosts: example  3   vars_files:  4     - [ "apache_{{ ansible_os_family }}.yml", "apache_default.yml"  ]  5   tasks:  6     - service: name={{ apache }} state=running   Then, add two files in the same folder as your example playbook, apache_CentOS.yml, and apache_default.yml. Define the variable apache: httpd in the CentOS file, and apache: apache2 in the default file.  As long as your remote server has facter or ohai installed, Ansible will be able to read the OS of the server, translate that to a variable  ansible_os_family , and include the vars file with the resulting name. If ansible can’t find a file with that name, it will use the second option  apache_default.yml . So, on a Debian or Ubuntu server, Ansible would correctly use apache2 as the service name, even though there is no apache_Debian.yml or apache_Ubuntu.yml file available.  Inventory variables Variables may also be added via Ansible inventory files, either inline with a host definition, or after a group:  1  Host-specific variables  defined inline .  2 [washington]  3 app1.example.com proxy_state=present  4 app2.example.com proxy_state=absent  5     6  Variables defined for the entire group.  7 [washington:vars]  8 cdn_host=washington.static.example.com  9 api_version=3.0.1   If you need to define more than a few variables, especially variables that apply to more than one or two hosts, inventory files can be cumbersome. In fact, Ansible’s documentation recommends not storing variables within the inventory. Instead, you can use group_vars and host_vars YAML variable files within a specific path, and Ansible will assign them to individual hosts and groups defined in your inventory.  For example, to apply a set of variables to the host app1.example.com, create a blank file named app1.example.com at the location  etc ansible host_vars app1.example.com, and add variables as you would in an included vars_files YAML file:  ---  foo: bar  baz: qux   To apply a set of variables to the entire washington group, create a similar file in the location  etc ansible group_vars washington  substitute washington for whatever group name’s variables you’re defining .  You can also put these files  named the same way  in host_vars or group_vars directories in your playbook’s directory. Ansible will use the variables defined in the inventory  etc ansible [hostgroup]_vars directory first  if the appropriate files exist , then it will use variables defined in the playbook directories.  Another alternative to using host_vars and group_vars is to use conditional variable file imports, as was mentioned above.  Registered Variables There are many times that you will want to run a command, then use its return code, stderr, or stdout to determine whether to run a later task. For these situations, Ansible allows you to use register to store the output of a particular command in a variable at runtime.   In the previous chapter, we used register to get the output of the forever list command, then used the output to determine whether we needed to start our Node.js app:  39 - name: "Node: Check list of Node.js apps running."  40   command: forever list  41   register: forever_list  42   changed_when: false  43   44 - name: "Node: Start example Node.js app."  45   command: forever start {{ node_apps_location }} app app.js  46   when: "forever_list.stdout.find '{{  node_apps_location}} app app.js'  == -1"   In that example, we used a string function built into Python  find  to search for the path to our app, and if it was not present, the Node.js app was started.  We will explore the use of register further later in this chapter.  Accessing Variables Simple variables  gathered by Ansible, defined in inventory files, or defined in playbook or variable files  can be used as part of a task using syntax like {{ variable }}. For example:  - command:  opt my-app rebuild {{ my_environment }}   When the command is run, Ansible will substitute the contents of my_environment for {{ my_environment }}. So the resulting command would be something like  opt my-app rebuild dev.  Many variables you will use are structured as arrays  or ‘lists’ , and accessing the array foo would not give you enough information to be useful  except when passing in the array in a context where Ansible will use the entire array, like when using with_items .  If you define a list variable like so:  foo_list:    - one      - two    - three   foo[0]  foofirst   You could access the first item in that array with either of the following syntax:  Note that the first line uses standard Python array access syntax  ‘retrieve the first  0-indexed  element of the array’ , whereas the second line uses a convenient filter provided by Jinja2. Either way is equally valid and useful, and it’s really up to you whether you like the first or second technique.  For larger and more structured arrays  for example, when retrieving the IP address of the server using the facts Ansible gathers from your server , you can access any part of the array by drilling through the array keys, either using bracket  []  or dot  .  syntax. For example, if you would like to retrieve the information about the eth0 network interface, you could first take a look at the entire array using debug in your playbook:   In your playbook.  tasks:    - debug: var=ansible_eth0   TASK: [debug var=ansible_eth0]  *****************************************  ok: [webserver] => {      "ansible_eth0": {          "active": true,          "device": "eth0",          "ipv4": {              "address": "10.0.2.15",              "netmask": "255.255.255.0",              "network": "10.0.2.0"          },          "ipv6": [              {                  "address": "fe80::a00:27ff:feb1:589a",                  "prefix": "64",                  "scope": "link"              }          ],          "macaddress": "08:00:27:b1:58:9a",          "module": "e1000",            "mtu": 1500,          "promisc": false,          "type": "ether"      }  }   Now that you know the overall structure of the variable, you can use either of the following techniques to retrieve only the IPv4 address of the server:  {{ ansible_eth0.ipv4.address }}  {{ ansible_eth0['ipv4']['address'] }}   Host and Group variables Ansible conveniently lets you define or override variables on a per-host or per-group basis. As we learned earlier, your inventory file can define groups and hosts like so:  The simplest way to define variables on a per-host or per-group basis is to do so directly within the inventory file:  1 [group]  2 host1  3 host2   1 [group]  2 host1 admin_user=jane  3 host2 admin_user=jack  4 host3  5   6 [group:vars]  7 admin_user=john   In this case, Ansible will use the group default variable ‘john’ for {{ admin_user }}, but for host1 and host2, the admin users defined alongside the hostname will be used.  This is convenient and works well when you need to define a variable or two per-host or per-group, but once you start getting into more involved playbooks, you might need to add a few  3+  host-specific variables. In these situations, you can define the variables in a different place to make maintenance and readability much easier.   group_vars and host_vars Ansible will search within the same directory as your inventory file  or inside  etc ansible if you’re using the default inventory file at  etc ansible hosts  for two specific directories: group_vars and host_vars.  You can place YAML files inside these directories named after the group name or hostname defined in your inventory file. Continuing our example above, let’s move the specific variables into place:  1 ---  2  File:  etc ansible group_vars group  3 admin_user: john   1 ---  2  File:  etc ansible host_vars host1  3 admin_user: jane   Even if you’re using the default inventory file  or an inventory file outside of your playbook’s root directory , Ansible will also use host and group variables files located within your playbook’s own group_vars and host_vars directories. This is convenient when you want to package together your entire playbook and infrastructure configuration  including all host group-specific configuration  into a source-control repository.  You can also define a group_vars all file that would apply to all groups, as well as a host_vars all file that would apply to all hosts. Usually, though, it’s a better idea to define sane defaults in your playbooks and roles  which will be discussed later .  Magic variables with host and group variables and information If you ever need to retrieve a specific host’s variables from another host, Ansible provides a magic hostvars variable containing all the defined host variables  from inventory files and any discovered YAML files inside host_vars directories .   From any host, returns "jane".  {{ hostvars['host1']['admin_user'] }}    There are a variety of other variables Ansible provides that you may need to use from time to time:  groups: A list of all group names in the inventory. group_names: A list of all the groups of which the current host is a part. inventory_hostname: The hostname of the current host, according to the inventory  this can differ from ansible_hostname, which is the hostname reported by the system . inventory_hostname_short: The first part of inventory_hostname, up to the first period. play_hosts: All hosts on which the current play will be run.  Please see Magic Variables, and How To Access Information About Other Hosts in Ansible’s official documentation for the latest information and further usage examples.  Facts  Variables derived from system information  By default, whenever you run an Ansible playbook, Ansible first gathers information  “facts”  about each host in the play. You may have noticed this whenever we ran playbooks in earlier chapters:  $ ansible-playbook playbook.yml    PLAY [group]  **********************************************************    GATHERING FACTS  *******************************************************  ok: [host1]  ok: [host2]  ok: [host3]   Facts can be extremely helpful when you’re running playbooks; you can use gathered information like host IP addresses, CPU type, disk space, operating system information, and network interface information to change when certain tasks are run, or change certain information used in configuration files.   To get a list of every gathered fact available, you can use the ansible command with the setup module:  $ ansible munin -m setup  munin.midwesternmac.com  success >> {      "ansible_facts": {          "ansible_all_ipv4_addresses": [              "167.88.120.81"          ],          "ansible_all_ipv6_addresses": [              "2604:180::a302:9076",  [...]   If you don’t need to use facts, and would like to save a few seconds per-host when running playbooks  this can be especially helpful when running an Ansible playbook against dozens or hundreds of servers , you can set gather_facts: no in your playbook:  - hosts: db    gather_facts: no   Many of my own playbooks and roles use facts like ansible_os_family, ansible_hostname, and ansible_memtotal_mb to register new variables or in tandem with when, to determine whether to run certain tasks.  If you have Facter or Ohai installed on a remote host, Ansible will also include their gathered facts as well, prefixed by facter_ and ohai_ , respectively. If you’re using Ansible in tandem with Puppet or Chef, and are already familiar with those system- information-gathering tools, you can conveniently use them within Ansible as well. If not, Ansible’s Facts are usually sufficient for whatever you need to do, and can be made even more flexible through the use of Local Facts.  If you run a playbook against similar servers or virtual machines  e.g. all your servers are running the same OS, same hosting provider, etc. , facts are almost always consistent in their behavior. When running playbooks against a diverse set of hosts  for example, hosts with different OSes, virtualization stacks, or hosting providers , know that some facts may contain different information than you were expecting. For Server Check.in, I have servers from no less than five different hosting providers, running on vastly different hardware, so I am sure to monitor the output of my ansible-playbook runs for abnormalities, especially when adding new servers to the mix.   Local Facts  Facts.d  Another way of defining host-specific facts is to place .fact file in a special directory on remote hosts,  etc ansible facts.d . These files can be either JSON or INI files, or you could use executables that return JSON. As an example, create the file  etc ansible facts.d settings.fact on a remote host, with the following contents:  1 [users]  2 admin=jane,john  3 normal=jim   Next, use Ansible’s setup module to display the new facts on the remote host:  $ ansible hostname -m setup -a "filter=ansible_local"  munin.midwesternmac.com  success >> {      "ansible_facts": {          "ansible_local": {              "settings": {                  "users": {                      "admin": "jane,john",                      "normal": "jim"                  }              }          }      },      "changed": false  }   If you are using a playbook to provision a new server, and part of that playbook adds a local .fact file which generates local facts that are used later, you can explicitly tell Ansible to reload the local facts using a task like the following:  1 - name: Reload local facts.  2   setup: filter=ansible_local    While it may be tempting to use local facts rather than host_vars or other variable definition methods, remember that it’s often better to build your playbooks in a way that doesn’t rely  or care about  specific details of individual hosts. Sometimes it is necessary to use local facts  especially if you are using executables in facts.d to define the facts based on changing local environments , but it’s almost always better to keep configuration in a central repository, and move away from host-specific facts.  Note that setup module options  like filter  won’t work on remote Windows hosts, as of this writing.  Variable Precedence It should be rare that you would need to dig into the details of which variable is used when you define the same variable in five different places, but since there are odd occasions where this is the case, Ansible’s documentation provides the following ranking:  1. Variables from the command line  -e in the command line  always  win.  2. Connection variables defined in inventory  ansible_ssh_user, etc. . 3. “Most everything else”  command line switches, variables defined in a  play, included variables, role variables, etc. . 4. Other  non-connection  inventory variables. 5. Local facts and automatically discovered facts  via gather_facts . 6. Role default variables  inside a role’s defaults main.yml file .  After lots of experience building playbooks, roles, and managing inventories, you’ll likely find the right mix of variable definition for your needs, but there are a few general things that will mitigate any pain in setting and overriding variables on a per-play, per-host, or per-run basis:  Roles  to be discussed in the next chapter  should provide sane default values via the role’s ‘defaults’ variables. These variables will be the fallback in case the variable is not defined anywhere else in the chain. Playbooks should rarely define variables  e.g. via set_fact , but rather, variables should be defined either in included vars_files or,   less often, via inventory. Only truly host- or group-specific variables should be defined in host or group inventories. Dynamic and static inventory sources should contain a minimum of variables, especially as these variables are often less visible to those maintaining a particular playbook. Command line variables  -e  should be avoided when possible. One of the main use cases is when doing local testing or running one-off playbooks where you aren’t worried about the maintainability or idempotence of the tasks you’re running.  See Ansible’s Variable Precedence documentation for more detail and examples.  If then when - Conditionals Many tasks need only be run in certain circumstances. Some tasks use modules with built-in idempotence  as is the case when ensuring a yum or apt package is installed , and you usually don’t need to define further conditional behaviors for these tasks.  However, there are many tasks—especially those using Ansible’s command or shell modules—which require further input as to when they’re supposed to run, whether they’ve changed anything after they’ve been run, or when they’ve failed to run.  We’ll cover all the main conditionals behaviors you can apply to Ansible tasks, as well as how you can tell Ansible when a play has done something to a server or failed.  Jinja2 Expressions, Python built-ins, and Logic Before discussing all the different uses of conditionals in Ansible, it’s worthwhile to at least quickly cover a small part of Jinja2  the syntax Ansible uses both for templates and for conditionals , and available Python functions  often referred to as ‘built-ins’ . Ansible uses expressions and built-ins with when, changed_when, and failed_when so you can describe these things to Ansible with as much precision as possible.   Jinja2 allows the definition of literals like strings  "string" , integers  42 , floats  42.33 , lists  [1, 2, 3] , tuples  like lists, but can’t be modified  dictionaries  {key: value, key2: value2} , and booleans  true or false .  Jinja2 also allows basic math operations, like addition, subtraction, multiplication and division, and comparisons  == for equality, != for inequality, >= for greater than or equal to, etc. . Logical operators are and, or, and not, and you can group expressions by placing them within parenthesis.  If you’re familiar with almost any programming language, you will probably pick up basic usage of Jinja2 expressions in Ansible very quickly.  For example:   The following expressions evaluate to 'true':  1 in [1, 2, 3]  'see' in 'Can you see me?'  foo != bar   1 < 2  and  'a' not in 'best'      The following expressions evaluate to 'false':  4 in [1, 2, 3]  foo == bar   foo != foo  or  a in [1, 2, 3]    Jinja2 also offers a helpful set of ‘tests’ you can use to test a given object. For example, if you define the variable foo for only a certain group of servers, but not others, you can use the expression foo is defined with a conditional to evaluate to ‘true’ if the variable is defined, or false if not.  There are many other checks you can perform as well, like undefined  the opposite of defined , equalto  works like == , even  returns true if the variable is an even number , iterable  if you can iterate over the object . We’ll cover the full gamut later in the book, but for now, know that you can use Ansible conditionals with Jinja2 expressions to do some powerful things!   For the few cases where Jinja2 doesn’t provide enough power and flexibility, you can invoke Python’s built-in library functions  like string.split, [number].is_signed    to manipulate variables and determine whether a given task should be run, resulted in a change, failed, etc.  As an example, I need to parse version strings from time to time, to find the major version of a particular project. Assuming the variable software_version is set to 4.6.1, I can get the major version by splitting the string on the . character, then using the first element of the array. I can check if the major version is 4 using when, and choose to run  or not run  a certain task:  1 - name: Do something only for version 4 of the software.  2   [task here]  3   when: software_version.split '.' [0] == '4'   It’s generally best to stick with simpler Jinja2 filters and variables, but it’s nice to be able to use Python when you’re doing more advanced variable manipulation.  register In Ansible, any play can ‘register’ a variable, and once registered, that variable will be available to all subsequent tasks. Registered variables work just like normal variables or host facts.  Many times, you may need the output  stdout or stderr  of a shell command, and you can get that in a variable using the following syntax:  - shell: my_command_here    register: my_command_result   Later, you can access stdout  as a string  with my_command_result.stdout, and stderr with my_command_result.stderr.  Registered facts are very helpful for many types of tasks, and can be used both with conditionals  defining when and how a play runs , and in any part of the play. As an example, if you have a command that outputs a version number string like “10.0.4”, and you register the output as version, you can   use the string later when doing a code checkout by printing the variable {{ version.stdout }}.  If you want to see the different properties of a particular registered variable, you can run a playbook with -v to inspect play output. Usually, you’ll get access to values like changed  whether the play resulted in a change , delta  the time it took to run the play , stderr and stdout, etc. Some Ansible modules  like stat  add much more data to the registered variable, so always inspect the output with -v if you need to see what’s inside.  when One of the most helpful extra keys you can add to a play is a when statement. Let’s take a look at a simple use of when:  - yum: name=mysql-server state=present    when: is_db_server   The above statement assumes you’ve defined the is_db_server variable as a boolean  true or false  earlier, and will run the play if the value is true, or skip the play when the value is false.  If you only define the is_db_server variable on database servers  meaning there are times when the variable may not be defined at all , you could run tasks conditionally like so:  - yum: name=mysql-server state=present    when:  is_db_server is defined  and is_db_server   when is even more powerful if used in conjunction with variables registered by previous tasks. For example, we want to check the status of a running application, and run a play only when that application reports it is ‘ready’ in its output:  - command: my-app --status    register: myapp_result    - command: do-something-to-my-app    when: "'ready' in myapp_result.stdout"    These examples are a little contrived, but they illustrate basic uses of when in your tasks. Here are some examples of uses of when in real-world playbooks:   From our Node.js playbook - register a command's output, then see   if the path to our app is in the output. Start the app if it's   not present.  - command: forever list    register: forever_list  - command: forever start  path to app app.js    when: "forever_list.stdout.find ' path to app app.js'  == -1"     Run 'ping-hosts.sh' script if 'ping_hosts' variable is true.  - command:  usr local bin ping-hosts.sh    when: ping_hosts     Run 'git-cleanup.sh' script if a branch we're interested in is   missing from git's list of branches in our project.  - command: chdir= path to project git branch    register: git_branches  - command:  path to project scripts git-cleanup.sh    when: " is_app_server == true  and  'interesting-branch' not in \    git_branches.stdout "     Downgrade PHP version if the current version contains '7.0'.  - shell: php --version    register: php_version  - shell: yum -y downgrade php*    when: "'7.0' in php_version.stdout"     Copy a file to the remote server if the hosts file doesn't exist.  - stat: path= etc hosts    register: hosts_file  - copy: src=path to local file dest= path to remote file    when: hosts_file.stat.exists == false   changed_when and failed_when Just like when, you can use changed_when and failed_when to influence Ansible’s reporting of when a certain task results in changes or failures.  It is difficult for Ansible to determine if a given command results in changes, so if you use the command or shell module without also using changed_when, Ansible will always report a change. Most Ansible modules report whether they resulted in changes correctly, but you can also override this behavior by invoking changed_when yourself.   When using PHP Composer as a command to install project dependencies, it’s useful to know when Composer installed something, or when nothing changed. Here’s an example:  1 - name: Install dependencies via Composer.  2   command: " usr local bin composer global require phpunit phpunit  --prefer-dist"  3   register: composer  4   changed_when: "'Nothing to install or update' not in  composer.stdout"   You can see we used register to store the results of the command, then we checked whether a certain string was in the registered variable’s stdout. Only when Composer doesn’t do anything will it print “Nothing to install or update”, so we use that string to tell Ansible if the task resulted in a change.  Many command-line utilities print results to stderr instead of stdout, so failed_when can be used to tell Ansible when a task has actually failed and is not just reporting its results in the wrong way. Here’s an example where we need to parse the stderr of a Jenkins CLI command to see if Jenkins did, in fact, fail to perform the command we requested:  1 - name: Import a Jenkins job via CLI.  2   shell: >  3     java -jar  opt jenkins-cli.jar -s http:  localhost:8080   4     create-job "My Job" <  usr local my-job.xml  5   register: import  6   failed_when: "import.stderr and 'already exists' not in  import.stderr"   In this case, we only want Ansible to report a failure when the command returns an error, and that error doesn’t contain ‘already exists’. It’s debatable whether the command should report a job already exists via stderr, or just print the result to stdout… but it’s easy to account for whatever the command does with Ansible!  ignore_errors Sometimes there are commands that should be run always, and they often report errors. Or there are scripts you might run that output errors left and right, and the errors don’t actually indicate a problem, but they’re just annoying  and they cause your playbooks to stop executing .   For these situations, you can add ignore_errors to the task, and Ansible will remain blissfully unaware of any problems running a particular task. Be careful using this, though; it’s usually best if you can find a way to work with and around the errors generated by tasks so playbooks do fail if there are actual problems.  Delegation, Local Actions, and Pauses Some tasks, like sending a notification, communicating with load balancers, or making changes to DNS, networking, or monitoring servers, require Ansible to run the task on the host machine  running the playbook  or another host besides the one s  being managed by the playbook. Ansible allows any task to be delegated to a particular host using delegate_to:  1 - name: Add server to Munin monitoring configuration.  2   command: monitor-server webservers {{ inventory_hostname }}  3   delegate_to: "{{ monitoring_master }}"   Delegation is often used to manage a server’s participation in a load balancer or replication pool; you might either run a particular command locally  as in the example below , or you could use one of Ansible’s built-in load balancer modules and delegate_to a specific load balancer host directly:  1 - name: Remove server from load balancer.  2   command: remove-from-lb {{ inventory_hostname }}  3   delegate_to: 127.0.0.1   If you’re delegating a task to localhost, Ansible has a convenient shorthand you can use, local_action, instead of adding the entire delegate_to line:  1 - name: Remove server from load balancer.  2   local_action: command remove-from-lb {{ inventory_hostname }}   Pausing playbook execution with wait_for You might also use local_action in the middle of a playbook to wait for a freshly-booted server or application to start listening on a particular port:  1 - name: Wait for webserver to start.  2   local_action:  3     module: wait_for    4     host: "{{ inventory_hostname }}"  5     port: "{{ webserver_port }}"  6     delay: 10  7     timeout: 300  8     state: started   The above task waits until webserver_port is open on inventory_hostname, as checked from the host running the Ansible playbook, with a 5-minute timeout  and 10 seconds before the first check, and between checks .  wait_for can be used to pause your playbook execution to wait for many different things:  Using host and port, wait a maximum of timeout seconds for the port to be available  or not . Using path  and search_regex if desired , wait a maximum of timeout seconds for the file to be present  or absent . Using host and port and drained for the state parameter, check if a given port has drained all it’s active connections. Using delay, you can simply pause playbook execution for a given amount of time  in seconds .  Running an entire playbook locally When running playbooks on the server or workstation where the tasks need to be run  e.g. self-provisioning , or when a playbook should be otherwise run on the same host as the ansible-playbook command is run, you can use --connection=local to speed up playbook execution by avoiding the SSH connection overhead.  As a quick example, here’s a short playbook that you can run with the command ansible-playbook test.yml --connection=local:   1 ---   2 - hosts: 127.0.0.1   3   gather_facts: no   4    5   tasks:   6     - name: Check the current system date.   7       command: date   8       register: date     9   10     - name: Print the current system date.  11       debug: var=date.stdout   This playbook will run on localhost and output the current date in a debug message. It should run very fast  it took about .2 seconds on my Mac!  since it’s running entirely over a local connection.  Running a playbook with --connection=local is also useful when you’re either running a playbook with --check mode to verify configuration  e.g. on a cron job that emails you when changes are reported , or when testing playbooks on testing infrastructure  e.g. via Travis, Jenkins, or some other CI tool .  Prompts In rare circumstances, you may require the user to enter the value of a variable that will be used in the playbook. If the playbook requires a user’s personal login information, or if you prompt for a version or other values that may change depending on who is running the playbook, or where it’s being run, and if there’s no other way this information can be configured  e.g. using environment variables, inventory variables, etc. , use vars_prompt.  As a simple example, you can request a user to enter a username and password that could be used to login to a network share:   1 ---   2 - hosts: all   3    4   vars_prompt:   5     - name: share_user   6       prompt: "What is your network username?"   7    8     - name: share_pass   9       prompt: "What is your network password?"  10       private: yes   Before Ansible runs the play, Ansible prompts the user for a username and password, the latter’s input being hidden on the command line for security purposes.   There are a few special options you can add to prompts:  private: If set to yes, the user’s input will be hidden on the command line. default: You can set a default value for the prompt, to save time for the end user. encrypt   confirm   salt_size: These values can be set for passwords so you can verify the entry  the user will have to enter the password twice if confirm is set to yes , and encrypt it using a salt  with the specified size and crypt scheme . See Ansible’s Prompts documentation for detailed information on prompted variable encryption.  Prompts are a simple way to gather user-specific information, but in most cases, you should avoid them unless absolutely necessary. It’s preferable to use role or playbook variables, inventory variables, or even local environment variables, to maintain complete automation of the playbook run.  Tags Tags allow you to run  or exclude  subsets of a playbook’s tasks.  You can tag roles, included files, individual tasks, and even entire plays. The syntax is simple, and below are examples of the different ways you can add tags:   1 ---   2  You can apply tags to an entire play.   3 - hosts: webservers   4   tags: deploy   5    6   roles:   7      Tags applied to a role will be applied to the tasks in the  role.   8     - { role: tomcat, tags: ['tomcat', 'app'] }   9   10   tasks:  11     - name: Notify on completion.  12       local_action:  13         module: osx_say  14         msg: "{{inventory_hostname}} is finished!"    15         voice: Zarvox  16       tags:  17         - notifications  18         - say  19   20     - include: foo.yml  21       tags: foo   Assuming we save the above playbook as tags.yml, you could run the command below to only run the tomcat role and the Notify on completion task:  1 $ ansible-playbook tags.yml --tags "tomcat,say"   If you want to exclude anything tagged with notifications, you can use - -skip-tags.  1 $ ansible-playbook tags.yml --skip-tags "notifications"   This is incredibly handy if you have a decent tagging structure; when you want to only run a particular portion of a playbook, or one play in a series  or, alternatively, if you want to exclude a play or included tasks , then it’s easy to do using --tags or --skip-tags.  There is one caveat when adding one or multiple tags using the tags option in a playbook: you can use the shorthand tags: tagname when adding just one tag, but if adding more than one tag, you have to use YAML’s list syntax, for example:   Shorthand list syntax.  tags: ['one', 'two', 'three']     Explicit list syntax.  tags:    - one    - two    - three     Non-working example.  tags: one, two, three   In general, I tend to use tags for larger playbooks, especially with individual roles and plays, but unless I’m debugging a set of tasks, I generally avoid   adding tags to individual tasks or includes  not adding tags everywhere reduces visual clutter . You will need to find a tagging style that suits your needs and lets you run  or not run  the specific parts of your playbooks you desire.  Summary Playbooks are Ansible’s primary means of automating infrastructure management. After reading this chapter, you should know how to use  and hopefully not abuse!  variables, inventories, handlers, conditionals, tags, and more.  The more you understand the fundamental components of a playbook, the more efficient you’ll be building and expanding your infrastructure with Ansible.   ____________________________________    Men have become the tools of their \  \ tools.  Henry David Thoreau            ------------------------------------          \   ^__^           \   oo \_______               __ \        \ \                  ----w                            Chapter 6 - Playbook Organization - Roles and Includes  So far, we’ve used fairly straightforward examples in this book. Most examples are ad-hoc for a particular server, and listing all tasks in one long listing makes for a fairly long playbook.  Ansible is very flexible when it comes to organizing your tasks in more efficient ways so you can make your playbooks more maintainable, reusable, and powerful. We’ll look at two ways to split up tasks more efficiently: using includes and roles. Finally, we’ll explore Ansible Galaxy, a repository of some community-maintained roles that help configure common packages and applications.  Includes We’ve already seen one of the most basic ways of including other files in Chapter 4, when vars_files was used to place variables into a separate vars.yml file instead of inline with the playbook:  - hosts: all      vars_files:    - vars.yml   Tasks can easily be included in a similar way. In the tasks: section of your playbook, you can add include directives like so:  tasks:    - include: included-playbook.yml   Just like with variable include files, tasks are formatted in a flat list in the included file. As an example, the included-playbook.yml could look like:  ---  - name: Add profile info for user.    copy:        src: example_profile      dest: " home {{ username }} .profile"      owner: "{{ username }}"      group: "{{ username }}"      mode: 0744    - name: Add private keys for user.    copy:      src: "{{ item.src }}"      dest: " home .ssh {{ item.dest }}"      owner: "{{ username }}"      group: "{{ username }}"      mode: 0600    with_items: ssh_private_keys    - name: Restart example service.    service: name=example state=restarted   In this case, you’d probably want to name the file user-config.yml, since it’s used to configure a user account and restart some service. Now, in this and any other playbook that provisions or configures a server, if you want to configure a particular user’s account, add the following in your playbook’s tasks section:  - include: example-app-config.yml   We used {{ username }} and {{ ssh_private_keys }} variables in this include file instead of hard-coded values so we could make this include file reusable. You could define the variables in your playbook’s inline variables or an included variables file, but Ansible also lets you pass variables directly into includes using normal YAML syntax. For example:  - { include: user-config.yml, username: johndoe, ssh_private_keys:  [] }  - { include: user-config.yml, username: janedoe, ssh_private_keys:  [] }   To make the syntax more readable, you can use structured variables, like so:  - include: user-config.yml    vars:      username: johndoe      ssh_private_keys:        - { src:  path to johndoe key1, dest: id_rsa }        - { src:  path to johndoe key2, dest: id_rsa_2 }    - include: user-config.yml    vars:      username: janedoe      ssh_private_keys:        - { src:  path to janedoe key1, dest: id_rsa }        - { src:  path to janedoe key2, dest: id_rsa_2 }   Include files can even include other files, so you could have something like the following:  tasks:    - include: user-config.yml   inside user-config.yml  - include: ssh-setup.yml   Handler includes Handlers can be included just like tasks, within a playbook’s handlers section. For example:  handlers:    - include: included-handlers.yml   This can be helpful in limiting the noise in your main playbook, since handlers are usually used for things like restarting services or loading a configuration, and can distract from the playbook’s primary purpose.  Playbook includes Playbooks can even be included in other playbooks, using the same include syntax in the top level of your playbook. For example, if you have two playbooks—one to set up your webservers  web.yml , and one to set up your database servers  db.yml , you could use the following playbook to run both at the same time:  - hosts: all    remote_user: root        tasks:      ...        - include: web.yml  - include: db.yml   This way, you can create playbooks to configure all the servers in your entire infrastructure, then create a master playbook that includes each of the individual playbooks. When you want to initialize your entire infrastructure, make changes across your entire fleet of servers, or just check to make sure their configuration matches your playbook definitions, you can run one ansible-playbook command!  Complete includes example What if I told you we could remake the 137-line Drupal LAMP server playbook from Chapter 4 in just 21 lines? With includes, it’s easy; just break out each of the sets of tasks into their own include files, and you’ll end up with a main playbook like this:   1 ---   2 - hosts: all   3    4   vars_files:   5     - vars.yml   6    7   pre_tasks:   8     - name: Update apt cache if needed.   9       apt: update_cache=yes cache_valid_time=3600  10   11   handlers:  12     - include: handlers handlers.yml  13   14   tasks:  15     - include: tasks common.yml  16     - include: tasks apache.yml  17     - include: tasks php.yml  18     - include: tasks mysql.yml  19     - include: tasks composer.yml  20     - include: tasks drush.yml  21     - include: tasks drupal.yml   All you need to do is create two new folders in the same folder where you saved the Drupal playbook.yml file, handlers and tasks, then create files inside for each section of the playbook.  For example, inside handlers handlers.yml, you’d have:   1 ---  2 - name: restart apache  3   service: name=apache2 state=restarted   And inside tasks drush.yml:   1 ---   2 - name: Check out drush master branch.   3   git:   4     repo: https:  github.com drush-ops drush.git   5     dest:  opt drush   6    7 - name: Install Drush dependencies with Composer."   8   shell: >   9      usr local bin composer install  10     chdir= opt drush  11     creates= opt drush vendor autoload.php  12   13 - name: Create drush bin symlink.  14   file:  15     src:  opt drush drush  16     dest:  usr local bin drush  17     state: link   Separating all the tasks into separate includes files means you’ll have more files to manage for your playbook, but it helps keep the main playbook more compact  meaning it’s easier to see all the installation and configuration steps the playbook contains , and also separates tasks into individual, easily-maintainable groupings. Instead of having to browse one playbook with twenty-three separate tasks, you now maintain eight included files with two to five tasks, each.  It’s much easier to maintain a more granular set of tasks than one very long playbook. However, there’s no reason to try to start writing a playbook with lots of individual includes. Most of the time, it’s best to start with a monolithic playbook while you’re working on the setup and configuration details, then move sets of tasks out to included files after you start seeing logical groupings.  You can also use tags  demonstrated in the previous chapter  to limit the playbook run to a certain include file. Using the above example, if you wanted to add a ‘drush’ tag to the included drush file  so you could run   ansible-playbook playbook.yml --tags=drush and only run the drush tasks , you can change line 20 to the following:  20 - include: tasks drush.yml tags=drush   You can find the entire example Drupal LAMP server playbook using include files in this book’s code repository at https:  github.com geerlingguy ansible-for-devops, in the includes directory.  You can’t use variables for task include file names  like you could with include_vars directives, e.g. include_vars: "{{ ansible_os_family }}.yml" as a task, or with vars_files . There’s usually a better way than conditional task includes to accomplish conditional task inclusion using a different playbook structure, or roles, which we will discuss next.  Roles Including playbooks inside other playbooks makes your playbook organization a little more sane, but once you start wrapping up your entire infrastructure’s configuration in playbooks, you might end up with something resembling Russian nesting dolls.  Wouldn’t it be nice if there were a way to take bits of related configuration, and package them together nicely? Additionally, what if we could take these packages  often configuring the same thing on many different servers  and make them flexible so we can use the same package throughout our infrastructure, with slightly different settings on individual servers or groups of servers?  Ansible Roles can do all that, and more!  Let’s dive into what makes an Ansible role by taking one of the playbook examples from Chapter 4 and splitting it into a more flexible structure using roles.  Role scaffolding   Instead of requiring you to explicitly include certain files and playbooks in a role, Ansible automatically includes any main.yml files inside specific directories that make up the role.  There are only two directories required to make a working Ansible role:  If you create a directory structure like the one shown above, with a main.yml file in each directory, Ansible will run all the tasks defined in tasks main.yml if you call the role from your playbook using the following syntax:  role_name     meta     tasks    1 ---  2 - hosts: all  3   roles:  4     - role_name   Your roles  each one as its own directory, where the directory name is used by Ansible as the name of the role  can live in a couple different places—in the default global Ansible role path  configurable in  etc ansible ansible.cfg , or in a ‘roles’ folder directly within the same directory as your main playbook file.  Another simple way to build the scaffolding for a role  complete with all the available options directories, a README file, and a structure suitable for contributing the role to Ansible Galaxy  we’ll get to Galaxy in a little bit!  so it can easily be shared , is to use the ansible-galaxy init command. Running this command creates an example role in the current working directory, which you can modify to suit your needs.  Building your first role Let’s clean up the Node.js server example from Chapter four, and break out one of the main parts of the configuration—installing Node.js and any required npm modules.   Create a roles folder in the same directory as the main playbook.yml file like we created in Chapter 4’s first example, and inside that folder, create a new folder nodejs  which will be our role’s name . Create two folders inside the nodejs role directory, meta and tasks.  Inside the meta folder, add a simple main.yml file with the following contents:  1 ---  2 dependencies: []   The meta information for your role is defined in this file. In basic examples and simple roles, you just need to list any role dependencies  other roles that are required to be run before the current role can do its work , but you can add much more to this file to describe your role to Ansible and to Ansible Galaxy. We’ll dive deeper into the meta information later. For now, save the file and head over to the tasks foler.  Create a main.yml file in this folder, and add the following contents  basically copying and pasting the configuration from the Chapter 4 example :  1 ---  2 - name: Install Node.js  npm plus all its dependencies .  3   yum: name=npm state=present enablerepo=epel  4   5 - name: Install forever module  to run our Node.js app .  6   npm: name=forever global=yes state=latest   The Node.js directory structure should now look like the following:   1 nodejs-app    2   app    3     app.js   4     package.json   5   playbook.yml   6   roles    7     nodejs    8       meta    9         main.yml  10       tasks   11         main.yml    You now have a complete Ansible role that you can use in your node.js server configuration playbook. Delete the Node.js app installation lines from playbook.yml, and reformat the playbook so the other tasks run first  in a pre_tasks: section instead of tasks: , then the role is included, then the rest of the tasks  in the main tasks: section . Something like:  pre_tasks:     EPEL GPG setup, firewall configuration...    roles:    - nodejs    tasks:     Node.js app deployment tasks...   You can view the full example of this playbook in the ansible-for-devops code repository.  Once you finish reformatting the main playbook, everything would run exactly the same during an ansible-playbook, with the exception of the tasks inside the nodejs role being prefixed with nodejs  [Task name here].  This little bit of extra data shown during playbook runs is useful because it automatically prefixes tasks with the role that provides them, without you having to add in descriptions as part of the name values of the tasks.  Our role isn’t all that helpful at this point, though, because it still does only one thing, and it’s not really flexible enough to be used on other servers that might need different Node.js modules to be installed.  More flexibility with role vars and defaults To make our role more flexible, we can make it use a list of npm modules instead of a hardcoded value, then allow playbooks using the role to provide their own module list variable to override our role’s default list.  When running a role’s tasks, Ansible picks up variables defined in a role’s vars main.yml file and defaults main.yml  I’ll get to the differences   between the two later , but will allow your playbooks to override the defaults or other role-provided variables if you want.  Modify the tasks main.yml file to use a list variable and iterate through the list to install as many packages as your playbook wants:  1 ---  2 - name: Install Node.js  npm plus all its dependencies .  3   yum: name=npm state=present enablerepo=epel  4   5 - name: Install npm modules required by our app.  6   npm: name={{ item }} global=yes state=latest  7   with_items: node_npm_modules   Let’s provide a sane default for the new node_npm_modules variable in defaults main.yml:  Now, if you run the playbook as-is, it will still do the exact same thing— install the forever module. But since the role is more flexible, we could create a new playbook like our first, but add a variable  either in a vars section or in an included file via vars_files  to override the default, like so:  1 ---  2 node_npm_modules:  3   - forever   1 node_npm_modules:  2   - forever  3   - async  4   - request   When you run the playbook with this custom variable  we didn’t change anything with our nodejs role , all three of the above npm modules will be installed.  Hopefully you’re beginning to see how this can be powerful!  Imagine if you had a playbook structure like:  1 ---  2 - hosts: appservers    3   roles:  4     - yum-repo-setup  5     - firewall  6     - nodejs  7     - app-deploy   Each one of the roles would live in its own isolated world, and could be shared with other servers and groups of servers in your infrastructure.  A yum-repo-setup role could enable certain repositories and import their GPG keys. A firewall role could have per-server or per-inventory-group options for ports and services to allow or deny. An app-deploy role could deploy your app to a directory  configurable per-server  and set certain app options per-server or per-group.  All these things become very easy to manage when you have small bits of functionality separated into different roles. Instead of managing 100+ lines of playbook tasks, and manually prefixing every name: with something like “Common ” or “App Deploy ”, you now manage a few roles with 10-20 lines of YAML each.  On top of that, when you’re building your main playbooks, they can be extremely simple  like the above example , enabling you to see everything being configured and deployed on a particular server without scrolling through dozens of included playbook files and hundreds of tasks.  Variable precedence: Note that Ansible handles variables placed in included files in defaults with less precedence than those placed in vars. If you have certain variables you need to allow hosts playbooks to easily override, you should probably put them into defaults. If they are common variables that should almost always be the values defined in your role, put them into vars. For more on variable precedence, see the aptly-named “Variable Precedence” section in the previous chapter.  Other role parts: handlers, files, and templates Handlers   In one of the prior examples, we introduced handlers—tasks that could be called via the notify option after any playbook task resulted in a change— and an example handler for restarting Apache was given:  1 handlers:  2   - name: restart apache  3     service: name=apache2 state=restarted   In Ansible roles, handlers are first-class citizens, alongside tasks, variables, and other configuration. You can store handlers directly inside a main.yml file inside a role’s handlers directory. So if we had a role for Apache configuration, our handlers main.yml file could look like the following:  1 ---  2 - name: restart apache  3   command: service apache2 restart   You can call handlers defined in a role’s handlers folder just like you would handlers included directly in your playbooks  e.g. notify: restart apache .  Files and Templates For the following examples, let’s assume our role is structured with files and templates inside files and templates directories, respectively:   1 roles    2   example    3     files    4       example.conf   5     meta    6       main.yml   7     templates    8       example.xml.j2   9     tasks   10       main.yml   when copying a file directly to the server, add the filename or the full path from within a role’s files directory, like so:  - name: Copy configuration file to server directly.    copy: >      src=example.conf        dest= etc myapp example.conf      mode=644   Similarly, when specifying a template, add the filename or the full path from within a role’s templates directory, like so:  - name: Copy configuration file to server using a template.    template: >      src=example.xml.j2      dest= etc myapp example.xml      mode=644   The copy module copies files from within the module’s files folder, and the template module runs given template files through the Jinja2 templating engine, merging in any variables available during your playbook run before copying the file to the server.  Organizing more complex and cross-platform roles For simple package installation and configuration roles, you can get by with placing all tasks, variables, and handlers directly in the respective main.yml file Ansible automatically loads. But you can also include other files from within a role’s main.yml files if needed.  As a rule of thumb, I like to keep my playbook and role task files under 100 lines of YAML if at all possible  that way it’s easier for me to keep the entire set of tasks in my head while working through any issues . If I start nearing that limit, I usually split the tasks into logical groupings, and include files from the main.yml file.  Let’s take a look at the way my geerlingguy.apache role is set up  it’s available on Ansible Galaxy and can be downloaded to your roles directory with the command ansible-galaxy install geerlingguy.apache; we’ll discuss Ansible Galaxy itself later .  Initially, the role’s main tasks main.yml file looked something like the following  generally speaking :  1 - name: Ensure Apache is installed  via apt .  2   3 - name: Configure Apache with lineinfile.    4   5 - name: Enable Apache modules.   Soon after creating the role, though, I wanted to make the role work with both Debian and RedHat hosts. I could’ve added two sets of tasks in the main.yml file, resulting in twice the number of tasks and a bunch of extra when statements:   1 - name: Ensure Apache is installed  via apt .   2   when: ansible_os_family == 'Debian'   3    4 - name: Ensure Apache is installed  via yum .   5   when: ansible_os_family == 'RedHat'   6    7 - name: Configure Apache with lineinfile  Debian .   8   when: ansible_os_family == 'Debian'   9   10 - name: Configure Apache with lineinfile  Redhat .  11   when: ansible_os_family == 'RedHat'  12   13 - name: Enable Apache modules  Debian .  14   when: ansible_os_family == 'Debian'  15   16 - name: Other OS-agnostic tasks...   If I had gone this route, and continued with the rest of the playbook tasks in one file, I would’ve quickly surpassed my informal 100-line limit. So I chose to use includes in my main tasks file:   1 - name: Include OS-specific variables.   2   include_vars: "{{ ansible_os_family }}.yml"   3    4 - include: setup-RedHat.yml   5   when: ansible_os_family == 'RedHat'   6    7 - include: setup-Debian.yml   8   when: ansible_os_family == 'Debian'   9   10 - name: Other OS-agnostic tasks...   Two important things to notice about this style of distribution-specific inclusion:  1. When including vars files  with include_vars , you can actually use  variables in the name of the file. This is very handy for a variety of use   cases, and here we’re including a vars file in the format distribution_name.yml. For our purposes, since the role will be used on Debian and RedHat-based hosts, we can create Debian.yml and RedHat.yml files in our role’s defaults and vars folders, and put distribution-specific variables there.  2. When including playbook files  with include , you can’t use variables in the name of the file, but you can do the next best thing: include the files by name explicitly, and use a condition to tell Ansible whether to run the tasks inside  the when condition will be applied to every task inside the included playbook .  After setting things up this way, I put RedHat and CentOS-specific tasks  like yum tasks  into tasks setup-RedHat.yml, and Debian and Ubuntu- specific tasks  like apt tasks  into tasks setup-Debian.yml. There are other ways of making roles work cross-platform, but using distribution- specific variables files and included playbooks is one of the simplest.  Now this Apache role can be used across different distributions, and with clever usage of variables in tasks and in configuration templates, it can be used in a very wide variety of infrastructure that needs Apache installed.  Ansible Galaxy Ansible roles are powerful and flexible; they allow you to encapsulate sets of configuration and deployable units of playbooks, variables, templates, and other files, so you can easily reuse them across different servers.  It’s annoying to have to start from scratch every time, though; wouldn’t it be better if people could share roles for commonly-installed applications and services? Enter Ansible Galaxy.  Ansible Galaxy, or just ‘Galaxy’, is a repository of community-contributed roles for common Ansible content. There are already hundreds of roles available which can configure and deploy common applications, and they’re all available through the ansible-galaxy command, introduced in Ansible 1.4.2.   Galaxy offers the ability to add, download, and rate roles, and you can register either using a social account or a normal account on the site  though you don’t need an account to install and use roles from Galaxy .  Getting roles from Galaxy One of the primary functions of the ansible-galaxy command is retrieving roles from Galaxy. Roles must be downloaded before they can be used in playbooks.  Remember the basic LAMP  Linux, Apache, MySQL and PHP  server we installed earlier in the book? Let’s create it again, but this time, using a few roles from Galaxy:  $ ansible-galaxy install geerlingguy.apache geerlingguy.mysql  geerlingguy.php   The latest version or a role will be downloaded if no version is specified. To specify a version, add the version after the role name, for example: $ ansible-galaxy install geerlingguy.apache,1.0.0.  Ansible Galaxy is still evolving rapidly, and has already seen many small improvements. There are a few areas where Galaxy could use some improvement  like browsing for roles by Operating System in the online interface, or automatically downloading roles that are included in playbooks , but most of these little bugs or rough areas will be fixed in time. Please check Ansible Galaxy’s About page and stay tuned to Ansible’s blog for the latest updates.  Using role requirements files to manage dependencies If your infrastructure configuration requires have five, ten, fifteen or more Ansible roles, installing them all via ansible-galaxy install commands can get very tiring. Additionally, if you host roles internally  e.g. via an internal Git repository , you can’t install the roles through Ansible Galaxy. The ansible-galaxy command, however, can be passed a ‘requirements’ file that it will parse and use to automatically download all the included dependencies—whether on Ansible Galaxy or in some other role repository.   There are two simple syntaxes, the first which follows Python’s pip requirements convention. Generally, you can create a requirements.txt file  I usually add one in the root of my project directory , and include a line for each role, using the same syntax we used in the install command earlier:  1 geerlingguy.apache,1.3.1 2 geerlingguy.mysql 3 geerlingguy.php,1.4.1  Specify one Ansible Galaxy role per line either by itself, or with a particular version number, and then run ansible-galaxy install -r requirements.txt. Ansible will download all the roles from Galaxy into your local roles path.  If you want to be able to install roles from other sources, like GitHub, an HTTP download, BitBucket, etc., or if you’d like to specify the path into which the roles should be downloaded, you can use a requirements.yml file with the following syntax:   1  From Ansible Galaxy, like the earlier requirements.txt example.  2 - src: geerlingguy.firewall  3    4  From GitHub, into a particular path, with a custom name and version.  5 - src: https:  github.com geerlingguy ansible-role-passenger  6   path:  etc ansible roles   7   name: passenger  8   version: 1.0.2  9   10  From a web server, with a custom name. 11 - src: https:  www.example.com ansible roles my-role-name.tar.gz 12   name: my-role  Installing roles defined in this file is similar to the .txt example: ansible- galaxy install -r requirements.yml. For more documentation on Ansible requirements files, read the official documentation: Advanced Control over Role Requirements Files.  A LAMP server in six lines of YAML With the Apache, MySQL, and PHP roles installed, we can quickly create a LAMP server. This example assumes you already have a CentOS-based   linux VM or server booted and can connect to it or run Ansible as a provisioner via Vagrant on it, and that you’ve run the ansible-galaxy install command above to download the required roles.  First, create an Ansible playbook named lamp.yml with the following contents:  1 ---  2 - hosts: all  3   roles:  4     - geerlingguy.mysql  5     - geerlingguy.apache  6     - geerlingguy.php   Now, run the playbook against a host:  $ ansible-playbook -i path to custom-inventory lamp.yml   After a few minutes, an entire LAMP server should be set up and running. If you add in a few variables, you can configure virtualhosts, PHP configuration options, MySQL server settings, etc.  We’ve effectively reduced about thirty lines of YAML  from previous examples dealing with LAMP or LAMP-like servers  down to three. Obviously, the roles have extra code in them, but the power here is in abstraction. Since most companies have many servers using similar software, but with slightly different configurations, having centralized, flexible roles saves a lot of repetition.  You could think of Galaxy roles  which typically install and configure common software like Apache or MySQL, or set up security rules or frameworks  as glorified packages; they not only install software, but they configure it exactly how you want it, every time, with minimal manual labor. Additionally, many of these roles work across different flavors of Linux and UNIX, so you have better configuration portability!  A Solr server in six lines of YAML Let’s grab a few more roles and build an Apache Solr search server, which requires Java and Apache Tomcat to be installed and configured.   $ ansible-galaxy install geerlingguy.java geerlingguy.tomcat6  geerlingguy.solr   Then create a playbook named solr.yml with the following contents:  1 ---  2 - hosts: all  3   roles:  4     - geerlingguy.java  5     - geerlingguy.tomcat6  6     - geerlingguy.solr   Now we have a fully-functional Solr server, and we could add some variables to configure it exactly how we want, by using a non-default port, or changing the memory allocation for Tomcat6.  I think you might get the point. Now, I could’ve also left out the java and tomcat6 roles, since they’ll be automatically picked up during installation of the geerlingguy.solr role  they’re listed in the solr role’s dependencies .  A role’s page on the Ansible Galaxy website highlights available variables for setting things like what version of Solr to install, where to install it, etc.  as an example, view the geerlingguy.solr Galaxy page .  Using community-maintained roles, you can build a wide variety of servers with minimal effort. Instead of having to maintain lengthy playbooks and roles unique to each server, Galaxy lets you build a list of the required roles, and a few variables that set up the servers with the proper versions and paths. Configuration management with Ansible Galaxy becomes true configuration management—you get to spend more time managing your server’s configuration, and less time on packaging and building individual services!  Helpful Galaxy commands Some other helpful ansible-galaxy commands you might use from time to time:  ansible-galaxy list displays a list of installed roles, with version numbers   ansible-galaxy remove [role] removes an installed role ansible-galaxy init can be used to create a role template suitable for submission to Ansible Galaxy  You can configure the default path where Ansible roles will be downloaded by editing your ansible.cfg configuration file  normally located in  etc ansible ansible.cfg , and setting a roles_path in the [defaults] section.  Contributing to Ansible Galaxy If you’ve been working on some useful Ansible roles, and you’d like to share them with others, all you need to do is make sure they follow Ansible Galaxy’s basic template  especially within the meta main.yml and README.md files . To get started, use ansible-galaxy init to generate a basic Galaxy template, and make your own role match the Galaxy template’s structure.  Then push your role up to a new project on GitHub  I usually name my Galaxy roles like ansible-role-[rolename], so I can easily see them when browsing my repos on GitHub , and add a new role while logged into galaxy.ansible.com.  Summary Using includes and Ansible roles organizes Playbooks and makes them maintainable. This chapter introduced different ways of using include, the power and flexible structure of roles, and how you can utilize Ansible Galaxy, the community repository of configurable Ansible roles that do just about anything.   _________________________________________    When the only tool you own is a hammer, \   every problem begins to resemble a        \ nail.  Abraham Maslow                       -----------------------------------------          \   ^__^           \   oo \_______               __ \        \ \                  ----w                            Chapter 7 - Inventories  Earlier in the book, a basic inventory file example was given  see Chapter 1’s basic inventory file example . For the simplest of purposes, an inventory file at the default location   etc ansible hosts  will suffice to describe to Ansible how to reach the servers you want to manage.  Later, a slightly more involved inventory file was introduced  see Chapter 3’s inventory file for multiple servers , which allowed us to tell Ansible about multiple servers, and even group them into role-related groups, so we could run certain playbooks against certain groups.  Let’s jump back to a basic inventory file example and build from there:  1  Inventory file at  etc ansible hosts  2   3  Groups are defined using square brackets  e.g. [groupname] .  Each server  4  in the group is defined on its own line.  5 [myapp]  6 www.myapp.com   If you want to run an ansible playbook on all the myapp servers in this inventory  so far, just one, www.myapp.com , you can set up the playbook like so:  ---  - hosts: myapp      tasks:      [...]   If you want to run an ad-hoc command against all the myapp servers in the inventory, you can run a command like so:   Use ansible to check memory usage on all the myapp servers.  $ ansible myapp -a "free -m"    A real-world web application server inventory The example above might be adequate for single-server services and tiny apps or websites, but most real-world applications require many more servers, and usually separate servers per application concern  database, caching, application, queuing, etc. . Let’s take a look at a real-world inventory file for a small web application that monitors server uptime, Server Check.in.   1  Individual Server Check.in servers.   2 [servercheck-web]   3 www1.servercheck.in   4 www2.servercheck.in   5    6 [servercheck-web:vars]   7 ansible_ssh_user=servercheck_svc   8    9 [servercheck-db]  10 db1.servercheck.in  11   12 [servercheck-log]  13 log.servercheck.in  14   15 [servercheck-backup]  16 backup.servercheck.in  17   18 [servercheck-nodejs]  19 atl1.servercheck.in  20 atl2.servercheck.in  21 nyc1.servercheck.in  22 nyc2.servercheck.in  23 nyc3.servercheck.in  24 ned1.servercheck.in  25 ned2.servercheck.in  26   27 [servercheck-nodejs:vars]  28 ansible_ssh_user=servercheck_svc  29 foo=bar  30   31  Server Check.in distribution-based groups.  32 [centos:children]  33 servercheck-web  34 servercheck-db  35 servercheck-nodejs  36 servercheck-backup  37   38 [ubuntu:children]  39 servercheck-log    This inventory may look a little overwhelming at first, but if you break it apart into simple groupings  web app servers, database servers, logging server, and node.js app servers , it describes a straightforward architecture.  Server Check.in Infrastructure.  Lines 1-29 describe a few groups of servers  some with only one server , so playbooks and ansible commands can refer to the group by name. Lines 6- 7 and 27-29 set variables that will apply only to the servers in the group  e.g. variables below [servercheck-nodejs:vars] will only apply to the servers in the servercheck-nodejs group .  Lines 31-39 describe groups of groups  using groupname:children to describe ‘child’ groups  that allow for some helpful abstractions.  Describing infrastructure in such a way affords a lot of flexibility when using Ansible. Consider the task of patching a vulnerability on all your   CentOS servers; instead of having to log into each of the servers, or even having to run an ansible command against all the groups, using the above structure allows you to easily run an ansible command or playbook against all centos servers.  As an example, when the Shellshock vulnerability was disclosed in 2014, patched bash packages were released for all the major distributions within hours. To update all the Server Check.in servers, all that was needed was:  $ ansible centos -m yum -a "name=bash state=latest"   You could even go further and create a small playbook that would patch the vulnerability, then run tests to make sure the vulnerability was no longer present, as illustrated in this playbook. This would also allow you to run the playbook in check mode or run it through a continuous integration system to verify the fix works in a non-prod environment.  This infrastructure inventory is also nice in that you could create a top-level playbook that runs certain roles or tasks against all your infrastructure, others against all servers of a certain Linux flavor, and another against all servers in your entire infrastructure.  Consider, for example, this example master playbook to completely configure all the servers:   1 ---   2  Set up basic, standardized components across all servers.   3 - hosts: all   4   sudo: true   5   roles:   6     - security   7     - logging   8     - firewall   9   10  Configure web application servers.  11 - hosts: servercheck-web  12   roles:  13     - nginx  14     - php  15     - servercheck-web  16   17  Configure database servers.  18 - hosts: servercheck-db    19   roles:  20     - pgsql  21     - db-tuning  22   23  Configure logging server.  24 - hosts: servercheck-log  25   roles:  26     - java  27     - elasticsearch  28     - logstash  29     - kibana  30   31  Configure backup server.  32 - hosts: servercheck-backup  33   roles:  34     - backup  35   36  Configure Node.js application servers.  37 - hosts: servercheck-nodejs  38   roles:  39     - servercheck-node   There are a number of different ways you can structure your infrastructure- management playbooks and roles, and we’ll explore some in later chapters, but for a simple infrastructure, something like this is adequate and maintainable.  Non-prod environments, separate inventory files Using the above playbook and the globally-configured Ansible inventory file is great for your production infrastructure, but what happens when you want to configure a separate but similar infrastructure for, say a development or user certification environment?  In this case, it’s easiest to use individual inventory files, rather than the central, locally-managed Ansible inventory file. For typical team-managed infrastructure, I would recommend including an inventory file for each environment in the same version-controlled repository as your Ansible playbooks, perhaps within an ‘inventories’ directory.  For example, I could take the entire contents of  etc ansible hosts above, and stash that inside an inventory file named inventory-prod, then duplicate it, changing server names where appropriate  e.g. the   [servercheck-web] group would only have www-dev1.servercheck.in for the development environment , and naming the files for the environments:  servercheck     inventories       inventory-prod      inventory-cert      inventory-dev    playbook.yml   Now, when running playbook.yml to configure the development infrastructure, I would pass in the path to the dev inventory  assuming my current working directory is servercheck  :  $ ansible-playbook playbook.yml -i inventory-dev   Using inventory variables  which will be explored further , and well- constructed roles and or tasks that use the variables effectively, you could architect your entire infrastructure, with environment-specific configurations, by changing some things in your inventory files.  Inventory variables Chapter 5 introduced basic methods of managing variables for individual hosts or groups of hosts through your inventory in the inventory variables section, but it’s worth exploring the different ways of defining and overriding variables through inventory here.  For extremely simple use cases—usually when you need to define one or two connection-related variables  like ansible_ssh_user or ansible_ssh_port —you can place variables directly inside an inventory file.  Assuming we have a standalone inventory file for a basic web application, here are some examples of variable definition inside the file:   1 [www]   2  You can define host-specific variables inline with the host.   3 www1.example.com ansible_ssh_user=johndoe   4 www2.example.com   5    6 [db]     7 db1.example.com   8 db2.example.com   9   10  You can add a '[group:vars]' heading to create variables that  will apply  11  to an entire inventory group.  12 [db:vars]  13 ansible_ssh_port=5222  14 database_performance_mode=true   It’s usually better to avoid throwing too many variables inside static inventory files, because not only are these variables typically less visible, they are also mixed in with your architecture definition. Especially for host- specific vars  which appear on one long line per host , this is an unmaintainable, low-visibility approach to host and group-specific variables.  Fortunately, Ansible provides a more flexible way of declaring host and group variables.  host_vars For Hosted Apache Solr, different servers in a solr group have different memory requirements. The simplest way to tell Ansible to override a default variable in our Ansible playbook  in this case, the tomcat_xmx variable  is to use a host_vars directory  which can be placed either in the same location as your inventory file, or in a playbook’s root directory , and place a YAML file named after the host which needs the overridden variable.  As an illustration of the use of host_vars, we’ll assume we have the following directory layout:  hostedapachesolr     host_vars       nyc1.hostedapachesolr.com    inventory       hosts    main.yml   The inventory hosts file contains a simple definition of all the servers by group:   1 [solr]  2 nyc1.hostedapachesolr.com  3 nyc2.hostedapachesolr.com  4 jap1.hostedapachesolr.com  5 ...  6   7 [log]  8 log.hostedapachesolr.com   Ansible will search for a file at either hostedapachesolr host_vars nyc1.hostedapachesolr.com or hostedapachesolr inventory host_vars nyc1.hostedapachesolr.com, and if there are any variables defined in the file  in YAML format , those variables will override all other playbook and role variables and gathered facts, only for the single host.  The nyc1.hostedapachesolr.com host_vars file looks like:  1 ---  2 tomcat_xmx: "1024m"   The default for tomcat_xmx may normally be 640m, but when Ansible runs a playbook against nyc1.hostedapachesolr.com, the value of tomcat_xmx will be 1024m instead.  Overriding host variables with host_vars is much more maintainable than doing so directly in static inventory files, and also provides greater visibility into what hosts are getting what overrides.  group_vars Much like host_vars, Ansible will automatically load any files named after inventory groups in a group_vars directory placed inside the playbook or inventory file’s location.  Using the same example as above, we’ll override one particular variable for an entire group of servers. First, we add a group_vars directory with a file named after the group needing the overridden variable:  hostedapachesolr     group_vars       solr      host_vars       nyc1.hostedapachesolr.com    inventory       hosts    main.yml   1 ---  2 do_something_amazing=true  3 foo=bar   Then, inside group_vars solr, use YAML to define a list of variables that will be applied to servers in the solr group:  Typically, if your playbook is only being run on one group of hosts, it’s easier to define the variables in the playbook via an included vars file. However, in many cases you will be running a playbook or applying a set of roles to multiple inventory groups. In these situations, you may need to use group_vars to override specific variables for one or more groups of servers.  Ephemeral infrastructure: Dynamic inventory In many circumstances, static inventories are adequate for describing your infrastructure. When working on small applications, low-traffic web applications, and individual workstations, it’s simple enough to manage an inventory file by hand.  However, in the age of cloud computing and highly scalable application architecture, it’s often necessary to add dozens or hundreds of servers to an infrastructure in a short period of time—or to add and remove servers continuously, to scale as traffic grows and subsides. In this circumstance, it would be tedious  if not impossible  to manage a single inventory file by hand, especially if you’re using auto-scaling infrastructure new instances are provisioned and need to be configured in minutes or seconds.  Even in the case of container-based infrastructure, new instances need to be configured correctly, with the proper port mappings, application settings, and filesystem configuration.  For these situations, Ansible allows you to define inventory dynamically. If you’re using one of the larger cloud-based hosting providers, chances are   there is already a dynamic inventory script  which Ansible uses to build an inventory  for you to use. Ansible core already includes scripts for Amazon Web Services, Cobbler, DigitalOcean, Linode, OpenStack, and other large providers, and later we’ll explore creating our own dynamic inventory script  if you aren’t using one of the major hosting providers or cloud management platforms .  Dynamic inventory with DigitalOcean Digital Ocean is one of the world’s top five hosting companies, and has grown rapidly since it’s founding in 2011. One of the reasons for the extremely rapid growth is the ease of provisioning new ‘droplets’  cloud VPS servers , and the value provided; as of this writing, you could get a fairly speedy VPS with 512MB of RAM and a generous portion of fast SSD storage for $5 USD per month.  Digital Ocean’s API and simple developer-friendly philosophy has made it easy for Ansible to interact with Digital Ocean droplets; you can create, manage, and delete droplets with Ansible, as well as use droplets with your playbooks using dynamic inventory.  DigitalOcean account prerequisites Before you can follow the rest of the examples in this section, you will need:  1. A DigitalOcean account  sign up at www.digitalocean.com . 2. dopy, a Python wrapper for Digital Ocean API interaction  you can  install it with pip: sudo pip install dopy .  3. Your DigitalOcean account API key and client ID  Ansible currently supports the v1 API, so you need to go to the ‘Apps & API’ page in your profile, then click the ‘API v1.0 Page’ link to get a key and client ID .  4. An SSH key pair, which will be used to connect to your DigitalOcean  servers. Follow this guide to create a key pair and add the public key to your DigitalOcean account.  Once you have these four things set up and ready to go, you should be able to communicate with your DigitalOcean account through Ansible.   Connecting to your DigitalOcean account There are a few different ways you can specify your DigitalOcean client ID and API key  including command line arguments --client-id and --api- key, as values inside a digital_ocean.ini file, or as environment variables . For our example, we’ll use environment variables  since these are easy to configure, and work both with Ansible’s digital_ocean module and the dynamic inventory script . Open up a terminal session, and enter the following commands:  $ export DO_CLIENT_ID=YOUR_CLIENT_ID_HERE  $ export DO_API_KEY=YOUR_API_KEY_HERE   Before we can use a dynamic inventory script to discover our DigitalOcean droplets, let’s use Ansible to quickly provision a new droplet.  Creating cloud instances  ‘Droplets’, in DigitalOcean parlance  will incur minimal charges for the time you use them  currently less than $0.01 hour for the size in this example . For the purposes of this tutorial  and in general, for any testing , make sure you shut down and destroy your instances when you’re finished using them, or you will be charged through the next billing cycle! Even so, using low-priced instances  like a $5 month DigitalOcean droplet with hourly billing  means that, even in the worst case, you won’t have to pay much. If you create and destroy an instance in a few hours, you’ll be charged a few pennies.  Creating a droplet with Ansible Create a new playbook named provision.yml, with the following contents:   1 ---   2 - hosts: localhost   3   connection: local   4   gather_facts: false   5    6   tasks:   7     - name: Create new Droplet.   8       digital_ocean:   9         state: present  10         command: droplet  11         name: ansible-test  12         private_networking: yes  13          512mb  14         size_id: 66  15          CentOS 7.0 x64    16         image_id: 6713409  17          nyc2  18         region_id: 4  19         ssh_key_ids: 138954  20          Required for idempotence only one droplet creation.  21         unique_name: yes  22       register: do   The digital_ocean module lets you create, manage, and delete droplets with ease. You can read the documentation for all the options, but the above is an overview of the main options. name sets the hostname for the droplet, state can also be set to deleted if you want the droplet to be destroyed, and other options tell DigitalOcean where to set up the droplet, and with what OS and configuration.  You can use DigitalOcean’s API, along with your client_id and api_key, to get the IDs for size_id  the size of the Droplet , image_id  the system or distro image to use , region_id  the data center in which your droplet will be created , and ssh_key_ids  a comma separate list of SSH keys to be included in the root account’s authorized_keys file .  As an example, to get all the available images, use curl "https:  api.digitalocean.com images ? client_id=CLIENT_ID&api_key=API_KEY&filter=global"  python -m json.tool, substituting your own CLIENT_ID and API_KEY, and you’ll receive a JSON listing of all available values. Browse the DigitalOcean API for information on how to query SSH key information, size information, etc.  We used register as part of the digital_ocean task so we could immediately start using and configuring the new host if needed. Running the above playbook returns the following output  using debug: var=do in an additional task to dump the contents of our registered variable, do :  $ ansible-playbook do_test.yml    PLAY [localhost]  ***********************************************************    TASK: [Create new Droplet.]  ************************************************  changed: [localhost]    TASK: [debug var=do]    *******************************************************  ok: [localhost] => {      "do": {          "changed": true,          "droplet": {              "backups": [],              "backups_active": false,              "created_at": "2014-10-22T02:09:20Z",              "event_id": 34915980,              "id": 2940194,              "image_id": 6918990,              "ip_address": "162.243.20.29",              "locked": false,              "name": "ansible-test",              "private_ip_address": null,              "region_id": 4,              "size_id": 66,              "snapshots": [],              "status": "active"          },          "invocation": {              "module_args": "",              "module_name": "digital_ocean"          }      }  }    PLAY RECAP  *****************************************************************  localhost                  : ok=2    changed=1    unreachable=0     failed=0   Since do contains the new droplet’s IP address  alongside other relevant information , you can place your freshly-created droplet in an existing inventory group using Ansible’s add_host module. Adding to the playbook we started above, you could set up your playbook to provision an instance and immediately configure it  after waiting for port 22 to become available  with something like:  24     - name: Add new host to our inventory.  25       add_host:  26         name: "{{ do.droplet.ip_address }}"  27         groups: do  28       when: do.droplet is defined  29   30 - hosts: do  31   remote_user: root  32   gather_facts: false    33   34   tasks:  35     - name: Wait for port 22 to become available.  36       local_action: "wait_for port=22 host={{ inventory_hostname  }}"  37   38     - name: Install tcpdump.  39       yum: name=tcpdump state=installed   At this point, if you run the playbook  $ ansible-playbook provision.yml , it should create a new droplet  if it has not already been created , then add that droplet to the do inventory group, and finally, run a new play on all the do hosts  including the new droplet . Here are the results:  $ ansible-playbook provision.yml    PLAY [localhost]  ***********************************************************    TASK: [Create new Droplet.]  ************************************************  changed: [localhost]    TASK: [Add new host to our inventory.]  *************************************  ok: [localhost]    PLAY [do]  ******************************************************************    TASK: [Install tcpdump.]  ***************************************************  changed: [162.243.20.29]    PLAY RECAP  *****************************************************************  162.243.20.29              : ok=2    changed=1    unreachable=0     failed=0  localhost                  : ok=2    changed=1    unreachable=0     failed=0   If you run the same playbook again, it should report no changes—the entire playbook is idempotent! You might be starting to see just how powerful it is to have a tool as flexible as Ansible at your disposal; not only can you configure servers, you can create them  singly, or dozens at a time , and   configure them at once. And even if a ham-fisted sysadmin jumps in and deletes an entire server, you can run the playbook again, and rest assured your server will be recreated and reconfigured exactly as it was when it was first set up.  Note that you might need to disable strict host key checking to get provisioning and instant configuration to work correctly, otherwise you may run into an error stating that Ansible can’t connect to the new droplet during the second play. To do this, add the line host_key_checking=False under the [defaults] section in your ansible.cfg file  located in  etc ansible by default .  You should normally leave host_key_checking enabled, but when rapidly building and destroying VMs for testing purposes, it is simplest to disable it temporarily.  DigitalOcean dynamic inventory with digital_ocean.py Once you have some DigitalOcean droplets, you need a way for Ansible to dynamically build an inventory of your servers so you can build playbooks and use the servers in logical groupings  or run playbooks and ansible commands directly on all droplets .  There are a few steps to getting DigitalOcean’s official dynamic inventory script working:  1. Install dopy via pip  the DigitalOcean Python library : $ pip install  dopy.  2. Download the DigitalOcean dynamic inventory script from Ansible on  GitHub: $ curl -O https:  raw.githubusercontent.com ansible ansible devel plu gins inventory digital_ocean.py.  3. Make the inventory script executable: $ chmod +x  digital_ocean.py.  4. Make sure you have the credentials configured in digital_ocean.ini   as explained earlier in this chapter . Alternatively, you can set DO_CLIENT_ID and DO_API_KEY in your environment, or pass the command line options --client-id and --api-key.  5. Make sure the script is working by running the script directly: $  . digital_ocean.py --pretty. After a second or two, you should   see all your droplets  likely just the one you created earlier  listed by IP address and dynamic group as JSON.  6. Ping all your DigitalOcean droplets: $ ansible all -m ping -i  digital_ocean.py -u root.  Now that you have all your hosts being loaded through the dynamic inventory script, you can use add_hosts to build groups of the Droplets for use in your playbooks. Alternatively, if you want to fork the digital_ocean.py inventory script, you can modify it to suit your needs; exclude certain servers, build groups based on certain criteria, etc.  Ansible currently supports DigitalOcean’s v1 API, which makes working with DigitalOcean slightly more difficult. The v2 API allows you to use region names  e.g. “nyc2”  instead of numeric IDs, allows you to add metadata to your droplets, and much more. Ansible should soon support the v2 API. If you’re interested in the current status of this effort, or would like to help in migrating to the v2 API, visit the v2 API support issue on GitHub.  Dynamic inventory with AWS Many of this book’s readers are familiar with Amazon Web Services  especially EC2, S3, ElastiCache, and Route53 , and likely have managed or currently manage an infrastructure within Amazon’s cloud. Ansible has very strong support for managing AWS-based infrastructure, and includes a dynamic inventory script to help you run playbooks on your hosts in a variety of ways.  There are a few excellent guides to using Ansible with AWS, for example:  Ansible - Amazon Web Services Guide Ansible for AWS  I won’t be covering dynamic inventory in this chapter, but will mention that the ec2.py dynamic inventory script, along with Ansible’s extensive support for AWS infrastructure through ec2_* modules, makes Ansible the best and most simple tool for managing a broad AWS infrastructure.   In the next chapter, one of the examples will include a guide for provisioning infrastructure on AWS, along with a quick overview of dynamic inventory on AWS.  Inventory on-the-fly: add_host and group_by Sometimes, especially when provisioning new servers, you will need to modify the in-memory inventory during the course of a playbook run. Ansible offers the add_host and group_by modules to help you manage inventory for these scenarios.  In the DigitalOcean example above, add_host was used to add the new droplet to the do group:  [...]      - name: Add new host to our inventory.        add_host:          name: "{{ do.droplet.ip_address }}"          groups: do        when: do.droplet is defined    - hosts: do    remote_user: root      tasks:  [...]   You could add multiple groups with add_host, and you can also add other variables for the host inline with add_host. As an example, let’s say you created a VM using an image that exposes SSH on port 2288 and requires an application-specific memory limit specific to this VM:  - name: Add new host to our inventory.    add_host:      name: "{{ do.droplet.ip_address }}"      ansible_ssh_port: 2288      myapp_memory_maximum: "1G"    when: do.droplet is defined   The custom port will be used when Ansible connects to this host, and the myapp_memory_maximum will be passed into the playbooks just as any other inventory variable.   The group_by module is even simpler, and allows you to create dynamic groups during the course of a playbook run. Usage is extremely simple:  - hosts: all    gather_facts: yes    tasks:      - name: Create an inventory group for each architecture.        group_by: "key=architecture-{{ ansible_machine }}"        - debug: var=groups   After running the above playbook, you’d see all your normal inventory groups, plus groups for architecture-x86_64, i386, etc.  depending on what kind of server architectures you use .  Multiple inventory sources - mixing static and dynamic inventories If you need to combine static and dynamic inventory, or even if you wish to use multiple dynamic inventories  for example, if you are managing servers hosted by two different cloud providers , you can pass a directory to ansible or ansible-playbook, and Ansible will combine the output of all the inventories  both static and dynamic  inside the directory:  `ansible-playbook -i path to inventories main.yml`   One caveat: Ansible ignores .ini and backup files in the directory, but will attempt to parse every text file and execute every executable file in the directory—don’t leave random files in mixed inventory folders!  Creating custom dynamic inventories TODO:  Dynamic Inventory Developing dynamic inventory sources  Summary From the most basic infrastructure consisting of one server to a multi- tenant, dynamic infrastructure with thousands of servers, Ansible offers   many options for describing your servers, and overriding playbook and role variables for specific hosts or groups. You should be able to describe all your servers, however they’re managed and wherever they’re hosted, with Ansible’s flexible inventory system.   ___________________________________    A pint of sweat saves a gallon of \  \ blood.  General Patton                -----------------------------------          \   ^__^           \   oo \_______               __ \        \ \                  ----w                            Chapter 8 - Ansible Cookbooks  Most of the book up to this point has demonstrated individual aspects of Ansible—inventory, playbooks, ad-hoc tasks, etc.—but this chapter will start to synthesize everything and show how Ansible is applied to real- world infrastructure management scenarios.  Highly-Available Infrastructure with Ansible Real-world web applications require redundancy and horizontal scalability with multi-server infrastructure. In the following example, we’ll use Ansible to configure a complex infrastructure  illustrated below  on servers provisioned either locally via Vagrant and VirtualBox, or on a set of automatically-provisioned instances running on either DigitalOcean or Amazon Web Services:   Highly-Available Infrastructure.  Varnish acts as a load balancer and reverse proxy, fronting web requests and routing them to the application servers. We could just as easily use something like Nginx or HAProxy, or even a proprietary cloud-based solution like an Amazon’s Elastic Load Balancer or Linode’s NodeBalancer, but for simplicity’s sake, and for flexibility in deployment, we’ll use Varnish.  Apache and mod_php run a PHP-based application that displays the entire stack’s current status and outputs the current server’s IP address for load balancing verification.  A Memcached server provides a caching layer that can be used to store and retrieve frequently-accessed objects in lieu of slower database storage.  Two MySQL servers, configured as a master and slave, offer redundant and performant database access; all data will be replicated from the master to   the slave, and the slave can also be used as a secondary server for read-only queries to take some load off the master.  Directory Structure In order to keep our configuration organized, we’ll use the following structure for our playbooks and configuration:  lamp-infrastructure     inventories     playbooks       db       memcached       varnish       www     provisioners     configure.yml    provision.yml    requirements.txt    Vagrantfile   Organizing things this way allows us to focus on each server configuration individually, then build playbooks for provisioning and configuring instances on different hosting providers later. This organization also keeps server playbooks completely independent, so we can modularize and reuse individual server configurations.  Individual Server Playbooks Let’s start building our individual server playbooks  in the playbooks directory . To make our playbooks more efficient, we’ll use some contributed Ansible roles on Ansible Galaxy rather than install and configure everything step-by-step. We’re going to target CentOS 6.x servers in these playbooks, but only minimal changes would be required to use the playbooks with Ubuntu, Debian, or later versions of CentOS.  Create a main.yml file within the the playbooks varnish directory, with the following contents:  Varnish   1 ---   2 - hosts: lamp-varnish     3   sudo: yes   4    5   vars_files:   6     - vars.yml   7    8   roles:   9     - geerlingguy.firewall  10     - geerlingguy.repo-epel  11     - geerlingguy.varnish  12   13   tasks:  14     - name: Copy Varnish default.vcl.  15       template:  16         src: "templates default.vcl.j2"  17         dest: " etc varnish default.vcl"  18       notify: restart varnish   We’re going to run this playbook on all hosts in the lamp-varnish inventory group  we’ll create this later , and we’ll run a few simple roles to configure the server:  geerlingguy.firewall configures a simple iptables-based firewall using a couple variables defined in vars.yml. geerlingguy.repo-epel adds the EPEL repository  a prerequisite for varnish . geerlingguy.varnish installs and configures Varnish.  Finally, a task copies over a custom default.vcl that configures Varnish, telling it where to find our web servers and how to load balance requests between the servers.  Let’s create the two files referenced in the above playbook. First, vars.yml, in the same directory as main.yml:  1 ---  2 firewall_allowed_tcp_ports:  3   - "22"  4   - "80"  5   6 varnish_use_default_vcl: false   The first variable tells the geerlingguy.firewall role to open TCP ports 22 and 80 for incoming traffic. The second variable tells the   geerlingguy.varnish we will supply a custom default.vcl for Varnish configuration.  Create a templates directory inside the playbooks varnish directory, and inside, create a default.vcl.j2 file. This file will use Jinja2 syntax to build Varnish’s custom default.vcl file:   1 vcl 4.0;   2    3 import directors;   4    5 {% for host in groups['lamp-www'] %}   6 backend www{{ loop.index }} {   7   .host = "{{ host }}";   8   .port = "80";   9 }  10 {% endfor %}  11   12 sub vcl_init {  13   new vdir = directors.random  ;  14 {% for host in groups['lamp-www'] %}  15   vdir.add_backend www{{ loop.index }}, 1 ;  16 {% endfor %}  17 }  18   19 sub vcl_recv {  20   set req.backend_hint = vdir.backend  ;  21   22    For testing ONLY; makes sure load balancing is working  correctly.  23   return  pass ;  24 }   We won’t study Varnish’s VCL syntax in depth but we’ll run through default.vcl and highlight what is being configured:  1.  1-3  Indicate that we’re using the 4.0 version of the VCL syntax and import the directors varnish module  which is used to configure load balancing .  2.  5-10  Define each web server as a new backend; give a host and a  port through which varnish can contact each host.  3.  12-17  vcl_init is called when Varnish boots and initializes any  required varnish modules. In this case, we’re configuring a load balancer vdir, and adding each of the www[] backends we defined   earlier as backends to which the load balancer will distribute requests. We use a random director so we can easily demonstrate Varnish’s ability to distribute requests to both app backends, but other load balancing strategies are also available.  4.  19-24  vcl_recv is called for each request, and routes the request  through Varnish. In this case, we route the request to the vdir backend defined in vcl_init, and indicate that Varnish should not cache the result.  According to 4, we’re actually bypassing Varnish’s caching layer, which is not helpful in a typical production environment. If you only need a load balancer without any reverse proxy or caching capabilities, there are better options. However, we need to verify our infrastructure is working as it should. If we used Varnish’s caching, Varnish would only ever hit one of our two web servers during normal testing.  In terms of our caching load balancing layer, this should suffice. For a true production environment, you should remove the final return  pass  and customize default.vcl according to your application’s needs.  Apache   PHP  Create a main.yml file within the the playbooks www directory, with the following contents:   1 ---   2 - hosts: lamp-www   3   sudo: yes   4    5   vars_files:   6     - vars.yml   7    8   roles:   9     - geerlingguy.firewall  10     - geerlingguy.repo-epel  11     - geerlingguy.apache  12     - geerlingguy.php  13     - geerlingguy.php-mysql  14     - geerlingguy.php-memcached  15   16   tasks:  17     - name: Remove the Apache test page.    18       file:  19         path:  var www html index.html  20         state: absent  21     - name: Copy our fancy server-specific home page.  22       template:  23         src: templates index.php.j2  24         dest:  var www html index.php   As with Varnish’s configuration, we’ll configure a firewall and add the EPEL repository  required for PHP’s memcached integration , and we’ll also add the following roles:  geerlingguy.apache installs and configures the latest available version of the Apache web server. geerlingguy.php installs and configures PHP to run through Apache. geerlingguy.php-mysql adds MySQL support to PHP. geerlingguy.php-memcached adds Memcached support to PHP.  Two final tasks remove the default index.html home page included with Apache, and replace it with our PHP app.  As in the Varnish example, create the two files referenced in the above playbook. First, vars.yml, alongside main.yml:  1 ---  2 firewall_allowed_tcp_ports:  3   - "22"  4   - "80"   Create a templates directory inside the playbooks www directory, and inside, create an index.php.j2 file. This file will use Jinja2 syntax to build a  relatively  simple PHP script to display the health and status of all the servers in our infrastructure:   1 <?php   2  **   3  * @file   4  * Infrastructure test page.   5  *   6  * DO NOT use this in production. It is simply a PoC.   7  *    8    9 $mysql_servers = array     10 {% for host in groups['lamp-db'] %}  11   '{{ host }}',  12 {% endfor %}  13  ;  14 $mysql_results = array  ;  15 foreach  $mysql_servers as $host  {  16   if  $result = mysql_test_connection $host   {  17     $mysql_results[$host] = '<span style="color:  green;">PASS ';  18     $mysql_results[$host] .= '  ' . $result['status'] . ' ';  19   }  20   else {  21     $mysql_results[$host] = '<span style="color:  red;">FAIL ';  22   }  23 }  24   25    Connect to Memcached.  26 $memcached_result = ' FAIL ';  27 if  class_exists 'Memcached'   {  28   $memcached = new Memcached;  29   $memcached->addServer '{{ groups['lamp-memcached'][0] }}',  11211 ;  30   31      Test adding a value to memcached.  32   if  $memcached->add 'test', 'success', 1   {  33     $result = $memcached->get 'test' ;  34     if  $result == 'success'  {  35       $memcached_result = '<span style="color:  green;">PASS ';  36       $memcached->delete 'test' ;  37     }  38   }  39 }  40   41  **  42  * Connect to a MySQL server and test the connection.  43  *  44  * @param string $host  45  *   IP Address or hostname of the server.  46  *  47  * @return array  48  *   Array with keys 'success'  bool  and 'status'  'slave' or  'master' .  49  *   Empty if connection failure.  50  *   51 function mysql_test_connection $host  {  52   $username = 'mycompany_user';  53   $password = 'secret';  54   try {    55     $db = new PDO   56       'mysql:host=' . $host . ';dbname=mycompany_database',  57       $username,  58       $password,  59       array PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION  ;  60   61        Query to see if the server is configured as a master or  slave.  62     $statement = $db->prepare "SELECT variable_value  63       FROM information_schema.global_variables  64       WHERE variable_name = 'LOG_BIN';" ;  65     $statement->execute  ;  66     $result = $statement->fetch  ;  67   68     return array   69       'success' => TRUE,  70       'status' =>  $result[0] == 'ON'  ? 'master' : 'slave',  71      ;  72   }  73   catch  PDOException $e  {  74     return array  ;  75   }  76 }  77 ?>  78    79    80    81    Host {{ inventory_hostname }}   82    * { font-family: Helvetica, Arial, sans-serif }   83    84    85    Host {{ inventory_hostname }}   86     $result : ?>  87      MySQL Connection    : <?php print  $result; ?>   88      89    Memcached Connection:     90    91     Don’t try transcribing this example manually; you can get the code from this book’s repository on GitHub. Visit the ansible-for-devops repository and download the source for index.php.j2  As this is the heart of the example application we’re deploying to the infrastructure, it’s necessarily a bit more complex than most examples in the   book, but a quick run through follows:   9-23  Iterate through all the lamp-db MySQL hosts defined in the playbook inventory, and test the ability to connect to them, and whether they are configured as master or slave, using the mysql_test_connection   function defined later  40-73 .  25-39  Check the first defined lamp-memcached Memcached host defined in the playbook inventory, confirming the ability to connect and create, retrieve, and delete a value from the cache.  41-76  Define the mysql_test_connection   function which tests the the ability to connect to a MySQL server and also returns its replication status.  78-91  Print the results of all the MySQL and Memcached tests, along with {{ inventory_hostname }} as the page title, so we can easily see which web server is serving the viewed page.  At this point, the heart of our infrastructure—the application that will test and display the status of all our servers—is ready to go.  Memcached  Compared to the earlier playbooks, the Memcached playbook is quite simple. Create playbooks memcached main.yml with the following contents:   1 ---   2 - hosts: lamp-memcached   3   sudo: yes   4    5   vars_files:   6     - vars.yml   7    8   roles:   9     - geerlingguy.firewall  10     - geerlingguy.memcached   As with the other servers, we need to ensure only the required TCP ports are open using the simple geerlingguy.firewall role. Next we install Memcached using the geerlingguy.memcached role.   In our vars.yml file  again, alongside main.yml , add the following:  1 ---  2 firewall_allowed_tcp_ports:  3   - "22"  4 firewall_additional_rules:  5   - "iptables -A INPUT -p tcp --dport 11211 -s {{ groups['lamp- www'][0] }} -j AC\  6 CEPT"  7   - "iptables -A INPUT -p tcp --dport 11211 -s {{ groups['lamp- www'][1] }} -j AC\  8 CEPT"   We need port 22 open for remote access, and for Memcached, we’re adding manual iptables rules to allow access on port 11211 for the web servers only. We add one rule per lamp-www server by drilling down into each item in the the generated groups variable that Ansible uses to track all inventory groups currently available.  The principle of least privilege “requires that in a particular abstraction layer of a computing environment, every module … must be able to access only the information and resources that are necessary for its legitimate purpose”  Source: Wikipedia . Always restrict services and ports to only those servers or users that need access!  MySQL  The MySQL configuration is more complex than the other servers because we need to configure MySQL users per-host and configure replication. Because we want to maintain an independent and flexible playbook, we also need to dynamically create some variables so MySQL will get the right server addresses in any potential environment.  Let’s first create the main playbook, playbooks db main.yml:   1 ---   2 - hosts: lamp-db   3   sudo: yes   4    5   vars_files:   6     - vars.yml   7    8   pre_tasks:     9     - name: Create dynamic MySQL variables.  10       set_fact:  11         mysql_users:  12           - {  13             name: mycompany_user,  14             host: "{{ groups['lamp-www'][0] }}",  15             password: secret,  16             priv: "*.*:SELECT"  17           }  18           - {  19             name: mycompany_user,  20             host: "{{ groups['lamp-www'][1] }}",  21             password: secret,  22             priv: "*.*:SELECT"  23           }  24         mysql_replication_master: "{{ groups['a4d.lamp.db.1'][0]  }}"  25   26   roles:  27     - geerlingguy.firewall  28     - geerlingguy.mysql   Most of the playbook is straightforward, but in this instance, we’re using set_fact as a pre_task  to be run before the geerlingguy.firewall and geerlingguy.mysql roles  to dynamically create variables for MySQL configuration.  set_fact allows us to define variables at runtime, so we can are guaranteed to have all server IP addresses available, even if the servers were freshly provisioned at the beginning of the playbook’s run. We’ll create two variables:  mysql_users is a list of users the geerlingguy.mysql role will create when it runs. This variable will be used on all database servers so both of the two lamp-www servers get SELECT privileges on all databases. mysql_replication_master is used to indicate to the geerlingguy.mysql role which database server is the master; it will perform certain steps differently depending on whether the server being configured is a master or slave, and ensure that all the slaves are configured to replicate data from the master.  We’ll need a few other normal variables to configure MySQL, so we’ll add them alongside the firewall variable in playbooks db vars.yml:   1 ---  2 firewall_allowed_tcp_ports:  3   - "22"  4   - "3306"  5   6 mysql_replication_user: {name: 'replication', password: 'secret'}  7 mysql_databases:  8   - { name: mycompany_database, collation: utf8_general_ci,  encoding: utf8 }   We’re opening port 3306 to anyone, but according to the principle of least privilege discussed earlier, you would be justified in restricting this port to only the servers and users that need access to MySQL  similar to the memcached server configuration . In this case, the attack vector is mitigated because MySQL’s own authentication layer is used through the mysql_user variable generated in main.yml.  We are defining two MySQL variables, mysql_replication_user to be used as for master and slave replication, and mysql_databases to define a list of databases that will be created  if they don’t already exist  on the database servers.  With the configuration of the database servers complete, the server-specific playbooks are ready to go.  Main Playbook for Configuring All Servers A simple playbook including each of the group-specific playbooks is all we need for the overall configuration to take place. Create configure.yml in the project’s root directory, with the following contents:  1 ---  2 - include: playbooks varnish main.yml  3 - include: playbooks www main.yml  4 - include: playbooks db main.yml  5 - include: playbooks memcached main.yml   At this point, if you had some already-booted servers and statically defined inventory groups like lamp-www, lamp-db, etc., you could run ansible- playbook configure.yml and you’d have a full HA infrastructure at the ready!   But we’re going to continue to make our playbooks more flexible and useful.  Getting the required roles As mentioned in the Chapter 6, Ansible allows you to define all the required Ansible Galaxy roles for a given project in a requirements.txt file. Instead of having to remember to run ansible-galaxy install -y [role1] [role2] [role3] for each of the roles we’re using, we can create requirements.txt in the root of our project, with the following contents:  1 geerlingguy.firewall  2 geerlingguy.repo-epel  3 geerlingguy.varnish  4 geerlingguy.apache  5 geerlingguy.php  6 geerlingguy.php-mysql  7 geerlingguy.php-memcached  8 geerlingguy.mysql  9 geerlingguy.memcached   To make sure all the required dependencies are installed, run ansible- galaxy install -r requirements.txt from within the project’s root.  Vagrantfile for Local Infrastructure via VirtualBox As with many other examples in this book, we can use Vagrant and VirtualBox to build and configure the infrastructure locally. This lets us test things as much as we want with zero cost, and usually results in faster testing cycles, since everything is orchestrated over a local private network on a  hopefully  beefy workstation.  Our basic Vagrantfile layout will be something like the following:  1. Define a base box  in this case, CentOS 6.x  and VM hardware  defaults.  2. Define all the VMs to be built, with VM-specific IP addresses and  hostname configurations.  3. Define the Ansible provisioner along with the last VM, so Ansible can  run once at the end of Vagrant’s build cycle.   Here’s the Vagrantfile in all its glory:   1  -*- mode: ruby -*-  2  vi: set ft=ruby :  3    4 Vagrant.configure "2"  do config  5    Base VM OS configuration.  6   config.vm.box = "geerlingguy centos6"  7   config.ssh.insert_key = false  8    9    General VirtualBox VM configuration. 10   config.vm.provider :virtualbox do v 11     v.customize ["modifyvm", :id, "--memory", 512] 12     v.customize ["modifyvm", :id, "--cpus", 1] 13     v.customize ["modifyvm", :id, "--natdnshostresolver1", "on"] 14     v.customize ["modifyvm", :id, "--ioapic", "on"] 15   end 16   17    Varnish. 18   config.vm.define "varnish" do varnish 19     varnish.vm.hostname = "varnish.dev" 20     varnish.vm.network :private_network, ip: "192.168.2.2" 21   end 22   23    Apache. 24   config.vm.define "www1" do www1 25     www1.vm.hostname = "www1.dev" 26     www1.vm.network :private_network, ip: "192.168.2.3" 27   28     www1.vm.provision "shell", 29       inline: "sudo yum update -y" 30   31     www1.vm.provider :virtualbox do v 32       v.customize ["modifyvm", :id, "--memory", 256] 33     end 34   end 35   36    Apache. 37   config.vm.define "www2" do www2 38     www2.vm.hostname = "www2.dev" 39     www2.vm.network :private_network, ip: "192.168.2.4" 40   41     www2.vm.provision "shell", 42       inline: "sudo yum update -y" 43   44     www2.vm.provider :virtualbox do v 45       v.customize ["modifyvm", :id, "--memory", 256] 46     end 47   end 48     49    MySQL. 50   config.vm.define "db1" do db1 51     db1.vm.hostname = "db1.dev" 52     db1.vm.network :private_network, ip: "192.168.2.5" 53   end 54   55    MySQL. 56   config.vm.define "db2" do db2 57     db2.vm.hostname = "db2.dev" 58     db2.vm.network :private_network, ip: "192.168.2.6" 59   end 60   61    Memcached. 62   config.vm.define "memcached" do memcached 63     memcached.vm.hostname = "memcached.dev" 64     memcached.vm.network :private_network, ip: "192.168.2.7" 65   66      Run Ansible provisioner once for all VMs at the end. 67     memcached.vm.provision "ansible" do ansible 68       ansible.playbook = "configure.yml" 69       ansible.inventory_path = "inventories vagrant inventory" 70       ansible.limit = "all" 71       ansible.extra_vars = { 72         ansible_ssh_user: 'vagrant', 73         ansible_ssh_private_key_file: "~ .vagrant.d insecure_private_key" 74       } 75     end 76   end 77 end  Most of the Vagrantfile is straightforward, and similar to other examples used in this book. The last block of code, which defines the ansible provisioner configuration, contains three extra values that are important for our purposes:  1       ansible.inventory_path = "inventories vagrant inventory" 2       ansible.limit = "all" 3       ansible.extra_vars = { 4         ansible_ssh_user: 'vagrant', 5         ansible_ssh_private_key_file: "~ .vagrant.d insecure_private_key" 6       }  1. ansible.inventory_path defines an inventory file to be used with the  ansible.playbook. You could certainly create a dynamic inventory script for use with Vagrant, but because we know the IP addresses ahead of time, and are expecting a few specially-crafted inventory   group names, it’s simpler to build the inventory file for Vagrant provisioning by hand  we’ll do this next .  2. ansible.limit is set to all so Vagrant knows it should run the  Ansible playbook connected to all VMs, and not just the current VM. You could technically use ansible.limit with a provisioner configuration for each of the individual VMs, and just run the VM- specific playbook through Vagrant, but our live production infrastructure will be using one playbook to configure all the servers, so we’ll do the same locally.  3. ansible.extra_vars contains the vagrant SSH user configuration for  Ansible. It’s more standard to include these settings in a static inventory file or use Vagrant’s automatically-generated inventory file, but it’s easiest to set them once for all servers here.  Before running vagrant up to see the fruits of our labor, we need to create an inventory file for Vagrant at inventories vagrant inventory:   1 [lamp-varnish]   2 192.168.2.2   3    4 [lamp-www]   5 192.168.2.3   6 192.168.2.4   7    8 [a4d.lamp.db.1]   9 192.168.2.5  10   11 [lamp-db]  12 192.168.2.5  13 192.168.2.6  14   15 [lamp-memcached]  16 192.168.2.7   Now cd into the project’s root directory, run vagrant up, and after ten or fifteen minutes, load http:  192.168.2.2  in your browser. Voila!   Highly Available Infrastructure - Success!  You should see something like the above screenshot; the PHP app displays the current app server’s IP address, the individual MySQL servers’ status, and the Memcached server status. Refresh the page a few times to verify Varnish is distributing requests randomly between the two app servers.  We have local infrastructure development covered, and Ansible makes it easy to use the exact same configuration to build our infrastructure in the cloud.  Provisioner Configuration: DigitalOcean In Chapter 7, we learned provisioning and configuring DigitalOcean droplets in an Ansible playbook is fairly simple. But we need to take provisioning a step further by provisioning multiple droplets  one for each server in our infrastructure  and dynamically grouping them so we can configure them after they are booted and online.  For the sake of flexibility, let’s create a playbook for our DigitalOcean droplets in provisioners digitalocean.yml. This will allow us to add other provisioner configurations later, alongside the digitalocean.yml playbook. As with our example in Chapter 7, we will use a local connection to provision cloud instances. Begin the playbook with:  1 ---  2 - hosts: localhost  3   connection: local  4   gather_facts: false   Next we need to define some metadata to describe each of our droplets. For simplicity’s sake, we’ll inline the droplets variable in this playbook:    6   vars:   7     droplets:   8       - { name: a4d.lamp.varnish, group: "lamp-varnish" }   9       - { name: a4d.lamp.www.1, group: "lamp-www" }  10       - { name: a4d.lamp.www.2, group: "lamp-www" }  11       - { name: a4d.lamp.db.1, group: "lamp-db" }  12       - { name: a4d.lamp.db.2, group: "lamp-db" }  13       - { name: a4d.lamp.memcached, group: "lamp-memcached" }   Each droplet is an object with two keys:  name: The name of the Droplet for DigitalOcean’s listings and Ansible’s host inventory. group: The Ansible inventory group for the droplet.  Next we need to add a task to create the droplets, using the droplets list as a guide, and as part of the same task, register each droplet’s information in a separate dictionary, created_droplets:  15   tasks:  16     - name: Provision DigitalOcean droplets.  17       digital_ocean:  18         state: "{{ item.state  default 'present'  }}"  19         command: droplet  20         name: "{{ item.name }}"  21         private_networking: yes  22         size_id: "{{ item.size  default 66  }}"  512mb  23         image_id: "{{ item.image  default 6372108  }}"  CentOS  6 x64.  24         region_id: "{{ item.region  default 4  }}"  NYC2  25         ssh_key_ids: "{{ item.ssh_key  default '138954'  }}"   geerlingguy  26         unique_name: yes  27       register: created_droplets  28       with_items: droplets   Many of the options  e.g. size_id  are defined as {{ item.property  default 'default_value'  }}, which allows us to use optional variables per droplet. For any of the defined droplets, we could add size_id: 72  or whatever valid value you’d like , and it would override the default value set in the task.   You could specify an SSH public key per droplet, or  as in this instance  use the same key for all hosts by providing a default. In this case, I added an SSH key to my DigitalOcean account, then used the DigitalOcean API to retrieve the key’s numeric ID  as described in the previous chapter .  It’s best to use key-based authentication and add at least one SSH key to your DigitalOcean account so Ansible can connect using keys instead of insecure passwords, especially since these instances will be created with only a root account.  We loop through all the defined droplets using with_items: droplets, and after each droplet is created add the droplet’s metadata  name, IP address, etc.  to the created_droplets variable. Next, we’ll loop through that variable to build our inventory on-the-fly so our configuration applies to the correct servers:  30     - name: Add DigitalOcean hosts to their respective inventory  groups.  31       add_host:  32         name: "{{ item.1.droplet.ip_address }}"  33         groups: "do,{{ droplets[item.0].group }},{{  item.1.droplet.name }}"  34          You can dynamically add inventory variables per-host.  35         ansible_ssh_user: root  36         mysql_replication_role: >  37           "{{ 'master' if  item.1.droplet.name ==  'a4d.lamp.db.1'   38           else 'slave' }}"  39         mysql_server_id: "{{ item.0 }}"  40       when: item.1.droplet is defined  41       with_indexed_items: created_droplets.results   You’ll notice a few interesting things happening in this task:  This is the first time we’ve used with_indexed_items. The reason for using this less-common loop feature is to add a sequential and unique mysql_server_id. Though only the MySQL servers need a server ID set, it’s simplest to dynamically create the variable for every server, so it’s available when needed. with_indexed_items sets item.0 to the key of the item, and item.1 to the value of the item. with_indexed_items also helps us reliably set each droplet’s group. Because the v1 DigitalOcean API doesn’t support features like tags for   Droplets, we need to set up the groups on our own. Using the droplets variable we manually created earlier allows us to set the proper group for a particular droplet. Finally we add inventory variables per-host in add_host by adding the variable name as a key, and the variable value as the key’s value. Simple, but powerful!  There are a few different ways you can approach dynamic provisioning and inventory management for your infrastructure, and, especially if you are only targeting one cloud hosting provider, there are ways to avoid using more exotic features of Ansible  e.g. with_indexed_items  and complex if else conditions. This example is slightly more complex due to the fact that the playbook is being created to be interchangeable with other similar provisioning playbooks.  The final step in our provisioning is to make sure all the droplets are booted and can be reached via SSH, so at the end of the digitalocean.yml playbook, add another play to be run on hosts in the do group we just defined:  43 - hosts: do  44   remote_user: root  45   gather_facts: no  46   47   tasks:  48     - name: Wait for port 22 to become available.  49       local_action: "wait_for port=22 host={{ inventory_hostname  }}"   Once we know port 22 is reachable, we know the droplet is up and ready for configuration.  We’re almost ready to provision and configure our entire infrastructure on DigitalOcean, but we need to create one last playbook to tie everything together. Create provision.yml in the project root with the following contents:  1 ---  2 - include: provisioners digitalocean.yml  3 - include: configure.yml    That’s it! Now, assuming you set the environment variables DO_CLIENT_ID and DO_API_KEY, you can run $ ansible-playbook provision.yml to provision and configure the infrastructure on DigitalOcean.  The entire process should take about 15 minutes, and once it’s complete, you should see something like:  PLAY RECAP  *****************************************************************  107.170.27.137             : ok=19   changed=13   unreachable=0     failed=0  107.170.3.23               : ok=13   changed=8    unreachable=0     failed=0  107.170.51.216             : ok=40   changed=18   unreachable=0     failed=0  107.170.54.218             : ok=27   changed=16   unreachable=0     failed=0  162.243.20.29              : ok=24   changed=15   unreachable=0     failed=0  192.241.181.197            : ok=40   changed=18   unreachable=0     failed=0  localhost                  : ok=2    changed=1    unreachable=0     failed=0   Visit the IP address of the varnish server and you should be greeted with a status page similar to the one generated by the Vagrant-based infrastructure:  Highly Available Infrastructure on DigitalOcean.  Because everything in this playbook is idempotent, running $ ansible- playbook provision.yml again should report no changes, and helps you verify that everything is running correctly.  Ansible will also rebuild and reconfigure any droplets that may be missing from your infrastructure. If you’re daring, and want to test this feature, just log into your DigitalOcean account, delete one of the droplets just created   by this playbook  maybe one of the two app servers , then run the playbook again.  Now that we’ve tested our infrastructure on DigitalOcean, we can destroy the droplets just as easily  change the state parameter in provisioners digitalocean.yml to default to 'absent' and run $ ansible-playbook provision.yml again .  Next up, we’ll build the infrastructure a third time—on Amazon’s infrastructure.  Provisioner Configuration: Amazon Web Services  EC2  For Amazon Web Services, provisioning works slightly different. Amazon has a broader ecosystem of services surrounding EC2 instances, and for our particular example, we will need to configure security groups prior to provisioning instances.  To begin, create aws.yml inside the provisioners directory and begin the playbook the same ways as with DigitalOcean:  1 ---  2 - hosts: localhost  3   connection: local  4   gather_facts: false   EC2 instances use security groups as an AWS-level firewall  which operates outside the individual instance’s OS . We will need to define a list of security_groups alongside our EC2 instances. First, the instances:   6   vars:   7     instances:   8       - {   9         name: a4d.lamp.varnish,  10         group: "lamp-varnish",  11         security_group: ["default", "a4d_lamp_http"]  12       }  13       - {  14         name: a4d.lamp.www.1,  15         group: "lamp-www",  16         security_group: ["default", "a4d_lamp_http"]  17       }  18       - {    19         name: a4d.lamp.www.2,  20         group: "lamp-www",  21         security_group: ["default", "a4d_lamp_http"]  22       }  23       - {  24         name: a4d.lamp.db.1,  25         group: "lamp-db",  26         security_group: ["default", "a4d_lamp_db"]  27       }  28       - {  29         name: a4d.lamp.db.2,  30         group: "lamp-db",  31         security_group: ["default", "a4d_lamp_db"]  32       }  33       - {  34         name: a4d.lamp.memcached,  35         group: "lamp-memcached",  36         security_group: ["default", "a4d_lamp_memcached"]  37       }   Inside the instances variable, each instance is an object with three keys:  name: The name of the instance, which we’ll use to tag the instance and ensure only one instance is created per name. group: The Ansible inventory group in which the instance should belong. security_group: A list of security groups into which the instance will be placed. The default security group comes is added to your AWS account upon creation, and has one rule to allow outgoing traffic on any port to any IP address.  If you use AWS exclusively, it would be best to autoscaling groups and change the design of this infrastructure a bit. For this example, we just need to ensure that the six instances we explicitly define are created, so we’re using particular names and an exact_count to enforce the 1:1 relationship.  With our instances defined, we’ll next define a security_groups variable containing all the required security group configuration for each server:  39     security_groups:  40       - name: a4d_lamp_http  41         rules:  42           - { proto: tcp, from_port: 80, to_port: 80, cidr_ip:    0.0.0.0 0 }  43           - { proto: tcp, from_port: 22, to_port: 22, cidr_ip:  0.0.0.0 0 }  44         rules_egress: []  45       - name: a4d_lamp_db  46         rules:  47           - { proto: tcp, from_port: 3306, to_port: 3306,  cidr_ip: 0.0.0.0 0 }  48           - { proto: tcp, from_port: 22, to_port: 22, cidr_ip:  0.0.0.0 0 }  49         rules_egress: []  50       - name: a4d_lamp_memcached  51         rules:  52           - { proto: tcp, from_port: 11211, to_port: 11211,  cidr_ip: 0.0.0.0 0 }  53           - { proto: tcp, from_port: 22, to_port: 22, cidr_ip:  0.0.0.0 0 }  54         rules_egress: []   Each security group has a name  which was used to identify the security group in the instances list , rules  a list of firewall rules like protocol, ports, and IP ranges to limit incoming traffic , and rules_egress  a list of firewall rules to limit outgoing traffic .  We need three security groups: a4d_lamp_http to open port 80, a4d_lamp_db to open port 3306, and a4d_lamp_memcached to open port 11211.  Now that we have all the data we need to set up security groups and instances, the first task needs to to create or verify the existence of the security groups:  56   tasks:  57     - name: Configure EC2 Security Groups.  58       ec2_group:  59         name: "{{ item.name }}"  60         description: Example EC2 security group for A4D.  61         region: "{{ item.region  default 'us-west-2'  }}"   Oregon  62         state: present  63         rules: "{{ item.rules }}"  64         rules_egress: "{{ item.rules_egress }}"  65       with_items: security_groups    The ec2_group requires a name, region, and rules for each security group. Security groups will be created if they don’t exist, modified to match the supplied values if they do exist, or verified if they exist and match the given values.  With the security groups configured, we can provision the defined EC2 instances by looping through instances with the ec2 module:  67     - name: Provision EC2 instances.  68       ec2:  69         key_name: "{{ item.ssh_key  default 'jeff_mba_home'  }}"  70         instance_tags:  71           inventory_group: "{{ item.group  default ''  }}"  72           inventory_host: "{{ item.name  default ''  }}"  73         group: "{{ item.security_group  default ''  }}"  74         instance_type: "{{ item.type  default 't2.micro' }}"   Free Tier  75         image: "{{ item.image  default 'ami-11125e21'  }}"   RHEL6 x64 hvm  76         region: "{{ item.region  default 'us-west-2'  }}"   Oregon  77         wait: yes  78         wait_timeout: 500  79         exact_count: 1  80         count_tag:  81           inventory_group: "{{ item.group  default ''  }}"  82           inventory_host: "{{ item.name  default ''  }}"  83       register: created_instances  84       with_items: instances   This example is slightly more complex than the DigitalOcean example, and a few parts warrant a deeper look:  EC2 allows SSH keys to be defined by name—in my case, I have a key jeff_mba_home in my AWS account. You should set the key_name default to a key that you have in your account. Instance tags are tags that AWS will attach to your instance, for categorization purposes. By giving a list of keys and values, I can then use that list later in the count_tag parameter. t2.micro was used as the default instance type, since it falls within EC2’s free tier usage. If you just set up an account and keep all AWS resource usage within free tier limits, you won’t be billed anything.   exact_count and count_tag work together to ensure AWS provisions only one of each of the instances we defined. The count_tag tells the ec2 module to match the given group + host and then exact_count tells the module to only provision 1 instance. If you wanted to remove all your instances, you could set exact_count to 0 and run the playbook again.  Each provisioned instance will have its metadata added to the registered created_instances variable, which we’ll use to build Ansible inventory groups for the server configuration playbooks.  86     - name: Add EC2 instances to their respective inventory  groups.  87       add_host:  88         name: "{{ item.1.tagged_instances.0.public_ip }}"  89         groups: "aws,{{ item.1.item.group }},{{ item.1.item.name  }}"  90          You can dynamically add inventory variables per-host.  91         ansible_ssh_user: ec2-user  92         mysql_replication_role: >  93           {{ 'master' if  item.1.item.name == 'a4d.lamp.db.1'   94           else 'slave' }}  95         mysql_server_id: "{{ item.0 }}"  96       when: item.1.instances is defined  97       with_indexed_items: created_instances.results   This add_host example is slightly simpler than the one for DigitalOcean, because AWS attaches metadata to EC2 instances which we can re-use when building groups or hostnames  e.g. item.1.item.group . We don’t have to use list indexes to fetch group names from the original instances variable.  We still use with_indexed_items so we can use the index to generate a unique ID per server for use in building the MySQL master-slave replication.  The final step in provisioning the EC2 instances is to ensure we can connect to them before continuing, and to set selinux into permissive mode so the configuration we supply will work correctly.  86  Run some general configuration on all AWS hosts.  87 - hosts: aws    88   gather_facts: false  89   90   tasks:  91     - name: Wait for port 22 to become available.  92       local_action: "wait_for port=22 host={{ inventory_hostname  }}"  93   94     - name: Set selinux into 'permissive' mode.  95       selinux: policy=targeted state=permissive  96       sudo: yes   Since we defined ansible_ssh_user as ec2-user in the dynamically- generated inventory above, we need to ensure the selinux task runs with sudo explicitly.  Now, modify the provision.yml file in the root of the project folder, and change the provisioners include to look like the following:  1 ---  2 - include: provisioners aws.yml  3 - include: configure.yml   Assuming the environment variables AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY are set in your current terminal session, you can run $ ansible-playbook provision.yml to provision and configure the infrastructure on AWS.  The entire process should take about 15 minutes, and once it’s complete, you should see something like:  PLAY RECAP  *****************************************************************  54.148.100.44              : ok=24   changed=16   unreachable=0     failed=0  54.148.120.23              : ok=40   changed=19   unreachable=0     failed=0  54.148.41.134              : ok=40   changed=19   unreachable=0     failed=0  54.148.56.137              : ok=13   changed=9    unreachable=0     failed=0  54.69.160.32               : ok=27   changed=17   unreachable=0     failed=0  54.69.86.187               : ok=19   changed=14   unreachable=0     failed=0    localhost                  : ok=3    changed=1    unreachable=0     failed=0   Visit the IP address of the varnish server  the first server configured  and you should be greeted with a status page similar to the one generated by the Vagrant and DigitalOcean-based infrastructure:  Highly Available Infrastructure on AWS EC2.  As with the earlier examples, running ansible-playbook provision.yml again should produce no changes, because everything in this playbook is idempotent. And if one of your instances were terminated, running the playbook again would recreate and reconfigure the instance in a few minutes.  To terminate all the provisioned instances, you can change the exact_count in the ec2 task to 0, and run $ ansible-playbook provision.yml again.  Summary In the above example, an entire highly-available PHP application infrastructure was defined in a series of short Ansible playbooks, and then provisioning configuration was created to build the infrastructure on either local VMs, DigitalOcean droplets, or AWS EC2 instances.  Once you start working on building infrastructure this way—abstracting individual servers, then abstracting cloud provisioning—you’ll start to see some of Ansible’s true power in being more than just a configuration management tool. Imagine being able to create your own multi-datacenter, multi-provider infrastructure with Ansible and some basic configuration.  While Amazon, DigitalOcean, Rackspace and other hosting providers have their own tooling and unique infrastructure merits, the agility and flexibility   afforded by building infrastructure in a provider-agnostic fashion lets you treat hosting providers as commodities, and gives you freedom to build more reliable, performant, and simple application infrastructure.  Even if you plan on running everything within one hosting provider’s network  or in a private cloud, or even on a few bare metal servers , Ansible provides deep stack-specific integration so you can do whatever you need to do and manage the provider’s services within your playbooks.  You can find the entire contents of this example in the Ansible for DevOps GitHub repository, in the lamp-infrastructure directory.  ELK Logging with Ansible Though application, database, and backup servers may be some of the most mission-critical components of a well-rounded infrastructure, one area that is equally important is a decent logging system.  In the old days, when one or two servers could handle an entire website or application, you could work with built-in logfiles and rsyslog to troubleshoot an issue or check trends in performance, errors, or overall traffic. With a typical modern infrastructure—like the example above, with six separate servers—it pays dividends to find a better solution for application, server, and firewall authentication logging. Plain text files, logrotate, and grep don’t cut it anymore.  Among various modern logging and reporting toolsets, the ‘ELK’ stack  Elasticsearch, Logstash, and Kibana  has come to the fore as one of the best-performing and easiest-to-configure open source centralized logging solutions.   An example Kibana logging dashboard.  In our example, we’ll configure a single ELK server to handle aggregation, searching, and graphical display of logged data from a variety of other servers, and give some common configuration examples to send common system logs, webserver logs, etc.  ELK Playbook Just like our previous example, we’re going to let a few roles from Ansible Galaxy do the heavy lifting of actually installing and configuring Elasticsearch, Logstash, and Kibana. If you’re interested in reading through the roles that do this work, feel free to peruse them after you’ve downloaded them.  In this example, rather than walking through each role and variable in detail, I’m going to highlight the important parts, but then jump immediately into how you can use this base server to aggregate logs, then how to point your other servers’ log files to it using Logstash Forwarder.  Here’s our main playbook, saved as provisioning elk playbook.yml:   1 - hosts: logs   2   gather_facts: yes   3    4   vars_files:   5     - vars main.yml   6      7   pre_tasks:   8     - name: Update apt cache if needed.   9       apt: update_cache=yes cache_valid_time=86400  10   11   roles:  12     - geerlingguy.java  13     - geerlingguy.nginx  14     - geerlingguy.elasticsearch  15     - geerlingguy.elasticsearch-curator  16     - geerlingguy.kibana  17     - geerlingguy.logstash  18     - geerlingguy.logstash-forwarder   This assumes you have a logs group in your inventory with at least one server listed. The playbook includes a vars file located in provisioning elk vars main.yml, so create that file, and then put the following inside:   1 ---   2 java_packages:   3   - openjdk-7-jdk   4    5 nginx_user: www-data   6 nginx_worker_connections: 1024   7 nginx_remove_default_vhost: true   8    9 kibana_server_name: logs  10 kibana_username: kibana  11 kibana_password: password  12   13 logstash_monitor_local_syslog: false  14 logstash_forwarder_files:  15   - paths:  16       -  var log auth.log  17     fields:  18       type: syslog   You’ll want to use a different password besides ‘password’ for kibana_password. Other options are straightforward, with the exception of the two logstash_* variables.  The first variable tells the geerlingguy.logstash role to ignore the local syslog file  in this case, we’re only interested in logging authorization attempts through the local auth.log .   The second variable gives the geerlingguy.logstash-forwarder role a list of files to monitor, along with metadata to tell logstash what kind of file is being monitored. In this case, we are only worried about the auth.log file, and we know it’s a syslog-style file.  Logstash needs to know what kind of file you’re monitoring so it can parse the logged messages correctly .  If you want to get this ELK server up and running quickly, you can create a local VM using Vagrant like you have in most other examples in the book. Create a Vagrantfile in the same directory as the provisioning folder, with the following contents:   1  -*- mode: ruby -*-  2  vi: set ft=ruby :  3    4 VAGRANTFILE_API_VERSION = "2"  5    6 Vagrant.configure VAGRANTFILE_API_VERSION  do config  7   config.vm.box = "geerlingguy ubuntu1204"  8    9   config.vm.provider :virtualbox do v 10     v.customize ["modifyvm", :id, "--natdnshostresolver1", "on"] 11     v.customize ["modifyvm", :id, "--memory", 1024] 12     v.customize ["modifyvm", :id, "--cpus", 2] 13     v.customize ["modifyvm", :id, "--ioapic", "on"] 14   end 15   16    ELK server. 17   config.vm.define "logs" do logs 18     logs.vm.hostname = "logs" 19     logs.vm.network :private_network, ip: "192.168.9.90" 20   21     logs.vm.provision :ansible do ansible 22       ansible.playbook = "provisioning elk playbook.yml" 23       ansible.inventory_path = "provisioning elk inventory" 24       ansible.sudo = true 25     end 26   end 27   28 end  This Vagrant configuration expects an inventory file at provisioning elk inventory, so quickly create one with the following contents:  1 logs ansible_ssh_host=192.168.9.90 ansible_ssh_port=22    Now, run vagrant up. The build should take about five minutes, and upon completion, if you add a line like logs 192.168.9.90 to your  etc hosts file, you can visit http:  logs  in your browser and see Kibana’s default homepage:  Kibana’s default homepage.  Kibana helpfully links to an example dashboard for Logstash  under the “Are you a Logstash User?” section , and if you select it, you should see a live dashboard that shows logged activity for the past day:  Kibana’s default Logstash dashboard.   This example won’t dive too deep into customizing Kibana’s dashboard customization, since there are many guides to using Kibana available freely, including Kibana’s official guide. For our purposes, we’ll use the default dashboard.  This example uses Kibana 3.x, but a stable release of Kibana 4.x is on the horizon  as of early 2015 . Some of the screenshots may show a different interface than the latest release, but this book will likely be updated with newer screenshots and updated guides once the 4.x release comes out.  Forwarding Logs from Other Servers It’s great that we have the ELK stack running; Elasticsearch will store and make available log data with one search index per day, Logstash will listening for log entries, Logstash Forwarder will send entries in  var log auth.log to Logstash, and Kibana will organize the logged data with useful visualizations.  Configuring additional servers to direct their logs to our new Logstash server is fairly simple using Logstash Forwarder. The basic steps we’ll follow are:  1. Set up another server in the Vagrantfile. 2. Set up an Ansible playbook to install and configure Logstash  Forwarder alongside the application running on the server.  3. Boot the server and watch as the logs are forwarded to the main ELK  server.  Let’s begin by creating a new Nginx web server. It’s useful to monitor webserver access logs for a variety of reasons, not the least of which is to watch for traffic spikes and increases in non-200 responses for certain resources. Add the following server definition inside the Vagrantfile, just after the end of the ELK server definition:  28    Web server. 29   config.vm.define "webs" do webs 30     webs.vm.hostname = "webs" 31     webs.vm.network :private_network, ip: "192.168.9.91"   32   33     webs.vm.provision :ansible do ansible 34       ansible.playbook = "provisioning web playbook.yml" 35       ansible.inventory_path = "provisioning web inventory" 36       ansible.sudo = true 37     end 38   end  We’ll next set up the simple playbook to install and configure both Nginx and Logstash Forwarder, at provisioning web playbook.yml:   1 - hosts: webs   2   gather_facts: yes   3    4   vars_files:   5     - vars main.yml   6    7   pre_tasks:   8     - name: Update apt cache if needed.   9       apt: update_cache=yes cache_valid_time=86400  10   11   roles:  12     - geerlingguy.nginx  13     - geerlingguy.logstash-forwarder  14   15   tasks:  16     - name: Set up virtual host for testing.  17       copy:  18         src: files example.conf  19         dest:  etc nginx conf.d example.conf  20         owner: root  21         group: root  22         mode: 0644  23       notify: restart nginx   This playbook installs the geerlingguy.nginx and geerlingguy.logstash-forwarder roles, and in the tasks, there is an additional task to configure one virtualhost in a Nginx configuration directory, via the file example.conf. Create that file now  at the path provisioning web files example.conf , and define one Nginx virtualhost for our testing:  1 server {  2   listen 80 default_server;  3   4   root  usr share nginx www;  5   index index.html index.htm;    6   7   access_log  var log nginx access.log combined;  8   error_log  var log nginx error.log debug;  9 }   Since this is the only server definition, and it’s set as the default_server on port 80, all requests will be directed to it. We routed the access_log to  var log nginx access.log, and told Nginx to write log entries using the combined format, which is what our Logstash server will expect for nginx access logs.  Next, set up the required variables to tell the nginx and logstash- forwarder roles how to configure their respective services. Inside provisioning web vars main.yml:   1 ---   2 nginx_user: www-data   3 nginx_worker_connections: 1024   4 nginx_remove_default_vhost: true   5    6 logstash_forwarder_logstash_server: 192.168.9.90   7 logstash_forwarder_logstash_server_port: 5000   8    9 logstash_forwarder_files:  10   - paths:  11       -  var log secure  12     fields:  13       type: syslog  14   - paths:  15       -  var log nginx access.log  16     fields:  17       type: nginx   The nginx variables ensure Nginx will run optimally on our Ubuntu server, and remove the default virtualhost entry. The logstash_forwarder variables tell geerlingguy.logstash-forwarder what logs to forward to our central log server:  logstash_forwarder_logstash_server and _port: Defines the server IP or domain and port to which logs should be transported. logstash_forwarder_files: Defines a list of paths and fields, which identify a file or list of files to be transported to the log server, along with a type for the files. In this case, the authentication log     var log secure  is a syslog-formatted log file, and  var log nginx access.log is of type nginx  which will be parsed correctly on the Logstash server since it’s in the combined log format popularized by Apache .  Note that this demonstration configuration is not using a custom certificate to authenticate logging connections. You should normally configure your own secure certificate and give the logstash-forwarder role the path to the certificate using the logstash_forwarder_ssl_certificate_file variable. If you use the example provided with the project, you could expose your logging infrastructure to the outside, plus you’ll get a ***SECURITY RISK*** warning in the logs every time the Logstash role is run.  To allow Vagrant to pass the proper connection details to Ansible, create provisioning web inventory with the webs host details:  1 webs ansible_ssh_host=192.168.9.91 ansible_ssh_port=22   Run vagrant up again. Vagrant should verify that the first server  logs  is running, then create and run the Ansible provisioner on the newly-defined webs Nginx server.  You can load http:  192.168.9.91  or http:  webs  in your browser, and you should see a Welcome to nginx! message on the page. You can refresh the page a few times, then switch back over to http:  logs  to view some new log entries on the ELK server:   Entries populating the Logstash Search Kibana dashboard.  If you refresh the page a few times, and no entries show up in the Kibana Logstash dashboard, it could be that Nginx is buffering the log entries. In this case, keep refreshing a while  so you generate a few dozen or hundred entries , and Nginx will eventually write the entries to disk  thus allowing Logstash Forwarder to convey the logs to the Logstash server . Read more about Nginx log buffering in the Nginx’s ngx_http_log_module documentation.  A few requests being logged through logstash forwarder isn’t all that exciting. Let’s use the popular ab tool available most anywhere to put some load on the web server. On a modest MacBook Air, running the command below resulted in Nginx serving around 1,200 requests per second.  ab -n 20000 -c 50 http:  webs    During the course of the load test, I set Kibana to show only the past 5 minutes of log data, automatically refreshed every 5 seconds, and I could monitor the requests on the ELK server just a few seconds after they were served by Nginx:   Monitoring a deluge of Nginx requests in near-realtime.  Logstash Forwarder uses a highly-efficient TCP-like protocol, Lumberjack, to transmit log entries securely between servers. With the right tuning and scaling, you can efficiently process and display thousands of requests per second across your infrastructure! For most, even the simple example demonstrated above would adequately cover an entire infrastructure’s logging and log analysis needs.  Summary Log aggregation and analysis are two fields that see constant improvements and innovation. There are many SaaS products and proprietary solutions that can assist with logging, but few match the flexibility, security, and TCO of Elasticsearch, Logstash and Kibana.  Ansible is the simplest way to configure an ELK server and direct all your infrastructure’s pertinent log data to the server.  GlusterFS Distributed File System Configuration with Ansible Modern infrastructure often involves some amount of horizontal scaling; instead of having one giant server, with one storage volume, one database,   one application instance, etc., most apps use two, four, ten, or dozens of servers.  Monitoring a deluge of Nginx requests in near-realtime.  Many applications can be scaled horizontally with ease, but what happens when you need shared resources, like files, application code, or other transient data, to be shared on all the servers? And how do you have this data scale out with your infrastructure, in a fast but reliable way? There are many different approaches to synchronizing or distributing files across servers:  Set up rsync either on cron or via inotify to synchronize smaller sets of files on a regular basis. Store everything in a code repository  e.g. Git, SVN, etc.  and deploy files to each server using Ansible. Have one large volume on a file server and mount it via NFS or some other file sharing protocol. Have one master SAN that’s mounted on each of the servers. Use a distributed file system, like Gluster, Lustre, Fraunhofer, or Ceph.  Some options are easier to set up than others, and all have benefits—and drawbacks. Rsync, git, or NFS offer simple initial setup, and low impact on filesystem performance  in many scenarios . But if you need more flexibility and scalability, less network overhead, and greater fault   tolerance, you will have to consider something that requires more configuration  e.g. a distributed file system  and or more hardware  e.g. a SAN .  GlusterFS is licensed under the AGPL license, has good documentation, and a fairly active support community  especially in the gluster IRC channel . But to someone new to distributed file systems, it can be daunting to get set it up the first time.  Configuring Gluster - Basic Overview To get Gluster working on a basic two-server setup  so you can have one folder that’s synchronized and replicated across the two servers—allowing one server to go down completely, and the other to still have access to the files , you need to do the following:  1. Install Gluster server and client on each server, and start the server  2.  On both servers  Create a ‘brick’ directory  where Gluster will store  daemon.  files for a given volume .  3.  On both servers  Create a directory to be used as a mount point  a  directory where you’ll have Gluster mount the shared volume .  4.  On both servers  Use gluster peer probe to have Gluster connect to  5.  On one server  Use gluster volume create to create a new Gluster  6.  On one server  Use gluster volume start to start the new Gluster  the other server.  volume.  volume.  7.  On both servers  Mount the gluster volume  adding a record to   etc fstab to make the mount permanent .  Additionally, you need to make sure you have the following ports open on both servers  so Gluster can communicate : TCP ports 111, 24007-24011, 49152-49153, and UDP port 111.  You need to add an additional TCP port in the 49xxx range for each extra server in your Gluster cluster.   Configuring Gluster with Ansible   The following example is adapted from the gluster.yml file I’m using for my Raspberry Pi Dramble cluster  a cluster of Raspberry Pis running a Drupal website .  First, we need to punch a hole in the firewall for all the required ports. I am using the geerlingguy.firewall role on all my servers, so in my vars files, I added:  firewall_allowed_tcp_ports:    - 22    - 80     For Gluster.    - 111     Port-mapper for Gluster 3.4+.     - 2049     Gluster Daemon.    - 24007     24009+ for Gluster <= 3.3; 49152+ for Gluster 3.4+  one port  per server .    - 24009    - 24010    - 24011     Gluster inline NFS server.    - 38465    - 38466    - 38467  firewall_allowed_udp_ports:    - 111   Next, I’ll include the geerlingguy.glusterfs role in my playbook to install GlusterFS on my servers  like most of the geerlingguy.* roles, this role works with Debian, Ubuntu, RedHat, and CentOS :  Then, I include a separate task include file with the Gluster configuration in my main playbook:  roles:    - geerlingguy.firewall    - geerlingguy.glusterfs   tasks:    - include: gluster.yml   Inside that file:    1 ---   2 - name: Ensure Gluster brick and mount directories exist.   3   file:   4     path: "{{ item }}"   5     state: directory   6     owner: root   7     group: www-data   8     mode: 0775   9   with_items:  10     - "{{ gluster_brick_dir }}"  11     - "{{ gluster_mount_dir }}"  12   13  Gluster volume configuration.  14 - name: Check if Gluster volumes already exist.  15   shell: "gluster volume info"  16   changed_when: false  17   register: gluster_volume_info  18   19 - name: Connect to Gluster peers.  20   shell: "gluster peer probe {{ item }}"  21   register: gluster_peer_probe  22   changed_when: "'already in peer list' not in  gluster_peer_probe.stdout"  23   failed_when: false  24   with_items: groups.webservers  25   when: "'Volume Name: gluster' not in  gluster_volume_info.stdout"  26   27 - name: Create Gluster volume.  28   shell: "gluster volume create {{ gluster_brick_name }} {{  gluster_brick_config\  29  }}"  30   register: gluster_volume_create  31   changed_when: "'successful' in gluster_volume_create.stdout"  32   when:  33     "inventory_hostname == groups.webservers[0]  34     and 'Volume Name: gluster' not in gluster_volume_info.stdout"  35   36 - name: Ensure Gluster volume is started.  37   shell: "gluster volume start {{ gluster_brick_name }}"  38   register: gluster_volume_start  39   changed_when: "'successful' in gluster_volume_start.stdout"  40   when:  41     "inventory_hostname == groups.webservers[0]  42     and 'Volume Name: gluster' not in gluster_volume_info.stdout"  43   44  Mount configuration.  45 - name: Ensure the Gluster volume is mounted.  46   mount:  47     name: "{{ gluster_mount_dir }}"    48     src: "{{ groups.webservers[0] }}: {{ gluster_brick_name }}"  49     fstype: glusterfs  50     opts: "defaults,_netdev"  51     state: mounted   The first task ensures the brick and mount directories exist and have the appropriate permissions for our application. Next, gluster peer probe links all the servers together. Then, on only one of the servers  in this case, the first of the webservers inventory group , the Gluster volume is created and started.  Finally, an entry is added to  etc fstab and then the volume is mounted at gluster_mount_dir  using Ansible’s mount module, which configures  etc fstab and mounts the volume for us .  There were a few different Jinja2 variables I used to make the Gluster configuration and volume mounting simple and flexible  a task include like this is very flexible and could be used for many different server configurations . Define these variables separately, like so:  1 gluster_mount_dir:  mnt gluster  2 gluster_brick_dir:  srv gluster brick  3 gluster_brick_name: gluster  4  Note: This is hardcoded for 2 webservers. Adjust accordingly.  5 gluster_brick_config:  6   "replica 2 transport tcp  7   {{ groups.webservers[0] }}:{{ gluster_brick_dir }}  8   {{ groups.webservers[1] }}:{{ gluster_brick_dir }}"   Most of these vars are self-explanatory, but the gluster_brick_config variable deserves a little more explanation. That variable tells Gluster to set up two replicas  one full replica on each server , using the tcp transport method, then it lists each server that will have a share of the volume, followed by the path to that share.  If you have two servers, this should work perfectly. If you have three servers, you will need to adjust the configuration to either use three replicas or use a different data partitioning scheme. If you have four or more servers, you just need an even number of replicas to allow Gluster to replicate data appropriately.   Summary Deploying distributed file systems like Gluster can seem challenging, but Ansible simplifies the process, and more importantly, does so idempotently; each time you run the playbook again, it will ensure everything stays configured as you’ve set it.  Ansible 1.9.x’s inclusion of the gluster_volume module will make this process even simpler, since the built-in module will handle edge cases and general configuration even better than we did above.  You can view this configuration in its full context in the Raspberry Pi Dramble project on GitHub  see, specifically, the file playbooks web gluster.yml .  Mac Provisioning with Ansible and Homebrew The next example will be specific to the Mac  since that’s the author’s platform of choice , but the principle behind it applies universally. How many times have you wanted to hit the ‘reset’ button on your day-to-day workstation or personal computer? How much time to you spend automating configuration and testing of applications and infrastructure at your day job, and how little do you spend automating your own local environment?  Over the past few years, as I’ve gone through four Macs  one personal, three employer-provided , I decided to start fresh on each new Mac  rather than transfer all my cruft from my old Mac to my new Mac through Apple’s Migration Assistant . I had a problem, though; I had to spend at least 4-6 hours on each Mac, downloading, installing, and configuring everything. Another problem: since I actively used at least two separate Macs, I had to manually install and configure new software on both Macs whenever I wanted to try a new tool.  To restore order to this madness, I wrapped up all the configuration I could into a set of dotfiles and used git to synchronize the dotfiles to all my workstations.   However, even with the assistance of Homebrew, a great package manager for OS X, there was still a lot of manual labor involved in installing and configuring my favorite apps and command line tools.  Running Ansible playbooks locally We’ve seen examples of running playbooks with connection: local earlier, when provisioning virtual machines in the cloud through our local workstation; but you can perform any Ansible task using a local connection. This is how we’ll configure our local workstation using Ansible.  I usually begin building a playbook with the basic scaffolding in place, and fill in details as I go. You can follow along by creating the playbook main.yml with:   1 ---   2 - hosts: localhost   3   user: jgeerling   4   connection: local   5    6   vars_files:   7     - vars main.yml   8    9   roles: []  10   11   tasks: []   We’ll store any variables we need in the included vars main.yml file. The user is set to my local user account, in this case, jgeerling, so file permissions are set for my account, and tasks are run under my own account to minimize surprises.  If certain tasks need to be run with sudo privileges, you can add sudo: yes to the task, and either run the playbook with --ask-sudo-pass  in which case, Ansible will prompt you for your sudo password before running the playbook , or run the playbook normally, and wait for Ansible to prompt you for your sudo password.  Automating Homebrew package and app management   Since I use Homebrew  billed as “the missing package manager for OS X”  for most of my application installation and configuration, I created the role geerlingguy.homebrew, which installs homebrew, then installs all the applications and packages I configure in a few simple variables.  The next step, then, is to add the Homebrew role and configure the required variables. Inside main.yml, update the roles section:   9   roles:  10     - geerlingguy.homebrew   Then add the following into vars main.yml:   1 ---   2 homebrew_installed_packages:   3   - ansible   4   - sqlite   5   - mysql   6   - php56   7   - python   8   - ssh-copy-id   9   - cowsay  10   - pv  11   - drush  12   - wget  13   - brew-cask  14   15 homebrew_taps:  16   - caskroom cask  17   - homebrew binary  18   - homebrew dupes  19   - homebrew php  20   - homebrew versions  21   22 homebrew_cask_appdir:  Applications  23 homebrew_cask_apps:  24   - google-chrome  25   - firefox  26   - sequel-pro  27   - sublime-text  28   - vagrant  29   - vagrant-manager  30   - virtualbox   Homebrew has a few tricks up its sleeve, like being able to manage general packages like PHP, MySQL, Python, Pipe Viewer, etc. natively  using   commands like brew install [package] and brew uninstall package , and can also install and manage general application installation for many Mac apps, like Chrome, Firefox, VLC, etc. using brew cask.  To anyone who’s set up a new Mac the old-fashioned way—download 15 .dmg files, mount them, drag the applications to the Applications folder, eject them, delete the .dmg files—Homebrew’s simplicity and speed are a godsend. This Ansible playbook has so far automated that process completely, so you don’t even need to run the Homebrew commands manually! The geerlingguy.homebrew role uses Ansible’s built-in homebrew module to manage package installation, and some custom tasks to manage cask applications.  Configuring Mac OS X through dotfiles Just like there’s a homebrew role on Galaxy made for configuring and installing packages via Homebrew, there’s a dotfiles role you can use to download and configure your local dotfiles.  Dotfiles are named as such because they are, simply, files that begin with a . placed in your home directory. Many programs and shell environments read local configuration from dotfiles, so dotfiles are a simple, efficient, and easily-synchronized method of customizing your development environment for maximum efficiency.  In this example, we’ll use the author’s dotfiles, but you can tell the role to use whatever set of dotfiles you want.  Add another role to the roles list:   9   roles:  10     - geerlingguy.homebrew  11     - geerlingguy.dotfiles   Then, add the following three variables to your vars main.yml file:  2 dotfiles_repo: https:  github.com geerlingguy dotfiles.git  3 dotfiles_repo_local_destination: ~ repositories dotfiles  4 dotfiles_files:  5   - .bash_profile  6   - .gitignore    7   - .inputrc  8   - .osx  9   - .vimrc   The first variable gives the git repository URL for the dotfiles to be cloned. The second gives a local path for the repository to be stored, and the final variable tells the role which dotfiles it should use from the specified repository.  The dotfiles role clones the specified dotfiles repository locally, then symlinks every one of the dotfiles specified in dotfiles_files into your home folder  removing any existing dotfiles of the same name .  If you want to run the .osx dotfile, which adjusts many system and application settings, add in a new task under the tasks section in the main playbook:  1   tasks:  2     - name: Run .osx dotfiles.  3       shell: ~ .osx --no-restart  4       changed_when: false   In this case, the .osx dotfile allows a --no-restart flag to be passed to prevent the script from restarting certain apps and services including Terminal—which is good, since you’d likely be running the playbook from within Terminal.  At this point, you already have the majority of your local environment set up. Copying additional settings and tweaking things further is an exercise in adjusting your dotfiles or including another playbook that copies or links preference files into the right places.  I’m constantly tweaking my own development workstation, and for the most part, all my configuration is wrapped up in my Mac Development Ansible Playbook, available on GitHub. I’d encourage you to fork that project, as well as my dotfiles, if you’d like to get started automating the build of your own development workstation. Even if you don’t use a Mac, most of the structure is similar; just substitute a different package manager, and start automating everything!   Summary Ansible is the best way to automate infrastructure provisioning and configuration. Ansible can also be used to configure your own worstation or workstations, saving you time and frustration in doing so yourself. Unfortunately, you can’t yet provision yourself a new top-of-the-line workstation with Ansible!  You can find the full playbook I’m currently using to configure my Macs on GitHub: Mac Development Ansible Playbook.  Docker-based Infrastructure with Ansible Docker is a highly optimized platform for building and running containers on local machines and servers in a highly efficient manner. You can think of Docker containers as sort-of lightweight virtual machines. This book won’t go into the details of how Docker and Linux containers work, but will provide an introduction to how Ansible can integrate with Docker to build, manage, and deploy containers.  Prior to running example Docker commands or building and managing containers using Ansible, you’ll need to make sure Docker is installed on either your workstation or a VM or server where you’ll be testing everything. Please see the installation guide for Docker for help installing Docker on whatever platform you’re using.  A brief introduction to Docker containers Starting with an extremely simple example, let’s build a docker image from a Dockerfile. In this case, we just want to show how Dockerfiles work, and how we can use Ansible to build the image in the same way you could using the command line with docker build.  Let’s start with a really simple Dockerfile:  1  Build an example Docker container image.  2 FROM busybox  3 MAINTAINER Jeff Geerling    4   5  Run a command when the container starts.  6 CMD [" bin true"]    This Docker container doesn’t do much, but that’s okay; we just want to build it and verify that it’s present and working—first with Docker, then with Ansible.  Save the above file as Dockerfile inside a new directory, and then on the command line, run the following command to build the container:  $ docker build -t test .   After a few seconds, the docker image should be built, and if you list all local images with docker image, you should see your new test image  along with the busybox image, which was used as a base :  $ docker images  REPOSITORY  TAG     IMAGE ID      CREATED             VIRTUAL SIZE  test        latest  50d6e6479bc7  About a minute ago  2.433 MB  busybox     latest  4986bf8c1536  2 weeks ago         2.433 MB   If you want to run the container image you just created, enter the following:  $ docker run --name=test test   This creates a docker container with the name test, and starts the container. Since the only thing our container does is calls  bin true, the container will run the command, then exit. You can see the current status of all your containers  whether or not they’re actively running  with the docker ps -a command:  $ docker ps -a  CONTAINER ID  IMAGE        [...]  CREATED        STATUS  bae0972c26d4  test:latest  [...]  3 seconds ago  Exited  0  2  seconds ago   You can control the container using either the container ID  in this case, bae0972c26d4  or the name  test ; start with docker start [container], stop with docker stop [container], delete remove with docker rm [container].  If you delete the container  docker rm test  and delete the image you built  docker rmi test , you can experiment with the Dockerfile by changing it and rebuilding the image  with docker build , and running the resulting   image  with docker run . As an example, if you change the command from  bin true to  bin false, then run build and run the container, docker ps -a will show that the container exited with the status code 1 instead of 0.  For our purposes, this is a simple enough introduction to how Docker works. To summarize:  Dockerfiles contain the instructions Docker uses to build containers. docker build builds Dockerfiles and generates container images. docker images lists all images present on the system. docker run runs created images. docker ps -a lists all containers, both running and stopped.  When developing Dockerfiles to containerize your own applications, you will likely want to get familiar with the Docker CLI and how the process works from a manual perspective. But when building the final images and running them on your servers, Ansible can help ease the process.  Using Ansible to build and manage containers Ansible has a built-in Docker module that integrates nicely with Docker for container management. We’re going to use it to automate the building and running of the container managed by the Dockerfile we just created.  Move the Dockerfile you had into a subdirectory, and create a new Ansible playbook  call it main.yml  in the project root directory. The directory layout should look like:  docker     main.yml    test       Dockerfile   Inside the new playbook, add the following:   1 ---   2 - hosts: localhost   3   connection: local   4    5   tasks:   6     - name: Build Docker image from Dockerfiles.     7       docker_image:   8         name: test   9         path: test  10         state: build   The playbook uses the docker_image module to build an image. Provide a name for the image, the path to the Dockerfile  in this case, inside the test directory , and tell Ansible via the state parameter whether the image should be present, absent, or built  via build .  Ansible’s Docker integration may require you to install an extra Docker python library on the system running the Ansible playbook. For example, on ArchLinux, if you get the error “failed to import Python module”, you will need to install the python2- docker-py package.  The docker_image module is listed as being deprecated as of early 2015. The module’s functionality will soon be moved into the main docker module, but until that time, this playbook should work as-is.  Run the playbook  $ ansible-playbook main.yml , and then list all the Docker images  $ docker images . If all was successful, you should see a fresh test image in the list.  Run docker ps -a again, though, and you’ll see that the new test image was never run and is absent from the output. Let’s remedy that by adding another task to our Ansible playbook:  12 - name: Run the test container.  13   docker:  14     image: test:latest  15     name: test  16     state: running   If you run the playbook again, Ansible will run the docker container. Check the list of containers with docker ps -a, and you’ll note that the test container is again present.   You can remove the container and the image via ansible by changing the state parameter to absent for both tasks.  This playbook assumes you have both Docker and Ansible installed on whatever host you’re using to test Docker containers. If this is not the case, you may need to modify the example so the Ansible playbook is targeting the correct hosts and using the right connection settings. Additionally, if the user account under which you run the playbook can’t run docker commands, you may need to use sudo with this playbook.  The code example above can be found in the Ansible for DevOps GitHub repository.  Building a Flask app with Ansible and Docker Let’s build a more useful Docker-powered environment, with a container that runs our application  built with Flask, a lightweight Python web framework , and a container that runs a database  MySQL , along with a data container. We need a separate data container to persist the MySQL database, because data changed inside the MySQL container is lost every time the container stops.  Docker stack for Flask App  We’ll create a VM using Vagrant to run our Docker containers so the same Docker configuration can be tested on on any machine capable of running   Ansible and Vagrant. Create a docker folder, and inside it, the following Vagrantfile:   1  -*- mode: ruby -*-  2  vi: set ft=ruby :  3    4 VAGRANTFILE_API_VERSION = "2"  5    6 Vagrant.configure VAGRANTFILE_API_VERSION  do config  7   config.vm.box = "geerlingguy ubuntu1404"  8   config.vm.network :private_network, ip: "192.168.33.39"  9   config.ssh.insert_key = false 10   11   config.vm.provider :virtualbox do v 12     v.customize ["modifyvm", :id, "--name", "docker.dev"] 13     v.customize ["modifyvm", :id, "--natdnshostresolver1", "on"] 14     v.customize ["modifyvm", :id, "--memory", 1024] 15     v.customize ["modifyvm", :id, "--cpus", 2] 16     v.customize ["modifyvm", :id, "--ioapic", "on"] 17   end 18   19    Enable provisioning with Ansible. 20   config.vm.provision "ansible" do ansible 21     ansible.playbook = "provisioning main.yml" 22   end 23   24 end  We’ll use Ubuntu 14.04 for this example, and we’ve specified an Ansible playbook  provisioning main.yml  to set everything up. Inside provisioning main.yml, we need to first install and configure Docker  which we’ll do using the Ansible Galaxy role angstwad.docker_ubuntu , then run some additional setup tasks, and finally build and start the required Docker containers:   1 ---   2 - hosts: all   3   sudo: yes   4    5   roles:   6     - role: angstwad.docker_ubuntu   7    8   tasks:   9     - include: setup.yml  10     - include: docker.yml    We’re using sudo for everything because Docker either requires root privileges, or requires the current user account to be in the docker group. It’s simplest for our purposes to set everything up with sudo.  Angstwad’s docker_ubuntu role requires no additional settings or configuration, so we can move on to setup.yml  in the same provisioning directory alongside main.yml :  1 ---  2 - name: Install Pip.  3   apt: name=python-pip state=installed  4   sudo: yes  5   6 - name: Install Docker Python library.  7   pip: name=docker-py state=present  8   sudo: yes   Ansible needs the docker-py library in order to control Docker via Python, so we install pip, then use it to install docker-py.  Next is the meat of the playbook, docker.yml  also in the provisioning directory . The first task is building docker images for our data, application, and database containers:   1 ---   2 - name: Build Docker images from Dockerfiles.   3   docker_image:   4     name: "{{ item.name }}"   5     tag: "{{ item.tag }}"   6     path: " vagrant provisioning {{ item.directory }}"   7     state: build   8   with_items:   9     - { name: data, tag: "data", directory: data }  10     - { name: www, tag: "flask", directory: www }  11     - { name: db, tag: mysql, directory: db }   Don’t worry that we haven’t created the actual Dockerfiles required to create the Docker images yet; we’ll do that after we finish structuring everything with Ansible.  Like our earlier usage of docker_image, we supply a name, path, and state for each image. In this example, we’re also adding a tag, which behaves like a git tag, allowing future Docker commands to use the images we   created at a specific version. We’ll be building three containers, data, www, and db, and we’re pointing docker to the path  vagrant provisioning [directory], where [directory] contains the Dockerfile and any other helpful files to be used to build the Docker image.  After building the images, we will need to start each of them  or at least make sure a container is present, in the case of the data container—since you can use data volumes from non-running containers . We’ll do that in three separate docker tasks:  13  Data containers don't need to be running to be utilized.  14 - name: Run a Data container.  15   docker:  16     image: data:data  17     name: data  18     state: present  19   20 - name: Run a Flask container.  21   docker:  22     image: www:flask  23     name: www  24     state: running  25     command: python  opt www index.py  26     ports: "80:80"  27   28 - name: Run a MySQL container.  29   docker:  30     image: db:mysql  31     name: db  32     state: running  33     volumes_from: data  34     command:  opt start-mysql.sh  35     ports: "3306:3306"   Each of these containers’ configuration is a little more involved than the previous. In the case of the first container, it’s just present; Ansible will ensure a data container is present.  For the Flask container, we need to make sure our app is running, and continues running, so in this case  unlike our earlier usage of  bin true to run a container briefly and exit , we are providing an explicit command to run:  26     command: python  opt www index.py    Calling the script directly will launch the app in the foreground and log everything to stdout, making it easy to inspect what’s going on with docker logs [container] if needed.  Additionally, we want to map the container’s port 80 to the host’s port 80, so external users can load pages over HTTP. This is done using the ports option, passing data just as you would using Docker’s --publish syntax.  The Flask container will have a static web application running on it, and has no need for extra non-transient file storage, but the MySQL container will mount a data volume from the data container so it has a place to store data that won’t vanish when the container dies and is restarted.  Thus, for the db container, we have two special options; the volumes_from option, which mounts volumes from the specified container  in this case, the data container , and the command, which calls a shell script to start MySQL. We’ll get to why we’re running a shell script and not launching a MySQL daemon directly in a bit.  Now that we have the playbook structured to build our simple Docker- based infrastructure, we’ll build out each of the three Dockerfiles and related configuration to support the data, www, and db containers.  At this point, we should have a directory structure like:  docker     provisioning       data       db       www       docker.yml      main.yml      setup.yml    Vagrantfile   Data storage container For the data storage container, we don’t need much; we just need to create a directory and set it as an exposed mount point using VOLUME:  1  Build a simple MySQL data volume Docker container.  2 FROM busybox    3 MAINTAINER Jeff Geerling    4   5  Create data volume for MySQL.  6 RUN mkdir  var lib mysql  7 VOLUME  var lib mysql   We create a directory  line 6  and expose the directory as a volume  line 7  which can be mounted by the host or other containers. Save the above into a new file, docker provisioning data Dockerfile.  This container builds on top of the official busybox base image. Busybox is an extremely simple distribution that’s linux-like, but doesn’t contain every option or application generally found in popular distributions like Debian, Ubuntu, or RedHat. Since we only need to create and share a directory, we don’t need any additional ‘baggage’ inside the container. In the Docker world, it’s best to use the most minimal base images possible, and only install and run the bare necessities inside each container to support the container’s app.  Flask container Flask is a lightweight Python web framework “based on Werkzeug, Jinja 2 and good intentions”. It’s a great web framework for small, fast, and robust websites and apps, or even a simple API. For our purposes, we need to build a Flask app that connects to a MySQL database and displays the status of the connection on a simple web page  very much like our PHP example, in the earlier Highly-Available Infrastructure example .  Here’s the code for the Flask app  save it as docker provisioning www index.py.j2 :   1  Infrastructure test page.  2 from flask import Flask  3 from flask import Markup  4 from flask import render_template  5 from flask.ext.sqlalchemy import SQLAlchemy  6    7 app = Flask __name__   8    9  Configure MySQL connection. 10 db = SQLAlchemy   11 db_uri = 'mysql:  admin:admin@{{ host_ip_address }} information_schema' 12 app.config['SQLALCHEMY_DATABASE_URI'] = db_uri 13 db.init_app app    14   15 @app.route " "  16 def test  : 17     mysql_result = False 18     try: 19         if db.session.query "1" .from_statement "SELECT 1" .all  : 20             mysql_result = True 21     except: 22         pass 23   24     if mysql_result: 25         result = Markup ' PASS '  26     else: 27         result = Markup ' FAIL '  28   29      Return the page with the result. 30     return render_template 'index.html', result=result  31   32 if __name__ == "__main__": 33     app.run host="0.0.0.0", port=80   This simple app defines one route    , listens on every interface on port 80, and shows a MySQL connection status page rendered by the template index.html. There’s nothing particularly complicated in this application, but there is one Jinja2 varible  {{ host_ip_address }}  which an Ansible playbook will replace during deployment , and the app has a few dependencies  like flask-sqlalchemy  which will need to be installed via the Dockerfile.  Since we are using a Jinja2 template to render the page, let’s create that template in docker provisioning www templates index.html  Flask automatically picks up any templates inside a templates directory :   1    2    3    4    Flask + MySQL Docker Example   5    * { font-family: Helvetica, Arial, sans-serif }   6    7    8    Flask + MySQL Docker Example   9    MySQL Connection: {{ result }}  10   11     In this case, the .html template contains a Jinja2 variable  {{ result }} , and Flask will fill in that variable with the status of the MySQL connection.  Now that we have the app defined, we need to build the container to run the app. Here’s a Dockerfile that will install all the required dependencies, then copy a simple Ansible playbook and the app itself into place, so we can do the more complicated configuration  like copying a template with variable replacement  through Ansible:   1  A simple Flask app container.   2 FROM ansible ubuntu14.04-ansible   3 MAINTAINER Jeff Geerling     4    5  Install Flask app dependencies.   6 RUN apt-get install -y libmysqlclient-dev python-dev   7 RUN pip install flask flask-sqlalchemy mysql-python   8    9  Install playbook and run it.  10 COPY playbook.yml  etc ansible playbook.yml  11 COPY index.py.j2  etc ansible index.py.j2  12 COPY templates  etc ansible templates  13 RUN mkdir -m 755  opt www  14 RUN ansible-playbook  etc ansible playbook.yml --connection=local  15   16 EXPOSE 80   Instead of installing apt and pip packages using Ansible, we’ll install them using RUN commands in the Dockerfile. This allows those commands to be cached by Docker. Generally, more complicated package installation and configuration is easier and more maintainable inside Ansible, but in the case of simple package installation, having Docker cache the steps so future docker build commands take seconds instead of minutes is worth the verbosity of the Dockerfile.  At the end of the Dockerfile, we run a playbook  which should be located in the same directory as the Dockerfile , and expose port 80 so the app can be accessed via HTTP by the outside world. We’ll create the app deployment playbook next.   Purists might cringe at the sight of an Ansible playbook inside a Dockerfile, and for good reason! Commands like the ansible-playbook command cover up configuration that might normally be done  and cached  within Docker. Additionally, using the ansible ubuntu14.04-ansible base image  which includes Ansible  requires an initial download that’s 50+ MB larger than a comparable debian or ubuntu image without Ansible. However, for brevity and ease of maintenance, we’re using Ansible to manage all the app configuration inside the container  otherwise we’d need to run a bunch of verbose and incomprehensible shell commands to replace Ansible’s template functionality .  For the Flask app to function properly, we’ll need to get the host_ip_address, then replace the variable in the index.py.j2 template. Create the Flask deployment playbook at docker provisioning www playbook.yml:   1 ---   2 - hosts: localhost   3   sudo: yes   4    5   tasks:   6     - name: Get host IP address.   7       shell: " sbin ip routeawk ' default  { print $3 }'"   8       register: host_ip   9       changed_when: false  10   11     - name: Set host_ip_address variable.  12       set_fact:  13         host_ip_address: "{{ host_ip.stdout }}"  14   15     - name: Copy Flask app into place.  16       template:  17         src:  etc ansible index.py.j2  18         dest:  opt www index.py  19         mode: 0755  20   21     - name: Copy Flask templates into place.  22       copy:  23         src:  etc ansible templates  24         dest:  opt www  25         mode: 0755   The shell command that registers the host_ip  which is used in the next task to generate the host_ip_address variable  is a simple way to retrieve the IP while still letting Docker do it’s own virtual network management.   The last two tasks copy the flask app and templates directory into place.  The docker provisioning www directory should now contain the following:  www     templates       index.html    Dockerfile    index.py.j2    playbook.yml   MySQL container We’ve configured MySQL a few times throughout this book, so little time will be spent discussing how MySQL is set up. We’ll instead dive into how MySQL is configured to work inside a docker container, with a persistent data volume from the previously-configured data container.  First, we’ll create a really simple Ansible playbook to install and configure MySQL using the geerlingguy.mysql role:   1 ---   2 - hosts: localhost   3   sudo: yes   4    5   vars:   6     mysql_users:   7       - name: admin   8         host: "%"   9         password: admin  10         priv: "*.*:ALL"  11   12   roles:  13     - geerlingguy.mysql   This playbook is quite simple; it just sets up one MySQL user using the mysql_users variable, and then runs geerlingguy.mysql. Save it as docker provisioning db playbook.yml.  Next, we need to account for the fact that there are two conditions under which MySQL will be started:   1. When Docker builds the container initially  using docker build  through Ansible’s docker_image module .  2. When we launch the container and pass in the data volume  using  docker run through Ansible’s docker module .  In the latter case, the data volume’s  var lib mysql directory will supplant the container’s own directory, but it will be empty! Therefore, instead of just launching the MySQL daemon as we launched the Flask app in the www container, we need to build a small shell script to run on container start to detect if MySQL has already been setup inside  var lib mysql, and if not, reconfigure MySQL so the data is there.  Here’s a simple script to do just that—using the playbook we just created to do most of the heavy lifting. Save this as docker provisioning db start- mysql.sh:   1 ! bin bash  2    3  If connecting to a new data volume, we need to reconfigure MySQL.  4 if [[ ! -d  var lib mysql mysql ]]; then  5     rm -f ~ .my.cnf   6     mysql_install_db   7     ansible-playbook  etc ansible playbook.yml --connection=local  8     mysqladmin shutdown   9 fi 10   11 exec  usr bin mysqld_safe   This bash script checks if there’s already a mysql directory inside MySQL’s default data directory, and if not  as is the case when we run the container with the data volume , it will remove any existing .my.cnf connection file, run mysql_install_db to initialize MySQL, then run the playbook, and shut down MySQL.  Once that’s all done  or if the persistent data volume has already been set up previously , MySQL is started with the mysqld_safe startup script which, according to the MySQL documentation, is “the recommended way to start a mysqld server on Unix”.  Next comes the Dockerfile, where we’ll make sure the playbook.yml playbook and start-mysql.sh script are put in the right places, and expose   the MySQL port so other containers can connect to MySQL.   1  A simple MySQL container.   2 FROM ansible ubuntu14.04-ansible   3 MAINTAINER Jeff Geerling     4    5  Install required Ansible roles.   6 RUN ansible-galaxy install geerlingguy.mysql   7    8  Copy startup script.   9 COPY start-mysql.sh  opt start-mysql.sh  10 RUN chmod +x  opt start-mysql.sh  11   12  Install playbook and run it.  13 COPY playbook.yml  etc ansible playbook.yml  14 RUN ansible-playbook  etc ansible playbook.yml --connection=local  15   16 EXPOSE 3306   Just as with the Flask app container, we’re using a base image with Ubuntu 14.04 and Ansible. This time, since we’re doing a bit more configuration via the playbook, we also need to install the geerlingguy.mysql role via Ansible Galaxy.  The start-mysql.sh script needs to be in the location where we’re calling it with command:  opt start-mysql.sh in the docker.yml file we set up much earlier, so we copy it in place, then give +x permissions so Docker can execute the file.  Finally, the Ansible playbook that configures MySQL is copied into place, then run, and port 3306 is exposed.  The docker provisioning db directory should now contain the following:  db     Dockerfile    playbook.yml    start-mysql.sh   Ship it! Now that everything’s in place, you should be able to cd into the main docker directory, and run vagrant up. After 10 minutes or so, Vagrant should show that Ansible provisioning was successful, and if you visit   http:  192.168.33.39  in your browser, you should see something like the following:  Docker orchestration success!  If you see “MySQL Connection: PASS”, congratulations, everything worked! If it shows ‘FAIL’, you might need to give the MySQL a little extra time to finish it’s reconfiguration, since it has to rebuild the database on first launch. If the page doesn’t show up at all, you might want to compare your code with the Docker LAMP example on GitHub.  Summary The entire Docker LAMP example is available on GitHub, if you want to clone it and try it locally.  The Docker examples in this book barely scratch the surface of what makes Docker a fascinating and useful application deployment tool. As of the writing of this book, Docker is still in its infancy, so there are dozens of ways to manage the building of Dockerfiles, the deployment of images, and the running and linking of containers. Ansible is a solid contender in this space, and can even be used within a Dockerfile to simplify complex container configurations.   _________________________________________    Any sufficiently advanced technology is \   indistinguishable from magic.             \  Arthur C. Clarke                           -----------------------------------------          \   ^__^           \   oo \_______               __ \        \ \                  ----w                            Chapter 9 - Deployments with Ansible  Deploying application code to servers is one of the hardest, but most rewarding, tasks of any development team. Most shops using traditional deployment techniques  manual steps, shell scripts, and prayers  dread deployments, especially for complex, monolithic apps.  Deployments are less daunting when you adopt modern deployment processes and use the right amount of automation. In the best case, deployments become so boring and routine they barely register as a blip on your team’s radar.  Consider Etsy, a company whose engineers are deploying code to production up to 40 times per day, with no manual intervention from the operations team. The operations team is free to work on more creative endeavors, and the developers see their code go live in near-real-time!  Etsy’s production deployment schedule is enabled by a strong DevOps- oriented culture  with robust code repository management, continuous integration, well-tested code, feature flags, etc. . While it may not be immediately possible to start deploying your application to production 20 times a day, you can move a long way towards effortless deployments by automating deployments with Ansible.  Deployment strategies There are dozens of ways to deploy code to servers. For the simplest of applications, all that’s involved might be switching to a new tag in a code repository on the server and restarting a service.  For more complex applications, you might do a full Blue-Green deployment, where you build an entire new infrastructure alongside your current production infrastructure, run tests on the new infrastructure, then automatically cut over to the new instances. This may be overkill for many   applications  especially if <100% uptime is acceptable , but it is becoming more and more common—and Ansible can automate the entire process.  In this chapter, we will be covering the following deployment strategies:  1. Single-server deployments. 2. Zero-downtime multi-server deployments. 3. Capistrano-style and blue-green deployments.  These are three of the most common deployment techniques, and they cover many common use cases. There are other ways you can strengthen your deployment processes, often involving application-level and organizational change, but those deployment aspects are out of the scope of this book.  Simple single-server deployments The vast majority of small applications and websites are easily run on a single virtual machine or dedicated server. Using Ansible to provision and manage the configuration on the server is a no-brainer. Even though you only have to manage one server, it’s better to encapsulate all the setup so you don’t end up with a snowflake server.  In this instance, we are managing a very simple Ruby on Rails site that allows users to perform CRUD operations on articles  very simple database records with a title and body .  The code repository for this app is located on GitHub at https:  github.com geerlingguy demo-rails-app.  To make testing simple, we’ll begin by creating a new Vagrant VM using the following Vagrantfile:   1  -*- mode: ruby -*-  2  vi: set ft=ruby :  3    4 Vagrant.configure 2  do config  5   config.vm.box = "geerlingguy ubuntu1404"  6    7   config.vm.provider "virtualbox" do v  8     v.name = "rails-demo"  9     v.memory = 1024   10     v.cpus = 2 11   end 12   13   config.vm.hostname = "rails-demo" 14   config.vm.network :private_network, ip: "192.168.33.7" 15   16   config.vm.provision "ansible" do ansible 17     ansible.playbook = "playbooks main.yml" 18     ansible.sudo = true 19   end 20   21 end  In this case, we have a very simple VM that will be accessible at the IP address 192.168.33.7, and when provisioned, it will run the Ansible playbook defined in playbooks main.yml.  Provisioning a simple Ruby on Rails server To prepare for our application deployment, we need to do the following:  1. Install git  our application is version controlled in a git repository . 2. Install Node.js  asset compilation requires it’s Javascript runtime . 3. Install Ruby  our application requires version 2.2.0 or later . 4. Install Passenger with Nginx  we need a fast web server to run our  rails application .  5. Install any other dependencies, and prepare the server for deployment.  To that end, let’s create a new playbook just for the provisioning tasks  we’ll worry about deployment later , in a new file, playbooks provision.yml:   1 ---   2 - hosts: all   3   sudo: yes   4    5   vars_files:   6     - vars.yml   7    8   roles:   9     - geerlingguy.git  10     - geerlingguy.nodejs  11     - geerlingguy.ruby  12     - geerlingguy.passenger  13     14   tasks:  15     - name: Install app dependencies.  16       apt: "name={{ item }} state=present"  17       with_items:  18         - libsqlite3-dev  19         - libreadline-dev  20   21     - name: Ensure app directory exists and is writeable.  22       file:  23         path: "{{ app_directory }}"  24         state: directory  25         owner: "{{ app_user }}"  26         group: "{{ app_user }}"  27         mode: 0755   This is a fairly simple playbook. We’ll need to define a few variables to make sure the geerlingguy.ruby role installs the correct version of Ruby  at least 2.2.0 , and the geerlingguy.passenger role is configured to serve our app correctly.  There are also a few other variables we will need, like app_directory and app_user, so let’s create the variables file now, at playbooks vars.yml:   1  Variables for our app.   2 app_directory:  opt demo-rails-app   3 app_user: www-data   4    5  Variables for Passenger and Nginx.   6 passenger_server_name: 0.0.0.0   7 passenger_app_root:  opt demo-rails-app public   8 passenger_app_env: production   9 passenger_ruby:  usr local bin ruby  10   11  Variables for Ruby installation.  12 ruby_install_from_source: true  13 ruby_download_url: http:  cache.ruby-lang.org pub ruby 2.2 ruby- 2.2.0.tar.gz  14 ruby_version: 2.2.0   The passenger variables tell Passenger to run a server available on every network interface, and to launch our app  which will be located in  opt demo-rails-app public  with production settings  the app’s environment , using the ruby binary we have installed in  usr local bin ruby.   The Ruby variables tell the ruby role to install Ruby 2.2.0 from source, since the packages available through Ubuntu’s standard apt repositories only contain older versions.  The playbook specified in our Vagrantfile, playbooks main.yml, doesn’t yet exist. Let’s create that playbook and include the above provisioning.yml playbook so our server will be provisioned successfully. We’ll separate out the deployment steps into another playbook and include that separately. Inside playbooks main.yml:  1 ---  2 - include: provision.yml   Deploying a Rails app to the server All the dependencies for our app’s deployment were configured in provision.yml, so we’re ready to build a playbook to perform all the deployment tasks.  Add a line to the main.yml file to include a new deploy.yml playbook:  1 ---  2 - include: provision.yml  3 - include: deploy.yml   Now we’re ready to create a the deploy.yml playbook, which will do the following:  1. Use git to check out the latest production release of the Rails app. 2. Copy over a secrets.yml template that holds some secure app data  required for running the app.  3. Make sure all the gems required for the app are installed  via Bundler . 4. Create the database  if it doesn’t already exist . 5. Run rake tasks to make sure the database schema is up-to-date and all  assets  like JS and CSS  are compiled.  6. Make sure the app files’ ownership is set correctly so Passenger and  Nginx can serve them without error.  7. If any changes or updates were made, restart Passenger and Nginx.   Most of these tasks will use Ansible’s modules, but for a few, we’ll just wrap the normal deployment-related commands in shell since there aren’t pre-existing modules to take care of them for us:   1 ---   2 - hosts: all   3   sudo: yes   4    5   vars_files:   6     - vars.yml   7    8   roles:   9     - geerlingguy.passenger  10   11   tasks:  12     - name: Ensure demo application is at correct release.  13       git:  14         repo: https:  github.com geerlingguy demo-rails-app.git  15         version: "{{ app_version }}"  16         dest: "{{ app_directory }}"  17         accept_hostkey: true  18       register: app_updated  19       notify: restart nginx  20   21     - name: Ensure secrets file is present.  22       template:  23         src: templates secrets.yml.j2  24         dest: "{{ app_directory }} config secrets.yml"  25         owner: "{{ app_user }}"  26         group: "{{ app_user }}"  27         mode: 0664  28       notify: restart nginx  29   30     - name: Install required dependencies with bundler.  31       shell: "bundle install --path vendor bundle chdir={{  app_directory }}"  32       when: app_updated.changed == true  33       notify: restart nginx  34   35     - name: Check if database exists.  36       stat: "path={{ app_directory }} db {{  app_environment.RAILS_ENV }}.sqlite3"  37       register: app_db_exists  38   39     - name: Create database.  40       shell: "bundle exec rake db:create chdir={{ app_directory  }}"  41       when: app_db_exists.stat.exists == false  42       notify: restart nginx    43   44     - name: Perform deployment-related rake tasks.  45       shell: "{{ item }} chdir={{ app_directory }}"  46       with_items:  47         - bundle exec rake db:migrate  48         - bundle exec rake assets:precompile  49       environment: app_environment  50       when: app_updated.changed == true  51       notify: restart nginx  52   53     - name: Ensure demo application has correct user for files.  54       file:  55         path: "{{ app_directory }}"  56         state: directory  57         owner: "{{ app_user }}"  58         group: "{{ app_user }}"  59         recurse: yes  60       notify: restart nginx   The first thing you’ll notice  besides the fact that we’ve included the vars.yml file again, since we need those variables in this playbook as well  is that we’ve added the geerlingguy.passenger role in this playbook. Since we’ll be using one of the handlers defined in that playbook  restart nginx , we need to include the role explicitly. We could’ve added a separate handler specific to this playbook, but it’s more maintainable to reuse handlers from roles if necessary.  Let’s walk through the tasks, one-by-one:  1.  Lines 12-19  We put all the application files in place by checking out  the git repository at the version app_version into the directory app_directory. We set accept_hostkey to true so that, the first time we deploy the app, this task doesn’t hang since we haven’t yet accepted the Git server’s hostkey.  2.  Lines 21-28  We copy a secrets.yml file to the application’s  configuration directory. There are different ways to deploy app secrets, but this is the simplest and easiest, and allows us to store the app secrets in an Ansible Vault-protected vars file if we so desire. 3.  Lines 30-33  If the app_updated variable shows that a change  occurred as part of the first git task, we’ll run a bundler command to ensure all the latest bundled dependencies are installed in the vendor bundle directory.   4.  Lines 35-42  Create the application database with rake db:create if  it doesn’t already exist. Since this application uses a simple SQLite database, it’s a matter of checking if the .sqlite3 file exists, and if not, running the db:create task.  5.  Lines 44-51  If the app_updated variable shows that a change  occurred as part of the first git task, we’ll also run a couple rake tasks to make sure the database schema is up to date, and all assets  like scripts and stylesheets  are compiled.  6.  Lines 53-60  Make sure all app files have the correct permissions for  Passenger Nginx to serve them correctly.  Because many of the tasks result in filesystem changes that could change the behavior of the application, they all notify the restart nginx handler provided by the geerlingguy.passenger role, so Passenger reloads the configuration and restarts the app.  There are a few new variables we need to add to vars.yml, and we also need to add the secrets.yml.j2 template mentioned in the task that copies it into place.  First, we’ll create the secrets file, inside playbooks templates secrets.yml.j2:  1 development:  2   secret_key_base: {{ app_secrets.dev }}  3   4 test:  5   secret_key_base: {{ app_secrets.test }}  6   7 production:  8   secret_key_base: {{ app_secrets.prod }}    1 ---   2  Variables for our app.   3 app_version: 1.2.2   4 app_directory:  opt demo-rails-app   5 app_user: www-data   6 app_secrets:   7   dev: fe562ec1e21eecc5af4d83f6a157a7   We’ll be using a dictionary variable for app_secrets, so let’s add that and all the other new variables to playbooks vars.yml:    8   test: 4408f36dd290766d2f368fdfcedf4d   9   prod: 9bf801da1a24c9a103ea86a1438caa  10 app_environment:  11   RAILS_ENV: production  12   13  Variables for Passenger and Nginx.  14 passenger_server_name: 0.0.0.0  15 passenger_app_root:  opt demo-rails-app public  16 passenger_app_env: production  17 passenger_ruby:  usr local bin ruby  18   19  Variables for Ruby installation.  20 ruby_install_from_source: true  21 ruby_download_url: http:  cache.ruby-lang.org pub ruby 2.2 ruby- 2.2.0.tar.gz  22 ruby_version: 2.2.0   Note the addition of the following variables to support our deploy.yml playbook:  app_version: This is the git tag or branch tip to be deployed to the server. app_secrets: A dictionary of Rails app secrets, which are used to verify the integrity of signed app cookies. You can generate new, unique strings for these variables using rake secret. app_environment: Environment settings required for certain commands  like bundle exec and rake  to run with the correct Rails application environment.  Provisioning and Deploying the Rails App Since we now have our provision.yml and deploy.yml playbooks completed, and both are included in the main.yml playbook Vagrant will run, we can finally bring up the new VM using Vagrant, and see if our application works!  The structure of your project folder should look like this:  deployments     playbooks       templates         secrets.yml.j2      deploy.yml      main.yml        provision.yml      vars.yml    Vagrantfile   Before we can run the playbook, we need to make sure all the role dependencies are present. If you were building everything from scratch, you might have a roles directory with all the roles inside, but in this case, since we’re using roles from Ansible Galaxy, it’s best to not include the role files directly with our playbook, but instead, add a requirements.txt file to the project and install the roles automatically with Galaxy.  Inside requirements.txt:  1 geerlingguy.git  2 geerlingguy.ruby  3 geerlingguy.nodejs  4 geerlingguy.passenger   Now, in the same directory as that file, run the command $ ansible- galaxy install -r requirements.txt, and after a minute, all the required roles will be downloaded to your default Ansible roles directory, if they’re not already present.  Change directory back to the main directory containing the Vagrantfile, and run vagrant up. Assuming everything runs correctly, you should see the playbook complete successfully after a few minutes:  TASK: [Ensure demo application has correct user for files.]  *************  changed: [default]    NOTIFIED: [geerlingguy.passenger  restart nginx]  ***********************  changed: [default]    PLAY RECAP  **************************************************************  default               : ok=46   changed=28   unreachable=0     failed=0   Now, jump over to a web browser and load http:  192.168.33.7 . You should see something like the following:   Demonstration Rails app running successfully.  Try creating, updating, and deleting a few articles to make sure the database and all app functionality is working correctly:  A simple app to perform CRUD operations on Articles.  The app seems to function perfectly, but it could use some improvements. After more development work, we have a new version of to deploy. We could update the app_version variable in vars.yml and run vagrant provision to run the entire provisioning and deployment playbook again, but to save a little time, and to utilize the more flexible playbook layout  with provisioning and deployment concerns separated , we can run the deploy.yml playbook separately.  Deploying application updates   First, to test whether we can deploy without provisioning, we will need to create an inventory file to tell Ansible how to connect directly to the Vagrant-managed VM.  Create the file playbooks inventory-ansible with the following contents:  1 [rails]  2 192.168.33.7  3   4 [rails:vars]  5 ansible_ssh_user=vagrant  6 ansible_ssh_private_key_file=~ .vagrant.d insecure_private_key   If you were creating this playbook for a server or VM running outside of Vagrant’s control, you’d probably have already created an inventory file or added the server to your global inventory, but when we’re working with Vagrant, it’s often convenient to use Vagrant’s own dynamically-managed inventory. Running playbooks outside of Vagrant’s up provision functionality requires us to create a separate inventory file.  Test the ability to run the deploy.yml playbook by running the following command inside the playbooks directory:  $ ansible-playbook deploy.yml -i inventory-ansible   Hopefully the playbook completed its run successfully. It may have reported a change in the “Ensure demo application has correct user for files” task, and if so, it will have restarted Passenger. Run it again, and ansible should report no changes:  PLAY RECAP  **************************************************************  192.168.33.7          : ok=16   changed=0    unreachable=0     failed=0   Hopefully you’ve noticed that running the deploy.yml playbook standalone is much faster than running the provision and deploy playbooks together  deployment only takes 16 tasks, while both playbooks add up to 70+ tasks! . In the future, we can deploy application updates using only the deploy.yml playbook and changing the app_version either in vars.yml or   by specifying the version on the command line in the ansible-playbook command.  It’s generally preferred to change variables in vars files that are versioned with your playbooks, rather than specify them through inventory files, environment variables, or on the command line. This way the entire state of your infrastructure is encapsulated in your playbook files, which ideally should be version controlled and managed similarly to the application they deploy. Plus, who wants to enter any more information on the command line than is absolutely required?  Our application is a fairly generic web application that has updates to application code  which require a webserver reload , styles  which need recompiling , and possibly the database schema  which needs rake migrate tasks to be run . Any time app_version is changed inside playbooks vars.yml, the deploy playbook will automatically run all the required tasks to get our app running with the latest code.  Update app_version to 1.3.0, and then run the following command again:  $ ansible-playbook deploy.yml -i inventory-ansible   After a minute or so, the deployment should complete, and once that’s done, you’ll see the much improved new version of the Demonstration Ruby on Rails Application:   Rails app - version 1.3.0 with a responsive UI.  Simple application update deployments will involve incrementing the app_version to the latest git tag, then running the deploy.yml playbook again. You can always run the main.yml playbook to ensure the entire server stack is in the correct state, but it’s faster to just deploy the app updates.  Zero-downtime multi-server deployments A single server deployment strategy is all that’s needed for many applications, but if you need to run an application on multiple servers for horizontal scalability or redundancy, deployments can be cumbersome—but not when you use Ansible!  Server Check.in is a simple server and website monitoring service that has a microservices-based architecture; there is a website, an API application, and a server checking application.  The server checking application needs to run on a variety of servers hosted around the world by different providers to provide redundancy and reliability. Server Check.in uses Ansible to manage rolling deployments for   this application, so new code can be deployed across all the servers in minutes while maintaining 100% uptime!  We’ll emulate part of Server Check.in’s infrastructure  the check server application  by deploying and updating a simple Node.js application to a set of virtual machines. The code repository for this app is located on GitHub at https:  github.com geerlingguy demo-nodejs-api. Here’s a diagram of the infrastructure we’ll be building:  Four servers connected to the Internet.  To begin, create four lightweight Vagrant VMs using the following Vagrantfile:   1  -*- mode: ruby -*-  2  vi: set ft=ruby :  3    4 Vagrant.configure "2"  do config  5    Base VM OS configuration.  6   config.vm.box = "geerlingguy ubuntu1404"  7   config.vm.synced_folder '.', ' vagrant', disabled: true  8   config.ssh.insert_key = false  9   10   config.vm.provider :virtualbox do v 11     v.memory = 256 12     v.cpus = 1 13   end 14   15    Define four VMs with static private IP addresses. 16   boxes = [ 17     { :name => "nodejs1", :ip => "192.168.3.2" }, 18     { :name => "nodejs2", :ip => "192.168.3.3" },   19     { :name => "nodejs3", :ip => "192.168.3.4" }, 20     { :name => "nodejs4", :ip => "192.168.3.5" } 21   ] 22   23    Provision each of the VMs. 24   boxes.each do opts 25     config.vm.define opts[:name] do config 26       config.vm.hostname = opts[:name] 27       config.vm.network :private_network, ip: opts[:ip] 28   29        Provision all the VMs using Ansible after the last VM is booted. 30       if opts[:name] == "nodejs4" 31         config.vm.provision "ansible" do ansible 32           ansible.playbook = "playbooks main.yml" 33           ansible.inventory_path = "inventory" 34           ansible.limit = "all" 35         end 36       end 37     end 38   end 39   40 end  The above Vagrantfile defines four VMs that each use 256MB of RAM and have a unique hostname and IP address  defined by the boxes variable . Our Node.js app doesn’t require much in the way of processing power or memory.  In the provision section of the playbook, we told Vagrant to provision the all the VMs with Ansible, using the inventory file inventory, and the playbook playbooks main.yml. Create these two files in the same folder as your Vagrantfile:  rolling-deployments     playbooks       main.yml    inventory    Vagrantfile   1 [nodejs-api]  2 192.168.3.2  3 192.168.3.3  4 192.168.3.4   Inside the inventory file, we just need to define a list of all the Node.js API app VMs by IP address:   5 192.168.3.5  6   7 [nodejs-api:vars]  8 ansible_ssh_user=vagrant  9 ansible_ssh_private_key_file=~ .vagrant.d insecure_private_key   Inside the main.yml playbook, we’ll call out two separate playbooks—one for the initial provisioning  installing Node.js and making sure the server is configured correctly , and another for deployment  ensuring our Node.js API app is present and running :  1 ---  2 - include: provision.yml  3 - include: deploy.yml   Go ahead and create the provision.yml and deploy.yml playbooks, starting with provision.yml:   1 ---   2 - hosts: nodejs-api   3   sudo: yes   4    5   vars:   6     nodejs_forever: true   7     firewall_allowed_tcp_ports:   8       - "22"   9       - "8080"  10   11   roles:  12     - geerlingguy.firewall  13     - geerlingguy.nodejs   This extremely simple playbook runs on all the servers defined in our inventory file, and runs two roles on the servers: geerlingguy.firewall  which installs and configures a firewall, in this case opening ports 22 for SSH and 8080 for our app  and geerlingguy.nodejs  which installs Node.js, NPM, and forever, which we’ll use to run our app as a daemon .  Since we’re using two roles from Ansible Galaxy, it’s best practice to also include those roles in a requirements file so CI tools and others using this playbook can easily install all the required roles.  Create a requirements.txt file in the root folder and add the following:   1 geerlingguy.firewall  2 geerlingguy.nodejs   Now, whenever someone new to the project wants to run the playbook, all that person needs to do is run ansible-galaxy install -r requirements.txt to install all the required roles.  At this point, your project directory should be structured like the following:  rolling-deployments     playbooks       deploy.yml      main.yml      provision.yml    inventory    requirements.txt    Vagrantfile   1 ---  2 - hosts: nodejs-api  3   gather_facts: no  4   sudo: yes  5   6   vars_files:  7     - vars.yml   Before we can run vagrant up and see our infrastructure in action, we need to build out the deploy.yml playbook, which will ensure our app is present and running correctly on all the servers.  Inside deploy.yml, add the following:  Use sudo for this playbook to keep things simple, and set gather_facts to no to save a little time during deployments, since our simple app doesn’t require any of the gathered system facts to run.  Since we have a few variables to define, and we’d like to track them separately for easier file revision history, we’ll define the variables in a vars.yml file in the same directory as the deploy.yml playbook:  1 ---  2 app_repository: https:  github.com geerlingguy demo-nodejs-api.git    3 app_version: "1.0.0"  4 app_directory:  opt demo-nodejs-api   Once you’ve saved the vars.yml file, continue building out deploy.yml, starting with a task to clone the app’s repository  which we just defined in vars.yml :   9   tasks:  10     - name: Ensure Node.js API app is present.  11       git:  12         repo: "{{ app_repository }}"  13         version: "{{ app_version }}"  14         dest: "{{ app_directory }}"  15         accept_hostkey: true  16       register: app_updated  17       notify: restart forever apps   Using variables for the git module’s repo and version affords flexibility; app version changes might happen frequently, and it’s easier to manage that in a separate vars.yml file.  We also want to notify a restart forever apps handler whenever the codebase is changed. We’ll define the restart forever apps handler later in the playbook.  18     - name: Stop all running instances of the app.  19       command: "forever stopall"  20       when: app_updated.changed  21   22     - name: Ensure Node.js API app dependencies are present.  23       npm: "path={{ app_directory }}"  24       when: app_updated.changed  25   26     - name: Run Node.js API app tests.  27       command: "npm test chdir={{ app_directory }}"  28       when: app_updated.changed   Once the app is present on the server, we need to use npm to install dependencies  using Ansible’s npm module , then run the app’s test suite using npm test. To save time, we only stop the application, update dependencies, and run tests if the application has changed  using the app_updated variable we registered when checking out the application code .   Running the tests for the app during every deployment ensures the app is present and in a functioning state. Having a thorough unit and integration test suite that runs on every deployment is almost prerequisite to a frequent or continuously-integrated project! Running the tests during deployments also helps with ensuring zero-downtime deployments, as we’ll see later.  25     - name: Get list of all running Node.js apps.  26       command: forever list  27       register: forever_list  28       changed_when: false  29   30     - name: Ensure Node.js API app is started.  31       command: "forever start {{ app_directory }} app.js"  32       when: "forever_list.stdout.find 'app.js'  == -1"   Once the app is present and running correctly, we need to make sure it’s started. There’s a command to get the list of all running apps  using forever , then a command to start the app if it’s not already running.  34     - name: Add cron entry to start Node.js API app on reboot.  35       cron:  36         name: "Start Node.js API app"  37         special_time: reboot  38         job: "forever start {{ app_directory }} app.js"   The final task adds a cron job to make sure the app is started after the server reboots. Since we’re managing the deamonization of our app using forever instead of the OS’s init system, it’s simplest to make sure the app starts on system boot using a reboot cron job.  Remember when we added the line notify: restart forever apps to the task that ensured the app was present on the server? It’s time to define that handler, which runs the command forever restartall  which does exactly what it says :  40   handlers:  41     - name: restart forever apps  42       command: "forever restartall"   At this point, the Ansible playbooks and Vagrant configuration should be complete. The playbook will clone the demo-nodejs-api project, run its   tests to make sure everything’s working correctly, then start the app using forever and make sure it’s started whenever the the server reboots.  You can run the command below to test all the new servers and make sure the app is running correctly:  $ for i in {2..5}; \      do curl -w "\n" "http:  192.168.3.$i:8080 hello john"; \    done   If all the servers are online, you should see the text "hello john" repeated four times  once for each server :  "hello john"  "hello john"  "hello john"  "hello john"   You can run vagrant provision to run the entire provisioning and deployment process again, or just run ansible-playbook -i inventory playbooks deploy.yml to run the deployment playbook again. In either case, you should see no changes, and Ansible should verify that everything’s ok.  You now have a fleet of Node.js API servers similar to Server Check.in’s server checking infrastructure—except it doesn’t do much yet! Luckily, the project has seen some new feature development since the initial 1.0.0 version you just deployed. We now need a way to get the new version deployed to and running on all the servers while maintaining 100% uptime for the API as a whole.  Ensuring zero downtime with serial and integration tests Now, after a little extra time in development, we have new features to deploy in a 1.0.1 version. You could run the exact same ansible-playbook command as above, adding in --extra-vars "app_version=1.0.1", but best practice is to update the variable in your included variables file, since that change can be tracked in version control and  hopefully  be used for automated deployments.   Change the app_version in playbooks vars.yml to 1.0.1, and run the deployment playbook again:  ansible-playbook -i inventory playbooks deploy.yml   Uh oh—after we deployed the new version, our tests started failing! Since we deployed to all four servers asynchronously, all four application servers are offline, and our boss and customers are going to be very angry.  In this case, rolling back is simply a matter of reverting to 1.0.0 and redeploying  go ahead and do that now, so you keep at least a few 9’s of uptime! , but imagine if part of the application update changed a database schema or did something else that required a lot more work to roll back changes; you’d be in a world of hurt!  Ansible has two particular settings that will help protect you when you deploy to many servers while maintaining your infrastructure’s overall integrity during a failed deployment.  Open the deployment playbook  playbooks deploy.yml  and modify the initial settings to match the following:  1 ---  2 - hosts: nodejs-api  3   gather_facts: no  4   sudo: yes  5   serial: 2   Note the addition of serial: 1. This tells Ansible to run the entire playbook on two servers at a time. If you update app_version to 1.0.1 again, and run the playbook, you should see it run on two of the four servers, and once it hits the test failure, the playbook execution will stop— leaving your other two servers up  and saving you a few hours on a conference bridge explaining the outage .  You could again revert back to 1.0.0, but in the time that you were deploying the failed version, developers finished a new version that got all tests passing again, 1.0.2. Go ahead and update app_version and run the playbook again.   PLAY RECAP  ***********************************************************  192.168.3.2         : ok=8    changed=5    unreachable=0     failed=0  192.168.3.3         : ok=8    changed=5    unreachable=0     failed=0  192.168.3.4         : ok=8    changed=5    unreachable=0     failed=0  192.168.3.5         : ok=8    changed=5    unreachable=0     failed=0   Whew! Everything is back online and operational, and all tests are passing with the latest version of the application.  This contrived example should be pretty rare in the real world; it should be rare that tests fail only on production. But there are many times where networking issues or even latency in third party services causes a random failure or two. Whenever you move beyond one server  usually to provide both redundancy and cacpacity , you will eventually run into these transient issues. It’s best to account for them in your automated deployment process by tuning settings like serial well.  Ansible exposes two different settings that you can use to control rolling deployment failure scenarios:  1. serial: Can be an integer  e.g. 3  or a percentage  e.g. 30% . Used to  control how many hosts Ansible will manage at once.  2. max_fail_percentage: An integer between 1-100. Used to tell  Ansible what percentage of hosts can fail a task before the play will be aborted.  If you have some headroom in your infrastructure, you can set these values higher without fear of leaving your infrastructure in a very bad state after a failed deployment. If you have only as much infrastructure running as your application needs, and having more than one or two servers offline would put your infrastructure into a bad state, you should probably be more conservative with these settings—and provision a little more capacity!  Deploying to app servers behind a load balancer   In the case of Server Check.in, there are two separate API layers that manage the complexity of ensuring all server checks happen, regardless of whether certain servers are up or down. The ‘load balancing’ occurs on the application layer instead of as a separate infrastructure layer  this is extremely helpful when dealing with global latency and network reliability variation .  For many applications, especially those with app servers close together  e.g. in the same data center  the infrastructure layer follows a more traditional layout, with a load balancer to handle the API request distribution:  TODO.  Four servers behind a load balancer.  Capistrano-style and blue-green deployments Many developers who deal with Ruby applications are familiar with Capistrano, a task automation and application deployment application built with Ruby. Capistrano’s basic style of deployment is to create dated release directories, then symlink the current release into a stable application directory, along with resources that are continuous among releases  like logs and uploaded files .  Capistrano does a lot more than that basic deployment model, but many people want to replicate that simple application deployment workflow    which is also fairly simple for rollbacks, since you just revert the symlink to the previous release directory! . This is fairly simple to do with Ansible, and rather than walk you through the entire process in this book, I’ll point you to a few great resources that explain the process in detail, along with an Ansible Galaxy role that coordinates Capistrano-style deployments even more easily!  Rebuilding Capistrano-like deployment with Ansible project_deploy role on Ansible Galaxy Thoughts on deploying with Ansible  background for the above role  Ansible project-deploy  presentation about the above role   Extending things a little further, many organizations use blue-green deployments. The basic concept involves bringing up a parallel production infrastructure, then switching over to it. The cutover may take only a few milliseconds and no active production infrastructure is ever offline during the deployment process.  A few different technologies and concepts, like container-based infrasturcture and microservices  which are faster to deploy , and better cloud autoscaling and load balancing options, have made blue-green deployments much easier than in the past.  This book won’t go through a detailed example of this style of deployment, as the process is similar to other examples provided, the only difference being an additional task of switching a load balancer from the old to the new infrastructure once it’s up and running. Ansible’s blog has an excellent overview of AWS-based blue-green deployments: Immutable Systems and Ansible, and there are built-in modules to manage almost any type of load balancer you could use, including F5’s BIG-IP, HAProxy, Citrix NetScaler, and Amazon ELB.  Additional Deployment Scenarios TODO:  run_once For things like database updates and schema changes. delegate_to   Notifications with Ansible  Summary Automating deployments with Ansible enables your development team to have their code on production servers more reliably and quickly, and it enables your operations team to spend less time on repetitive tasks, and more time improving your infrastructure.  This chapter outlined only a few of the most popular deployment techniques, but Ansible is flexible enough to handle almost any situation out of the box.   _______________________________________    One machine can do the work of fifty  \   ordinary men. No machine can do the      work of one extraordinary man.          \  Elbert Hubbard                           ---------------------------------------          \   ^__^           \   oo \_______               __ \        \ \                  ----w                            Chapter 10 - Server Security and Ansible  One of the first configuration steps that should be performed on any new server—especially any server with any exposure  direct or indirect  to the public Internet —is security configuration.  I debated adding this chapter earlier in the book, as the importance of a secure configuration  especially when automating server configuration, application deployments, etc.  cannot be understated. But as it is, I decided to focus on Ansible’s core functionality before giving a general overview of security, especially pertaining to Linux servers.  There are nine basic measures that must be taken to make sure that servers are secure from unauthorized access or intercepted communications:  1. Use secure and encrypted communication. 2. Disable root login and use sudo. 3. Remove unused software, open only required ports. 4. Use the principle of least privilege. 5. Update the OS and installed software. 6. Use a properly-configured firewall. 7. Make sure log files are populated and rotated. 8. Monitor logins and block suspect IP addresses. 9. Use SELinux  Security-Enhanced Linux .  Your infrastructure is as weak as the weakest server; in many high-profile security breaches, one poorly-secured server acts as a gateway into the rest of the network. Don’t let your servers be those servers! Good security also helps you achieve the holy grail of system administration—100% uptime.  In this chapter, you’ll learn about Linux security and how Ansible can help secure your servers, following the basic topics above.  A brief history of SSH and remote access   In the beginning, computers were the size of large conference rooms. A punch card reader would merrily accept pieces of paper that instructed the computer to do something, and then a printer would etch the results into another piece of paper. Thousands of mechanical parts worked harmoniously  when they did work  to compute relatively simple commands.  As time progressed, computers became somewhat smaller, and interactive terminals became more user-friendly, but they were still wired directly into the computer being used. Mainframes came to the fore in the 1960s, originally used via typewriter and teletype interfaces, then via keyboards and small text displays. As networked computing became more mainstream in the 1970s and 1980s, remote terminal access was used to interact with the large central computers.  The first remote terminal interfaces assumed a high level of trust between the central computer and all those on the network, because the small, centralized networks used were physically isolated from one another.  Telnet In the late 1960s, the Telnet protocol was defined and started being used over TCP networks  normally on port 23  for remote control over larger private networks, and eventually the public Internet.  Telnet’s underlying technology  a text-based protocol to transfer data between different systems  was the basis for many foundational communications protocols in use today, including HTTP, FTP, and POP3. However, plain text streams are not secure, and even with the addition of TLS and SASL, Telnet was never very secure by default. With the advent of SSH  which we’ll get to in a bit , the protocol has declined in popularity for most remote administration purposes.  Telnet still has uses like configuring devices over local serial connections, or checking if a particular service is operating correctly on a remote server  like an HTTP server on port 80, mysql on port 3306, or munin on port 4949 , but it is not installed by default on modern Linux distributions.   Plain text communications over a network are only as secure as the network’s weakest link. In the early days of computer networking, networks were usually isolated to a specific company or educational institution, so transmitting things like passwords or secrets in plain text using the TCP protocol wasn’t such a bad idea. Every part of the network  cabling, switches, and routers  was contained inside a secured physical perimeter. When connections started moving to the public Internet, this changed.  TCP packets can be intercepted over the Internet, at any point between the client and server, and these packets can easily be read if not encrypted. Therefore, plain text protocols are highly insecure, and should never be used to transmit sensitive information or system control data. Even on highly secure networks with properly- configured firewalls, it’s a bad idea to use insecure communication methods like plain text rlogin and telnet connections for authentication and remote control.  Try running traceroute google.com in your terminal. Look at each of the hops between you and Google’s CDN. Do you know who controls each of the devices between your computer and Google? Do you trust these operators with all of your personal or corporate secrets? Probably not. Each of these connection points—and each network device and cable connecting them—is a weak point exposing you to a man-in-the-middle attack. Strong encryption is needed between your computer and the destination if you want to ensure data security.  rlogin, rsh and rcp rlogin was introduced in BSD 4.2 in 1983, and has been distributed with many UNIX-like systems alongside Telnet until recently. rlogin was used widely during the 80s and much of the 90s.  Just like Telnet, a user could log into the remote system with a password, but rlogin additionally allowed automatic  passwordless  logins for users on trusted remote computers. rlogin also worked better than telnet for remote administration, as it worked correctly with certain characters and commands where telnet required extra translation.  However, like Telnet, rlogin still used plain text communications over TCP port 513 by default. On top of that, rlogin also didn’t have many safeguards against clients spoofing their true identities. Some of rlogin’s intrinsic flaws were highlighted in a 1998 report by Carnegie Mellon, rlogin: The Untold Story.  rsh  “remote shell”  is a command line program used alongside rlogin to execute individual shell commands remotely, and rcp  “remote copy”  is   used for remote file copies. rsh and rcp inherited the same security problems as rlogin, since they use the same connection method  over different ports .  SSH Secure Shell was created in 1995 by Finland native Tatu Ylönen, in response to a password-sniffing attack at his university. Seeing the flaws in plain text communication for secure information, Tatu created Secure Shell SSH with a strong emphasis on encryption and security.  His version of SSH was developed for a few years as freeware with liberal licensing, but as his SSH Communications Security Corporation began limiting the license and commercializing SSH, alternative forks began to gain in popularity. The most popular fork, OSSH, by Swedish programmer Bjoern Groenvall, was chosen as a starting point by some developers from the OpenBSD project.  OpenBSD was  and still is!  a highly secure, free version of BSD UNIX, and the project’s developers needed a secure remote communication protocol, so a few project members worked to clean up and improve OSSH so it could be included in OpenBSD’s 2.6 release in December 1999. From there, it was quickly ported and adopted for all major versions of Linux, and is now ubiquitous in the world of POSIX-compliant operating systems.  How does SSH work, and what makes it better than telnet or rlogin? It starts with the basic connection. SSH connection encryption works similarly to SSL for secure HTTP connections, but its authentication layer adds more security:  1. When you enter ssh user@example.host to connect to the  example.host server as user, your client and the host exchange keys.  2. If you’re connecting to a host the first time, or if the host’s key has  changed since last time you connected  this happens often when connecting via DNS rather than directly by IP , SSH will prompt you for your approval of the host key.  3. If you have a private key in your ~ .ssh folder that matches one of the  keys in ~ .ssh authorized_keys on the remote system, the   connection will continue to step 4. Otherwise, if password authentication is allowed, SSH will prompt you for your password. There are other authentication methods as well, such as Kerberos, but they are less common and not covered in this book.  4. The transferred key is used to create a session key that’s used for the  remainder of the connection, encrypting all communication with a cipher such as AES, 3DES, Blowfish or RC4  ‘arcfour’ .  5. The connection remains encrypted and persists until you exit out of the  remote connection  in the case of an interactive session , or until the operation being performed  an scp or sftp file transfer, for example  is complete.  SSH uses encrypted keys to identify the client and host  which adds a layer of security over telnet and rlogin’s defaults , and then sets up a per- session encrypted channel for further communication. This same connection method is used for interactive ssh sessions, as well as for services like:  scp  secure copy , SSH’s counterpart to rlogin’s rcp. sftp  secure FTP , SSH’s client server file transfer protocol. SSH port forwarding  so you can run services securely over remote servers . SSH X11 forwarding  so you can use X windows securely .   A full list of features is available on OpenBSD’s site: OpenSSH Features .  The full suite of SSH packages also includes helpful utilities like ssh- keygen, which generates public private key pairs suitable for use when connecting via SSH. You can also install the utility ssh-copy-id, which speeds up the process of manually adding your identity file to a remote server.  SSH is fairly secure by default—certainly more so than telnet or rlogin’s default configuration—but for even greater security, there are a few extra settings you should use  all of these settings are configured in  etc ssh sshd_config, and require a restart of the sshd service to take effect :   1. Disable password-based SSH authentication. Even though  passwords are sent in the clear, disabling password-based authentication makes it impossible for brute-force password attacks to even be attempted, even if you have the additional  and recommended  layer of something like Fail2Ban running. Set PasswordAuthentication no in the configuration.  2. Disable root account remote login. You shouldn’t log in as the root  user regardless  use sudo instead , but to reinforce this good habit, disable remote root user account login by setting PermitRootLogin no in the configuration. If you need to perform actions as root, either use sudo  preferred , or if it’s absolutely necessary to work interactively as root, login with a normal account, then su to the root account.  3. Explicitly allow deny SSH for users. You can enable or disable SSH  access for particular users on your system with AllowUsers and DenyUsers. To allow only ‘John’ to log in, the rule would be AllowUsers John. To allow any user except John to log in, the rule would be DenyUsers John.  4. Use a non-standard port. You can change the default SSH port from  22 to something more obscure, like 2849, and prevent thousands of ‘script kiddie’ attacks that look for servers responding on port 22. While security through obscurity is no substitute for actually securing SSH overall, it can provide a slight extra layer of protection. To change the port, set Port [new-port-number] in the configuration.  We’ll cover how Ansible can help configure some of these particular options in SSH in the next section.  The evolution of SSH and the future of remote access It has been over a decade since OpenSSH became the de facto standard of remote access protocols, and in that time, Internet connectivity has changed dramatically. For reliable, low-latency LAN and Internet connections, SSH is still the king due to its simplicity, speed, and security. But in high-latency environments  think 3G or 4G mobile network connections, or satellite uplinks , using SSH can be a slow and painful experience.  In some circumstances, just establishing a connection can take some time. Additionally, once connected, the delay inherent in SSH’s TCP interface    where every packet must reach its destination and be acknowledged before further input will be accepted  means entering commands or viewing progress over a high-latency connection is an exercise in frustration.  Mosh, “the mobile shell”, a new alternative to SSH, uses SSH to establish an initial connection, then synchronizes the following local session with a remote session on the server via UDP.  Using UDP instead of TCP requires Mosh to do a little extra behind-the- scenes work to synchronize the local and remote sessions  instead of sending all local keystrokes over the wire serially via TCP, then waiting for stdout and stderr to be returned, like SSH .  Mosh also promises better UTF-8 support than SSH, and is well supported by all the major POSIX-like operating systems  and can even run inside Google Chrome! .  It will be interesting to see where the future leads with regard to remote terminal access, but one thing is for sure: Ansible will continue to support the most secure, fast, and reliable connection methods to help you build and manage your infrastructure!  Use secure and encrypted communication We spent a lot of time discussing SSH’s heritage and the way it works because it is, in many ways, the foundation of a secure infrastructure—in almost every circumstance, you will allow SSH remote access for your servers, so it’s important you know how it works, and how to configure it to ensure you always administer the server securely, over an encrypted connection.  Let’s look at the security settings configured in  etc ssh sshd_config  mentioned earlier , and how we can control them with Ansible.  For our secure server, we want to disable password-based SSH authentication  make sure you can already log in via your SSH key before you do this! , disable remote root login, and change the port over which SSH operates. Let’s do it!    1 - hosts: example   2   tasks:   3     - name: Update SSH configuration to be more secure.   4       lineinfile:   5         dest:  etc ssh sshd_config   6         regexp: "{{ item.regexp }}"   7         line: "{{ item.line }}"   8         state: present   9       with_items:  10         - {  11           regexp: "^PasswordAuthentication",  12           line: "PasswordAuthentication no"  13         }  14         - {  15           regexp: "^PermitRootLogin",  16           line: "PermitRootLogin no"  17         }  18         - {  19           regexp: "^Port",  20           line: "Port 2849"  21         }  22       notify: restart ssh  23   24   handlers:  25     - name: restart ssh  26       service: name=ssh state=restarted   In this extremely simple playbook, we set three options in SSH configuration  PasswordAuthentication no, PermitRootLogin no, and Port 2849  using Ansible’s lineinfile module, then use a handler we define in the handlers section to restart the ssh service.  Note that the task and handler defined here would probably be in separate files in a real-world playbook .  Note that if you change certain SSH settings, like the port for SSH, you will need to make sure Ansible’s inventory is updated. You can explicitly define the SSH port for a host with the option ansible_ssh_port, and the local path to a private key file  identity file  with ansible_ssh_private_key_file, though Ansible uses keys defined by your ssh-agent setup, so typically a manual definition of the key file is not required.  Disable root login and use sudo   We’ve already disabled root login with Ansible’s lineinfile module in the previous section, but we’ll cover a general Linux best practice here: don’t use the root account if you don’t absolutely need to use it.  Linux’s sudo allows you  or other users  to run certain commands with root privileges  by default—you can also run commands as another user , ensuring you can do things that need elevated privileges without requiring you to be logged in as root  or another user .  Using sudo also forces you to be more explicit when performing certain actions with security implications, which is always a good thing. You don’t want to accidentally delete a necessary file, or turn off a required service, which is easy to do if you’re root.  In Ansible, it’s preferred you log into the remote server with a normal or admin-level system account, and use the sudo parameter with a value of yes with any play or playbook include that needs elevated privileges. For example, if restarting Apache requires elevated privileges, you would write the play like so:  - name: Restart Apache.    service: name=httpd state=restarted    sudo: yes   You can also add sudo_user: [username] to a task to specify a specific user account to use with sudo  this will only apply if sudo is already set on the task or in the playbook .  You can also use Ansible to control sudo’s configuration, defining who should have access to what commands and whether the user should be required to enter a password, among other things.  As an example, we can set up the user johndoe with permission to use any command as root via sudo by adding a line in the  etc sudoers file with Ansible’s lineinfile module:  - name: Add sudo group rights for deployment user.    lineinfile:      dest:  etc sudoers      regexp: '^%johndoe'        line: 'johndoe ALL= ALL  NOPASSWD: ALL'      state: present   If you’re ever editing the sudoers file by hand, you should use visudo, which validates your changes and makes sure you don’t break sudo when you save the changes. When using Ansible with lineinfile, you have to use caution when making changes, and make sure your syntax is correct.  Another way of changing the sudoers file, and ensuring the integrity of the file, is to create a sudoers file locally, and copy it using Ansible’s copy module, with a validation command, like so:  - name: Copy validated sudoers file into place.    copy:      src: sudoers      dest:  etc sudoers      validate: 'visudo -cf %s'   The %s is a placeholder for the file’s path, and will be filled in by Ansible before the sudoers file is copied into its final destination. The same parameter can be passed into Ansible’s template module, if you need to copy a filled-in template to the server instead of a static file.  The sudoers file syntax is very powerful and flexible, but also a bit obtuse. Read the entire Sudoers Manual for all the details, or check out the sample sudoers file for some practical examples.  Remove unused software, open only required ports Before the widespread use of configuration management tools for servers, when snowflake servers were the norm, many servers would become bloated with extra software no longer in active use, open ports for old services that are no longer needed, and old configuration settings serving no purpose other than to act as a potential attack vector.  If you’re not actively using a piece of software, or there’s a cron task running that isn’t required, get rid of it. If you’re using Ansible for your entire infrastructure, this shouldn’t be an issue, since you could just bring   up new servers to replace old ones when you have major configuration and or package changes. But if not, consider adding in a ‘cleanup’ role or at least a task to remove packages that shouldn’t be installed, like:  1 - name: Remove unused packages.  2   apt: name={{ item }} state=absent purge=yes  3   with_items:  4     - apache2  5     - nano  6     - mailutils   With modules like yum, apt, file, and mysql_db, a state=absent parameter means Ansible will remove whatever packages, files or databases you want, and will check to make sure this is still the case during future runs of your playbook.  Opening only required ports  and, as a secondary  is something to be done by a simple set of firewall rules. This will be covered fully in the “Use a properly-configured firewall” section, but as an example, don’t leave port 25 open on your server unless your server will be used as an SMTP relay server. Further, make sure the services you have listening on your open ports are configured to only allow access from trusted clients.  Use the principle of least privilege Users, applications, and processes should only be able to access information  files  and resources  memory, network ports, etc  that are necessary for their operation.  Many of the other basic security measures in this chapter are tangentially related to the principle of least privilege, but user account configuration and file permissions are two main areas that are directly related to the principle.  User account configuration New user accounts, by default, have fairly limited permissions on a Linux server. They usually have a home folder, over which they have complete control, but any other folder or file on the system is only available for reading, writing, or execution if the folder has group permissions set.   Usually, users can gain access to other files and services through two methods:  1. Adding the user to another group with wider access privileges. 2. Allowing the user to use the sudo command to execute commands and  access files as root or another user.  For the former method, please read the next section on file permissions to learn how to limit access. For the latter, please make sure you understand the use of sudoers as explained earlier in this chapter.  File permissions Every Ansible module that deals with files has file ownership and permission parameters available, including owner, group, and mode. Almost every time you handle files  using copy, template, file, etc. , you should explicitly define the correct permissions and ownership. For example, for a configuration file  in our example, the GitLab configuration file  that should only be readable or writeable by the root user, set the following:  1 - name: Configure the GitLab global configuration file.  2   file:  3     path:  etc gitlab gitlab.rb  4     owner: root  5     group: root  6     mode: 0600    File permissions may seem a bit obtuse, and sometimes, they may cause headaches. But in reality, using octal numbers to represent file permissions is a helpful way to encapsulate a lot of configuration in three simple numbers. The main thing to remember is the following: for each of the file’s user, group, and for everyone  each of the three digits , use the following digits to represent permission levels:  7: rwx  read write execute   6: rw-  read write   5: r-x  read execute   4: r--  read   3: -wx  write execute   2: -w-  write   1: --x  execute   0: ---  no permissions    In simpler terms, 4 = read, 2 = write and 1 = execute. Therefore read  4  and write  2  is 6 in the octal representation, and read  4  and execute  1  is 5.  Less experienced admins are overly permissive, setting files and directories to 777 to fix issues they have with their applications. To allow one user  for example, your webserver user, httpd or nginx  access to a directory or some files, you should consider setting the directory’s or files’ group to the user’s group instead of giving permissions to every user on the system!  For example, if you have a directory of web application files, the user  or in Ansible’s terminology, “owner”  might be your personal user account, or a deployment or service account on the server. Set the group for the files to a group the webserver user is in, and the webserver should now be able to access the files  assuming you have the same permissions set for the user and group, like 664 .  Update the OS and installed software Every year, hundreds of security updates are released for the packages running on your servers, some of them fixing critical bugs. If you don’t keep your server software up to date, you will be extremely vulnerable, especially when large exposures like Heartbleed are uncovered.  At a minimum, you should schedule regular patch maintenance and package upgrade windows, and make sure you test the upgrades and patches on non-   critical servers to make sure your applications work before applying the same on your production infrastructure.  With Ansible, since you already have your entire infrastructure described via Ansible inventories, you should be able to use a command like the following to upgrade all installed packages on a RedHat-based system:  $ ansible webservers -m yum -a "name=* state=latest"   On a Debian-based system, the syntax is similar:  $ ansible webservers -m apt -a "upgrade=dist update_cache=yes"   The above commands will upgrade everything installed on your server. Sometimes, you only want to install security-related updates, or exclude certain packages. In those cases, you need to configure yum or apt to tell them what to do  edit  etc yum.conf for yum on RedHat-based systems, or use apt-mark hold [package-name] to keep a certain package at its current version on Debian-based systems .  Automating updates Fully automated daily or weekly package and system upgrades provide even greater security. Not every environment or corporation can accommodate frequent automated upgrades  especially if your application has been known to break due to past package updates, or relies on custom builds or specific package versions , but if you can do it for your servers, it will increase the depth of your infrastructure’s security.  As mentioned in an earlier sidebar, GPG package signature checking is enabled by default for all package-related functionality. It’s best to leave GPG checks in place, and import keys from trusted sources when necessary, especially when using automatic updates, if you want to prevent potentially insecure packages from being installed on your servers!  Automating updates for RedHat-based systems RedHat 6 and later  and modern versions of Fedora, and RedHat derivatives like CentOS  uses a simple cron-based package, yum-cron, for automatic   updates. For basic, set-and-forget usage, install yum-cron and make sure it’s started and set to run on system boot:  1 - name: Install yum-cron.  2   yum: name=yum-cron state=installed  3   4 - name: Ensure yum-cron is running and enabled on boot.  5   service: name=yum-cron state=started enabled=yes   Further configuration  such as packages to exclude from automatic updates  can be done in the yum.conf file, at  etc yum.conf.  Automating updates for Debian-based systems Debian and its derivatives typically use the unattended-upgrades package to configure automatic updates. Like yum-cron, it is easy to install, and its configuration is placed in a variety of files within  etc apt apt.conf.d :   1 - name: Install unattended upgrades package.   2   apt: name=unattended-upgrades state=installed   3    4 - name: Copy unattended-upgrades configuration files in place.   5   template:   6     src: ".. templates {{ item }}.j2"   7     dest: " etc apt apt.conf.d {{ item }}"   8     owner: root   9     group: root  10     mode: 0644  11   with_items:  12     - 10periodic  13     - 50unattended-upgrades   The template files copied in the second task should look something like the following:  1  File:  etc apt apt.conf.d 10periodic  2 APT::Periodic::Update-Package-Lists "1";  3 APT::Periodic::Download-Upgradeable-Packages "1";  4 APT::Periodic::AutocleanInterval "7";  5 APT::Periodic::Unattended-Upgrade "1";   This file provides configuration for the apt script that runs as part of the unattended upgrades package, and tells apt whether to enable unattended upgrades.   1  File:  etc apt apt.conf.d 50unattended-upgrades  2 Unattended-Upgrade::Automatic-Reboot "false";  3   4 Unattended-Upgrade::Allowed-Origins {  5         "Ubuntu lucid-security";  6         "Ubuntu lucid-updates";  7 };   This file provides further configuration for unattended upgrades, like whether to automatically restart the server for package and kernel upgrades that require a reboot  make sure, if you have this set to false, that you get notifications or check in on your servers so you know when they’ll need a manual reboot! , or what apt sources should be checked for updated packages.  Use a properly-configured firewall If you were building a secure bank vault, you wouldn’t want to have a large array of doors and windows that lead into the vault. Rather, you’d build thick reinforced concrete walls, and maybe have one or two locked-down controlled-access doors.  Similarly, you shouldn’t close any port that isn’t explicitly required to remain open on all your servers—whether in a DMZ in your network or open the the entire Internet. There are dozens of different ways to manage firewalls nowadays, from iptables and helpful tools like ufw and firewalld that help make iptables configuration easier, to AWS security groups and other external firewall services.  Ansible includes built-in support for configuring server firewalls with ufw  common on newer Debian and Ubuntu distributions  and firewalld  common on newer Fedora, RedHat, and CentOS distributions .  Configuring a firewall with ufw on Debian or Ubuntu Below is an entire firewall configuration that will lock down most everything on a Debian or Ubuntu server, allowing traffic only through ports 22  SSH , 80  HTTP , and 123  NTP :   1 - name: Configure open ports with ufw.   2   ufw:     3     rule: "{{ item.rule }}"   4     port: "{{ item.port }}"   5     proto: "{{ item.proto }}"   6   with_items:   7     - { rule: 'allow', port: 22, proto: 'tcp' }   8     - { rule: 'allow', port: 80, proto: 'tcp' }   9     - { rule: 'allow', port: 123, proto: 'udp' }  10   11 - name: Configure default incoming outgoing rules with ufw.  12   ufw:  13     direction: "{{ item.direction }}"  14     policy: "{{ item.policy }}"  15     state: enabled  16   with_items:  17     - { direction: outgoing, policy: allow }  18     - { direction: incoming, policy: deny }   If you run a playbook with the above rules, the log into the machine  or use the ansible command  and run sudo ufw status verbose, you should see the configuration has been updated to the following:  $ sudo ufw status verbose  Status: active  Logging: on  low   Default: deny  incoming , allow  outgoing , disabled  routed   New profiles: skip    To                         Action      From  --                         ------      ----  22 tcp                     ALLOW IN    Anywhere  80 tcp                     ALLOW IN    Anywhere  123 udp                    ALLOW IN    Anywhere  22 tcp  v6                 ALLOW IN    Anywhere  v6   80 tcp  v6                 ALLOW IN    Anywhere  v6   123 udp  v6                ALLOW IN    Anywhere  v6    Configuring a firewall with firewalld on RedHat, Fedora, or CentOS The same firewall configuration can be done via firewalld for RedHat- based systems with similar ease:   1 - name: Configure open ports with firewalld.   2   firewalld:   3     state: "{{ item.state }}"   4     port: "{{ item.port }}"   5     zone: external     6     immediate: yes   7     permanent: yes   8   with_items:   9     - { state: 'enabled', port: '22 tcp' }  10     - { state: 'enabled', port: '80 tcp' }  11     - { state: 'enabled', port: '123 udp' }   The immediate parameter was added in Ansible 1.9, and is required to make the rules effective immediately when the permanent parameter is set to yes. If you are running an older version of Ansible, you will need to restart to see your changes, or set permanent to no.  Note that firewalld doesn’t have a simple explicit command to allow setting default inbound outbound policies, but you can still use iptables commands or manage the firewall via XML files inside  etc firewalld.  If you run sudo firewall-cmd --zone=external --list-all, you should see the open ports:  $ sudo firewall-cmd --zone=external --list-all  external    interfaces:    sources:    services: ssh    ports: 123 udp 80 tcp 22 tcp    masquerade: yes    forward-ports:    icmp-blocks:    rich rules:   Some still prefer configuring firewalls with iptables  which can be obtuse, but is almost infinitely malleable . This approach is used in the geerlingguy.firewall role on Ansible Galaxy, which translates simple variables like firewall_allowed_tcp_ports and firewall_forwarded_tcp_ports into iptables rules, and provides a simple firewall service for loading firewall rules.  It doesn’t really matter what method you use to control access to your server, but the principle of least privilege applies here, as in most security-   related discussions: only allow access on ports that are absolutely necessary for the functionality of your server, and restrict the use of those ports to only the hosts or subnets that need access to the services listening on the ports.  When you’re building up a firewall, make sure that you don’t accidentally lock down ports or IP addresses that will lock you out of the server entirely, otherwise you’ll have to connect to the server through a local terminal connection and start over!  Make sure log files are populated and rotated Checking server logs is one of the most effective ways to not only see what attacks have taken place on a server, but also to see trends over time and predict high-traffic periods, potential attack vectors, and potential catastrophe.  But logs are completely worthless if they aren’t being populated with effective data, aren’t being monitored in any way, or are the cause of an outage! There are too many root cause analyses that conclude, “the server’s disk was full because log file x took up all the free space”. I have my eyes on you, 218.78.214.9…  1 sshd[19731]: input_userauth_request: invalid user db2admin   2 sshd[19731]: Received disconnect from 218.78.214.9: 11: Bye Bye   3 sshd[19732]: Invalid user jenkins from 218.78.214.9   4 sshd[19733]: input_userauth_request: invalid user jenkins   5 sshd[19733]: Received disconnect from 218.78.214.9: 11: Bye Bye   6 sshd[19734]: Invalid user jenkins from 218.78.214.9   7 sshd[19735]: input_userauth_request: invalid user jenkins   8 sshd[19735]: Received disconnect from 218.78.214.9: 11: Bye Bye   9 sshd[19736]: Invalid user minecraft from 218.78.214.9  10 sshd[19737]: input_userauth_request: invalid user minecraft  11 sshd[19737]: Received disconnect from 218.78.214.9: 11: Bye Bye   Only you will know what logs are the most important to monitor on your servers, but some of the most common ones are database slow query logs, webserver access and error logs, authorization logs, and cron logs. You can use tools like the ELK stack  demonstrated in a cookbook in Chapter 8 ,   Munin, Nagios, or even a hosted service to make sure logs are populated and monitored.  Additionally, you should always make sure log files are rotated and archived  according to your infrastructure’s needs  using a tool like logrotate, and you should have monitoring enabled on log file sizes so you have an early warning when a particular log file or directory grows a bit too large. There are a number of logrotate roles on Ansible Galaxy  e.g. Nick Hammond’s logrotate role  that make rotation configuration simple.  Monitor logins and block suspect IP addresses If you’ve ever set up a new server on the public internet and enabled SSH on port 22 with password-based login enabled, you know how quickly the deluge of script-based logins begins. Many honeypot servers detect hundreds or thousands of such attempts per hours.  Suffice it to say, if you allow password-based login  for SSH, for your web app, or for anything else for that matter , you need to implement some form of monitoring and rate limiting. At a most basic level  and this may be all you need , you should install a tool like Fail2Ban, which monitors log files and bans IP addresses when it detects too many unsuccessful login attempts in a given period of time.  For the most basic level of security, you should install Fail2Ban and use it’s default configuration, which will help you protect common application logins. Here’s a simple set of tasks you could add to your playbook to install Fail2Ban and make sure it’s started on either Debian or RedHat- based distributions:   1 - name: Install fail2ban  RedHat .   2   yum: name=fail2ban state=present enablerepo=epel   3   when: ansible_os_family == 'RedHat'   4    5 - name: Install fail2ban  Debian .   6   apt: name=fail2ban state=present   7   when: ansible_os_family == 'Debian'   8    9 - name: Ensure fail2ban is running and enabled on boot.  10   service: name=fail2ban state=started enabled=yes    Fail2Ban configuration is managed in a series of .conf files inside  etc fail2ban, and most of the simpler configuration can be done by overriding defaults in a local override file,  etc fail2ban jail.local. See the Fail2Ban manual for more information.  Use SELinux  Security-Enhanced Linux  or AppArmor SELinux and AppArmor are two different tools which allow you to construct security sandboxes for memory and filesystem access, so, for example, one application can’t easily access another application’s resources. It’s a little like user and group file permissions, but allowing far finer detail —with far more complexity.  You’d be forgiven if you disabled SELinux or AppArmor in the past; both require extra work to set up and configure for your particular servers, especially if you’re using less popular distribution packages  extremely popular packages like Apache and MySQL are extremely well supported out-of-the-box on most distributions .  However, both of these tools are excellent ways to add defense in depth to your infrastructure. You should already have decent configurations for firewalls, file permissions, users and groups, OS updates, etc. But if you’re running a web-facing application—especially one that runs on a server with any other applications—it’s great to have the extra protection SELinux or AppArmor provides from applications accessing things they shouldn’t.  SELinux is usually installed and enabled by default on Fedora, RedHat and CentOS systems, is available and supported on most other Linux platforms, and is widely supported through Ansible modules, so we’ll cover SELinux in a bit more depth.  To enable SELinux in targeted mode  which is the most secure mode without being almost impossible to work with , make sure the Python SELinux library is installed, then use Ansible’s selinux module:  - name: Install Python SELinux library.    yum: name=libselinux-python state=installed      - Ensure SELinux is enabled in `targeted` mode.    selinux: policy=targeted state=enforcing   Ansible also has a seboolean module that allows setting SELinux booleans. A very common setting for web servers involves setting the httpd_can_network_connect boolean:  - name: Ensure httpd can connect to the network.    seboolean: name=httpd_can_network_connect state=yes  persistent=yes   The Ansible file module also integrates well with SELinux, as you can set the four security context fields for a file or directory, one per parameter:  1. selevel 2. serole 3. setype 4. seuser  Building custom SELinux policies for more complex scenarios is out of the scope of this chapter, but you should be able to use tools like setroubleshoot, setroubleshoot-server, getsebool, and aureport to see what is being blocked, what booleans are available  and or enabled currently , and even get helpful notifications when SELinux denies access to an application. Read Getting started with SELinux for an excellent and concise introduction.  Next time you’re tempted to disable SELinux instead of fixing the underlying problem, spend a little time seeing if you can keep SELinux’s additional layer of protection by setting the correct boolean or configuring your filesystem correctly.  Summary and further reading This chapter contains a broad overview of some Linux security best practices, and how Ansible can help you conform to them. There is a wealth of good information on the Internet to help you secure your servers, including articles and publications like the following:   Linode Library: Linux Security Basics My First Five Minutes on a Server 20 Linux Server Hardening Security Tips Unix and Linux System Administration Handbook  Also, much of the security configuration in this chapter is encapsulated in a simple Ansible role on Ansible Galaxy, which you can use for your own servers: security role by geerlingguy.   _____________________________________    Bad planning on your part does not  \   constitute an emergency on my part.   \  Proverb                                -------------------------------------          \   ^__^           \   oo \_______               __ \        \ \                  ----w                            Chapter 11 - Automating Your Automation - Ansible Tower and CI CD  At this point, you should be able to convert almost any bit of your infrastructure’s configuration into Ansible playbooks, roles, and inventories. And before deploying any infrastructure changes, you should test the changes in a non-production environment  just like you would with application releases . Manually running a playbook that configures your entire infrastructure, then making sure it does what you expect, is a good start towards order and stability.  Since all your infrastructure is defined in code, you can start automating all the aspects of infrastructure deployment, and even run unit, functional, and integration tests on your infrastructure, just like you do for your applications.  This section will cover different levels of infrastructure automation and testing, and highlight tools and techniques you can use to automate and streamline infrastructure operations.  Ansible Tower Throughout this book, all the examples use Ansible’s CLI to run playbooks and report back the results. For smaller teams, especially when everyone on the team is well-versed in how to use Ansible, YAML syntax, and follows security best practices with playbooks and variables files, using the CLI can be a sustainable approach.  But for many organizations, there are needs that stretch basic CLI use too far:  The business needs detailed reporting of infrastructure deployments and failures, especially for audit purposes.   Team-based infrastructure management requires varying levels of involvement in playbook management, inventory management, and key and password access. A thorough visual overview of the current and historical playbook runs and server health helps identify potential issues before they affect the bottom line. Playbook scheduling can help ensure infrastructure remains in a known state.  Ansible Tower checks off these items—and many more—and provides a great mechanism for team-based Ansible usage. The product is currently free for teams managing ten or fewer servers  it’s basically an ‘unlimited trial’ mode , and has flexible pricing for teams managing dozens to thousands of servers.  While this book includes a brief overview of Tower, and how you can get started with Tower, it is highly recommended that you read through Ansible, Inc’s extensive Tower User Guide, which includes details this book won’t be covering such as LDAP integration and multiple-team playbook management workflows.  Getting and Installing Ansible Tower Ansible has a very thorough Ansible Tower User Guide, which details the installation and configuration of Ansible Tower. For the purposes of this chapter, since we just want to download and try out Tower locally, we are going to use Ansible’s official Vagrant box to quickly build an Ansible Tower VM.  Make sure you have Vagrant and VirtualBox installed, then create a directory  e.g. tower  and do the following within the directory:  1. vagrant init tower http:  vms.ansible.com ansible-tower- 2.1.4-virtualbox.box  Create a new Vagrantfile using the Tower base box from Ansible .  2. vagrant up  Build the Tower VM . 3. vagrant ssh  Log into the VM, and Tower will display a message  with connection information .   The above installation instructions and Vagrant box come from a blog post on Ansible’s official blog, Ansible Tower and Vagrant.  You can now visit the URL provided by the login welcome message  something like https:  10.42.0.42  , and after confirming a security exception for the Ansible Tower certificate, login with the credentials from step 3.  At this point, you will need to register a free trial license of Ansible Tower, which can be done following the instructions on the screen. The free trial allows you to use all of Tower’s features for up to 10 servers, and is great for experimenting and seeing how Tower fits into your workflow. After you get the license  it’s a block of JSON which you paste into the license field , you should get to Tower’s default dashboard page:  Ansible Tower’s Dashboard  Using Ansible Tower Ansible Tower is centered around the idea of organizing Projects  which run your playbooks via Jobs  and Inventories  which describe the servers on which your playbooks should be run  inside of Organizations. Organizations can then be set up with different levels of access based on Users and Credentials grouped in different Teams. It can be a little   overwhelming at first, but once you get the initial structure configured, you’ll see how powerful and flexible Tower’s Project workflow is.  Let’s get started with our first project!  The first step is to make sure you have a test playbook you can run using Ansible Tower. Generally, your playbooks should be stored in a source code repository  e.g. Git or Subversion , with Tower configured to check out the latest version of the playbook from the repository and run it. Since we’re only going to run a simple example, we will create a playbook in Tower’s default projects directory located in  var lib awx projects:  1. Log into the Tower VM: vagrant ssh 2. Switch to the awx user: sudo su - awx 3. Go to Tower’s default projects directory: cd   var lib awx projects  4. Create a new project directory: mkdir ansible-for-devops && cd  5. Create a new playbook file, main.yml, within the new directory, with  ansible-for-devops  the following contents:  1 ---  2 - hosts: all  3   gather_facts: no  4   connection: local  5   6   tasks:  7     - name: Check the date on the server.  8       command: date   Switch back to your web browser and get everything set up to run the test playbook inside Ansible Tower’s web UI:  1. Create a new Organization, called ‘Ansible for DevOps’. 2. Add a new User to the Organization, named John Doe, with the  username johndoe and password johndoe1234.  3. Create a new Team, called ‘DevOps Engineers’, in the ‘Ansible for  DevOps’ Organization.  4. Under the Team’s Credentials section, add in SSH credentials by selecting ‘Machine’ for the Credential type, and setting ‘Name’ to   Vagrant, ‘Type’ to Machine, ‘SSH Username’ to vagrant, and ‘SSH Password’ to vagrant.  5. Under the Team’s Projects section, add a new Project. Set the ‘Name’ to Tower Test, ‘Organization’ to Ansible for DevOps, ‘SCM Type’ to Manual, and ‘Playbook Directory’ to ansible-for-devops  Tower automatically detects all folders placed inside  var lib awx projects, but you could also use an alternate Project Base Path if you want to store projects elsewhere .  6. Under the Inventories section, add an Inventory. Set the ‘Name’ to Tower Local, and ‘Organization’ set to Ansible for DevOps. Once the inventory is saved: 1. Add a ‘Group’ with the Name localhost. Click on the group once it’s saved. 2. Add a ‘Host’ with the Host Name 127.0.0.1.  New Credentials have a somewhat dizzying array of options, and offer login and API key support for a variety of services, like SSH, AWS, Rackspace, VMWare vCenter, and SCM systems. If you can login to a system, Tower likely supports the login mechanism!  Now that we have all the structure for running playbooks configured, we need only create a Job Template so we can run the playbook on the localhost and see whether we’ve succeeded. Click on ‘Job Templates’, and create a new Job Template with the following configuration:  Name: Tower Test Inventory: Tower Local Project: Tower Test Playbook: main.yml Machine Credential: Vagrant  Save the Job Template, then click the small Rocketship button to start a job using the template. You’ll be redirected to a Job status page, which provides live updates of the job status, and then a summary of the playbook run when complete:   Tower Test job completed successfully!  You can view the playbook run’s standard output in real-time  or review it after the fact  with the ‘View standard out’ button. You can also stop a running job, delete a job’s record, or relaunch a job with the same parameters using the respective buttons on the job’s page.  The job’s dashboard page is very useful for giving an overview of how many hosts were successful, how many tasks resulted in changes, and the timing of the different parts of the playbook run.  Other Tower Features of Note In our simple walkthrough above, we used Tower to run a simple playbook on the local server; setting up Tower to run playbooks on real-world infastructure or other local VMs is just as easy, and the tools Ansible Tower provides are very handy, especially when working in larger team environments.  This book won’t walk through the entirety of Ansible Tower’s documentation, but a few other simple features you should try out include:  Setting up scheduled Job runs  especially with the ‘Check’ option instead of ‘Run’  for CI CD. Integrating user accounts and Teams with LDAP users and groups for automatic team-based project management.   Setting different levels of permissions for Users and Teams so certain users can edit certain jobs, others can only run certain jobs, and yet others can only view the results of job runs within an Organization. Configuring Ansible Vault credentials so you can easily and automatically use Vault-protected variables in your playbooks. Setting up Provisioning Callbacks so newly-provisioned servers can self-provision via a URL per Job Template. Surveys, which allow users to add extra information based on a ‘Survey’ of questions per job run. Inventory Scripts, which allow you to build inventory dynamically. Built-in Munin monitoring  to monitor the Tower server , available with the same admin credentials at https:  [tower- hostname] munin.  Ansible Tower continues to improve rapidly, and is one of the best ways to run Ansible Playbooks from a central CI CD-style server with team-based access and extremely detailed live and historical status reporting.  Tower Alternatives Ansible Tower is purpose-built for use with Ansible playbooks, but there are many other ways to run playbooks on your servers with a solid workflow. If price is a major concern, and you don’t need all the bells and whistles Tower provides, you can use other popular tools like Jenkins, Rundeck, or Go CI.  All these tools provide flexiblity and security for running Ansible Playbooks, and each one requires a different amount of setup and configuration before it will work well for common usage scenarios. One of the most popular and long-standing CI tools is Jenkins, so we’ll explore how to configure a similar Playbook run in Jenkins next.  Jenkins CI TODO.  Unit, Integration, and Functional Testing   When determining how you should test your infrastructure, you need to understand the different kinds of testing, and then determine the kinds of testing on which you should focus more effort.  Unit testing, when applied to applications, is testing that applies to the smallest units of code  usually functions or class methods . In Ansible, unit testing would typically apply to individual playbooks. You could run individual playbooks in an isolated environment, but that’s often not worth the effort. What is worth your effort is at least checking the playbook syntax, to make sure you didn’t just commit a YAML file that will break an entire deployment because of a missing quotation mark, or a whitespace issue!  Integration testing, which is definitely more valuable when it comes to Ansible, is the testing of small groupings of individual units of code, to make sure they work correctly together. Breaking your infrastructure definition into many task-specific roles and playbooks allows you to do this; if you’ve structured your playbooks so they have no or limited dependencies, you could test each role individually in a fresh virtual machine, before you use the role as part of a full infrastructure deployment.  Functional testing involves the whole shebang. Basically, you set up a complete infrastructure environment, and then run tests against it to make sure everything was successfully installed, deployed, and configured. Ansible’s own reporting is helpful in this kind of testing  and often, all that is necessary , and there are also external tools that can be used to test infrastructure even more deeply.  It is often possible to perform all the testing you need on your own local workstation, using Virtual Machines  as demonstrated in earlier chapters , using tools like VirtualBox or VMWare. And with most cloud services providing robust control APIs and hourly billing, it’s often simple, inexpensive, and just as fast to test directly on cloud instances that mirror your production infrastructure!  We’ll begin with some of the simplest tests you can run against Ansible configuration, along with some common debugging techniques, then   progress on to some more advanced, full-fledged functional testing methods using tools to fully automate the process.  Debugging and Asserting TODO:  debug fail assert  Checking syntax and performing dry runs TODO:  ansible-playbook --syntax-check ansible-playbook --check Ansible lint  Automated testing on GitHub using Travis CI Automated testing using a continuous integration tool like Travis CI  which is free for public projects and integrated very well with GitHub  allows you to run tests against Ansible playbooks or roles you have hosted on GitHub with every commit.  There are four main things that should be tested when building and maintaining Ansible playbooks or roles:  1. The playbook or role’s syntax  are all the .yml files formatted  2. Whether the playbook or role will run through all the included tasks  3. The playbook or role’s idempotence  if run again, it should not make  4. The playbook or role’s success  does the role do what it should be  correctly? .  without failing.  any changes! .  doing? .  Ultimately, the most important aspect is 4, because what’s the point of a playbook or role if it doesn’t do what you want it to do  e.g. start a web server, configure a database, deploy an app, etc. ?   We’re going to assume, for the rest of this example, that you’re testing a role you have on GitHub, though the example can be applied just as easily for standalone Ansible playbooks.  Setting up a role for testing Since you’re going to need a simple Ansible playbook and inventory file to test your role, you can create both inside a new ‘tests’ directory in your Ansible role:  1  Directory structure:  2 my_role   3   tests   4     test.yml <-- your test playbook  5     inventory <-- an inventory file to use with the playbook   We just want to tell Ansible to run commands on the local machine  we’ll use the –connection=local option when running the test playbook .  Inside the inventory file, add:  1 localhost   Inside test.yml, add:  1 ---  2 - hosts: localhost  3   remote_user: root  4   roles:  5     - github-role-project-name   Substitude your own role name for github-role-project-name  e.g. ansible-role-django . This is a typical Ansible playbook, and we tell Ansible to run the tasks on localhost, with the root user  otherwise, you could run tasks with travis if you want, and use sudo on certain tasks . You can add vars, vars_files, etc. if you want, but we’ll keep things simple, because for many smaller roles, the role is pre-packaged with sane defaults and all the other info it needs to run.  The next step is to add a .travis.yml file to your role so Travis CI will pick it up and use it for testing. Add that file to the root level of your role, and add the following to kick things off:    1 ---  2 language: python  3 python: "2.7"  4    5 before_install:  6    Make sure everything's up to date.  7   - sudo apt-get update -qq  8    9 install: 10    Install Ansible. 11   - pip install ansible 12   13    Add ansible.cfg to pick up roles path. 14   - "printf '[defaults]\nroles_path = .. ' > ansible.cfg" 15   16 script: 17    We'll add some commands to test the role here.  The only surprising part here is the printf line in the install section; I’ve added that line to create a quick and dirty ansible.cfg configuration file Ansible will use to set the roles_path one directory up from the current working directory. That way, we can include roles like github-role- project-name, or if we use ansible-galaxy to download dependencies  as another command in the install section , we can just use - galaxy-role- name-here to include that role in our test.yml playbook.  Now that we have the basic structure, it’s time to start adding the commands to test our role.  Testing the role’s syntax This is the easiest test; ansible-playbook has a built in command that will check a playbook’s syntax  including all the included files and roles , and return 0 if there are no problems, or an error code and some output if there were any syntax issues.  1 ansible-playbook -i tests inventory tests test.yml --syntax-check   Add this as a command in the script section of .travis.yml:  1 script:  2    Check the role playbook's syntax.  3   - ansible-playbook -i tests inventory tests test.yml --syntax- check    If there are any syntax errors, Travis will fail the build and output the errors in the log.  Role success - first run The next aspect to check is whether the role runs correctly or fails on its first run.  1  Run the role playbook with ansible-playbook.  2 - "ansible-playbook -i tests inventory tests test.yml -- connection=local --sudo"   This is a basic ansible-playbook command, which runs the playbook test.yml against the local host, using --sudo, and with the inventory file we added to the role’s tests directory.  Ansible returns a non-zero exit code if the playbook run fails, so Travis will know whether the command succeeded or failed.  Role idempotence Another important test is the idempotence test—does the role change anything if it runs a second time? It should not, since all tasks you perform via Ansible should be idempotent  ensuring a static unchanging configuration on subsequent runs with the same settings .  1  Run the role playbook again, checking to make sure it's  idempotent.  2 - >  3   ansible-playbook -i tests inventory tests test.yml -- connection=local --sudo  4    grep -q 'changed=0.*failed=0'  5   &&  echo 'Idempotence test: pass' && exit 0   6     echo 'Idempotence test: fail' && exit 1    This command runs the exact same command as before, but pipes the results through grep, which checks to make sure ‘changed’ and ‘failed’ both report 0. If there were no changes or failures, the idempotence test passes  and Travis sees the 0 exit and is happy , but if there were any changes or failures, the test fails  and Travis sees the 1 exit and reports a build failure .  Role success - final result   The last thing I check is whether the role actually did what it was supposed to do. If it configured a web server, is the server responding on port 80 or 443 without any errors? If it configured a command line application, does that command line application work when invoked, and do the things it’s supposed to do?  1  Request a page via the web server, to make sure it's running and  responds.  2 - "curl http:  localhost "   In this example, I’m testing a web server by loading ‘localhost’; curl will exit with a 0 status  and dump the output of the web server’s response  if the server responds with a 200 OK status, or will exit with a non-zero status if the server responds with an error status  like 500  or is unavailable.  Taking this a step further, you could even run a deployed application or service’s own automated tests after ansible is finished with the deployment, thus testing your infrastructure and application in one go—but we’re getting ahead of ourselves here… that’s a topic for later!  Some notes about Travis CI There are a few things you need to know about Travis CI, especially if you’re testing Ansible, which will rely heavily on the VM environment inside which it is running:  Ubuntu 12.04: As of this writing, the only OS available via Travis CI is Ubuntu 12.04. Most of my roles work with Ubuntu Debian RedHat CentOS, so it’s not an issue for me… but if your roles strictly target a non-Debian-flavored distro, you probably won’t get much mileage out of Travis.  There is an open issue to get Travis upgraded to Ubuntu 14.04, at least . Preinstalled packages: Travis CI comes with a bunch of services installed out of the box, like MySQL, Elasticsearch, Ruby, etc. In the .travis.yml before_install section, you may need to do some apt- get remove --purge [package] commands and or other cleanup commands to make sure the VM is fresh for your Ansible role’s run. Networking Disk Memory: Travis CI continously shifts the VM specs you’re using, so don’t assume you’ll have X amount of RAM,   disk space, or network capacity. You can add commands like cat  proc cpuinfo, cat  proc meminfo, free -m, etc. in the .travis.yml before_install section if you need to figure out the resources available in your VM.  See much more information about the VM environment on the Travis CI Build Environment page.  Real-world examples This style of testing is integrated into many of the geerlingguy.* roles on Ansible Galaxy; here are a few example roles that use Travis CI integration in the way outlined above:  https:  github.com geerlingguy ansible-role-apache https:  github.com geerlingguy ansible-role-gitlab https:  github.com geerlingguy ansible-role-mysql  Automated testing with test-runner TODO:  debops test-runner  Functional testing using serverspec TODO:  server-spec Caveat: Ansible already testing things as it goes. Do you really need another layer of testing?  Summary Tools to help manage, test, and run playbooks regularly and easily, such as Travis CI, Jenkins, and Ansible Tower, also help deliver certainty when applying changes to your infrastructure using Ansible. In addition the information contained in this chapter, read through the Testing Strategies documentation in Ansible’s documentation for a comprehensive overview of infrastructure testing and Ansible.    ________________________________________    The first rule of any technology used  \   in a business is that automation          applied to an efficient operation will    magnify the efficiency. The second is     that automation applied to an             inefficient operation will magnify the   \ inefficiency.  Bill Gates                  ----------------------------------------          \   ^__^           \   oo \_______               __ \        \ \                  ----w                            Appendix A - Using Ansible on Windows workstations  Ansible works primarily over the SSH protocol, which is supported natively by most every server, workstation, and operating system on the planet, with one exception—Microsoft’s venerable Windows OS.  To use SSH on Windows, you need additional software. But Ansible also requires other utilities and subsystems only present on Linux or other UNIX-like operating systems. This poses a problem for many system administrators who are either forced to use or have chosen to use Windows as their primary OS.  This appendix will guide Windows users through the author’s preferred method of using Ansible on a Windows workstation.  Ansible 1.7 and later can be used to manage Windows hosts  see Ansible’s Windows Support documentation , but it can’t be run from within Windows natively. You will still need to follow the instructions here to run the Ansible client on a Windows host, if you are stuck on Windows and want to use Ansible to manage other  Windows, Linux, Mac, etc.  hosts.  Prerequisites Our goal is to have a virtual machine running Linux running on your computer. The easiest way to do this is to download and install Vagrant and VirtualBox  both 100% free! , and then use Vagrant to install Linux, and PuTTY to connect and use Ansible. Here are the links to download these applications:  1. Vagrant 2. VirtualBox 3. PuTTY   Once you’ve installed all three applications, you can use either the command prompt  cmd , Windows PowerShell, or a Linux terminal emulator like Cygwin to boot up a basic Linux VM with Vagrant  if you use Cygwin, which is not covered here, you could install its SSH component and use it for SSH, and avoid using PuTTY .  Set up an Ubuntu Linux Virtual Machine Open PowerShell  open the Start Menu or go to the Windows home and type in ‘PowerShell’ , and change directory to a place where you will store some metadata about the virtual machine you’re about to boot. I like having a ‘VMs’ folder in my home directory to contain all my virtual machines:   Change directory to your user directory.  PS > cd C: Users [username]   Make a 'VMs' directory and cd to it.  PS > md -Name VMs  PS > cd VMs   Make a 'Ubuntu64' directory and cd to it.  PS > md -Name ubuntu-precise-64  PS > cd ubuntu-precise-64   Now, use vagrant to create the scaffolding for our new virtual machine:  PS > vagrant init precise64  http:  files.vagrantup.com precise64.box   Vagrant creates a ‘Vagrantfile’ describing a basic Ubuntu Precise  12.04  64-bit virtual machine in the current directory, and is now ready for you to run vagrant up to download and build the machine. Run vagrant up, and wait for the box to be downloaded and installed:  PS > vagrant up   After a few minutes, the box will be downloaded and a new virtual machine set up inside VirtualBox. Vagrant will boot and configure the machine according to the defaults defined in the Vagrantfile. Once the VM is booted, and you’re back at the command prompt, it’s time to log into the VM.  Log into the Virtual Machine   Use vagrant ssh-config to grab the SSH connection details, which you will then enter into PuTTY to connect to the VM.  PS > vagrant ssh-config   It should show something like:  Host default    Hostname 127.0.0.1    User vagrant    Port 2222    UserKnownHostsFile  dev null    StrictHostKeyChecking no    PasswordAuthentication no    IdentityFile C: Users [username] .vagrant.d insecure_private_key    IdentitiesOnly yes    LogLevel FATAL   The lines we’re interested in are the Hostname, User, Port, and IdentityFile.  Launch PuTTY, and enter the connection details:  Host Name  or IP address : 127.0.0.1 Port: 2222  Click Open to connect  you can save the connection details by entering a name in the ‘Saved Sessions’ field and clicking ‘Save’ to save the details , and if you receive a Security Alert concerning the server’s host key, click ‘Yes’ to tell PuTTY to trust the host.  PuTTY will ask for login credentials; we’ll use the default login for a Vagrant box  vagrant for both the username and password :  login as: vagrant  vagrant@127.0.0.1's password: vagrant   You should now be connected to the virtual machine, and see the message of the day:  Welcome to Ubuntu 12.04 LTS  GN Linux 3.2.0-23-generic x86_64       * Documentation: https:  help.ubuntu.com   Welcome to your Vagrant-built virtual machine.    Last login:   from    vagrant@precise64:~$   If you see this prompt, you’re logged in, and you can start administering the VM. The next  and final  step is to install Ansible.  This example uses PuTTY to log into the VM, but other applications like Cygwin or Git for Windows work just as well, and may be easier to use. Since these alternatives have built-in SSH support, you don’t need to do any extra connection configuration, or even launch the apps manually; just cd to the same location as the Vagrantfile, and enter vagrant ssh!  Install Ansible Before installing Ansible, make sure your package list is up to date by updating apt-get:  $ sudo apt-get update   Ansible can be installed in a variety of ways, but the easiest is to use pip, a simple Python package manager. Python should already be installed on the system, but pip may not be, so let’s install it, along with Python’s development header files  which are in the python-dev package .  $ sudo apt-get install -y python-pip python-dev   After the installation is complete, installing Ansible is simple:  $ sudo pip install ansible   After Ansible and all its dependencies are downloaded and installed, make sure Ansible is running and working:  $ ansible --version  ansible 1.9.0    Upgrading Ansible is also easy with pip: Run sudo pip install --upgrade ansible to get the latest version.  Summary You should now have Ansible installed within a virtual machine running on your Windows workstation. You can control the virtual machine with Vagrant  cd to the location of the Vagrantfile , using up to boot or wake the VM, halt to shut down the VM, or suspend to sleep the VM. You can log into the VM using PuTTY and manually entering a username and password, or using Cygwin or Git’s Windows shell and the vagrant ssh command.  Use Ansible from within the virtual machine just as you would on a Linux or Mac workstation directly. If you need to share files between your Windows environment and the VM, Vagrant conveniently maps  vagrant on the VM to the same folder where your Vagrantfile is located. You can also connect between the two via other methods  SSH, SMB, SFTP etc.  if you so desire.   Appendix B - Ansible Best Practices and Conventions  Ansible is a simple, flexible tool, and allows for a variety of organization methods and configuration syntaxes. You might like to have many tasks in one main file, or few tasks in many files. You might prefer defining variables in group variable files, host variable files, inventories, or elsewhere, or you might try to find ways of avoiding variables in inventories altogether.  There are few universal best practices in Ansible, but this appendix contains many helpful suggestions for organizing playbooks, writing tasks, using roles, and otherwise build infrastructure with Ansible.  TODO:  Incorporate other commonly-asked-about best practices  ongoing . Best Practices Ansible  Real Life  Good Practices  Playbook Organization As playbooks are Ansible’s bread and butter, it’s important to organize them in a logical manner, so you can easily write, debug, and maintain them.  Write comments and use name liberally Many tasks you write will be fairly obvious when you write them, but less so six months later when you are making changes. Just like application code, Ansible playbooks should be documented, at least minimally, so you can spend less time familiarizing yourself with what a particular task is supposed to do, and more time fixing problems or extending your playbooks.   In YAML, you can write a comment by starting a line with a hash   . If your comment spans multiple lines, start each line with .  It’s also a good idea to use a name for every task you write, besides the most trivial. If you’re using the git module to check out a specific tag, use a name to indicate what repository you’re using, why a tag instead of a commit hash, etc. This way, whenever your playbook is run, you’ll see the comment you wrote and be assured what’s going on.  - hosts: all      tasks:         This task takes up to five minutes and is required so we will  have       access to the images used in our application.      - name: Copy the entire file repository to the application.        copy:          src: ...   This advice assumes, of course, that your comments actually indicate what’s happening in your playbooks! Generally, I use full sentences with a period for all comments and names, but if you’d like to use a slightly different style, that’s not an issue. Just try to be consistent, and remember that bad comments are worse than no comments at all.  Include related variables and tasks If you find yourself writing a playbook that’s over 50-100 lines and configures three or four different applications or services, it may help to separate each group of tasks into a separate file, and use include to place them in a playbook.  Additionally, variables are usually better left in their own file and included using vars_files rather than defined inline with a playbook.  - hosts: all      vars_files:      - vars main.yml      handlers:      - include: handlers handlers.yml        tasks:      - include: tasks init.yml      - include: tasks database.yml      - include: tasks app.yml   Using a more hierarchical model like this allows you to see what your playbook is doing at a higher level, and also lets you manage each portion of a configuration or deployment separately. I generally split tasks into separate files once I reach 15-20 tasks in a given file.  Use Roles to bundle logical groupings of configuration Along the same lines as using included files to better organize your playbooks and separate bits of configuration logically, Ansible roles can supercharge your ability to manage infrastructure well.  Using loosely-coupled roles to configure individual components of your servers  like databases, application deployments, the networking stack, monitoring packages, etc.  allows you to write configuration once, and use it on all your servers, regardless of their role.  Consider that you will probably configure something like NTP  Network Time Protocol  on every single server you manage, or at a minimum, set a timezone for the server. Instead of adding two or three tasks to every playbook you manage, set up a role  maybe call it time or ntp  that does this configuration, and use a few variables to allow different groups of servers to have customized settings.  Additionally, if you learn to build roles in a generic fashion, and for multiple platforms, you could even share it on Ansible Galaxy so others can use the role and help you make it more robust and efficient!  YAML Conventions and Best Practices YAML is a human-readable, machine-parseable syntax that allows for almost any list, map, or array structure to be described using a few basic conventions, so it is a great fit for a configuration management tool. Consider the following method of defining a list  or ‘collection’  of widgets:   widget:    - foo    - bar    - fizz   This would translate into Python  using the PyYAML library employed by Ansible  as the following:  translated_yaml = {'widget': ['foo', 'bar', 'fizz']}  And what about a structured list map in YAML?  widget:    foo: 12    bar: 13   The Python that would result:  translated_yaml = {'widget': {'foo': 12, 'bar': 13}}  A few things to note with both of the above examples:  YAML will try to determine the type of an item automatically. So foo in the first example would be translated as a string, true or false would be a boolean, and 123 would be an integer. You can read the official documentation for further insight, but for our purposes, realize you can minimize surprises by declaring strings with quotes  '' or "" . Whitespace matters! YAML uses spaces  literal space characters—not tabs  to define structure  mappings, array lists, etc. , so set your editor to use spaces for tabs. You can technically use either a tab or a space to delimit parameters  like apt: name=foo state=installed—you can use either a tab or a space between parameters , but it’s generally preferred to use spaces everywhere, to minimize errors and display irregularities across editors and platforms. YAML syntax is robust and well-documented. Read through the official YAML Specification and or the PyYAMLDocumentation to dig deeper.  YAML for Ansible tasks Consider the following task:   - name: Install foo.    apt: name=foo state=installed   All well and good, right? Well, as you get deeper into Ansible and start defining more complex configuration, you might start seeing tasks like the following:  - name: Copy Phergie shell script into place.    template: src=templates phergie.sh.j2 dest= opt phergie.sh owner= {{ phergie_us\  er }} group={{ phergie_user }} mode=755   The one-line syntax  which uses Ansible-specific key=value shorthand for defining parameters  has some positive attributes:  Simpler tasks  like installations and copies  are compact and readable  apt: name=apache2 state=installed is just about as simple as apt- get install -y apache2; in this way, an Ansible playbook feels very much like a shell script. Playbooks are more compact, and more configuration can be displayed on one screen. Ansible’s official documentation follows this format, as do many existing roles and playbooks.  However, as highlighted in the above example, there are a few issues with this key=value syntax:  Smaller monitors, terminal windows, and source control applications will either wrap or hide part of the task line. Diff viewers and source control systems generally don’t highlight intra-line differences as well as full line changes. Variables and parameters are converted to strings, which may or may not be desired.  Ansible’s shorthand syntax can be troublesome for complicated playbooks and roles, but luckily there are other ways you can write tasks which are better for narrower displays, version control software and diffing.  Three ways to format Ansible tasks   The following methods are most often used to define Ansible tasks in playbooks:  Shorthand one-line  key=value  Ansible’s shorthand syntax uses key=value parameters after the name of a module as a key:  - name: Install Nginx.    yum: name=nginx state=installed   For any situation where an equivalent shell command would roughly match what I’m writing in the YAML, I prefer this method, since it’s immediately obvious what’s happening, and it’s highly unlikely any of the parameters  like state=installed  will change frequently during development.  Ansible’s official documentation generally uses this syntax, so it maps nicely to examples you’ll find from Ansible, Inc. and many other sources.  Structured map multi-line  key:value  You can define a structured map of parameters  using key: value, with each parameter on its own line  for a task:  - name: Copy Phergie shell script into place.    template:      src: "templates phergie.sh.j2"      dest: " home {{ phergie_user }} phergie.sh"      owner: "{{ phergie_user }}"      group: "{{ phergie_user }}"      mode: 0755   A few notes on this syntax:  The structure is all valid YAML, and functions similarly to Ansible’s shorthand syntax. Strings, booleans, integers, octals, etc. are all preserved  instead of being converted to strings . Each parameter must be on its own line, so you can’t chain together mode: 0755, owner: root, user: root to save space. YAML syntax highlighting  if you have an editor that supports it  works slightly better for this format than key=value, since each key   will be highlighted, and values will be displayed as constants, strings, etc.  Folded scalars multi-line  >  You can also use the > character to break up Ansible’s shorthand key=value syntax over multiple lines.  - name: Copy Phergie shell script into place.    template: >      src=templates phergie.sh.j2      dest= home {{ phergie_user }} phergie.sh      owner={{ phergie_user }} group={{ phergie_user }} mode=755   In YAML, the > character denotes a folded scalar, where every line that follows  as long as it’s indented further than the line with the >  will be joined with the line above by a space. So the above YAML and the earlier template example will function exactly the same.  This syntax allows arbitrary splitting of lines on parameters, but it does not preserve value types  0775 would be converted to a string, for example .  While this syntax is often seen in the wild, I don’t recommend it except for certain situations, like tasks using the command and shell modules with extra options:  - name: Install Drupal.    command: >      drush si -y      --site-name="{{ drupal_site_name }}"      --account-name=admin      --account-pass={{ drupal_admin_pass }}      --db-url=mysql:  root@localhost {{ domain }}      chdir={{ drupal_core_path }}      creates={{ drupal_core_path }} sites default settings.php   If you can find a way to run a command without having to use creates and chdir, or very long commands  which are arguably unreadable either in single or multiline format! , it’s better to do that instead of this monstrosity.  Sometimes, though, the above is as good as you can do to keep unwieldy tasks sane.   Using  to format multiline variables In addition to using > to join multiple lines using spaces, YAML allows the use of   pipe  to define literal scalars, so you can define strings with newlines preserved.  For example:  1 extra_lines:   2   first line  3   second line  4   third line   1 first line  2 second line  3 third line   1 extra_lines: >  2   first line  3   second line  4   third line   Would be translated to a block of text with newlines intact:  Using a folded scalar  >  would concatenate the lines, which might not be desirable. For example:  Would be translated to a single string with no newlines:  1 first line second line third line   Using ansible-playbook Generally, running playbooks from your own computer or a central playbook runner is preferable to running Ansible playbooks locally  using - -connection=local , since you can avoid installing Ansible and all its dependencies on the system you’re provisioning. Because of Ansible’s optimized use of SSH for connecting to remote machines, there is usually minimal difference in performance running Ansible locally or from a remote workstation  barring network flakiness or a high-latency connection .   Use Ansible Tower If you are able to use Ansible Tower to run your playbooks, this is even better, as you’ll have a central server running Ansible playbooks, logging output, compiling statistics, and even allowing a team to work together to build servers and deploy applications in one place.  Specify --forks for playbooks running on > 5 servers If you are running a playbook on a large number of servers, consider increasing the number of forks Ansible uses to run tasks simultaneously. The default, 5, means Ansible will only run a given task on 5 servers at a time. Consider increasing this to 10, 15, or however many connections your local workstation and ISP can handle—this can dramatically reduce the amount of time it takes a playbook to run.  Use Ansible’s Configuration file Ansible’s main configuration file, in  etc ansible ansible.cfg, can contain a wealth of optimizations and customizations that help you run playbooks and ad-hoc tasks more easily, faster, or with better output than stock Ansible provides.  Read through the official documentation’s Ansible Configuration File page for details on options you can customize in ansible.cfg.  Summary One of Ansible’s strengths is its flexibility; there are often multiple ‘right’ ways of accomplishing your goals. I have chosen to use the methods I outlined above as they have proven to help me write and maintain a variety of playbooks and roles with minimal headaches.  It’s perfectly acceptable to try a different approach; as with most programming and technical things, being consistent is more important than following a particular set of rules, especially if that set of rules isn’t universally agreed upon. Consistency is especially important when you’re not working solo—if every team member used Ansible in a different way, it would become difficult to share work very quickly!   Appendix C - Jinja2 and Ansible  Jinja2 Docs Using Variables: About Jinja2  TODO:  Summary TODO.   Changelog  This log will track changes between releases of the book. Until version 1.0, each release number will correlate to the amount complete, so ‘Version 0.75’ equals 75% complete. After the final, complete book, major version numbers will track editions.  Hopefully these notes will help readers figure out what’s changed since the last time they’ve downloaded the book.  Version 0.94  2015-05-16   Added information about Capistrano and blue-green deployments in chapter 9. Reorganized chapter 9 with an eye towards a 1.0 release. Merged chapter 12 into chapter 11 with an eye towards a 1.0 release. Fixed vagrant init command in chapter 2  thanks to Ned Schumann! . Completed ‘Delegation, Local Actions, and Pauses’ section in chapter 5. Completed DigitalOcean dynamic inventory example in chapter 7. Fixed CentOS 6 vs 7 nomenclature in chapters 2 and 3  thanks to @39digits and Alex Litvineko! . Completed Ansible Tower installation guide in chapter 11. Completed Ansible Tower usage guide and alternatives in chapter 11.  Version 0.92  2015-04-09   Update Ansible project ‘stars’ count on GitHub in the introduction. Added zero-downtime multi-server deployment example to chapter 9. Removed frequent use of the filler word ‘simply’  thanks to a reader’s suggestion! . Fixed language around ‘plays’ vs. ‘tasks’ in chapters 4, 5, and 6  thanks to André! .   Fixed ad-hoc Django installation in chapter 3  thanks to @wimvandijck! .  Version 0.90  2015-03-16   Tweaked requirements.txt explanation in chapter 8. Tweaked formatting of GlusterFS cookbook in chapter 6. Fixed GlusterFS example ports and mount task in chapter 8. Fixed some examples in chapter 4 to ensure apt repositories update cache. Fixed some typos in chapter 8  thanks to Juan Martinez! . Updated Ansible installation instructions for Debian Ubuntu in chapter 1. Corrected use of yum module in fail2ban example in chapter 10  thanks to @lekum! . Fixed references to ansible.cfg config file in appendix b  thanks to @lekum! . Fixed DigitalOcean provisioning playbook in chapter 8  thanks to @jonathanhle! . Adjusted DigitalOcean dynamic inventory example in chapter 7. Rewrote completely nonsensical sentence in chapter 7  thanks to @dan_bohea! . Fixed some errors throughout the first few chapters  thanks to nesfel! . Fixed a couple errors in chapters 2 and 4  thanks to Barry McClendon! .  Version 0.89  2015-02-26   Completed first deployment example for Rails app in chapter 9. Added notes on role requirements.txt and requirements.yml options in chapter 6. Tweaked language and cleaned up examples for roles in chapter 6. Added GlusterFS cookbook to chapter 6.  Version 0.88  2015-02-13   Fixed two errors in chapter 7  thanks to Jonathan Le   @jonathanhle!    Wrote introduction to chapter 9. Wrote first deployment example for Rails app in chapter 9.  Version 0.87  2015-02-01   Cleaned up Docker examples in chapter 8. Fixed a typo in chapter 3  thanks to Jonathan Le   @jonathanhle!  Added section on configuring firewalls with ufw and firewalld in chapter 10. Updated Apache Solr version in chapter 4 example. Fixed APC uploadprogress task in Drupal example in chapter 4. Added section on installing and configuring Fail2Ban in chapter 10. Added suggestion for setting ANSIBLE_HOSTS environment variable in chapter 3  thanks to Jason Baker   @diermakeralch! . Added section on SELinux and AppArmor in chapter 10. Completed chapter 10.  Version 0.84  2015-01-27   Version 0.81  2015-01-11   Added Docker introduction and cookbooks in chapter 8.  Fixed Vagrantfile examples to work with Vagrant 1.7.x. Added local Mac configuration example in chapter 8. Used name instead of pkg for packaging modules as per updated Ansible style guide. Incorporated editorial changes for introduction, chapter 1, chapter 2, and chapter 3. Fixed references to Vagrant Cloud HashiCorp’s Atlas. Finished almost all the rest of chapter 5.  Version 0.75  2014-12-23   Fixed code formatting in examples in chapter 8. Added YAML  multiline variable delimiter example to appendix b.   Edited and updated examples and guide for HA Infrastructure in chapter 8. Completed the ELK and Logstash Forwarder examples in chapter 8. Started on the Mac provisioning example in chapter 8.  Version 0.73  2014-12-09   Added wait_for to DigitalOcean example in chapter 7. Completed Hightly-Available Infrastructure cookbook in chapter 8. Began work on ELK log monitoring cookbook in chapter 8. Fixed a few typos in chapters 5 and 6  thanks to George Boobyer   @ibluebag! . Incorporated edits in preface from technical editor.  Version 0.71  2014-11-27   Added Highly-Available Infrastructure cookbook to chapter 8. Updated screenshots throughout the book. Began incorporating changes from copy editor  more to come! .  Version 0.70  2014-11-16   Coverted Testing CI section into its own chapter. Added cowsay to chapter 12. Removed glossary  and pointed readers directly to Ansible’s very helpful glossary . Added missing link in chapter 7. Converted chapter 8 from “Ansible Modules” to “Ansible Cookbooks” due to reader interest. Cleaned up Vagrantfile in chapter 3, as well as throughout ansible- for-devops git repo. Added “Web Architecture Example” example to ansible-for-devops git repo. Built structure of chapter 8  “Ansible Cookbooks” . Added cowsay to chapter 8. Added information about add_host and group_by to chapter 7. Reworked sections in chapter 12 and fixed a few problems.   Version 0.64  2014-10-24   Added Server Check.in architecture diagram  chapter 7 . Wrote about host_vars, group_vars, and dynamic inventory  chapter 7 . Added Digital Ocean provisioning and dynamic inventory walkthrough  chapter 7 .  Version 0.62  2014-10-07   Wrote a good deal of chapter 7  Inventories . Cleaned up code examples to follow updated best practices in appendix b. Updated installation instructions to use Ansible’s official PPA for Ubuntu  thanks to Rohit Bhute! .  Version 0.60  2014-09-30   Wrote most of appendix b  Best Practices . Updated definition of idempotence in chapter 1. Fixed a few LeanPub-related code formatting issues. Many grammar fixes throughout the book  thanks to Jon Forrest! . Some spelling and ad-hoc command fixes  thanks to Hugo Posca! . Had a baby  thus the dearth of updates from 8 1-10 1 :- . Wrote introduction and basic structure of chapter 11  Ansible Tower .  Version 0.58  2014-08-01   Even more sections on variables in chapter 5  almost finished! . Fixed a few old Ansible and Drupal version references. Added a playbook include tag example in chapter 6. Completed first draft of chapter 6. Fixed broken handler in chapter 4’s Tomcat handler  thanks to Joel Shprentz! . Fixed a missing closing quotation in chapter 3 example  thanks to Jonathan Nakatsui! .   Version 0.56  2014-07-20   Filled in many more sections on variables in chapter 5. Some editing in chapter 6. Side work on some supplemental material for a potential chapter on Docker.  Version 0.54  2014-07-02   Finished roles section in chapter 6. Fixed a few code examples for better style in chapter 4. Fixed references to official code repository in chapters 4 and 6.  Version 0.53  2014-06-28   Added note about Windows Support in appendix a. Wrote large portion of roles section in chapter 6.  Version 0.52  2014-06-14   Adjusted some code listings to make more readable line breaks. Added section on Ansible testing with Travis CI in chapter 12. Expanded mention of Ansible’s excellent documentation in introduction. Greatly expanded security coverage in chapter 10. Added link to security role on Ansible Galaxy in chapter 10.  Version 0.50  2014-05-05   Wrote includes section in chapter 6. Added links to code repository examples in chapters 4 and 6. Fixed broken internal links. Fixed typos in chapter 10. Added note about --force-handlers  new in Ansible 1.6  in chapter 4. Use Ansible’s apache2_module module for LAMP example in chapter 4.   Moved Jinja2 chapter to appendix c. Removed ‘Variables’ chapter  variables will be covered in-depth elsewhere . Added Appendix B - Ansible Best Practices and Conventions. Started tagging code in Ansible for DevOps GitHub repository to match manuscript version  starting with this version, 0.50 . Fixed various layout issues.  Version 0.49  2014-04-24   Completed history of SSH in chapter 10. Clarified definition of the word ‘DevOps’ in chapter 1. Added section “Testing Ansible Playbooks” in chapter 14. Added links to Ansible for DevOps GitHub repository in the introduction and chapter 4.  Version 0.47  2014-04-13   Added Apache Solr example in chapter 4. Updated VM diagrams in chapter 4. Added information about ansible-playbook command in chapter 4  thanks to a reader’s suggestion! . Clarified code example in preface.  Version 0.44  2014-04-04   Expanded chapter 10  security . Fixed formatting issues in Warning Info Tip asides. Fixed formatting of some code examples to prevent line wrapping. Added section on Ansible Galaxy in chapter 6. Updated installation section in chapter 1 with simplified install processes. Added warnings concerning faster SSH in Ansible 1.5+  thanks to @LeeVanSteerthem .  Version 0.42  2014-03-25    Added history of SSH section. Expanded chapter 10  security . Many small spelling and grammar mistakes corrected. Fixed formatting of info warning tip asides.  Version 0.38  2014-03-11   Added Appendix A - Using Ansible on Windows workstations  thanks to a reader’s suggestion! . Updated chapter 1 to include a reference to appendix a. Clarified and expanded installation instructions for Mac and Linux in chapter 1. Added chapter 10 - Server Security and Ansible Updated chapter 1 to include a reference to chapter 10. Added notes and TODOs to a few more areas of the book  random .  Version 0.35  2014-02-25   Added this changelog. Split out roles and playbook organization into its own chapter. Expanded ‘Environment Variables’ section in chapter 5. Expanded ‘Variables’ section in chapter 5. MORE COWBELL!  Cowsay motivational quotes at the end of every completed chapter . Fixed NTP installation examples in chapter 2  thanks to a reader’s suggestion! .  Version 0.33  2014-02-20   Initial published release, up to chapter 4, part of chapter 5.

@highlight

Ansible is a simple, but powerful, server and configuration management tool (with a few other tricks up its sleeve). This book will help those familiar with the command line and basic shell scripting start using Ansible to provision and manage anywhere from one to thousands of servers. The book begins with fundamentals, like installing Ansible, setting up a basic inventory file, and basic concepts, then guides you through Ansible's many uses, including ad-hoc commands, basic and advanced playbooks, application deployments, custom modules, and special cases like running ansible in 'pull' mode when you have thousands of servers to manage (or more). Everything is explained with pertinent real-world examples, often using Vagrant-managed virtual machines.