SQL Cookbook  SECOND EDITION  Query Solutions and Techniques for All SQL Users  Anthony Molinaro and Robert de Graaf   SQL Cookbook by Anthony Molinaro and Robert de Graaf Copyright   2021 Robert de Graaf. All rights reserved. Printed in the United States of America. Published by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472. O’Reilly books may be purchased for educational, business, or sales promotional use. Online editions are also available for most titles  http:  oreilly.com . For more information, contact our corporate institutional sales department: 800-998-9938 or corporate@oreilly.com.  Acquisitions Editor: Jessica Haberman Development Editor: Virginia Wilson Production Editor: Kate Galloway Copyeditor: Kim Wimpsett Proofreader: nSight, Inc. Indexer: WordCo Indexing Services, Inc. Interior Designer: David Futato Cover Designer: Karen Montgomery Illustrator: O’Reilly Media December 2005: First Edition December 2020: Second Edition  Revision History for the Second Edition  2020-11-03: First Release  See http:  oreilly.com catalog errata.csp?isbn=9781492077442 for release details. The O’Reilly logo is a registered trademark of O’Reilly Media, Inc. SQL Cookbook, the cover image, and related trade dress are trademarks of O’Reilly Media, Inc.   The views expressed in this work are those of the authors, and do not represent the publisher’s views. While the publisher and the authors have used good faith efforts to ensure that the information and instructions contained in this work are accurate, the publisher and the authors disclaim all responsibility for errors or omissions, including without limitation responsibility for damages resulting from the use of or reliance on this work. Use of the information and instructions contained in this work is at your own risk. If any code samples or other technology this work contains or describes is subject to open source licenses or the intellectual property rights of others, it is your responsibility to ensure that your use thereof complies with such licenses and or rights. This work is part of a collaboration between O’Reilly and Yugabyte. See our statement of editorial independence. 978-1-098-10014-8 [LSI]   Dedication To my mom: You’re the best! Thank you for everything. Anthony To Clare, Maya, and Leda. Robert   Preface  SQL is the lingua franca of the data professional. At the same time, it doesn’t always get the attention it deserves compared to the hot tool du jour. As result, it’s common to find people who use SQL frequently but rarely or never go beyond the simplest queries, often enough because they believe that’s all there is. This book shows how much SQL can do, expanding users’ tool boxes. By the end of the book you will have seen how SQL can be used for statistical analysis; to do reporting in a manner similar to Business Intelligence tools; to match text data; to perform sophisticated analysis on date data; and much more. The first edition of SQL Cookbook has been a popular choice as the “second book on SQL”—the book people read after they learn the basics—since its original release. It has many strengths, such as its wide range of topics and its friendly style. However, computing is known to move fast, even when it comes to something as mature as SQL, which has roots going back to the 1970s. While this new edition doesn’t cover brand new language features, an important change is that features that were novel at the time of the first edition, and found in some implementations and not in others, are now stabilized and standardized. As a result, we have a lot more scope for developing standard solutions than was possible earlier. There are two key examples that are important to highlight. Common table expressions  CTEs , including recursive CTEs, were available in a couple of implementations at the time the first edition was released, but are now available in all five. They were introduced to solve some practical limitations of SQL, some of which can be seen directly in these recipes. A new appendix on recursive CTEs in this edition underlines their importance and explains their relevance.   Window functions were also new enough at the time of the first edition’s release that they weren’t available in every implementation. They were also new enough that a special appendix was written to explain them, which remains. Now, however, window functions are in all implementations in this book. They are also in every other SQL implementation that we’re aware of, although there are so many databases out there, it’s impossible to guarantee there isn’t one that neglects window functions and or CTEs. In addition to standardizing queries where possible, we’ve brought new material into Chapters 6 and 7. The material in Chapter 7 unlocks new data analysis applications in recipes about the median absolute deviation and Benford’s law. In Chapter 6, we have a new recipe to help match data by the sound of the text, and we have moved material on regular expressions to Chapter 6 from Chapter 14.   Who This Book Is For This book is meant to be for any SQL user who wants to take their queries further. In terms of ability, it’s meant for someone who knows at least some SQL—you might have read Alan Beaulieu’s Learning SQL, for example— and ideally you’ve had to write queries on data in the wild to answer a real- life problem. Other than those loose parameters, this is a book for all SQL users, including data engineers, data scientists, data visualization folk, BI people, etc. Some of these users may never or rarely access databases directly, but use their data visualization, BI, or statistical tool to query and fetch data. The emphasis is on practical queries that can solve real-world problems. Where a small amount of theory appears, it’s there to directly support the practical elements.  What’s Missing from This Book This is a practical book, chiefly about using SQL to understand data. It doesn’t cover theoretical aspects of databases, database design, or the theory behind SQL except where needed to explain specific recipes or techniques. It also doesn’t cover extensions to databases to handle data types such as XML and JSON. There are other resources available for those specialist topics.  Platform and Version SQL is a moving target. Vendors are constantly pumping new features and functionality into their products. Thus, you should know up front which versions of the various platforms were used in the preparation of this text:  DB2 11.5 Oracle Database 19c   PostgreSQL 12 SQL Server 2017 MySQL 8.0  Tables Used in This Book The majority of the examples in this book involve the use of two tables, EMP and DEPT. The EMP table is a simple 14-row table with only numeric, string, and date fields. The DEPT table is a simple four-row table with only numeric and string fields. These tables appear in many old database texts, and the many-to-one relationship between departments and employees is well understood. All but a very few solutions in this book run against these tables. Nowhere do we tweak the example data to set up a solution that you would be unlikely to have a chance of implementing in the real world, as some books do. The contents of EMP and DEPT are shown here, respectively:    s e l e c t   *   f r o m   e m p ;     E M P N O   E N A M E     J O B                 M G R   H I R E D A T E           S A L   C O M M     D E P T N O   - - - - -   - - - - - -   - - - - - - - - -   - - - -   - - - - - - - - - - -   - - - -   - - - -   - - - - - - -     7 3 6 9   S M I T H     C L E R K           7 9 0 2   1 7 - D E C - 2 0 0 5     8 0 0                       2 0     7 4 9 9   A L L E N     S A L E S M A N     7 6 9 8   2 0 - F E B - 2 0 0 6   1 6 0 0     3 0 0             3 0     7 5 2 1   W A R D       S A L E S M A N     7 6 9 8   2 2 - F E B - 2 0 0 6   1 2 5 0     5 0 0             3 0     7 5 6 6   J O N E S     M A N A G E R       7 8 3 9   0 2 - A P R - 2 0 0 6   2 9 7 5                       2 0     7 6 5 4   M A R T I N   S A L E S M A N     7 6 9 8   2 8 - S E P - 2 0 0 6   1 2 5 0   1 4 0 0             3 0     7 6 9 8   B L A K E     M A N A G E R       7 8 3 9   0 1 - M A Y - 2 0 0 6   2 8 5 0                       3 0     7 7 8 2   C L A R K     M A N A G E R       7 8 3 9   0 9 - J U N - 2 0 0 6   2 4 5 0                       1 0     7 7 8 8   S C O T T     A N A L Y S T       7 5 6 6   0 9 - D E C - 2 0 0 7   3 0 0 0                       2 0     7 8 3 9   K I N G       P R E S I D E N T             1 7 - N O V - 2 0 0 6   5 0 0 0                       1 0     7 8 4 4   T U R N E R   S A L E S M A N     7 6 9 8   0 8 - S E P - 2 0 0 6   1 5 0 0         0             3 0     7 8 7 6   A D A M S     C L E R K           7 7 8 8   1 2 - J A N - 2 0 0 8   1 1 0 0                       2 0     7 9 0 0   J A M E S     C L E R K           7 6 9 8   0 3 - D E C - 2 0 0 6     9 5 0                       3 0     7 9 0 2   F O R D       A N A L Y S T       7 5 6 6   0 3 - D E C - 2 0 0 6   3 0 0 0                       2 0     7 9 3 4   M I L L E R   C L E R K           7 7 8 2   2 3 - J A N - 2 0 0 7   1 3 0 0                       1 0        Additionally, you will find four pivot tables used in this book: T1, T10, T100, and T500. Because these tables exist only to facilitate pivots, we didn’t give them clever names. The number following the “T” in each of the pivot tables signifies the number of rows in each table, starting from 1. For example, here are the values for T1 and T10:  The pivot tables are a useful shortcut when we need to create a series of rows to facilitate a query. As an aside, some vendors allow partial SELECT statements. For example, you can have SELECT without a FROM clause. Sometimes in this book we will use a support table, T1, with a single row, rather than using partial queries for clarity. This is similar in usage to Oracle’s DUAL table, but by      s e l e c t   *   f r o m   d e p t ;     D E P T N O   D N A M E                     L O C   - - - - - -   - - - - - - - - - - - - - -   - - - - - - - - -           1 0   A C C O U N T I N G           N E W   Y O R K           2 0   R E S E A R C H               D A L L A S           3 0   S A L E S                     C H I C A G O           4 0   O P E R A T I O N S           B O S T O N s e l e c t   i d   f r o m   t 1 ;                     I D   - - - - - - - - - -                     1     s e l e c t   i d   f r o m   t 1 0 ;                     I D   - - - - - - - - - -                     1                     2                     3                     4                     5                     6                     7                     8                     9                   1 0  using the T1 table, we do the same thing in a standardized way across all the implementations we are looking at. Any other tables are specific to particular recipes and chapters and will be introduced in the text when appropriate.  Conventions Used in This Book We use a number of typographical and coding conventions in this book. Take time to become familiar with them. Doing so will enhance your understanding of the text. Coding conventions in particular are important, because we can’t repeat them for each recipe in the book. Instead, we list the important conventions here.  Typographical Conventions The following typographical conventions are used in this book: UPPERCASE  Used to indicate SQL keywords within text.  lowercase  Used for all queries in code examples. Other languages such as C and Java use lowercase for most keywords, and we find it far more readable than uppercase. Thus, all queries will be lowercase.  Indicates user input in examples showing an interaction.  Indicates a tip, suggestion, or general note.  TIP  C o n s t a n t   w i d t h   b o l d  Indicates a warning or caution.  WARNING  Coding Conventions Our preference for case in SQL statements is to always use lowercase, for both keywords and user-specified identifiers. For example:  Your preference may be otherwise. For example, many prefer to uppercase SQL keywords. Use whatever coding style you prefer, or whatever your project requires. Despite the use of lowercase in code examples, we consistently use uppercase for SQL keywords and identifiers in the text. We do this to make those items stand out as something other than regular prose. For example: The preceding query represents a SELECT against the EMP table. While this book covers databases from five different vendors, we’ve decided to use one format for all the output:  Many solutions make use of inline views, or subqueries in the FROM clause. The ANSI SQL standard requires that such views be given table aliases.  Oracle is the only vendor that lets you get away without specifying such aliases.  Thus, our solutions use aliases such as X and Y to identify the result sets from inline views:  s e l e c t   e m p n o ,   e n a m e       f r o m   e m p ; E M P N O   E N A M E   - - - - -   - - - - - -     7 3 6 9   S M I T H     7 4 9 9   A L L E N       …   s e l e c t   j o b ,   s a l   f r o m     s e l e c t   j o b ,   m a x   s a l     s a l    Notice the letter X following the final, closing parenthesis. That letter X becomes the name of the “table” returned by the subquery in the FROM clause. While column aliases are a valuable tool for writing self- documenting code, aliases on inline views  for most recipes in this book  are simply formalities. They are typically given trivial names such as X, Y, Z, TMP1, and TMP2. In cases where a better alias might provide more understanding, we use them. You will notice that the SQL in the “Solution” section of the recipes is typically numbered, for example:  The number is not part of the syntax; it is just to reference parts of the query by number in the “Discussion” section.  O’Reilly Online Learning  For more than 40 years, O’Reilly Media has provided technology and business training, knowledge, and insight to help companies succeed.  NOTE  Our unique network of experts and innovators share their knowledge and expertise through books, articles, and our online learning platform. O’Reilly’s online learning platform gives you on-demand access to live training courses, in-depth learning paths, interactive coding environments, and a vast collection of text and video from O’Reilly and 200+ other publishers. For more information, visit http:  oreilly.com.    j ,                     f r o m   e m p               g r o u p   b y   j o b   x ; 1   s e l e c t   e n a m e   2           f r o m   e m p   3     w h e r e   d e p t n o   =   1 0  How to Contact Us Please address comments and questions concerning this book to the publisher:  O’Reilly Media, Inc. 1005 Gravenstein Highway North Sebastopol, CA 95472 800-998-9938  in the United States or Canada  707-829-0515  international or local  707-829-0104  fax   We have a web page for this book, where we list errata, examples, and any additional information. You can access this page at https:  oreil.ly sql-ckbk- 2e. Email bookquestions@oreilly.com to comment or ask technical questions about this book. For news and information about our books and courses, visit http:  oreilly.com. Find us on Facebook: http:  facebook.com oreilly Follow us on Twitter: http:  twitter.com oreillymedia Watch us on YouTube: http:  www.youtube.com oreillymedia  Second Edition Acknowledgments A bunch of great people have helped with this second edition. Thanks to Jess Haberman, Virginia Wilson, Kate Galloway, and Gary O’Brien at O’Reilly. Thanks to Nicholas Adams for repeatedly saving the day in Atlas. Many thanks to the tech reviewers: Alan Beaulieu, Scott Haines, and Thomas Nield. Finally, many thanks to my family—Clare, Maya, and Leda—for graciously bearing losing me to another book for a while. —Robert de Graaf   First Edition Acknowledgments This book would not exist without all the support we’ve received from a great many people. I would like to thank my mother, Connie, to whom this book is dedicated. Without your hard work and sacrifice, I would not be where I am today. Thank you for everything, Mom. I am thankful and appreciative of everything you’ve done for my brother and me. I have been blessed to have you as my mother. To my brother, Joe: Every time I came home from Baltimore to take a break from writing, you were there to remind me how great things are when we’re not working, and how I should finish writing so I can get back to the more important things in life. You’re a good man, and I respect you. I am extremely proud of you, and proud to call you my brother. To my wonderful fiancée, Georgia: Without your support I would not have made it through all 600-plus pages of this book. You were here sharing this experience with me, day after day. I know it was just as hard on you as it was on me. I spent all day working and all night writing, but you were great through it all. You were understanding and supportive, and I am forever grateful. Thank you. I love you. To my future in-laws: To my mother-in-law and father-in-law, Kiki and George, thank you for your support throughout this whole experience. You always made me feel at home whenever I took a break and came to visit, and you made sure Georgia and I were always well fed. To my sister-in- laws, Anna and Kathy, it was always fun coming home and hanging out with you guys, giving Georgia and I a much needed break from the book and from Baltimore. To my editor, Jonathan Gennick, without whom this book would not exist: Jonathan, you deserve a tremendous amount of credit for this book. You went above and beyond what an editor would normally do, and for that you deserve much thanks. From supplying recipes to tons of rewrites to keeping things humorous despite oncoming deadlines, I could not have done it without you. I am grateful to have had you as my editor and grateful for the opportunity you have given me. An experienced DBA and author yourself,   it was a pleasure to work with someone of your technical level and expertise. I can’t imagine there are too many editors out there who can, if they decided to, stop editing and work practically anywhere as a database administrator  DBA ; Jonathan can. Being a DBA certainly gives you an edge as an editor as you usually know what I want to say even when I’m having trouble expressing it. O’Reilly is lucky to have you on staff, and I am lucky to have you as an editor. I would like to thank Ales Spetic and Jonathan Gennick for Transact-SQL Cookbook. Isaac Newton famously said, “If I have seen a little further it is by standing on the shoulders of giants.” In the acknowledgments section of the Transact-SQL Cookbook, Ales Spetic wrote something that is a testament to this famous quote, and I feel should be in every SQL book. I include his words here: I hope that this book will complement the exiting opuses of outstanding authors like Joe Celko, David Rozenshtein, Anatoly Abramovich, Eugine Berger, Iztik Ben-Gan, Richard Snodgrass, and others. I spent many nights studying their work, and I learned almost everything I know from their books. As I am writing these lines, I’m aware that for every night I spent discovering their secrets, they must have spent 10 nights putting their knowledge into a consistent and readable form. It is an honor to be able to give something back to the SQL community. I would like to thank Sanjay Mishra for his excellent Mastering Oracle SQL book, and also for putting me in touch with Jonathan. If not for Sanjay, I may have never met Jonathan and never would have written this book. Amazing how a simple email can change your life. I would like to thank David Rozenshtein, especially, for his Essence of SQL book, which provided me with a solid understanding of how to think and problem solve in sets SQL. I would like to thank David Rozenshtein, Anatoly Abramovich, and Eugene Birger for their book Optimizing Transact-SQL, from which I learned many of the advanced SQL techniques I use today. I would like to thank the whole team at Wireless Generation, a great company with great people. A big thank-you to all of the people who took the time to review, critique, or offer advice to help me complete this book:   Jesse Davis, Joel Patterson, Philip Zee, Kevin Marshall, Doug Daniels, Otis Gospodnetic, Ken Gunn, John Stewart, Jim Abramson, Adam Mayer, Susan Lau, Alexis Le-Quoc, and Paul Feuer. I would like to thank Maggie Ho for her careful review of my work and extremely useful feedback regarding the window function refresher. I would like to thank Chuck Van Buren and Gillian Gutenberg for their great advice about running. Early morning workouts helped me clear my mind and unwind. I don’t think I would have been able to finish this book without getting out a bit. I would like to thank Steve Kang and Chad Levinson for putting up with all my incessant talk about different SQL techniques on the nights when all they wanted was to head to Union Square to get a beer and a burger at Heartland Brewery after a long day of work. I would like to thank Aaron Boyd for all his support, kind words, and, most importantly, good advice. Aaron is honest, hardworking, and a very straightforward guy; people like him make a company better. I would like to thank Olivier Pomel for his support and help in writing this book, in particular for the DB2 solution for creating delimited lists from rows. Olivier contributed that solution without even having a DB2 system to test it! I explained to him how the WITH clause worked, and minutes later he came up with the solution you see in this book. Jonah Harris and David Rozenshtein also provided helpful technical review feedback on the manuscript. And Arun Marathe, Nuno Pinto do Souto, and Andrew Odewahn weighed in on the outline and choice of recipes while this book was in its formative stages. Thanks, very much, to all of you. I want to thank John Haydu and the MODEL clause development team at Oracle Corporation for taking the time to review the MODEL clause article I wrote for O’Reilly, and for ultimately giving me a better understanding of how that clause works. I would like to thank Tom Kyte of Oracle Corporation for allowing me to adapt his TO_BASE function into a SQL- only solution. Bruno Denuit of Microsoft answered questions I had regarding the functionality of the window functions introduced in SQL Server 2005. Simon Riggs of PostgreSQL kept me up-to-date about new SQL features in PostgreSQL  very big thanks: Simon, by knowing what   was coming out and when, I was able to incorporate some new SQL features such as the ever-so-cool GENERATE_SERIES function, which I think made for more elegant solutions compared to pivot tables . Last but certainly not least, I’d like to thank Kay Young. When you are talented and passionate about what you do, it is great to be able to work with people who are likewise as talented and passionate. Many of the recipes you see in this text have come from working with Kay and coming up with SQL solutions for everyday problems at Wireless Generation. I want to thank you and let you know I absolutely appreciate all the help you have given me throughout all of this; from advice to grammar corrections to code, you played an integral role in the writing of this book. It’s been great working with you, and Wireless Generation is a better company because you are there. —Anthony Molinaro   Chapter 1. Retrieving Records  This chapter focuses on basic SELECT statements. It is important to have a solid understanding of the basics as many of the topics covered here are not only present in more difficult recipes but are also found in everyday SQL.  1.1 Retrieving All Rows and Columns from a Table  Problem You have a table and want to see all of the data in it.  Solution Use the special * character and issue a SELECT against the table:  Discussion The character * has special meaning in SQL. Using it will return every column for the table specified. Since there is no WHERE clause specified, every row will be returned as well. The alternative would be to list each column individually:  In ad hoc queries that you execute interactively, it’s easier to use SELECT *. However, when writing program code, it’s better to specify each column individually. The performance will be the same, but by being explicit you  1   s e l e c t   *   2       f r o m   e m p s e l e c t   e m p n o , e n a m e , j o b , s a l , m g r , h i r e d a t e , c o m m , d e p t n o       f r o m   e m p  will always know what columns you are returning from the query. Likewise, such queries are easier to understand by people other than yourself  who may or may not know all the columns in the tables in the query . Problems with SELECT * can also arise if your query is within code, and the program gets a different set of columns from the query than was expected. At least, if you specify all columns and one or more is missing, any error thrown is more likely to be traceable to the specific missing column s .  1.2 Retrieving a Subset of Rows from a Table  Problem You have a table and want to see only rows that satisfy a specific condition.  Solution Use the WHERE clause to specify which rows to keep. For example, to view all employees assigned to department number 10:  Discussion The WHERE clause allows you to retrieve only rows you are interested in. If the expression in the WHERE clause is true for any row, then that row is returned. Most vendors support common operators such as =,  ,  =, !, and  . Additionally, you may want rows that satisfy multiple conditions; this can be done by specifying AND, OR, and parentheses, as shown in the next recipe.  1   s e l e c t   *   2       f r o m   e m p   3     w h e r e   d e p t n o   =   1 0  1.3 Finding Rows That Satisfy Multiple Conditions  Problem You want to return rows that satisfy multiple conditions.  Solution Use the WHERE clause along with the OR and AND clauses. For example, if you would like to find all the employees in department 10, along with any employees who earn a commission, along with any employees in department 20 who earn at most $2,000:  Discussion You can use a combination of AND, OR, and parentheses to return rows that satisfy multiple conditions. In the solution example, the WHERE clause finds rows such that:  The DEPTNO is 10 The COMM is not NULL The salary is $2,000 or less for any employee in DEPTNO 20.  The presence of parentheses causes conditions within them to be evaluated together. For example, consider how the result set changes if the query was written with the parentheses as shown here:  1   s e l e c t   *   2       f r o m   e m p   3     w h e r e   d e p t n o   =   1 0   4           o r   c o m m   i s   n o t   n u l l   5           o r   s a l   < =   2 0 0 0   a n d   d e p t n o = 2 0 s e l e c t   *     f r o m   e m p    1.4 Retrieving a Subset of Columns from a Table  Problem You have a table and want to see values for specific columns rather than for all the columns.  Solution Specify the columns you are interested in. For example, to see only name, department number, and salary for employees:  Discussion By specifying the columns in the SELECT clause, you ensure that no extraneous data is returned. This can be especially important when retrieving data across a network, as it avoids the waste of time inherent in retrieving data that you do not need.  1.5 Providing Meaningful Names for Columns  w h e r e               d e p t n o   =   1 0                   o r   c o m m   i s   n o t   n u l l                   o r   s a l   < =   2 0 0 0                       a n d   d e p t n o = 2 0     E M P N O   E N A M E     J O B           M G R     H I R E D A T E             S A L               C O M M     D E P T N O   - - - - -   - - - - - -   - - - - -   - - - - -     - - - - - - - - - - -   - - - - -   - - - - - - - - - -     - - - - - -     7 3 6 9   S M I T H     C L E R K     7 9 0 2     1 7 - D E C - 1 9 8 0       8 0 0                                   2 0     7 8 7 6   A D A M S     C L E R K     7 7 8 8     1 2 - J A N - 1 9 8 3     1 1 0 0                                   2 0 1   s e l e c t   e n a m e , d e p t n o , s a l   2       f r o m   e m p  Problem You would like to change the names of the columns that are returned by your query so they are more readable and understandable. Consider this query that returns the salaries and commissions for each employee:  What’s SAL? Is it short for sale? Is it someone’s name? What’s COMM? Is it communication? You want the results to have more meaningful labels.  Solution To change the names of your query results, use the AS keyword in the form e. Some databases do not require AS, but all  accept it:  Discussion  1   s e l e c t   s a l , c o m m   2       f r o m   e m p o r i g i n a l _ n a m e   A S   n e w _ n a m   1   s e l e c t   s a l   a s   s a l a r y ,   c o m m   a s   c o m m i s s i o n       2       f r o m   e m p     S A L A R Y       C O M M I S S I O N   - - - - - - -     - - - - - - - - - -           8 0 0         1 6 0 0                   3 0 0         1 2 5 0                   5 0 0         2 9 7 5         1 2 5 0                 1 4 0 0         2 8 5 0         2 4 5 0         3 0 0 0         5 0 0 0         1 5 0 0                       0         1 1 0 0           9 5 0         3 0 0 0         1 3 0 0  Using the AS keyword to give new names to columns returned by your query is known as aliasing those columns. The new names that you give are known as aliases. Creating good aliases can go a long way toward making a query and its results understandable to others.  1.6 Referencing an Aliased Column in the WHERE Clause  Problem You have used aliases to provide more meaningful column names for your result set and would like to exclude some of the rows using the WHERE clause. However, your attempt to reference alias names in the WHERE clause fails:  Solution By wrapping your query as an inline view, you can reference the aliased columns:  Discussion In this simple example, you can avoid the inline view and reference COMM or SAL directly in the WHERE clause to achieve the same result. This solution introduces you to what you would need to do when attempting to reference any of the following in a WHERE clause:  s e l e c t   s a l   a s   s a l a r y ,   c o m m   a s   c o m m i s s i o n       f r o m   e m p     w h e r e   s a l a r y   <   5 0 0 0 1   s e l e c t   *   2       f r o m       3   s e l e c t   s a l   a s   s a l a r y ,   c o m m   a s   c o m m i s s i o n   4       f r o m   e m p   5                     x   6     w h e r e   s a l a r y   <   5 0 0 0  Aggregate functions Scalar subqueries Windowing functions Aliases  Placing your query, the one giving aliases, in an inline view gives you the ability to reference the aliased columns in your outer query. Why do you need to do this? The WHERE clause is evaluated before the SELECT; thus, SALARY and COMMISSION do not yet exist when the “Problem” query’s WHERE clause is evaluated. Those aliases are not applied until after the WHERE clause processing is complete. However, the FROM clause is evaluated before the WHERE. By placing the original query in a FROM clause, the results from that query are generated before the outermost WHERE clause, and your outermost WHERE clause “sees” the alias names. This technique is particularly useful when the columns in a table are not named particularly well.  The inline view in this solution is aliased X. Not all databases require an inline view to be explicitly aliased, but some do. All of them accept it.  TIP  1.7 Concatenating Column Values  Problem You want to return values in multiple columns as one column. For example, you would like to produce this result set from a query against the EMP table:  C L A R K   W O R K S   A S   A   M A N A G E R   K I N G   W O R K S   A S   A   P R E S I D E N T   M I L L E R   W O R K S   A S   A   C L E R K  However, the data that you need to generate this result set comes from two different columns, the ENAME and JOB columns in the EMP table:  Solution Find and use the built-in function provided by your DBMS to concatenate values from multiple columns.  DB2, Oracle, PostgreSQL These databases use the double vertical bar as the concatenation operator:  MySQL This database supports a function called CONCAT:  SQL Server Use the + operator for concatenation:    s e l e c t   e n a m e ,   j o b           f r o m   e m p           w h e r e   d e p t n o   =   1 0     E N A M E             J O B   - - - - - - - - - -   - - - - - - - - -   C L A R K             M A N A G E R   K I N G               P R E S I D E N T   M I L L E R           C L E R K 1   s e l e c t   e n a m e   '   W O R K S   A S   A   '   j o b   a s   m s g   2       f r o m   e m p   3     w h e r e   d e p t n o = 1 0 1   s e l e c t   c o n c a t   e n a m e ,   '   W O R K S   A S   A   ' , j o b     a s   m s g   2       f r o m   e m p   3     w h e r e   d e p t n o = 1 0 1   s e l e c t   e n a m e   +   '   W O R K S   A S   A   '   +   j o b   a s   m s g   2       f r o m   e m p   3     w h e r e   d e p t n o = 1 0  Discussion Use the CONCAT function to concatenate values from multiple columns. The  is a shortcut for the CONCAT function in DB2, Oracle, and PostgreSQL, while + is the shortcut for SQL Server.  1.8 Using Conditional Logic in a SELECT Statement  Problem You want to perform IF-ELSE operations on values in your SELECT statement. For example, you would like to produce a result set such that if an employee is paid $2,000 or less, a message of “UNDERPAID” is returned; if an employee is paid $4,000 or more, a message of “OVERPAID” is returned; and if they make somewhere in between, then “OK” is returned. The result set should look like this:  Solution Use the CASE expression to perform conditional logic directly in your SELECT statement:    E N A M E                         S A L     S T A T U S   - - - - - - - - - -   - - - - - - - - - -     - - - - - - - - -   S M I T H                           8 0 0     U N D E R P A I D   A L L E N                         1 6 0 0     U N D E R P A I D   W A R D                           1 2 5 0     U N D E R P A I D   J O N E S                         2 9 7 5     O K   M A R T I N                       1 2 5 0     U N D E R P A I D   B L A K E                         2 8 5 0     O K   C L A R K                         2 4 5 0     O K   S C O T T                         3 0 0 0     O K   K I N G                           5 0 0 0     O V E R P A I D   T U R N E R                       1 5 0 0     U N D E R P A I D   A D A M S                         1 1 0 0     U N D E R P A I D   J A M E S                           9 5 0     U N D E R P A I D   F O R D                           3 0 0 0     O K   M I L L E R                       1 3 0 0     U N D E R P A I D  Discussion The CASE expression allows you to perform condition logic on values returned by a query. You can provide an alias for a CASE expression to return a more readable result set. In the solution, you’ll see the alias STATUS given to the result of the CASE expression. The ELSE clause is optional. Omit the ELSE, and the CASE expression will return NULL for any row that does not satisfy the test condition.  1.9 Limiting the Number of Rows Returned  Problem You want to limit the number of rows returned in your query. You are not concerned with order; any n rows will do.  Solution Use the built-in function provided by your database to control the number of rows returned.  DB2 In DB2 use the FETCH FIRST clause:  MySQL and PostgreSQL Do the same thing in MySQL and PostgreSQL using LIMIT:  1   s e l e c t   e n a m e , s a l ,   2                 c a s e   w h e n   s a l   < =   2 0 0 0   t h e n   ' U N D E R P A I D '   3                           w h e n   s a l   > =   4 0 0 0   t h e n   ' O V E R P A I D '   4                           e l s e   ' O K '   5                 e n d   a s   s t a t u s   6       f r o m   e m p 1   s e l e c t   *   2       f r o m   e m p   f e t c h   f i r s t   5   r o w s   o n l y  Oracle In Oracle, place a restriction on the number of rows returned by restricting ROWNUM in the WHERE clause:  SQL Server Use the TOP keyword to restrict the number of rows returned:  Discussion Many vendors provide clauses such as FETCH FIRST and LIMIT that let you specify the number of rows to be returned from a query. Oracle is different, in that you must make use of a function called ROWNUM that returns a number for each row returned  an increasing value starting from one . Here is what happens when you use ROWNUM <= 5 to return the first five rows:  1. Oracle executes your query. 2. Oracle fetches the first row and calls it row number one. 3. Have we gotten past row number five yet? If no, then Oracle returns the row, because it meets the criteria of being numbered less than or equal to five. If yes, then Oracle does not return the row.  4. Oracle fetches the next row and advances the row number  to two,  then to three, then to four, and so forth .  5. Go to step 3.  1   s e l e c t   *   2       f r o m   e m p   l i m i t   5 1   s e l e c t   *   2       f r o m   e m p   3     w h e r e   r o w n u m   < =   5 1   s e l e c t   t o p   5   *   2       f r o m   e m p  As this process shows, values from Oracle’s ROWNUM are assigned after each row is fetched. This is an important and key point. Many Oracle developers attempt to return only, say, the fifth row returned by a query by specifying ROWNUM = 5. Using an equality condition in conjunction with ROWNUM is a bad idea. Here is what happens when you try to return, say, the fifth row using ROWNUM = 5:  1. Oracle executes your query. 2. Oracle fetches the first row and calls it row number one. 3. Have we gotten to row number five yet? If no, then Oracle discards  the row, because it doesn’t meet the criteria. If yes, then Oracle returns the row. But the answer will never be yes!  4. Oracle fetches the next row and calls it row number one. This is  because the first row to be returned from the query must be numbered as one.  5. Go to step 3.  Study this process closely, and you can see why the use of ROWNUM = 5 to return the fifth row fails. You can’t have a fifth row if you don’t first return rows one through four! You may notice that ROWNUM = 1 does, in fact, work to return the first row, which may seem to contradict the explanation thus far. The reason ROWNUM = 1 works to return the first row is that, to determine whether there are any rows in the table, Oracle has to attempt to fetch at least once. Read the preceding process carefully, substituting one for five, and you’ll understand why it’s OK to specify ROWNUM = 1 as a condition  for returning one row .  1.10 Returning n Random Records from a Table   Problem You want to return a specific number of random records from a table. You want to modify the following statement such that successive executions will produce a different set of five rows:  Solution Take any built-in function supported by your DBMS for returning random values. Use that function in an ORDER BY clause to sort rows randomly. Then, use the previous recipe’s technique to limit the number of randomly sorted rows to return.  DB2 Use the built-in function RAND in conjunction with ORDER BY and FETCH:  MySQL Use the built-in RAND function in conjunction with LIMIT and ORDER BY:  PostgreSQL Use the built-in RANDOM function in conjunction with LIMIT and ORDER BY:  s e l e c t   e n a m e ,   j o b       f r o m   e m p 1   s e l e c t   e n a m e , j o b   2       f r o m   e m p   3     o r d e r   b y   r a n d       f e t c h   f i r s t   5   r o w s   o n l y 1   s e l e c t   e n a m e , j o b   2       f r o m   e m p   3     o r d e r   b y   r a n d       l i m i t   5  Oracle Use the built-in function VALUE, found in the built-in package DBMS_RANDOM, in conjunction with ORDER BY and the built-in function ROWNUM:  SQL Server Use the built-in function NEWID in conjunction with TOP and ORDER BY to return a random result set:  Discussion The ORDER BY clause can accept a function’s return value and use it to change the order of the result set. These solutions all restrict the number of rows to return after the function in the ORDER BY clause is executed. Non-Oracle users may find it helpful to look at the Oracle solution as it shows  conceptually  what is happening under the covers of the other solutions. It is important that you don’t confuse using a function in the ORDER BY clause with using a numeric constant. When specifying a numeric constant in the ORDER BY clause, you are requesting that the sort be done according the column in that ordinal position in the SELECT list. When you    1   s e l e c t   e n a m e , j o b   2       f r o m   e m p   3     o r d e r   b y   r a n d o m       l i m i t   5 1   s e l e c t   *   2       f r o m       3     s e l e c t   e n a m e ,   j o b   4         f r o m   e m p   6       o r d e r   b y   d b m s _ r a n d o m . v a l u e       7                     8       w h e r e   r o w n u m   < =   5 1   s e l e c t   t o p   5   e n a m e , j o b   2       f r o m   e m p   3     o r d e r   b y   n e w i d      specify a function in the ORDER BY clause, the sort is performed on the result from the function as it is evaluated for each row.  1.11 Finding Null Values  Problem You want to find all rows that are null for a particular column.  Solution To determine whether a value is null, you must use IS NULL:  Discussion NULL is never equal not equal to anything, not even itself; therefore, you cannot use = or != for testing whether a column is NULL. To determine whether a row has NULL values, you must use IS NULL. You can also use IS NOT NULL to find rows without a null in a given column.  1.12 Transforming Nulls into Real Values  Problem You have rows that contain nulls and would like to return non-null values in place of those nulls.  Solution Use the function COALESCE to substitute real values for nulls:  1   s e l e c t   *   2       f r o m   e m p   3     w h e r e   c o m m   i s   n u l l  Discussion The COALESCE function takes one or more values as arguments. The function returns the first non-null value in the list. In the solution, the value of COMM is returned whenever COMM is not null. Otherwise, a zero is returned. When working with nulls, it’s best to take advantage of the built-in functionality provided by your DBMS; in many cases you’ll find several functions work equally as well for this task. COALESCE happens to work for all DBMSs. Additionally, CASE can be used for all DBMSs as well:  While you can use CASE to translate nulls into values, you can see that it’s much easier and more succinct to use COALESCE.  1.13 Searching for Patterns  Problem You want to return rows that match a particular substring or pattern. Consider the following query and result set:  1   s e l e c t   c o a l e s c e   c o m m , 0     2       f r o m   e m p s e l e c t   c a s e                 w h e n   c o m m   i s   n o t   n u l l   t h e n   c o m m                 e l s e   0                 e n d       f r o m   e m p s e l e c t   e n a m e ,   j o b       f r o m   e m p     w h e r e   d e p t n o   i n     1 0 , 2 0       E N A M E               J O B   - - - - - - - - - -     - - - - - - - - -   S M I T H               C L E R K   J O N E S               M A N A G E R    Of the employees in departments 10 and 20, you want to return only those that have either an “I” somewhere in their name or a job title ending with “ER”:  Solution Use the LIKE operator in conjunction with the SQL wildcard operator  % :  Discussion When used in a LIKE pattern-match operation, the percent  %  operator matches any sequence of characters. Most SQL implementations also provide the underscore  “_”  operator to match a single character. By enclosing the search pattern “I” with % operators, any string that contains an “I”  at any position  will be returned. If you do not enclose the search pattern with %, then where you place the operator will affect the results of the query. For example, to find job titles that end in “ER,” prefix the % operator to “ER”; if the requirement is to search for all job titles beginning with “ER,” then append the % operator to “ER.”  C L A R K               M A N A G E R   S C O T T               A N A L Y S T   K I N G                 P R E S I D E N T   A D A M S               C L E R K   F O R D                 A N A L Y S T   M I L L E R             C L E R K E N A M E               J O B   - - - - - - - - - -     - - - - - - - - -   S M I T H               C L E R K   J O N E S               M A N A G E R   C L A R K               M A N A G E R   K I N G                 P R E S I D E N T   M I L L E R             C L E R K 1   s e l e c t   e n a m e ,   j o b   2       f r o m   e m p   3     w h e r e   d e p t n o   i n     1 0 , 2 0     4         a n d     e n a m e   l i k e   ' % I % '   o r   j o b   l i k e   ' % E R '    1.14 Summing Up These recipes may be simple, but they are also fundamental. Information retrieval is the core of database querying, and that means these recipes are at the heart of virtually everything that is discussed throughout the rest of the book.   Chapter 2. Sorting Query Results  This chapter focuses on customizing how your query results look. By understanding how to control how your result set is organized, you can provide more readable and meaningful data.  2.1 Returning Query Results in a Specified Order  Problem You want to display the names, jobs, and salaries of employees in department 10 in order based on their salary  from lowest to highest . You want to return the following result set:  Solution Use the ORDER BY clause:  Discussion  E N A M E               J O B                               S A L   - - - - - - - - - -     - - - - - - - - -     - - - - - - - - - -   M I L L E R             C L E R K                         1 3 0 0   C L A R K               M A N A G E R                     2 4 5 0   K I N G                 P R E S I D E N T                 5 0 0 0 1   s e l e c t   e n a m e , j o b , s a l   2       f r o m   e m p   3     w h e r e   d e p t n o   =   1 0   4     o r d e r   b y   s a l   a s c  The ORDER BY clause allows you to order the rows of your result set. The solution sorts the rows based on SAL in ascending order. By default, ORDER BY will sort in ascending order, and the ASC clause is therefore optional. Alternatively, specify DESC to sort in descending order:  You need not specify the name of the column on which to sort. You can instead specify a number representing the column. The number starts at 1 and matches the items in the SELECT list from left to right. For example:  The number 3 in this example’s ORDER BY clause corresponds to the third column in the SELECT list, which is SAL.  2.2 Sorting by Multiple Fields  Problem  s e l e c t   e n a m e , j o b , s a l       f r o m   e m p     w h e r e   d e p t n o   =   1 0     o r d e r   b y   s a l   d e s c     E N A M E               J O B                               S A L   - - - - - - - - - -     - - - - - - - - -     - - - - - - - - - -   K I N G                 P R E S I D E N T                 5 0 0 0   C L A R K               M A N A G E R                     2 4 5 0   M I L L E R             C L E R K                         1 3 0 0 s e l e c t   e n a m e , j o b , s a l       f r o m   e m p     w h e r e   d e p t n o   =   1 0     o r d e r   b y   3   d e s c     E N A M E               J O B                               S A L   - - - - - - - - - -     - - - - - - - - -     - - - - - - - - - -   K I N G                 P R E S I D E N T                 5 0 0 0   C L A R K               M A N A G E R                     2 4 5 0   M I L L E R             C L E R K                         1 3 0 0  You want to sort the rows from EMP first by DEPTNO ascending, then by salary descending. You want to return the following result set:  Solution List the different sort columns in the ORDER BY clause, separated by commas:  Discussion The order of precedence in ORDER BY is from left to right. If you are ordering using the numeric position of a column in the SELECT list, then that number must not be greater than the number of items in the SELECT list. You are generally permitted to order by a column not in the SELECT list, but to do so you must explicitly name the column. However, if you are using GROUP BY or DISTINCT in your query, you cannot order by columns that are not in the SELECT list.            E M P N O             D E P T N O                   S A L     E N A M E               J O B   - - - - - - - - - -     - - - - - - - - - -     - - - - - - - - - -     - - - - - - - - - -     - - - - - - - - -               7 8 3 9                     1 0                 5 0 0 0     K I N G                 P R E S I D E N T               7 7 8 2                     1 0                 2 4 5 0     C L A R K               M A N A G E R               7 9 3 4                     1 0                 1 3 0 0     M I L L E R             C L E R K               7 7 8 8                     2 0                 3 0 0 0     S C O T T               A N A L Y S T               7 9 0 2                     2 0                 3 0 0 0     F O R D                 A N A L Y S T               7 5 6 6                     2 0                 2 9 7 5     J O N E S               M A N A G E R               7 8 7 6                     2 0                 1 1 0 0     A D A M S               C L E R K               7 3 6 9                     2 0                   8 0 0     S M I T H               C L E R K               7 6 9 8                     3 0                 2 8 5 0     B L A K E               M A N A G E R               7 4 9 9                     3 0                 1 6 0 0     A L L E N               S A L E S M A N               7 8 4 4                     3 0                 1 5 0 0     T U R N E R             S A L E S M A N               7 5 2 1                     3 0                 1 2 5 0     W A R D                 S A L E S M A N               7 6 5 4                     3 0                 1 2 5 0     M A R T I N             S A L E S M A N               7 9 0 0                     3 0                   9 5 0     J A M E S               C L E R K 1   s e l e c t   e m p n o , d e p t n o , s a l , e n a m e , j o b   2       f r o m   e m p   3     o r d e r   b y   d e p t n o ,   s a l   d e s c  2.3 Sorting by Substrings  Problem You want to sort the results of a query by specific parts of a string. For example, you want to return employee names and jobs from table EMP and sort by the last two characters in the JOB field. The result set should look like the following:  Solution  DB2, MySQL, Oracle, and PostgreSQL Use the SUBSTR function in the ORDER BY clause:  SQL Server Use the SUBSTRING function in the ORDER BY clause:  E N A M E               J O B   - - - - - - - - - -     - - - - - - - - -   K I N G                 P R E S I D E N T   S M I T H               C L E R K   A D A M S               C L E R K   J A M E S               C L E R K   M I L L E R             C L E R K   J O N E S               M A N A G E R   C L A R K               M A N A G E R   B L A K E               M A N A G E R   A L L E N               S A L E S M A N   M A R T I N             S A L E S M A N   W A R D                 S A L E S M A N   T U R N E R             S A L E S M A N   S C O T T               A N A L Y S T   F O R D                 A N A L Y S T s e l e c t   e n a m e , j o b       f r o m   e m p     o r d e r   b y   s u b s t r   j o b , l e n g t h   j o b   - 1    Discussion Using your DBMS’s substring function, you can easily sort by any part of a string. To sort by the last two characters of a string, find the end of the string  which is the length of the string  and subtract two. The start position will be the second to last character in the string. You then take all characters after that start position. SQL Server’s SUBSTRING is different from the SUBSTR function as it requires a third parameter that specifies how many characters to take. In this example, any number greater than or equal to two will work.  2.4 Sorting Mixed Alphanumeric Data  Problem You have mixed alphanumeric data and want to sort by either the numeric or character portion of the data. Consider this view, created from the EMP table:  s e l e c t   e n a m e , j o b       f r o m   e m p     o r d e r   b y   s u b s t r i n g   j o b , l e n   j o b   - 1 , 2   c r e a t e   v i e w   V   a s   s e l e c t   e n a m e   '   '   d e p t n o   a s   d a t a       f r o m   e m p     s e l e c t   *   f r o m   V     D A T A   - - - - - - - - - - - - -   S M I T H   2 0   A L L E N   3 0   W A R D   3 0   J O N E S   2 0   M A R T I N   3 0   B L A K E   3 0   C L A R K   1 0   S C O T T   2 0    You want to sort the results by DEPTNO or ENAME. Sorting by DEPTNO produces the following result set:  Sorting by ENAME produces the following result set:  K I N G   1 0   T U R N E R   3 0   A D A M S   2 0   J A M E S   3 0   F O R D   2 0   M I L L E R   1 0 D A T A   - - - - - - - - - -   C L A R K   1 0   K I N G   1 0   M I L L E R   1 0   S M I T H   2 0   A D A M S   2 0   F O R D   2 0   S C O T T   2 0   J O N E S   2 0   A L L E N   3 0   B L A K E   3 0   M A R T I N   3 0   J A M E S   3 0   T U R N E R   3 0   W A R D   3 0 D A T A   - - - - - - - - -   A D A M S   2 0   A L L E N   3 0   B L A K E   3 0   C L A R K   1 0   F O R D   2 0   J A M E S   3 0   J O N E S   2 0   K I N G   1 0   M A R T I N   3 0   M I L L E R   1 0   S C O T T   2 0   S M I T H   2 0   T U R N E R   3 0   W A R D   3 0  Solution  Oracle, SQL Server, and PostgreSQL Use the functions REPLACE and TRANSLATE to modify the string for sorting:  DB2 Implicit type conversion is more strict in DB2 than in Oracle or PostgreSQL, so you will need to cast DEPTNO to a CHAR for view V to be valid. Rather than re-create view V, this solution will simply use an inline view. The solution uses REPLACE and TRANSLATE in the same way as the Oracle and PostrgreSQL solution, but the order of arguments for TRANSLATE is slightly different for DB2:    *   O R D E R   B Y   D E P T N O   *       1   s e l e c t   d a t a   2       f r o m   V   3     o r d e r   b y   r e p l a c e   d a t a ,   4                       r e p l a c e     5                   t r a n s l a t e   d a t a , ' 0 1 2 3 4 5 6 7 8 9 ' , '           '   , '  ' , ' '   , ' '         *   O R D E R   B Y   E N A M E   *       1   s e l e c t   d a t a   2       f r o m   V   3     o r d e r   b y   r e p l a c e     4                       t r a n s l a t e   d a t a , ' 0 1 2 3 4 5 6 7 8 9 ' , '           '   , '  ' , ' '     *   O R D E R   B Y   D E P T N O   *       1     s e l e c t   *   2         f r o m       3     s e l e c t   e n a m e   '   '   c a s t   d e p t n o   a s   c h a r   2       a s   d a t a   4         f r o m   e m p   5                       v   6       o r d e r   b y   r e p l a c e   d a t a ,   7                           r e p l a c e     8                       t r a n s l a t e   d a t a , '           ' , ' 0 1 2 3 4 5 6 7 8 9 '   , '  ' , ' '   , ' '         *   O R D E R   B Y   E N A M E   *      MySQL The TRANSLATE function is not currently supported by these platforms; thus, a solution for this problem will not be provided.  Discussion The TRANSLATE and REPLACE functions remove either the numbers or characters from each row, allowing you to easily sort by one or the other. The values passed to ORDER BY are shown in the following query results  using the Oracle solution as the example, as the same technique applies to all three vendors; only the order of parameters passed to TRANSLATE is what sets DB2 apart :    1     s e l e c t   *   2         f r o m       3     s e l e c t   e n a m e   '   '   c a s t   d e p t n o   a s   c h a r   2       a s   d a t a   4         f r o m   e m p   5                       v   6       o r d e r   b y   r e p l a c e     7                         t r a n s l a t e   d a t a , '           ' , ' 0 1 2 3 4 5 6 7 8 9 '   , '  ' , ' '   s e l e c t   d a t a ,                 r e p l a c e   d a t a ,                 r e p l a c e               t r a n s l a t e   d a t a , ' 0 1 2 3 4 5 6 7 8 9 ' , '           '   , '  ' , ' '   , ' '     n u m s ,                 r e p l a c e               t r a n s l a t e   d a t a , ' 0 1 2 3 4 5 6 7 8 9 ' , '           '   , '  ' , ' '     c h a r s       f r o m   V     D A T A                   N U M S       C H A R S   - - - - - - - - - - - -   - - - - - -   - - - - - - - - - -   S M I T H   2 0           2 0           S M I T H   A L L E N   3 0           3 0           A L L E N   W A R D   3 0             3 0           W A R D   J O N E S   2 0           2 0           J O N E S   M A R T I N   3 0         3 0           M A R T I N   B L A K E   3 0           3 0           B L A K E   C L A R K   1 0           1 0           C L A R K   S C O T T   2 0           2 0           S C O T T   K I N G   1 0             1 0           K I N G   T U R N E R   3 0         3 0           T U R N E R    2.5 Dealing with Nulls When Sorting  Problem You want to sort results from EMP by COMM, but the field is nullable. You need a way to specify whether nulls sort last:  or whether they sort first:  A D A M S   2 0           2 0           A D A M S   J A M E S   3 0           3 0           J A M E S   F O R D   2 0             2 0           F O R D   M I L L E R   1 0         1 0           M I L L E R E N A M E                             S A L                 C O M M   - - - - - - - - - -     - - - - - - - - - -     - - - - - - - - - -   T U R N E R                         1 5 0 0                       0   A L L E N                           1 6 0 0                   3 0 0   W A R D                             1 2 5 0                   5 0 0   M A R T I N                         1 2 5 0                 1 4 0 0   S M I T H                             8 0 0   J O N E S                           2 9 7 5   J A M E S                             9 5 0   M I L L E R                         1 3 0 0   F O R D                             3 0 0 0   A D A M S                           1 1 0 0   B L A K E                           2 8 5 0   C L A R K                           2 4 5 0   S C O T T                           3 0 0 0   K I N G                             5 0 0 0 E N A M E                             S A L                 C O M M   - - - - - - - - - -     - - - - - - - - - -     - - - - - - - - - -   S M I T H                             8 0 0   J O N E S                           2 9 7 5   C L A R K                           2 4 5 0   B L A K E                           2 8 5 0   S C O T T                           3 0 0 0   K I N G                             5 0 0 0   J A M E S                             9 5 0   M I L L E R                         1 3 0 0   F O R D                             3 0 0 0   A D A M S                           1 1 0 0    Solution Depending on how you want the data to look and how your particular RDBMS sorts NULL values, you can sort the nullable column in ascending or descending order:  This solution puts you in a position such that if the nullable column contains non-NULL values, they will be sorted in ascending or descending order as well, according to what you ask for; this may or may not be what you have in mind. If instead you would like to sort NULL values differently than non-NULL values, for example, you want to sort non-NULL values in ascending or descending order and all NULL values last, you can use a CASE expression to conditionally sort the column.  DB2, MySQL, PostgreSQL, and SQL Server Use a CASE expression to “flag” when a value is NULL. The idea is to have a flag with two values: one to represent NULLs, the other to represent non-NULLs. Once you have that, simply add this flag column to the ORDER BY clause. You’ll easily be able to control whether NULL values are sorted first or last without interfering with non-NULL values:  M A R T I N                         1 2 5 0                 1 4 0 0   W A R D                             1 2 5 0                   5 0 0   A L L E N                           1 6 0 0                   3 0 0   T U R N E R                         1 5 0 0                       0 1   s e l e c t   e n a m e , s a l , c o m m   2       f r o m   e m p   3     o r d e r   b y   3     1   s e l e c t   e n a m e , s a l , c o m m   2       f r o m   e m p   3     o r d e r   b y   3   d e s c   *   N O N - N U L L   C O M M   S O R T E D   A S C E N D I N G ,   A L L   N U L L S   L A S T   *       1     s e l e c t   e n a m e , s a l , c o m m   2         f r o m       3     s e l e c t   e n a m e , s a l , c o m m ,    4                   c a s e   w h e n   c o m m   i s   n u l l   t h e n   0   e l s e   1   e n d   a s   i s _ n u l l   5         f r o m   e m p   6                       x   7         o r d e r   b y   i s _ n u l l   d e s c , c o m m     E N A M E           S A L                 C O M M   - - - - - -     - - - - -     - - - - - - - - - -   T U R N E R       1 5 0 0                       0   A L L E N         1 6 0 0                   3 0 0   W A R D           1 2 5 0                   5 0 0   M A R T I N       1 2 5 0                 1 4 0 0   S M I T H           8 0 0   J O N E S         2 9 7 5   J A M E S           9 5 0   M I L L E R       1 3 0 0   F O R D           3 0 0 0   A D A M S         1 1 0 0   B L A K E         2 8 5 0   C L A R K         2 4 5 0   S C O T T         3 0 0 0   K I N G           5 0 0 0       *   N O N - N U L L   C O M M   S O R T E D   D E S C E N D I N G ,   A L L   N U L L S   L A S T   *       1     s e l e c t   e n a m e , s a l , c o m m   2         f r o m       3     s e l e c t   e n a m e , s a l , c o m m ,   4                   c a s e   w h e n   c o m m   i s   n u l l   t h e n   0   e l s e   1   e n d   a s   i s _ n u l l   5         f r o m   e m p   6                       x   7       o r d e r   b y   i s _ n u l l   d e s c , c o m m   d e s c     E N A M E           S A L                 C O M M   - - - - - -     - - - - -     - - - - - - - - - -   M A R T I N       1 2 5 0                 1 4 0 0   W A R D           1 2 5 0                   5 0 0   A L L E N         1 6 0 0                   3 0 0   T U R N E R       1 5 0 0                       0   S M I T H           8 0 0   J O N E S         2 9 7 5   J A M E S           9 5 0   M I L L E R       1 3 0 0   F O R D           3 0 0 0   A D A M S         1 1 0 0   B L A K E         2 8 5 0   C L A R K         2 4 5 0   S C O T T         3 0 0 0   K I N G           5 0 0 0        *   N O N - N U L L   C O M M   S O R T E D   A S C E N D I N G ,   A L L   N U L L S   F I R S T   *       1   s e l e c t   e n a m e , s a l , c o m m   2       f r o m       3   s e l e c t   e n a m e , s a l , c o m m ,   4                 c a s e   w h e n   c o m m   i s   n u l l   t h e n   0   e l s e   1   e n d   a s   i s _ n u l l   5       f r o m   e m p   6                     x   7     o r d e r   b y   i s _ n u l l , c o m m     E N A M E         S A L               C O M M   - - - - - -   - - - - -   - - - - - - - - - -   S M I T H         8 0 0   J O N E S       2 9 7 5   C L A R K       2 4 5 0   B L A K E       2 8 5 0   S C O T T       3 0 0 0   K I N G         5 0 0 0   J A M E S         9 5 0   M I L L E R     1 3 0 0   F O R D         3 0 0 0   A D A M S       1 1 0 0   T U R N E R     1 5 0 0                     0   A L L E N       1 6 0 0                 3 0 0   W A R D         1 2 5 0                 5 0 0   M A R T I N     1 2 5 0               1 4 0 0       *   N O N - N U L L   C O M M   S O R T E D   D E S C E N D I N G ,   A L L   N U L L S   F I R S T   *       1     s e l e c t   e n a m e , s a l , c o m m   2         f r o m       3     s e l e c t   e n a m e , s a l , c o m m ,   4                   c a s e   w h e n   c o m m   i s   n u l l   t h e n   0   e l s e   1   e n d   a s   i s _ n u l l   5         f r o m   e m p   6                       x   7       o r d e r   b y   i s _ n u l l , c o m m   d e s c     E N A M E         S A L               C O M M   - - - - - -   - - - - -   - - - - - - - - - -   S M I T H         8 0 0   J O N E S       2 9 7 5   C L A R K       2 4 5 0   B L A K E       2 8 5 0   S C O T T       3 0 0 0   K I N G         5 0 0 0   J A M E S         9 5 0   M I L L E R     1 3 0 0    Oracle Oracle users can use the solution for the other platforms. They can also use the following Oracle-only solution, taking advantage of the NULLS FIRST and NULLS LAST extension to the ORDER BY clause to ensure NULLs are sorted first or last regardless of how non-NULL values are sorted:  F O R D         3 0 0 0   A D A M S       1 1 0 0   M A R T I N     1 2 5 0               1 4 0 0   W A R D         1 2 5 0                 5 0 0   A L L E N       1 6 0 0                 3 0 0   T U R N E R     1 5 0 0                     0   *   N O N - N U L L   C O M M   S O R T E D   A S C E N D I N G ,   A L L   N U L L S   L A S T   *       1   s e l e c t   e n a m e , s a l , c o m m   2       f r o m   e m p   3     o r d e r   b y   c o m m   n u l l s   l a s t     E N A M E         S A L               C O M M   - - - - - -     - - - - -   - - - - - - - - -   T U R N E R       1 5 0 0                   0   A L L E N         1 6 0 0               3 0 0   W A R D           1 2 5 0               5 0 0   M A R T I N       1 2 5 0             1 4 0 0   S M I T H           8 0 0   J O N E S         2 9 7 5   J A M E S           9 5 0   M I L L E R       1 3 0 0   F O R D           3 0 0 0   A D A M S         1 1 0 0   B L A K E         2 8 5 0   C L A R K         2 4 5 0   S C O T T         3 0 0 0   K I N G           5 0 0 0       *   N O N - N U L L   C O M M   S O R T E D   A S C E N D I N G ,   A L L   N U L L S   F I R S T   *       1   s e l e c t   e n a m e , s a l , c o m m   2       f r o m   e m p   3     o r d e r   b y   c o m m   n u l l s   f i r s t     E N A M E         S A L               C O M M   - - - - - -   - - - - -   - - - - - - - - - -    Discussion Unless your RDBMS provides you with a way to easily sort NULL values first or last without modifying non-NULL values in the same column  as Oracle does , you’ll need an auxiliary column.  S M I T H         8 0 0   J O N E S       2 9 7 5   C L A R K       2 4 5 0   B L A K E       2 8 5 0   S C O T T       3 0 0 0   K I N G         5 0 0 0   J A M E S         9 5 0   M I L L E R     1 3 0 0   F O R D         3 0 0 0   A D A M S       1 1 0 0   T U R N E R     1 5 0 0                     0   A L L E N       1 6 0 0                 3 0 0   W A R D         1 2 5 0                 5 0 0   M A R T I N     1 2 5 0               1 4 0 0       *   N O N - N U L L   C O M M   S O R T E D   D E S C E N D I N G ,   A L L   N U L L S   F I R S T   *       1   s e l e c t   e n a m e , s a l , c o m m   2       f r o m   e m p   3     o r d e r   b y   c o m m   d e s c   n u l l s   f i r s t     E N A M E         S A L               C O M M   - - - - - -   - - - - -   - - - - - - - - - -   S M I T H         8 0 0   J O N E S       2 9 7 5   C L A R K       2 4 5 0   B L A K E       2 8 5 0   S C O T T       3 0 0 0   K I N G         5 0 0 0   J A M E S         9 5 0   M I L L E R     1 3 0 0   F O R D         3 0 0 0   A D A M S       1 1 0 0   M A R T I N     1 2 5 0               1 4 0 0   W A R D         1 2 5 0                 5 0 0   A L L E N       1 6 0 0                 3 0 0   T U R N E R     1 5 0 0                     0  TIP  As of the time of this writing, DB2 users can use NULLS FIRST and NULLS LAST in the ORDER BY subclause of the OVER clause in window functions but not in the ORDER BY clause for the entire result set.  The purpose of this extra column  in the query only, not in the table  is to allow you to identify NULL values and sort them altogether, first or last. The following query returns the result set for inline view X for the non- Oracle solution:  By using the values returned by IS_NULL, you can easily sort NULLS first or last without interfering with the sorting of COMM.  2.6 Sorting on a Data-Dependent Key  Problem  s e l e c t   e n a m e , s a l , c o m m ,                 c a s e   w h e n   c o m m   i s   n u l l   t h e n   0   e l s e   1   e n d   a s   i s _ n u l l       f r o m   e m p     E N A M E         S A L               C O M M         I S _ N U L L   - - - - - -   - - - - -   - - - - - - - - - -   - - - - - - - - - -   S M I T H         8 0 0                                           0   A L L E N       1 6 0 0                 3 0 0                     1   W A R D         1 2 5 0                 5 0 0                     1     J O N E S       2 9 7 5                                           0   M A R T I N     1 2 5 0               1 4 0 0                     1   B L A K E       2 8 5 0                                           0   C L A R K       2 4 5 0                                           0   S C O T T       3 0 0 0                                           0   K I N G         5 0 0 0                                           0   T U R N E R     1 5 0 0                     0                     1   A D A M S       1 1 0 0                                           0   J A M E S         9 5 0                                           0   F O R D         3 0 0 0                                           0   M I L L E R     1 3 0 0                                           0  You want to sort based on some conditional logic. For example, if JOB is SALESMAN, you want to sort on COMM; otherwise, you want to sort by SAL. You want to return the following result set:  Solution Use a CASE expression in the ORDER BY clause:  Discussion You can use the CASE expression to dynamically change how results are sorted. The values passed to the ORDER BY look as follows:  E N A M E                           S A L   J O B                           C O M M   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - -   - - - - - - - - - -   T U R N E R                       1 5 0 0     S A L E S M A N                     0   A L L E N                         1 6 0 0     S A L E S M A N                 3 0 0   W A R D                           1 2 5 0     S A L E S M A N                 5 0 0   S M I T H                           8 0 0     C L E R K   J A M E S                           9 5 0     C L E R K   A D A M S                         1 1 0 0     C L E R K   M I L L E R                       1 3 0 0     C L E R K   M A R T I N                       1 2 5 0     S A L E S M A N               1 4 0 0   C L A R K                         2 4 5 0     M A N A G E R   B L A K E                         2 8 5 0     M A N A G E R   J O N E S                         2 9 7 5     M A N A G E R   S C O T T                         3 0 0 0     A N A L Y S T   F O R D                           3 0 0 0     A N A L Y S T   K I N G                           5 0 0 0     P R E S I D E N T 1   s e l e c t   e n a m e , s a l , j o b , c o m m   2       f r o m   e m p   3     o r d e r   b y   c a s e   w h e n   j o b   =   ' S A L E S M A N '   t h e n   c o m m   e l s e   s a l   e n d s e l e c t   e n a m e , s a l , j o b , c o m m ,                 c a s e   w h e n   j o b   =   ' S A L E S M A N '   t h e n   c o m m   e l s e   s a l   e n d   a s   o r d e r e d       f r o m   e m p     o r d e r   b y   5     E N A M E                           S A L   J O B                           C O M M         O R D E R E D   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   T U R N E R                       1 5 0 0   S A L E S M A N                       0                     0   A L L E N                         1 6 0 0   S A L E S M A N                   3 0 0                 3 0 0    2.7 Summing Up Sorting query results is one of the core skills for any user of SQL. The ORDER BY clause can be very powerful, but as we have seen in this chapter, still often requires some nuance to use effectively. It’s important to master its use, as many of the recipes in the later chapters depend on it.  W A R D 1                           2 5 0   S A L E S M A N                   5 0 0                 5 0 0   S M I T H                           8 0 0   C L E R K                                               8 0 0   J A M E S                           9 5 0   C L E R K                                               9 5 0   A D A M S                         1 1 0 0   C L E R K                                             1 1 0 0   M I L L E R                       1 3 0 0   C L E R K                                             1 3 0 0   M A R T I N                       1 2 5 0   S A L E S M A N                 1 4 0 0               1 4 0 0   C L A R K 2                         4 5 0   M A N A G E R                                         2 4 5 0   B L A K E 2                         8 5 0   M A N A G E R                                         2 8 5 0   J O N E S 2                         9 7 5   M A N A G E R                                         2 9 7 5   S C O T T                         3 0 0 0   A N A L Y S T                                         3 0 0 0   F O R D                           3 0 0 0   A N A L Y S T                                         3 0 0 0   K I N G                           5 0 0 0   P R E S I D E N T                                     5 0 0 0  Chapter 3. Working with Multiple Tables  This chapter introduces the use of joins and set operations to combine data from multiple tables. Joins are the foundation of SQL. Set operations are also important. If you want to master the complex queries found in the later chapters of this book, you must start here, with joins and set operations.  3.1 Stacking One Rowset atop Another  Problem You want to return data stored in more than one table, conceptually stacking one result set atop the other. The tables do not necessarily have a common key, but their columns do have the same data types. For example, you want to display the name and department number of the employees in department 10 in table EMP, along with the name and department number of each department in table DEPT. You want the result set to look like the following:  Solution  E N A M E _ A N D _ D N A M E             D E P T N O   - - - - - - - - - - - - - - -     - - - - - - - - - -   C L A R K                                         1 0   K I N G                                           1 0   M I L L E R                                       1 0   - - - - - - - - - -   A C C O U N T I N G                               1 0   R E S E A R C H                                   2 0   S A L E S                                         3 0   O P E R A T I O N S                               4 0  Use the set operation UNION ALL to combine rows from multiple tables:  Discussion UNION ALL combines rows from multiple row sources into one result set. As with all set operations, the items in all the SELECT lists must match in number and data type. For example, both of the following queries will fail:  It is important to note, UNION ALL will include duplicates if they exist. If you want to filter out duplicates, use the UNION operator. For example, a UNION between EMP.DEPTNO and DEPT.DEPTNO returns only four rows:  1     s e l e c t   e n a m e   a s   e n a m e _ a n d _ d n a m e ,   d e p t n o   2         f r o m   e m p   3       w h e r e   d e p t n o   =   1 0   4       u n i o n   a l l   5     s e l e c t   ' - - - - - - - - - - ' ,   n u l l   6         f r o m   t 1   7       u n i o n   a l l   8     s e l e c t   d n a m e ,   d e p t n o   9         f r o m   d e p t s e l e c t   d e p t n o            s e l e c t   d e p t n o ,   d n a m e       f r o m   d e p t                    f r o m   d e p t     u n i o n   a l l                    u n i o n   a l l   s e l e c t   e n a m e              s e l e c t   d e p t n o       f r o m   e m p                      f r o m   e m p s e l e c t   d e p t n o       f r o m   e m p     u n i o n   s e l e c t   d e p t n o       f r o m   d e p t           D E P T N O   - - - - - - - - -                 1 0                 2 0                 3 0                 4 0  Specifying UNION rather than UNION ALL will most likely result in a sort operation to eliminate duplicates. Keep this in mind when working with large result sets. Using UNION is roughly equivalent to the following query, which applies DISTINCT to the output from a UNION ALL:  You wouldn’t use DISTINCT in a query unless you had to, and the same rule applies for UNION: don’t use it instead of UNION ALL unless you have to. For example, although in this book we have limited the number of tables for teaching purposes, in real life if you are querying one table, there may be a more suitable way to query a single table.  3.2 Combining Related Rows  Problem You want to return rows from multiple tables by joining on a known common column or joining on columns that share common values. For example, you want to display the names of all employees in department 10 along with the location of each employee’s department, but that data is stored in two separate tables. You want the result set to be the following:  s e l e c t   d i s t i n c t   d e p t n o       f r o m       s e l e c t   d e p t n o       f r o m   e m p     u n i o n   a l l   s e l e c t   d e p t n o       f r o m   d e p t                                 D E P T N O   - - - - - - - - -                 1 0                 2 0                 3 0                 4 0  Solution Join table EMP to table DEPT on DEPTNO:  Discussion The solution is an example of a join, or more accurately an equi-join, which is a type of inner join. A join is an operation that combines rows from two tables into one. An equi-join is one in which the join condition is based on an equality condition  e.g., where one department number equals another . An inner join is the original type of join; each row returned contains data from each table. Conceptually, the result set from a join is produced by first creating a Cartesian product  all possible combinations of rows  from the tables listed in the FROM clause, as shown here:  E N A M E               L O C   - - - - - - - - - -     - - - - - - - - - -   C L A R K               N E W   Y O R K   K I N G                 N E W   Y O R K   M I L L E R             N E W   Y O R K 1   s e l e c t   e . e n a m e ,   d . l o c   2       f r o m   e m p   e ,   d e p t   d   3     w h e r e   e . d e p t n o   =   d . d e p t n o   4         a n d   e . d e p t n o   =   1 0 s e l e c t   e . e n a m e ,   d . l o c ,                 e . d e p t n o   a s   e m p _ d e p t n o ,                 d . d e p t n o   a s   d e p t _ d e p t n o       f r o m   e m p   e ,   d e p t   d     w h e r e   e . d e p t n o   =   1 0     E N A M E             L O C                         E M P _ D E P T N O   D E P T _ D E P T N O   - - - - - - - - - -   - - - - - - - - - - - - -     - - - - - - - - - -   - - - - - - - - - - -   C L A R K             N E W   Y O R K                               1 0                     1 0   K I N G               N E W   Y O R K                               1 0                     1 0   M I L L E R           N E W   Y O R K                               1 0                     1 0   C L A R K             D A L L A S                                   1 0                     2 0     K I N G               D A L L A S                                   1 0                     2 0    Every employee in table EMP  in department 10  is returned along with every department in table DEPT. Then, the expression in the WHERE clause involving e.deptno and d.deptno  the join  restricts the result set such that the only rows returned are the ones where EMP.DEPTNO and DEPT.DEPTNO are equal:  An alternative solution makes use of an explicit JOIN clause  the INNER keyword is optional :  Use the JOIN clause if you prefer to have the join logic in the FROM clause rather than the WHERE clause. Both styles are ANSI compliant and work on all the latest versions of the RDBMSs in this book.  M I L L E R           D A L L A S                                   1 0                     2 0   C L A R K             C H I C A G O                                 1 0                     3 0   K I N G               C H I C A G O                                 1 0                     3 0   M I L L E R           C H I C A G O                                 1 0                     3 0   C L A R K             B O S T O N                                   1 0                     4 0   K I N G               B O S T O N                                   1 0                     4 0   M I L L E R           B O S T O N                                   1 0                     4 0 s e l e c t   e . e n a m e ,   d . l o c ,                 e . d e p t n o   a s   e m p _ d e p t n o ,                 d . d e p t n o   a s   d e p t _ d e p t n o       f r o m   e m p   e ,   d e p t   d     w h e r e   e . d e p t n o   =   d . d e p t n o         a n d   e . d e p t n o   =   1 0     E N A M E               L O C                           E M P _ D E P T N O     D E P T _ D E P T N O   - - - - - - - - - -     - - - - - - - - - - - - - -     - - - - - - - - - -     - - - - - - - - - - -   C L A R K               N E W   Y O R K                                 1 0                       1 0   K I N G                 N E W   Y O R K                                 1 0                       1 0   M I L L E R             N E W   Y O R K                                 1 0                       1 0 s e l e c t   e . e n a m e ,   d . l o c       f r o m   e m p   e   i n n e r   j o i n   d e p t   d           o n     e . d e p t n o   =   d . d e p t n o       w h e r e   e . d e p t n o   =   1 0  3.3 Finding Rows in Common Between Two Tables  Problem You want to find common rows between two tables, but there are multiple columns on which you can join. For example, consider the following view V created from the EMP table for teaching purposes:  Only clerks are returned from view V. However, the view does not show all possible EMP columns. You want to return the EMPNO, ENAME, JOB, SAL, and DEPTNO of all employees in EMP that match the rows from view V. You want the result set to be the following:  Solution Join the tables on all the columns necessary to return the correct result. Alternatively, use the set operation INTERSECT to avoid performing a join  c r e a t e   v i e w   V   a s   s e l e c t   e n a m e , j o b , s a l       f r o m   e m p     w h e r e   j o b   =   ' C L E R K '         s e l e c t   *   f r o m   V     E N A M E               J O B                             S A L   - - - - - - - - - -     - - - - - - - - -   - - - - - - - - - -   S M I T H               C L E R K                         8 0 0   A D A M S               C L E R K                       1 1 0 0   J A M E S               C L E R K                         9 5 0   M I L L E R             C L E R K                       1 3 0 0       E M P N O     E N A M E               J O B                           S A L           D E P T N O   - - - - - - - -     - - - - - - - - - -     - - - - - - - - -   - - - - - - - - - -   - - - - - - - - -         7 3 6 9       S M I T H               C L E R K                       8 0 0                   2 0         7 8 7 6       A D A M S               C L E R K                     1 1 0 0                   2 0         7 9 0 0       J A M E S               C L E R K                       9 5 0                   3 0         7 9 3 4       M I L L E R             C L E R K                     1 3 0 0                   1 0  and instead return the intersection  common rows  of the two tables.  MySQL and SQL Server Join table EMP to view V using multiple join conditions:  Alternatively, you can perform the same join via the JOIN clause:  DB2, Oracle, and PostgreSQL The MySQL and SQL Server solution also works for DB2, Oracle, and PostgreSQL. It’s the solution you should use if you need to return values from view V. If you do not actually need to return columns from view V, you may use the set operation INTERSECT along with an IN predicate:  Discussion When performing joins, you must consider the proper columns to join in order to return correct results. This is especially important when rows can  1   s e l e c t   e . e m p n o , e . e n a m e , e . j o b , e . s a l , e . d e p t n o   2       f r o m   e m p   e ,   V   3     w h e r e   e . e n a m e   =   v . e n a m e   4         a n d   e . j o b       =   v . j o b   5         a n d   e . s a l       =   v . s a l 1   s e l e c t   e . e m p n o , e . e n a m e , e . j o b , e . s a l , e . d e p t n o   2       f r o m   e m p   e   j o i n   V   3           o n             e . e n a m e       =   v . e n a m e   4                 a n d   e . j o b           =   v . j o b   5                 a n d   e . s a l           =   v . s a l     1   s e l e c t   e m p n o , e n a m e , j o b , s a l , d e p t n o   2       f r o m   e m p   3     w h e r e     e n a m e , j o b , s a l     i n       4       s e l e c t   e n a m e , j o b , s a l   f r o m   e m p   5     i n t e r s e c t   6       s e l e c t   e n a m e , j o b , s a l   f r o m   V   7        have common values for some columns while having different values for others. The set operation INTERSECT will return rows common to both row sources. When using INTERSECT, you are required to compare the same number of items, having the same data type, from two tables. When working with set operations, keep in mind that, by default, duplicate rows will not be returned.  3.4 Retrieving Values from One Table That Do Not Exist in Another  Problem You want to find those values in one table, call it the source table, that do not also exist in some target table. For example, you want to find which departments  if any  in table DEPT do not exist in table EMP. In the example data, DEPTNO 40 from table DEPT does not exist in table EMP, so the result set should be the following:  Solution Having functions that perform set difference is particularly useful for this problem. DB2, PostgreSQL, SQL Server, and Oracle all support set difference operations. If your DBMS does not support a set difference function, use a subquery as shown for MySQL.  DB2, PostgreSQL, and SQL Server Use the set operation EXCEPT:          D E P T N O   - - - - - - - - - -                   4 0 1   s e l e c t   d e p t n o   f r o m   d e p t   2   e x c e p t    Oracle Use the set operation MINUS:  MySQL Use a subquery to return all DEPTNOs from table EMP into an outer query that searches table DEPT for rows that are not among the rows returned from the subquery:  Discussion  DB2, PostgreSQL, and SQL Server Set difference functions make this operation easy. The EXCEPT operator takes the first result set and removes from it all rows found in the second result set. The operation is very much like a subtraction. There are restrictions on the use of set operators, including EXCEPT. Data types and number of values to compare must match in both SELECT lists. Additionally, EXCEPT will not return duplicates and, unlike a subquery using NOT IN, NULLs do not present a problem  see the discussion for MySQL . The EXCEPT operator will return rows from the upper query  the query before the EXCEPT  that do not exist in the lower query  the query after the EXCEPT .  Oracle The Oracle solution is identical to the solution using the EXCEPT operator; however, Oracle calls its set difference operator MINUS instead of  3   s e l e c t   d e p t n o   f r o m   e m p 1   s e l e c t   d e p t n o   f r o m   d e p t   2   m i n u s   3   s e l e c t   d e p t n o   f r o m   e m p 1   s e l e c t   d e p t n o   2       f r o m   d e p t   3     w h e r e   d e p t n o   n o t   i n     s e l e c t   d e p t n o   f r o m   e m p    EXCEPT. Otherwise, the preceding explanation applies to Oracle as well.  MySQL The subquery will return all DEPTNOs from table EMP. The outer query returns all DEPTNOs from table DEPT that are “not in” or “not included in” the result set returned from the subquery. Duplicate elimination is something you’ll want to consider when using the MySQL solutions. The EXCEPT- and MINUS-based solutions used for the other platforms eliminate duplicate rows from the result set, ensuring that each DEPTNO is reported only one time. Of course, that can only be the case anyway, as DEPTNO is a key field in my example data. Were DEPTNO not a key field, you could use DISTINCT as follows to ensure that each DEPTNO value missing from EMP is reported only once:  Be mindful of NULLs when using NOT IN. Consider the following table, NEW_DEPT:  If you try to find the DEPTNOs in table DEPT that do not exist in table NEW_DEPT and use a subquery with NOT IN, you’ll find that the query returns no rows:  DEPTNOs 20, 30, and 40 are not in table NEW_DEPT, yet were not returned by the query. Why? The reason is the NULL value present in table NEW_DEPT. Three rows are returned by the subquery, with DEPTNOs of  s e l e c t   d i s t i n c t   d e p t n o       f r o m   d e p t     w h e r e   d e p t n o   n o t   i n     s e l e c t   d e p t n o   f r o m   e m p   c r e a t e   t a b l e   n e w _ d e p t   d e p t n o   i n t e g e r     i n s e r t   i n t o   n e w _ d e p t v a l u e s     1 0     i n s e r t   i n t o   n e w _ d e p t   v a l u e s     5 0     i n s e r t   i n t o   n e w _ d e p t   v a l u e s     n u l l   s e l e c t   *       f r o m   d e p t     w h e r e   d e p t n o   n o t   i n     s e l e c t   d e p t n o   f r o m   n e w _ d e p t    10, 50, and NULL. IN and NOT IN are essentially OR operations and will yield different results because of how NULL values are treated by logical OR evaluations. To understand this, examine these truth tables  Let T=true, F=false, N=null :  Now consider the following example using IN and its equivalent using OR:      O R      T      F      N        + - - - - + - - - + - - - + - - - - +      T        T      T      T           F        T      F      N           N        T      N      N        + - - - - + - - - + - - - + - - - - +         N O T      + - - - - - + - - - +        T        F           F        T           N        N      + - - - - - + - - - +         A N D      T      F      N      + - - - - - + - - - + - - - + - - - +        T        T      F      N           F        F      F      F           N        N      F      N      + - - - - - + - - - + - - - + - - - + s e l e c t   d e p t n o       f r o m   d e p t     w h e r e   d e p t n o   i n       1 0 , 5 0 , n u l l           D E P T N O   - - - - - - -             1 0     s e l e c t   d e p t n o       f r o m   d e p t     w h e r e     d e p t n o = 1 0   o r   d e p t n o = 5 0   o r   d e p t n o = n u l l       D E P T N O   - - - - - - -             1 0  Why was only DEPTNO 10 returned? There are four DEPTNOs in DEPT,  10, 20, 30, 40 , and each one is evaluated against the predicate  deptno=10 or deptno=50 or deptno=null . According to the preceding truth tables, for each DEPTNO  10, 20, 30, 40 , the predicate yields:  Now it is obvious why only DEPTNO 10 was returned when using IN and OR. Next, consider the same example using NOT IN and NOT OR:  D E P T N O = 1 0     d e p t n o = 1 0   o r   d e p t n o = 5 0   o r   d e p t n o = n u l l     =     1 0 = 1 0   o r   1 0 = 5 0   o r   1 0 = n u l l     =     T   o r   F   o r   N     =     T   o r   N     =     T       D E P T N O = 2 0     d e p t n o = 1 0   o r   d e p t n o = 5 0   o r   d e p t n o = n u l l     =     2 0 = 1 0   o r   2 0 = 5 0   o r   2 0 = n u l l     =     F   o r   F   o r   N     =     F   o r   N     =     N       D E P T N O = 3 0     d e p t n o = 1 0   o r   d e p t n o = 5 0   o r   d e p t n o = n u l l     =     3 0 = 1 0   o r   3 0 = 5 0   o r   3 0 = n u l l     =     F   o r   F   o r   N     =     F   o r   N     =     N       D E P T N O = 4 0     d e p t n o = 1 0   o r   d e p t n o = 5 0   o r   d e p t n o = n u l l     =     4 0 = 1 0   o r   4 0 = 5 0   o r   4 0 = n u l l     =     F   o r   F   o r   N     =     F   o r   N     =     N   s e l e c t   d e p t n o       f r o m   d e p t     w h e r e   d e p t n o   n o t   i n       1 0 , 5 0 , n u l l             n o   r o w s         s e l e c t   d e p t n o       f r o m   d e p t    Why are no rows returned? Let’s check the truth tables:  In SQL, “TRUE or NULL” is TRUE, but “FALSE or NULL” is NULL! You must keep this in mind when using IN predicates, and when performing logical OR evaluations and NULL values are involved. To avoid the problem with NOT IN and NULLs, use a correlated subquery in conjunction with NOT EXISTS. The term correlated subquery is used    w h e r e   n o t     d e p t n o = 1 0   o r   d e p t n o = 5 0   o r   d e p t n o = n u l l           n o   r o w s     D E P T N O = 1 0   N O T     d e p t n o = 1 0   o r   d e p t n o = 5 0   o r   d e p t n o = n u l l     =   N O T     1 0 = 1 0   o r   1 0 = 5 0   o r   1 0 = n u l l     =   N O T     T   o r   F   o r   N     =   N O T     T   o r   N     =   N O T     T     =     F       D E P T N O = 2 0   N O T     d e p t n o = 1 0   o r   d e p t n o = 5 0   o r   d e p t n o = n u l l     =   N O T     2 0 = 1 0   o r   2 0 = 5 0   o r   2 0 = n u l l     =   N O T     F   o r   F   o r   N     =   N O T     F   o r   N     =   N O T     N     =     N       D E P T N O = 3 0   N O T     d e p t n o = 1 0   o r   d e p t n o = 5 0   o r   d e p t n o = n u l l     =   N O T     3 0 = 1 0   o r   3 0 = 5 0   o r   3 0 = n u l l     =   N O T     F   o r   F   o r   N     =   N O T     F   o r   N     =   N O T     N     =     N       D E P T N O = 4 0   N O T     d e p t n o = 1 0   o r   d e p t n o = 5 0   o r   d e p t n o = n u l l     =   N O T     4 0 = 1 0   o r   4 0 = 5 0   o r   4 0 = n u l l     =   N O T     F   o r   F   o r   N     =   N O T     F   o r   N     =   N O T     N     =     N    because rows from the outer query are referenced in the subquery. The following example is an alternative solution that will not be affected by NULL rows  going back to the original query from the “Problem” section :  Conceptually, the outer query in this solution considers each row in the DEPT table. For each DEPT row, the following happens:  1. The subquery is executed to see whether the department number exists  in the EMP table. Note the condition D.DEPTNO = E.DEPTNO, which brings together the department numbers from the two tables.  2. If the subquery returns results, then EXISTS  …  evaluates to true and  NOT EXISTS  …  thus evaluates to FALSE, and the row being considered by the outer query is discarded.  3. If the subquery returns no results, then NOT EXISTS  …  evaluates to  TRUE, and the row being considered by the outer query is returned  s e l e c t   d . d e p t n o       f r o m   d e p t   d     w h e r e   n o t   e x i s t s             s e l e c t   1             f r o m   e m p   e           w h e r e   d . d e p t n o   =   e . d e p t n o         D E P T N O   - - - - - - - - - -   4 0     s e l e c t   d . d e p t n o       f r o m   d e p t   d     w h e r e   n o t   e x i s t s             s e l e c t   1             f r o m   n e w _ d e p t   n d           w h e r e   d . d e p t n o   =   n d . d e p t n o         D E P T N O   - - - - - - - - - -   3 0   4 0   2 0   because it is for a department not represented in the EMP table .  The items in the SELECT list of the subquery are unimportant when using a correlated subquery with EXISTS NOT EXISTS, which is why we chose to select NULL, to force you to focus on the join in the subquery rather than the items in the SELECT list.  3.5 Retrieving Rows from One Table That Do Not Correspond to Rows in Another  Problem You want to find rows that are in one table that do not have a match in another table, for two tables that have common keys. For example, you want to find which departments have no employees. The result set should be the following:  Finding the department each employee works in requires an equi-join on DEPTNO from EMP to DEPT. The DEPTNO column represents the common value between tables. Unfortunately, an equi-join will not show you which department has no employees. That’s because by equi-joining EMP and DEPT you are returning all rows that satisfy the join condition. Instead, you want only those rows from DEPT that do not satisfy the join condition. This is a subtly different problem than in the preceding recipe, though at first glance they may seem the same. The difference is that the preceding recipe yields only a list of department numbers not represented in table EMP. Using this recipe, however, you can easily return other columns from the DEPT table; you can return more than just department numbers.          D E P T N O     D N A M E                       L O C   - - - - - - - - - -     - - - - - - - - - - - - - -     - - - - - - - - - - - - -                   4 0     O P E R A T I O N S             B O S T O N  Solution Return all rows from one table along with rows from another that may or may not have a match on the common column. Then, keep only those rows with no match.  DB2, MySQL, PostgreSQL, and SQL Server Use an outer join and filter for NULLs  keyword OUTER is optional :  Discussion This solution works by outer joining and then keeping only rows that have no match. This sort of operation is sometimes called an anti-join. To get a better idea of how an anti-join works, first examine the result set without filtering for NULLs:  1   s e l e c t   d . *   2       f r o m   d e p t   d   l e f t   o u t e r   j o i n   e m p   e   3           o n     d . d e p t n o   =   e . d e p t n o     4     w h e r e   e . d e p t n o   i s   n u l l s e l e c t   e . e n a m e ,   e . d e p t n o   a s   e m p _ d e p t n o ,   d . *       f r o m   d e p t   d   l e f t   j o i n   e m p   e           o n     d . d e p t n o   =   e . d e p t n o       E N A M E               E M P _ D E P T N O             D E P T N O   D N A M E                     L O C   - - - - - - - - - -     - - - - - - - - - -     - - - - - - - - - -   - - - - - - - - - - - - - -   - - - - - - - - - - - - -   S M I T H                               2 0                     2 0   R E S E A R C H               D A L L A S   A L L E N                               3 0                     3 0   S A L E S                     C H I C A G O   W A R D                                 3 0                     3 0   S A L E S                     C H I C A G O   J O N E S                               2 0                     2 0   R E S E A R C H               D A L L A S   M A R T I N                             3 0                     3 0   S A L E S                     C H I C A G O   B L A K E                               3 0                     3 0   S A L E S                     C H I C A G O   C L A R K                               1 0                     1 0   A C C O U N T I N G           N E W   Y O R K   S C O T T                               2 0                     2 0   R E S E A R C H               D A L L A S   K I N G                                 1 0                     1 0   A C C O U N T I N G           N E W   Y O R K   T U R N E R                             3 0                     3 0   S A L E S                     C H I C A G O   A D A M S                               2 0                     2 0   R E S E A R C H               D A L L A S   J A M E S                               3 0                     3 0   S A L E S                     C H I C A G O   F O R D                                 2 0                     2 0   R E S E A R C H               D A L L A S   M I L L E R                             1 0                     1 0   A C C O U N T I N G           N E W   Y O R K                                                                   4 0   O P E R A T I O N S           B O S T O N  Notice, the last row has a NULL value for EMP.ENAME and EMP_DEPTNO. That’s because no employees work in department 40. The solution uses the WHERE clause to keep only rows where EMP_DEPTNO is NULL  thus keeping only rows from DEPT that have no match in EMP .  3.6 Adding Joins to a Query Without Interfering with Other Joins  Problem You have a query that returns the results you want. You need additional information, but when trying to get it, you lose data from the original result set. For example, you want to return all employees, the location of the department in which they work, and the date they received a bonus. For this problem, the EMP_BONUS table contains the following data:  The query you start with looks like this:  s e l e c t   *   f r o m   e m p _ b o n u s                 E M P N O     R E C E I V E D                     T Y P E     - - - - - - - - - -     - - - - - - - - - - -   - - - - - - - - - -                 7 3 6 9     1 4 - M A R - 2 0 0 5                     1                 7 9 0 0     1 4 - M A R - 2 0 0 5                     2                 7 7 8 8     1 4 - M A R - 2 0 0 5                     3 s e l e c t   e . e n a m e ,   d . l o c       f r o m   e m p   e ,   d e p t   d     w h e r e   e . d e p t n o = d . d e p t n o         E N A M E             L O C       - - - - - - - - - -   - - - - - - - - - - - - -       S M I T H             D A L L A S       A L L E N             C H I C A G O       W A R D               C H I C A G O       J O N E S             D A L L A S       M A R T I N           C H I C A G O       B L A K E             C H I C A G O       C L A R K             N E W   Y O R K    You want to add to these results the date a bonus was given to an employee, but joining to the EMP_BONUS table returns fewer rows than you want because not every employee has a bonus:  Your desired result set is the following:  Solution      S C O T T             D A L L A S       K I N G               N E W   Y O R K       T U R N E R           C H I C A G O       A D A M S             D A L L A S       J A M E S             C H I C A G O       F O R D               D A L L A S       M I L L E R           N E W   Y O R K s e l e c t   e . e n a m e ,   d . l o c , e b . r e c e i v e d       f r o m   e m p   e ,   d e p t   d ,   e m p _ b o n u s   e b     w h e r e   e . d e p t n o = d . d e p t n o         a n d   e . e m p n o = e b . e m p n o     E N A M E               L O C                       R E C E I V E D   - - - - - - - - - -     - - - - - - - - - - - - -   - - - - - - - - - - -   S C O T T               D A L L A S                 1 4 - M A R - 2 0 0 5   S M I T H               D A L L A S                 1 4 - M A R - 2 0 0 5   J A M E S               C H I C A G O               1 4 - M A R - 2 0 0 5 E N A M E               L O C                         R E C E I V E D   - - - - - - - - - -     - - - - - - - - - - - - -     - - - - - - - - - - -   A L L E N               C H I C A G O   W A R D                 C H I C A G O   M A R T I N             C H I C A G O   J A M E S               C H I C A G O                 1 4 - M A R - 2 0 0 5   T U R N E R             C H I C A G O   B L A K E               C H I C A G O   S M I T H               D A L L A S                   1 4 - M A R - 2 0 0 5   F O R D                 D A L L A S   A D A M S               D A L L A S   J O N E S               D A L L A S   S C O T T               D A L L A S                   1 4 - M A R - 2 0 0 5   C L A R K               N E W   Y O R K   K I N G                 N E W   Y O R K   M I L L E R             N E W   Y O R K  You can use an outer join to obtain the additional information without losing the data from the original query. First join table EMP to table DEPT to get all employees and the location of the department they work, then outer join to table EMP_ BONUS to return the date of the bonus if there is one. The following is the DB2, MySQL, PostgreSQL, and SQL server syntax:  You can also use a scalar subquery  a subquery placed in the SELECT list  to mimic an outer join:  The scalar subquery solution will work across all platforms.  Discussion An outer join will return all rows from one table and matching rows from another. See the previous recipe for another example of such a join. The reason an outer join works to solve this problem is that it does not result in any rows being eliminated that would otherwise be returned. The query will return all the rows it would return without the outer join. And it also returns the received date, if one exists. Use of a scalar subquery is also a convenient technique for this sort of problem, as it does not require you to modify already correct joins in your main query. Using a scalar subquery is an easy way to tack on extra data to a query without compromising the current result set. When working with  1   s e l e c t   e . e n a m e ,   d . l o c ,   e b . r e c e i v e d   2       f r o m   e m p   e   j o i n   d e p t   d   3           o n     e . d e p t n o = d . d e p t n o     4       l e f t   j o i n   e m p _ b o n u s   e b   5           o n     e . e m p n o = e b . e m p n o     6     o r d e r   b y   2 1   s e l e c t   e . e n a m e ,   d . l o c ,   2                   s e l e c t   e b . r e c e i v e d   f r o m   e m p _ b o n u s   e b   3                     w h e r e   e b . e m p n o = e . e m p n o     a s   r e c e i v e d   4       f r o m   e m p   e ,   d e p t   d   5     w h e r e   e . d e p t n o = d . d e p t n o   6     o r d e r   b y   2  scalar subqueries, you must ensure they return a scalar  single  value. If a subquery in the SELECT list returns more than one row, you will receive an error.  See Also See Recipe 14.10 for a workaround to the problem of not being able to return multiple rows from a SELECT-list subquery.  3.7 Determining Whether Two Tables Have the Same Data  Problem You want to know whether two tables or views have the same data  cardinality and values . Consider the following view:  c r e a t e   v i e w   V   a s   s e l e c t   *   f r o m   e m p   w h e r e   d e p t n o   ! =   1 0     u n i o n   a l l   s e l e c t   *   f r o m   e m p   w h e r e   e n a m e   =   ' W A R D '     s e l e c t   *   f r o m   V     E M P N O   E N A M E               J O B                 M G R     H I R E D A T E             S A L     C O M M   D E P T N O   - - - - -   - - - - - - - - - -     - - - - - - - - -   - - - - -   - - - - - - - - - - -   - - - - -   - - - - -   - - - - - -     7 3 6 9   S M I T H               C L E R K             7 9 0 2   1 7 - D E C - 2 0 0 5       8 0 0                       2 0     7 4 9 9   A L L E N               S A L E S M A N       7 6 9 8   2 0 - F E B - 2 0 0 6     1 6 0 0       3 0 0           3 0     7 5 2 1   W A R D                 S A L E S M A N       7 6 9 8   2 2 - F E B - 2 0 0 6     1 2 5 0       5 0 0           3 0     7 5 6 6   J O N E S               M A N A G E R         7 8 3 9   0 2 - A P R - 2 0 0 6     2 9 7 5                       2 0     7 6 5 4   M A R T I N             S A L E S M A N       7 6 9 8   2 8 - S E P - 2 0 0 6     1 2 5 0     1 4 0 0           3 0     7 6 9 8   B L A K E               M A N A G E R         7 8 3 9   0 1 - M A Y - 2 0 0 6     2 8 5 0                       3 0     7 7 8 8   S C O T T               A N A L Y S T         7 5 6 6   0 9 - D E C - 2 0 0 7     3 0 0 0                       2 0     7 8 4 4   T U R N E R             S A L E S M A N       7 6 9 8   0 8 - S E P - 2 0 0 6     1 5 0 0           0           3 0     7 8 7 6   A D A M S               C L E R K             7 7 8 8   1 2 - J A N - 2 0 0 8     1 1 0 0                       2 0     7 9 0 0   J A M E S               C L E R K             7 6 9 8   0 3 - D E C - 2 0 0 6       9 5 0                       3 0     7 9 0 2   F O R D                 A N A L Y S T         7 5 6 6   0 3 - D E C - 2 0 0 6     3 0 0 0                       2 0     7 5 2 1   W A R D                 S A L E S M A N       7 6 9 8   2 2 - F E B - 2 0 0 6     1 2 5 0       5 0 0           3 0  You want to determine whether this view has exactly the same data as table EMP. The row for employee WARD is duplicated to show that the solution will reveal not only different data but duplicates as well. Based on the rows in table EMP, the difference will be the three rows for employees in department 10 and the two rows for employee WARD. You want to return the following result set:  Solution Functions that perform SET difference MINUS or EXCEPT, depending on your DBMS, make the problem of comparing tables a relatively easy one to solve. If your DBMS does not offer such functions, you can use a correlated subquery.  DB2 and PostgreSQL Use the set operations EXCEPT and UNION ALL to find the difference between view V and table EMP combined with the difference between table EMP and view V:  E M P N O   E N A M E               J O B                   M G R     H I R E D A T E             S A L       C O M M   D E P T N O   C N T   - - - - -   - - - - - - - - - -     - - - - - - - - -     - - - - -   - - - - - - - - - - -   - - - - -     - - - - -   - - - - - -   - - -     7 5 2 1   W A R D                 S A L E S M A N         7 6 9 8   2 2 - F E B - 2 0 0 6     1 2 5 0         5 0 0           3 0       1     7 5 2 1   W A R D                 S A L E S M A N         7 6 9 8   2 2 - F E B - 2 0 0 6     1 2 5 0         5 0 0           3 0       2     7 7 8 2   C L A R K               M A N A G E R           7 8 3 9   0 9 - J U N - 2 0 0 6     2 4 5 0                         1 0       1     7 8 3 9   K I N G                 P R E S I D E N T                 1 7 - N O V - 2 0 0 6     5 0 0 0                         1 0       1     7 9 3 4   M I L L E R             C L E R K               7 7 8 2   2 3 - J A N - 2 0 0 7     1 3 0 0                         1 0       1   1           2       s e l e c t   e m p n o , e n a m e , j o b , m g r , h i r e d a t e , s a l , c o m m , d e p t n o ,     3                     c o u n t   *     a s   c n t     4           f r o m   V     5         g r o u p   b y   e m p n o , e n a m e , j o b , m g r , h i r e d a t e , s a l , c o m m , d e p t n o     6       e x c e p t     7       s e l e c t   e m p n o , e n a m e , j o b , m g r , h i r e d a t e , s a l , c o m m , d e p t n o ,     8                     c o u n t   *     a s   c n t     9           f r o m   e m p   1 0         g r o u p   b y   e m p n o , e n a m e , j o b , m g r , h i r e d a t e , s a l , c o m m , d e p t n o   1 1           1 2         u n i o n   a l l   1 3            Oracle Use the set operations MINUS and UNION ALL to find the difference between view V and table EMP combined with the difference between table EMP and view V:  MySQL and SQL Server Use a correlated subquery and UNION ALL to find the rows in view V and not in table EMP combined with the rows in table EMP and not in view V:  1 4       s e l e c t   e m p n o , e n a m e , j o b , m g r , h i r e d a t e , s a l , c o m m , d e p t n o ,   1 5                     c o u n t   *     a s   c n t   1 6           f r o m   e m p   1 7         g r o u p   b y   e m p n o , e n a m e , j o b , m g r , h i r e d a t e , s a l , c o m m , d e p t n o   1 8       e x c e p t   1 9       s e l e c t   e m p n o , e n a m e , j o b , m g r , h i r e d a t e , s a l , c o m m , d e p t n o ,   2 0                     c o u n t   *     a s   c n t   2 1           f r o m   v   2 2         g r o u p   b y   e m p n o , e n a m e , j o b , m g r , h i r e d a t e , s a l , c o m m , d e p t n o   2 3         1           2       s e l e c t   e m p n o , e n a m e , j o b , m g r , h i r e d a t e , s a l , c o m m , d e p t n o ,     3                     c o u n t   *     a s   c n t     4           f r o m     V     5         g r o u p   b y   e m p n o , e n a m e , j o b , m g r , h i r e d a t e , s a l , c o m m , d e p t n o     6         m i n u s     7       s e l e c t   e m p n o , e n a m e , j o b , m g r , h i r e d a t e , s a l , c o m m , d e p t n o ,     8                     c o u n t   *     a s   c n t     9           f r o m   e m p   1 0         g r o u p   b y   e m p n o , e n a m e , j o b , m g r , h i r e d a t e , s a l , c o m m , d e p t n o   1 1           1 2           u n i o n   a l l   1 3           1 4       s e l e c t   e m p n o , e n a m e , j o b , m g r , h i r e d a t e , s a l , c o m m , d e p t n o ,   1 5                     c o u n t   *     a s   c n t   1 6           f r o m   e m p   1 7         g r o u p   b y   e m p n o , e n a m e , j o b , m g r , h i r e d a t e , s a l , c o m m , d e p t n o   1 8         m i n u s   1 9       s e l e c t   e m p n o , e n a m e , j o b , m g r , h i r e d a t e , s a l , c o m m , d e p t n o ,   2 0                     c o u n t   *     a s   c n t   2 1           f r o m   v   2 2         g r o u p   b y   e m p n o , e n a m e , j o b , m g r , h i r e d a t e , s a l , c o m m , d e p t n o   2 3          1     s e l e c t   *     2         f r o m         3     s e l e c t   e . e m p n o , e . e n a m e , e . j o b , e . m g r , e . h i r e d a t e ,     4                   e . s a l , e . c o m m , e . d e p t n o ,   c o u n t   *     a s   c n t     5         f r o m   e m p   e     6       g r o u p   b y   e m p n o , e n a m e , j o b , m g r , h i r e d a t e ,     7                       s a l , c o m m , d e p t n o     8                       e     9       w h e r e   n o t   e x i s t s       1 0     s e l e c t   n u l l   1 1         f r o m       1 2     s e l e c t   v . e m p n o , v . e n a m e , v . j o b , v . m g r , v . h i r e d a t e ,   1 3                   v . s a l , v . c o m m , v . d e p t n o ,   c o u n t   *     a s   c n t   1 4         f r o m   v   1 5       g r o u p   b y   e m p n o , e n a m e , j o b , m g r , h i r e d a t e ,   1 6                         s a l , c o m m , d e p t n o   1 7                       v   1 8         w h e r e   v . e m p n o           =   e . e m p n o   1 9               a n d   v . e n a m e         =   e . e n a m e   2 0               a n d   v . j o b             =   e . j o b   2 1               a n d   c o a l e s c e   v . m g r , 0     =   c o a l e s c e   e . m g r , 0     2 2               a n d   v . h i r e d a t e   =   e . h i r e d a t e   2 3               a n d   v . s a l             =   e . s a l   2 4               a n d   v . d e p t n o       =   e . d e p t n o   2 5               a n d   v . c n t             =   e . c n t   2 6               a n d   c o a l e s c e   v . c o m m , 0     =   c o a l e s c e   e . c o m m , 0     2 7         2 8           u n i o n   a l l   2 9         s e l e c t   *   3 0             f r o m       3 1         s e l e c t   v . e m p n o , v . e n a m e , v . j o b , v . m g r , v . h i r e d a t e ,   3 2                       v . s a l , v . c o m m , v . d e p t n o ,   c o u n t   *     a s   c n t   3 3             f r o m   v   3 4         g r o u p   b y   e m p n o , e n a m e , j o b , m g r , h i r e d a t e ,   3 5                           s a l , c o m m , d e p t n o   3 6                         v   3 7         w h e r e   n o t   e x i s t s       3 8       s e l e c t   n u l l   3 9           f r o m       4 0       s e l e c t   e . e m p n o , e . e n a m e , e . j o b , e . m g r , e . h i r e d a t e ,   4 1                     e . s a l , e . c o m m , e . d e p t n o ,   c o u n t   *     a s   c n t   4 2           f r o m   e m p   e   4 3         g r o u p   b y   e m p n o , e n a m e , j o b , m g r , h i r e d a t e ,   4 4                           s a l , c o m m , d e p t n o   4 5                         e   4 6         w h e r e   v . e m p n o           =   e . e m p n o   4 7             a n d   v . e n a m e           =   e . e n a m e   4 8             a n d   v . j o b               =   e . j o b    Discussion Despite using different techniques, the concept is the same for all solutions:  1. Find rows in table EMP that do not exist in view V. 2. Combine  UNION ALL  those rows with rows from view V that do  not exist in table EMP.  If the tables in question are equal, then no rows are returned. If the tables are different, the rows causing the difference are returned. As an easy first step when comparing tables, you can compare the cardinalities alone rather than including them with the data comparison. The following query is a simple example of this and will work on all DBMSs:  Because UNION will filter out duplicates, only one row will be returned if the tables’ cardinalities are the same. Because two rows are returned in this example, you know that the tables do not contain identical rowsets.  DB2, Oracle, and PostgreSQL  j j 4 9             a n d   c o a l e s c e   v . m g r , 0     =   c o a l e s c e   e . m g r , 0     5 0             a n d   v . h i r e d a t e     =   e . h i r e d a t e   5 1             a n d   v . s a l               =   e . s a l   5 2             a n d   v . d e p t n o         =   e . d e p t n o   5 3             a n d   v . c n t               =   e . c n t   5 4             a n d   c o a l e s c e   v . c o m m , 0     =   c o a l e s c e   e . c o m m , 0     5 5       s e l e c t   c o u n t   *         f r o m   e m p     u n i o n   s e l e c t   c o u n t   *         f r o m   d e p t     C O U N T   *     - - - - - - - -                 4               1 4  MINUS and EXCEPT work in the same way, so we will use EXCEPT for this discussion. The queries before and after the UNION ALL are similar. So, to understand how the solution works, simply execute the query prior to the UNION ALL by itself. The following result set is produced by executing lines 1–11 in the “Solution” section:  The result set represents a row found in view V that is either not in table EMP, or has a different cardinality than that same row in table EMP. In this case, the duplicate row for employee WARD is found and returned. If you’re still having trouble understanding how the result set is produced, run each query on either side of EXCEPT individually. You’ll notice the only difference between the two result sets is the CNT for employee WARD returned by view V. The portion of the query after the UNION ALL does the opposite of the query preceding UNION ALL. The query returns rows in table EMP not in view V:          s e l e c t   e m p n o , e n a m e , j o b , m g r , h i r e d a t e , s a l , c o m m , d e p t n o ,                     c o u n t   *     a s   c n t           f r o m   V         g r o u p   b y   e m p n o , e n a m e , j o b , m g r , h i r e d a t e , s a l , c o m m , d e p t n o       e x c e p t       s e l e c t   e m p n o , e n a m e , j o b , m g r , h i r e d a t e , s a l , c o m m , d e p t n o ,                     c o u n t   *     a s   c n t           f r o m   e m p       g r o u p   b y   e m p n o , e n a m e , j o b , m g r , h i r e d a t e , s a l , c o m m , d e p t n o           E M P N O   E N A M E             J O B                 M G R     H I R E D A T E             S A L     C O M M   D E P T N O   C N T     - - - - -   - - - - - - - - - -   - - - - - - - - -   - - - - -   - - - - - - - - - - -   - - - - -   - - - - -   - - - - - -   - - -     7 5 2 1     W A R D               S A L E S M A N       7 6 9 8   2 2 - F E B - 2 0 0 6     1 2 5 0       5 0 0           3 0       2         s e l e c t   e m p n o , e n a m e , j o b , m g r , h i r e d a t e , s a l , c o m m , d e p t n o ,                     c o u n t   *     a s   c n t           f r o m   e m p         g r o u p   b y   e m p n o , e n a m e , j o b , m g r , h i r e d a t e , s a l , c o m m , d e p t n o         m i n u s       s e l e c t   e m p n o , e n a m e , j o b , m g r , h i r e d a t e , s a l , c o m m , d e p t n o ,    The results are then combined by UNION ALL to produce the final result set.  MySQL and SQL Server The queries before and after the UNION ALL are similar. To understand how the subquery-based solution works, simply execute the query prior to the UNION ALL by itself. The following query is from lines 1–27 in the solution:                    c o u n t   *     a s   c n t           f r o m   v         g r o u p   b y   e m p n o , e n a m e , j o b , m g r , h i r e d a t e , s a l , c o m m , d e p t n o         E M P N O   E N A M E             J O B                   M G R   H I R E D A T E             S A L     C O M M   D E P T N O   C N T   - - - - -   - - - - - - - - - -   - - - - - - - - -   - - - - -   - - - - - - - - - - -   - - - - -   - - - - -   - - - - - -   - - -   7 5 2 1     W A R D               S A L E S M A N       7 6 9 8   2 2 - F E B - 2 0 0 6     1 2 5 0       5 0 0           3 0       1   7 7 8 2     C L A R K             M A N A G E R         7 8 3 9   0 9 - J U N - 2 0 0 6     2 4 5 0                       1 0       1   7 8 3 9     K I N G               P R E S I D E N T               1 7 - N O V - 2 0 0 6     5 0 0 0                       1 0       1   7 9 3 4     M I L L E R           C L E R K             7 7 8 2   2 3 - J A N - 2 0 0 7     1 3 0 0                       1 0       1 s e l e c t   *         f r o m         s e l e c t   e . e m p n o , e . e n a m e , e . j o b , e . m g r , e . h i r e d a t e ,                   e . s a l , e . c o m m , e . d e p t n o ,   c o u n t   *     a s   c n t         f r o m   e m p   e       g r o u p   b y   e m p n o , e n a m e , j o b , m g r , h i r e d a t e ,                         s a l , c o m m , d e p t n o                       e       w h e r e   n o t   e x i s t s       s e l e c t   n u l l       f r o m       s e l e c t   v . e m p n o , v . e n a m e , v . j o b , v . m g r , v . h i r e d a t e ,                 v . s a l , v . c o m m , v . d e p t n o ,   c o u n t   *     a s   c n t       f r o m   v     g r o u p   b y   e m p n o , e n a m e , j o b , m g r , h i r e d a t e ,                       s a l , c o m m , d e p t n o                     v       w h e r e   v . e m p n o         =   e . e m p n o           a n d   v . e n a m e         =   e . e n a m e           a n d   v . j o b             =   e . j o b           a n d   v . m g r             =   e . m g r           a n d   v . h i r e d a t e   =   e . h i r e d a t e           a n d   v . s a l             =   e . s a l    Notice that the comparison is not between table EMP and view V, but rather between inline view E and inline view V. The cardinality for each row is found and returned as an attribute for that row. You are comparing each row and its occurrence count. If you are having trouble understanding how the comparison works, run the subqueries independently. The next step is to find all rows  including CNT  in inline view E that do not exist in inline view V. The comparison uses a correlated subquery and NOT EXISTS. The joins will determine which rows are the same, and the result will be all rows from inline view E that are not the rows returned by the join. The query after the UNION ALL does the opposite; it finds all rows in inline view V that do not exist in inline view E:          a n d   v . d e p t n o       =   e . d e p t n o           a n d   v . c n t             =   e . c n t           a n d   c o a l e s c e   v . c o m m , 0     =   c o a l e s c e   e . c o m m , 0               E M P N O   E N A M E             J O B                   M G R   H I R E D A T E             S A L     C O M M   D E P T N O   C N T     - - - - -   - - - - - - - - - -   - - - - - - - - -   - - - - -   - - - - - - - - - - -   - - - - -   - - - - -   - - - - - -   - - -       7 5 2 1   W A R D               S A L E S M A N       7 6 9 8   2 2 - F E B - 2 0 0 6     1 2 5 0       5 0 0           3 0       1       7 7 8 2   C L A R K             M A N A G E R         7 8 3 9   0 9 - J U N - 2 0 0 6     2 4 5 0                       1 0       1       7 8 3 9   K I N G               P R E S I D E N T               1 7 - N O V - 2 0 0 6     5 0 0 0                       1 0       1       7 9 3 4   M I L L E R           C L E R K             7 7 8 2   2 3 - J A N - 2 0 0 7     1 3 0 0                       1 0       1 s e l e c t   *       f r o m       s e l e c t   v . e m p n o , v . e n a m e , v . j o b , v . m g r , v . h i r e d a t e ,                 v . s a l , v . c o m m , v . d e p t n o ,   c o u n t   *     a s   c n t       f r o m   v     g r o u p   b y   e m p n o , e n a m e , j o b , m g r , h i r e d a t e ,                       s a l , c o m m , d e p t n o                     v       w h e r e   n o t   e x i s t s       s e l e c t   n u l l       f r o m         s e l e c t   e . e m p n o , e . e n a m e , e . j o b , e . m g r , e . h i r e d a t e ,                   e . s a l , e . c o m m , e . d e p t n o ,   c o u n t   *     a s   c n t         f r o m   e m p   e       g r o u p   b y   e m p n o , e n a m e , j o b , m g r , h i r e d a t e ,                         s a l , c o m m , d e p t n o                     e       w h e r e   v . e m p n o         =   e . e m p n o    The results are then combined by UNION ALL to produce the final result set.  TIP  Ales Spetic and Jonathan Gennick give an alternate solution in their book Transact-SQL Cookbook  O’Reilly . See the section “Comparing Two Sets for Equality” in Chapter 2 of their book.  3.8 Identifying and Avoiding Cartesian Products  Problem You want to return the name of each employee in department 10 along with the location of the department. The following query is returning incorrect data:          a n d   v . e n a m e         =   e . e n a m e           a n d   v . j o b             =   e . j o b           a n d   v . m g r             =   e . m g r           a n d   v . h i r e d a t e   =   e . h i r e d a t e           a n d   v . s a l             =   e . s a l           a n d   v . d e p t n o       =   e . d e p t n o           a n d   v . c n t             =   e . c n t           a n d   c o a l e s c e   v . c o m m , 0     =   c o a l e s c e   e . c o m m , 0           E M P N O   E N A M E             J O B                   M G R   H I R E D A T E             S A L     C O M M   D E P T N O   C N T   - - - - -   - - - - - - - - - -   - - - - - - - - -   - - - - -   - - - - - - - - - - -   - - - - -   - - - - -   - - - - - -   - - -     7 5 2 1   W A R D               S A L E S M A N       7 6 9 8   2 2 - F E B - 2 0 0 6     1 2 5 0       5 0 0           3 0       2 s e l e c t   e . e n a m e ,   d . l o c       f r o m   e m p   e ,   d e p t   d     w h e r e   e . d e p t n o   =   1 0     E N A M E               L O C   - - - - - - - - - -     - - - - - - - - - - - - -   C L A R K               N E W   Y O R K    The correct result set is the following:  Solution Use a join between the tables in the FROM clause to return the correct result set:  Discussion Let’s look at the data in the DEPT table:  C L A R K               D A L L A S   C L A R K               C H I C A G O   C L A R K               B O S T O N   K I N G                 N E W   Y O R K   K I N G                 D A L L A S   K I N G                 C H I C A G O   K I N G                 B O S T O N   M I L L E R             N E W   Y O R K   M I L L E R             D A L L A S   M I L L E R             C H I C A G O   M I L L E R             B O S T O N E N A M E               L O C   - - - - - - - - - -     - - - - - - - - -   C L A R K               N E W   Y O R K   K I N G                 N E W   Y O R K   M I L L E R             N E W   Y O R K 1   s e l e c t   e . e n a m e ,   d . l o c   2       f r o m   e m p   e ,   d e p t   d   3     w h e r e   e . d e p t n o   =   1 0   4         a n d   d . d e p t n o   =   e . d e p t n o s e l e c t   *   f r o m   d e p t             D E P T N O   D N A M E                     L O C   - - - - - - - - - -   - - - - - - - - - - - - - -   - - - - - - - - - - - - -                   1 0   A C C O U N T I N G           N E W   Y O R K                   2 0   R E S E A R C H               D A L L A S                   3 0   S A L E S                     C H I C A G O                   4 0   O P E R A T I O N S           B O S T O N  You can see that department 10 is in New York, and thus you can know that returning employees with any location other than New York is incorrect. The number of rows returned by the incorrect query is the product of the cardinalities of the two tables in the FROM clause. In the original query, the filter on EMP for department 10 will result in three rows. Because there is no filter for DEPT, all four rows from DEPT are returned. Three multiplied by four is twelve, so the incorrect query returns twelve rows. Generally, to avoid a Cartesian product, you would apply the n–1 rule where n represents the number of tables in the FROM clause and n–1 represents the minimum number of joins necessary to avoid a Cartesian product. Depending on what the keys and join columns in your tables are, you may very well need more than n–1 joins, but n–1 is a good place to start when writing queries.  TIP  When used properly, Cartesian products can be useful. Common uses of Cartesian products include transposing or pivoting  and unpivoting  a result set, generating a sequence of values, and mimicking a loop  although the last two may also be accomplished using a recursive CTE .  3.9 Performing Joins When Using Aggregates  Problem You want to perform an aggregation, but your query involves multiple tables. You want to ensure that joins do not disrupt the aggregation. For example, you want to find the sum of the salaries for employees in department 10 along with the sum of their bonuses. Some employees have more than one bonus, and the join between table EMP and table EMP_BONUS is causing incorrect values to be returned by the aggregate function SUM. For this problem, table EMP_BONUS contains the following data:   Now, consider the following query that returns the salary and bonus for all employees in department 10. Table BONUS.TYPE determines the amount of the bonus. A type 1 bonus is 10% of an employee’s salary, type 2 is 20%, and type 3 is 30%.  So far, so good. However, things go awry when you attempt a join to the EMP_BONUS table to sum the bonus amounts:  s e l e c t   *   f r o m   e m p _ b o n u s     E M P N O   R E C E I V E D                     T Y P E   - - - - -   - - - - - - - - - - -   - - - - - - - - - -     7 9 3 4   1 7 - M A R - 2 0 0 5                     1     7 9 3 4   1 5 - F E B - 2 0 0 5                     2     7 8 3 9   1 5 - F E B - 2 0 0 5                     3     7 7 8 2   1 5 - F E B - 2 0 0 5                     1 s e l e c t   e . e m p n o ,                 e . e n a m e ,                 e . s a l ,                 e . d e p t n o ,                 e . s a l * c a s e   w h e n   e b . t y p e   =   1   t h e n   . 1                                       w h e n   e b . t y p e   =   2   t h e n   . 2                                       e l s e   . 3                             e n d   a s   b o n u s     f r o m   e m p   e ,   e m p _ b o n u s   e b   w h e r e   e . e m p n o     =   e b . e m p n o       a n d   e . d e p t n o   =   1 0           E M P N O   E N A M E                           S A L           D E P T N O           B O N U S   - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - -         7 9 3 4   M I L L E R                       1 3 0 0                   1 0               1 3 0         7 9 3 4   M I L L E R                       1 3 0 0                   1 0               2 6 0         7 8 3 9   K I N G                           5 0 0 0                   1 0             1 5 0 0         7 7 8 2   C L A R K                         2 4 5 0                   1 0               2 4 5 s e l e c t   d e p t n o ,                 s u m   s a l     a s   t o t a l _ s a l ,                 s u m   b o n u s     a s   t o t a l _ b o n u s       f r o m       s e l e c t   e . e m p n o ,                 e . e n a m e ,                 e . s a l ,    While the TOTAL_BONUS is correct, the TOTAL_SAL is incorrect. The sum of all salaries in department 10 is 8750, as the following query shows:  Why is TOTAL_SAL incorrect? The reason is the duplicate rows in the SAL column created by the join. Consider the following query, which joins tables EMP and EMP_BONUS:                e . d e p t n o ,                 e . s a l * c a s e   w h e n   e b . t y p e   =   1   t h e n   . 1                                       w h e n   e b . t y p e   =   2   t h e n   . 2                                       e l s e   . 3                             e n d   a s   b o n u s       f r o m   e m p   e ,   e m p _ b o n u s   e b     w h e r e   e . e m p n o     =   e b . e m p n o         a n d   e . d e p t n o   =   1 0                     x     g r o u p   b y   d e p t n o       D E P T N O       T O T A L _ S A L     T O T A L _ B O N U S   - - - - - -   - - - - - - - - - - -     - - - - - - - - - - -           1 0               1 0 0 5 0                   2 1 3 5 s e l e c t   s u m   s a l     f r o m   e m p   w h e r e   d e p t n o = 1 0         S U M   S A L     - - - - - - - - - -               8 7 5 0 s e l e c t   e . e n a m e ,                 e . s a l       f r o m   e m p   e ,   e m p _ b o n u s   e b     w h e r e   e . e m p n o     =   e b . e m p n o         a n d   e . d e p t n o   =   1 0     E N A M E                           S A L   - - - - - - - - - -   - - - - - - - - - -   C L A R K                         2 4 5 0   K I N G                           5 0 0 0   M I L L E R                       1 3 0 0   M I L L E R                       1 3 0 0  Now it is easy to see why the value for TOTAL_SAL is incorrect: MILLER’s salary is counted twice. The final result set that you are really after is:  Solution You have to be careful when computing aggregates across joins. Typically when duplicates are returned due to a join, you can avoid miscalculations by aggregate functions in two ways: you can simply use the keyword DISTINCT in the call to the aggregate function, so only unique instances of each value are used in the computation; or you can perform the aggregation first  in an inline view  prior to joining, thus avoiding the incorrect computation by the aggregate function because the aggregate will already be computed before you even join, thus avoiding the problem altogether. The solutions that follow use DISTINCT. The “Discussion” section will discuss the technique of using an inline view to perform the aggregation prior to joining.  MySQL and PostgreSQL Perform a sum of only the DISTINCT salaries:  D E P T N O   T O T A L _ S A L   T O T A L _ B O N U S   - - - - - -   - - - - - - - - -   - - - - - - - - - - -           1 0             8 7 5 0                 2 1 3 5   1   s e l e c t   d e p t n o ,     2                 s u m   d i s t i n c t   s a l     a s   t o t a l _ s a l ,     3                 s u m   b o n u s     a s   t o t a l _ b o n u s     4       f r o m         5   s e l e c t   e . e m p n o ,     6                 e . e n a m e ,     7                 e . s a l ,     8                 e . d e p t n o ,     9                 e . s a l * c a s e   w h e n   e b . t y p e   =   1   t h e n   . 1   1 0                                       w h e n   e b . t y p e   =   2   t h e n   . 2   1 1                                       e l s e   . 3   1 2                               e n d   a s   b o n u s   1 3       f r o m   e m p   e ,   e m p _ b o n u s   e b   1 4       w h e r e   e . e m p n o   =   e b . e m p n o    DB2, Oracle, and SQL Server These platforms support the preceding solution, but they also support an alternative solution using the window function SUM OVER:  Discussion  MySQL and PostgreSQL The second query in the “Problem” section of this recipe joins table EMP and table EMP_BONUS and returns two rows for employee MILLER, which is what causes the error on the sum of EMP.SAL  the salary is added twice . The solution is to simply sum the distinct EMP.SAL values that are returned by the query. The following query is an alternative solution— necessary if there could be duplicate values in the column you are summing. The sum of all salaries in department 10 is computed first, and that row is then joined to table EMP, which is then joined to table EMP_BONUS. The following query works for all DBMSs:  1 5         a n d   e . d e p t n o   =   1 0   1 6                     x   1 7     g r o u p   b y   d e p t n o   1   s e l e c t   d i s t i n c t   d e p t n o , t o t a l _ s a l , t o t a l _ b o n u s     2       f r o m         3   s e l e c t   e . e m p n o ,     4                 e . e n a m e ,     5                 s u m   d i s t i n c t   e . s a l     o v e r     6                   p a r t i t i o n   b y   e . d e p t n o     a s   t o t a l _ s a l ,     7                   e . d e p t n o ,     8                   s u m   e . s a l * c a s e   w h e n   e b . t y p e   =   1   t h e n   . 1     9                                                 w h e n   e b . t y p e   =   2   t h e n   . 2   1 0                                                 e l s e   . 3   e n d     o v e r   1 1                     p a r t i t i o n   b y   d e p t n o     a s   t o t a l _ b o n u s   1 2         f r o m   e m p   e ,   e m p _ b o n u s   e b   1 3       w h e r e   e . e m p n o   =   e b . e m p n o   1 4           a n d   e . d e p t n o   =   1 0   1 5                       x  DB2, Oracle, and SQL Server This alternative solution takes advantage of the window function SUM OVER. The following query is taken from lines 3–14 in “Solution” and returns the following result set:  s e l e c t   d . d e p t n o ,                 d . t o t a l _ s a l ,                 s u m   e . s a l * c a s e   w h e n   e b . t y p e   =   1   t h e n   . 1                                               w h e n   e b . t y p e   =   2   t h e n   . 2                                               e l s e   . 3   e n d     a s   t o t a l _ b o n u s       f r o m   e m p   e ,                 e m p _ b o n u s   e b ,                     s e l e c t   d e p t n o ,   s u m   s a l     a s   t o t a l _ s a l       f r o m   e m p     w h e r e   d e p t n o   =   1 0     g r o u p   b y   d e p t n o                       d     w h e r e   e . d e p t n o   =   d . d e p t n o         a n d   e . e m p n o   =   e b . e m p n o     g r o u p   b y   d . d e p t n o , d . t o t a l _ s a l             D E P T N O     T O T A L _ S A L     T O T A L _ B O N U S   - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - - - -                 1 0               8 7 5 0                   2 1 3 5 s e l e c t   e . e m p n o ,                       e . e n a m e ,                       s u m   d i s t i n c t   e . s a l     o v e r                         p a r t i t i o n   b y   e . d e p t n o     a s   t o t a l _ s a l ,                       e . d e p t n o ,                       s u m   e . s a l * c a s e   w h e n   e b . t y p e   =   1   t h e n   . 1                                                     w h e n   e b . t y p e   =   2   t h e n   . 2                                                   e l s e   . 3   e n d     o v e r                       p a r t i t i o n   b y   d e p t n o     a s   t o t a l _ b o n u s           f r o m   e m p   e ,   e m p _ b o n u s   e b         w h e r e   e . e m p n o     =   e b . e m p n o             a n d   e . d e p t n o   =   1 0     E M P N O   E N A M E                 T O T A L _ S A L       D E P T N O     T O T A L _ B O N U S   - - - - -   - - - - - - - - - -     - - - - - - - - - -       - - - - - -     - - - - - - - - - - -     7 9 3 4   M I L L E R                         8 7 5 0               1 0                   2 1 3 5     7 9 3 4   M I L L E R                         8 7 5 0               1 0                   2 1 3 5    The windowing function, SUM OVER, is called twice, first to compute the sum of the distinct salaries for the defined partition or group. In this case, the partition is DEPTNO 10, and the sum of the distinct salaries for DEPTNO 10 is 8750. The next call to SUM OVER computes the sum of the bonuses for the same defined partition. The final result set is produced by taking the distinct values for TOTAL_SAL, DEPTNO, and TOTAL_BONUS.  3.10 Performing Outer Joins When Using Aggregates  Problem Begin with the same problem as in Recipe 3.9, but modify table EMP_BONUS such that the difference in this case is not all employees in department 10 have been given bonuses. Consider the EMP_BONUS table and a query to  ostensibly  find both the sum of all salaries for department 10 and the sum of all bonuses for all employees in department 10:    7 7 8 2   C L A R K                           8 7 5 0               1 0                   2 1 3 5     7 8 3 9   K I N G                             8 7 5 0               1 0                   2 1 3 5 s e l e c t   *   f r o m   e m p _ b o n u s               E M P N O   R E C E I V E D                     T Y P E   - - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - - -               7 9 3 4   1 7 - M A R - 2 0 0 5                     1               7 9 3 4   1 5 - F E B - 2 0 0 5                     2       s e l e c t   d e p t n o ,                 s u m   s a l     a s   t o t a l _ s a l ,                 s u m   b o n u s     a s   t o t a l _ b o n u s       f r o m       s e l e c t   e . e m p n o ,                 e . e n a m e ,                 e . s a l ,                 e . d e p t n o ,                 e . s a l * c a s e   w h e n   e b . t y p e   =   1   t h e n   . 1    The result for TOTAL_BONUS is correct, but the value returned for TOTAL_SAL does not represent the sum of all salaries in department 10. The following query shows why the TOTAL_SAL is incorrect:  Rather than sum all salaries in department 10, only the salary for MILLER is summed, and it is erroneously summed twice. Ultimately, you would like to return the following result set:  Solution                                      w h e n   e b . t y p e   =   2   t h e n   . 2                                       e l s e   . 3   e n d   a s   b o n u s       f r o m   e m p   e ,   e m p _ b o n u s   e b     w h e r e   e . e m p n o     =   e b . e m p n o         a n d   e . d e p t n o   =   1 0                       g r o u p   b y   d e p t n o       D E P T N O     T O T A L _ S A L   T O T A L _ B O N U S     - - - - - -   - - - - - - - - - -   - - - - - - - - - - -             1 0               2 6 0 0                   3 9 0 s e l e c t   e . e m p n o ,                 e . e n a m e ,                 e . s a l ,                 e . d e p t n o ,                 e . s a l * c a s e   w h e n   e b . t y p e   =   1   t h e n   . 1                                       w h e n   e b . t y p e   =   2   t h e n   . 2                             e l s e   . 3   e n d   a s   b o n u s       f r o m   e m p   e ,   e m p _ b o n u s   e b     w h e r e   e . e m p n o   =   e b . e m p n o         a n d   e . d e p t n o   =   1 0             E M P N O   E N A M E                     S A L           D E P T N O             B O N U S   - - - - - - - - -   - - - - - - - - -     - - - - - - -   - - - - - - - - - -   - - - - - - - - - -             7 9 3 4   M I L L E R                 1 3 0 0                   1 0                 1 3 0             7 9 3 4   M I L L E R                 1 3 0 0                   1 0                 2 6 0 D E P T N O   T O T A L _ S A L   T O T A L _ B O N U S   - - - - - -   - - - - - - - - -   - - - - - - - - - - -           1 0             8 7 5 0                   3 9 0  The solution is similar to that of Recipe 3.9, but here you outer join to EMP_BONUS to ensure all employees from department 10 are included.  DB2, MySQL, PostgreSQL, and SQL Server Outer join to EMP_BONUS, then perform the sum on only distinct salaries from department 10:  You can also use the window function SUM OVER:    1   s e l e c t   d e p t n o ,     2                 s u m   d i s t i n c t   s a l     a s   t o t a l _ s a l ,     3                 s u m   b o n u s     a s   t o t a l _ b o n u s     4       f r o m         5   s e l e c t   e . e m p n o ,     6                 e . e n a m e ,     7                 e . s a l ,     8                 e . d e p t n o ,     9                 e . s a l * c a s e   w h e n   e b . t y p e   i s   n u l l   t h e n   0   1 0                                       w h e n   e b . t y p e   =   1   t h e n   . 1   1 1                                       w h e n   e b . t y p e   =   2   t h e n   . 2   1 2                                       e l s e   . 3   e n d   a s   b o n u s   1 3       f r o m   e m p   e   l e f t   o u t e r   j o i n   e m p _ b o n u s   e b   1 4           o n     e . e m p n o   =   e b . e m p n o     1 5     w h e r e   e . d e p t n o   =   1 0   1 6                     1 7     g r o u p   b y   d e p t n o   1   s e l e c t   d i s t i n c t   d e p t n o , t o t a l _ s a l , t o t a l _ b o n u s     2       f r o m         3   s e l e c t   e . e m p n o ,     4                 e . e n a m e ,     5                 s u m   d i s t i n c t   e . s a l     o v e r     6                   p a r t i t i o n   b y   e . d e p t n o     a s   t o t a l _ s a l ,     7                 e . d e p t n o ,     8                 s u m   e . s a l * c a s e   w h e n   e b . t y p e   i s   n u l l   t h e n   0     9                                               w h e n   e b . t y p e   =   1   t h e n   . 1   1 0                                               w h e n   e b . t y p e   =   2   t h e n   . 2   1 1                                               e l s e   . 3   1 2                                     e n d     o v e r   1 3                   p a r t i t i o n   b y   d e p t n o     a s   t o t a l _ b o n u s   1 4       f r o m   e m p   e   l e f t   o u t e r   j o i n   e m p _ b o n u s   e b   1 5           o n     e . e m p n o   =   e b . e m p n o     1 6     w h e r e   e . d e p t n o   =   1 0   1 7                     x  Discussion The second query in the “Problem” section of this recipe joins table EMP and table EMP_BONUS and returns only rows for employee MILLER, which is what causes the error on the sum of EMP.SAL  the other employees in DEPTNO 10 do not have bonuses, and their salaries are not included in the sum . The solution is to outer join table EMP to table EMP_BONUS so even employees without a bonus will be included in the result. If an employee does not have a bonus, NULL will be returned for EMP_BONUS.TYPE. It is important to keep this in mind as the CASE statement has been modified and is slightly different from Recipe 3.9. If EMP_BONUS.TYPE is NULL, the CASE expression returns zero, which has no effect on the sum. The following query is an alternative solution. The sum of all salaries in department 10 is computed first, then joined to table EMP, which is then joined to table EMP_BONUS  thus avoiding the outer join . The following query works for all DBMSs:  s e l e c t   d . d e p t n o ,                 d . t o t a l _ s a l ,                 s u m   e . s a l * c a s e   w h e n   e b . t y p e   =   1   t h e n   . 1                                               w h e n   e b . t y p e   =   2   t h e n   . 2                                               e l s e   . 3   e n d     a s   t o t a l _ b o n u s       f r o m   e m p   e ,                 e m p _ b o n u s   e b ,                   s e l e c t   d e p t n o ,   s u m   s a l     a s   t o t a l _ s a l       f r o m   e m p     w h e r e   d e p t n o   =   1 0     g r o u p   b y   d e p t n o                     d     w h e r e   e . d e p t n o   =   d . d e p t n o         a n d   e . e m p n o   =   e b . e m p n o     g r o u p   b y   d . d e p t n o , d . t o t a l _ s a l             D E P T N O     T O T A L _ S A L   T O T A L _ B O N U S   - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - - -                 1 0               8 7 5 0                   3 9 0  3.11 Returning Missing Data from Multiple Tables  Problem You want to return missing data from multiple tables simultaneously. Returning rows from table DEPT that do not exist in table EMP  any departments that have no employees  requires an outer join. Consider the following query, which returns all DEPTNOs and DNAMEs from DEPT along with the names of all the employees in each department  if there is an employee in a particular department :  The last row, the OPERATIONS department, is returned despite that department not having any employees, because table EMP was outer joined to table DEPT. Now, suppose there was an employee without a department. How would you return the previous result set along with a row for the employee having no department? In other words, you want to outer join to  s e l e c t   d . d e p t n o , d . d n a m e , e . e n a m e       f r o m   d e p t   d   l e f t   o u t e r   j o i n   e m p   e           o n     d . d e p t n o = e . d e p t n o             D E P T N O   D N A M E                     E N A M E   - - - - - - - - -   - - - - - - - - - - - - - -   - - - - - - - - - -                 2 0   R E S E A R C H               S M I T H                 3 0   S A L E S                     A L L E N                 3 0   S A L E S                     W A R D                 2 0   R E S E A R C H               J O N E S                 3 0   S A L E S                     M A R T I N                 3 0   S A L E S                     B L A K E                 1 0   A C C O U N T I N G           C L A R K                 2 0   R E S E A R C H               S C O T T                 1 0   A C C O U N T I N G           K I N G                 3 0   S A L E S                     T U R N E R                 2 0   R E S E A R C H               A D A M S                 3 0   S A L E S                     J A M E S                 2 0   R E S E A R C H               F O R D                 1 0   A C C O U N T I N G           M I L L E R                 4 0   O P E R A T I O N S  both table EMP and table DEPT, and in the same query. After creating the new employee, a first attempt may look like this:  This outer join manages to return the new employee but lost the OPERATIONS department from the original result set. The final result set should return a row for YODA as well as OPERATIONS, such as the following:  i n s e r t   i n t o   e m p     e m p n o , e n a m e , j o b , m g r , h i r e d a t e , s a l , c o m m , d e p t n o     s e l e c t   1 1 1 1 , ' Y O D A ' , ' J E D I ' , n u l l , h i r e d a t e , s a l , c o m m , n u l l       f r o m   e m p     w h e r e   e n a m e   =   ' K I N G '     s e l e c t   d . d e p t n o , d . d n a m e , e . e n a m e       f r o m   d e p t   d   r i g h t   o u t e r   j o i n   e m p   e           o n     d . d e p t n o = e . d e p t n o               D E P T N O   D N A M E                 E N A M E   - - - - - - - - - -   - - - - - - - - - - - -   - - - - - - - - - -                   1 0   A C C O U N T I N G       M I L L E R                   1 0   A C C O U N T I N G       K I N G                   1 0   A C C O U N T I N G       C L A R K                   2 0   R E S E A R C H           F O R D                   2 0   R E S E A R C H           A D A M S                   2 0   R E S E A R C H           S C O T T                   2 0   R E S E A R C H           J O N E S                   2 0   R E S E A R C H           S M I T H                   3 0   S A L E S                 J A M E S                   3 0   S A L E S                 T U R N E R                   3 0   S A L E S                 B L A K E                   3 0   S A L E S                 M A R T I N                   3 0   S A L E S                 W A R D                   3 0   S A L E S                 A L L E N                                                   Y O D A         D E P T N O   D N A M E                 E N A M E   - - - - - - - - - -   - - - - - - - - - - - -   - - - - - - - -                   1 0   A C C O U N T I N G       C L A R K                   1 0   A C C O U N T I N G       K I N G                   1 0   A C C O U N T I N G       M I L L E R                   2 0   R E S E A R C H           A D A M S                   2 0   R E S E A R C H           F O R D                   2 0   R E S E A R C H           J O N E S                   2 0   R E S E A R C H           S C O T T    Solution Use a full outer join to return missing data from both tables based on a common value.  DB2, MySQL, PostgreSQL, and SQL Server Use the explicit FULL OUTER JOIN command to return missing rows from both tables along with matching rows:  Alternatively, since MySQL does not yet have a FULL OUTER JOIN, UNION the results of the two different outer joins:  Oracle Oracle users can still use either of the preceding solutions. Alternatively, you can use Oracle’s proprietary outer join syntax:                  2 0   R E S E A R C H           S M I T H                   3 0   S A L E S                 A L L E N                   3 0   S A L E S                 B L A K E                   3 0   S A L E S                 J A M E S                   3 0   S A L E S                 M A R T I N                   3 0   S A L E S                 T U R N E R                   3 0   S A L E S                 W A R D                   4 0   O P E R A T I O N S                                                   Y O D A 1   s e l e c t   d . d e p t n o , d . d n a m e , e . e n a m e   2       f r o m   d e p t   d   f u l l   o u t e r   j o i n   e m p   e   3           o n     d . d e p t n o = e . d e p t n o   1   s e l e c t   d . d e p t n o , d . d n a m e , e . e n a m e   2       f r o m   d e p t   d   r i g h t   o u t e r   j o i n   e m p   e   3           o n     d . d e p t n o = e . d e p t n o     4     u n i o n   5   s e l e c t   d . d e p t n o , d . d n a m e , e . e n a m e   6       f r o m   d e p t   d   l e f t   o u t e r   j o i n   e m p   e   7           o n     d . d e p t n o = e . d e p t n o   1   s e l e c t   d . d e p t n o , d . d n a m e , e . e n a m e   2       f r o m   d e p t   d ,   e m p   e    Discussion The full outer join is simply the combination of outer joins on both tables. To see how a full outer join works “under the covers,” simply run each outer join, then union the results. The following query returns rows from table DEPT and any matching rows from table EMP  if any :  This next query returns rows from table EMP and any matching rows from table DEPT  if any :  3     w h e r e   d . d e p t n o   =   e . d e p t n o   +     4     u n i o n   5   s e l e c t   d . d e p t n o , d . d n a m e , e . e n a m e   6       f r o m   d e p t   d ,   e m p   e   7     w h e r e   d . d e p t n o   +     =   e . d e p t n o s e l e c t   d . d e p t n o , d . d n a m e , e . e n a m e       f r o m   d e p t   d   l e f t   o u t e r   j o i n   e m p   e           o n     d . d e p t n o   =   e . d e p t n o           D E P T N O   D N A M E                     E N A M E       - - - - - -   - - - - - - - - - - - - - -   - - - - - - - - - -               2 0   R E S E A R C H               S M I T H               3 0   S A L E S                     A L L E N               3 0   S A L E S                     W A R D               2 0   R E S E A R C H               J O N E S               3 0   S A L E S                     M A R T I N               3 0   S A L E S                     B L A K E               1 0   A C C O U N T I N G           C L A R K               2 0   R E S E A R C H               S C O T T               1 0   A C C O U N T I N G           K I N G               3 0   S A L E S                     T U R N E R               2 0   R E S E A R C H               A D A M S               3 0   S A L E S                     J A M E S               2 0   R E S E A R C H               F O R D               1 0   A C C O U N T I N G           M I L L E R               4 0   O P E R A T I O N S s e l e c t   d . d e p t n o , d . d n a m e , e . e n a m e       f r o m   d e p t   d   r i g h t   o u t e r   j o i n   e m p   e           o n     d . d e p t n o   =   e . d e p t n o         D E P T N O   D N A M E                     E N A M E    The results from these two queries are unioned to provide the final result set.  3.12 Using NULLs in Operations and Comparisons  Problem NULL is never equal to or not equal to any value, not even itself, but you want to evaluate values returned by a nullable column like you would evaluate real values. For example, you want to find all employees in EMP whose commission  COMM  is less than the commission of employee WARD. Employees with a NULL commission should be included as well.  Solution Use a function such as COALESCE to transform the NULL value into a real value that can be used in standard evaluation:    - - - - - -   - - - - - - - - - - - - - -   - - - - - - - - - -             1 0   A C C O U N T I N G           M I L L E R             1 0   A C C O U N T I N G           K I N G             1 0   A C C O U N T I N G           C L A R K             2 0   R E S E A R C H               F O R D             2 0   R E S E A R C H               A D A M S             2 0   R E S E A R C H               S C O T T             2 0   R E S E A R C H               J O N E S             2 0   R E S E A R C H               S M I T H             3 0   S A L E S                     J A M E S             3 0   S A L E S                     T U R N E R             3 0   S A L E S                     B L A K E             3 0   S A L E S                     M A R T I N             3 0   S A L E S                     W A R D             3 0   S A L E S                     A L L E N                                                 Y O D A 1   s e l e c t   e n a m e , c o m m   2       f r o m   e m p   3     w h e r e   c o a l e s c e   c o m m , 0     <       s e l e c t   c o m m    Discussion The COALESCE function will return the first non-NULL value from the list of values passed to it. When a NULL value is encountered, it is replaced by zero, which is then compared with WARD’s commission. This can be seen by putting the COALESCE function in the SELECT list:  3.13 Summing Up Joins are a crucial aspect of querying databases—it will be the norm that you need to join two or more tables together to find what you are looking for. Mastering the different combinations and categories of joins that are covered in this chapter will set you up for success.  4                                                                     f r o m   e m p   5                                                                   w h e r e   e n a m e   =   ' W A R D '     s e l e c t   e n a m e , c o m m , c o a l e s c e   c o m m , 0         f r o m   e m p     w h e r e   c o a l e s c e   c o m m , 0     <       s e l e c t   c o m m                                                                     f r o m   e m p                                                                   w h e r e   e n a m e   =   ' W A R D '           E N A M E                         C O M M   C O A L E S C E   C O M M , 0       - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - - - - - - - -     S M I T H                                                                 0     A L L E N                           3 0 0                             3 0 0     J O N E S                                                                 0     B L A K E                                                                 0     C L A R K                                                                 0     S C O T T                                                                 0     K I N G                                                                   0     T U R N E R                             0                                 0     A D A M S                                                                 0     J A M E S                                                                 0     F O R D                                                                   0     M I L L E R                                                               0  Chapter 4. Inserting, Updating, and Deleting  The past few chapters have focused on basic query techniques, all centered around the task of getting data out of a database. This chapter turns the tables and focuses on the following three topic areas:  Inserting new records into your database Updating existing records Deleting records that you no longer want  For ease in finding them when you need them, recipes in this chapter have been grouped by topic: all the insertion recipes come first, followed by the update recipes, and finally recipes for deleting data. Inserting is usually a straightforward task. It begins with the simple problem of inserting a single row. Many times, however, it is more efficient to use a set-based approach to create new rows. To that end, you’ll also find techniques for inserting many rows at a time. Likewise, updating and deleting start out as simple tasks. You can update one record, and you can delete one record. But you can also update whole sets of records at once, and in very powerful ways. And there are many handy ways to delete records. For example, you can delete rows in one table depending on whether they exist in another table. SQL even has a way, a relatively new addition to the standard, letting you insert, update, and delete all at once. That may not sound like too useful a thing now, but the MERGE statement represents a powerful way to synchronize a database table with an external source of data  such as a flat file feed from a remote system . Check out Recipe 4.11 in this chapter for details.   4.1 Inserting a New Record  Problem You want to insert a new record into a table. For example, you want to insert a new record into the DEPT table. The value for DEPTNO should be 50, DNAME should be PROGRAMMING, and LOC should be BALTIMORE.  Solution Use the INSERT statement with the VALUES clause to insert one row at a time:  For DB2, SQL Server, PostgreSQL, and MySQL you have the option of inserting one row at a time or multiple rows at a time by including multiple VALUES lists:  Discussion The INSERT statement allows you to create new rows in database tables. The syntax for inserting a single row is consistent across all database brands. As a shortcut, you can omit the column list in an INSERT statement:  i n s e r t   i n t o   d e p t     d e p t n o , d n a m e , l o c     v a l u e s     5 0 , ' P R O G R A M M I N G ' , ' B A L T I M O R E '     *   m u l t i   r o w   i n s e r t   *     i n s e r t   i n t o   d e p t     d e p t n o , d n a m e , l o c     v a l u e s     1 , ' A ' , ' B '   ,                   2 , ' B ' , ' C '   i n s e r t   i n t o   d e p t   v a l u e s     5 0 , ' P R O G R A M M I N G ' , ' B A L T I M O R E '    However, if you do not list your target columns, you must insert into all of the columns in the table and be mindful of the order of the values in the VALUES list; you must supply values in the same order in which the database displays columns in response to a SELECT * query. Either way, you should be mindful of column constraints because if you don’t insert into every column, you are will create a row where some values are null. This can cause an error if there are columns constrained not to accept nulls.  4.2 Inserting Default Values  Problem A table can be defined to take default values for specific columns. You want to insert a row of default values without having to specify those values. Consider the following table:  You want to insert zero without explicitly specifying zero in the values list of an INSERT statement. You want to explicitly insert the default, whatever that default is.  Solution All brands support the use of the DEFAULT keyword as a way of explicitly specifying the default value for a column. Some brands provide additional ways to solve the problem. The following example illustrates the use of the DEFAULT keyword:  You may also explicitly specify the column name, which you’ll need to do anytime you are not inserting into all columns of a table:  c r e a t e   t a b l e   D     i d   i n t e g e r   d e f a u l t   0   i n s e r t   i n t o   D   v a l u e s     d e f a u l t    Oracle8i Database and prior versions do not support the DEFAULT keyword. Prior to Oracle9i Database, there was no way to explicitly insert a default column value. MySQL allows you to specify an empty values list if all columns have a default value defined:  In this case, all columns will be set to their default values. PostgreSQL and SQL Server support a DEFAULT VALUES clause:  The DEFAULT VALUES clause causes all columns to take on their default values.  Discussion The DEFAULT keyword in the values list will insert the value that was specified as the default for a particular column during table creation. The keyword is available for all DBMSs. MySQL, PostgreSQL, and SQL Server users have another option available if all columns in the table are defined with a default value  as table D is in this case . You may use an empty VALUES list  MySQL  or specify the DEFAULT VALUES clause  PostgreSQL and SQL Server  to create a new row with all default values; otherwise, you need to specify DEFAULT for each column in the table. For tables with a mix of default and nondefault columns, inserting default values for a column is as easy as excluding the column from the insert list; you do not need to use the DEFAULT keyword. Say that table D had an additional column that was not defined with a default value:  i n s e r t   i n t o   D     i d     v a l u e s     d e f a u l t   i n s e r t   i n t o   D   v a l u e s       i n s e r t   i n t o   D   d e f a u l t   v a l u e s  You can insert a default for ID by listing only FOO in the insert list:  This statement will result in a row in which ID is 0 and FOO is BAR. ID takes on its default value because no other value is specified.  4.3 Overriding a Default Value with NULL  Problem You are inserting into a column having a default value, and you want to override that default value by setting the column to NULL. Consider the following table:  You want to insert a row with a NULL value for ID.  Solution You can explicitly specify NULL in your values list:  Discussion Not everyone realizes that you can explicitly specify NULL in the values list of an INSERT statement. Typically, when you do not want to specify a value for a column, you leave that column out of your column and values lists:  c r e a t e   t a b l e   D     i d   i n t e g e r   d e f a u l t   0 ,   f o o   v a r c h a r   1 0     i n s e r t   i n t o   D     n a m e     v a l u e s     ' B a r '   c r e a t e   t a b l e   D     i d   i n t e g e r   d e f a u l t   0 ,   f o o   V A R C H A R   1 0     i n s e r t   i n t o   d     i d ,   f o o     v a l u e s     n u l l ,   ' B r i g h t e n '   i n s e r t   i n t o   d     f o o     v a l u e s     ' B r i g h t e n '    Here, no value for ID is specified. Many would expect the column to taken on the null value, but, alas, a default value was specified at table creation time, so the result of the preceding INSERT is that ID takes on the value zero  the default . By specifying NULL as the value for a column, you can set the column to NULL despite any default value  excepting where a constraint has been specifically applied to prevent NULLs .  4.4 Copying Rows from One Table into Another  Problem You want to copy rows from one table to another by using a query. The query may be complex or simple, but ultimately you want the result to be inserted into another table. For example, you want to copy rows from the DEPT table to the DEPT_EAST table. The DEPT_EAST table has already been created with the same structure  same columns and data types  as DEPT and is currently empty.  Solution Use the INSERT statement followed by a query to produce the rows you want:  Discussion Simply follow the INSERT statement with a query that returns the desired rows. If you want to copy all rows from the source table, exclude the WHERE clause from the query. Like a regular insert, you do not have to explicitly specify which columns you are inserting into. But if you do not  1   i n s e r t   i n t o   d e p t _ e a s t     d e p t n o , d n a m e , l o c     2   s e l e c t   d e p t n o , d n a m e , l o c   3       f r o m   d e p t   4     w h e r e   l o c   i n       ' N E W   Y O R K ' , ' B O S T O N '      specify your target columns, you must insert data into all of the table’s columns, and you must be mindful of the order of the values in the SELECT list, as described earlier in Recipe 4.1.  4.5 Copying a Table Definition  Problem You want to create a new table having the same set of columns as an existing table. For example, you want to create a copy of the DEPT table and call it DEPT_2. You do not want to copy the rows, only the column structure of the table.  Solution  DB2 Use the LIKE clause with the CREATE TABLE command:  Oracle, MySQL, and PostgreSQL Use the CREATE TABLE command with a subquery that returns no rows:  SQL Server Use the INTO clause with a subquery that returns no rows:  c r e a t e   t a b l e   d e p t _ 2   l i k e   d e p t 1   c r e a t e   t a b l e   d e p t _ 2   2   a s   3   s e l e c t   *   4       f r o m   d e p t   5     w h e r e   1   =   0 1   s e l e c t   *   2       i n t o   d e p t _ 2   3       f r o m   d e p t   4     w h e r e   1   =   0  Discussion  DB2 DB2’s CREATE TABLE…LIKE command allows you to easily use one table as the pattern for creating another. Simply specify your pattern table’s name following the LIKE keyword.  Oracle, MySQL, and PostgreSQL When using Create Table As Select  CTAS , all rows from your query will be used to populate the new table you are creating unless you specify a false condition in the WHERE clause. In the solution provided, the expression “1 = 0” in the WHERE clause of the query causes no rows to be returned. Thus, the result of the CTAS statement is an empty table based on the columns in the SELECT clause of the query.  SQL Server When using INTO to copy a table, all rows from your query will be used to populate the new table you are creating unless you specify a false condition in the WHERE clause of your query. In the solution provided, the expression “1 = 0” in the predicate of the query causes no rows to be returned. The result is an empty table based on the columns in the SELECT clause of the query.  4.6 Inserting into Multiple Tables at Once  Problem You want to take rows returned by a query and insert those rows into multiple target tables. For example, you want to insert rows from DEPT into tables DEPT_EAST, DEPT_WEST, and DEPT_MID. All three tables have the same structure  same columns and data types  as DEPT and are currently empty.   Solution The solution is to insert the result of a query into the target tables. The difference from Recipe 4.4 is that for this problem you have multiple target tables.  Oracle Use either the INSERT ALL or INSERT FIRST statement. Both share the same syntax except for the choice between the ALL and FIRST keywords. The following statement uses INSERT ALL to cause all possible target tables to be considered:  DB2 Insert into an inline view that performs a UNION ALL on the tables to be inserted. You must also be sure to place constraints on the tables that will ensure each row goes into the correct table:  1       i n s e r t   a l l   2           w h e n   l o c   i n     ' N E W   Y O R K ' , ' B O S T O N '     t h e n   3           i n t o   d e p t _ e a s t     d e p t n o , d n a m e , l o c     v a l u e s     d e p t n o , d n a m e , l o c     4           w h e n   l o c   =   ' C H I C A G O '   t h e n   5               i n t o   d e p t _ m i d     d e p t n o , d n a m e , l o c     v a l u e s     d e p t n o , d n a m e , l o c     6           e l s e   7               i n t o   d e p t _ w e s t     d e p t n o , d n a m e , l o c     v a l u e s     d e p t n o , d n a m e , l o c     8           s e l e c t   d e p t n o , d n a m e , l o c   9               f r o m   d e p t c r e a t e   t a b l e   d e p t _ e a s t       d e p t n o   i n t e g e r ,       d n a m e     v a r c h a r   1 0   ,       l o c         v a r c h a r   1 0     c h e c k     l o c   i n     ' N E W   Y O R K ' , ' B O S T O N '           c r e a t e   t a b l e   d e p t _ m i d       d e p t n o   i n t e g e r ,       d n a m e     v a r c h a r   1 0   ,       l o c         v a r c h a r   1 0     c h e c k     l o c   =   ' C H I C A G O '         c r e a t e   t a b l e   d e p t _ w e s t       d e p t n o   i n t e g e r ,       d n a m e     v a r c h a r   1 0   ,       l o c         v a r c h a r   1 0     c h e c k     l o c   =   ' D A L L A S '        MySQL, PostgreSQL, and SQL Server As of the time of this writing, these vendors do not support multitable inserts.  Discussion  Oracle Oracle’s multitable insert uses WHEN-THEN-ELSE clauses to evaluate the rows from the nested SELECT and insert them accordingly. In this recipe’s example, INSERT ALL and INSERT FIRST would produce the same result, but there is a difference between the two. INSERT FIRST will break out of the WHEN-THEN-ELSE evaluation as soon as it encounters a condition evaluating to true; INSERT ALL will evaluate all conditions even if prior tests evaluate to true. Thus, you can use INSERT ALL to insert the same row into more than one table.  DB2 My DB2 solution is a bit of a hack. It requires that the tables to be inserted into have constraints defined to ensure that each row evaluated from the subquery will go into the correct table. The technique is to insert into a view that is defined as the UNION ALL of the tables. If the check constraints are not unique among the tables in the INSERT  i.e., multiple tables have the same check constraint , the INSERT statement will not know where to put the rows, and it will fail.  MySQL, PostgreSQL, and SQL Server As of the time of this writing, only Oracle and DB2 provide mechanisms to insert rows returned by a query into one or more of several tables within the    1     i n s e r t   i n t o       2         s e l e c t   *   f r o m   d e p t _ w e s t   u n i o n   a l l   3         s e l e c t   *   f r o m   d e p t _ e a s t   u n i o n   a l l   4         s e l e c t   *   f r o m   d e p t _ m i d   5         s e l e c t   *   f r o m   d e p t  same statement.  4.7 Blocking Inserts to Certain Columns  Problem You want to prevent users, or an errant software application, from inserting values into certain table columns. For example, you want to allow a program to insert into EMP, but only into the EMPNO, ENAME, and JOB columns.  Solution Create a view on the table exposing only those columns you want to expose. Then force all inserts to go through that view. For example, to create a view exposing the three columns in EMP:  Grant access to this view to those users and programs allowed to populate only the three fields in the view. Do not grant those users insert access to the EMP table. Users may then create new EMP records by inserting into the NEW_EMPS view, but they will not be able to provide values for columns other than the three that are specified in the view definition.  Discussion When you insert into a simple view such as in the solution, your database server will translate that insert into the underlying table. For example, the following insert:  c r e a t e   v i e w   n e w _ e m p s   a s   s e l e c t   e m p n o ,   e n a m e ,   j o b       f r o m   e m p i n s e r t   i n t o   n e w _ e m p s           e m p n o   e n a m e ,   j o b           v a l u e s     1 ,   ' J o n a t h a n ' ,   ' E d i t o r '    will be translated behind the scenes into:  It is also possible, but perhaps less useful, to insert into an inline view  currently only supported by Oracle :  View insertion is a complex topic. The rules become complicated very quickly for all but the simplest of views. If you plan to make use of the ability to insert into views, it is imperative that you consult and fully understand your vendor documentation on the matter.  4.8 Modifying Records in a Table  Problem You want to modify values for some or all rows in a table. For example, you might want to increase the salaries of everyone in department 20 by 10%. The following result set shows the DEPTNO, ENAME, and SAL for employees in that department:  i n s e r t   i n t o   e m p           e m p n o   e n a m e ,   j o b           v a l u e s     1 ,   ' J o n a t h a n ' ,   ' E d i t o r '   i n s e r t   i n t o         s e l e c t   e m p n o ,   e n a m e ,   j o b             f r o m   e m p     v a l u e s     1 ,   ' J o n a t h a n ' ,   ' E d i t o r '   s e l e c t   d e p t n o , e n a m e , s a l       f r o m   e m p     w h e r e   d e p t n o   =   2 0     o r d e r   b y   1 , 3     D E P T N O   E N A M E                           S A L   - - - - - -   - - - - - - - - - -   - - - - - - - - - -           2 0   S M I T H                           8 0 0           2 0   A D A M S                         1 1 0 0           2 0   J O N E S                         2 9 7 5    You want to bump all the SAL values by 10%.  Solution Use the UPDATE statement to modify existing rows in a database table. For example:  Discussion Use the UPDATE statement along with a WHERE clause to specify which rows to update; if you exclude a WHERE clause, then all rows are updated. The expression SAL*1.10 in this solution returns the salary increased by 10%. When preparing for a mass update, you may want to preview the results. You can do that by issuing a SELECT statement that includes the expressions you plan to put into your SET clauses. The following SELECT shows the result of a 10% salary increase:          2 0   S C O T T                         3 0 0 0           2 0   F O R D                           3 0 0 0 1   u p d a t e   e m p   2         s e t   s a l   =   s a l * 1 . 1 0   3     w h e r e   d e p t n o   =   2 0 s e l e c t   d e p t n o ,                 e n a m e ,                 s a l             a s   o r i g _ s a l ,                 s a l * . 1 0     a s   a m t _ t o _ a d d ,                 s a l * 1 . 1 0   a s   n e w _ s a l       f r o m   e m p     w h e r e   d e p t n o = 2 0     o r d e r   b y   1 , 5     D E P T N O   E N A M E     O R I G _ S A L   A M T _ T O _ A D D     N E W _ S A L   - - - - - -   - - - - - -   - - - - - - - -   - - - - - - - - - -     - - - - - - -           2 0   S M I T H               8 0 0                   8 0             8 8 0           2 0   A D A M S             1 1 0 0                 1 1 0           1 2 1 0           2 0   J O N E S             2 9 7 5                 2 9 8           3 2 7 3    The salary increase is broken down into two columns: one to show the increase over the old salary, and the other to show the new salary.  4.9 Updating When Corresponding Rows Exist  Problem You want to update rows in one table when corresponding rows exist in another. For example, if an employee appears in table EMP_BONUS, you want to increase that employee’s salary  in table EMP  by 20%. The following result set represents the data currently in table EMP_BONUS:  Solution Use a subquery in your UPDATE statement’s WHERE clause to find employees in table EMP that are also in table EMP_BONUS. Your UPDATE will then act only on those rows, enabling you to increase their salary by 20%:  Discussion          2 0   S C O T T             3 0 0 0                 3 0 0           3 3 0 0           2 0   F O R D               3 0 0 0                 3 0 0           3 3 0 0 s e l e c t   e m p n o ,   e n a m e       f r o m   e m p _ b o n u s               E M P N O   E N A M E   - - - - - - - - - -   - - - - - - - - -               7 3 6 9   S M I T H               7 9 0 0   J A M E S               7 9 3 4   M I L L E R 1   u p d a t e   e m p   2         s e t   s a l = s a l * 1 . 2 0   3     w h e r e   e m p n o   i n       s e l e c t   e m p n o   f r o m   e m p _ b o n u s      The results from the subquery represent the rows that will be updated in table EMP. The IN predicate tests values of EMPNO from the EMP table to see whether they are in the list of EMPNO values returned by the subquery. When they are, the corresponding SAL values are updated. Alternatively, you can use EXISTS instead of IN:  You may be surprised to see NULL in the SELECT list of the EXISTS subquery. Fear not, that NULL does not have an adverse effect on the update. Arguably it increases readability as it reinforces the fact that, unlike the solution using a subquery with an IN operator, what will drive the update  i.e., which rows will be updated  will be controlled by the WHERE clause of the subquery, not the values returned as a result of the subquery’s SELECT list.  4.10 Updating with Values from Another Table  Problem You want to update rows in one table using values from another. For example, you have a table called NEW_SAL, which holds the new salaries for certain employees. The contents of table NEW_SAL are as follows:  u p d a t e   e m p         s e t   s a l   =   s a l * 1 . 2 0     w h e r e   e x i s t s       s e l e c t   n u l l                                       f r o m   e m p _ b o n u s                                     w h e r e   e m p . e m p n o = e m p _ b o n u s . e m p n o     s e l e c t   *       f r o m   n e w _ s a l     D E P T N O                 S A L   - - - - - -   - - - - - - - - - -           1 0               4 0 0 0  Column DEPTNO is the primary key of table NEW_SAL. You want to update the salaries and commission of certain employees in table EMP using values table NEW_SAL if there is a match between EMP.DEPTNO and NEW_SAL.DEPTNO, update EMP.SAL to NEW_SAL.SAL, and update EMP.COMM to 50% of NEW_SAL.SAL. The rows in EMP are as follows:  Solution Use a join between NEW_SAL and EMP to find and return the new COMM values to the UPDATE statement. It is quite common for updates such as this one to be performed via correlated subquery or alternatively using a CTE. Another technique involves creating a view  traditional or inline, depending on what your database supports  and then updating that view.  DB2 Use a correlated subquery to set new SAL and COMM values in EMP. Also use a correlated subquery to identify which rows from EMP should be  s e l e c t   d e p t n o , e n a m e , s a l , c o m m       f r o m   e m p     o r d e r   b y   1     D E P T N O   E N A M E                           S A L               C O M M   - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -           1 0   C L A R K                       2 4 5 0           1 0   K I N G                         5 0 0 0           1 0   M I L L E R                     1 3 0 0           2 0   S M I T H                         8 0 0           2 0   A D A M S                       1 1 0 0           2 0   F O R D                         3 0 0 0           2 0   S C O T T                       3 0 0 0           2 0   J O N E S                       2 9 7 5           3 0   A L L E N                       1 6 0 0                   3 0 0           3 0   B L A K E                       2 8 5 0           3 0   M A R T I N                     1 2 5 0                 1 4 0 0           3 0   J A M E S                         9 5 0           3 0   T U R N E R                     1 5 0 0                       0           3 0   W A R D                         1 2 5 0                   5 0 0  updated:  MySQL Include both EMP and NEW_SAL in the UPDATE clause of the UPDATE statement and join in the WHERE clause:  Oracle The method for the DB2 solution will work for Oracle, but as an alternative, you can update an inline view:  PostgreSQL The method used for the DB2 solution will work for PostgreSQL, but you could also  quite conveniently  join directly in the UPDATE statement:  1   u p d a t e   e m p   e   s e t     e . s a l , e . c o m m     =     s e l e c t   n s . s a l ,   n s . s a l   2   2                                                                             f r o m   n e w _ s a l   n s   3                                                                           w h e r e   n s . d e p t n o = e . d e p t n o     4     w h e r e   e x i s t s       s e l e c t   *   5                                       f r o m   n e w _ s a l   n s   6                                     w h e r e   n s . d e p t n o   =   e . d e p t n o     1   u p d a t e   e m p   e ,   n e w _ s a l   n s   2   s e t   e . s a l = n s . s a l ,   3   e . c o m m = n s . s a l   2   4   w h e r e   e . d e p t n o = n s . d e p t n o 1   u p d a t e       2     s e l e c t   e . s a l   a s   e m p _ s a l ,   e . c o m m   a s   e m p _ c o m m ,   3                   n s . s a l   a s   n s _ s a l ,   n s . s a l   2   a s   n s _ c o m m   4         f r o m   e m p   e ,   n e w _ s a l   n s   5       w h e r e   e . d e p t n o   =   n s . d e p t n o   6       s e t   e m p _ s a l   =   n s _ s a l ,   e m p _ c o m m   =   n s _ c o m m 1   u p d a t e   e m p   2         s e t   s a l   =   n s . s a l ,   3                 c o m m   =   n s . s a l   2   4       f r o m   n e w _ s a l   n s   5     w h e r e   n s . d e p t n o   =   e m p . d e p t n o  SQL Server The method used for the DB2 solution will work for SQL Server, but as an alternative you can  similarly to the PostgreSQL solution  join directly in the UPDATE statement:  Discussion Before discussing the different solutions, it’s worth mentioning something important regarding updates that use queries to supply new values. A WHERE clause in the subquery of a correlated update is not the same as the WHERE clause of the table being updated. If you look at the UPDATE statement in the “Problem” section, the join on DEPTNO between EMP and NEW_SAL is done and returns rows to the SET clause of the UPDATE statement. For employees in DEPTNO 10, valid values are returned because there is a matching DEPTNO in table NEW_SAL. But what about employees in the other departments? NEW_SAL does not have any other departments, so the SAL and COMM for employees in DEPTNOs 20 and 30 are set to NULL. Unless you are doing so via LIMIT or TOP or whatever mechanism your vendor supplies for limiting the number of rows returned in a result set, the only way to restrict rows from a table in SQL is to use a WHERE clause. To correctly perform this UPDATE, use a WHERE clause on the table being updated along with a WHERE clause in the correlated subquery.  DB2 To ensure you do not update every row in table EMP, remember to include a correlated subquery in the WHERE clause of the UPDATE. Performing the join  the correlated subquery  in the SET clause is not enough. By using a WHERE clause in the UPDATE, you ensure that only rows in EMP that  1   u p d a t e   e   2         s e t   e . s a l     =   n s . s a l ,   3                 e . c o m m   =   n s . s a l   2   4       f r o m   e m p   e ,   5                 n e w _ s a l   n s   6     w h e r e   n s . d e p t n o   =   e . d e p t n o  match on DEPTNO to table NEW_SAL are updated. This holds true for all RDBMSs.  Oracle In the Oracle solution using the update join view, you are using equi-joins to determine which rows will be updated. You can confirm which rows are being updated by executing the query independently. To be able to successfully use this type of UPDATE, you must first understand the concept of key-preservation. The DEPTNO column of the table NEW_SAL is the primary key of that table; thus, its values are unique within the table. When joining between EMP and NEW_SAL, however, NEW_SAL.DEPTNO is not unique in the result set, as shown here:  To enable Oracle to update this join, one of the tables must be key- preserved, meaning that if its values are not unique in the result set, it should at least be unique in the table it comes from. In this case, NEW_SAL has a primary key on DEPTNO, which makes it unique in the table. Because it is unique in its table, it may appear multiple times in the result set and will still be considered key-preserved, thus allowing the update to complete successfully.  PostgreSQL, SQL Server, and MySQL The syntax is a bit different between these platforms, but the technique is the same. Being able to join directly in the UPDATE statement is extremely convenient. Since you specify which table to update  the table listed after the UPDATE keyword , there’s no confusion as to which table’s rows are  s e l e c t   e . e m p n o ,   e . d e p t n o   e _ d e p t ,   n s . s a l ,   n s . d e p t n o   n s _ d e p t n o       f r o m   e m p   e ,   n e w _ s a l   n s     w h e r e   e . d e p t n o   =   n s . d e p t n o       E M P N O           E _ D E P T                 S A L     N S _ D E P T N O   - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -     7 7 8 2                   1 0               4 0 0 0                   1 0     7 8 3 9                   1 0               4 0 0 0                   1 0     7 9 3 4                   1 0               4 0 0 0                   1 0  modified. Additionally, because you are using joins in the update  since there is an explicit WHERE clause , you can avoid some of the pitfalls when coding correlated subquery updates; in particular, if you missed a join here, it would be obvious you’d have a problem.  4.11 Merging Records  Problem You want to conditionally insert, update, or delete records in a table depending on whether corresponding records exist.  If a record exists, then update; if not, then insert; if after updating a row fails to meet a certain condition, delete it.  For example, you want to modify table EMP_COMMISSION such that:  If any employee in EMP_COMMISSION also exists in table EMP, then update their commission  COMM  to 1000. For all employees who will potentially have their COMM updated to 1000, if their SAL is less than 2000, delete them  they should not be exist in EMP_[.keep-together] COMMISSION . Otherwise, insert the EMPNO, ENAME, and DEPTNO values from table EMP into table EMP_COMMISSION.  Essentially, you want to execute either an UPDATE or an INSERT depending on whether a given row from EMP has a match in EMP_COMMISSION. Then you want to execute a DELETE if the result of an UPDATE causes a commission that’s too high. The following rows are currently in tables EMP and EMP_COMMISSION, respectively:  s e l e c t   d e p t n o , e m p n o , e n a m e , c o m m       f r o m   e m p     o r d e r   b y   1     D E P T N O             E M P N O   E N A M E                 C O M M   - - - - - -   - - - - - - - - - -   - - - - - -   - - - - - - - - - -    Solution The statement designed to solve this problem is the MERGE statement, and it can perform either an UPDATE or an INSERT, as needed. For example:  Currently, MySQL does not have a MERGE statement; otherwise, this query should work on any RDBMS in this book, and in a wide number of others.          1 0               7 7 8 2     C L A R K           1 0               7 8 3 9     K I N G           1 0               7 9 3 4     M I L L E R           2 0               7 3 6 9     S M I T H           2 0               7 8 7 6     A D A M S           2 0               7 9 0 2     F O R D           2 0               7 7 8 8     S C O T T           2 0               7 5 6 6     J O N E S           3 0               7 4 9 9     A L L E N                 3 0 0           3 0               7 6 9 8     B L A K E           3 0               7 6 5 4     M A R T I N             1 4 0 0           3 0               7 9 0 0     J A M E S           3 0               7 8 4 4     T U R N E R                   0           3 0               7 5 2 1     W A R D                   5 0 0       s e l e c t   d e p t n o , e m p n o , e n a m e , c o m m       f r o m   e m p _ c o m m i s s i o n     o r d e r   b y   1             D E P T N O             E M P N O   E N A M E                         C O M M   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -                   1 0               7 7 8 2   C L A R K                   1 0               7 8 3 9   K I N G                   1 0               7 9 3 4   M I L L E R 1     m e r g e   i n t o   e m p _ c o m m i s s i o n   e c   2     u s i n g     s e l e c t   *   f r o m   e m p     e m p   3           o n     e c . e m p n o = e m p . e m p n o     4       w h e n   m a t c h e d   t h e n   5                 u p d a t e   s e t   e c . c o m m   =   1 0 0 0   6                 d e l e t e   w h e r e     s a l   <   2 0 0 0     7       w h e n   n o t   m a t c h e d   t h e n   8                 i n s e r t     e c . e m p n o , e c . e n a m e , e c . d e p t n o , e c . c o m m     9                 v a l u e s     e m p . e m p n o , e m p . e n a m e , e m p . d e p t n o , e m p . c o m m    Discussion The join on line 3 of the solution determines what rows already exist and will be updated. The join is between EMP_COMMISSION  aliased as EC  and the subquery  aliased as EMP . When the join succeeds, the two rows are considered “matched,” and the UPDATE specified in the WHEN MATCHED clause is executed. Otherwise, no match is found, and the INSERT in WHEN NOT MATCHED is executed. Thus, rows from table EMP that do not have corresponding rows based on EMPNO in table EMP_COMMISSION will be inserted into EMP_COMMISSION. Of all the employees in table EMP, only those in DEPTNO 10 should have their COMM updated in EMP_COMMISSION, while the rest of the employees are inserted. Additionally, since MILLER is in DEPTNO 10, he is a candidate to have his COMM updated, but because his SAL is less than 2,000, it is deleted from EMP_COMMISSION.  4.12 Deleting All Records from a Table  Problem You want to delete all the records from a table.  Solution Use the DELETE command to delete records from a table. For example, to delete all records from EMP, use the following:  Discussion When using the DELETE command without a WHERE clause, you will delete all rows from the table specified. Sometimes TRUNCATE, which applies to tables and therefore doesn’t use the WHERE clause, is preferred as it is faster. At least in Oracle, however, TRUNCATE cannot be undone.  d e l e t e   f r o m   e m p  You should carefully check vendor documentation for a detailed view of the performance and rollback differences between TRUNCATE and DELETE in your specific RDBMS.  4.13 Deleting Specific Records  Problem You want to delete records meeting a specific criterion from a table.  Solution Use the DELETE command with a WHERE clause specifying which rows to delete. For example, to delete all employees in department 10, use the following:  Discussion By using a WHERE clause with the DELETE command, you can delete a subset of rows in a table rather than all the rows. Don’t forget to check that you’re deleting the right data by previewing the effect of your WHERE clause using SELECT—you can delete the wrong data even in a simple situation. For example, in the previous case, a typo could lead to the employees in department 20 being deleted instead of department 10!  4.14 Deleting a Single Record  Problem You want to delete a single record from a table.  Solution  d e l e t e   f r o m   e m p   w h e r e   d e p t n o   =   1 0  This is a special case of Recipe 4.13. The key is to ensure that your selection criterion is narrow enough to specify only the one record that you want to delete. Often you will want to delete based on the primary key. For example, to delete employee CLARK  EMPNO 7782 :  Discussion Deleting is always about identifying the rows to be deleted, and the impact of a DELETE always comes down to its WHERE clause. Omit the WHERE clause and the scope of a DELETE is the entire table. By writing conditions in the WHERE clause, you can narrow the scope to a group of records or to a single record. When deleting a single record, you should typically be identifying that record based on its primary key or on one of its unique keys.  WARNING  If your deletion criterion is based on a primary or unique key, then you can be sure of deleting only one record.  This is because your RDBMS will not allow two rows to contain the same primary or unique key values.  Otherwise, you may want to check first, to be sure you aren’t about to inadvertently delete more records than you intend.  4.15 Deleting Referential Integrity Violations  Problem You want to delete records from a table when those records refer to nonexistent records in some other table. For example, some employees are assigned to departments that do not exist. You want to delete those employees.  Solution  d e l e t e   f r o m   e m p   w h e r e   e m p n o   =   7 7 8 2  Use the NOT EXISTS predicate with a subquery to test the validity of department numbers:  Alternatively, you can write the query using a NOT IN predicate:  Discussion Deleting is really all about selecting: the real work lies in writing WHERE clause conditions to correctly describe those records that you want to delete. The NOT EXISTS solution uses a correlated subquery to test for the existence of a record in DEPT having a DEPTNO matching that in a given EMP record. If such a record exists, then the EMP record is retained. Otherwise, it is deleted. Each EMP record is checked in this manner. The IN solution uses a subquery to retrieve a list of valid department numbers. DEPTNOs from each EMP record are then checked against that list. When an EMP record is found with a DEPTNO not in the list, the EMP record is deleted.  4.16 Deleting Duplicate Records  Problem You want to delete duplicate records from a table. Consider the following table:  d e l e t e   f r o m   e m p     w h e r e   n o t   e x i s t s             s e l e c t   *   f r o m   d e p t           w h e r e   d e p t . d e p t n o   =   e m p . d e p t n o     d e l e t e   f r o m   e m p   w h e r e   d e p t n o   n o t   i n     s e l e c t   d e p t n o   f r o m   d e p t   c r e a t e   t a b l e   d u p e s     i d   i n t e g e r ,   n a m e   v a r c h a r   1 0          For each group of duplicate names, such as SEA SHELLS, you want to arbitrarily retain one ID and delete the rest. In the case of SEA SHELLS, you don’t care whether you delete lines 5 and 6, or lines 5 and 7, or lines 6 and 7, but in the end you want just one record for SEA SHELLS.  Solution Use a subquery with an aggregate function such as MIN to arbitrarily choose the ID to retain  in this case only the NAME with the smallest value for ID is not deleted :  For MySQL users you will need slightly different syntax because you cannot reference the same table twice in a delete  as of the time of this writing :  i n s e r t   i n t o   d u p e s   v a l u e s     1 ,   ' N A P O L E O N '     i n s e r t   i n t o   d u p e s   v a l u e s     2 ,   ' D Y N A M I T E '     i n s e r t   i n t o   d u p e s   v a l u e s     3 ,   ' D Y N A M I T E '     i n s e r t   i n t o   d u p e s   v a l u e s     4 ,   ' S H E   S E L L S '     i n s e r t   i n t o   d u p e s   v a l u e s     5 ,   ' S E A   S H E L L S '     i n s e r t   i n t o   d u p e s   v a l u e s     6 ,   ' S E A   S H E L L S '     i n s e r t   i n t o   d u p e s   v a l u e s     7 ,   ' S E A   S H E L L S '       s e l e c t   *   f r o m   d u p e s   o r d e r   b y   1                     I D   N A M E   - - - - - - - - - -   - - - - - - - - - -                     1   N A P O L E O N                     2   D Y N A M I T E                     3   D Y N A M I T E                     4   S H E   S E L L S                     5   S E A   S H E L L S                     6   S E A   S H E L L S                     7   S E A   S H E L L S 1     d e l e t e   f r o m   d u p e s   2       w h e r e   i d   n o t   i n       s e l e c t   m i n   i d     3                                                 f r o m   d u p e s   4                                               g r o u p   b y   n a m e      Discussion The first thing to do when deleting duplicates is to define exactly what it means for two rows to be considered “duplicates” of each other. For my example in this recipe, the definition of “duplicate” is that two records contain the same value in their NAME column. Having that definition in place, you can look to some other column to discriminate among each set of duplicates, to identify those records to retain. It’s best if this discriminating column  or columns  is a primary key. We used the ID column, which is a good choice because no two records have the same ID. The key to the solution is that you group by the values that are duplicated  by NAME in this case , and then use an aggregate function to pick off just one key value to retain. The subquery in the “Solution” example will return the smallest ID for each NAME, which represents the row you will not delete:  The DELETE then deletes any ID in the table that is not returned by the subquery  in this case IDs 3, 6, and 7 . If you are having trouble seeing how this works, run the subquery first and include the NAME in the SELECT list:  1       d e l e t e   f r o m   d u p e s   2         w h e r e   i d   n o t   i n   3                       s e l e c t   m i n   i d     4         f r o m     s e l e c t   i d , n a m e   f r o m   d u p e s     t m p   5                       g r o u p   b y   n a m e   s e l e c t   m i n   i d         f r o m   d u p e s     g r o u p   b y   n a m e             M I N   I D     - - - - - - - - - - -                       2                       1                       5                       4  The rows returned by the subquery represent those to be retained. The NOT IN predicate in the DELETE statement causes all other rows to be deleted.  4.17 Deleting Records Referenced from Another Table  Problem You want to delete records from one table when those records are referenced from some other table. Consider the following table, named DEPT_ACCIDENTS, which contains one row for each accident that occurs in a manufacturing business. Each row records the department in which an accident occurred and also the type of accident.  s e l e c t   n a m e ,   m i n   i d         f r o m   d u p e s     g r o u p   b y   n a m e     N A M E                     M I N   I D     - - - - - - - - - -   - - - - - - - - - -   D Y N A M I T E                         2   N A P O L E O N                         1   S E A   S H E L L S                     5   S H E   S E L L S                       4 c r e a t e   t a b l e   d e p t _ a c c i d e n t s       d e p t n o                   i n t e g e r ,       a c c i d e n t _ n a m e     v a r c h a r   2 0           i n s e r t   i n t o   d e p t _ a c c i d e n t s   v a l u e s     1 0 , ' B R O K E N   F O O T '     i n s e r t   i n t o   d e p t _ a c c i d e n t s   v a l u e s     1 0 , ' F L E S H   W O U N D '     i n s e r t   i n t o   d e p t _ a c c i d e n t s   v a l u e s     2 0 , ' F I R E '     i n s e r t   i n t o   d e p t _ a c c i d e n t s   v a l u e s     2 0 , ' F I R E '     i n s e r t   i n t o   d e p t _ a c c i d e n t s   v a l u e s     2 0 , ' F L O O D '     i n s e r t   i n t o   d e p t _ a c c i d e n t s   v a l u e s     3 0 , ' B R U I S E D   G L U T E '       s e l e c t   *   f r o m   d e p t _ a c c i d e n t s             D E P T N O   A C C I D E N T _ N A M E   - - - - - - - - - -   - - - - - - - - - - - - - - - - - - - -                   1 0   B R O K E N   F O O T    You want to delete from EMP the records for those employees working at a department that has three or more accidents.  Solution Use a subquery and the aggregate function COUNT to find the departments with three or more accidents. Then delete all employees working in those departments:  Discussion The subquery will identify which departments have three or more accidents:  The DELETE will then delete any employees in the departments returned by the subquery  in this case, only in department 20 .  4.18 Summing Up                  1 0   F L E S H   W O U N D                   2 0   F I R E                   2 0   F I R E                   2 0   F L O O D                   3 0   B R U I S E D   G L U T E 1   d e l e t e   f r o m   e m p   2     w h e r e   d e p t n o   i n       s e l e c t   d e p t n o   3                                             f r o m   d e p t _ a c c i d e n t s   4                                           g r o u p   b y   d e p t n o   5                                         h a v i n g   c o u n t   *     > =   3     s e l e c t   d e p t n o       f r o m   d e p t _ a c c i d e n t s     g r o u p   b y   d e p t n o   h a v i n g   c o u n t   *     > =   3             D E P T N O   - - - - - - - - - -                   2 0  Inserting and updating data may seem to take up less of your time than querying data, and in the rest of the book we will concentrate on queries. However, being able to maintain the data in a database is clearly fundamental to its purpose, and these recipes are a crucial part of the skill set needed to maintain a database. Some of these commands, especially commands that remove or delete data, can have lasting consequences. Always preview any data you intend to delete to make sure you are really deleting what you mean to, and become familiar with what can and can’t be undone in your specific RDBMS.   Chapter 5. Metadata Queries  This chapter presents recipes that allow you to find information about a given schema. For example, you may want to know what tables you’ve created or which foreign keys are not indexed. All of the RDBMSs in this book provide tables and views for obtaining such data. The recipes in this chapter will get you started on gleaning information from those tables and views. Although at a high level the strategy of storing metadata in tables and views within the RDBMS is common, the ultimate implementation is not standardized to the same degree as most of the SQL language features covered in this book. Therefore, compared to other chapters, in this chapter having a different solution for each RDBMS is far more common. The following is selection of the most common schema queries written for each of the RDMSs covered in the book. There is far more information available than the recipes in this chapter can show. Consult your RDBMS’s documentation for the complete list of catalog or data dictionary tables views when you need to go beyond what’s presented here.  For the purposes of demonstration, all of the recipes in this chapter assume there is a schema named SMEAGOL.  TIP  5.1 Listing Tables in a Schema  Problem You want to see a list of all the tables you’ve created in a given schema.   Solution The solutions that follow all assume you are working with the SMEAGOL schema. The basic approach to a solution is the same for all RDBMSs: you query a system table  or view  containing a row for each table in the database.  DB2 Query SYSCAT.TABLES:  Oracle Query SYS.ALL_TABLES:  PostgreSQL, MySQL, and SQL Server Query INFORMATION_SCHEMA.TABLES:  Discussion In a delightfully circular manner, databases expose information about themselves through the very mechanisms that you create for your own applications: tables and views. Oracle, for example, maintains an extensive catalog of system views, such as ALL_TABLES, that you can query for information about tables, indexes, grants, and any other database object.  1   s e l e c t   t a b n a m e   2       f r o m   s y s c a t . t a b l e s   3     w h e r e   t a b s c h e m a   =   ' S M E A G O L ' s e l e c t   t a b l e _ n a m e       f r o m   a l l _ t a b l e s     w h e r e   o w n e r   =   ' S M E A G O L ' 1   s e l e c t   t a b l e _ n a m e   2       f r o m   i n f o r m a t i o n _ s c h e m a . t a b l e s   3     w h e r e   t a b l e _ s c h e m a   =   ' S M E A G O L '  TIP  Oracle’s catalog views are just that, views. They are based on an underlying set of tables that contain the information in a user-unfriendly form. The views put a usable face on Oracle’s catalog data.  Oracle’s system views and DB2’s system tables are each vendor-specific. PostgreSQL, MySQL, and SQL Server, on the other hand, support something called the information schema, which is a set of views defined by the ISO SQL standard. That’s why the same query can work for all three of those databases.  5.2 Listing a Table’s Columns  Problem You want to list the columns in a table, along with their data types, and their position in the table they are in.  Solution The following solutions assume that you want to list columns, their data types, and their numeric position in the table named EMP in the schema SMEAGOL.  DB2 Query SYSCAT.COLUMNS:  Oracle Query ALL_TAB_COLUMNS:  1   s e l e c t   c o l n a m e ,   t y p e n a m e ,   c o l n o   2       f r o m   s y s c a t . c o l u m n s   3     w h e r e   t a b n a m e       =   ' E M P '   4         a n d   t a b s c h e m a   =   ' S M E A G O L '  PostgreSQL, MySQL, and SQL Server Query INFORMATION_SCHEMA.COLUMNS:  Discussion Each vendor provides ways for you to get detailed information about your column data. In the previous examples, only the column name, data type, and position are returned. Additional useful items of information include length, nullability, and default values.  5.3 Listing Indexed Columns for a Table  Problem You want list indexes, their columns, and the column position  if available  in the index for a given table.  Solution The vendor-specific solutions that follow all assume that you are listing indexes for table EMP in the SMEAGOL schema.  DB2 Query SYSCAT.INDEXES:  1   s e l e c t   c o l u m n _ n a m e ,   d a t a _ t y p e ,   c o l u m n _ i d   2       f r o m   a l l _ t a b _ c o l u m n s   3     w h e r e   o w n e r             =   ' S M E A G O L '   4         a n d   t a b l e _ n a m e   =   ' E M P ' 1   s e l e c t   c o l u m n _ n a m e ,   d a t a _ t y p e ,   o r d i n a l _ p o s i t i o n   2       f r o m   i n f o r m a t i o n _ s c h e m a . c o l u m n s   3     w h e r e   t a b l e _ s c h e m a   =   ' S M E A G O L '   4         a n d   t a b l e _ n a m e       =   ' E M P ' 1     s e l e c t   a . t a b n a m e ,   b . i n d n a m e ,   b . c o l n a m e ,   b . c o l s e q   2         f r o m   s y s c a t . i n d e x e s   a ,    Oracle Query SYS.ALL_IND_COLUMNS:  PostgreSQL Query PG_CATALOG.PG_INDEXES and INFORMATION_SCHEMA.COLUMNS:  MySQL Use the SHOW INDEX command:  SQL Server Query SYS.TABLES, SYS.INDEXES, SYS.INDEX_COLUMNS, and SYS.COLUMNS:  3                   s y s c a t . i n d e x c o l u s e   b   4       w h e r e   a . t a b n a m e       =   ' E M P '   5           a n d   a . t a b s c h e m a   =   ' S M E A G O L '   6           a n d   a . i n d s c h e m a   =   b . i n d s c h e m a   7           a n d   a . i n d n a m e       =   b . i n d n a m e s e l e c t   t a b l e _ n a m e ,   i n d e x _ n a m e ,   c o l u m n _ n a m e ,   c o l u m n _ p o s i t i o n       f r o m   s y s . a l l _ i n d _ c o l u m n s     w h e r e   t a b l e _ n a m e     =   ' E M P '         a n d   t a b l e _ o w n e r   =   ' S M E A G O L ' 1     s e l e c t   a . t a b l e n a m e , a . i n d e x n a m e , b . c o l u m n _ n a m e   2         f r o m   p g _ c a t a l o g . p g _ i n d e x e s   a ,   3                   i n f o r m a t i o n _ s c h e m a . c o l u m n s   b   4       w h e r e   a . s c h e m a n a m e   =   ' S M E A G O L '   5           a n d   a . t a b l e n a m e     =   b . t a b l e _ n a m e s h o w   i n d e x   f r o m   e m p   1     s e l e c t   a . n a m e   t a b l e _ n a m e ,     2                   b . n a m e   i n d e x _ n a m e ,     3                   d . n a m e   c o l u m n _ n a m e ,     4                   c . i n d e x _ c o l u m n _ i d     5         f r o m   s y s . t a b l e s   a ,     6                   s y s . i n d e x e s   b ,    Discussion When it comes to queries, it’s important to know what columns are aren’t indexed. Indexes can provide good performance for queries against columns that are frequently used in filters and that are fairly selective. Indexes are also useful when joining between tables. By knowing what columns are indexed, you are already one step ahead of performance problems if they should occur. Additionally, you might want to find information about the indexes themselves: how many levels deep they are, how many distinct keys there are, how many leaf blocks there are, and so forth. Such information is also available from the views tables queried in this recipe’s solutions.  5.4 Listing Constraints on a Table  Problem You want to list the constraints defined for a table in some schema and the columns they are defined on. For example, you want to find the constraints and the columns they are on for table EMP.  Solution  DB2 Query SYSCAT.TABCONST and SYSCAT.COLUMNS:    7                   s y s . i n d e x _ c o l u m n s   c ,     8                   s y s . c o l u m n s   d     9     w h e r e   a . o b j e c t _ i d   =   b . o b j e c t _ i d   1 0         a n d   b . o b j e c t _ i d   =   c . o b j e c t _ i d   1 1         a n d   b . i n d e x _ i d     =   c . i n d e x _ i d   1 2         a n d   c . o b j e c t _ i d   =   d . o b j e c t _ i d   1 3         a n d   c . c o l u m n _ i d   =   d . c o l u m n _ i d   1 4         a n d   a . n a m e             =   ' E M P '  Oracle Query SYS.ALL_CONSTRAINTS and SYS.ALL_CONS_COLUMNS:  PostgreSQL, MySQL, and SQL Server Query INFORMATION_SCHEMA.TABLE_CONSTRAINTS and INFORMATION_ SCHEMA.KEY_COLUMN_USAGE:  Discussion  1     s e l e c t   a . t a b n a m e ,   a . c o n s t n a m e ,   b . c o l n a m e ,   a . t y p e   2         f r o m   s y s c a t . t a b c o n s t   a ,   3                   s y s c a t . c o l u m n s   b   4     w h e r e   a . t a b n a m e       =   ' E M P '   5         a n d   a . t a b s c h e m a   =   ' S M E A G O L '   6         a n d   a . t a b n a m e       =   b . t a b n a m e   7         a n d   a . t a b s c h e m a   =   b . t a b s c h e m a   1     s e l e c t   a . t a b l e _ n a m e ,     2                   a . c o n s t r a i n t _ n a m e ,     3                   b . c o l u m n _ n a m e ,     4                   a . c o n s t r a i n t _ t y p e     5         f r o m   a l l _ c o n s t r a i n t s   a ,     6                   a l l _ c o n s _ c o l u m n s   b     7     w h e r e   a . t a b l e _ n a m e             =   ' E M P '     8         a n d   a . o w n e r                       =   ' S M E A G O L '     9         a n d   a . t a b l e _ n a m e             =   b . t a b l e _ n a m e   1 0         a n d   a . o w n e r                       =   b . o w n e r   1 1         a n d   a . c o n s t r a i n t _ n a m e   =   b . c o n s t r a i n t _ n a m e   1     s e l e c t   a . t a b l e _ n a m e ,     2                   a . c o n s t r a i n t _ n a m e ,     3                   b . c o l u m n _ n a m e ,     4                   a . c o n s t r a i n t _ t y p e     5         f r o m   i n f o r m a t i o n _ s c h e m a . t a b l e _ c o n s t r a i n t s   a ,     6                   i n f o r m a t i o n _ s c h e m a . k e y _ c o l u m n _ u s a g e   b     7     w h e r e   a . t a b l e _ n a m e             =   ' E M P '     8         a n d   a . t a b l e _ s c h e m a         =   ' S M E A G O L '     9         a n d   a . t a b l e _ n a m e             =   b . t a b l e _ n a m e   1 0         a n d   a . t a b l e _ s c h e m a         =   b . t a b l e _ s c h e m a   1 1         a n d   a . c o n s t r a i n t _ n a m e   =   b . c o n s t r a i n t _ n a m e  Constraints are such a critical part of relational databases that it should go without saying why you need to know what constraints are on your tables. Listing the constraints on tables is useful for a variety of reasons: you may want to find tables missing a primary key, you may want to find which columns should be foreign keys but are not  i.e., child tables have data different from the parent tables and you want to know how that happened , or you may want to know about check constraints  Are columns nullable? Do they have to satisfy a specific condition? etc. .  5.5 Listing Foreign Keys Without Corresponding Indexes  Problem You want to list tables that have foreign key columns that are not indexed. For example, you want to determine whether the foreign keys on table EMP are indexed.  Solution  DB2 Query SYSCAT.TABCONST, SYSCAT.KEYCOLUSE, SYSCAT.INDEXES, and SYSCAT.INDEXCOLUSE:    1     s e l e c t   f k e y s . t a b n a m e ,     2                   f k e y s . c o n s t n a m e ,     3                   f k e y s . c o l n a m e ,     4                   i n d _ c o l s . i n d n a m e     5         f r o m         6     s e l e c t   a . t a b s c h e m a ,   a . t a b n a m e ,   a . c o n s t n a m e ,   b . c o l n a m e     7         f r o m   s y s c a t . t a b c o n s t   a ,     8                   s y s c a t . k e y c o l u s e   b     9     w h e r e   a . t a b n a m e         =   ' E M P '   1 0         a n d   a . t a b s c h e m a     =   ' S M E A G O L '   1 1         a n d   a . t y p e               =   ' F '   1 2         a n d   a . t a b n a m e         =   b . t a b n a m e   1 3         a n d   a . t a b s c h e m a     =   b . t a b s c h e m a    Oracle Query SYS.ALL_CONS_COLUMNS, SYS.ALL_CONSTRAINTS, and SYS.ALL_IND_COLUMNS:  PostgreSQL Query INFORMATION_SCHEMA.KEY_COLUMN_USAGE, INFORMATION_ SCHEMA.REFERENTIAL_CONSTRAINTS,  1 4                     f k e y s   1 5                 l e f t   j o i n   1 6                     1 7     s e l e c t   a . t a b s c h e m a ,   1 8                   a . t a b n a m e ,   1 9                   a . i n d n a m e ,   2 0                   b . c o l n a m e   2 1         f r o m   s y s c a t . i n d e x e s   a ,   2 2                   s y s c a t . i n d e x c o l u s e   b   2 3     w h e r e   a . i n d s c h e m a     =   b . i n d s c h e m a   2 4         a n d   a . i n d n a m e         =   b . i n d n a m e   2 5                     i n d _ c o l s   2 6           o n     f k e y s . t a b s c h e m a   =   i n d _ c o l s . t a b s c h e m a   2 7                     a n d   f k e y s . t a b n a m e       =   i n d _ c o l s . t a b n a m e   2 8                     a n d   f k e y s . c o l n a m e       =   i n d _ c o l s . c o l n a m e       2 9     w h e r e   i n d _ c o l s . i n d n a m e   i s   n u l l   1     s e l e c t   a . t a b l e _ n a m e ,     2                   a . c o n s t r a i n t _ n a m e ,     3                   a . c o l u m n _ n a m e ,     4                   c . i n d e x _ n a m e     5         f r o m   a l l _ c o n s _ c o l u m n s   a ,     6                   a l l _ c o n s t r a i n t s   b ,     7                   a l l _ i n d _ c o l u m n s   c     8     w h e r e   a . t a b l e _ n a m e             =   ' E M P '     9         a n d   a . o w n e r                       =   ' S M E A G O L '   1 0         a n d   b . c o n s t r a i n t _ t y p e   =   ' R '   1 1         a n d   a . o w n e r                       =   b . o w n e r   1 2         a n d   a . t a b l e _ n a m e             =   b . t a b l e _ n a m e   1 3         a n d   a . c o n s t r a i n t _ n a m e   =   b . c o n s t r a i n t _ n a m e   1 4         a n d   a . o w n e r                       =   c . t a b l e _ o w n e r     +     1 5         a n d   a . t a b l e _ n a m e             =   c . t a b l e _ n a m e     +     1 6         a n d   a . c o l u m n _ n a m e           =   c . c o l u m n _ n a m e     +     1 7         a n d   c . i n d e x _ n a m e             i s   n u l l  INFORMATION_SCHEMA.COLUMNS, and PG_CATALOG.PG_INDEXES:  MySQL You can use the SHOW INDEX command to retrieve index information such as index name, columns in the index, and ordinal position of the columns in the index. Additionally, you can query INFORMATION_SCHEMA.KEY_COLUMN_USAGE to list the foreign keys for a given table. In MySQL 5, foreign keys are said to be indexed automatically, but can in fact be dropped. To determine whether a foreign key column’s index has been dropped, you can execute SHOW INDEX for a particular table and compare the output with that of INFORMATION_SCHEMA.KEY_    1     s e l e c t   f k e y s . t a b l e _ n a m e ,     2                   f k e y s . c o n s t r a i n t _ n a m e ,     3                   f k e y s . c o l u m n _ n a m e ,     4                   i n d _ c o l s . i n d e x n a m e     5         f r o m         6     s e l e c t   a . c o n s t r a i n t _ s c h e m a ,     7                   a . t a b l e _ n a m e ,     8                   a . c o n s t r a i n t _ n a m e ,     9                   a . c o l u m n _ n a m e   1 0         f r o m   i n f o r m a t i o n _ s c h e m a . k e y _ c o l u m n _ u s a g e   a ,   1 1                   i n f o r m a t i o n _ s c h e m a . r e f e r e n t i a l _ c o n s t r a i n t s   b   1 2       w h e r e   a . c o n s t r a i n t _ n a m e       =   b . c o n s t r a i n t _ n a m e   1 3           a n d   a . c o n s t r a i n t _ s c h e m a   =   b . c o n s t r a i n t _ s c h e m a   1 4           a n d   a . c o n s t r a i n t _ s c h e m a   =   ' S M E A G O L '   1 5           a n d   a . t a b l e _ n a m e                 =   ' E M P '   1 6                       f k e y s   1 7                   l e f t   j o i n   1 8                       1 9     s e l e c t   a . s c h e m a n a m e ,   a . t a b l e n a m e ,   a . i n d e x n a m e ,   b . c o l u m n _ n a m e   2 0         f r o m   p g _ c a t a l o g . p g _ i n d e x e s   a ,   2 1                   i n f o r m a t i o n _ s c h e m a . c o l u m n s   b   2 2       w h e r e   a . t a b l e n a m e     =   b . t a b l e _ n a m e   2 3           a n d   a . s c h e m a n a m e   =   b . t a b l e _ s c h e m a   2 4                       i n d _ c o l s   2 5             o n         f k e y s . c o n s t r a i n t _ s c h e m a   =   i n d _ c o l s . s c h e m a n a m e   2 6                       a n d   f k e y s . t a b l e _ n a m e           =   i n d _ c o l s . t a b l e n a m e   2 7                       a n d   f k e y s . c o l u m n _ n a m e         =   i n d _ c o l s . c o l u m n _ n a m e       2 8       w h e r e   i n d _ c o l s . i n d e x n a m e   i s   n u l l  COLUMN_USAGE.COLUMN_NAME for the same table. If the COLUMN_NAME is listed in KEY_COLUMN_USAGE but is not returned by SHOW INDEX, you know that column is not indexed.  SQL Server Query SYS.TABLES, SYS.FOREIGN_KEYS, SYS.COLUMNS, SYS.INDEXES, and SYS.INDEX_COLUMNS:    1     s e l e c t   f k e y s . t a b l e _ n a m e ,     2                   f k e y s . c o n s t r a i n t _ n a m e ,     3                   f k e y s . c o l u m n _ n a m e ,     4                   i n d _ c o l s . i n d e x _ n a m e     5         f r o m         6     s e l e c t   a . o b j e c t _ i d ,     7                   d . c o l u m n _ i d ,     8                   a . n a m e   t a b l e _ n a m e ,     9                   b . n a m e   c o n s t r a i n t _ n a m e ,   1 0                   d . n a m e   c o l u m n _ n a m e   1 1         f r o m   s y s . t a b l e s   a   1 2                   j o i n   1 3                   s y s . f o r e i g n _ k e y s   b   1 4             o n       a . n a m e                     =   ' E M P '   1 5                       a n d   a . o b j e c t _ i d   =   b . p a r e n t _ o b j e c t _ i d   1 6                       1 7                   j o i n   1 8                   s y s . f o r e i g n _ k e y _ c o l u m n s   c   1 9           o n         b . o b j e c t _ i d   =   c . c o n s t r a i n t _ o b j e c t _ i d       2 0                 j o i n   2 1                 s y s . c o l u m n s   d   2 2           o n             c . c o n s t r a i n t _ c o l u m n _ i d   =   d . c o l u m n _ i d   2 3                   a n d   a . o b j e c t _ i d                         =   d . o b j e c t _ i d   2 4                     2 5                     f k e y s   2 6                 l e f t   j o i n   2 7                     2 8   s e l e c t   a . n a m e   i n d e x _ n a m e ,   2 9                 b . o b j e c t _ i d ,   3 0                 b . c o l u m n _ i d   3 1       f r o m   s y s . i n d e x e s   a ,   3 2                 s y s . i n d e x _ c o l u m n s   b   3 3     w h e r e   a . i n d e x _ i d   =   b . i n d e x _ i d   3 4                     i n d _ c o l s   3 5           o n               f k e y s . o b j e c t _ i d   =   i n d _ c o l s . o b j e c t _ i d    Discussion Each vendor uses its own locking mechanism when modifying rows. In cases where there is a parent-child relationship enforced via foreign key, having indexes on the child column s  can reducing locking  see your specific RDBMS documentation for details . In other cases, it is common that a child table is joined to a parent table on the foreign key column, so an index may help improve performance in that scenario as well.  5.6 Using SQL to Generate SQL  Problem You want to create dynamic SQL statements, perhaps to automate maintenance tasks. You want to accomplish three tasks in particular: count the number of rows in your tables, disable foreign key constraints defined on your tables, and generate insert scripts from the data in your tables.  Solution The concept is to use strings to build SQL statements, and the values that need to be filled in  such as the object name the command acts upon  will be supplied by data from the tables you are selecting from. Keep in mind, the queries only generate the statements; you must then run these statements via script, manually, or however you execute your SQL statements. The following examples are queries that would work on an Oracle system. For other RDBMSs the technique is exactly the same, the only difference being things like the names of the data dictionary tables and date formatting. The output shown from the queries that follow are a portion of the rows returned from an instance of Oracle on my laptop. Your result sets will of course vary:  3 6                     a n d   f k e y s . c o l u m n _ i d   =   i n d _ c o l s . c o l u m n _ i d       3 7     w h e r e   i n d _ c o l s . i n d e x _ n a m e   i s   n u l l    *   g e n e r a t e   S Q L   t o   c o u n t   a l l   t h e   r o w s   i n   a l l   y o u r   t a b l e s   *       s e l e c t   ' s e l e c t   c o u n t   *     f r o m   '   t a b l e _ n a m e   ' ; '   c n t s       f r o m   u s e r _ t a b l e s ;     C N T S   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   s e l e c t   c o u n t   *     f r o m   A N T ;   s e l e c t   c o u n t   *     f r o m   B O N U S ;   s e l e c t   c o u n t   *     f r o m   D E M O 1 ;   s e l e c t   c o u n t   *     f r o m   D E M O 2 ;   s e l e c t   c o u n t   *     f r o m   D E P T ;   s e l e c t   c o u n t   *     f r o m   D U M M Y ;   s e l e c t   c o u n t   *     f r o m   E M P ;   s e l e c t   c o u n t   *     f r o m   E M P _ S A L E S ;   s e l e c t   c o u n t   *     f r o m   E M P _ S C O R E ;   s e l e c t   c o u n t   *     f r o m   P R O F E S S O R ;   s e l e c t   c o u n t   *     f r o m   T ;   s e l e c t   c o u n t   *     f r o m   T 1 ;   s e l e c t   c o u n t   *     f r o m   T 2 ;   s e l e c t   c o u n t   *     f r o m   T 3 ;   s e l e c t   c o u n t   *     f r o m   T E A C H ;   s e l e c t   c o u n t   *     f r o m   T E S T ;   s e l e c t   c o u n t   *     f r o m   T R X _ L O G ;   s e l e c t   c o u n t   *     f r o m   X ;       *   d i s a b l e   f o r e i g n   k e y s   f r o m   a l l   t a b l e s   *       s e l e c t   ' a l t e r   t a b l e   '   t a b l e _ n a m e                   '   d i s a b l e   c o n s t r a i n t   '   c o n s t r a i n t _ n a m e   ' ; '   c o n s       f r o m   u s e r _ c o n s t r a i n t s     w h e r e   c o n s t r a i n t _ t y p e   =   ' R ' ;     C O N S   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   a l t e r   t a b l e   A N T   d i s a b l e   c o n s t r a i n t   A N T _ F K ;   a l t e r   t a b l e   B O N U S   d i s a b l e   c o n s t r a i n t   B O N U S _ F K ;   a l t e r   t a b l e   D E M O 1   d i s a b l e   c o n s t r a i n t   D E M O 1 _ F K ;   a l t e r   t a b l e   D E M O 2   d i s a b l e   c o n s t r a i n t   D E M O 2 _ F K ;   a l t e r   t a b l e   D E P T   d i s a b l e   c o n s t r a i n t   D E P T _ F K ;   a l t e r   t a b l e   D U M M Y   d i s a b l e   c o n s t r a i n t   D U M M Y _ F K ;   a l t e r   t a b l e   E M P   d i s a b l e   c o n s t r a i n t   E M P _ F K ;   a l t e r   t a b l e   E M P _ S A L E S   d i s a b l e   c o n s t r a i n t   E M P _ S A L E S _ F K ;   a l t e r   t a b l e   E M P _ S C O R E   d i s a b l e   c o n s t r a i n t   E M P _ S C O R E _ F K ;   a l t e r   t a b l e   P R O F E S S O R   d i s a b l e   c o n s t r a i n t   P R O F E S S O R _ F K ;       *   g e n e r a t e   a n   i n s e r t   s c r i p t   f r o m   s o m e   c o l u m n s   i n   t a b l e   E M P   *        Discussion Using SQL to generate SQL is particularly useful for creating portable scripts such as you might use when testing on multiple environments. Additionally, as can be seen by the previous examples, using SQL to generate SQL is useful for performing batch maintenance, and for easily finding out information about multiple objects in one go. Generating SQL with SQL is an extremely simple operation, and the more you experiment with it, the easier it will become. The examples provided should give you a nice base on how to build your own “dynamic” SQL scripts because, quite frankly, there’s not much to it. Work on it and you’ll get it.  5.7 Describing the Data Dictionary Views in an Oracle Database  Problem You are using Oracle. You can’t remember what data dictionary views are available to you, nor can you remember their column definitions. Worse yet, you do not have convenient access to vendor documentation.  s e l e c t   ' i n s e r t   i n t o   e m p   e m p n o , e n a m e , h i r e d a t e     '   c h r   1 0                     ' v a l u e s     '   e m p n o   ' , '   ' ' ' '   e n a m e                   ' ' ' , t o _ d a t e   '   ' ' ' '   h i r e d a t e   ' ' '       ; '   i n s e r t s       f r o m   e m p     w h e r e   d e p t n o   =   1 0 ;     I N S E R T S   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   i n s e r t   i n t o   e m p   e m p n o , e n a m e , h i r e d a t e     v a l u e s     7 7 8 2 , ' C L A R K ' , t o _ d a t e   ' 0 9 - J U N - 2 0 0 6   0 0 : 0 0 : 0 0 '       ;     i n s e r t   i n t o   e m p   e m p n o , e n a m e , h i r e d a t e     v a l u e s     7 8 3 9 , ' K I N G ' , t o _ d a t e   ' 1 7 - N O V - 2 0 0 6   0 0 : 0 0 : 0 0 '       ;     i n s e r t   i n t o   e m p   e m p n o , e n a m e , h i r e d a t e     v a l u e s     7 9 3 4 , ' M I L L E R ' , t o _ d a t e   ' 2 3 - J A N - 2 0 0 7   0 0 : 0 0 : 0 0 '       ;  Solution This is an Oracle-specific recipe. Not only does Oracle maintain a robust set of data dictionary views, but there are also data dictionary views to document the data dictionary views. It’s all so wonderfully circular. Query the view named DICTIONARY to list data dictionary views and their purposes:  Query DICT_COLUMNS to describe the columns in a given data dictionary view:  Discussion  s e l e c t   t a b l e _ n a m e ,   c o m m e n t s       f r o m   d i c t i o n a r y       o r d e r   b y   t a b l e _ n a m e ;     T A B L E _ N A M E                                           C O M M E N T S   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   A L L _ A L L _ T A B L E S                                   D e s c r i p t i o n   o f   a l l   o b j e c t   a n d   r e l a t i o n a l                                                                 t a b l e s   a c c e s s i b l e   t o   t h e   u s e r     A L L _ A P P L Y                                             D e t a i l s   a b o u t   e a c h   a p p l y   p r o c e s s   t h a t                                                                 d e q u e u e s   f r o m   t h e   q u e u e   v i s i b l e   t o   t h e                                                                 c u r r e n t   u s e r   … s e l e c t   c o l u m n _ n a m e ,   c o m m e n t s             f r o m   d i c t _ c o l u m n s     w h e r e   t a b l e _ n a m e   =   ' A L L _ T A B _ C O L U M N S ' ;     C O L U M N _ N A M E                                           C O M M E N T S   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   O W N E R   T A B L E _ N A M E                                             T a b l e ,   v i e w   o r   c l u s t e r   n a m e   C O L U M N _ N A M E                                           C o l u m n   n a m e   D A T A _ T Y P E                                               D a t a t y p e   o f   t h e   c o l u m n   D A T A _ T Y P E _ M O D                                       D a t a t y p e   m o d i f i e r   o f   t h e   c o l u m n   D A T A _ T Y P E _ O W N E R                                   O w n e r   o f   t h e   d a t a t y p e   o f   t h e   c o l u m n   D A T A _ L E N G T H                                           L e n g t h   o f   t h e   c o l u m n   i n   b y t e s   D A T A _ P R E C I S I O N                                     L e n g t h :   d e c i m a l   d i g i t s     N U M B E R     o r   b i n a r y                                                                   d i g i t s     F L O A T    Back in the day, when Oracle’s documentation set wasn’t so freely available on the web, it was incredibly convenient that Oracle made the DICTIONARY and DICT_ COLUMNS views available. Knowing just those two views, you could bootstrap to learning about all the other views and then shift to learning about your entire database. Even today, it’s convenient to know about DICTIONARY and DICT_COLUMNS. Often, if you aren’t quite certain which view describes a given object type, you can issue a wildcard query to find out. For example, to get a handle on what views might describe tables in your schema:  This query returns all data dictionary view names that include the term TABLE. This approach takes advantage of Oracle’s fairly consistent data dictionary view naming conventions. Views describing tables are all likely to contain TABLE in their name.  Sometimes, as in the case of ALL_TAB_COLUMNS, TABLE is abbreviated TAB.   5.8 Summing Up Queries on metadata open up a range of possibilities for letting SQL do more of the work than you, and they relieve some of the need to know your database. This is especially useful as you deal with more complex databases with similarly complex structures.  s e l e c t   t a b l e _ n a m e ,   c o m m e n t s       f r o m   d i c t i o n a r y     w h e r e   t a b l e _ n a m e   L I K E   ' % T A B L E % '     o r d e r   b y   t a b l e _ n a m e ;  Chapter 6. Working with Strings  This chapter focuses on string manipulation in SQL. Keep in mind that SQL is not designed to perform complex string manipulation, and you can  and will  find working with strings in SQL to be cumbersome and frustrating at times. Despite SQL’s limitations, there are some useful built-in functions provided by the different DBMSs, and we’ve tried to use them in creative ways. This chapter in particular is representative of the message we tried to convey in the introduction; SQL is the good, the bad, and the ugly. Hopefully you take away from this chapter a better appreciation for what can and can’t be done in SQL when working with strings. In many cases you’ll be surprised by how easy parsing and transforming strings can be, while at other times you’ll be aghast by the kind of SQL that is necessary to accomplish a particular task. Many of the recipes that follow use the TRANSLATE and REPLACE functions that are now available in all the DBMSs covered in this book, with the exception of MySQL, which only has r e. In this last case, it is worth noting early on that you can replicate the effect of TRANSLATE by using nested REPLACE functions. The first recipe in this chapter is critically important, as it is leveraged by several of the subsequent solutions. In many cases, you’d like to have the ability to traverse a string by moving through it a character at a time. Unfortunately, SQL does not make this easy. Because there is limited loop functionality in SQL, you need to mimic a loop to traverse a string. We call this operation “walking a string” or “walking through a string,” and the very first recipe explains the technique. This is a fundamental operation in string parsing when using SQL, and is referenced and used by almost all recipes in this chapter. We strongly suggest becoming comfortable with how the technique works.  e p l a c  6.1 Walking a String  Problem You want to traverse a string to return each character as a row, but SQL lacks a loop operation. For example, you want to display the ENAME “KING” from table EMP as four rows, where each row contains just characters from KING.  Solution Use a Cartesian product to generate the number of rows needed to return each character of a string on its own line. Then use your DBMS’s built-in string parsing function to extract the characters you are interested in  SQL Server users will use SUBSTRING instead of SUBSTR and DATALENGTH instead of LENGTH :  Discussion The key to iterating through a string’s characters is to join against a table that has enough rows to produce the required number of iterations. This example uses table T10, which contains 10 rows  it has one column, ID, holding the values 1 through 10 . The maximum number of rows that can be returned from this query is 10.  1   s e l e c t   s u b s t r   e . e n a m e , i t e r . p o s , 1     a s   C   2       f r o m     s e l e c t   e n a m e   f r o m   e m p   w h e r e   e n a m e   =   ' K I N G '     e ,   3                   s e l e c t   i d   a s   p o s   f r o m   t 1 0     i t e r   4     w h e r e   i t e r . p o s   < =   l e n g t h   e . e n a m e         C   -   K   I   N   G  The following example shows the Cartesian product between E and ITER  i.e., between the specific name and the 10 rows from T10  without parsing ENAME:  The cardinality of inline view E is 1, and the cardinality of inline view ITER is 10. The Cartesian product is then 10 rows. Generating such a product is the first step in mimicking a loop in SQL.  It is common practice to refer to table T10 as a “pivot” table.  TIP  The solution uses a WHERE clause to break out of the loop after four rows have been returned. To restrict the result set to the same number of rows as there are characters in the name, that WHERE clause specifies ITER.POS <= LENGTH E. ENAME  as the condition:  s e l e c t   e n a m e ,   i t e r . p o s       f r o m     s e l e c t   e n a m e   f r o m   e m p   w h e r e   e n a m e   =   ' K I N G '     e ,                   s e l e c t   i d   a s   p o s   f r o m   t 1 0     i t e r     E N A M E                           P O S   - - - - - - - - - -   - - - - - - - - - -   K I N G                                 1   K I N G                                 2   K I N G                                 3   K I N G                                 4   K I N G                                 5   K I N G                                 6   K I N G                                 7   K I N G                                 8   K I N G                                 9   K I N G                               1 0 s e l e c t   e n a m e ,   i t e r . p o s       f r o m     s e l e c t   e n a m e   f r o m   e m p   w h e r e   e n a m e   =   ' K I N G '     e ,                   s e l e c t   i d   a s   p o s   f r o m   t 1 0     i t e r     w h e r e   i t e r . p o s   < =   l e n g t h   e . e n a m e        Now that you have one row for each character in E.ENAME, you can use ITER.POS as a parameter to SUBSTR, allowing you to navigate through the characters in the string. ITER.POS increments with each row, and thus each row can be made to return a successive character from E.ENAME. This is how the solution example works. Depending on what you are trying to accomplish, you may or may not need to generate a row for every single character in a string. The following query is an example of walking E.ENAME and exposing different portions  more than a single character  of the string:  The most common scenarios for the recipes in this chapter involve walking the whole string to generate a row for each character in the string, or walking the string such that the number of rows generated reflects the number of particular characters or delimiters that are present in the string.  6.2 Embedding Quotes Within String Literals  E N A M E                           P O S   - - - - - - - - - -   - - - - - - - - - -   K I N G                                 1   K I N G                                 2   K I N G                                 3   K I N G                                 4 s e l e c t   s u b s t r   e . e n a m e , i t e r . p o s     a ,                 s u b s t r   e . e n a m e , l e n g t h   e . e n a m e   - i t e r . p o s + 1     b       f r o m     s e l e c t   e n a m e   f r o m   e m p   w h e r e   e n a m e   =   ' K I N G '     e ,                   s e l e c t   i d   p o s   f r o m   t 1 0     i t e r     w h e r e   i t e r . p o s   < =   l e n g t h   e . e n a m e         A                     B   - - - - - - - - - -   - - - - - - - - - -   K I N G               G   I N G                 N G   N G                   I N G   G                     K I N G  Problem You want to embed quote marks within string literals. You would like to produce results such as the following with SQL:  Solution The following three SELECTs highlight different ways you can create quotes: in the middle of a string and by themselves:  Discussion When working with quotes, it’s often useful to think of them like parentheses. When you have an opening parenthesis, you must always have a closing parenthesis. The same goes for quotes. Keep in mind that you should always have an even number of quotes across any given string. To embed a single quote within a string, you need to use two quotes:  The following is the solution stripped down to its bare elements. You have two outer quotes defining a string literal, and within that string literal, you have two quotes that together represent just one quote in the string that you actually get:  Q M A R K S   - - - - - - - - - - - - - -   g ' d a y   m a t e   b e a v e r s '   t e e t h   ' 1   s e l e c t   ' g ' ' d a y   m a t e '   q m a r k s   f r o m   t 1   u n i o n   a l l   2   s e l e c t   ' b e a v e r s ' '   t e e t h '         f r o m   t 1   u n i o n   a l l   3   s e l e c t   ' ' ' '                                   f r o m   t 1 s e l e c t   ' a p p l e s   c o r e ' ,   ' a p p l e ' ' s   c o r e ' ,                   c a s e   w h e n   ' '   i s   n u l l   t h e n   0   e l s e   1   e n d       f r o m   t 1       ' A P P L E S C O R E   ' A P P L E ' ' S C O R   C A S E W H E N ' ' I S N U L L T H E N 0 E L S E 1 E N D     - - - - - - - - - - -   - - - - - - - - - - - -   - - - - - - - - - - - - - - - - - - - - - - - - - - - - -     a p p l e s   c o r e   a p p l e ' s   c o r e                                                           0  When working with quotes, be sure to remember that a string literal comprising two quotes alone, with no intervening characters, is NULL.  6.3 Counting the Occurrences of a Character in a String  Problem You want to count the number of times a character or substring occurs within a given string. Consider the following string:  You want to determine how many commas are in the string.  Solution Subtract the length of the string without the commas from the original length of the string to determine the number of commas in the string. Each DBMS provides functions for obtaining the length of a string and removing characters from a string. In most cases, these functions are LENGTH and REPLACE, respectively  SQL Server users will use the built-in function LEN rather than LENGTH :  Discussion  s e l e c t   ' ' ' '   a s   q u o t e   f r o m   t 1     Q   -   ' 1 0 , C L A R K , M A N A G E R 1   s e l e c t     l e n g t h   ' 1 0 , C L A R K , M A N A G E R '   -   2                 l e n g t h   r e p l a c e   ' 1 0 , C L A R K , M A N A G E R ' , ' , ' , ' '         l e n g t h   ' , '     3                 a s   c n t   4       f r o m   t 1  You arrive at the solution by using simple subtraction. The call to LENGTH on line 1 returns the original size of the string, and the first call to LENGTH on line 2 returns the size of the string without the commas, which are removed by REPLACE. By subtracting the two lengths, you obtain the difference in terms of characters, which is the number of commas in the string. The last operation divides the difference by the length of your search string. This division is necessary if the string you are looking for has a length greater than 1. In the following example, counting the occurrence of “LL” in the string “HELLO HELLO” without dividing will return an incorrect result:  6.4 Removing Unwanted Characters from a String  Problem You want to remove specific characters from your data. A scenario where this may occur is in dealing with badly formatted numeric data, especially currency data, where commas have been used to separate zeros, and currency markers are mixed in the column with the quantity. Another scenario is that you want to export data from your database as a CSV file, but there is a text field containing commas, which will be read as separators when the CSV file is accessed. Consider this result set:  s e l e c t                   l e n g t h   ' H E L L O   H E L L O '   -                 l e n g t h   r e p l a c e   ' H E L L O   H E L L O ' , ' L L ' , ' '         l e n g t h   ' L L '                   a s   c o r r e c t _ c n t ,                   l e n g t h   ' H E L L O   H E L L O '   -                 l e n g t h   r e p l a c e   ' H E L L O   H E L L O ' , ' L L ' , ' '         a s   i n c o r r e c t _ c n t       f r o m   t 1     C O R R E C T _ C N T   I N C O R R E C T _ C N T   - - - - - - - - - - -   - - - - - - - - - - - - -                       2                           4  You want to remove all zeros and vowels as shown by the following values in columns STRIPPED1 and STRIPPED2:  Solution Each DBMS provides functions for removing unwanted characters from a string. The functions REPLACE and TRANSLATE are most useful for this problem.  DB2, Oracle, PostgreSQL, and SQL Server  E N A M E                           S A L   - - - - - - - - - -   - - - - - - - - - -   S M I T H                           8 0 0   A L L E N                         1 6 0 0   W A R D                           1 2 5 0   J O N E S                         2 9 7 5   M A R T I N                       1 2 5 0   B L A K E                         2 8 5 0   C L A R K                         2 4 5 0   S C O T T                         3 0 0 0   K I N G                           5 0 0 0   T U R N E R                       1 5 0 0   A D A M S                         1 1 0 0   J A M E S                           9 5 0   F O R D                           3 0 0 0   M I L L E R                       1 3 0 0 E N A M E             S T R I P P E D 1                   S A L   S T R I P P E D 2   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - -   S M I T H             S M T H                             8 0 0   8   A L L E N             L L N                             1 6 0 0   1 6   W A R D               W R D                             1 2 5 0   1 2 5   J O N E S             J N S                             2 9 7 5   2 9 7 5   M A R T I N           M R T N                           1 2 5 0   1 2 5   B L A K E             B L K                             2 8 5 0   2 8 5   C L A R K             C L R K                           2 4 5 0   2 4 5   S C O T T             S C T T                           3 0 0 0   3   K I N G               K N G                             5 0 0 0   5   T U R N E R           T R N R                           1 5 0 0   1 5   A D A M S             D M S                             1 1 0 0   1 1   J A M E S             J M S                               9 5 0   9 5   F O R D               F R D                             3 0 0 0   3   M I L L E R           M L L R                           1 3 0 0   1 3  Use the built-in functions TRANSLATE and REPLACE to remove unwanted characters and strings:  Note that for DB2, the AS keyword is optional for assigning a column alias and can be left out.  MySQL MySQL does not offer a TRANSLATE function, so several calls to REPLACE are needed:  Discussion The built-in function REPLACE removes all occurrences of zeros. To remove the vowels, use TRANSLATE to convert all vowels into one specific character  we used “a”; you can use any character ; then use REPLACE to remove all occurrences of that character.  6.5 Separating Numeric and Character Data  Problem  1   s e l e c t   e n a m e ,   2                 r e p l a c e   t r a n s l a t e   e n a m e , ' a a a a a ' , ' A E I O U '   , ' a ' , ' '     a s   s t r i p p e d 1 ,   3                 s a l ,   4                 r e p l a c e   c a s t   s a l   a s   c h a r   4     , ' 0 ' , ' '     a s   s t r i p p e d 2   5       f r o m   e m p   1   s e l e c t   e n a m e ,     2                 r e p l a c e       3                 r e p l a c e       4                 r e p l a c e       5                 r e p l a c e       6                 r e p l a c e   e n a m e , ' A ' , ' '   , ' E ' , ' '   , ' I ' , ' '   , ' O ' , ' '   , ' U ' , ' '       7                 a s   s t r i p p e d 1 ,     8                 s a l ,     9                 r e p l a c e   s a l , 0 , ' '     s t r i p p e d 2   1 0       f r o m   e m p  You have numeric data stored with character data together in one column. This could easily happen if you inherit data where units of measurement or currency have been stored with their quantity  e.g., a column with 100 km, AUD$200, or 40 pounds, rather than either the column making the units clear or a separate column showing the units where necessary . You want to separate the character data from the numeric data. Consider the following result set:  You would like the result to be:  D A T A   - - - - - - - - - - - - - - -   S M I T H 8 0 0   A L L E N 1 6 0 0   W A R D 1 2 5 0   J O N E S 2 9 7 5   M A R T I N 1 2 5 0   B L A K E 2 8 5 0   C L A R K 2 4 5 0   S C O T T 3 0 0 0   K I N G 5 0 0 0   T U R N E R 1 5 0 0   A D A M S 1 1 0 0   J A M E S 9 5 0   F O R D 3 0 0 0   M I L L E R 1 3 0 0 E N A M E                           S A L   - - - - - - - - - -   - - - - - - - - - -   S M I T H                           8 0 0   A L L E N                         1 6 0 0   W A R D                           1 2 5 0   J O N E S                         2 9 7 5   M A R T I N                       1 2 5 0   B L A K E                         2 8 5 0   C L A R K                         2 4 5 0   S C O T T                         3 0 0 0   K I N G                           5 0 0 0   T U R N E R                       1 5 0 0   A D A M S                         1 1 0 0   J A M E S                           9 5 0   F O R D                           3 0 0 0   M I L L E R                       1 3 0 0  Solution Use the built-in functions TRANSLATE and REPLACE to isolate the character from the numeric data. Like other recipes in this chapter, the trick is to use TRANSLATE to transform multiple characters into a single character you can reference. This way you are no longer searching for multiple numbers or characters; rather, you are searching for just one character to represent all numbers or one character to represent all characters.  DB2 Use the functions TRANSLATE and REPLACE to isolate and separate the numeric from the character data:  Oracle Use the functions TRANSLATE and REPLACE to isolate and separate the numeric from the character data:    1   s e l e c t   r e p l a c e       2             t r a n s l a t e   d a t a , ' 0 0 0 0 0 0 0 0 0 0 ' , ' 0 1 2 3 4 5 6 7 8 9 '   , ' 0 ' , ' '     e n a m e ,     3                 c a s t       4             r e p l a c e       5         t r a n s l a t e   l o w e r   d a t a   , r e p e a t   ' z ' , 2 6   ,     6                       ' a b c d e f g h i j k l m n o p q r s t u v w x y z '   , ' z ' , ' '     a s   i n t e g e r     s a l     7         f r o m         8     s e l e c t   e n a m e   c a s t   s a l   a s   c h a r   4       d a t a     9         f r o m   e m p   1 0                       x   1   s e l e c t   r e p l a c e       2             t r a n s l a t e   d a t a , ' 0 1 2 3 4 5 6 7 8 9 ' , ' 0 0 0 0 0 0 0 0 0 0 '   , ' 0 '     e n a m e ,     3             t o _ n u m b e r       4                 r e p l a c e       5                 t r a n s l a t e   l o w e r   d a t a   ,     6                                     ' a b c d e f g h i j k l m n o p q r s t u v w x y z ' ,     7                                       r p a d   ' z ' , 2 6 , ' z '     , ' z '       s a l     8       f r o m         9   s e l e c t   e n a m e   s a l   d a t a   1 0       f r o m   e m p   1 1                    PostgreSQL Use the functions TRANSLATE and REPLACE to isolate and separate the numeric from the character data:  SQL Server Use the functions TRANSLATE and REPLACE to isolate and separate the numeric from the character data:  Discussion The syntax is a bit different for each DBMS, but the technique is the same. The syntax is slightly different for each DBMS, but the technique is the same; we will use the Oracle solution for this discussion. The key to solving this problem is to isolate the numeric and character data. You can use TRANSLATE and REPLACE to do this. To extract the numeric data, first isolate all character data using TRANSLATE:    1   s e l e c t   r e p l a c e       2             t r a n s l a t e   d a t a , ' 0 1 2 3 4 5 6 7 8 9 ' , ' 0 0 0 0 0 0 0 0 0 0 '   , ' 0 ' , ' '     a s   e n a m e ,     3                       c a s t       4                 r e p l a c e       5             t r a n s l a t e   l o w e r   d a t a   ,     6                                 ' a b c d e f g h i j k l m n o p q r s t u v w x y z ' ,     7                                 r p a d   ' z ' , 2 6 , ' z '     , ' z ' , ' '     a s   i n t e g e r     a s   s a l     8       f r o m         9   s e l e c t   e n a m e   s a l   a s   d a t a   1 0       f r o m   e m p   1 1                     x   1   s e l e c t   r e p l a c e       2             t r a n s l a t e   d a t a , ' 0 1 2 3 4 5 6 7 8 9 ' , ' 0 0 0 0 0 0 0 0 0 0 '   , ' 0 ' , ' '     a s   e n a m e ,     3                       c a s t       4                 r e p l a c e       5             t r a n s l a t e   l o w e r   d a t a   ,     6                                 ' a b c d e f g h i j k l m n o p q r s t u v w x y z ' ,     7                                 r e p l i c a t e   ' z ' , 2 6   , ' z ' , ' '     a s   i n t e g e r     a s   s a l     8       f r o m         9   s e l e c t   c o n c a t   e n a m e , s a l     a s   d a t a   1 0       f r o m   e m p   1 1                     x  By using TRANSLATE you convert every nonnumeric character into a lowercase Z. The next step is to remove all instances of lowercase Z from each record using REPLACE, leaving only numerical characters that can then be cast to a number:  s e l e c t   d a t a ,                 t r a n s l a t e   l o w e r   d a t a   ,                                   ' a b c d e f g h i j k l m n o p q r s t u v w x y z ' ,                                   r p a d   ' z ' , 2 6 , ' z '       s a l       f r o m     s e l e c t   e n a m e   s a l   d a t a   f r o m   e m p       D A T A                                   S A L   - - - - - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - - - - - -   S M I T H 8 0 0                           z z z z z 8 0 0   A L L E N 1 6 0 0                         z z z z z 1 6 0 0   W A R D 1 2 5 0                           z z z z 1 2 5 0   J O N E S 2 9 7 5                         z z z z z 2 9 7 5   M A R T I N 1 2 5 0                       z z z z z z 1 2 5 0   B L A K E 2 8 5 0                         z z z z z 2 8 5 0   C L A R K 2 4 5 0                         z z z z z 2 4 5 0   S C O T T 3 0 0 0                         z z z z z 3 0 0 0   K I N G 5 0 0 0                           z z z z 5 0 0 0   T U R N E R 1 5 0 0                       z z z z z z 1 5 0 0   A D A M S 1 1 0 0                         z z z z z 1 1 0 0   J A M E S 9 5 0                           z z z z z 9 5 0   F O R D 3 0 0 0                           z z z z 3 0 0 0   M I L L E R 1 3 0 0                       z z z z z z 1 3 0 0 s e l e c t   d a t a ,                 t o _ n u m b e r                       r e p l a c e                   t r a n s l a t e   l o w e r   d a t a   ,                                     ' a b c d e f g h i j k l m n o p q r s t u v w x y z ' ,                                     r p a d   ' z ' , 2 6 , ' z '     , ' z '       s a l       f r o m     s e l e c t   e n a m e   s a l   d a t a   f r o m   e m p         D A T A                                                 S A L     - - - - - - - - - - - - - - - - - - - -   - - - - - - - - - -     S M I T H 8 0 0                                         8 0 0     A L L E N 1 6 0 0                                     1 6 0 0     W A R D 1 2 5 0                                       1 2 5 0     J O N E S 2 9 7 5                                     2 9 7 5     M A R T I N 1 2 5 0                                   1 2 5 0     B L A K E 2 8 5 0                                     2 8 5 0     C L A R K 2 4 5 0                                     2 4 5 0    To extract the nonnumeric characters, isolate the numeric characters using TRANSLATE:  By using TRANSLATE, you convert every numeric character into a zero. The next step is to remove all instances of zero from each record using REPLACE, leaving only nonnumeric characters:    S C O T T 3 0 0 0                                     3 0 0 0     K I N G 5 0 0 0                                       5 0 0 0     T U R N E R 1 5 0 0                                   1 5 0 0     A D A M S 1 1 0 0                                     1 1 0 0     J A M E S 9 5 0                                         9 5 0     F O R D 3 0 0 0                                       3 0 0 0     M I L L E R 1 3 0 0                                   1 3 0 0 s e l e c t   d a t a ,                 t r a n s l a t e   d a t a , ' 0 1 2 3 4 5 6 7 8 9 ' , ' 0 0 0 0 0 0 0 0 0 0 '     e n a m e       f r o m     s e l e c t   e n a m e   s a l   d a t a   f r o m   e m p         D A T A                                   E N A M E     - - - - - - - - - - - - - - - - - - - -   - - - - - - - - - -     S M I T H 8 0 0                           S M I T H 0 0 0     A L L E N 1 6 0 0                         A L L E N 0 0 0 0     W A R D 1 2 5 0                           W A R D 0 0 0 0     J O N E S 2 9 7 5                         J O N E S 0 0 0 0     M A R T I N 1 2 5 0                       M A R T I N 0 0 0 0     B L A K E 2 8 5 0                         B L A K E 0 0 0 0     C L A R K 2 4 5 0                         C L A R K 0 0 0 0     S C O T T 3 0 0 0                         S C O T T 0 0 0 0     K I N G 5 0 0 0                           K I N G 0 0 0 0     T U R N E R 1 5 0 0                       T U R N E R 0 0 0 0     A D A M S 1 1 0 0                         A D A M S 0 0 0 0     J A M E S 9 5 0                           J A M E S 0 0 0     F O R D 3 0 0 0                           F O R D 0 0 0 0     M I L L E R 1 3 0 0                       M I L L E R 0 0 0 0 s e l e c t   d a t a ,                 r e p l a c e   t r a n s l a t e   d a t a , ' 0 1 2 3 4 5 6 7 8 9 ' , ' 0 0 0 0 0 0 0 0 0 0 '   , ' 0 '     e n a m e       f r o m     s e l e c t   e n a m e   s a l   d a t a   f r o m   e m p         D A T A                                   E N A M E     - - - - - - - - - - - - - - - - - - - -   - - - - - - -     S M I T H 8 0 0                           S M I T H     A L L E N 1 6 0 0                         A L L E N    Put the two techniques together and you have your solution.  6.6 Determining Whether a String Is Alphanumeric  Problem You want to return rows from a table only when a column of interest contains no characters other than numbers and letters. Consider the following view V  SQL Server users will use the operator + for concatenation instead of  :  The view V represents your table, and it returns the following:    W A R D 1 2 5 0                           W A R D     J O N E S 2 9 7 5                         J O N E S     M A R T I N 1 2 5 0                       M A R T I N     B L A K E 2 8 5 0                         B L A K E     C L A R K 2 4 5 0                         C L A R K     S C O T T 3 0 0 0                         S C O T T     K I N G 5 0 0 0                           K I N G     T U R N E R 1 5 0 0                       T U R N E R     A D A M S 1 1 0 0                         A D A M S     J A M E S 9 5 0                           J A M E S     F O R D 3 0 0 0                           F O R D     M I L L E R 1 3 0 0                       M I L L E R c r e a t e   v i e w   V   a s   s e l e c t   e n a m e   a s   d a t a       f r o m   e m p     w h e r e   d e p t n o = 1 0     u n i o n   a l l   s e l e c t   e n a m e   ' ,   $ '     c a s t   s a l   a s   c h a r   4         ' . 0 0 '   a s   d a t a       f r o m   e m p     w h e r e   d e p t n o = 2 0     u n i o n   a l l   s e l e c t   e n a m e     c a s t   d e p t n o   a s   c h a r   4       a s   d a t a       f r o m   e m p     w h e r e   d e p t n o = 3 0  However, from the view’s data you want to return only the following records:  In short, you want to omit those rows containing data other than letters and digits.  Solution It may seem intuitive at first to solve the problem by searching for all the possible non-alphanumeric characters that can be found in a string, but, on the contrary, you will find it easier to do the exact opposite: find all the alphanumeric characters. By doing so, you can treat all the alphanumeric characters as one by converting them to one single character. The reason  D A T A   - - - - - - - - - - - - - - - - - - - -   C L A R K   K I N G   M I L L E R   S M I T H ,   $ 8 0 0 . 0 0   J O N E S ,   $ 2 9 7 5 . 0 0   S C O T T ,   $ 3 0 0 0 . 0 0   A D A M S ,   $ 1 1 0 0 . 0 0   F O R D ,   $ 3 0 0 0 . 0 0   A L L E N 3 0   W A R D 3 0   M A R T I N 3 0   B L A K E 3 0   T U R N E R 3 0   J A M E S 3 0 D A T A   - - - - - - - - - - - - -   C L A R K   K I N G   M I L L E R   A L L E N 3 0   W A R D 3 0   M A R T I N 3 0   B L A K E 3 0   T U R N E R 3 0   J A M E S 3 0  you want to do this is so the alphanumeric characters can be manipulated together, as a whole. Once you’ve generated a copy of the string in which all alphanumeric characters are represented by a single character of your choosing, it is easy to isolate the alphanumeric characters from any other characters.  DB2 Use the function TRANSLATE to convert all alphanumeric characters to a single character; then identify any rows that have characters other than the converted alphanumeric character. For DB2 users, the CAST function calls in view V are necessary; otherwise, the view cannot be created due to type conversion errors. Take extra care when working with casts to CHAR as they are fixed length  padded :  MySQL The syntax for view V is slightly different in MySQL:  Use a regular expression to easily find rows that contain non-alphanumeric data:  1   s e l e c t   d a t a   2       f r o m   V   3     w h e r e   t r a n s l a t e   l o w e r   d a t a   ,   4                                     r e p e a t   ' a ' , 3 6   ,   5                                     ' 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v w x y z '     =   6                                     r e p e a t   ' a ' , l e n g t h   d a t a     c r e a t e   v i e w   V   a s   s e l e c t   e n a m e   a s   d a t a       f r o m   e m p     w h e r e   d e p t n o = 1 0     u n i o n   a l l   s e l e c t   c o n c a t   e n a m e , ' ,   $ ' , s a l , ' . 0 0 '     a s   d a t a       f r o m   e m p     w h e r e   d e p t n o = 2 0     u n i o n   a l l   s e l e c t   c o n c a t   e n a m e , d e p t n o     a s   d a t a       f r o m   e m p     w h e r e   d e p t n o = 3 0  Oracle and PostgreSQL Use the function TRANSLATE to convert all alphanumeric characters to a single character; then identify any rows that have characters other than the converted alphanumeric character. The CAST function calls in view V are not needed for Oracle and PostgreSQL. Take extra care when working with casts to CHAR as they are fixed length  padded . If you decide to cast, cast to VARCHAR or VARCHAR2:  SQL Server The technique is the same, with the exception of there being no RPAD in SQL Server:  Discussion The key to these solutions is being able to reference multiple characters concurrently. By using the function TRANSLATE, you can easily manipulate all numbers or all characters without having to “iterate” and inspect each character one by one.  DB2, Oracle, PostgreSQL, and SQL Server  1   s e l e c t   d a t a   2       f r o m   V   3     w h e r e   d a t a   r e g e x p   ' [ ^ 0 - 9 a - z A - Z ] '   =   0 1   s e l e c t   d a t a   2       f r o m   V   3     w h e r e   t r a n s l a t e   l o w e r   d a t a   ,   4                                     ' 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v w x y z ' ,   5                                     r p a d   ' a ' , 3 6 , ' a '       =   r p a d   ' a ' , l e n g t h   d a t a   , ' a '   1   s e l e c t   d a t a   2       f r o m   V   3     w h e r e   t r a n s l a t e   l o w e r   d a t a   ,   4                                     ' 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v w x y z ' ,   5                                     r e p l i c a t e   ' a ' , 3 6       =   r e p l i c a t e   ' a ' , l e n   d a t a      Only 9 of the 14 rows from view V are alphanumeric. To find the rows that are alphanumeric only, simply use the function TRANSLATE. In this example, TRANSLATE converts characters 0–9 and a–z to “a”. Once the conversion is done, the converted row is then compared with a string of all “a” with the same length  as the row . If the length is the same, then you know all the characters are alphanumeric and nothing else. By using the TRANSLATE function  using the Oracle syntax :  you convert all numbers and letters into a distinct character  we chose “a” . Once the data is converted, all strings that are indeed alphanumeric can be identified as a string comprising only a single character  in this case, “a” . This can be seen by running TRANSLATE by itself:  The alphanumeric values are converted, but the string lengths have not been modified. Because the lengths are the same, the rows to keep are the ones for which the call to TRANSLATE returns all “a"s. You keep those rows, rejecting the others, by comparing each original string’s length with the length of its corresponding string of “a"s:  w h e r e   t r a n s l a t e   l o w e r   d a t a   ,                                   ' 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v w x y z ' ,                                     r p a d   ' a ' , 3 6 , ' a '     s e l e c t   d a t a ,   t r a n s l a t e   l o w e r   d a t a   ,                                       ' 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v w x y z ' ,                                         r p a d   ' a ' , 3 6 , ' a '           f r o m   V     D A T A                                   T R A N S L A T E   L O W E R   D A T A     - - - - - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - - - - - - - -   C L A R K                                 a a a a a   …   S M I T H ,   $ 8 0 0 . 0 0               a a a a a ,   $ a a a . a a   …   A L L E N 3 0                             a a a a a a a   … s e l e c t   d a t a ,   t r a n s l a t e   l o w e r   d a t a   ,                                       ' 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v w x y z ' ,    The last step is to keep only the strings where TRANSLATED equals FIXED.  MySQL The expression in the WHERE clause:  causes rows that have only numbers or characters to be returned. The value ranges in the brackets, “0-9a-zA-Z”, represent all possible numbers and letters. The character ^ is for negation, so the expression can be stated as “not numbers or letters.” A return value of 1 is true and 0 is false, so the whole expression can be stated as “return rows where anything other than numbers and letters is false.”  6.7 Extracting Initials from a Name  Problem You want convert a full name into initials. Consider the following name:  You would like to return:                                        r p a d   ' a ' , 3 6 , ' a '       t r a n s l a t e d ,                   r p a d   ' a ' , l e n g t h   d a t a   , ' a '     f i x e d       f r o m   V     D A T A                                   T R A N S L A T E D                       F I X E D   - - - - - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - - -   C L A R K                                 a a a a a                                 a a a a a   …   S M I T H ,   $ 8 0 0 . 0 0               a a a a a ,   $ a a a . a a               a a a a a a a a a a a a a a   …   A L L E N 3 0                             a a a a a a a                             a a a a a a a   … w h e r e   d a t a   r e g e x p   ' [ ^ 0 - 9 a - z A - Z ] '   =   0 S t e w i e   G r i f f i n  Solution It’s important to keep in mind that SQL does not provide the flexibility of languages such as C or Python; therefore, creating a generic solution to deal with any name format is not something particularly easy to do in SQL. The solutions presented here expect the names to be either first and last name, or first, middle name middle initial, and last name.  DB2 Use the built-in functions REPLACE, TRANSLATE, and REPEAT to extract the initials:  MySQL Use the built-in functions CONCAT, CONCAT_WS, SUBSTRING, and SUBSTRING_ INDEX to extract the initials:  S . G . 1   s e l e c t   r e p l a c e     2                 r e p l a c e     3                 t r a n s l a t e   r e p l a c e   ' S t e w i e   G r i f f i n ' ,   ' . ' ,   ' '   ,   4                                     r e p e a t   '  ' , 2 6   ,   5                                     ' a b c d e f g h i j k l m n o p q r s t u v w x y z '   ,   6                                       '  ' , ' '     ,   '   ' , ' . '       7                                       ' . '   8       f r o m   t 1   1   s e l e c t   c a s e     2                     w h e n   c n t   =   2   t h e n     3                         t r i m   t r a i l i n g   ' . '   f r o m     4                                   c o n c a t _ w s   ' . ' ,     5                                     s u b s t r   s u b s t r i n g _ i n d e x   n a m e , '   ' , 1   , 1 , 1   ,     6                                     s u b s t r   n a m e ,     7                                                   l e n g t h   s u b s t r i n g _ i n d e x   n a m e , '   ' , 1     + 2 , 1   ,     8                                     s u b s t r   s u b s t r i n g _ i n d e x   n a m e , '   ' , - 1   , 1 , 1   ,     9                                     ' . '       1 0                     e l s e   1 1                         t r i m   t r a i l i n g   ' . '   f r o m   1 2                                   c o n c a t _ w s   ' . ' ,   1 3                                     s u b s t r   s u b s t r i n g _ i n d e x   n a m e , '   ' , 1   , 1 , 1   ,   1 4                                     s u b s t r   s u b s t r i n g _ i n d e x   n a m e , '   ' , - 1   , 1 , 1      Oracle and PostgreSQL Use the built-in functions REPLACE, TRANSLATE, and RPAD to extract the initials:  SQL Server  Discussion By isolating the capital letters, you can extract the initials from a name. The following sections describe each vendor-specific solution in detail.  DB2 The REPLACE function will remove any periods in the name  to handle middle initials , and the TRANSLATE function will convert all non- uppercase letters to .  1 5                                           1 6                     e n d   a s   i n i t i a l s   1 7       f r o m       1 8   s e l e c t   n a m e , l e n g t h   n a m e   - l e n g t h   r e p l a c e   n a m e , '   ' , ' '       a s   c n t   1 9       f r o m       2 0   s e l e c t   r e p l a c e   ' S t e w i e   G r i f f i n ' , ' . ' , ' '     a s   n a m e   f r o m   t 1   2 1                   y   2 2                   x 1   s e l e c t   r e p l a c e     2                 r e p l a c e     3                 t r a n s l a t e   r e p l a c e   ' S t e w i e   G r i f f i n ' ,   ' . ' ,   ' '   ,   4                                     ' a b c d e f g h i j k l m n o p q r s t u v w x y z ' ,   5                                     r p a d   '  ' , 2 6 , '  '       ,   '  ' , ' '     , '   ' , ' . '         ' . '   6       f r o m   t 1 1   s e l e c t   r e p l a c e     2                 r e p l a c e     3                 t r a n s l a t e   r e p l a c e   ' S t e w i e   G r i f f i n ' ,   ' . ' ,   ' '   ,   4                                     ' a b c d e f g h i j k l m n o p q r s t u v w x y z ' ,   5                                     r e p l i c a t e   '  ' , 2 6       ,   '  ' , ' '     , '   ' , ' . '       +   ' . '   6       f r o m   t 1  At this point, the initials are the characters that are not . The function REPLACE is then used to remove all the  characters:  The next step is to replace the white space with a period by using REPLACE again:  The final step is to append a decimal to the end of the initials.  Oracle and PostgreSQL The REPLACE function will remove any periods in the name  to handle middle initials , and the TRANSLATE function will convert all non-  s e l e c t   t r a n s l a t e   r e p l a c e   ' S t e w i e   G r i f f i n ' ,   ' . ' ,   ' '   ,                                     r e p e a t   '  ' , 2 6   ,                                     ' a b c d e f g h i j k l m n o p q r s t u v w x y z '         f r o m   t 1     T R A N S L A T E   ' S T E   - - - - - - - - - - - - - -   S        G       s e l e c t   r e p l a c e                   t r a n s l a t e   r e p l a c e   ' S t e w i e   G r i f f i n ' ,   ' . ' ,   ' '   ,                                       r e p e a t   '  ' , 2 6   ,                                       ' a b c d e f g h i j k l m n o p q r s t u v w x y z '   , '  ' , ' '         f r o m   t 1       R E P   - - -   S   G s e l e c t   r e p l a c e                     r e p l a c e                     t r a n s l a t e   r e p l a c e   ' S t e w i e   G r i f f i n ' ,   ' . ' ,   ' '   ,                                       r e p e a t   '  ' , 2 6   ,                                     ' a b c d e f g h i j k l m n o p q r s t u v w x y z '   , '  ' , ' '   , '   ' , ' . '         ' . '         f r o m   t 1       R E P L A     - - - - -     S . G  uppercase letters to .  At this point, the initials are the characters that are not . The function REPLACE is then used to remove all the  characters:  The next step is to replace the white space with a period by using REPLACE again:  The final step is to append a decimal to the end of the initials.  MySQL  s e l e c t   t r a n s l a t e   r e p l a c e   ' S t e w i e   G r i f f i n ' , ' . ' , ' '   ,                                     ' a b c d e f g h i j k l m n o p q r s t u v w x y z ' ,                                     r p a d   '  ' , 2 6 , '  '           f r o m   t 1     T R A N S L A T E   ' S T E   - - - - - - - - - - - - - -   S        G       s e l e c t   r e p l a c e                   t r a n s l a t e   r e p l a c e   ' S t e w i e   G r i f f i n ' , ' . ' , ' '   ,                                     ' a b c d e f g h i j k l m n o p q r s t u v w x y z ' ,                                       r p a d   '  ' , 2 6 , '  '     , '  ' , ' '         f r o m   t 1     R E P   - - -   S   G s e l e c t   r e p l a c e                   r e p l a c e               t r a n s l a t e   r e p l a c e   ' S t e w i e   G r i f f i n ' , ' . ' , ' '   ,                                 ' a b c d e f g h i j k l m n o p q r s t u v w x y z ' ,                                 r p a d   '  ' , 2 6 , '  '       , '  ' , ' '   , '   ' , ' . '         ' . '       f r o m   t 1     R E P L A   - - - - -   S . G  The inline view Y is used to remove any period from the name. The inline view X finds the number of white spaces in the name so the SUBSTR function can be called the correct number of times to extract the initials. The three calls to SUBSTRING_ INDEX parse the string into individual names based on the location of the white space. Because there is only a first and last name, the code in the ELSE portion of the case statement is executed:  If the name in question has a middle name or initial, the initial would be returned by executing:  which finds the end of the first name and then moves two spaces to the beginning of the middle name or initial, that is, the start position for SUBSTR. Because only one character is kept, the middle name or initial is successfully returned. The initials are then passed to CONCAT_WS, which separates the initials by a period:  The last step is to trim the extraneous period from the initials.  s e l e c t   s u b s t r   s u b s t r i n g _ i n d e x   n a m e ,   '   ' , 1   , 1 , 1     a s   a ,                 s u b s t r   s u b s t r i n g _ i n d e x   n a m e , '   ' , - 1   , 1 , 1     a s   b       f r o m     s e l e c t   ' S t e w i e   G r i f f i n '   a s   n a m e   f r o m   t 1     x     A   B   -   -   S   G s u b s t r   n a m e , l e n g t h   s u b s t r i n g _ i n d e x   n a m e ,   '   ' , 1     + 2 , 1   s e l e c t   c o n c a t _ w s   ' . ' ,                                     s u b s t r   s u b s t r i n g _ i n d e x   n a m e ,   '   ' , 1   , 1 , 1   ,                                     s u b s t r   s u b s t r i n g _ i n d e x   n a m e , '   ' , - 1   , 1 , 1   ,                                     ' . '       a       f r o m     s e l e c t   ' S t e w i e   G r i f f i n '   a s   n a m e   f r o m   t 1     x     A   - - - - -   S . G . .  6.8 Ordering by Parts of a String  Problem You want to order your result set based on a substring. Consider the following records:  You want the records to be ordered based on the last two characters of each name:  E N A M E   - - - - - - - - - -   S M I T H   A L L E N   W A R D   J O N E S   M A R T I N   B L A K E   C L A R K   S C O T T   K I N G   T U R N E R   A D A M S   J A M E S   F O R D   M I L L E R E N A M E   - - - - - - - - -   A L L E N   T U R N E R   M I L L E R   J O N E S   J A M E S   M A R T I N   B L A K E   A D A M S   K I N G   W A R D   F O R D   C L A R K   S M I T H   S C O T T  Solution The key to this solution is to find and use your DBMS’s built-in function to extract the substring on which you want to sort. This is typically done with the SUBSTR function.  DB2, Oracle, MySQL, and PostgreSQL Use a combination of the built-in functions LENGTH and SUBSTR to order by a specific part of a string:  SQL Server Use functions SUBSTRING and LEN to order by a specific part of a string:  Discussion By using a SUBSTR expression in your ORDER BY clause, you can pick any part of a string to use in ordering a result set. You’re not limited to SUBSTR either. You can order rows by the result of almost any expression.  6.9 Ordering by a Number in a String  Problem You want order your result set based on a number within a string. Consider the following view:  1   s e l e c t   e n a m e   2       f r o m   e m p   3     o r d e r   b y   s u b s t r   e n a m e , l e n g t h   e n a m e   - 1 ,   1   s e l e c t   e n a m e   2       f r o m   e m p   3     o r d e r   b y   s u b s t r i n g   e n a m e , l e n   e n a m e   - 1 , 2   c r e a t e   v i e w   V   a s   s e l e c t   e . e n a m e     '   '                     c a s t   e . e m p n o   a s   c h a r   4       '   '      This view returns the following data:  You want to order the results based on the employee number, which falls between the employee name and respective department:  Solution                  d . d n a m e   a s   d a t a       f r o m   e m p   e ,   d e p t   d     w h e r e   e . d e p t n o = d . d e p t n o D A T A     - - - - - - - - - - - - - - - - - - - - - - - - - - - -     C L A R K       7 7 8 2   A C C O U N T I N G     K I N G         7 8 3 9   A C C O U N T I N G     M I L L E R     7 9 3 4   A C C O U N T I N G     S M I T H       7 3 6 9   R E S E A R C H     J O N E S       7 5 6 6   R E S E A R C H     S C O T T       7 7 8 8   R E S E A R C H     A D A M S       7 8 7 6   R E S E A R C H     F O R D         7 9 0 2   R E S E A R C H     A L L E N       7 4 9 9   S A L E S     W A R D         7 5 2 1   S A L E S     M A R T I N     7 6 5 4   S A L E S     B L A K E       7 6 9 8   S A L E S     T U R N E R     7 8 4 4   S A L E S     J A M E S       7 9 0 0   S A L E S D A T A   - - - - - - - - - - - - - - - - - - - - - - - - - - -   S M I T H         7 3 6 9   R E S E A R C H   A L L E N         7 4 9 9   S A L E S   W A R D           7 5 2 1   S A L E S   J O N E S         7 5 6 6   R E S E A R C H   M A R T I N       7 6 5 4   S A L E S   B L A K E         7 6 9 8   S A L E S   C L A R K         7 7 8 2   A C C O U N T I N G   S C O T T         7 7 8 8   R E S E A R C H   K I N G           7 8 3 9   A C C O U N T I N G   T U R N E R       7 8 4 4   S A L E S   A D A M S         7 8 7 6   R E S E A R C H   J A M E S         7 9 0 0   S A L E S   F O R D           7 9 0 2   R E S E A R C H   M I L L E R       7 9 3 4   A C C O U N T I N G  Each solution uses functions and syntax specific to its DBMS, but the method  making use of the built-in functions REPLACE and TRANSLATE  is the same for each. The idea is to use REPLACE and TRANSLATE to remove nondigits from the strings, leaving only the numeric values upon which to sort.  DB2 Use the built-in functions REPLACE and TRANSLATE to order by numeric characters in a string:  Oracle Use the built-in functions REPLACE and TRANSLATE to order by numeric characters in a string:  PostgreSQL Use the built-in functions REPLACE and TRANSLATE to order by numeric characters in a string:  1   s e l e c t   d a t a   2       f r o m   V   3     o r d e r   b y   4                   c a s t     5             r e p l a c e     6         t r a n s l a t e   d a t a , r e p e a t   '  ' , l e n g t h   d a t a     ,   7             r e p l a c e     8         t r a n s l a t e   d a t a , '           ' , ' 0 1 2 3 4 5 6 7 8 9 '   ,   9                           '  ' , ' '     , '  ' , ' '     a s   i n t e g e r   1   s e l e c t   d a t a   2       f r o m   V   3     o r d e r   b y   4                   t o _ n u m b e r     5                       r e p l a c e     6                   t r a n s l a t e   d a t a ,   7                       r e p l a c e     8                   t r a n s l a t e   d a t a , ' 0 1 2 3 4 5 6 7 8 9 ' , '           '   ,   9                                     '  '   , r p a d   '  ' , 2 0 , '  '     , '  '      MySQL As of the time of this writing, MySQL does not provide the TRANSLATE function.  Discussion The purpose of view V is only to supply rows on which to demonstrate this recipe’s solution. The view simply concatenates several columns from the EMP table. The solution shows how to take such concatenated text as input and sort it by the employee number embedded within. The ORDER BY clause in each solution may look intimidating, but it performs quite well and is straightforward once you examine it piece by piece. To order by the numbers in the string, it’s easiest to remove any characters that are not numbers. Once the nonnumeric characters are removed, all that is left to do is cast the string of numerals into a number and then sort as you see fit. Before examining each function call, it is important to understand the order in which each function is called. Starting with the innermost call, TRANSLATE  line 8 from each of the original solutions , you see that: From the innermost call, the sequence of steps is TRANSLATE  line 8 ; REPLACE  line 7  ; TRANSLATE  line 6 ; REPLACE  line 5 . The final step is to use CAST to return the result as a number. The first step is to convert the numbers into characters that do not exist in the rest of the string. For this example, we chose  and used TRANSLATE to convert all nonnumeric characters into occurrences of . For example, the  1   s e l e c t   d a t a   2       f r o m   V   3     o r d e r   b y   4                   c a s t     5             r e p l a c e     6         t r a n s l a t e   d a t a ,   7             r e p l a c e     8         t r a n s l a t e   d a t a , ' 0 1 2 3 4 5 6 7 8 9 ' , '           '   ,   9                           '  ' , ' '   , r p a d   '  ' , 2 0 , '  '     , '  ' , ' '     a s   i n t e g e r    following query shows the original data on the left and the results from the first translation:  TRANSLATE finds the numerals in each string and converts each one to the  character. The modified strings are then returned to REPLACE  line 11 , which removes all occurrences of :  s e l e c t   d a t a ,                 t r a n s l a t e   d a t a , ' 0 1 2 3 4 5 6 7 8 9 ' , '           '     a s   t m p       f r o m   V     D A T A                                                       T M P     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - - - - - - - - - -     C L A R K       7 7 8 2   A C C O U N T I N G                 C L A R K             A C C O U N T I N G     K I N G         7 8 3 9   A C C O U N T I N G                 K I N G               A C C O U N T I N G     M I L L E R     7 9 3 4   A C C O U N T I N G                 M I L L E R           A C C O U N T I N G     S M I T H       7 3 6 9   R E S E A R C H                     S M I T H             R E S E A R C H     J O N E S       7 5 6 6   R E S E A R C H                     J O N E S             R E S E A R C H     S C O T T       7 7 8 8   R E S E A R C H                     S C O T T             R E S E A R C H     A D A M S       7 8 7 6   R E S E A R C H                     A D A M S             R E S E A R C H     F O R D         7 9 0 2   R E S E A R C H                     F O R D               R E S E A R C H     A L L E N       7 4 9 9   S A L E S                           A L L E N             S A L E S     W A R D         7 5 2 1   S A L E S                           W A R D               S A L E S     M A R T I N     7 6 5 4   S A L E S                           M A R T I N           S A L E S     B L A K E       7 6 9 8   S A L E S                           B L A K E             S A L E S     T U R N E R   7 8 4 4   S A L E S                             T U R N E R           S A L E S     J A M E S     7 9 0 0   S A L E S                             J A M E S             S A L E S s e l e c t   d a t a ,   r e p l a c e     t r a n s l a t e   d a t a , ' 0 1 2 3 4 5 6 7 8 9 ' , '           '   , '  '     a s   t m p       f r o m   V     D A T A                                                       T M P     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - - - - - -     C L A R K       7 7 8 2   A C C O U N T I N G                 C L A R K       A C C O U N T I N G     K I N G         7 8 3 9   A C C O U N T I N G                 K I N G         A C C O U N T I N G     M I L L E R     7 9 3 4   A C C O U N T I N G                 M I L L E R     A C C O U N T I N G     S M I T H       7 3 6 9   R E S E A R C H                     S M I T H       R E S E A R C H     J O N E S       7 5 6 6   R E S E A R C H                     J O N E S       R E S E A R C H     S C O T T       7 7 8 8   R E S E A R C H                     S C O T T       R E S E A R C H     A D A M S       7 8 7 6   R E S E A R C H                     A D A M S       R E S E A R C H     F O R D         7 9 0 2   R E S E A R C H                     F O R D         R E S E A R C H     A L L E N       7 4 9 9   S A L E S                           A L L E N       S A L E S    The strings are then returned to TRANSLATE once again, but this time it’s the second  outermost  TRANSLATE in the solution. TRANSLATE searches the original string for any characters that match the characters in TMP. If any are found, they too are converted to s. This conversion allows all nonnumeric characters to be treated as a single character  because they are all transformed to the same character :  The next step is to remove all  characters through a call to REPLACE  line 8 , leaving you with only numbers:    W A R D         7 5 2 1   S A L E S                           W A R D         S A L E S     M A R T I N     7 6 5 4   S A L E S                           M A R T I N     S A L E S     B L A K E       7 6 9 8   S A L E S                           B L A K E       S A L E S     T U R N E R     7 8 4 4   S A L E S                           T U R N E R     S A L E S     J A M E S       7 9 0 0   S A L E S                           J A M E S       S A L E S s e l e c t   d a t a ,   t r a n s l a t e   d a t a ,                             r e p l a c e                               t r a n s l a t e   d a t a , ' 0 1 2 3 4 5 6 7 8 9 ' , '           '   ,                             '  '   ,                             r p a d   '  ' , l e n g t h   d a t a   , '  '       a s   t m p       f r o m   V     D A T A                                                       T M P   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - - - - - - - - - - - - - -   C L A R K       7 7 8 2   A C C O U N T I N G                         7 7 8 2              K I N G         7 8 3 9   A C C O U N T I N G                         7 8 3 9              M I L L E R     7 9 3 4   A C C O U N T I N G                         7 9 3 4              S M I T H       7 3 6 9   R E S E A R C H                             7 3 6 9            J O N E S       7 5 6 6   R E S E A R C H                             7 5 6 6            S C O T T       7 7 8 8   R E S E A R C H                             7 7 8 8            A D A M S       7 8 7 6   R E S E A R C H                             7 8 7 6            F O R D         7 9 0 2   R E S E A R C H                             7 9 0 2            A L L E N       7 4 9 9   S A L E S                                   7 4 9 9         W A R D         7 5 2 1   S A L E S                                   7 5 2 1         M A R T I N     7 6 5 4   S A L E S                                   7 6 5 4         B L A K E       7 6 9 8   S A L E S                                   7 6 9 8         T U R N E R     7 8 4 4   S A L E S                                   7 8 4 4         J A M E S       7 9 0 0   S A L E S                                   7 9 0 0       s e l e c t   d a t a ,   r e p l a c e                               t r a n s l a t e   d a t a ,    Finally, cast TMP to a number  line 4  using the appropriate DBMS function  often CAST  to accomplish this:                            r e p l a c e                           t r a n s l a t e   d a t a , ' 0 1 2 3 4 5 6 7 8 9 ' , '           '   ,                                             '  '   ,                                             r p a d   '  ' , l e n g t h   d a t a   , '  '     , '  '     a s   t m p       f r o m   V     D A T A                                                       T M P   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   - - - - - - - - - - -   C L A R K       7 7 8 2   A C C O U N T I N G                 7 7 8 2   K I N G         7 8 3 9   A C C O U N T I N G                 7 8 3 9   M I L L E R     7 9 3 4   A C C O U N T I N G                 7 9 3 4   S M I T H       7 3 6 9   R E S E A R C H                     7 3 6 9   J O N E S       7 5 6 6   R E S E A R C H                     7 5 6 6   S C O T T       7 7 8 8   R E S E A R C H                     7 7 8 8   A D A M S       7 8 7 6   R E S E A R C H                     7 8 7 6   F O R D         7 9 0 2   R E S E A R C H                     7 9 0 2   A L L E N       7 4 9 9   S A L E S                           7 4 9 9   W A R D         7 5 2 1   S A L E S                           7 5 2 1   M A R T I N     7 6 5 4   S A L E S                           7 6 5 4   B L A K E       7 6 9 8   S A L E S                           7 6 9 8   T U R N E R     7 8 4 4   S A L E S                           7 8 4 4   J A M E S       7 9 0 0   S A L E S                           7 9 0 0 s e l e c t   d a t a ,   t o _ n u m b e r                                 r e p l a c e                               t r a n s l a t e   d a t a ,                             r e p l a c e                   t r a n s l a t e   d a t a , ' 0 1 2 3 4 5 6 7 8 9 ' , '           '   ,                                     '  '   ,                                     r p a d   '  ' , l e n g t h   d a t a   , '  '     , '  '       a s   t m p       f r o m   V     D A T A                                                                     T M P   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   - - - - - - - - - -   C L A R K       7 7 8 2   A C C O U N T I N G                             7 7 8 2   K I N G         7 8 3 9   A C C O U N T I N G                             7 8 3 9   M I L L E R     7 9 3 4   A C C O U N T I N G                             7 9 3 4   S M I T H       7 3 6 9   R E S E A R C H                                 7 3 6 9   J O N E S       7 5 6 6   R E S E A R C H                                 7 5 6 6   S C O T T       7 7 8 8   R E S E A R C H                                 7 7 8 8   A D A M S       7 8 7 6   R E S E A R C H                                 7 8 7 6   F O R D         7 9 0 2   R E S E A R C H                                 7 9 0 2   A L L E N       7 4 9 9   S A L E S                                       7 4 9 9    When developing queries like this, it’s helpful to work with your expressions in the SELECT list. That way, you can easily view the intermediate results as you work toward a final solution. However, because the point of this recipe is to order the results, ultimately you should place all the function calls into the ORDER BY clause:  As a final note, the data in the view is comprised of three fields, only one being numeric. Keep in mind that if there had been multiple numeric fields,  W A R D         7 5 2 1   S A L E S                                       7 5 2 1   M A R T I N     7 6 5 4   S A L E S                                       7 6 5 4   B L A K E       7 6 9 8   S A L E S                                       7 6 9 8   T U R N E R     7 8 4 4   S A L E S                                       7 8 4 4   J A M E S       7 9 0 0   S A L E S                                       7 9 0 0 s e l e c t   d a t a       f r o m   V     o r d e r   b y                   t o _ n u m b e r                         r e p l a c e                     t r a n s l a t e     d a t a ,                       r e p l a c e                     t r a n s l a t e     d a t a , ' 0 1 2 3 4 5 6 7 8 9 ' , '           '   ,                                       '  '   , r p a d   '  ' , l e n g t h   d a t a   , '  '     , '  '           D A T A   - - - - - - - - - - - - - - - - - - - - - - - - - - -   S M I T H       7 3 6 9   R E S E A R C H   A L L E N       7 4 9 9   S A L E S   W A R D         7 5 2 1   S A L E S   J O N E S       7 5 6 6   R E S E A R C H   M A R T I N     7 6 5 4   S A L E S   B L A K E       7 6 9 8   S A L E S   C L A R K       7 7 8 2   A C C O U N T I N G   S C O T T       7 7 8 8   R E S E A R C H   K I N G         7 8 3 9   A C C O U N T I N G   T U R N E R     7 8 4 4   S A L E S   A D A M S       7 8 7 6   R E S E A R C H   J A M E S       7 9 0 0   S A L E S   F O R D         7 9 0 2   R E S E A R C H   M I L L E R     7 9 3 4   A C C O U N T I N G  they would have all been concatenated into one number before the rows were sorted.  6.10 Creating a Delimited List from Table Rows  Problem You want to return table rows as values in a delimited list, perhaps delimited by commas, rather than in vertical columns as they normally appear. You want to convert a result set from this:  to this:  Solution  D E P T N O   E M P S   - - - - - -   - - - - - - - - - -           1 0   C L A R K           1 0   K I N G           1 0   M I L L E R           2 0   S M I T H           2 0   A D A M S           2 0   F O R D           2 0   S C O T T           2 0   J O N E S           3 0   A L L E N           3 0   B L A K E           3 0   M A R T I N           3 0   J A M E S           3 0   T U R N E R           3 0   W A R D   D E P T N O   E M P S   - - - - - - -   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -             1 0   C L A R K , K I N G , M I L L E R             2 0   S M I T H , J O N E S , S C O T T , A D A M S , F O R D             3 0   A L L E N , W A R D , M A R T I N , B L A K E , T U R N E R , J A M E S  Each DBMS requires a different approach to this problem. The key is to take advantage of the built-in functions provided by your DBMS. Understanding what is available to you will allow you to exploit your DBMS’s functionality and come up with creative solutions for a problem that is typically not solved in SQL. Most DBMSs have now adopted a function specifically designed to concatenate strings, such as MySQL’s GROUP_CONCAT function  one of the earliest  or STRING_ADD  added to SQL Server as recently as SQL Server 2017 . These functions have similar syntax, and make this task straightforward.  DB2 Use LIST_AGG to build the delimited list:  MySQL Use the built-in function GROUP_CONCAT to build the delimited list:  Oracle Use the built-in function SYS_CONNECT_BY_PATH to build the delimited list:  1   s e l e c t   d e p t n o ,   2                 l i s t _ a g g   e n a m e   ' , '     w i t h i n   G R O U P   O r d e r   b y   0     a s   e m p s   3       f r o m   e m p   4     g r o u p   b y   d e p t n o 1   s e l e c t   d e p t n o ,   2                 g r o u p _ c o n c a t   e n a m e   o r d e r   b y   e m p n o   s e p a r a t o r ,   ' , '     a s   e m p s   3       f r o m   e m p   4     g r o u p   b y   d e p t n o   1   s e l e c t   d e p t n o ,     2                 l t r i m   s y s _ c o n n e c t _ b y _ p a t h   e n a m e , ' , '   , ' , '     e m p s     3       f r o m         4   s e l e c t   d e p t n o ,     5                 e n a m e ,     6                 r o w _ n u m b e r       o v e r    PostgreSQL and SQL Server  Discussion Being able to create delimited lists in SQL is useful because it is a common requirement. The SQL:2016 standard added LIST_AGG to perform this task, but only DB2 has implemented this function so far. Thankfully, other DBMS have similar functions, often with simpler syntax.  MySQL The function GROUP_CONCAT in MySQL concatenates the values found in the column passed to it, in this case ENAME. It’s an aggregate function, thus the need for GROUP BY in the query.  PostgreSQL and SQL Server The STRING_AGG function syntax is similar enough to GROUP_CONCAT that the same query can be used with the GROUP_CONCAT simply changed to STRING_AGG.  Oracle The first step to understanding the Oracle query is to break it down. Running the inline view by itself  lines 4–10 , you generate a result set that includes the following for each employee: her department, her name, a rank    7                                     p a r t i t i o n   b y   d e p t n o   o r d e r   b y   e m p n o     r n ,     8                 c o u n t   *     o v e r     9                                     p a r t i t i o n   b y   d e p t n o     c n t   1 0       f r o m   e m p   1 1                     1 2     w h e r e   l e v e l   =   c n t   1 3     s t a r t   w i t h   r n   =   1   1 4   c o n n e c t   b y   p r i o r   d e p t n o   =   d e p t n o   a n d   p r i o r   r n   =   r n - 1 1   s e l e c t   d e p t n o ,   2                 s t r i n g _ a g g   e n a m e   o r d e r   b y   e m p n o   s e p a r a t o r ,   ' , '     a s   e m p s   3       f r o m   e m p   4     g r o u p   b y   d e p t n o  within her respective department that is derived by an ascending sort on EMPNO, and a count of all employees in her department. For example:  The purpose of the rank  aliased RN in the query  is to allow you to walk the tree. Since the function ROW_NUMBER generates an enumeration starting from one with no duplicates or gaps, just subtract one  from the current value  to reference a prior  or parent  row. For example, the number prior to 3 is 3 minus 1, which equals 2. In this context, 2 is the parent of 3; you can observe this on line 12. Additionally, the lines:  identify the root for each DEPTNO as having RN equal to 1 and create a new list whenever a new department is encountered  whenever a new occurrence of 1 is found for RN .  s e l e c t   d e p t n o ,                   e n a m e ,                   r o w _ n u m b e r       o v e r                                         p a r t i t i o n   b y   d e p t n o   o r d e r   b y   e m p n o     r n ,                   c o u n t   *     o v e r     p a r t i t i o n   b y   d e p t n o     c n t       f r o m   e m p     D E P T N O   E N A M E             R N   C N T   - - - - - -   - - - - - - - - - -   - -   - - -           1 0   C L A R K               1       3           1 0   K I N G                 2       3           1 0   M I L L E R             3       3           2 0   S M I T H               1       5           2 0   J O N E S               2       5           2 0   S C O T T               3       5           2 0   A D A M S               4       5           2 0   F O R D                 5       5           3 0   A L L E N               1       6           3 0   W A R D                 2       6           3 0   M A R T I N             3       6           3 0   B L A K E               4       6           3 0   T U R N E R             5       6           3 0   J A M E S               6       6 s t a r t   w i t h   r n   =   1   c o n n e c t   b y   p r i o r   d e p t n o   =   d e p t n o  At this point, it’s important to stop and look at the ORDER BY portion of the ROW_NUMBER function. Keep in mind the names are ranked by EMPNO, and the list will be created in that order. The number of employees per department is calculated  aliased CNT  and is used to ensure that the query returns only the list that has all the employee names for a department. This is done because SYS_CONNECT_ BY_PATH builds the list iteratively, and you do not want to end up with partial lists. For hierarchical queries, the pseudocolumn LEVEL starts with 1  for queries not using CONNECT BY, LEVEL is 0, unless you are on release 10g and later when LEVEL is available only when using CONNECT BY  and increments by one after each employee in a department has been evaluated  for each level of depth in the hierarchy . Because of this, you know that once LEVEL reaches CNT, you have reached the last EMPNO and will have a complete list.  TIP  The SYS_CONNECT_BY_PATH function prefixes the list with your chosen delimiter  in this case, a comma . You may or may not want that behavior. In this recipe’s solution, the call to the function LTRIM removes the leading comma from the list.  6.11 Converting Delimited Data into a Multivalued IN-List  Problem You have delimited data that you want to pass to the IN-list iterator of a WHERE clause. Consider the following string:  You would like to use the string in a WHERE clause, but the following SQL fails because EMPNO is a numeric column:  7 6 5 4 , 7 6 9 8 , 7 7 8 2 , 7 7 8 8  This SQL fails because, while EMPNO is a numeric column, the IN list is composed of a single string value. You want that string to be treated as a comma-delimited list of numeric values.  Solution On the surface it may seem that SQL should do the work of treating a delimited string as a list of delimited values for you, but that is not the case. When a comma embedded within quotes is encountered, SQL can’t possibly know that signals a multivalued list. SQL must treat everything between the quotes as a single entity, as one string value. You must break the string up into individual EMPNOs. The key to this solution is to walk the string, but not into individual characters. You want to walk the string into valid EMPNO values.  DB2 By walking the string passed to the IN-list, you can easily convert it to rows. The functions ROW_NUMBER, LOCATE, and SUBSTR are particularly useful here:  s e l e c t   e n a m e , s a l , d e p t n o       f r o m   e m p     w h e r e   e m p n o   i n       ' 7 6 5 4 , 7 6 9 8 , 7 7 8 2 , 7 7 8 8 '       1   s e l e c t   e m p n o , e n a m e , s a l , d e p t n o     2       f r o m   e m p     3     w h e r e   e m p n o   i n         4   s e l e c t   c a s t   s u b s t r   c , 2 , l o c a t e   ' , ' , c , 2   - 2     a s   i n t e g e r     e m p n o     5       f r o m         6   s e l e c t   s u b s t r   c s v . e m p s , c a s t   i t e r . p o s   a s   i n t e g e r       a s   c     7       f r o m     s e l e c t   ' , '   ' 7 6 5 4 , 7 6 9 8 , 7 7 8 2 , 7 7 8 8 '   ' , '   e m p s     8                     f r o m   t 1     c s v ,     9                   s e l e c t   i d   a s   p o s   1 0                       f r o m   t 1 0 0       i t e r   1 1     w h e r e   i t e r . p o s   < =   l e n g t h   c s v . e m p s     1 2                     x   1 3     w h e r e   l e n g t h   c     >   1   1 4         a n d   s u b s t r   c , 1 , 1     =   ' , '   1 5                    MySQL By walking the string passed to the IN-list, you can easily convert it to rows:  Oracle By walking the string passed to the IN-list, you can easily convert it to rows. The functions ROWNUM, SUBSTR, and INSTR are particularly useful here:  PostgreSQL By walking the string passed to the IN-list, you can easily convert it to rows. The function SPLIT_PART makes it easy to parse the string into individual numbers:    1   s e l e c t   e m p n o ,   e n a m e ,   s a l ,   d e p t n o     2       f r o m   e m p     3     w h e r e   e m p n o   i n     4                       5   s e l e c t   s u b s t r i n g _ i n d e x       6                 s u b s t r i n g _ i n d e x   l i s t . v a l s , ' , ' , i t e r . p o s   , ' , ' , - 1     e m p n o     7       f r o m     s e l e c t   i d   p o s   f r o m   t 1 0     a s   i t e r ,     8                   s e l e c t   ' 7 6 5 4 , 7 6 9 8 , 7 7 8 2 , 7 7 8 8 '   a s   v a l s     9                       f r o m   t 1     l i s t   1 0       w h e r e   i t e r . p o s   < =   1 1                   l e n g t h   l i s t . v a l s   - l e n g t h   r e p l a c e   l i s t . v a l s , ' , ' , ' '       + 1   1 2                     1   s e l e c t   e m p n o , e n a m e , s a l , d e p t n o     2       f r o m   e m p     3     w h e r e   e m p n o   i n         4                 s e l e c t   t o _ n u m b e r       5                                       r t r i m       6                                   s u b s t r   e m p s ,     7                                     i n s t r   e m p s , ' , ' , 1 , i t e r . p o s   + 1 ,     8                                     i n s t r   e m p s , ' , ' , 1 , i t e r . p o s + 1       9                                     i n s t r   e m p s , ' , ' , 1 , i t e r . p o s     , ' , '       e m p s   1 0                     f r o m     s e l e c t   ' , '   ' 7 6 5 4 , 7 6 9 8 , 7 7 8 2 , 7 7 8 8 '   ' , '   e m p s   f r o m   t 1     c s v ,   1 1                                 s e l e c t   r o w n u m   p o s   f r o m   e m p     i t e r   1 2                   w h e r e   i t e r . p o s   < =       l e n g t h   c s v . e m p s   -   1 3                                       l e n g t h   r e p l a c e   c s v . e m p s , ' , '         l e n g t h   ' , '     - 1   1 4      SQL Server By walking the string passed to the IN-list, you can easily convert it to rows. The functions ROW_NUMBER, CHARINDEX, and SUBSTRING are particularly useful here:  Discussion The first and most important step in this solution is to walk the string. Once you’ve accomplished that, all that’s left is to parse the string into individual numeric values using your DBMS’s provided functions.  DB2 and SQL Server    1   s e l e c t   e n a m e , s a l , d e p t n o     2       f r o m   e m p     3     w h e r e   e m p n o   i n         4   s e l e c t   c a s t   e m p n o   a s   i n t e g e r     a s   e m p n o     5       f r o m         6   s e l e c t   s p l i t _ p a r t   l i s t . v a l s , ' , ' , i t e r . p o s     a s   e m p n o     7       f r o m     s e l e c t   i d   a s   p o s   f r o m   t 1 0     i t e r ,     8                   s e l e c t   ' , '   ' 7 6 5 4 , 7 6 9 8 , 7 7 8 2 , 7 7 8 8 '   ' , '   a s   v a l s     9                       f r o m   t 1     l i s t   1 0     w h e r e   i t e r . p o s   < =   1 1                 l e n g t h   l i s t . v a l s   - l e n g t h   r e p l a c e   l i s t . v a l s , ' , ' , ' '       1 2                     z   1 3     w h e r e   l e n g t h   e m p n o     >   0   1 4                     1   s e l e c t   e m p n o , e n a m e , s a l , d e p t n o     2       f r o m   e m p     3     w h e r e   e m p n o   i n     s e l e c t   s u b s t r i n g   c , 2 , c h a r i n d e x   ' , ' , c , 2   - 2     a s   e m p n o     4       f r o m         5   s e l e c t   s u b s t r i n g   c s v . e m p s , i t e r . p o s , l e n   c s v . e m p s       a s   c     6       f r o m     s e l e c t   ' , ' + ' 7 6 5 4 , 7 6 9 8 , 7 7 8 2 , 7 7 8 8 ' + ' , '   a s   e m p s     7                       f r o m   t 1     c s v ,     8                   s e l e c t   i d   a s   p o s     9                     f r o m   t 1 0 0     i t e r   1 0     w h e r e   i t e r . p o s   < =   l e n   c s v . e m p s     1 1                   x   1 2     w h e r e   l e n   c     >   1   1 3         a n d   s u b s t r i n g   c , 1 , 1     =   ' , '   1 4                  The inline view X  lines 6–11  walks the string. The idea in this solution is to “walk through” the string so that each row has one less character than the one before it:  Notice that by enclosing the string in commas  the delimiter , there’s no need to make special checks as to where the beginning or end of the string is. The next step is to keep only the values you want to use in the IN-list. The values to keep are the ones with leading commas, with the exception of the last row with its lone comma. Use SUBSTR or SUBSTRING to identify which rows have a leading comma, then keep all characters found before the next comma in that row. Once that’s done, cast the string to a number so it can be properly evaluated against the numeric column EMPNO  lines 4– 14 :  , 7 6 5 4 , 7 6 9 8 , 7 7 8 2 , 7 7 8 8 ,   7 6 5 4 , 7 6 9 8 , 7 7 8 2 , 7 7 8 8 ,   6 5 4 , 7 6 9 8 , 7 7 8 2 , 7 7 8 8 ,   5 4 , 7 6 9 8 , 7 7 8 2 , 7 7 8 8 ,   4 , 7 6 9 8 , 7 7 8 2 , 7 7 8 8 ,   , 7 6 9 8 , 7 7 8 2 , 7 7 8 8 ,   7 6 9 8 , 7 7 8 2 , 7 7 8 8 ,   6 9 8 , 7 7 8 2 , 7 7 8 8 ,   9 8 , 7 7 8 2 , 7 7 8 8 ,   8 , 7 7 8 2 , 7 7 8 8 ,   , 7 7 8 2 , 7 7 8 8 ,   7 7 8 2 , 7 7 8 8 ,   7 8 2 , 7 7 8 8 ,   8 2 , 7 7 8 8 ,   2 , 7 7 8 8 ,   , 7 7 8 8 ,   7 7 8 8 ,   7 8 8 ,   8 8 ,   8 ,   ,   E M P N O   - - - - - -       7 6 5 4       7 6 9 8    The final step is to use the results in a subquery to return the desired rows.  MySQL The inline view  lines 5–9  walks the string. The expression on line 10 determines how many values are in the string by finding the number of commas  the delimiter  and adding one. The function SUBSTRING_INDEX  line 6  returns all characters in the string before  to the left of   the nth occurrence of a comma  the delimiter :  Those rows are then passed to another call to SUBSTRING_INDEX  line 5 ; this time the nth occurrence of the delimited is –1, which causes all values to the right of the nth occurrence of the delimiter to be kept:  The final step is to plug the results into a subquery.  Oracle The first step is to walk the string:      7 7 8 2       7 7 8 8 + - - - - - - - - - - - - - - - - - - - - - +      e m p n o                                  + - - - - - - - - - - - - - - - - - - - - - +      7 6 5 4                                       7 6 5 4 , 7 6 9 8                             7 6 5 4 , 7 6 9 8 , 7 7 8 2                   7 6 5 4 , 7 6 9 8 , 7 7 8 2 , 7 7 8 8      + - - - - - - - - - - - - - - - - - - - - - + + - - - - - - - +      e m p n o      + - - - - - - - +      7 6 5 4           7 6 9 8           7 7 8 2           7 7 8 8        + - - - - - - - +  The number of rows returned represents the number of values in your list. The values for POS are crucial to the query as they are needed to parse the string into individual values. The strings are parsed using SUBSTR and INSTR. POS is used to locate the nth occurrence of the delimiter in each string. By enclosing the strings in commas, no special checks are necessary to determine the beginning or end of a string. The values passed to SUBSTR and INSTR  lines 7–9  locate the nth and nth+1 occurrence of the delimiter. By subtracting the value returned for the current comma  the location in the string where the current comma is  from the value returned by the next comma  the location in the string where the next comma is  you can extract each value from the string:  s e l e c t   e m p s , p o s       f r o m     s e l e c t   ' , '   ' 7 6 5 4 , 7 6 9 8 , 7 7 8 2 , 7 7 8 8 '   ' , '   e m p s                       f r o m   t 1     c s v ,                   s e l e c t   r o w n u m   p o s   f r o m   e m p     i t e r     w h e r e   i t e r . p o s   < =         l e n g t h   c s v . e m p s   - l e n g t h   r e p l a c e   c s v . e m p s , ' , '         l e n g t h   ' , '     - 1       E M P S                                                   P O S   - - - - - - - - - - - - - - - - - - - - -   - - - - - - - - - -   , 7 6 5 4 , 7 6 9 8 , 7 7 8 2 , 7 7 8 8 ,                     1   , 7 6 5 4 , 7 6 9 8 , 7 7 8 2 , 7 7 8 8 ,                     2   , 7 6 5 4 , 7 6 9 8 , 7 7 8 2 , 7 7 8 8 ,                     3   , 7 6 5 4 , 7 6 9 8 , 7 7 8 2 , 7 7 8 8 ,                     4 s e l e c t   s u b s t r   e m p s ,                 i n s t r   e m p s , ' , ' , 1 , i t e r . p o s   + 1 ,                 i n s t r   e m p s , ' , ' , 1 , i t e r . p o s + 1                   i n s t r   e m p s , ' , ' , 1 , i t e r . p o s       e m p s       f r o m     s e l e c t   ' , '   ' 7 6 5 4 , 7 6 9 8 , 7 7 8 2 , 7 7 8 8 '   ' , '   e m p s                       f r o m   t 1     c s v ,                   s e l e c t   r o w n u m   p o s   f r o m   e m p     i t e r     w h e r e   i t e r . p o s   < =           l e n g t h   c s v . e m p s   - l e n g t h   r e p l a c e   c s v . e m p s , ' , '         l e n g t h   ' , '     - 1       E M P S     - - - - - - - - - - -     7 6 5 4 ,     7 6 9 8 ,    The final step is to remove the trailing comma from each value, cast it to a number, and plug it into a subquery.  PostgreSQL The inline view Z  lines 6–9  walks the string. The number of rows returned is determined by how many values are in the string. To find the number of values in the string, subtract the size of the string without the delimiter from the size of the string with the delimiter  line 9 . The function SPLIT_PART does the work of parsing the string. It looks for the value that comes before the nth occurrence of the delimiter:  The final step is to cast the values  EMPNO  to a number and plug it into a subquery.  6.12 Alphabetizing a String  Problem    7 7 8 2 ,     7 7 8 8 , s e l e c t   l i s t . v a l s ,                 s p l i t _ p a r t   l i s t . v a l s , ' , ' , i t e r . p o s     a s   e m p n o ,                 i t e r . p o s       f r o m     s e l e c t   i d   a s   p o s   f r o m   t 1 0     i t e r ,                   s e l e c t   ' , '   ' 7 6 5 4 , 7 6 9 8 , 7 7 8 2 , 7 7 8 8 '   ' , '   a s   v a l s                       f r o m   t 1     l i s t     w h e r e   i t e r . p o s   < =                 l e n g t h   l i s t . v a l s   - l e n g t h   r e p l a c e   l i s t . v a l s , ' , ' , ' '                   v a l s                              e m p n o      p o s   - - - - - - - - - - - - - - - - - - - - - - + - - - - - - - + - - - - -   , 7 6 5 4 , 7 6 9 8 , 7 7 8 2 , 7 7 8 8 ,                         1   , 7 6 5 4 , 7 6 9 8 , 7 7 8 2 , 7 7 8 8 ,      7 6 5 4            2   , 7 6 5 4 , 7 6 9 8 , 7 7 8 2 , 7 7 8 8 ,      7 6 9 8            3   , 7 6 5 4 , 7 6 9 8 , 7 7 8 2 , 7 7 8 8 ,      7 7 8 2            4   , 7 6 5 4 , 7 6 9 8 , 7 7 8 2 , 7 7 8 8 ,      7 7 8 8            5  You want alphabetize the individual characters within strings in your tables. Consider the following result set:  You would like the result to be:  Solution This problem is a good example of the way increased standardization allows for more similar, and therefore portable solutions.  E N A M E   - - - - - - - - - -   A D A M S   A L L E N   B L A K E   C L A R K   F O R D   J A M E S   J O N E S   K I N G   M A R T I N   M I L L E R   S C O T T   S M I T H   T U R N E R   W A R D O L D _ N A M E       N E W _ N A M E   - - - - - - - - - -   - - - - - - - -   A D A M S             A A D M S   A L L E N             A E L L N   B L A K E             A B E K L   C L A R K             A C K L R   F O R D               D F O R   J A M E S             A E J M S   J O N E S             E J N O S   K I N G               G I K N   M A R T I N           A I M N R T   M I L L E R           E I L L M R   S C O T T             C O S T T   S M I T H             H I M S T   T U R N E R           E N R R T U   W A R D               A D R W  DB2 To alphabetize rows of strings, it is necessary to walk each string and then order its characters:  MySQL The key here is the GROUP_CONCAT function, which allows you to not only concatenate the characters that make up each name but also order them:  Oracle The function SYS_CONNECT_BY_PATH allows you to iteratively build a list:    1   s e l e c t   e n a m e ,     2                 l i s t a g g   c , ' '       W I T H I N   G R O U P     O R D E R   B Y   c       3       f r o m         4                   s e l e c t   a . e n a m e ,     5                   s u b s t r   a . e n a m e , i t e r . p o s , 1     6                       a s   c     7     f r o m   e m p   a ,     8               s e l e c t   i d   a s   p o s   f r o m   t 1 0     i t e r     9                 w h e r e   i t e r . p o s   < =   l e n g t h   a . e n a m e       1 0                 o r d e r   b y   1 , 2     1 1                 x     1 2               G r o u p   B y   c 1   s e l e c t   e n a m e ,   g r o u p _ c o n c a t   c   o r d e r   b y   c   s e p a r a t o r   ' '     2       f r o m       3   s e l e c t   e n a m e ,   s u b s t r   a . e n a m e , i t e r . p o s , 1     c   4       f r o m   e m p   a ,   5                     s e l e c t   i d   p o s   f r o m   t 1 0       i t e r   6     w h e r e   i t e r . p o s   < =   l e n g t h   a . e n a m e     7                     x   8     g r o u p   b y   e n a m e   1   s e l e c t   o l d _ n a m e ,   n e w _ n a m e     2       f r o m         3   s e l e c t   o l d _ n a m e ,   r e p l a c e   s y s _ c o n n e c t _ b y _ p a t h   c , '   '   , '   '     n e w _ n a m e     4       f r o m         5   s e l e c t   e . e n a m e   o l d _ n a m e ,     6                 r o w _ n u m b e r       o v e r   p a r t i t i o n   b y   e . e n a m e    PostgreSQL PostgreSQL has now added STRING_AGG to order characters within a string.  SQL Server If you are using SQL Server 2017 or beyond, the PostgreSQL solution with STRING_AGG will work. Otherwise, to alphabetize rows of strings, it is necessary to walk each string and then order their characters:    7                                                   o r d e r   b y   s u b s t r   e . e n a m e , i t e r . p o s , 1       r n ,     8                 s u b s t r   e . e n a m e , i t e r . p o s , 1     c     9       f r o m   e m p   e ,   1 0                     s e l e c t   r o w n u m   p o s   f r o m   e m p       i t e r   1 1     w h e r e   i t e r . p o s   < =   l e n g t h   e . e n a m e     1 2     o r d e r   b y   1   1 3                       x   1 4     s t a r t   w i t h   r n   =   1   1 5   c o n n e c t   b y   p r i o r   r n   =   r n - 1   a n d   p r i o r   o l d _ n a m e   =   o l d _ n a m e   1 6                       1 7     w h e r e   l e n g t h   o l d _ n a m e     =   l e n g t h   n e w _ n a m e       s e l e c t   e n a m e ,   s t r i n g _ a g g   c   ,   ' '               O R D E R   B Y   c     f r o m           s e l e c t   a . e n a m e ,                     s u b s t r   a . e n a m e , i t e r . p o s , 1     a s   c           f r o m   e m p   a ,                       s e l e c t   i d   a s   p o s   f r o m   t 1 0     i t e r         w h e r e   i t e r . p o s   < =   l e n g t h   a . e n a m e           o r d e r   b y   1 , 2                         x                     G r o u p   B y   c   1   s e l e c t   e n a m e ,     2                       m a x   c a s e   w h e n   p o s = 1   t h e n   c   e l s e   ' '   e n d   +     3                       m a x   c a s e   w h e n   p o s = 2   t h e n   c   e l s e   ' '   e n d   +     4                       m a x   c a s e   w h e n   p o s = 3   t h e n   c   e l s e   ' '   e n d   +     5                       m a x   c a s e   w h e n   p o s = 4   t h e n   c   e l s e   ' '   e n d   +     6                       m a x   c a s e   w h e n   p o s = 5   t h e n   c   e l s e   ' '   e n d   +     7                       m a x   c a s e   w h e n   p o s = 6   t h e n   c   e l s e   ' '   e n d       8             f r o m         9         s e l e c t   e . e n a m e ,   1 0                   s u b s t r i n g   e . e n a m e , i t e r . p o s , 1     a s   c ,    Discussion  SQL Server The inline view X returns each character in each name as a row. The function SUBSTR or SUBSTRING extracts each character from each name, and the function ROW_NUMBER ranks each character alphabetically:  To return each letter of a string as a row, you must walk the string. This is accomplished with inline view ITER. Now that the letters in each name have been alphabetized, the last step is to put those letters back together, into a string, in the order they are ranked. Each letter’s position is evaluated by the CASE statements  lines 2–7 . If a character is found at a particular position, it is then concatenated to the result of the next evaluation  the following CASE statement . Because the aggregate function MAX is used as well, only one character per position POS is returned so that only one row per name is returned. The CASE evaluation goes up to the number six, which is the maximum number of characters in any name in table EMP.  1 1                   r o w _ n u m b e r       o v e r       1 2                     p a r t i t i o n   b y   e . e n a m e   1 3                             o r d e r   b y   s u b s t r i n g   e . e n a m e , i t e r . p o s , 1       a s   p o s   1 4         f r o m   e m p   e ,   1 5                     s e l e c t   r o w _ n u m b e r     o v e r   o r d e r   b y   e n a m e     a s   p o s   1 6                         f r o m   e m p     i t e r   1 7       w h e r e   i t e r . p o s   < =   l e n   e . e n a m e     1 8                         x   1 9       g r o u p   b y   e n a m e E N A M E     C     P O S   - - - - -     -     - - -   A D A M S     A     1   A D A M S     A     2   A D A M S     D     3   A D A M S     M     4   A D A M S     S     5   …  MySQL The inline view X  lines 3–6  returns each character in each name as a row. The function SUBSTR extracts each character from each name:  Inline view ITER is used to walk the string. From there, the rest of the work is done by the GROUP_CONCAT function. By specifying an order, the function not only concatenates each letter, it does so alphabetically.  Oracle The real work is done by inline view X  lines 5–11 , where the characters in each name are extracted and put into alphabetical order. This is accomplished by walking the string and then imposing order on those characters. The rest of the query merely glues the names back together. The tearing apart of names can be seen by executing only inline view X:  The next step is to take the alphabetized characters and rebuild each name. This is done with the function SYS_CONNECT_BY_PATH by appending each character to the ones before it:  E N A M E     C   - - - - -     -   A D A M S     A   A D A M S     A   A D A M S     D   A D A M S     M   A D A M S     S   … O L D _ N A M E                     R N   C   - - - - - - - - - -   - - - - - - - - -   -   A D A M S                             1   A   A D A M S                             2   A   A D A M S                             3   D   A D A M S                             4   M   A D A M S                             5   S   … O L D _ N A M E       N E W _ N A M E   - - - - - - - - - -   - - - - - - - - -    The final step is to keep only the strings that have the same length as the names they were built from.  PostgreSQL For readability, view V is used in this solution to walk the string. The function SUBSTR, in the view definition, extracts each character from each name so that the view returns:  The view also orders the results by ENAME and by each letter in each name. The inline view X  lines 15–18  returns the names and characters from view V, the number of times each character occurs in each name, and its position  alphabetically :  The extra columns CNT and POS, returned by the inline view X, are crucial to the solution. POS is used to rank each character, and CNT is used to determine the number of times the character exists in each name. The final  A D A M S             A   A D A M S             A A   A D A M S             A A D   A D A M S             A A D M   A D A M S             A A D M S   … E N A M E   C   - - - - -   -   A D A M S   A   A D A M S   A   A D A M S   D   A D A M S   M   A D A M S   S   … e n a m e      c      c n t      p o s   - - - - - - + - - - + - - - - - + - - - - -   A D A M S      A          2          1   A D A M S      A          2          1   A D A M S      D          1          3   A D A M S      M          1          4   A D A M S      S          1          5  step is to evaluate the position of each character and rebuild the name. You’ll notice that each case statement is actually two case statements. This is to determine whether a character occurs more than once in a name; if it does, then rather than return that character, what is returned is that character appended to itself CNT times. The aggregate function, MAX, is used to ensure there is only one row per name.  6.13 Identifying Strings That Can Be Treated as Numbers  Problem You have a column that is defined to hold character data. Unfortunately, the rows contain mixed numeric and character data. Consider view V:  c r e a t e   v i e w   V   a s   s e l e c t   r e p l a c e   m i x e d , '   ' , ' '     a s   m i x e d       f r o m       s e l e c t   s u b s t r   e n a m e , 1 , 2                     c a s t   d e p t n o   a s   c h a r   4                       s u b s t r   e n a m e , 3 , 2     a s   m i x e d       f r o m   e m p     w h e r e   d e p t n o   =   1 0     u n i o n   a l l   s e l e c t   c a s t   e m p n o   a s   c h a r   4       a s   m i x e d       f r o m   e m p     w h e r e   d e p t n o   =   2 0     u n i o n   a l l   s e l e c t   e n a m e   a s   m i x e d       f r o m   e m p     w h e r e   d e p t n o   =   3 0                     x   s e l e c t   *   f r o m   v       M I X E D     - - - - - - - - - - - - - -     C L 1 0 A R     K I 1 0 N G     M I 1 0 L L     7 3 6 9     7 5 6 6    You want to return rows that are numbers only, or that contain at least one number. If the numbers are mixed with character data, you want to remove the characters and return only the numbers. For the sample data shown previously, you want the following result set:  Solution The functions REPLACE and TRANSLATE are extremely useful for manipulating strings and individual characters. The key is to convert all numbers to a single character, which then makes it easy to isolate and identify any number by referring to a single character.  DB2 Use functions TRANSLATE, REPLACE, and POSSTR to isolate the numeric characters in each row. The calls to CAST are necessary in view V; otherwise, the view will fail to be created due to type conversion errors. You’ll need the function REPLACE to remove extraneous whitespace due to casting to the fixed-length CHAR:    7 7 8 8     7 8 7 6     7 9 0 2     A L L E N     W A R D     M A R T I N     B L A K E     T U R N E R     J A M E S       M I X E D   - - - - - - - -               1 0               1 0               1 0           7 3 6 9           7 5 6 6           7 7 8 8           7 8 7 6           7 9 0 2  MySQL The syntax for MySQL is slightly different and will define view V as:  Because MySQL does not support the TRANSLATE function, you must walk each row and evaluate it on a character-by-character basis.    1   s e l e c t   m i x e d   o l d ,     2                 c a s t       3                     c a s e     4                     w h e n     5                         r e p l a c e       6                       t r a n s l a t e   m i x e d , ' 9 9 9 9 9 9 9 9 9 9 ' , ' 0 1 2 3 4 5 6 7 8 9 '   , ' 9 ' , ' '     =   ' '     7                     t h e n     8                           m i x e d     9                     e l s e   r e p l a c e     1 0                         t r a n s l a t e   m i x e d ,   1 1                               r e p e a t   '  ' , l e n g t h   m i x e d     ,   1 2                           r e p l a c e     1 3                             t r a n s l a t e   m i x e d , ' 9 9 9 9 9 9 9 9 9 9 ' , ' 0 1 2 3 4 5 6 7 8 9 '   , ' 9 ' , ' '     ,   1 4                                             '  ' , ' '     1 5                     e n d   a s   i n t e g e r       m i x e d   1 6       f r o m   V   1 7     w h e r e   p o s s t r   t r a n s l a t e   m i x e d , ' 9 9 9 9 9 9 9 9 9 9 ' , ' 0 1 2 3 4 5 6 7 8 9 '   , ' 9 '     >   0 c r e a t e   v i e w   V   a s   s e l e c t   c o n c a t                       s u b s t r   e n a m e , 1 , 2   ,                     r e p l a c e   c a s t   d e p t n o   a s   c h a r   4     , '   ' , ' '   ,                     s u b s t r   e n a m e , 3 , 2                       a s   m i x e d       f r o m   e m p     w h e r e   d e p t n o   =   1 0     u n i o n   a l l   s e l e c t   r e p l a c e   c a s t   e m p n o   a s   c h a r   4     ,   '   ' ,   ' '         f r o m   e m p   w h e r e   d e p t n o   =   2 0     u n i o n   a l l   s e l e c t   e n a m e   f r o m   e m p   w h e r e   d e p t n o   =   3 0   1   s e l e c t   c a s t   g r o u p _ c o n c a t   c   o r d e r   b y   p o s   s e p a r a t o r   ' '     a s   u n s i g n e d       2                 a s   M I X E D 1     3       f r o m         4   s e l e c t   v . m i x e d ,   i t e r . p o s ,   s u b s t r   v . m i x e d , i t e r . p o s , 1     a s   c     5       f r o m   V ,     6                     s e l e c t   i d   p o s   f r o m   t 1 0       i t e r    Oracle Use functions TRANSLATE, REPLACE, and INSTR to isolate the numeric characters in each row. The calls to CAST are not necessary in view V. Use the function REPLACE to remove extraneous whitespace due to casting to the fixed-length CHAR. If you decide you would like to keep the explicit type conversion calls in the view definition, it is suggested you cast to VARCHAR2:  PostgreSQL Use functions TRANSLATE, REPLACE, and STRPOS to isolate the numeric characters in each row. The calls to CAST are not necessary in view V. Use the function REPLACE to remove extraneous whitespace due to casting to the fixed-length CHAR. If you decide you would like to keep the explicit type conversion calls in the view definition, it is suggested you cast to VARCHAR:    7     w h e r e   i t e r . p o s   < =   l e n g t h   v . m i x e d       8         a n d   a s c i i   s u b s t r   v . m i x e d , i t e r . p o s , 1       b e t w e e n   4 8   a n d   5 7     9                     y   1 0     g r o u p   b y   m i x e d   1 1     o r d e r   b y   1   1   s e l e c t   t o _ n u m b e r         2                   c a s e     3                   w h e n     4                         r e p l a c e   t r a n s l a t e   m i x e d , ' 0 1 2 3 4 5 6 7 8 9 ' , ' 9 9 9 9 9 9 9 9 9 9 '   , ' 9 '       5                       i s   n o t   n u l l     6                   t h e n     7                             r e p l a c e       8                         t r a n s l a t e   m i x e d ,     9                             r e p l a c e     1 0                         t r a n s l a t e   m i x e d , ' 0 1 2 3 4 5 6 7 8 9 ' , ' 9 9 9 9 9 9 9 9 9 9 '   , ' 9 '   ,   1 1                                           r p a d   '  ' , l e n g t h   m i x e d   , '  '     , '  '     1 2                   e l s e   1 3                             m i x e d   1 4                   e n d   1 5                       m i x e d   1 6       f r o m   V   1 7     w h e r e   i n s t r   t r a n s l a t e   m i x e d , ' 0 1 2 3 4 5 6 7 8 9 ' , ' 9 9 9 9 9 9 9 9 9 9 '   , ' 9 '     >   0  SQL Server The built-in function ISNUMERIC along with a wildcard search allows you to easily identify strings that contain numbers, but getting numeric characters out of a string is not particularly efficient because the TRANSLATE function is not supported.  Discussion The TRANSLATE function is useful here as it allows you to easily isolate and identify numbers and characters. The trick is to convert all numbers to a single character; this way, rather than searching for different numbers, you search for only one character.  DB2, Oracle, and PostgreSQL The syntax differs slightly among these DBMSs, but the technique is the same. We’ll use the solution for PostgreSQL for the discussion. The real work is done by functions TRANSLATE and REPLACE. Getting the final result set requires several function calls, each listed here in one query:    1   s e l e c t   c a s t       2                 c a s e     3                 w h e n     4                   r e p l a c e   t r a n s l a t e   m i x e d , ' 0 1 2 3 4 5 6 7 8 9 ' , ' 9 9 9 9 9 9 9 9 9 9 '   , ' 9 ' , ' '       5                   i s   n o t   n u l l     6                 t h e n     7                       r e p l a c e       8                 t r a n s l a t e   m i x e d ,     9                       r e p l a c e     1 0                 t r a n s l a t e   m i x e d , ' 0 1 2 3 4 5 6 7 8 9 ' , ' 9 9 9 9 9 9 9 9 9 9 '   , ' 9 ' , ' '   ,   1 1                                   r p a d   '  ' , l e n g t h   m i x e d   , '  '     , '  ' , ' '     1 2                 e l s e   1 3                     m i x e d   1 4                 e n d   a s   i n t e g e r       a s   m i x e d   1 5         f r o m   V   1 6     w h e r e   s t r p o s   t r a n s l a t e   m i x e d , ' 0 1 2 3 4 5 6 7 8 9 ' , ' 9 9 9 9 9 9 9 9 9 9 '   , ' 9 '     >   0 s e l e c t   m i x e d   a s   o r i g ,   t r a n s l a t e   m i x e d , ' 0 1 2 3 4 5 6 7 8 9 ' , ' 9 9 9 9 9 9 9 9 9 9 '     a s   m i x e d 1 ,    First, notice that any rows without at least one number are removed. How this is accomplished will become clear as you examine each of the columns in the previous result set. The rows that are kept are the values in the ORIG column and are the rows that will eventually make up the result set. The first step to extracting the numbers is to use the function TRANSLATE to convert any number to a 9  you can use any digit; 9 is arbitrary ; this is represented by the values in MIXED1. Now that all numbers are 9s, they can be treated as a single unit. The next step is to remove all of the numbers by using the function REPLACE. Because all digits are now 9, REPLACE simply looks for any 9s and removes them. This is represented by the values in MIXED2. The next step, MIXED3, uses values that are returned by MIXED2. These values are then compared to the values in ORIG. If any characters from MIXED2 are found in ORIG, they are converted to the  character by TRANSLATE. The result set from MIXED3 shows that the letters, not the numbers, have now been singled out and converted to a single character. Now that all nonnumeric characters are represented by s, they can be treated as a single unit. The next step, MIXED4, uses  r e p l a c e   t r a n s l a t e   m i x e d , ' 0 1 2 3 4 5 6 7 8 9 ' , ' 9 9 9 9 9 9 9 9 9 9 '   , ' 9 ' , ' '     a s   m i x e d 2 ,     t r a n s l a t e   m i x e d ,     r e p l a c e       t r a n s l a t e   m i x e d , ' 0 1 2 3 4 5 6 7 8 9 ' , ' 9 9 9 9 9 9 9 9 9 9 '   , ' 9 ' , ' '   ,                       r p a d   '  ' , l e n g t h   m i x e d   , '  '       a s   m i x e d 3 ,       r e p l a c e       t r a n s l a t e   m i x e d ,     r e p l a c e       t r a n s l a t e   m i x e d , ' 0 1 2 3 4 5 6 7 8 9 ' , ' 9 9 9 9 9 9 9 9 9 9 '   , ' 9 ' , ' '   ,                       r p a d   '  ' , l e n g t h   m i x e d   , '  '     , '  ' , ' '     a s   m i x e d 4       f r o m   V       w h e r e   s t r p o s   t r a n s l a t e   m i x e d , ' 0 1 2 3 4 5 6 7 8 9 ' , ' 9 9 9 9 9 9 9 9 9 9 '   , ' 9 '     >   0         O R I G        M I X E D 1      M I X E D 2      M I X E D 3      M I X E D 4      M I X E D 5   - - - - - - - - + - - - - - - - - + - - - - - - - - + - - - - - - - - + - - - - - - - - + - - - - - - - -     C L 1 0 A R      C L 9 9 A R      C L A R            1 0        1 0                      1 0     K I 1 0 N G      K I 9 9 N G      K I N G            1 0        1 0                      1 0     M I 1 0 L L      M I 9 9 L L      M I L L            1 0        1 0                      1 0     7 3 6 9          9 9 9 9                           7 3 6 9          7 3 6 9              7 3 6 9     7 5 6 6          9 9 9 9                           7 5 6 6          7 5 6 6              7 5 6 6     7 7 8 8          9 9 9 9                           7 7 8 8          7 7 8 8              7 7 8 8     7 8 7 6          9 9 9 9                           7 8 7 6          7 8 7 6              7 8 7 6     7 9 0 2          9 9 9 9                           7 9 0 2          7 9 0 2              7 9 0 2  REPLACE to find and remove any  characters in each row; what’s left are numbers only. The final step is to cast the numeric characters as numbers. Now that you’ve gone through the steps, you can see how the WHERE clause works. The results from MIXED1 are passed to STRPOS, and if a 9 is found  the position in the string where the first 9 is located , the result must be greater than 0. For rows that return a value greater than zero, it means there’s at least one number in that row and it should be kept.  MySQL The first step is to walk each string, evaluate each character, and determine whether it’s a number:  Now that each character in each string can be evaluated individually, the next step is to keep only the rows that have a number in the C column:  s e l e c t   v . m i x e d ,   i t e r . p o s ,   s u b s t r   v . m i x e d , i t e r . p o s , 1     a s   c       f r o m   V ,                   s e l e c t   i d   p o s   f r o m   t 1 0       i t e r     w h e r e   i t e r . p o s   < =   l e n g t h   v . m i x e d         o r d e r   b y   1 , 2     + - - - - - - - - + - - - - - - + - - - - - - +      m i x e d        p o s        c            + - - - - - - - - + - - - - - - + - - - - - - +      7 3 6 9                1      7               7 3 6 9                2      3               7 3 6 9                3      6               7 3 6 9                4      9            …      A L L E N              1      A               A L L E N              2      L               A L L E N              3      L               A L L E N              4      E               A L L E N              5      N            …      C L 1 0 A R            1      C               C L 1 0 A R            2      L               C L 1 0 A R            3      1               C L 1 0 A R            4      0               C L 1 0 A R            5      A               C L 1 0 A R            6      R            + - - - - - - - - + - - - - - - + - - - - - - +  At this point, all the rows in column C are numbers. The next step is to use GROUP_CONCAT to concatenate the numbers to form their respective whole number in MIXED. The final result is then cast as a number:  s e l e c t   v . m i x e d ,   i t e r . p o s ,   s u b s t r   v . m i x e d , i t e r . p o s , 1     a s   c         f r o m   V ,                     s e l e c t   i d   p o s   f r o m   t 1 0       i t e r     w h e r e   i t e r . p o s   < =   l e n g t h   v . m i x e d         a n d   a s c i i   s u b s t r   v . m i x e d , i t e r . p o s , 1       b e t w e e n   4 8   a n d   5 7     o r d e r   b y   1 , 2     + - - - - - - - - + - - - - - - + - - - - - - +      m i x e d        p o s        c            + - - - - - - - - + - - - - - - + - - - - - - +      7 3 6 9                1      7               7 3 6 9                2      3               7 3 6 9                3      6               7 3 6 9                4      9            …      C L 1 0 A R            3      1               C L 1 0 A R            4      0            …   + - - - - - - - - + - - - - - - + - - - - - - + s e l e c t   c a s t   g r o u p _ c o n c a t   c   o r d e r   b y   p o s   s e p a r a t o r   ' '     a s   u n s i g n e d                       a s   M I X E D 1       f r o m         s e l e c t   v . m i x e d ,   i t e r . p o s ,   s u b s t r   v . m i x e d , i t e r . p o s , 1     a s   c         f r o m   V ,                     s e l e c t   i d   p o s   f r o m   t 1 0       i t e r       w h e r e   i t e r . p o s   < =   l e n g t h   v . m i x e d           a n d   a s c i i   s u b s t r   x . m i x e d , i t e r . p o s , 1       b e t w e e n   4 8   a n d   5 7                     y       g r o u p   b y   m i x e d       o r d e r   b y   1     + - - - - - - - - +      M I X E D 1      + - - - - - - - - +            1 0                 1 0                 1 0             7 3 6 9             7 5 6 6             7 7 8 8             7 8 7 6         As a final note, keep in mind that any digits in each string will be concatenated to form one numeric value. For example, an input value of, say, 9 something to keep in mind, particularly when working with serialized data.  7 will result in the value 9987 being returned. This is  6.14 Extracting the nth Delimited Substring  Problem You want to extract a specified, delimited substring from a string. Consider the following view V, which generates source data for this problem:  Output from the view is as follows:  You would like to extract the second name in each row, so the final result set would be as follows:       7 9 0 2        + - - - - - - - - + 9 G e n n i c k 8 c r e a t e   v i e w   V   a s   s e l e c t   ' m o , l a r r y , c u r l y '   a s   n a m e       f r o m   t 1     u n i o n   a l l   s e l e c t   ' t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a '   a s   n a m e       f r o m   t 1 s e l e c t   *   f r o m   v     N A M E   - - - - - - - - - - - - - - - - - - -   m o , l a r r y , c u r l y   t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a     S U B   - - - - -   l a r r y   g i n a  Solution The key to solving this problem is to return each name as an individual row while preserving the order in which the name exists in the list. Exactly how you do these things depends on which DBMS you are using.  DB2 After walking the NAMEs returned by view V, use the function ROW_NUMBER to keep only the second name from each string:  MySQL After walking the NAMEs returned by view V, use the position of the commas to return only the second name in each string:    1   s e l e c t   s u b s t r   c , 2 , l o c a t e   ' , ' , c , 2   - 2       2       f r o m         3   s e l e c t   p o s ,   n a m e ,   s u b s t r   n a m e ,   p o s     c ,     4                 r o w _ n u m b e r       o v e r     p a r t i t i o n   b y   n a m e     5                                               o r d e r   b y   l e n g t h   s u b s t r   n a m e , p o s       d e s c     r n     6     f r o m         7   s e l e c t   ' , '     c s v . n a m e     ' , '   a s   n a m e ,     8                   c a s t   i t e r . p o s   a s   i n t e g e r     a s   p o s     9       f r o m   V   c s v ,   1 0                   s e l e c t   r o w _ n u m b e r       o v e r       p o s   f r o m   t 1 0 0       i t e r   1 1     w h e r e   i t e r . p o s   < =   l e n g t h   c s v . n a m e   + 2   1 2                     x   1 3     w h e r e   l e n g t h   s u b s t r   n a m e , p o s       >   1   1 4       a n d   s u b s t r   s u b s t r   n a m e , p o s   , 1 , 1     =   ' , '   1 5                     y   1 6     w h e r e   r n   =   2   1   s e l e c t   n a m e     2       f r o m         3   s e l e c t   i t e r . p o s ,     4                 s u b s t r i n g _ i n d e x       5                 s u b s t r i n g _ i n d e x   s r c . n a m e , ' , ' , i t e r . p o s   , ' , ' , - 1     n a m e     6       f r o m   V   s r c ,     7                   s e l e c t   i d   p o s   f r o m   t 1 0     i t e r ,     8     w h e r e   i t e r . p o s   < =     9                 l e n g t h   s r c . n a m e   - l e n g t h   r e p l a c e   s r c . n a m e , ' , ' , ' '       1 0                     x   1 1     w h e r e   p o s   =   2  Oracle After walking the NAMEs returned by view V, retrieve the second name in each list by using SUBSTR and INSTR:  PostgreSQL Use the function SPLIT_PART to help return each individual name as a row:  SQL Server The SQL Server STRING_SPLIT function will do the whole job, but can only take a single cell. Hence, we use a STRING_AGG within a CTE to present the data the way STRING_SPLIT requires.      1   s e l e c t   s u b       2       f r o m           3   s e l e c t   i t e r . p o s ,       4                 s r c . n a m e ,       5                 s u b s t r     s r c . n a m e ,       6                   i n s t r     s r c . n a m e , ' , ' , 1 , i t e r . p o s     + 1 ,       7                   i n s t r     s r c . n a m e , ' , ' , 1 , i t e r . p o s + 1       -       8                   i n s t r     s r c . n a m e , ' , ' , 1 , i t e r . p o s     - 1     s u b       9       f r o m     s e l e c t   ' , '   n a m e   ' , '   a s   n a m e   f r o m   V     s r c ,     1 0                   s e l e c t   r o w n u m   p o s   f r o m   e m p     i t e r     1 1     w h e r e   i t e r . p o s   <   l e n g t h   s r c . n a m e   - l e n g t h   r e p l a c e   s r c . n a m e , ' , '         1 2                       1 3     w h e r e   p o s   =   2   1   s e l e c t   n a m e     2       f r o m         3   s e l e c t   i t e r . p o s ,   s p l i t _ p a r t   s r c . n a m e , ' , ' , i t e r . p o s     a s   n a m e     4       f r o m     s e l e c t   i d   a s   p o s   f r o m   t 1 0     i t e r ,     5                   s e l e c t   c a s t   n a m e   a s   t e x t     a s   n a m e   f r o m   v     s r c     7     w h e r e   i t e r . p o s   < =     8                   l e n g t h   s r c . n a m e   - l e n g t h   r e p l a c e   s r c . n a m e , ' , ' , ' '     + 1     9                     x   1 0     w h e r e   p o s   =   2 1   w i t h   a g g _ t a b   n a m e     2           a s   3             s e l e c t   S T R I N G _ A G G   n a m e , ' , '     f r o m   V     4   s e l e c t   v a l u e   f r o m    Discussion  DB2 The syntax is slightly different between these two DBMSs, but the technique is the same. We will use the solution for DB2 for the discussion. The strings are walked and the results are represented by inline view X:  The next step is to then step through each character in each string:  5           S T R I N G _ S P L I T     6             s e l e c t   n a m e   f r o m   a g g _ t a b   , ' , '   s e l e c t   ' , '   c s v . n a m e     ' , '   a s   n a m e ,                   i t e r . p o s       f r o m   v   c s v ,                     s e l e c t   r o w _ n u m b e r       o v e r       p o s   f r o m   t 1 0 0       i t e r     w h e r e   i t e r . p o s   < =   l e n g t h   c s v . n a m e   + 2     E M P S                                                           P O S   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   - - - -   , t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a ,         1   , t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a ,         2   , t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a ,         3   … s e l e c t   p o s ,   n a m e ,   s u b s t r   n a m e ,   p o s     c ,                   r o w _ n u m b e r       o v e r   p a r t i t i o n   b y   n a m e                                                   o r d e r   b y   l e n g t h   s u b s t r   n a m e ,   p o s       d e s c     r n       f r o m       s e l e c t   ' , '   c s v . n a m e   ' , '   a s   n a m e ,                 c a s t   i t e r . p o s   a s   i n t e g e r     a s   p o s       f r o m   v   c s v ,                 s e l e c t   r o w _ n u m b e r       o v e r       p o s   f r o m   t 1 0 0       i t e r     w h e r e   i t e r . p o s   < =   l e n g t h   c s v . n a m e   + 2                     x     w h e r e   l e n g t h   s u b s t r   n a m e , p o s       >   1     P O S   E M P S                         C                                 R N   - - -   - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - - -   - -       1   , m o , l a r r y , c u r l y ,   , m o , l a r r y , c u r l y ,   1       2   , m o , l a r r y , c u r l y ,   m o , l a r r y , c u r l y ,     2       3   , m o , l a r r y , c u r l y ,   o , l a r r y , c u r l y ,       3    Now that different portions of the string are available to you, simply identify which rows to keep. The rows you are interested in are the ones that begin with a comma; the rest can be discarded:  This is an important step as it sets up how you will get the nth substring. Notice that many rows have been eliminated from this query because of the      4   , m o , l a r r y , c u r l y ,   , l a r r y , c u r l y ,         4       … s e l e c t   p o s ,   n a m e ,   s u b s t r   n a m e , p o s     c ,                 r o w _ n u m b e r       o v e r   p a r t i t i o n   b y   n a m e                                                 o r d e r   b y   l e n g t h   s u b s t r   n a m e ,   p o s       d e s c     r n       f r o m       s e l e c t   ' , '   c s v . n a m e   ' , '   a s   n a m e ,                 c a s t   i t e r . p o s   a s   i n t e g e r     a s   p o s       f r o m   v   c s v ,                   s e l e c t   r o w _ n u m b e r       o v e r       p o s   f r o m   t 1 0 0       i t e r       w h e r e   i t e r . p o s   < =   l e n g t h   c s v . n a m e   + 2                     x       w h e r e   l e n g t h   s u b s t r   n a m e , p o s       >   1             a n d   s u b s t r   s u b s t r   n a m e , p o s   , 1 , 1     =   ' , '       P O S     E M P S                                                               C                                                                         R N     - - -     - - - - - - - - - - - - - -                                           - - - - - - - - - - - - - - - -                                             - -         1     , m o , l a r r y , c u r l y ,                                       , m o , l a r r y , c u r l y ,                                               1         4     , m o , l a r r y , c u r l y ,                                       , l a r r y , c u r l y ,                                                     2       1 0     , m o , l a r r y , c u r l y ,                                       , c u r l y ,                                                                 3         1     , t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a ,       , t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a ,               1         6     , t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a ,       , g i n a , j a u n i t a , r e g i n a , l e e n a ,                         2       1 1     , t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a ,       , j a u n i t a , r e g i n a , l e e n a ,                                   3       1 9     , t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a ,       , r e g i n a , l e e n a ,                                                   4       2 6     , t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a ,       , l e e n a ,                                                                 5  following condition in the WHERE clause:  , was ranked 4, but now is ranked 2.  You’ll notice that , Remember, the WHERE clause is evaluated before the SELECT, so the rows with leading commas are kept, then ROW_NUMBER performs its ranking. At this point it’s easy to see that, to get the nth substring, you want rows where RN equals n. The last step is to keep only the rows you are interested in  in this case where RN equals two  and use SUBSTR to extract the name from that row. The name to keep is the first name in the row:  y from ,  a from  , and g ,.  MySQL The inline view X walks each string. You can determine how many values are in each string by counting the delimiters in the string:  In this case, there is one fewer row than values in each string because that’s all that is needed. The function SUBSTRING_INDEX takes care of parsing the needed values:  s u b s t r   s u b s t r   n a m e , p o s   , 1 , 1     =   ' , ' m o , l a r r y , c u r l y l a r r l a r r y , c u r l y i n , g i n a , j a u n i t a , r e g i n a , l e e n a s e l e c t   i t e r . p o s ,   s r c . n a m e       f r o m     s e l e c t   i d   p o s   f r o m   t 1 0     i t e r ,                 V   s r c     w h e r e   i t e r . p o s   < =                 l e n g t h   s r c . n a m e   - l e n g t h   r e p l a c e   s r c . n a m e , ' , ' , ' '         + - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +      p o s        n a m e                                                          + - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +            1      m o , l a r r y , c u r l y                                               2      m o , l a r r y , c u r l y                                               1      t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a               2      t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a               3      t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a               4      t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a      + - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +  We’ve shown three name fields, so you can see how the nested SUBSTRING_INDEX calls work. The inner call returns all characters to the left of the nth occurrence of a comma. The outer call returns everything to the right of the first comma it finds  starting from the end of the string . The final step is to keep the value for NAME3 where POS equals n, in this case 2.  SQL Server STRING_SPLIT is the workhorse here, but needs its data the right way. The CTE is merely to turn the two rows of the V.names column into a single value, as required by STRING_SPLIT being a table-valued function.  Oracle The inline view walks each string. The number of times each string is returned is determined by how many values are in each string. The solution finds the number of values in each string by counting the number of delimiters in it. Because each string is enclosed in commas, the number of values in a string is the number of commas minus one. The strings are then UNIONed and joined to a table with a cardinality that is at least the number    s e l e c t   i t e r . p o s , s r c . n a m e   n a m e 1 ,                     s u b s t r i n g _ i n d e x   s r c . n a m e , ' , ' , i t e r . p o s     n a m e 2 ,                     s u b s t r i n g _ i n d e x                         s u b s t r i n g _ i n d e x   s r c . n a m e , ' , ' , i t e r . p o s   , ' , ' , - 1     n a m e 3           f r o m     s e l e c t   i d   p o s   f r o m   t 1 0     i t e r ,                     V   s r c         w h e r e     i t e r . p o s   < =                     l e n g t h   s r c . n a m e   - l e n g t h   r e p l a c e   s r c . n a m e , ' , ' , ' '         + - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - +      p o s        n a m e 1                                                    n a m e 2                                                n a m e 3          + - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - +            1      m o , l a r r y , c u r l y                                      m o                                                  m o                         2      m o , l a r r y , c u r l y                                      m o , l a r r y                                      l a r r y                   1      t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a      t i n a                                              t i n a                     2      t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a      t i n a , g i n a                                    g i n a                     3      t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a      t i n a , g i n a , j a u n i t a                    j a u n i t a               4      t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a      t i n a , g i n a , j a u n i t a , r e g i n a      r e g i n a        + - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - +  of values in the largest string. The functions SUBSTR and INSTR use the value of POS to parse each string:  The first call to INSTR within SUBSTR determines the start position of the substring to extract. The next call to INSTR within SUBSTR finds the position of the nth comma  same as the start position  as well the position of the nth + 1 comma. Subtracting the two values returns the length of the substring to extract. Because every value is parsed into its own row, simply specify WHERE POS = n to keep the nth substring  in this case, where POS = 2, so the second substring in the list .  PostgreSQL The inline view X walks each string. The number of rows returned is determined by how many values are in each string. To find the number of values in each string, find the number of delimiters in each string and add one. The function SPLIT_PART uses the values in POS to find the nth occurrence of the delimiter and parse the string into values:  s e l e c t   i t e r . p o s ,   s r c . n a m e ,                 s u b s t r     s r c . n a m e ,                   i n s t r     s r c . n a m e , ' , ' , 1 , i t e r . p o s     + 1 ,                   i n s t r     s r c . n a m e , ' , ' , 1 , i t e r . p o s + 1                       i n s t r     s r c . n a m e , ' , ' , 1 , i t e r . p o s     - 1     s u b       f r o m     s e l e c t   ' , '   n a m e   ' , '   a s   n a m e   f r o m   v     s r c ,                   s e l e c t   r o w n u m   p o s   f r o m   e m p     i t e r     w h e r e   i t e r . p o s   <   l e n g t h   s r c . n a m e   - l e n g t h   r e p l a c e   s r c . n a m e , ' , '           P O S   N A M E                                                             S U B   - - -   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   - - - - - - - - - - - - -       1   , m o , l a r r y , c u r l y ,                                     m o       1   ,   t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a ,   t i n a       2   , m o , l a r r y , c u r l y ,                                     l a r r y       2   ,   t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a ,   g i n a       3   , m o , l a r r y , c u r l y ,                                     c u r l y       3   ,   t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a ,   j a u n i t a       4   ,   t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a ,   r e g i n a       5   ,   t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a ,   l e e n a  We’ve shown NAME twice so you can see how SPLIT_PART parses each string using POS. Once each string is parsed, the final step is to keep the rows where POS equals the nth substring you are interested in, in this case, 2.  6.15 Parsing an IP Address  Problem You want to parse an IP address’s fields into columns. Consider the following IP address:  You would like the result of your query to be:  Solution  s e l e c t   i t e r . p o s ,   s r c . n a m e   a s   n a m e 1 ,                   s p l i t _ p a r t   s r c . n a m e , ' , ' , i t e r . p o s     a s   n a m e 2         f r o m     s e l e c t   i d   a s   p o s   f r o m   t 1 0     i t e r ,                     s e l e c t   c a s t   n a m e   a s   t e x t     a s   n a m e   f r o m   v     s r c       w h e r e   i t e r . p o s   < =                   l e n g t h   s r c . n a m e   - l e n g t h   r e p l a c e   s r c . n a m e , ' , ' , ' '     + 1       p o s                              n a m e 1                                  n a m e 2   - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + - - - - - - - - -         1      m o , l a r r y , c u r l y                                      m o         2      m o , l a r r y , c u r l y                                      l a r r y         3      m o , l a r r y , c u r l y                                      c u r l y         1      t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a      t i n a         2      t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a      g i n a         3      t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a      j a u n i t a         4      t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a      r e g i n a         5      t i n a , g i n a , j a u n i t a , r e g i n a , l e e n a      l e e n a 1 1 1 . 2 2 . 3 . 4 A           B         C             D   - - - - -   - - - - -   - - - - -   - - -   1 1 1       2 2         3           4  The solution depends on the built-in functions provided by your DBMS. Regardless of your DBMS, being able to locate periods and the numbers immediately surrounding them are the keys to the solution.  DB2 Use the recursive WITH clause to simulate an iteration through the IP address while using SUBSTR to easily parse it. A leading period is added to the IP address so that every set of numbers has a period in front of it and can be treated the same way.  MySQL The function SUBSTR_INDEX makes parsing an IP address an easy operation:    1   w i t h   x     p o s , i p     a s         2       v a l u e s     1 , ' . 9 2 . 1 1 1 . 0 . 2 2 2 '       3       u n i o n   a l l     4     s e l e c t   p o s + 1 , i p   f r o m   x   w h e r e   p o s + 1   < =   2 0     5         6   s e l e c t   m a x   c a s e   w h e n   r n = 1   t h e n   e   e n d     a ,     7                 m a x   c a s e   w h e n   r n = 2   t h e n   e   e n d     b ,     8                 m a x   c a s e   w h e n   r n = 3   t h e n   e   e n d     c ,     9                 m a x   c a s e   w h e n   r n = 4   t h e n   e   e n d     d   1 0       f r o m       1 1   s e l e c t   p o s , c , d ,   1 2                 c a s e   w h e n   p o s s t r   d , ' . '     >   0   t h e n   s u b s t r   d , 1 , p o s s t r   d , ' . '   - 1     1 3                           e l s e   d   1 4                 e n d   a s   e ,   1 5                 r o w _ n u m b e r       o v e r     o r d e r   b y   p o s   d e s c     r n   1 6       f r o m       1 7   s e l e c t   p o s ,   i p , r i g h t   i p , p o s     a s   c ,   s u b s t r   r i g h t   i p , p o s   , 2     a s   d   1 8       f r o m   x   1 9     w h e r e   p o s   < =   l e n g t h   i p     2 0       a n d   s u b s t r   r i g h t   i p , p o s   , 1 , 1     =   ' . '   2 1                 x   2 2                 y 1   s e l e c t   s u b s t r i n g _ i n d e x   s u b s t r i n g _ i n d e x   y . i p , ' . ' , 1   , ' . ' , - 1     a ,   2                 s u b s t r i n g _ i n d e x   s u b s t r i n g _ i n d e x   y . i p , ' . ' , 2   , ' . ' , - 1     b ,   3                 s u b s t r i n g _ i n d e x   s u b s t r i n g _ i n d e x   y . i p , ' . ' , 3   , ' . ' , - 1     c ,    Oracle Use the built-in function SUBSTR and INSTR to parse and navigate through the IP address:  PostgreSQL Use the built-in function SPLIT_PART to parse an IP address:  SQL Server Use the recursive WITH clause to simulate an iteration through the IP address while using SUBSTR to easily parse it. A leading period is added to the IP address so that every set of numbers has a period in front of it and can be treated the same way:  4                 s u b s t r i n g _ i n d e x   s u b s t r i n g _ i n d e x   y . i p , ' . ' , 4   , ' . ' , - 1     d   5       f r o m     s e l e c t   ' 9 2 . 1 1 1 . 0 . 2 '   a s   i p   f r o m   t 1     y 1   s e l e c t   i p ,   2                 s u b s t r   i p ,   1 ,   i n s t r   i p , ' . '   - 1       a ,   3                 s u b s t r   i p ,   i n s t r   i p , ' . '   + 1 ,   4                                         i n s t r   i p , ' . ' , 1 , 2   - i n s t r   i p , ' . '   - 1       b ,   5                 s u b s t r   i p ,   i n s t r   i p , ' . ' , 1 , 2   + 1 ,   6                                         i n s t r   i p , ' . ' , 1 , 3   - i n s t r   i p , ' . ' , 1 , 2   - 1       c ,   7                 s u b s t r   i p ,   i n s t r   i p , ' . ' , 1 , 3   + 1       d   8       f r o m     s e l e c t   ' 9 2 . 1 1 1 . 0 . 2 '   a s   i p   f r o m   t 1   1   s e l e c t   s p l i t _ p a r t   y . i p , ' . ' , 1     a s   a ,   2                 s p l i t _ p a r t   y . i p , ' . ' , 2     a s   b ,   3                 s p l i t _ p a r t   y . i p , ' . ' , 3     a s   c ,   4                 s p l i t _ p a r t   y . i p , ' . ' , 4     a s   d   5       f r o m     s e l e c t   c a s t   ' 9 2 . 1 1 1 . 0 . 2 '   a s   t e x t     a s   i p   f r o m   t 1     a s   y   1     w i t h   x     p o s , i p     a s         2         s e l e c t   1   a s   p o s , ' . 9 2 . 1 1 1 . 0 . 2 2 2 '   a s   i p   f r o m   t 1     3         u n i o n   a l l     4       s e l e c t   p o s + 1 , i p   f r o m   x   w h e r e   p o s + 1   < =   2 0     5           6     s e l e c t   m a x   c a s e   w h e n   r n = 1   t h e n   e   e n d     a ,     7                   m a x   c a s e   w h e n   r n = 2   t h e n   e   e n d     b ,     8                   m a x   c a s e   w h e n   r n = 3   t h e n   e   e n d     c ,     9                   m a x   c a s e   w h e n   r n = 4   t h e n   e   e n d     d    Discussion By using the built-in functions for your database, you can easily walk through parts of a string. The key is being able to locate each of the periods in the address. Then you can parse the numbers between each. In Recipe 6.17 we will see how regular expressions can be used with most RDBMSs—parsing an IP address is also a good area to apply this idea.  6.16 Comparing Strings by Sound  Problem Between spelling mistakes and legitimate ways to spell words differently, such as British versus American spelling, there are many times that two words that you want to match are represented by different strings of characters. Fortunately, SQL provides a way to represent the way words sound, which allows you to find strings that sound the same even though the underlying characters aren’t identical. For example, you have a list of authors’ names, including some from an earlier era when spelling wasn’t as fixed as it is now, combined with some extra misspellings and typos. The following column of names is an example:  1 0         f r o m         1 1     s e l e c t   p o s , c , d ,   1 2                   c a s e   w h e n   c h a r i n d e x   ' . ' , d     >   0   1 3                         t h e n   s u b s t r i n g   d , 1 , c h a r i n d e x   ' . ' , d   - 1     1 4                         e l s e   d   1 5                 e n d   a s   e ,   1 6                 r o w _ n u m b e r       o v e r   o r d e r   b y   p o s   d e s c     r n   1 7       f r o m       1 8   s e l e c t   p o s ,   i p , r i g h t   i p , p o s     a s   c ,   1 9                 s u b s t r i n g   r i g h t   i p , p o s   , 2 , l e n   i p       a s   d   2 0       f r o m   x   2 1     w h e r e   p o s   < =   l e n   i p     2 2         a n d   s u b s t r i n g   r i g h t   i p , p o s   , 1 , 1     =   ' . '   2 3                   x   2 4                   y  Although this is likely part of a longer list, you’d like to identify which of these names are plausible phonetic matches for other names on the list. While this is an exercise where there is more than one possible solution, your solution will look something like this  the meaning of the last column will become clearer by the end of the recipe :  Solution Use the SOUNDEX function to convert strings of characters into the way they sound when spoken in English. A simple self-join allows you to compare values from the same column.    a _ n a m e   - - - -   1   J o h n s o n   2   J o n s o n   3   J o n s e n   4   J e n s e n   5   J o h n s e n   6   S h a k e s p e a r e   7   S h a k s p e a r   8   S h a e k s p i r   9   S h a k e s p a r a _ n a m e 1                 a _ n a m e 2               s o u n d e x _ n a m e   - - - -                       - - - -                     - - - -   J e n s e n                 J o h n s o n             J 5 2 5   J e n s e n                 J o n s o n             J 5 2 5   J e n s e n                 J o n s e n             J 5 2 5   J e n s e n                 J o h n s e n             J 5 2 5   J o h n s e n                 J o h n s o n             J 5 2 5   J o h n s e n                 J o n s o n             J 5 2 5   J o h n s e n                 J o n s e n             J 5 2 5   J o h n s e n                 J e n s e n             J 5 2 5   . . .   J o n s o n                 J e n s e n             J 5 2 5   J o n s o n                 J o h n s e n             J 5 2 5   S h a e k s p i r         S h a k s p e a r     S 2 1 6   S h a k e s p a r         S h a k e s p e a r e     S 2 2 1   S h a k e s p e a r e         S h a k e s p a r     S 2 2 1   S h a k s p e a r         S h a e k s p i r     S 2 1 6  Discussion The thinking behind SOUNDEX predates both databases and computing, as it originated with the US Census as an attempt to resolve different spellings of proper names for both people and places. There are many algorithms that attempt the same task as SOUNDEX, and, of course, there are alternative versions for languages other than English. However, we cover SOUNDEX, as it comes with most RDBMSs. Soundex keeps the first letter of the name and then replaces the remaining values with numbers that have the same value if they are phonetically similar. For example, m and n are both replaced with the number 5. In the previous example, the actual Soundex output is shown in the Soundex_Name column. This is just to show what is happening, and not necessary for the solution; some RDMSs even have a function that hides the Soundex result, such as SQL Server’s D compares two strings using Soundex and returns a similarity scale from 0 to 4  e.g., 4 is a perfect match between the Soundex outputs, representing 4 4 characters in the Soundex version if the two strings match . Sometimes Soundex will be sufficient for your needs; other times it won’t be. However, a small amount of research, possibly using texts such as Data Matching  Christen, 2012 , will help you find other algorithms that are frequently  but not always  simple to implement as a user-defined function, or in another programming language to suit your taste and needs.  e function, which  6.17 Finding Text Not Matching a Pattern  Problem  1     s e l e c t   a n 1 . a _ n a m e   a s   n a m e 1 ,   a n 2 . a _ n a m e   a s   n a m e 2 ,   2     S O U N D E X   a n 1 . a _ n a m e     a s   S o u n d e x _ N a m e   3     f r o m   a u t h o r _ n a m e s   a n 1   4     j o i n   a u t h o r _ n a m e s   a n 2   5     o n     S O U N D E X   a n 1 . a _ n a m e   = S O U N D E X   a n 2 . a _ n a m e     6     a n d   a n 1 . a _ n a m e   n o t   l i k e   a n 2 . a _ n a m e   i f f e r e n c  You have a text field that contains some structured text values  e.g., phone numbers , and you want to find occurrences where those values are structured incorrectly. For example, you have data like the following:  and you want to list rows having invalidly formatted phone numbers. For example, you want to list the following row because its phone number uses two different separator characters:  You want to consider valid only those phone numbers that use the same character for both delimiters.  Solution This problem has a multipart solution:  1. Find a way to describe the universe of apparent phone numbers that  you want to consider.  2. Remove any validly formatted phone numbers from consideration. 3. See whether you still have any apparent phone numbers left. If you  do, you know those are invalidly formatted.  s e l e c t   e m p _ i d ,   t e x t       f r o m   e m p l o y e e _ c o m m e n t     E M P _ I D           T E X T   - - - - - - - - - -   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   7 3 6 9               1 2 6   V a r n u m ,   E d m o r e   M I   4 8 8 2 9 ,   9 8 9   3 1 3 - 5 3 5 1   7 4 9 9               1 1 0 5   M c C o n n e l l   C o u r t                         C e d a r   L a k e   M I   4 8 8 1 2                         H o m e :   9 8 9 - 3 8 7 - 4 3 2 1                         C e l l :     2 3 7     4 3 8 - 3 3 3 3 7 3 6 9                         1 2 6   V a r n u m ,   E d m o r e   M I   4 8 8 2 9 ,   9 8 9   3 1 3 - 5 3 5 1 s e l e c t   e m p _ i d ,   t e x t   f r o m   e m p l o y e e _ c o m m e n t   w h e r e   r e g e x p _ l i k e   t e x t ,   ' [ 0 - 9 ] { 3 } [ - .   ] [ 0 - 9 ] { 3 } [ - .   ] [ 0 - 9 ] { 4 } '         a n d   r e g e x p _ l i k e                       r e g e x p _ r e p l a c e   t e x t ,    Each of these rows contains at least one apparent phone number that is not correctly formatted.  Discussion The key to this solution lies in the detection of an “apparent phone number.” Given that the phone numbers are stored in a comment field, any text at all in the field could be construed to be an invalid phone number. You need a way to narrow the field to a more reasonable set of values to consider. You don’t, for example, want to see the following row in your output:  Clearly there’s no phone number at all in this row, much less one that is invalid. We can all see that. The question is, how do you get the RDBMS to “see” it? We think you’ll enjoy the answer. Please read on.  This recipe comes  with permission  from an article by Jonathan Gennick called “Regular Expression Anti-Patterns.”  TIP  The solution uses Pattern A to define the set of “apparent” phone numbers to consider:                          ' [ 0 - 9 ] { 3 }   [ - .   ]   [ 0 - 9 ] { 3 } \ 1 [ 0 - 9 ] { 4 } ' , ' * * * '   ,                     ' [ 0 - 9 ] { 3 } [ - .   ] [ 0 - 9 ] { 3 } [ - .   ] [ 0 - 9 ] { 4 } '               E M P _ I D   T E X T   - - - - - - - - - -   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -       7 3 6 9           1 2 6   V a r n u m ,   E d m o r e   M I   4 8 8 2 9 ,   9 8 9   3 1 3 - 5 3 5 1       7 8 4 4           9 8 9 - 3 8 7 . 5 3 5 9       9 9 9 9           9 0 6 - 3 8 7 - 1 6 9 8 ,   3 1 3 - 5 3 5 . 8 8 8 6         E M P _ I D   T E X T   - - - - - - - - - -   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               7 9 0 0   C a r e s   f o r   1 0 0 - y e a r - o l d   a u n t   d u r i n g   t h e   d a y .   S c h e d u l e   o n l y                         f o r   e v e n i n g   a n d   n i g h t   s h i f t s .  Pattern A checks for two groups of three digits followed by one group of four digits. Any one of a dash  - , a period  . , or a space is accepted as a delimiter between groups. You could come up with a more complex pattern. For example, you could decide that you also want to consider seven-digit phone numbers. But don’t get side-tracked. The point now is that somehow you do need to define the universe of possible phone number strings to consider, and for this problem that universe is defined by Pattern A. You can define a different Pattern A, and the general solution still applies. The solution uses Pattern A in the WHERE clause to ensure that only rows having potential phone numbers  as defined by the pattern!  are considered:  Next, you need to define what a “good” phone number looks like. The solution does this using Pattern B:  This time, the pattern uses \1 to reference the first subexpression. Whichever character is matched by  [-. ]  must also be matched by \1. Pattern B describes good phone numbers, which must be eliminated from consideration  as they are not bad . The solution eliminates the well- formatted phone numbers through a call to REGEXP_ REPLACE:  This call to REGEXP_REPLACE occurs in the WHERE clause. Any well- formatted phone numbers are replaced by a string of three asterisks. Again, Pattern B can be any pattern that you desire. The point is that Pattern B describes the acceptable pattern that you are after.  P a t t e r n   A :   [ 0 - 9 ] { 3 } [ - .   ] [ 0 - 9 ] { 3 } [ - .   ] [ 0 - 9 ] { 4 } s e l e c t   e m p _ i d ,   t e x t       f r o m   e m p l o y e e _ c o m m e n t     w h e r e   r e g e x p _ l i k e   t e x t ,   ' [ 0 - 9 ] { 3 } [ - .   ] [ 0 - 9 ] { 3 } [ - .   ] [ 0 - 9 ] { 4 } '   P a t t e r n   B :   [ 0 - 9 ] { 3 }   [ - .   ]   [ 0 - 9 ] { 3 } \ 1 [ 0 - 9 ] { 4 } r e g e x p _ r e p l a c e   t e x t ,           ' [ 0 - 9 ] { 3 }   [ - .   ]   [ 0 - 9 ] { 3 } \ 1 [ 0 - 9 ] { 4 } ' , ' * * * '   ,  Having replaced well-formatted phone numbers with strings of three asterisks  * , any “apparent” phone numbers that remain must, by definition, be poorly formatted. The solution applies REGEXP_LIKE to the output from REGEXP_LIKE to see whether any poorly formatted phone numbers remain:  TIP  Regular expressions are a big topic in their own right, requiring practice to master. Once you do master them, you will find they match a great variety of string patterns with ease. We recommend studying a book such as Mastering Regular Expressions by Jeffrey Friedl to get your regular expression skills to the required level.  6.18 Summing Up Matching on strings can be a painful task. SQL has added a range of tools to reduce the pain, and mastering them will keep you out of trouble. Although a lot can be done with the native SQL string functions, using the regular expression functions that are increasingly available takes it to another level altogether.  a n d   r e g e x p _ l i k e                   r e g e x p _ r e p l a c e   t e x t ,                       ' [ 0 - 9 ] { 3 }   [ - .   ]   [ 0 - 9 ] { 3 } \ 1 [ 0 - 9 ] { 4 } ' , ' * * * '   ,                 ' [ 0 - 9 ] { 3 } [ - .   ] [ 0 - 9 ] { 3 } [ - .   ] [ 0 - 9 ] { 4 } '    Chapter 7. Working with Numbers  This chapter focuses on common operations involving numbers, including numeric computations. While SQL is not typically considered the first choice for complex computations, it is efficient for day-to-day numeric chores. More importantly, as databases and datawarehouses supporting SQL probably remain the most common place to find an organization’s data, using SQL to explore and evaluate that data is essential for anyone putting that data to work. The techniques in this section have also been chosen to help data scientists decide which data is the most promising for further analysis.  TIP  Some recipes in this chapter make use of aggregate functions and the GROUP BY clause. If you are not familiar with grouping, please read at least the first major section, called “Grouping,” in Appendix A.  7.1 Computing an Average  Problem You want to compute the average value in a column, either for all rows in a table or for some subset of rows. For example, you might want to find the average salary for all employees as well as the average salary for each department.  Solution   When computing the average of all employee salaries, simply apply the AVG function to the column containing those salaries. By excluding a WHERE clause, the average is computed against all non- NULL values:  To compute the average salary for each department, use the GROUP BY clause to create a group corresponding to each department:  Discussion When finding an average where the whole table is the group or window, simply apply the AVG function to the column you are interested in without using the GROUP BY clause. It is important to realize that the function AVG ignores NULLs. The effect of NULL values being ignored can be seen here:  1   s e l e c t   a v g   s a l     a s   a v g _ s a l   2       f r o m   e m p           A V G _ S A L   - - - - - - - - - -   2 0 7 3 . 2 1 4 2 9 1   s e l e c t   d e p t n o ,   a v g   s a l     a s   a v g _ s a l   2       f r o m   e m p   3     g r o u p   b y   d e p t n o             D E P T N O           A V G _ S A L   - - - - - - - - - -     - - - - - - - - - -                   1 0     2 9 1 6 . 6 6 6 6 7                   2 0                 2 1 7 5                   3 0     1 5 6 6 . 6 6 6 6 7 c r e a t e   t a b l e   t 2   s a l   i n t e g e r     i n s e r t   i n t o   t 2   v a l u e s     1 0     i n s e r t   i n t o   t 2   v a l u e s     2 0     i n s e r t   i n t o   t 2   v a l u e s     n u l l     s e l e c t   a v g   s a l           s e l e c t   d i s t i n c t   3 0   2       f r o m   t 2                         f r o m   t 2         A V G   S A L                                 3 0   2    The COALESCE function will return the first non-NULL value found in the list of values that you pass. When NULL SAL values are converted to zero, the average changes. When invoking aggregate functions, always give thought to how you want NULLs handled. The second part of the solution uses GROUP BY  line 3  to divide employee records into groups based on department affiliation. GROUP BY automatically causes aggregate functions such as AVG to execute and return a result for each group. In this example, AVG would execute once for each department-based group of employee records. It is not necessary, by the way, to include GROUP BY columns in your select list. For example:  You are still grouping by DEPTNO even though it is not in the SELECT clause. Including the column you are grouping by in the SELECT clause often improves readability, but is not mandatory. It is mandatory, however, to avoid placing columns in your SELECT list that are not also in your GROUP BY clause.  - - - - - - - - - -                   - - - - - - - - - -                   1 5                                   1 5       s e l e c t   a v g   c o a l e s c e   s a l , 0             s e l e c t   d i s t i n c t   3 0   3       f r o m   t 2                                                 f r o m   t 2     A V G   C O A L E S C E   S A L , 0                                       3 0   3   - - - - - - - - - - - - - - - - - - - -                       - - - - - - - - - -                                       1 0                                       1 0 s e l e c t   a v g   s a l         f r o m   e m p     g r o u p   b y   d e p t n o         A V G   S A L     - - - - - - - - - -   2 9 1 6 . 6 6 6 6 7               2 1 7 5   1 5 6 6 . 6 6 6 6 7  See Also See Appendix A for a refresher on GROUP BY functionality.  7.2 Finding the Min Max Value in a Column  Problem You want to find the highest and lowest values in a given column. For example, you want to find the highest and lowest salaries for all employees, as well as the highest and lowest salaries for each department.  Solution When searching for the lowest and highest salaries for all employees, simply use the functions MIN and MAX, respectively:  When searching for the lowest and highest salaries for each department, use the functions MIN and MAX with the GROUP BY clause:  Discussion  1   s e l e c t   m i n   s a l     a s   m i n _ s a l ,   m a x   s a l     a s   m a x _ s a l       2       f r o m   e m p           M I N _ S A L           M A X _ S A L   - - - - - - - - - -     - - - - - - - - - -                 8 0 0                 5 0 0 0 1   s e l e c t   d e p t n o ,   m i n   s a l     a s   m i n _ s a l ,   m a x   s a l     a s   m a x _ s a l       2       f r o m   e m p       3     g r o u p   b y   d e p t n o                     D E P T N O           M I N _ S A L           M A X _ S A L           - - - - - - - - - -     - - - - - - - - - -     - - - - - - - - - -                           1 0                 1 3 0 0                 5 0 0 0                           2 0                   8 0 0                 3 0 0 0                           3 0                   9 5 0                 2 8 5 0  When searching for the highest or lowest values, and in cases where the whole table is the group or window, simply apply the MIN or MAX function to the column you are interested in without using the GROUP BY clause. Remember that the MIN and MAX functions ignore NULLs, and that you can have NULL groups as well as NULL values for columns in a group. The following are examples that ultimately lead to a query using GROUP BY that returns NULL values for two groups  DEPTNO 10 and 20 :  s e l e c t   d e p t n o ,   c o m m       f r o m   e m p     w h e r e   d e p t n o   i n     1 0 , 3 0       o r d e r   b y   1                 D E P T N O               C O M M     - - - - - - - - - -   - - - - - - - - - -                     1 0                     1 0                     1 0                     3 0                 3 0 0                     3 0                 5 0 0                     3 0                     3 0                     0                     3 0               1 3 0 0                     3 0       s e l e c t   m i n   c o m m   ,   m a x   c o m m         f r o m   e m p       M I N   C O M M         M A X   C O M M     - - - - - - - - - -     - - - - - - - - - -                     0                 1 3 0 0       s e l e c t   d e p t n o ,   m i n   c o m m   ,   m a x   c o m m         f r o m   e m p     g r o u p   b y   d e p t n o               D E P T N O     M I N   C O M M         M A X   C O M M       - - - - - - - - - -   - - - - - - - - - -     - - - - - - - - - -                     1 0    Remember, as Appendix A points out, even if nothing other than aggregate functions are listed in the SELECT clause, you can still group by other columns in the table; for example:  Here you are still grouping by DEPTNO even though it is not in the SELECT clause. Including the column you are grouping by in the SELECT clause often improves readability, but is not mandatory. It is mandatory, however, that any column in the SELECT list of a GROUP BY query also be listed in the GROUP BY clause.  See Also See Appendix A for a refresher on GROUP BY functionality.  7.3 Summing the Values in a Column  Problem You want to compute the sum of all values, such as all employee salaries, in a column.  Solution When computing a sum where the whole table is the group or window, just apply the SUM function to the columns you are interested in without using the GROUP BY clause:                    2 0                     3 0                     0                 1 3 0 0 s e l e c t   m i n   c o m m   ,   m a x   c o m m         f r o m   e m p     g r o u p   b y   d e p t n o       M I N   C O M M         M A X   C O M M     - - - - - - - - - -     - - - - - - - - - -                     0                 1 3 0 0  When creating multiple groups or windows of data, use the SUM function with the GROUP BY clause. The following example sums employee salaries by department:  Discussion When searching for the sum of all salaries for each department, you are creating groups or “windows” of data. Each employee’s salary is added together to produce a total for their respective department. This is an example of aggregation in SQL because detailed information, such as each individual employee’s salary, is not the focus; the focus is the end result for each department. It is important to note that the SUM function will ignore NULLs, but you can have NULL groups, which can be seen here. DEPTNO 10 does not have any employees who earn a commission; thus, grouping by DEPTNO 10 while attempting to SUM the values in COMM will result in a group with a NULL value returned by SUM:  1   s e l e c t   s u m   s a l     2     f r o m   e m p         S U M   S A L     - - - - - - - - - -             2 9 0 2 5 1   s e l e c t   d e p t n o ,   s u m   s a l     a s   t o t a l _ f o r _ d e p t   2       f r o m   e m p   3     g r o u p   b y   d e p t n o               D E P T N O     T O T A L _ F O R _ D E P T   - - - - - - - - - -     - - - - - - - - - - - - - -                   1 0                         8 7 5 0                   2 0                       1 0 8 7 5                   3 0                         9 4 0 0 s e l e c t   d e p t n o ,   c o m m       f r o m   e m p     w h e r e   d e p t n o   i n     1 0 , 3 0       o r d e r   b y   1             D E P T N O               C O M M    See Also See Appendix A for a refresher on GROUP BY functionality.  7.4 Counting Rows in a Table  Problem You want to count the number of rows in a table, or you want to count the number of values in a column. For example, you want to find the total number of employees as well as the number of employees in each department.  - - - - - - - - - -   - - - - - - - - - -                   1 0                   1 0                   1 0                   3 0                 3 0 0                   3 0                 5 0 0                   3 0                   3 0                     0                   3 0               1 3 0 0                   3 0       s e l e c t   s u m   c o m m         f r o m   e m p       S U M   C O M M     - - - - - - - - - -               2 1 0 0     s e l e c t   d e p t n o ,   s u m   c o m m         f r o m   e m p     w h e r e   d e p t n o   i n     1 0 , 3 0       g r o u p   b y   d e p t n o             D E P T N O       S U M   C O M M     - - - - - - - - - -     - - - - - - - - - -                   1 0                   3 0                 2 1 0 0  Solution When counting rows where the whole table is the group or window, simply use the COUNT function along with the * character:  When creating multiple groups, or windows of data, use the COUNT function with the GROUP BY clause:  Discussion When counting the number of employees for each department, you are creating groups or “windows” of data. Each employee found increments the count by one to produce a total for their respective department. This is an example of aggregation in SQL because detailed information, such as each individual employee’s salary or job, is not the focus; the focus is the end result for each department. It is important to note that the COUNT function will ignore NULLs when passed a column name as an argument, but will include NULLs when passed the * character or any constant; consider the following:  1   s e l e c t   c o u n t   *     2     f r o m   e m p         C O U N T   *     - - - - - - - - - -                   1 4 1   s e l e c t   d e p t n o ,   c o u n t   *     2       f r o m   e m p   3     g r o u p   b y   d e p t n o             D E P T N O         C O U N T   *     - - - - - - - - - -     - - - - - - - - - -                   1 0                       3                   2 0                       5                   3 0                       6 s e l e c t   d e p t n o ,   c o m m       f r o m   e m p      If all rows are null for the column passed to COUNT or if the table is empty, COUNT will return zero. It should also be noted that, even if nothing other than aggregate functions are specified in the SELECT clause, you can still group by other columns in the table, for example:          D E P T N O                 C O M M   - - - - - - - - - -     - - - - - - - - - -                   2 0                   3 0                   3 0 0                   3 0                   5 0 0                   2 0                   3 0                 1 3 0 0                   3 0                   1 0                   2 0                   1 0                   3 0                       0                   2 0                   3 0                   2 0                   1 0       s e l e c t   c o u n t   *   ,   c o u n t   d e p t n o   ,   c o u n t   c o m m   ,   c o u n t   ' h e l l o '         f r o m   e m p         C O U N T   *       C O U N T   D E P T N O         C O U N T   C O M M       C O U N T   ' H E L L O '     - - - - - - - - - -     - - - - - - - - - - - - -       - - - - - - - - - - -     - - - - - - - - - - - - - -                   1 4                           1 4                           4                             1 4       s e l e c t   d e p t n o ,   c o u n t   *   ,   c o u n t   c o m m   ,   c o u n t   ' h e l l o '         f r o m   e m p     g r o u p   b y   d e p t n o               D E P T N O       C O U N T   *       C O U N T   C O M M       C O U N T   ' H E L L O '       - - - - - - - - - -   - - - - - - - - - -     - - - - - - - - - - -     - - - - - - - - - - - - - -                     1 0                     3                         0                               3                     2 0                     5                         0                               5                     3 0                     6                         4                               6 s e l e c t   c o u n t   *         f r o m   e m p     g r o u p   b y   d e p t n o      Notice that you are still grouping by DEPTNO even though it is not in the SELECT clause. Including the column you are grouping by in the SELECT clause often improves readability, but is not mandatory. If you do include it  in the SELECT list , it is mandatory that it is listed in the GROUP BY clause.  See Also See Appendix A for a refresher on GROUP BY functionality.  7.5 Counting Values in a Column  Problem You want to count the number of non-NULL values in a column. For example, you’d like to find out how many employees are on commission.  Solution Count the number of non-NULL values in the EMP table’s COMM column:  Discussion When you “count star,” as in COUNT * , what you are really counting is rows  regardless of actual value, which is why rows containing NULL and        C O U N T   *       - - - - - - - - - -                       3                       5                       6 s e l e c t   c o u n t   c o m m         f r o m   e m p     C O U N T   C O M M     - - - - - - - - - - -                       4  non-NULL values are counted . But when you COUNT a column, you are counting the number of non-NULL values in that column. The previous recipe’s discussion touches on this distinction. In this solution, COUNT COMM  returns the number of non-NULL values in the COMM column. Since only commissioned employees have commissions, the result of COUNT COMM  is the number of such employees.  7.6 Generating a Running Total  Problem You want to calculate a running total of values in a column.  Solution As an example, the following solutions show how to compute a running total of salaries for all employees. For readability, results are ordered by SAL whenever possible so that you can easily eyeball the progression of the running total.  1   s e l e c t   e n a m e ,   s a l ,   2                 s u m   s a l     o v e r     o r d e r   b y   s a l , e m p n o     a s   r u n n i n g _ t o t a l   3       f r o m   e m p   4       o r d e r   b y   2       E N A M E                             S A L     R U N N I N G _ T O T A L   - - - - - - - - - -     - - - - - - - - - -     - - - - - - - - - - - - -   S M I T H                             8 0 0                         8 0 0   J A M E S                             9 5 0                       1 7 5 0   A D A M S                           1 1 0 0                       2 8 5 0   W A R D                             1 2 5 0                       4 1 0 0   M A R T I N                         1 2 5 0                       5 3 5 0   M I L L E R                         1 3 0 0                       6 6 5 0   T U R N E R                         1 5 0 0                       8 1 5 0   A L L E N                           1 6 0 0                       9 7 5 0   C L A R K                           2 4 5 0                     1 2 2 0 0   B L A K E                           2 8 5 0                     1 5 0 5 0   J O N E S                           2 9 7 5                     1 8 0 2 5   S C O T T                           3 0 0 0                     2 1 0 2 5    Discussion The windowing function SUM OVER makes generating a running total a simple task. The ORDER BY clause in the solution includes not only the SAL column, but also the EMPNO column  which is the primary key  to avoid duplicate values in the running total. The column RUNNING_TOTAL2 in the following example illustrates the problem that you might otherwise have with duplicates:  The values in RUNNING_TOTAL2 for WARD, MARTIN, SCOTT, and FORD are incorrect. Their salaries occur more than once, and those duplicates are summed and added to the running total. This is why EMPNO  which is unique  is needed to produce the  correct  results that you see in RUNNING_TOTAL1. Consider this: for ADAMS you see 2850 for RUNNING_TOTAL1 and RUNNING_TOTAL2. Add WARD’s salary of  F O R D                             3 0 0 0                     2 4 0 2 5   K I N G                             5 0 0 0                     2 9 0 2 5 s e l e c t   e m p n o ,   s a l ,                 s u m   s a l   o v e r   o r d e r   b y   s a l , e m p n o     a s   r u n n i n g _ t o t a l 1 ,                 s u m   s a l   o v e r   o r d e r   b y   s a l     a s   r u n n i n g _ t o t a l 2       f r o m   e m p     o r d e r   b y   2     E N A M E                             S A L     R U N N I N G _ T O T A L 1     R U N N I N G _ T O T A L 2   - - - - - - - - - -     - - - - - - - - - -     - - - - - - - - - - - - - -     - - - - - - - - - - - - - -   S M I T H                             8 0 0                           8 0 0                           8 0 0   J A M E S                             9 5 0                         1 7 5 0                         1 7 5 0   A D A M S                           1 1 0 0                         2 8 5 0                         2 8 5 0   W A R D                             1 2 5 0                         4 1 0 0                         5 3 5 0   M A R T I N                         1 2 5 0                         5 3 5 0                         5 3 5 0   M I L L E R                         1 3 0 0                         6 6 5 0                         6 6 5 0   T U R N E R                         1 5 0 0                         8 1 5 0                         8 1 5 0   A L L E N                           1 6 0 0                         9 7 5 0                         9 7 5 0   C L A R K                           2 4 5 0                       1 2 2 0 0                       1 2 2 0 0   B L A K E                           2 8 5 0                       1 5 0 5 0                       1 5 0 5 0   J O N E S                           2 9 7 5                       1 8 0 2 5                       1 8 0 2 5   S C O T T                           3 0 0 0                       2 1 0 2 5                       2 4 0 2 5   F O R D                             3 0 0 0                       2 4 0 2 5                       2 4 0 2 5   K I N G                             5 0 0 0                       2 9 0 2 5                       2 9 0 2 5  1250 to 2850 and you get 4100, yet RUNNING_TOTAL2 returns 5350. Why? Since WARD and MARTIN have the same SAL, their two 1250 salaries are added together to yield 2500, which is then added to 2850 to arrive at 5350 for both WARD and MARTIN. By specifying a combination of columns to order by that cannot result in duplicate values  e.g., any combination of SAL and EMPNO is unique , you ensure the correct progression of the running total.  7.7 Generating a Running Product  Problem You want to compute a running product on a numeric column. The operation is similar to Recipe 7.6, but using multiplication instead of addition.  Solution By way of example, the solutions all compute running products of employee salaries. While a running product of salaries may not be all that useful, the technique can easily be applied to other, more useful domains. Use the windowing function SUM OVER and take advantage of the fact that you can simulate multiplication by adding logarithms:  1   s e l e c t   e m p n o , e n a m e , s a l ,   2                 e x p   s u m   l n   s a l     o v e r   o r d e r   b y   s a l , e m p n o       a s   r u n n i n g _ p r o d   3       f r o m   e m p   4     w h e r e   d e p t n o   =   1 0     E M P N O   E N A M E                     S A L                         R U N N I N G _ P R O D   - - - - -   - - - - - - - - - -         - - - -         - - - - - - - - - - - - - - - - - - - -     7 9 3 4   M I L L E R                 1 3 0 0                                         1 3 0 0     7 7 8 2   C L A R K                   2 4 5 0                                   3 1 8 5 0 0 0     7 8 3 9   K I N G                     5 0 0 0                           1 5 9 2 5 0 0 0 0 0 0  It is not valid in SQL  or, formally speaking, in mathematics  to compute logarithms of values less than or equal to zero. If you have such values in your tables, you need to avoid passing those invalid values to SQL’s LN function. Precautions against invalid values and NULLs are not provided in this solution for the sake of readability, but you should consider whether to place such precautions in production code that you write. If you absolutely must work with negative and zero values, then this solution may not work for you. At the same time, if you have zeros  but no values below zero , a common workaround is to add 1 to all values, noting that the logarithm of 1 is always zero regardless of base. SQL Server users use LOG instead of LN.  Discussion The solution takes advantage of the fact that you can multiply two numbers by:  1. Computing their respective natural logarithms 2. Summing those logarithms 3. Raising the result to the power of the mathematical constant e  using  the EXP function   The one caveat when using this approach is that it doesn’t work for summing zero or negative values, because any value less than or equal to zero is out of range for an SQL logarithm. For an explanation of how the window function SUM OVER works, see Recipe 7.6.  7.8 Smoothing a Series of Values  Problem You have a series of values that appear over time, such as monthly sales figures. As is common, the data shows a lot of variation from point to point,   but you are interested in the overall trend. Therefore, you want to implement a simple smoother, such as weighted running average to better identify the trend. Imagine you have daily sales totals, in dollars, such as from a newsstand:  However, you know that there is volatility to the sales data that makes it difficult to discern an underlying trend. Possibly different days of the week or month are known to have especially high or low sales. Alternatively, maybe you are aware that due to the way the data is collected, sometimes sales for one day are moved into the next day, creating a trough followed by a peak, but there is no practical way to allocate the sales to their correct day. Therefore, you need to smooth the data over a number of days to achieve a proper view of what’s happening. A moving average can be calculated by summing the current value and the preceding n-1 values and dividing by n. If you also display the previous values for reference, you expect something like this:  D A T E 1                         S A L E S   2 0 2 0 - 0 1 - 0 1                   6 4 7   2 0 2 0 - 0 1 - 0 2                   5 6 1   2 0 2 0 - 0 1 - 0 3                   7 4 1   2 0 2 0 - 0 1 - 0 4                   9 7 8   2 0 2 0 - 0 1 - 0 5                 1 0 6 2   2 0 2 0 - 0 1 - 0 6                 1 0 7 2   . . .                                 . . . D A T E 1                   s a l e s         s a l e s L a g O n e       S a l e s L a g T w o         M o v i n g A v e r a g e   - - - - -                 - - - - - -       - - - - - - - - - - -       - - - - - - - - - - - -     - - - - - - - - - - - - - -   2 0 2 0 - 0 1 - 0 1         6 4 7               N U L L                       N U L l                                     N U L L   2 0 2 0 - 0 1 - 0 2         5 6 1               6 4 7                         N U L L                                     N U L L   2 0 2 0 - 0 1 - 0 3         7 4 1               5 6 1                         6 4 7                                 6 4 9 . 6 6 7   2 0 2 0 - 0 1 - 0 4         9 7 8               7 4 1                         5 6 1                                         7 6 0   2 0 2 0 - 0 1 - 0 5         1 0 6 2             9 7 8                         7 4 1                                         9 2 7   2 0 2 0 - 0 1 - 0 6         1 0 7 2             1 0 6 2                       9 7 8                               1 0 3 7 . 3 3 3   2 0 2 0 - 0 1 - 0 7         8 0 5               1 0 7 2                       1 0 6 2                               9 7 9 . 6 6 7   2 0 2 0 - 0 1 - 0 8         6 6 2               8 0 5                         1 0 7 2                               8 4 6 . 3 3 3   2 0 2 0 - 0 1 - 0 9         1 0 8 3             6 6 2                         8 0 5                                         8 5 0   2 0 2 0 - 0 1 - 1 0         9 7 0               1 0 8 3                       6 6 2                                         9 0 5  Solution The formula for the mean is well known. By applying a simple weighting to the formula, we can make it more relevant for this task by giving more weight to more recent values. Use the window function LAG to create a moving average:  Discussion A weighted moving average is one of the simplest ways to analyze time- series data  data that appears at particular time intervals . This is just one way to calculate a simple moving average—you can also use a partition with average. Although we have selected a simple three-point moving average, there are different formulas with differing numbers of points according to the characteristics of the data you apply them [.keep- together]to—that’s where this technique really comes into its own. For example, a simple three-point weighted moving average that emphasizes the most recent data point could be implemented with the following variant on the solution, where coefficients and the denominator have been updated:  7.9 Calculating a Mode  s e l e c t   d a t e 1 ,   s a l e s , l a g   s a l e s , 1     o v e r   o r d e r   b y   d a t e 1     a s   s a l e s L a g O n e ,   l a g   s a l e s , 2     o v e r   o r d e r   b y   d a t e 1     a s   s a l e s L a g T w o ,     s a l e s   +     l a g   s a l e s , 1     o v e r   o r d e r   b y   d a t e 1       +   l a g   s a l e s , 2     o v e r   o r d e r   b y   d a t e 1       3   a s   M o v i n g A v e r a g e   f r o m   s a l e s s e l e c t   d a t e 1 ,   s a l e s , l a g   s a l e s , 1     o v e r   o r d e r   b y   d a t e 1   ,   l a g   s a l e s , 2     o v e r   o r d e r   b y   d a t e 1   ,       3 * s a l e s     +     2 *   l a g   s a l e s , 1     o v e r   o r d e r   b y   d a t e 1         +     l a g   s a l e s , 2     o v e r   o r d e r   b y   d a t e 1         6   a s   S a l e s M A   f r o m   s a l e s  Problem You want to find the mode  for those of you who don’t recall, the mode in mathematics is the element that appears most frequently for a given set of data  of the values in a column. For example, you want to find the mode of the salaries in DEPTNO 20. Based on the following salaries:  the mode is 3000.  Solution  DB2, MySQL, PostgreSQL, and SQL Server Use the window function DENSE_RANK to rank the counts of the salaries to facilitate extracting the mode:  s e l e c t   s a l       f r o m   e m p     w h e r e   d e p t n o   =   2 0     o r d e r   b y   s a l                     S A L   - - - - - - - - - -                 8 0 0               1 1 0 0               2 9 7 5               3 0 0 0               3 0 0 0   1   s e l e c t   s a l     2       f r o m         3   s e l e c t   s a l ,     4                 d e n s e _ r a n k     o v e r     o r d e r   b y   c n t   d e s c     a s   r n k     5       f r o m         6   s e l e c t   s a l ,   c o u n t   *     a s   c n t     8       f r o m   e m p     9     w h e r e   d e p t n o   =   2 0   1 0     g r o u p   b y   s a l   1 1                     x    Oracle You can use the KEEP extension to the aggregate function MAX to find the mode SAL. One important note is that if there are ties, i.e., multiple rows that are the mode, the solution using KEEP will keep only one, and that is the one with the highest salary. If you want to see all modes  if more than one exists , you must modify this solution or simply use the DB2 solution presented earlier. In this case, since 3000 is the mode SAL in DEPTNO 20 and is also the highest SAL, this solution is sufficient:  Discussion  DB2 and SQL Server The inline view X returns each SAL and the number of times it occurs. Inline view Y uses the window function DENSE_RANK  which allows for ties  to sort the results. The results are ranked based on the number of times each SAL occurs, as shown here:  1 2                     y   1 3     w h e r e   r n k   =   1 1   s e l e c t   m a x   s a l     2                 k e e p   d e n s e _ r a n k   f i r s t   o r d e r   b y   c n t   d e s c     s a l   3       f r o m       4   s e l e c t   s a l ,   c o u n t   *     c n t   5       f r o m   e m p   6     w h e r e   d e p t n o = 2 0   7     g r o u p   b y   s a l   8                   1   s e l e c t   s a l ,   2                 d e n s e _ r a n k     o v e r   o r d e r   b y   c n t   d e s c     a s   r n k   3       f r o m       4   s e l e c t   s a l , c o u n t   *     a s   c n t   5       f r o m   e m p   6     w h e r e   d e p t n o   =   2 0   7     g r o u p   b y   s a l   8                     x      The outermost portion of query simply keeps the row s  where RNK is 1.  Oracle The inline view returns each SAL and the number of times it occurs and is shown here:  The next step is to use the KEEP extension of the aggregate function MAX to find the mode. If you analyze the KEEP clause shown here, you will notice three subclauses, DENSE_RANK, FIRST, and ORDER BY CNT DESC:  This makes finding the mode extremely convenient. The KEEP clause determines which SAL will be returned by MAX by looking at the value of CNT returned by the inline view. Working from right to left, the values for CNT are ordered in descending order; then the first is kept of all the values for CNT returned in DENSE_RANK order. Looking at the result set from the inline view, you can see that 3000 has the highest CNT of 2. The      S A L                     R N K   - - - - -       - - - - - - - - - -     3 0 0 0                         1       8 0 0                         2     1 1 0 0                         2     2 9 7 5                         2 s e l e c t   s a l ,   c o u n t   *     c n t           f r o m   e m p         w h e r e   d e p t n o = 2 0         g r o u p   b y   s a l                 S A L                     C N T           - - - - -       - - - - - - - - - -               8 0 0                         1             1 1 0 0                         1             2 9 7 5                         1             3 0 0 0                         2 k e e p   d e n s e _ r a n k   f i r s t   o r d e r   b y   c n t   d e s c    MAX SAL  returned is the greatest SAL that has the greatest CNT, in this case 3000.  See Also See Chapter 11, particularly the section on “Finding Knight Values,” for a deeper discussion of Oracle’s KEEP extension of aggregate functions.  7.10 Calculating a Median  Problem You want to calculate the median  for those of who do not recall, the median is the value of the middle member of a set of ordered elements  value for a column of numeric values. For example, you want to find the median of the salaries in DEPTNO 20. Based on the following salaries:  the median is 2975.  Solution Other than the Oracle solution  which uses supplied functions to compute a median , the introduction of window functions allows for a more efficient solution compared to the traditional self-join.  s e l e c t   s a l       f r o m   e m p     w h e r e   d e p t n o   =   2 0     o r d e r   b y   s a l                   S A L   - - - - - - - - - -                 8 0 0               1 1 0 0               2 9 7 5               3 0 0 0               3 0 0 0  DB2 and PostgreSQL Use the window function PERCENTILE_CONT to find the median:  SQL Server Use the window function PERCENTILE_CONT to find the median:  The SQL Server solution works on the same principle but requires an OVER clause.  MySQL MySQL doesn’t have the PERCENTILE_CONT function, so a workaround is required. One way is to use the CUME_DIST function in conjunction with a CTE, effectively re-creating the PERCENTILE_CONT function:  1   s e l e c t   p e r c e n t i l e _ c o n t   0 . 5     2                   w i t h i n   g r o u p   o r d e r   b y   s a l     3       f r o m   e m p   4     w h e r e   d e p t n o = 2 0 1   s e l e c t   p e r c e n t i l e _ c o n t   0 . 5             2                   w i t h i n   g r o u p   o r d e r   b y   s a l             3                   o v e r               4       f r o m   e m p           5     w h e r e   d e p t n o = 2 0 w i t h   r a n k _ t a b     s a l ,   r a n k _ s a l     a s       s e l e c t   s a l ,   c u m e _ d i s t       o v e r     o r d e r   b y   s a l                             f r o m   e m p                           w h e r e   d e p t n o = 2 0     ,     i n t e r   a s                       s e l e c t   s a l ,   r a n k _ s a l   f r o m   r a n k _ t a b                   w h e r e   r a n k _ s a l > = 0 . 5   u n i o n                   s e l e c t   s a l ,   r a n k _ s a l   f r o m   r a n k _ t a b                   w h e r e   r a n k _ s a l < = 0 . 5          Oracle Use the functions MEDIAN or PERCENTILE_CONT:  Discussion  Oracle, PostgreSQL, SQL Server, and DB2 Other than Oracle’s MEDIAN function, the structure of all the solutions is the same. The PERCENTILE_CONT function allows you to directly apply the definition of a median, as the median is by definition the 50th percentile. Hence, applying this function with the appropriate syntax and using 0.5 as the argument finds the median. Of course, other percentiles are also available from this function. For example, you can look for the 5th and or 95th percentiles to find outliers  another method of finding outliers is outlined later in this chapter when we discuss the median absolute deviation .  MySQL MySQL doesn’t have a PERCENTILE_CONT function, which makes things trickier. To find the median, the values for SAL must be ordered from lowest to highest. The CUME_DIST function achieves this goal and labels each row with its percentile. Hence, it can be used to achieve the same outcome as the PERCENTILE_CONT function used in the solution for the other databases.                  s e l e c t   a v g   s a l     a s   M e d i a n S a l                                 f r o m   i n t e r 1   s e l e c t   m e d i a n   s a l     2       f r o m   e m p   3     w h e r e   d e p t n o = 2 0     1   s e l e c t   p e r c e n t i l e _ c o n t   0 . 5     2                   w i t h i n   g r o u p   o r d e r   b y   s a l     3       f r o m   e m p   4     w h e r e   d e p t n o = 2 0  The only difficulty is that the CUME_DIST function is not permitted in a WHERE clause. As a result, you need to apply it first in a CTE. The only trap here is that if the number of rows is even, there won’t be a row exactly on the median. Hence, the solution is written to find the average of the highest value below or equal to the median, and the lowest value above or equal to the median. This method works for both odd and even numbers of rows, and if there is an odd number of rows giving an exact median, it will take average of two numbers that are equal.  7.11 Determining the Percentage of a Total  Problem You want to determine the percentage that values in a specific column represent against a total. For example, you want to determine what percentage of all salaries are the salaries in DEPTNO 10  the percentage that DEPTNO 10 salaries contribute to the total .  Solution In general, computing a percentage against a total in SQL is no different than doing so on paper: simply divide, then multiply. In this example you want to find the percentage of total salaries in table EMP that come from DEPTNO 10. To do that, simply find the salaries for DEPTNO 10, and then divide by the total salary for the table. As the last step, multiply by 100 to return a value that represents a percent.  MySQL and PostgreSQL Divide the sum of the salaries in DEPTNO 10 by the sum of all salaries:  1   s e l e c t     s u m     2                     c a s e   w h e n   d e p t n o   =   1 0   t h e n   s a l   e n d     s u m   s a l     3                     * 1 0 0   a s   p c t   4       f r o m   e m p  DB2, Oracle, and SQL Server Use an inline view with the window function SUM OVER to find the sum of all salaries along with the sum of all salaries in DEPTNO 10. Then do the division and multiplication in the outer query:  Discussion  MySQL and PostgreSQL The CASE statement conveniently returns only the salaries from DEPTNO 10. They are then summed and divided by the sum of all the salaries. Because NULLs are ignored by aggregates, an ELSE clause is not needed in the CASE statement. To see exactly which values are divided, execute the query without the division:  Depending on how you define SAL, you may need to explicitly use CAST when performing division to ensure the correct data type. For example, on DB2, SQL Server, and PostgreSQL, if SAL is stored as an integer, you can apply CAST to ensure a decimal value is returned, as shown here:  1   s e l e c t   d i s t i n c t     d 1 0   t o t a l   * 1 0 0   a s   p c t   2       f r o m       3   s e l e c t   d e p t n o ,   4                 s u m   s a l   o v e r       t o t a l ,   5                 s u m   s a l   o v e r   p a r t i t i o n   b y   d e p t n o     d 1 0   6       f r o m   e m p   7                     x   8     w h e r e   d e p t n o = 1 0 s e l e c t   s u m   c a s e   w h e n   d e p t n o   =   1 0   t h e n   s a l   e n d     a s   d 1 0 ,                 s u m   s a l         f r o m   e m p     D 1 0     S U M   S A L     - - - -   - - - - - - - - -   8 7 5 0           2 9 0 2 5 s e l e c t     c a s t                       s u m   c a s e   w h e n   d e p t n o   =   1 0   t h e n   s a l   e n d                             a s   d e c i m a l     s u m   s a l      DB2, Oracle, and SQL Server As an alternative to the traditional solution, this solution uses window functions to compute a percentage relative to the total. For DB2 and SQL Server, if you’ve stored SAL as an integer, you’ll need to use CAST before dividing:  It is important to keep in mind that window functions are applied after the WHERE clause is evaluated. Thus, the filter on DEPTNO cannot be performed in inline view X. Consider the results of inline view X without and with the filter on DEPTNO. First without:                    * 1 0 0   a s   p c t       f r o m   e m p s e l e c t   d i s t i n c t                 c a s t   d 1 0   a s   d e c i m a l     t o t a l * 1 0 0   a s   p c t       f r o m       s e l e c t   d e p t n o ,                 s u m   s a l   o v e r       t o t a l ,                 s u m   s a l   o v e r   p a r t i t i o n   b y   d e p t n o     d 1 0       f r o m   e m p                     x     w h e r e   d e p t n o = 1 0 s e l e c t   d e p t n o ,                 s u m   s a l   o v e r       t o t a l ,                 s u m   s a l   o v e r   p a r t i t i o n   b y   d e p t n o     d 1 0       f r o m   e m p     D E P T N O             T O T A L               D 1 0   - - - - - - -   - - - - - - - - -   - - - - - - - - -             1 0           2 9 0 2 5             8 7 5 0             1 0           2 9 0 2 5             8 7 5 0             1 0           2 9 0 2 5             8 7 5 0             2 0           2 9 0 2 5           1 0 8 7 5             2 0           2 9 0 2 5           1 0 8 7 5             2 0           2 9 0 2 5           1 0 8 7 5             2 0           2 9 0 2 5           1 0 8 7 5             2 0           2 9 0 2 5           1 0 8 7 5             3 0           2 9 0 2 5             9 4 0 0             3 0           2 9 0 2 5             9 4 0 0             3 0           2 9 0 2 5             9 4 0 0    and now with:  Because window functions are applied after the WHERE clause, the value for TOTAL represents the sum of all salaries in DEPTNO 10 only. But to solve the problem you want the TOTAL to represent the sum of all salaries, period. That’s why the filter on DEPTNO must happen outside of inline view X.  7.12 Aggregating Nullable Columns  Problem You want to perform an aggregation on a column, but the column is nullable. You want the accuracy of your aggregation to be preserved, but are concerned because aggregate functions ignore NULLs. For example, you want to determine the average commission for employees in DEPTNO 30, but there are some employees who do not earn a commission  COMM is NULL for those employees . Because NULLs are ignored by aggregates, the accuracy of the output is compromised. You would like to somehow include NULL values in your aggregation.            3 0           2 9 0 2 5             9 4 0 0             3 0           2 9 0 2 5             9 4 0 0             3 0           2 9 0 2 5             9 4 0 0 s e l e c t   d e p t n o ,                 s u m   s a l   o v e r       t o t a l ,                 s u m   s a l   o v e r   p a r t i t i o n   b y   d e p t n o     d 1 0       f r o m   e m p     w h e r e   d e p t n o = 1 0     D E P T N O           T O T A L               D 1 0   - - - - - -   - - - - - - - - -   - - - - - - - - -           1 0             8 7 5 0             8 7 5 0           1 0             8 7 5 0             8 7 5 0           1 0             8 7 5 0             8 7 5 0  Solution Use the COALESCE function to convert NULLs to zero so they will be included in the aggregation:  Discussion When working with aggregate functions, keep in mind that NULLs are ignored. Consider the output of the solution without using the COALESCE function:  This query shows an average commission of 550 for DEPTNO 30, but a quick examination of those rows:  shows that only four of the six employees can earn a commission. The sum of all commissions in DEPTNO 30 is 2200, and the average should be  1   s e l e c t   a v g   c o a l e s c e   c o m m , 0       a s   a v g _ c o m m   2       f r o m   e m p   3     w h e r e   d e p t n o = 3 0 s e l e c t   a v g   c o m m         f r o m   e m p     w h e r e   d e p t n o = 3 0       A V G   C O M M       - - - - - - - - -                 5 5 0 s e l e c t   e n a m e ,   c o m m       f r o m   e m p     w h e r e   d e p t n o = 3 0   o r d e r   b y   c o m m   d e s c     E N A M E                       C O M M   - - - - - - - - - -   - - - - - - - - -   B L A K E   J A M E S   M A R T I N                     1 4 0 0   W A R D                           5 0 0   A L L E N                         3 0 0   T U R N E R                           0  2200 6, not 2200 4. By excluding the COALESCE function, you answer the question “What is the average commission of employees in DEPTNO 30 who can earn a commission?” rather than “What is the average commission of all employees in DEPTNO 30?” When working with aggregates, remember to treat NULLs accordingly.  7.13 Computing Averages Without High and Low Values  Problem You want to compute an average, but you want to exclude the highest and lowest values to  hopefully  reduce the effect of skew. In statistical language, this is known as a trimmed mean. For example, you want to compute the average salary of all employees excluding the highest and lowest salaries.  Solution  MySQL and PostgreSQL Use subqueries to exclude high and low values:  DB2, Oracle, and SQL Server Use an inline view with the windowing functions MAX OVER and MIN OVER to generate a result set from which you can easily eliminate the high and low values:  1   s e l e c t   a v g   s a l     2       f r o m   e m p   3     w h e r e   s a l   n o t   i n       4             s e l e c t   m i n   s a l     f r o m   e m p   ,   5             s e l e c t   m a x   s a l     f r o m   e m p     6        Discussion  MySQL and PostgreSQL The subqueries return the highest and lowest salaries in the table. By using NOT IN against the values returned, you exclude the highest and lowest salaries from the average. Keep in mind that if there are duplicates  if multiple employees have the highest or lowest salaries , they will all be excluded from the average. If your goal is to exclude only a single instance of the high and low values, simply subtract them from the SUM and then divide:  DB2, Oracle, and SQL Server Inline view X returns each salary along with the highest and lowest salaries:  1   s e l e c t   a v g   s a l     2       f r o m       3   s e l e c t   s a l ,   m i n   s a l   o v e r       m i n _ s a l ,   m a x   s a l   o v e r       m a x _ s a l   4       f r o m   e m p   5                     x   6     w h e r e   s a l   n o t   i n     m i n _ s a l , m a x _ s a l   s e l e c t     s u m   s a l   - m i n   s a l   - m a x   s a l         c o u n t   *   - 2         f r o m   e m p s e l e c t   s a l ,   m i n   s a l   o v e r       m i n _ s a l ,   m a x   s a l   o v e r       m a x _ s a l       f r o m   e m p                 S A L       M I N _ S A L       M A X _ S A L   - - - - - - - - -   - - - - - - - - -   - - - - - - - - -               8 0 0               8 0 0             5 0 0 0             1 6 0 0               8 0 0             5 0 0 0             1 2 5 0               8 0 0             5 0 0 0             2 9 7 5               8 0 0             5 0 0 0             1 2 5 0               8 0 0             5 0 0 0             2 8 5 0               8 0 0             5 0 0 0             2 4 5 0               8 0 0             5 0 0 0             3 0 0 0               8 0 0             5 0 0 0             5 0 0 0               8 0 0             5 0 0 0             1 5 0 0               8 0 0             5 0 0 0             1 1 0 0               8 0 0             5 0 0 0               9 5 0               8 0 0             5 0 0 0    You can access the high and low salaries at every row, so finding which salaries are highest and or lowest is trivial. The outer query filters the rows returned from inline view X such that any salary that matches either MIN_SAL or MAX_SAL is excluded from the average.  Robust Statistics In statistical parlance, a mean calculated with the largest and smallest values removed is called a trimmed mean. This can be considered a safer estimate of the average, and is an example of a robust statistic, so called because they are less sensitive to problems such as bias. Recipe 7.16 is another example of a robust statistical tool. In both cases, these approaches are valuable to someone analyzing data within an RDBMS because they don’t require the analyst to make assumptions that are difficult to test with the relatively limited range of statistical tools available in SQL.  7.14 Converting Alphanumeric Strings into Numbers  Problem You have alphanumeric data and would like to return numbers only. You want to return the number 123321 from the string “paul123f321.”  Solution  DB2 Use the functions TRANSLATE and REPLACE to extract numeric characters from an alphanumeric string:            3 0 0 0               8 0 0             5 0 0 0             1 3 0 0               8 0 0             5 0 0 0 1   s e l e c t   c a s t     2                 r e p l a c e      Oracle, SQL Server, and PostgreSQL Use the functions TRANSLATE and REPLACE to extract numeric characters from an alphanumeric string:  MySQL As of the time of this writing, MySQL doesn’t support the TRANSLATE function; thus, a solution will not be provided.  Discussion The only difference between the two solutions is syntax; DB2 uses the function REPEAT rather than RPAD, and the parameter list for TRANSLATE is in a different order. The following explanation uses the Oracle PostgreSQL solution but is relevant to DB2 as well. If you run query inside out  starting with TRANSLATE only , you’ll see this is simple. First, TRANSLATE converts any nonnumeric character to an instance of :  p   3             t r a n s l a t e     ' p a u l 1 2 3 f 3 2 1 ' ,   4                                   r e p e a t   '  ' , 2 6   ,   5                                   ' a b c d e f g h i j k l m n o p q r s t u v w x y z '   , '  ' , ' '     6                 a s   i n t e g e r       a s   n u m   7       f r o m   t 1 1   s e l e c t   c a s t     2                 r e p l a c e     3             t r a n s l a t e     ' p a u l 1 2 3 f 3 2 1 ' ,   4                                   ' a b c d e f g h i j k l m n o p q r s t u v w x y z ' ,   5                                   r p a d   '  ' , 2 6 , '  '     , '  ' , ' '     6                 a s   i n t e g e r       a s   n u m   7       f r o m   t 1 s e l e c t   t r a n s l a t e     ' p a u l 1 2 3 f 3 2 1 ' ,                                       ' a b c d e f g h i j k l m n o p q r s t u v w x y z ' ,                                       r p a d   '  ' , 2 6 , '  '       a s   n u m       f r o m   t 1     N U M   - - - - - - - - - - -       1 2 3  3 2 1  Since all nonnumeric characters are now represented by , simply use REPLACE to remove them, then use CAST the return the result as a number. This particular example is extremely simple because the data is alphanumeric. If additional characters can be stored, rather than fishing for those characters, it is easier to approach this problem differently: rather than finding nonnumeric characters and then removing them, find all numeric characters and remove anything that is not among them. The following example will help clarify this technique:  This solution looks a bit more convoluted than the original but is not so bad once you break it down. Observe the innermost call to TRANSLATE:  So, the initial approach is different; rather than replacing each nonnumeric character with an instance of , you replace each numeric character with an instance of . The next step removes all instances of , thus leaving only nonnumeric characters:  s e l e c t   r e p l a c e               t r a n s l a t e   ' p a u l 1 2 3 f 3 2 1 ' ,                 r e p l a c e   t r a n s l a t e     ' p a u l 1 2 3 f 3 2 1 ' ,                                                       ' 0 1 2 3 4 5 6 7 8 9 ' ,                                                       r p a d   '  ' , 1 0 , '  '     , '  ' , ' '   ,                                 r p a d   '  ' , l e n g t h   ' p a u l 1 2 3 f 3 2 1 '   , '  '     , '  ' , ' '     a s   n u m       f r o m   t 1     N U M   - - - - - - - - - - -   1 2 3 3 2 1 s e l e c t   t r a n s l a t e     ' p a u l 1 2 3 f 3 2 1 ' ,                                       ' 0 1 2 3 4 5 6 7 8 9 ' ,                                       r p a d   '  ' , 1 0 , '  '           f r o m   t 1     T R A N S L A T E   '   - - - - - - - - - - -   p a u l    f    s e l e c t   r e p l a c e   t r a n s l a t e     ' p a u l 1 2 3 f 3 2 1 ' ,                                                       ' 0 1 2 3 4 5 6 7 8 9 ' ,    The next step is to call TRANSLATE again, this time to replace each of the nonnumeric characters  from the previous query  with an instance of  in the original string:  At this point, stop and examine the outermost call to TRANSLATE. The second parameter to RPAD  or the second parameter to REPEAT for DB2  is the length of the original string. This is convenient to use since no character can occur enough times to be greater than the string it is part of. Now that all nonnumeric characters are replaced by instances of , the last step is to use REPLACE to remove all instances of . Now you are left with a number.  7.15 Changing Values in a Running Total  Problem You want to modify the values in a running total depending on the values in another column. Consider a scenario where you want to display the transaction history of a credit card account along with the current balance after each transaction. The following view, V, will be used in this example:                                                      r p a d   '  ' , 1 0 , '  '     , '  ' , ' '         f r o m   t 1     R E P L A   - - - - -   p a u l f s e l e c t   t r a n s l a t e   ' p a u l 1 2 3 f 3 2 1 ' ,                 r e p l a c e   t r a n s l a t e     ' p a u l 1 2 3 f 3 2 1 ' ,                                                       ' 0 1 2 3 4 5 6 7 8 9 ' ,                                                       r p a d   '  ' , 1 0 , '  '     , '  ' , ' '   ,                                 r p a d   '  ' , l e n g t h   ' p a u l 1 2 3 f 3 2 1 '   , '  '           f r o m   t 1     T R A N S L A T E   '   - - - - - - - - - - -       1 2 3  3 2 1  The ID column uniquely identifies each transaction. The AMT column represents the amount of money involved in each transaction  either a purchase or a payment . The TRX column defines the type of transaction; a payment is “PY” and a purchase is “PR.” If the value for TRX is PY, you want the current value for AMT subtracted from the running total; if the value for TRX is PR, you want the current value for AMT added to the running total. Ultimately you want to return the following result set:  Solution Use the window function SUM OVER to create the running total along with a CASE expression to determine the type of transaction:  c r e a t e   v i e w   V     i d , a m t , t r x     a s   s e l e c t   1 ,   1 0 0 ,   ' P R '   f r o m   t 1   u n i o n   a l l   s e l e c t   2 ,   1 0 0 ,   ' P R '   f r o m   t 1   u n i o n   a l l   s e l e c t   3 ,   5 0 ,     ' P Y '   f r o m   t 1   u n i o n   a l l   s e l e c t   4 ,   1 0 0 ,   ' P R '   f r o m   t 1   u n i o n   a l l   s e l e c t   5 ,   2 0 0 ,   ' P Y '   f r o m   t 1   u n i o n   a l l   s e l e c t   6 ,   5 0 ,     ' P Y '   f r o m   t 1         s e l e c t   *   f r o m   V     I D                   A M T     T R   - -     - - - - - - - - - -     - -     1                   1 0 0     P R     2                   1 0 0     P R     3                     5 0     P Y     4                   1 0 0     P R     5                   2 0 0     P Y     6                     5 0     P Y T R X _ T Y P E                 A M T         B A L A N C E   - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   P U R C H A S E                 1 0 0                 1 0 0   P U R C H A S E                 1 0 0                 2 0 0   P A Y M E N T                     5 0                 1 5 0   P U R C H A S E                 1 0 0                 2 5 0   P A Y M E N T                   2 0 0                   5 0   P A Y M E N T                     5 0                     0  Discussion The CASE expression determines whether the current AMT is added or deducted from the running total. If the transaction is a payment, the AMT is changed to a negative value, thus reducing the amount of the running total. The result of the CASE expression is shown here:  After evaluating the transaction type, the values for AMT are then added to or subtracted from the running total. For an explanation on how the window function, SUM OVER, or the scalar subquery creates the running total, see recipe Recipe 7.6.    1   s e l e c t   c a s e   w h e n   t r x   =   ' P Y '     2                           t h e n   ' P A Y M E N T '     3                           e l s e   ' P U R C H A S E '     4                   e n d   t r x _ t y p e ,     5                   a m t ,     6                   s u m       7                     c a s e   w h e n   t r x   =   ' P Y '     8                           t h e n   - a m t   e l s e   a m t     9                     e n d   1 0                     o v e r     o r d e r   b y   i d , a m t     a s   b a l a n c e   1 1   f r o m   V s e l e c t   c a s e   w h e n   t r x   =   ' P Y '                           t h e n   ' P A Y M E N T '                           e l s e   ' P U R C H A S E '                 e n d   t r x _ t y p e ,                 c a s e   w h e n   t r x   =   ' P Y '                           t h e n   - a m t   e l s e   a m t                 e n d   a s   a m t       f r o m   V     T R X _ T Y P E               A M T   - - - - - - - -   - - - - - - - - -   P U R C H A S E               1 0 0   P U R C H A S E               1 0 0   P A Y M E N T                 - 5 0   P U R C H A S E               1 0 0   P A Y M E N T               - 2 0 0   P A Y M E N T                 - 5 0  7.16 Finding Outliers Using the Median Absolute Deviation  Problem You want to identify values in your data that may be suspect. There are various reasons why values could be suspect—there could be a data collection issue, such as an error with the meter that records the value. There could be a data entry error such as a typo or similar. There could also be unusual circumstances when the data was generated that mean the data point is correct, but they still require you to use caution in any conclusion you make from the data. Therefore, you want to detect outliers. A common way to detect outliers, taught in many statistics courses aimed at non-statisticians, is to calculate the standard deviation of the data and decide that data points more than three standard deviations  or some other similar distance  are outliers. However, this method can misidentify outliers if the data don’t follow a normal distribution, especially if the spread of data isn’t symmetrical or doesn’t thin out in the same way as a normal distribution as you move further from the mean.  Solution First find the median of the values using the recipe for finding the median from earlier in this chapter. You will need to put this query into a CTE to make it available for further querying. The deviation is the absolute difference between the median and each value; the median absolute deviation is the median of this value, so we need to calculate the median again.  SQL Server SQL Server has the PERCENTILE_CONT function, which simplifies finding the median. As we need to find two different medians and manipulate them, we need a series of CTEs:   PostgreSQL and DB2 The overall pattern is the same, but there is different syntax for PERCENTILE_CONT, as PostgreSQL and DB2 treat PERCENTILE_CONT as an aggregate function rather than strictly a window function:  Oracle  w i t h   m e d i a n     m e d i a n     a s     s e l e c t   d i s t i n c t   p e r c e n t i l e _ c o n t   0 . 5     w i t h i n   g r o u p   o r d e r   b y   s a l                     o v e r       f r o m   e m p   ,     D e v i a t i o n     D e v i a t i o n         a s     S e l e c t   a b s   s a l - m e d i a n     f r o m   e m p   j o i n   m e d i a n   o n   1 = 1   ,     M A D     M A D     a s     s e l e c t   D I S T I N C T   P E R C E N T I L E _ C O N T   0 . 5     w i t h i n   g r o u p   o r d e r   b y   d e v i a t i o n     o v e r       f r o m   D e v i a t i o n         s e l e c t   a b s   s a l - M A D     M A D ,   s a l ,   e n a m e ,   j o b   f r o m   M A D   j o i n   e m p   o n   1 = 1 w i t h   m e d i a n     m e d i a n     a s     s e l e c t   p e r c e n t i l e _ c o n t   0 . 5     w i t h i n   g r o u p   o r d e r   b y   s a l     f r o m   e m p   ,     d e v t a b     d e v i a t i o n         a s     s e l e c t   a b s   s a l - m e d i a n     f r o m   e m p   j o i n   m e d i a n   ,     M e d A b s D e v i a t i o n     M A D     a s     s e l e c t   p e r c e n t i l e _ c o n t     0 . 5     w i t h i n   g r o u p   o r d e r   b y   d e v i a t i o n     f r o m   d e v t a b       s e l e c t   a b s   s a l - M A D     M A D ,   s a l ,   e n a m e ,   j o b   F R O M   M e d A b s D e v i a t i o n   j o i n   e m p  The recipe is simplified for Oracle users due to the existence of a median function. However, we still need to use a CTE to handle the scalar value of deviation:  MySQL As we saw in the earlier section on the median, there is unfortunately no MEDIAN or PERCENTILE_CONT function in MySQL. This means that each of the medians we need to find to compute the median absolute deviation is two subqueries within a CTE. This makes the MySQL a little long-winded:  w i t h   D e v i a t i o n     D e v i a t i o n         a s     s e l e c t   a b s   s a l - m e d i a n   s a l       f r o m   e m p   ,     M A D     M A D     a s     s e l e c t   m e d i a n   D e v i a t i o n     f r o m   D e v i a t i o n         s e l e c t   a b s   s a l - M A D     M A D ,   s a l ,   e n a m e ,   j o b   F R O M   M A D   j o i n   e m p w i t h   r a n k _ t a b     s a l ,   r a n k _ s a l     a s       s e l e c t   s a l ,   c u m e _ d i s t       o v e r     o r d e r   b y   s a l     f r o m   e m p   ,   i n t e r   a s       s e l e c t   s a l ,   r a n k _ s a l   f r o m   r a n k _ t a b   w h e r e   r a n k _ s a l > = 0 . 5   u n i o n   s e l e c t   s a l ,   r a n k _ s a l   f r o m   r a n k _ t a b   w h e r e   r a n k _ s a l < = 0 . 5       ,     m e d i a n S a l     m e d i a n S a l     a s         s e l e c t     m a x   s a l   + m i n   s a l       2   f r o m   i n t e r   ,   d e v i a t i o n S a l     S a l , d e v i a t i o n S a l     a s    Discussion In each case the recipe follows a similar strategy. First we need to calculate the median, and then we need to calculate the median of the difference between each value and the median, which is the actual median absolute deviation. Finally, we need to use a query to find the ratio of the deviation of each value to the median deviation. At that point, we can use the outcome in a similar way to the standard deviation. For example, if a value    ,     s e l e c t   S a l , a b s   s a l - m e d i a n S a l     f r o m   e m p   j o i n   m e d i a n S a l   o n   1 = 1       ,     d i s t D e v S a l     s a l , d e v i a t i o n S a l , d i s t D e v i a t i o n S a l     a s         s e l e c t   s a l , d e v i a t i o n S a l , c u m e _ d i s t       o v e r     o r d e r   b y   d e v i a t i o n S a l     f r o m   d e v i a t i o n S a l     ,     D e v I n t e r     D e v I n t e r ,   s a l     a s       s e l e c t   m i n   d e v i a t i o n S a l   ,   s a l   f r o m   d i s t D e v S a l   w h e r e   d i s t D e v i a t i o n S a l   > =   0 . 5     u n i o n     s e l e c t   m a x   D e v i a t i o n S a l   ,   s a l   f r o m   d i s t D e v S a l   w h e r e   d i s t D e v i a t i o n S a l   < =   0 . 5     ,     M A D     M e d i a n A b s o l u t e D e v i a n c e     a s       s e l e c t   a b s   e m p . s a l -   m i n   d e v I n t e r   + m a x   d e v I n t e r       2     f r o m   e m p   j o i n   D e v I n t e r   o n   1 = 1         s e l e c t   e m p . s a l , M e d i a n A b s o l u t e D e v i a n c e ,     e m p . s a l - d e v i a t i o n S a l     M e d i a n A b s o l u t e D e v i a n c e   f r o m     e m p   j o i n   M A D   o n   1 = 1                       j o i n   d e v i a t i o n S a l   o n   e m p . s a l = d e v i a t i o n S a l . s a l  is three or more deviations from the median, it can be considered an outlier, to use a common interpretation. As mentioned earlier, the benefit of this approach over the standard deviation is that the interpretation is still valid even if the data doesn’t display a normal distribution. For example, it can be lopsided, and the median absolute deviation will still give a sound answer. In our salary data, there is one salary that is more than three absolute deviations from the median: the CEO’s. Although there are differing opinions about the fairness of CEO salaries versus those of most other workers, given that the outlier salary belongs to the CEO, it fits with our understanding of the data. In other contexts, if there wasn’t a clear explanation of why the value differed so much, it could lead us to question whether that value was correct or whether the value made sense when taken with the rest of the values  e.g., if it not actually an error, it might make us think we need to analyze our data within more than one subgroup .  NOTE  Many of the common statistics, such as the mean and the standard deviation, assume that the shape of the data is a bell curve—a normal distribution. This is true for many data sets, and also not true for many data sets. There are a number of methods for testing whether a data set follows a normal distribution, both by visualizing the data and through calculations. Statistical packages commonly contain functions for these tests, but they are nonexistent and hard to replicate in SQL. However, there are often alternative statistical tools that don’t assume the data takes a particular form—nonparametric statistics—and these are safer to use.  7.17 Finding Anomalies Using Benford’s Law  Problem Although outliers, as shown in the previous recipe, are a readily identifiable form of anomalous data, some other data is less easy to identify as   problematic. One way to detect situations where there are anomalous data but no obvious outliers is to look at the frequency of digits, which is usually expected to follow Benford’s law. Although using Benford’s law is most often associated with detecting fraud in situations where humans have added fake numbers to a data set, it can be used more generally to detect data that doesn’t follow expected patterns. For example, it can detect errors such as duplicated data points, which won’t necessarily stand out as outliers.  Solution To use Benford’s law, you need to calculate the expected distribution of digits and then the actual distribution to compare. Although the most sophisticated uses look at first, second, and combinations of digits, in this example we will stick to just the first digits. You compare the frequency predicted by Benford’s law with the actual frequency of your data. Ultimately you want four columns—the first digit, the count of how many times each first digit appears, the frequency of first digits predicted by Benford’s law, and the actual frequency:  w i t h   F i r s t D i g i t s     F i r s t D i g i t     a s     s e l e c t   l e f t   c a s t   S A L   a s   C H A R   , 1     a s   F i r s t D i g i t                   f r o m   e m p   ,     T o t a l C o u n t     T o t a l     a s       s e l e c t   c o u n t   *         f r o m   e m p   ,     E x p e c t e d B e n f o r d     D i g i t , E x p e c t e d     a s         s e l e c t   v a l u e ,   l o g 1 0   v a l u e   +   1     -   l o g 1 0   v a l u e       a s   e x p e c t e d         f r o m   t 1 0         w h e r e   v a l u e   <   1 0       s e l e c t   c o u n t   F i r s t D i g i t   , D i g i t   , c o a l e s c e   c o u n t   *     T o t a l , 0     a s   A c t u a l P r o p o r t i o n , E x p e c t e d   F r o m   F i r s t D i g i t s    Discussion Because we need to make use of two different counts—one of the total rows, and another of the number of rows containing each different first digit —we need to use a CTE. Strictly speaking, we don’t need to put the expected Benford’s law results into a separate query within the CTE, but we have done so in this case as it allows us to identify the digits with a zero count and display them in the table via the right join. It’s also possible to produce the FirstDigits count in the main query, but we have chosen not to improve readability through not needing to repeat the LEFT CAST… expression in the GROUP BY clause. The math behind Benford’s law is simple:  We can use the T10 pivot table to generate the appropriate values. From there we just need to calculate the actual frequencies for comparison, which first requires us to identify the first digit. Benford’s law works best when there is a relatively large collection of values to apply it to, and when those values span more than one order of magnitude  10, 100, 1,000, etc. . Those conditions aren’t entirely met here. At the same time, the deviation from expected should still make us suspicious that these values are in some sense made-up values and worth investigating further.  7.18 Summing Up An enterprise’s data is frequently found in a database supported by SQL, so it makes sense to use SQL to try to understand that data. SQL doesn’t have the full array of statistical tools you would expect in a purpose-built            J o i n   T o t a l C o u n t             R i g h t   J o i n   E x p e c t e d B e n f o r d             o n   F i r s t D i g i t s . F i r s t D i g i t = E x p e c t e d B e n f o r d . D i g i t   g r o u p   b y   D i g i t   o r d e r   b y   D i g i t ; E x p e c t e d f r e q u e n c y = l o g 1 0     d + 1 d  package such as SAS, the statistical programming language R, or Python’s statistical libraries. However, it does have a rich set of tools for calculation that as we have seen can provide a deep understanding of the statistical properties of your data.   Chapter 8. Date Arithmetic  This chapter introduces techniques for performing simple date arithmetic. Recipes cover common tasks such as adding days to dates, finding the number of business days between dates, and finding the difference between dates in days. Being able to successfully manipulate dates with your RDBMS’s built-in functions can greatly improve your productivity. For all the recipes in this chapter, we try to take advantage of each RDBMS’s built-in functions. In addition, we have chosen to use one date format for all the recipes, DD- MON-YYYY. Of course, there are a number of other commonly used formats, such as DD-MM-YYYY, the ISO standard format. We chose to standardize on DD-MON-YYYY to benefit those of you who work with one RDBMS and want to learn others. Seeing one standard format will help you focus on the different techniques and functions provided by each RDBMS without having to worry about default date formats.  TIP  This chapter focuses on basic date arithmetic. You’ll find more advanced date recipes in the following chapter. The recipes presented in this chapter use simple date data types. If you are using more complex date data types, you will need to adjust the solutions accordingly.  8.1 Adding and Subtracting Days, Months, and Years  Problem   You need to add or subtract some number of days, months, or years from a date. For example, using the HIREDATE for employee CLARK, you want to return six different dates: five days before and after CLARK was hired, five months before and after CLARK was hired, and, finally, five years before and after CLARK was hired. CLARK was hired on 09-JUN-2006, so you want to return the following result set:  Solution  DB2 Standard addition and subtraction is allowed on date values, but any value that you add to or subtract from a date must be followed by the unit of time it represents:  Oracle Use standard addition and subtraction for days, and use the ADD_MONTHS function to add and subtract months and years:  H D _ M I N U S _ 5 D   H D _ P L U S _ 5 D     H D _ M I N U S _ 5 M   H D _ P L U S _ 5 M     H D _ M I N U S _ 5 Y   H D _ P L U S _ 5 Y   - - - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - - - -   0 4 - J U N - 2 0 0 6   1 4 - J U N - 2 0 0 6   0 9 - J A N - 2 0 0 6   0 9 - N O V - 2 0 0 6   0 9 - J U N - 2 0 0 1   0 9 - J U N - 2 0 0 1   1 2 - N O V - 2 0 0 6   2 2 - N O V - 2 0 0 6   1 7 - J U N - 2 0 0 6   1 7 - A P R - 2 0 0 7   1 7 - N O V - 2 0 0 1   1 7 - N O V - 2 0 0 1   1 8 - J A N - 2 0 0 7   2 8 - J A N - 2 0 0 7   2 3 - A U G - 2 0 0 6   2 3 - J U N - 2 0 0 7   2 3 - J A N - 2 0 0 2   2 3 - J A N - 2 0 0 2 1   s e l e c t   h i r e d a t e   - 5   d a y       a s   h d _ m i n u s _ 5 D ,   2                 h i r e d a t e   + 5   d a y       a s   h d _ p l u s _ 5 D ,   3                 h i r e d a t e   - 5   m o n t h   a s   h d _ m i n u s _ 5 M ,   4                 h i r e d a t e   + 5   m o n t h   a s   h d _ p l u s _ 5 M ,   5                 h i r e d a t e   - 5   y e a r     a s   h d _ m i n u s _ 5 Y ,   6                 h i r e d a t e   + 5   y e a r     a s   h d _ p l u s _ 5 Y   7       f r o m   e m p   8     w h e r e   d e p t n o   =   1 0 1   s e l e c t   h i r e d a t e - 5                                   a s   h d _ m i n u s _ 5 D ,   2                 h i r e d a t e + 5                                   a s   h d _ p l u s _ 5 D ,   3                 a d d _ m o n t h s   h i r e d a t e , - 5           a s   h d _ m i n u s _ 5 M ,   4                 a d d _ m o n t h s   h i r e d a t e , 5             a s   h d _ p l u s _ 5 M ,   5                 a d d _ m o n t h s   h i r e d a t e , - 5 * 1 2     a s   h d _ m i n u s _ 5 Y ,   6                 a d d _ m o n t h s   h i r e d a t e , 5 * 1 2       a s   h d _ p l u s _ 5 Y    PostgreSQL Use standard addition and subtraction with the INTERVAL keyword specifying the unit of time to add or subtract. Single quotes are required when specifying an INTERVAL value:  MySQL Use standard addition and subtraction with the INTERVAL keyword specifying the unit of time to add or subtract. Unlike the PostgreSQL solution, you do not place single quotes around the INTERVAL value:  Alternatively, you can use the DATE_ADD function, which is shown here:  7       f r o m   e m p   8     w h e r e   d e p t n o   =   1 0 1   s e l e c t   h i r e d a t e   -   i n t e r v a l   ' 5   d a y '       a s   h d _ m i n u s _ 5 D ,   2                 h i r e d a t e   +   i n t e r v a l   ' 5   d a y '       a s   h d _ p l u s _ 5 D ,   3                 h i r e d a t e   -   i n t e r v a l   ' 5   m o n t h '   a s   h d _ m i n u s _ 5 M ,   4                 h i r e d a t e   +   i n t e r v a l   ' 5   m o n t h '   a s   h d _ p l u s _ 5 M ,   5                 h i r e d a t e   -   i n t e r v a l   ' 5   y e a r '     a s   h d _ m i n u s _ 5 Y ,   6                 h i r e d a t e   +   i n t e r v a l   ' 5   y e a r '     a s   h d _ p l u s _ 5 Y   7       f r o m   e m p   8     w h e r e   d e p t n o = 1 0 1   s e l e c t   h i r e d a t e   -   i n t e r v a l   5   d a y       a s   h d _ m i n u s _ 5 D ,   2                 h i r e d a t e   +   i n t e r v a l   5   d a y       a s   h d _ p l u s _ 5 D ,   3                 h i r e d a t e   -   i n t e r v a l   5   m o n t h   a s   h d _ m i n u s _ 5 M ,   4                 h i r e d a t e   +   i n t e r v a l   5   m o n t h   a s   h d _ p l u s _ 5 M ,   5                 h i r e d a t e   -   i n t e r v a l   5   y e a r     a s   h d _ m i n u s _ 5 Y ,   6                 h i r e d a t e   +   i n t e r v a l   5   y e a r     a s   h d _ p l u s _ 5 Y   7       f r o m   e m p   8     w h e r e   d e p t n o = 1 0 1   s e l e c t   d a t e _ a d d   h i r e d a t e , i n t e r v a l   - 5   d a y         a s   h d _ m i n u s _ 5 D ,   2                 d a t e _ a d d   h i r e d a t e , i n t e r v a l     5   d a y         a s   h d _ p l u s _ 5 D ,   3                 d a t e _ a d d   h i r e d a t e , i n t e r v a l   - 5   m o n t h     a s   h d _ m i n u s _ 5 M ,   4                 d a t e _ a d d   h i r e d a t e , i n t e r v a l     5   m o n t h     a s   h d _ p l u s _ 5 M ,   5                 d a t e _ a d d   h i r e d a t e , i n t e r v a l   - 5   y e a r       a s   h d _ m i n u s _ 5 Y ,   6                 d a t e _ a d d   h i r e d a t e , i n t e r v a l     5   y e a r       a s   h d _ p l u s _ 5 D Y   7       f r o m   e m p   8     w h e r e   d e p t n o = 1 0  SQL Server Use the DATEADD function to add or subtract different units of time to from a date:  Discussion The Oracle solution takes advantage of the fact that integer values represent days when performing date arithmetic. However, that’s true only of arithmetic with DATE types. Oracle also has TIMESTAMP types. For those, you should use the INTERVAL solution shown for PostgreSQL. Beware too, of passing TIMESTAMPs to old-style date functions such as ADD_MONTHS. By doing so, you can lose any fractional seconds that such TIMESTAMP values may contain. The INTERVAL keyword and the string literals that go with it represent ISO-standard SQL syntax. The standard requires that interval values be enclosed within single quotes. PostgreSQL  and Oracle9i Database and later  complies with the standard. MySQL deviates somewhat by omitting support for the quotes.  8.2 Determining the Number of Days Between Two Dates  Problem You want to find the difference between two dates and represent the result in days. For example, you want to find the difference in days between the  1   s e l e c t   d a t e a d d   d a y , - 5 , h i r e d a t e         a s   h d _ m i n u s _ 5 D ,   2                 d a t e a d d   d a y , 5 , h i r e d a t e           a s   h d _ p l u s _ 5 D ,   3                 d a t e a d d   m o n t h , - 5 , h i r e d a t e     a s   h d _ m i n u s _ 5 M ,   4                 d a t e a d d   m o n t h , 5 , h i r e d a t e       a s   h d _ p l u s _ 5 M ,   5                 d a t e a d d   y e a r , - 5 , h i r e d a t e       a s   h d _ m i n u s _ 5 Y ,   6                 d a t e a d d   y e a r , 5 , h i r e d a t e         a s   h d _ p l u s _ 5 Y   7       f r o m   e m p   8     w h e r e   d e p t n o   =   1 0  HIREDATEs of employee ALLEN and employee WARD.  Solution  DB2 Use two inline views to find the HIREDATEs for WARD and ALLEN. Then subtract one HIREDATE from the other using the DAYS function:  Oracle and PostgreSQL Use two inline views to find the HIREDATEs for WARD and ALLEN, and then subtract one date from the other:  MySQL and SQL Server Use the function DATEDIFF to find the number of days between two dates. MySQL’s version of DATEDIFF requires only two parameters  the two    1   s e l e c t   d a y s   w a r d _ h d     -   d a y s   a l l e n _ h d       2       f r o m         3   s e l e c t   h i r e d a t e   a s   w a r d _ h d     4       f r o m   e m p     5     w h e r e   e n a m e   =   ' W A R D '     6                     x ,     7                       8   s e l e c t   h i r e d a t e   a s   a l l e n _ h d     9       f r o m   e m p   1 0     w h e r e   e n a m e   =   ' A L L E N '   1 1                     y   1   s e l e c t   w a r d _ h d   -   a l l e n _ h d     2       f r o m         3   s e l e c t   h i r e d a t e   a s   w a r d _ h d     4       f r o m   e m p     5     w h e r e   e n a m e   =   ' W A R D '     6                     x ,     7                       8   s e l e c t   h i r e d a t e   a s   a l l e n _ h d     9       f r o m   e m p   1 0     w h e r e   e n a m e   =   ' A L L E N '   1 1                     y  dates you want to find the difference in days between , and the smaller of the two dates should be passed first to avoid negative values  opposite in SQL Server . SQL Server’s version of the function allows you to specify what you want the return value to represent  in this example you want to return the difference in days . The solution following uses the SQL Server version:  MySQL users can simply remove the first argument of the function and flip-flop the order in which ALLEN_HD and WARD_HD is passed.  Discussion For all solutions, inline views X and Y return the HIREDATEs for employees WARD and ALLEN, respectively. For example:    1   s e l e c t   d a t e d i f f   d a y , a l l e n _ h d , w a r d _ h d       2       f r o m         3   s e l e c t   h i r e d a t e   a s   w a r d _ h d     4       f r o m   e m p     5     w h e r e   e n a m e   =   ' W A R D '     6                     x ,     7                       8   s e l e c t   h i r e d a t e   a s   a l l e n _ h d     9       f r o m   e m p   1 0     w h e r e   e n a m e   =   ' A L L E N '   1 1                     y s e l e c t   w a r d _ h d ,   a l l e n _ h d           f r o m       s e l e c t   h i r e d a t e   a s   w a r d _ h d       f r o m   e m p     w h e r e   e n a m e   =   ' W A R D '                     y ,                     s e l e c t   h i r e d a t e   a s   a l l e n _ h d       f r o m   e m p     w h e r e   e n a m e   =   ' A L L E N '                     x     W A R D _ H D           A L L E N _ H D   - - - - - - - - - - -   - - - - - - - - - -   2 2 - F E B - 2 0 0 6   2 0 - F E B - 2 0 0 6  You’ll notice a Cartesian product is created, because there is no join specified between X and Y. In this case, the lack of a join is harmless as the cardinalities for X and Y are both 1; thus, the result set will ultimately have one row  obviously, because 1 × 1 = 1 . To get the difference in days, simply subtract one of the two values returned from the other using methods appropriate for your database.  8.3 Determining the Number of Business Days Between Two Dates  Problem Given two dates, you want to find how many “working” days are between them, including the two dates themselves. For example, if January 10th is a Tuesday and January 11th is a Monday, then the number of working days between these two dates is two, as both days are typical workdays. For this recipe, a “business day” is defined as any day that is not Saturday or Sunday.  Solution The solution examples find the number of business days between the HIREDATEs of BLAKE and JONES. To determine the number of business days between two dates, you can use a pivot table to return a row for each day between the two dates  including the start and end dates . Having done that, finding the number of business days is simply counting the dates returned that are not Saturday or Sunday.  If you want to exclude holidays as well, you can create a HOLIDAYS table. Then include a simple NOT IN predicate to exclude days listed in HOLIDAYS from the solution.  TIP   DB2 Use the pivot table T500 to generate the required number of rows  representing days  between the two dates. Then count each day that is not a weekend. Use the DAYNAME function to return the weekday name of each date. For example:  MySQL Use the pivot table T500 to generate the required number of rows  days  between the two dates. Then count each day that is not a weekend. Use the DATE_ADD function to add days to each date. Use the DATE_FORMAT function to obtain the weekday name of each date:    1   s e l e c t   s u m   c a s e   w h e n   d a y n a m e   j o n e s _ h d + t 5 0 0 . i d   d a y   - 1   d a y       2                                       i n       ' S a t u r d a y ' , ' S u n d a y '         3                                   t h e n   0   e l s e   1     4                         e n d     a s   d a y s     5       f r o m         6   s e l e c t   m a x   c a s e   w h e n   e n a m e   =   ' B L A K E '     7                                   t h e n   h i r e d a t e     8                         e n d     a s   b l a k e _ h d ,     9                 m a x   c a s e   w h e n   e n a m e   =   ' J O N E S '   1 0                                   t h e n   h i r e d a t e   1 1                         e n d     a s   j o n e s _ h d   1 2       f r o m   e m p   1 3     w h e r e   e n a m e   i n       ' B L A K E ' , ' J O N E S '       1 4                     x ,   1 5                 t 5 0 0   1 6     w h e r e   t 5 0 0 . i d   < =   b l a k e _ h d - j o n e s _ h d + 1   1   s e l e c t   s u m   c a s e   w h e n   d a t e _ f o r m a t       2                                                   d a t e _ a d d   j o n e s _ h d ,     3                                                                     i n t e r v a l   t 5 0 0 . i d - 1   D A Y   , ' % a '       4                                       i n       ' S a t ' , ' S u n '         5                                   t h e n   0   e l s e   1     6                         e n d     a s   d a y s     7       f r o m         8   s e l e c t   m a x   c a s e   w h e n   e n a m e   =   ' B L A K E '     9                                   t h e n   h i r e d a t e   1 0                         e n d     a s   b l a k e _ h d ,   1 1                 m a x   c a s e   w h e n   e n a m e   =   ' J O N E S '   1 2                                   t h e n   h i r e d a t e   1 3                           e n d     a s   j o n e s _ h d    Oracle Use the pivot table T500 to generate the required number of rows  days  between the two dates, and then count each day that is not a weekend. Use the TO_CHAR function to obtain the weekday name of each date:  PostgreSQL Use the pivot table T500 to generate the required number of rows  days  between the two dates. Then count each day that is not a weekend. Use the TO_CHAR function to obtain the weekday name of each date:  1 4       f r o m   e m p   1 5     w h e r e   e n a m e   i n       ' B L A K E ' , ' J O N E S '       1 6                     x ,   1 7                 t 5 0 0   1 8     w h e r e   t 5 0 0 . i d   < =   d a t e d i f f   b l a k e _ h d , j o n e s _ h d   + 1   1   s e l e c t   s u m   c a s e   w h e n   t o _ c h a r   j o n e s _ h d + t 5 0 0 . i d - 1 , ' D Y '       2                                       i n       ' S A T ' , ' S U N '         3                                   t h e n   0   e l s e   1     4                         e n d     a s   d a y s     5       f r o m         6   s e l e c t   m a x   c a s e   w h e n   e n a m e   =   ' B L A K E '     7                                   t h e n   h i r e d a t e     8                         e n d     a s   b l a k e _ h d ,     9                 m a x   c a s e   w h e n   e n a m e   =   ' J O N E S '   1 0                                   t h e n   h i r e d a t e   1 1                         e n d     a s   j o n e s _ h d   1 2       f r o m   e m p   1 3     w h e r e   e n a m e   i n       ' B L A K E ' , ' J O N E S '       1 4                     x ,   1 5                 t 5 0 0   1 6     w h e r e   t 5 0 0 . i d   < =   b l a k e _ h d - j o n e s _ h d + 1   1   s e l e c t   s u m   c a s e   w h e n   t r i m   t o _ c h a r   j o n e s _ h d + t 5 0 0 . i d - 1 , ' D A Y '         2                                       i n       ' S A T U R D A Y ' , ' S U N D A Y '         3                                   t h e n   0   e l s e   1     4                         e n d     a s   d a y s     5       f r o m         6   s e l e c t   m a x   c a s e   w h e n   e n a m e   =   ' B L A K E '     7                                   t h e n   h i r e d a t e     8                         e n d     a s   b l a k e _ h d ,     9                 m a x   c a s e   w h e n   e n a m e   =   ' J O N E S '    SQL Server Use the pivot table T500 to generate the required number of rows  days  between the two dates, and then count each day that is not a weekend. Use the DATENAME function to obtain the weekday name of each date:  Discussion While each RDBMS requires the use of different built-in functions to determine the name of a day, the overall solution approach is the same for each. The solution can be broken into two steps:  1. Return the days between the start date and end date  inclusive . 2. Count how many days  i.e., rows  there are, excluding weekends. Inline view X performs step one. If you examine inline view X, you’ll notice the use of the aggregate function MAX, which the recipe uses to remove NULLs. If the use of MAX is unclear, the following output might  1 0                                   t h e n   h i r e d a t e   1 1                         e n d     a s   j o n e s _ h d   1 2       f r o m   e m p   1 3     w h e r e   e n a m e   i n       ' B L A K E ' , ' J O N E S '       1 4                     x ,   1 5                 t 5 0 0   1 6     w h e r e   t 5 0 0 . i d   < =   b l a k e _ h d - j o n e s _ h d + 1   1   s e l e c t   s u m   c a s e   w h e n   d a t e n a m e   d w , j o n e s _ h d + t 5 0 0 . i d - 1       2                                       i n       ' S A T U R D A Y ' , ' S U N D A Y '         3                                     t h e n   0   e l s e   1     4                         e n d     a s   d a y s     5       f r o m         6   s e l e c t m a x   c a s e   w h e n   e n a m e   =   ' B L A K E '     7                                   t h e n   h i r e d a t e     8                         e n d     a s   b l a k e _ h d ,     9                 m a x   c a s e   w h e n   e n a m e   =   ' J O N E S '   1 0                                   t h e n   h i r e d a t e   1 1                         e n d     a s   j o n e s _ h d   1 2       f r o m   e m p   1 3     w h e r e   e n a m e   i n       ' B L A K E ' , ' J O N E S '       1 4                     x ,   1 5                 t 5 0 0   1 6     w h e r e   t 5 0 0 . i d   < =   d a t e d i f f   d a y , j o n e s _ h d - b l a k e _ h d   + 1  help you understand. The output shows the results from inline view X without MAX:  Without MAX, two rows are returned. By using MAX you return only one row instead of two, and the NULLs are eliminated:  The number of days  inclusive  between the two dates here is 30. Now that the two dates are in one row, the next step is to generate one row for each of those 30 days. To return the 30 days  rows , use table T500. Since each value for ID in table T500 is simply one greater than the one before it, add each row returned by T500 to the earlier of the two dates  JONES_HD  to generate consecutive days starting from JONES_HD up to and including BLAKE_HD. The result of this addition is shown here  using Oracle syntax :  s e l e c t   c a s e   w h e n   e n a m e   =   ' B L A K E '                           t h e n   h i r e d a t e                 e n d   a s   b l a k e _ h d ,                 c a s e   w h e n   e n a m e   =   ' J O N E S '                           t h e n   h i r e d a t e                 e n d   a s   j o n e s _ h d       f r o m   e m p     w h e r e   e n a m e   i n       ' B L A K E ' , ' J O N E S '         B L A K E _ H D         J O N E S _ H D   - - - - - - - - - - -   - - - - - - - - - - -                           0 2 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6 s e l e c t   m a x   c a s e   w h e n   e n a m e   =   ' B L A K E '                           t h e n   h i r e d a t e                 e n d     a s   b l a k e _ h d ,                 m a x   c a s e   w h e n   e n a m e   =   ' J O N E S '                           t h e n   h i r e d a t e                 e n d     a s   j o n e s _ h d       f r o m   e m p     w h e r e   e n a m e   i n       ' B L A K E ' , ' J O N E S '         B L A K E _ H D         J O N E S _ H D   - - - - - - - - - - -   - - - - - - - - - - -   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6  s e l e c t   x . * ,   t 5 0 0 . * ,   j o n e s _ h d + t 5 0 0 . i d - 1       f r o m       s e l e c t   m a x   c a s e   w h e n   e n a m e   =   ' B L A K E '                                   t h e n   h i r e d a t e                         e n d     a s   b l a k e _ h d ,                 m a x   c a s e   w h e n   e n a m e   =   ' J O N E S '                                   t h e n   h i r e d a t e                         e n d     a s   j o n e s _ h d       f r o m   e m p     w h e r e   e n a m e   i n       ' B L A K E ' , ' J O N E S '                         x ,                 t 5 0 0     w h e r e   t 5 0 0 . i d   < =   b l a k e _ h d - j o n e s _ h d + 1     B L A K E _ H D         J O N E S _ H D                         I D   J O N E S _ H D + T 5   - - - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - - -   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                     1   0 2 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                     2   0 3 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                     3   0 4 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                     4   0 5 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                     5   0 6 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                     6   0 7 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                     7   0 8 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                     8   0 9 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                     9   1 0 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                   1 0   1 1 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                   1 1   1 2 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                   1 2   1 3 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                   1 3   1 4 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                   1 4   1 5 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                   1 5   1 6 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                   1 6   1 7 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                   1 7   1 8 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                   1 8   1 9 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                   1 9   2 0 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                   2 0   2 1 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                   2 1   2 2 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                   2 2   2 3 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                   2 3   2 4 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                   2 4   2 5 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                   2 5   2 6 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                   2 6   2 7 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                   2 7   2 8 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                   2 8   2 9 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                   2 9   3 0 - A P R - 2 0 0 6   0 1 - M A Y - 2 0 0 6   0 2 - A P R - 2 0 0 6                   3 0   0 1 - M A Y - 2 0 0 6  If you examine the WHERE clause, you’ll notice that you add 1 to the difference between BLAKE_HD and JONES_HD to generate the required 30 rows  otherwise, you would get 29 rows . You’ll also notice that you subtract 1 from T500.ID in the SELECT list of the outer query, since the values for ID start at 1 and adding 1 to JONES_HD would cause JONES_HD to be excluded from the final count. Once you generate the number of rows required for the result set, use a CASE expression to “flag” whether each of the days returned is weekday or weekend  return a 1 for a weekday and a 0 for a weekend . The final step is to use the aggregate function SUM to tally up the number of 1s to get the final answer.  8.4 Determining the Number of Months or Years Between Two Dates  Problem You want to find the difference between two dates in terms of either months or years. For example, you want to find the number of months between the first and last employees hired, and you also want to express that value as some number of years.  Solution Since there are always 12 months in a year, you can find the number of months between 2 dates and then divide by 12 to get the number of years. After getting comfortable with the solution, you’ll want to round the results up or down depending on what you want for the year. For example, the first HIREDATE in table EMP is 17-DEC-1980 and the last is 12-JAN-1983. If you do the math on the years  1983 minus 1980 , you get 3 years, yet the difference in months is approximately 25  a little over 2 years . You should tweak the solution as you see fit. The following solutions will return 25 months and approximately 2 years.   DB2 and MySQL Use the functions YEAR and MONTH to return the four-digit year and the two-digit month for the dates supplied:  Oracle Use the function MONTHS_BETWEEN to find the difference between two dates in months  to get years, simply divide by 12 :  PostgreSQL Use the function EXTRACT to return the four-digit year and two-digit month for the dates supplied:  1   s e l e c t   m n t h ,   m n t h   1 2   2       f r o m       3   s e l e c t     y e a r   m a x _ h d     -   y e a r   m i n _ h d     * 1 2   +   4                   m o n t h   m a x _ h d     -   m o n t h   m i n _ h d       a s   m n t h   5       f r o m       6   s e l e c t   m i n   h i r e d a t e     a s   m i n _ h d ,   m a x   h i r e d a t e     a s   m a x _ h d   7       f r o m   e m p   8                     x   9                     y 1   s e l e c t   m o n t h s _ b e t w e e n   m a x _ h d , m i n _ h d   ,   2                 m o n t h s _ b e t w e e n   m a x _ h d , m i n _ h d     1 2   3       f r o m       4   s e l e c t   m i n   h i r e d a t e     m i n _ h d ,   m a x   h i r e d a t e     m a x _ h d   5       f r o m   e m p   6                     x   1   s e l e c t   m n t h ,   m n t h   1 2     2       f r o m         3   s e l e c t       e x t r a c t   y e a r   f r o m   m a x _ h d       4                     e x t r a c t   y e a r   f r o m   m i n _ h d         *   1 2     5                 +     6                     e x t r a c t   m o n t h   f r o m   m a x _ h d       7                     e x t r a c t   m o n t h   f r o m   m i n _ h d         a s   m n t h     8       f r o m         9   s e l e c t   m i n   h i r e d a t e     a s   m i n _ h d ,   m a x   h i r e d a t e     a s   m a x _ h d   1 0       f r o m   e m p   1 1                     x   1 2                     y  SQL Server Use the function DATEDIFF to find the difference between two dates, and use the DATEPART argument to specify months and years as the time units returned:  Discussion  DB2, MySQL, and PostgreSQL Once you extract the year and month for MIN_HD and MAX_HD in the PostgreSQL solution, the method for finding the months and years between MIN_HD and MAX_HD is the same for all three RDBMs. This discussion will cover all three solutions. Inline view X returns the earliest and latest HIREDATEs in table EMP and is shown here:  To find the months between MAX_HD and MIN_HD, multiply the difference in years between MIN_HD and MAX_HD by 12, and then add the difference in months between MAX_HD and MIN_HD. If you are having trouble seeing how this works, return the date component for each date. The numeric values for the years and months are shown here:    1   s e l e c t   d a t e d i f f   m o n t h , m i n _ h d , m a x _ h d   ,     2                 d a t e d i f f   y e a r , m i n _ h d , m a x _ h d       3       f r o m         4   s e l e c t   m i n   h i r e d a t e     m i n _ h d ,   m a x   h i r e d a t e     m a x _ h d     5       f r o m   e m p     6                     x s e l e c t   m i n   h i r e d a t e     a s   m i n _ h d ,                 m a x   h i r e d a t e     a s   m a x _ h d       f r o m   e m p     M I N _ H D             M A X _ H D   - - - - - - - - - - -   - - - - - - - - - - -   1 7 - D E C - 1 9 8 0   1 2 - J A N - 1 9 8 3  Looking at these results, finding the months between MAX_HD and MIN_HD is simply   of years between MIN_HD and MAX_HD, divide the number of months by 12. Again, depending on the results you are looking for, you will want to round the values.   . To find the number  Oracle and SQL Server Inline view X returns the earliest and latest HIREDATEs in table EMP and is shown here:  The functions supplied by Oracle and SQL Server  MONTHS_BETWEEN and DATEDIFF, respectively  will return the number of months between two given dates. To find the year, divide the number of months by 12.  8.5 Determining the Number of Seconds, Minutes, or Hours Between Two Dates  Problem  s e l e c t   y e a r   m a x _ h d     a s   m a x _ y r ,   y e a r   m i n _ h d     a s   m i n _ y r ,                 m o n t h   m a x _ h d     a s   m a x _ m o n ,   m o n t h   m i n _ h d     a s   m i n _ m o n       f r o m       s e l e c t   m i n   h i r e d a t e     a s   m i n _ h d ,   m a x   h i r e d a t e     a s   m a x _ h d       f r o m   e m p                     x     M A X _ Y R           M I N _ Y R         M A X _ M O N         M I N _ M O N   - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -       1 9 8 3               1 9 8 0                     1                   1 2 1 9 8 3 − 1 9 8 0   × 1 2 +   1 − 1 2 s e l e c t   m i n   h i r e d a t e     a s   m i n _ h d ,   m a x   h i r e d a t e     a s   m a x _ h d       f r o m   e m p     M I N _ H D             M A X _ H D   - - - - - - - - - - -   - - - - - - - - - - -   1 7 - D E C - 1 9 8 0   1 2 - J A N - 1 9 8 3  You want to return the difference in seconds between two dates. For example, you want to return the difference between the HIREDATEs of ALLEN and WARD in seconds, minutes, and hours.  Solution If you can find the number of days between two dates, you can find seconds, minutes, and hours as they are the units of time that make up a day.  DB2 Use the function DAYS to find the difference between ALLEN_HD and WARD_HD in days. Then multiply to find each unit of time:  MySQL Use the DATEDIFF function to return the number of days between ALLEN_HD and WARD_HD. Then multiply to find each unit of time:    1   s e l e c t   d y * 2 4   h r ,   d y * 2 4 * 6 0   m i n ,   d y * 2 4 * 6 0 * 6 0   s e c     2       f r o m         3   s e l e c t       d a y s   m a x   c a s e   w h e n   e n a m e   =   ' W A R D '     4                                       t h e n   h i r e d a t e     5                             e n d       -     6                     d a y s   m a x   c a s e   w h e n   e n a m e   =   ' A L L E N '     7                                       t h e n   h i r e d a t e     8                             e n d         9                     a s   d y   1 0       f r o m   e m p   1 1                     x   1   s e l e c t   d a t e d i f f   d a y , a l l e n _ h d , w a r d _ h d   * 2 4   h r ,     2                 d a t e d i f f   d a y , a l l e n _ h d , w a r d _ h d   * 2 4 * 6 0   m i n ,     3                 d a t e d i f f   d a y , a l l e n _ h d , w a r d _ h d   * 2 4 * 6 0 * 6 0   s e c     4       f r o m         5   s e l e c t   m a x   c a s e   w h e n   e n a m e   =   ' W A R D '     6                                     t h e n   h i r e d a t e     7                         e n d     a s   w a r d _ h d ,     8                 m a x   c a s e   w h e n   e n a m e   =   ' A L L E N '     9                                   t h e n   h i r e d a t e   1 0                         e n d     a s   a l l e n _ h d    SQL Server Use the DATEDIFF function to return the number of days between ALLEN_HD and WARD_HD. Then use the DATEPART argument to specify the required time unit:  Oracle and PostgreSQL Use subtraction to return the number of days between ALLEN_HD and WARD_ HD. Then multiply to find each unit of time:  Discussion Inline view X for all solutions returns the HIREDATEs for WARD and ALLEN, as shown here:  1 1       f r o m   e m p   1 2                     x   1   s e l e c t   d a t e d i f f   d a y , a l l e n _ h d , w a r d _ h d , h o u r     a s   h r ,     2                 d a t e d i f f   d a y , a l l e n _ h d , w a r d _ h d , m i n u t e     a s   m i n ,     3                 d a t e d i f f   d a y , a l l e n _ h d , w a r d _ h d , s e c o n d     a s   s e c     4       f r o m         5   s e l e c t   m a x   c a s e   w h e n   e n a m e   =   ' W A R D '     6                                     t h e n   h i r e d a t e     7                         e n d     a s   w a r d _ h d ,     8                 m a x   c a s e   w h e n   e n a m e   =   ' A L L E N '     9                                   t h e n   h i r e d a t e   1 0                         e n d     a s   a l l e n _ h d   1 1       f r o m   e m p   1 2                     x   1   s e l e c t   d y * 2 4   a s   h r ,   d y * 2 4 * 6 0   a s   m i n ,   d y * 2 4 * 6 0 * 6 0   a s   s e c     2       f r o m         3   s e l e c t     m a x   c a s e   w h e n   e n a m e   =   ' W A R D '     4                                   t h e n   h i r e d a t e     5                         e n d     -     6                 m a x   c a s e   w h e n   e n a m e   =   ' A L L E N '     7                                   t h e n   h i r e d a t e     8                         e n d       a s   d y     9       f r o m   e m p   1 0                     x  Multiply the number of days between WARD_HD and ALLEN_HD by 24  hours in a day , 1440  minutes in a day , and 86400  seconds in a day .  8.6 Counting the Occurrences of Weekdays in a Year  Problem You want to count the number of times each weekday occurs in one year.  Solution To find the number of occurrences of each weekday in a year, you must:  1. Generate all possible dates in the year. 2. Format the dates such that they resolve to the name of their respective  weekdays.  3. Count the occurrence of each weekday name.  DB2 Use recursive WITH to avoid the need to SELECT against a table with at least 366 rows. Use the function DAYNAME to obtain the weekday name for each date, and then count the occurrence of each:  s e l e c t   m a x   c a s e   w h e n   e n a m e   =   ' W A R D '                                     t h e n   h i r e d a t e                         e n d     a s   w a r d _ h d ,                 m a x   c a s e   w h e n   e n a m e   =   ' A L L E N '                                   t h e n   h i r e d a t e                         e n d     a s   a l l e n _ h d       f r o m   e m p     W A R D _ H D           A L L E N _ H D   - - - - - - - - - - -   - - - - - - - - - - -   2 2 - F E B - 2 0 0 6   2 0 - F E B - 2 0 0 6  MySQL Select against table T500 to generate enough rows to return every day in the year. Use the DATE_FORMAT function to obtain the weekday name of each date, and then count the occurrence of each name:    1   w i t h   x     s t a r t _ d a t e , e n d _ d a t e       2   a s         3   s e l e c t   s t a r t _ d a t e ,     4                 s t a r t _ d a t e   +   1   y e a r   e n d _ d a t e     5       f r o m         6   s e l e c t     c u r r e n t _ d a t e     7                   d a y o f y e a r   c u r r e n t _ d a t e     d a y       8                   + 1   d a y   a s   s t a r t _ d a t e     9       f r o m   t 1   1 0                     t m p   1 1     u n i o n   a l l   1 2   s e l e c t   s t a r t _ d a t e   +   1   d a y ,   e n d _ d a t e   1 3       f r o m   x   1 4     w h e r e   s t a r t _ d a t e   +   1   d a y   <   e n d _ d a t e   1 5       1 6   s e l e c t   d a y n a m e   s t a r t _ d a t e   , c o u n t   *     1 7       f r o m   x   1 8     g r o u p   b y   d a y n a m e   s t a r t _ d a t e     1   s e l e c t   d a t e _ f o r m a t       2                       d a t e _ a d d       3                               c a s t       4                           c o n c a t   y e a r   c u r r e n t _ d a t e   , ' - 0 1 - 0 1 '       5                                         a s   d a t e   ,     6                                         i n t e r v a l   t 5 0 0 . i d - 1   d a y   ,     7                                         ' % W '     d a y ,     8                 c o u n t   *       9       f r o m   t 5 0 0   1 0     w h e r e   t 5 0 0 . i d   < =   d a t e d i f f     1 1                                                     c a s t     1 2                                                 c o n c a t   y e a r   c u r r e n t _ d a t e   + 1 , ' - 0 1 - 0 1 '     1 3                                                               a s   d a t e   ,   1 4                                                     c a s t     1 5                                                 c o n c a t   y e a r   c u r r e n t _ d a t e   , ' - 0 1 - 0 1 '     1 6                                                               a s   d a t e       1 7   g r o u p   b y   d a t e _ f o r m a t     1 8                           d a t e _ a d d     1 9                                   c a s t     2 0                               c o n c a t   y e a r   c u r r e n t _ d a t e   , ' - 0 1 - 0 1 '     2 1                                             a s   d a t e   ,    Oracle You can use the recursive CONNECT BY to return each day in a year:  PostgreSQL Use the built-in function GENERATE_SERIES to generate one row for every day in the year. Then use the TO_CHAR function to obtain the weekday name of each date. Finally, count the occurrence of each weekday name. For example:  SQL Server  2 2                                             i n t e r v a l   t 5 0 0 . i d - 1   d a y   ,   2 3                                             ' % W '     1   w i t h   x   a s         2   s e l e c t   l e v e l   l v l     3       f r o m   d u a l     4     c o n n e c t   b y   l e v e l   < =         5         a d d _ m o n t h s   t r u n c   s y s d a t e , ' y '   , 1 2   - t r u n c   s y s d a t e , ' y '       6           7         8   s e l e c t   t o _ c h a r   t r u n c   s y s d a t e , ' y '   + l v l - 1 , ' D A Y '   ,   c o u n t   *       9       f r o m   x   1 0     g r o u p   b y   t o _ c h a r   t r u n c   s y s d a t e , ' y '   + l v l - 1 , ' D A Y '     1   s e l e c t   t o _ c h a r       2                       c a s t       3           d a t e _ t r u n c   ' y e a r ' , c u r r e n t _ d a t e       4                                 a s   d a t e     +   g s . i d - 1 , ' D A Y '   ,     5                 c o u n t   *       6       f r o m   g e n e r a t e _ s e r i e s   1 , 3 6 6     g s   i d       7     w h e r e   g s . i d   < =     c a s t     8                                                 d a t e _ t r u n c   ' y e a r ' , c u r r e n t _ d a t e     +     9                                                       i n t e r v a l   ' 1 2   m o n t h '   a s   d a t e     -   1 0   c a s t   d a t e _ t r u n c   ' y e a r ' , c u r r e n t _ d a t e     1 1                                               a s   d a t e       1 2     g r o u p   b y   t o _ c h a r     1 3                             c a s t     1 4                 d a t e _ t r u n c   ' y e a r ' , c u r r e n t _ d a t e     1 5                       a s   d a t e     +   g s . i d - 1 , ' D A Y '    Use the recursive WITH to avoid the need to SELECT against a table with at least 366 rows. Use the DATENAME function to obtain the weekday name of each date, and then count the occurrence of each name. For example:  Discussion  DB2 Inline view TMP, in the recursive WITH view X, returns the first day of the current year and is shown here:    1   w i t h   x     s t a r t _ d a t e , e n d _ d a t e       2   a s         3   s e l e c t   s t a r t _ d a t e ,     4                 d a t e a d d   y e a r , 1 , s t a r t _ d a t e     e n d _ d a t e     5       f r o m         6   s e l e c t   c a s t       7                 c a s t   y e a r   g e t d a t e         a s   v a r c h a r     +   ' - 0 1 - 0 1 '     8                           a s   d a t e t i m e     s t a r t _ d a t e     9       f r o m   t 1   1 0                     t m p   1 1   u n i o n   a l l   1 2   s e l e c t   d a t e a d d   d a y , 1 , s t a r t _ d a t e   ,   e n d _ d a t e   1 3       f r o m   x   1 4     w h e r e   d a t e a d d   d a y , 1 , s t a r t _ d a t e     <   e n d _ d a t e   1 5       1 6   s e l e c t   d a t e n a m e   d w , s t a r t _ d a t e   , c o u n t   *     1 7       f r o m   x   1 8     g r o u p   b y   d a t e n a m e   d w , s t a r t _ d a t e     1 9   O P T I O N     M A X R E C U R S I O N   3 6 6   s e l e c t     c u r r e n t _ d a t e                   d a y o f y e a r   c u r r e n t _ d a t e     d a y                     + 1   d a y   a s   s t a r t _ d a t e       f r o m   t 1     S T A R T _ D A T E   - - - - - - - - - - - - -   0 1 - J A N - 2 0 0 5  The next step is to add one year to START_DATE so that you have the beginning and end dates. You need to know both because you want to generate every day in a year. START_DATE and END_DATE are shown here:  The next step is to recursively increment START_DATE by one day, stopping before it equals END_DATE. A portion of the rows returned by the recursive view X is shown here:  s e l e c t   s t a r t _ d a t e ,                 s t a r t _ d a t e   +   1   y e a r   e n d _ d a t e       f r o m       s e l e c t     c u r r e n t _ d a t e                   d a y o f y e a r   c u r r e n t _ d a t e     d a y                     + 1   d a y   a s   s t a r t _ d a t e       f r o m   t 1                     t m p       S T A R T _ D A T E     E N D _ D A T E     - - - - - - - - - - -   - - - - - - - - - - - -     0 1 - J A N - 2 0 0 5   0 1 - J A N - 2 0 0 6 w i t h   x     s t a r t _ d a t e , e n d _ d a t e     a s       s e l e c t   s t a r t _ d a t e ,                 s t a r t _ d a t e   +   1   y e a r   e n d _ d a t e       f r o m       s e l e c t     c u r r e n t _ d a t e   -                   d a y o f y e a r   c u r r e n t _ d a t e     d a y                     + 1   d a y   a s   s t a r t _ d a t e       f r o m   t 1                     t m p     u n i o n   a l l   s e l e c t   s t a r t _ d a t e   +   1   d a y ,   e n d _ d a t e       f r o m   x     w h e r e   s t a r t _ d a t e   +   1   d a y   <   e n d _ d a t e       s e l e c t   *   f r o m   x     S T A R T _ D A T E     E N D _ D A T E   - - - - - - - - - - -   - - - - - - - - - - -   0 1 - J A N - 2 0 0 5   0 1 - J A N - 2 0 0 6   0 2 - J A N - 2 0 0 5   0 1 - J A N - 2 0 0 6   0 3 - J A N - 2 0 0 5   0 1 - J A N - 2 0 0 6    The final step is to use the function DAYNAME on the rows returned by the recursive view X and count how many times each weekday occurs. The final result is shown here:  …   2 9 - J A N - 2 0 0 5   0 1 - J A N - 2 0 0 6   3 0 - J A N - 2 0 0 5   0 1 - J A N - 2 0 0 6   3 1 - J A N - 2 0 0 5   0 1 - J A N - 2 0 0 6   …   0 1 - D E C - 2 0 0 5   0 1 - J A N - 2 0 0 6   0 2 - D E C - 2 0 0 5   0 1 - J A N - 2 0 0 6   0 3 - D E C - 2 0 0 5   0 1 - J A N - 2 0 0 6   …   2 9 - D E C - 2 0 0 5   0 1 - J A N - 2 0 0 6   3 0 - D E C - 2 0 0 5   0 1 - J A N - 2 0 0 6   3 1 - D E C - 2 0 0 5   0 1 - J A N - 2 0 0 6 w i t h   x     s t a r t _ d a t e , e n d _ d a t e     a s       s e l e c t   s t a r t _ d a t e ,                 s t a r t _ d a t e   +   1   y e a r   e n d _ d a t e       f r o m       s e l e c t                                 c u r r e n t _ d a t e   -                   d a y o f y e a r   c u r r e n t _ d a t e     d a y                     + 1   d a y   a s   s t a r t _ d a t e       f r o m   t 1                     t m p     u n i o n   a l l   s e l e c t   s t a r t _ d a t e   +   1   d a y ,   e n d _ d a t e       f r o m   x     w h e r e   s t a r t _ d a t e   +   1   d a y   <   e n d _ d a t e       s e l e c t   d a y n a m e   s t a r t _ d a t e   , c o u n t   *         f r o m   x     g r o u p   b y   d a y n a m e   s t a r t _ d a t e       S T A R T _ D A T E       C O U N T   *     - - - - - - - - - -   - - - - - - - - - -   F R I D A Y                           5 2   M O N D A Y                           5 2   S A T U R D A Y                       5 3   S U N D A Y                           5 2   T H U R S D A Y                       5 2   T U E S D A Y                         5 2   W E D N E S D A Y                     5 2  MySQL This solution selects against table T500 to generate one row for every day in the year. The command on line 4 returns the first day of the current year. It does this by returning the year of the date returned by the function CURRENT_DATE and then appending a month and day  following MySQL’s default date format . The result is shown here:  Now that you have the first day in the current year, use the DATEADD function to add each value from T500.ID to generate each day in the year. Use the function DATE_FORMAT to return the weekday for each date. To generate the required number of rows from table T500, find the difference in days between the first day of the current year and the first day of the next year, and return that many rows  will be either 365 or 366 . A portion of the results is shown here:  s e l e c t   c o n c a t   y e a r   c u r r e n t _ d a t e   , ' - 0 1 - 0 1 '         f r o m   t 1     S T A R T _ D A T E   - - - - - - - - - - -   0 1 - J A N - 2 0 0 5 s e l e c t   d a t e _ f o r m a t                         d a t e _ a d d                                 c a s t                             c o n c a t   y e a r   c u r r e n t _ d a t e   , ' - 0 1 - 0 1 '                                           a s   d a t e   ,                                         i n t e r v a l   t 5 0 0 . i d - 1   d a y   ,                                         ' % W '     d a y       f r o m   t 5 0 0     w h e r e   t 5 0 0 . i d   < =   d a t e d i f f                                                       c a s t                                                   c o n c a t   y e a r   c u r r e n t _ d a t e   + 1 , ' - 0 1 - 0 1 '                                                                 a s   d a t e   ,                                                     c a s t                                                   c o n c a t   y e a r   c u r r e n t _ d a t e   , ' - 0 1 - 0 1 '                                                               a s   d a t e         D A Y   - - - - - - - - - - -   0 1 - J A N - 2 0 0 5    Now that you can return every day in the current year, count the occurrences of each weekday returned by the function DAYNAME. The final results are shown here:  0 2 - J A N - 2 0 0 5   0 3 - J A N - 2 0 0 5   …   2 9 - J A N - 2 0 0 5   3 0 - J A N - 2 0 0 5   3 1 - J A N - 2 0 0 5   …   0 1 - D E C - 2 0 0 5   0 2 - D E C - 2 0 0 5   0 3 - D E C - 2 0 0 5   …   2 9 - D E C - 2 0 0 5   3 0 - D E C - 2 0 0 5   3 1 - D E C - 2 0 0 5 s e l e c t   d a t e _ f o r m a t                         d a t e _ a d d                                 c a s t                             c o n c a t   y e a r   c u r r e n t _ d a t e   , ' - 0 1 - 0 1 '                                           a s   d a t e   ,                                         i n t e r v a l   t 5 0 0 . i d - 1   d a y   ,                                         ' % W '     d a y ,                 c o u n t   *         f r o m   t 5 0 0     w h e r e   t 5 0 0 . i d   < =   d a t e d i f f                                                       c a s t                                                   c o n c a t   y e a r   c u r r e n t _ d a t e   + 1 , ' - 0 1 - 0 1 '                                                                 a s   d a t e   ,                                                     c a s t                                                   c o n c a t   y e a r   c u r r e n t _ d a t e   , ' - 0 1 - 0 1 '                                                                 a s   d a t e         g r o u p   b y   d a t e _ f o r m a t                               d a t e _ a d d                                       c a s t                                   c o n c a t   y e a r   c u r r e n t _ d a t e   , ' - 0 1 - 0 1 '                                                 a s   d a t e   ,                                             i n t e r v a l   t 5 0 0 . i d - 1   d a y   ,                                             ' % W '       D A Y               C O U N T   *     - - - - - - - - -   - - - - - - - - - -   F R I D A Y                         5 2    Oracle The solutions provided either select against table T500  a pivot table , or use the recursive CONNECT BY and WITH to generate a row for every day in the current year. The call to the function TRUNC truncates the current date to the first day of the current year. If you are using the CONNECT BY WITH solution, you can use the pseudo-column LEVEL to generate sequential numbers beginning at one. To generate the required number of rows needed for this solution, filter ROWNUM or LEVEL on the difference in days between the first day of the current year and the first day of the next year  will be 365 or 366 days . The next step is to increment each day by adding ROWNUM or LEVEL to the first day of the current year. Partial results are shown here:  If you are using the pivot-table solution, you can use any table or view with at least 366 rows in it. And since Oracle has ROWNUM, there’s no need for a table with incrementing values starting from one. Consider the following example, which uses pivot table T500 to return every day in the current year:  M O N D A Y                         5 2   S A T U R D A Y                     5 3   S U N D A Y                         5 2   T H U R S D A Y                     5 2   T U E S D A Y                       5 2   W E D N E S D A Y                   5 2   *   O r a c l e   9 i   a n d   l a t e r   *     w i t h   x   a s       s e l e c t   l e v e l   l v l       f r o m   d u a l     c o n n e c t   b y   l e v e l   < =             a d d _ m o n t h s   t r u n c   s y s d a t e , ' y '   , 1 2   - t r u n c   s y s d a t e , ' y '               s e l e c t   t r u n c   s y s d a t e , ' y '   + l v l - 1       f r o m   x   *   O r a c l e   8 i   a n d   e a r l i e r   *     s e l e c t   t r u n c   s y s d a t e , ' y '   + r o w n u m - 1   s t a r t _ d a t e       f r o m   t 5 0 0    Regardless of which approach you take, you eventually must use the function TO_ CHAR to return the weekday name for each date and then count the occurrence of each name. The final results are shown here:    w h e r e   r o w n u m   < =     a d d _ m o n t h s   t r u n c   s y s d a t e , ' y '   , 1 2                                               -   t r u n c   s y s d a t e , ' y '         S T A R T _ D A T E   - - - - - - - - - - -   0 1 - J A N - 2 0 0 5   0 2 - J A N - 2 0 0 5   0 3 - J A N - 2 0 0 5   …   2 9 - J A N - 2 0 0 5   3 0 - J A N - 2 0 0 5   3 1 - J A N - 2 0 0 5   …   0 1 - D E C - 2 0 0 5   0 2 - D E C - 2 0 0 5   0 3 - D E C - 2 0 0 5   …   2 9 - D E C - 2 0 0 5   3 0 - D E C - 2 0 0 5   3 1 - D E C - 2 0 0 5   *   O r a c l e   9 i   a n d   l a t e r   *     w i t h   x   a s       s e l e c t   l e v e l   l v l       f r o m   d u a l     c o n n e c t   b y   l e v e l   < =             a d d _ m o n t h s   t r u n c   s y s d a t e , ' y '   , 1 2   - t r u n c   s y s d a t e , ' y '               s e l e c t   t o _ c h a r   t r u n c   s y s d a t e , ' y '   + l v l - 1 , ' D A Y '   ,   c o u n t   *         f r o m   x     g r o u p   b y   t o _ c h a r   t r u n c   s y s d a t e , ' y '   + l v l - 1 , ' D A Y '         *   O r a c l e   8 i   a n d   e a r l i e r   *     s e l e c t   t o _ c h a r   t r u n c   s y s d a t e , ' y '   + r o w n u m - 1 , ' D A Y '     s t a r t _ d a t e ,                 c o u n t   *         f r o m   t 5 0 0     w h e r e   r o w n u m   < =     a d d _ m o n t h s   t r u n c   s y s d a t e , ' y '   , 1 2                                               -   t r u n c   s y s d a t e , ' y '         g r o u p   b y   t o _ c h a r   t r u n c   s y s d a t e , ' y '   + r o w n u m - 1 , ' D A Y '       S T A R T _ D A T E       C O U N T   *      PostgreSQL The first step is to use the DATE_TRUNC function to return the year of the current date  shown here, selecting against T1 so only one row is returned :  The next step is to select against a row source  any table expression, really  with at least 366 rows. The solution uses the function GENERATE_SERIES as the row source. You can, of course, use table T500 instead. Then add one day to the first day of the current year until you return every day in the year  shown here :  - - - - - - - - - -   - - - - - - - - - -   F R I D A Y                           5 2   M O N D A Y                           5 2   S A T U R D A Y                       5 3   S U N D A Y                           5 2   T H U R S D A Y                       5 2   T U E S D A Y                         5 2   W E D N E S D A Y                     5 2 s e l e c t   c a s t                       d a t e _ t r u n c   ' y e a r ' , c u r r e n t _ d a t e                       a s   d a t e     a s   s t a r t _ d a t e       f r o m   t 1       S T A R T _ D A T E     - - - - - - - - - -     0 1 - J A N - 2 0 0 5 s e l e c t   c a s t     d a t e _ t r u n c   ' y e a r ' , c u r r e n t _ d a t e                                   a s   d a t e     +   g s . i d - 1   a s   s t a r t _ d a t e       f r o m   g e n e r a t e _ s e r i e s     1 , 3 6 6     g s   i d       w h e r e   g s . i d   < =     c a s t                                                 d a t e _ t r u n c   ' y e a r ' , c u r r e n t _ d a t e     +                                                       i n t e r v a l   ' 1 2   m o n t h '   a s   d a t e     -             c a s t   d a t e _ t r u n c   ' y e a r ' , c u r r e n t _ d a t e                                                 a s   d a t e         S T A R T _ D A T E   - - - - - - - - - - -   0 1 - J A N - 2 0 0 5   0 2 - J A N - 2 0 0 5   0 3 - J A N - 2 0 0 5   …    The final step is to use the function TO_CHAR to return the weekday name for each date and then count the occurrence of each name. The final results are shown here:  SQL Server  2 9 - J A N - 2 0 0 5   3 0 - J A N - 2 0 0 5   3 1 - J A N - 2 0 0 5   …   0 1 - D E C - 2 0 0 5   0 2 - D E C - 2 0 0 5   0 3 - D E C - 2 0 0 5   …   2 9 - D E C - 2 0 0 5   3 0 - D E C - 2 0 0 5   3 1 - D E C - 2 0 0 5 s e l e c t   t o _ c h a r                         c a s t             d a t e _ t r u n c   ' y e a r ' , c u r r e n t _ d a t e                                   a s   d a t e     +   g s . i d - 1 , ' D A Y '     a s   s t a r t _ d a t e s ,                 c o u n t   *         f r o m   g e n e r a t e _ s e r i e s   1 , 3 6 6     g s   i d       w h e r e   g s . i d   < =     c a s t                                                 d a t e _ t r u n c   ' y e a r ' , c u r r e n t _ d a t e     +                                                     i n t e r v a l   ' 1 2   m o n t h '   a s   d a t e     -             c a s t   d a t e _ t r u n c   ' y e a r ' , c u r r e n t _ d a t e                                                 a s   d a t e         g r o u p   b y   t o _ c h a r                               c a s t                   d a t e _ t r u n c   ' y e a r ' , c u r r e n t _ d a t e                         a s   d a t e     +   g s . i d - 1 , ' D A Y '       S T A R T _ D A T E       C O U N T   *     - - - - - - - - - -   - - - - - - - - - -   F R I D A Y                           5 2   M O N D A Y                           5 2   S A T U R D A Y                       5 3   S U N D A Y                           5 2   T H U R S D A Y                       5 2   T U E S D A Y                         5 2   W E D N E S D A Y                     5 2  Inline view TMP, in the recursive WITH view X, returns the first day of the current year and is shown here:  Once you return the first day of the current year, add one year to START_DATE so that you have the beginning and end dates. You need to know both because you want to generate every day in a year. START_DATE and END_DATE are shown here:  Next, recursively increment START_DATE by one day and stop before it equals END_DATE. A portion of the rows returned by the recursive view X is shown below:  s e l e c t   c a s t                   c a s t   y e a r   g e t d a t e         a s   v a r c h a r     +   ' - 0 1 - 0 1 '                           a s   d a t e t i m e     s t a r t _ d a t e       f r o m   t 1     S T A R T _ D A T E   - - - - - - - - - - -   0 1 - J A N - 2 0 0 5 s e l e c t   s t a r t _ d a t e ,                   d a t e a d d   y e a r , 1 , s t a r t _ d a t e     e n d _ d a t e       f r o m       s e l e c t   c a s t                   c a s t   y e a r   g e t d a t e         a s   v a r c h a r     +   ' - 0 1 - 0 1 '                           a s   d a t e t i m e     s t a r t _ d a t e       f r o m   t 1                     t m p     S T A R T _ D A T E     E N D _ D A T E   - - - - - - - - - - -   - - - - - - - - - - -   0 1 - J A N - 2 0 0 5   0 1 - J A N - 2 0 0 6 w i t h   x     s t a r t _ d a t e , e n d _ d a t e       a s         s e l e c t   s t a r t _ d a t e ,                   d a t e a d d   y e a r , 1 , s t a r t _ d a t e     e n d _ d a t e         f r o m         s e l e c t   c a s t                     c a s t   y e a r   g e t d a t e         a s   v a r c h a r     +   ' - 0 1 - 0 1 '                             a s   d a t e t i m e     s t a r t _ d a t e    The final step is to use the function DATENAME on the rows returned by the recursive view X and count how many times each weekday occurs. The final result is shown here:        f r o m   t 1                       t m p     u n i o n   a l l     s e l e c t   d a t e a d d   d a y , 1 , s t a r t _ d a t e   ,   e n d _ d a t e         f r o m   x       w h e r e   d a t e a d d   d a y , 1 , s t a r t _ d a t e     <   e n d _ d a t e           s e l e c t   *   f r o m   x     O P T I O N     M A X R E C U R S I O N   3 6 6       S T A R T _ D A T E     E N D _ D A T E   - - - - - - - - - - -   - - - - - - - - - - -   0 1 - J A N - 2 0 0 5   0 1 - J A N - 2 0 0 6   0 2 - J A N - 2 0 0 5   0 1 - J A N - 2 0 0 6   0 3 - J A N - 2 0 0 5   0 1 - J A N - 2 0 0 6   …   2 9 - J A N - 2 0 0 5   0 1 - J A N - 2 0 0 6   3 0 - J A N - 2 0 0 5   0 1 - J A N - 2 0 0 6   3 1 - J A N - 2 0 0 5   0 1 - J A N - 2 0 0 6   …   0 1 - D E C - 2 0 0 5   0 1 - J A N - 2 0 0 6   0 2 - D E C - 2 0 0 5   0 1 - J A N - 2 0 0 6   0 3 - D E C - 2 0 0 5   0 1 - J A N - 2 0 0 6   …   2 9 - D E C - 2 0 0 5   0 1 - J A N - 2 0 0 6   3 0 - D E C - 2 0 0 5   0 1 - J A N - 2 0 0 6   3 1 - D E C - 2 0 0 5   0 1 - J A N - 2 0 0 6 w i t h   x   s t a r t _ d a t e , e n d _ d a t e       a s         s e l e c t   s t a r t _ d a t e ,                   d a t e a d d   y e a r , 1 , s t a r t _ d a t e     e n d _ d a t e         f r o m         s e l e c t   c a s t                     c a s t   y e a r   g e t d a t e         a s   v a r c h a r     +   ' - 0 1 - 0 1 '                             a s   d a t e t i m e     s t a r t _ d a t e         f r o m   t 1                       t m p     u n i o n   a l l     s e l e c t   d a t e a d d   d a y , 1 , s t a r t _ d a t e   ,   e n d _ d a t e         f r o m   x       w h e r e   d a t e a d d   d a y , 1 , s t a r t _ d a t e     <   e n d _ d a t e    8.7 Determining the Date Difference Between the Current Record and the Next Record  Problem You want to determine the difference in days between two dates  specifically dates stored in two different rows . For example, for every employee in DEPTNO 10, you want to determine the number of days between the day they were hired and the day the next employee  can be in another department  was hired.  Solution The trick to this problem’s solution is to find the earliest HIREDATE after the current employee was hired. After that, simply use the technique from Recipe 8.2 to find the difference in days.  DB2 Use a scalar subquery to find the next HIREDATE relative to the current HIREDATE. Then use the DAYS function to find the difference in days:          s e l e c t   d a t e n a m e   d w , s t a r t _ d a t e   ,   c o u n t   *           f r o m   x       g r o u p   b y   d a t e n a m e   d w , s t a r t _ d a t e       O P T I O N     M A X R E C U R S I O N   3 6 6         S T A R T _ D A T E       C O U N T   *     - - - - - - - - -     - - - - - - - - - -   F R I D A Y                           5 2   M O N D A Y                           5 2   S A T U R D A Y                       5 3   S U N D A Y                           5 2   T H U R S D A Y                       5 2   T U E S D A Y                         5 2   W E D N E S D A Y                     5 2  MySQL and SQL Server Use the lead function to access the next row. The SQL Server version of DATEDIFF is used here:  MySQL users can exclude the first argument  “day”  and switch the order of the two remaining arguments:  Oracle Use the window function LEAD OVER to access the next HIREDATE relative to the current row, thus facilitating subtraction:  PostgreSQL  1   s e l e c t   x . * ,   2                 d a y s   x . n e x t _ h d     -   d a y s   x . h i r e d a t e     d i f f   3       f r o m       4   s e l e c t   e . d e p t n o ,   e . e n a m e ,   e . h i r e d a t e ,   5                 l e a d   h i r e d a t e   o v e r   o r d e r   b y   h i r e d a t e     n e x t _ h d   6       f r o m   e m p   e   7     w h e r e   e . d e p t n o   =   1 0   8                     x 1   s e l e c t   x . e n a m e ,   x . h i r e d a t e ,   x . n e x t _ h d ,   2                 d a t e d i f f   x . h i r e d a t e , x . n e x t _ h d , d a y     a s   d i f f   3       f r o m       4   s e l e c t   d e p t n o ,   e n a m e ,   h i r e d a t e ,   5                 l e a d   h i r e d a t e   o v e r   o r d e r   b y   h i r e d a t e     a s   n e x t _ h d   6       f r o m   e m p   e   7                     x   8     w h e r e   e . d e p t n o = 1 0 2                   d a t e d i f f   x . n e x t _ h d ,   x . h i r e d a t e     d i f f 1   s e l e c t   e n a m e ,   h i r e d a t e ,   n e x t _ h d ,   2                 n e x t _ h d   -   h i r e d a t e   d i f f   3       f r o m       4   s e l e c t   d e p t n o ,   e n a m e ,   h i r e d a t e ,   5                 l e a d   h i r e d a t e   o v e r   o r d e r   b y   h i r e d a t e     n e x t _ h d   6       f r o m   e m p   7                     8     w h e r e   d e p t n o = 1 0  Use a scalar subquery to find the next HIREDATE relative to the current HIREDATE. Then use simple subtraction to find the difference in days:  Discussion Despite the differences in syntax, the approach is the same for all these solutions: use the window function LEAD and then find the difference in days between the two using the technique described in Recipe 8.2. The ability to access rows around your current row without additional joins provides for more readable and efficient code. When working with window functions, keep in mind that they are evaluated after the WHERE clause, hence the need for an inline view in the solution. If you were to move the filter on DEPTNO into the inline view, the results would change  only the HIREDATEs from DEPTNO 10 would be considered . One important note to mention about Oracle’s LEAD and LAG functions is their behavior in the presence of duplicates. In the preface we mention that these recipes are not coded “defensively” because there are too many conditions that one can’t possibly foresee that can break code. Or, even if one can foresee every problem, sometimes the resulting SQL becomes unreadable. So in most cases, the goal of a solution is to introduce a technique: one that you can use in your production system, but that must be tested and many times tweaked to work for your particular data. In this case, though, there is a situation that we will discuss simply because the workaround may not be all that obvious, particularly for those coming from non-Oracle systems. In this example there are no duplicate HIREDATEs in table EMP, but it is certainly possible  and probably likely  that there are duplicate date values in your tables. Consider the employees in DEPTNO 10 and their HIREDATEs:  1   s e l e c t   x . * ,   2                 x . n e x t _ h d   -   x . h i r e d a t e   a s   d i f f   3       f r o m       4   s e l e c t   e . d e p t n o ,   e . e n a m e ,   e . h i r e d a t e ,   5                 l e a d   h i r e d a t e   o v e r   o r d e r   b y   h i r e d a t e     a s   n e x t _ h d   7       f r o m   e m p   e   8     w h e r e   e . d e p t n o   =   1 0   9                     x  For the sake of this example, let’s insert four duplicates such that there are five employees  including KING  hired on November 17:  Now there are multiple employees in DEPTNO 10 hired on the same day. If you try to use the proposed solution  moving the filter into the inline view  s e l e c t   e n a m e ,   h i r e d a t e       f r o m   e m p     w h e r e   d e p t n o = 1 0     o r d e r   b y   2     E N A M E     H I R E D A T E   - - - - - -   - - - - - - - - - - -   C L A R K     0 9 - J U N - 2 0 0 6   K I N G       1 7 - N O V - 2 0 0 6   M I L L E R   2 3 - J A N - 2 0 0 7 i n s e r t   i n t o   e m p     e m p n o , e n a m e , d e p t n o , h i r e d a t e     v a l u e s     1 , ' a n t ' , 1 0 , t o _ d a t e   ' 1 7 - N O V - 2 0 0 6 '         i n s e r t   i n t o   e m p     e m p n o , e n a m e , d e p t n o , h i r e d a t e     v a l u e s     2 , ' j o e ' , 1 0 , t o _ d a t e   ' 1 7 - N O V - 2 0 0 6 '         i n s e r t   i n t o   e m p     e m p n o , e n a m e , d e p t n o , h i r e d a t e     v a l u e s     3 , ' j i m ' , 1 0 , t o _ d a t e   ' 1 7 - N O V - 2 0 0 6 '         i n s e r t   i n t o   e m p     e m p n o , e n a m e , d e p t n o , h i r e d a t e     v a l u e s     4 , ' c h o i ' , 1 0 , t o _ d a t e   ' 1 7 - N O V - 2 0 0 6 '         s e l e c t   e n a m e ,   h i r e d a t e       f r o m   e m p     w h e r e   d e p t n o = 1 0     o r d e r   b y   2     E N A M E     H I R E D A T E   - - - - - -   - - - - - - - - - - -   C L A R K     0 9 - J U N - 2 0 0 6   a n t         1 7 - N O V - 2 0 0 6   j o e         1 7 - N O V - 2 0 0 6   K I N G       1 7 - N O V - 2 0 0 6   j i m         1 7 - N O V - 2 0 0 6   c h o i       1 7 - N O V - 2 0 0 7   M I L L E R   2 3 - J A N - 2 0 0 7  so you only are concerned with employees in DEPTNO 10 and their HIREDATEs  on this result set, you get the following output:  Looking at the values of DIFF for four of the five employees hired on the same day, you can see that the value is zero. This is not correct. All employees hired on the same day should have their dates evaluated against the HIREDATE of the next date on which an employee was hired  i.e., all employees hired on November 17 should be evaluated against MILLER’s HIREDATE . The problem here is that the LEAD function orders the rows by HIREDATE but does not skip duplicates. So, for example, when employee ANT’s HIREDATE is evaluated against employee JOE’s HIREDATE, the difference is zero, hence a DIFF value of zero for ANT. Fortunately, Oracle has provided an easy workaround for situations like this one. When invoking the LEAD function, you can pass an argument to LEAD to specify exactly where the future row is  i.e., is it the next row, 10 rows later, etc. . So, looking at employee ANT, instead of looking ahead one row, you need to look ahead five rows  you want to jump over all the other duplicates , because that’s where MILLER is. If you look at employee JOE, he is four rows from MILLER, JIM is three rows from MILLER, KING is two rows from MILLER, and pretty boy CHOI is one row from  s e l e c t   e n a m e ,   h i r e d a t e ,   n e x t _ h d ,                 n e x t _ h d   -   h i r e d a t e   d i f f       f r o m       s e l e c t   d e p t n o ,   e n a m e ,   h i r e d a t e ,                 l e a d   h i r e d a t e   o v e r   o r d e r   b y   h i r e d a t e     n e x t _ h d       f r o m   e m p     w h e r e   d e p t n o = 1 0                         E N A M E     H I R E D A T E         N E X T _ H D                       D I F F   - - - - - -   - - - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - - -   C L A R K     0 9 - J U N - 2 0 0 6   1 7 - N O V - 2 0 0 6                 1 6 1   a n t         1 7 - N O V - 2 0 0 6   1 7 - N O V - 2 0 0 6                     0   j o e         1 7 - N O V - 2 0 0 6   1 7 - N O V - 2 0 0 6                     0   K I N G       1 7 - N O V - 2 0 0 6   1 7 - N O V - 2 0 0 6                     0   j i m         1 7 - N O V - 2 0 0 6   1 7 - N O V - 2 0 0 6                     0   c h o i       1 7 - N O V - 2 0 0 6   2 3 - J A N - 2 0 0 7                   6 7   M I L L E R   2 3 - J A N - 2 0 0 7     n u l l                           n u l l    MILLER. To get the correct answer, simply pass the distance from each employee to MILLER as an argument to LEAD. The solution is shown here:  Now the results are correct. All the employees hired on the same day have their HIREDATEs evaluated against the next HIREDATE, not a HIREDATE that matches their own. If the workaround isn’t immediately obvious, simply break down the query. Start with the inline view:  s e l e c t   e n a m e ,   h i r e d a t e ,   n e x t _ h d ,                 n e x t _ h d   -   h i r e d a t e   d i f f       f r o m       s e l e c t   d e p t n o ,   e n a m e ,   h i r e d a t e ,                 l e a d   h i r e d a t e , c n t - r n + 1   o v e r   o r d e r   b y   h i r e d a t e     n e x t _ h d       f r o m       s e l e c t   d e p t n o , e n a m e , h i r e d a t e ,                 c o u n t   *   o v e r   p a r t i t i o n   b y   h i r e d a t e     c n t ,                 r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   h i r e d a t e   o r d e r   b y   e m p n o     r n       f r o m   e m p     w h e r e   d e p t n o = 1 0                                             E N A M E     H I R E D A T E         N E X T _ H D                       D I F F   - - - - - -   - - - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - - -   C L A R K     0 9 - J U N - 2 0 0 6   1 7 - N O V - 2 0 0 6                 1 6 1   a n t         1 7 - N O V - 2 0 0 6   2 3 - J A N - 2 0 0 7                   6 7   j o e         1 7 - N O V - 2 0 0 6   2 3 - J A N - 2 0 0 7                   6 7   j i m         1 7 - N O V - 2 0 0 6   2 3 - J A N - 2 0 0 7                   6 7   c h o i       1 7 - N O V - 2 0 0 6   2 3 - J A N - 2 0 0 7                   6 7   K I N G       1 7 - N O V - 2 0 0 6   2 3 - J A N - 2 0 0 7                   6 7   M I L L E R   2 3 - J A N - 2 0 0 7     n u l l                           n u l l   s e l e c t   d e p t n o , e n a m e , h i r e d a t e ,                 c o u n t   *   o v e r   p a r t i t i o n   b y   h i r e d a t e     c n t ,                 r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   h i r e d a t e   o r d e r   b y   e m p n o     r n       f r o m   e m p     w h e r e   d e p t n o = 1 0     D E P T N O   E N A M E     H I R E D A T E                       C N T                   R N   - - - - - -   - - - - - -   - - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -           1 0   C L A R K     0 9 - J U N - 2 0 0 6                     1                     1    The window function COUNT OVER counts the number of times each HIREDATE occurs and returns this value to each row. For the duplicate HIREDATEs, a value of 5 is returned for each row with that HIREDATE. The window function ROW_NUMBER OVER ranks each employee by EMPNO. The ranking is partitioned by HIREDATE, so unless there are duplicate HIREDATEs, each employee will have a rank of 1. At this point, all the duplicates have been counted and ranked, and the ranking can serve as the distance to the next HIREDATE  MILLER’s HIREDATE . You can see this by subtracting RN from CNT and adding 1 for each row when calling LEAD:  As you can see, by passing the appropriate distance to jump ahead to, the LEAD function performs the subtraction on the correct dates.          1 0   a n t         1 7 - N O V - 2 0 0 6                     5                     1           1 0   j o e         1 7 - N O V - 2 0 0 6                     5                     2           1 0   j i m         1 7 - N O V - 2 0 0 6                     5                     3           1 0   c h o i       1 7 - N O V - 2 0 0 6                     5                     4           1 0   K I N G       1 7 - N O V - 2 0 0 6                     5                     5           1 0   M I L L E R   2 3 - J A N - 2 0 0 7                     1                     1 s e l e c t   d e p t n o ,   e n a m e ,   h i r e d a t e ,                 c n t - r n + 1   d i s t a n c e _ t o _ m i l l e r ,                 l e a d   h i r e d a t e , c n t - r n + 1   o v e r   o r d e r   b y   h i r e d a t e     n e x t _ h d       f r o m       s e l e c t   d e p t n o , e n a m e , h i r e d a t e ,                 c o u n t   *   o v e r   p a r t i t i o n   b y   h i r e d a t e     c n t ,                 r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   h i r e d a t e   o r d e r   b y   e m p n o     r n       f r o m   e m p     w h e r e   d e p t n o = 1 0                         D E P T N O   E N A M E     H I R E D A T E         D I S T A N C E _ T O _ M I L L E R   N E X T _ H D   - - - - - -   - - - - - -   - - - - - - - - - - -   - - - - - - - - - - - - - - - - - -   - - - - - - - - - - -           1 0   C L A R K     0 9 - J U N - 2 0 0 6                                     1   1 7 - N O V - 2 0 0 6           1 0   a n t         1 7 - N O V - 2 0 0 6                                     5   2 3 - J A N - 2 0 0 7           1 0   j o e         1 7 - N O V - 2 0 0 6                                     4   2 3 - J A N - 2 0 0 7           1 0   j i m         1 7 - N O V - 2 0 0 6                                     3   2 3 - J A N - 2 0 0 7           1 0   c h o i       1 7 - N O V - 2 0 0 6                                     2   2 3 - J A N - 2 0 0 7           1 0   K I N G       1 7 - N O V - 2 0 0 6                                     1   2 3 - J A N - 2 0 0 7           1 0   M I L L E R   2 3 - J A N - 2 0 0 7                                     1     n u l l    8.8 Summing Up Dates are a common data type, but have their own quirks, as they have more structure than simple number data types. In relative terms, there is less standardization between vendors than in many other areas, but every implementation has a core group of functions that perform the same tasks even where the syntax is slightly different. Mastering this core group will ensure your success with dates.   Chapter 9. Date Manipulation  This chapter introduces recipes for searching and modifying dates. Queries involving dates are very common. Thus, you need to know how to think when working with dates, and you need to have a good understanding of the functions that your RDBMS platform provides for manipulating them. The recipes in this chapter form an important foundation for future work as you move on to more complex queries involving not only dates, but times, too. Before getting into the recipes, we want to reinforce the concept  mentioned in the preface  of using these solutions as guidelines to solving your specific problems. Try to think “big picture.” For example, if a recipe solves a problem for the current month, keep in mind that you may be able to use the recipe for any month  with minor modifications , not just the month used in the recipe. Again, these recipes are guidelines, the absolute final option. There’s no possible way a book can contain an answer for all your problems, but if you understand what is presented here, modifying these solutions to fit your needs is trivial. Also consider alternative versions of these solutions. For instance, if the solution uses one particular function provided by your RDBMS, it is worth the time and effort to find out if there is an alternative—maybe one that is more or less efficient than what is presented here. Knowing your options will make you a better SQL programmer.  The recipes presented in this chapter use simple date data types. If you are using more complex date data types, you will need to adjust the solutions accordingly.  TIP  9.1 Determining Whether a Year Is a Leap Year   Problem You want to determine whether the current year is a leap year.  Solution If you’ve worked on SQL for some time, there’s no doubt that you’ve come across several techniques for solving this problem. Just about all the solutions we’ve encountered work well, but the one presented in this recipe is probably the simplest. This solution simply checks the last day of February; if it is the 29th, then the current year is a leap year.  DB2 Use the recursive WITH clause to return each day in February. Use the aggregate function MAX to determine the last day in February:  Oracle Use the function LAST_DAY to find the last day in February:    1       w i t h   x     d y , m t h       2           a s         3   s e l e c t   d y ,   m o n t h   d y       4       f r o m         5   s e l e c t     c u r r e n t _ d a t e   -     6                     d a y o f y e a r   c u r r e n t _ d a t e     d a y s   + 1   d a y s       7                       + 1   m o n t h s   a s   d y     8       f r o m   t 1     9                     t m p 1   1 0     u n i o n   a l l   1 1   s e l e c t   d y + 1   d a y s ,   m t h   1 2       f r o m   x   1 3     w h e r e   m o n t h   d y + 1   d a y     =   m t h   1 4       1 5   s e l e c t   m a x   d a y   d y       1 6       f r o m   x 1   s e l e c t   t o _ c h a r     2                     l a s t _ d a y   a d d _ m o n t h s   t r u n c   s y s d a t e , ' y '   , 1     ,   3                   ' D D '     4       f r o m   t 1  PostgreSQL Use the function GENERATE_SERIES to return each day in February, and then use the aggregate function MAX to find the last day in February:  MySQL Use the function LAST_DAY to find the last day in February:  SQL Server Use the recursive WITH clause to return each day in February. Use the aggregate function MAX to determine the last day in February:    1   s e l e c t   m a x   t o _ c h a r   t m p 2 . d y + x . i d , ' D D '       a s   d y     2       f r o m         3   s e l e c t   d y ,   t o _ c h a r   d y , ' M M '     a s   m t h     4       f r o m         5   s e l e c t   c a s t   c a s t       6                           d a t e _ t r u n c   ' y e a r ' , c u r r e n t _ d a t e     a s   d a t e       7                                                 +   i n t e r v a l   ' 1   m o n t h '   a s   d a t e     a s   d y     8       f r o m   t 1     9                     t m p 1   1 0                     t m p 2 ,   g e n e r a t e _ s e r i e s     0 , 2 9     x   i d     1 1     w h e r e   t o _ c h a r   t m p 2 . d y + x . i d , ' M M '     =   t m p 2 . m t h 1   s e l e c t   d a y     2                 l a s t _ d a y     3                 d a t e _ a d d     4                 d a t e _ a d d     5                 d a t e _ a d d   c u r r e n t _ d a t e ,   6                                   i n t e r v a l   - d a y o f y e a r   c u r r e n t _ d a t e     d a y   ,   7                                   i n t e r v a l   1   d a y   ,   8                                   i n t e r v a l   1   m o n t h         d y   9       f r o m   t 1   s e l e c t   c o a l e s c e                       d a y           c a s t   c o n c a t           y e a r   g e t d a t e       , ' - 0 2 - 2 9 '             a s   d a t e               , 2 8   ;  Discussion  DB2 The inline view TMP1 in the recursive view X returns the first day in February by:  1. Starting with the current date 2. Using DAYOFYEAR to determine the number of days into the  current year that the current date represents  3. Subtracting that number of days from the current date to get  December 31 of the prior year and then adding one to get to January 1 of the current year  4. Adding one month to get to February 1  The result of all this math is shown here:  The next step is to return the month of the date returned by inline view TMP1 by using the MONTH function:    s e l e c t     c u r r e n t _ d a t e                         d a y o f y e a r   c u r r e n t _ d a t e     d a y s   + 1   d a y s     + 1   m o n t h s   a s   d y         f r o m   t 1     D Y   - - - - - - - - - - -   0 1 - F E B - 2 0 0 5 s e l e c t   d y ,   m o n t h   d y     a s   m t h       f r o m       s e l e c t     c u r r e n t _ d a t e                       d a y o f y e a r   c u r r e n t _ d a t e     d a y s   + 1   d a y s     + 1   m o n t h s   a s   d y       f r o m   t 1                     t m p 1     D Y                     M T H   - - - - - - - - - - -   - - -   0 1 - F E B - 2 0 0 5       2  The results presented thus far provide the start point for the recursive operation that generates each day in February. To return each day in February, repeatedly add one day to DY until you are no longer in the month of February. A portion of the results of the WITH operation is shown here:  The final step is to use the MAX function on the DY column to return the last day in February; if it is the 29th, you are in a leap year.  Oracle The first step is to find the beginning of the year using the TRUNC function:      w i t h   x     d y , m t h             a s       s e l e c t   d y ,   m o n t h   d y         f r o m       s e l e c t     c u r r e n t _ d a t e   -                     d a y o f y e a r   c u r r e n t _ d a t e     d a y s   + 1   d a y s     + 1   m o n t h s   a s   d y       f r o m   t 1                     t m p 1     u n i o n   a l l     s e l e c t   d y + 1   d a y s ,   m t h         f r o m   x       w h e r e   m o n t h   d y + 1   d a y     =   m t h           s e l e c t   d y , m t h         f r o m   x     D Y                     M T H   - - - - - - - - - - -   - - -   0 1 - F E B - 2 0 0 5       2   …   1 0 - F E B - 2 0 0 5       2   …   2 8 - F E B - 2 0 0 5       2 s e l e c t   t r u n c   s y s d a t e , ' y '         f r o m   t 1     D Y    Because the first day of the year is January 1st, the next step is to add one month to get to February 1st:  The next step is to use the LAST_DAY function to find the last day in February:  The final step  which is optional  is to use TO_CHAR to return either 28 or 29.  PostgreSQL The first step is to examine the results returned by inline view TMP1. Use the DATE_TRUNC function to find the beginning of the current year and cast that result as a DATE:  - - - - - - - - - - -   0 1 - J A N - 2 0 0 5 s e l e c t   a d d _ m o n t h s   t r u n c   s y s d a t e , ' y '   , 1     d y       f r o m   t 1     D Y   - - - - - - - - - - -   0 1 - F E B - 2 0 0 5 s e l e c t   l a s t _ d a y   a d d _ m o n t h s   t r u n c   s y s d a t e , ' y '   , 1       d y       f r o m   t 1     D Y   - - - - - - - - - - -   2 8 - F E B - 2 0 0 5 s e l e c t   c a s t   d a t e _ t r u n c   ' y e a r ' , c u r r e n t _ d a t e     a s   d a t e     a s   d y       f r o m   t 1       D Y   - - - - - - - - - - -   0 1 - J A N - 2 0 0 5  The next step is to add one month to the first day of the current year to get the first day in February, casting the result as a date:  Next, return DY from inline view TMP1 along with the numeric month of DY. Return the numeric month by using the TO_CHAR function:  The results shown thus far comprise the result set of inline view TMP2. Your next step is to use the extremely useful function GENERATE_SERIES to return 29 rows  values 1 through 29 . Every row returned by GENERATE_SERIES  aliased X  is added to DY from inline view TMP2. Partial results are shown here:  s e l e c t   c a s t   c a s t                             d a t e _ t r u n c   ' y e a r ' , c u r r e n t _ d a t e     a s   d a t e                                                   +   i n t e r v a l   ' 1   m o n t h '   a s   d a t e     a s   d y       f r o m   t 1     D Y   - - - - - - - - - - -   0 1 - F E B - 2 0 0 5 s e l e c t   d y ,   t o _ c h a r   d y , ' M M '     a s   m t h         f r o m         s e l e c t   c a s t   c a s t                               d a t e _ t r u n c   ' y e a r ' , c u r r e n t _ d a t e     a s   d a t e                                                     +   i n t e r v a l   ' 1   m o n t h '   a s   d a t e     a s   d y         f r o m   t 1                       t m p 1     D Y                     M T H   - - - - - - - - - - -   - - -   0 1 - F E B - 2 0 0 5       2 s e l e c t   t m p 2 . d y + x . i d   a s   d y ,   t m p 2 . m t h       f r o m       s e l e c t   d y ,   t o _ c h a r   d y , ' M M '     a s   m t h       f r o m       s e l e c t   c a s t   c a s t                             d a t e _ t r u n c   ' y e a r ' , c u r r e n t _ d a t e     a s   d a t e                                                   +   i n t e r v a l   ' 1   m o n t h '   a s   d a t e     a s   d y       f r o m   t 1                     t m p 1    The final step is to use the MAX function to return the last day in February. The function TO_CHAR is applied to that value and will return either 28 or 29.  MySQL The first step is to find the first day of the current year by subtracting from the current date the number of days it is into the year and then adding one day. Do all of this with the DATE_ADD function:  Then add one month again using the DATE_ADD function:                    t m p 2 ,   g e n e r a t e _ s e r i e s     0 , 2 9     x   i d       w h e r e   t o _ c h a r   t m p 2 . d y + x . i d , ' M M '     =   t m p 2 . m t h     D Y                     M T H   - - - - - - - - - - -   - - -   0 1 - F E B - 2 0 0 5     0 2   …   1 0 - F E B - 2 0 0 5     0 2   …   2 8 - F E B - 2 0 0 5     0 2 s e l e c t   d a t e _ a d d                   d a t e _ a d d   c u r r e n t _ d a t e ,                                   i n t e r v a l   - d a y o f y e a r   c u r r e n t _ d a t e     d a y   ,                                   i n t e r v a l   1   d a y     d y       f r o m   t 1     D Y   - - - - - - - - - - -   0 1 - J A N - 2 0 0 5 s e l e c t   d a t e _ a d d                   d a t e _ a d d                   d a t e _ a d d   c u r r e n t _ d a t e ,                                   i n t e r v a l   - d a y o f y e a r   c u r r e n t _ d a t e     d a y   ,                                   i n t e r v a l   1   d a y   ,                                   i n t e r v a l   1   m o n t h     d y       f r o m   t 1     D Y    Now that you’ve made it to February, use the LAST_DAY function to find the last day of the month:  The final step  which is optional  is to use the DAY function to return either a 28 or 29.  SQL Server We can create a new date in most RDMSs by creating a string in a recognized date format and using CAST to change format. We can therefore use the current year by retrieving the year from the current date. In SQL Server, this is done by applying YEAR to GET_DATE:  This will return the year as an integer. We can then create 29th of February by using CONCAT and CAST:  However, this won’t be a real date if the current year isn’t a leap year. For example, there is no date 2019-02-29. Hence, if we try to use an operator like DAY to find any of its parts, it will return NULL. Therefore, use  - - - - - - - - - - -   0 1 - F E B - 2 0 0 5 s e l e c t   l a s t _ d a y                   d a t e _ a d d                   d a t e _ a d d                   d a t e _ a d d   c u r r e n t _ d a t e ,                                   i n t e r v a l   - d a y o f y e a r   c u r r e n t _ d a t e     d a y   ,                                   i n t e r v a l   1   d a y   ,                                   i n t e r v a l   1   m o n t h       d y       f r o m   t 1     D Y   - - - - - - - - - - -   2 8 - F E B - 2 0 0 5 s e l e c t   Y E A R   G E T D A T E       ; s e l e c t   c a s t   c o n c a t                   y e a r   g e t d a t e       , ' - 0 2 - 2 9 '   ;  COALESCE and DAY to determine whether there is a 29th day in the month.  9.2 Determining the Number of Days in a Year  Problem You want to count the number of days in the current year.  Solution The number of days in the current year is the difference between the first day of the next year and the first day of the current year  in days . For each solution the steps are:  1. Find the first day of the current year. 2. Add one year to that date  to get the first day of the next year . 3. Subtract the current year from the result of Step 2.  The solutions differ only in the built-in functions that you use to perform these steps.  DB2 Use the function DAYOFYEAR to help find the first day of the current year, and use DAYS to find the number of days in the current year:  Oracle  1   s e l e c t   d a y s     c u r r _ y e a r   +   1   y e a r       -   d a y s   c u r r _ y e a r     2       f r o m       3   s e l e c t     c u r r e n t _ d a t e   -   4                   d a y o f y e a r   c u r r e n t _ d a t e     d a y   +   5                     1   d a y     c u r r _ y e a r   6       f r o m   t 1   7                     x  Use the function TRUNC to find the beginning of the current year, and use ADD_ MONTHS to then find the beginning of next year:  PostgreSQL Use the function DATE_TRUNC to find the beginning of the current year. Then use interval arithmetic to determine the beginning of next year:  MySQL Use ADDDATE to help find the beginning of the current year. Use DATEDIFF and interval arithmetic to determine the number of days in the year:  SQL Server Use the function DATEADD to find the first day of the current year. Use DATEDIFF to return the number of days in the current year:  Discussion  1   s e l e c t a d d _ m o n t h s   t r u n c   s y s d a t e , ' y '   , 1 2     -   t r u n c   s y s d a t e , ' y '     2       f r o m   d u a l 1   s e l e c t   c a s t     c u r r _ y e a r   +   i n t e r v a l   ' 1   y e a r '     a s   d a t e     -   c u r r _ y e a r   2       f r o m       3   s e l e c t   c a s t   d a t e _ t r u n c   ' y e a r ' , c u r r e n t _ d a t e     a s   d a t e     a s   c u r r _ y e a r   4       f r o m   t 1   5                     x 1   s e l e c t   d a t e d i f f     c u r r _ y e a r   +   i n t e r v a l   1   y e a r   , c u r r _ y e a r     2       f r o m       3   s e l e c t   a d d d a t e   c u r r e n t _ d a t e , - d a y o f y e a r   c u r r e n t _ d a t e   + 1     c u r r _ y e a r   4       f r o m   t 1   5                     x 1   s e l e c t   d a t e d i f f   d , c u r r _ y e a r , d a t e a d d   y y , 1 , c u r r _ y e a r       2       f r o m       3   s e l e c t   d a t e a d d   d , - d a t e p a r t   d y , g e t d a t e       + 1 , g e t d a t e         c u r r _ y e a r   4       f r o m   t 1   5                     x  DB2 The first step is to find the first day of the current year. Use DAYOFYEAR to determine how many days you are into the current year. Subtract that value from the current date to get the last day of last year, and then add 1:  Now that you have the first day of the current year, just add one year to it; this gives you the first day of next year. Then subtract the beginning of the current year from the beginning of the next year.  Oracle The first step is to find the first day of the current year, which you can easily do by invoking the built-in TRUNC function and passing Y as the second argument  thereby truncating the date to the beginning of the year :  Then add one year to arrive at the first day of the next year. Finally, subtract the two dates to find the number of days in the current year.  PostgreSQL Begin by finding the first day of the current year. To do that, invoke the DATE_ TRUNC function as follows:  s e l e c t     c u r r e n t _ d a t e                   d a y o f y e a r   c u r r e n t _ d a t e     d a y   +                     1   d a y     c u r r _ y e a r       f r o m   t 1     C U R R _ Y E A R   - - - - - - - - - - -   0 1 - J A N - 2 0 0 5 s e l e c t   s e l e c t   t r u n c   s y s d a t e , ' y '     c u r r _ y e a r       f r o m   d u a l     C U R R _ Y E A R   - - - - - - - - - - -   0 1 - J A N - 2 0 0 5  You can then easily add a year to compute the first day of next year. Then all you need to do is to subtract the two dates. Be sure to subtract the earlier date from the later date. The result will be the number of days in the current year.  MySQL Your first step is to find the first day of the current year. Use DAYOFYEAR to find how many days you are into the current year. Subtract that value from the current date, and add one:  Now that you have the first day of the current year, your next step is to add one year to it to get the first day of next year. Then subtract the beginning of the current year from the beginning of the next year. The result is the number of days in the current year.  SQL Server Your first step is to find the first day of the current year. Use DATEADD and DATEPART to subtract from the current date the number of days into the year the current date is, and add 1:  s e l e c t   c a s t   d a t e _ t r u n c   ' y e a r ' , c u r r e n t _ d a t e     a s   d a t e     a s   c u r r _ y e a r       f r o m   t 1     C U R R _ Y E A R   - - - - - - - - - - -   0 1 - J A N - 2 0 0 5 s e l e c t   a d d d a t e   c u r r e n t _ d a t e , - d a y o f y e a r   c u r r e n t _ d a t e   + 1     c u r r _ y e a r       f r o m   t 1     C U R R _ Y E A R   - - - - - - - - - - -   0 1 - J A N - 2 0 0 5 s e l e c t   d a t e a d d   d , - d a t e p a r t   d y , g e t d a t e       + 1 , g e t d a t e         c u r r _ y e a r       f r o m   t 1     C U R R _ Y E A R    Now that you have the first day of the current year, your next step is to add one year to it to get the first day of the next year. Then subtract the beginning of the current year from the beginning of the next year. The result is the number of days in the current year.  9.3 Extracting Units of Time from a Date  Problem You want to break the current date down into six parts: day, month, year, second, minute, and hour. You want the results to be returned as numbers.  Solution Use of the current date is arbitrary. Feel free to use this recipe with other dates. Most vendors have now adopted the ANSI standard function for extracting parts of dates, EXTRACT, although SQL Server is an exception. They also retain their own legacy methods.  DB2 DB2 implements a set of built-in functions that make it easy for you to extract portions of a date. The function names HOUR, MINUTE, SECOND, DAY, MONTH, and YEAR conveniently correspond to the units of time you can return: if you want the day, use DAY; hour, use HOUR; etc. For example:  - - - - - - - - - - -   0 1 - J A N - 2 0 0 5   1   s e l e c t         h o u r     c u r r e n t _ t i m e s t a m p       h r ,     2                   m i n u t e     c u r r e n t _ t i m e s t a m p       m i n ,     3                   s e c o n d     c u r r e n t _ t i m e s t a m p       s e c ,     4                         d a y     c u r r e n t _ t i m e s t a m p       d y ,     5                     m o n t h     c u r r e n t _ t i m e s t a m p       m t h ,     6                         y e a r     c u r r e n t _ t i m e s t a m p       y r     7       f r o m   t 1      Oracle Use functions TO_CHAR and TO_NUMBER to return specific units of time from a date:  PostgreSQL Use functions TO_CHAR and TO_NUMBER to return specific units of time from a date:  s e l e c t                   e x t r a c t   h o u r   f r o m   c u r r e n t _ t i m e s t a m p                 ,   e x t r a c t   m i n u t e   f r o m   c u r r e n t _ t i m e s t a m p               ,   e x t r a c t   s e c o n d   f r o m   c u r r e n t _ t i m e s t a m p                 ,   e x t r a c t   d a y   f r o m   c u r r e n t _ t i m e s t a m p                 ,   e x t r a c t   m o n t h   f r o m   c u r r e n t _ t i m e s t a m p                 ,   e x t r a c t   y e a r   f r o m   c u r r e n t _ t i m e s t a m p             H R       M I N       S E C         D Y       M T H         Y R     - - - -   - - - - -   - - - - -   - - - - -   - - - - -   - - - - -         2 0         2 8         3 6         1 5           6     2 0 0 5 1     s e l e c t   t o _ n u m b e r   t o _ c h a r   s y s d a t e , ' h h 2 4 '       h o u r ,   2                   t o _ n u m b e r   t o _ c h a r   s y s d a t e , ' m i '       m i n ,   3                   t o _ n u m b e r   t o _ c h a r   s y s d a t e , ' s s '       s e c ,   4                   t o _ n u m b e r   t o _ c h a r   s y s d a t e , ' d d '       d a y ,   5                   t o _ n u m b e r   t o _ c h a r   s y s d a t e , ' m m '       m t h ,   6                   t o _ n u m b e r   t o _ c h a r   s y s d a t e , ' y y y y '       y e a r   7       f r o m   d u a l         H O U R       M I N       S E C       D A Y       M T H     Y E A R       - - - -   - - - - -   - - - - -   - - - - -   - - - - -   - - - - -           2 0         2 8         3 6         1 5           6     2 0 0 5 1   s e l e c t   t o _ n u m b e r   t o _ c h a r   c u r r e n t _ t i m e s t a m p , ' h h 2 4 '   , ' 9 9 '     a s   h r ,   2                 t o _ n u m b e r   t o _ c h a r   c u r r e n t _ t i m e s t a m p , ' m i '   , ' 9 9 '     a s   m i n ,   3                 t o _ n u m b e r   t o _ c h a r   c u r r e n t _ t i m e s t a m p , ' s s '   , ' 9 9 '     a s   s e c ,   4                 t o _ n u m b e r   t o _ c h a r   c u r r e n t _ t i m e s t a m p , ' d d '   , ' 9 9 '     a s   d a y ,   5                 t o _ n u m b e r   t o _ c h a r   c u r r e n t _ t i m e s t a m p , ' m m '   , ' 9 9 '     a s   m t h ,   6                 t o _ n u m b e r   t o _ c h a r   c u r r e n t _ t i m e s t a m p , ' y y y y '   , ' 9 9 9 9 '     a s   y r   7       f r o m   t 1           H R       M I N       S E C       D A Y       M T H         Y R     - - - -   - - - - -   - - - - -   - - - - -   - - - - -   - - - - -     2 0             2 8         3 6         1 5           6     2 0 0 5  MySQL Use the DATE_FORMAT function to return specific units of time from a date:  SQL Server Use the function DATEPART to return specific units of time from a date:  Discussion There’s nothing fancy in these solutions; just take advantage of what you’re already paying for. Take the time to learn the date functions available to you. This recipe only scratches the surface of the functions presented in each solution. You’ll find that each of the functions takes many more arguments and can return more information than what this recipe provides you.  1   s e l e c t   d a t e _ f o r m a t   c u r r e n t _ t i m e s t a m p , ' % k '     h r ,   2                 d a t e _ f o r m a t   c u r r e n t _ t i m e s t a m p , ' % i '     m i n ,   3                 d a t e _ f o r m a t   c u r r e n t _ t i m e s t a m p , ' % s '     s e c ,   4                 d a t e _ f o r m a t   c u r r e n t _ t i m e s t a m p , ' % d '     d y ,   5                 d a t e _ f o r m a t   c u r r e n t _ t i m e s t a m p , ' % m '     m o n ,   6                 d a t e _ f o r m a t   c u r r e n t _ t i m e s t a m p , ' % Y '     y r   7       f r o m   t 1         H R       M I N       S E C       D A Y       M T H         Y R   - - - -   - - - - -   - - - - -   - - - - -   - - - - -   - - - - -       2 0         2 8         3 6         1 5           6     2 0 0 5 1   s e l e c t   d a t e p a r t     h o u r ,   g e t d a t e         h r ,   2                 d a t e p a r t     m i n u t e , g e t d a t e         m i n ,   3                 d a t e p a r t     s e c o n d , g e t d a t e         s e c ,   4                 d a t e p a r t     d a y ,   g e t d a t e         d y ,   5                 d a t e p a r t     m o n t h ,   g e t d a t e         m o n ,   6                 d a t e p a r t     y e a r ,   g e t d a t e         y r   7       f r o m   t 1         H R       M I N       S E C       D A Y       M T H         Y R   - - - -   - - - - -   - - - - -   - - - - -   - - - - -   - - - - -       2 0         2 8         3 6         1 5           6     2 0 0 5  9.4 Determining the First and Last Days of a Month  Problem You want to determine the first and last days for the current month.  Solution The solutions presented here are for finding first and last days for the current month. Using the current month is arbitrary. With a bit of adjustment, you can make the solutions work for any month.  DB2 Use the DAY function to return the number of days into the current month the current date represents. Subtract this value from the current date, and then add one to get the first of the month. To get the last day of the month, add one month to the current date, and then subtract from it the value returned by the DAY function as applied to the current date:  Oracle Use the function TRUNC to find the first of the month, and use the function LAST_DAY to find the last day of the month:  1   s e l e c t     d a t e   c u r r e n t _ d a t e     -   d a y   d a t e   c u r r e n t _ d a t e       d a y   +   1   d a y     f i r s t d a y ,   2                   d a t e   c u r r e n t _ d a t e   + 1   m o n t h   3                   -   d a y   d a t e   c u r r e n t _ d a t e   + 1   m o n t h     d a y     l a s t d a y   4       f r o m   t 1 1   s e l e c t   t r u n c   s y s d a t e , ' m m '     f i r s t d a y ,   2                 l a s t _ d a y   s y s d a t e     l a s t d a y   3       f r o m   d u a l  Using TRUNC as described here will result in the loss of any time-of-day component, whereas LAST_DAY will preserve the time of day.  TIP  PostgreSQL Use the DATE_TRUNC function to truncate the current date to the first of the current month. Once you have the first day of the month, add one month and subtract one day to find the end of the current month:  MySQL Use the DATE_ADD and DAY functions to find the number of days into the month the current date is. Then subtract that value from the current date and add one to find the first of the month. To find the last day of the current month, use the LAST_DAY function:  SQL Server Use the DATEADD and DAY functions to find the number of days into the month represented by the current date. Then subtract that value from the current date and add one to find the first of the month. To get the last day of the month, add one month to the current date, and then subtract from that result the value returned by the DAY function applied to the current date, again using the functions DAY and DATEADD:    1   s e l e c t   f i r s t d a y ,     2                 c a s t   f i r s t d a y   +   i n t e r v a l   ' 1   m o n t h '     3                                             -   i n t e r v a l   ' 1   d a y '   a s   d a t e     a s   l a s t d a y     4       f r o m         5   s e l e c t   c a s t   d a t e _ t r u n c   ' m o n t h ' , c u r r e n t _ d a t e     a s   d a t e     a s   f i r s t d a y     6       f r o m   t 1     7                     x 1   s e l e c t   d a t e _ a d d   c u r r e n t _ d a t e ,   2                                   i n t e r v a l   - d a y   c u r r e n t _ d a t e   + 1   d a y     f i r s t d a y ,   3                 l a s t _ d a y   c u r r e n t _ d a t e     l a s t d a y   4       f r o m   t 1  Discussion  DB2 To find the first day of the month, simply find the numeric value of the current day of the month, and then subtract this from the current date. For example, if the date is March 14th, the numeric day value is 14. Subtracting 14 days from March 14th gives you the last day of the month in February. From there, simply add one day to get to the first of the current month. The technique to get the last day of the month is similar to that of the first: subtract the numeric day of the month from the current date to get the last day of the prior month. Since we want the last day of the current month  not the last day of the prior month , we need to add one month to the current date.  Oracle To find the first day of the current month, use the TRUNC function with “mm” as the second argument to “truncate” the current date down to the first of the month. To find the last day of the current month, simply use the LAST_DAY function.  PostgreSQL To find the first day of the current month, use the DATE_TRUNC function with “month” as the second argument to “truncate” the current date down to the first of the month. To find the last day of the current month, add one month to the first day of the month, and then subtract one day.  MySQL To find the first day of the month, use the DAY function. The DAY function returns the day of the month for the date passed. If you subtract the value  1   s e l e c t   d a t e a d d   d a y , - d a y   g e t d a t e       + 1 , g e t d a t e         f i r s t d a y ,   2                 d a t e a d d   d a y ,   3                                 - d a y   d a t e a d d   m o n t h , 1 , g e t d a t e         ,   4                                 d a t e a d d   m o n t h , 1 , g e t d a t e           l a s t d a y   5       f r o m   t 1  returned by DAY CURRENT_DATE  from the current date, you get the last day of the prior month; add one day to get the first day of the current month. To find the last day of the current month, simply use the LAST_DAY function.  SQL Server To find the first day of the month, use the DAY function. The DAY function conveniently returns the day of the month for the date passed. If you subtract the value returned by DAY GETDATE    from the current date, you get the last day of the prior month; add one day to get the first day of the current month. To find the last day of the current month, use the DATEADD function. Add one month to the current date, then subtract from it the value returned by DAY GETDATE    to get the last day of the current month. Add one month to the current date, and then subtract from it the value returned by DAY DATEADD MONTH,1,GETDATE     to get the last day of the current month.  9.5 Determining All Dates for a Particular Weekday Throughout a Year  Problem You want to find all the dates in a year that correspond to a given day of the week. For example, you may want to generate a list of Fridays for the current year.  Solution Regardless of vendor, the key to the solution is to return each day for the current year and keep only those dates corresponding to the day of the week that you care about. The solution examples retain all the Fridays.  DB2   Use the recursive WITH clause to return each day in the current year. Then use the function DAYNAME to keep only Fridays:  Oracle Use the recursive CONNECT BY clause to return each day in the current year. Then use the function TO_CHAR to keep only Fridays:  PostgreSQL Use a recursive CTE to generate every day of the year, and filter out days that aren’t Fridays. This version makes use of the ANSI standard EXTRACT, so it will run on a wide variety of RDBMs:    1       w i t h   x     d y , y r       2           a s         3   s e l e c t   d y ,   y e a r   d y     y r     4       f r o m         5   s e l e c t     c u r r e n t _ d a t e   -     6                     d a y o f y e a r   c u r r e n t _ d a t e     d a y s   + 1   d a y s     a s   d y     7       f r o m   t 1     8                     t m p 1     9     u n i o n   a l l     1 0   s e l e c t   d y + 1   d a y s ,   y r     1 1       f r o m   x     1 2     w h e r e   y e a r   d y   + 1   d a y     =   y r     1 3         1 4   s e l e c t   d y     1 5       f r o m   x     1 6     w h e r e   d a y n a m e   d y     =   ' F r i d a y ' 1       w i t h   x   2           a s       3   s e l e c t   t r u n c   s y s d a t e , ' y '   + l e v e l - 1   d y   4       f r o m   t 1   5       c o n n e c t   b y   l e v e l   < =   6             a d d _ m o n t h s   t r u n c   s y s d a t e , ' y '   , 1 2   - t r u n c   s y s d a t e , ' y '     7       8   s e l e c t   *   9       f r o m   x   1 0     w h e r e   t o _ c h a r     d y ,   ' d y '     =   ' f r i '  MySQL Use a recursive CTE to find all the days in the year. Then filter all days but Fridays:  SQL Server Use the recursive WITH clause to return each day in the current year. Then use the function DAYNAME to keep only Fridays:  1       w i t h   r e c u r s i v e   c a l     d y     2       a s       3       s e l e c t   c u r r e n t _ d a t e   4         -   c a s t   5             e x t r a c t   d o y   f r o m   c u r r e n t _ d a t e     a s   i n t e g e r     6         - 1     7         u n i o n   a l l   8         s e l e c t   d y + 1   9         f r o m   c a l   1 0       w h e r e   e x t r a c t   y e a r   f r o m   d y   = e x t r a c t   y e a r   f r o m     d y + 1       1 1               1 2   1 3       s e l e c t   d y , e x t r a c t   d o w   f r o m   d y     f r o m   c a l   1 4       w h e r e   c a s t   e x t r a c t   d o w   f r o m   d y     a s   i n t e g e r     =   6 1       w i t h   r e c u r s i v e   c a l     d y , y r     2       a s   3               4           s e l e c t   d y ,   e x t r a c t   y e a r   f r o m   d y     a s   y r   5       f r o m   6             s e l e c t   a d d d a t e   7                             a d d d a t e   c u r r e n t _ d a t e ,   i n t e r v a l   -   d a y o f y e a r   c u r r e n t _ d a t e     8       d a y   ,   i n t e r v a l   1   d a y     a s   d y     a s   t m p 1   9       u n i o n   a l l   1 0           s e l e c t   d a t e _ a d d   d y ,   i n t e r v a l   1   d a y   ,   y r   1 1     f r o m   c a l   1 2     w h e r e   e x t r a c t   y e a r   f r o m   d a t e _ a d d   d y ,   i n t e r v a l   1   d a y       =   y r   1 3         1 4           s e l e c t   d y   f r o m   c a l   1 5           w h e r e   d a y o f w e e k   d y     =   6   1       w i t h   x     d y , y r       2           a s         3   s e l e c t   d y ,   y e a r   d y     y r     4       f r o m        Discussion  DB2 To find all the Fridays in the current year, you must be able to return every day in the current year. The first step is to find the first day of the year by using the DAYOFYEAR function. Subtract the value returned by DAYOFYEAR CURRENT_DATE  from the current date to get December 31 of the prior year, and then add one to get the first day of the current year:  Now that you have the first day of the year, use the WITH clause to repeatedly add one day to the first day of the year until you are no longer in the current year. The result set will be every day in the current year  a portion of the rows returned by the recursive view X is shown here :    5   s e l e c t   g e t d a t e     - d a t e p a r t   d y , g e t d a t e       + 1   d y     6       f r o m   t 1     7                     t m p 1     8     u n i o n   a l l     9   s e l e c t   d a t e a d d   d d , 1 , d y   ,   y r   1 0       f r o m   x   1 1     w h e r e   y e a r   d a t e a d d   d d , 1 , d y       =   y r   1 2       1 3   s e l e c t   x . d y   1 4       f r o m   x   1 5     w h e r e   d a t e n a m e   d w , x . d y     =   ' F r i d a y '   1 6   o p t i o n     m a x r e c u r s i o n   4 0 0   s e l e c t     c u r r e n t _ d a t e                     d a y o f y e a r   c u r r e n t _ d a t e     d a y s   + 1   d a y s     a s   d y       f r o m   t 1     D Y   - - - - - - - - - - -   0 1 - J A N - 2 0 0 5   w i t h   x     d y , y r           a s       s e l e c t   d y ,   y e a r   d y     y r       f r o m       s e l e c t     c u r r e n t _ d a t e                     d a y o f y e a r   c u r r e n t _ d a t e     d a y s   + 1   d a y s     a s   d y    The final step is to use the DAYNAME function to keep only rows that are Fridays.  Oracle To find all the Fridays in the current year, you must be able to return every day in the current year. Begin by using the TRUNC function to find the first day of the year:  Next, use the CONNECT BY clause to return every day in the current year  to understand how to use CONNECT BY to generate rows, see Recipe 10.5 .      f r o m   t 1                       t m p 1   u n i o n   a l l   s e l e c t   d y + 1   d a y s ,   y r       f r o m   x     w h e r e   y e a r   d y   + 1   d a y     =   y r       s e l e c t   d y       f r o m   x     D Y   - - - - - - - - - - -   0 1 - J A N - 2 0 2 0   …   1 5 - F E B - 2 0 2 0   …   2 2 - N O V - 2 0 2 0   …   3 1 - D E C - 2 0 2 0 s e l e c t   t r u n c   s y s d a t e , ' y '     d y         f r o m   t 1       D Y     - - - - - - - - - - -     0 1 - J A N - 2 0 2 0  As an aside, this recipe uses the WITH clause, but you can also use an inline view.  TIP  A portion of the result set returned by view X is shown here:  The final step is to use the TO_CHAR function to keep only Fridays.  PostgreSQL To find the Fridays, first find all the days. You need to find the first day of the year, and then use the recursive CTE to fill in the rest of the days. Remember PostgreSQL is one of the packages that requires the use of the RECURSIVE keyword to identify a recursive CTE. The final step is to use the TO_CHAR function to keep only the Fridays.  MySQL To find all the Fridays in the current year, you must be able to return every day in the current year. The first step is to find the first day of the year.    w i t h   x         a s       s e l e c t   t r u n c   s y s d a t e , ' y '   + l e v e l - 1   d y   f r o m   t 1     c o n n e c t   b y   l e v e l   < =           a d d _ m o n t h s   t r u n c   s y s d a t e , ' y '   , 1 2   - t r u n c   s y s d a t e , ' y '         s e l e c t   *   f r o m   x     D Y   - - - - - - - - - - -   0 1 - J A N - 2 0 2 0   …   1 5 - F E B - 2 0 2 0   …   2 2 - N O V - 2 0 2 0   …   3 1 - D E C - 2 0 2 0  Subtract the value returned by DAYOFYEAR CURRENT_DATE  from the current date, and then add one to get the first day of the current year:  Once you’ve got the first day of the year, it’s simple to use a recursive CTE to add every day of the year:  The final step is to use the DAYNAME function to keep only Fridays.  SQL Server To find all the Fridays in the current year, you must be able to return every day in the current year. The first step is to find the first day of the year by using the DATEPART function. Subtract the value returned by DATEPART DY,GETDATE    from the current date, and then add one to get the first day of the current year:  s e l e c t   a d d d a t e                   a d d d a t e   c u r r e n t _ d a t e ,                                 i n t e r v a l   - d a y o f y e a r   c u r r e n t _ d a t e     d a y   ,                                 i n t e r v a l   1   d a y       d y       f r o m   t 1     D Y   - - - - - - - - - - -   0 1 - J A N - 2 0 2 0 w i t h   c a l     d y     a s     s e l e c t   c u r r e n t     u n i o n   a l l   s e l e c t   d y + 1         D Y     - - - - - - - - - - -     0 1 - J A N - 2 0 2 0     …     1 5 - F E B - 2 0 2 0     …     2 2 - N O V - 2 0 2 0     …     3 1 - D E C - 2 0 2 0  Now that you have the first day of the year, use the WITH clause and the DATEADD function to repeatedly add one day to the first day of the year until you are no longer in the current year. The result set will be every day in the current year  a portion of the rows returned by the recursive view X is shown here :  Finally, use the DATENAME function to keep only rows that are Fridays. For this solution to work, you must set MAXRECURSION to at least 366  the filter on the year portion of the current year, in recursive view X, guarantees you will never generate more than 366 rows .  s e l e c t   g e t d a t e     - d a t e p a r t   d y , g e t d a t e       + 1   d y       f r o m   t 1     D Y   - - - - - - - - - - -   0 1 - J A N - 2 0 0 5 w i t h   x     d y , y r         a s       s e l e c t   d y ,   y e a r   d y     y r       f r o m       s e l e c t   g e t d a t e     - d a t e p a r t   d y , g e t d a t e       + 1   d y       f r o m   t 1                     t m p 1     u n i o n   a l l   s e l e c t   d a t e a d d   d d , 1 , d y   ,   y r       f r o m   x     w h e r e   y e a r   d a t e a d d   d d , 1 , d y       =   y r       s e l e c t   x . d y       f r o m   x   o p t i o n     m a x r e c u r s i o n   4 0 0       D Y   - - - - - - - - - - -   0 1 - J A N - 2 0 2 0   …   1 5 - F E B - 2 0 2 0   …   2 2 - N O V - 2 0 2 0   …   3 1 - D E C - 2 0 2 0  9.6 Determining the Date of the First and Last Occurrences of a Specific Weekday in a Month  Problem You want to find, for example, the first and last Mondays of the current month.  Solution The choice to use Monday and the current month is arbitrary; you can use the solutions presented in this recipe for any weekday and any month. Because each weekday is 7 days apart from itself, once you have the first instance of a weekday, you can add 7 days to get the second and 14 days to get the third. Likewise, if you have the last instance of a weekday in a month, you can subtract 7 days to get the third and subtract 14 days to get the second.  DB2 Use the recursive WITH clause to generate each day in the current month and use a CASE expression to flag all Mondays. The first and last Mondays will be the earliest and latest of the flagged dates:    1       w i t h   x     d y , m t h , i s _ m o n d a y       2           a s         3   s e l e c t   d y , m o n t h   d y   ,     4                 c a s e   w h e n   d a y n a m e   d y   = ' M o n d a y '     5                             t h e n   1   e l s e   0     6                 e n d     7       f r o m         8   s e l e c t     c u r r e n t _ d a t e - d a y   c u r r e n t _ d a t e     d a y   + 1   d a y     d y     9       f r o m   t 1   1 0                     t m p 1   1 1     u n i o n   a l l   1 2   s e l e c t     d y   + 1   d a y   ,   m t h ,   1 3                 c a s e   w h e n   d a y n a m e   d y   + 1   d a y   = ' M o n d a y '   1 4                           t h e n   1   e l s e   0    Oracle Use the functions NEXT_DAY and LAST_DAY, together with a bit of clever date arithmetic, to find the first and last Mondays of the current month:  PostgreSQL Use the function DATE_TRUNC to find the first day of the month. Once you have the first day of the month, you can use simple arithmetic involving the numeric values of weekdays  Sun–Sat is 1–7  to find the first and last Mondays of the current month:  1 5                 e n d   1 6       f r o m   x   1 7     w h e r e   m o n t h   d y   + 1   d a y     =   m t h   1 8       1 9   s e l e c t   m i n   d y     f i r s t _ m o n d a y ,   m a x   d y     l a s t _ m o n d a y   2 0       f r o m   x   2 1     w h e r e   i s _ m o n d a y   =   1 s e l e c t   n e x t _ d a y   t r u n c   s y s d a t e , ' m m '   - 1 , ' M O N D A Y '     f i r s t _ m o n d a y ,                 n e x t _ d a y   l a s t _ d a y   t r u n c   s y s d a t e , ' m m '     - 7 , ' M O N D A Y '     l a s t _ m o n d a y       f r o m   d u a l   1   s e l e c t   f i r s t _ m o n d a y ,     2                 c a s e   t o _ c h a r   f i r s t _ m o n d a y + 2 8 , ' m m '       3                           w h e n   m t h   t h e n   f i r s t _ m o n d a y + 2 8     4                                             e l s e   f i r s t _ m o n d a y + 2 1     5                 e n d   a s   l a s t _ m o n d a y     6       f r o m         7   s e l e c t   c a s e   s i g n   c a s t   t o _ c h a r   d y , ' d '     a s   i n t e g e r   - 2       8                           w h e n   0     9                           t h e n   d y   1 0                           w h e n   - 1   1 1                           t h e n   d y + a b s   c a s t   t o _ c h a r   d y , ' d '     a s   i n t e g e r   - 2     1 2                           w h e n   1   1 3                           t h e n     7 -   c a s t   t o _ c h a r   d y , ' d '     a s   i n t e g e r   - 2     + d y   1 4                 e n d   a s   f i r s t _ m o n d a y ,   1 5                 m t h   1 6       f r o m       1 7   s e l e c t   c a s t   d a t e _ t r u n c   ' m o n t h ' , c u r r e n t _ d a t e     a s   d a t e     a s   d y ,   1 8                 t o _ c h a r   c u r r e n t _ d a t e , ' m m '     a s   m t h   1 9       f r o m   t 1    MySQL Use the ADDDATE function to find the first day of the month. Once you have the first day of the month, you can use simple arithmetic on the numeric values of weekdays  Sun–Sat is 1–7  to find the first and last Mondays of the current month:  SQL Server Use the recursive WITH clause to generate each day in the current month, and then use a CASE expression to flag all Mondays. The first and last Mondays will be the earliest and latest of the flagged dates:  2 0                     x   2 1                     y   1   s e l e c t   f i r s t _ m o n d a y ,     2                 c a s e   m o n t h   a d d d a t e   f i r s t _ m o n d a y , 2 8         3                           w h e n   m t h   t h e n   a d d d a t e   f i r s t _ m o n d a y , 2 8       4                                             e l s e   a d d d a t e   f i r s t _ m o n d a y , 2 1       5                 e n d   l a s t _ m o n d a y     6     f r o m         7   s e l e c t   c a s e   s i g n   d a y o f w e e k   d y   - 2       8                           w h e n   0   t h e n   d y     9                           w h e n   - 1   t h e n   a d d d a t e   d y , a b s   d a y o f w e e k   d y   - 2       1 0                           w h e n   1   t h e n   a d d d a t e   d y ,   7 -   d a y o f w e e k   d y   - 2         1 1                 e n d   f i r s t _ m o n d a y ,   1 2                 m t h   1 3       f r o m       1 4   s e l e c t   a d d d a t e   a d d d a t e   c u r r e n t _ d a t e , - d a y   c u r r e n t _ d a t e     , 1     d y ,   1 5                 m o n t h   c u r r e n t _ d a t e     m t h   1 6       f r o m   t 1   1 7                     x   1 8                     y   1       w i t h   x     d y , m t h , i s _ m o n d a y       2           a s         3   s e l e c t   d y , m t h ,     4                 c a s e   w h e n   d a t e p a r t   d w , d y     =   2     5                           t h e n   1   e l s e   0     6                 e n d     7       f r o m         8   s e l e c t   d a t e a d d   d a y , 1 , d a t e a d d   d a y , - d a y   g e t d a t e       , g e t d a t e           d y ,     9                 m o n t h   g e t d a t e         m t h    Discussion  DB2 and SQL Server DB2 and SQL Server use different functions to solve this problem, but the technique is exactly the same. If you eyeball both solutions, you’ll see the only difference between the two is the way dates are added. This discussion will cover both solutions, using the DB2 solution’s code to show the results of intermediate steps.  If you do not have access to the recursive WITH clause in the version of SQL Server or DB2 that you are running, you can use the PostgreSQL technique instead.  TIP  The first step in finding the first and last Mondays of the current month is to return the first day of the month. Inline view TMP1 in recursive view X finds the first day of the current month by first finding the current date, specifically, the day of the month for the current date. The day of the month for the current date represents how many days into the month you are  e.g., April 10th is the 10th day of the April . If you subtract this day of the month value from the current date, you end up at the last day of the  1 0       f r o m   t 1   1 1                     t m p 1   1 2     u n i o n   a l l   1 3   s e l e c t   d a t e a d d   d a y , 1 , d y   ,   1 4                 m t h ,   1 5                 c a s e   w h e n   d a t e p a r t   d w , d a t e a d d   d a y , 1 , d y       =   2   1 6                           t h e n   1   e l s e   0   1 7                 e n d   1 8       f r o m   x   1 9     w h e r e   m o n t h   d a t e a d d   d a y , 1 , d y       =   m t h   2 0       2 1   s e l e c t   m i n   d y     f i r s t _ m o n d a y ,   2 2                 m a x   d y     l a s t _ m o n d a y   2 3       f r o m   x   2 4     w h e r e   i s _ m o n d a y   =   1  previous month  e.g., subtracting 10 from April 10th puts you at the last day of March . After this subtraction, simply add one day to arrive at the first day of the current month:  Next, find the month for the current date using the MONTH function and a simple CASE expression to determine whether the first day of the month is a Monday:  Then use the recursive capabilities of the WITH clause to repeatedly add one day to the first day of the month until you’re no longer in the current month. Along the way, you will use a CASE expression to determine which days in the month are Mondays  Mondays will be flagged with 1 . A portion of the output from recursive view X is shown here:  s e l e c t     c u r r e n t _ d a t e - d a y   c u r r e n t _ d a t e     d a y   + 1   d a y     d y       f r o m   t 1     D Y   - - - - - - - - - - -   0 1 - J U N - 2 0 0 5 s e l e c t   d y ,   m o n t h   d y     m t h ,                   c a s e   w h e n   d a y n a m e   d y   = ' M o n d a y '                             t h e n   1   e l s e   0                   e n d   i s _ m o n d a y       f r o m         s e l e c t       c u r r e n t _ d a t e - d a y   c u r r e n t _ d a t e     d a y   + 1   d a y     d y       f r o m     t 1                       t m p 1     D Y                     M T H     I S _ M O N D A Y   - - - - - - - - - - -   - - -   - - - - - - - - - -   0 1 - J U N - 2 0 0 5       6                     0 w i t h   x     d y , m t h , i s _ m o n d a y               a s         s e l e c t   d y , m o n t h   d y     m t h ,                   c a s e   w h e n   d a y n a m e   d y   = ' M o n d a y '                             t h e n   1   e l s e   0                   e n d   i s _ m o n d a y         f r o m        Only Mondays will have a value of 1 for IS_MONDAY, so the final step is to use the aggregate functions MIN and MAX on rows where IS_MONDAY is 1 to find the first and last Mondays of the month.  Oracle The function NEXT_DAY makes this problem easy to solve. To find the first Monday of the current month, first return the last day of the prior month via some date arithmetic involving the TRUNC function:    s e l e c t     c u r r e n t _ d a t e - d a y   c u r r e n t _ d a t e     d a y   + 1   d a y     d y         f r o m   t 1                       t m p 1       u n i o n   a l l     s e l e c t     d y   + 1   d a y   ,   m t h ,                   c a s e   w h e n   d a y n a m e   d y   + 1   d a y   = ' M o n d a y '                             t h e n   1   e l s e   0                   e n d         f r o m   x       w h e r e   m o n t h   d y   + 1   d a y     =   m t h           s e l e c t   *         f r o m   x     D Y                     M T H     I S _ M O N D A Y   - - - - - - - - - - -   - - -   - - - - - - - - - -   0 1 - J U N - 2 0 0 5       6                     0   0 2 - J U N - 2 0 0 5       6                     0   0 3 - J U N - 2 0 0 5       6                     0   0 4 - J U N - 2 0 0 5       6                     0   0 5 - J U N - 2 0 0 5       6                     0   0 6 - J U N - 2 0 0 5       6                     1   0 7 - J U N - 2 0 0 5       6                     0   0 8 - J U N - 2 0 0 5       6                     0   … s e l e c t   t r u n c   s y s d a t e , ' m m '   - 1   d y       f r o m   d u a l     D Y   - - - - - - - - - - -   3 1 - M A Y - 2 0 0 5  Then use the NEXT_DAY function to find the first Monday that comes after the last day of the previous month  i.e., the first Monday of the current month :  To find the last Monday of the current month, start by returning the first day of the current month by using the TRUNC function:  The next step is to find the last week  the last seven days  of the month. Use the LAST_DAY function to find the last day of the month, and then subtract seven days:  If it isn’t immediately obvious, you go back seven days from the last day of the month to ensure that you will have at least one of any weekday left in the month. The last step is to use the function NEXT_DAY to find the next  and last  Monday of the month:  s e l e c t   n e x t _ d a y   t r u n c   s y s d a t e , ' m m '   - 1 , ' M O N D A Y '     f i r s t _ m o n d a y       f r o m   d u a l       F I R S T _ M O N D A Y   - - - - - - - - - - - -   0 6 - J U N - 2 0 0 5 s e l e c t   t r u n c   s y s d a t e , ' m m '     d y       f r o m   d u a l     D Y   - - - - - - - - - - -   0 1 - J U N - 2 0 0 5 s e l e c t   l a s t _ d a y   t r u n c   s y s d a t e , ' m m '     - 7   d y       f r o m   d u a l     D Y   - - - - - - - - - - -   2 3 - J U N - 2 0 0 5 s e l e c t   n e x t _ d a y   l a s t _ d a y   t r u n c   s y s d a t e , ' m m '     - 7 , ' M O N D A Y '     l a s t _ m o n d a y       f r o m   d u a l    PostgreSQL and MySQL PostgreSQL and MySQL also share the same solution approach. The difference is in the functions that you invoke. Despite their lengths, the respective queries are extremely simple; little overhead is involved in finding the first and last Mondays of the current month. The first step is to find the first day of the current month. The next step is to find the first Monday of the month. Since there is no function to find the next date for a given weekday, you need to use a little arithmetic. The CASE expression beginning on line 7  of either solution  evaluates the difference between the numeric value for the weekday of the first day of the month and the numeric value corresponding to Monday. Given that the function TO_CHAR  PostgreSQL , when called with the D or d format, and the function DAYOFWEEK  MySQL  will return a numeric value from 1 to 7 representing days Sunday to Saturday, Monday is always represented by 2. The first test evaluated by CASE is the SIGN of the numeric value of the first day of the month  whatever it may be  minus the numeric value of Monday  2 . If the result is zero, then the first day of the month falls on a Monday, and that is the first Monday of the month. If the result is –1, then the first day of the month falls on a Sunday, and to find the first Monday of the month, simply add the difference in days between 2 and 1  numeric values of Monday and Sunday, respectively  to the first day of the month.  TIP  If you are having trouble understanding how this works, forget the weekday names and just do the math. For example, say you happen to be starting on a Tuesday and you are looking for the next Friday. When using TO_CHAR with the d format, or DAYOFWEEK, Friday is 6 and Tuesday is 3. To get to 6 from 3, simply take the difference  6–3 = 3  and add it to the smaller value   6–3  + 3 = 6 . So, regardless of the actual dates, if the numeric value of the day you are starting from is less than the numeric value of the day you are searching for, adding the difference between the two dates to the date you are starting from will get you to the date you are searching for.    L A S T _ M O N D A Y   - - - - - - - - - - -   2 7 - J U N - 2 0 0 5  If the result from SIGN is 1, then the first day of the month falls between Tuesday and Saturday  inclusive . When the first day of the month has a numeric value greater than 2  Monday , subtract from 7 the difference between the numeric value of the first day of the month and the numeric value of Monday  2 , and then add that value to the first day of the month. You will have arrived at the day of the week that you are after, in this case Monday.  TIP  Again, if you are having trouble understanding how this works, forget the weekday names and just do the math. For example, suppose you want to find the next Tuesday and you are starting from Friday. Tuesday  3  is less than Friday  6 . To get to 3 from 6, subtract the difference between the two values from 7  7–  3–6   = 4  and add the result  4  to the start day Friday.  The vertical bars in 3–6 generate the absolute value of that difference.  Here, you’re not adding 4 to 6  which will give you 10 ; you are adding four days to Friday, which will give you the next Tuesday.  The idea behind the CASE expression is to create a sort of a “next day” function for PostgreSQL and MySQL. If you do not start with the first day of the month, the value for DY will be the value returned by CURRENT_DATE, and the result of the CASE expression will return the date of the next Monday starting from the current date  unless CURRENT_DATE is a Monday, then that date will be returned . Now that you have the first Monday of the month, add either 21 or 28 days to find the last Monday of the month. The CASE expression in lines 2–5 determines whether to add 21 or 28 days by checking to see whether 28 days takes you into the next month. The CASE expression does this through the following process:  1. It adds 28 to the value of FIRST_MONDAY. 2. Using either TO_CHAR  PostgreSQL  or MONTH, the CASE  expression extracts the name of the current month from the result of FIRST_MONDAY + 28.   3. The result from step two is compared to the value MTH from the inline view. The value MTH is the name of the current month as derived from CURRENT_ DATE. If the 2 month values match, then the month is large enough for you to need to add 28 days, and the CASE expression returns FIRST_MONDAY + 28. If the two month values do not match, then you do not have room to add 28 days, and the CASE expression returns FIRST_MONDAY + 21 days instead. It is convenient that our months are such that 28 and 21 are the only two possible values you need worry about adding.  You can extend the solution by adding 7 and 14 days to find the second and third Mondays of the month, respectively.  TIP  9.7 Creating a Calendar  Problem You want to create a calendar for the current month. The calendar should be formatted like a calendar you might have on your desk: seven columns across and  usually  five rows down.  Solution Each solution will look a bit different, but they all solve the problem the same way: return each day for the current month, and then pivot on the day of the week for each week in the month to create a calendar. There are different formats available for calendars. For example, the Unix CAL command formats the days from Sunday to Saturday. The examples in this recipe are based on ISO weeks, so the Monday through Friday format is the most convenient to generate. Once you become comfortable with the   solutions, you’ll see that reformatting however you like is simply a matter of modifying the values assigned by the ISO week before pivoting.  TIP  As you begin to use different types of formatting with SQL to create readable output, you will notice your queries becoming longer. Don’t let those long queries intimidate you; the queries presented for this recipe are extremely simple once broken down and run piece by piece.  DB2 Use the recursive WITH clause to return every day in the current month. Then pivot on the day of the week using CASE and MAX:  Oracle    1       w i t h   x   d y , d m , m t h , d w , w k       2       a s         3   s e l e c t     c u r r e n t _ d a t e   - d a y   c u r r e n t _ d a t e     d a y   + 1   d a y     d y ,     4                   d a y     c u r r e n t _ d a t e   - d a y   c u r r e n t _ d a t e     d a y   + 1   d a y       d m ,     5                   m o n t h   c u r r e n t _ d a t e     m t h ,     6                   d a y o f w e e k   c u r r e n t _ d a t e   - d a y   c u r r e n t _ d a t e     d a y   + 1   d a y     d w ,     7                   w e e k _ i s o   c u r r e n t _ d a t e   - d a y   c u r r e n t _ d a t e     d a y   + 1   d a y     w k     8       f r o m   t 1     9     u n i o n   a l l   1 0   s e l e c t   d y + 1   d a y ,   d a y   d y + 1   d a y   ,   m t h ,   1 1                   d a y o f w e e k   d y + 1   d a y   ,   w e e k _ i s o   d y + 1   d a y     1 2       f r o m   x   1 3     w h e r e   m o n t h   d y + 1   d a y     =   m t h   1 4         1 5     s e l e c t   m a x   c a s e   d w   w h e n   2   t h e n   d m   e n d     a s   M o ,   1 6                   m a x   c a s e   d w   w h e n   3   t h e n   d m   e n d     a s   T u ,   1 7                   m a x   c a s e   d w   w h e n   4   t h e n   d m   e n d     a s   W e ,   1 8                   m a x   c a s e   d w   w h e n   5   t h e n   d m   e n d     a s   T h ,   1 9                   m a x   c a s e   d w   w h e n   6   t h e n   d m   e n d     a s   F r ,   2 0                   m a x   c a s e   d w   w h e n   7   t h e n   d m   e n d     a s   S a ,   2 1                   m a x   c a s e   d w   w h e n   1   t h e n   d m   e n d     a s   S u   2 2       f r o m   x   2 3     g r o u p   b y   w k   2 4     o r d e r   b y   w k  Use the recursive CONNECT BY clause to return each day in the current month. Then pivot on the day of the week using CASE and MAX:  PostgreSQL Use the function GENERATE_SERIES to return every day in the current month. Then pivot on the day of the week using MAX and CASE:    1     w i t h   x     2         a s         3   s e l e c t   *     4       f r o m         5   s e l e c t   t o _ c h a r   t r u n c   s y s d a t e , ' m m '   + l e v e l - 1 , ' i w '     w k ,     6                 t o _ c h a r   t r u n c   s y s d a t e , ' m m '   + l e v e l - 1 , ' d d '     d m ,     7                 t o _ n u m b e r   t o _ c h a r   t r u n c   s y s d a t e , ' m m '   + l e v e l - 1 , ' d '       d w ,     8                 t o _ c h a r   t r u n c   s y s d a t e , ' m m '   + l e v e l - 1 , ' m m '     c u r r _ m t h ,     9                 t o _ c h a r   s y s d a t e , ' m m '     m t h   1 0       f r o m   d u a l   1 1     c o n n e c t   b y   l e v e l   < =   3 1   1 2                     1 3     w h e r e   c u r r _ m t h   =   m t h   1 4       1 5   s e l e c t   m a x   c a s e   d w   w h e n   2   t h e n   d m   e n d     M o ,   1 6                 m a x   c a s e   d w   w h e n   3   t h e n   d m   e n d     T u ,   1 7                 m a x   c a s e   d w   w h e n   4   t h e n   d m   e n d     W e ,   1 8                 m a x   c a s e   d w   w h e n   5   t h e n   d m   e n d     T h ,   1 9                 m a x   c a s e   d w   w h e n   6   t h e n   d m   e n d     F r ,   2 0                 m a x   c a s e   d w   w h e n   7   t h e n   d m   e n d     S a ,   2 1                 m a x   c a s e   d w   w h e n   1   t h e n   d m   e n d     S u   2 2       f r o m   x   2 3     g r o u p   b y   w k   2 4     o r d e r   b y   w k   1   s e l e c t   m a x   c a s e   d w   w h e n   2   t h e n   d m   e n d     a s   M o ,     2                 m a x   c a s e   d w   w h e n   3   t h e n   d m   e n d     a s   T u ,     3                 m a x   c a s e   d w   w h e n   4   t h e n   d m   e n d     a s   W e ,     4                 m a x   c a s e   d w   w h e n   5   t h e n   d m   e n d     a s   T h ,     5                 m a x   c a s e   d w   w h e n   6   t h e n   d m   e n d     a s   F r ,     6                 m a x   c a s e   d w   w h e n   7   t h e n   d m   e n d     a s   S a ,     7                 m a x   c a s e   d w   w h e n   1   t h e n   d m   e n d     a s   S u     8       f r o m         9   s e l e c t   *   1 0       f r o m       1 1   s e l e c t   c a s t   d a t e _ t r u n c   ' m o n t h ' , c u r r e n t _ d a t e     a s   d a t e   + x . i d ,   1 2                 t o _ c h a r      MySQL Use a recursive CTE to return each day in the current month. Then pivot on the day of the week using MAX and CASE:  1 3                       c a s t     1 4           d a t e _ t r u n c   ' m o n t h ' , c u r r e n t _ d a t e     1 5                                 a s   d a t e   + x . i d , ' i w '     a s   w k ,   1 6                 t o _ c h a r     1 7                       c a s t     1 8           d a t e _ t r u n c   ' m o n t h ' , c u r r e n t _ d a t e     1 9                                 a s   d a t e   + x . i d , ' d d '     a s   d m ,   2 0                 c a s t     2 1           t o _ c h a r     2 2                 c a s t     2 3       d a t e _ t r u n c   ' m o n t h ' , c u r r e n t _ d a t e     2 4                                   a s   d a t e   + x . i d , ' d '     a s   i n t e g e r     a s   d w ,   2 5                   t o _ c h a r     2 6                         c a s t     2 7           d a t e _ t r u n c   ' m o n t h ' , c u r r e n t _ d a t e     2 8                                   a s   d a t e   + x . i d , ' m m '     a s   c u r r _ m t h ,   2 9                   t o _ c h a r   c u r r e n t _ d a t e , ' m m '     a s   m t h   3 0       f r o m   g e n e r a t e _ s e r i e s     0 , 3 1     x   i d     3 1                     x   3 2     w h e r e   m t h   =   c u r r _ m t h   3 3                     y   3 4     g r o u p   b y   w k   3 5     o r d e r   b y   w k w i t h   r e c u r s i v e     x   d y , d m , m t h , d w , w k                 a s           s e l e c t   d y ,                     d a y   d y     d m ,                     d a t e p a r t   m , d y     m t h ,                     d a t e p a r t   d w , d y     d w ,                     c a s e   w h e n   d a t e p a r t   d w , d y     =   1                               t h e n   d a t e p a r t   w w , d y   - 1                               e l s e   d a t e p a r t   w w , d y                     e n d   w k         f r o m         s e l e c t   d a t e _ a d d   d a y , - d a y   g e t d a t e       + 1 , g e t d a t e         d y         f r o m   t 1                       x       u n i o n   a l l       s e l e c t   d a t e a d d   d , 1 , d y   ,   d a y   d a t e _ a d d   d , 1 , d y     ,   m t h ,                     d a t e p a r t   d w , d a t e a d d   d , 1 , d y     ,    SQL Server Use the recursive WITH clause to return every day in the current month. Then pivot on the day of the week using CASE and MAX:                    c a s e   w h e n   d a t e p a r t   d w , d a t e _ a d d   d , 1 , d y       =   1                               t h e n   d a t e p a r t   w k , d a t e _ a d d   d , 1 , d y     - 1                               e l s e   d a t e p a r t   w k , d a t e _ a d d   d , 1 , d y                         e n d           f r o m   x         w h e r e   d a t e p a r t   m , d a t e _ a d d   d , 1 , d y       =   m t h           s e l e c t   m a x   c a s e   d w   w h e n   2   t h e n   d m   e n d     a s   M o ,                   m a x   c a s e   d w   w h e n   3   t h e n   d m   e n d     a s   T u ,                   m a x   c a s e   d w   w h e n   4   t h e n   d m   e n d     a s   W e ,                   m a x   c a s e   d w   w h e n   5   t h e n   d m   e n d     a s   T h ,                   m a x   c a s e   d w   w h e n   6   t h e n   d m   e n d     a s   F r ,                   m a x   c a s e   d w   w h e n   7   t h e n   d m   e n d     a s   S a ,                   m a x   c a s e   d w   w h e n   1   t h e n   d m   e n d     a s   S u         f r o m   x       g r o u p   b y   w k       o r d e r   b y   w k ;   1       w i t h   x   d y , d m , m t h , d w , w k       2           a s         3   s e l e c t   d y ,     4                 d a y   d y     d m ,     5                 d a t e p a r t   m , d y     m t h ,     6                 d a t e p a r t   d w , d y     d w ,     7                 c a s e   w h e n   d a t e p a r t   d w , d y     =   1     8                           t h e n   d a t e p a r t   w w , d y   - 1     9                           e l s e   d a t e p a r t   w w , d y     1 0                 e n d   w k   1 1       f r o m       1 2   s e l e c t   d a t e a d d   d a y , - d a y   g e t d a t e       + 1 , g e t d a t e         d y   1 3       f r o m   t 1   1 4                     x   1 5     u n i o n   a l l   1 6     s e l e c t   d a t e a d d   d , 1 , d y   ,   d a y   d a t e a d d   d , 1 , d y     ,   m t h ,   1 7                   d a t e p a r t   d w , d a t e a d d   d , 1 , d y     ,   1 8                   c a s e   w h e n   d a t e p a r t   d w , d a t e a d d   d , 1 , d y       =   1   1 9                             t h e n   d a t e p a r t   w k , d a t e a d d   d , 1 , d y         - 1   2 0                             e l s e   d a t e p a r t   w k , d a t e a d d   d , 1 , d y       2 1                   e n d   2 2         f r o m   x   2 3       w h e r e   d a t e p a r t   m , d a t e a d d   d , 1 , d y       =   m t h    Discussion  DB2 The first step is to return each day in the month for which you want to create a calendar. Do that using the recursive WITH clause. Along with each day of the month  DM , you will need to return different parts of each date: the day of the week  DW , the current month you are working with  MTH , and the ISO week for each day of the month  WK . The results of the recursive view X prior to recursion taking place  the upper portion of the UNION ALL  are shown here:  The next step is to repeatedly increase the value for DM  move through the days of the month  until you are no longer in the current month. As you move through each day in the month, you will also return the day of the week that each day is, and which ISO week the current day of the month falls into. Partial results are shown here:  2 4       2 5   s e l e c t   m a x   c a s e   d w   w h e n   2   t h e n   d m   e n d     a s   M o ,   2 6                 m a x   c a s e   d w   w h e n   3   t h e n   d m   e n d     a s   T u ,   2 7                 m a x   c a s e   d w   w h e n   4   t h e n   d m   e n d     a s   W e ,   2 8                 m a x   c a s e   d w   w h e n   5   t h e n   d m   e n d     a s   T h ,   2 9                 m a x   c a s e   d w   w h e n   6   t h e n   d m   e n d     a s   F r ,   3 0                 m a x   c a s e   d w   w h e n   7   t h e n   d m   e n d     a s   S a ,   3 1                 m a x   c a s e   d w   w h e n   1   t h e n   d m   e n d     a s   S u   3 2       f r o m   x   3 3     g r o u p   b y   w k   3 4     o r d e r   b y   w k s e l e c t     c u r r e n t _ d a t e   - d a y   c u r r e n t _ d a t e     d a y   + 1   d a y     d y ,                 d a y     c u r r e n t _ d a t e   - d a y   c u r r e n t _ d a t e     d a y   + 1   d a y       d m ,                 m o n t h   c u r r e n t _ d a t e     m t h ,                 d a y o f w e e k   c u r r e n t _ d a t e   - d a y   c u r r e n t _ d a t e     d a y   + 1   d a y     d w ,                 w e e k _ i s o   c u r r e n t _ d a t e   - d a y   c u r r e n t _ d a t e     d a y   + 1   d a y     w k       f r o m   t 1     D Y                     D M   M T H                   D W   W K   - - - - - - - - - - -   - -   - - -   - - - - - - - - - -   - -   0 1 - J U N - 2 0 0 5   0 1     0 6                     4   2 2  What you are returning at this point is: each day for the current month, the two-digit numeric day of the month, the two-digit numeric month, the one- digit day of the week  1–7 for Sun–Sat , and the two-digit ISO week each day falls into. With all this information available, you can use a CASE expression to determine which day of the week each value of DM  each day of the month  falls into. A portion of the results is shown here:  w i t h   x   d y , d m , m t h , d w , w k         a s       s e l e c t     c u r r e n t _ d a t e   - d a y   c u r r e n t _ d a t e     d a y   + 1   d a y     d y ,                 d a y     c u r r e n t _ d a t e   - d a y   c u r r e n t _ d a t e     d a y   + 1   d a y       d m ,                 m o n t h   c u r r e n t _ d a t e     m t h ,                 d a y o f w e e k   c u r r e n t _ d a t e   - d a y   c u r r e n t _ d a t e     d a y   + 1   d a y     d w ,                 w e e k _ i s o   c u r r e n t _ d a t e   - d a y   c u r r e n t _ d a t e     d a y   + 1   d a y     w k       f r o m   t 1     u n i o n   a l l     s e l e c t   d y + 1   d a y ,   d a y   d y + 1   d a y   ,   m t h ,                   d a y o f w e e k   d y + 1   d a y   ,   w e e k _ i s o   d y + 1   d a y           f r o m   x       w h e r e   m o n t h   d y + 1   d a y     =   m t h       s e l e c t   *       f r o m   x     D Y                     D M   M T H                   D W   W K   - - - - - - - - - - -   - -   - - -   - - - - - - - - - -   - -   0 1 - J U N - 2 0 2 0   0 1   0 6                       4   2 2   0 2 - J U N - 2 0 2 0   0 2   0 6                       5   2 2   …   2 1 - J U N - 2 0 2 0   2 1   0 6                       3   2 5   2 2 - J U N - 2 0 2 0   2 2   0 6                       4   2 5   …   3 0 - J U N - 2 0 2 0   3 0   0 6                       5   2 6 w i t h   x   d y , d m , m t h , d w , w k         a s       s e l e c t     c u r r e n t _ d a t e   - d a y   c u r r e n t _ d a t e     d a y   + 1   d a y     d y ,                 d a y     c u r r e n t _ d a t e   - d a y   c u r r e n t _ d a t e     d a y   + 1   d a y       d m ,                 m o n t h   c u r r e n t _ d a t e     m t h ,                 d a y o f w e e k   c u r r e n t _ d a t e   - d a y   c u r r e n t _ d a t e     d a y   + 1   d a y     d w ,                 w e e k _ i s o   c u r r e n t _ d a t e   - d a y   c u r r e n t _ d a t e     d a y   + 1   d a y     w k       f r o m   t 1     u n i o n   a l l     s e l e c t   d y + 1   d a y ,   d a y   d y + 1   d a y   ,   m t h ,    As you can see from the partial output, every day in each week is returned as a row. What you want to do now is to group the days by week, and then collapse all the days for each week into a single row. Use the aggregate function MAX, and group by WK  the ISO week  to return all the days for a week as one row. To properly format the calendar and ensure that the days are in the right order, order the results by WK. The final output is shown here:                  d a y o f w e e k   d y + 1   d a y   ,   w e e k _ i s o   d y + 1   d a y           f r o m   x       w h e r e   m o n t h   d y + 1   d a y     =   m t h           s e l e c t   w k ,                   c a s e   d w   w h e n   2   t h e n   d m   e n d   a s   M o ,                   c a s e   d w   w h e n   3   t h e n   d m   e n d   a s   T u ,                   c a s e   d w   w h e n   4   t h e n   d m   e n d   a s   W e ,                   c a s e   d w   w h e n   5   t h e n   d m   e n d   a s   T h ,                   c a s e   d w   w h e n   6   t h e n   d m   e n d   a s   F r ,                   c a s e   d w   w h e n   7   t h e n   d m   e n d   a s   S a ,                   c a s e   d w   w h e n   1   t h e n   d m   e n d   a s   S u         f r o m   x     W K   M O   T U   W E   T H   F R   S A   S U   - -   - -   - -   - -   - -   - -   - -   - -   2 2               0 1   2 2                     0 2   2 2                           0 3   2 2                                 0 4   2 2                                       0 5   2 3   0 6   2 3         0 7   2 3               0 8   2 3                     0 9   2 3                           1 0   2 3                                 1 1   2 3                                       1 2 w i t h   x   d y , d m , m t h , d w , w k         a s       s e l e c t     c u r r e n t _ d a t e   - d a y   c u r r e n t _ d a t e     d a y   + 1   d a y     d y ,                 d a y     c u r r e n t _ d a t e   - d a y   c u r r e n t _ d a t e     d a y   + 1   d a y       d m ,                 m o n t h   c u r r e n t _ d a t e     m t h ,                 d a y o f w e e k   c u r r e n t _ d a t e   - d a y   c u r r e n t _ d a t e     d a y   + 1   d a y     d w ,                 w e e k _ i s o   c u r r e n t _ d a t e   - d a y   c u r r e n t _ d a t e     d a y   + 1   d a y     w k    Oracle Begin by using the recursive CONNECT BY clause to generate a row for each day in the month for which you want to generate a calendar. If you aren’t running at least Oracle9i Database, you can’t use CONNECT BY this way. Instead, you can use a pivot table, such as T500 in the MySQL solution. Along with each day of the month, you will need to return different bits of information for each day: the day of the month  DM , the day of the week  DW , the current month you are working with  MTH , and the ISO week for each day of the month  WK . The results of the WITH view X for the first day of the current month are shown here:      f r o m   t 1     u n i o n   a l l     s e l e c t   d y + 1   d a y ,   d a y   d y + 1   d a y   ,   m t h ,                   d a y o f w e e k   d y + 1   d a y   ,   w e e k _ i s o   d y + 1   d a y           f r o m   x       w h e r e   m o n t h   d y + 1   d a y     =   m t h       s e l e c t   m a x   c a s e   d w   w h e n   2   t h e n   d m   e n d     a s   M o ,                 m a x   c a s e   d w   w h e n   3   t h e n   d m   e n d     a s   T u ,                 m a x   c a s e   d w   w h e n   4   t h e n   d m   e n d     a s   W e ,                 m a x   c a s e   d w   w h e n   5   t h e n   d m   e n d     a s   T h ,                 m a x   c a s e   d w   w h e n   6   t h e n   d m   e n d     a s   F r ,                 m a x   c a s e   d w   w h e n   7   t h e n   d m   e n d     a s   S a ,                 m a x   c a s e   d w   w h e n   1   t h e n   d m   e n d     a s   S u       f r o m   x     g r o u p   b y   w k     o r d e r   b y   w k       M O   T U   W E   T H   F R   S A   S U   - -   - -   - -   - -   - -   - -   - -               0 1   0 2   0 3   0 4   0 5   0 6   0 7   0 8   0 9   1 0   1 1   1 2   1 3   1 4   1 5   1 6   1 7   1 8   1 9   2 0   2 1   2 2   2 3   2 4   2 5   2 6   2 7   2 8   2 9   3 0 s e l e c t   t r u n c   s y s d a t e , ' m m '     d y ,                 t o _ c h a r   t r u n c   s y s d a t e , ' m m '   , ' d d '     d m ,                 t o _ c h a r   s y s d a t e , ' m m '     m t h ,    The next step is to repeatedly increase the value for DM  move through the days of the month  until you are no longer in the current month. As you move through each day in the month, you will also return the day of the week for each day and the ISO week into which the current day falls. Partial results are shown here  the full date for each day is added for readability :  What you are returning at this point is one row for each day of the current month. In that row you have: the two-digit numeric day of the month, the                t o _ n u m b e r   t o _ c h a r   t r u n c   s y s d a t e , ' m m '   , ' d '       d w ,                 t o _ c h a r   t r u n c   s y s d a t e , ' m m '   , ' i w '     w k       f r o m   d u a l     D Y                     D M   M T                   D W   W K   - - - - - - - - - - -   - -   - -   - - - - - - - - - -   - -   0 1 - J U N - 2 0 2 0   0 1   0 6                     4   2 2 w i t h   x       a s       s e l e c t   *       f r o m       s e l e c t   t r u n c   s y s d a t e , ' m m '   + l e v e l - 1   d y ,                 t o _ c h a r   t r u n c   s y s d a t e , ' m m '   + l e v e l - 1 , ' i w '     w k ,                 t o _ c h a r   t r u n c   s y s d a t e , ' m m '   + l e v e l - 1 , ' d d '     d m ,                 t o _ n u m b e r   t o _ c h a r   t r u n c   s y s d a t e , ' m m '   + l e v e l - 1 , ' d '       d w ,                 t o _ c h a r   t r u n c   s y s d a t e , ' m m '   + l e v e l - 1 , ' m m '     c u r r _ m t h ,                 t o _ c h a r   s y s d a t e , ' m m '     m t h       f r o m   d u a l     c o n n e c t   b y   l e v e l   < =   3 1                       w h e r e   c u r r _ m t h   =   m t h       s e l e c t   *       f r o m   x     D Y                     W K   D M                   D W   C U   M T   - - - - - - - - - - -   - -   - -   - - - - - - - - - -   - -   - -   0 1 - J U N - 2 0 2 0   2 2   0 1                     4   0 6   0 6   0 2 - J U N - 2 0 2 0   2 2   0 2                     5   0 6   0 6   …   2 1 - J U N - 2 0 2 0   2 5   2 1                     3   0 6   0 6   2 2 - J U N - 2 0 2 0   2 5   2 2                     4   0 6   0 6   …   3 0 - J U N - 2 0 2 0   2 6   3 0                     5   0 6   0 6  two-digit numeric month, the one-digit day of the week  1–7 for Sun–Sat , and the two-digit ISO week number. With all this information available, you can use a CASE expression to determine which day of the week each value of DM  each day of the month  falls into. A portion of the results is shown here:  w i t h   x       a s       s e l e c t   *       f r o m       s e l e c t   t r u n c   s y s d a t e , ' m m '   + l e v e l - 1   d y ,                 t o _ c h a r   t r u n c   s y s d a t e , ' m m '   + l e v e l - 1 , ' i w '     w k ,                 t o _ c h a r   t r u n c   s y s d a t e , ' m m '   + l e v e l - 1 , ' d d '     d m ,                 t o _ n u m b e r   t o _ c h a r   t r u n c   s y s d a t e , ' m m '   + l e v e l - 1 , ' d '       d w ,                 t o _ c h a r   t r u n c   s y s d a t e , ' m m '   + l e v e l - 1 , ' m m '     c u r r _ m t h ,                 t o _ c h a r   s y s d a t e , ' m m '     m t h       f r o m   d u a l     c o n n e c t   b y   l e v e l   < =   3 1                       w h e r e   c u r r _ m t h   =   m t h       s e l e c t   w k ,                 c a s e   d w   w h e n   2   t h e n   d m   e n d   a s   M o ,                 c a s e   d w   w h e n   3   t h e n   d m   e n d   a s   T u ,                 c a s e   d w   w h e n   4   t h e n   d m   e n d   a s   W e ,                 c a s e   d w   w h e n   5   t h e n   d m   e n d   a s   T h ,                 c a s e   d w   w h e n   6   t h e n   d m   e n d   a s   F r ,                 c a s e   d w   w h e n   7   t h e n   d m   e n d   a s   S a ,                 c a s e   d w   w h e n   1   t h e n   d m   e n d   a s   S u       f r o m   x     W K   M O   T U   W E   T H   F R   S A   S U   - -   - -   - -   - -   - -   - -   - -   - -   2 2               0 1   2 2                     0 2   2 2                           0 3   2 2                                 0 4   2 2                                     0 5   2 3   0 6   2 3         0 7   2 3               0 8   2 3                     0 9   2 3                           1 0   2 3                               1 1   2 3                                   1 2  As you can see from the partial output, every day in each week is returned as a row, but the day number is in one of seven columns corresponding to the day of the week. Your task now is to consolidate the days into one row for each week. Use the aggregate function MAX and group by WK  the ISO week  to return all the days for a week as one row. To ensure the days are in the right order, order the results by WK. The final output is shown here:  MySQL, PostgreSQL, and SQL Server  w i t h   x       a s       s e l e c t   *       f r o m       s e l e c t   t o _ c h a r   t r u n c   s y s d a t e , ' m m '   + l e v e l - 1 , ' i w '     w k ,                 t o _ c h a r   t r u n c   s y s d a t e , ' m m '   + l e v e l - 1 , ' d d '     d m ,                 t o _ n u m b e r   t o _ c h a r   t r u n c   s y s d a t e , ' m m '   + l e v e l - 1 , ' d '       d w ,                 t o _ c h a r   t r u n c   s y s d a t e , ' m m '   + l e v e l - 1 , ' m m '     c u r r _ m t h ,                 t o _ c h a r   s y s d a t e , ' m m '     m t h       f r o m   d u a l     c o n n e c t   b y   l e v e l   < =   3 1                       w h e r e   c u r r _ m t h   =   m t h       s e l e c t   m a x   c a s e   d w   w h e n   2   t h e n   d m   e n d     M o ,                 m a x   c a s e   d w   w h e n   3   t h e n   d m   e n d     T u ,                 m a x   c a s e   d w   w h e n   4   t h e n   d m   e n d     W e ,                 m a x   c a s e   d w   w h e n   5   t h e n   d m   e n d     T h ,                 m a x   c a s e   d w   w h e n   6   t h e n   d m   e n d     F r ,                 m a x   c a s e   d w   w h e n   7   t h e n   d m   e n d     S a ,                 m a x   c a s e   d w   w h e n   1   t h e n   d m   e n d     S u       f r o m   x     g r o u p   b y   w k     o r d e r   b y   w k     M O   T U   W E   T H   F R   S A   S U   - -   - -   - -   - -   - -   - -   - -               0 1   0 2   0 3   0 4   0 5   0 6   0 7   0 8   0 9   1 0   1 1   1 2   1 3   1 4   1 5   1 6   1 7   1 8   1 9   2 0   2 1   2 2   2 3   2 4   2 5   2 6   2 7   2 8   2 9   3 0  These solutions are the same except for differences in the specific functions used to call dates. We arbitrarily use the SQL Serve solution for the explanation. Begin by returning one row for each day of the month. You can do that using the recursive WITH clause. For each row that you return, you will need the following items: the day of the month  DM , the day of the week  DW , the current month you are working with  MTH , and the ISO week for each day of the month  WK . The results of the recursive view X prior to recursion taking place  the upper portion of the UNION ALL  are shown here:  Your next step is to repeatedly increase the value for DM  move through the days of the month  until you are no longer in the current month. As you move through each day in the month, you will also return the day of the week and the ISO week number. Partial results are shown here:  s e l e c t   d y ,                 d a y   d y     d m ,                 d a t e p a r t   m , d y     m t h ,                 d a t e p a r t   d w , d y     d w ,                 c a s e   w h e n   d a t e p a r t   d w , d y     =   1                           t h e n   d a t e p a r t   w w , d y   - 1                           e l s e   d a t e p a r t   w w , d y                   e n d   w k       f r o m       s e l e c t   d a t e a d d   d a y , - d a y   g e t d a t e       + 1 , g e t d a t e         d y       f r o m   t 1                     x     D Y                     D M   M T H                   D W   W K   - - - - - - - - - - -   - -   - - -   - - - - - - - - - -   - -   0 1 - J U N - 2 0 0 5     1       6                     4   2 3     w i t h   x   d y , d m , m t h , d w , w k             a s       s e l e c t   d y ,                 d a y   d y     d m ,                 d a t e p a r t   m , d y     m t h ,                 d a t e p a r t   d w , d y     d w ,                 c a s e   w h e n   d a t e p a r t   d w , d y     =   1                           t h e n   d a t e p a r t   w w , d y   - 1                           e l s e   d a t e p a r t   w w , d y      For each day in the current month, you now have: the two-digit numeric day of the month, the two-digit numeric month, the one-digit day of the week  1–7 for Sun– Sat , and the two-digit ISO week number. Now, use a CASE expression to determine which day of the week each value of DM  each day of the month  falls into. A portion of the results is shown here:                e n d   w k       f r o m       s e l e c t   d a t e a d d   d a y , - d a y   g e t d a t e       + 1 , g e t d a t e         d y       f r o m   t 1                     x     u n i o n   a l l     s e l e c t   d a t e a d d   d , 1 , d y   ,   d a y   d a t e a d d   d , 1 , d y     ,   m t h ,                   d a t e p a r t   d w , d a t e a d d   d , 1 , d y     ,                   c a s e   w h e n   d a t e p a r t   d w , d a t e a d d   d , 1 , d y       =   1                             t h e n   d a t e p a r t   w k , d a t e a d d   d , 1 , d y     - 1                             e l s e   d a t e p a r t   w k , d a t e a d d   d , 1 , d y                       e n d       f r o m   x     w h e r e   d a t e p a r t   m , d a t e a d d   d , 1 , d y       =   m t h       s e l e c t   *       f r o m   x     D Y                     D M   M T H                   D W   W K   - - - - - - - - - - -   - -   - - -   - - - - - - - - - -   - -   0 1 - J U N - 2 0 0 5   0 1   0 6                       4   2 3   0 2 - J U N - 2 0 0 5   0 2   0 6                       5   2 3   …   2 1 - J U N - 2 0 0 5   2 1   0 6                       3   2 6   2 2 - J U N - 2 0 0 5   2 2   0 6                       4   2 6   …   3 0 - J U N - 2 0 0 5   3 0   0 6                       5   2 7     w i t h   x   d y , d m , m t h , d w , w k             a s       s e l e c t   d y ,                 d a y   d y     d m ,                 d a t e p a r t   m , d y     m t h ,                 d a t e p a r t   d w , d y     d w ,                 c a s e   w h e n   d a t e p a r t   d w , d y     =   1                           t h e n   d a t e p a r t   w w , d y   - 1                           e l s e   d a t e p a r t   w w , d y      Every day in each week is returned as a separate row. In each row, the column containing the day number corresponds to the day of the week. You now need to consolidate the days for each week into one row. Do that by grouping the rows by WK  the ISO week  and applying the MAX function to the different columns. The results will be in calendar format as shown here:                e n d   w k       f r o m       s e l e c t   d a t e a d d   d a y , - d a y   g e t d a t e       + 1 , g e t d a t e         d y       f r o m   t 1                     x     u n i o n   a l l     s e l e c t   d a t e a d d   d , 1 , d y   ,   d a y   d a t e a d d   d , 1 , d y     ,   m t h ,                   d a t e p a r t   d w , d a t e a d d   d , 1 , d y     ,                   c a s e   w h e n   d a t e p a r t   d w , d a t e a d d   d , 1 , d y       =   1                             t h e n   d a t e p a r t   w k , d a t e a d d   d , 1 , d y     - 1                             e l s e   d a t e p a r t   w k , d a t e a d d   d , 1 , d y                       e n d         f r o m   x       w h e r e   d a t e p a r t   m , d a t e a d d   d , 1 , d y       =   m t h       s e l e c t   c a s e   d w   w h e n   2   t h e n   d m   e n d   a s   M o ,                 c a s e   d w   w h e n   3   t h e n   d m   e n d   a s   T u ,                 c a s e   d w   w h e n   4   t h e n   d m   e n d   a s   W e ,                 c a s e   d w   w h e n   5   t h e n   d m   e n d   a s   T h ,                 c a s e   d w   w h e n   6   t h e n   d m   e n d   a s   F r ,                 c a s e   d w   w h e n   7   t h e n   d m   e n d   a s   S a ,                 c a s e   d w   w h e n   1   t h e n   d m   e n d   a s   S u       f r o m   x     W K   M O   T U   W E   T H   F R   S A   S U   - -   - -   - -   - -   - -   - -   - -   - -   2 2               0 1   2 2                     0 2   2 2                           0 3   2 2                                 0 4   2 2                                       0 5   2 3   0 6   2 3         0 7   2 3               0 8   2 3                     0 9   2 3                           1 0   2 3                                 1 1   2 3                                       1 2  9.8 Listing Quarter Start and End Dates for the Year  w i t h   x   d y , d m , m t h , d w , w k             a s       s e l e c t   d y ,                 d a y   d y     d m ,                 d a t e p a r t   m , d y     m t h ,                 d a t e p a r t   d w , d y     d w ,                 c a s e   w h e n   d a t e p a r t   d w , d y     =   1                           t h e n   d a t e p a r t   w w , d y   - 1                           e l s e   d a t e p a r t   w w , d y                   e n d   w k       f r o m       s e l e c t   d a t e a d d   d a y , - d a y   g e t d a t e       + 1 , g e t d a t e         d y       f r o m   t 1                     x     u n i o n   a l l     s e l e c t   d a t e a d d   d , 1 , d y   ,   d a y   d a t e a d d   d , 1 , d y     ,   m t h ,                   d a t e p a r t   d w , d a t e a d d   d , 1 , d y     ,                   c a s e   w h e n   d a t e p a r t   d w , d a t e a d d   d , 1 , d y       =   1                             t h e n   d a t e p a r t   w k , d a t e a d d   d , 1 , d y     - 1                             e l s e   d a t e p a r t   w k , d a t e a d d   d , 1 , d y                       e n d         f r o m   x       w h e r e   d a t e p a r t   m , d a t e a d d   d , 1 , d y       =   m t h       s e l e c t   m a x   c a s e   d w   w h e n   2   t h e n   d m   e n d     a s   M o ,                 m a x   c a s e   d w   w h e n   3   t h e n   d m   e n d     a s   T u ,                 m a x   c a s e   d w   w h e n   4   t h e n   d m   e n d     a s   W e ,                 m a x   c a s e   d w   w h e n   5   t h e n   d m   e n d     a s   T h ,                 m a x   c a s e   d w   w h e n   6   t h e n   d m   e n d     a s   F r ,                 m a x   c a s e   d w   w h e n   7   t h e n   d m   e n d     a s   S a ,                 m a x   c a s e   d w   w h e n   1   t h e n   d m   e n d     a s   S u       f r o m   x     g r o u p   b y   w k     o r d e r   b y   w k     M O   T U   W E   T H   F R   S A   S U   - -   - -   - -   - -   - -   - -   - -               0 1   0 2   0 3   0 4   0 5   0 6   0 7   0 8   0 9   1 0   1 1   1 2   1 3   1 4   1 5   1 6   1 7   1 8   1 9   2 0   2 1   2 2   2 3   2 4   2 5   2 6   2 7   2 8   2 9   3 0  Problem You want to return the start and end dates for each of the four quarters of a given year.  Solution There are four quarters to a year, so you know you will need to generate four rows. After generating the desired number of rows, simply use the date functions supplied by your RDBMS to return to the quarter the start and end dates fall into. Your goal is to produce the following result set  one again, the choice to use the current year is arbitrary :  DB2 Use table EMP and the window function ROW_NUMBER OVER to generate four rows. Alternatively, you can use the WITH clause to generate rows  as many of the recipes do , or you can query against any table with at least four rows. The following solution uses the ROW_NUMBER OVER approach:  Q T R   Q _ S T A R T           Q _ E N D   - - -   - - - - - - - - - - -   - - - - - - - - - - -       1   0 1 - J A N - 2 0 2 0   3 1 - M A R - 2 0 2 0       2   0 1 - A P R - 2 0 2 0   3 0 - J U N - 2 0 2 0       3   0 1 - J U L - 2 0 2 0   3 0 - S E P - 2 0 2 0       4   0 1 - O C T - 2 0 2 0   3 1 - D E C - 2 0 2 0   1   s e l e c t   q u a r t e r   d y - 1   d a y     Q T R ,     2                 d y - 3   m o n t h   Q _ s t a r t ,     3                 d y - 1   d a y   Q _ e n d     4       f r o m         5   s e l e c t     c u r r e n t _ d a t e   -     6                       d a y o f y e a r   c u r r e n t _ d a t e   - 1     d a y     7                         +     r n * 3     m o n t h     d y     8       f r o m         9   s e l e c t   r o w _ n u m b e r     o v e r       r n   1 0       f r o m   e m p   1 1     f e t c h   f i r s t   4   r o w s   o n l y   1 2                       x   1 3                       y  Oracle Use the function ADD_MONTHS to find the start and end dates for each quarter. Use ROWNUM to represent the quarter the start and end dates belong to. The following solution uses table EMP to generate four rows:  PostgreSQL Find the first day of the year based on the current date, and use a recursive CTE to fill in the first date of the remaining three quarters before finding the last day of each quarter:  MySQL Find the first day of the year from the current day, and use a CTE to create four rows, one for each quarter. Use ADDDATE to find the last day of each quarter  three months after the previous last day, or the first day of the quarter minus one :  1   s e l e c t   r o w n u m   q t r ,   2                 a d d _ m o n t h s   t r u n c   s y s d a t e , ' y '   ,   r o w n u m - 1   * 3     q _ s t a r t ,   3                 a d d _ m o n t h s   t r u n c   s y s d a t e , ' y '   , r o w n u m * 3   - 1   q _ e n d   4       f r o m   e m p   5     w h e r e   r o w n u m   < =   4     w i t h   r e c u r s i v e   x     d y , c n t               a s           s e l e c t                   c u r r e n t _ d a t e   - c a s t   e x t r a c t   d a y   f r o m   c u r r e n t _ d a t e   a s   i n t e g e r     + 1   d y                   ,   i d           f r o m   t 1         u n i o n   a l l       s e l e c t   c a s t   d y     +   i n t e r v a l   ' 3   m o n t h s '   a s   d a t e     ,   c n t + 1           f r o m   x         w h e r e   c n t + 1   < =   4           s e l e c t     c a s t   d y   -   i n t e r v a l   ' 3   m o n t h s '   a s   d a t e     a s   Q _ s t a r t                   ,   d y - 1   a s   Q _ e n d       f r o m   x 1               w i t h   r e c u r s i v e   x     d y , c n t     2           a s       3                     s e l e c t    SQL Server Use the recursive WITH clause to generate four rows. Use the function DATEADD to find the start and end dates. Use the function DATEPART to determine which quarter the start and end dates belong to:  Discussion  DB2 The first step is to generate four rows  with values one through four  for each quarter in the year. Inline view X uses the window function  4                   a d d d a t e   c u r r e n t _ d a t e ,   - d a y o f y e a r   c u r r e n t _ d a t e     + 1     d y   5                       , i d   6             f r o m   t 1   7         u n i o n   a l l   8                     s e l e c t   a d d d a t e   d y ,   i n t e r v a l   3   m o n t h     ,   c n t + 1   9                     f r o m   x   1 0                   w h e r e   c n t + 1   < =   4   1 1                     1 2   1 3               s e l e c t   q u a r t e r   a d d d a t e   d y , - 1       Q T R   1 4         ,     d a t e _ a d d   d y ,   i n t e r v a l   - 3   m o n t h     Q _ s t a r t   1 5         ,     a d d d a t e   d y , - 1       Q _ e n d   1 6           f r o m   x   1 7           o r d e r   b y   1 ;   1     w i t h   x     d y , c n t       2         a s         3   s e l e c t   d a t e a d d   d , -   d a t e p a r t   d y , g e t d a t e       - 1   , g e t d a t e       ,     4                 1     5       f r o m   t 1     6     u n i o n   a l l     7   s e l e c t   d a t e a d d   m , 3 , d y   ,   c n t + 1     8       f r o m   x     9     w h e r e   c n t + 1   < =   4   1 0       1 1   s e l e c t   d a t e p a r t   q , d a t e a d d   d , - 1 , d y       Q T R ,   1 2                   d a t e a d d   m , - 3 , d y     Q _ s t a r t ,   1 3                 d a t e a d d   d , - 1 , d y     Q _ e n d   1 4       f r o m   x   1 5   o r d e r   b y   1  ROW_NUMBER OVER and the FETCH FIRST clause to return only four rows from EMP. The results are shown here:  The next step is to find the first day of the year, then add n months to it, where n is three times RN  you are adding 3, 6, 9, and 12 months to the first day of the year . The results are shown here:  At this point, the values for DY are one day after the end date for each quarter. The next step is to get the start and end dates for each quarter. Subtract one day from DY to get the end of each quarter, and subtract three months from DY to get the start of each quarter. Use the QUARTER function on DY-1  the end date for each quarter  to determine which quarter the start and end dates belong to.  s e l e c t   r o w _ n u m b e r     o v e r       r n       f r o m   e m p     f e t c h   f i r s t   4   r o w s   o n l y     R N   - -     1     2     3     4 s e l e c t     c u r r e n t _ d a t e                     d a y o f y e a r   c u r r e n t _ d a t e   - 1     d a y                       +     r n * 3     m o n t h     d y         f r o m       s e l e c t   r o w _ n u m b e r     o v e r       r n       f r o m   e m p     f e t c h   f i r s t   4   r o w s   o n l y                     x     D Y   - - - - - - - - - - -   0 1 - A P R - 2 0 0 5   0 1 - J U L - 2 0 0 5   0 1 - O C T - 2 0 0 5   0 1 - J A N - 2 0 0 5  Oracle The combination of ROWNUM, TRUNC, and ADD_MONTHS makes this solution easy. To find the start of each quarter, simply add n months to the first day of the year, where n is  ROWNUM-1 *3  giving you 0, 3, 6, 9 . To find the end of each quarter, add n months to the first day of the year, where n is ROWNUM*3, and subtract one day. As an aside, when working with quarters, you may also find it useful to use TO_CHAR and or TRUNC with the Q formatting option.  PostgreSQL, MySQL, and SQL Server Like some of the previous recipes, this recipe uses the same structure across three RDMS implementations, but different syntax for the date operations. The first step is to find the first day of the year and then recursively add n months, where n is three times the current iteration  there are four iterations, therefore, you are adding 3*1 months, 3*2 months, etc. , using the DATEADD function or its equivalent. The results are shown here:  The values for DY are one day after the end of each quarter. To get the end of each quarter, simply subtract one day from DY by using the DATEADD  w i t h   x     d y , c n t           a s       s e l e c t   d a t e a d d   d , -   d a t e p a r t   d y , g e t d a t e       - 1   , g e t d a t e       ,                 1       f r o m   t 1     u n i o n   a l l   s e l e c t   d a t e a d d   m , 3 , d y   ,   c n t + 1       f r o m   x     w h e r e   c n t + 1   < =   4       s e l e c t   d y       f r o m   x     D Y   - - - - - - - - - - -   0 1 - A P R - 2 0 2 0   0 1 - J U L - 2 0 2 0   0 1 - O C T - 2 0 2 0   0 1 - J A N - 2 0 2 0  function. To find the start of each quarter, use the DATEADD function to subtract three months from DY. Use the DATEPART function on the end date for each quarter to determine which quarter the start and end dates belong to or its equivalent. If you are using PostgreSQL, note that you need CAST to ensure data types align after performing adding the three months to the start date, or the data types will different, and the UNION ALL in the recursive CTE will fail.  9.9 Determining Quarter Start and End Dates for a Given Quarter  Problem When given a year and quarter in the format of YYYYQ  four-digit year, one-digit quarter , you want to return the quarter’s start and end dates.  Solution The key to this solution is to find the quarter by using the modulus function on the YYYYQ value.  As an alternative to modulo, since the year format is four digits, you can simply substring out the last digit to get the quarter.  Once you have the quarter, simply multiply by three to get the ending month for the quarter. In the solutions that follow, inline view X will return all four year and quarter combinations. The result set for inline view X is as follows:  s e l e c t   2 0 0 5 1   a s   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 2   a s   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 3   a s   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 4   a s   y r q   f r o m   t 1           Y R Q   - - - - - - -       2 0 0 5 1       2 0 0 5 2       2 0 0 5 3       2 0 0 5 4  DB2 Use the function SUBSTR to return the year from inline view X. Use the MOD function to determine which quarter you are looking for:  Oracle Use the function SUBSTR to return the year from inline view X. Use the MOD function to determine which quarter you are looking for:  PostgreSQL Use the function SUBSTR to return the year from the inline view X. Use the MOD function to determine which quarter you are looking for:    1   s e l e c t     q _ e n d - 2   m o n t h     q _ s t a r t ,     2                   q _ e n d + 1   m o n t h   - 1   d a y   q _ e n d     3       f r o m         4   s e l e c t   d a t e   s u b s t r   c a s t   y r q   a s   c h a r   4     , 1 , 4       ' - '       5                 r t r i m   c a s t   m o d   y r q , 1 0   * 3   a s   c h a r   2           ' - 1 '     q _ e n d     6       f r o m         7   s e l e c t   2 0 0 5 1   y r q   f r o m   t 1   u n i o n   a l l     8   s e l e c t   2 0 0 5 2   y r q   f r o m   t 1   u n i o n   a l l     9   s e l e c t   2 0 0 5 3   y r q   f r o m   t 1   u n i o n   a l l   1 0   s e l e c t   2 0 0 5 4   y r q   f r o m   t 1   1 1                     x   1 2                     y   1   s e l e c t   a d d _ m o n t h s   q _ e n d , - 2     q _ s t a r t ,     2                 l a s t _ d a y   q _ e n d     q _ e n d     3       f r o m         4   s e l e c t   t o _ d a t e   s u b s t r   y r q , 1 , 4     m o d   y r q , 1 0   * 3 , ' y y y y m m '     q _ e n d     5       f r o m         6   s e l e c t   2 0 0 5 1   y r q   f r o m   d u a l   u n i o n   a l l     7   s e l e c t   2 0 0 5 2   y r q   f r o m   d u a l   u n i o n   a l l     8   s e l e c t   2 0 0 5 3   y r q   f r o m   d u a l   u n i o n   a l l     9   s e l e c t   2 0 0 5 4   y r q   f r o m   d u a l   1 0                     x   1 1                     y   1   s e l e c t   d a t e   q _ e n d -   2 * i n t e r v a l   ' 1   m o n t h '       a s   q _ s t a r t ,     2                 d a t e   q _ e n d + i n t e r v a l   ' 1   m o n t h ' - i n t e r v a l   ' 1   d a y '     a s   q _ e n d     3       f r o m         4   s e l e c t   t o _ d a t e   s u b s t r   y r q , 1 , 4     m o d   y r q , 1 0   * 3 , ' y y y y m m '     a s   q _ e n d    MySQL Use the function SUBSTR to return the year from the inline view X. Use the MOD function to determine which quarter you are looking for:  SQL Server Use the function SUBSTRING to return the year from the inline view X. Use the modulus function  %  to determine which quarter you are looking for:    5       f r o m         6   s e l e c t   2 0 0 5 1   a s   y r q   f r o m   t 1   u n i o n   a l l     7   s e l e c t   2 0 0 5 2   a s   y r q   f r o m   t 1   u n i o n   a l l     8   s e l e c t   2 0 0 5 3   a s   y r q   f r o m   t 1   u n i o n   a l l     9   s e l e c t   2 0 0 5 4   a s   y r q   f r o m   t 1   1 0                     x   1 1                     y   1   s e l e c t   d a t e _ a d d       2                   a d d d a t e   q _ e n d , - d a y   q _ e n d   + 1   ,     3                                 i n t e r v a l   - 2   m o n t h     q _ s t a r t ,     4                 q _ e n d     5       f r o m         6   s e l e c t   l a s t _ d a y       7           s t r _ t o _ d a t e       8                     c o n c a t       9                     s u b s t r   y r q , 1 , 4   , m o d   y r q , 1 0   * 3   , ' % Y % m '       q _ e n d   1 0       f r o m       1 1   s e l e c t   2 0 0 5 1   a s   y r q   f r o m   t 1   u n i o n   a l l   1 2   s e l e c t   2 0 0 5 2   a s   y r q   f r o m   t 1   u n i o n   a l l   1 3   s e l e c t   2 0 0 5 3   a s   y r q   f r o m   t 1   u n i o n   a l l   1 4   s e l e c t   2 0 0 5 4   a s   y r q   f r o m   t 1   1 5                     x   1 6                     y   1   s e l e c t   d a t e a d d   m , - 2 , q _ e n d     q _ s t a r t ,     2                 d a t e a d d   d , - 1 , d a t e a d d   m , 1 , q _ e n d       q _ e n d     3       f r o m         4   s e l e c t   c a s t   s u b s t r i n g   c a s t   y r q   a s   v a r c h a r   , 1 , 4   + ' - ' +     5                 c a s t   y r q % 1 0 * 3   a s   v a r c h a r   + ' - 1 '   a s   d a t e t i m e     q _ e n d     6       f r o m         7   s e l e c t   2 0 0 5 1   a s   y r q   f r o m   t 1   u n i o n   a l l     8   s e l e c t   2 0 0 5 2   a s   y r q   f r o m   t 1   u n i o n   a l l     9   s e l e c t   2 0 0 5 2   a s   y r q   f r o m   t 1   u n i o n   a l l    Discussion  DB2 The first step is to find the year and quarter you are working with. Substring out the year from inline view X  X.YRQ  using the SUBSTR function. To get the quarter, use modulus 10 on YRQ. Once you have the quarter, multiply by three to get the end month for the quarter. The results are shown here:  At this point you have the year and end month for each quarter. Use those values to construct a date, specifically, the first day of the last month for each quarter. Use the concatenation operator  to glue together the year and month, and then use the DATE function to convert to a date:  1 0   s e l e c t   2 0 0 5 4   a s   y r q   f r o m   t 1   1 1                     x   1 2                     y s e l e c t   s u b s t r   c a s t   y r q   a s   c h a r   4     , 1 , 4     y r ,                 m o d   y r q , 1 0   * 3   m t h       f r o m       s e l e c t   2 0 0 5 1   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 2   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 3   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 4   y r q   f r o m   t 1                     x     Y R             M T H   - - - -   - - - - - -   2 0 0 5             3   2 0 0 5             6   2 0 0 5             9   2 0 0 5           1 2 s e l e c t   d a t e   s u b s t r   c a s t   y r q   a s   c h a r   4     , 1 , 4       ' - '                   r t r i m   c a s t   m o d   y r q , 1 0   * 3   a s   c h a r   2           ' - 1 '     q _ e n d       f r o m       s e l e c t   2 0 0 5 1   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 2   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 3   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 4   y r q   f r o m   t 1    The values for Q_END are the first day of the last month of each quarter. To get to the last day of the month, add one month to Q_END and then subtract one day. To find the start date for each quarter, subtract two months from Q_END.  Oracle The first step is to find the year and quarter you are working with. Substring out the year from inline view X  X.YRQ  using the SUBSTR function. To get the quarter, use modulus 10 on YRQ. Once you have the quarter, multiply by three to get the end month for the quarter. The results are shown here:  At this point you have the year and end month for each quarter. Use those values to construct a date, specifically, the first day of the last month for each quarter. Use the concatenation operator  to glue together the year and month, and then use the TO_DATE function to convert to a date:                    x     Q _ E N D   - - - - - - - - - - -   0 1 - M A R - 2 0 0 5   0 1 - J U N - 2 0 0 5   0 1 - S E P - 2 0 0 5   0 1 - D E C - 2 0 0 5 s e l e c t   s u b s t r   y r q , 1 , 4     y r ,   m o d   y r q , 1 0   * 3   m t h       f r o m       s e l e c t   2 0 0 5 1   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 2   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 3   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 4   y r q   f r o m   t 1                     x     Y R             M T H   - - - -   - - - - - -   2 0 0 5             3   2 0 0 5             6   2 0 0 5             9   2 0 0 5           1 2  The values for Q_END are the first day of the last month of each quarter. To get to the last day of the month, use the LAST_DAY function on Q_END. To find the start date for each quarter, subtract two months from Q_END using the ADD_MONTHS function.  PostgreSQL The first step is to find the year and quarter you are working with. Substring out the year from inline view X  X.YRQ  using the SUBSTR function. To get the quarter, use modulus 10 on YRQ. Once you have the quarter, multiply by 3 to get the end month for the quarter. The results are shown here:  s e l e c t   t o _ d a t e   s u b s t r   y r q , 1 , 4     m o d   y r q , 1 0   * 3 , ' y y y y m m '     q _ e n d       f r o m       s e l e c t   2 0 0 5 1   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 2   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 3   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 4   y r q   f r o m   t 1                     x     Q _ E N D   - - - - - - - - - - -   0 1 - M A R - 2 0 0 5   0 1 - J U N - 2 0 0 5   0 1 - S E P - 2 0 0 5   0 1 - D E C - 2 0 0 5 s e l e c t   s u b s t r   y r q , 1 , 4     y r ,   m o d   y r q , 1 0   * 3   m t h       f r o m       s e l e c t   2 0 0 5 1   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 2   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 3   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 4   y r q   f r o m   t 1                     x     Y R                 M T H   - - - -     - - - - - - -   2 0 0 5                 3   2 0 0 5                 6   2 0 0 5                 9   2 0 0 5               1 2  At this point, you have the year and end month for each quarter. Use those values to construct a date, specifically, the first day of the last month for each quarter. Use the concatenation operator  to glue together the year and month, and then use the TO_ DATE function to convert to a date:  The values for Q_END are the first day of the last month of each quarter. To get to the last day of the month, add one month to Q_END and subtract one day. To find the start date for each quarter, subtract two months from Q_END. Cast the final result as dates.  MySQL The first step is to find the year and quarter you are working with. Substring out the year from inline view X  X.YRQ  using the SUBSTR function. To get the quarter, use modulus 10 on YRQ. Once you have the quarter, multiply by three to get the end month for the quarter. The results are shown here:  s e l e c t   t o _ d a t e   s u b s t r   y r q , 1 , 4     m o d   y r q , 1 0   * 3 , ' y y y y m m '     q _ e n d       f r o m       s e l e c t   2 0 0 5 1   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 2   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 3   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 4   y r q   f r o m   t 1                     x     Q _ E N D   - - - - - - - - - - -   0 1 - M A R - 2 0 0 5   0 1 - J U N - 2 0 0 5   0 1 - S E P - 2 0 0 5   0 1 - D E C - 2 0 0 5 s e l e c t   s u b s t r   y r q , 1 , 4     y r ,   m o d   y r q , 1 0   * 3   m t h       f r o m       s e l e c t   2 0 0 5 1   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 2   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 3   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 4   y r q   f r o m   t 1                     x      At this point, you have the year and end month for each quarter. Use those values to construct a date, specifically, the last day of each quarter. Use the CONCAT function to glue together the year and month, and then use the STR_TO_DATE function to convert to a date. Use the LAST_DAY function to find the last day for each quarter:  Because you already have the end of each quarter, all that’s left is to find the start date for each quarter. Use the DAY function to return the day of the month the end of each quarter falls on, and subtract that from Q_END using the ADDDATE function to give you the end of the prior month; add one day to bring you to the first day of the last month of each quarter. The last step is to use the DATE_ADD function to subtract two months from the first day of the last month of each quarter to get you to the start date for each quarter.  SQL Server  Y R             M T H   - - - -   - - - - - -   2 0 0 5             3   2 0 0 5             6   2 0 0 5             9   2 0 0 5           1 2 s e l e c t   l a s t _ d a y             s t r _ t o _ d a t e                       c o n c a t                       s u b s t r   y r q , 1 , 4   , m o d   y r q , 1 0   * 3   , ' % Y % m '       q _ e n d       f r o m       s e l e c t   2 0 0 5 1   a s   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 2   a s   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 3   a s   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 4   a s   y r q   f r o m   t 1                     x     Q _ E N D   - - - - - - - - - - -   3 1 - M A R - 2 0 0 5   3 0 - J U N - 2 0 0 5   3 0 - S E P - 2 0 0 5   3 1 - D E C - 2 0 0 5  The first step is to find the year and quarter you are working with. Substring out the year from inline view X  X.YRQ  using the SUBSTRING function. To get the quarter, use modulus 10 on YRQ. Once you have the quarter, multiply by three to get the end month for the quarter. The results are shown here:  At this point, you have the year and end month for each quarter. Use those values to construct a date, specifically, the first day of the last month for each quarter. Use the concatenation operator + to glue together the year and month, and then use the CAST function to convert to a date:  s e l e c t   s u b s t r i n g   y r q , 1 , 4     y r ,   y r q % 1 0 * 3   m t h       f r o m       s e l e c t   2 0 0 5 1   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 2   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 3   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 4   y r q   f r o m   t 1                     x     Y R                 M T H   - - - -       - - - - - -   2 0 0 5                 3   2 0 0 5                 6   2 0 0 5                 9   2 0 0 5               1 2 s e l e c t   c a s t   s u b s t r i n g   c a s t   y r q   a s   v a r c h a r   , 1 , 4   + ' - ' +                 c a s t   y r q % 1 0 * 3   a s   v a r c h a r   + ' - 1 '   a s   d a t e t i m e     q _ e n d       f r o m       s e l e c t   2 0 0 5 1   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 2   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 3   y r q   f r o m   t 1   u n i o n   a l l   s e l e c t   2 0 0 5 4   y r q   f r o m   t 1                     x     Q _ E N D   - - - - - - - - - - -   0 1 - M A R - 2 0 0 5   0 1 - J U N - 2 0 0 5   0 1 - S E P - 2 0 0 5   0 1 - D E C - 2 0 0 5  The values for Q_END are the first day of the last month of each quarter. To get to the last day of the month, add one month to Q_END and subtract one day using the DATEADD function. To find the start date for each quarter, subtract two months from Q_END using the DATEADD function.  9.10 Filling in Missing Dates  Problem You need to generate a row for every date  or every month, week, or year  within a given range. Such rowsets are often used to generate summary reports. For example, you want to count the number of employees hired every month of every year in which any employee has been hired. Examining the dates of all the employees hired, there have been hirings from 2000 to 2003:  You want to determine the number of employees hired each month from 2000 to 2003. A portion of the desired result set is shown here:  s e l e c t   d i s t i n c t                 e x t r a c t   y e a r   f r o m   h i r e d a t e     a s   y e a r       f r o m   e m p     Y E A R   - - - - -     2 0 0 0     2 0 0 1     2 0 0 2     2 0 0 3 M T H                     N U M _ H I R E D   - - - - - - - - - - -   - - - - - - - - - -   0 1 - J A N - 2 0 0 1                     0   0 1 - F E B - 2 0 0 1                     2   0 1 - M A R - 2 0 0 1                     0   0 1 - A P R - 2 0 0 1                     1   0 1 - M A Y - 2 0 0 1                     1   0 1 - J U N - 2 0 0 1                     1   0 1 - J U L - 2 0 0 1                     0    Solution The trick here is that you want to return a row for each month even if no employee was hired  i.e., the count would be zero . Because there isn’t an employee hired every month between 2000 and 2003, you must generate those months yourself and then outer join to table EMP on HIREDATE  truncating the actual HIREDATE to its month so it can match the generated months when possible .  DB2 Use the recursive WITH clause to generate every month  the first day of each month from January 1, 2000, to December 1, 2003 . Once you have all the months for the required range of dates, outer join to table EMP and use the aggregate function COUNT to count the number of hires for each month:  Oracle  0 1 - A U G - 2 0 0 1                     0   0 1 - S E P - 2 0 0 1                     2   0 1 - O C T - 2 0 0 1                     0   0 1 - N O V - 2 0 0 1                     1   0 1 - D E C - 2 0 0 1                     2   1       w i t h   x     s t a r t _ d a t e , e n d _ d a t e       2           a s         3   s e l e c t     m i n   h i r e d a t e       4                     d a y o f y e a r   m i n   h i r e d a t e       d a y   + 1   d a y     s t a r t _ d a t e ,     5                   m a x   h i r e d a t e       6                     d a y o f y e a r   m a x   h i r e d a t e       d a y   + 1   d a y     + 1   y e a r   e n d _ d a t e     7       f r o m   e m p     8     u n i o n   a l l     9   s e l e c t   s t a r t _ d a t e   + 1   m o n t h ,   e n d _ d a t e   1 0       f r o m   x   1 1     w h e r e     s t a r t _ d a t e   + 1   m o n t h     <   e n d _ d a t e   1 2       1 3   s e l e c t   x . s t a r t _ d a t e   m t h ,   c o u n t   e . h i r e d a t e     n u m _ h i r e d   1 4       f r o m   x   l e f t   j o i n   e m p   e   1 5           o n     x . s t a r t _ d a t e   =     e . h i r e d a t e -   d a y   h i r e d a t e   - 1     d a y       1 6     g r o u p   b y   x . s t a r t _ d a t e   1 7     o r d e r   b y   1  Use the CONNECT BY clause to generate each month between 2000 and 2003. Then outer join to table EMP and use the aggregate function COUNT to count the number of employees hired in each month:  PostgreSQL Use CTE to fill in the months since the earliest hire and then LEFT OUTER JOIN on the EMP table using the month and year of each generated month to enable the COUNT of the number of hiredates in each period:    1       w i t h   x     2           a s         3   s e l e c t   a d d _ m o n t h s   s t a r t _ d a t e , l e v e l - 1     s t a r t _ d a t e     4       f r o m         5   s e l e c t   m i n   t r u n c   h i r e d a t e , ' y '       s t a r t _ d a t e ,     6                 a d d _ m o n t h s   m a x   t r u n c   h i r e d a t e , ' y '     , 1 2     e n d _ d a t e     7       f r o m   e m p     8                       9     c o n n e c t   b y   l e v e l   < =   m o n t h s _ b e t w e e n   e n d _ d a t e , s t a r t _ d a t e     1 0       1 1   s e l e c t   x . s t a r t _ d a t e   M T H ,   c o u n t   e . h i r e d a t e     n u m _ h i r e d   1 2       f r o m   x   l e f t   j o i n   e m p   e   1 3           o n     x . s t a r t _ d a t e   =   t r u n c   e . h i r e d a t e , ' m m '       1 4     g r o u p   b y   x . s t a r t _ d a t e   1 5     o r d e r   b y   1   w i t h   r e c u r s i v e   x     s t a r t _ d a t e ,   e n d _ d a t e     a s               s e l e c t           c a s t   m i n   h i r e d a t e     -     c a s t   e x t r a c t   d a y   f r o m   m i n   h i r e d a t e               a s   i n t e g e r     -   1     a s   d a t e             ,   m a x   h i r e d a t e             f r o m   e m p       u n i o n   a l l           s e l e c t   c a s t   s t a r t _ d a t e   +   i n t e r v a l   ' 1   m o n t h '   a s   d a t e             ,   e n d _ d a t e           f r o m   x           w h e r e   s t a r t _ d a t e   <   e n d _ d a t e             s e l e c t   x . s t a r t _ d a t e , c o u n t   h i r e d a t e       f r o m   x   l e f t   j o i n   e m p       o n     e x t r a c t   m o n t h   f r o m   s t a r t _ d a t e     =    MySQL Use a recursive CTE to generate each month between the start and end dates, and then check for hires by using an outer join to table EMP:  SQL Server Use the recursive WITH clause to generate every month  the first day of each month from January 1, 2000, to December 1, 2003 . Once you have all the months for the required range of dates, outer join to table EMP and use the aggregate function COUNT to count the number of hires for each month:                            e x t r a c t   m o n t h   f r o m   e m p . h i r e d a t e           a n d   e x t r a c t   y e a r   f r o m   s t a r t _ d a t e           =   e x t r a c t   y e a r   f r o m   e m p . h i r e d a t e           g r o u p   b y   x . s t a r t _ d a t e       o r d e r   b y   1   w i t h   r e c u r s i v e   x     s t a r t _ d a t e , e n d _ d a t e                 a s                             s e l e c t                       a d d d a t e   m i n   h i r e d a t e   ,                       - d a y o f y e a r   m i n   h i r e d a t e     + 1       s t a r t _ d a t e                       , a d d d a t e   m a x   h i r e d a t e   ,                       - d a y o f y e a r   m a x   h i r e d a t e     + 1       e n d _ d a t e                       f r o m   e m p                 u n i o n   a l l                       s e l e c t   d a t e _ a d d   s t a r t _ d a t e , i n t e r v a l   1   m o n t h                         ,   e n d _ d a t e                       f r o m   x                       w h e r e   d a t e _ a d d   s t a r t _ d a t e ,   i n t e r v a l   1   m o n t h     <   e n d _ d a t e                                   s e l e c t   x . s t a r t _ d a t e   m t h ,   c o u n t   e . h i r e d a t e     n u m _ h i r e d                 f r o m   x   l e f t   j o i n   e m p   e                 o n     e x t r a c t   y e a r _ m o n t h   f r o m   s t a r t _ d a t e                           =                         e x t r a c t   y e a r _ m o n t h   f r o m   e . h i r e d a t e                     g r o u p   b y   x . s t a r t _ d a t e                 o r d e r   b y   1 ;  Discussion  DB2 The first step is to generate every month  actually the first day of each month  from 2000 to 2003. Start using the DAYOFYEAR function on the MIN and MAX HIREDATEs to find the boundary months:  Your next step is to repeatedly add months to START_DATE to return all the months necessary for the final result set. The value for END_DATE is one day more than it should be. This is OK. As you recursively add months to START_DATE, you can stop before you hit END_DATE. A portion of the months created is shown here:  1       w i t h   x     s t a r t _ d a t e , e n d _ d a t e     2           a s       3   s e l e c t     m i n   h i r e d a t e     -   4                     d a t e p a r t   d y , m i n   h i r e d a t e     + 1     s t a r t _ d a t e ,   5                 d a t e a d d   y y , 1 ,   6                     m a x   h i r e d a t e     -   7                     d a t e p a r t   d y , m a x   h i r e d a t e     + 1       e n d _ d a t e   8       f r o m   e m p   9     u n i o n   a l l   1 0   s e l e c t   d a t e a d d   m m , 1 , s t a r t _ d a t e   ,   e n d _ d a t e   1 1       f r o m   x   1 2     w h e r e   d a t e a d d   m m , 1 , s t a r t _ d a t e     <   e n d _ d a t e   1 3       1 4   s e l e c t   x . s t a r t _ d a t e   m t h ,   c o u n t   e . h i r e d a t e     n u m _ h i r e d   1 5       f r o m   x   l e f t   j o i n   e m p   e   1 6           o n     x . s t a r t _ d a t e   =   1 7                         d a t e a d d   d d , - d a y   e . h i r e d a t e   + 1 , e . h i r e d a t e       1 8   g r o u p   b y   x . s t a r t _ d a t e   1 9   o r d e r   b y   1 s e l e c t     m i n   h i r e d a t e                       d a y o f y e a r   m i n   h i r e d a t e       d a y   + 1   d a y     s t a r t _ d a t e ,                   m a x   h i r e d a t e                       d a y o f y e a r   m a x   h i r e d a t e       d a y   + 1   d a y     + 1   y e a r   e n d _ d a t e       f r o m   e m p     S T A R T _ D A T E     E N D _ D A T E   - - - - - - - - - - -   - - - - - - - - - - -   0 1 - J A N - 2 0 0 0   0 1 - J A N - 2 0 0 4  At this point, you have all the months you need, and you can simply outer join to EMP.HIREDATE. Because the day for each START_DATE is the first of the month, truncate EMP.HIREDATE to the first day of its month. Finally, use the aggregate function COUNT on EMP.HIREDATE.  Oracle The first step is to generate the first day of every for every month from 2000 to 2003. Start by using TRUNC and ADD_MONTHS together with the MIN and MAX HIREDATE values to find the boundary months:  w i t h   x     s t a r t _ d a t e , e n d _ d a t e         a s       s e l e c t     m i n   h i r e d a t e                       d a y o f y e a r   m i n   h i r e d a t e       d a y   + 1   d a y     s t a r t _ d a t e ,                   m a x   h i r e d a t e                       d a y o f y e a r   m a x   h i r e d a t e       d a y   + 1   d a y     + 1   y e a r   e n d _ d a t e       f r o m   e m p     u n i o n   a l l   s e l e c t   s t a r t _ d a t e   + 1   m o n t h ,   e n d _ d a t e       f r o m   x     w h e r e     s t a r t _ d a t e   + 1   m o n t h     <   e n d _ d a t e       s e l e c t   *       f r o m   x     S T A R T _ D A T E     E N D _ D A T E   - - - - - - - - - - -   - - - - - - - - - - -   0 1 - J A N - 2 0 0 0   0 1 - J A N - 2 0 0 4   0 1 - F E B - 2 0 0 0   0 1 - J A N - 2 0 0 4   0 1 - M A R - 2 0 0 0   0 1 - J A N - 2 0 0 4   …   0 1 - O C T - 2 0 0 3   0 1 - J A N - 2 0 0 4   0 1 - N O V - 2 0 0 3   0 1 - J A N - 2 0 0 4   0 1 - D E C - 2 0 0 3   0 1 - J A N - 2 0 0 4 s e l e c t   m i n   t r u n c   h i r e d a t e , ' y '       s t a r t _ d a t e ,                 a d d _ m o n t h s   m a x   t r u n c   h i r e d a t e , ' y '     , 1 2     e n d _ d a t e       f r o m   e m p     S T A R T _ D A T E     E N D _ D A T E   - - - - - - - - - - -   - - - - - - - - - - -   0 1 - J A N - 2 0 0 0   0 1 - J A N - 2 0 0 4  Then repeatedly add months to START_DATE to return all the months necessary for the final result set. The value for END_DATE is one day more than it should be, which is OK. As you recursively add months to START_DATE, you can stop before you hit END_DATE. A portion of the months created is shown here:  At this point, you have all the months you need, and you can simply outer join to EMP.HIREDATE. Because the day for each START_DATE is the first of the month, truncate EMP.HIREDATE to the first day of the month it is in. The final step is to use the aggregate function COUNT on EMP.HIREDATE.  PostgreSQL This solution uses a CTE to generate the months you need and is similar to the subsequent solutions for MySQL and SQL Server. The first step is to create the boundary dates using aggregate functions. You could simply find earliest and latest hire dates using the MIN   and MAX   functions, but the  w i t h   x   a s       s e l e c t   a d d _ m o n t h s   s t a r t _ d a t e , l e v e l - 1     s t a r t _ d a t e       f r o m       s e l e c t   m i n   t r u n c   h i r e d a t e , ' y '       s t a r t _ d a t e ,                 a d d _ m o n t h s   m a x   t r u n c   h i r e d a t e , ' y '     , 1 2     e n d _ d a t e       f r o m   e m p                       c o n n e c t   b y   l e v e l   < =   m o n t h s _ b e t w e e n   e n d _ d a t e , s t a r t _ d a t e         s e l e c t   *       f r o m   x     S T A R T _ D A T E   - - - - - - - - - - -   0 1 - J A N - 2 0 0 0   0 1 - F E B - 2 0 0 0   0 1 - M A R - 2 0 0 0   …   0 1 - O C T - 2 0 0 3   0 1 - N O V - 2 0 0 3   0 1 - D E C - 2 0 0 3  output makes more sense if you find the first day of the month containing the earliest hire date.  MySQL First, find the boundary dates by using the aggregate functions MIN and MAX along with the DAYOFYEAR and ADDDATE functions. The result set shown here is from inline view X:  Next, increment MAX_HD to the last month of the year by the CTE:  w i t h   r e c u r s i v e   x     s t a r t _ d a t e , e n d _ d a t e                 a s                           s e l e c t                         a d d d a t e   m i n   h i r e d a t e   ,                       - d a y o f y e a r   m i n   h i r e d a t e     + 1       s t a r t _ d a t e                       , a d d d a t e   m a x   h i r e d a t e   ,                       - d a y o f y e a r   m a x   h i r e d a t e     + 1       e n d _ d a t e                       f r o m   e m p                 u n i o n   a l l                 s e l e c t   d a t e _ a d d   s t a r t _ d a t e , i n t e r v a l   1   m o n t h                   ,   e n d _ d a t e                 f r o m   x                 w h e r e   d a t e _ a d d   s t a r t _ d a t e ,   i n t e r v a l   1   m o n t h     <   e n d _ d a t e                           s e l e c t   *   f r o m   x   s e l e c t   a d d d a t e   m i n   h i r e d a t e   , - d a y o f y e a r   m i n   h i r e d a t e     + 1     m i n _ h d ,                   a d d d a t e   m a x   h i r e d a t e   , - d a y o f y e a r   m a x   h i r e d a t e     + 1     m a x _ h d         f r o m   e m p       M I N _ H D             M A X _ H D     - - - - - - - - - - -   - - - - - - - - - - -     0 1 - J A N - 2 0 0 0   0 1 - J A N - 2 0 0 3 M T H   - - - - - - - - - - -   0 1 - J A N - 2 0 0 0   0 1 - F E B - 2 0 0 0   0 1 - M A R - 2 0 0 0   …   0 1 - O C T - 2 0 0 3   0 1 - N O V - 2 0 0 3   0 1 - D E C - 2 0 0 3  Now that you have all the months you need for the final result set, outer join to EMP.HIREDATE  be sure to truncate EMP.HIREDATE to the first day of the month  and use the aggregate function COUNT on EMP.HIREDATE to count the number of hires in each month.  SQL Server Begin by generating every month  actually, the first day of each month  from 2000 to 2003. Then find the boundary months by applying the DAYOFYEAR function to the MIN and MAX HIREDATEs:  Your next step is to repeatedly add months to START_DATE to return all the months necessary for the final result set. The value for END_DATE is one day more than it should be, which is OK, as you can stop recursively adding months to START_DATE before you hit END_DATE. A portion of the months created is shown here:  s e l e c t     m i n   h i r e d a t e     -                     d a t e p a r t   d y , m i n   h i r e d a t e     + 1     s t a r t _ d a t e ,                 d a t e a d d   y y , 1 ,                     m a x   h i r e d a t e     -                     d a t e p a r t   d y , m a x   h i r e d a t e     + 1       e n d _ d a t e       f r o m   e m p     S T A R T _ D A T E     E N D _ D A T E   - - - - - - - - - - -   - - - - - - - - - - -   0 1 - J A N - 2 0 0 0   0 1 - J A N - 2 0 0 4 w i t h   x     s t a r t _ d a t e , e n d _ d a t e         a s       s e l e c t     m i n   h i r e d a t e     -                     d a t e p a r t   d y , m i n   h i r e d a t e     + 1     s t a r t _ d a t e ,                 d a t e a d d   y y , 1 ,                     m a x   h i r e d a t e     -                     d a t e p a r t   d y , m a x   h i r e d a t e     + 1       e n d _ d a t e       f r o m   e m p     u n i o n   a l l   s e l e c t   d a t e a d d   m m , 1 , s t a r t _ d a t e   ,   e n d _ d a t e       f r o m   x     w h e r e   d a t e a d d   m m , 1 , s t a r t _ d a t e     <   e n d _ d a t e       s e l e c t   *    At this point, you have all the months you need. Simply outer join to EMP.HIREDATE. Because the day for each START_DATE is the first of the month, truncate EMP.HIREDATE to the first day of the month. The final step is to use the aggregate function COUNT on EMP.HIREDATE.  9.11 Searching on Specific Units of Time  Problem You want to search for dates that match a given month, day of the week, or some other unit of time. For example, you want to find all employees hired in February or December, as well as employees hired on a Tuesday.  Solution Use the functions supplied by your RDBMS to find month and weekday names for dates. This particular recipe can be useful in various places. Consider, if you wanted to search HIREDATEs but wanted to ignore the year by extracting the month  or any other part of the HIREDATE you are interested in , you can do so. The example solutions to this problem search by month and weekday name. By studying the date formatting functions provided by your RDBMS, you can easily modify these solutions to search by year, quarter, combination of year and quarter, month and year combination, etc.      f r o m   x     S T A R T _ D A T E     E N D _ D A T E   - - - - - - - - - - -   - - - - - - - - - - -   0 1 - J A N - 2 0 0 0   0 1 - J A N - 2 0 0 4   0 1 - F E B - 2 0 0 0   0 1 - J A N - 2 0 0 4   0 1 - M A R - 2 0 0 0   0 1 - J A N - 2 0 0 4   …   0 1 - O C T - 2 0 0 3   0 1 - J A N - 2 0 0 4   0 1 - N O V - 2 0 0 3   0 1 - J A N - 2 0 0 4   0 1 - D E C - 2 0 0 3   0 1 - J A N - 2 0 0 4  DB2 and MySQL Use the functions MONTHNAME and DAYNAME to find the name of the month and weekday an employee was hired, respectively:  Oracle and PostgreSQL Use the function TO_CHAR to find the names of the month and weekday an employee was hired. Use the function RTRIM to remove trailing whitespaces:  SQL Server Use the function DATENAME to find the names of the month and weekday an employee was hired:  Discussion The key to each solution is simply knowing which functions to use and how to use them. To verify what the return values are, put the functions in the SELECT clause and examine the output. Listed here is the result set for employees in DEPTNO 10  using SQL Server syntax :  1   s e l e c t   e n a m e   2       f r o m   e m p   3   w h e r e   m o n t h n a m e   h i r e d a t e     i n     ' F e b r u a r y ' , ' D e c e m b e r '     4         o r   d a y n a m e   h i r e d a t e     =   ' T u e s d a y ' 1   s e l e c t   e n a m e   2       f r o m   e m p   3   w h e r e   r t r i m   t o _ c h a r   h i r e d a t e , ' m o n t h '       i n     ' f e b r u a r y ' , ' d e c e m b e r '     4         o r   r t r i m   t o _ c h a r   h i r e d a t e , ' d a y '       =   ' t u e s d a y ' 1   s e l e c t   e n a m e   2       f r o m   e m p   3   w h e r e   d a t e n a m e   m , h i r e d a t e     i n     ' F e b r u a r y ' , ' D e c e m b e r '     4         o r   d a t e n a m e   d w , h i r e d a t e     =   ' T u e s d a y ' s e l e c t   e n a m e , d a t e n a m e   m , h i r e d a t e     m t h , d a t e n a m e   d w , h i r e d a t e     d w       f r o m   e m p     w h e r e   d e p t n o   =   1 0    Once you know what the function s  return, finding rows using the functions shown in each of the solutions is easy.  9.12 Comparing Records Using Specific Parts of a Date  Problem You want to find which employees have been hired on the same month and weekday. For example, if an employee was hired on Monday, March 10, 2008, and another employee was hired on Monday, March 2, 2001, you want those two to come up as a match since the day of week and month match. In table EMP, only three employees meet this requirement. You want to return the following result set:  Solution Because you want to compare one employee’s HIREDATE with the HIREDATE of the other employees, you will need to self-join table EMP. That makes each possible combination of HIREDATEs available for you to compare. Then, simply extract the weekday and month from each HIREDATE and compare.  DB2    E N A M E       M T H                 D W   - - - - - -     - - - - - - - - -     - - - - - - - - - - -   C L A R K       J u n e               T u e s d a y   K I N G         N o v e m b e r       T u e s d a y   M I L L E R     J a n u a r y         S a t u r d a y M S G   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   J A M E S   w a s   h i r e d   o n   t h e   s a m e   m o n t h   a n d   w e e k d a y   a s   F O R D   S C O T T   w a s   h i r e d   o n   t h e   s a m e   m o n t h   a n d   w e e k d a y   a s   J A M E S   S C O T T   w a s   h i r e d   o n   t h e   s a m e   m o n t h   a n d   w e e k d a y   a s   F O R D  After self-joining table EMP, use the function DAYOFWEEK to return the numeric day of the week. Use the function MONTHNAME to return the name of the month:  Oracle and PostgreSQL After self-joining table EMP, use the TO_CHAR function to format the HIREDATE into weekday and month for comparison:  MySQL After self-joining table EMP, use the DATE_FORMAT function to format the HIREDATE into weekday and month for comparison:  SQL Server  1   s e l e c t   a . e n a m e       2                 '   w a s   h i r e d   o n   t h e   s a m e   m o n t h   a n d   w e e k d a y   a s   '     3                 b . e n a m e   m s g   4       f r o m   e m p   a ,   e m p   b   5   w h e r e     d a y o f w e e k   a . h i r e d a t e   , m o n t h n a m e   a . h i r e d a t e       =   6                 d a y o f w e e k   b . h i r e d a t e   , m o n t h n a m e   b . h i r e d a t e       7       a n d   a . e m p n o   <   b . e m p n o   8   o r d e r   b y   a . e n a m e 1   s e l e c t   a . e n a m e       2                 '   w a s   h i r e d   o n   t h e   s a m e   m o n t h   a n d   w e e k d a y   a s   '     3                 b . e n a m e   a s   m s g   4       f r o m   e m p   a ,   e m p   b   5   w h e r e   t o _ c h a r   a . h i r e d a t e , ' D M O N '     =   6               t o _ c h a r   b . h i r e d a t e , ' D M O N '     7       a n d   a . e m p n o   <   b . e m p n o   8   o r d e r   b y   a . e n a m e 1   s e l e c t   c o n c a t   a . e n a m e ,   2                 '   w a s   h i r e d   o n   t h e   s a m e   m o n t h   a n d   w e e k d a y   a s   ' ,   3                 b . e n a m e     m s g   4       f r o m   e m p   a ,   e m p   b   5     w h e r e   d a t e _ f o r m a t   a . h i r e d a t e , ' % w % M '     =   6                 d a t e _ f o r m a t   b . h i r e d a t e , ' % w % M '     7         a n d   a . e m p n o   <   b . e m p n o   8   o r d e r   b y   a . e n a m e  After self-joining table EMP, use the DATENAME function to format the HIREDATE into weekday and month for comparison:  Discussion The only difference between the solutions is the date function used to format the HIREDATE. We’ll use the Oracle PostgreSQL solution in this discussion  because it’s the shortest to type out , but the explanation holds true for the other solutions as well. The first step is to self-join EMP so that each employee has access to the other employees’ HIREDATEs. Consider the results of the query shown here  filtered for SCOTT :  1   s e l e c t   a . e n a m e   +   2                 '   w a s   h i r e d   o n   t h e   s a m e   m o n t h   a n d   w e e k d a y   a s   ' +   3                 b . e n a m e   m s g   4     f r o m   e m p   a ,   e m p   b   5   w h e r e   d a t e n a m e   d w , a . h i r e d a t e     =   d a t e n a m e   d w , b . h i r e d a t e     6       a n d   d a t e n a m e   m , a . h i r e d a t e     =   d a t e n a m e   m , b . h i r e d a t e     7       a n d   a . e m p n o   <   b . e m p n o   8   o r d e r   b y   a . e n a m e s e l e c t   a . e n a m e   a s   s c o t t ,   a . h i r e d a t e   a s   s c o t t _ h d ,                 b . e n a m e   a s   o t h e r _ e m p s ,   b . h i r e d a t e   a s   o t h e r _ h d s       f r o m   e m p   a ,   e m p   b     w h e r e   a . e n a m e   =   ' S C O T T '       a n d   a . e m p n o   ! =   b . e m p n o     S C O T T             S C O T T _ H D         O T H E R _ E M P S   O T H E R _ H D S   - - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - - -   S C O T T             0 9 - D E C - 2 0 0 2   S M I T H             1 7 - D E C - 2 0 0 0   S C O T T             0 9 - D E C - 2 0 0 2   A L L E N             2 0 - F E B - 2 0 0 1   S C O T T             0 9 - D E C - 2 0 0 2   W A R D               2 2 - F E B - 2 0 0 1   S C O T T             0 9 - D E C - 2 0 0 2   J O N E S             0 2 - A P R - 2 0 0 1   S C O T T             0 9 - D E C - 2 0 0 2   M A R T I N           2 8 - S E P - 2 0 0 1   S C O T T             0 9 - D E C - 2 0 0 2   B L A K E             0 1 - M A Y - 2 0 0 1   S C O T T             0 9 - D E C - 2 0 0 2   C L A R K             0 9 - J U N - 2 0 0 1   S C O T T             0 9 - D E C - 2 0 0 2   K I N G               1 7 - N O V - 2 0 0 1   S C O T T             0 9 - D E C - 2 0 0 2   T U R N E R           0 8 - S E P - 2 0 0 1   S C O T T             0 9 - D E C - 2 0 0 2   A D A M S             1 2 - J A N - 2 0 0 3   S C O T T             0 9 - D E C - 2 0 0 2   J A M E S             0 3 - D E C - 2 0 0 1    By self-joining table EMP, you can compare SCOTT’s HIREDATE to the HIREDATE of all the other employees. The filter on EMPNO is so that SCOTT’s HIREDATE is not returned as one of the OTHER_HDS. The next step is to use your RDBMS’s supplied date formatting function s  to compare the weekday and month of the HIREDATEs and keep only those that match:  At this point, the HIREDATEs are correctly matched, but there are six rows in the result set rather than the three in the “Problem” section of this recipe. The reason for the extra rows is the filter on EMPNO. By using “not equals,” you do not filter out the reciprocals. For example, the first row matches FORD and SCOTT, and the last row matches SCOTT and FORD. The six rows in the result set are technically accurate but redundant. To remove the redundancy, use “less than”  the HIREDATEs are removed to bring the intermediate queries closer to the final result set :  S C O T T             0 9 - D E C - 2 0 0 2   F O R D               0 3 - D E C - 2 0 0 1   S C O T T             0 9 - D E C - 2 0 0 2   M I L L E R           2 3 - J A N - 2 0 0 2 s e l e c t   a . e n a m e   a s   e m p 1 ,   a . h i r e d a t e   a s   e m p 1 _ h d ,                 b . e n a m e   a s   e m p 2 ,   b . h i r e d a t e   a s   e m p 2 _ h d       f r o m   e m p   a ,   e m p   b     w h e r e   t o _ c h a r   a . h i r e d a t e , ' D M O N '     =                 t o _ c h a r   b . h i r e d a t e , ' D M O N '           a n d   a . e m p n o   ! =   b . e m p n o     o r d e r   b y   1     E M P 1               E M P 1 _ H D           E M P 2               E M P 2 _ H D   - - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - - -   F O R D               0 3 - D E C - 2 0 0 1   S C O T T             0 9 - D E C - 2 0 0 2   F O R D               0 3 - D E C - 2 0 0 1   J A M E S             0 3 - D E C - 2 0 0 1   J A M E S             0 3 - D E C - 2 0 0 1   S C O T T             0 9 - D E C - 2 0 0 2   J A M E S             0 3 - D E C - 2 0 0 1   F O R D               0 3 - D E C - 2 0 0 1     S C O T T             0 9 - D E C - 2 0 0 2   J A M E S             0 3 - D E C - 2 0 0 1   S C O T T             0 9 - D E C - 2 0 0 2   F O R D               0 3 - D E C - 2 0 0 1 s e l e c t   a . e n a m e   a s   e m p 1 ,   b . e n a m e   a s   e m p 2       f r o m   e m p   a ,   e m p   b     w h e r e   t o _ c h a r   a . h i r e d a t e , ' D M O N '     =                 t o _ c h a r   b . h i r e d a t e , ' D M O N '      The final step is to simply concatenate the result set to form the message.  9.13 Identifying Overlapping Date Ranges  Problem You want to find all instances of an employee starting a new project before ending an existing project. Consider table EMP_PROJECT:  Looking at the results for employee KING, you see that KING began PROJ_ID 8 before finishing PROJ_ID 5 and began PROJ_ID 5 before  _   ,         a n d   a . e m p n o   <   b . e m p n o     o r d e r   b y   1     E M P 1               E M P 2   - - - - - - - - - -   - - - - - - - - - -   J A M E S             F O R D   S C O T T             J A M E S   S C O T T             F O R D s e l e c t   *       f r o m   e m p _ p r o j e c t     E M P N O   E N A M E             P R O J _ I D   P R O J _ S T A R T     P R O J _ E N D   - - - - -   - - - - - - - - - -   - - - - - - -   - - - - - - - - - - -   - - - - - - - - - - -   7 7 8 2     C L A R K                         1   1 6 - J U N - 2 0 0 5   1 8 - J U N - 2 0 0 5   7 7 8 2     C L A R K                         4   1 9 - J U N - 2 0 0 5   2 4 - J U N - 2 0 0 5   7 7 8 2     C L A R K                         7   2 2 - J U N - 2 0 0 5   2 5 - J U N - 2 0 0 5   7 7 8 2     C L A R K                       1 0   2 5 - J U N - 2 0 0 5   2 8 - J U N - 2 0 0 5   7 7 8 2     C L A R K                       1 3   2 8 - J U N - 2 0 0 5   0 2 - J U L - 2 0 0 5   7 8 3 9     K I N G                           2   1 7 - J U N - 2 0 0 5   2 1 - J U N - 2 0 0 5   7 8 3 9     K I N G                           8   2 3 - J U N - 2 0 0 5   2 5 - J U N - 2 0 0 5   7 8 3 9     K I N G                         1 4   2 9 - J U N - 2 0 0 5   3 0 - J U N - 2 0 0 5   7 8 3 9     K I N G                         1 1   2 6 - J U N - 2 0 0 5   2 7 - J U N - 2 0 0 5   7 8 3 9     K I N G                           5   2 0 - J U N - 2 0 0 5   2 4 - J U N - 2 0 0 5   7 9 3 4     M I L L E R                       3   1 8 - J U N - 2 0 0 5   2 2 - J U N - 2 0 0 5   7 9 3 4     M I L L E R                     1 2   2 7 - J U N - 2 0 0 5   2 8 - J U N - 2 0 0 5   7 9 3 4     M I L L E R                     1 5   3 0 - J U N - 2 0 0 5   0 3 - J U L - 2 0 0 5   7 9 3 4     M I L L E R                       9   2 4 - J U N - 2 0 0 5   2 7 - J U N - 2 0 0 5   7 9 3 4     M I L L E R                       6   2 1 - J U N - 2 0 0 5   2 3 - J U N - 2 0 0 5  finishing PROJ_ID 2. You want to return the following result set:  Solution The key here is to find rows where PROJ_START  the date the new project starts  occurs on or after another project’s PROJ_START date and on or before that other project’s PROJ_END date. To begin, you need to be able to compare each project with each other project  for the same employee . By self-joining EMP_PROJECT on employee, you generate every possible combination of two projects for each employee. To find the overlaps, simply find the rows where PROJ_START for any PROJ_ID falls between PROJ_START and PROJ_END for another PROJ_ID by the same employee.  DB2, PostgreSQL, and Oracle Self-join EMP_PROJECT. Then use the concatenation operator  to construct the message that explains which projects overlap:  MySQL  E M P N O   E N A M E             M S G   - - - - -   - - - - - - - - - -   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   7 7 8 2     C L A R K             p r o j e c t   7   o v e r l a p s   p r o j e c t   4   7 7 8 2     C L A R K             p r o j e c t   1 0   o v e r l a p s   p r o j e c t   7   7 7 8 2     C L A R K             p r o j e c t   1 3   o v e r l a p s   p r o j e c t   1 0   7 8 3 9     K I N G               p r o j e c t   8   o v e r l a p s   p r o j e c t   5   7 8 3 9     K I N G               p r o j e c t   5   o v e r l a p s   p r o j e c t   2   7 9 3 4     M I L L E R           p r o j e c t   1 2   o v e r l a p s   p r o j e c t   9   7 9 3 4     M I L L E R           p r o j e c t   6   o v e r l a p s   p r o j e c t   3 1   s e l e c t   a . e m p n o , a . e n a m e ,   2                 ' p r o j e c t   '   b . p r o j _ i d     3                 '   o v e r l a p s   p r o j e c t   '   a . p r o j _ i d   a s   m s g   4       f r o m   e m p _ p r o j e c t   a ,   5                 e m p _ p r o j e c t   b   6     w h e r e   a . e m p n o   =   b . e m p n o   7         a n d   b . p r o j _ s t a r t   > =   a . p r o j _ s t a r t   8         a n d   b . p r o j _ s t a r t   < =   a . p r o j _ e n d   9         a n d   a . p r o j _ i d   ! =   b . p r o j _ i d  Self-join EMP_PROJECT. Then use the CONCAT function to construct the message that explains which projects overlap:  SQL Server Self-join EMP_PROJECT. Then use the concatenation operator + to construct the message that explains which projects overlap:  Discussion The only difference between the solutions lies in the string concatenation, so one discussion using the DB2 syntax will cover all three solutions. The first step is a self-join of EMP_PROJECT so that the PROJ_START dates can be compared among the different projects. The output of the self-join for employee KING is shown here. You can observe how each project can “see” the other projects:  1   s e l e c t   a . e m p n o , a . e n a m e ,   2                 c o n c a t   ' p r o j e c t   ' , b . p r o j _ i d ,   3                   '   o v e r l a p s   p r o j e c t   ' , a . p r o j _ i d     a s   m s g   4       f r o m   e m p _ p r o j e c t   a ,   5                 e m p _ p r o j e c t   b   6     w h e r e   a . e m p n o   =   b . e m p n o   7         a n d   b . p r o j _ s t a r t   > =   a . p r o j _ s t a r t   8         a n d   b . p r o j _ s t a r t   < =   a . p r o j _ e n d   9         a n d   a . p r o j _ i d   ! =   b . p r o j _ i d 1   s e l e c t   a . e m p n o , a . e n a m e ,   2                 ' p r o j e c t   ' + b . p r o j _ i d +   3                 '   o v e r l a p s   p r o j e c t   ' + a . p r o j _ i d   a s   m s g   4       f r o m   e m p _ p r o j e c t   a ,   5                 e m p _ p r o j e c t   b   6     w h e r e   a . e m p n o   =   b . e m p n o   7         a n d   b . p r o j _ s t a r t   > =   a . p r o j _ s t a r t   8         a n d   b . p r o j _ s t a r t   < =   a . p r o j _ e n d   9         a n d   a . p r o j _ i d   ! =   b . p r o j _ i d s e l e c t   a . e n a m e ,                 a . p r o j _ i d   a s   a _ i d ,                 a . p r o j _ s t a r t   a s   a _ s t a r t ,                 a . p r o j _ e n d   a s   a _ e n d ,                 b . p r o j _ i d   a s   b _ i d ,    As you can see from the result set, the self-join makes finding overlapping dates easy: simply return each row where B_START occurs between A_START and A_END. If you look at the WHERE clause on lines 7 and 8 of the solution:  it is doing just that. Once you have the required rows, constructing the messages is just a matter of concatenating the return values. Oracle users can use the window function LEAD OVER to avoid the self- join, if the maximum number of projects per employee is fixed. This can                b . p r o j _ s t a r t   a s   b _ s t a r t       f r o m   e m p _ p r o j e c t   a ,                 e m p _ p r o j e c t   b     w h e r e   a . e n a m e   =   ' K I N G '         a n d   a . e m p n o   =   b . e m p n o         a n d   a . p r o j _ i d   ! =   b . p r o j _ i d   o r d e r   b y   2     E N A M E     A _ I D     A _ S T A R T           A _ E N D               B _ I D     B _ S T A R T   - - - - - -   - - - - -   - - - - - - - - - - -   - - - - - - - - - - -   - - - - -   - - - - - - - - - - -   K I N G               2   1 7 - J U N - 2 0 0 5   2 1 - J U N - 2 0 0 5           8   2 3 - J U N - 2 0 0 5   K I N G               2   1 7 - J U N - 2 0 0 5   2 1 - J U N - 2 0 0 5         1 4   2 9 - J U N - 2 0 0 5   K I N G               2   1 7 - J U N - 2 0 0 5   2 1 - J U N - 2 0 0 5         1 1   2 6 - J U N - 2 0 0 5   K I N G               2   1 7 - J U N - 2 0 0 5   2 1 - J U N - 2 0 0 5           5   2 0 - J U N - 2 0 0 5   K I N G               5   2 0 - J U N - 2 0 0 5   2 4 - J U N - 2 0 0 5           2   1 7 - J U N - 2 0 0 5   K I N G               5   2 0 - J U N - 2 0 0 5   2 4 - J U N - 2 0 0 5           8   2 3 - J U N - 2 0 0 5   K I N G               5   2 0 - J U N - 2 0 0 5   2 4 - J U N - 2 0 0 5         1 1   2 6 - J U N - 2 0 0 5   K I N G               5   2 0 - J U N - 2 0 0 5   2 4 - J U N - 2 0 0 5         1 4   2 9 - J U N - 2 0 0 5   K I N G               8   2 3 - J U N - 2 0 0 5   2 5 - J U N - 2 0 0 5           2   1 7 - J U N - 2 0 0 5   K I N G               8   2 3 - J U N - 2 0 0 5   2 5 - J U N - 2 0 0 5         1 4   2 9 - J U N - 2 0 0 5   K I N G               8   2 3 - J U N - 2 0 0 5   2 5 - J U N - 2 0 0 5           5   2 0 - J U N - 2 0 0 5   K I N G               8   2 3 - J U N - 2 0 0 5   2 5 - J U N - 2 0 0 5         1 1   2 6 - J U N - 2 0 0 5   K I N G             1 1   2 6 - J U N - 2 0 0 5   2 7 - J U N - 2 0 0 5           2   1 7 - J U N - 2 0 0 5   K I N G             1 1   2 6 - J U N - 2 0 0 5   2 7 - J U N - 2 0 0 5           8   2 3 - J U N - 2 0 0 5   K I N G             1 1   2 6 - J U N - 2 0 0 5   2 7 - J U N - 2 0 0 5         1 4   2 9 - J U N - 2 0 0 5   K I N G             1 1   2 6 - J U N - 2 0 0 5   2 7 - J U N - 2 0 0 5           5   2 0 - J U N - 2 0 0 5   K I N G             1 4   2 9 - J U N - 2 0 0 5   3 0 - J U N - 2 0 0 5           2   1 7 - J U N - 2 0 0 5   K I N G             1 4   2 9 - J U N - 2 0 0 5   3 0 - J U N - 2 0 0 5           8   2 3 - J U N - 2 0 0 5   K I N G             1 4   2 9 - J U N - 2 0 0 5   3 0 - J U N - 2 0 0 5           5   2 0 - J U N - 2 0 0 5   K I N G             1 4   2 9 - J U N - 2 0 0 5   3 0 - J U N - 2 0 0 5         1 1   2 6 - J U N - 2 0 0 5 a n d   b . p r o j _ s t a r t   > =   a . p r o j _ s t a r t   a n d   b . p r o j _ s t a r t   < =   a . p r o j _ e n d  come in handy if the self-join is expensive for your particular results  if the self-join requires more resources than the sorts needed for LEAD OVER . For example, consider the alternative for employee KING using LEAD OVER:  Because the number of projects is fixed at five for employee KING, you can use LEAD OVER to examine the dates of all the projects without a self-join. From here, producing the final result set is easy. Simply keep the rows where IS_OVERLAP is not NULL:  s e l e c t   e m p n o ,                 e n a m e ,                 p r o j _ i d ,                 p r o j _ s t a r t ,                 p r o j _ e n d ,                 c a s e                 w h e n   l e a d   p r o j _ s t a r t , 1   o v e r   o r d e r   b y   p r o j _ s t a r t                             b e t w e e n   p r o j _ s t a r t   a n d   p r o j _ e n d                 t h e n   l e a d   p r o j _ i d   o v e r   o r d e r   b y   p r o j _ s t a r t                   w h e n   l e a d   p r o j _ s t a r t , 2   o v e r   o r d e r   b y   p r o j _ s t a r t                             b e t w e e n   p r o j _ s t a r t   a n d   p r o j _ e n d                 t h e n   l e a d   p r o j _ i d   o v e r   o r d e r   b y   p r o j _ s t a r t                   w h e n   l e a d   p r o j _ s t a r t , 3   o v e r   o r d e r   b y   p r o j _ s t a r t                             b e t w e e n   p r o j _ s t a r t   a n d   p r o j _ e n d                 t h e n   l e a d   p r o j _ i d   o v e r   o r d e r   b y   p r o j _ s t a r t                   w h e n   l e a d   p r o j _ s t a r t , 4   o v e r   o r d e r   b y   p r o j _ s t a r t                             b e t w e e n   p r o j _ s t a r t   a n d   p r o j _ e n d                 t h e n   l e a d   p r o j _ i d   o v e r   o r d e r   b y   p r o j _ s t a r t                   e n d   i s _ o v e r l a p       f r o m   e m p _ p r o j e c t     w h e r e   e n a m e   =   ' K I N G '     E M P N O   E N A M E     P R O J _ I D   P R O J _ S T A R T     P R O J _ E N D         I S _ O V E R L A P   - - - - -   - - - - - -   - - - - - - -   - - - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - - -   7 8 3 9     K I N G                   2   1 7 - J U N - 2 0 0 5   2 1 - J U N - 2 0 0 5                     5   7 8 3 9     K I N G                   5   2 0 - J U N - 2 0 0 5   2 4 - J U N - 2 0 0 5                     8   7 8 3 9     K I N G                   8   2 3 - J U N - 2 0 0 5   2 5 - J U N - 2 0 0 5   7 8 3 9     K I N G                 1 1   2 6 - J U N - 2 0 0 5   2 7 - J U N - 2 0 0 5   7 8 3 9     K I N G                 1 4   2 9 - J U N - 2 0 0 5   3 0 - J U N - 2 0 0 5 s e l e c t   e m p n o , e n a m e ,                 ' p r o j e c t   '   i s _ o v e r l a p                   '   o v e r l a p s   p r o j e c t   '   p r o j _ i d   m s g    To allow the solution to work for all employees  not just KING , partition by ENAME in the LEAD OVER function:      f r o m       s e l e c t   e m p n o ,                 e n a m e ,                 p r o j _ i d ,                 p r o j _ s t a r t ,                 p r o j _ e n d ,                 c a s e                 w h e n   l e a d   p r o j _ s t a r t , 1   o v e r   o r d e r   b y   p r o j _ s t a r t                             b e t w e e n   p r o j _ s t a r t   a n d   p r o j _ e n d                 t h e n   l e a d   p r o j _ i d   o v e r   o r d e r   b y   p r o j _ s t a r t                   w h e n   l e a d   p r o j _ s t a r t , 2   o v e r   o r d e r   b y   p r o j _ s t a r t                             b e t w e e n   p r o j _ s t a r t   a n d   p r o j _ e n d                 t h e n   l e a d   p r o j _ i d   o v e r   o r d e r   b y   p r o j _ s t a r t                   w h e n   l e a d   p r o j _ s t a r t , 3   o v e r   o r d e r   b y   p r o j _ s t a r t                             b e t w e e n   p r o j _ s t a r t   a n d   p r o j _ e n d                 t h e n   l e a d   p r o j _ i d   o v e r   o r d e r   b y   p r o j _ s t a r t                   w h e n   l e a d   p r o j _ s t a r t , 4   o v e r   o r d e r   b y   p r o j _ s t a r t                             b e t w e e n   p r o j _ s t a r t   a n d   p r o j _ e n d                 t h e n   l e a d   p r o j _ i d   o v e r   o r d e r   b y   p r o j _ s t a r t                   e n d   i s _ o v e r l a p       f r o m   e m p _ p r o j e c t     w h e r e   e n a m e   =   ' K I N G '                       w h e r e   i s _ o v e r l a p   i s   n o t   n u l l     E M P N O   E N A M E     M S G   - - - - -   - - - - - -   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   7 8 3 9     K I N G       p r o j e c t   5   o v e r l a p s   p r o j e c t   2   7 8 3 9     K I N G       p r o j e c t   8   o v e r l a p s   p r o j e c t   5 s e l e c t   e m p n o , e n a m e ,                 ' p r o j e c t   '   i s _ o v e r l a p                   '   o v e r l a p s   p r o j e c t   '   p r o j _ i d   m s g       f r o m       s e l e c t   e m p n o ,                 e n a m e ,                 p r o j _ i d ,                 p r o j _ s t a r t ,                 p r o j _ e n d ,                 c a s e                 w h e n   l e a d   p r o j _ s t a r t , 1   o v e r   p a r t i t i o n   b y   e n a m e                                                                                 o r d e r   b y   p r o j _ s t a r t                             b e t w e e n   p r o j _ s t a r t   a n d   p r o j _ e n d    9.14 Summing Up Date manipulations are a common problem for anyone querying a database —a series of events stored with their dates inspires business users to ask creative date-based questions. At the same time, dates are one of the less standardized areas of SQLs between vendors. We hope that you take away from this chapter an idea of how even when the syntax is different, there is still a common logic that can be applied to queries that use dates.                t h e n   l e a d   p r o j _ i d   o v e r   p a r t i t i o n   b y   e n a m e                                                                       o r d e r   b y   p r o j _ s t a r t                   w h e n   l e a d   p r o j _ s t a r t , 2   o v e r   p a r t i t i o n   b y   e n a m e                                                                                 o r d e r   b y   p r o j _ s t a r t                             b e t w e e n   p r o j _ s t a r t   a n d   p r o j _ e n d                 t h e n   l e a d   p r o j _ i d   o v e r   p a r t i t i o n   b y   e n a m e                                                                       o r d e r   b y   p r o j _ s t a r t                   w h e n   l e a d   p r o j _ s t a r t , 3   o v e r   p a r t i t i o n   b y   e n a m e                                                                                 o r d e r   b y   p r o j _ s t a r t                             b e t w e e n   p r o j _ s t a r t   a n d   p r o j _ e n d                 t h e n   l e a d   p r o j _ i d   o v e r   p a r t i t i o n   b y   e n a m e                                                                       o r d e r   b y   p r o j _ s t a r t                   w h e n   l e a d   p r o j _ s t a r t , 4   o v e r   p a r t i t i o n   b y   e n a m e                                                                                 o r d e r   b y   p r o j _ s t a r t                             b e t w e e n   p r o j _ s t a r t   a n d   p r o j _ e n d                 t h e n   l e a d   p r o j _ i d   o v e r   p a r t i t i o n   b y   e n a m e                                                                       o r d e r   b y   p r o j _ s t a r t                   e n d   i s _ o v e r l a p     f r o m   e m p _ p r o j e c t                   w h e r e   i s _ o v e r l a p   i s   n o t   n u l l     E M P N O   E N A M E     M S G   - - - - -   - - - - - -   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   7 7 8 2     C L A R K     p r o j e c t   7   o v e r l a p s   p r o j e c t   4   7 7 8 2     C L A R K     p r o j e c t   1 0   o v e r l a p s   p r o j e c t   7   7 7 8 2     C L A R K     p r o j e c t   1 3   o v e r l a p s   p r o j e c t   1 0   7 8 3 9     K I N G       p r o j e c t   5   o v e r l a p s   p r o j e c t   2   7 8 3 9     K I N G       p r o j e c t   8   o v e r l a p s   p r o j e c t   5   7 9 3 4     M I L L E R   p r o j e c t   6   o v e r l a p s   p r o j e c t   3   7 9 3 4     M I L L E R   p r o j e c t   1 2   o v e r l a p s   p r o j e c t   9  Chapter 10. Working with Ranges  This chapter is about “everyday” queries that involve ranges. Ranges are common in everyday life. For example, projects that we work on range over consecutive periods of time. In SQL, it’s often necessary to search for ranges, or to generate ranges, or to otherwise manipulate range-based data. The queries you’ll read about here are slightly more involved than the queries found in the preceding chapters, but they are just as common, and they’ll begin to give you a sense of what SQL can really do for you when you learn to take full advantage of it.  10.1 Locating a Range of Consecutive Values  Problem You want to determine which rows represent a range of consecutive projects. Consider the following result set from view V, which contains data about a project and its start and end dates:  s e l e c t   *       f r o m   V     P R O J _ I D   P R O J _ S T A R T     P R O J _ E N D   - - - - - - -   - - - - - - - - - - -   - - - - - - - - - - -               1   0 1 - J A N - 2 0 2 0   0 2 - J A N - 2 0 2 0               2   0 2 - J A N - 2 0 2 0   0 3 - J A N - 2 0 2 0               3   0 3 - J A N - 2 0 2 0   0 4 - J A N - 2 0 2 0               4   0 4 - J A N - 2 0 2 0   0 5 - J A N - 2 0 2 0               5   0 6 - J A N - 2 0 2 0   0 7 - J A N - 2 0 2 0               6   1 6 - J A N - 2 0 2 0   1 7 - J A N - 2 0 2 0               7   1 7 - J A N - 2 0 2 0   1 8 - J A N - 2 0 2 0               8   1 8 - J A N - 2 0 2 0   1 9 - J A N - 2 0 2 0               9   1 9 - J A N - 2 0 2 0   2 0 - J A N - 2 0 2 0    Excluding the first row, each row’s PROJ_START should equal the PROJ_END of the row before it  “before” is defined as PROJ_ID–1 for the current row . Examining the first five rows from view V, PROJ_IDs 1 through 3 are part of the same “group” as each PROJ_END equals the PROJ_START of the row after it. Because you want to find the range of dates for consecutive projects, you would like to return all rows where the current PROJ_END equals the next row’s PROJ_START. If the first five rows comprised the entire result set, you would like to return only the first three rows. The final result set  using all 14 rows from view V  should be:  The rows with PROJ_IDs 4, 5, 9, 10, and 14 are excluded from this result set because the PROJ_END of each of these rows does not match the PROJ_START of the row following it.  Solution This solution takes best advantage of the window function LEAD OVER to look at the “next” row’s BEGIN_DATE, thus avoiding the need to self-join, which was necessary before window functions were widely introduced:            1 0   2 1 - J A N - 2 0 2 0   2 2 - J A N - 2 0 2 0             1 1   2 6 - J A N - 2 0 2 0   2 7 - J A N - 2 0 2 0             1 2   2 7 - J A N - 2 0 2 0   2 8 - J A N - 2 0 2 0             1 3   2 8 - J A N - 2 0 2 0   2 9 - J A N - 2 0 2 0             1 4   2 9 - J A N - 2 0 2 0   3 0 - J A N - 2 0 2 0 P R O J _ I D   P R O J _ S T A R T     P R O J _ E N D   - - - - - - -   - - - - - - - - - - -   - - - - - - - - - - -             1     0 1 - J A N - 2 0 2 0   0 2 - J A N - 2 0 2 0             2     0 2 - J A N - 2 0 2 0   0 3 - J A N - 2 0 2 0             3     0 3 - J A N - 2 0 2 0   0 4 - J A N - 2 0 2 0             6     1 6 - J A N - 2 0 2 0   1 7 - J A N - 2 0 2 0             7     1 7 - J A N - 2 0 2 0   1 8 - J A N - 2 0 2 0             8     1 8 - J A N - 2 0 2 0   1 9 - J A N - 2 0 2 0           1 1     2 6 - J A N - 2 0 2 0   2 7 - J A N - 2 0 2 0           1 2     2 7 - J A N - 2 0 2 0   2 8 - J A N - 2 0 2 0           1 3     2 8 - J A N - 2 0 2 0   2 9 - J A N - 2 0 2 0 1   s e l e c t   p r o j _ i d ,   p r o j _ s t a r t ,   p r o j _ e n d   2       f r o m        Discussion  DB2, MySQL, PostgreSQL, SQL Server, and Oracle Although it is possible to develop a solution using a self-join, the window function LEAD OVER is perfect for this type of problem, and more intuitive. The function LEAD OVER allows you to examine other rows without performing a self-join  though the function must impose order on the result set to do so . Consider the results of the inline view  lines 3–5  for IDs 1 and 4:  Examining this snippet of code and its result set, it is particularly easy to see why PROJ_ID 4 is excluded from the final result set of the complete solution. It’s excluded because its PROJ_END date of 05-JAN-2020 does not match the “next” project’s start date of 06-JAN-2020. The function LEAD OVER is extremely handy when it comes to problems such as this one, particularly when examining partial results. When working with window functions, keep in mind that they are evaluated after the FROM and WHERE clauses, so the LEAD OVER function in the preceding query must be embedded within an inline view. Otherwise, the LEAD    3   s e l e c t   p r o j _ i d ,   p r o j _ s t a r t ,   p r o j _ e n d ,   4                 l e a d   p r o j _ s t a r t   o v e r   o r d e r   b y   p r o j _ i d     n e x t _ p r o j _ s t a r t   5       f r o m   V   6                     a l i a s   7   w h e r e   n e x t _ p r o j _ s t a r t   =   p r o j _ e n d s e l e c t   *       f r o m       s e l e c t   p r o j _ i d ,   p r o j _ s t a r t ,   p r o j _ e n d ,                 l e a d   p r o j _ s t a r t   o v e r   o r d e r   b y   p r o j _ i d     n e x t _ p r o j _ s t a r t       f r o m   v                       w h e r e   p r o j _ i d   i n       1 ,   4         P R O J _ I D   P R O J _ S T A R T     P R O J _ E N D         N E X T _ P R O J _ S T A R T   - - - - - - -   - - - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - - - - - - - -               1   0 1 - J A N - 2 0 2 0   0 2 - J A N - 2 0 2 0   0 2 - J A N - 2 0 2 0               4   0 4 - J A N - 2 0 2 0   0 5 - J A N - 2 0 2 0   0 6 - J A N - 2 0 2 0  OVER function is applied to the result set after the WHERE clause has filtered out all rows except for PROJ_ID’s 1 and 4. Now, depending on how you view the data, you may very well want to include PROJ_ID 4 in the final result set. Consider the first five rows from view V:  If your requirement is such that PROJ_ID 4 is in fact contiguous  because PROJ_ START for PROJ_ID 4 matches PROJ_END for PROJ_ID 3 , and that only PROJ_ ID 5 should be discarded, the proposed solution for this recipe is incorrect  !  or, at the very least, incomplete:  If you believe PROJ_ID 4 should be included, simply add LAG OVER to the query and use an additional filter in the WHERE clause:  s e l e c t   *       f r o m   V     w h e r e   p r o j _ i d   < =   5     P R O J _ I D   P R O J _ S T A R T     P R O J _ E N D   - - - - - - -   - - - - - - - - - - -   - - - - - - - - - - -               1   0 1 - J A N - 2 0 2 0   0 2 - J A N - 2 0 2 0               2   0 2 - J A N - 2 0 2 0   0 3 - J A N - 2 0 2 0               3   0 3 - J A N - 2 0 2 0   0 4 - J A N - 2 0 2 0               4   0 4 - J A N - 2 0 2 0   0 5 - J A N - 2 0 2 0               5   0 6 - J A N - 2 0 2 0   0 7 - J A N - 2 0 2 0 s e l e c t   p r o j _ i d ,   p r o j _ s t a r t ,   p r o j _ e n d       f r o m       s e l e c t   p r o j _ i d ,   p r o j _ s t a r t ,   p r o j _ e n d ,                   l e a d   p r o j _ s t a r t   o v e r   o r d e r   b y   p r o j _ i d     n e x t _ s t a r t       f r o m   V   w h e r e   p r o j _ i d   < =   5                   w h e r e   p r o j _ e n d   =   n e x t _ s t a r t     P R O J _ I D   P R O J _ S T A R T     P R O J _ E N D   - - - - - - -   - - - - - - - - - - -   - - - - - - - - - - -               1   0 1 - J A N - 2 0 2 0   0 2 - J A N - 2 0 2 0               2   0 2 - J A N - 2 0 2 0   0 3 - J A N - 2 0 2 0               3   0 3 - J A N - 2 0 2 0   0 4 - J A N - 2 0 2 0  Now PROJ_ID 4 is included in the final result set, and only the evil PROJ_ID 5 is excluded. Please consider your exact requirements when applying these recipes to your code.  10.2 Finding Differences Between Rows in the Same Group or Partition  Problem You want to return the DEPTNO, ENAME, and SAL of each employee along with the difference in SAL between employees in the same department  i.e., having the same value for DEPTNO . The difference should be between each current employee and the employee hired immediately afterward  you want to see if there is a correlation between seniority and salary on a “per department” basis . For each employee hired last in his department, return “N A” for the difference. The result set should look like this:  s e l e c t   p r o j _ i d ,   p r o j _ s t a r t ,   p r o j _ e n d       f r o m       s e l e c t   p r o j _ i d ,   p r o j _ s t a r t ,   p r o j _ e n d ,                   l e a d   p r o j _ s t a r t   o v e r   o r d e r   b y   p r o j _ i d     n e x t _ s t a r t ,                 l a g   p r o j _ e n d   o v e r   o r d e r   b y   p r o j _ i d     l a s t _ e n d       f r o m   V   w h e r e   p r o j _ i d   < =   5                   w h e r e   p r o j _ e n d   =   n e x t _ s t a r t         o r   p r o j _ s t a r t   =   l a s t _ e n d     P R O J _ I D   P R O J _ S T A R T     P R O J _ E N D   - - - - - - -   - - - - - - - - - - -   - - - - - - - - - - -               1   0 1 - J A N - 2 0 2 0   0 2 - J A N - 2 0 2 0               2   0 2 - J A N - 2 0 2 0   0 3 - J A N - 2 0 2 0               3   0 3 - J A N - 2 0 2 0   0 4 - J A N - 2 0 2 0               4   0 4 - J A N - 2 0 2 0   0 5 - J A N - 2 0 2 0 D E P T N O   E N A M E                           S A L   H I R E D A T E         D I F F   - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - - -           1 0   C L A R K                         2 4 5 0   0 9 - J U N - 2 0 0 6             - 2 5 5 0    Solution The is another example of where the window functions LEAD OVER and LAG OVER come in handy. You can easily access next and prior rows without additional joins. Alternative methods such as subqueries or self- joins are possible but awkward:  In this case, for the sake of variety, we have used a CTE rather than a subquery—both will work across most RDBMSs these days, with the preference usually relating to readability.  Discussion The first step is to use the LEAD OVER window function to find the “next” salary for each employee within their department. The employees hired last in each department will have a NULL value for NEXT_SAL:          1 0   K I N G                           5 0 0 0   1 7 - N O V - 2 0 0 6               3 7 0 0           1 0   M I L L E R                       1 3 0 0   2 3 - J A N - 2 0 0 7                 N   A           2 0   S M I T H                           8 0 0   1 7 - D E C - 2 0 0 5             - 2 1 7 5           2 0   J O N E S                         2 9 7 5   0 2 - A P R - 2 0 0 6                 - 2 5           2 0   F O R D                           3 0 0 0   0 3 - D E C - 2 0 0 6                     0           2 0   S C O T T                         3 0 0 0   0 9 - D E C - 2 0 0 7               1 9 0 0           2 0   A D A M S                         1 1 0 0   1 2 - J A N - 2 0 0 8                 N   A           3 0   A L L E N                         1 6 0 0   2 0 - F E B - 2 0 0 6                 3 5 0           3 0   W A R D                           1 2 5 0   2 2 - F E B - 2 0 0 6             - 1 6 0 0           3 0   B L A K E                         2 8 5 0   0 1 - M A Y - 2 0 0 6               1 3 5 0           3 0   T U R N E R                       1 5 0 0   0 8 - S E P - 2 0 0 6                 2 5 0           3 0   M A R T I N                       1 2 5 0   2 8 - S E P - 2 0 0 6                 3 0 0           3 0   J A M E S                           9 5 0   0 3 - D E C - 2 0 0 6                 N   A 1     w i t h   n e x t _ s a l _ t a b     d e p t n o , e n a m e , s a l , h i r e d a t e , n e x t _ s a l     2     a s   3       s e l e c t   d e p t n o ,   e n a m e ,   s a l ,   h i r e d a t e ,   4                 l e a d   s a l   o v e r   p a r t i t i o n   b y   d e p t n o   5                                                     o r d e r   b y   h i r e d a t e     a s   n e x t _ s a l   6       f r o m   e m p       7   8           s e l e c t   d e p t n o ,   e n a m e ,   s a l ,   h i r e d a t e   9     ,         c o a l e s c e   c a s t   s a l - n e x t _ s a l   a s   c h a r   ,   ' N   A '     a s   d i f f   1 0         f r o m   n e x t _ s a l _ t a b  The next step is to take the difference between each employee’s salary and the salary of the employee hired immediately after them in the same department:  s e l e c t   d e p t n o , e n a m e , s a l , h i r e d a t e ,                 l e a d   s a l   o v e r   p a r t i t i o n   b y   d e p t n o   o r d e r   b y   h i r e d a t e     a s   n e x t _ s a l       f r o m   e m p     D E P T N O   E N A M E                           S A L   H I R E D A T E             N E X T _ S A L   - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - - -           1 0   C L A R K                         2 4 5 0   0 9 - J U N - 2 0 0 6               5 0 0 0           1 0   K I N G                           5 0 0 0   1 7 - N O V - 2 0 0 6               1 3 0 0           1 0   M I L L E R                       1 3 0 0   2 3 - J A N - 2 0 0 7           2 0   S M I T H                           8 0 0   1 7 - D E C - 2 0 0 5               2 9 7 5           2 0   J O N E S                         2 9 7 5   0 2 - A P R - 2 0 0 6               3 0 0 0           2 0   F O R D                           3 0 0 0   0 3 - D E C - 2 0 0 6               3 0 0 0           2 0   S C O T T                         3 0 0 0   0 9 - D E C - 2 0 0 7               1 1 0 0           2 0   A D A M S                         1 1 0 0   1 2 - J A N - 2 0 0 8           3 0   A L L E N                         1 6 0 0   2 0 - F E B - 2 0 0 6               1 2 5 0           3 0   W A R D                           1 2 5 0   2 2 - F E B - 2 0 0 6               2 8 5 0           3 0   B L A K E                         2 8 5 0   0 1 - M A Y - 2 0 0 6               1 5 0 0           3 0   T U R N E R                       1 5 0 0   0 8 - S E P - 2 0 0 6               1 2 5 0           3 0   M A R T I N                       1 2 5 0   2 8 - S E P - 2 0 0 6                 9 5 0           3 0   J A M E S                           9 5 0   0 3 - D E C - 2 0 0 6 s e l e c t   d e p t n o , e n a m e , s a l , h i r e d a t e ,   s a l - n e x t _ s a l   d i f f       f r o m       s e l e c t   d e p t n o , e n a m e , s a l , h i r e d a t e ,                 l e a d   s a l   o v e r   p a r t i t i o n   b y   d e p t n o   o r d e r   b y   h i r e d a t e     n e x t _ s a l       f r o m   e m p                       D E P T N O   E N A M E                           S A L   H I R E D A T E                     D I F F   - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - - -           1 0   C L A R K                         2 4 5 0   0 9 - J U N - 2 0 0 6             - 2 5 5 0           1 0   K I N G                           5 0 0 0   1 7 - N O V - 2 0 0 6               3 7 0 0           1 0   M I L L E R                       1 3 0 0   2 3 - J A N - 2 0 0 7           2 0   S M I T H                           8 0 0   1 7 - D E C - 2 0 0 5             - 2 1 7 5           2 0   J O N E S                         2 9 7 5   0 2 - A P R - 2 0 0 6                 - 2 5           2 0   F O R D                           3 0 0 0   0 3 - D E C - 2 0 0 6                     0           2 0   S C O T T                         3 0 0 0   0 9 - D E C - 2 0 0 7               1 9 0 0           2 0   A D A M S                         1 1 0 0   1 2 - J A N - 2 0 0 8           3 0   A L L E N                         1 6 0 0   2 0 - F E B - 2 0 0 6                 3 5 0           3 0   W A R D                           1 2 5 0   2 2 - F E B - 2 0 0 6             - 1 6 0 0           3 0   B L A K E                         2 8 5 0   0 1 - M A Y - 2 0 0 6               1 3 5 0           3 0   T U R N E R                       1 5 0 0   0 8 - S E P - 2 0 0 6                 2 5 0    The next step is to use the COALESCE function to insert “N A” when there is no next salary. To be able to return “N A” you must cast the value of DIFF to a string:  While the majority of the solutions provided in this book do not deal with “what if” scenarios  for the sake of readability and the author’s sanity , the scenario involving duplicates when using the LEAD OVER function in this manner must be discussed. In the simple sample data in table EMP, no employees have duplicate HIREDATEs, yet this is an unlikely situation. Normally, we would not discuss a “what if” situation such as duplicates  since there aren’t any in table EMP , but the workaround involving LEAD may not be immediately obvious. Consider the following query, which          3 0   M A R T I N                       1 2 5 0   2 8 - S E P - 2 0 0 6                 3 0 0           3 0   J A M E S                           9 5 0   0 3 - D E C - 2 0 0 6 s e l e c t   d e p t n o , e n a m e , s a l , h i r e d a t e ,                 n v l   t o _ c h a r   s a l - n e x t _ s a l   , ' N   A '     d i f f       f r o m       s e l e c t   d e p t n o , e n a m e , s a l , h i r e d a t e ,                 l e a d   s a l   o v e r   p a r t i t i o n   b y   d e p t n o   o r d e r   b y   h i r e d a t e     n e x t _ s a l       f r o m   e m p                       D E P T N O   E N A M E                           S A L   H I R E D A T E         D I F F   - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - - - - - - - -           1 0   C L A R K                         2 4 5 0   0 9 - J U N - 2 0 0 6   - 2 5 5 0           1 0   K I N G                           5 0 0 0   1 7 - N O V - 2 0 0 6   3 7 0 0           1 0   M I L L E R                       1 3 0 0   2 3 - J A N - 2 0 0 7   N   A           2 0   S M I T H                           8 0 0   1 7 - D E C - 2 0 0 5   - 2 1 7 5           2 0   J O N E S                         2 9 7 5   0 2 - A P R - 2 0 0 6   - 2 5           2 0   F O R D                           3 0 0 0   0 3 - D E C - 2 0 0 6   0           2 0   S C O T T                         3 0 0 0   0 9 - D E C - 2 0 0 7   1 9 0 0           2 0   A D A M S                         1 1 0 0   1 2 - J A N - 2 0 0 8   N   A           3 0   A L L E N                         1 6 0 0   2 0 - F E B - 2 0 0 6   3 5 0           3 0   W A R D                           1 2 5 0   2 2 - F E B - 2 0 0 6   - 1 6 0 0           3 0   B L A K E                         2 8 5 0   0 1 - M A Y - 2 0 0 6   1 3 5 0           3 0   T U R N E R                       1 5 0 0   0 8 - S E P - 2 0 0 6   2 5 0           3 0   M A R T I N                       1 2 5 0   2 8 - S E P - 2 0 0 6   3 0 0           3 0   J A M E S                           9 5 0   0 3 - D E C - 2 0 0 6   N   A  returns the difference in SAL between the employees in DEPTNO 10  the difference is performed in the order in which they were hired :  This solution is correct considering the data in table EMP, but if there were duplicate rows, the solution would fail. Consider the following example, which shows four more employees hired on the same day as KING:  s e l e c t   d e p t n o , e n a m e , s a l , h i r e d a t e ,                 l p a d   n v l   t o _ c h a r   s a l - n e x t _ s a l   , ' N   A '   , 1 0     d i f f       f r o m       s e l e c t   d e p t n o , e n a m e , s a l , h i r e d a t e ,                 l e a d   s a l   o v e r   p a r t i t i o n   b y   d e p t n o                                                     o r d e r   b y   h i r e d a t e     n e x t _ s a l       f r o m   e m p     w h e r e   d e p t n o = 1 0   a n d   e m p n o   >   1 0                       D E P T N O   E N A M E         S A L   H I R E D A T E         D I F F   - - - - - -   - - - - - -   - - - - -   - - - - - - - - - - -   - - - - - - - - - -           1 0   C L A R K       2 4 5 0   0 9 - J U N - 2 0 0 6             - 2 5 5 0           1 0   K I N G         5 0 0 0   1 7 - N O V - 2 0 0 6               3 7 0 0           1 0   M I L L E R     1 3 0 0   2 3 - J A N - 2 0 0 7                 N   A i n s e r t   i n t o   e m p     e m p n o , e n a m e , d e p t n o , s a l , h i r e d a t e     v a l u e s     1 , ' a n t ' , 1 0 , 1 0 0 0 , t o _ d a t e   ' 1 7 - N O V - 2 0 0 6 '         i n s e r t   i n t o   e m p     e m p n o , e n a m e , d e p t n o , s a l , h i r e d a t e     v a l u e s     2 , ' j o e ' , 1 0 , 1 5 0 0 , t o _ d a t e   ' 1 7 - N O V - 2 0 0 6 '         i n s e r t   i n t o   e m p     e m p n o , e n a m e , d e p t n o , s a l , h i r e d a t e     v a l u e s     3 , ' j i m ' , 1 0 , 1 6 0 0 , t o _ d a t e   ' 1 7 - N O V - 2 0 0 6 '         i n s e r t   i n t o   e m p     e m p n o , e n a m e , d e p t n o , s a l , h i r e d a t e     v a l u e s     4 , ' j o n ' , 1 0 , 1 7 0 0 , t o _ d a t e   ' 1 7 - N O V - 2 0 0 6 '         s e l e c t   d e p t n o , e n a m e , s a l , h i r e d a t e ,                 l p a d   n v l   t o _ c h a r   s a l - n e x t _ s a l   , ' N   A '   , 1 0     d i f f       f r o m       s e l e c t   d e p t n o , e n a m e , s a l , h i r e d a t e ,                 l e a d   s a l   o v e r   p a r t i t i o n   b y   d e p t n o                                                     o r d e r   b y   h i r e d a t e     n e x t _ s a l       f r o m   e m p     w h e r e   d e p t n o = 1 0                      You’ll notice that with the exception of employee JON, all employees hired on the same date  November 17  evaluate their salary against another employee hired on the same date! This is incorrect. All employees hired on November 17 should have the difference of salary computed against MILLER’s salary, not another employee hired on November 17. Take, for example, employee ANT. The value for DIFF for ANT is –500 because ANT’s SAL is compared with JOE’s SAL and is 500 less than JOE’s SAL, hence the value of –500. The correct value for DIFF for employee ANT should be –300 because ANT makes 300 less than MILLER, who is the next employee hired by HIREDATE. The reason the solution seems to not work is due to the default behavior of Oracle’s LEAD OVER function. By default, LEAD OVER looks ahead only one row. So, for employee ANT, the next SAL based on HIREDATE is JOE’s SAL, because LEAD OVER simply looks one row ahead and doesn’t skip duplicates. Fortunately, Oracle planned for such a situation and allows you to pass an additional parameter to LEAD OVER to determine how far ahead it should look. In the previous example, the solution is simply a matter of counting: find the distance from each employee hired on November 17 to January 23  MILLER’s HIREDATE . The following shows how to accomplish this:    D E P T N O   E N A M E         S A L   H I R E D A T E         D I F F   - - - - - -   - - - - - -   - - - - -   - - - - - - - - - - -   - - - - - - - - - -           1 0   C L A R K       2 4 5 0   0 9 - J U N - 2 0 0 6               1 4 5 0           1 0   a n t           1 0 0 0   1 7 - N O V - 2 0 0 6               - 5 0 0           1 0   j o e           1 5 0 0   1 7 - N O V - 2 0 0 6             - 3 5 0 0           1 0   K I N G         5 0 0 0   1 7 - N O V - 2 0 0 6               3 4 0 0           1 0   j i m           1 6 0 0   1 7 - N O V - 2 0 0 6               - 1 0 0           1 0   j o n           1 7 0 0   1 7 - N O V - 2 0 0 6                 4 0 0           1 0   M I L L E R     1 3 0 0   2 3 - J A N - 2 0 0 7                 N   A s e l e c t   d e p t n o , e n a m e , s a l , h i r e d a t e ,                 l p a d   n v l   t o _ c h a r   s a l - n e x t _ s a l   , ' N   A '   , 1 0     d i f f       f r o m       s e l e c t   d e p t n o , e n a m e , s a l , h i r e d a t e ,                 l e a d   s a l , c n t - r n + 1   o v e r   p a r t i t i o n   b y   d e p t n o                                                     o r d e r   b y   h i r e d a t e     n e x t _ s a l       f r o m       s e l e c t   d e p t n o , e n a m e , s a l , h i r e d a t e ,    Now the solution is correct. As you can see, all the employees hired on November 17 now have their salaries compared with MILLER’s salary. Inspecting the results, employee ANT now has a value of –300 for DIFF, which is what we were hoping for. If it isn’t immediately obvious, the expression passed to LEAD OVER; CNT-RN+1 is simply the distance from each employee hired on November 17 to MILLER. Consider the following inline view, which shows the values for CNT and RN:  The value for CNT represents, for each employee with a duplicate HIREDATE, how many duplicates there are in total for their HIREDATE.                c o u n t   *   o v e r   p a r t i t i o n   b y   d e p t n o , h i r e d a t e     c n t ,                 r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   d e p t n o , h i r e d a t e   o r d e r   b y   s a l     r n       f r o m   e m p     w h e r e   d e p t n o = 1 0                                         D E P T N O   E N A M E           S A L   H I R E D A T E         D I F F   - - - - - -   - - - - - -     - - - - -   - - - - - - - - - - -   - - - - - - - - - -           1 0   C L A R K         2 4 5 0   0 9 - J U N - 2 0 0 6               1 4 5 0           1 0   a n t             1 0 0 0   1 7 - N O V - 2 0 0 6               - 3 0 0           1 0   j o e             1 5 0 0   1 7 - N O V - 2 0 0 6                 2 0 0           1 0   j i m             1 6 0 0   1 7 - N O V - 2 0 0 6                 3 0 0           1 0   j o n             1 7 0 0   1 7 - N O V - 2 0 0 6                 4 0 0           1 0   K I N G           5 0 0 0   1 7 - N O V - 2 0 0 6               3 7 0 0           1 0   M I L L E R       1 3 0 0   2 3 - J A N - 2 0 0 7                 N   A s e l e c t   d e p t n o , e n a m e , s a l , h i r e d a t e ,                 c o u n t   *   o v e r   p a r t i t i o n   b y   d e p t n o , h i r e d a t e     c n t ,                 r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   d e p t n o , h i r e d a t e   o r d e r   b y   s a l     r n       f r o m   e m p     w h e r e   d e p t n o = 1 0     D E P T N O   E N A M E         S A L   H I R E D A T E                       C N T                   R N   - - - - - -   - - - - - -   - - - - -   - - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -           1 0   C L A R K       2 4 5 0   0 9 - J U N - 2 0 0 6                     1                     1           1 0   a n t           1 0 0 0   1 7 - N O V - 2 0 0 6                     5                     1           1 0   j o e           1 5 0 0   1 7 - N O V - 2 0 0 6                     5                     2           1 0   j i m           1 6 0 0   1 7 - N O V - 2 0 0 6                     5                     3           1 0   j o n           1 7 0 0   1 7 - N O V - 2 0 0 6                     5                     4           1 0   K I N G         5 0 0 0   1 7 - N O V - 2 0 0 6                     5                     5           1 0   M I L L E R     1 3 0 0   2 3 - J A N - 2 0 0 7                     1                     1  The value for RN represents a ranking for the employees in DEPTNO 10. The rank is partitioned by DEPTNO and HIREDATE so only employees with a HIREDATE that another employee has will have a value greater than one. The ranking is sorted by SAL  this is arbitrary; SAL is convenient, but we could have just as easily chosen EMPNO . Now that you know how many total duplicates there are and you have a ranking of each duplicate, the distance to MILLER is simply the total number of duplicates minus the current rank plus one  CNT-RN+1 . The results of the distance calculation and its effect on LEAD OVER are shown here:  Now you can clearly see the effect that you have when you pass the correct distance to LEAD OVER. The rows for INCORRECT represent the values returned by LEAD OVER using a default distance of one. The rows for CORRECT represent the values returned by LEAD OVER using the proper distance for each employee with a duplicate HIREDATE to MILLER. At  s e l e c t   d e p t n o , e n a m e , s a l , h i r e d a t e ,                 l e a d   s a l   o v e r   p a r t i t i o n   b y   d e p t n o                                                     o r d e r   b y   h i r e d a t e     i n c o r r e c t ,                 c n t - r n + 1   d i s t a n c e ,                 l e a d   s a l , c n t - r n + 1   o v e r   p a r t i t i o n   b y   d e p t n o                                                     o r d e r   b y   h i r e d a t e     c o r r e c t       f r o m       s e l e c t   d e p t n o , e n a m e , s a l , h i r e d a t e ,                 c o u n t   *   o v e r   p a r t i t i o n   b y   d e p t n o , h i r e d a t e     c n t ,                 r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   d e p t n o , h i r e d a t e                                                           o r d e r   b y   s a l     r n       f r o m   e m p     w h e r e   d e p t n o = 1 0                       D E P T N O   E N A M E         S A L   H I R E D A T E         I N C O R R E C T         D I S T A N C E         C O R R E C T   - - - - - -   - - - - - -   - - - - -   - - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -           1 0   C L A R K       2 4 5 0   0 9 - J U N - 2 0 0 6               1 0 0 0                     1               1 0 0 0           1 0   a n t           1 0 0 0   1 7 - N O V - 2 0 0 6               1 5 0 0                     5               1 3 0 0           1 0   j o e           1 5 0 0   1 7 - N O V - 2 0 0 6               1 6 0 0                     4               1 3 0 0           1 0   j i m           1 6 0 0   1 7 - N O V - 2 0 0 6               1 7 0 0                     3               1 3 0 0           1 0   j o n           1 7 0 0   1 7 - N O V - 2 0 0 6               5 0 0 0                     2               1 3 0 0           1 0   K I N G         5 0 0 0   1 7 - N O V - 2 0 0 6               1 3 0 0                     1               1 3 0 0           1 0   M I L L E R     1 3 0 0   2 3 - J A N - 2 0 0 7                                           1  this point, all that is left is to find the difference between CORRECT and SAL for each row, which has already been shown.  10.3 Locating the Beginning and End of a Range of Consecutive Values  Problem This recipe is an extension of the prior recipe, and it uses the same view V from the prior recipe. Now that you’ve located the ranges of consecutive values, you want to find just their start and end points. Unlike the prior recipe, if a row is not part of a set of consecutive values, you still want to return it. Why? Because such a row represents both the beginning and end of its range. Using the data from view V:  you want the final result set to be as follows:  s e l e c t   *       f r o m   V       P R O J _ I D   P R O J _ S T A R T     P R O J _ E N D   - - - - - - -   - - - - - - - - - - -   - - - - - - - - - - -               1   0 1 - J A N - 2 0 2 0   0 2 - J A N - 2 0 2 0               2   0 2 - J A N - 2 0 2 0   0 3 - J A N - 2 0 2 0               3   0 3 - J A N - 2 0 2 0   0 4 - J A N - 2 0 2 0               4   0 4 - J A N - 2 0 2 0   0 5 - J A N - 2 0 2 0               5   0 6 - J A N - 2 0 2 0   0 7 - J A N - 2 0 2 0               6   1 6 - J A N - 2 0 2 0   1 7 - J A N - 2 0 2 0               7   1 7 - J A N - 2 0 2 0   1 8 - J A N - 2 0 2 0               8   1 8 - J A N - 2 0 2 0   1 9 - J A N - 2 0 2 0               9   1 9 - J A N - 2 0 2 0   2 0 - J A N - 2 0 2 0             1 0   2 1 - J A N - 2 0 2 0   2 2 - J A N - 2 0 2 0             1 1   2 6 - J A N - 2 0 2 0   2 7 - J A N - 2 0 2 0             1 2   2 7 - J A N - 2 0 2 0   2 8 - J A N - 2 0 2 0             1 3   2 8 - J A N - 2 0 2 0   2 9 - J A N - 2 0 2 0             1 4   2 9 - J A N - 2 0 2 0   3 0 - J A N - 2 0 2 0  Solution This problem is a bit more involved than its predecessor. First, you must identify what the ranges are. A range of rows is defined by the values for PROJ_START and PROJ_END. For a row to be considered “consecutive” or part of a group, its PROJ_START value must equal the PROJ_END value of the row before it. In the case where a row’s PROJ_START value does not equal the prior row’s PROJ_END value and its PROJ_END value does not equal the next row’s PROJ_START value, this is an instance of a single row group. Once you have identify the ranges, you need to be able to group the rows in these ranges together  into groups  and return only their start and end points. Examine the first row of the desired result set. The PROJ_START is the PROJ_ START for PROJ_ID 1 from view V, and the PROJ_END is the PROJ_END for PROJ_ID 4 from view V. Despite the fact that PROJ_ID 4 does not have a consecutive value following it, it is the last of a range of consecutive values, and thus it is included in the first group. The most straightforward approach for this problem is to use the LAG OVER window function. Use LAG OVER to determine whether each prior row’s PROJ_END equals the current row’s PROJ_START to help place the rows into groups. Once they are grouped, use the aggregate functions MIN and MAX to find their start and end points:  P R O J _ G R P   P R O J _ S T A R T     P R O J _ E N D   - - - - - - - -   - - - - - - - - - - -   - - - - - - - - - - -                 1   0 1 - J A N - 2 0 2 0   0 5 - J A N - 2 0 2 0                 2   0 6 - J A N - 2 0 2 0   0 7 - J A N - 2 0 2 0                 3   1 6 - J A N - 2 0 2 0   2 0 - J A N - 2 0 2 0                 4   2 1 - J A N - 2 0 2 0   2 2 - J A N - 2 0 2 0                 5   2 6 - J A N - 2 0 2 0   3 0 - J A N - 2 0 2 0   1   s e l e c t   p r o j _ g r p ,   m i n   p r o j _ s t a r t   ,   m a x   p r o j _ e n d       2       f r o m         3   s e l e c t   p r o j _ i d , p r o j _ s t a r t , p r o j _ e n d ,     4                 s u m   f l a g   o v e r   o r d e r   b y   p r o j _ i d     p r o j _ g r p     5       f r o m         6   s e l e c t   p r o j _ i d , p r o j _ s t a r t , p r o j _ e n d ,     7                 c a s e   w h e n    Discussion The window function LAG OVER is extremely useful in this situation. You can examine each prior row’s PROJ_END value without a self-join, without a scalar subquery, and without a view. The results of the LAG OVER function without the CASE expression are as follows:  The CASE expression in the complete solution simply compares the value returned by LAG OVER to the current row’s PROJ_START value; if they are the same, return 0, else return 1. The next step is to create a running total on the zeros and ones returned by the CASE expression to put each row into a group. The results of the running total are shown here:    8                           l a g   p r o j _ e n d   o v e r   o r d e r   b y   p r o j _ i d     =   p r o j _ s t a r t     9                           t h e n   0   e l s e   1   1 0                 e n d   f l a g   1 1       f r o m   V   1 2                     a l i a s 1   1 3                     a l i a s 2   1 4     g r o u p   b y   p r o j _ g r p s e l e c t   p r o j _ i d , p r o j _ s t a r t , p r o j _ e n d ,               l a g   p r o j _ e n d   o v e r   o r d e r   b y   p r o j _ i d     p r i o r _ p r o j _ e n d       f r o m   V       P R O J _ I D   P R O J _ S T A R T     P R O J _ E N D         P R I O R _ P R O J _ E N D   - - - - - - -   - - - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - - - - - - -               1   0 1 - J A N - 2 0 2 0   0 2 - J A N - 2 0 2 0               2   0 2 - J A N - 2 0 2 0   0 3 - J A N - 2 0 2 0   0 2 - J A N - 2 0 2 0               3   0 3 - J A N - 2 0 2 0   0 4 - J A N - 2 0 2 0   0 3 - J A N - 2 0 2 0               4   0 4 - J A N - 2 0 2 0   0 5 - J A N - 2 0 2 0   0 4 - J A N - 2 0 2 0               5   0 6 - J A N - 2 0 2 0   0 7 - J A N - 2 0 2 0   0 5 - J A N - 2 0 2 0               6   1 6 - J A N - 2 0 2 0   1 7 - J A N - 2 0 2 0   0 7 - J A N - 2 0 2 0               7   1 7 - J A N - 2 0 2 0   1 8 - J A N - 2 0 2 0   1 7 - J A N - 2 0 2 0               8   1 8 - J A N - 2 0 2 0   1 9 - J A N - 2 0 2 0   1 8 - J A N - 2 0 2 0               9   1 9 - J A N - 2 0 2 0   2 0 - J A N - 2 0 2 0   1 9 - J A N - 2 0 2 0             1 0   2 1 - J A N - 2 0 2 0   2 2 - J A N - 2 0 2 0   2 0 - J A N - 2 0 2 0             1 1   2 6 - J A N - 2 0 2 0   2 7 - J A N - 2 0 2 0   2 2 - J A N - 2 0 2 0             1 2   2 7 - J A N - 2 0 2 0   2 8 - J A N - 2 0 2 0   2 7 - J A N - 2 0 2 0             1 3   2 8 - J A N - 2 0 2 0   2 9 - J A N - 2 0 2 0   2 8 - J A N - 2 0 2 0             1 4   2 9 - J A N - 2 0 2 0   3 0 - J A N - 2 0 2 0   2 9 - J A N - 2 0 2 0  Now that each row has been placed into a group, simply use the aggregate functions MIN and MAX on PROJ_START and PROJ_END, respectively, and group by the values created in the PROJ_GRP running total column.  10.4 Filling in Missing Values in a Range of Values  Problem You want to return the number of employees hired each year for the entire decade of the 2005s, but there are some years in which no employees were hired. You would like to return the following result set:  s e l e c t   p r o j _ i d , p r o j _ s t a r t , p r o j _ e n d ,                 s u m   f l a g   o v e r   o r d e r   b y   p r o j _ i d     p r o j _ g r p       f r o m       s e l e c t   p r o j _ i d , p r o j _ s t a r t , p r o j _ e n d ,                 c a s e   w h e n                           l a g   p r o j _ e n d   o v e r   o r d e r   b y   p r o j _ i d     =   p r o j _ s t a r t                           t h e n   0   e l s e   1                 e n d   f l a g       f r o m   V                         P R O J _ I D   P R O J _ S T A R T     P R O J _ E N D             P R O J _ G R P   - - - - - - -   - - - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - - -               1   0 1 - J A N - 2 0 2 0   0 2 - J A N - 2 0 2 0                     1               2   0 2 - J A N - 2 0 2 0   0 3 - J A N - 2 0 2 0                     1               3   0 3 - J A N - 2 0 2 0   0 4 - J A N - 2 0 2 0                     1               4   0 4 - J A N - 2 0 2 0   0 5 - J A N - 2 0 2 0                     1               5   0 6 - J A N - 2 0 2 0   0 7 - J A N - 2 0 2 0                     2               6   1 6 - J A N - 2 0 2 0   1 7 - J A N - 2 0 2 0                     3               7   1 7 - J A N - 2 0 2 0   1 8 - J A N - 2 0 2 0                     3               8   1 8 - J A N - 2 0 2 0   1 9 - J A N - 2 0 2 0                     3               9   1 9 - J A N - 2 0 2 0   2 0 - J A N - 2 0 2 0                     3             1 0   2 1 - J A N - 2 0 2 0   2 2 - J A N - 2 0 2 0                     4             1 1   2 6 - J A N - 2 0 2 0   2 7 - J A N - 2 0 2 0                     5             1 2   2 7 - J A N - 2 0 2 0   2 8 - J A N - 2 0 2 0                     5             1 3   2 8 - J A N - 2 0 2 0   2 9 - J A N - 2 0 2 0                     5             1 4   2 9 - J A N - 2 0 2 0   3 0 - J A N - 2 0 2 0                     5  Solution The trick to this solution is returning zeros for years that saw no employees hired. If no employee was hired in a given year, then no rows for that year will exist in table EMP. If the year does not exist in the table, how can you return a count, any count, even zero? The solution requires you to outer join. You must supply a result set that returns all the years you want to see, and then perform a count against table EMP to see if there were any employees hired in each of those years.  DB2 Use table EMP as a pivot table  because it has 14 rows  and the built-in function YEAR to generate one row for each year in the decade of 2005. Outer join to table EMP and count how many employees were hired each year:  Y R                     C N T   - - - -   - - - - - - - - - -   2 0 0 5                     1   2 0 0 6                   1 0   2 0 0 7                     2   2 0 0 8                     1   2 0 0 9                     0   2 0 1 0                     0   2 0 1 1                     0   2 0 1 2                     0   2 0 1 3                     0   2 0 1 4                     0   1   s e l e c t   x . y r ,   c o a l e s c e   y . c n t , 0     c n t     2       f r o m         3   s e l e c t   y e a r   m i n   h i r e d a t e   o v e r         -     4                 m o d   y e a r   m i n   h i r e d a t e   o v e r       , 1 0     +     5                 r o w _ n u m b e r     o v e r     - 1   y r     6       f r o m   e m p   f e t c h   f i r s t   1 0   r o w s   o n l y     7                     x     8       l e f t   j o i n     9                     1 0   s e l e c t   y e a r   h i r e d a t e     y r 1 ,   c o u n t   *     c n t   1 1       f r o m   e m p   1 2     g r o u p   b y   y e a r   h i r e d a t e      Oracle The Oracle solution follows the same structure as the DB2 solution, with only the differences in the syntax Oracle handles causing a distinct solution to be required:  PostgreSQL and MySQL Use table T10 as a pivot table  because it has 10 rows  and the built-in function EXTRACT to generate one row for each year in the decade of 2005. Outer join to table EMP and count how many employees were hired each year:  1 3                     y   1 4           o n       x . y r   =   y . y r 1       1   s e l e c t   x . y r ,   c o a l e s c e   c n t , 0     c n t     2       f r o m         3   s e l e c t   e x t r a c t   y e a r   f r o m   m i n   h i r e d a t e   o v e r         -     4                 m o d   e x t r a c t   y e a r   f r o m   m i n   h i r e d a t e   o v e r       , 1 0     +     5                 r o w n u m - 1   y r     6       f r o m   e m p     7     w h e r e   r o w n u m   < =   1 0     8                     x     9       l e f t   j o i n   1 0                     1 1   s e l e c t   t o _ n u m b e r   t o _ c h a r   h i r e d a t e , ' Y Y Y Y '       y r ,   c o u n t   *     c n t   1 2       f r o m   e m p   1 3     g r o u p   b y   t o _ n u m b e r   t o _ c h a r   h i r e d a t e , ' Y Y Y Y '       1 4                     y   1 5           o n       x . y r   =   y . y r       1   s e l e c t   y . y r ,   c o a l e s c e   x . c n t , 0     a s   c n t     2       f r o m         3   s e l e c t m i n _ y e a r - m o d   c a s t   m i n _ y e a r   a s   i n t   , 1 0   + r n   a s   y r     4       f r o m         5   s e l e c t     s e l e c t   m i n   e x t r a c t   y e a r   f r o m   h i r e d a t e         6                       f r o m   e m p     a s   m i n _ y e a r ,     7                 i d - 1   a s   r n     8       f r o m   t 1 0     9                     a   1 0                     y   1 1       l e f t   j o i n   1 2                      SQL Server Use table EMP as a pivot table  because it has 14 rows  and the built-in function YEAR to generate one row for each year in the decade of 2005. Outer join to table EMP and count how many employees were hired each year:  Discussion Despite the difference in syntax, the approach is the same for all solutions. Inline view X returns each year in the decade of the ’80s by first finding the year of the earliest HIREDATE. The next step is to add RN–1 to the difference between the earliest year and the earliest year modulus ten. To see how this works, simply execute inline view X and return each of the values involved separately. Listed here is the result set for inline view X using the window function MIN OVER  DB2, Oracle, SQL Server  and a scalar subquery  MySQL, PostgreSQL :  1 3   s e l e c t   e x t r a c t   y e a r   f r o m   h i r e d a t e     a s   y r ,   c o u n t   *     a s   c n t   1 4       f r o m   e m p   1 5     g r o u p   b y   e x t r a c t   y e a r   f r o m   h i r e d a t e     1 6                     x   1 7           o n       y . y r   =   x . y r       1   s e l e c t   x . y r ,   c o a l e s c e   y . c n t , 0     c n t     2       f r o m         3   s e l e c t   t o p     1 0       4                   y e a r   m i n   h i r e d a t e   o v e r         -     5                   y e a r   m i n   h i r e d a t e   o v e r       % 1 0   +     6                   r o w _ n u m b e r     o v e r   o r d e r   b y   h i r e d a t e   - 1   y r     7       f r o m   e m p     8                     x     9       l e f t   j o i n   1 0                     1 1   s e l e c t   y e a r   h i r e d a t e     y r ,   c o u n t   *     c n t   1 2       f r o m   e m p   1 3     g r o u p   b y   y e a r   h i r e d a t e     1 4                     y   1 5           o n       x . y r   =   y . y r      s e l e c t   y e a r   m i n   h i r e d a t e   o v e r         -                 m o d   y e a r   m i n   h i r e d a t e   o v e r       , 1 0     +                 r o w _ n u m b e r     o v e r     - 1   y r ,                 y e a r   m i n   h i r e d a t e   o v e r         m i n _ y e a r ,                 m o d   y e a r   m i n   h i r e d a t e   o v e r       , 1 0     m o d _ y r ,                 r o w _ n u m b e r     o v e r     - 1   r n       f r o m   e m p   f e t c h   f i r s t   1 0   r o w s   o n l y         Y R       M I N _ Y E A R           M O D _ Y R                   R N   - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   2 0 0 5               2 0 0 5                     0                     0   2 0 0 6               2 0 0 5                     0                     1   2 0 0 7               2 0 0 5                     0                     2   2 0 0 8               2 0 0 5                     0                     3   1 9 8 4               2 0 0 5                     0                     4   2 0 1 0               2 0 0 5                     0                     5   2 0 1 1               2 0 0 5                     0                     6   2 0 1 2               2 0 0 5                     0                     7   2 0 1 3               2 0 0 5                     0                     8   2 0 1 4               2 0 0 5                     0                     9       s e l e c t   m i n _ y e a r - m o d   m i n _ y e a r , 1 0   + r n   a s   y r ,                 m i n _ y e a r ,                 m o d   m i n _ y e a r , 1 0     a s   m o d _ y r                 r n       f r o m       s e l e c t     s e l e c t   m i n   e x t r a c t   y e a r   f r o m   h i r e d a t e                           f r o m   e m p     a s   m i n _ y e a r ,                   i d - 1   a s   r n       f r o m   t 1 0                     x         Y R       M I N _ Y E A R           M O D _ Y R                   R N   - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   2 0 0 5               2 0 0 5                     0                     0   2 0 0 6               2 0 0 5                     0                     1   2 0 0 7               2 0 0 5                     0                     2   2 0 0 8               2 0 0 5                     0                     3   2 0 0 9               2 0 0 5                     0                     4   2 0 1 0               2 0 0 5                     0                     5   2 0 1 1               2 0 0 5                     0                     6   2 0 1 2               2 0 0 5                     0                     7   2 0 1 3               2 0 0 5                     0                     8   2 0 1 4               2 0 0 5                     0                     9  Inline view Y returns the year for each HIREDATE and the number of employees hired during that year:  Finally, outer join inline view Y to inline view X so that every year is returned even if there are no employees hired.  10.5 Generating Consecutive Numeric Values  Problem You would like to have a “row source generator” available to you in your queries. Row source generators are useful for queries that require pivoting. For example, you want to return a result set such as the following, up to any number of rows that you specify:  s e l e c t   y e a r   h i r e d a t e     y r ,   c o u n t   *     c n t       f r o m   e m p     g r o u p   b y   y e a r   h i r e d a t e             Y R                 C N T   - - - - -   - - - - - - - - - -     2 0 0 5                     1     2 0 0 6                   1 0     2 0 0 7                     2     2 0 0 8                     1 I D   - - -       1       2       3       4       5       6       7       8       9     1 0   …  If your RDBMS provides built-in functions for returning rows dynamically, you do not need to create a pivot table in advance with a fixed number of rows. That’s why a dynamic row generator can be so handy. Otherwise, you must use a traditional pivot table with a fixed number of rows  that may not always be enough  to generate rows when needed.  Solution This solution shows how to return 10 rows of increasing numbers starting from 1. You can easily adapt the solution to return any number of rows. The ability to return increasing values from one opens the door to many other solutions. For example, you can generate numbers to add to dates in order to generate sequences of days. You can also use such numbers to parse through strings.  DB2 and SQL Server Use the recursive WITH clause to generate a sequence of rows with incrementing values. Using a recursive CTE will in fact work with the majority of RDBMSs today:  Oracle In Oracle Database you can generate rows using the MODEL clause:    1   w i t h   x     i d       2   a s         3   s e l e c t   1     4     u n i o n   a l l     5   s e l e c t   i d + 1     6       f r o m   x     7     w h e r e   i d + 1   < =   1 0     8         9   s e l e c t   *   f r o m   x 1   s e l e c t   a r r a y   i d   2       f r o m   d u a l   3     m o d e l   4         d i m e n s i o n   b y     0   i d x     5         m e a s u r e s   1   a r r a y      PostgreSQL Use the handy function GENERATE_SERIES, which is designed for the express purpose of generating rows:  Discussion  DB2 and SQL Server The recursive WITH clause increments ID  which starts at one  until the WHERE clause is satisfied. To kick things off, you must generate one row having the value 1. You can do this by selecting 1 from a one-row table or, in the case of DB2, by using the VALUES clause to create a one-row result set.  Oracle In the MODEL clause solution, there is an explicit ITERATE command that allows you to generate multiple rows. Without the ITERATE clause, only one row will be returned, since DUAL has only one row. For example:  The MODEL clause not only allows you array access to rows, it allows you to easily “create” or return rows that are not in the table you are selecting  6         r u l e s   i t e r a t e     1 0         7             a r r a y [ i t e r a t i o n _ n u m b e r ]   =   i t e r a t i o n _ n u m b e r + 1   8           1   s e l e c t   i d   2       f r o m   g e n e r a t e _ s e r i e s     1 ,   1 0     x   i d   s e l e c t   a r r a y   i d       f r o m   d u a l   m o d e l       d i m e n s i o n   b y     0   i d x         m e a s u r e s   1   a r r a y         r u l e s             I D     - -       1  against. In this solution, IDX is the array index  location of a specific value in the array  and ARRAY  aliased ID  is the “array” of rows. The first row defaults to 1 and can be referenced with ARRAY[0]. Oracle provides the function ITERATION_NUMBER so you can track the number of times you’ve iterated. The solution iterates 10 times, causing ITERATION_NUMBER to go from 0 to 9. Adding one to each of those values yields the results 1 through 10. It may be easier to visualize what’s happening with the model clause if you execute the following query:  PostgreSQL All the work is done by the function GENERATE_SERIES. The function accepts three parameters, all numeric values. The first parameter is the start value, the second parameter is the ending value, and the third parameter is an optional “step” value  how much each value is incremented by . If you do not pass a third parameter, the increment defaults to one.  s e l e c t   ' a r r a y [ '   i d x   ' ]   =   '   a r r a y   a s   o u t p u t       f r o m   d u a l     m o d e l         d i m e n s i o n   b y     0   i d x           m e a s u r e s   1   a r r a y           r u l e s   i t e r a t e     1 0                   a r r a y [ i t e r a t i o n _ n u m b e r ]   =   i t e r a t i o n _ n u m b e r + 1               O U T P U T   - - - - - - - - - - - - - - - - - -   a r r a y [ 0 ]   =   1   a r r a y [ 1 ]   =   2   a r r a y [ 2 ]   =   3   a r r a y [ 3 ]   =   4   a r r a y [ 4 ]   =   5   a r r a y [ 5 ]   =   6   a r r a y [ 6 ]   =   7   a r r a y [ 7 ]   =   8   a r r a y [ 8 ]   =   9   a r r a y [ 9 ]   =   1 0  The GENERATE_SERIES function is flexible enough so that you do not have to hardcode parameters. For example, if you wanted to return 5 rows starting from value 10 and ending with value 30, incrementing by 5 such that the result set is the following:  you can be creative and do something like this:  Notice here that the actual values passed to GENERATE_SERIES are not known when the query is written. Instead, they are generated by subqueries when the main query executes.  10.6 Summing Up Queries that take into account ranges are one of the most common requests from business users—they are a natural consquence of the way that businesses operate. At least some of the time, however, a degree of dexterity is needed to apply the range correctly, and the recipes in this chapter should demonstrate how to apply that dexterity.    I D   - - -     1 0     1 5     2 0     2 5     3 0 s e l e c t   i d       f r o m   g e n e r a t e _ s e r i e s                         s e l e c t   m i n   d e p t n o     f r o m   e m p   ,                       s e l e c t   m a x   d e p t n o     f r o m   e m p   ,                     5                     x   i d    Chapter 11. Advanced Searching  In a very real sense, this entire book so far has been about searching. You’ve seen all sorts of queries that use joins and WHERE clauses and grouping techniques to search out and return the results you need. Some types of searching operations, though, stand apart from others in that they represent a different way of thinking about searching. Perhaps you’re displaying a result set one page at a time. Half of that problem is to identify  search for  the entire set of records that you want to display. The other half of that problem is to repeatedly search for the next page to display as a user cycles through the records on a display. Your first thought may not be to think of pagination as a searching problem, but it can be thought of that way, and it can be solved that way; that is the type of searching solution this chapter is all about.  11.1 Paginating Through a Result Set  Problem You want to paginate or “scroll through” a result set. For example, you want to return the first five salaries from table EMP, then the next five, and so forth. Your goal is to allow a user to view five records at a time, scrolling forward with each click of a Next button.  Solution Because there is no concept of first, last, or next in SQL, you must impose order on the rows you are working with. Only by imposing order can you accurately return ranges of records.   Use the window function ROW_NUMBER OVER to impose order, and specify the window of records that you want returned in your WHERE clause. For example, use this to return rows 1 through 5:  Then use this to return rows 6 through 10:  You can return any range of rows that you want simply by changing the WHERE clause of your query.  s e l e c t   s a l       f r o m       s e l e c t   r o w _ n u m b e r       o v e r     o r d e r   b y   s a l     a s   r n ,                 s a l       f r o m   e m p                     x     w h e r e   r n   b e t w e e n   1   a n d   5         S A L   - - - -     8 0 0     9 5 0   1 1 0 0   1 2 5 0   1 2 5 0 s e l e c t   s a l       f r o m       s e l e c t   r o w _ n u m b e r       o v e r     o r d e r   b y   s a l     a s   r n ,                 s a l       f r o m   e m p                     x     w h e r e   r n   b e t w e e n   6   a n d   1 0           S A L   - - - - -     1 3 0 0     1 5 0 0     1 6 0 0     2 4 5 0     2 8 5 0  Discussion The window function ROW_NUMBER OVER in inline view X will assign a unique number to each salary  in increasing order starting from 1 . Listed here is the result set for inline view X:  Once a number has been assigned to a salary, simply pick the range you want to return by specifying values for RN. For Oracle users, an alternative: you can use ROWNUM instead of ROW NUMBER OVER to generate sequence numbers for the rows:  s e l e c t   r o w _ n u m b e r       o v e r     o r d e r   b y   s a l     a s   r n ,                 s a l       f r o m   e m p     R N                   S A L   - -     - - - - - - - - - -     1                   8 0 0     2                   9 5 0     3                 1 1 0 0     4                 1 2 5 0     5                 1 2 5 0     6                 1 3 0 0     7                 1 5 0 0     8                 1 6 0 0     9                 2 4 5 0   1 0                 2 8 5 0   1 1                 2 9 7 5   1 2                 3 0 0 0   1 3                 3 0 0 0   1 4                 5 0 0 0 s e l e c t   s a l       f r o m       s e l e c t   s a l ,   r o w n u m   r n       f r o m       s e l e c t   s a l       f r o m   e m p     o r d e r   b y   s a l                                         w h e r e   r n   b e t w e e n   6   a n d   1 0      Using ROWNUM forces you into writing an extra level of subquery. The innermost subquery sorts rows by salary. The next outermost subquery applies row numbers to those rows, and, finally, the very outermost SELECT returns the data you are after.  11.2 Skipping n Rows from a Table  Problem You want a query to return every other employee in table EMP; you want the first employee, third employee, and so forth. For example, from the following result set:  you want to return the following:      S A L   - - - - -     1 3 0 0     1 5 0 0     1 6 0 0     2 4 5 0     2 8 5 0 E N A M E   - - - - - - - -   A D A M S   A L L E N   B L A K E   C L A R K   F O R D   J A M E S   J O N E S   K I N G   M A R T I N   M I L L E R   S C O T T   S M I T H   T U R N E R   W A R D  Solution To skip the second or fourth or nth row from a result set, you must impose order on the result set; otherwise, there is no concept of first or next, second, or fourth. Use the window function ROW_NUMBER OVER to assign a number to each row, which you can then use in conjunction with the modulo function to skip unwanted rows. The modulo function is MOD for DB2, MySQL, PostgreSQL, and Oracle. In SQL Server, use the percent  %  operator. The following example uses MOD to skip even-numbered rows:  Discussion The call to the window function ROW_NUMBER OVER in inline view X will assign a rank to each row  no ties, even with duplicate names . The results are shown here:  E N A M E   - - - - - - - - - -   A D A M S   B L A K E   F O R D   J O N E S   M A R T I N   S C O T T   T U R N E R 1     s e l e c t   e n a m e   2         f r o m       3     s e l e c t   r o w _ n u m b e r       o v e r     o r d e r   b y   e n a m e     r n ,   4                   e n a m e   5         f r o m   e m p   6                       x   7       w h e r e   m o d   r n , 2     =   1 s e l e c t   r o w _ n u m b e r       o v e r     o r d e r   b y   e n a m e     r n ,   e n a m e       f r o m   e m p     R N   E N A M E   - -   - - - - - - - -     1   A D A M S    The last step is to simply use modulus to skip every other row.  11.3 Incorporating OR Logic When Using Outer Joins  Problem You want to return the name and department information for all employees in departments 10 and 20 along with department information for departments 30 and 40  but no employee information . Your first attempt looks like this:    2   A L L E N     3   B L A K E     4   C L A R K     5   F O R D     6   J A M E S     7   J O N E S     8   K I N G     9   M A R T I N   1 0   M I L L E R   1 1   S C O T T   1 2   S M I T H   1 3   T U R N E R   1 4   W A R D s e l e c t   e . e n a m e ,   d . d e p t n o ,   d . d n a m e ,   d . l o c       f r o m   d e p t   d ,   e m p   e     w h e r e   d . d e p t n o   =   e . d e p t n o         a n d     e . d e p t n o   =   1 0   o r   e . d e p t n o   =   2 0       o r d e r   b y   2     E N A M E               D E P T N O   D N A M E                     L O C   - - - - - - -   - - - - - - - - - -   - - - - - - - - - - - - - -   - - - - - - - - - - -   C L A R K                       1 0   A C C O U N T I N G           N E W   Y O R K   K I N G                         1 0   A C C O U N T I N G           N E W   Y O R K   M I L L E R                     1 0   A C C O U N T I N G           N E W   Y O R K   S M I T H                       2 0   R E S E A R C H               D A L L A S   A D A M S                       2 0   R E S E A R C H               D A L L A S   F O R D                         2 0   R E S E A R C H               D A L L A S    Because the join in this query is an inner join, the result set does not include department information for DEPTNOs 30 and 40. You attempt to outer join EMP to DEPT with the following query, but you still do not get the correct results:  Ultimately, you would like the result set to be the following:  Solution  S C O T T                       2 0   R E S E A R C H               D A L L A S   J O N E S                       2 0   R E S E A R C H               D A L L A S s e l e c t   e . e n a m e ,   d . d e p t n o ,   d . d n a m e ,   d . l o c       f r o m   d e p t   d   l e f t   j o i n   e m p   e           o n     d . d e p t n o   =   e . d e p t n o       w h e r e   e . d e p t n o   =   1 0           o r   e . d e p t n o   =   2 0     o r d e r   b y   2     E N A M E               D E P T N O   D N A M E                 L O C   - - - - - - -   - - - - - - - - - -   - - - - - - - - - - - -   - - - - - - - - - - -   C L A R K                       1 0   A C C O U N T I N G       N E W   Y O R K   K I N G                         1 0   A C C O U N T I N G       N E W   Y O R K   M I L L E R                     1 0   A C C O U N T I N G       N E W   Y O R K   S M I T H                       2 0   R E S E A R C H           D A L L A S   A D A M S                       2 0   R E S E A R C H           D A L L A S   F O R D                         2 0   R E S E A R C H           D A L L A S   S C O T T                       2 0   R E S E A R C H           D A L L A S   J O N E S                       2 0   R E S E A R C H           D A L L A S E N A M E               D E P T N O   D N A M E                 L O C   - - - - - - -   - - - - - - - - - -   - - - - - - - - - - - -   - - - - - - - - -   C L A R K                       1 0   A C C O U N T I N G         N E W   Y O R K   K I N G                         1 0   A C C O U N T I N G         N E W   Y O R K   M I L L E R                     1 0   A C C O U N T I N G         N E W   Y O R K   S M I T H                       2 0   R E S E A R C H             D A L L A S   J O N E S                       2 0   R E S E A R C H             D A L L A S   S C O T T                       2 0   R E S E A R C H             D A L L A S   A D A M S                       2 0   R E S E A R C H             D A L L A S   F O R D                         2 0   R E S E A R C H             D A L L A S                                   3 0   S A L E S                   C H I C A G O                                   4 0   O P E R A T I O N S         B O S T O N  Move the OR condition into the JOIN clause:  Alternatively, you can filter on EMP.DEPTNO first in an inline view and then outer join:  Discussion  DB2, MySQL, PostgreSQL, and SQL Server Two solutions are given for these products. The first moves the OR condition into the JOIN clause, making it part of the join condition. By doing that, you can filter the rows returned from EMP without losing DEPTNOs 30 and 40 from DEPT. The second solution moves the filtering into an inline view. Inline view E filters on EMP.DEPTNO and returns EMP rows of interest. These are then outer joined to DEPT. Because DEPT is the anchor table in the outer join, all departments, including 30 and 40, are returned.  11.4 Determining Which Rows Are Reciprocals  Problem  1     s e l e c t   e . e n a m e ,   d . d e p t n o ,   d . d n a m e ,   d . l o c   2         f r o m   d e p t   d   l e f t   j o i n   e m p   e   3             o n     d . d e p t n o   =   e . d e p t n o   4                   a n d     e . d e p t n o = 1 0   o r   e . d e p t n o = 2 0       5       o r d e r   b y   2 1     s e l e c t   e . e n a m e ,   d . d e p t n o ,   d . d n a m e ,   d . l o c   2         f r o m   d e p t   d   3         l e f t   j o i n   4                     s e l e c t   e n a m e ,   d e p t n o   5                         f r o m   e m p   6                       w h e r e   d e p t n o   i n       1 0 ,   2 0       7                       e   o n       e . d e p t n o   =   d . d e p t n o       8     o r d e r   b y   2  You have a table containing the results of two tests, and you want to determine which pair of scores are reciprocals. Consider the following result set from view V:  Examining these results, you see that a test score for TEST1 of 70 and TEST2 of 90 is a reciprocal  there exists a score of 90 for TEST1 and a score of 70 for TEST2 . Likewise, the scores of 80 for TEST1 and 130 for TEST2 are reciprocals of 130 for TEST1 and 80 for TEST2. Additionally, the scores of 20 for TEST1 and 20 for TEST2 are reciprocals of 20 for TEST2 and 20 for TEST1. You want to identify only one set of reciprocals. You want your result set to be this:  not this:  s e l e c t   *       f r o m   V     T E S T 1             T E S T 2   - - - - -   - - - - - - - - - -         2 0                   2 0         5 0                   2 5         2 0                   2 0         6 0                   3 0         7 0                   9 0         8 0                 1 3 0         9 0                   7 0       1 0 0                   5 0       1 1 0                   5 5       1 2 0                   6 0       1 3 0                   8 0       1 4 0                   7 0 T E S T 1             T E S T 2   - - - - -     - - - - - - - - -         2 0                   2 0         7 0                   9 0         8 0                 1 3 0 T E S T 1             T E S T 2   - - - - -     - - - - - - - - -         2 0                   2 0    Solution Use a self-join to identify rows where TEST1 equals TEST2, and vice versa:  Discussion The self-join results in a Cartesian product in which every TEST1 score can be compared against every TEST2 score, and vice versa. The following query will identify the reciprocals:  The use of DISTINCT ensures that duplicate rows are removed from the final result set. The final filter in the WHERE clause  and V1.TEST1 <=        2 0                   2 0         7 0                   9 0         8 0                 1 3 0         9 0                   7 0       1 3 0                   8 0 s e l e c t   d i s t i n c t   v 1 . *       f r o m   V   v 1 ,   V   v 2     w h e r e   v 1 . t e s t 1   =   v 2 . t e s t 2         a n d   v 1 . t e s t 2   =   v 2 . t e s t 1         a n d   v 1 . t e s t 1   < =   v 1 . t e s t 2 s e l e c t   v 1 . *       f r o m   V   v 1 ,   V   v 2     w h e r e   v 1 . t e s t 1   =   v 2 . t e s t 2         a n d   v 1 . t e s t 2   =   v 2 . t e s t 1     T E S T 1             T E S T 2   - - - - -   - - - - - - - - - -         2 0                   2 0         2 0                   2 0         2 0                   2 0         2 0                   2 0         9 0                   7 0       1 3 0                   8 0         7 0                   9 0         8 0                 1 3 0  V1.TEST2  will ensure that only one pair of reciprocals  where TEST1 is the smaller or equal value  is returned.  11.5 Selecting the Top n Records  Problem You want to limit a result set to a specific number of records based on a ranking of some sort. For example, you want to return the names and salaries of the employees with the top five salaries.  Solution The solution to this problem depends on the use of a window function. Which window function you will use depends on how you want to deal with ties. The following solution uses DENSE_RANK so that each tie in salary will count as only one against the total:  The total number of rows returned may exceed five, but there will be only five distinct salaries. Use ROW_NUMBER OVER if you want to return five rows regardless of ties  as no ties are allowed with this function .  Discussion The window function DENSE_RANK OVER in inline view X does all the work. The following example shows the entire table after applying that function:  1     s e l e c t   e n a m e , s a l   2         f r o m       3     s e l e c t   e n a m e ,   s a l ,   4                   d e n s e _ r a n k       o v e r     o r d e r   b y   s a l   d e s c     d r   5         f r o m   e m p   6                       x   7       w h e r e   d r   < =   5  Now it’s just a matter of returning rows where DR is less than or equal to five.  11.6 Finding Records with the Highest and Lowest Values  Problem You want to find “extreme” values in your table. For example, you want to find the employees with the highest and lowest salaries in table EMP.  Solution  DB2, Oracle, and SQL Server Use the window functions MIN OVER and MAX OVER to find the lowest and highest salaries, respectively:  s e l e c t   e n a m e ,   s a l ,                 d e n s e _ r a n k       o v e r     o r d e r   b y   s a l   d e s c     d r       f r o m   e m p     E N A M E             S A L                   D R   - - - - - - -   - - - - - -   - - - - - - - - - -   K I N G             5 0 0 0                     1   S C O T T           3 0 0 0                     2   F O R D             3 0 0 0                     2   J O N E S           2 9 7 5                     3   B L A K E           2 8 5 0                     4   C L A R K           2 4 5 0                     5   A L L E N           1 6 0 0                     6   T U R N E R         1 5 0 0                     7   M I L L E R         1 3 0 0                     8   W A R D             1 2 5 0                     9   M A R T I N         1 2 5 0                     9   A D A M S           1 1 0 0                   1 0   J A M E S             9 5 0                   1 1   S M I T H             8 0 0                   1 2  Discussion  DB2, Oracle, and SQL Server The window functions MIN OVER and MAX OVER allow each row to have access to the lowest and highest salaries. The result set from inline view X is as follows:  Given this result set, all that’s left is to return rows where SAL equals MIN_SAL or MAX_SAL.  1     s e l e c t   e n a m e   2         f r o m       3     s e l e c t   e n a m e ,   s a l ,   4                   m i n   s a l   o v e r       m i n _ s a l ,   5                   m a x   s a l   o v e r       m a x _ s a l   6         f r o m   e m p   7                       x   8       w h e r e   s a l   i n     m i n _ s a l , m a x _ s a l   s e l e c t   e n a m e ,   s a l ,                 m i n   s a l   o v e r       m i n _ s a l ,                 m a x   s a l   o v e r       m a x _ s a l       f r o m   e m p     E N A M E             S A L         M I N _ S A L         M A X _ S A L   - - - - - - -   - - - - - -   - - - - - - - - - -   - - - - - - - - - -   S M I T H             8 0 0                 8 0 0               5 0 0 0   A L L E N           1 6 0 0                 8 0 0               5 0 0 0   W A R D             1 2 5 0                 8 0 0               5 0 0 0   J O N E S           2 9 7 5                 8 0 0               5 0 0 0   M A R T I N         1 2 5 0                 8 0 0               5 0 0 0   B L A K E           2 8 5 0                 8 0 0               5 0 0 0   C L A R K           2 4 5 0                 8 0 0               5 0 0 0   S C O T T           3 0 0 0                 8 0 0               5 0 0 0   K I N G             5 0 0 0                 8 0 0               5 0 0 0   T U R N E R         1 5 0 0                 8 0 0               5 0 0 0   A D A M S           1 1 0 0                 8 0 0               5 0 0 0   J A M E S             9 5 0                 8 0 0               5 0 0 0   F O R D             3 0 0 0                 8 0 0               5 0 0 0   M I L L E R         1 3 0 0                 8 0 0               5 0 0 0  11.7 Investigating Future Rows  Problem You want to find any employees who earn less than the employee hired immediately after them. Based on the following result set:  SMITH, WARD, MARTIN, JAMES, and MILLER earn less than the person hired immediately after they were hired, so those are the employees you want to find with a query.  Solution The first step is to define what “future” means. You must impose order on your result set to be able to define a row as having a value that is “later” than another. You can use the LEAD OVER window function to access the salary of the next employee that was hired. It’s then a simple matter to check whether that salary is larger:  E N A M E                           S A L   H I R E D A T E   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - -   S M I T H                           8 0 0   1 7 - D E C - 8 0   A L L E N                         1 6 0 0   2 0 - F E B - 8 1   W A R D                           1 2 5 0   2 2 - F E B - 8 1   J O N E S                         2 9 7 5   0 2 - A P R - 8 1   B L A K E                         2 8 5 0   0 1 - M A Y - 8 1   C L A R K                         2 4 5 0   0 9 - J U N - 8 1   T U R N E R                       1 5 0 0   0 8 - S E P - 8 1   M A R T I N                       1 2 5 0   2 8 - S E P - 8 1   K I N G                           5 0 0 0   1 7 - N O V - 8 1   J A M E S                           9 5 0   0 3 - D E C - 8 1   F O R D                           3 0 0 0   0 3 - D E C - 8 1   M I L L E R                       1 3 0 0   2 3 - J A N - 8 2   S C O T T                         3 0 0 0   0 9 - D E C - 8 2   A D A M S                         1 1 0 0   1 2 - J A N - 8 3 1     s e l e c t   e n a m e ,   s a l ,   h i r e d a t e   2         f r o m       3     s e l e c t   e n a m e ,   s a l ,   h i r e d a t e ,    Discussion The window function LEAD OVER is perfect for a problem such as this one. It not only makes for a more readable query than the solution for the other products, LEAD OVER also leads to a more flexible solution because an argument can be passed to it that will determine how many rows ahead it should look  by default one . Being able to leap ahead more than one row is important in the case of duplicates in the column you are ordering by. The following example shows how easy it is to use LEAD OVER to look at the salary of the “next” employee hired:  The final step is to return only rows where SAL is less than NEXT_SAL. Because of LEAD OVER’s default range of one row, if there had been duplicates in table EMP—in particular, multiple employees hired on the same date—their SAL would be compared. This may or may not have been  4                   l e a d   s a l   o v e r   o r d e r   b y   h i r e d a t e     n e x t _ s a l   5         f r o m   e m p   6                       a l i a s   7       w h e r e   s a l   <   n e x t _ s a l s e l e c t   e n a m e ,   s a l ,   h i r e d a t e ,                 l e a d   s a l   o v e r   o r d e r   b y   h i r e d a t e     n e x t _ s a l       f r o m   e m p     E N A M E             S A L   H I R E D A T E         N E X T _ S A L   - - - - - - -   - - - - - -   - - - - - - - - -   - - - - - - - - - -   S M I T H             8 0 0   1 7 - D E C - 8 0               1 6 0 0   A L L E N           1 6 0 0   2 0 - F E B - 8 1               1 2 5 0   W A R D             1 2 5 0   2 2 - F E B - 8 1               2 9 7 5   J O N E S           2 9 7 5   0 2 - A P R - 8 1               2 8 5 0   B L A K E           2 8 5 0   0 1 - M A Y - 8 1               2 4 5 0   C L A R K           2 4 5 0   0 9 - J U N - 8 1               1 5 0 0   T U R N E R         1 5 0 0   0 8 - S E P - 8 1               1 2 5 0   M A R T I N         1 2 5 0   2 8 - S E P - 8 1               5 0 0 0   K I N G             5 0 0 0   1 7 - N O V - 8 1                 9 5 0   J A M E S             9 5 0   0 3 - D E C - 8 1               3 0 0 0   F O R D             3 0 0 0   0 3 - D E C - 8 1               1 3 0 0   M I L L E R         1 3 0 0   2 3 - J A N - 8 2               3 0 0 0   S C O T T           3 0 0 0   0 9 - D E C - 8 2               1 1 0 0   A D A M S           1 1 0 0   1 2 - J A N - 8 3  what you intended. If your goal is to compare the SAL of each employee with SAL of the next employee hired, excluding other employees hired on the same day, you can use the following solution as an alternative:  The idea behind this solution is to find the distance from the current row to the row it should be compared with. For example, if there are five duplicates, the first of the five needs to leap five rows to get to its correct LEAD OVER row. The value for CNT represents, for each employee with a duplicate HIREDATE, how many duplicates there are in total for their HIREDATE. The value for RN represents a ranking for the employees in DEPTNO 10. The rank is partitioned by HIREDATE so only employees with a HIREDATE that another employee has will have a value greater than one. The ranking is sorted by EMPNO  this is arbitrary . Now that you know how many total duplicates there are and you have a ranking of each duplicate, the distance to the next HIREDATE is simply the total number of duplicates minus the current rank plus one  CNT-RN+1 .  See Also For additional examples of using LEAD OVER in the presence of duplicates  and a more thorough discussion of this technique , see Recipe 8.7 and Recipe 10.2.  11.8 Shifting Row Values  s e l e c t   e n a m e ,   s a l ,   h i r e d a t e       f r o m       s e l e c t   e n a m e ,   s a l ,   h i r e d a t e ,                 l e a d   s a l , c n t - r n + 1   o v e r   o r d e r   b y   h i r e d a t e     n e x t _ s a l       f r o m       s e l e c t   e n a m e , s a l , h i r e d a t e ,                 c o u n t   *   o v e r   p a r t i t i o n   b y   h i r e d a t e     c n t ,                 r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   h i r e d a t e   o r d e r   b y   e m p n o     r n       f r o m   e m p                                         w h e r e   s a l   <   n e x t _ s a l  Problem You want to return each employee’s name and salary along with the next highest and lowest salaries. If there are no higher or lower salaries, you want the results to wrap  first SAL shows last SAL and vice versa . You want to return the following result set:  Solution The window functions LEAD OVER and LAG OVER make this problem easy to solve and the resulting queries very readable. Use the window functions LAG OVER and LEAD OVER to access prior and next rows relative to the current row:  Discussion The window functions LAG OVER and LEAD OVER will  by default and unless otherwise specified  return values from the row before and after the current row, respectively. You define what “before” or “after” means in the  E N A M E                           S A L         F O R W A R D           R E W I N D   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   S M I T H                           8 0 0                 9 5 0               5 0 0 0   J A M E S                           9 5 0               1 1 0 0                 8 0 0   A D A M S                         1 1 0 0               1 2 5 0                 9 5 0   W A R D                           1 2 5 0               1 2 5 0               1 1 0 0   M A R T I N                       1 2 5 0               1 3 0 0               1 2 5 0   M I L L E R                       1 3 0 0               1 5 0 0               1 2 5 0   T U R N E R                       1 5 0 0               1 6 0 0               1 3 0 0   A L L E N                         1 6 0 0               2 4 5 0               1 5 0 0   C L A R K                         2 4 5 0               2 8 5 0               1 6 0 0   B L A K E                         2 8 5 0               2 9 7 5               2 4 5 0   J O N E S                         2 9 7 5               3 0 0 0               2 8 5 0   S C O T T                         3 0 0 0               3 0 0 0               2 9 7 5   F O R D                           3 0 0 0               5 0 0 0               3 0 0 0   K I N G                           5 0 0 0                 8 0 0               3 0 0 0 1     s e l e c t   e n a m e , s a l ,   2                   c o a l e s c e   l e a d   s a l   o v e r   o r d e r   b y   s a l   , m i n   s a l   o v e r         f o r w a r d ,   3                   c o a l e s c e   l a g   s a l   o v e r   o r d e r   b y   s a l   , m a x   s a l   o v e r         r e w i n d   4         f r o m   e m p  ORDER BY portion of the OVER clause. If you examine the solution, the first step is to return the next and prior rows relative to the current row, ordered by SAL:  Notice that REWIND is NULL for employee SMITH, and FORWARD is NULL for employee KING; that is because those two employees have the lowest and highest salaries, respectively. The requirement in the “Problem” section should NULL values exist in FORWARD or REWIND is to “wrap” the results, meaning that for the highest SAL, FORWARD should be the value of the lowest SAL in the table, and for the lowest SAL, REWIND should be the value of the highest SAL in the table. The window functions MIN OVER and MAX OVER with no partition or window specified  i.e., an empty parentheses after the OVER clause  will return the lowest and highest salaries in the table, respectively. The results are shown here:  s e l e c t   e n a m e , s a l ,                 l e a d   s a l   o v e r   o r d e r   b y   s a l     f o r w a r d ,                 l a g   s a l   o v e r   o r d e r   b y   s a l     r e w i n d       f r o m   e m p       E N A M E                           S A L         F O R W A R D           R E W I N D   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   S M I T H                           8 0 0                 9 5 0   J A M E S                           9 5 0               1 1 0 0                 8 0 0   A D A M S                         1 1 0 0               1 2 5 0                 9 5 0   W A R D                           1 2 5 0               1 2 5 0               1 1 0 0   M A R T I N                       1 2 5 0               1 3 0 0               1 2 5 0   M I L L E R                       1 3 0 0               1 5 0 0               1 2 5 0   T U R N E R                       1 5 0 0               1 6 0 0               1 3 0 0   A L L E N                         1 6 0 0               2 4 5 0               1 5 0 0   C L A R K                         2 4 5 0               2 8 5 0               1 6 0 0   B L A K E                         2 8 5 0               2 9 7 5               2 4 5 0   J O N E S                         2 9 7 5               3 0 0 0               2 8 5 0   S C O T T                         3 0 0 0               3 0 0 0               2 9 7 5   F O R D                           3 0 0 0               5 0 0 0               3 0 0 0   K I N G                           5 0 0 0                                     3 0 0 0 s e l e c t   e n a m e , s a l ,                 c o a l e s c e   l e a d   s a l   o v e r   o r d e r   b y   s a l   , m i n   s a l   o v e r         f o r w a r d ,                 c o a l e s c e   l a g   s a l   o v e r   o r d e r   b y   s a l   , m a x   s a l   o v e r         r e w i n d    Another useful feature of LAG OVER and LEAD OVER is the ability to define how far forward or back you would like to go. In the example for this recipe, you go only one row forward or back. If want to move three rows forward and five rows back, doing so is simple. Just specify the values 3 and 5, as shown here:      f r o m   e m p       E N A M E                           S A L         F O R W A R D           R E W I N D   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   S M I T H                           8 0 0                 9 5 0               5 0 0 0   J A M E S                           9 5 0               1 1 0 0                 8 0 0   A D A M S                         1 1 0 0               1 2 5 0                 9 5 0   W A R D                           1 2 5 0               1 2 5 0               1 1 0 0   M A R T I N                       1 2 5 0               1 3 0 0               1 2 5 0   M I L L E R                       1 3 0 0               1 5 0 0               1 2 5 0   T U R N E R                       1 5 0 0               1 6 0 0               1 3 0 0   A L L E N                         1 6 0 0               2 4 5 0               1 5 0 0   C L A R K                         2 4 5 0               2 8 5 0               1 6 0 0   B L A K E                         2 8 5 0               2 9 7 5               2 4 5 0   J O N E S                         2 9 7 5               3 0 0 0               2 8 5 0   S C O T T                         3 0 0 0               3 0 0 0               2 9 7 5   F O R D                           3 0 0 0               5 0 0 0               3 0 0 0   K I N G                           5 0 0 0                 8 0 0               3 0 0 0 s e l e c t   e n a m e , s a l ,                 l e a d   s a l , 3   o v e r   o r d e r   b y   s a l     f o r w a r d ,                 l a g   s a l , 5   o v e r   o r d e r   b y   s a l     r e w i n d       f r o m   e m p     E N A M E                           S A L         F O R W A R D           R E W I N D   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   S M I T H                           8 0 0             1 2 5 0   J A M E S                           9 5 0             1 2 5 0   A D A M S                         1 1 0 0             1 3 0 0   W A R D                           1 2 5 0             1 5 0 0   M A R T I N                       1 2 5 0             1 6 0 0   M I L L E R                       1 3 0 0             2 4 5 0                   8 0 0   T U R N E R                       1 5 0 0             2 8 5 0                   9 5 0   A L L E N                         1 6 0 0             2 9 7 5                 1 1 0 0   C L A R K                         2 4 5 0             3 0 0 0                 1 2 5 0   B L A K E                         2 8 5 0             3 0 0 0                 1 2 5 0   J O N E S                         2 9 7 5             5 0 0 0                 1 3 0 0   S C O T T                         3 0 0 0                                     1 5 0 0    11.9 Ranking Results  Problem You want to rank the salaries in table EMP while allowing for ties. You want to return the following result set:  Solution Window functions make ranking queries extremely simple. Three window functions are particularly useful for ranking: DENSE_RANK OVER, ROW_NUMBER OVER, and RANK OVER. Because you want to allow for ties, use the window function DENSE_RANK OVER:  Discussion  F O R D                           3 0 0 0                                     1 6 0 0   K I N G                           5 0 0 0                                     2 4 5 0 R N K           S A L   - - -   - - - - - - -       1           8 0 0       2           9 5 0       3         1 1 0 0       4         1 2 5 0       4         1 2 5 0       5         1 3 0 0       6         1 5 0 0       7         1 6 0 0       8         2 4 5 0       9         2 8 5 0     1 0         2 9 7 5     1 1         3 0 0 0     1 1         3 0 0 0     1 2         5 0 0 0 1   s e l e c t   d e n s e _ r a n k       o v e r   o r d e r   b y   s a l     r n k ,   s a l   2       f r o m   e m p  The window function DENSE_RANK OVER does all the legwork here. In parentheses following the OVER keyword you place an ORDER BY clause to specify the order in which rows are ranked. The solution uses ORDER BY SAL, so rows from EMP are ranked in ascending order of salary.  11.10 Suppressing Duplicates  Problem You want to find the different job types in table EMP but do not want to see duplicates. The result set should be as follows:  Solution All of the RDBMSs support the keyword DISTINCT, and it arguably is the easiest mechanism for suppressing duplicates from the result set. However, this recipe will also cover two additional methods for suppressing duplicates. The traditional method of using DISTINCT and sometimes GROUP BY certainly works. The following solution is an alternative that makes use of the window function ROW_NUMBER OVER:  J O B   - - - - - - - - -   A N A L Y S T   C L E R K   M A N A G E R   P R E S I D E N T   S A L E S M A N 1     s e l e c t   j o b   2         f r o m       3     s e l e c t   j o b ,   4                   r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   j o b   o r d e r   b y   j o b     r n   5         f r o m   e m p   6                       x   7       w h e r e   r n   =   1  Traditional alternatives Use the DISTINCT keyword to suppress duplicates from the result set:  Additionally, it is also possible to use GROUP BY to suppress duplicates:  Discussion  DB2, Oracle, and SQL Server This solution depends on some outside-the-box thinking about partitioned window functions. By using PARTITION BY in the OVER clause of ROW_NUMBER, you can reset the value returned by ROW_NUMBER to 1 whenever a new job is encountered. The following results are from inline view X:  s e l e c t   d i s t i n c t   j o b       f r o m   e m p s e l e c t   j o b       f r o m   e m p     g r o u p   b y   j o b s e l e c t   j o b ,                 r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   j o b   o r d e r   b y   j o b     r n       f r o m   e m p       J O B                               R N   - - - - - - - - -   - - - - - - - - - -   A N A L Y S T                         1   A N A L Y S T                         2   C L E R K                             1   C L E R K                             2   C L E R K                             3   C L E R K                             4   M A N A G E R                         1   M A N A G E R                         2   M A N A G E R                         3   P R E S I D E N T                     1   S A L E S M A N                       1   S A L E S M A N                       2    Each row is given an increasing, sequential number, and that number is reset to one whenever the job changes. To filter out the duplicates, all you must do is keep the rows where RN is 1. An ORDER BY clause is mandatory when using ROW_NUMBER OVER  except in DB2  but doesn’t affect the result. Which job is returned is irrelevant so long as you return one of each job.  Traditional alternatives The first solution shows how to use the keyword DISTINCT to suppress duplicates from a result set. Keep in mind that DISTINCT is applied to the whole SELECT list; additional columns can and will change the result set. Consider the difference between these two queries:  By adding DEPTNO to the SELECT list, what you return is each DISTINCT pair of JOB DEPTNO values from table EMP. The second solution uses GROUP BY to suppress duplicates. While using GROUP BY in this way is not uncommon, keep in mind that GROUP BY and DISTINCT are two very different clauses that are not interchangeable. I’ve included GROUP BY in this solution for completeness, as you will no doubt come across it at some point.  S A L E S M A N                       3   S A L E S M A N                       4 s e l e c t   d i s t i n c t   j o b                       s e l e c t   d i s t i n c t   j o b ,   d e p t n o       f r o m   e m p                                             f r o m   e m p     J O B                                                       J O B                       D E P T N O   - - - - - - - - -                                           - - - - - - - - -   - - - - - - - - - -   A N A L Y S T                                               A N A L Y S T                       2 0   C L E R K                                                   C L E R K                           1 0   M A N A G E R                                               C L E R K                           2 0   P R E S I D E N T                                           C L E R K                           3 0   S A L E S M A N                                             M A N A G E R                       1 0                                                               M A N A G E R                       2 0                                                               M A N A G E R                       3 0                                                               P R E S I D E N T                   1 0                                                               S A L E S M A N                     3 0  11.11 Finding Knight Values  Problem You want return a result set that contains each employee’s name, the department they work in, their salary, the date they were hired, and the salary of the last employee hired, in each department. You want to return the following result set:  The values in LATEST_SAL are the “knight values” because the path to find them is analogous to a knight’s path in the game of chess. You determine the result the way a knight determines a new location: by jumping to a row and then turning and jumping to a different column  see Figure 11-1 . To find the correct values for LATEST_SAL, you must first locate  jump to  the row with the latest HIREDATE in each DEPTNO, and then you select  jump to  the SAL column of that row.  D E P T N O   E N A M E                           S A L   H I R E D A T E         L A T E S T _ S A L   - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - - -           1 0   M I L L E R                         1 3 0 0   2 3 - J A N - 2 0 0 7             1 3 0 0           1 0   K I N G                             5 0 0 0   1 7 - N O V - 2 0 0 6             1 3 0 0           1 0   C L A R K                           2 4 5 0   0 9 - J U N - 2 0 0 6             1 3 0 0           2 0   A D A M S                           1 1 0 0   1 2 - J A N - 2 0 0 7             1 1 0 0           2 0   S C O T T                           3 0 0 0   0 9 - D E C - 2 0 0 7             1 1 0 0           2 0   F O R D                             3 0 0 0   0 3 - D E C - 2 0 0 6             1 1 0 0           2 0   J O N E S                           2 9 7 5   0 2 - A P R - 2 0 0 6             1 1 0 0           2 0   S M I T H                             8 0 0   1 7 - D E C - 2 0 0 5             1 1 0 0           3 0   J A M E S                             9 5 0   0 3 - D E C - 2 0 0 6               9 5 0           3 0   M A R T I N                         1 2 5 0   2 8 - S E P - 2 0 0 6               9 5 0           3 0   T U R N E R                         1 5 0 0   0 8 - S E P - 2 0 0 6               9 5 0           3 0   B L A K E                           2 8 5 0   0 1 - M A Y - 2 0 0 6               9 5 0           3 0   W A R D                             1 2 5 0   2 2 - F E B - 2 0 0 6               9 5 0           3 0   A L L E N                           1 6 0 0   2 0 - F E B - 2 0 0 6               9 5 0  Figure 11-1. A knight value comes from “up and over”  TIP  The term knight value was coined by a clever coworker of Anthony’s, Kay Young. After having him review the recipes for correctness, Anthony admitted to Kay that he was stumped and could not come up with a good title. Because you need to initially evaluate one row and then “jump” and take a value from another, Kay came up with the term knight value.  Solution  DB2 and SQL Server Use a CASE expression in a subquery to return the SAL of the last employee hired in each DEPTNO; for all other salaries, return 0. Use the window function MAX OVER in the outer query to return the nonzero SAL for each employee’s department:    1     s e l e c t   d e p t n o ,     2                   e n a m e ,     3                   s a l ,     4                   h i r e d a t e ,     5                   m a x   l a t e s t _ s a l   o v e r   p a r t i t i o n   b y   d e p t n o     l a t e s t _ s a l     6         f r o m         7     s e l e c t   d e p t n o ,     8                   e n a m e ,    Oracle Use the window function MAX OVER to return the highest SAL for each DEPTNO. Use the functions DENSE_RANK and LAST, while ordering by HIREDATE in the KEEP clause to return the highest SAL for the latest HIREDATE in a given DEPTNO:  Discussion  DB2 and SQL Server The first step is to use the window function MAX OVER in a CASE expression to find the employee hired last, or most recently, in each DEPTNO. If an employee’s HIREDATE matches the value returned by MAX OVER, then use a CASE expression to return that employee’s SAL; otherwise, return zero. The results of this are shown here:  ,   9                   s a l ,   1 0                   h i r e d a t e ,   1 1                   c a s e   1 2                       w h e n   h i r e d a t e   =   m a x   h i r e d a t e   o v e r   p a r t i t i o n   b y   d e p t n o     1 3                       t h e n   s a l   e l s e   0   1 4                   e n d   l a t e s t _ s a l   1 5         f r o m   e m p   1 6                       x   1 7       o r d e r   b y   1 ,   4   d e s c 1     s e l e c t   d e p t n o ,   2                     e n a m e ,   3                     s a l ,   4                     h i r e d a t e ,   5                       m a x   s a l     6                           k e e p   d e n s e _ r a n k   l a s t   o r d e r   b y   h i r e d a t e     7                           o v e r   p a r t i t i o n   b y   d e p t n o     l a t e s t _ s a l   8         f r o m   e m p   9     o r d e r   b y   1 ,   4   d e s c s e l e c t   d e p t n o ,                 e n a m e ,                 s a l ,                 h i r e d a t e ,                 c a s e    Because the value for LATEST_SAL will be either zero or the SAL of the employee s  hired most recently, you can wrap the previous query in an inline view and use MAX OVER again, but this time to return the greatest nonzero LATEST_SAL for each DEPTNO:                        w h e n   h i r e d a t e   =   m a x   h i r e d a t e   o v e r   p a r t i t i o n   b y   d e p t n o                           t h e n   s a l   e l s e   0                 e n d   l a t e s t _ s a l       f r o m   e m p       D E P T N O   E N A M E                           S A L   H I R E D A T E         L A T E S T _ S A L   - - - - - -   - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - - -           1 0   C L A R K                         2 4 5 0   0 9 - J U N - 2 0 0 6                     0           1 0   K I N G                           5 0 0 0   1 7 - N O V - 2 0 0 6                     0           1 0   M I L L E R                       1 3 0 0   2 3 - J A N - 2 0 0 7               1 3 0 0           2 0   S M I T H                           8 0 0   1 7 - D E C - 2 0 0 5                     0           2 0   A D A M S                         1 1 0 0   1 2 - J A N - 2 0 0 7               1 1 0 0           2 0   F O R D                           3 0 0 0   0 3 - D E C - 2 0 0 6                     0           2 0   S C O T T                         3 0 0 0   0 9 - D E C - 2 0 0 7                     0           2 0   J O N E S                         2 9 7 5   0 2 - A P R - 2 0 0 6                     0           3 0   A L L E N                         1 6 0 0   2 0 - F E B - 2 0 0 6                     0           3 0   B L A K E                         2 8 5 0   0 1 - M A Y - 2 0 0 6                     0           3 0   M A R T I N                       1 2 5 0   2 8 - S E P - 2 0 0 6                     0           3 0   J A M E S                           9 5 0   0 3 - D E C - 2 0 0 6                 9 5 0           3 0   T U R N E R                       1 5 0 0   0 8 - S E P - 2 0 0 6                     0           3 0   W A R D                           1 2 5 0   2 2 - F E B - 2 0 0 6                     0 s e l e c t   d e p t n o ,                 e n a m e ,                 s a l ,                 h i r e d a t e ,                 m a x   l a t e s t _ s a l   o v e r   p a r t i t i o n   b y   d e p t n o     l a t e s t _ s a l       f r o m       s e l e c t   d e p t n o ,                 e n a m e ,                 s a l ,                 h i r e d a t e ,                 c a s e                         w h e n   h i r e d a t e   =   m a x   h i r e d a t e   o v e r   p a r t i t i o n   b y   d e p t n o                           t h e n   s a l   e l s e   0                 e n d   l a t e s t _ s a l       f r o m   e m p                     x     o r d e r   b y   1 ,   4   d e s c    Oracle The key to the Oracle solution is to take advantage of the KEEP clause. The KEEP clause allows you to rank the rows returned by a group partition and work with the first or last row in the group. Consider what the solution looks like without KEEP:      D E P T N O     E N A M E                         S A L   H I R E D A T E         L A T E S T _ S A L   - - - - - - -   - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - - -           1 0     M I L L E R                     1 3 0 0   2 3 - J A N - 2 0 0 7               1 3 0 0           1 0     K I N G                         5 0 0 0   1 7 - N O V - 2 0 0 6               1 3 0 0           1 0     C L A R K                       2 4 5 0   0 9 - J U N - 2 0 0 6               1 3 0 0           2 0     A D A M S                       1 1 0 0   1 2 - J A N - 2 0 0 7               1 1 0 0           2 0     S C O T T                       3 0 0 0   0 9 - D E C - 2 0 0 7               1 1 0 0           2 0     F O R D                         3 0 0 0   0 3 - D E C - 2 0 0 6               1 1 0 0           2 0     J O N E S                       2 9 7 5   0 2 - A P R - 2 0 0 6               1 1 0 0           2 0     S M I T H                         8 0 0   1 7 - D E C - 2 0 0 5               1 1 0 0           3 0     J A M E S                         9 5 0   0 3 - D E C - 2 0 0 6                 9 5 0           3 0     M A R T I N                     1 2 5 0   2 8 - S E P - 2 0 0 6                 9 5 0           3 0     T U R N E R                     1 5 0 0   0 8 - S E P - 2 0 0 6                 9 5 0           3 0     B L A K E                       2 8 5 0   0 1 - M A Y - 2 0 0 6                 9 5 0           3 0     W A R D                         1 2 5 0   2 2 - F E B - 2 0 0 6                 9 5 0           3 0     A L L E N                       1 6 0 0   2 0 - F E B - 2 0 0 6                 9 5 0 s e l e c t   d e p t n o ,                 e n a m e ,                 s a l ,                 h i r e d a t e ,                 m a x   s a l     o v e r   p a r t i t i o n   b y   d e p t n o     l a t e s t _ s a l       f r o m   e m p     o r d e r   b y   1 ,   4   d e s c       D E P T N O   E N A M E                           S A L   H I R E D A T E         L A T E S T _ S A L   - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - - -           1 0   M I L L E R                       1 3 0 0   2 3 - J A N - 2 0 0 7               5 0 0 0           1 0   K I N G                           5 0 0 0   1 7 - N O V - 2 0 0 6               5 0 0 0           1 0   C L A R K                         2 4 5 0   0 9 - J U N - 2 0 0 6               5 0 0 0           2 0   A D A M S                         1 1 0 0   1 2 - J A N - 2 0 0 7               3 0 0 0           2 0   S C O T T                         3 0 0 0   0 9 - D E C - 2 0 0 7               3 0 0 0           2 0   F O R D                           3 0 0 0   0 3 - D E C - 2 0 0 6               3 0 0 0           2 0   J O N E S                         2 9 7 5   0 2 - A P R - 2 0 0 6               3 0 0 0           2 0   S M I T H                           8 0 0   1 7 - D E C - 2 0 0 5               3 0 0 0    Rather than returning the SAL of the latest employee hired, MAX OVER without KEEP simply returns the highest salary in each DEPTNO. KEEP, in this recipe, allows you to order the salaries by HIREDATE in each DEPTNO by specifying ORDER BY HIREDATE. Then, the function DENSE_RANK assigns a rank to each HIREDATE in ascending order. Finally, the function LAST determines which row to apply the aggregate function to: the “last” row based on the ranking of DENSE_RANK. In this case, the aggregate function MAX is applied to the SAL column for the row with the “last” HIREDATE. In essence, keep the SAL of the HIREDATE ranked last in each DEPTNO. You are ranking the rows in each DEPTNO based on one column  HIREDATE , but then applying the aggregation  MAX  on another column  SAL . This ability to rank in one dimension and aggregate over another is convenient as it allows you to avoid extra joins and inline views as are used in the other solutions. Finally, by adding the OVER clause after the KEEP clause, you can return the SAL “kept” by KEEP for each row in the partition. Alternatively, you can order by HIREDATE in descending order and “keep” the first SAL. Compare the following two queries, which return the same result set:          3 0   J A M E S                           9 5 0   0 3 - D E C - 2 0 0 6               2 8 5 0           3 0   M A R T I N                       1 2 5 0   2 8 - S E P - 2 0 0 6               2 8 5 0           3 0   T U R N E R                       1 5 0 0   0 8 - S E P - 2 0 0 6               2 8 5 0           3 0   B L A K E                         2 8 5 0   0 1 - M A Y - 2 0 0 6               2 8 5 0           3 0   W A R D                           1 2 5 0   2 2 - F E B - 2 0 0 6               2 8 5 0           3 0   A L L E N                         1 6 0 0   2 0 - F E B - 2 0 0 6               2 8 5 0 s e l e c t   d e p t n o ,                 e n a m e ,                 s a l ,                 h i r e d a t e ,                 m a x   s a l                       k e e p   d e n s e _ r a n k   l a s t   o r d e r   b y   h i r e d a t e                       o v e r   p a r t i t i o n   b y   d e p t n o     l a t e s t _ s a l       f r o m   e m p     o r d e r   b y   1 ,   4   d e s c        D E P T N O   E N A M E                           S A L   H I R E D A T E         L A T E S T _ S A L   - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - - -           1 0   M I L L E R                       1 3 0 0   2 3 - J A N - 2 0 0 7               1 3 0 0           1 0   K I N G                           5 0 0 0   1 7 - N O V - 2 0 0 6               1 3 0 0           1 0   C L A R K                         2 4 5 0   0 9 - J U N - 2 0 0 6               1 3 0 0           2 0   A D A M S                         1 1 0 0   1 2 - J A N - 2 0 0 7               1 1 0 0           2 0   S C O T T                         3 0 0 0   0 9 - D E C - 2 0 0 7               1 1 0 0           2 0   F O R D                           3 0 0 0   0 3 - D E C - 2 0 0 6               1 1 0 0           2 0   J O N E S                         2 9 7 5   0 2 - A P R - 2 0 0 6               1 1 0 0           2 0   S M I T H                           8 0 0   1 7 - D E C - 2 0 0 5               1 1 0 0           3 0   J A M E S                           9 5 0   0 3 - D E C - 2 0 0 6                 9 5 0           3 0   M A R T I N                       1 2 5 0   2 8 - S E P - 2 0 0 6                 9 5 0           3 0   T U R N E R                       1 5 0 0   0 8 - S E P - 2 0 0 6                 9 5 0           3 0   B L A K E                         2 8 5 0   0 1 - M A Y - 2 0 0 6                 9 5 0           3 0   W A R D                           1 2 5 0   2 2 - F E B - 2 0 0 6                 9 5 0           3 0   A L L E N                         1 6 0 0   2 0 - F E B - 2 0 0 6                 9 5 0       s e l e c t   d e p t n o ,                 e n a m e ,                 s a l ,                 h i r e d a t e ,                 m a x   s a l                       k e e p   d e n s e _ r a n k   f i r s t   o r d e r   b y   h i r e d a t e   d e s c                       o v e r   p a r t i t i o n   b y   d e p t n o     l a t e s t _ s a l       f r o m   e m p     o r d e r   b y   1 ,   4   d e s c       D E P T N O   E N A M E                           S A L   H I R E D A T E         L A T E S T _ S A L   - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - - -           1 0   M I L L E R                       1 3 0 0   2 3 - J A N - 2 0 0 7               1 3 0 0           1 0   K I N G                           5 0 0 0   1 7 - N O V - 2 0 0 6               1 3 0 0           1 0   C L A R K                         2 4 5 0   0 9 - J U N - 2 0 0 6               1 3 0 0           2 0   A D A M S                         1 1 0 0   1 2 - J A N - 2 0 0 7               1 1 0 0           2 0   S C O T T                         3 0 0 0   0 9 - D E C - 2 0 0 7               1 1 0 0           2 0   F O R D                           3 0 0 0   0 3 - D E C - 2 0 0 6               1 1 0 0           2 0   J O N E S                         2 9 7 5   0 2 - A P R - 2 0 0 6               1 1 0 0           2 0   S M I T H                           8 0 0   1 7 - D E C - 2 0 0 5               1 1 0 0           3 0   J A M E S                           9 5 0   0 3 - D E C - 2 0 0 6                 9 5 0           3 0   M A R T I N                       1 2 5 0   2 8 - S E P - 2 0 0 6                 9 5 0           3 0   T U R N E R                       1 5 0 0   0 8 - S E P - 2 0 0 6                 9 5 0           3 0   B L A K E                         2 8 5 0   0 1 - M A Y - 2 0 0 6                 9 5 0           3 0   W A R D                           1 2 5 0   2 2 - F E B - 2 0 0 6                 9 5 0           3 0   A L L E N                         1 6 0 0   2 0 - F E B - 2 0 0 6                 9 5 0  11.12 Generating Simple Forecasts  Problem Based on current data, you want to return additional rows and columns representing future actions. For example, consider the following result set:  You want to return three rows per row returned in your result set  each row plus two additional rows for each order . Along with the extra rows, you would like to return two additional columns providing dates for expected order processing. From the previous result set, you can see that an order takes two days to process. For the purposes of this example, let’s say the next step after processing is verification, and the last step is shipment. Verification occurs one day after processing, and shipment occurs one day after verification. You want to return a result set expressing the whole procedure. Ultimately you want to transform the previous result set to the following result set:  Solution  I D   O R D E R _ D A T E     P R O C E S S _ D A T E   - -   - - - - - - - - - - -   - - - - - - - - - - - -     1   2 5 - S E P - 2 0 0 5     2 7 - S E P - 2 0 0 5     2   2 6 - S E P - 2 0 0 5     2 8 - S E P - 2 0 0 5     3   2 7 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5 I D   O R D E R _ D A T E     P R O C E S S _ D A T E     V E R I F I E D           S H I P P E D   - -   - - - - - - - - - - -   - - - - - - - - - - - -     - - - - - - - - - - -     - - - - - - - - - - -     1   2 5 - S E P - 2 0 0 5     2 7 - S E P - 2 0 0 5     1   2 5 - S E P - 2 0 0 5     2 7 - S E P - 2 0 0 5     2 8 - S E P - 2 0 0 5     1   2 5 - S E P - 2 0 0 5     2 7 - S E P - 2 0 0 5     2 8 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5     2   2 6 - S E P - 2 0 0 5     2 8 - S E P - 2 0 0 5     2   2 6 - S E P - 2 0 0 5     2 8 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5     2   2 6 - S E P - 2 0 0 5     2 8 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5     3 0 - S E P - 2 0 0 5     3   2 7 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5     3   2 7 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5     3 0 - S E P - 2 0 0 5     3   2 7 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5     3 0 - S E P - 2 0 0 5     0 1 - O C T - 2 0 0 5  The key is to use a Cartesian product to generate two additional rows for each order and then simply use CASE expressions to create the required column values.  DB2, MySQL, and SQL Server Use the recursive WITH clause to generate rows needed for your Cartesian product. The DB2 and SQL Server solutions are identical except for the function used to retrieve the current date. DB2 uses CURRENT_DATE and SQL Server uses GET-DATE. MySQL uses the CURDATE and requires the insertion of the keyword RECURSIVE after WITH to indicate that this is a recursive CTE. The SQL Server solution is shown here:  Oracle Use the hierarchical CONNECT BY clause to generate the three rows needed for the Cartesian product. Use the WITH clause to allow you to reuse the results returned by CONNECT BY without having to call it again:    1     w i t h   n r o w s   n     a s         2     s e l e c t   1   f r o m   t 1   u n i o n   a l l     3     s e l e c t   n + 1   f r o m   n r o w s   w h e r e   n + 1   < =   3     4           5     s e l e c t   i d ,     6                   o r d e r _ d a t e ,     7                   p r o c e s s _ d a t e ,     8                   c a s e   w h e n   n r o w s . n   > =   2     9                             t h e n   p r o c e s s _ d a t e + 1   1 0                             e l s e   n u l l   1 1                   e n d   a s   v e r i f i e d ,   1 2                   c a s e   w h e n   n r o w s . n   =   3   1 3                             t h e n   p r o c e s s _ d a t e + 2   1 4                             e l s e   n u l l   1 5                   e n d   a s   s h i p p e d   1 6         f r o m       1 7     s e l e c t   n r o w s . n   i d ,   1 8                   g e t d a t e     + n r o w s . n       a s   o r d e r _ d a t e ,   1 9                   g e t d a t e     + n r o w s . n + 2   a s   p r o c e s s _ d a t e   2 0         f r o m   n r o w s   2 1                       o r d e r s ,   n r o w s   2 2       o r d e r   b y   1  PostgreSQL You can create a Cartesian product many different ways; this solution uses the PostgreSQL function GENERATE_SERIES:    1     w i t h   n r o w s   a s         2     s e l e c t   l e v e l   n     3         f r o m   d u a l     4     c o n n e c t   b y   l e v e l   < =   3     5           6     s e l e c t   i d ,     7                   o r d e r _ d a t e ,     8                   p r o c e s s _ d a t e ,     9                   c a s e   w h e n   n r o w s . n   > =   2   1 0                             t h e n   p r o c e s s _ d a t e + 1   1 1                             e l s e   n u l l   1 2                   e n d   a s   v e r i f i e d ,   1 3                   c a s e   w h e n   n r o w s . n   =   3   1 4                             t h e n   p r o c e s s _ d a t e + 2   1 5                             e l s e   n u l l   1 6                   e n d   a s   s h i p p e d   1 7     f r o m       1 8   s e l e c t   n r o w s . n   i d ,   1 9                 s y s d a t e + n r o w s . n   a s   o r d e r _ d a t e ,   2 0                 s y s d a t e + n r o w s . n + 2   a s   p r o c e s s _ d a t e   2 1       f r o m   n r o w s   2 2                     o r d e r s ,   n r o w s   1   s e l e c t   i d ,     2                 o r d e r _ d a t e ,     3                 p r o c e s s _ d a t e ,     4                 c a s e   w h e n   g s . n   > =   2     5                           t h e n   p r o c e s s _ d a t e + 1     6                           e l s e   n u l l     7                 e n d   a s   v e r i f i e d ,     8                 c a s e   w h e n   g s . n   =   3     9                           t h e n   p r o c e s s _ d a t e + 2   1 0                           e l s e   n u l l   1 1                 e n d   a s   s h i p p e d   1 2     f r o m       1 3   s e l e c t   g s . i d ,   1 4                 c u r r e n t _ d a t e + g s . i d   a s   o r d e r _ d a t e ,   1 5                 c u r r e n t _ d a t e + g s . i d + 2   a s   p r o c e s s _ d a t e   1 6       f r o m   g e n e r a t e _ s e r i e s   1 , 3     g s     i d     1 7                     o r d e r s ,   1 8                     g e n e r a t e _ s e r i e s   1 , 3   g s   n    MySQL MySQL does not support a function for automatic row generation.  Discussion  DB2, MySQL, and SQL Server The result set presented in the “Problem” section is returned via inline view ORDERS, and is shown here:  This query simply uses the WITH clause to make up three rows representing the orders you must process. NROWS returns the values 1, 2, and 3, and those numbers are added to GETDATE  CURRENT_DATE for DB2, CURDATE   for MySQL  to represent the dates of the orders. Because the “Problem” section states that processing time takes two days, the query also adds two days to the ORDER_DATE  adds the value returned by NROWS to GETDATE and then adds two more days . Now that you have your base result set, the next step is to create a Cartesian product because the requirement is to return three rows for each order. Use NROWS to create a Cartesian product to return three rows for each order:  w i t h   n r o w s   n     a s       s e l e c t   1   f r o m   t 1   u n i o n   a l l   s e l e c t   n + 1   f r o m   n r o w s   w h e r e   n + 1   < =   3       s e l e c t   n r o w s . n   i d , g e t d a t e     + n r o w s . n       a s   o r d e r _ d a t e ,                 g e t d a t e     + n r o w s . n + 2   a s   p r o c e s s _ d a t e       f r o m   n r o w s     I D   O R D E R _ D A T E     P R O C E S S _ D A T E   - -   - - - - - - - - - - -   - - - - - - - - - - - -     1   2 5 - S E P - 2 0 0 5     2 7 - S E P - 2 0 0 5     2   2 6 - S E P - 2 0 0 5     2 8 - S E P - 2 0 0 5     3   2 7 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5 w i t h   n r o w s   n     a s       s e l e c t   1   f r o m   t 1   u n i o n   a l l   s e l e c t   n + 1   f r o m   n r o w s   w h e r e   n + 1   < =   3        Now that you have three rows for each order, simply use a CASE expression to create the addition column values to represent the status of verification and shipment. The first row for each order should have a NULL value for VERIFIED and SHIPPED. The second row for each order should have a NULL value for SHIPPED. The third row for each order should have non-NULL values for each column. The final result set is shown here:  s e l e c t   n r o w s . n ,                 o r d e r s . *       f r o m       s e l e c t   n r o w s . n   i d ,                 g e t d a t e     + n r o w s . n         a s   o r d e r _ d a t e ,                   g e t d a t e     + n r o w s . n + 2   a s   p r o c e s s _ d a t e       f r o m   n r o w s                     o r d e r s ,   n r o w s     o r d e r   b y   2 , 1         N     I D     O R D E R _ D A T E     P R O C E S S _ D A T E   - - -   - - -     - - - - - - - - - - -   - - - - - - - - - - - -       1       1     2 5 - S E P - 2 0 0 5     2 7 - S E P - 2 0 0 5       2       1     2 5 - S E P - 2 0 0 5     2 7 - S E P - 2 0 0 5       3       1     2 5 - S E P - 2 0 0 5     2 7 - S E P - 2 0 0 5       1       2     2 6 - S E P - 2 0 0 5     2 8 - S E P - 2 0 0 5       2       2     2 6 - S E P - 2 0 0 5     2 8 - S E P - 2 0 0 5       3       2     2 6 - S E P - 2 0 0 5     2 8 - S E P - 2 0 0 5       1       3     2 7 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5       2       3     2 7 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5       3       3     2 7 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5 w i t h   n r o w s   n     a s       s e l e c t   1   f r o m   t 1   u n i o n   a l l   s e l e c t   n + 1   f r o m   n r o w s   w h e r e   n + 1   < =   3       s e l e c t   i d ,                 o r d e r _ d a t e ,                 p r o c e s s _ d a t e ,                 c a s e   w h e n   n r o w s . n   > =   2                           t h e n   p r o c e s s _ d a t e + 1                           e l s e   n u l l                   e n d   a s   v e r i f i e d ,                 c a s e   w h e n   n r o w s . n   =   3                         t h e n   p r o c e s s _ d a t e + 2    The final result set expresses the complete order process, from the day the order was received to the day it should be shipped.  Oracle The result set presented in the problem section is returned via inline view ORDERS and is shown here:                        e l s e   n u l l                 e n d   a s   s h i p p e d       f r o m       s e l e c t   n r o w s . n   i d ,                 g e t d a t e     + n r o w s . n       a s   o r d e r _ d a t e ,                 g e t d a t e     + n r o w s . n + 2   a s   p r o c e s s _ d a t e       f r o m   n r o w s                     o r d e r s ,   n r o w s     o r d e r   b y   1     I D   O R D E R _ D A T E     P R O C E S S _ D A T E     V E R I F I E D           S H I P P E D   - -   - - - - - - - - - - -   - - - - - - - - - - - -     - - - - - - - - - - -     - - - - - - - - - - -     1   2 5 - S E P - 2 0 0 5     2 7 - S E P - 2 0 0 5     1   2 5 - S E P - 2 0 0 5     2 7 - S E P - 2 0 0 5     2 8 - S E P - 2 0 0 5     1   2 5 - S E P - 2 0 0 5     2 7 - S E P - 2 0 0 5     2 8 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5     2   2 6 - S E P - 2 0 0 5     2 8 - S E P - 2 0 0 5     2   2 6 - S E P - 2 0 0 5     2 8 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5     2   2 6 - S E P - 2 0 0 5     2 8 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5     3 0 - S E P - 2 0 0 5     3   2 7 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5     3   2 7 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5     3 0 - S E P - 2 0 0 5     3   2 7 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5     3 0 - S E P - 2 0 0 5     0 1 - O C T - 2 0 0 5 w i t h   n r o w s   a s       s e l e c t   l e v e l   n       f r o m   d u a l   c o n n e c t   b y   l e v e l   < =   3       s e l e c t   n r o w s . n   i d ,                 s y s d a t e + n r o w s . n   o r d e r _ d a t e ,                 s y s d a t e + n r o w s . n + 2   p r o c e s s _ d a t e       f r o m   n r o w s     I D   O R D E R _ D A T E       P R O C E S S _ D A T E   - -   - - - - - - - - - - -     - - - - - - - - - - - -     1   2 5 - S E P - 2 0 0 5       2 7 - S E P - 2 0 0 5     2   2 6 - S E P - 2 0 0 5       2 8 - S E P - 2 0 0 5     3   2 7 - S E P - 2 0 0 5       2 9 - S E P - 2 0 0 5  This query simply uses CONNECT BY to make up three rows representing the orders you must process. Use the WITH clause to refer to the rows returned by CONNECT BY as NROWS.N. CONNECT BY returns the values 1, 2, and 3, and those numbers are added to SYSDATE to represent the dates of the orders. Since the “Problem” section states that processing time takes two days, the query also adds two days to the ORDER_DATE  adds the value returned by GENERATE_ SERIES to SYSDATE and then adds two more days . Now that you have your base result set, the next step is to create a Cartesian product because the requirement is to return three rows for each order. Use NROWS to create a Cartesian product to return three rows for each order:  Now that you have three rows for each order, simply use a CASE expression to create the addition column values to represent the status of verification and shipment.  w i t h   n r o w s   a s       s e l e c t   l e v e l   n       f r o m   d u a l   c o n n e c t   b y   l e v e l   < =   3       s e l e c t   n r o w s . n ,                 o r d e r s . *       f r o m       s e l e c t   n r o w s . n   i d ,                 s y s d a t e + n r o w s . n   o r d e r _ d a t e ,                 s y s d a t e + n r o w s . n + 2   p r o c e s s _ d a t e       f r o m   n r o w s           o r d e r s ,   n r o w s         N     I D   O R D E R _ D A T E     P R O C E S S _ D A T E   - - -   - - -   - - - - - - - - - - -   - - - - - - - - - - - -       1       1   2 5 - S E P - 2 0 0 5     2 7 - S E P - 2 0 0 5       2       1   2 5 - S E P - 2 0 0 5     2 7 - S E P - 2 0 0 5       3       1   2 5 - S E P - 2 0 0 5     2 7 - S E P - 2 0 0 5       1       2   2 6 - S E P - 2 0 0 5     2 8 - S E P - 2 0 0 5       2       2   2 6 - S E P - 2 0 0 5     2 8 - S E P - 2 0 0 5       3       2   2 6 - S E P - 2 0 0 5     2 8 - S E P - 2 0 0 5       1       3   2 7 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5       2       3   2 7 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5       3       3   2 7 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5  The first row for each order should have a NULL value for VERIFIED and SHIPPED. The second row for each order should have a NULL value for SHIPPED. The third row for each order should have non-NULL values for each column. The final result set is shown here:  The final result set expresses the complete order process from the day the order was received to the day it should be shipped.  PostgreSQL  w i t h   n r o w s   a s       s e l e c t   l e v e l   n       f r o m   d u a l   c o n n e c t   b y   l e v e l   < =   3       s e l e c t   i d ,                 o r d e r _ d a t e ,                 p r o c e s s _ d a t e ,                 c a s e   w h e n   n r o w s . n   > =   2                           t h e n   p r o c e s s _ d a t e + 1                           e l s e   n u l l                 e n d   a s   v e r i f i e d ,                 c a s e   w h e n   n r o w s . n   =   3                           t h e n   p r o c e s s _ d a t e + 2                           e l s e   n u l l                 e n d   a s   s h i p p e d       f r o m       s e l e c t   n r o w s . n   i d ,                 s y s d a t e + n r o w s . n   o r d e r _ d a t e ,                 s y s d a t e + n r o w s . n + 2   p r o c e s s _ d a t e       f r o m   n r o w s                     o r d e r s ,   n r o w s       I D   O R D E R _ D A T E     P R O C E S S _ D A T E     V E R I F I E D           S H I P P E D     - -   - - - - - - - - - - -   - - - - - - - - - - - -     - - - - - - - - - - -     - - - - - - - - - - -       1   2 5 - S E P - 2 0 0 5     2 7 - S E P - 2 0 0 5       1   2 5 - S E P - 2 0 0 5     2 7 - S E P - 2 0 0 5     2 8 - S E P - 2 0 0 5       1   2 5 - S E P - 2 0 0 5     2 7 - S E P - 2 0 0 5     2 8 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5       2   2 6 - S E P - 2 0 0 5     2 8 - S E P - 2 0 0 5       2   2 6 - S E P - 2 0 0 5     2 8 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5       2   2 6 - S E P - 2 0 0 5     2 8 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5     3 0 - S E P - 2 0 0 5       3   2 7 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5       3   2 7 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5     3 0 - S E P - 2 0 0 5       3   2 7 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5     3 0 - S E P - 2 0 0 5     0 1 - O C T - 2 0 0 5  The result set presented in the problem section is returned via inline view ORDERS and is shown here:  This query simply uses the GENERATE_SERIES function to make up three rows representing the orders you must process. GENERATE_SERIES returns the values 1, 2, and 3, and those numbers are added to CURRENT_DATE to represent the dates of the orders. Since the “Problem” section states that processing time takes two days, the query also adds two days to the ORDER_DATE  adds the value returned by GENERATE_SERIES to CURRENT_DATE and then adds two more days . Now that you have your base result set, the next step is to create a Cartesian product because the requirement is to return three rows for each order. Use the GENERATE_ SERIES function to create a Cartesian product to return three rows for each order:  s e l e c t   g s . i d ,                 c u r r e n t _ d a t e + g s . i d   a s   o r d e r _ d a t e ,                 c u r r e n t _ d a t e + g s . i d + 2   a s   p r o c e s s _ d a t e     f r o m   g e n e r a t e _ s e r i e s   1 , 3     g s     i d       I D   O R D E R _ D A T E     P R O C E S S _ D A T E   - -   - - - - - - - - - - -   - - - - - - - - - - - -     1   2 5 - S E P - 2 0 0 5     2 7 - S E P - 2 0 0 5     2   2 6 - S E P - 2 0 0 5     2 8 - S E P - 2 0 0 5     3   2 7 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5 s e l e c t   g s . n ,                 o r d e r s . *       f r o m       s e l e c t   g s . i d ,                 c u r r e n t _ d a t e + g s . i d   a s   o r d e r _ d a t e ,                 c u r r e n t _ d a t e + g s . i d + 2   a s   p r o c e s s _ d a t e       f r o m   g e n e r a t e _ s e r i e s   1 , 3     g s     i d                       o r d e r s ,                     g e n e r a t e _ s e r i e s   1 , 3   g s   n           N   I D     O R D E R _ D A T E     P R O C E S S _ D A T E   - - -   - - -   - - - - - - - - - - -   - - - - - - - - - - - -       1       1   2 5 - S E P - 2 0 0 5     2 7 - S E P - 2 0 0 5       2       1   2 5 - S E P - 2 0 0 5     2 7 - S E P - 2 0 0 5       3       1   2 5 - S E P - 2 0 0 5     2 7 - S E P - 2 0 0 5    Now that you have three rows for each order, simply use a CASE expression to create the addition column values to represent the status of verification and shipment. The first row for each order should have a NULL value for VERIFIED and SHIPPED. The second row for each order should have a NULL value for SHIPPED. The third row for each order should have non-NULL values for each column. The final result set is shown here:      1       2   2 6 - S E P - 2 0 0 5     2 8 - S E P - 2 0 0 5       2       2   2 6 - S E P - 2 0 0 5     2 8 - S E P - 2 0 0 5       3       2   2 6 - S E P - 2 0 0 5     2 8 - S E P - 2 0 0 5       1       3   2 7 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5       2       3   2 7 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5       3       3   2 7 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5 s e l e c t   i d ,                 o r d e r _ d a t e ,                 p r o c e s s _ d a t e ,                 c a s e   w h e n   g s . n   > =   2                           t h e n   p r o c e s s _ d a t e + 1                           e l s e   n u l l                 e n d   a s   v e r i f i e d ,                 c a s e   w h e n   g s . n   =   3                           t h e n   p r o c e s s _ d a t e + 2                           e l s e   n u l l                 e n d   a s   s h i p p e d       f r o m       s e l e c t   g s . i d ,                 c u r r e n t _ d a t e + g s . i d   a s   o r d e r _ d a t e ,                 c u r r e n t _ d a t e + g s . i d + 2   a s   p r o c e s s _ d a t e       f r o m   g e n e r a t e _ s e r i e s   1 , 3     g s   i d                       o r d e r s ,                     g e n e r a t e _ s e r i e s   1 , 3   g s   n       I D   O R D E R _ D A T E     P R O C E S S _ D A T E     V E R I F I E D           S H I P P E D   - -   - - - - - - - - - - -   - - - - - - - - - - - -     - - - - - - - - - - -     - - - - - - - - - - -     1   2 5 - S E P - 2 0 0 5   2 7 - S E P - 2 0 0 5     1   2 5 - S E P - 2 0 0 5   2 7 - S E P - 2 0 0 5       2 8 - S E P - 2 0 0 5     1   2 5 - S E P - 2 0 0 5   2 7 - S E P - 2 0 0 5       2 8 - S E P - 2 0 0 5     2 9 - S E P - 2 0 0 5     2   2 6 - S E P - 2 0 0 5   2 8 - S E P - 2 0 0 5     2   2 6 - S E P - 2 0 0 5   2 8 - S E P - 2 0 0 5       2 9 - S E P - 2 0 0 5     2   2 6 - S E P - 2 0 0 5   2 8 - S E P - 2 0 0 5       2 9 - S E P - 2 0 0 5     3 0 - S E P - 2 0 0 5     3   2 7 - S E P - 2 0 0 5   2 9 - S E P - 2 0 0 5    The final result set expresses the complete order process from the day the order was received to the day it should be shipped.  11.13 Summing Up The recipes from this chapter represent practical problems that can’t be solved with a single function. They are some the kinds of problems that business users will frequently look to you to solve for them.    3   2 7 - S E P - 2 0 0 5   2 9 - S E P - 2 0 0 5       3 0 - S E P - 2 0 0 5     3   2 7 - S E P - 2 0 0 5   2 9 - S E P - 2 0 0 5       3 0 - S E P - 2 0 0 5     0 1 - O C T - 2 0 0 5  Chapter 12. Reporting and Reshaping  This chapter introduces queries you may find helpful for creating reports. These typically involve reporting-specific formatting considerations along with different levels of aggregation. Another focus of this chapter is transposing or pivoting result sets: reshaping the data by turning rows into columns. In general, these recipes have in common that they allow you to present data in formats or shapes different from the way they are stored. As your comfort level with pivoting increases, you’ll undoubtedly find uses for it outside of what are presented in this chapter.  12.1 Pivoting a Result Set into One Row  Problem You want to take values from groups of rows and turn those values into columns in a single row per group. For example, you have a result set displaying the number of employees in each department:  You would like to reformat the output so that the result set looks as follows:  D E P T N O                 C N T   - - - - - -   - - - - - - - - - -           1 0                     3           2 0                     5           3 0                     6 D E P T N O _ 1 0       D E P T N O _ 2 0       D E P T N O _ 3 0   - - - - - - - - -     - - - - - - - - - -     - - - - - - - - - -                   3                       5                       6  This is a classic example of data presented in a different shape than the way it is stored.  Solution Transpose the result set using CASE and the aggregate function SUM:  Discussion This example is an excellent introduction to pivoting. The concept is simple: for each row returned by the unpivoted query, use a CASE expression to separate the rows into columns. Then, because this particular problem is to count the number of employees per department, use the aggregate function SUM to count the occurrence of each DEPTNO. If you’re having trouble understanding how this works exactly, execute the query with the aggregate function SUM and include DEPTNO for readability:  1   s e l e c t   s u m   c a s e   w h e n   d e p t n o = 1 0   t h e n   1   e l s e   0   e n d     a s   d e p t n o _ 1 0 ,   2                 s u m   c a s e   w h e n   d e p t n o = 2 0   t h e n   1   e l s e   0   e n d     a s   d e p t n o _ 2 0 ,   3                 s u m   c a s e   w h e n   d e p t n o = 3 0   t h e n   1   e l s e   0   e n d     a s   d e p t n o _ 3 0   4       f r o m   e m p s e l e c t   d e p t n o ,                 c a s e   w h e n   d e p t n o = 1 0   t h e n   1   e l s e   0   e n d   a s   d e p t n o _ 1 0 ,                 c a s e   w h e n   d e p t n o = 2 0   t h e n   1   e l s e   0   e n d   a s   d e p t n o _ 2 0 ,                 c a s e   w h e n   d e p t n o = 3 0   t h e n   1   e l s e   0   e n d   a s   d e p t n o _ 3 0       f r o m   e m p     o r d e r   b y   1       D E P T N O       D E P T N O _ 1 0       D E P T N O _ 2 0       D E P T N O _ 3 0     - - - - - -     - - - - - - - - - -     - - - - - - - - - -     - - - - - - - - - -             1 0                       1                       0                       0             1 0                       1                       0                       0             1 0                       1                       0                       0             2 0                       0                       1                       0             2 0                       0                       1                       0             2 0                       0                       1                       0             2 0                       0                       1                       0             3 0                       0                       0                       1             3 0                       0                       0                       1    You can think of each CASE expression as a flag to determine which DEPTNO a row belongs to. At this point, the “rows to columns” transformation is already done; the next step is to simply sum the values returned by DEPTNO_10, DEPTNO_20, and DEPTNO_30, and then to group by DEPTNO. The following are the results:  If you inspect this result set, you see that logically the output makes sense; for example, DEPTNO 10 has three employees in DEPTNO_10 and zero in the other departments. Since the goal is to return one row, the last step is to remove the DEPTNO and GROUP BY clause and simply sum the CASE expressions:  The following is another approach that you may sometimes see applied to this same sort of problem:            3 0                       0                       0                       1             3 0                       0                       0                       1             3 0                       0                       0                       1             3 0                       0                       0                       1 s e l e c t   d e p t n o ,                 s u m   c a s e   w h e n   d e p t n o = 1 0   t h e n   1   e l s e   0   e n d     a s   d e p t n o _ 1 0 ,                 s u m   c a s e   w h e n   d e p t n o = 2 0   t h e n   1   e l s e   0   e n d     a s   d e p t n o _ 2 0 ,                 s u m   c a s e   w h e n   d e p t n o = 3 0   t h e n   1   e l s e   0   e n d     a s   d e p t n o _ 3 0       f r o m   e m p     g r o u p   b y   d e p t n o     D E P T N O       D E P T N O _ 1 0       D E P T N O _ 2 0       D E P T N O _ 3 0   - - - - - -     - - - - - - - - - -     - - - - - - - - - -     - - - - - - - - - -           1 0                       3                       0                       0           2 0                       0                       5                       0           3 0                       0                       0                       6 s e l e c t   s u m   c a s e   w h e n   d e p t n o = 1 0   t h e n   1   e l s e   0   e n d     a s   d e p t n o _ 1 0 ,                 s u m   c a s e   w h e n   d e p t n o = 2 0   t h e n   1   e l s e   0   e n d     a s   d e p t n o _ 2 0 ,                 s u m   c a s e   w h e n   d e p t n o = 3 0   t h e n   1   e l s e   0   e n d     a s   d e p t n o _ 3 0       f r o m   e m p         D E P T N O _ 1 0       D E P T N O _ 2 0       D E P T N O _ 3 0       - - - - - - - - -     - - - - - - - - - -     - - - - - - - - - -                       3                       5                       6  This approach uses an inline view to generate the employee counts per department. CASE expressions in the main query translate rows to columns, getting you to the following results:  Then the MAX functions collapses the columns into one row:  12.2 Pivoting a Result Set into Multiple Rows  Problem You want to turn rows into columns by creating a column corresponding to each of the values in a single given column. However, unlike in the previous recipe, you need multiple rows of output. Like the earlier recipe, pivoting into multiple rows is a fundamental method of reshaping data. For example, you want to return each employee and their position  JOB , and you currently use a query that returns the following result set:  s e l e c t   m a x   c a s e   w h e n   d e p t n o = 1 0   t h e n   e m p c o u n t   e l s e   n u l l   e n d     a s   d e p t n o _ 1 0                 m a x   c a s e   w h e n   d e p t n o = 2 0   t h e n   e m p c o u n t   e l s e   n u l l   e n d     a s   d e p t n o _ 2 0 ,                 m a x   c a s e   w h e n   d e p t n o = 1 0   t h e n   e m p c o u n t   e l s e   n u l l   e n d     a s   d e p t n o _ 3 0       f r o m       s e l e c t   d e p t n o ,   c o u n t   *     a s   e m p c o u n t       f r o m   e m p     g r o u p   b y   d e p t n o                     x D E P T N O _ 1 0       D E P T N O _ 2 0       D E P T N O _ 3 0   - - - - - - - - -     - - - - - - - - - -     - - - - - - - - - -                   3                 N U L L                 N U L L             N U L L                       5                 N U L L             N U L L                 N U L L                       6 D E P T N O _ 1 0       D E P T N O _ 2 0       D E P T N O _ 3 0   - - - - - - - - -     - - - - - - - - - -     - - - - - - - - - -                   3                       5                       6 J O B                 E N A M E   - - - - - - - - -     - - - - - - - - - -   A N A L Y S T         S C O T T    You would like to format the result set such that each job gets its own column:  Solution Unlike the first recipe in this chapter, the result set for this recipe consists of more than one row. Using the previous recipe’s technique will not work for this recipe, as the MAX ENAME  for each JOB would be returned, which would result in one ENAME for each JOB  i.e., one row will be returned as in the first recipe . To solve this problem, you must make each JOB ENAME combination unique. Then, when you apply an aggregate function to remove NULLs, you don’t lose any ENAMEs. Use the ranking function ROW_NUMBER OVER to make each JOB ENAME combination unique. Pivot the result set using a CASE expression and the aggregate function MAX while grouping on the value returned by the window function:  A N A L Y S T         F O R D   C L E R K             S M I T H   C L E R K             A D A M S   C L E R K             M I L L E R   C L E R K             J A M E S   M A N A G E R         J O N E S   M A N A G E R         C L A R K   M A N A G E R         B L A K E   P R E S I D E N T     K I N G   S A L E S M A N       A L L E N   S A L E S M A N       M A R T I N   S A L E S M A N       T U R N E R   S A L E S M A N       W A R D C L E R K S     A N A L Y S T S     M G R S       P R E Z     S A L E S   - - - - - -     - - - - - - - -     - - - - -     - - - -     - - - - - -   M I L L E R     F O R D             C L A R K     K I N G     T U R N E R   J A M E S       S C O T T           B L A K E                 M A R T I N   A D A M S                           J O N E S                 W A R D   S M I T H                                                     A L L E N   1     s e l e c t   m a x   c a s e   w h e n   j o b = ' C L E R K '     2                                     t h e n   e n a m e   e l s e   n u l l   e n d     a s   c l e r k s ,    Discussion The first step is to use the window function ROW_NUMBER OVER to help make each JOB ENAME combination unique:  Giving each ENAME a unique “row number” within a given job prevents any problems that might otherwise result from two employees having the    3                   m a x   c a s e   w h e n   j o b = ' A N A L Y S T '     4                                     t h e n   e n a m e   e l s e   n u l l   e n d     a s   a n a l y s t s ,     5                   m a x   c a s e   w h e n   j o b = ' M A N A G E R '     6                                     t h e n   e n a m e   e l s e   n u l l   e n d     a s   m g r s ,     7                   m a x   c a s e   w h e n   j o b = ' P R E S I D E N T '     8                                     t h e n   e n a m e   e l s e   n u l l   e n d     a s   p r e z ,     9                   m a x   c a s e   w h e n   j o b = ' S A L E S M A N '   1 0                                     t h e n   e n a m e   e l s e   n u l l   e n d     a s   s a l e s   1 1       f r o m       1 2   s e l e c t   j o b ,   1 3                 e n a m e ,   1 4                 r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   j o b   o r d e r   b y   e n a m e     r n   1 5       f r o m   e m p   1 6                     x   1 7     g r o u p   b y   r n s e l e c t   j o b ,                 e n a m e ,                 r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   j o b   o r d e r   b y   e n a m e     r n       f r o m   e m p         J O B               E N A M E                             R N       - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -       A N A L Y S T       F O R D                                 1       A N A L Y S T       S C O T T                               2       C L E R K           A D A M S                               1       C L E R K           J A M E S                               2       C L E R K           M I L L E R                             3       C L E R K           S M I T H                               4       M A N A G E R       B L A K E                               1       M A N A G E R       C L A R K                               2       M A N A G E R       J O N E S                               3       P R E S I D E N T   K I N G                                 1       S A L E S M A N     A L L E N                               1       S A L E S M A N     M A R T I N                             2       S A L E S M A N     T U R N E R                             3       S A L E S M A N     W A R D                                 4  same name and job. The goal here is to be able to group on row number  on RN  without dropping any employees from the result set due to the use of MAX. This step is the most important step in solving the problem. Without this first step, the aggregation in the outer query will remove necessary rows. Consider what the result set would look like without using ROW_NUMBER OVER, using the same technique as shown in the first recipe:  Unfortunately, only one row is returned for each JOB: the employee with the MAX ENAME. When it comes time to pivot the result set, using MIN or MAX should serve as a means to remove NULLs from the result set, not restrict the ENAMEs returned. How this works will be come clearer as you continue through the explanation. The next step uses a CASE expression to organize the ENAMEs into their proper column  JOB :  s e l e c t   m a x   c a s e   w h e n   j o b = ' C L E R K '                                   t h e n   e n a m e   e l s e   n u l l   e n d     a s   c l e r k s ,                 m a x   c a s e   w h e n   j o b = ' A N A L Y S T '                                   t h e n   e n a m e   e l s e   n u l l   e n d     a s   a n a l y s t s ,                 m a x   c a s e   w h e n   j o b = ' M A N A G E R '                                   t h e n   e n a m e   e l s e   n u l l   e n d     a s   m g r s ,                 m a x   c a s e   w h e n   j o b = ' P R E S I D E N T '                                   t h e n   e n a m e   e l s e   n u l l   e n d     a s   p r e z ,                 m a x   c a s e   w h e n   j o b = ' S A L E S M A N '                                   t h e n   e n a m e   e l s e   n u l l   e n d     a s   s a l e s       f r o m   e m p       C L E R K S             A N A L Y S T S         M G R S                 P R E Z                 S A L E S   - - - - - - - - - -     - - - - - - - - - -     - - - - - - - - - -     - - - - - - - - - -     - - - - - - - - - -   S M I T H               S C O T T               J O N E S               K I N G                 W A R D s e l e c t   r n ,                 c a s e   w h e n   j o b = ' C L E R K '                           t h e n   e n a m e   e l s e   n u l l   e n d   a s   c l e r k s ,                 c a s e   w h e n   j o b = ' A N A L Y S T '                           t h e n   e n a m e   e l s e   n u l l   e n d   a s   a n a l y s t s ,                 c a s e   w h e n   j o b = ' M A N A G E R '                           t h e n   e n a m e   e l s e   n u l l   e n d   a s   m g r s ,    At this point, the rows are transposed into columns, and the last step is to remove the NULLs to make the result set more readable. To remove the NULLs, use the aggregate function MAX and group by RN.  You can use the function MIN as well. The choice to use MAX is arbitrary, as you will only ever be aggregating one value per group.  There is only one value for each RN JOB ENAME combination. Grouping by RN in conjunction with the CASE expressions embedded within the calls to MAX ensures that each call to MAX results in picking only one name from a group of otherwise NULL values:                c a s e   w h e n   j o b = ' P R E S I D E N T '                           t h e n   e n a m e   e l s e   n u l l   e n d   a s   p r e z ,                 c a s e   w h e n   j o b = ' S A L E S M A N '                           t h e n   e n a m e   e l s e   n u l l   e n d   a s   s a l e s       f r o m       s e l e c t   j o b ,                 e n a m e ,                 r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   j o b   o r d e r   b y   e n a m e     r n       f r o m   e m p                     x     R N     C L E R K S             A N A L Y S T S         M G R S                 P R E Z                 S A L E S   - -     - - - - - - - - - -     - - - - - - - - - -     - - - - - - - - - -     - - - - - - - - - -     - - - - - - - - - -     1                             F O R D     2                             S C O T T     1     A D A M S     2     J A M E S     3     M I L L E R     4     S M I T H     1                                                     B L A K E     2                                                     C L A R K     3                                                     J O N E S     1                                                                             K I N G     1                                                                                                     A L L E N     2                                                                                                     M A R T I N     3                                                                                                     T U R N E R     4                                                                                                     W A R D s e l e c t   m a x   c a s e   w h e n   j o b = ' C L E R K '                                   t h e n   e n a m e   e l s e   n u l l   e n d     a s   c l e r k s ,                 m a x   c a s e   w h e n   j o b = ' A N A L Y S T '                                   t h e n   e n a m e   e l s e   n u l l   e n d     a s   a n a l y s t s ,                 m a x   c a s e   w h e n   j o b = ' M A N A G E R '    The technique of using ROW_NUMBER OVER to create unique combinations of rows is extremely useful for formatting query results. Consider the following query that creates a sparse report showing employees by DEPTNO and JOB:                                  t h e n   e n a m e   e l s e   n u l l   e n d     a s   m g r s ,                 m a x   c a s e   w h e n   j o b = ' P R E S I D E N T '                                   t h e n   e n a m e   e l s e   n u l l   e n d     a s   p r e z ,                 m a x   c a s e   w h e n   j o b = ' S A L E S M A N '                                   t h e n   e n a m e   e l s e   n u l l   e n d     a s   s a l e s       f r o m       s e l e c t   j o b ,                 e n a m e ,                 r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   j o b   o r d e r   b y   e n a m e     r n       f r o m   e m p                     x   g r o u p   b y   r n     C L E R K S     A N A L Y S T S     M G R S       P R E Z     S A L E S   - - - - - -     - - - - - - - -     - - - - -     - - - -     - - - - - -   M I L L E R     F O R D             C L A R K     K I N G     T U R N E R   J A M E S       S C O T T           B L A K E                 M A R T I N   A D A M S                           J O N E S                 W A R D   S M I T H                                                     A L L E N s e l e c t   d e p t n o   d n o ,   j o b ,                 m a x   c a s e   w h e n   d e p t n o = 1 0                                   t h e n   e n a m e   e l s e   n u l l   e n d     a s   d 1 0 ,                 m a x   c a s e   w h e n   d e p t n o = 2 0                                   t h e n   e n a m e   e l s e   n u l l   e n d     a s   d 2 0 ,                 m a x   c a s e   w h e n   d e p t n o = 3 0                                   t h e n   e n a m e   e l s e   n u l l   e n d     a s   d 3 0 ,                 m a x   c a s e   w h e n   j o b = ' C L E R K '                                   t h e n   e n a m e   e l s e   n u l l   e n d     a s   c l e r k s ,                 m a x   c a s e   w h e n   j o b = ' A N A L Y S T '                                   t h e n   e n a m e   e l s e   n u l l   e n d     a s   a n a l s ,                 m a x   c a s e   w h e n   j o b = ' M A N A G E R '                                   t h e n   e n a m e   e l s e   n u l l   e n d     a s   m g r s ,                 m a x   c a s e   w h e n   j o b = ' P R E S I D E N T '                                   t h e n   e n a m e   e l s e   n u l l   e n d     a s   p r e z ,                 m a x   c a s e   w h e n   j o b = ' S A L E S M A N '                                   t h e n   e n a m e   e l s e   n u l l   e n d     a s   s a l e s       f r o m       S e l e c t   d e p t n o ,                 j o b ,    By simply modifying what you group by  hence the nonaggregate items in the previous SELECT list , you can produce reports with different formats. It is worth the time of changing things around to understand how these formats change based on what you include in your GROUP BY clause.  12.3 Reverse Pivoting a Result Set  Problem You want to transform columns to rows. Consider the following result set:  You would like to convert that to the following:                e n a m e ,                 r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   j o b   o r d e r   b y   e n a m e     r n _ j o b ,                 r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   j o b   o r d e r   b y   e n a m e     r n _ d e p t n o       f r o m   e m p                     x     g r o u p   b y   d e p t n o ,   j o b ,   r n _ d e p t n o ,   r n _ j o b     o r d e r   b y   1     D N O   J O B               D 1 0         D 2 0       D 3 0         C L E R K S   A N A L S   M G R S     P R E Z   S A L E S   - - -   - - - - - - - - -   - - - - - -   - - - - -   - - - - - -   - - - - - -   - - - - -   - - - - -   - - - -   - - - - - -     1 0   C L E R K           M I L L E R                             M I L L E R     1 0   M A N A G E R       C L A R K                                                         C L A R K     1 0   P R E S I D E N T   K I N G                                                                       K I N G     2 0   A N A L Y S T                     F O R D                                 F O R D     2 0   A N A L Y S T                     S C O T T                               S C O T T     2 0   C L E R K                         A D A M S                 A D A M S     2 0   C L E R K                         S M I T H                 S M I T H     2 0   M A N A G E R                     J O N E S                                           J O N E S     3 0   C L E R K                                     J A M E S     J A M E S     3 0   M A N A G E R                                 B L A K E                               B L A K E     3 0   S A L E S M A N                               A L L E N                                                     A L L E N     3 0   S A L E S M A N                               M A R T I N                                                   M A R T I N     3 0   S A L E S M A N                               T U R N E R                                                   T U R N E R     3 0   S A L E S M A N                               W A R D                                                       W A R D D E P T N O _ 1 0     D E P T N O _ 2 0     D E P T N O _ 3 0   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -                     3                     5                     6  Some readers may have noticed that the first listing is the output from the first recipe in this chapter. To make this output available for this recipe, we can store it in a view with the following query:  In the solution and discussion that follow, the queries will refer to the EMP_CNTS view created by the preceding query.  Solution Examining the desired result set, it’s easy to see that you can execute a simple COUNT and GROUP BY on table EMP to produce the desired result. The object here, though, is to imagine that the data is not stored as rows; perhaps the data is denormalized and aggregated values are stored as multiple columns. To convert columns to rows, use a Cartesian product. You’ll need to know in advance how many columns you want to convert to rows because the table expression you use to create the Cartesian product must have a cardinality of at least the number of columns you want to transpose. Rather than create a denormalized table of data, the solution for this recipe will use the solution from the first recipe of this chapter to create a “wide” result set. The full solution is as follows:  D E P T N O   C O U N T S _ B Y _ D E P T   - - - - - -   - - - - - - - - - - - - - -           1 0                             3           2 0                             5           3 0                             6 c r e a t e   v i e w   e m p _ c n t s   a s       s e l e c t   s u m   c a s e   w h e n   d e p t n o = 1 0   t h e n   1   e l s e   0   e n d     a s   d e p t n o _ 1 0 ,                       s u m   c a s e   w h e n   d e p t n o = 2 0   t h e n   1   e l s e   0   e n d     a s   d e p t n o _ 2 0 ,                       s u m   c a s e   w h e n   d e p t n o = 3 0   t h e n   1   e l s e   0   e n d     a s   d e p t n o _ 3 0             f r o m   e m p       1   s e l e c t   d e p t . d e p t n o ,     2                 c a s e   d e p t . d e p t n o    Discussion The view EMP_CNTS represents the denormalized view, or “wide” result set that you want to convert to rows, and is shown here:  Because there are three columns, you will create three rows. Begin by creating a Cartesian product between inline view EMP_CNTS and some table expression that has at least three rows. The following code uses table DEPT to create the Cartesian product; DEPT has four rows:  The Cartesian product enables you to return a row for each column in inline view EMP_CNTS. Since the final result set should have only the DEPTNO    3                           w h e n   1 0   t h e n   e m p _ c n t s . d e p t n o _ 1 0     4                           w h e n   2 0   t h e n   e m p _ c n t s . d e p t n o _ 2 0     5                           w h e n   3 0   t h e n   e m p _ c n t s . d e p t n o _ 3 0     6                 e n d   a s   c o u n t s _ b y _ d e p t     7       f r o m   e m p _ c n t s   c r o s s   j o i n     8                   s e l e c t   d e p t n o   f r o m   d e p t   w h e r e   d e p t n o   < =   3 0     d e p t D E P T N O _ 1 0       D E P T N O _ 2 0       D E P T N O _ 3 0   - - - - - - - - -     - - - - - - - - - -     - - - - - - - - - -                   3                       5                       6 s e l e c t   d e p t . d e p t n o ,                     e m p _ c n t s . d e p t n o _ 1 0 ,                     e m p _ c n t s . d e p t n o _ 2 0 ,                     e m p _ c n t s . d e p t n o _ 3 0           f r o m           S e l e c t   s u m   c a s e   w h e n   d e p t n o = 1 0   t h e n   1   e l s e   0   e n d     a s   d e p t n o _ 1 0 ,                     s u m   c a s e   w h e n   d e p t n o = 2 0   t h e n   1   e l s e   0   e n d     a s   d e p t n o _ 2 0 ,                     s u m   c a s e   w h e n   d e p t n o = 3 0   t h e n   1   e l s e   0   e n d     a s   d e p t n o _ 3 0           f r o m   e m p                         e m p _ c n t s ,                       s e l e c t   d e p t n o   f r o m   d e p t   w h e r e   d e p t n o   < =   3 0     d e p t         D E P T N O   D E P T N O _ 1 0     D E P T N O _ 2 0     D E P T N O _ 3 0       - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - -               1 0                     3                     5                   6               2 0                     3                     5                   6               3 0                     3                     5                   6  and the number of employees in said DEPTNO, use a CASE expression to transform the three columns into one:  12.4 Reverse Pivoting a Result Set into One Column  Problem You want to return all columns from a query as just one column. For example, you want to return the ENAME, JOB, and SAL of all employees in DEPTNO 10, and you want to return all three values in one column. You want to return three rows for each employee and one row of white space between employees. You want to return the following result set:    s e l e c t   d e p t . d e p t n o ,                     c a s e   d e p t . d e p t n o                               w h e n   1 0   t h e n   e m p _ c n t s . d e p t n o _ 1 0                               w h e n   2 0   t h e n   e m p _ c n t s . d e p t n o _ 2 0                               w h e n   3 0   t h e n   e m p _ c n t s . d e p t n o _ 3 0                     e n d   a s   c o u n t s _ b y _ d e p t           f r o m                         e m p _ c n t s   c r o s s   j o i n     s e l e c t   d e p t n o   f r o m   d e p t   w h e r e   d e p t n o   < =   3 0     d e p t         D E P T N O   C O U N T S _ B Y _ D E P T       - - - - - -   - - - - - - - - - - - - - -               1 0                             3               2 0                             5               3 0                             6 E M P S   - - - - - - - - - -   C L A R K   M A N A G E R   2 4 5 0     K I N G   P R E S I D E N T   5 0 0 0     M I L L E R    Solution The key is to use a recursive CTE combined with Cartesian product to return four rows for each employee. Chapter 10 covers the recursive CTE we need, and it’s explored further in Appendix B. Using the Cartesian join lets you return one column value per row and have an extra row for spacing between employees. Use the window function ROW_NUMBER OVER to rank each row based on EMPNO  1–4 . Then use a CASE expression to transform three columns into one  the keyword RECURSIVE is needed after the first WITH in PostgreSQL and MySQL :  C L E R K   1 3 0 0 1       w i t h   f o u r _ r o w s     i d     2           a s   3           4         s e l e c t   1   5             u n i o n   a l l   6         s e l e c t   i d + 1   7             f r o m   f o u r _ r o w s   8             w h e r e   i d   <   4   9             1 0       ,   1 1         x _ t a b     e n a m e , j o b , s a l , r n       1 2           a s   1 3                       s e l e c t     e . e n a m e , e . j o b , e . s a l ,   1 4             r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   e . e m p n o   1 5             o r d e r   b y   e . e m p n o     1 6             f r o m   e m p   e   1 7             j o i n   f o u r _ r o w s   o n   1 = 1   1 8             1 9   2 0       s e l e c t   2 1           c a s e   r n   2 2           w h e n   1   t h e n   e n a m e   2 3           w h e n   2   t h e n   j o b   2 4           w h e n   3   t h e n   c a s t   s a l   a s   c h a r   4       2 5         e n d   e m p s   2 6     f r o m   x _ t a b  Discussion The first step is to use the window function ROW_NUMBER OVER to create a ranking for each employee in DEPTNO 10:  At this point, the ranking doesn’t mean much. You are partitioning by EMPNO, so the rank is 1 for all three rows in DEPTNO 10. Once you add the Cartesian product, the rank will begin to take shape, as shown in the following results:  s e l e c t   e . e n a m e , e . j o b , e . s a l ,                 r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   e . e m p n o                                       o r d e r   b y   e . e m p n o     r n   f r o m   e m p   e     w h e r e   e . d e p t n o = 1 0     E N A M E               J O B                           S A L                   R N   - - - - - - - - - -   - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   C L A R K             M A N A G E R                   2 4 5 0                     1   K I N G               P R E S I D E N T               5 0 0 0                     1   M I L L E R           C L E R K                       1 3 0 0                     1 w i t h   f o u r _ r o w s     i d         a s         s e l e c t   1       u n i o n   a l l       s e l e c t   i d + 1       f r o m   f o u r _ r o w s       w h e r e   i d   <   4             s e l e c t   e . e n a m e , e . j o b , e . s a l ,     r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   e . e m p n o     o r d e r   b y   e . e m p n o         f r o m   e m p   e       j o i n   f o u r _ r o w s   o n   1 = 1         E N A M E             J O B                             S A L                   R N       - - - - - - - - - -   - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -       C L A R K             M A N A G E R                   2 4 5 0                     1       C L A R K             M A N A G E R                   2 4 5 0                     2       C L A R K             M A N A G E R                   2 4 5 0                     3       C L A R K             M A N A G E R                   2 4 5 0                     4       K I N G               P R E S I D E N T               5 0 0 0                     1       K I N G               P R E S I D E N T               5 0 0 0                     2    You should stop at this point and understand two key points:  RN is no longer 1 for each employee; it is now a repeating sequence of values from 1 to 4, the reason being that window functions are applied after the FROM and WHERE clauses are evaluated. So, partitioning by EMPNO causes the RN to reset to 1 when a new employee is encountered. We’ve used a recursive CTE to ensure that for each employee there are four rows. We don’t need the RECURSIVE keyword in SQL Server or DB2, but we do for Oracle, MySQL, and PostgreSQL.  The hard work is now done, and all that is left is to use a CASE expression to put ENAME, JOB, and SAL into one column for each employee  you need to use CAST to convert SAL to a string to keep CASE happy :      K I N G               P R E S I D E N T               5 0 0 0                     3       K I N G               P R E S I D E N T               5 0 0 0                     4       M I L L E R           C L E R K                       1 3 0 0                     1       M I L L E R           C L E R K                       1 3 0 0                     2       M I L L E R           C L E R K                       1 3 0 0                     3       M I L L E R           C L E R K                       1 3 0 0                     4   w i t h   f o u r _ r o w s     i d         a s         s e l e c t   1       u n i o n   a l l       s e l e c t   i d + 1       f r o m   f o u r _ r o w s       w h e r e   i d   <   4               ,       x _ t a b     e n a m e , j o b , s a l , r n           a s         s e l e c t   e . e n a m e , e . j o b , e . s a l ,     r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   e . e m p n o     o r d e r   b y   e . e m p n o         f r o m   e m p   e       j o i n   f o u r _ r o w s   o n   1 = 1             s e l e c t   c a s e   r n       w h e n   1   t h e n   e n a m e       w h e n   2   t h e n   j o b       w h e n   3   t h e n   c a s t   s a l   a s   c h a r   4        12.5 Suppressing Repeating Values from a Result Set  Problem You are generating a report, and when two rows have the same value in a column, you want to display that value only once. For example, you want to return DEPTNO and ENAME from table EMP, you want to group all rows for each DEPTNO, and you want to display each DEPTNO only one time. You want to return the following result set:    e n d   e m p s       f r o m   x _ t a b         E M P S       - - - - - - - - - -       C L A R K       M A N A G E R       2 4 5 0         K I N G       P R E S I D E N T       5 0 0 0         M I L L E R       C L E R K       1 3 0 0 D E P T N O   E N A M E   - - - - - -   - - - - - - - - -           1 0   C L A R K                 K I N G                 M I L L E R           2 0   S M I T H                 A D A M S                 F O R D                 S C O T T                 J O N E S           3 0   A L L E N                 B L A K E                 M A R T I N                 J A M E S    Solution This is a simple formatting problem that is easily solved by the window function LAG OVER:  Oracle users can also use DECODE as an alternative to CASE:  Discussion The first step is to use the window function LAG OVER to return the prior DEPTNO for each row:                T U R N E R                 W A R D 1       s e l e c t   2                       c a s e   w h e n   3                             l a g   d e p t n o   o v e r   o r d e r   b y   d e p t n o     =   d e p t n o   t h e n   n u l l   4                             e l s e   d e p t n o   e n d   D E P T N O   5               ,   e n a m e   6         f r o m   e m p 1   s e l e c t   t o _ n u m b e r     2                       d e c o d e   l a g   d e p t n o   o v e r   o r d e r   b y   d e p t n o   ,   3                                   d e p t n o , n u l l , d e p t n o     4                     d e p t n o ,   e n a m e   5       f r o m   e m p s e l e c t   l a g   d e p t n o   o v e r   o r d e r   b y   d e p t n o     l a g _ d e p t n o ,                 d e p t n o ,                 e n a m e       f r o m   e m p     L A G _ D E P T N O           D E P T N O   E N A M E   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -                                         1 0   C L A R K                   1 0                   1 0   K I N G                   1 0                   1 0   M I L L E R                   1 0                   2 0   S M I T H                   2 0                   2 0   A D A M S                   2 0                   2 0   F O R D                   2 0                   2 0   S C O T T                   2 0                   2 0   J O N E S    If you inspect the previous result set, you can easily see where DEPTNO matches LAG_ DEPTNO. For those rows, you want to set DEPTNO to NULL. Do that by using DECODE  TO_NUMBER is included to cast DEPTNO as a number :  12.6 Pivoting a Result Set to Facilitate Inter- Row Calculations  Problem                  2 0                   3 0   A L L E N                   3 0                   3 0   B L A K E                   3 0                   3 0   M A R T I N                   3 0                   3 0   J A M E S                   3 0                   3 0   T U R N E R                   3 0                   3 0   W A R D s e l e c t   t o _ n u m b e r                           C A S E   W H E N     l a g   d e p t n o   o v e r   o r d e r   b y   d e p t n o     =   d e p t n o   T H E N   n u l l   e l s e   d e p t n o   E N D   d e p t n o   ,                                     d e p t n o , n u l l , d e p t n o                         d e p t n o ,   e n a m e       f r o m   e m p     D E P T N O   E N A M E   - - - - - -   - - - - - - - - - -           1 0   C L A R K                 K I N G                 M I L L E R           2 0   S M I T H                 A D A M S                 F O R D                 S C O T T                 J O N E S           3 0   A L L E N                 B L A K E                 M A R T I N                 J A M E S                 T U R N E R                 W A R D  You want to make calculations involving data from multiple rows. To make your job easier, you want to pivot those rows into columns such that all values you need are then in a single row. In this book’s example data, DEPTNO 20 is the department with the highest combined salary, which you can confirm by executing the following query:  You want to calculate the difference between the salaries of DEPTNO 20 and DEPTNO 10 and between DEPTNO 20 and DEPTNO 30. The final result will look like this:  Solution Transpose the totals using the aggregate function SUM and a CASE expression. Then code your expressions in the select list:  s e l e c t   d e p t n o ,   s u m   s a l     a s   s a l       f r o m   e m p     g r o u p   b y   d e p t n o     D E P T N O                 S A L   - - - - - -   - - - - - - - - - -           1 0               8 7 5 0           2 0             1 0 8 7 5           3 0               9 4 0 0 d 2 0 _ 1 0 _ d i f f         d 2 0 _ 3 0 _ d i f f   - - - - - - - - - - - -       - - - - - - - - - -   2 1 2 5                         1 4 7 5 1   s e l e c t   d 2 0 _ s a l   -   d 1 0 _ s a l   a s   d 2 0 _ 1 0 _ d i f f ,   2                 d 2 0 _ s a l   -   d 3 0 _ s a l   a s   d 2 0 _ 3 0 _ d i f f   3       f r o m       4   s e l e c t   s u m   c a s e   w h e n   d e p t n o = 1 0   t h e n   s a l   e n d     a s   d 1 0 _ s a l ,   5                 s u m   c a s e   w h e n   d e p t n o = 2 0   t h e n   s a l   e n d     a s   d 2 0 _ s a l ,   6                 s u m   c a s e   w h e n   d e p t n o = 3 0   t h e n   s a l   e n d     a s   d 3 0 _ s a l   7       f r o m   e m p   8                     t o t a l s _ b y _ d e p t  It is also possible to write this query using a CTE, which some people may find more readable:  Discussion The first step is to pivot the salaries for each DEPTNO from rows to columns by using a CASE expression:  w i t h   t o t a l s _ b y _ d e p t     d 1 0 _ s a l ,   d 2 0 _ s a l ,   d 3 0 _ s a l     a s     s e l e c t                       s u m   c a s e   w h e n   d e p t n o = 1 0   t h e n   s a l   e n d     a s   d 1 0 _ s a l ,                         s u m   c a s e   w h e n   d e p t n o = 2 0   t h e n   s a l   e n d     a s   d 2 0 _ s a l ,                         s u m   c a s e   w h e n   d e p t n o = 3 0   t h e n   s a l   e n d     a s   d 3 0 _ s a l     f r o m   e m p       s e l e c t       d 2 0 _ s a l   -   d 1 0 _ s a l   a s   d 2 0 _ 1 0 _ d i f f ,                       d 2 0 _ s a l   -   d 3 0 _ s a l   a s   d 2 0 _ 3 0 _ d i f f             f r o m   t o t a l s _ b y _ d e p t s e l e c t   c a s e   w h e n   d e p t n o = 1 0   t h e n   s a l   e n d   a s   d 1 0 _ s a l ,                 c a s e   w h e n   d e p t n o = 2 0   t h e n   s a l   e n d   a s   d 2 0 _ s a l ,                 c a s e   w h e n   d e p t n o = 3 0   t h e n   s a l   e n d   a s   d 3 0 _ s a l       f r o m   e m p     D 1 0 _ S A L         D 2 0 _ S A L         D 3 0 _ S A L   - - - - - - -   - - - - - - - - - -   - - - - - - - - - -                                 8 0 0                                                     1 6 0 0                                                     1 2 5 0                               2 9 7 5                                                     1 2 5 0                                                     2 8 5 0         2 4 5 0                               3 0 0 0         5 0 0 0                                                     1 5 0 0                               1 1 0 0                                                       9 5 0                               3 0 0 0         1 3 0 0  The next step is to sum all the salaries for each DEPTNO by applying the aggregate function SUM to each CASE expression:  The final step is to simply wrap the previous SQL in an inline view and perform the subtractions.  12.7 Creating Buckets of Data, of a Fixed Size  Problem You want to organize data into evenly sized buckets, with a predetermined number of elements in each bucket. The total number of buckets may be unknown, but you want to ensure that each bucket has five elements. For example, you want to organize the employees in table EMP into groups of five based on the value of EMPNO, as shown in the following results:  s e l e c t   s u m   c a s e   w h e n   d e p t n o = 1 0   t h e n   s a l   e n d     a s   d 1 0 _ s a l ,                 s u m   c a s e   w h e n   d e p t n o = 2 0   t h e n   s a l   e n d     a s   d 2 0 _ s a l ,                 s u m   c a s e   w h e n   d e p t n o = 3 0   t h e n   s a l   e n d     a s   d 3 0 _ s a l       f r o m   e m p     D 1 0 _ S A L         D 2 0 _ S A L         D 3 0 _ S A L   - - - - - - -   - - - - - - - - - -   - - - - - - - - - -         8 7 5 0             1 0 8 7 5               9 4 0 0 G R P             E M P N O   E N A M E   - - -   - - - - - - - - - -   - - - - - - -       1               7 3 6 9   S M I T H       1               7 4 9 9   A L L E N       1               7 5 2 1   W A R D       1               7 5 6 6   J O N E S       1               7 6 5 4   M A R T I N       2               7 6 9 8   B L A K E       2               7 7 8 2   C L A R K       2               7 7 8 8   S C O T T       2               7 8 3 9   K I N G       2               7 8 4 4   T U R N E R       3               7 8 7 6   A D A M S    Solution The solution to this problem is greatly simplified by functions for ranking rows. Once the rows are ranked, creating buckets of five is simply a matter of dividing and then taking the mathematical ceiling of the quotient. Use the window function ROW_NUMBER OVER to rank each employee by EMPNO. Then divide by five to create the groups  SQL Server users will use CEILING, not CEIL :  Discussion The window function ROW_NUMBER OVER assigns a rank or “row number” to each row sorted by EMPNO:      3               7 9 0 0   J A M E S       3               7 9 0 2   F O R D       3               7 9 3 4   M I L L E R 1   s e l e c t   c e i l   r o w _ n u m b e r     o v e r   o r d e r   b y   e m p n o     5 . 0     g r p ,   2                 e m p n o ,   3                 e n a m e   4       f r o m   e m p s e l e c t   r o w _ n u m b e r     o v e r   o r d e r   b y   e m p n o     r n ,                 e m p n o ,                 e n a m e       f r o m   e m p     R N             E M P N O   E N A M E   - -   - - - - - - - - - -   - - - - - - - - - -     1               7 3 6 9   S M I T H     2               7 4 9 9   A L L E N     3               7 5 2 1   W A R D     4               7 5 6 6   J O N E S     5               7 6 5 4   M A R T I N     6               7 6 9 8   B L A K E     7               7 7 8 2   C L A R K     8               7 7 8 8   S C O T T     9               7 8 3 9   K I N G   1 0               7 8 4 4   T U R N E R   1 1               7 8 7 6   A D A M S   1 2               7 9 0 0   J A M E S    The next step is to apply the function CEIL  or CEILING  after dividing ROW_ NUMBER OVER by five. Dividing by five logically organizes the rows into groups of five  i.e., five values less than or equal to 1, five values greater than 1 but less than or equal to 2 ; the remaining group  composed of the last 4 rows since 14, the number of rows in table EMP, is not a multiple of 5  has a value greater than 2 but less than or equal to 3. The CEIL function will return the smallest whole number greater than the value passed to it; this will create whole number groups. The results of the division and application of the CEIL are shown here. You can follow the order of operation from left to right, from RN to DIVISION to GRP:  12.8 Creating a Predefined Number of Buckets  1 3               7 9 0 2   F O R D   1 4               7 9 3 4   M I L L E R s e l e c t   r o w _ n u m b e r     o v e r   o r d e r   b y   e m p n o     r n ,                 r o w _ n u m b e r     o v e r   o r d e r   b y   e m p n o     5 . 0   d i v i s i o n ,                 c e i l   r o w _ n u m b e r     o v e r   o r d e r   b y   e m p n o     5 . 0     g r p ,                 e m p n o ,                 e n a m e       f r o m   e m p     R N       D I V I S I O N   G R P   E M P N O   E N A M E   - -   - - - - - - - - - -   - - -   - - - - -   - - - - - - - - - -     1                   . 2       1     7 3 6 9   S M I T H     2                   . 4       1     7 4 9 9   A L L E N     3                   . 6       1     7 5 2 1   W A R D     4                   . 8       1     7 5 6 6   J O N E S     5                     1       1     7 6 5 4   M A R T I N     6                 1 . 2       2     7 6 9 8   B L A K E     7                 1 . 4       2     7 7 8 2   C L A R K     8                 1 . 6       2     7 7 8 8   S C O T T     9                 1 . 8       2     7 8 3 9   K I N G   1 0                     2       2     7 8 4 4   T U R N E R   1 1                 2 . 2       3     7 8 7 6   A D A M S   1 2                 2 . 4       3     7 9 0 0   J A M E S   1 3                 2 . 6       3     7 9 0 2   F O R D   1 4                 2 . 8       3     7 9 3 4   M I L L E R  Problem You want to organize your data into a fixed number of buckets. For example, you want to organize the employees in table EMP into four buckets. The result set should look similar to the following:  This is a common way to organize categorical data as dividing a set into a number of smaller equal sized sets is an important first step for many kinds of analysis. For example, taking the averages of these groups on salary or any other value may reveal a trend that is concealed by variability when looking at the cases individually. This problem is the opposite of the previous recipe, where you had an unknown number of buckets but a predetermined number of elements in each bucket. In this recipe, the goal is such that you may not necessarily know how many elements are in each bucket, but you are defining a fixed  known  number of buckets to be created.  Solution The solution to this problem is simple now that the NTILE function is widely available. NTILE organizes an ordered set into the number of buckets you specify, with any stragglers distributed into the available  G R P   E M P N O   E N A M E   - - -   - - - - -   - - - - - - - - -       1     7 3 6 9   S M I T H       1     7 4 9 9   A L L E N       1     7 5 2 1   W A R D       1     7 5 6 6   J O N E S       2     7 6 5 4   M A R T I N       2     7 6 9 8   B L A K E       2     7 7 8 2   C L A R K       2     7 7 8 8   S C O T T       3     7 8 3 9   K I N G       3     7 8 4 4   T U R N E R       3     7 8 7 6   A D A M S       4     7 9 0 0   J A M E S       4     7 9 0 2   F O R D       4     7 9 3 4   M I L L E R  buckets starting from the first bucket. The desired result set for this recipe reflects this: buckets 1 and 2 have four rows, while buckets 3 and 4 have three rows. Use the NTILE window function to create four buckets:  Discussion All the work is done by the NTILE function. The ORDER BY clause puts the rows into the desired order, and the function itself then assigns a group number to each row, for example, so that the first quarter  in this case  are put into group one, the second into group two, etc.  12.9 Creating Horizontal Histograms  Problem You want to use SQL to generate histograms that extend horizontally. For example, you want to display the number of employees in each department as a horizontal histogram with each employee represented by an instance of *. You want to return the following result set:  Solution The key to this solution is to use the aggregate function COUNT and use GROUP BY DEPTNO to determine the number of employees in each  1   s e l e c t   n t i l e   4   o v e r   o r d e r   b y   e m p n o     g r p ,   2                 e m p n o ,   3                 e n a m e   4       f r o m   e m p D E P T N O   C N T   - - - - - -   - - - - - - - - - -           1 0   * * *           2 0   * * * * *           3 0   * * * * * *  DEPTNO. The value returned by COUNT is then passed to a string function that generates a series of * characters.  DB2 Use the REPEAT function to generate the histogram:  Oracle, PostgreSQL, and MySQL Use the LPAD function to generate the needed strings of * characters:  SQL Server Generate the histogram using the REPLICATE function:  Discussion The technique is the same for all vendors. The only difference lies in the string function used to return a * for each employee. The Oracle solution will be used for this discussion, but the explanation is relevant for all the solutions. The first step is to count the number of employees in each department:  1   s e l e c t   d e p t n o ,   2                 r e p e a t   ' * ' , c o u n t   *       c n t   3       f r o m   e m p   4     g r o u p   b y   d e p t n o 1   s e l e c t   d e p t n o ,   2                 l p a d   ' * ' , c o u n t   *   , ' * '     a s   c n t   3       f r o m   e m p   4     g r o u p   b y   d e p t n o 1   s e l e c t   d e p t n o ,   2                 r e p l i c a t e   ' * ' , c o u n t   *       c n t   3       f r o m   e m p   4     g r o u p   b y   d e p t n o s e l e c t   d e p t n o ,                 c o u n t   *         f r o m   e m p    The next step is to use the value returned by COUNT to control the number of * characters to return for each department. Simply pass COUNT  *   as an argument to the string function LPAD to return the desired number of *:  For PostgreSQL users, you may need to use CAST to ensure that COUNT *  returns an integer as shown here:  This CAST is necessary because PostgreSQL requires the numeric argument to LPAD to be an integer.  12.10 Creating Vertical Histograms    g r o u p   b y   d e p t n o     D E P T N O       C O U N T   *     - - - - - -   - - - - - - - - - -           1 0                     3           2 0                     5           3 0                     6 s e l e c t   d e p t n o ,                 l p a d   ' * ' , c o u n t   *   , ' * '     a s   c n t       f r o m   e m p     g r o u p   b y   d e p t n o     D E P T N O   C N T   - - - - - -   - - - - - - - - - -           1 0   * * *           2 0   * * * * *           3 0   * * * * * * s e l e c t   d e p t n o ,                 l p a d   ' * ' , c o u n t   *   : : i n t e g e r , ' * '     a s   c n t       f r o m   e m p     g r o u p   b y   d e p t n o     D E P T N O   C N T   - - - - - -   - - - - - - - - - -           1 0   * * *           2 0   * * * * *           3 0   * * * * * *  Problem You want to generate a histogram that grows from the bottom up. For example, you want to display the number of employees in each department as a vertical histogram with each employee represented by an instance of *. You want to return the following result set:  Solution The technique used to solve this problem is built on a technique used earlier in this chapter: use the ROW_NUMBER OVER function to uniquely identify each instance of * for each DEPTNO. Use the aggregate function MAX to pivot the result set and group by the values returned by ROW_NUMBER OVER  SQL Server users should not use DESC in the ORDER BY clause :  Discussion  D 1 0   D 2 0   D 3 0   - - -   - - -   - - -                   *           *       *           *       *   *       *       *   *       *       *   *       *       *   1   s e l e c t   m a x   d e p t n o _ 1 0     d 1 0 ,     2                 m a x   d e p t n o _ 2 0     d 2 0 ,     3                 m a x   d e p t n o _ 3 0     d 3 0     4       f r o m         5   s e l e c t   r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   d e p t n o   o r d e r   b y   e m p n o     r n ,     6                 c a s e   w h e n   d e p t n o = 1 0   t h e n   ' * '   e l s e   n u l l   e n d   d e p t n o _ 1 0 ,     7                 c a s e   w h e n   d e p t n o = 2 0   t h e n   ' * '   e l s e   n u l l   e n d   d e p t n o _ 2 0 ,     8                 c a s e   w h e n   d e p t n o = 3 0   t h e n   ' * '   e l s e   n u l l   e n d   d e p t n o _ 3 0     9       f r o m   e m p   1 0                     x   1 1     g r o u p   b y   r n   1 2     o r d e r   b y   1   d e s c ,   2   d e s c ,   3   d e s c  The first step is to use the window function ROW_NUMBER to uniquely identify each instance of * in each department. Use a CASE expression to return a * for each employee in each department:  The next and last step is to use the aggregate function MAX on each CASE expression, grouping by RN to remove the NULLs from the result set. Order the results ASC or DESC depending on how your RDBMS sorts NULLs:  s e l e c t   r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   d e p t n o   o r d e r   b y   e m p n o     r n ,                 c a s e   w h e n   d e p t n o = 1 0   t h e n   ' * '   e l s e   n u l l   e n d   d e p t n o _ 1 0 ,                 c a s e   w h e n   d e p t n o = 2 0   t h e n   ' * '   e l s e   n u l l   e n d   d e p t n o _ 2 0 ,                 c a s e   w h e n   d e p t n o = 3 0   t h e n   ' * '   e l s e   n u l l   e n d   d e p t n o _ 3 0       f r o m   e m p     R N   D E P T N O _ 1 0     D E P T N O _ 2 0     D E P T N O _ 3 0   - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - -     1   *     2   *     3   *     1                         *     2                         *     3                         *     4                         *     5                         *     1                                               *     2                                               *     3                                               *     4                                               *     5                                               *     6                                               * s e l e c t   m a x   d e p t n o _ 1 0     d 1 0 ,                 m a x   d e p t n o _ 2 0     d 2 0 ,                 m a x   d e p t n o _ 3 0     d 3 0       f r o m       s e l e c t   r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   d e p t n o   o r d e r   b y   e m p n o     r n ,                 c a s e   w h e n   d e p t n o = 1 0   t h e n   ' * '   e l s e   n u l l   e n d   d e p t n o _ 1 0 ,                 c a s e   w h e n   d e p t n o = 2 0   t h e n   ' * '   e l s e   n u l l   e n d   d e p t n o _ 2 0 ,                 c a s e   w h e n   d e p t n o = 3 0   t h e n   ' * '   e l s e   n u l l   e n d   d e p t n o _ 3 0       f r o m   e m p                     x     g r o u p   b y   r n     o r d e r   b y   1   d e s c ,   2   d e s c ,   3   d e s c    12.11 Returning Non-GROUP BY Columns  Problem You are executing a GROUP BY query, and you want to return columns in your select list that are not also listed in your GROUP BY clause. This is not normally possible, as such ungrouped columns would not represent a single value per row. Say that you want to find the employees who earn the highest and lowest salaries in each department, as well as the employees who earn the highest and lowest salaries in each job. You want to see each employee’s name, the department he works in, his job title, and his salary. You want to return the following result set:    D 1 0   D 2 0   D 3 0   - - -   - - -   - - -                   *           *       *           *       *   *       *       *   *       *       *   *       *       * D E P T N O   E N A M E     J O B                   S A L   D E P T _ S T A T U S           J O B _ S T A T U S   - - - - - -   - - - - - -   - - - - - - - - -   - - - - -   - - - - - - - - - - - - - - -   - - - - - - - - - - - - - -           1 0   M I L L E R   C L E R K             1 3 0 0   L O W   S A L   I N   D E P T   T O P   S A L   I N   J O B           1 0   C L A R K     M A N A G E R         2 4 5 0                                   L O W   S A L   I N   J O B           1 0   K I N G       P R E S I D E N T     5 0 0 0   T O P   S A L   I N   D E P T   T O P   S A L   I N   J O B           2 0   S C O T T     A N A L Y S T         3 0 0 0   T O P   S A L   I N   D E P T   T O P   S A L   I N   J O B           2 0   F O R D       A N A L Y S T         3 0 0 0   T O P   S A L   I N   D E P T   T O P   S A L   I N   J O B           2 0   S M I T H     C L E R K               8 0 0   L O W   S A L   I N   D E P T   L O W   S A L   I N   J O B           2 0   J O N E S     M A N A G E R         2 9 7 5                                   T O P   S A L   I N   J O B           3 0   J A M E S     C L E R K               9 5 0   L O W   S A L   I N   D E P T           3 0   M A R T I N   S A L E S M A N       1 2 5 0                                   L O W   S A L   I N   J O B           3 0   W A R D       S A L E S M A N       1 2 5 0                                   L O W   S A L   I N   J O B           3 0   A L L E N     S A L E S M A N       1 6 0 0                                   T O P   S A L   I N   J O B           3 0   B L A K E     M A N A G E R         2 8 5 0   T O P   S A L   I N   D E P T  Unfortunately, including all these columns in the SELECT clause will ruin the grouping. Consider the following example: employee KING earns the highest salary. You want to verify this with the following query:  Instead of seeing KING and KING’s salary, the previous query will return all 14 rows from table EMP. The reason is because of the grouping: the MAX SAL  is applied to each ENAME. So, it would seem the previous query can be stated as “find the employee with the highest salary,” but in fact what it is doing is “find the highest salary for each ENAME in table EMP.” This recipe explains a technique for including ENAME without the need to GROUP BY that column.  Solution Use an inline view to find the high and low salaries by DEPTNO and JOB. Then keep only the employees who make those salaries. Use the window functions MAX OVER and MIN OVER to find the highest and lowest salaries by DEPTNO and JOB. Then keep the rows where the salaries are those that are highest or lowest by DEPTNO or JOB:  s e l e c t   e n a m e , m a x   s a l         f r o m   e m p g r o u p   b y   e n a m e   1   s e l e c t   d e p t n o , e n a m e , j o b , s a l ,     2                 c a s e   w h e n   s a l   =   m a x _ b y _ d e p t     3                           t h e n   ' T O P   S A L   I N   D E P T '     4                           w h e n   s a l   =   m i n _ b y _ d e p t     5                           t h e n   ' L O W   S A L   I N   D E P T '     6                 e n d   d e p t _ s t a t u s ,     7                 c a s e   w h e n   s a l   =   m a x _ b y _ j o b     8                           t h e n   ' T O P   S A L   I N   J O B '     9                           w h e n   s a l   =   m i n _ b y _ j o b   1 0                           t h e n   ' L O W   S A L   I N   J O B '   1 1                 e n d   j o b _ s t a t u s   1 2       f r o m       1 3   s e l e c t   d e p t n o , e n a m e , j o b , s a l ,   1 4                 m a x   s a l   o v e r   p a r t i t i o n   b y   d e p t n o     m a x _ b y _ d e p t ,   1 5                 m a x   s a l   o v e r   p a r t i t i o n   b y   j o b         m a x _ b y _ j o b ,   1 6                 m i n   s a l   o v e r   p a r t i t i o n   b y   d e p t n o     m i n _ b y _ d e p t ,    Discussion The first step is to use the window functions MAX OVER and MIN OVER to find the highest and lowest salaries by DEPTNO and JOB:  At this point, every salary can be compared with the highest and lowest salaries by DEPTNO and JOB. Notice that the grouping  the inclusion of multiple columns in the SELECT clause  does not affect the values returned by MIN OVER and MAX OVER. This is the beauty of window functions: the aggregate is computed over a defined “group” or partition and returns multiple rows for each group. The last step is to simply wrap the window functions in an inline view and keep only those rows that match the values  1 7                 m i n   s a l   o v e r   p a r t i t i o n   b y   j o b         m i n _ b y _ j o b   1 8       f r o m   e m p   1 9                     e m p _ s a l s   2 0     w h e r e   s a l   i n     m a x _ b y _ d e p t , m a x _ b y _ j o b ,   2 1                                 m i n _ b y _ d e p t , m i n _ b y _ j o b   s e l e c t   d e p t n o , e n a m e , j o b , s a l ,                 m a x   s a l   o v e r   p a r t i t i o n   b y   d e p t n o     m a x D E P T ,                 m a x   s a l   o v e r   p a r t i t i o n   b y   j o b     m a x J O B ,                 m i n   s a l   o v e r   p a r t i t i o n   b y   d e p t n o     m i n D E P T ,                 m i n   s a l   o v e r   p a r t i t i o n   b y   j o b     m i n J O B       f r o m   e m p     D E P T N O   E N A M E     J O B                   S A L   M A X D E P T   M A X J O B   M I N D E P T   M I N J O B   - - - - - -   - - - - - -   - - - - - - - - -   - - - - -   - - - - - - -   - - - - - -   - - - - - - -   - - - - - -           1 0   M I L L E R   C L E R K             1 3 0 0         5 0 0 0       1 3 0 0         1 3 0 0         8 0 0           1 0   C L A R K     M A N A G E R         2 4 5 0         5 0 0 0       2 9 7 5         1 3 0 0       2 4 5 0           1 0   K I N G       P R E S I D E N T     5 0 0 0         5 0 0 0       5 0 0 0         1 3 0 0       5 0 0 0           2 0   S C O T T     A N A L Y S T         3 0 0 0         3 0 0 0       3 0 0 0           8 0 0       3 0 0 0           2 0   F O R D       A N A L Y S T         3 0 0 0         3 0 0 0       3 0 0 0           8 0 0       3 0 0 0           2 0   S M I T H     C L E R K               8 0 0         3 0 0 0       1 3 0 0           8 0 0         8 0 0           2 0   J O N E S     M A N A G E R         2 9 7 5         3 0 0 0       2 9 7 5           8 0 0       2 4 5 0           2 0   A D A M S     C L E R K             1 1 0 0         3 0 0 0       1 3 0 0           8 0 0         8 0 0           3 0   J A M E S     C L E R K               9 5 0         2 8 5 0       1 3 0 0           9 5 0         8 0 0           3 0   M A R T I N   S A L E S M A N       1 2 5 0         2 8 5 0       1 6 0 0           9 5 0       1 2 5 0           3 0   T U R N E R   S A L E S M A N       1 5 0 0         2 8 5 0       1 6 0 0           9 5 0       1 2 5 0           3 0   W A R D       S A L E S M A N       1 2 5 0         2 8 5 0       1 6 0 0           9 5 0       1 2 5 0           3 0   A L L E N     S A L E S M A N       1 6 0 0         2 8 5 0       1 6 0 0           9 5 0       1 2 5 0           3 0   B L A K E     M A N A G E R         2 8 5 0         2 8 5 0       2 9 7 5           9 5 0       2 4 5 0  returned by the window functions. Use a simple CASE expression to display the “status” of each employee in the final result set:  12.12 Calculating Simple Subtotals  Problem  s e l e c t   d e p t n o , e n a m e , j o b , s a l ,                 c a s e   w h e n   s a l   =   m a x _ b y _ d e p t                           t h e n   ' T O P   S A L   I N   D E P T '                           w h e n   s a l   =   m i n _ b y _ d e p t                           t h e n   ' L O W   S A L   I N   D E P T '                 e n d   d e p t _ s t a t u s ,                 c a s e   w h e n   s a l   =   m a x _ b y _ j o b                           t h e n   ' T O P   S A L   I N   J O B '                           w h e n   s a l   =   m i n _ b y _ j o b                           t h e n   ' L O W   S A L   I N   J O B '                 e n d   j o b _ s t a t u s       f r o m       s e l e c t   d e p t n o , e n a m e , j o b , s a l ,                 m a x   s a l   o v e r   p a r t i t i o n   b y   d e p t n o     m a x _ b y _ d e p t ,                 m a x   s a l   o v e r   p a r t i t i o n   b y   j o b     m a x _ b y _ j o b ,                 m i n   s a l   o v e r   p a r t i t i o n   b y   d e p t n o     m i n _ b y _ d e p t ,                 m i n   s a l   o v e r   p a r t i t i o n   b y   j o b     m i n _ b y _ j o b       f r o m   e m p                     x     w h e r e   s a l   i n     m a x _ b y _ d e p t , m a x _ b y _ j o b ,                                 m i n _ b y _ d e p t , m i n _ b y _ j o b       D E P T N O   E N A M E     J O B                   S A L   D E P T _ S T A T U S           J O B _ S T A T U S   - - - - - -   - - - - - -   - - - - - - - - -   - - - - -   - - - - - - - - - - - - - - -   - - - - - - - - - - - - - -           1 0   M I L L E R   C L E R K             1 3 0 0   L O W   S A L   I N   D E P T   T O P   S A L   I N   J O B           1 0   C L A R K     M A N A G E R         2 4 5 0                                   L O W   S A L   I N   J O B           1 0   K I N G       P R E S I D E N T     5 0 0 0   T O P   S A L   I N   D E P T   T O P   S A L   I N   J O B           2 0   S C O T T     A N A L Y S T         3 0 0 0   T O P   S A L   I N   D E P T   T O P   S A L   I N   J O B           2 0   F O R D       A N A L Y S T         3 0 0 0   T O P   S A L   I N   D E P T   T O P   S A L   I N   J O B           2 0   S M I T H     C L E R K               8 0 0   L O W   S A L   I N   D E P T   L O W   S A L   I N   J O B           2 0   J O N E S     M A N A G E R         2 9 7 5                                   T O P   S A L   I N   J O B           3 0   J A M E S     C L E R K               9 5 0   L O W   S A L   I N   D E P T           3 0   M A R T I N   S A L E S M A N       1 2 5 0                                   L O W   S A L   I N   J O B           3 0   W A R D       S A L E S M A N       1 2 5 0                                   L O W   S A L   I N   J O B           3 0   A L L E N     S A L E S M A N       1 6 0 0                                   T O P   S A L   I N   J O B           3 0   B L A K E     M A N A G E R         2 8 5 0   T O P   S A L   I N   D E P T  For the purposes of this recipe, a simple subtotal is defined as a result set that contains values from the aggregation of one column along with a grand total value for the table. An example would be a result set that sums the salaries in table EMP by JOB and that also includes the sum of all salaries in table EMP. The summed salaries by JOB are the subtotals, and the sum of all salaries in table EMP is the grand total. Such a result set should look as follows:  Solution The ROLLUP extension to the GROUP BY clause solves this problem perfectly. If ROLLUP is not available for your RDBMS, you can solve the problem, albeit with more difficulty, using a scalar subquery or a UNION query.  DB2 and Oracle Use the aggregate function SUM to sum the salaries, and use the ROLLUP extension of GROUP BY to organize the results into subtotals  by JOB  and a grand total  for the whole table :  SQL Server and MySQL  J O B                             S A L   - - - - - - - - -   - - - - - - - - - -   A N A L Y S T                   6 0 0 0   C L E R K                       4 1 5 0   M A N A G E R                   8 2 7 5   P R E S I D E N T               5 0 0 0   S A L E S M A N                 5 6 0 0   T O T A L                     2 9 0 2 5 1   s e l e c t   c a s e   g r o u p i n g   j o b     2                           w h e n   0   t h e n   j o b   3                           e l s e   ' T O T A L '   4                 e n d   j o b ,   5                 s u m   s a l     s a l   6       f r o m   e m p   7     g r o u p   b y   r o l l u p   j o b    Use the aggregate function SUM to sum the salaries, and use WITH ROLLUP to organize the results into subtotals  by JOB  and a grand total  for the whole table . Then use COALESCE to supply the label TOTAL for the grand total row  which will otherwise have a NULL in the JOB column :  With SQL Server, you also have the option to use the GROUPING function shown in the Oracle DB2 recipe rather than COALESCE to determine the level of aggregation.  PostgreSQL Similar to the SQL Server and MySQL solutions, you use the ROLLUP extension to GROUP BY with slightly different syntax:  Discussion  DB2 and Oracle The first step is to use the aggregate function SUM, grouping by JOB in order to sum the salaries by JOB:  1   s e l e c t   c o a l e s c e   j o b , ' T O T A L '     j o b ,   2                 s u m   s a l     s a l   3       f r o m   e m p   4     g r o u p   b y   j o b   w i t h   r o l l u p s e l e c t   c o a l e s c e   j o b , ' T O T A L '     j o b ,                   s u m   s a l     s a l         f r o m   e m p       g r o u p   b y   r o l l u p   j o b   s e l e c t   j o b ,   s u m   s a l     s a l       f r o m   e m p     g r o u p   b y   j o b     J O B                   S A L   - - - - - - - - -   - - - - -   A N A L Y S T         6 0 0 0   C L E R K             4 1 5 0    The next step is to use the ROLLUP extension to GROUP BY to produce a grand total for all salaries along with the subtotals for each JOB:  The last step is to use the GROUPING function in the JOB column to display a label for the grand total. If the value of JOB is NULL, the GROUPING function will return 1, which signifies that the value for SAL is the grand total created by ROLLUP. If the value of JOB is not NULL, the GROUPING function will return 0, which signifies the value for SAL is the result of the GROUP BY, not the ROLLUP. Wrap the call to GROUPING JOB  in a CASE expression that returns either the job name or the label TOTAL, as appropriate:  M A N A G E R         8 2 7 5   P R E S I D E N T     5 0 0 0   S A L E S M A N       5 6 0 0 s e l e c t   j o b ,   s u m   s a l     s a l       f r o m   e m p     g r o u p   b y   r o l l u p   j o b       J O B                       S A L   - - - - - - - - -   - - - - - - -   A N A L Y S T             6 0 0 0   C L E R K                 4 1 5 0   M A N A G E R             8 2 7 5   P R E S I D E N T         5 0 0 0   S A L E S M A N           5 6 0 0                           2 9 0 2 5 s e l e c t   c a s e   g r o u p i n g   j o b                             w h e n   0   t h e n   j o b                           e l s e   ' T O T A L '                 e n d   j o b ,                 s u m   s a l     s a l       f r o m   e m p     g r o u p   b y   r o l l u p   j o b         J O B                             S A L   - - - - - - - - -   - - - - - - - - - -   A N A L Y S T                   6 0 0 0   C L E R K                       4 1 5 0    SQL Server and MySQL The first step is to use the aggregate function SUM, grouping the results by JOB to generate salary sums by JOB:  The next step is to use GROUP BY’s ROLLUP extension to produce a grand total for all salaries along with the subtotals for each JOB:  The last step is to use the COEALESCE function against the JOB column. If the value of JOB is NULL, the value for SAL is the grand total created by ROLLUP. If the value of JOB is not NULL, the value for SAL is the result of the “regular” GROUP BY, not the ROLLUP:  M A N A G E R                   8 2 7 5   P R E S I D E N T               5 0 0 0   S A L E S M A N                 5 6 0 0   T O T A L                     2 9 0 2 5 s e l e c t   j o b ,   s u m   s a l     s a l       f r o m   e m p     g r o u p   b y   j o b       J O B                   S A L   - - - - - - - - -   - - - - -   A N A L Y S T         6 0 0 0   C L E R K             4 1 5 0   M A N A G E R         8 2 7 5   P R E S I D E N T     5 0 0 0   S A L E S M A N       5 6 0 0 s e l e c t   j o b ,   s u m   s a l     s a l       f r o m   e m p     g r o u p   b y   j o b   w i t h   r o l l u p     J O B                       S A L   - - - - - - - - -   - - - - - - -   A N A L Y S T             6 0 0 0   C L E R K                 4 1 5 0   M A N A G E R             8 2 7 5   P R E S I D E N T         5 0 0 0   S A L E S M A N           5 6 0 0                           2 9 0 2 5  PostgreSQL The solution is the same in its manner of operation as the preceeding solution for MySQL and SQL Server. The only difference is the syntax for the ROLLUP clause: write ROLLUP JOB  after GROUP BY.  12.13 Calculating Subtotals for All Possible Expression Combinations  Problem You want to find the sum of all salaries by DEPTNO, and by JOB, for every JOB  DEPTNO combination. You also want a grand total for all salaries in table EMP. You want to return the following result set:  s e l e c t   c o a l e s c e   j o b , ' T O T A L '     j o b ,                 s u m   s a l     s a l       f r o m   e m p     g r o u p   b y   j o b   w i t h   r o l l u p     J O B                             S A L   - - - - - - - - -   - - - - - - - - - -   A N A L Y S T                   6 0 0 0   C L E R K                       4 1 5 0   M A N A G E R                   8 2 7 5   P R E S I D E N T               5 0 0 0   S A L E S M A N                 5 6 0 0   T O T A L                     2 9 0 2 5 D E P T N O   J O B               C A T E G O R Y                                     S A L   - - - - - -   - - - - - - - - -   - - - - - - - - - - - - - - - - - - - - -   - - - - - - -           1 0   C L E R K           T O T A L   B Y   D E P T   A N D   J O B         1 3 0 0           1 0   M A N A G E R       T O T A L   B Y   D E P T   A N D   J O B         2 4 5 0           1 0   P R E S I D E N T   T O T A L   B Y   D E P T   A N D   J O B         5 0 0 0           2 0   C L E R K           T O T A L   B Y   D E P T   A N D   J O B         1 9 0 0           3 0   C L E R K           T O T A L   B Y   D E P T   A N D   J O B           9 5 0           3 0   S A L E S M A N     T O T A L   B Y   D E P T   A N D   J O B         5 6 0 0           3 0   M A N A G E R       T O T A L   B Y   D E P T   A N D   J O B         2 8 5 0           2 0   M A N A G E R       T O T A L   B Y   D E P T   A N D   J O B         2 9 7 5           2 0   A N A L Y S T       T O T A L   B Y   D E P T   A N D   J O B         6 0 0 0                 C L E R K           T O T A L   B Y   J O B                           4 1 5 0    Solution Extensions added to GROUP BY in recent years make this a fairly easy problem to solve. If your platform does not supply such extensions for computing various levels of subtotals, then you must compute them manually  via self-joins or scalar subqueries .  DB2 For DB2, you will need to use CAST to return from GROUPING as the CHAR 1  data type:  Oracle Use the CUBE extension to the GROUP BY clause with the concatenation operator :                A N A L Y S T       T O T A L   B Y   J O B                           6 0 0 0                 M A N A G E R       T O T A L   B Y   J O B                           8 2 7 5                 P R E S I D E N T   T O T A L   B Y   J O B                           5 0 0 0                 S A L E S M A N     T O T A L   B Y   J O B                           5 6 0 0           1 0                       T O T A L   B Y   D E P T                         8 7 5 0           3 0                       T O T A L   B Y   D E P T                         9 4 0 0           2 0                       T O T A L   B Y   D E P T                       1 0 8 7 5                                     G R A N D   T O T A L   F O R   T A B L E       2 9 0 2 5   1   s e l e c t   d e p t n o ,     2                 j o b ,     3                 c a s e   c a s t   g r o u p i n g   d e p t n o     a s   c h a r   1           4                           c a s t   g r o u p i n g   j o b     a s   c h a r   1         5                           w h e n   ' 0 0 '   t h e n   ' T O T A L   B Y   D E P T   A N D   J O B '     6                           w h e n   ' 1 0 '   t h e n   ' T O T A L   B Y   J O B '     7                           w h e n   ' 0 1 '   t h e n   ' T O T A L   B Y   D E P T '     8                           w h e n   ' 1 1 '   t h e n   ' T O T A L   F O R   T A B L E '     9                 e n d   c a t e g o r y ,   1 0                 s u m   s a l     1 1       f r o m   e m p   1 2     g r o u p   b y   c u b e   d e p t n o , j o b     1 3     o r d e r   b y   g r o u p i n g   j o b   , g r o u p i n g   d e p t n o     1   s e l e c t   d e p t n o ,     2                 j o b ,     3                 c a s e   g r o u p i n g   d e p t n o     g r o u p i n g   j o b      SQL Server Use the CUBE extension to the GROUP BY clause. For SQL Server, you will need to CAST the results from GROUPING to CHAR 1 , and you will need to use the + operator for concatenation  as opposed to Oracle’s  operator :  PostgreSQL PostgreSQL is similar to the preceding, but with slightly different syntax for the CUBE operator and the concatenation:    4                           w h e n   ' 0 0 '   t h e n   ' T O T A L   B Y   D E P T   A N D   J O B '     5                           w h e n   ' 1 0 '   t h e n   ' T O T A L   B Y   J O B '     6                           w h e n   ' 0 1 '   t h e n   ' T O T A L   B Y   D E P T '     7                           w h e n   ' 1 1 '   t h e n   ' G R A N D   T O T A L F O R   T A B L E '     8                 e n d   c a t e g o r y ,     9                 s u m   s a l     s a l   1 0       f r o m   e m p   1 1     g r o u p   b y   c u b e   d e p t n o , j o b     1 2     o r d e r   b y   g r o u p i n g   j o b   , g r o u p i n g   d e p t n o     1   s e l e c t   d e p t n o ,     2                 j o b ,     3                 c a s e   c a s t   g r o u p i n g   d e p t n o   a s   c h a r   1     +     4                           c a s t   g r o u p i n g   j o b   a s   c h a r   1         5                           w h e n   ' 0 0 '   t h e n   ' T O T A L   B Y   D E P T   A N D   J O B '     6                           w h e n   ' 1 0 '   t h e n   ' T O T A L   B Y   J O B '     7                           w h e n   ' 0 1 '   t h e n   ' T O T A L   B Y   D E P T '     8                           w h e n   ' 1 1 '   t h e n   ' G R A N D   T O T A L   F O R   T A B L E '     9                 e n d   c a t e g o r y ,   1 0                 s u m   s a l     s a l   1 1       f r o m   e m p   1 2     g r o u p   b y   d e p t n o , j o b   w i t h   c u b e   1 3     o r d e r   b y   g r o u p i n g   j o b   , g r o u p i n g   d e p t n o   s e l e c t   d e p t n o , j o b   , c a s e   c o n c a t     c a s t     g r o u p i n g   d e p t n o     a s   c h a r   1     , c a s t     g r o u p i n g   j o b     a s   c h a r   1                   w h e n   ' 0 0 '   t h e n   ' T O T A L   B Y   D E P T   A N D   J O B '                                 w h e n   ' 1 0 '   t h e n   ' T O T A L   B Y   J O B '                                 w h e n   ' 0 1 '   t h e n   ' T O T A L   B Y   D E P T '                                 w h e n   ' 1 1 '   t h e n   ' G R A N D   T O T A L   F O R   T A B L E '    MySQL Although part of the functionality is available, it is not complete, as MySQL has no CUBE function. Hence, use multiple UNION ALLs, creating different sums for each:  Discussion  Oracle, DB2, and SQL Server The solutions for all three are essentially the same. The first step is to use the aggregate function SUM and group by both DEPTNO and JOB to find the total salaries for each JOB and DEPTNO combination:                      e n d   c a t e g o r y       ,   s u m   s a l     a s   s a l           f r o m   e m p           g r o u p   b y   c u b e   d e p t n o , j o b     1   s e l e c t   d e p t n o ,   j o b ,     2                 ' T O T A L   B Y   D E P T   A N D   J O B '   a s   c a t e g o r y ,     3                 s u m   s a l     a s   s a l     4       f r o m   e m p     5     g r o u p   b y   d e p t n o ,   j o b     6     u n i o n   a l l     7   s e l e c t   n u l l ,   j o b ,   ' T O T A L   B Y   J O B ' ,   s u m   s a l       8       f r o m   e m p     9     g r o u p   b y   j o b   1 0     u n i o n   a l l   1 1   s e l e c t   d e p t n o ,   n u l l ,   ' T O T A L   B Y   D E P T ' ,   s u m   s a l     1 2       f r o m   e m p   1 3     g r o u p   b y   d e p t n o   1 4     u n i o n   a l l   1 5   s e l e c t   n u l l , n u l l , ' G R A N D   T O T A L   F O R   T A B L E ' ,   s u m   s a l     1 6     f r o m   e m p s e l e c t   d e p t n o ,   j o b ,   s u m   s a l     s a l       f r o m   e m p     g r o u p   b y   d e p t n o ,   j o b     D E P T N O   J O B                       S A L   - - - - - -   - - - - - - - - -   - - - - - - -           1 0   C L E R K                 1 3 0 0    The next step is to create subtotals by JOB and DEPTNO along with the grand total for the whole table. Use the CUBE extension to the GROUP BY clause to perform aggregations on SAL by DEPTNO, JOB, and for the whole table:  Next, use the GROUPING function in conjunction with CASE to format the results into more meaningful output. The value from GROUPING JOB           1 0   M A N A G E R             2 4 5 0           1 0   P R E S I D E N T         5 0 0 0           2 0   C L E R K                 1 9 0 0           2 0   A N A L Y S T             6 0 0 0           2 0   M A N A G E R             2 9 7 5           3 0   C L E R K                   9 5 0           3 0   M A N A G E R             2 8 5 0           3 0   S A L E S M A N           5 6 0 0 s e l e c t   d e p t n o ,                 j o b ,                 s u m   s a l     s a l       f r o m   e m p     g r o u p   b y   c u b e   d e p t n o , j o b         D E P T N O   J O B                       S A L   - - - - - -   - - - - - - - - -   - - - - - - -                                         2 9 0 2 5                 C L E R K                 4 1 5 0                 A N A L Y S T             6 0 0 0                 M A N A G E R             8 2 7 5                 S A L E S M A N           5 6 0 0                 P R E S I D E N T         5 0 0 0           1 0                             8 7 5 0           1 0   C L E R K                 1 3 0 0           1 0   M A N A G E R             2 4 5 0           1 0   P R E S I D E N T         5 0 0 0           2 0                           1 0 8 7 5           2 0   C L E R K                 1 9 0 0           2 0   A N A L Y S T             6 0 0 0           2 0   M A N A G E R             2 9 7 5           3 0                             9 4 0 0           3 0   C L E R K                   9 5 0           3 0   M A N A G E R             2 8 5 0           3 0   S A L E S M A N           5 6 0 0  will be 1 or 0 depending on whether the values for SAL are due to the GROUP BY or the CUBE. If the results are due to the CUBE, the value will be 1; otherwise, it will be 0. The same goes for GROUPING DEPTNO . Looking at the first step of the solution, you should see that grouping is done by DEPTNO and JOB. Thus, the expected values from the calls to GROUPING when a row represents a combination of both DEPTNO and JOB is 0. The following query confirms this:  The final step is to use a CASE expression to determine which category each row belongs to based on the values returned by GROUPING JOB  and GROUPING DEPTNO  concatenated:  s e l e c t   d e p t n o ,                 j o b ,                 g r o u p i n g   d e p t n o     i s _ d e p t n o _ s u b t o t a l ,                 g r o u p i n g   j o b     i s _ j o b _ s u b t o t a l ,                 s u m   s a l     s a l       f r o m   e m p     g r o u p   b y   c u b e   d e p t n o , j o b       o r d e r   b y   3 , 4     D E P T N O   J O B               I S _ D E P T N O _ S U B T O T A L   I S _ J O B _ S U B T O T A L           S A L   - - - - - -   - - - - - - - - -   - - - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - -   - - - - - - -           1 0   C L E R K                                             0                               0         1 3 0 0           1 0   M A N A G E R                                         0                               0         2 4 5 0           1 0   P R E S I D E N T                                     0                               0         5 0 0 0           2 0   C L E R K                                             0                               0         1 9 0 0           3 0   C L E R K                                             0                               0           9 5 0           3 0   S A L E S M A N                                       0                               0         5 6 0 0           3 0   M A N A G E R                                         0                               0         2 8 5 0           2 0   M A N A G E R                                         0                               0         2 9 7 5           2 0   A N A L Y S T                                         0                               0         6 0 0 0           1 0                                                         0                               1         8 7 5 0           2 0                                                         0                               1       1 0 8 7 5           3 0                                                         0                               1         9 4 0 0                 C L E R K                                             1                               0         4 1 5 0                 A N A L Y S T                                         1                               0         6 0 0 0                 M A N A G E R                                         1                               0         8 2 7 5                 P R E S I D E N T                                     1                               0         5 0 0 0                 S A L E S M A N                                       1                               0         5 6 0 0                                                                       1                               1       2 9 0 2 5  This Oracle solution implicitly converts the results from the GROUPING functions to a character type in preparation for concatenating the two values. DB2 and SQL Server users will need to explicitly CAST the results of the GROUPING functions to CHAR 1 , as shown in the solution. In addition, SQL Server users must use the + operator, and not the  operator, to concatenate the results from the two GROUPING calls into one string. For Oracle and DB2 users, there is an additional extension to GROUP BY called GROUPING SETS; this extension is extremely useful. For example, you can use GROUPING SETS to mimic the output created by CUBE as is  s e l e c t   d e p t n o ,                 j o b ,                 c a s e   g r o u p i n g   d e p t n o     g r o u p i n g   j o b                             w h e n   ' 0 0 '   t h e n   ' T O T A L   B Y   D E P T   A N D   J O B '                           w h e n   ' 1 0 '   t h e n   ' T O T A L   B Y   J O B '                           w h e n   ' 0 1 '   t h e n   ' T O T A L   B Y   D E P T '                           w h e n   ' 1 1 '   t h e n   ' G R A N D   T O T A L   F O R   T A B L E '                 e n d   c a t e g o r y ,                 s u m   s a l     s a l       f r o m   e m p     g r o u p   b y   c u b e   d e p t n o , j o b       o r d e r   b y   g r o u p i n g   j o b   , g r o u p i n g   d e p t n o       D E P T N O   J O B               C A T E G O R Y                                     S A L   - - - - - -   - - - - - - - - -   - - - - - - - - - - - - - - - - - - - - -   - - - - - - -           1 0   C L E R K           T O T A L   B Y   D E P T   A N D   J O B         1 3 0 0           1 0   M A N A G E R       T O T A L   B Y   D E P T   A N D   J O B         2 4 5 0           1 0   P R E S I D E N T   T O T A L   B Y   D E P T   A N D   J O B         5 0 0 0           2 0   C L E R K           T O T A L   B Y   D E P T   A N D   J O B         1 9 0 0           3 0   C L E R K           T O T A L   B Y   D E P T   A N D   J O B           9 5 0           3 0   S A L E S M A N     T O T A L   B Y   D E P T   A N D   J O B         5 6 0 0           3 0   M A N A G E R       T O T A L   B Y   D E P T   A N D   J O B         2 8 5 0           2 0   M A N A G E R       T O T A L   B Y   D E P T   A N D   J O B         2 9 7 5           2 0   A N A L Y S T       T O T A L   B Y   D E P T   A N D   J O B         6 0 0 0                 C L E R K           T O T A L   B Y   J O B                           4 1 5 0                 A N A L Y S T       T O T A L   B Y   J O B                           6 0 0 0                 M A N A G E R       T O T A L   B Y   J O B                           8 2 7 5                 P R E S I D E N T   T O T A L   B Y   J O B                           5 0 0 0                 S A L E S M A N     T O T A L   B Y   J O B                           5 6 0 0           1 0                       T O T A L   B Y   D E P T                         8 7 5 0           3 0                       T O T A L   B Y   D E P T                         9 4 0 0           2 0                       T O T A L   B Y   D E P T                       1 0 8 7 5                                     G R A N D   T O T A L   F O R   T A B L E       2 9 0 2 5  shown here  DB2 and SQL Server users will need to use CAST to ensure the values returned by the GROUPING function are in the correct format in the same way as in the CUBE solution :  What’s great about GROUPING SETS is that it allows you to define the groups. The GROUPING SETS clause in the preceding query causes groups to be created by DEPTNO, by JOB, and by the combination of DEPTNO and JOB, and finally the empty parentheses requests a grand total. GROUPING SETS gives you enormous flexibility for creating reports with different levels of aggregation; for example, if you wanted to modify  s e l e c t   d e p t n o ,                 j o b ,                 c a s e   g r o u p i n g   d e p t n o     g r o u p i n g   j o b                             w h e n   ' 0 0 '   t h e n   ' T O T A L   B Y   D E P T   A N D   J O B '                           w h e n   ' 1 0 '   t h e n   ' T O T A L   B Y   J O B '                           w h e n   ' 0 1 '   t h e n   ' T O T A L   B Y   D E P T '                           w h e n   ' 1 1 '   t h e n   ' G R A N D   T O T A L   F O R   T A B L E '                 e n d   c a t e g o r y ,                 s u m   s a l     s a l       f r o m   e m p     g r o u p   b y   g r o u p i n g   s e t s       d e p t n o   ,   j o b   ,   d e p t n o , j o b   ,           D E P T N O   J O B               C A T E G O R Y                                     S A L   - - - - - -   - - - - - - - - -   - - - - - - - - - - - - - - - - - - - - -   - - - - - - -           1 0   C L E R K           T O T A L   B Y   D E P T   A N D   J O B         1 3 0 0           2 0   C L E R K           T O T A L   B Y   D E P T   A N D   J O B         1 9 0 0           3 0   C L E R K           T O T A L   B Y   D E P T   A N D   J O B           9 5 0           2 0   A N A L Y S T       T O T A L   B Y   D E P T   A N D   J O B         6 0 0 0           1 0   M A N A G E R       T O T A L   B Y   D E P T   A N D   J O B         2 4 5 0           2 0   M A N A G E R       T O T A L   B Y   D E P T   A N D   J O B         2 9 7 5           3 0   M A N A G E R       T O T A L   B Y   D E P T   A N D   J O B         2 8 5 0           3 0   S A L E S M A N     T O T A L   B Y   D E P T   A N D   J O B         5 6 0 0           1 0   P R E S I D E N T   T O T A L   B Y   D E P T   A N D   J O B         5 0 0 0                 C L E R K           T O T A L   B Y   J O B                           4 1 5 0                 A N A L Y S T       T O T A L   B Y   J O B                           6 0 0 0                 M A N A G E R       T O T A L   B Y   J O B                           8 2 7 5                 S A L E S M A N     T O T A L   B Y   J O B                           5 6 0 0                 P R E S I D E N T   T O T A L   B Y   J O B                           5 0 0 0           1 0                       T O T A L   B Y   D E P T                         8 7 5 0           2 0                       T O T A L   B Y   D E P T                       1 0 8 7 5           3 0                       T O T A L   B Y   D E P T                         9 4 0 0                                     G R A N D   T O T A L   F O R   T A B L E       2 9 0 2 5  the preceding example to exclude the GRAND TOTAL, simply modify the GROUPING SETS clause by excluding the empty parentheses:  You can also eliminate a subtotal, such as the one on DEPTNO, simply by omitting  DEPTNO  from the GROUPING SETS clause:    *   n o   g r a n d   t o t a l   *       s e l e c t   d e p t n o ,                 j o b ,                 c a s e   g r o u p i n g   d e p t n o     g r o u p i n g   j o b                             w h e n   ' 0 0 '   t h e n   ' T O T A L   B Y   D E P T   A N D   J O B '                           w h e n   ' 1 0 '   t h e n   ' T O T A L   B Y   J O B '                           w h e n   ' 0 1 '   t h e n   ' T O T A L   B Y   D E P T '                           w h e n   ' 1 1 '   t h e n   ' G R A N D   T O T A L   F O R   T A B L E '                 e n d   c a t e g o r y ,                 s u m   s a l     s a l       f r o m   e m p     g r o u p   b y   g r o u p i n g   s e t s       d e p t n o   ,   j o b   ,   d e p t n o , j o b           D E P T N O   J O B               C A T E G O R Y                                         S A L   - - - - - -   - - - - - - - - -   - - - - - - - - - - - - - - - - - - - - -   - - - - - - - - - -           1 0   C L E R K           T O T A L   B Y   D E P T   A N D   J O B               1 3 0 0           2 0   C L E R K           T O T A L   B Y   D E P T   A N D   J O B               1 9 0 0           3 0   C L E R K           T O T A L   B Y   D E P T   A N D   J O B                 9 5 0           2 0   A N A L Y S T       T O T A L   B Y   D E P T   A N D   J O B               6 0 0 0           1 0   M A N A G E R       T O T A L   B Y   D E P T   A N D   J O B               2 4 5 0           2 0   M A N A G E R       T O T A L   B Y   D E P T   A N D   J O B               2 9 7 5           3 0   M A N A G E R       T O T A L   B Y   D E P T   A N D   J O B               2 8 5 0           3 0   S A L E S M A N     T O T A L   B Y   D E P T   A N D   J O B               5 6 0 0           1 0   P R E S I D E N T   T O T A L   B Y   D E P T   A N D   J O B               5 0 0 0                 C L E R K           T O T A L   B Y   J O B                                 4 1 5 0                 A N A L Y S T       T O T A L   B Y   J O B                                 6 0 0 0                 M A N A G E R         T O T A L   B Y   J O B                                 8 2 7 5                 S A L E S M A N     T O T A L   B Y   J O B                                 5 6 0 0                 P R E S I D E N T   T O T A L   B Y   J O B                                 5 0 0 0           1 0                       T O T A L   B Y   D E P T                               8 7 5 0           2 0                       T O T A L   B Y   D E P T                             1 0 8 7 5           3 0                       T O T A L   B Y   D E P T                               9 4 0 0   *   n o s u b t o t a l s   b y   D E P T N O   *       s e l e c t   d e p t n o ,                 j o b ,    As you can see, GROUPING SETS makes it easy indeed to play around with totals and subtotals to look at your data from different angles.  MySQL The first step is to use the aggregate function SUM and group by both DEPTNO and JOB:                c a s e   g r o u p i n g   d e p t n o     g r o u p i n g   j o b                             w h e n   ' 0 0 '   t h e n   ' T O T A L   B Y   D E P T   A N D   J O B '                           w h e n   ' 1 0 '   t h e n   ' T O T A L   B Y   J O B '                           w h e n   ' 0 1 '   t h e n   ' T O T A L   B Y   D E P T '                           w h e n   ' 1 1 '   t h e n   ' G R A N D   T O T A L   F O R   T A B L E '                 e n d   c a t e g o r y ,                 s u m   s a l     s a l       f r o m   e m p     g r o u p   b y   g r o u p i n g   s e t s       j o b   ,   d e p t n o , j o b   ,           o r d e r   b y   3       D E P T N O   J O B               C A T E G O R Y                                           S A L   - - - - - -   - - - - - - - - -   - - - - - - - - - - - - - - - - - - - - -   - - - - - - - - - -                                     G R A N D   T O T A L   F O R   T A B L E             2 9 0 2 5           1 0   C L E R K           T O T A L   B Y   D E P T   A N D   J O B               1 3 0 0           2 0   C L E R K           T O T A L   B Y   D E P T   A N D   J O B               1 9 0 0           3 0   C L E R K           T O T A L   B Y   D E P T   A N D   J O B                 9 5 0           2 0   A N A L Y S T       T O T A L   B Y   D E P T   A N D   J O B               6 0 0 0           2 0   M A N A G E R       T O T A L   B Y   D E P T   A N D   J O B               2 9 7 5           3 0   M A N A G E R       T O T A L   B Y   D E P T   A N D   J O B               2 8 5 0           3 0   S A L E S M A N     T O T A L   B Y   D E P T   A N D   J O B               5 6 0 0           1 0   P R E S I D E N T   T O T A L   B Y   D E P T   A N D   J O B               5 0 0 0           1 0   M A N A G E R       T O T A L   B Y   D E P T   A N D   J O B               2 4 5 0                 C L E R K           T O T A L   B Y   J O B                                 4 1 5 0                 S A L E S M A N     T O T A L   B Y   J O B                                 5 6 0 0                 P R E S I D E N T   T O T A L   B Y   J O B                                 5 0 0 0                 M A N A G E R       T O T A L   B Y   J O B                                 8 2 7 5                 A N A L Y S T       T O T A L   B Y   J O B                                 6 0 0 0 s e l e c t   d e p t n o ,   j o b ,                 ' T O T A L   B Y   D E P T   A N D   J O B '   a s   c a t e g o r y ,                 s u m   s a l     a s   s a l       f r o m   e m p     g r o u p   b y   d e p t n o ,   j o b     D E P T N O   J O B               C A T E G O R Y                                     S A L    The next step is to use UNION ALL to append TOTAL BY JOB sums:  The next step is to UNION ALL the sum of all the salaries by DEPTNO:  - - - - - -   - - - - - - - - -   - - - - - - - - - - - - - - - - - - - - -   - - - - - - -           1 0   C L E R K           T O T A L   B Y   D E P T   A N D   J O B         1 3 0 0           1 0   M A N A G E R       T O T A L   B Y   D E P T   A N D   J O B         2 4 5 0           1 0   P R E S I D E N T   T O T A L   B Y   D E P T   A N D   J O B         5 0 0 0           2 0   C L E R K           T O T A L   B Y   D E P T   A N D   J O B         1 9 0 0           2 0   A N A L Y S T       T O T A L   B Y   D E P T   A N D   J O B         6 0 0 0           2 0   M A N A G E R       T O T A L   B Y   D E P T   A N D   J O B         2 9 7 5           3 0   C L E R K           T O T A L   B Y   D E P T   A N D   J O B           9 5 0           3 0   M A N A G E R       T O T A L   B Y   D E P T   A N D   J O B         2 8 5 0           3 0   S A L E S M A N     T O T A L   B Y   D E P T   A N D   J O B         5 6 0 0 s e l e c t   d e p t n o ,   j o b ,                 ' T O T A L   B Y   D E P T   A N D   J O B '   a s   c a t e g o r y ,                 s u m   s a l     a s   s a l       f r o m   e m p     g r o u p   b y   d e p t n o ,   j o b     u n i o n   a l l   s e l e c t   n u l l ,   j o b ,   ' T O T A L   B Y   J O B ' ,   s u m   s a l         f r o m   e m p     g r o u p   b y   j o b     D E P T N O   J O B               C A T E G O R Y                                     S A L   - - - - - -   - - - - - - - - -   - - - - - - - - - - - - - - - - - - - - -   - - - - - - -           1 0   C L E R K           T O T A L   B Y   D E P T   A N D   J O B         1 3 0 0           1 0   M A N A G E R       T O T A L   B Y   D E P T   A N D   J O B         2 4 5 0           1 0   P R E S I D E N T   T O T A L   B Y   D E P T   A N D   J O B         5 0 0 0           2 0   C L E R K           T O T A L   B Y   D E P T   A N D   J O B         1 9 0 0           2 0   A N A L Y S T       T O T A L   B Y   D E P T   A N D   J O B         6 0 0 0           2 0   M A N A G E R       T O T A L   B Y   D E P T   A N D   J O B         2 9 7 5           3 0   C L E R K           T O T A L   B Y   D E P T   A N D   J O B           9 5 0           3 0   M A N A G E R       T O T A L   B Y   D E P T   A N D   J O B         2 8 5 0           3 0   S A L E S M A N     T O T A L   B Y   D E P T   A N D   J O B         5 6 0 0                 A N A L Y S T       T O T A L   B Y   J O B                           6 0 0 0                 C L E R K           T O T A L   B Y   J O B                           4 1 5 0                 M A N A G E R       T O T A L   B Y   J O B                           8 2 7 5                 P R E S I D E N T   T O T A L   B Y   J O B                           5 0 0 0                 S A L E S M A N     T O T A L   B Y   J O B                           5 6 0 0 s e l e c t   d e p t n o ,   j o b ,                 ' T O T A L   B Y   D E P T   A N D   J O B '   a s   c a t e g o r y ,                 s u m   s a l     a s   s a l    The final step is to use UNION ALL to append the sum of all salaries:      f r o m   e m p     g r o u p   b y   d e p t n o ,   j o b     u n i o n   a l l   s e l e c t   n u l l ,   j o b ,   ' T O T A L   B Y   J O B ' ,   s u m   s a l         f r o m   e m p     g r o u p   b y   j o b     u n i o n   a l l   s e l e c t   d e p t n o ,   n u l l ,   ' T O T A L   B Y   D E P T ' ,   s u m   s a l         f r o m   e m p     g r o u p   b y   d e p t n o     D E P T N O   J O B               C A T E G O R Y                                     S A L   - - - - - -   - - - - - - - - -   - - - - - - - - - - - - - - - - - - - - -   - - - - - - -           1 0   C L E R K           T O T A L   B Y   D E P T   A N D   J O B         1 3 0 0           1 0   M A N A G E R       T O T A L   B Y   D E P T   A N D   J O B         2 4 5 0           1 0   P R E S I D E N T   T O T A L   B Y   D E P T   A N D   J O B         5 0 0 0           2 0   C L E R K           T O T A L   B Y   D E P T   A N D   J O B         1 9 0 0           2 0   A N A L Y S T       T O T A L   B Y   D E P T   A N D   J O B         6 0 0 0           2 0   M A N A G E R       T O T A L   B Y   D E P T   A N D   J O B         2 9 7 5           3 0   C L E R K           T O T A L   B Y   D E P T   A N D   J O B           9 5 0           3 0   M A N A G E R       T O T A L   B Y   D E P T   A N D   J O B         2 8 5 0           3 0   S A L E S M A N     T O T A L   B Y   D E P T   A N D   J O B         5 6 0 0                 A N A L Y S T       T O T A L   B Y   J O B                           6 0 0 0                 C L E R K           T O T A L   B Y   J O B                           4 1 5 0                 M A N A G E R       T O T A L   B Y   J O B                           8 2 7 5                 P R E S I D E N T   T O T A L   B Y   J O B                           5 0 0 0                 S A L E S M A N     T O T A L   B Y   J O B                           5 6 0 0           1 0                       T O T A L   B Y   D E P T                         8 7 5 0           2 0                       T O T A L   B Y   D E P T                         1 0 8 7 5           3 0                       T O T A L   B Y   D E P T                           9 4 0 0 s e l e c t   d e p t n o ,   j o b ,                 ' T O T A L   B Y   D E P T   A N D   J O B '   a s   c a t e g o r y ,                 s u m   s a l     a s   s a l       f r o m   e m p     g r o u p   b y   d e p t n o ,   j o b     u n i o n   a l l   s e l e c t   n u l l ,   j o b ,   ' T O T A L   B Y   J O B ' ,   s u m   s a l         f r o m   e m p     g r o u p   b y   j o b     u n i o n   a l l   s e l e c t   d e p t n o ,   n u l l ,   ' T O T A L   B Y   D E P T ' ,   s u m   s a l         f r o m   e m p     g r o u p   b y   d e p t n o    12.14 Identifying Rows That Are Not Subtotals  Problem You’ve used the CUBE extension of the GROUP BY clause to create a report, and you need a way to differentiate between rows that would be generated by a normal GROUP BY clause and those rows that have been generated as a result of using CUBE or ROLLUP. The following is the result set from a query using the CUBE extension to GROUP BY to create a breakdown of the salaries in table EMP:    u n i o n   a l l   s e l e c t   n u l l , n u l l ,   ' G R A N D   T O T A L   F O R   T A B L E ' ,   s u m   s a l         f r o m   e m p     D E P T N O   J O B               C A T E G O R Y                                     S A L   - - - - - -   - - - - - - - - -   - - - - - - - - - - - - - - - - - - - - -   - - - - - - -           1 0   C L E R K           T O T A L   B Y   D E P T   A N D   J O B         1 3 0 0           1 0   M A N A G E R       T O T A L   B Y   D E P T   A N D   J O B         2 4 5 0           1 0   P R E S I D E N T   T O T A L   B Y   D E P T   A N D   J O B         5 0 0 0           2 0   C L E R K           T O T A L   B Y   D E P T   A N D   J O B         1 9 0 0           2 0   A N A L Y S T       T O T A L   B Y   D E P T   A N D   J O B         6 0 0 0           2 0   M A N A G E R       T O T A L   B Y   D E P T   A N D   J O B         2 9 7 5           3 0   C L E R K           T O T A L   B Y   D E P T   A N D   J O B           9 5 0           3 0   M A N A G E R       T O T A L   B Y   D E P T   A N D   J O B         2 8 5 0           3 0   S A L E S M A N     T O T A L   B Y   D E P T   A N D   J O B         5 6 0 0                 A N A L Y S T       T O T A L   B Y   J O B                           6 0 0 0                 C L E R K           T O T A L   B Y   J O B                           4 1 5 0                 M A N A G E R       T O T A L   B Y   J O B                           8 2 7 5                 P R E S I D E N T   T O T A L   B Y   J O B                           5 0 0 0                 S A L E S M A N     T O T A L   B Y   J O B                           5 6 0 0           1 0                       T O T A L   B Y   D E P T                         8 7 5 0           2 0                       T O T A L   B Y   D E P T                       1 0 8 7 5           3 0                       T O T A L   B Y   D E P T                         9 4 0 0                                     G R A N D   T O T A L   F O R   T A B L E       2 9 0 2 5 D E P T N O   J O B                       S A L   - - - - - -   - - - - - - - - -   - - - - - - -                                         2 9 0 2 5                 C L E R K                 4 1 5 0    This report includes the sum of all salaries by DEPTNO and JOB  for each JOB per DEPTNO , the sum of all salaries by DEPTNO, the sum of all salaries by JOB, and finally a grand total  the sum of all salaries in table EMP . You want to clearly identify the different levels of aggregation. You want to be able to identify which category an aggregated value belongs to  i.e., does a given value in the SAL column represent a total by DEPTNO? By JOB? The grand total? . You would like to return the following result set:                A N A L Y S T             6 0 0 0                 M A N A G E R             8 2 7 5                 S A L E S M A N           5 6 0 0                 P R E S I D E N T         5 0 0 0           1 0                             8 7 5 0           1 0   C L E R K                 1 3 0 0           1 0   M A N A G E R             2 4 5 0           1 0   P R E S I D E N T         5 0 0 0           2 0                           1 0 8 7 5           2 0   C L E R K                 1 9 0 0           2 0   A N A L Y S T             6 0 0 0           2 0   M A N A G E R             2 9 7 5           3 0                             9 4 0 0           3 0   C L E R K                   9 5 0           3 0   M A N A G E R             2 8 5 0           3 0   S A L E S M A N           5 6 0 0 D E P T N O   J O B                       S A L   D E P T N O _ S U B T O T A L S   J O B _ S U B T O T A L S   - - - - - -   - - - - - - - - -   - - - - - - -   - - - - - - - - - - - - - - - -   - - - - - - - - - - - - -                                         2 9 0 2 5                                 1                           1                 C L E R K                 4 1 5 0                                 1                           0                 A N A L Y S T             6 0 0 0                                 1                           0                 M A N A G E R             8 2 7 5                                 1                           0                 S A L E S M A N           5 6 0 0                                 1                           0                 P R E S I D E N T         5 0 0 0                                 1                           0           1 0                             8 7 5 0                                 0                           1           1 0   C L E R K                 1 3 0 0                                 0                           0           1 0   M A N A G E R             2 4 5 0                                 0                           0           1 0   P R E S I D E N T         5 0 0 0                                 0                           0           2 0                           1 0 8 7 5                                 0                           1           2 0   C L E R K                 1 9 0 0                                 0                           0           2 0   A N A L Y S T             6 0 0 0                                 0                           0           2 0   M A N A G E R             2 9 7 5                                 0                           0           3 0                             9 4 0 0                                 0                           1           3 0   C L E R K                   9 5 0                                 0                           0    Solution Use the GROUPING function to identify which values exist due to CUBE’s or ROLLUP’s creation of subtotals, or superaggregate values. The following is an example for PostgreSQL, DB2, and Oracle:  The only difference between the SQL Server solution and that for DB2 and Oracle lies in how the CUBE ROLLUP clauses are written:  This recipe is meant to highlight the use of CUBE and GROUPING when working with subtotals. As of the time of this writing, MySQL doesn’t support either CUBE or GROUPING.  Discussion If DEPTNO_SUBTOTALS is 0 and JOB_SUBTOTALS is 1  in which case JOB is NULL , the value of SAL represents a subtotal of salaries by DEPTNO created by CUBE. If JOB_SUBTOTALS is 0 and DEPTNO_SUBTOTALS is 1  in which case DEPTNO is NULL , the value of SAL represents a subtotal of salaries by JOB created by CUBE. Rows with 0 for both DEPTNO_SUBTOTALS and JOB_SUBTOTALS represent rows created by regular aggregation  the sum of SAL for each DEPTNO JOB combination .          3 0   M A N A G E R             2 8 5 0                                 0                           0           3 0   S A L E S M A N           5 6 0 0                                 0                           0   1   s e l e c t   d e p t n o ,   j o     s a l ,     2                 g r o u p i n g   d e p t n o     d e p t n o _ s u b t o t a l s ,     3                 g r o u p i n g   j o b     j o b _ s u b t o t a l s     4       f r o m   e m p     5     g r o u p   b y   c u b e   d e p t n o , j o b     1   s e l e c t   d e p t n o ,   j o b ,   s u m   s a l     s a l ,     2                 g r o u p i n g   d e p t n o     d e p t n o _ s u b t o t a l s ,     3                 g r o u p i n g   j o b     j o b _ s u b t o t a l s     4       f r o m   e m p     5     g r o u p   b y   d e p t n o , j o b   w i t h   c u b e  12.15 Using Case Expressions to Flag Rows  Problem You want to map the values in a column, perhaps the EMP table’s JOB column, into a series of “Boolean” flags. For example, you want to return the following result set:  Such a result set can be useful for debugging and to provide yourself a view of the data different from what you’d see in a more typical result set.  Solution Use a CASE expression to evaluate each employee’s JOB, and return a 1 or 0 to signify their JOB. You’ll need to write one CASE expression, and thus create one column for each possible job:  E N A M E     I S _ C L E R K   I S _ S A L E S   I S _ M G R   I S _ A N A L Y S T   I S _ P R E Z   - - - - - -   - - - - - - - -   - - - - - - - -   - - - - - -   - - - - - - - - - -   - - - - - - -   K I N G                     0                 0             0                     0               1   S C O T T                   0                 0             0                     1               0   F O R D                     0                 0             0                     1               0   J O N E S                   0                 0             1                     0               0   B L A K E                   0                 0             1                     0               0   C L A R K                   0                 0             1                     0               0   A L L E N                   0                 1             0                     0               0   W A R D                     0                 1             0                     0               0   M A R T I N                 0                 1             0                     0               0   T U R N E R                 0                 1             0                     0               0   S M I T H                   1                 0             0                     0               0   M I L L E R                 1                 0             0                     0               0   A D A M S                   1                 0             0                     0               0   J A M E S                   1                 0             0                     0               0   1   s e l e c t   e n a m e ,     2                 c a s e   w h e n   j o b   =   ' C L E R K '     3                           t h e n   1   e l s e   0     4                 e n d   a s   i s _ c l e r k ,     5                 c a s e   w h e n   j o b   =   ' S A L E S M A N '     6                           t h e n   1   e l s e   0     7                 e n d   a s   i s _ s a l e s ,    Discussion The solution code is pretty much self-explanatory. If you are having trouble understanding it, simply add JOB to the SELECT clause:    8                 c a s e   w h e n   j o b   =   ' M A N A G E R '     9                           t h e n   1   e l s e   0   1 0                 e n d   a s   i s _ m g r ,   1 1                 c a s e   w h e n   j o b   =   ' A N A L Y S T '   1 2                           t h e n   1   e l s e   0   1 3                 e n d   a s   i s _ a n a l y s t ,   1 4                 c a s e   w h e n   j o b   =   ' P R E S I D E N T '   1 5                           t h e n   1   e l s e   0   1 6                 e n d   a s   i s _ p r e z   1 7       f r o m   e m p   1 8     o r d e r   b y   2 , 3 , 4 , 5 , 6 s e l e c t   e n a m e ,                 j o b ,                 c a s e   w h e n   j o b   =   ' C L E R K '                           t h e n   1   e l s e   0                 e n d   a s   i s _ c l e r k ,                 c a s e   w h e n   j o b   =   ' S A L E S M A N '                           t h e n   1   e l s e   0                 e n d   a s   i s _ s a l e s ,                 c a s e   w h e n   j o b   =   ' M A N A G E R '                           t h e n   1   e l s e   0                 e n d   a s   i s _ m g r ,                 c a s e   w h e n   j o b   =   ' A N A L Y S T '                         t h e n   1   e l s e   0                 e n d   a s   i s _ a n a l y s t ,                 c a s e   w h e n   j o b   =   ' P R E S I D E N T '                         t h e n   1   e l s e   0                 e n d   a s   i s _ p r e z       f r o m   e m p     o r d e r   b y   2     E N A M E     J O B               I S _ C L E R K   I S _ S A L E S   I S _ M G R   I S _ A N A L Y S T   I S _ P R E Z   - - - - - -   - - - - - - - - -   - - - - - - - -   - - - - - - - -   - - - - - -   - - - - - - - - - -   - - - - - - -   S C O T T     A N A L Y S T                     0                 0             0                     1               0   F O R D       A N A L Y S T                     0                 0             0                     1               0   S M I T H     C L E R K                         1                 0             0                     0               0   A D A M S     C L E R K                         1                 0             0                     0               0   M I L L E R   C L E R K                         1                 0             0                     0               0   J A M E S     C L E R K                         1                 0             0                     0               0   J O N E S     M A N A G E R                     0                 0             1                     0               0    12.16 Creating a Sparse Matrix  Problem You want to create a sparse matrix, such as the following one transposing the DEPTNO and JOB columns of table EMP:  Solution Use CASE expressions to create a sparse row-to-column transformation:  C L A R K     M A N A G E R                     0                 0             1                     0               0   B L A K E     M A N A G E R                     0                 0             1                     0               0   K I N G       P R E S I D E N T                 0                 0             0                     0               1   A L L E N     S A L E S M A N                   0                 1             0                     0               0   M A R T I N   S A L E S M A N                   0                 1             0                     0               0   T U R N E R   S A L E S M A N                   0                 1             0                     0               0   W A R D       S A L E S M A N                   0                 1             0                     0               0 D 1 0                 D 2 0                 D 3 0                 C L E R K S   M G R S     P R E Z   A N A L S   S A L E S   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - -   - - - - -   - - - -   - - - - -   - - - - - -                         S M I T H                                   S M I T H                                               A L L E N                                                             A L L E N                                               W A R D                                                               W A R D                         J O N E S                                                 J O N E S                                               M A R T I N                                                           M A R T I N                                               B L A K E                           B L A K E   C L A R K                                                                       C L A R K                         S C O T T                                                                       S C O T T   K I N G                                                                                     K I N G                                               T U R N E R                                                           T U R N E R                         A D A M S                                   A D A M S                                               J A M E S             J A M E S                         F O R D                                                                         F O R D   M I L L E R                                                       M I L L E R   1   s e l e c t   c a s e   d e p t n o   w h e n   1 0   t h e n   e n a m e   e n d   a s   d 1 0 ,     2                 c a s e   d e p t n o   w h e n   2 0   t h e n   e n a m e   e n d   a s   d 2 0 ,     3                 c a s e   d e p t n o   w h e n   3 0   t h e n   e n a m e   e n d   a s   d 3 0 ,     4                 c a s e   j o b   w h e n   ' C L E R K '   t h e n   e n a m e   e n d   a s   c l e r k s ,     5                 c a s e   j o b   w h e n   ' M A N A G E R '   t h e n   e n a m e   e n d   a s   m g r s ,     6                 c a s e   j o b   w h e n   ' P R E S I D E N T '   t h e n   e n a m e   e n d   a s   p r e z ,    Discussion To transform the DEPTNO and JOB rows to columns, simply use a CASE expression to evaluate the possible values returned by those rows. That’s all there is to it. As an aside, if you want to “densify” the report and get rid of some of those NULL rows, you would need to find something to group by. For example, use the window function ROW_NUMBER OVER to assign a ranking for each employee per DEPTNO, and then use the aggregate function MAX to rub out some of the NULLs:  12.17 Grouping Rows by Units of Time  Problem    7                 c a s e   j o b   w h e n   ' A N A L Y S T '   t h e n   e n a m e   e n d   a s   a n a l s ,     8                 c a s e   j o b   w h e n   ' S A L E S M A N '   t h e n   e n a m e   e n d   a s   s a l e s     9       f r o m   e m p s e l e c t   m a x   c a s e   d e p t n o   w h e n   1 0   t h e n   e n a m e   e n d     d 1 0 ,                 m a x   c a s e   d e p t n o   w h e n   2 0   t h e n   e n a m e   e n d     d 2 0 ,                 m a x   c a s e   d e p t n o   w h e n   3 0   t h e n   e n a m e   e n d     d 3 0 ,                 m a x   c a s e   j o b   w h e n   ' C L E R K '   t h e n   e n a m e   e n d     c l e r k s ,                 m a x   c a s e   j o b   w h e n   ' M A N A G E R '   t h e n   e n a m e   e n d     m g r s ,                 m a x   c a s e   j o b   w h e n   ' P R E S I D E N T '   t h e n   e n a m e   e n d     p r e z ,                   m a x   c a s e   j o b   w h e n   ' A N A L Y S T '   t h e n   e n a m e   e n d     a n a l s ,                   m a x   c a s e   j o b   w h e n   ' S A L E S M A N '   t h e n   e n a m e   e n d     s a l e s       f r o m         s e l e c t   d e p t n o ,   j o b ,   e n a m e ,                 r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   d e p t n o   o r d e r   b y   e m p n o     r n         f r o m   e m p                       x       g r o u p   b y   r n     D 1 0                 D 2 0                 D 3 0                 C L E R K S   M G R S     P R E Z   A N A L S   S A L E S   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - -   - - - - -   - - - -   - - - - -   - - - - - -   C L A R K             S M I T H             A L L E N             S M I T H     C L A R K                         A L L E N   K I N G               J O N E S             W A R D                             J O N E S   K I N G               W A R D   M I L L E R           S C O T T             M A R T I N           M I L L E R               S C O T T             M A R T I N                         A D A M S             B L A K E             A D A M S     B L A K E                         F O R D               T U R N E R                                     F O R D               T U R N E R                                               J A M E S             J A M E S  You want to summarize data by some interval of time. For example, you have a transaction log and want to summarize transactions by five-second intervals. The rows in table TRX_LOG are shown here:  You want to return the following result set:  Solution  s e l e c t   t r x _ i d ,                 t r x _ d a t e ,                 t r x _ c n t       f r o m   t r x _ l o g   T R X _ I D   T R X _ D A T E                                 T R X _ C N T   - - - - - -   - - - - - - - - - - - - - - - - - - - -   - - - - - - - - - -             1   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 0 7                   4 4             2   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 0 8                   1 8             3   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 0 9                   2 3             4   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 0                   2 9             5   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 1                   2 7             6   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 2                   4 5             7   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 3                   4 5             8   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 4                   3 2             9   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 5                   4 1           1 0   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 6                   1 5           1 1   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 7                   2 4           1 2   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 8                   4 7           1 3   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 9                   3 7           1 4   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 0                   4 8           1 5   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 1                   4 6           1 6   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 2                   4 4           1 7   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 3                   3 6           1 8   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 4                   4 1           1 9   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 5                   3 3           2 0   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 6                   1 9 G R P   T R X _ S T A R T                         T R X _ E N D                                       T O T A L   - - -   - - - - - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - - - - - - -   - - - - - - - - - -       1   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 0 7   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 1                 1 4 1       2   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 2   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 6                 1 7 8       3   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 7   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 1                 2 0 2       4   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 2   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 6                 1 7 3  Group the entries into five row buckets. There are several ways to accomplish that logical grouping; this recipe does so by dividing the TRX_ID values by five, using a technique shown earlier in Recipe 12.7. Once you’ve created the “groups,” use the aggregate functions MIN, MAX, and SUM to find the start time, end time, and total number of transactions for each “group”  SQL Server users should use CEILING instead of CEIL :  Discussion The first step, and the key to the whole solution, is to logically group the rows together. By dividing by five and taking the smallest whole number greater than the quotient, you can create logical groups. For example:    1   s e l e c t   c e i l   t r x _ i d   5 . 0     a s   g r p ,     2                 m i n   t r x _ d a t e           a s   t r x _ s t a r t ,     3                 m a x   t r x _ d a t e           a s   t r x _ e n d ,     4                 s u m   t r x _ c n t             a s   t o t a l     5       f r o m   t r x _ l o g     6   g r o u p   b y   c e i l   t r x _ i d   5 . 0   s e l e c t   t r x _ i d ,                 t r x _ d a t e ,                 t r x _ c n t ,                 t r x _ i d   5 . 0   a s   v a l ,                 c e i l   t r x _ i d   5 . 0     a s   g r p       f r o m   t r x _ l o g   T R X _ I D   T R X _ D A T E                           T R X _ C N T           V A L   G R P   - - - - - -   - - - - - - - - - - - - - - - - - - - -   - - - - - - -     - - - - - -   - - -             1   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 0 7             4 4           . 2 0       1             2   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 0 8             1 8           . 4 0       1             3   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 0 9             2 3           . 6 0       1             4   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 0             2 9           . 8 0       1             5   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 1             2 7         1 . 0 0       1             6   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 2             4 5         1 . 2 0       2             7   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 3             4 5         1 . 4 0       2             8   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 4             3 2         1 . 6 0       2             9   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 5             4 1         1 . 8 0       2           1 0   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 6             1 5         2 . 0 0       2           1 1   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 7             2 4         2 . 2 0       3           1 2   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 8             4 7         2 . 4 0       3           1 3   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 9             3 7         2 . 6 0       3           1 4   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 0             4 8         2 . 8 0       3    The last step is to apply the appropriate aggregate functions to find the total number of transactions per five seconds, along with the start and end times for each transaction:  If your data is slightly different  perhaps you don’t have an ID for each row , you can always “group” by dividing the seconds of each TRX_DATE row by five to create a similar grouping. Then you can include the hour for each TRX_DATE and group by the actual hour and logical “grouping,” GRP. The following is an example of this technique  using Oracle’s TO_CHAR and TO_NUMBER functions, you would use the appropriate date and character formatting functions for your platform :          1 5   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 1             4 6         3 . 0 0       3           1 6   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 2             4 4         3 . 2 0       4           1 7   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 3             3 6         3 . 4 0       4           1 8   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 4             4 1         3 . 6 0       4           1 9   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 5             3 3         3 . 8 0       4           2 0   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 6             1 9         4 . 0 0       4 s e l e c t   c e i l   t r x _ i d   5 . 0     a s   g r p ,                 m i n   t r x _ d a t e     a s   t r x _ s t a r t ,                 m a x   t r x _ d a t e     a s   t r x _ e n d ,                 s u m   t r x _ c n t     a s   t o t a l       f r o m   t r x _ l o g     g r o u p   b y   c e i l   t r x _ i d   5 . 0     G R P   T R X _ S T A R T                         T R X _ E N D                                       T O T A L   - - -   - - - - - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - - - - - - -   - - - - - - - - - -       1   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 0 7   2 8 - J U L - 2 0 0 5   1 9 : 0 3 : 1 1                 1 4 1       2   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 2   2 8 - J U L - 2 0 0 5   1 9 : 0 3 : 1 6                 1 7 8       3   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 7   2 8 - J U L - 2 0 0 5   1 9 : 0 3 : 2 1                 2 0 2       4   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 2   2 8 - J U L - 2 0 0 5   1 9 : 0 3 : 2 6                 1 7 3 s e l e c t   t r x _ d a t e , t r x _ c n t ,                 t o _ n u m b e r   t o _ c h a r   t r x _ d a t e , ' h h 2 4 '       h r ,                 c e i l   t o _ n u m b e r   t o _ c h a r   t r x _ d a t e - 1   2 4   6 0   6 0 , ' m i s s '       5 . 0     g r p       f r o m   t r x _ l o g     T R X _ D A T E                           2 0       T R X _ C N T                   H R                   G R P   - - - - - - - - - - - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -     - - - - - - - - - -   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 0 7                   4 4                   1 9                     6 2   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 0 8                   1 8                   1 9                     6 2   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 0 9                   2 3                   1 9                     6 2    Regardless of the actual values for GRP, the key here is that you are grouping for every five seconds. From there you can apply the aggregate functions in the same way as in the original solution:  Including the hour in the grouping is useful if your transaction log spans hours. In DB2 and Oracle, you can also use the window function SUM OVER to produce the same result. The following query returns all rows from TRX_LOG along with a running total for TRX_CNT by logical “group,” and the TOTAL for TRX_CNT for each row in the “group”:  2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 0                   2 9                   1 9                     6 2   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 1                   2 7                   1 9                     6 2   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 2                   4 5                   1 9                     6 3   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 3                   4 5                   1 9                     6 3   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 4                   3 2                   1 9                     6 3   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 5                   4 1                   1 9                     6 3   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 6                   1 5                   1 9                     6 3   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 7                   2 4                   1 9                     6 4   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 8                   4 7                   1 9                     6 4   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 9                   3 7                   1 9                     6 4   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 0                   4 8                   1 9                     6 4   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 1                   4 6                   1 9                     6 4   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 2                   4 4                   1 9                     6 5   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 3                   3 6                   1 9                     6 5   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 4                   4 1                   1 9                     6 5   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 5                   3 3                   1 9                     6 5   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 6                   1 9                   1 9                     6 5 s e l e c t   h r , g r p , s u m   t r x _ c n t     t o t a l       f r o m       s e l e c t   t r x _ d a t e , t r x _ c n t ,                 t o _ n u m b e r   t o _ c h a r   t r x _ d a t e , ' h h 2 4 '       h r ,                 c e i l   t o _ n u m b e r   t o _ c h a r   t r x _ d a t e - 1   2 4   6 0   6 0 , ' m i s s '       5 . 0     g r p       f r o m   t r x _ l o g                     x     g r o u p   b y   h r , g r p   H R                 G R P               T O T A L   - -   - - - - - - - - - -     - - - - - - - - - -   1 9                   6 2                   1 4 1   1 9                   6 3                   1 7 8   1 9                   6 4                   2 0 2   1 9                   6 5                   1 7 3  12.18 Performing Aggregations over Different Groups Partitions Simultaneously  Problem You want to aggregate over different dimensions at the same time. For example, you want to return a result set that lists each employee’s name, their department, the number of employees in their department  themselves included , the number of employees that have the same job  themselves  s e l e c t   t r x _ i d ,   t r x _ d a t e ,   t r x _ c n t ,                 s u m   t r x _ c n t   o v e r   p a r t i t i o n   b y   c e i l   t r x _ i d   5 . 0                                                     o r d e r   b y   t r x _ d a t e                                                   r a n g e   b e t w e e n   u n b o u n d e d   p r e c e d i n g                                                       a n d   c u r r e n t   r o w     r u n i n g _ t o t a l ,                 s u m   t r x _ c n t   o v e r   p a r t i t i o n   b y   c e i l   t r x _ i d   5 . 0       t o t a l ,                 c a s e   w h e n   m o d   t r x _ i d , 5 . 0     =   0   t h e n   ' X '   e n d   g r p _ e n d       f r o m   t r x _ l o g     T R X _ I D   T R X _ D A T E                                 T R X _ C N T   R U N I N G _ T O T A L             T O T A L   G R P _ E N D   - - - - - -   - - - - - - - - - - - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - - - -   - - - - - - - - - -   - - - - - - -             1   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 0 7                   4 4                       4 4               1 4 1             2   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 0 8                   1 8                       6 2               1 4 1             3   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 0 9                   2 3                       8 5               1 4 1             4   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 0                   2 9                     1 1 4               1 4 1             5   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 1                   2 7                     1 4 1               1 4 1     X             6   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 2                   4 5                       4 5               1 7 8             7   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 3                   4 5                       9 0               1 7 8             8   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 4                   3 2                     1 2 2               1 7 8             9   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 5                   4 1                     1 6 3               1 7 8           1 0   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 6                   1 5                     1 7 8               1 7 8     X           1 1   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 7                   2 4                       2 4               2 0 2           1 2   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 8                   4 7                       7 1               2 0 2           1 3   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 1 9                   3 7                     1 0 8               2 0 2           1 4   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 0                   4 8                     1 5 6               2 0 2           1 5   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 1                   4 6                     2 0 2               2 0 2     X           1 6   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 2                   4 4                       4 4               1 7 3           1 7   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 3                   3 6                       8 0               1 7 3           1 8   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 4                   4 1                     1 2 1               1 7 3           1 9   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 5                   3 3                     1 5 4               1 7 3           2 0   2 8 - J U L - 2 0 2 0   1 9 : 0 3 : 2 6                   1 9                     1 7 3               1 7 3     X  included in this count as well , and the total number of employees in the EMP table. The result set should look like the following:  Solution Use the COUNT OVER window function while specifying different partitions, or groups of data, on which to perform aggregation:  Discussion This example really shows off the power and convenience of window functions. By simply specifying different partitions or groups of data to aggregate, you can create immensely detailed reports without having to self-join over and over, and without having to write cumbersome and perhaps poorly performing subqueries in your SELECT list. All the work is  E N A M E     D E P T N O   D E P T N O _ C N T   J O B               J O B _ C N T       T O T A L   - - - - - -   - - - - - -   - - - - - - - - - -   - - - - - - - - -   - - - - - - - -   - - - - - -   M I L L E R           1 0                     3   C L E R K                         4           1 4   C L A R K             1 0                     3   M A N A G E R                     3           1 4   K I N G               1 0                     3   P R E S I D E N T                 1           1 4   S C O T T             2 0                     5   A N A L Y S T                     2           1 4   F O R D               2 0                     5   A N A L Y S T                     2           1 4   S M I T H             2 0                     5   C L E R K                         4           1 4   J O N E S             2 0                     5   M A N A G E R                     3           1 4   A D A M S             2 0                     5   C L E R K                         4           1 4   J A M E S             3 0                     6   C L E R K                         4           1 4   M A R T I N           3 0                     6   S A L E S M A N                   4           1 4   T U R N E R           3 0                     6   S A L E S M A N                   4           1 4   W A R D               3 0                     6   S A L E S M A N                   4           1 4   A L L E N             3 0                     6   S A L E S M A N                   4           1 4   B L A K E             3 0                     6   M A N A G E R                     3           1 4 s e l e c t   e n a m e ,                 d e p t n o ,                 c o u n t   *   o v e r   p a r t i t i o n   b y   d e p t n o     d e p t n o _ c n t ,                 j o b ,                 c o u n t   *   o v e r   p a r t i t i o n   b y   j o b     j o b _ c n t ,                 c o u n t   *   o v e r       t o t a l       f r o m   e m p  done by the window function COUNT OVER. To understand the output, focus on the OVER clause for a moment for each COUNT operation:  Remember the main parts of the OVER clause: the PARTITION BY subclause, dividing the query into partitions; and the ORDER BY subclause, defining the logical order. Look at the first COUNT, which partitions by DEPTNO. The rows in table EMP will be grouped by DEPTNO, and the COUNT operation will be performed on all the rows in each group. Since there is no frame or window clause specified  no ORDER BY , all the rows in the group are counted. The PARTITION BY clause finds all the unique DEPTNO values, and then the COUNT function counts the number of rows having each value. In the specific example of COUNT * OVER PARTITION BY DEPTNO , the PARTITION BY clause identifies the partitions or groups to be values 10, 20, and 30. The same processing is applied to the second COUNT, which partitions by JOB. The last count does not partition by anything and simply has an empty parentheses. An empty parentheses implies “the whole table.” So, whereas the two prior COUNTs aggregate values based on the defined groups or partitions, the final COUNT counts all rows in table EMP.  WARNING  Keep in mind that window functions are applied after the WHERE clause. If you were to filter the result set in some way, for example, excluding all employees in DEPTNO 10, the value for TOTAL would not be 14—it would be 11. To filter results after window functions have been evaluated, you must make your windowing query into an inline view and then filter on the results from that view.  c o u n t   *   o v e r   p a r t i t i o n   b y   d e p t n o       c o u n t   *   o v e r   p a r t i t i o n   b y   j o b       c o u n t   *   o v e r      12.19 Performing Aggregations over a Moving Range of Values  Problem You want to compute a moving aggregation, such as a moving sum on the salaries in table EMP. You want to compute a sum for every 90 days, starting with the HIREDATE of the first employee. You want to see how spending has fluctuated for every 90-day period between the first and last employee hired. You want to return the following result set:  Solution Being able to specify a moving window in the framing or windowing clause of window functions makes this problem easy to solve, if your RDBMS supports such functions. The key is to order by HIREDATE in your window function and then specify a window of 90 days starting from the earliest employee hired. The sum will be computed using the salaries of employees hired up to 90 days prior to the current employee’s HIREDATE  the current employee is included in the sum . If you do not have window functions available, you can use scalar subqueries, but the solution will be more complex.  H I R E D A T E                 S A L   S P E N D I N G _ P A T T E R N   - - - - - - - - - - -   - - - - - - -   - - - - - - - - - - - - - - - -   1 7 - D E C - 2 0 0           8 0 0                             8 0 0   2 0 - F E B - 2 0 1 1         1 6 0 0                           2 4 0 0   2 2 - F E B - 2 0 1 1         1 2 5 0                           3 6 5 0   0 2 - A P R - 2 0 1 1         2 9 7 5                           5 8 2 5   0 1 - M A Y - 2 0 1 1         2 8 5 0                           8 6 7 5   0 9 - J U N - 2 0 1 1         2 4 5 0                           8 2 7 5   0 8 - S E P - 2 0 1 1         1 5 0 0                           1 5 0 0   2 8 - S E P - 2 0 1 1         1 2 5 0                           2 7 5 0   1 7 - N O V - 2 0 1 1         5 0 0 0                           7 7 5 0   0 3 - D E C - 2 0 1 1           9 5 0                         1 1 7 0 0   0 3 - D E C - 2 0 1 1         3 0 0 0                         1 1 7 0 0   2 3 - J A N - 2 0 1 2         1 3 0 0                         1 0 2 5 0   0 9 - D E C - 2 0 1 2         3 0 0 0                           3 0 0 0   1 2 - J A N - 2 0 1 3         1 1 0 0                           4 1 0 0  DB2 and Oracle For DB2 and Oracle, use the window function SUM OVER and order by HIREDATE. Specify a range of 90 days in the window or “framing” clause to allow the sum to be computed for each employee’s salary and to include the salaries of all employees hired up to 90 days earlier. Because DB2 does not allow you to specify HIREDATE in the ORDER BY clause of a window function  line 3 in the following code , you can order by DAYS HIREDATE  instead:  The Oracle solution is more straightforward than DB2’s, because Oracle allows window functions to order by datetime types:  MySQL Use the window function with slightly altered syntax:  PostgreSQL and SQL Server Use a scalar subquery to sum the salaries of all employees hired up to 90 days prior to the day each employee was hired:        1   s e l e c t   h i r e d a t e ,         2                 s a l ,         3                 s u m   s a l   o v e r   o r d e r   b y   d a y s   h i r e d a t e           4                                                 r a n g e   b e t w e e n   9 0   p r e c e d i n g         5                                                     a n d   c u r r e n t   r o w     s p e n d i n g _ p a t t e r n         6       f r o m   e m p   e       1   s e l e c t   h i r e d a t e ,         2                 s a l ,         3                 s u m   s a l   o v e r   o r d e r   b y   h i r e d a t e         4                                                 r a n g e   b e t w e e n   9 0   p r e c e d i n g         5                                                     a n d   c u r r e n t   r o w     s p e n d i n g _ p a t t e r n         6       f r o m   e m p   e 1     s e l e c t   h i r e d a t e ,   2                     s a l ,   3                     s u m   s a l   o v e r   o r d e r   b y   h i r e d a t e   4                             r a n g e   i n t e r v a l   9 0   d a y   p r e c e d i n g       s p e n d i n g _ p a t t e r n   5     f r o m   e m p   e  Discussion  DB2, MySQL, and Oracle DB2, MySQL, and Oracle share the same logical solution. The only minor differences between the solutions are in how you specify HIREDATE in the ORDER BY clause of the window function and the syntax of specifying the time interval in MySQL. At the time of this book’s writing, DB2 doesn’t allow a DATE value in such an ORDER BY clause if you are using a numeric value to set the window’s range.  For example, RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW allows you to order by a date, but RANGE BETWEEN 90 PRECEDING AND CURRENT ROW does not.  To understand what the solution query is doing, you simply need to understand what the window clause is doing. The window you are defining orders the salaries for all employees by HIREDATE. Then the function computes a sum. The sum is not computed for all salaries. Instead, the processing is as follows:  1. The salary of the first employee hired is evaluated. Since no  employees were hired before the first employee, the sum at this point is simply the first employee’s salary.  2. The salary of the next employee  by HIREDATE  is evaluated. This  employee’s salary is included in the moving sum along with any other employees who were hired up to 90 days prior.  The HIREDATE of the first employee is December 17, 2010, and the HIREDATE of the next hired employee is February 20, 2011. The second employee was hired less than 90 days after the first employee, and thus the    1   s e l e c t   e . h i r e d a t e ,     2                 e . s a l ,     3                   s e l e c t   s u m   s a l     f r o m   e m p   d     4                     w h e r e d . h i r e d a t e   b e t w e e n   e . h i r e d a t e - 9 0     5                                                             a n d   e . h i r e d a t e     a s   s p e n d i n g _ p a t t e r n     6       f r o m   e m p   e     7     o r d e r   b y   1  moving sum for the second employee is 2400  1600 + 800 . If you are having trouble understanding where the values in SPENDING_PATTERN come from, examine the following query and result set:  s e l e c t   d i s t i n c t                 d e n s e _ r a n k     o v e r   o r d e r   b y   e . h i r e d a t e     w i n d o w ,                 e . h i r e d a t e   c u r r e n t _ h i r e d a t e ,                 d . h i r e d a t e   h i r e d a t e _ w i t h i n _ 9 0 _ d a y s ,                 d . s a l   s a l s _ u s e d _ f o r _ s u m       f r o m   e m p   e ,                 e m p   d   w h e r e   d . h i r e d a t e   b e t w e e n   e . h i r e d a t e - 9 0   a n d   e . h i r e d a t e     W I N D O W   C U R R E N T _ H I R E D A T E   H I R E D A T E _ W I T H I N _ 9 0 _ D A Y S   S A L S _ U S E D _ F O R _ S U M   - - - - - -   - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - - - -             1   1 7 - D E C - 2 0 1 0             1 7 - D E C - 2 0 1 0                                                       8 0 0             2   2 0 - F E B - 2 0 1 1             1 7 - D E C - 2 0 1 0                                                       8 0 0             2   2 0 - F E B - 2 0 1 1             2 0 - F E B - 2 0 1 1                                                     1 6 0 0             3   2 2 - F E B - 2 0 1 1             1 7 - D E C - 2 0 1 0                                                       8 0 0             3   2 2 - F E B - 2 0 1 1             2 0 - F E B - 2 0 1 1                                                     1 6 0 0             3   2 2 - F E B - 2 0 1 1             2 2 - F E B - 2 0 1 1                                                     1 2 5 0             4   0 2 - A P R - 2 0 1 1             2 0 - F E B - 2 0 1 1                                                     1 6 0 0             4   0 2 - A P R - 2 0 1 1             2 2 - F E B - 2 0 1 1                                                     1 2 5 0             4   0 2 - A P R - 2 0 1 1             0 2 - A P R - 2 0 1 1                                                     2 9 7 5             5   0 1 - M A Y - 2 0 1 1             2 0 - F E B - 2 0 1 1                                                     1 6 0 0             5   0 1 - M A Y - 2 0 1 1             2 2 - F E B - 2 0 1 1                                                     1 2 5 0             5   0 1 - M A Y - 2 0 1 1             0 2 - A P R - 2 0 1 1                                                     2 9 7 5             5   0 1 - M A Y - 2 0 1 1             0 1 - M A Y - 2 0 1 1                                                     2 8 5 0             6   0 9 - J U N - 2 0 1 1             0 2 - A P R - 2 0 1 1                                                     2 9 7 5             6   0 9 - J U N - 2 0 1 1             0 1 - M A Y - 2 0 1 1                                                     2 8 5 0             6   0 9 - J U N - 2 0 1 1             0 9 - J U N - 2 0 1 1                                                     2 4 5 0             7   0 8 - S E P - 2 0 1 1             0 8 - S E P - 2 0 1 1                                                     1 5 0 0             8   2 8 - S E P - 2 0 1 1             0 8 - S E P - 2 0 1 1                                                     1 5 0 0             8   2 8 - S E P - 2 0 1 1             2 8 - S E P - 2 0 1 1                                                     1 2 5 0             9   1 7 - N O V - 2 0 1 1             0 8 - S E P - 2 0 1 1                                                     1 5 0 0             9   1 7 - N O V - 2 0 1 1             2 8 - S E P - 2 0 1 1                                                     1 2 5 0             9   1 7 - N O V - 2 0 1 1             1 7 - N O V - 2 0 1 1                                                     5 0 0 0           1 0   0 3 - D E C - 2 0 1 1             0 8 - S E P - 2 0 1 1                                                     1 5 0 0           1 0   0 3 - D E C - 2 0 1 1             2 8 - S E P - 2 0 1 1                                                     1 2 5 0           1 0   0 3 - D E C - 2 0 1 1             1 7 - N O V - 2 0 1 1                                                     5 0 0 0           1 0   0 3 - D E C - 2 0 1 1             0 3 - D E C - 2 0 1 1                                                       9 5 0           1 0   0 3 - D E C - 2 0 1 1             0 3 - D E C - 2 0 1 1                                                     3 0 0 0           1 1   2 3 - J A N - 2 0 1 2             1 7 - N O V - 2 0 1 1                                                     5 0 0 0           1 1   2 3 - J A N - 2 0 1 2             0 3 - D E C - 2 0 1 1                                                       9 5 0           1 1   2 3 - J A N - 2 0 1 2             0 3 - D E C - 2 0 1 1                                                     3 0 0 0           1 1   2 3 - J A N - 2 0 1 2             2 3 - J A N - 2 0 1 2                                                     1 3 0 0    If you look at the WINDOW column, only those rows with the same WINDOW value will be considered for each sum. Take, for example, WINDOW 3. The salaries used for the sum for that window are 800, 1600, and 1250, which total 3650. If you look at the final result set in the “Problem” section, you’ll see the SPENDING_PATTERN for February 22, 2011  WINDOW 3  is 3650. As proof, to verify that the previous self-join includes the correct salaries for the windows defined, simply sum the values in SALS_USED_FOR_SUM and group by CURRENT_DATE. The result should be the same as the result set shown in the “Problem” section  with the duplicate row for December 3, 2011, filtered out :          1 2   0 9 - D E C - 2 0 1 2             0 9 - D E C - 2 0 1 2                                                     3 0 0 0           1 3   1 2 - J A N - 2 0 1 3             0 9 - D E C - 2 0 1 2                                                     3 0 0 0           1 3   1 2 - J A N - 2 0 1 3             1 2 - J A N - 2 0 1 3                                                     1 1 0 0 s e l e c t   c u r r e n t _ h i r e d a t e ,                 s u m   s a l s _ u s e d _ f o r _ s u m     s p e n d i n g _ p a t t e r n       f r o m       s e l e c t   d i s t i n c t                 d e n s e _ r a n k     o v e r   o r d e r   b y   e . h i r e d a t e     w i n d o w ,                 e . h i r e d a t e   c u r r e n t _ h i r e d a t e ,                 d . h i r e d a t e   h i r e d a t e _ w i t h i n _ 9 0 _ d a y s ,                 d . s a l   s a l s _ u s e d _ f o r _ s u m       f r o m   e m p   e ,                 e m p   d       w h e r e   d . h i r e d a t e   b e t w e e n   e . h i r e d a t e - 9 0   a n d   e . h i r e d a t e                       x       g r o u p   b y   c u r r e n t _ h i r e d a t e     C U R R E N T _ H I R E D A T E   S P E N D I N G _ P A T T E R N   - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - - -   1 7 - D E C - 2 0 1 0                                       8 0 0   2 0 - F E B - 2 0 1 1                                     2 4 0 0   2 2 - F E B - 2 0 1 1                                     3 6 5 0   0 2 - A P R - 2 0 1 1                                     5 8 2 5   0 1 - M A Y - 2 0 1 1                                     8 6 7 5   0 9 - J U N - 2 0 1 1                                     8 2 7 5   0 8 - S E P - 2 0 1 1                                     1 5 0 0   2 8 - S E P - 2 0 1 1                                     2 7 5 0   1 7 - N O V - 2 0 1 1                                     7 7 5 0   0 3 - D E C - 2 0 1 1                                   1 1 7 0 0   2 3 - J A N - 2 0 1 2                                   1 0 2 5 0    PostgreSQL and SQL Server The key to this solution is to use a scalar subquery  a self-join will work as well  while using the aggregate function SUM to compute a sum for every 90 days based on HIREDATE. If you are having trouble seeing how this works, simply convert the solution to a self-join and examine which rows are included in the computations. Consider the following result set, which returns the same result set as that in the solution:  If it is still unclear, simply remove the aggregation and start with the Cartesian product. The first step is to generate a Cartesian product using table EMP so that each HIREDATE can be compared with all the other  0 9 - D E C - 2 0 1 2                                     3 0 0 0   1 2 - J A N - 2 0 1 3                                     4 1 0 0 s e l e c t   e . h i r e d a t e ,                 e . s a l ,                 s u m   d . s a l     a s   s p e n d i n g _ p a t t e r n       f r o m   e m p   e ,   e m p   d     w h e r e   d . h i r e d a t e                 b e t w e e n   e . h i r e d a t e - 9 0   a n d   e . h i r e d a t e     g r o u p   b y   e . h i r e d a t e , e . s a l     o r d e r   b y   1 \     H I R E D A T E             S A L       S P E N D I N G _ P A T T E R N   - - - - - - - - - - -   - - - - -       - - - - - - - - - - - - - - - -   1 7 - D E C - 2 0 1 0       8 0 0                                 8 0 0   2 0 - F E B - 2 0 1 1     1 6 0 0                               2 4 0 0   2 2 - F E B - 2 0 1 1     1 2 5 0                               3 6 5 0   0 2 - A P R - 2 0 1 1     2 9 7 5                               5 8 2 5   0 1 - M A Y - 2 0 1 1     2 8 5 0                               8 6 7 5   0 9 - J U N - 2 0 1 1     2 4 5 0                               8 2 7 5   0 8 - S E P - 2 0 1 1     1 5 0 0                               1 5 0 0   2 8 - S E P - 2 0 1 1     1 2 5 0                               2 7 5 0   1 7 - N O V - 2 0 1 1     5 0 0 0                               7 7 5 0   0 3 - D E C - 2 0 1 1       9 5 0                             1 1 7 0 0   0 3 - D E C - 2 0 1 1     3 0 0 0                             1 1 7 0 0   2 3 - J A N - 2 0 1 2     1 3 0 0                             1 0 2 5 0   0 9 - D E C - 2 0 1 2     3 0 0 0                               3 0 0 0   1 2 - J A N - 2 0 1 3     1 1 0 0                               4 1 0 0  HIREDATEs.  Only a snippet of the result set is shown here because there are 196 rows  14 × 14  returned by a Cartesian of EMP :  If you examine the previous result set, you’ll notice that there is no HIREDATE 90 days earlier or equal to December 17, except for December 17. So, the sum for that row should be only 800. If you examine the next HIREDATE, February 20, you’ll notice that there is one HIREDATE that  s e l e c t   e . h i r e d a t e ,                 e . s a l ,                 d . s a l ,                 d . h i r e d a t e       f r o m   e m p   e ,   e m p   d     H I R E D A T E             S A L             S A L   H I R E D A T E   - - - - - - - - - - -   - - - - -         - - - - -   - - - - - - - - - - -   1 7 - D E C - 2 0 1 0       8 0 0             8 0 0   1 7 - D E C - 2 0 1 0   1 7 - D E C - 2 0 1 0       8 0 0           1 6 0 0   2 0 - F E B - 2 0 1 1   1 7 - D E C - 2 0 1 0       8 0 0           1 2 5 0   2 2 - F E B - 2 0 1 1   1 7 - D E C - 2 0 1 0       8 0 0           2 9 7 5   0 2 - A P R - 2 0 1 1   1 7 - D E C - 2 0 1 0       8 0 0           1 2 5 0   2 8 - S E P - 2 0 1 1   1 7 - D E C - 2 0 1 0       8 0 0           2 8 5 0   0 1 - M A Y - 2 0 1 1   1 7 - D E C - 2 0 1 0       8 0 0           2 4 5 0   0 9 - J U N - 2 0 1 1   1 7 - D E C - 2 0 1 0       8 0 0           3 0 0 0   0 9 - D E C - 2 0 1 2   1 7 - D E C - 2 0 1 0       8 0 0           5 0 0 0   1 7 - N O V - 2 0 1 1   1 7 - D E C - 2 0 1 0       8 0 0           1 5 0 0   0 8 - S E P - 2 0 1 1   1 7 - D E C - 2 0 1 0       8 0 0           1 1 0 0   1 2 - J A N - 2 0 1 3   1 7 - D E C - 2 0 1 0       8 0 0             9 5 0   0 3 - D E C - 2 0 1 1   1 7 - D E C - 2 0 1 0       8 0 0           3 0 0 0   0 3 - D E C - 2 0 1 1   1 7 - D E C - 2 0 1 0       8 0 0           1 3 0 0   2 3 - J A N - 2 0 1 2   2 0 - F E B - 2 0 1 1     1 6 0 0             8 0 0   1 7 - D E C - 2 0 1 0   2 0 - F E B - 2 0 1 1     1 6 0 0           1 6 0 0   2 0 - F E B - 2 0 1 1   2 0 - F E B - 2 0 1 1     1 6 0 0           1 2 5 0   2 2 - F E B - 2 0 1 1   2 0 - F E B - 2 0 1 1     1 6 0 0           2 9 7 5   0 2 - A P R - 2 0 1 1   2 0 - F E B - 2 0 1 1     1 6 0 0           1 2 5 0   2 8 - S E P - 2 0 1 1   2 0 - F E B - 2 0 1 1     1 6 0 0           2 8 5 0   0 1 - M A Y - 2 0 1 1   2 0 - F E B - 2 0 1 1     1 6 0 0           2 4 5 0   0 9 - J U N - 2 0 1 1   2 0 - F E B - 2 0 1 1     1 6 0 0           3 0 0 0   0 9 - D E C - 2 0 1 2   2 0 - F E B - 2 0 1 1     1 6 0 0           5 0 0 0   1 7 - N O V - 2 0 1 1   2 0 - F E B - 2 0 1 1     1 6 0 0           1 5 0 0   0 8 - S E P - 2 0 1 1   2 0 - F E B - 2 0 1 1     1 6 0 0           1 1 0 0   1 2 - J A N - 2 0 1 3   2 0 - F E B - 2 0 1 1     1 6 0 0             9 5 0   0 3 - D E C - 2 0 1 1   2 0 - F E B - 2 0 1 1     1 6 0 0           3 0 0 0   0 3 - D E C - 2 0 1 1   2 0 - F E B - 2 0 1 1     1 6 0 0           1 3 0 0   2 3 - J A N - 2 0 1 2  falls within the 90-day window  within 90 days prior , and that is December 17. If you sum the SAL from December 17 with the SAL from February 20  because we are looking for HIREDATEs equal to each HIREDATE or within 90 days earlier , you get 2400, which happens to be the final result for that HIREDATE. Now that you know how it works, use a filter in the WHERE clause to return for each HIREDATE and HIREDATE that is equal to it or is no more than 90 days earlier:  s e l e c t   e . h i r e d a t e ,                 e . s a l ,                 d . s a l   s a l _ t o _ s u m ,                 d . h i r e d a t e   w i t h i n _ 9 0 _ d a y s       f r o m   e m p   e ,   e m p   d     w h e r e   d . h i r e d a t e                 b e t w e e n   e . h i r e d a t e - 9 0   a n d   e . h i r e d a t e     o r d e r   b y   1   H I R E D A T E             S A L   S A L _ T O _ S U M   W I T H I N _ 9 0 _ D A Y S   - - - - - - - - - - -   - - - - -   - - - - - - - - - -   - - - - - - - - - - - - - -   1 7 - D E C - 2 0 1 0       8 0 0                 8 0 0         1 7 - D E C - 2 0 1 0   2 0 - F E B - 2 0 1 1     1 6 0 0                 8 0 0         1 7 - D E C - 2 0 1 0   2 0 - F E B - 2 0 1 1     1 6 0 0               1 6 0 0         2 0 - F E B - 2 0 1 1   2 2 - F E B - 2 0 1 1     1 2 5 0                 8 0 0         1 7 - D E C - 2 0 1 0   2 2 - F E B - 2 0 1 1     1 2 5 0               1 6 0 0         2 0 - F E B - 2 0 1 1   2 2 - F E B - 2 0 1 1     1 2 5 0               1 2 5 0         2 2 - F E B - 2 0 1 1   0 2 - A P R - 2 0 1 1     2 9 7 5               1 6 0 0         2 0 - F E B - 2 0 1 1   0 2 - A P R - 2 0 1 1     2 9 7 5               1 2 5 0         2 2 - F E B - 2 0 1 1   0 2 - A P R - 2 0 1 1     2 9 7 5               2 9 7 5         0 2 - A P R - 2 0 1 1   0 1 - M A Y - 2 0 1 1     2 8 5 0               1 6 0 0         2 0 - F E B - 2 0 1 1   0 1 - M A Y - 2 0 1 1     2 8 5 0               1 2 5 0         2 2 - F E B - 2 0 1 1   0 1 - M A Y - 2 0 1 1     2 8 5 0               2 9 7 5         0 2 - A P R - 2 0 1 1   0 1 - M A Y - 2 0 1 1     2 8 5 0               2 8 5 0         0 1 - M A Y - 2 0 1 1   0 9 - J U N - 2 0 1 1     2 4 5 0               2 9 7 5         0 2 - A P R - 2 0 1 1   0 9 - J U N - 2 0 1 1     2 4 5 0               2 8 5 0         0 1 - M A Y - 2 0 1 1   0 9 - J U N - 2 0 1 1     2 4 5 0               2 4 5 0         0 9 - J U N - 2 0 1 1   0 8 - S E P - 2 0 1 1     1 5 0 0               1 5 0 0         0 8 - S E P - 2 0 1 1   2 8 - S E P - 2 0 1 1     1 2 5 0               1 5 0 0         0 8 - S E P - 2 0 1 1   2 8 - S E P - 2 0 1 1     1 2 5 0               1 2 5 0         2 8 - S E P - 2 0 1 1   1 7 - N O V - 2 0 1 1     5 0 0 0               1 5 0 0         0 8 - S E P - 2 0 1 1   1 7 - N O V - 2 0 1 1     5 0 0 0               1 2 5 0         2 8 - S E P - 2 0 1 1   1 7 - N O V - 2 0 1 1     5 0 0 0               5 0 0 0         1 7 - N O V - 2 0 1 1   0 3 - D E C - 2 0 1 1       9 5 0               1 5 0 0         0 8 - S E P - 2 0 1 1   0 3 - D E C - 2 0 1 1       9 5 0               1 2 5 0         2 8 - S E P - 2 0 1 1   0 3 - D E C - 2 0 1 1       9 5 0               5 0 0 0         1 7 - N O V - 2 0 1 1    Now that you know which SALs are to be included in the moving window of summation, simply use the aggregate function SUM to produce a more expressive result set:  If you compare the result set for the previous query and the result set for the query shown here  which is the original solution presented , you will see they are the same:  0 3 - D E C - 2 0 1 1       9 5 0                 9 5 0         0 3 - D E C - 2 0 1 1   0 3 - D E C - 2 0 1 1       9 5 0               3 0 0 0         0 3 - D E C - 2 0 1 1   0 3 - D E C - 2 0 1 1     3 0 0 0               1 5 0 0         0 8 - S E P - 2 0 1 1   0 3 - D E C - 2 0 1 1     3 0 0 0               1 2 5 0         2 8 - S E P - 2 0 1 1   0 3 - D E C - 2 0 1 1     3 0 0 0               5 0 0 0         1 7 - N O V - 2 0 1 1   0 3 - D E C - 2 0 1 1     3 0 0 0                 9 5 0         0 3 - D E C - 2 0 1 1   0 3 - D E C - 2 0 1 1     3 0 0 0               3 0 0 0         0 3 - D E C - 2 0 1 1   2 3 - J A N - 2 0 1 2     1 3 0 0               5 0 0 0         1 7 - N O V - 2 0 1 1   2 3 - J A N - 2 0 1 2     1 3 0 0                 9 5 0         0 3 - D E C - 2 0 1 1   2 3 - J A N - 2 0 1 2     1 3 0 0               3 0 0 0         0 3 - D E C - 2 0 1 1   2 3 - J A N - 2 0 1 2     1 3 0 0               1 3 0 0         2 3 - J A N - 2 0 1 2   0 9 - D E C - 2 0 1 2     3 0 0 0               3 0 0 0         0 9 - D E C - 2 0 1 2   1 2 - J A N - 2 0 1 3     1 1 0 0               3 0 0 0         0 9 - D E C - 2 0 1 2   1 2 - J A N - 2 0 1 3     1 1 0 0               1 1 0 0         1 2 - J A N - 2 0 1 3 s e l e c t   e . h i r e d a t e ,                 e . s a l ,                 s u m   d . s a l     a s   s p e n d i n g _ p a t t e r n       f r o m   e m p   e ,   e m p   d     w h e r e   d . h i r e d a t e                 b e t w e e n   e . h i r e d a t e - 9 0   a n d   e . h i r e d a t e     g r o u p   b y   e . h i r e d a t e , e . s a l     o r d e r   b y   1 s e l e c t   e . h i r e d a t e ,                 e . s a l ,                   s e l e c t   s u m   s a l     f r o m   e m p   d                   w h e r e   d . h i r e d a t e   b e t w e e n   e . h i r e d a t e - 9 0                                                             a n d   e . h i r e d a t e     a s   s p e n d i n g _ p a t t e r n       f r o m   e m p   e     o r d e r   b y   1     H I R E D A T E             S A L   S P E N D I N G _ P A T T E R N   - - - - - - - - - - -   - - - - -   - - - - - - - - - - - - - - - -   1 7 - D E C - 2 0 1 0     8 0 0                               8 0 0   2 0 - F E B - 2 0 1 1   1 6 0 0                             2 4 0 0    12.20 Pivoting a Result Set with Subtotals  Problem You want to create a report containing subtotals and then transpose the results to provide a more readable report. For example, you’ve been asked to create a report that displays for each department, the managers in the department, and a sum of the salaries of the employees who work for those managers. Additionally, you want to return two subtotals: the sum of all salaries in each department for those employees who have managers, and a sum of all salaries in the result set  the sum of the department subtotals . You currently have the following report:  2 2 - F E B - 2 0 1 1   1 2 5 0                             3 6 5 0   0 2 - A P R - 2 0 1 1   2 9 7 5                             5 8 2 5   0 1 - M A Y - 2 0 1 1   2 8 5 0                             8 6 7 5   0 9 - J U N - 2 0 1 1   2 4 5 0                             8 2 7 5   0 8 - S E P - 2 0 1 1   1 5 0 0                             1 5 0 0   2 8 - S E P - 2 0 1 1   1 2 5 0                             2 7 5 0   1 7 - N O V - 2 0 1 1   5 0 0 0                             7 7 5 0   0 3 - D E C - 2 0 1 1     9 5 0                           1 1 7 0 0   0 3 - D E C - 2 0 1 1   3 0 0 0                           1 1 7 0 0   2 3 - J A N - 2 0 1 2   1 3 0 0                           1 0 2 5 0   0 9 - D E C - 2 0 1 2   3 0 0 0                             3 0 0 0   1 2 - J A N - 2 0 1 3   1 1 0 0                             4 1 0 0 D E P T N O                 M G R                 S A L   - - - - - -   - - - - - - - - - -   - - - - - - - - - -           1 0               7 7 8 2               1 3 0 0           1 0               7 8 3 9               2 4 5 0           1 0                                     3 7 5 0           2 0               7 5 6 6               6 0 0 0           2 0               7 7 8 8               1 1 0 0           2 0               7 8 3 9               2 9 7 5           2 0               7 9 0 2                 8 0 0           2 0                                   1 0 8 7 5           3 0               7 6 9 8               6 5 5 0           3 0               7 8 3 9               2 8 5 0           3 0                                     9 4 0 0                                                 2 4 0 2 5  You want to provide a more readable report and want to transform the previous result set to the following, which makes the meaning of the report much clearer:  Solution The first step is to generate subtotals using the ROLLUP extension to GROUP BY. The next step is to perform a classic pivot  aggregate and CASE expression  to create the desired columns for your report. The GROUPING function allows you to easily determine which values are subtotals  that is, exist because of ROLLUP and otherwise would not normally be there . Depending on how your RDBMS sorts NULL values, you may need to add an ORDER BY to the solution to allow it to look like the previous target result set.  DB2 and Oracle Use the ROLLUP extension to GROUP BY and then use a CASE expression to format the data into a more readable report:  M G R           D E P T 1 0           D E P T 2 0           D E P T 3 0             T O T A L   - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   7 5 6 6                     0               6 0 0 0                     0   7 6 9 8                     0                     0               6 5 5 0   7 7 8 2               1 3 0 0                     0                     0   7 7 8 8                     0               1 1 0 0                     0   7 8 3 9               2 4 5 0               2 9 7 5               2 8 5 0   7 9 0 2                     0                 8 0 0                     0                         3 7 5 0             1 0 8 7 5               9 4 0 0           2 4 0 2 5   1   s e l e c t   m g r ,     2                 s u m   c a s e   d e p t n o   w h e n   1 0   t h e n   s a l   e l s e   0   e n d     d e p t 1 0 ,     3                 s u m   c a s e   d e p t n o   w h e n   2 0   t h e n   s a l   e l s e   0   e n d     d e p t 2 0 ,     4                 s u m   c a s e   d e p t n o   w h e n   3 0   t h e n   s a l   e l s e   0   e n d     d e p t 3 0 ,     5                 s u m   c a s e   f l a g   w h e n   ' 1 1 '   t h e n   s a l   e l s e   n u l l   e n d     t o t a l     6       f r o m         7   s e l e c t   d e p t n o , m g r , s u m   s a l     s a l ,     8                 c a s t   g r o u p i n g   d e p t n o     a s   c h a r   1           9                 c a s t   g r o u p i n g   m g r     a s   c h a r   1       f l a g   1 0       f r o m   e m p   1 1     w h e r e   m g r   i s   n o t   n u l l    SQL Server Use the ROLLUP extension to GROUP BY and then use a CASE expression to format the data into a more readable report:  PostgreSQL Use the ROLLUP extension to GROUP BY and then use a CASE expression to format the data into a more readable report:  1 2     g r o u p   b y   r o l l u p   d e p t n o , m g r     1 3                     x   1 4     g r o u p   b y   m g r   1   s e l e c t   m g r ,     2                 s u m   c a s e   d e p t n o   w h e n   1 0   t h e n   s a l   e l s e   0   e n d     d e p t 1 0 ,     3                 s u m   c a s e   d e p t n o   w h e n   2 0   t h e n   s a l   e l s e   0   e n d     d e p t 2 0 ,     4                 s u m   c a s e   d e p t n o   w h e n   3 0   t h e n   s a l   e l s e   0   e n d     d e p t 3 0 ,     5                 s u m   c a s e   f l a g   w h e n   ' 1 1 '   t h e n   s a l   e l s e   n u l l   e n d     t o t a l     6       f r o m         7   s e l e c t   d e p t n o , m g r , s u m   s a l     s a l ,     8                 c a s t   g r o u p i n g   d e p t n o     a s   c h a r   1     +     9                 c a s t   g r o u p i n g   m g r     a s   c h a r   1       f l a g   1 0       f r o m   e m p   1 1     w h e r e   m g r   i s   n o t   n u l l   1 2     g r o u p   b y   d e p t n o , m g r   w i t h   r o l l u p   1 3                     x   1 4     g r o u p   b y   m g r   1       s e l e c t   m g r ,     2                     s u m   c a s e   d e p t n o   w h e n   1 0   t h e n   s a l   e l s e   0   e n d     d e p t 1 0 ,     3                     s u m   c a s e   d e p t n o   w h e n   2 0   t h e n   s a l   e l s e   0   e n d     d e p t 2 0 ,     4                     s u m   c a s e   d e p t n o   w h e n   3 0   t h e n   s a l   e l s e   0   e n d     d e p t 3 0 ,     5                     s u m   c a s e   f l a g   w h e n   ' 1 1 '   t h e n   s a l   e l s e   n u l l   e n d     t o t a l     6           f r o m         7       s e l e c t   d e p t n o , m g r , s u m   s a l     s a l ,     8                     c o n c a t   c a s t     g r o u p i n g   d e p t n o     a s   c h a r   1     ,     9                     c a s t   g r o u p i n g   m g r     a s   c h a r   1         f l a g     1 0     f r o m   e m p     1 1     w h e r e   m g r   i s   n o t   n u l l     1 2     g r o u p   b y   r o l l u p     d e p t n o , m g r       1 3                   x     1 4     g r o u p   b y   m g r  MySQL Use the ROLLUP extension to GROUP BY and then use a CASE expression to format the data into a more readable report:  Discussion The solutions provided here are identical except for the string concatenation and how GROUPING is specified. Because the solutions are so similar, the following discussion will refer to the SQL Server solution to highlight the intermediate result sets  the discussion is relevant to DB2 and Oracle as well . The first step is to generate a result set that sums the SAL for the employees in each DEPTNO per MGR. The idea is to show how much the employees make under a particular manager in a particular department. For example, the following query will allow you to compare the salaries of employees who work for KING in DEPTNO 10 compared with those who work for KING in DEPTNO 30:  1         s e l e c t   m g r ,   2                     s u m   c a s e   d e p t n o   w h e n   1 0   t h e n   s a l   e l s e   0   e n d     d e p t 1 0 ,   3                     s u m   c a s e   d e p t n o   w h e n   2 0   t h e n   s a l   e l s e   0   e n d     d e p t 2 0 ,   4                     s u m   c a s e   d e p t n o   w h e n   3 0   t h e n   s a l   e l s e   0   e n d     d e p t 3 0 ,   5                     s u m   c a s e   f l a g   w h e n   ' 1 1 '   t h e n   s a l   e l s e   n u l l   e n d     t o t a l   6           f r o m       7         s e l e c t     d e p t n o , m g r , s u m   s a l     s a l ,   8                         c o n c a t     c a s t   g r o u p i n g   d e p t n o     a s   c h a r   1       ,   9                         c a s t   g r o u p i n g   m g r     a s   c h a r   1         f l a g   1 0       f r o m   e m p   1 1     w h e r e   m g r   i s   n o t   n u l l   1 2       g r o u p   b y   d e p t n o , m g r   w i t h   r o l l u p   1 3                       x   1 4       g r o u p   b y   m g r ; s e l e c t   d e p t n o , m g r , s u m   s a l     s a l       f r o m   e m p     w h e r e   m g r   i s   n o t   n u l l     g r o u p   b y   m g r , d e p t n o     o r d e r   b y   1 , 2     D E P T N O                 M G R                 S A L    The next step is to use the ROLLUP extension to GROUP BY to create subtotals for each DEPTNO and across all employees  who have a manager :  With the subtotals created, you need a way to determine which values are in fact subtotals  created by ROLLUP  and which are results of the regular GROUP BY. Use the GROUPING function to create bitmaps to help identify the subtotal values from the regular aggregate values:  - - - - - -   - - - - - - - - - -   - - - - - - - - - -           1 0               7 7 8 2               1 3 0 0           1 0               7 8 3 9               2 4 5 0           2 0               7 5 6 6               6 0 0 0           2 0               7 7 8 8               1 1 0 0           2 0               7 8 3 9               2 9 7 5           2 0               7 9 0 2                 8 0 0           3 0               7 6 9 8               6 5 5 0           3 0               7 8 3 9               2 8 5 0 s e l e c t   d e p t n o , m g r , s u m   s a l     s a l       f r o m   e m p     w h e r e   m g r   i s   n o t   n u l l     g r o u p   b y   d e p t n o , m g r   w i t h   r o l l u p     D E P T N O                 M G R                 S A L   - - - - - -   - - - - - - - - - -   - - - - - - - - - -           1 0               7 7 8 2               1 3 0 0           1 0               7 8 3 9               2 4 5 0           1 0                                     3 7 5 0           2 0               7 5 6 6               6 0 0 0           2 0               7 7 8 8               1 1 0 0           2 0               7 8 3 9               2 9 7 5           2 0               7 9 0 2                 8 0 0           2 0                                   1 0 8 7 5           3 0               7 6 9 8               6 5 5 0           3 0               7 8 3 9               2 8 5 0           3 0                                     9 4 0 0                                                 2 4 0 2 5 s e l e c t   d e p t n o , m g r , s u m   s a l     s a l ,                 c a s t   g r o u p i n g   d e p t n o     a s   c h a r   1     +                 c a s t   g r o u p i n g   m g r     a s   c h a r   1       f l a g       f r o m   e m p    If it isn’t immediately obvious, the rows with a value of 00 for FLAG are the results of regular aggregation. The rows with a value of 01 for FLAG are the results of ROLLUP aggregating SAL by DEPTNO  since DEPTNO is listed first in the ROLLUP; if you switch the order, for example, GROUP BY MGR, DEPTNO WITH ROLLUP, you’d see quite different results . The row with a value of 11 for FLAG is the result of ROLLUP aggregating SAL over all rows. At this point you have everything you need to create a beautified report by simply using CASE expressions. The goal is to provide a report that shows employee salaries for each manager across departments. If a manager does not have any subordinates in a particular department, a zero should be returned; otherwise, you want to return the sum of all salaries for that manager’s subordinates in that department. Additionally, you want to add a final column, TOTAL, representing a sum of all the salaries in the report. The solution satisfying all these requirements is shown here:    w h e r e   m g r   i s   n o t   n u l l     g r o u p   b y   d e p t n o , m g r   w i t h   r o l l u p     D E P T N O                 M G R                 S A L   F L A G   - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - -           1 0               7 7 8 2               1 3 0 0   0 0           1 0               7 8 3 9               2 4 5 0   0 0           1 0                                     3 7 5 0   0 1           2 0               7 5 6 6               6 0 0 0   0 0           2 0               7 7 8 8               1 1 0 0   0 0           2 0               7 8 3 9               2 9 7 5   0 0           2 0               7 9 0 2                 8 0 0   0 0           2 0                                   1 0 8 7 5   0 1           3 0               7 6 9 8               6 5 5 0   0 0           3 0               7 8 3 9               2 8 5 0   0 0           3 0                                     9 4 0 0   0 1                                                 2 4 0 2 5   1 1 s e l e c t   m g r ,                 s u m   c a s e   d e p t n o   w h e n   1 0   t h e n   s a l   e l s e   0   e n d     d e p t 1 0 ,                 s u m   c a s e   d e p t n o   w h e n   2 0   t h e n   s a l   e l s e   0   e n d     d e p t 2 0 ,                 s u m   c a s e   d e p t n o   w h e n   3 0   t h e n   s a l   e l s e   0   e n d     d e p t 3 0 ,                 s u m   c a s e   f l a g   w h e n   ' 1 1 '   t h e n   s a l   e l s e   n u l l   e n d     t o t a l       f r o m        12.21 Summing Up Databases are for storing data, but eventually someone needs to retrieve the data and present it somewhere. The recipes in this chapter show a variety of important ways that data can be re-shaped or formatted to meet the needs of users. Apart from their general usefulness in giving users data in the form they need, these techniques play an important role in giving a database owner the ability to create a datawarehouse. As you gain more experience in supporting users in the business, you will become more adept and extend the ideas here into more elaborate presentations.  s e l e c t   d e p t n o , m g r , s u m   s a l     s a l ,                 c a s t   g r o u p i n g   d e p t n o     a s   c h a r   1     +                 c a s t   g r o u p i n g   m g r     a s   c h a r   1       f l a g       f r o m   e m p     w h e r e   m g r   i s   n o t   n u l l     g r o u p   b y   d e p t n o , m g r   w i t h   r o l l u p                     x     g r o u p   b y   m g r     o r d e r   b y   c o a l e s c e   m g r , 9 9 9 9       M G R           D E P T 1 0           D E P T 2 0           D E P T 3 0           T O T A L   - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   7 5 6 6                     0               6 0 0 0                     0   7 6 9 8                     0                     0               6 5 5 0   7 7 8 2               1 3 0 0                     0                     0   7 7 8 8                     0               1 1 0 0                     0   7 8 3 9               2 4 5 0               2 9 7 5               2 8 5 0   7 9 0 2                     0                 8 0 0                     0                         3 7 5 0             1 0 8 7 5               9 4 0 0         2 4 0 2 5  Chapter 13. Hierarchical Queries  This chapter introduces recipes for expressing hierarchical relationships that you may have in your data. It is typical when working with hierarchical data to have more difficulty retrieving and displaying the data  as a hierarchy  than storing it. Although it’s only been a couple of years since MySQL added recursive CTEs, now that they are available it means that recursive CTEs are available in virtually every RDBMS. As a result, they are the gold standard for dealing with hierarchical queries, and this chapter will make liberal use of this capability to provide recipes to help you unravel the hierarchical structure of your data. Before starting, examine table EMP and the hierarchical relationship between EMPNO and MGR:  s e l e c t   e m p n o , m g r       f r o m   e m p   o r d e r   b y   2               E M P N O                 M G R   - - - - - - - - - -   - - - - - - - - - -               7 7 8 8               7 5 6 6               7 9 0 2               7 5 6 6               7 4 9 9               7 6 9 8               7 5 2 1               7 6 9 8               7 9 0 0               7 6 9 8               7 8 4 4               7 6 9 8               7 6 5 4               7 6 9 8               7 9 3 4               7 7 8 2               7 8 7 6               7 7 8 8               7 5 6 6               7 8 3 9               7 7 8 2               7 8 3 9               7 6 9 8               7 8 3 9               7 3 6 9               7 9 0 2               7 8 3 9  If you look carefully, you will see that each value for MGR is also an EMPNO, meaning the manager of each employee in table EMP is also an employee in table EMP and not stored somewhere else. The relationship between MGR and EMPNO is a parent-child relationship in that the value for MGR is the most immediate parent for a given EMPNO  it is also possible that the manager for a specific employee can have a manager as well, and those managers can in turn have managers, and so on, creating an n-tier hierarchy . If an employee has no manager, then MGR is NULL.  13.1 Expressing a Parent-Child Relationship  Problem You want to include parent information along with data from child records. For example, you want to display each employee’s name along with the name of their manager. You want to return the following result set:  Solution Self-join EMP on MGR and EMPNO to find the name of each employee’s manager. Then use your RDBMS’s supplied function s  for string concatenation to generate the strings in the desired result set.  E M P S _ A N D _ M G R S   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   F O R D   w o r k s   f o r   J O N E S   S C O T T   w o r k s   f o r   J O N E S   J A M E S   w o r k s   f o r   B L A K E   T U R N E R   w o r k s   f o r   B L A K E   M A R T I N   w o r k s   f o r   B L A K E   W A R D   w o r k s   f o r   B L A K E   A L L E N   w o r k s   f o r   B L A K E   M I L L E R   w o r k s   f o r   C L A R K   A D A M S   w o r k s   f o r   S C O T T   C L A R K   w o r k s   f o r   K I N G   B L A K E   w o r k s   f o r   K I N G   J O N E S   w o r k s   f o r   K I N G   S M I T H   w o r k s   f o r   F O R D  DB2, Oracle, and PostgreSQL Self-join on EMP. Then use the double vertical-bar    concatenation operator:  MySQL Self-join on EMP. Then use the concatenation function CONCAT:  SQL Server Self-join on EMP. Then use the plus sign  +  as the concatenation operator:  Discussion The implementation is essentially the same for all the solutions. The difference lies only in the method of string concatenation, and thus one discussion will cover all of the solutions. The key is the join between MGR and EMPNO. The first step is to build a Cartesian product by joining EMP to itself  only a portion of the rows returned by the Cartesian product is shown here :  1   s e l e c t   a . e n a m e       '   w o r k s   f o r   '       b . e n a m e   a s   e m p s _ a n d _ m g r s   2       f r o m   e m p   a ,   e m p   b   3     w h e r e   a . m g r   =   b . e m p n o 1   s e l e c t   c o n c a t   a . e n a m e ,   '   w o r k s   f o r   ' , b . e n a m e     a s   e m p s _ a n d _ m g r s   2       f r o m   e m p   a ,   e m p   b   3     w h e r e   a . m g r   =   b . e m p n o 1   s e l e c t   a . e n a m e   +   '   w o r k s   f o r   '   +   b . e n a m e   a s   e m p s _ a n d _ m g r s   2       f r o m   e m p   a ,   e m p   b   3     w h e r e   a . m g r   =   b . e m p n o s e l e c t   a . e m p n o ,   b . e m p n o       f r o m   e m p   a ,   e m p   b     E M P N O                 M G R   - - - - -   - - - - - - - - - -     7 3 6 9               7 3 6 9     7 3 6 9               7 4 9 9    As you can see, by using a Cartesian product you are returning every possible EMPNO EMPNO combination  such that it looks like the manager for EMPNO 7369 is all the other employees in the table, including EMPNO 7369 . The next step is to filter the results such that you return only each employee and their manager’s EMPNO. Accomplish this by joining on MGR and EMPNO:    7 3 6 9               7 5 2 1     7 3 6 9               7 5 6 6     7 3 6 9               7 6 5 4     7 3 6 9               7 6 9 8     7 3 6 9               7 7 8 2     7 3 6 9               7 7 8 8     7 3 6 9               7 8 3 9     7 3 6 9               7 8 4 4     7 3 6 9               7 8 7 6     7 3 6 9               7 9 0 0     7 3 6 9               7 9 0 2     7 3 6 9               7 9 3 4     7 4 9 9               7 3 6 9     7 4 9 9               7 4 9 9     7 4 9 9               7 5 2 1     7 4 9 9               7 5 6 6     7 4 9 9               7 6 5 4     7 4 9 9               7 6 9 8     7 4 9 9               7 7 8 2     7 4 9 9               7 7 8 8     7 4 9 9               7 8 3 9     7 4 9 9               7 8 4 4     7 4 9 9               7 8 7 6     7 4 9 9               7 9 0 0     7 4 9 9               7 9 0 2     7 4 9 9               7 9 3 4 1   s e l e c t   a . e m p n o ,   b . e m p n o   m g r   2       f r o m   e m p   a ,   e m p   b   3     w h e r e   a . m g r   =   b . e m p n o               E M P N O                 M G R   - - - - - - - - - -   - - - - - - - - - -               7 9 0 2               7 5 6 6               7 7 8 8               7 5 6 6               7 9 0 0               7 6 9 8    Now that you have each employee and the EMPNO of their manager, you can return the name of each manager by simply selecting B.ENAME rather than B.EMPNO. If after some practice you have difficulty grasping how this works, you can use a scalar subquery rather than a self-join to get the answer:  The scalar subquery version is equivalent to the self-join, except for one row: employee KING is in the result set, but that is not the case with the self-join. “Why not?” you might ask. Remember, NULL is never equal to              7 8 4 4               7 6 9 8               7 6 5 4               7 6 9 8               7 5 2 1               7 6 9 8               7 4 9 9               7 6 9 8               7 9 3 4               7 7 8 2               7 8 7 6               7 7 8 8               7 7 8 2               7 8 3 9               7 6 9 8               7 8 3 9               7 5 6 6               7 8 3 9               7 3 6 9               7 9 0 2 s e l e c t   a . e n a m e ,                   s e l e c t   b . e n a m e                       f r o m   e m p   b                     w h e r e   b . e m p n o   =   a . m g r     a s   m g r       f r o m   e m p   a     E N A M E             M G R   - - - - - - - - - -   - - - - - - - - - -   S M I T H             F O R D   A L L E N             B L A K E   W A R D               B L A K E   J O N E S             K I N G   M A R T I N           B L A K E   B L A K E             K I N G   C L A R K             K I N G   S C O T T             J O N E S   K I N G   T U R N E R           B L A K E   A D A M S             S C O T T   J A M E S             B L A K E   F O R D               J O N E S   M I L L E R           C L A R K  anything, not even itself. In the self-join solution, you use an equi-join between EMPNO and MGR, thus filtering out any employees who have NULL for MGR. To see employee KING when using the self-join method, you must outer join as shown in the following two queries. The first solution uses the ANSI outer join, while the second uses the Oracle outer- join syntax. The output is the same for both and is shown following the second query:  13.2 Expressing a Child-Parent-Grandparent Relationship  Problem    *   A N S I   *     s e l e c t   a . e n a m e ,   b . e n a m e   m g r       f r o m   e m p   a   l e f t   j o i n   e m p   b           o n     a . m g r   =   b . e m p n o         *   O r a c l e   *     s e l e c t   a . e n a m e ,   b . e n a m e   m g r       f r o m   e m p   a ,   e m p   b     w h e r e   a . m g r   =   b . e m p n o     +       E N A M E             M G R   - - - - - - - - - -   - - - - - - - - - -   F O R D               J O N E S   S C O T T             J O N E S   J A M E S             B L A K E   T U R N E R           B L A K E   M A R T I N           B L A K E   W A R D               B L A K E   A L L E N             B L A K E   M I L L E R           C L A R K   A D A M S             S C O T T   C L A R K             K I N G   B L A K E             K I N G   J O N E S             K I N G   S M I T H             F O R D   K I N G  Employee CLARK works for KING, and to express that relationship you can use the first recipe in this chapter. What if employee CLARK was in turn a manager for another employee? Consider the following query:  As you can see, employee MILLER works for CLARK who in turn works for KING. You want to express the full hierarchy from MILLER to KING. You want to return the following result set:  However, the single self-join approach from the previous recipe will not suffice to show the entire relationship from top to bottom. You could write a query that does two self-joins, but what you really need is a general approach for traversing such hierarchies.  Solution This recipe differs from the first recipe because there is now a three-tier relationship, as the title suggests. If your RDBMS does not supply functionality for traversing tree-structured data, as is the case for Oracle, then you can solve this problem using the CTEs.  DB2, PostgreSQL, and SQL Server Use the recursive WITH clause to find MILLER’s manager, CLARK, and then CLARK’s manager, KING. The SQL Server string concatenation operator + is used in this solution:  s e l e c t   e n a m e , e m p n o , m g r       f r o m   e m p     w h e r e   e n a m e   i n     ' K I N G ' , ' C L A R K ' , ' M I L L E R '       E N A M E                 E M P N O           M G R   - - - - - - - - -   - - - - - - - -   - - - - - - -   C L A R K                   7 7 8 2         7 8 3 9   K I N G                     7 8 3 9   M I L L E R                 7 9 3 4         7 7 8 2 L E A F _ _ _ B R A N C H _ _ _ R O O T   - - - - - - - - - - - - - - - - - - - - -   M I L L E R - - > C L A R K - - > K I N G  This solution can work on other databases if the concatenation operator is changed. Hence, change to  for DB2 or CONCAT for PostgreSQL.  MySQL This is similar to the previous solution, but also needs the RECURSIVE keyword:  Oracle Use the function SYS_CONNECT_BY_PATH to return MILLER; MILLER’s manager, CLARK; and then CLARK’s manager, KING. Use the  1         w i t h     x     t r e e , m g r , d e p t h     2             a s         3     s e l e c t     c a s t   e n a m e   a s   v a r c h a r   1 0 0     ,   4                     m g r ,   0   5         f r o m     e m p   6       w h e r e     e n a m e   =   ' M I L L E R '   7       u n i o n     a l l   8     s e l e c t     c a s t   x . t r e e + ' - - > ' + e . e n a m e   a s   v a r c h a r   1 0 0     ,   9                     e . m g r ,   x . d e p t h + 1   1 0       f r o m     e m p   e ,   x   1 1     w h e r e   x . m g r   =   e . e m p n o   1 2       1 3   s e l e c t   t r e e   l e a f _ _ _ b r a n c h _ _ _ r o o t   1 4       f r o m   x   1 5     w h e r e   d e p t h   =   2 1         w i t h   r e c u r s i v e   x     t r e e , m g r , d e p t h     2             a s         3     s e l e c t     c a s t   e n a m e   a s   v a r c h a r   1 0 0     ,   4                     m g r ,   0   5         f r o m     e m p   6       w h e r e     e n a m e   =   ' M I L L E R '   7       u n i o n     a l l   8     s e l e c t     c a s t   c o n c a t   x . t r e e , ' - - > ' , e m p . e n a m e     a s   c h a r   1 0 0     ,   9                     e . m g r ,   x . d e p t h + 1   1 0       f r o m     e m p   e ,   x   1 1     w h e r e   x . m g r   =   e . e m p n o   1 2       1 3   s e l e c t   t r e e   l e a f _ _ _ b r a n c h _ _ _ r o o t   1 4       f r o m   x   1 5     w h e r e   d e p t h   =   2  CONNECT BY clause to walk the tree:  Discussion  DB2, SQL Server, PostgreSQL, and MySQL The approach here is to start at the leaf node and walk your way up to the root  as useful practice, try walking in the other direction . The upper part of the UNION ALL simply finds the row for employee MILLER  the leaf node . The lower part of the UNION ALL finds the employee who is MILLER’s manager and then finds that person’s manager, and this process of finding the “manager’s manager” repeats until processing stops at the highest-level manager  the root node . The value for DEPTH starts at 0 and increments automatically by 1 each time a manager is found. DEPTH is a value that DB2 maintains for you when you execute a recursive query.  For an interesting and in-depth introduction to the WITH clause with a focus on its use recursively, see Jonathan Gennick’s article “Understanding the WITH Clause”.  TIP  Next, the second query of the UNION ALL joins the recursive view X to table EMP, to define the parent-child relationship. The query at this point, using SQL Server’s concatenation operator, is as follows:  1     s e l e c t   l t r i m     2                       s y s _ c o n n e c t _ b y _ p a t h   e n a m e , ' - - > '   ,   3                   ' - - > '     l e a f _ _ _ b r a n c h _ _ _ r o o t   4         f r o m   e m p   5       w h e r e   l e v e l   =   3   6       s t a r t   w i t h   e n a m e   =   ' M I L L E R '   7   c o n n e c t   b y   p r i o r   m g r   =   e m p n o     w i t h   x     t r e e , m g r , d e p t h             a s       s e l e c t   c a s t   e n a m e   a s   v a r c h a r   1 0 0     ,                 m g r ,   0       f r o m   e m p    At this point, the heart of the problem has been solved; starting from MILLER, return the full hierarchical relationship from bottom to top. What’s left then is merely formatting. Since the tree traversal is recursive, simply concatenate the current ENAME from EMP to the one before it, which gives you the following result set:    w h e r e   e n a m e   =   ' M I L L E R '     u n i o n   a l l   s e l e c t   c a s t   x . t r e e + ' - - > ' + e . e n a m e   a s   v a r c h a r   1 0 0     ,                 e . m g r ,   x . d e p t h + 1       f r o m   e m p   e ,   x     w h e r e   x . m g r   =   e . e m p n o       s e l e c t   t r e e   l e a f _ _ _ b r a n c h _ _ _ r o o t       f r o m   x     T R E E                         D E P T H   - - - - - - - - - -   - - - - - - - - - -   M I L L E R                             0   C L A R K                               1   K I N G                                 2     w i t h   x     t r e e , m g r , d e p t h             a s       s e l e c t     c a s t   e n a m e   a s   v a r c h a r   1 0 0     ,                   m g r ,   0       f r o m   e m p     w h e r e   e n a m e   =   ' M I L L E R '     u n i o n   a l l   s e l e c t   c a s t   x . t r e e + ' - - > ' + e . e n a m e   a s   v a r c h a r   1 0 0     ,                 e . m g r ,   x . d e p t h + 1       f r o m   e m p   e ,   x     w h e r e   x . m g r   =   e . e m p n o       s e l e c t   d e p t h ,   t r e e       f r o m   x     D E P T H   T R E E   - - - - -   - - - - - - - - - - - - - - - - - - - - - - - - - - -           0   M I L L E R           1   M I L L E R - - > C L A R K           2   M I L L E R - - > C L A R K - - > K I N G  The final step is to keep only the last row in the hierarchy. There are several ways to do this, but the solution uses DEPTH to determine when the root is reached  obviously, if CLARK has a manager other than KING, the filter on DEPTH would have to change; for a more generic solution that requires no such filter, see the next recipe .  Oracle The CONNECT BY clause does all the work in the Oracle solution. Starting with MILLER, you walk all the way to KING without the need for any joins. The expression in the CONNECT BY clause defines the relationship of the data and how the tree will be walked:  The keyword PRIOR lets you access values from the previous record in the hierarchy. Thus, for any given EMPNO, you can use PRIOR MGR to access that employee’s manager number. When you see a clause such as CONNECT BY PRIOR MGR = EMPNO, think of that clause as expressing a join between, in this case, parent and child.  For more on CONNECT BY and its use in hierarchical queries, “Hierarchical Queries in Oracle” is a good overview.  TIP  At this point, you have successfully displayed the full hierarchy starting from MILLER and ending at KING. The problem is for the most part    s e l e c t   e n a m e         f r o m   e m p       s t a r t   w i t h   e n a m e   =   ' M I L L E R '   c o n n e c t   b y   p r i o r   m g r   =   e m p n o     E N A M E   - - - - - - - -   M I L L E R   C L A R K   K I N G  solved. All that remains is the formatting. Use the function SYS_CONNECT_BY_PATH to append each ENAME to the one before it:  Because you are interested in only the complete hierarchy, you can filter on the pseudo-column LEVEL  a more generic approach is shown in the next recipe :  The final step is to use the LTRIM function to remove the leading --> from the result set.  13.3 Creating a Hierarchical View of a Table  Problem You want to return a result set that describes the hierarchy of an entire table. In the case of the EMP table, employee KING has no manager, so KING is the root node. You want to display, starting from KING, all employees    s e l e c t   s y s _ c o n n e c t _ b y _ p a t h   e n a m e , ' - - > '     t r e e         f r o m   e m p       s t a r t   w i t h   e n a m e   =   ' M I L L E R '   c o n n e c t   b y   p r i o r   m g r   =   e m p n o     T R E E   - - - - - - - - - - - - - - - - - - - - - - - - - - -   - - > M I L L E R   - - > M I L L E R - - > C L A R K   - - > M I L L E R - - > C L A R K - - > K I N G   s e l e c t   s y s _ c o n n e c t _ b y _ p a t h   e n a m e , ' - - > '     t r e e         f r o m   e m p       w h e r e   l e v e l   =   3       s t a r t   w i t h   e n a m e   =   ' M I L L E R '   c o n n e c t   b y   p r i o r   m g r   =   e m p n o     T R E E   - - - - - - - - - - - - - - - - - - - - - - - - - - -   - - > M I L L E R - - > C L A R K - - > K I N G  under KING and all employees  if any  under KING’s subordinates. Ultimately, you want to return the following result set:  Solution  DB2, PostgreSQL, and SQL Server Use the recursive WITH clause to start building the hierarchy at KING and then ultimately display all the employees. The solution following uses the DB2 concatenation operator   . SQL Server users use the concatenation operator  + , and MySQL uses the CONCAT function. Other than the concatenation operators, the solution will work as-is on both RDBMSs:  E M P _ T R E E   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   K I N G   K I N G   -   B L A K E   K I N G   -   B L A K E   -   A L L E N   K I N G   -   B L A K E   -   J A M E S   K I N G   -   B L A K E   -   M A R T I N   K I N G   -   B L A K E   -   T U R N E R   K I N G   -   B L A K E   -   W A R D   K I N G   -   C L A R K   K I N G   -   C L A R K   -   M I L L E R   K I N G   -   J O N E S   K I N G   -   J O N E S   -   F O R D   K I N G   -   J O N E S   -   F O R D   -   S M I T H   K I N G   -   J O N E S   -   S C O T T   K I N G   -   J O N E S   -   S C O T T   -   A D A M S   1       w i t h   x     e n a m e , e m p n o       2             a s         3     s e l e c t   c a s t   e n a m e   a s   v a r c h a r   1 0 0     , e m p n o     4         f r o m   e m p     5       w h e r e   m g r   i s   n u l l     6       u n i o n   a l l     7     s e l e c t   c a s t   x . e n a m e   '   -   '   e . e n a m e   a s   v a r c h a r   1 0 0     ,     8                   e . e m p n o     9         f r o m   e m p   e ,   x   1 0       w h e r e   e . m g r   =   x . e m p n o   1 1         1 2     s e l e c t   e n a m e   a s   e m p _ t r e e    MySQL MySQL also needs the RECURSIVE keyword:  Oracle Use the CONNECT BY function to define the hierarchy. Use the SYS_CONNECT_BY_PATH function to format the output accordingly:  This solution differs from the previous recipe in that it includes no filter on the LEVEL pseudo-column. Without the filter, all possible trees  where PRIOR EMPNO=MGR  are displayed.  Discussion  DB2, MySQL, PostgreSQL, and SQL Server  1 3         f r o m   x   1 4       o r d e r   b y   1   1       w i t h   r e c u r s i v e   x     e n a m e , e m p n o       2             a s         3     s e l e c t   c a s t   e n a m e   a s   v a r c h a r   1 0 0     , e m p n o     4         f r o m   e m p     5       w h e r e   m g r   i s   n u l l     6       u n i o n   a l l     7     s e l e c t   c a s t   c o n c a t   x . e n a m e , '   -   ' , e . e n a m e     a s   v a r c h a r   1 0 0     ,     8                   e . e m p n o     9         f r o m   e m p   e ,   x   1 0       w h e r e   e . m g r   =   x . e m p n o   1 1         1 2     s e l e c t   e n a m e   a s   e m p _ t r e e   1 3         f r o m   x   1 4       o r d e r   b y   1 1     s e l e c t   l t r i m     2                       s y s _ c o n n e c t _ b y _ p a t h   e n a m e , '   -   '   ,   3                   '   -   '     e m p _ t r e e   4         f r o m   e m p   5         s t a r t   w i t h   m g r   i s   n u l l   6     c o n n e c t   b y   p r i o r   e m p n o = m g r   7         o r d e r   b y   1  The first step is to identify the root row  employee KING  in the upper part of the UNION ALL in the recursive view X. The next step is to find KING’s subordinates, and their subordinates if there are any, by joining recursive view X to table EMP. Recursion will continue until you’ve returned all employees. Without the formatting you see in the final result set, the result set returned by the recursive view X is shown here:  All the rows in the hierarchy are returned  which can be useful , but without the formatting you cannot tell who the managers are. By concatenating each employee to her manager, you return more meaningful output. Produce the desired output simply by using the following:  w i t h   x     e n a m e , e m p n o             a s       s e l e c t   c a s t   e n a m e   a s   v a r c h a r   1 0 0     , e m p n o       f r o m   e m p     w h e r e   m g r   i s   n u l l     u n i o n   a l l   s e l e c t   c a s t   e . e n a m e   a s   v a r c h a r   1 0 0     , e . e m p n o       f r o m   e m p   e ,   x     w h e r e   e . m g r   =   x . e m p n o           s e l e c t   e n a m e   e m p _ t r e e         f r o m   x       E M P _ T R E E     - - - - - - - - - - - - - - - -     K I N G     J O N E S     S C O T T     A D A M S     F O R D     S M I T H     B L A K E     A L L E N     W A R D     M A R T I N     T U R N E R     J A M E S     C L A R K     M I L L E R  in the SELECT clause of the lower portion of the UNION ALL in recursive view X. The WITH clause is extremely useful in solving this type of problem, because the hierarchy can change  for example, leaf nodes become branch nodes  without any need to modify the query.  Oracle The CONNECT BY clause returns the rows in the hierarchy. The START WITH clause defines the root row. If you run the solution without SYS_CONNECT_BY_PATH, you can see that the correct rows are returned  which can be useful , but not formatted to express the relationship of the rows:  By using the pseudo-column LEVEL and the function LPAD, you can see the hierarchy more clearly, and you can ultimately see why  c a s t   x . e n a m e + ' , ' + e . e n a m e   a s   v a r c h a r   1 0 0     s e l e c t   e n a m e   e m p _ t r e e       f r o m   e m p     s t a r t   w i t h   m g r   i s   n u l l   c o n n e c t   b y   p r i o r   e m p n o   =   m g r     E M P _ T R E E   - - - - - - - - - - - - - - - - -   K I N G   J O N E S   S C O T T   A D A M S   F O R D   S M I T H   B L A K E   A L L E N   W A R D   M A R T I N   T U R N E R   J A M E S   C L A R K   M I L L E R  SYS_CONNECT_BY_PATH returns the results that you see in the desired output shown earlier:  The indentation in this output indicates who the managers are by nesting subordinates under their superiors. For example, KING works for no one. JONES works for KING. SCOTT works for JONES. ADAMS works for SCOTT. If you look at the corresponding rows from the solution when using SYS_CONNECT_BY_PATH, you will see that SYS_CONNECT_BY_PATH rolls up the hierarchy for you. When you get to a new node, you see all the prior nodes as well:  s e l e c t   l p a d   ' . ' , 2 * l e v e l , ' . '     e n a m e   e m p _ t r e e         f r o m   e m p       s t a r t   w i t h   m g r   i s   n u l l   c o n n e c t   b y   p r i o r   e m p n o   =   m g r     E M P _ T R E E   - - - - - - - - - - - - - - - - -   . . K I N G   . . . . J O N E S   . . . . . . S C O T T   . . . . . . . . A D A M S   . . . . . . F O R D   . . . . . . . . S M I T H   . . . . B L A K E   . . . . . . A L L E N   . . . . . . W A R D   . . . . . . M A R T I N   . . . . . . T U R N E R   . . . . . . J A M E S   . . . . C L A R K   . . . . . . M I L L E R K I N G   K I N G   -   J O N E S   K I N G   -   J O N E S   -   S C O T T   K I N G   -   J O N E S   -   S C O T T   -   A D A M S  13.4 Finding All Child Rows for a Given Parent Row  Problem You want to find all the employees who work for JONES, either directly or indirectly  i.e., they work for someone who works for JONES . The list of employees under JONES is shown here  JONES is included in the result set :  Solution Being able to move to the absolute top or bottom of a tree is extremely useful. For this solution, there is no special formatting necessary. The goal is to simply return all employees who work under employee JONES, including JONES himself. This type of query really shows the usefulness of recursive SQL extensions like Oracle’s CONNECT BY and SQL Server’s DB2’s WITH clause.  DB2, PostgreSQL, and SQL Server Use the recursive WITH clause to find all employees under JONES. Begin with JONES by specifying WHERE ENAME = JONES in the first of the two union queries:  E N A M E   - - - - - - - - - -   J O N E S   S C O T T   A D A M S   F O R D   S M I T H   1       w i t h   x     e n a m e , e m p n o       2           a s         3   s e l e c t   e n a m e , e m p n o     4       f r o m   e m p     5     w h e r e   e n a m e   =   ' J O N E S '     6     u n i o n   a l l    Oracle Use the CONNECT BY clause and specify START WITH ENAME = JONES to find all the employees under JONES:  Discussion  DB2, MySQL, PostgreSQL, and SQL Server The recursive WITH clause makes this a relatively easy problem to solve. The first part of the WITH clause, the upper part of the UNION ALL, returns the row for employee JONES. You need to return ENAME to see the name and EMPNO so you can use it to join on. The lower part of the UNION ALL recursively joins EMP.MGR to X.EMPNO. The join condition will be applied until the result set is exhausted.  Oracle The START WTH clause tells the query to make JONES the root node. The condition in the CONNECT BY clause drives the tree walk and will run until the condition is no longer true.  13.5 Determining Which Rows Are Leaf, Branch, or Root Nodes  Problem    7   s e l e c t   e . e n a m e ,   e . e m p n o     8       f r o m   e m p   e ,   x     9     w h e r e   x . e m p n o   =   e . m g r   1 0       1 1   s e l e c t   e n a m e   1 2       f r o m   x 1   s e l e c t   e n a m e   2       f r o m   e m p   3     s t a r t   w i t h   e n a m e   =   ' J O N E S '   4   c o n n e c t   b y   p r i o r   e m p n o   =   m g r  You want to determine what type of node a given row is: a leaf, branch, or root. For this example, a leaf node is an employee who is not a manager. A branch node is an employee who is both a manager and also has a manager. A root node is an employee without a manager. You want to return 1  TRUE  or 0  FALSE  to reflect the status of each row in the hierarchy. You want to return the following result set:  Solution It is important to realize that the EMP table is modeled in a tree hierarchy, not a recursive hierarchy, and the value for MGR for root nodes is NULL. If EMP were modeled to use a recursive hierarchy, root nodes would be self- referencing  i.e., the value for MGR for employee KING would be KING’s EMPNO . We find self-referencing to be counterintuitive and thus are using NULL values for root nodes’ MGR. For Oracle users using CONNECT BY and DB2 SQL Server users using WITH, you’ll find tree hierarchies easier to work with and potentially more efficient than recursive hierarchies. If you are in a situation where you have a recursive hierarchy and are using CONNECT BY or WITH, watch out: you can end up with a loop in your SQL. You need to code around such loops if you are stuck with recursive hierarchies.  E N A M E                     I S _ L E A F       I S _ B R A N C H           I S _ R O O T   - - - - - - - - - -     - - - - - - - - - -     - - - - - - - - - -     - - - - - - - - - -   K I N G                                   0                       0                       1   J O N E S                                 0                       1                       0   S C O T T                                 0                       1                       0   F O R D                                   0                       1                       0   C L A R K                                 0                       1                       0   B L A K E                                 0                       1                       0   A D A M S                                 1                       0                       0   M I L L E R                               1                       0                       0   J A M E S                                 1                       0                       0   T U R N E R                               1                       0                       0   A L L E N                                 1                       0                       0   W A R D                                   1                       0                       0   M A R T I N                               1                       0                       0   S M I T H                                 1                       0                       0  DB2, PostgreSQL, MySQL, and SQL Server Use three scalar subqueries to determine the correct “Boolean” value  either a 1 or a 0  to return for each node type:  Oracle The scalar subquery solution will work for Oracle as well and should be used if you are on a version of Oracle prior to Oracle Database 10g. The following solution highlights built-in functions provided by Oracle  that were introduced in Oracle Database 10g  to identify root and leaf rows. The functions are CONNECT_BY_ROOT and CONNECT_BY_ISLEAF, respectively:  Discussion    1   s e l e c t   e . e n a m e ,     2                   s e l e c t   s i g n   c o u n t   *       f r o m   e m p   d     3                     w h e r e   0   =     4                           s e l e c t   c o u n t   *     f r o m   e m p   f     5                             w h e r e   f . m g r   =   e . e m p n o       a s   i s _ l e a f ,     6                   s e l e c t   s i g n   c o u n t   *       f r o m   e m p   d     7                     w h e r e   d . m g r   =   e . e m p n o     8                       a n d   e . m g r   i s   n o t   n u l l     a s   i s _ b r a n c h ,     9                   s e l e c t   s i g n   c o u n t   *       f r o m   e m p   d   1 0                     w h e r e   d . e m p n o   =   e . e m p n o   1 1                         a n d   d . m g r   i s   n u l l     a s   i s _ r o o t   1 2       f r o m   e m p   e   1 3   o r d e r   b y   4   d e s c , 3   d e s c   1     s e l e c t   e n a m e ,     2                   c o n n e c t _ b y _ i s l e a f   i s _ l e a f ,     3                     s e l e c t   c o u n t   *     f r o m   e m p   e     4                       w h e r e   e . m g r   =   e m p . e m p n o     5                           a n d   e m p . m g r   i s   n o t   n u l l     6                           a n d   r o w n u m   =   1     i s _ b r a n c h ,     7                   d e c o d e   e n a m e , c o n n e c t _ b y _ r o o t   e n a m e   , 1 , 0     i s _ r o o t     8         f r o m   e m p     9       s t a r t   w i t h   m g r   i s   n u l l   1 0   c o n n e c t   b y   p r i o r   e m p n o   =   m g r   1 1   o r d e r   b y   4   d e s c ,   3   d e s c  DB2, PostgreSQL, MySQL, and SQL Server This solution simply applies the rules defined in the “Problem” section to determine leaves, branches, and roots. The first step is to determine whether an employee is a leaf node. If the employee is not a manager  no one works under them , then she is a leaf node. The first scalar subquery, IS_LEAF, is shown here:  Because the output for IS_LEAF should be a 0 or 1, it is necessary to take the SIGN of the COUNT *  operation. Otherwise, you would get 14 instead of 1 for leaf rows. As an alternative, you can use a table with only one row to count against, because you only want to return 0 or 1. For example:  s e l e c t   e . e n a m e ,                   s e l e c t   s i g n   c o u n t   *       f r o m   e m p   d                     w h e r e   0   =                           s e l e c t   c o u n t   *     f r o m   e m p   f                             w h e r e   f . m g r   =   e . e m p n o       a s   i s _ l e a f       f r o m   e m p   e   o r d e r   b y   2   d e s c     E N A M E                 I S _ L E A F   - - - - - - - - - - -   - - - - - - - -   S M I T H                             1   A L L E N                             1   W A R D                               1   A D A M S                             1   T U R N E R                           1   M A R T I N                           1   J A M E S                             1   M I L L E R                           1   J O N E S                             0   B L A K E                             0   C L A R K                             0   F O R D                               0   S C O T T                             0   K I N G                               0 s e l e c t   e . e n a m e ,                   s e l e c t   c o u n t   *     f r o m   t 1   d                     w h e r e   n o t   e x i s t s                           s e l e c t   n u l l   f r o m   e m p   f                             w h e r e   f . m g r   =   e . e m p n o       a s   i s _ l e a f    The next step is to find branch nodes. If an employee is a manager  someone works for them  and they also happen to work for someone else, then the employee is a branch node. The results of the scalar subquery IS_BRANCH are shown here:      f r o m   e m p   e   o r d e r   b y   2   d e s c     E N A M E                   I S _ L E A F   - - - - - - - - - -   - - - - - - - - - -   S M I T H                               1   A L L E N                               1   W A R D                                 1   A D A M S                               1   T U R N E R                             1   M A R T I N                             1   J A M E S                               1   M I L L E R                             1   J O N E S                               0   B L A K E                               0   C L A R K                               0   F O R D                                 0   S C O T T                               0   K I N G                                 0 s e l e c t   e . e n a m e ,                   s e l e c t   s i g n   c o u n t   *       f r o m   e m p   d                     w h e r e   d . m g r   =   e . e m p n o                       a n d   e . m g r   i s   n o t   n u l l     a s   i s _ b r a n c h       f r o m   e m p   e   o r d e r   b y   2   d e s c       E N A M E               I S _ B R A N C H   - - - - - - - - - - -   - - - - - - - - -   J O N E S                               1   B L A K E                               1   S C O T T                               1   C L A R K                               1   F O R D                                 1   S M I T H                               0   T U R N E R                             0   M I L L E R                             0   J A M E S                               0   A D A M S                               0    Again, it is necessary to take the SIGN of the COUNT *  operation. Otherwise, you will get  potentially  values greater than 1 when a node is a branch. Like scalar subquery IS_LEAF, you can use a table with one row to avoid using SIGN. The following solution uses the T1 table:  The last step is to find the root nodes. A root node is defined as an employee who is a manager but who does not work for anyone else. In table EMP, only KING is a root node. Scalar subquery IS_ROOT is shown here:  K I N G                                 0   A L L E N                               0   M A R T I N                             0   W A R D                                 0 s e l e c t   e . e n a m e ,                 s e l e c t   c o u n t   *     f r o m   t 1   t                   w h e r e   e x i s t s                         s e l e c t   n u l l   f r o m   e m p   f                       w h e r e   f . m g r   =   e . e m p n o                           a n d   e . m g r   i s   n o t   n u l l       a s   i s _ b r a n c h       f r o m   e m p   e   o r d e r   b y   2   d e s c       E N A M E                         I S _ B R A N C H   - - - - - - - - - - - - - - -   - - - - - - - - - -   J O N E S                                         1   B L A K E                                         1   S C O T T                                         1   C L A R K                                         1   F O R D                                           1   S M I T H                                         0   T U R N E R                                       0   M I L L E R                                       0   J A M E S                                         0   A D A M S                                         0   K I N G                                           0   A L L E N                                         0   M A R T I N                                       0   W A R D                                           0 s e l e c t   e . e n a m e ,                   s e l e c t   s i g n   c o u n t   *       f r o m   e m p   d    Because EMP is a small 14-row table, it is easy to see that employee KING is the only root node, so in this case taking the SIGN of the COUNT *  operation is not strictly necessary. If there can be multiple root nodes, then you can use SIGN, or you can use a one-row table in the scalar subquery as is shown earlier for IS_BRANCH and IS_LEAF.  Oracle For those of you on versions of Oracle prior to Oracle Database 10g, you can follow the discussion for the other RDBMSs, as that solution will work  without modifications  in Oracle. If you are on Oracle Database 10g or later, you may want to take advantage of two functions to make identifying root and leaf nodes a simple task: they are CONNECT_BY_ROOT and CONNECT_BY_ISLEAF, respectively. As of the time of this writing, it is necessary to use CONNECT BY in your SQL statement in order for you to be able to use CONNECT_BY_ROOT and CONNECT_BY_ISLEAF. The first step is to find the leaf nodes by using CONNECT_BY_ISLEAF as follows:                    w h e r e   d . e m p n o   =   e . e m p n o                         a n d   d . m g r   i s   n u l l     a s   i s _ r o o t       f r o m   e m p   e   o r d e r   b y   2   d e s c       E N A M E                   I S _ R O O T   - - - - - - - - - -     - - - - - - - - -   K I N G                                 1   S M I T H                               0   A L L E N                               0   W A R D                                 0   J O N E S                               0   T U R N E R                             0   J A M E S                               0   M I L L E R                             0   F O R D                                 0   A D A M S                               0   M A R T I N                             0   B L A K E                               0   C L A R K                               0   S C O T T                               0  The next step is to use a scalar subquery to find the branch nodes. Branch nodes are employees who are managers but who also work for someone else:  s e l e c t   e n a m e ,                   c o n n e c t _ b y _ i s l e a f   i s _ l e a f       f r o m   e m p     s t a r t   w i t h   m g r   i s   n u l l   c o n n e c t   b y   p r i o r   e m p n o   =   m g r   o r d e r   b y   2   d e s c       E N A M E                     I S _ L E A F   - - - - - - - - - -     - - - - - - - - - -   A D A M S                                 1   S M I T H                                 1   A L L E N                                 1   T U R N E R                               1   M A R T I N                               1   W A R D                                   1   J A M E S                                 1   M I L L E R                               1   K I N G                                   0   J O N E S                                 0   B L A K E                                 0   C L A R K                                 0   F O R D                                   0   S C O T T                                 0 s e l e c t   e n a m e ,                     s e l e c t   c o u n t   *     f r o m   e m p   e                       w h e r e   e . m g r   =   e m p . e m p n o                           a n d   e m p . m g r   i s   n o t   n u l l                           a n d   r o w n u m   =   1     i s _ b r a n c h       f r o m   e m p     s t a r t   w i t h   m g r   i s   n u l l   c o n n e c t   b y   p r i o r   e m p n o   =   m g r   o r d e r   b y   2   d e s c     E N A M E               I S _ B R A N C H   - - - - - - - - - -   - - - - - - - - - -   J O N E S                               1   S C O T T                               1   B L A K E                               1   F O R D                                 1   C L A R K                               1    The filter on ROWNUM is necessary to ensure that you return a count of 1 or 0, and nothing else. The last step is to identify the root nodes by using the function CONNECT_BY_ROOT. The solution finds the ENAME for the root node and compares it with all the rows returned by the query. If there is a match, that row is the root node:  The SYS_CONNECT_BY_PATH function rolls up a hierarchy starting from the root value, as shown here:  K I N G                                 0   M A R T I N                             0   M I L L E R                             0   J A M E S                               0   T U R N E R                             0   W A R D                                 0   A D A M S                               0   A L L E N                               0   S M I T H                               0 s e l e c t   e n a m e ,                   d e c o d e   e n a m e , c o n n e c t _ b y _ r o o t   e n a m e   , 1 , 0     i s _ r o o t       f r o m   e m p     s t a r t   w i t h   m g r   i s   n u l l   c o n n e c t   b y   p r i o r   e m p n o   =   m g r   o r d e r   b y   2   d e s c     E N A M E                     I S _ R O O T   - - - - - - - - - -     - - - - - - - - - -   K I N G                                   1   J O N E S                                 0   S C O T T                                 0   A D A M S                                 0   F O R D                                   0   S M I T H                                 0   B L A K E                                 0   A L L E N                                 0   W A R D                                   0   M A R T I N                               0   T U R N E R                               0   J A M E S                                 0   C L A R K                                 0   M I L L E R                               0  To get the root row, simply substring out the first ENAME in PATH:  s e l e c t   e n a m e ,                 l t r i m   s y s _ c o n n e c t _ b y _ p a t h   e n a m e , ' , '   , ' , '     p a t h       f r o m   e m p   s t a r t   w i t h   m g r   i s   n u l l   c o n n e c t   b y   p r i o r   e m p n o = m g r     E N A M E             P A T H   - - - - - - - - - -   - - - - - - - - - - - - - - - - - - - - - - - - - - - -   K I N G               K I N G   J O N E S             K I N G , J O N E S   S C O T T             K I N G , J O N E S , S C O T T   A D A M S             K I N G , J O N E S , S C O T T , A D A M S   F O R D               K I N G , J O N E S , F O R D   S M I T H             K I N G , J O N E S , F O R D , S M I T H   B L A K E             K I N G , B L A K E   A L L E N             K I N G , B L A K E , A L L E N   W A R D               K I N G , B L A K E , W A R D   M A R T I N           K I N G , B L A K E , M A R T I N   T U R N E R           K I N G , B L A K E , T U R N E R   J A M E S             K I N G , B L A K E , J A M E S   C L A R K             K I N G , C L A R K   M I L L E R           K I N G , C L A R K , M I L L E R s e l e c t   e n a m e ,                 s u b s t r   r o o t , 1 , i n s t r   r o o t , ' , '   - 1     r o o t       f r o m       s e l e c t   e n a m e ,                 l t r i m   s y s _ c o n n e c t _ b y _ p a t h   e n a m e , ' , '   , ' , '     r o o t       f r o m   e m p   s t a r t   w i t h   m g r   i s   n u l l   c o n n e c t   b y   p r i o r   e m p n o = m g r                       E N A M E             R O O T   - - - - - - - - - -   - - - - - - - - - -   K I N G   J O N E S             K I N G   S C O T T             K I N G   A D A M S             K I N G   F O R D               K I N G   S M I T H             K I N G   B L A K E             K I N G   A L L E N             K I N G   W A R D               K I N G    The last step is to flag the result from the ROOT column; if it is NULL, that is your root row.  13.6 Summing Up The spread of CTEs across all vendors has made standardized approaches to hierarchical queries far more achievable. This a great step forward as hierarchical relationships appear in many kinds of data, even data where the relationship isn’t necessarily planned for, so queries need to account for it.  M A R T I N           K I N G   T U R N E R           K I N G   J A M E S             K I N G   C L A R K             K I N G   M I L L E R           K I N G  Chapter 14. Odds ’n’ Ends  This chapter contains queries that didn’t fit in any other chapter, either because the chapter they would belong to is already long enough, or because the problems they solve are more fun than realistic. This chapter is meant to be a “fun” chapter, in that the recipes here may or may not be recipes that you would actually use; nevertheless, the queries are interesting, and we wanted to include them in this book.  14.1 Creating Cross-Tab Reports Using SQL Server’s PIVOT Operator  Problem You want to create a cross-tab report to transform your result set’s rows into columns. You are aware of traditional methods of pivoting but would like to try something different. In particular, you want to return the following result set without using CASE expressions or joins:  Solution Use the PIVOT operator to create the required result set without CASE expressions or additional joins:  D E P T _ 1 0           D E P T _ 2 0           D E P T _ 3 0         D E P T _ 4 0   - - - - - - -   - - - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - - -               3                       5                       6                     0 1   s e l e c t   [ 1 0 ]   a s   d e p t _ 1 0 ,   2                 [ 2 0 ]   a s   d e p t _ 2 0 ,   3                 [ 3 0 ]   a s   d e p t _ 3 0 ,   4                 [ 4 0 ]   a s   d e p t _ 4 0   5       f r o m     s e l e c t   d e p t n o ,   e m p n o   f r o m   e m p     d r i v e r   6     p i v o t        Discussion The PIVOT operator may seem strange at first, but the operation it performs in the solution is technically the same as the more familiar transposition query shown here:  Now that you know what is essentially happening, let’s break down what the PIVOT operator is doing. Line 5 of the solution shows an inline view named DRIVER:  We’ve used the alias DRIVER because the rows from this inline view  or table expression  feed directly into the PIVOT operation. The PIVOT operator rotates the rows to columns by evaluating the items listed on line 8 in the FOR list  shown here :  The evaluation goes something like this:  1. If there are any DEPTNOs with a value of 10, perform the aggregate  operation defined  COUNT DRIVER.EMPNO   for those rows.  2. Repeat for DEPTNOs 20, 30, and 40.  7           c o u n t   d r i v e r . e m p n o     8           f o r   d r i v e r . d e p t n o   i n       [ 1 0 ] , [ 2 0 ] , [ 3 0 ] , [ 4 0 ]       9         a s   e m p P i v o t s e l e c t   s u m   c a s e   d e p t n o   w h e n   1 0   t h e n   1   e l s e   0   e n d     a s   d e p t _ 1 0 ,                 s u m   c a s e   d e p t n o   w h e n   2 0   t h e n   1   e l s e   0   e n d     a s   d e p t _ 2 0 ,                 s u m   c a s e   d e p t n o   w h e n   3 0   t h e n   1   e l s e   0   e n d     a s   d e p t _ 3 0 ,                 s u m   c a s e   d e p t n o   w h e n   4 0   t h e n   1   e l s e   0   e n d     a s   d e p t _ 4 0       f r o m   e m p     D E P T _ 1 0         D E P T _ 2 0         D E P T _ 3 0         D E P T _ 4 0   - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -               3                     5                     6                     0 f r o m     s e l e c t   d e p t n o ,   e m p n o   f r o m   e m p     d r i v e r f o r   d r i v e r . d e p t n o   i n       [ 1 0 ] , [ 2 0 ] , [ 3 0 ] , [ 4 0 ]      The items listed in the brackets on line 8 serve not only to define values for which aggregation is performed; the items also become the column names in the result set  without the square brackets . In the SELECT clause of the solution, the items in the FOR list are referenced and aliased. If you do not alias the items in the FOR list, the column names become the items in the FOR list sans brackets. Interestingly enough, since inline view DRIVER is just that—an inline view —you may put more complex SQL in there. For example, consider the situation where you want to modify the result set such that the actual department name is the name of the column. Listed here are the rows in table DEPT:  You want to use PIVOT to return the following result set:  Because inline view DRIVER can be practically any valid table expression, you can perform the join from table EMP to table DEPT and then have PIVOT evaluate those rows. The following query will return the desired result set:  s e l e c t   *   f r o m   d e p t     D E P T N O   D N A M E                     L O C   - - - - - -   - - - - - - - - - - - - - -   - - - - - - - - - - - - -           1 0   A C C O U N T I N G           N E W   Y O R K           2 0   R E S E A R C H               D A L L A S           3 0   S A L E S                     C H I C A G O           4 0   O P E R A T I O N S           B O S T O N A C C O U N T I N G       R E S E A R C H             S A L E S   O P E R A T I O N S   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -                     3                     5                     6                     0 s e l e c t   [ A C C O U N T I N G ]   a s   A C C O U N T I N G ,                 [ S A L E S ]             a s   S A L E S ,                 [ R E S E A R C H ]       a s   R E S E A R C H ,                 [ O P E R A T I O N S ]   a s   O P E R A T I O N S       f r o m                           s e l e c t   d . d n a m e ,   e . e m p n o                           f r o m   e m p   e , d e p t   d    As you can see, PIVOT provides an interesting spin on pivoting result sets. Regardless of whether you prefer using it to the traditional methods of pivoting, it’s nice to have another tool in your toolbox.  14.2 Unpivoting a Cross-Tab Report Using SQL Server’s UNPIVOT Operator  Problem You have a pivoted result set  or simply a fact table , and you want to unpivot the result set. For example, instead of having a result set with one row and four columns, you want to return a result set with two columns and four rows. Using the result set from the previous recipe, you want to convert it from this:  to this:  Solution                        w h e r e   e . d e p t n o = d . d e p t n o                         d r i v e r       p i v o t             c o u n t   d r i v e r . e m p n o           f o r   d r i v e r . d n a m e   i n     [ A C C O U N T I N G ] , [ S A L E S ] , [ R E S E A R C H ] , [ O P E R A T I O N S ]             a s   e m p P i v o t A C C O U N T I N G       R E S E A R C H             S A L E S   O P E R A T I O N S   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -                     3                     5                     6                     0 D N A M E                                   C N T   - - - - - - - - - - - - - -   - - - - - - - - - -   A C C O U N T I N G                             3   R E S E A R C H                                 5   S A L E S                                       6   O P E R A T I O N S                             0  You didn’t think SQL Server would give you the ability to PIVOT without being able to UNPIVOT, did you? To unpivot the result set, just use it as the driver and let the UNPIVOT operator do all the work. All you need to do is specify the column names:  Ideally, before reading this recipe you’ve read the one prior to it, because the inline view NEW_DRIVER is simply the code from the previous recipe  if you don’t understand it, please refer to the previous recipe before looking at this one . Since lines 3–16 consist of code you’ve already seen, the only new syntax is on line 18, where you use UNPIVOT. The UNPIVOT command simply looks at the result set from NEW_DRIVER and evaluates each column and row. For example, the UNPIVOT operator evaluates the column names from NEW_DRIVER. When it encounters ACCOUNTING, it transforms the column name ACCOUNTING into a row value  under the column DNAME . It also takes the value for ACCOUNTING from NEW_DRIVER  which is 3  and returns that as part of the ACCOUNTING row as well  under the column    1       s e l e c t   D N A M E ,   C N T     2           f r o m         3               s e l e c t   [ A C C O U N T I N G ]   a s   A C C O U N T I N G ,     4                             [ S A L E S ]             a s   S A L E S ,     5                             [ R E S E A R C H ]       a s   R E S E A R C H ,     6                             [ O P E R A T I O N S ]   a s   O P E R A T I O N S     7                   f r o m         8                                   s e l e c t   d . d n a m e ,   e . e m p n o     9                                       f r o m   e m p   e , d e p t   d   1 0                                     w h e r e   e . d e p t n o = d . d e p t n o   1 1   1 2                                   d r i v e r   1 3                   p i v o t       1 4                       c o u n t   d r i v e r . e m p n o     1 5                       f o r   d r i v e r . d n a m e   i n     [ A C C O U N T I N G ] , [ S A L E S ] , [ R E S E A R C H ] , [ O P E R A T I O N S ]     1 6                       a s   e m p P i v o t   1 7           n e w _ d r i v e r   1 8     u n p i v o t     c n t   f o r   d n a m e   i n     A C C O U N T I N G , S A L E S , R E S E A R C H , O P E R A T I O N S     1 9         a s   u n _ p i v o t  CNT . UNPIVOT does this for each of the items specified in the FOR list and simply returns each one as a row. The new result set is now skinny and has two columns, DNAME and CNT, with four rows:  14.3 Transposing a Result Set Using Oracle’s MODEL Clause  Problem Like the first recipe in this chapter, you want to find an alternative to the traditional pivoting techniques you’ve seen already. You want to try your hand at Oracle’s MODEL clause. Unlike SQL Server’s PIVOT operator,  s e l e c t   D N A M E ,   C N T       f r o m               s e l e c t   [ A C C O U N T I N G ]   a s   A C C O U N T I N G ,                         [ S A L E S ]             a s   S A L E S ,                         [ R E S E A R C H ]       a s   R E S E A R C H ,                         [ O P E R A T I O N S ]   a s   O P E R A T I O N S               f r o m                                   s e l e c t   d . d n a m e ,   e . e m p n o                                   f r o m   e m p   e , d e p t   d                                 w h e r e   e . d e p t n o = d . d e p t n o                                 d r i v e r             p i v o t                     c o u n t   d r i v e r . e m p n o                   f o r   d r i v e r . d n a m e   i n       [ A C C O U N T I N G ] , [ S A L E S ] , [ R E S E A R C H ] , [ O P E R A T I O N S ]                     a s   e m p P i v o t       n e w _ d r i v e r   u n p i v o t     c n t   f o r   d n a m e   i n     A C C O U N T I N G , S A L E S , R E S E A R C H , O P E R A T I O N S         a s   u n _ p i v o t     D N A M E                                   C N T   - - - - - - - - - - - - - -   - - - - - - - - - -   A C C O U N T I N G                             3   R E S E A R C H                                 5   S A L E S                                       6   O P E R A T I O N S                             0  Oracle’s MODEL clause does not exist to transpose result sets; as a matter of fact, it would be quite accurate to say the application of the MODEL clause for pivoting would be a misuse and clearly not what the MODEL clause was intended for. Nevertheless, the MODEL clause provides for an interesting approach to a common problem. For this particular problem, you want to transform the following result set from this:  to this:  Solution Use aggregation and CASE expressions in the MODEL clause just as you would use them if pivoting with traditional techniques. The main difference in this case is that you use arrays to store the values of the aggregation and return the arrays in the result set:  s e l e c t   d e p t n o ,   c o u n t   *     c n t       f r o m   e m p     g r o u p   b y   d e p t n o     D E P T N O                 C N T   - - - - - -   - - - - - - - - - -           1 0                     3           2 0                     5           3 0                     6               D 1 0                 D 2 0                 D 3 0   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -                     3                     5                     6 s e l e c t   m a x   d 1 0     d 1 0 ,                 m a x   d 2 0     d 2 0 ,                 m a x   d 3 0     d 3 0       f r o m       s e l e c t   d 1 0 , d 2 0 , d 3 0       f r o m       s e l e c t   d e p t n o ,   c o u n t   *     c n t   f r o m   e m p   g r o u p   b y   d e p t n o         m o d e l       d i m e n s i o n   b y   d e p t n o   d           m e a s u r e s   d e p t n o ,   c n t   d 1 0 ,   c n t   d 2 0 ,   c n t   d 3 0           r u l e s               d 1 0 [ a n y ]   =   c a s e   w h e n   d e p t n o [ c v     ] = 1 0   t h e n   d 1 0 [ c v     ]   e l s e   0   e n d ,    Discussion The MODEL clause is a powerful addition to the Oracle SQL toolbox. Once you begin working with MODEL, you’ll notice helpful features such as iteration, array access to row values, the ability to “upsert” rows into a result set, and the ability to build reference models. You’ll quickly see that this recipe doesn’t take advantage of any of the cool features the MODEL clause offers, but it’s nice to be able to look at a problem from multiple angles and use different features in unexpected ways  if for no other reason than to learn where certain features are more useful than others . The first step to understanding the solution is to examine the inline view in the FROM clause. The inline view simply counts the number of employees in each DEPTNO in table EMP. The results are shown here:  This result set is what is given to MODEL to work with. Examining the MODEL clause, you see three subclauses that stand out: DIMENSION BY, MEASURES, and RULES. Let’s start with MEASURES. The items in the MEASURES list are simply the arrays you are declaring for this query. The query uses four arrays: DEPTNO, D10, D20, and D30. Like columns in a SELECT list, arrays in the MEASURES list can have aliases. As you can see, three of the four arrays are actually CNT from the inline view.            d 2 0 [ a n y ]   =   c a s e   w h e n   d e p t n o [ c v     ] = 2 0   t h e n   d 2 0 [ c v     ]   e l s e   0   e n d ,             d 3 0 [ a n y ]   =   c a s e   w h e n   d e p t n o [ c v     ] = 3 0   t h e n   d 3 0 [ c v     ]   e l s e   0   e n d                 s e l e c t   d e p t n o ,   c o u n t   *     c n t       f r o m   e m p     g r o u p   b y   d e p t n o     D E P T N O                 C N T   - - - - - -   - - - - - - - - - -           1 0                     3           2 0                     5           3 0                     6  If the MEASURES list contains our arrays, then the items in the DIMENSION BY subclause are the array indices. Consider this: array D10 is simply an alias for CNT. If you look at the result set for the previous inline view, you’ll see that CNT has three values: 3, 5, and 6. When you create an array of CNT, you are creating an array with three elements, namely, the three integers: 3, 5, and 6. Now, how do you access these values from the array individually? You use the array index. The index, defined in the DIMENSION BY subclause, has the values of 10, 20, and 30  from the result set above . So, for example, the following expression:  would evaluate to 3, as you are accessing the value for CNT in array D10 for DEPTNO 10  which is 3 . Because all three arrays  D10, D20, D30  contain the values from CNT, all three of them have the same results. How then do we get the proper count into the correct array? Enter the RULES subclause. If you look at the result set for the inline view shown earlier, you’ll see that the values for DEPTNO are 10, 20, and 30. The expressions involving CASE in the RULES clause simply evaluate each value in the DEPTNO array:  If the value is 10, store the CNT for DEPTNO 10 in D10[10] or else store 0. If the value is 20, store the CNT for DEPTNO 20 in D20[20] or else store 0. If the value is 30, store the CNT for DEPTNO 30 in D30[30] or else store 0.  If you find yourself feeling a bit like Alice tumbling down the rabbit hole, don’t worry; just stop and execute what’s been discussed thus far. The following result set represents what has been discussed. Sometimes it’s easier to read a bit, look at the code that actually performs what you just read, and then go back and read it again. The following is quite simple once you see it in action:  d 1 0 [ 1 0 ]  As you can see, the RULES subclause is what changed the values in each array. If you are still not catching on, simply execute the same query but comment out the expressions in the RULES subclass:  It should be clear now that the result set from the MODEL clause is the same as the inline view, except that the COUNT operation is aliased D10, D20, and D30. The following query proves this:  s e l e c t   d e p t n o ,   d 1 0 , d 2 0 , d 3 0       f r o m       s e l e c t   d e p t n o ,   c o u n t   *     c n t   f r o m   e m p   g r o u p   b y   d e p t n o         m o d e l       d i m e n s i o n   b y   d e p t n o   d           m e a s u r e s   d e p t n o ,   c n t   d 1 0 ,   c n t   d 2 0 ,   c n t   d 3 0           r u l e s               d 1 0 [ a n y ]   =   c a s e   w h e n   d e p t n o [ c v     ] = 1 0   t h e n   d 1 0 [ c v     ]   e l s e   0   e n d ,             d 2 0 [ a n y ]   =   c a s e   w h e n   d e p t n o [ c v     ] = 2 0   t h e n   d 2 0 [ c v     ]   e l s e   0   e n d ,             d 3 0 [ a n y ]   =   c a s e   w h e n   d e p t n o [ c v     ] = 3 0   t h e n   d 3 0 [ c v     ]   e l s e   0   e n d                 D E P T N O                 D 1 0                 D 2 0                 D 3 0       - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -               1 0                     3                     0                     0               2 0                     0                     5                     0               3 0                     0                     0                     6 s e l e c t   d e p t n o ,   d 1 0 , d 2 0 , d 3 0       f r o m       s e l e c t   d e p t n o ,   c o u n t   *     c n t   f r o m   e m p   g r o u p   b y   d e p t n o         m o d e l       d i m e n s i o n   b y   d e p t n o   d           m e a s u r e s   d e p t n o ,   c n t   d 1 0 ,   c n t   d 2 0 ,   c n t   d 3 0           r u l e s               *             d 1 0 [ a n y ]   =   c a s e   w h e n   d e p t n o [ c v     ] = 1 0   t h e n   d 1 0 [ c v     ]   e l s e   0   e n d ,             d 2 0 [ a n y ]   =   c a s e   w h e n   d e p t n o [ c v     ] = 2 0   t h e n   d 2 0 [ c v     ]   e l s e   0   e n d ,             d 3 0 [ a n y ]   =   c a s e   w h e n   d e p t n o [ c v     ] = 3 0   t h e n   d 3 0 [ c v     ]   e l s e   0   e n d           *                   D E P T N O                 D 1 0                 D 2 0                 D 3 0       - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -               1 0                     3                     3                     3               2 0                     5                     5                     5               3 0                     6                     6                     6  So, all the MODEL clause did was to take the values for DEPTNO and CNT, put them into arrays, and then make sure that each array represents a single DEPTNO. At this point, arrays D10, D20, and D30 each have a single nonzero value representing the CNT for a given DEPTNO. The result set is already transposed, and all that is left is to use the aggregate function MAX  you could have used MIN or SUM; it would make no difference in this case  to return only one row:  14.4 Extracting Elements of a String from Unfixed Locations  s e l e c t   d e p t n o ,   c o u n t   *     d 1 0 ,   c o u n t   *     d 2 0 ,   c o u n t   *     d 3 0       f r o m   e m p     g r o u p   b y   d e p t n o       D E P T N O                 D 1 0                 D 2 0                 D 3 0     - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -             1 0                     3                     3                     3             2 0                     5                     5                     5             3 0                     6                     6                     6 s e l e c t   m a x   d 1 0     d 1 0 ,                 m a x   d 2 0     d 2 0 ,                 m a x   d 3 0     d 3 0       f r o m       s e l e c t   d 1 0 , d 2 0 , d 3 0       f r o m       s e l e c t   d e p t n o ,   c o u n t   *     c n t   f r o m   e m p   g r o u p   b y   d e p t n o         m o d e l       d i m e n s i o n   b y   d e p t n o   d           m e a s u r e s   d e p t n o ,   c n t   d 1 0 ,   c n t   d 2 0 ,   c n t   d 3 0           r u l e s               d 1 0 [ a n y ]   =   c a s e   w h e n   d e p t n o [ c v     ] = 1 0   t h e n   d 1 0 [ c v     ]   e l s e   0   e n d ,             d 2 0 [ a n y ]   =   c a s e   w h e n   d e p t n o [ c v     ] = 2 0   t h e n   d 2 0 [ c v     ]   e l s e   0   e n d ,             d 3 0 [ a n y ]   =   c a s e   w h e n   d e p t n o [ c v     ] = 3 0   t h e n   d 3 0 [ c v     ]   e l s e   0   e n d                                       D 1 0                 D 2 0                 D 3 0       - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -                         3                     5                     6  Problem You have a string field that contains serialized log data. You want to parse through the string and extract the relevant information. Unfortunately, the relevant information is not at fixed points in the string. Instead, you must use the fact that certain characters exist around the information you need, to extract said information. For example, consider the following strings:  You want to extract the values between the square brackets, returning the following result set:  Solution Despite not knowing the exact locations within the string of the interesting values, you do know that they are located between square brackets [], and you know there are three of them. Use Oracle’s built-in function INSTR to find the locations of the brackets. Use the built-in function SUBSTR to extract the values from the string. View V will contain the strings to parse and is defined as follows  its use is strictly for readability :  x x x x x a b c [ 8 6 7 ] x x x [ - ] x x x x [ 5 3 0 9 ] x x x x x   x x x x x t i m e : [ 1 1 2 7 1 9 7 8 ] f a v n u m : [ 4 ] i d : [ J o e ] x x x x x   c a l l : [ F _ G E T _ R O W S     ] b 1 : [ R O S E W O O D … S I R ] b 2 : [ 4 4 4 0 0 0 0 2 ] 7 7 . 9 0 x x x x x   f i l m : [ n o n _ m a r k e d ] q q : [ u n i t ] t a i l p i p e : [ w i t h a b a n a n a ? ] 8 0 s x x x x x F I R S T _ V A L               S E C O N D _ V A L                     L A S T _ V A L   - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - -   8 6 7                           -                                       5 3 0 9   1 1 2 7 1 9 7 8                 4                                       J o e   F _ G E T _ R O W S           R O S E W O O D … S I R   4 4 4 0 0 0 0 2   n o n _ m a r k e d             u n i t                                 w i t h a b a n a n a ? c r e a t e   v i e w   V   a s   s e l e c t   ' x x x x x a b c [ 8 6 7 ] x x x [ - ] x x x x [ 5 3 0 9 ] x x x x x '   m s g           f r o m   d u a l         u n i o n   a l l       s e l e c t   ' x x x x x t i m e : [ 1 1 2 7 1 9 7 8 ] f a v n u m : [ 4 ] i d : [ J o e ] x x x x x '   m s g           f r o m   d u a l         u n i o n   a l l    Discussion Using Oracle’s built-in function INSTR makes this problem fairly simple to solve. Since you know the values you are after are enclosed in [], and that there are three sets of [], the first step to this solution is to simply use INSTR to find the numeric positions of [] in each string. The following example returns the numeric position of the opening and closing brackets in each row:  At this point, the hard work is done. All that is left is to plug the numeric positions into SUBSTR to parse MSG at those locations. You’ll notice that      s e l e c t   ' c a l l : [ F _ G E T _ R O W S     ] b 1 : [ R O S E W O O D … S I R ] b 2 : [ 4 4 4 0 0 0 0 2 ] 7 7 . 9 0 x x x x x '   m s g           f r o m   d u a l         u n i o n   a l l       s e l e c t   ' f i l m : [ n o n _ m a r k e d ] q q : [ u n i t ] t a i l p i p e : [ w i t h a b a n a n a ? ] 8 0 s x x x x x '   m s g           f r o m   d u a l       1   s e l e c t   s u b s t r   m s g ,     2                   i n s t r   m s g , ' [ ' , 1 , 1   + 1 ,     3                   i n s t r   m s g , ' ] ' , 1 , 1   - i n s t r   m s g , ' [ ' , 1 , 1   - 1     f i r s t _ v a l ,     4                 s u b s t r   m s g ,     5                   i n s t r   m s g , ' [ ' , 1 , 2   + 1 ,     6                   i n s t r   m s g , ' ] ' , 1 , 2   - i n s t r   m s g , ' [ ' , 1 , 2   - 1     s e c o n d _ v a l ,     7                 s u b s t r   m s g ,     8                   i n s t r   m s g , ' [ ' , - 1 , 1   + 1 ,     9                   i n s t r   m s g , ' ] ' , - 1 , 1   - i n s t r   m s g , ' [ ' , - 1 , 1   - 1     l a s t _ v a l   1 0     f r o m   V s e l e c t   i n s t r   m s g , ' [ ' , 1 , 1     " 1 s t _ [ " ,                                       i n s t r   m s g , ' ] ' , 1 , 1     " ] _ 1 s t " ,                                       i n s t r   m s g , ' [ ' , 1 , 2     " 2 n d _ [ " ,                                       i n s t r   m s g , ' ] ' , 1 , 2     " ] _ 2 n d " ,                                       i n s t r   m s g , ' [ ' , - 1 , 1     " 3 r d _ [ " ,                                       i n s t r   m s g , ' ] ' , - 1 , 1     " ] _ 3 r d "                             f r o m   V         1 s t _ [   ] _ 1 s t             2 n d _ [   ] _ 2 n d             3 r d _ [   ] _ 3 r d       - - - - - -   - - - - -   - - - - - - - - - -   - - - - -   - - - - - - - - - -   - - - - -                 9         1 3                   1 7         1 9                   2 4         2 9               1 1         2 0                   2 8         3 0                   3 4         3 8                 6         1 9                   2 3         3 8                   4 2         5 1                 6         1 7                   2 1         2 6                   3 6         4 9  in the complete solution there’s some simple arithmetic on the values returned by INSTR, particularly, +1 and –1; this is necessary to ensure the opening square bracket, [, is not returned in the final result set. Listed here is the solution less addition and subtraction of 1 on the return values from INSTR; notice how each value has a leading square bracket:  From the previous result set, you can see that the open bracket is there. You may be thinking: “OK, put the addition of 1 to INSTR back and the leading square bracket goes away. Why do we need to subtract 1?” The reason is this: if you put the addition back but leave out the subtraction, you end up including the closing square bracket, as shown here:  s e l e c t   s u b s t r   m s g ,                   i n s t r   m s g , ' [ ' , 1 , 1   ,                   i n s t r   m s g , ' ] ' , 1 , 1   - i n s t r   m s g , ' [ ' , 1 , 1       f i r s t _ v a l ,                 s u b s t r   m s g ,                   i n s t r   m s g , ' [ ' , 1 , 2   ,                   i n s t r   m s g , ' ] ' , 1 , 2   - i n s t r   m s g , ' [ ' , 1 , 2       s e c o n d _ v a l ,                 s u b s t r   m s g ,                   i n s t r   m s g , ' [ ' , - 1 , 1   ,                   i n s t r   m s g , ' ] ' , - 1 , 1   - i n s t r   m s g , ' [ ' , - 1 , 1       l a s t _ v a l       f r o m   V     F I R S T _ V A L               S E C O N D _ V A L                       L A S T _ V A L   - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - - - - - - -   - - - - - - -   [ 8 6 7                         [ -                                       [ 5 3 0 9   [ 1 1 2 7 1 9 7 8               [ 4                                       [ J o e   [ F _ G E T _ R O W S         [ R O S E W O O D … S I R   [ 4 4 4 0 0 0 0 2   [ n o n _ m a r k e d           [ u n i t                                 [ w i t h a b a n a n a ? s e l e c t   s u b s t r   m s g ,                   i n s t r   m s g , ' [ ' , 1 , 1   + 1 ,                   i n s t r   m s g , ' ] ' , 1 , 1   - i n s t r   m s g , ' [ ' , 1 , 1       f i r s t _ v a l ,         s u b s t r   m s g ,           i n s t r   m s g , ' [ ' , 1 , 2   + 1 ,           i n s t r   m s g , ' ] ' , 1 , 2   - i n s t r   m s g , ' [ ' , 1 , 2       s e c o n d _ v a l ,           s u b s t r   m s g ,           i n s t r   m s g , ' [ ' , - 1 , 1   + 1 ,           i n s t r   m s g , ' ] ' , - 1 , 1   - i n s t r   m s g , ' [ ' , - 1 , 1       l a s t _ v a l       f r o m   V     F I R S T _ V A L               S E C O N D _ V A L                       L A S T _ V A L    At this point it should be clear: to ensure you include neither of the square brackets, you must add one to the beginning index and subtract one from the ending index.  14.5 Finding the Number of Days in a Year  an Alternate Solution for Oracle   Problem You want to find the number of days in a year.  This recipe presents an alternative solution to “Determining the Number of Days in a Year” from Chapter 9. This solution is specific to Oracle.  TIP  Solution Use the TO_CHAR function to format the last date of the year into a three- digit day-of-the-year number:  - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - -             - - - - - - - - - - - - -   8 6 7 ]                         - ]                                       5 3 0 9 ]   1 1 2 7 1 9 7 8 ]               4 ]                                       J o e ]   F _ G E T _ R O W S     ]     R O S E W O O D … S I R ]     4 4 4 0 0 0 0 2 ]   n o n _ m a r k e d ]           u n i t ]                                 w i t h a b a n a n a ? ] 1   s e l e c t   ' D a y s   i n   2 0 2 1 :   '     2                 t o _ c h a r   a d d _ m o n t h s   t r u n c   s y s d a t e , ' y '   , 1 2   - 1 , ' D D D '     3                 a s   r e p o r t   4       f r o m   d u a l   5   u n i o n   a l l   6   s e l e c t   ' D a y s   i n   2 0 2 0 :   '     7                 t o _ c h a r   a d d _ m o n t h s   t r u n c     8                 t o _ d a t e   ' 0 1 - S E P - 2 0 2 0 '   , ' y '   , 1 2   - 1 , ' D D D '     9       f r o m   d u a l     R E P O R T    Discussion Begin by using the TRUNC function to return the first day of the year for the given date, as follows:  Next, use ADD_MONTHS to add one year  12 months  to the truncated date. Then subtract one day, bringing you to the end of the year in which your original date falls:  Now that you have found the last day in the year you are working with, simply use TO_CHAR to return a three-digit number representing on which day  1st, 50th, etc.  of the year the last day is:  - - - - - - - - - - - - - - - - -   D a y s   i n   2 0 2 1 :   3 6 5   D a y s   i n   2 0 2 0 :   3 6 6 s e l e c t   t r u n c   t o _ d a t e   ' 0 1 - S E P - 2 0 2 0 '   , ' y '         f r o m   d u a l     T R U N C   T O _ D A   - - - - - - - - - - -   0 1 - J A N - 2 0 2 0 s e l e c t   a d d _ m o n t h s                       t r u n c   t o _ d a t e   ' 0 1 - S E P - 2 0 2 0 '   , ' y '   ,                     1 2     b e f o r e _ s u b t r a c t i o n ,                 a d d _ m o n t h s                       t r u n c   t o _ d a t e   ' 0 1 - S E P - 2 0 2 0 '   , ' y '   ,                     1 2   - 1   a f t e r _ s u b t r a c t i o n       f r o m   d u a l     B E F O R E _ S U B T   A F T E R _ S U B T R   - - - - - - - - - - -   - - - - - - - - - - -   0 1 - J A N - 2 0 2 1   3 1 - D E C - 2 0 2 0 s e l e c t   t o _ c h a r                       a d d _ m o n t h s                           t r u n c   t o _ d a t e   ' 0 1 - S E P - 2 0 2 0 '   , ' y '   ,                         1 2   - 1 , ' D D D '     n u m _ d a y s _ i n _ 2 0 2 0       f r o m   d u a l      14.6 Searching for Mixed Alphanumeric Strings  Problem You have a column with mixed alphanumeric data. You want to return those rows that have both alphabetical and numeric characters; in other words, if a string has only number or only letters, do not return it. The return values should have a mix of both letters and numbers. Consider the following data:  The final result set should contain only those rows that have both letters and numbers:  Solution Use the built-in function TRANSLATE to convert each occurrence of a letter or digit into a specific character. Then keep only those strings that have at least one occurrence of both. The solution uses Oracle syntax, but both DB2 and PostgreSQL support TRANSLATE, so modifying the solution to work on those platforms should be trivial:  N U M   - - -   3 6 6 S T R I N G S   - - - - - - - - - - - -   1 0 1 0   s w i t c h   3 3 3   3 4 5 3 4 3 0 2 7 8   C l a s s S u m m a r y   f i n d R o w   5 5   t h r e e s S T R I N G S   - - - - - - - - - - - -   1 0 1 0   s w i t c h   f i n d R o w   5 5  As an alternative to the WITH clause, you may use an inline view or simply create a view.  TIP  Discussion The TRANSLATE function makes this problem extremely easy to solve. The first step is to use TRANSLATE to identify all letters and all digits by pound    and asterisk  *  characters, respectively. The intermediate results  from inline view X  are as follows:      w i t h   v   a s           s e l e c t   ' C l a s s S u m m a r y '   s t r i n g s   f r o m   d u a l   u n i o n       s e l e c t   ' 3 4 5 3 4 3 0 2 7 8 '                       f r o m   d u a l   u n i o n       s e l e c t   ' f i n d R o w   5 5 '                       f r o m   d u a l   u n i o n       s e l e c t   ' 1 0 1 0   s w i t c h '                     f r o m   d u a l   u n i o n       s e l e c t   ' 3 3 3 '                                     f r o m   d u a l   u n i o n       s e l e c t   ' t h r e e s '                               f r o m   d u a l               s e l e c t   s t r i n g s           f r o m           s e l e c t   s t r i n g s ,       t r a n s l a t e         s t r i n g s ,       ' a b c d e f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9 ' ,                         r p a d   '  ' , 2 6 , '  '     r p a d   ' * ' , 1 0 , ' * '       t r a n s l a t e d       f r o m   v       x   w h e r e i n s t r   t r a n s l a t e d , '  '     >   0   a n d   i n s t r   t r a n s l a t e d , ' * '     >   0 w i t h   v   a s       s e l e c t   ' C l a s s S u m m a r y '   s t r i n g s   f r o m   d u a l   u n i o n   s e l e c t   ' 3 4 5 3 4 3 0 2 7 8 '                       f r o m   d u a l   u n i o n   s e l e c t   ' f i n d R o w   5 5 '                       f r o m   d u a l   u n i o n   s e l e c t   ' 1 0 1 0   s w i t c h '                     f r o m   d u a l   u n i o n   s e l e c t   ' 3 3 3 '                                     f r o m   d u a l   u n i o n   s e l e c t   ' t h r e e s '                               f r o m   d u a l       s e l e c t   s t r i n g s ,                 t r a n s l a t e                       s t r i n g s ,                     ' a b c d e f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9 ' ,    At this point, it is only a matter of keeping those rows that have at least one instance each of  and *. Use the function INSTR to determine whether  and * are in a string. If those two characters are, in fact, present, then the value returned will be greater than zero. The final strings to return, along with their translated values, are shown next for clarity:                    r p a d   '  ' , 2 6 , '  '     r p a d   ' * ' , 1 0 , ' * '       t r a n s l a t e d       f r o m   v     S T R I N G S               T R A N S L A T E D   - - - - - - - - - - - - -   - - - - - - - - - - - -   1 0 1 0   s w i t c h       * * * *           3 3 3                       * * *   3 4 5 3 4 3 0 2 7 8         * * * * * * * * * *   C l a s s S u m m a r y     C     S         f i n d R o w   5 5             R     * *   t h r e e s                       w i t h   v   a s       s e l e c t   ' C l a s s S u m m a r y '   s t r i n g s   f r o m   d u a l   u n i o n   s e l e c t   ' 3 4 5 3 4 3 0 2 7 8 '                       f r o m   d u a l   u n i o n   s e l e c t   ' f i n d R o w   5 5 '                       f r o m   d u a l   u n i o n   s e l e c t   ' 1 0 1 0   s w i t c h '                     f r o m   d u a l   u n i o n   s e l e c t   ' 3 3 3 '                                     f r o m   d u a l   u n i o n   s e l e c t   ' t h r e e s '                               f r o m   d u a l       s e l e c t   s t r i n g s ,   t r a n s l a t e d       f r o m       s e l e c t   s t r i n g s ,                 t r a n s l a t e                       s t r i n g s ,                     ' a b c d e f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9 ' ,                     r p a d   '  ' , 2 6 , '  '     r p a d   ' * ' , 1 0 , ' * '       t r a n s l a t e d       f r o m   v                       w h e r e   i n s t r   t r a n s l a t e d , '  '     >   0         a n d   i n s t r   t r a n s l a t e d , ' * '     >   0     S T R I N G S             T R A N S L A T E D   - - - - - - - - - - - -   - - - - - - - - - - - -   1 0 1 0   s w i t c h     * * * *           f i n d R o w   5 5           R     * *  14.7 Converting Whole Numbers to Binary Using Oracle  Problem You want to convert a whole number to its binary representation on an Oracle system. For example, you would like to return all the salaries in table EMP in binary as part of the following result set:  Solution Because of MODEL’s ability to iterate and provide array access to row values, it is a natural choice for this operation  assuming you are forced to solve the problem in SQL, as a stored function is more appropriate here . Like the rest of the solutions in this book, even if you don’t find a practical application for this code, focus on the technique. It is useful to know that the MODEL clause can perform procedural tasks while still keeping SQL’s set-based nature and power. So, even if you find yourself saying, “I’d never do this in SQL,” that’s fine. We’re in no way suggesting you should or shouldn’t. We remind you to focus on the technique, so you can apply it to whatever you consider a more “practical” application.  E N A M E                 S A L   S A L _ B I N A R Y   - - - - - - - - - -   - - - - -   - - - - - - - - - - - - - - - - - - - -   S M I T H                 8 0 0   1 1 0 0 1 0 0 0 0 0   A L L E N               1 6 0 0   1 1 0 0 1 0 0 0 0 0 0   W A R D                 1 2 5 0   1 0 0 1 1 1 0 0 0 1 0   J O N E S               2 9 7 5   1 0 1 1 1 0 0 1 1 1 1 1   M A R T I N             1 2 5 0   1 0 0 1 1 1 0 0 0 1 0   B L A K E               2 8 5 0   1 0 1 1 0 0 1 0 0 0 1 0   C L A R K               2 4 5 0   1 0 0 1 1 0 0 1 0 0 1 0   S C O T T               3 0 0 0   1 0 1 1 1 0 1 1 1 0 0 0   K I N G                 5 0 0 0   1 0 0 1 1 1 0 0 0 1 0 0 0   T U R N E R             1 5 0 0   1 0 1 1 1 0 1 1 1 0 0   A D A M S               1 1 0 0   1 0 0 0 1 0 0 1 1 0 0   J A M E S                 9 5 0   1 1 1 0 1 1 0 1 1 0   F O R D                 3 0 0 0   1 0 1 1 1 0 1 1 1 0 0 0   M I L L E R             1 3 0 0   1 0 1 0 0 0 1 0 1 0 0  The following solution returns all ENAME and SAL from table EMP, while calling the MODEL clause in a scalar subquery  this way it serves as sort of a standalone function from table EMP that simply receives an input, processes it, and returns a value, much like a function would :  Discussion We mentioned in the “Solution” section that this problem is most likely better solved via a stored function. Indeed, the idea for this recipe came from a function. As a matter of fact, this recipe is an adaptation of a function called TO_BASE, written by Tom Kyte of Oracle Corporation. Like other recipes in this book that you may decide not to use, even if you do not use this recipe, it does a nice job of showing of some of the features of the MODEL clause such as iteration and array access of rows. To make the explanation easier, we focus on a slight variation of the subquery containing the MODEL clause. The code that follows is essentially the subquery from the solution, except that it’s been hardwired to return the value 2 in binary:    1   s e l e c t   e n a m e ,     2                 s a l ,     3                       4                 s e l e c t   b i n     5                     f r o m   d u a l     6                   m o d e l     7                   d i m e n s i o n   b y       0   a t t r         8                   m e a s u r e s       s a l   n u m ,     9                                         c a s t   n u l l   a s   v a r c h a r 2   3 0       b i n ,   1 0                                       ' 0 1 2 3 4 5 6 7 8 9 A B C D E F '   h e x   1 1                                         1 2                   r u l e s   i t e r a t e     1 0 0 0 0     u n t i l     n u m [ 0 ]   < =   0         1 3                       b i n [ 0 ]   =   s u b s t r   h e x [ c v     ] , m o d   n u m [ c v     ] , 2   + 1 , 1     b i n [ c v     ] ,   1 4                       n u m [ 0 ]   =   t r u n c   n u m [ c v     ]   2     1 5                       1 6                     s a l _ b i n a r y   1 7       f r o m   e m p s e l e c t   b i n       f r o m   d u a l     m o d e l    The following query outputs the values returned from one iteration of the RULES defined in the previous query:  START_VAL represents the number you want to convert to binary, which in this case is 2. The value for BIN is the result of a substring operation on 0123456789ABCDEF  HEX, in the original solution . The value for NUM is the test that will determine when you exit the loop. As you can see from the preceding result set, the first time through the loop BIN is 0 and NUM is 1. Because NUM is not less than or equal to 0, another loop iteration occurs. The following SQL statement shows the results of the next iteration:    d i m e n s i o n   b y       0   a t t r         m e a s u r e s       2   n u m ,                           c a s t   n u l l   a s   v a r c h a r 2   3 0       b i n ,                           ' 0 1 2 3 4 5 6 7 8 9 A B C D E F '   h e x                             r u l e s   i t e r a t e     1 0 0 0 0     u n t i l     n u m [ 0 ]   < =   0               b i n [ 0 ]   =   s u b s t r     h e x [ c v     ] , m o d   n u m [ c v     ] , 2   + 1 , 1     b i n [ c v     ] ,         n u m [ 0 ]   =   t r u n c   n u m [ c v     ]   2             B I N   - - - - - - - - - -   1 0 s e l e c t   2   s t a r t _ v a l ,                 ' 0 1 2 3 4 5 6 7 8 9 A B C D E F '   h e x ,                 s u b s t r   ' 0 1 2 3 4 5 6 7 8 9 A B C D E F ' , m o d   2 , 2   + 1 , 1                       c a s t   n u l l   a s   v a r c h a r 2   3 0       b i n ,                 t r u n c   2   2     n u m       f r o m   d u a l     S T A R T _ V A L   H E X                             B I N                 N U M   - - - - - - - - -   - - - - - - - - - - - - - - - -   - - - - - - - - - -   - - -                   2   0 1 2 3 4 5 6 7 8 9 A B C D E F   0                         1 s e l e c t   n u m   s t a r t _ v a l ,                 s u b s t r   ' 0 1 2 3 4 5 6 7 8 9 A B C D E F ' , m o d   1 , 2   + 1 , 1         b i n   b i n ,                 t r u n c   1   2     n u m       f r o m       s e l e c t   2   s t a r t _ v a l ,    The next time through the loop, the result of the substring operation on HEX returns 1, and the prior value of BIN, 0, is appended to it. The test, NUM, is now 0; thus, this is the last iteration, and the return value “10” is the binary representation of the number 2. Once you’re comfortable with what’s going on, you can remove the iteration from the MODEL clause and step through it row by row to follow how the rules are applied to come to the final result set, as is shown here:  14.8 Pivoting a Ranked Result Set                ' 0 1 2 3 4 5 6 7 8 9 A B C D E F '   h e x ,                 s u b s t r   ' 0 1 2 3 4 5 6 7 8 9 A B C D E F ' , m o d   2 , 2   + 1 , 1                       c a s t   n u l l   a s   v a r c h a r 2   3 0       b i n ,                 t r u n c   2   2     n u m       f r o m   d u a l                       S T A R T _ V A L   B I N                 N U M   - - - - - - - - -   - - - - - - - - - -   - - -                   1   1 0                       0 s e l e c t   2   o r i g _ v a l ,   n u m ,   b i n       f r o m   d u a l     m o d e l     d i m e n s i o n   b y       0   a t t r         m e a s u r e s       2   n u m ,                           c a s t   n u l l   a s   v a r c h a r 2   3 0       b i n ,                         ' 0 1 2 3 4 5 6 7 8 9 A B C D E F '   h e x                             r u l e s             b i n [ 0 ]   =   s u b s t r     h e x [ c v     ] , m o d   n u m [ c v     ] , 2   + 1 , 1     b i n [ c v     ] ,         n u m [ 0 ]   =   t r u n c   n u m [ c v     ]   2   ,         b i n [ 1 ]   =   s u b s t r     h e x [ 0 ] , m o d   n u m [ 0 ] , 2   + 1 , 1     b i n [ 0 ] ,         n u m [ 1 ]   =   t r u n c   n u m [ 0 ]   2             O R I G _ V A L   N U M   B I N   - - - - - - - -   - - -   - - - - - - - - -                 2       1   0                 2       0   1 0  Problem You want to rank the values in a table and then pivot the result set into three columns. The idea is to show the top three, the next three, and then all the rest. For example, you want to rank the employees in table EMP by SAL and then pivot the results into three columns. The desired result set is as follows:  Solution The key to this solution is to first use the window function DENSE_RANK OVER to rank the employees by SAL while allowing for ties. By using DENSE_RANK OVER, you can easily see the top three salaries, the next three salaries, and then all the rest. Next, use the window function ROW_NUMBER OVER to rank each employee within their group  the top three, next three, or last group . From there, simply perform a classic transpose, while using the built-in string functions available on your platform to beautify the results. The following solution uses Oracle syntax. Since all vendors now support window functions, converting the solution to work for other platforms is trivial:  T O P _ 3                       N E X T _ 3                     R E S T   - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - -   - - - - - - - - - - - - - -   K I N G           5 0 0 0       B L A K E         2 8 5 0       T U R N E R     1 5 0 0     F O R D           3 0 0 0       C L A R K         2 4 5 0       M I L L E R     1 3 0 0     S C O T T         3 0 0 0       A L L E N         1 6 0 0       M A R T I N     1 2 5 0     J O N E S         2 9 7 5                                       W A R D         1 2 5 0                                                                     A D A M S       1 1 0 0                                                                     J A M E S       9 5 0                                                                     S M I T H       8 0 0     1   s e l e c t   m a x   c a s e   g r p   w h e n   1   t h e n   r p a d   e n a m e , 6           2                                           '     '     s a l     '   '   e n d     t o p _ 3 ,     3               m a x   c a s e   g r p   w h e n   2   t h e n   r p a d   e n a m e , 6           4                                         '     '     s a l     '   '   e n d     n e x t _ 3 ,     5               m a x   c a s e   g r p   w h e n   3   t h e n   r p a d   e n a m e , 6           6                                           '     '     s a l     '   '   e n d     r e s t     7       f r o m         8   s e l e c t   e n a m e ,     9                 s a l ,    Discussion This recipe is a perfect example of how much you can accomplish with so little, with the help of window functions. The solution may look involved, but as you break it down from inside out, you will be surprised how simple it is. Let’s begin by executing inline view X first:  1 0                 r n k ,   1 1                 c a s e   w h e n   r n k   < =   3   t h e n   1   1 2                           w h e n   r n k   < =   6   t h e n   2   1 3                           e l s e                                     3   1 4                 e n d   g r p ,   1 5                 r o w _ n u m b e r     o v e r       1 6                     p a r t i t i o n   b y   c a s e   w h e n   r n k   < =   3   t h e n   1   1 7                                                         w h e n   r n k   < =   6   t h e n   2   1 8                                                         e l s e                                   3   1 9                                               e n d   2 0                             o r d e r   b y   s a l   d e s c ,   e n a m e   2 1                     g r p _ r n k   2 2       f r o m       2 3   s e l e c t   e n a m e ,   2 4                 s a l ,   2 5                 d e n s e _ r a n k     o v e r   o r d e r   b y   s a l   d e s c     r n k   2 6       f r o m   e m p   2 7                     x   2 8                     y   2 9     g r o u p   b y   g r p _ r n k s e l e c t   e n a m e ,                 s a l ,                 d e n s e _ r a n k     o v e r   o r d e r   b y   s a l   d e s c     r n k       f r o m   e m p     E N A M E                 S A L                 R N K   - - - - - - - - - -   - - - - -   - - - - - - - - - -   K I N G                 5 0 0 0                     1   S C O T T               3 0 0 0                     2   F O R D                 3 0 0 0                     2   J O N E S               2 9 7 5                     3   B L A K E               2 8 5 0                     4   C L A R K               2 4 5 0                     5   A L L E N               1 6 0 0                     6   T U R N E R             1 5 0 0                     7   M I L L E R             1 3 0 0                     8   W A R D                 1 2 5 0                     9    As you can see from the previous result set, inline view X simply ranks the employees by SAL, while allowing for ties  because the solution uses DENSE_RANK instead of RANK, there are ties without gaps . The next step is to take the rows from inline view X and create groups by using a CASE expression to evaluate the ranking from DENSE_RANK. Additionally, use the window function ROW_NUMBER OVER to rank the employees by SAL within their group  within the group you are creating with the CASE expression . All of this happens in inline view Y and is shown here:  M A R T I N             1 2 5 0                     9   A D A M S               1 1 0 0                   1 0   J A M E S                 9 5 0                   1 1   S M I T H                 8 0 0                   1 2 s e l e c t   e n a m e ,                 s a l ,                 r n k ,                 c a s e   w h e n   r n k   < =   3   t h e n   1                           w h e n   r n k   < =   6   t h e n   2                           e l s e                                     3                 e n d   g r p ,                 r o w _ n u m b e r     o v e r                         p a r t i t i o n   b y   c a s e   w h e n   r n k   < =   3   t h e n   1                                                         w h e n   r n k   < =   6   t h e n   2                                                         e l s e                                     3                                                 e n d                             o r d e r   b y   s a l   d e s c ,   e n a m e                     g r p _ r n k       f r o m       s e l e c t   e n a m e ,                 s a l ,                 d e n s e _ r a n k     o v e r   o r d e r   b y   s a l   d e s c     r n k       f r o m   e m p                     x       E N A M E                 S A L     R N K     G R P   G R P _ R N K   - - - - - - - - - -   - - - - -   - - - -   - - - -   - - - - - - -   K I N G                 5 0 0 0         1         1               1   F O R D                 3 0 0 0         2         1               2   S C O T T               3 0 0 0         2         1               3   J O N E S               2 9 7 5         3         1               4    Now the query is starting to take shape, and if you followed it from the beginning  from inline view X , you can see that it’s not that complicated. The query so far returns each employee; their SAL; their RNK, which represents where their SAL ranks among all employees; their GRP, which indicates the group each employee is in  based on SAL ; and finally GRP_RANK, which is a ranking  based on SAL  within their GRP. At this point, perform a traditional pivot on ENAME while using the Oracle concatenation operator  to append the SAL. The function RPAD ensures that the numeric values in parentheses line up nicely. Finally, use GROUP BY on GRP_RNK to ensure you show each employee in the result set. The final result set is shown here:  B L A K E               2 8 5 0         4         2               1   C L A R K               2 4 5 0         5         2               2   A L L E N               1 6 0 0         6         2               3   T U R N E R             1 5 0 0         7         3               1   M I L L E R             1 3 0 0         8         3               2   M A R T I N             1 2 5 0         9         3               3   W A R D                 1 2 5 0         9         3               4   A D A M S               1 1 0 0       1 0         3               5   J A M E S                 9 5 0       1 1         3               6   S M I T H                 8 0 0       1 2         3               7 s e l e c t   m a x   c a s e   g r p   w h e n   1   t h e n   r p a d   e n a m e , 6                                                 '     '     s a l     '   '   e n d     t o p _ 3 ,                 m a x   c a s e   g r p   w h e n   2   t h e n   r p a d   e n a m e , 6                                                 '     '     s a l     '   '   e n d     n e x t _ 3 ,                 m a x   c a s e   g r p   w h e n   3   t h e n   r p a d   e n a m e , 6                                                 '     '     s a l     '   '   e n d     r e s t       f r o m       s e l e c t   e n a m e ,                 s a l ,                 r n k ,                 c a s e   w h e n   r n k   < =   3   t h e n   1                           w h e n   r n k   < =   6   t h e n   2                           e l s e                                       3                 e n d   g r p ,                 r o w _ n u m b e r     o v e r                         p a r t i t i o n   b y   c a s e   w h e n   r n k   < =   3   t h e n   1                                                         w h e n   r n k   < =   6   t h e n   2                                                         e l s e                                     3                                                 e n d    If you examine the queries in all of the steps, you’ll notice that table EMP is accessed exactly once. One of the remarkable things about window functions is how much work you can do in just one pass through your data. There’s no need for self-joins or temp tables; just get the rows you need and then let the window functions do the rest. Only in inline view X do you need to access EMP. From there, it’s simply a matter of massaging the result set to look the way you want. Consider what all this means for performance if you can create this type of report with a single table access. Pretty cool.  14.9 Adding a Column Header into a Double Pivoted Result Set  Problem You want to stack two result sets and then pivot them into two columns. Additionally, you want to add a “header” for each group of rows in each column. For example, you have two tables containing information about                            O r d e r   b y   s a l   d e s c ,   e n a m e                     g r p _ r n k       f r o m       s e l e c t   e n a m e ,                 s a l ,                 d e n s e _ r a n k     o v e r   o r d e r   b y   s a l   d e s c     r n k       f r o m   e m p                     x                     y   g r o u p   b y   g r p _ r n k     T O P _ 3                       N E X T _ 3                     R E S T   - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - -   - - - - - - - - - - - - -   K I N G           5 0 0 0       B L A K E         2 8 5 0       T U R N E R     1 5 0 0     F O R D           3 0 0 0       C L A R K         2 4 5 0       M I L L E R     1 3 0 0     S C O T T         3 0 0 0       A L L E N         1 6 0 0       M A R T I N     1 2 5 0     J O N E S         2 9 7 5                                       W A R D         1 2 5 0     A D A M S       1 1 0 0                                                                     J A M E S         9 5 0                                                                     S M I T H         8 0 0    employees working in different areas of development in your company  say, in research and applications :  You would like to create a report listing the employees from each table in two columns. You want to return the DEPTNO followed by ENAME for each. Ultimately, you want to return the following result set:  s e l e c t   *   f r o m   i t _ r e s e a r c h     D E P T N O   E N A M E   - - - - - -   - - - - - - - - - - - - - - - - - - - -         1 0 0   H O P K I N S         1 0 0   J O N E S         1 0 0   T O N E Y         2 0 0   M O R A L E S         2 0 0   P . W H I T A K E R         2 0 0   M A R C I A N O         2 0 0   R O B I N S O N         3 0 0   L A C Y         3 0 0   W R I G H T         3 0 0   J . T A Y L O R       s e l e c t   *   f r o m   i t _ a p p s     D E P T N O   E N A M E   - - - - - -   - - - - - - - - - - - - - - - - -         4 0 0   C O R R A L E S         4 0 0   M A Y W E A T H E R         4 0 0   C A S T I L L O         4 0 0   M A R Q U E Z         4 0 0   M O S L E Y         5 0 0   G A T T I         5 0 0   C A L Z A G H E         6 0 0   L A M O T T A         6 0 0   H A G L E R         6 0 0   H E A R N S         6 0 0   F R A Z I E R         7 0 0   G U I N N         7 0 0   J U D A H         7 0 0   M A R G A R I T O R E S E A R C H                           A P P S   - - - - - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - -    Solution For the most part, this solution requires nothing more than a simple stack ’n’ pivot  union then pivot  with an added twist: the DEPTNO must precede the ENAME for each employee returned. The technique here uses a Cartesian product to generate an extra row for each DEPTNO, so you have the required rows necessary to show all employees, plus room for the DEPTNO. The solution uses Oracle syntax, but since DB2 supports window functions that can compute moving windows  the framing clause , converting this solution to work for DB2 is trivial. Because the IT_ RESEARCH and IT_APPS tables exist only for this recipe, their table creation statements are shown along with this solution:  1 0 0                                     4 0 0       J O N E S                                 M A Y W E A T H E R       T O N E Y                                 C A S T I L L O       H O P K I N S                             M A R Q U E Z   2 0 0                                         M O S L E Y       P . W H I T A K E R                       C O R R A L E S       M A R C I A N O                       5 0 0       R O B I N S O N                           C A L Z A G H E       M O R A L E S                             G A T T I   3 0 0                                     6 0 0       W R I G H T                               H A G L E R       J . T A Y L O R                           H E A R N S       L A C Y                                   F R A Z I E R                                                 L A M O T T A                                             7 0 0                                                 J U D A H                                                 M A R G A R I T O                                                 G U I N N c r e a t e   t a b l e   I T _ r e s e a r c h     d e p t n o   n u m b e r ,   e n a m e   v a r c h a r 2   2 0         i n s e r t   i n t o   I T _ r e s e a r c h   v a l u e s     1 0 0 , ' H O P K I N S '     i n s e r t   i n t o   I T _ r e s e a r c h   v a l u e s     1 0 0 , ' J O N E S '     i n s e r t   i n t o   I T _ r e s e a r c h   v a l u e s     1 0 0 , ' T O N E Y '     i n s e r t   i n t o   I T _ r e s e a r c h   v a l u e s     2 0 0 , ' M O R A L E S '     i n s e r t   i n t o   I T _ r e s e a r c h   v a l u e s     2 0 0 , ' P . W H I T A K E R '     i n s e r t   i n t o   I T _ r e s e a r c h   v a l u e s     2 0 0 , ' M A R C I A N O '     i n s e r t   i n t o   I T _ r e s e a r c h   v a l u e s     2 0 0 , ' R O B I N S O N '     i n s e r t   i n t o   I T _ r e s e a r c h   v a l u e s     3 0 0 , ' L A C Y '     i n s e r t   i n t o   I T _ r e s e a r c h   v a l u e s     3 0 0 , ' W R I G H T '      i n s e r t   i n t o   I T _ r e s e a r c h   v a l u e s     3 0 0 , ' J . T A Y L O R '         c r e a t e   t a b l e   I T _ a p p s     d e p t n o   n u m b e r ,   e n a m e   v a r c h a r 2   2 0         i n s e r t   i n t o   I T _ a p p s   v a l u e s     4 0 0 , ' C O R R A L E S '     i n s e r t   i n t o   I T _ a p p s   v a l u e s     4 0 0 , ' M A Y W E A T H E R '     i n s e r t   i n t o   I T _ a p p s   v a l u e s     4 0 0 , ' C A S T I L L O '     i n s e r t   i n t o   I T _ a p p s   v a l u e s     4 0 0 , ' M A R Q U E Z '     i n s e r t   i n t o   I T _ a p p s   v a l u e s     4 0 0 , ' M O S L E Y '     i n s e r t   i n t o   I T _ a p p s   v a l u e s     5 0 0 , ' G A T T I '     i n s e r t   i n t o   I T _ a p p s   v a l u e s     5 0 0 , ' C A L Z A G H E '     i n s e r t   i n t o   I T _ a p p s   v a l u e s     6 0 0 , ' L A M O T T A '     i n s e r t   i n t o   I T _ a p p s   v a l u e s     6 0 0 , ' H A G L E R '     i n s e r t   i n t o   I T _ a p p s   v a l u e s     6 0 0 , ' H E A R N S '     i n s e r t   i n t o   I T _ a p p s   v a l u e s     6 0 0 , ' F R A Z I E R '     i n s e r t   i n t o   I T _ a p p s   v a l u e s     7 0 0 , ' G U I N N '     i n s e r t   i n t o   I T _ a p p s   v a l u e s     7 0 0 , ' J U D A H '     i n s e r t   i n t o   I T _ a p p s   v a l u e s     7 0 0 , ' M A R G A R I T O '           1   s e l e c t   m a x   d e c o d e   f l a g 2 , 0 , i t _ d e p t       r e s e a r c h ,     2                 m a x   d e c o d e   f l a g 2 , 1 , i t _ d e p t       a p p s     3       f r o m         4   s e l e c t   s u m   f l a g 1   o v e r   p a r t i t i o n   b y   f l a g 2     5                                                       o r d e r   b y   f l a g 1 , r o w n u m     f l a g ,     6                 i t _ d e p t ,   f l a g 2     7       f r o m         8   s e l e c t   1   f l a g 1 ,   0   f l a g 2 ,     9                 d e c o d e   r n , 1 , t o _ c h a r   d e p t n o   , '   '   e n a m e     i t _ d e p t   1 0       f r o m       1 1   s e l e c t   x . * ,   y . i d ,   1 2                 r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   x . d e p t n o   o r d e r   b y   y . i d     r n   1 3       f r o m       1 4   s e l e c t   d e p t n o ,   1 5                 e n a m e ,   1 6                 c o u n t   *   o v e r   p a r t i t i o n   b y   d e p t n o     c n t   1 7       f r o m   i t _ r e s e a r c h   1 8                     x ,   1 9                   s e l e c t   l e v e l   i d   f r o m   d u a l   c o n n e c t   b y   l e v e l   < =   2     y   2 0                     2 1     w h e r e   r n   < =   c n t + 1   2 2   u n i o n   a l l   2 3   s e l e c t   1   f l a g 1 ,   1   f l a g 2 ,   2 4                 d e c o d e   r n , 1 , t o _ c h a r   d e p t n o   , '   '   e n a m e     i t _ d e p t   2 5       f r o m       2 6   s e l e c t   x . * ,   y . i d ,   2 7                 r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   x . d e p t n o   o r d e r   b y   y . i d     r n    Discussion Like many of the other warehousing report type queries, the solution presented looks quite convoluted, but once broken down, you’ll seen it’s nothing more than a stack ’n’ pivot with a Cartesian twist  on the rocks, with a little umbrella . The way to break down this query is to work on each part of the UNION ALL first and then bring it together for the pivot. Let’s start with the lower portion of the UNION ALL:  _       p y p y y   2 8       f r o m       2 9   s e l e c t   d e p t n o ,   3 0                 e n a m e ,   3 1                 c o u n t   *   o v e r   p a r t i t i o n   b y   d e p t n o     c n t   3 2       f r o m   i t _ a p p s   3 3                     x ,   3 4                   s e l e c t   l e v e l   i d   f r o m   d u a l   c o n n e c t   b y   l e v e l   < =   2     y   3 5                     3 6     w h e r e   r n   < =   c n t + 1   3 7                     t m p 1   3 8                     t m p 2   3 9     g r o u p   b y   f l a g s e l e c t   1   f l a g 1 ,   1   f l a g 2 ,                 d e c o d e   r n , 1 , t o _ c h a r   d e p t n o   , '   '   e n a m e     i t _ d e p t       f r o m       s e l e c t   x . * ,   y . i d ,                 r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   x . d e p t n o   o r d e r   b y   y . i d     r n       f r o m       s e l e c t   d e p t n o ,                 e n a m e ,                 c o u n t   *   o v e r   p a r t i t i o n   b y   d e p t n o     c n t       f r o m   i t _ a p p s                     x ,                   s e l e c t   l e v e l   i d   f r o m   d u a l   c o n n e c t   b y   l e v e l   < =   2     y                     z     w h e r e   r n   < =   c n t + 1     F L A G 1             F L A G 2   I T _ D E P T   - - - - -   - - - - - - - - - -   - - - - - - - - - - - - - - - - - - - - - - - - - -           1                     1   4 0 0           1                     1       M A Y W E A T H E R           1                     1       C A S T I L L O           1                     1       M A R Q U E Z           1                     1       M O S L E Y    Let’s examine exactly how that result set is put together. Breaking down the previous query to its simplest components, you have inline view X, which simply returns each ENAME and DEPTNO and the number of employees in each DEPTNO from table IT_APPS. The results are as follows:  The next step is to create a Cartesian product between the rows returned from inline view X and two rows generated from DUAL using CONNECT BY. The results of this operation are as follows:          1                     1       C O R R A L E S           1                     1   5 0 0           1                     1       C A L Z A G H E           1                     1       G A T T I           1                     1   6 0 0           1                     1       H A G L E R           1                     1       H E A R N S           1                     1       F R A Z I E R           1                     1       L A M O T T A           1                     1   7 0 0           1                     1       J U D A H           1                     1       M A R G A R I T O           1                     1       G U I N N s e l e c t   d e p t n o   d e p t n o ,                 e n a m e ,                 c o u n t   *   o v e r   p a r t i t i o n   b y   d e p t n o     c n t       f r o m   i t _ a p p s     D E P T N O   E N A M E                                               C N T   - - - - - -   - - - - - - - - - - - - - - - - - - - -   - - - - - - - - - -         4 0 0   C O R R A L E S                                             5         4 0 0   M A Y W E A T H E R                                         5         4 0 0   C A S T I L L O                                             5         4 0 0   M A R Q U E Z                                               5         4 0 0   M O S L E Y                                                 5         5 0 0   G A T T I                                                   2         5 0 0   C A L Z A G H E                                             2         6 0 0   L A M O T T A                                               4         6 0 0   H A G L E R                                                 4         6 0 0   H E A R N S                                                 4         6 0 0   F R A Z I E R                                               4         7 0 0   G U I N N                                                   3         7 0 0   J U D A H                                                   3         7 0 0   M A R G A R I T O                                           3  As you can see from these results, each row from inline view X is now returned twice due to the Cartesian product with inline view Y. The reason a Cartesian is needed will become clear shortly. The next step is to take the current result set and rank each employee within his DEPTNO by ID  ID  s e l e c t   *       f r o m       s e l e c t   d e p t n o   d e p t n o ,                 e n a m e ,                 c o u n t   *   o v e r   p a r t i t i o n   b y   d e p t n o     c n t       f r o m   i t _ a p p s                     x ,                   s e l e c t   l e v e l   i d   f r o m   d u a l   c o n n e c t   b y   l e v e l   < =   2     y     o r d e r   b y   2     D E P T N O   E N A M E             C N T     I D   - - - - - -   - - - - - - - - - -   - - -   - - -         5 0 0   C A L Z A G H E           2       1         5 0 0   C A L Z A G H E           2       2         4 0 0   C A S T I L L O           5       1         4 0 0   C A S T I L L O           5       2         4 0 0   C O R R A L E S           5       1         4 0 0   C O R R A L E S           5       2         6 0 0   F R A Z I E R             4       1         6 0 0   F R A Z I E R             4       2         5 0 0   G A T T I                 2       1         5 0 0   G A T T I                 2       2         7 0 0   G U I N N                 3       1         7 0 0   G U I N N                 3       2         6 0 0   H A G L E R               4       1         6 0 0   H A G L E R               4       2         6 0 0   H E A R N S               4       1         6 0 0   H E A R N S               4       2         7 0 0   J U D A H                 3       1         7 0 0   J U D A H                 3       2         6 0 0   L A M O T T A             4       1         6 0 0   L A M O T T A             4       2         7 0 0   M A R G A R I T O         3       1         7 0 0   M A R G A R I T O         3       2         4 0 0   M A R Q U E Z             5       1         4 0 0   M A R Q U E Z             5       2         4 0 0   M A Y W E A T H E R       5       1         4 0 0   M A Y W E A T H E R       5       2         4 0 0   M O S L E Y               5       1         4 0 0   M O S L E Y               5       2  has a value of 1 or 2 as was returned by the Cartesian product . The result of this ranking is shown in the output from the following query:  s e l e c t   x . * ,   y . i d ,                 r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   x . d e p t n o   o r d e r   b y   y . i d     r n       f r o m       s e l e c t   d e p t n o   d e p t n o ,                 e n a m e ,                 c o u n t   *   o v e r   p a r t i t i o n   b y   d e p t n o     c n t       f r o m   i t _ a p p s                     x ,                   s e l e c t   l e v e l   i d   f r o m   d u a l   c o n n e c t   b y   l e v e l   < =   2     y     D E P T N O   E N A M E             C N T   I D                     R N   - - - - - -   - - - - - - - - - -   - - -   - - -   - - - - - - - - - -         4 0 0   C O R R A L E S           5       1                     1         4 0 0   M A Y W E A T H E R       5       1                     2         4 0 0   C A S T I L L O           5       1                     3         4 0 0   M A R Q U E Z             5       1                     4         4 0 0   M O S L E Y               5       1                     5         4 0 0   C O R R A L E S           5       2                     6         4 0 0   M O S L E Y               5       2                     7         4 0 0   M A Y W E A T H E R       5       2                     8         4 0 0   C A S T I L L O           5       2                     9         4 0 0   M A R Q U E Z             5       2                   1 0         5 0 0   G A T T I                 2       1                     1         5 0 0   C A L Z A G H E           2       1                     2         5 0 0   G A T T I                 2       2                     3         5 0 0   C A L Z A G H E           2       2                     4         6 0 0   L A M O T T A             4       1                     1         6 0 0   H A G L E R               4       1                     2         6 0 0   H E A R N S               4       1                     3         6 0 0   F R A Z I E R             4       1                     4         6 0 0   L A M O T T A             4       2                     5         6 0 0   H A G L E R               4       2                     6         6 0 0   F R A Z I E R             4       2                     7         6 0 0   H E A R N S               4       2                     8         7 0 0   G U I N N                 3       1                     1         7 0 0   J U D A H                 3       1                     2         7 0 0   M A R G A R I T O         3       1                     3         7 0 0   G U I N N                 3       2                     4         7 0 0   J U D A H                 3       2                     5         7 0 0   M A R G A R I T O         3       2                     6  Each employee is ranked; then his duplicate is ranked. The result set contains duplicates for all employees in table IT_APP, along with their ranking within their DEPTNO. The reason you need to generate these extra rows is because you need a slot in the result set to slip in the DEPTNO in the ENAME column. If you Cartesian-join IT_APPS with a one-row table, you get no extra rows  because cardinality of any table × 1 = cardinality of that table . The next step is to take the results returned thus far and pivot the result set such that all the ENAMEs are returned in one column but are preceded by the DEPTNO they are in. The following query shows how this happens:  s e l e c t   1   f l a g 1 ,   1   f l a g 2 ,                 d e c o d e   r n , 1 , t o _ c h a r   d e p t n o   , '   '   e n a m e     i t _ d e p t       f r o m       s e l e c t   x . * ,   y . i d ,                 r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   x . d e p t n o   o r d e r   b y   y . i d     r n       f r o m       s e l e c t   d e p t n o   d e p t n o ,                 e n a m e ,                 c o u n t   *   o v e r   p a r t i t i o n   b y   d e p t n o     c n t       f r o m   i t _ a p p s                     x ,                   s e l e c t   l e v e l   i d   f r o m   d u a l   c o n n e c t   b y   l e v e l   < =   2     y                     z     w h e r e   r n   < =   c n t + 1     F L A G 1             F L A G 2   I T _ D E P T   - - - - -   - - - - - - - - - -   - - - - - - - - - - - - - - - - - - - - - - - - -           1                     1   4 0 0           1                     1       M A Y W E A T H E R           1                     1       C A S T I L L O           1                     1       M A R Q U E Z           1                     1       M O S L E Y           1                     1       C O R R A L E S           1                     1   5 0 0           1                     1       C A L Z A G H E           1                     1       G A T T I           1                     1   6 0 0           1                     1       H A G L E R           1                     1       H E A R N S           1                     1       F R A Z I E R           1                     1       L A M O T T A           1                     1   7 0 0    FLAG1 and FLAG2 come into play later and can be ignored for the moment. Focus your attention on the rows in IT_DEPT. The number of rows returned for each DEPTNO is CNT*2, but all that is needed is CNT+1, which is the filter in the WHERE clause. RN is the ranking for each employee. The rows kept are all those ranked less than or equal to CNT+1; i.e., all employees in each DEPTNO plus one more  this extra employee is the employee who is ranked first in their DEPTNO . This extra row is where the DEPTNO will slide in. By using DECODE  an older Oracle function that gives more or less the equivalent of a CASE expression  to evaluate the value of RN, you can slide the value of DEPTNO into the result set. The employee who was at position one  based on the value of RN  is still shown in the result set, but is now last in each DEPTNO  because the order is irrelevant, this is not a problem . That pretty much covers the lower part of the UNION ALL. The upper part of the UNION ALL is processed in the same way as the lower part, so there’s no need to explain how that works. Instead, let’s examine the result set returned when stacking the queries:          1                     1       J U D A H           1                     1       M A R G A R I T O           1                     1       G U I N N s e l e c t   1   f l a g 1 ,   0   f l a g 2 ,                 d e c o d e   r n , 1 , t o _ c h a r   d e p t n o   , '   '   e n a m e     i t _ d e p t       f r o m       s e l e c t   x . * ,   y . i d ,                 r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   x . d e p t n o   o r d e r   b y   y . i d     r n       f r o m       s e l e c t   d e p t n o ,                 e n a m e ,                 c o u n t   *   o v e r   p a r t i t i o n   b y   d e p t n o     c n t       f r o m   i t _ r e s e a r c h                     x ,                   s e l e c t   l e v e l   i d   f r o m   d u a l   c o n n e c t   b y   l e v e l   < =   2     y                       w h e r e   r n   < =   c n t + 1   u n i o n   a l l   s e l e c t   1   f l a g 1 ,   1   f l a g 2 ,                 d e c o d e   r n , 1 , t o _ c h a r   d e p t n o   , '   '   e n a m e     i t _ d e p t       f r o m        s e l e c t   x . * ,   y . i d ,                 r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   x . d e p t n o   o r d e r   b y   y . i d     r n       f r o m       s e l e c t   d e p t n o   d e p t n o ,                 e n a m e ,                 c o u n t   *   o v e r   p a r t i t i o n   b y   d e p t n o     c n t       f r o m   i t _ a p p s                     x ,                   s e l e c t   l e v e l   i d   f r o m   d u a l   c o n n e c t   b y   l e v e l   < =   2     y                       w h e r e   r n   < =   c n t + 1     F L A G 1             F L A G 2   I T _ D E P T   - - - - -   - - - - - - - - - -   - - - - - - - - - - - - - - - - - - - - - - -           1                     0   1 0 0           1                     0       J O N E S           1                     0       T O N E Y           1                     0       H O P K I N S           1                     0   2 0 0           1                     0       P . W H I T A K E R           1                     0       M A R C I A N O           1                     0       R O B I N S O N           1                     0       M O R A L E S           1                     0   3 0 0           1                     0       W R I G H T           1                     0       J . T A Y L O R           1                     0       L A C Y           1                     1   4 0 0           1                     1       M A Y W E A T H E R           1                     1       C A S T I L L O           1                     1       M A R Q U E Z           1                     1       M O S L E Y           1                     1       C O R R A L E S           1                     1   5 0 0           1                     1       C A L Z A G H E           1                     1       G A T T I           1                     1   6 0 0           1                     1       H A G L E R           1                     1       H E A R N S           1                     1       F R A Z I E R           1                     1       L A M O T T A           1                     1   7 0 0           1                     1       J U D A H           1                     1       M A R G A R I T O           1                     1       G U I N N  At this point, it isn’t clear what FLAG1’s purpose is, but you can see that FLAG2 identifies which rows come from which part of the UNION ALL  0 for the upper part, 1 for the lower part . The next step is to wrap the stacked result set in an inline view and create a running total on FLAG1  finally, its purpose is revealed! , which will act as a ranking for each row in each stack. The results of the ranking  running total  are shown here:  s e l e c t   s u m   f l a g 1   o v e r   p a r t i t i o n   b y   f l a g 2                                               o r d e r   b y   f l a g 1 , r o w n u m     f l a g ,                 i t _ d e p t ,   f l a g 2       f r o m       s e l e c t   1   f l a g 1 ,   0   f l a g 2 ,                 d e c o d e   r n , 1 , t o _ c h a r   d e p t n o   , '   '   e n a m e     i t _ d e p t       f r o m       s e l e c t   x . * ,   y . i d ,                 r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   x . d e p t n o   o r d e r   b y   y . i d     r n       f r o m       s e l e c t   d e p t n o ,                 e n a m e ,                 c o u n t   *   o v e r   p a r t i t i o n   b y   d e p t n o     c n t       f r o m   i t _ r e s e a r c h                     x ,                   s e l e c t   l e v e l   i d   f r o m   d u a l   c o n n e c t   b y   l e v e l   < =   2     y                       w h e r e   r n   < =   c n t + 1   u n i o n   a l l   s e l e c t   1   f l a g 1 ,   1   f l a g 2 ,                 d e c o d e   r n , 1 , t o _ c h a r   d e p t n o   , '   '   e n a m e     i t _ d e p t           f r o m       s e l e c t   x . * ,   y . i d ,                 r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   x . d e p t n o   o r d e r   b y   y . i d     r n       f r o m       s e l e c t   d e p t n o   d e p t n o ,                 e n a m e ,                 c o u n t   *   o v e r   p a r t i t i o n   b y   d e p t n o     c n t       f r o m   i t _ a p p s                     x ,                   s e l e c t   l e v e l   i d   f r o m   d u a l   c o n n e c t   b y   l e v e l   < =   2     y                       w h e r e   r n   < =   c n t + 1                     t m p 1        The last step  finally!  is to pivot the value returned by TMP1 on FLAG2 while grouping by FLAG  the running total generated in TMP1 . The results from TMP1 are wrapped in an inline view and pivoted  wrapped in a final inline view called TMP2 . The ultimate solution and result set are shown here:  F L A G   I T _ D E P T                             F L A G 2   - - - -   - - - - - - - - - - - - - - -   - - - - - - - - - -         1       1 0 0                                         0         2           J O N E S                                 0         3           T O N E Y                                 0         4           H O P K I N S                             0         5       2 0 0                                         0         6           P . W H I T A K E R                       0         7           M A R C I A N O                           0         8           R O B I N S O N                           0         9           M O R A L E S                             0       1 0         3 0 0                                       0       1 1           W R I G H T                               0       1 2           J . T A Y L O R                           0       1 3           L A C Y                                   0         1       4 0 0                                         1         2           M A Y W E A T H E R                       1         3           C A S T I L L O                           1         4           M A R Q U E Z                             1         5           M O S L E Y                               1         6           C O R R A L E S                           1         7       5 0 0                                         1         8           C A L Z A G H E e                         1         9           G A T T I                                 1       1 0       6 0 0                                         1       1 1           H A G L E R                               1       1 2           H E A R N S                               1       1 3           F R A Z I E R                             1       1 4           L A M O T T A                             1       1 5       7 0 0                                         1       1 6           J U D A H                                 1       1 7           M A R G A R I T O                         1       1 8           G U I N N                                 1 s e l e c t   m a x   d e c o d e   f l a g 2 , 0 , i t _ d e p t       r e s e a r c h ,                 m a x   d e c o d e   f l a g 2 , 1 , i t _ d e p t       a p p s       f r o m       s e l e c t   s u m   f l a g 1   o v e r   p a r t i t i o n   b y   f l a g 2                                                       o r d e r   b y   f l a g 1 , r o w n u m     f l a g ,                  i t _ d e p t ,   f l a g 2       f r o m       s e l e c t   1   f l a g 1 ,   0   f l a g 2 ,                 d e c o d e   r n , 1 , t o _ c h a r   d e p t n o   , '   '   e n a m e     i t _ d e p t       f r o m       s e l e c t   x . * ,   y . i d ,                 r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   x . d e p t n o   o r d e r   b y   y . i d     r n       f r o m       s e l e c t   d e p t n o ,                 e n a m e ,                 c o u n t   *   o v e r   p a r t i t i o n   b y   d e p t n o     c n t       f r o m   i t _ r e s e a r c h                     x ,                   s e l e c t   l e v e l   i d   f r o m   d u a l   c o n n e c t   b y   l e v e l   < =   2     y                       w h e r e   r n   < =   c n t + 1   u n i o n   a l l   s e l e c t   1   f l a g 1 ,   1   f l a g 2 ,                 d e c o d e   r n , 1 , t o _ c h a r   d e p t n o   , '   '   e n a m e     i t _ d e p t       f r o m       s e l e c t   x . * ,   y . i d ,                 r o w _ n u m b e r     o v e r   p a r t i t i o n   b y   x . d e p t n o   o r d e r   b y   y . i d     r n       f r o m       s e l e c t   d e p t n o   d e p t n o ,                 e n a m e ,                 c o u n t   *   o v e r   p a r t i t i o n   b y   d e p t n o     c n t       f r o m   i t _ a p p s                     x ,                   s e l e c t   l e v e l   i d   f r o m   d u a l   c o n n e c t   b y   l e v e l   < =   2     y                       w h e r e   r n   < =   c n t + 1                     t m p 1                     t m p 2     g r o u p   b y   f l a g       R E S E A R C H                           A P P S   - - - - - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - -   1 0 0                                     4 0 0       J O N E S                                 M A Y W E A T H E R       T O N E Y                                 C A S T I L L O       H O P K I N S                             M A R Q U E Z   2 0 0                                         M O S L E Y       P . W H I T A K E R                       C O R R A L E S       M A R C I A N O                       5 0 0       R O B I N S O N                           C A L Z A G H E       M O R A L E S                             G A T T I   3 0 0                                     6 0 0    14.10 Converting a Scalar Subquery to a Composite Subquery in Oracle  Problem You want to bypass the restriction of returning exactly one value from a scalar subquery. For example, you attempt to execute the following query:  but receive an error because subqueries in the SELECT list are allowed to return only a single value.  Solution Admittedly, this problem is quite unrealistic, because a simple join between tables EMP and DEPT would allow you to return as many values you want from DEPT. Nevertheless, the key is to focus on the technique and understand how to apply it to a scenario that you find useful. The key to bypassing the requirement to return a single value when placing a SELECT within SELECT  scalar subquery  is to take advantage of Oracle’s object types. You can define an object to have several attributes, and then you can work with it as a single entity or reference each element individually. In      W R I G H T                               H A G L E R       J . T A Y L O R                           H E A R N S       L A C Y                                   F R A Z I E R                                                 L A M O T T A                                             7 0 0                                                 J U D A H                                                 M A R G A R I T O                                                 G U I N N s e l e c t   e . d e p t n o ,                 e . e n a m e ,                 e . s a l ,                   s e l e c t   d . d n a m e , d . l o c , s y s d a t e   t o d a y                       f r o m   d e p t   d                     w h e r e   e . d e p t n o = d . d e p t n o         f r o m   e m p   e  effect, you don’t really bypass the rule at all. You simply return one value— an [.keep-together]object—that in turn contains many attributes. This solution makes use of the following object type:  With this type in place, you can execute the following query:  c r e a t e   t y p e   g e n e r i c _ o b j           a s   o b j e c t               v a l 1   v a r c h a r 2   1 0   ,           v a l 2   v a r c h a r 2   1 0   ,           v a l 3   d a t e       ;   1   s e l e c t   x . d e p t n o ,     2                 x . e n a m e ,     3                 x . m u l t i v a l . v a l 1   d n a m e ,     4                 x . m u l t i v a l . v a l 2   l o c ,     5                 x . m u l t i v a l . v a l 3   t o d a y     6     f r o m         7 s e l e c t   e . d e p t n o ,     8               e . e n a m e ,     9               e . s a l ,   1 0                 s e l e c t   g e n e r i c _ o b j   d . d n a m e , d . l o c , s y s d a t e + 1     1 1                     f r o m   d e p t   d   1 2                   w h e r e   e . d e p t n o = d . d e p t n o     m u l t i v a l   1 3     f r o m   e m p   e   1 4                   x     D E P T N O   E N A M E             D N A M E             L O C                 T O D A Y   - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - - -           2 0   S M I T H             R E S E A R C H       D A L L A S           1 2 - S E P - 2 0 2 0           3 0   A L L E N             S A L E S             C H I C A G O         1 2 - S E P - 2 0 2 0           3 0   W A R D               S A L E S             C H I C A G O         1 2 - S E P - 2 0 2 0           2 0   J O N E S             R E S E A R C H       D A L L A S           1 2 - S E P - 2 0 2 0           3 0   M A R T I N           S A L E S             C H I C A G O         1 2 - S E P - 2 0 2 0           3 0   B L A K E             S A L E S             C H I C A G O         1 2 - S E P - 2 0 2 0           1 0   C L A R K             A C C O U N T I N G   N E W   Y O R K       1 2 - S E P - 2 0 2 0           2 0   S C O T T             R E S E A R C H       D A L L A S           1 2 - S E P - 2 0 2 0           1 0   K I N G               A C C O U N T I N G   N E W   Y O R K       1 2 - S E P - 2 0 2 0           3 0   T U R N E R           S A L E S             C H I C A G O         1 2 - S E P - 2 0 2 0           2 0   A D A M S             R E S E A R C H       D A L L A S           1 2 - S E P - 2 0 2 0           3 0   J A M E S             S A L E S             C H I C A G O         1 2 - S E P - 2 0 2 0           2 0   F O R D               R E S E A R C H       D A L L A S           1 2 - S E P - 2 0 2 0           1 0   M I L L E R           A C C O U N T I N G   N E W   Y O R K       1 2 - S E P - 2 0 2 0  Discussion The key to the solution is to use the object’s constructor function  by default the constructor function has the same name as the object . Because the object itself is a single scalar value, it does not violate the scalar subquery rule, as you can see from the following:  The next step is to simply wrap the query in an inline view and extract the attributes.  WARNING  In Oracle, unlike the case with other vendors, you do not generally need to name your inline views. In this particular case, however, you do need to name your inline view. Otherwise, you will not be able to reference the object’s attributes.  s e l e c t   e . d e p t n o ,                 e . e n a m e ,                 e . s a l ,                   s e l e c t   g e n e r i c _ o b j   d . d n a m e , d . l o c , s y s d a t e - 1                         f r o m   d e p t   d                 w h e r e   e . d e p t n o = d . d e p t n o     m u l t i v a l   f r o m   e m p   e     D E P T N O   E N A M E     S A L       M U L T I V A L   V A L 1 ,   V A L 2 ,   V A L 3     - - - - - -   - - - - - -   - - - - -   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -           2 0   S M I T H       8 0 0     G E N E R I C _ O B J   ' R E S E A R C H ' ,   ' D A L L A S ' ,   ' 1 2 - S E P - 2 0 2 0 '             3 0   A L L E N     1 6 0 0     G E N E R I C _ O B J   ' S A L E S ' ,   ' C H I C A G O ' ,   ' 1 2 - S E P - 2 0 2 0 '             3 0   W A R D       1 2 5 0     G E N E R I C _ O B J   ' S A L E S ' ,   ' C H I C A G O ' ,   ' 1 2 - S E P - 2 0 2 0 '             2 0   J O N E S     2 9 7 5     G E N E R I C _ O B J   ' R E S E A R C H ' ,   ' D A L L A S ' ,   ' 1 2 - S E P - 2 0 2 0 '             3 0   M A R T I N   1 2 5 0     G E N E R I C _ O B J   ' S A L E S ' ,   ' C H I C A G O ' ,   ' 1 2 - S E P - 2 0 2 0 '             3 0   B L A K E     2 8 5 0     G E N E R I C _ O B J   ' S A L E S ' ,   ' C H I C A G O ' ,   ' 1 2 - S E P - 2 0 2 0 '             1 0   C L A R K     2 4 5 0     G E N E R I C _ O B J   ' A C C O U N T I N G ' ,   ' N E W   Y O R K ' ,   ' 1 2 - S E P - 2 0 2 0 '             2 0   S C O T T     3 0 0 0     G E N E R I C _ O B J   ' R E S E A R C H ' ,   ' D A L L A S ' ,   ' 1 2 - S E P - 2 0 2 0 '             1 0   K I N G       5 0 0 0     G E N E R I C _ O B J   ' A C C O U N T I N G ' ,   ' N E W   Y O R K ' ,   ' 1 2 - S E P - 2 0 2 0 '             3 0   T U R N E R   1 5 0 0     G E N E R I C _ O B J   ' S A L E S ' ,   ' C H I C A G O ' ,   ' 1 2 - S E P - 2 0 2 0 '             2 0   A D A M S     1 1 0 0     G E N E R I C _ O B J   ' R E S E A R C H ' ,   ' D A L L A S ' ,   ' 1 2 - S E P - 2 0 2 0 '             3 0   J A M E S       9 5 0     G E N E R I C _ O B J   ' S A L E S ' ,   ' C H I C A G O ' ,   ' 1 2 - S E P - 2 0 2 0 '             2 0   F O R D       3 0 0 0     G E N E R I C _ O B J   ' R E S E A R C H ' ,   ' D A L L A S ' ,   ' 1 2 - S E P - 2 0 2 0 '             1 0   M I L L E R   1 3 0 0     G E N E R I C _ O B J   ' A C C O U N T I N G ' ,   ' N E W   Y O R K ' ,   ' 1 2 - S E P - 2 0 2 0 '    14.11 Parsing Serialized Data into Rows  Problem You have serialized data  stored in strings  that you want to parse and return as rows. For example, you store the following data:  You want to convert these serialized strings into the following result set:  Solution Each serialized string in this example can store up to three values. The values are delimited by colons, and a string may or may not have all three entries. If a string does not have all three entries, you must be careful to place the entries that are available into the correct column in the result set. For example, consider the following row:  S T R I N G S   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   e n t r y : s t e w i e g r i f f i n : l o i s : b r i a n :   e n t r y : m o e : : s i z l a c k :   e n t r y : p e t e r g r i f f i n : m e g : c h r i s :   e n t r y : w i l l i e :   e n t r y : q u a g m i r e : m a y o r w e s t : c l e v e l a n d :   e n t r y : : : f l a n d e r s :   e n t r y : r o b o : t c h i : k e n : V A L 1                         V A L 2                         V A L 3   - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - -   m o e                                                           s i z l a c k   p e t e r g r i f f i n         m e g                           c h r i s   q u a g m i r e                 m a y o r w e s t               c l e v e l a n d   r o b o                         t c h i                         k e n   s t e w i e g r i f f i n       l o i s                         b r i a n   w i l l i e                                                                   f l a n d e r s e n t r y : : : f l a n d e r s :  This row represents an entry with the first two values missing and only the third value available. Hence, if you examine the target result set in the “Problem” section, you will notice that for the row FLANDERS is in, both VAL1 and VAL2 are NULL. The key to this solution is nothing more than a string walk with some string parsing, following by a simple pivot. This solution uses rows from view V, which is defined as follows. The example uses Oracle syntax, but since nothing more than string parsing functions are needed for this recipe, converting to other platforms is simple:  Using view V to supply the example data to parse, the solution is as follows:  c r e a t e   v i e w   V           a s   s e l e c t   ' e n t r y : s t e w i e g r i f f i n : l o i s : b r i a n : '   s t r i n g s       f r o m   d u a l     u n i o n   a l l   s e l e c t   ' e n t r y : m o e : : s i z l a c k : '       f r o m   d u a l     u n i o n   a l l   s e l e c t   ' e n t r y : p e t e r g r i f f i n : m e g : c h r i s : '       f r o m   d u a l     u n i o n   a l l   s e l e c t   ' e n t r y : w i l l i e : '       f r o m   d u a l     u n i o n   a l l   s e l e c t   ' e n t r y : q u a g m i r e : m a y o r w e s t : c l e v e l a n d : '       f r o m   d u a l     u n i o n   a l l   s e l e c t   ' e n t r y : : : f l a n d e r s : '       f r o m   d u a l     u n i o n   a l l   s e l e c t   ' e n t r y : r o b o : t c h i : k e n : '       f r o m   d u a l   1     w i t h   c a r t e s i a n   a s         2     s e l e c t   l e v e l   i d     3         f r o m   d u a l     4       c o n n e c t   b y   l e v e l   < =   1 0 0     5           6     s e l e c t   m a x   d e c o d e   i d , 1 , s u b s t r   s t r i n g s , p 1 + 1 , p 2 - 1         v a l 1 ,    Discussion The first step is to walk the serialized strings:    7                   m a x   d e c o d e   i d , 2 , s u b s t r   s t r i n g s , p 1 + 1 , p 2 - 1         v a l 2 ,     8                   m a x   d e c o d e   i d , 3 , s u b s t r   s t r i n g s , p 1 + 1 , p 2 - 1         v a l 3     9       f r o m       1 0   s e l e c t   v . s t r i n g s ,   1 1                 c . i d ,   1 2                 i n s t r   v . s t r i n g s , ' : ' , 1 , c . i d     p 1 ,   1 3                 i n s t r   v . s t r i n g s , ' : ' , 1 , c . i d + 1   - i n s t r   v . s t r i n g s , ' : ' , 1 , c . i d     p 2   1 4       f r o m   v ,   c a r t e s i a n   c   1 5     w h e r e   c . i d   < =     l e n g t h   v . s t r i n g s   - l e n g t h   r e p l a c e   v . s t r i n g s , ' : '       - 1   1 6                     1 7     g r o u p   b y   s t r i n g s   1 8     o r d e r   b y   1 w i t h   c a r t e s i a n   a s       s e l e c t   l e v e l   i d       f r o m   d u a l     c o n n e c t   b y   l e v e l   < =   1 0 0       s e l e c t   v . s t r i n g s ,             c . i d       f r o m   v , c a r t e s i a n   c     w h e r e   c . i d   < =     l e n g t h   v . s t r i n g s   - l e n g t h   r e p l a c e   v . s t r i n g s , ' : '       - 1     S T R I N G S                                                           I D   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   - - -   e n t r y : : : f l a n d e r s :                                         1   e n t r y : : : f l a n d e r s :                                         2   e n t r y : : : f l a n d e r s :                                         3   e n t r y : m o e : : s i z l a c k :                                     1   e n t r y : m o e : : s i z l a c k :                                     2   e n t r y : m o e : : s i z l a c k :                                     3   e n t r y : p e t e r g r i f f i n : m e g : c h r i s :                 1   e n t r y : p e t e r g r i f f i n : m e g : c h r i s :                 3   e n t r y : p e t e r g r i f f i n : m e g : c h r i s :                 2   e n t r y : q u a g m i r e : m a y o r w e s t : c l e v e l a n d :     1   e n t r y : q u a g m i r e : m a y o r w e s t : c l e v e l a n d :     3   e n t r y : q u a g m i r e : m a y o r w e s t : c l e v e l a n d :     2   e n t r y : r o b o : t c h i : k e n :                                   1   e n t r y : r o b o : t c h i : k e n :                                   2   e n t r y : r o b o : t c h i : k e n :                                   3   e n t r y : s t e w i e g r i f f i n : l o i s : b r i a n :             1   e n t r y : s t e w i e g r i f f i n : l o i s : b r i a n :             3    The next step is to use the function INSTR to find the numeric position of each colon in each string. Since each value you need to extract is enclosed by two colons, the numeric values are aliased P1 and P2, for “position one” and “position two”:  e n t r y : s t e w i e g r i f f i n : l o i s : b r i a n :             2   e n t r y : w i l l i e :                                                 1 w i t h   c a r t e s i a n   a s       s e l e c t   l e v e l   i d       f r o m   d u a l       c o n n e c t   b y   l e v e l   < =   1 0 0       s e l e c t   v . s t r i n g s ,                 c . i d ,                 i n s t r   v . s t r i n g s , ' : ' , 1 , c . i d     p 1 ,                 i n s t r   v . s t r i n g s , ' : ' , 1 , c . i d + 1   - i n s t r   v . s t r i n g s , ' : ' , 1 , c . i d     p 2                 f r o m   v , c a r t e s i a n   c               w h e r e   c . i d   < =     l e n g t h   v . s t r i n g s   - l e n g t h   r e p l a c e   v . s t r i n g s , ' : '       - 1               o r d e r   b y   1     S T R I N G S                                                           I D                     P 1                   P 2   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   - - -   - - - - - - - - - -   - - - - - - - - - -   e n t r y : : : f l a n d e r s :                                           1                     6                     1   e n t r y : : : f l a n d e r s :                                           2                     7                     1   e n t r y : : : f l a n d e r s :                                           3                     8                     9   e n t r y : m o e : : s i z l a c k :                                       1                     6                     4   e n t r y : m o e : : s i z l a c k :                                       2                   1 0                     1   e n t r y : m o e : : s i z l a c k :                                       3                   1 1                     8   e n t r y : p e t e r g r i f f i n : m e g : c h r i s :                   1                     6                   1 3   e n t r y : p e t e r g r i f f i n : m e g : c h r i s :                   3                   2 3                     6   e n t r y : p e t e r g r i f f i n : m e g : c h r i s :                   2                   1 9                     4   e n t r y : q u a g m i r e : m a y o r w e s t : c l e v e l a n d :       1                     6                     9   e n t r y : q u a g m i r e : m a y o r w e s t : c l e v e l a n d :       3                   2 5                   1 0   e n t r y : q u a g m i r e : m a y o r w e s t : c l e v e l a n d :       2                   1 5                   1 0   e n t r y : r o b o : t c h i : k e n :                                     1                     6                     5   e n t r y : r o b o : t c h i : k e n :                                     2                   1 1                     5   e n t r y : r o b o : t c h i : k e n :                                     3                   1 6                     4   e n t r y : s t e w i e g r i f f i n : l o i s : b r i a n :               1                     6                   1 4   e n t r y : s t e w i e g r i f f i n : l o i s : b r i a n :               3                   2 5                     6   e n t r y : s t e w i e g r i f f i n : l o i s : b r i a n :               2                   2 0                     5   e n t r y : w i l l i e :                                                   1                     6                     7  Now that you know the numeric positions for each pair of colons in each string, simply pass the information to the function SUBSTR to extract values. Since you want to create a result set with three columns, use DECODE to evaluate the ID from the Cartesian product:  w i t h   c a r t e s i a n   a s           s e l e c t   l e v e l   i d           f r o m   d u a l         c o n n e c t   b y   l e v e l   < =   1 0 0               s e l e c t   d e c o d e   i d , 1 , s u b s t r   s t r i n g s , p 1 + 1 , p 2 - 1       v a l 1 ,                     d e c o d e   i d , 2 , s u b s t r   s t r i n g s , p 1 + 1 , p 2 - 1       v a l 2 ,                     d e c o d e   i d , 3 , s u b s t r   s t r i n g s , p 1 + 1 , p 2 - 1       v a l 3           f r o m           s e l e c t   v . s t r i n g s ,                     c . i d ,                     i n s t r   v . s t r i n g s , ' : ' , 1 , c . i d     p 1 ,                     i n s t r   v . s t r i n g s , ' : ' , 1 , c . i d + 1   - i n s t r   v . s t r i n g s , ' : ' , 1 , c . i d     p 2           f r o m   v , c a r t e s i a n   c         w h e r e   c . i d   < =     l e n g t h   v . s t r i n g s   - l e n g t h   r e p l a c e   v . s t r i n g s , ' : '       - 1                               o r d e r   b y   1         V A L 1                         V A L 2                         V A L 3       - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - -   - - - - - - - - - - - - - -       m o e       p e t e r g r i f f i n       q u a g m i r e       r o b o       s t e w i e g r i f f i n       w i l l i e                                       l o i s                                         m e g                                       m a y o r w e s t                                         t c h i                                                                       b r i a n                                                                       s i z l a c k                                                                       c h r i s                                                                       c l e v e l a n d                                                                       f l a n d e r s                                                                       k e n  The last step is to apply an aggregate function to the values returned by SUBSTR while grouping by ID, to make a human-readable result set:  14.12 Calculating Percent Relative to Total  Problem You want to report a set of numeric values, and you want to show each value as a percentage of the whole. For example, you are on an Oracle system and you want to return a result set that shows the breakdown of salaries by JOB so that you can determine which JOB position costs the company the most money. You also want to include the number of  w i t h   c a r t e s i a n   a s       s e l e c t   l e v e l   i d       f r o m   d u a l     c o n n e c t   b y   l e v e l   < =   1 0 0       s e l e c t   m a x   d e c o d e   i d , 1 , s u b s t r   s t r i n g s , p 1 + 1 , p 2 - 1         v a l 1 ,                 m a x   d e c o d e   i d , 2 , s u b s t r   s t r i n g s , p 1 + 1 , p 2 - 1         v a l 2 ,                 m a x   d e c o d e   i d , 3 , s u b s t r   s t r i n g s , p 1 + 1 , p 2 - 1         v a l 3       f r o m       s e l e c t   v . s t r i n g s ,                 c . i d ,                 i n s t r   v . s t r i n g s , ' : ' , 1 , c . i d     p 1 ,                 i n s t r   v . s t r i n g s , ' : ' , 1 , c . i d + 1   - i n s t r   v . s t r i n g s , ' : ' , 1 , c . i d     p 2     f r o m   v , c a r t e s i a n   c   w h e r e   c . i d   < =     l e n g t h   v . s t r i n g s   - l e n g t h   r e p l a c e   v . s t r i n g s , ' : '       - 1                     g r o u p   b y   s t r i n g s   o r d e r   b y   1     V A L 1                         V A L 2                         V A L 3   - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - -   - - - - - - - - - - -   m o e                                                           s i z l a c k   p e t e r g r i f f i n         m e g                           c h r i s   q u a g m i r e                 m a y o r w e s t               c l e v e l a n d   r o b o                         t c h i                         k e n   s t e w i e g r i f f i n       l o i s                         b r i a n   w i l l i e                                                                   f l a n d e r s  employees per JOB to prevent the results from being misleading. You want to produce the following report:  As you can see, if the number of employees is not included in the report, it looks as if the president position takes very little of the overall salary. Seeing that there is only one president helps put into perspective what that 17% means.  Solution Only Oracle enables a decent solution to this problem, which involves using the built-in function RATIO_TO_REPORT. To calculate percentages of the whole for other databases, you can use division as shown in Recipe 7.11:  Discussion The first step is to use the window function COUNT OVER to return the number of employees per JOB. Then use RATIO_TO_REPORT to return the percentage each salary counts against the total  the value is returned in decimal :  J O B                   N U M _ E M P S   P C T _ O F _ A L L _ S A L A R I E S   - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - - - - - - - - - - -   C L E R K                             4                                     1 4   A N A L Y S T                         2                                     2 0   M A N A G E R                         3                                     2 8   S A L E S M A N                       4                                     1 9   P R E S I D E N T                     1                                     1 7 1     s e l e c t   j o b , n u m _ e m p s , s u m   r o u n d   p c t       p c t _ o f _ a l l _ s a l a r i e s   2       f r o m       3     s e l e c t   j o b ,   4                   c o u n t   *   o v e r   p a r t i t i o n   b y   j o b     n u m _ e m p s ,   5                   r a t i o _ t o _ r e p o r t   s a l   o v e r     * 1 0 0   p c t   6         f r o m   e m p   7                       8       g r o u p   b y   j o b , n u m _ e m p s s e l e c t   j o b ,                 c o u n t   *   o v e r   p a r t i t i o n   b y   j o b     n u m _ e m p s ,    The last step is to use the aggregate function SUM to sum the values returned by RATIO_TO_REPORT. Be sure to group by JOB and NUM_EMPS. Multiply by 100 to return a whole number that represents a percentage  e.g., to return 25 rather than 0.25 for 25% :                r a t i o _ t o _ r e p o r t   s a l   o v e r     * 1 0 0   p c t       f r o m   e m p     J O B                   N U M _ E M P S                 P C T   - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   A N A L Y S T                         2   1 0 . 3 3 5 9 1 7 3   A N A L Y S T                         2   1 0 . 3 3 5 9 1 7 3   C L E R K                             4   2 . 7 5 6 2 4 4 6 2   C L E R K                             4   3 . 7 8 9 8 3 6 3 5   C L E R K                             4     4 . 4 7 8 8 9 7 5   C L E R K                             4   3 . 2 7 3 0 4 0 4 8   M A N A G E R                         3   1 0 . 2 4 9 7 8 4 7   M A N A G E R                         3   8 . 4 4 0 9 9 9 1 4   M A N A G E R                         3   9 . 8 1 9 1 2 1 4 5   P R E S I D E N T                     1   1 7 . 2 2 6 5 2 8 9   S A L E S M A N                       4   5 . 5 1 2 4 8 9 2 3   S A L E S M A N                       4   4 . 3 0 6 6 3 2 2 1   S A L E S M A N                       4   5 . 1 6 7 9 5 8 6 6   S A L E S M A N                       4   4 . 3 0 6 6 3 2 2 1 s e l e c t   j o b , n u m _ e m p s , s u m   r o u n d   p c t       p c t _ o f _ a l l _ s a l a r i e s       f r o m       s e l e c t   j o b ,                 c o u n t   *   o v e r   p a r t i t i o n   b y   j o b     n u m _ e m p s ,                 r a t i o _ t o _ r e p o r t   s a l   o v e r     * 1 0 0   p c t       f r o m   e m p                       g r o u p   b y   j o b , n u m _ e m p s     J O B                   N U M _ E M P S   P C T _ O F _ A L L _ S A L A R I E S   - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - - - - - - - - - - -   C L E R K                             4                                     1 4   A N A L Y S T                         2                                     2 0   M A N A G E R                         3                                     2 8   S A L E S M A N                       4                                     1 9   P R E S I D E N T                     1                                     1 7  14.13 Testing for Existence of a Value Within a Group  Problem You want to create a Boolean flag for a row depending on whether any row in its group contains a specific value. Consider an example of a student who has taken a certain number of exams during a period of time. A student will take three exams over three months. If a student passes one of these exams, the requirement is satisfied and a flag should be returned to express that fact. If a student did not pass any of the three tests in the three-month period, then an additional flag should be returned to express that fact as well. Consider the following example  using Oracle syntax to make up rows for this example; minor modifications are necessary for the other vendors, making user of window functions :  c r e a t e   v i e w   V   a s   s e l e c t   1   s t u d e n t _ i d ,                 1   t e s t _ i d ,                 2   g r a d e _ i d ,                 1   p e r i o d _ i d ,                 t o _ d a t e   ' 0 2   0 1   2 0 2 0 ' , ' M M   D D   Y Y Y Y '     t e s t _ d a t e ,                 0   p a s s _ f a i l       f r o m   d u a l   u n i o n   a l l   s e l e c t   1 ,   2 ,   2 ,   1 ,   t o _ d a t e   ' 0 3   0 1   2 0 2 0 ' , ' M M   D D   Y Y Y Y '   ,   1   f r o m   d u a l   u n i o n   a l l   s e l e c t   1 ,   3 ,   2 ,   1 ,   t o _ d a t e   ' 0 4   0 1   2 0 2 0 ' , ' M M   D D   Y Y Y Y '   ,   0   f r o m   d u a l   u n i o n   a l l   s e l e c t   1 ,   4 ,   2 ,   2 ,   t o _ d a t e   ' 0 5   0 1   2 0 2 0 ' , ' M M   D D   Y Y Y Y '   ,   0   f r o m   d u a l   u n i o n   a l l   s e l e c t   1 ,   5 ,   2 ,   2 ,   t o _ d a t e   ' 0 6   0 1   2 0 2 0 ' , ' M M   D D   Y Y Y Y '   ,   0   f r o m   d u a l   u n i o n   a l l   s e l e c t   1 ,   6 ,   2 ,   2 ,   t o _ d a t e   ' 0 7   0 1   2 0 2 0 ' , ' M M   D D   Y Y Y Y '   ,   0   f r o m   d u a l     s e l e c t   *       f r o m   V     S T U D E N T _ I D   T E S T _ I D   G R A D E _ I D   P E R I O D _ I D   T E S T _ D A T E       P A S S _ F A I L   - - - - - - - - - -   - - - - - - -   - - - - - - - -   - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - -                       1               1                 2                 1   0 1 - F E B - 2 0 2 0                   0                       1               2                 2                 1   0 1 - M A R - 2 0 2 0                   1                       1               3                 2                 1   0 1 - A P R - 2 0 2 0                   0                       1               4                 2                 2   0 1 - M A Y - 2 0 2 0                   0    Examining the previous result set, you see that the student has taken six tests over two, three-month periods. The student has passed one test  1 means “pass”; 0 means “fail” ; thus, the requirement is satisfied for the entire first period. Because the student did not pass any exams during the second period  the next three months , PASS_FAIL is 0 for all three exams. You want to return a result set that highlights whether a student has passed a test for a given period. Ultimately you want to return the following result set:  The values for METREQ  “met requirement”  are + and –, signifying the student either has or has not satisfied the requirement of passing at least one test in a period  three-month span , respectively. The value for IN_PROGRESS should be 0 if a student has already passed a test in a given period. If a student has not passed a test for a given period, then the row that has the latest exam date for that student will have a value of 1 for IN_PROGRESS.  Solution This problem appears tricky because you have to treat rows in a group as a group and not as individuals. Consider the values for PASS_FAIL in the “Problem” section. If you evaluate row by row, it appears that the value for METREQ for each row except TEST_ID 2 should be –, when it’s not the case. You must ensure you evaluate the rows as a group. By using the window function MAX OVER, you can easily determine whether a student                      1               5                 2                 2   0 1 - J U N - 2 0 2 0                   0                       1               6                 2                 2   0 1 - J U L - 2 0 2 0                   0 S T U D E N T _ I D   T E S T _ I D   G R A D E _ I D   P E R I O D _ I D   T E S T _ D A T E       M E T R E Q   I N _ P R O G R E S S   - - - - - - - - - -   - - - - - - -   - - - - - - - -   - - - - - - - - -   - - - - - - - - - - -   - - - - - -   - - - - - - - - - - -                     1               1                 2                   1   0 1 - F E B - 2 0 2 0             +                       0                     1               2                 2                   1   0 1 - M A R - 2 0 2 0             +                       0                     1               3                 2                   1   0 1 - A P R - 2 0 2 0             +                       0                     1               4                 2                   2   0 1 - M A Y - 2 0 2 0             -                       0                     1               5                 2                   2   0 1 - J U N - 2 0 2 0             -                       0                     1               6                 2                   2   0 1 - J U L - 2 0 2 0             -                       1  passed at least one test during a particular period. Once you have that information, the “Boolean” values are a simple matter of using CASE expressions:  Discussion The key to the solution is using the window function MAX OVER to return the greatest value of PASS_FAIL for each group. Because the values for PASS_FAIL are only 1 or 0, if a student passed at least one exam, then MAX OVER would return 1 for the entire group. How this works is shown here:    1     s e l e c t   s t u d e n t _ i d ,     2                   t e s t _ i d ,     3                   g r a d e _ i d ,     4                   p e r i o d _ i d ,     5                   t e s t _ d a t e ,     6                   d e c o d e     g r p _ p _ f , 1 , l p a d   ' + ' , 6   , l p a d   ' - ' , 6         m e t r e q ,     7                   d e c o d e     g r p _ p _ f , 1 , 0 ,     8                                   d e c o d e     t e s t _ d a t e , l a s t _ t e s t , 1 , 0           i n _ p r o g r e s s     9       f r o m       1 0   s e l e c t   V . * ,   1 1                 m a x   p a s s _ f a i l   o v e r   p a r t i t i o n   b y   1 2                                             s t u d e n t _ i d , g r a d e _ i d , p e r i o d _ i d     g r p _ p _ f ,   1 3                 m a x   t e s t _ d a t e   o v e r   p a r t i t i o n   b y   1 4                                             s t u d e n t _ i d , g r a d e _ i d , p e r i o d _ i d     l a s t _ t e s t   1 5       f r o m   V   1 6                     x s e l e c t   V . * ,                 m a x   p a s s _ f a i l   o v e r   p a r t i t i o n   b y                                               s t u d e n t _ i d , g r a d e _ i d , p e r i o d _ i d     g r p _ p a s s _ f a i l       f r o m   V     S T U D E N T _ I D   T E S T _ I D   G R A D E _ I D   P E R I O D _ I D   T E S T _ D A T E       P A S S _ F A I L   G R P _ P A S S _ F A I L   - - - - - - - - - -   - - - - - - -   - - - - - - - -   - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - -   - - - - - - - - - - - - -                     1               1                 2                   1   0 1 - F E B - 2 0 2 0                   0                           1                     1               2                 2                   1   0 1 - M A R - 2 0 2 0                   1                           1                     1               3                 2                   1   0 1 - A P R - 2 0 2 0                   0                           1                     1               4                 2                   2   0 1 - M A Y - 2 0 2 0                   0                           0                     1               5                 2                   2   0 1 - J U N - 2 0 2 0                   0                           0                     1               6                 2                   2   0 1 - J U L - 2 0 2 0                   0                           0  The previous result set shows that the student passed at least one test during the first period; thus, the entire group has a value of 1 or “pass.” The next requirement is that if the student has not passed any tests in a period, return a value of 1 for the IN_ PROGRESS flag for the latest test date in that group. You can use the window function MAX OVER to do this as well:  Now that you have determined for which period the student has passed a test and what the latest test date for each period is, the last step is simply a matter of applying some formatting magic to make the result set look nice. The ultimate solution uses Oracle’s DECODE function  CASE supporters, eat your hearts out  to create the METREQ and IN_PROGRESS columns. Use the LPAD function to right justify the values for METREQ:  s e l e c t   V . * ,                 m a x   p a s s _ f a i l   o v e r   p a r t i t i o n   b y                                               s t u d e n t _ i d , g r a d e _ i d , p e r i o d _ i d     g r p _ p _ f ,                 m a x   t e s t _ d a t e   o v e r   p a r t i t i o n   b y                                               s t u d e n t _ i d , g r a d e _ i d , p e r i o d _ i d     l a s t _ t e s t       f r o m   V     S T U D E N T _ I D   T E S T _ I D   G R A D E _ I D   P E R I O D _ I D   T E S T _ D A T E       P A S S _ F A I L   G R P _ P _ F   L A S T _ T E S T   - - - - - - - - - -   - - - - - - -   - - - - - - - -   - - - - - - - - -   - - - - - - - - - - -   - - - - - - - - -   - - - - - - -   - - - - - - - - - - -                     1               1                 2                   1   0 1 - F E B - 2 0 2 0                   0               1   0 1 - A P R - 2 0 2 0                     1               2                 2                   1   0 1 - M A R - 2 0 2 0                   1               1   0 1 - A P R - 2 0 2 0                     1               3                 2                   1   0 1 - A P R - 2 0 2 0                   0               1   0 1 - A P R - 2 0 2 0                     1               4                 2                   2   0 1 - M A Y - 2 0 2 0                   0               0   0 1 - J U L - 2 0 2 0                     1               5                 2                   2   0 1 - J U N - 2 0 2 0                   0               0   0 1 - J U L - 2 0 2 0                     1               6                 2                   2   0 1 - J U L - 2 0 2 0                   0               0   0 1 - J U L - 2 0 2 0 s e l e c t   s t u d e n t _ i d ,                 t e s t _ i d ,                 g r a d e _ i d ,                 p e r i o d _ i d ,                 t e s t _ d a t e ,                 d e c o d e     g r p _ p _ f , 1 , l p a d   ' + ' , 6   , l p a d   ' - ' , 6         m e t r e q ,    14.14 Summing Up SQL is more powerful than many credit it. Throughout this book we have tried to challenge you to see more applications than are typically noted. In this chapter, we’ve headed straight for the edge cases and tried to show just how you can push SQL, both with standard features and with certain vendor-specific features.                d e c o d e     g r p _ p _ f , 1 , 0 ,                                 d e c o d e     t e s t _ d a t e , l a s t _ t e s t , 1 , 0           i n _ p r o g r e s s       f r o m       s e l e c t   V . * ,                 m a x   p a s s _ f a i l   o v e r   p a r t i t i o n   b y                                               s t u d e n t _ i d , g r a d e _ i d , p e r i o d _ i d     g r p _ p _ f ,                 m a x   t e s t _ d a t e   o v e r   p a r t i t i o n   b y                                               s t u d e n t _ i d , g r a d e _ i d , p e r i o d _ i d     l a s t _ t e s t       f r o m   V                     x     S T U D E N T _ I D   T E S T _ I D   G R A D E _ I D   P E R I O D _ I D   T E S T _ D A T E       M E T R E Q   I N _ P R O G R E S S   - - - - - - - - - -   - - - - - - -   - - - - - - - -   - - - - - - - - -   - - - - - - - - - - -   - - - - - -   - - - - - - - - - - -                     1               1                 2                   1   0 1 - F E B - 2 0 2 0             +                       0                     1               2                 2                   1   0 1 - M A R - 2 0 2 0             +                       0                     1               3                 2                   1   0 1 - A P R - 2 0 2 0             +                       0                     1               4                 2                   2   0 1 - M A Y - 2 0 2 0             -                       0                     1               5                 2                   2   0 1 - J U N - 2 0 2 0             -                       0                     1               6                 2                   2   0 1 - J U L - 2 0 2 0             -                       1  Appendix A. Window Function Refresher  The recipes in this book take full advantage of the window functions added to the ISO SQL standard in 2003, as well as vendor-specific window functions. This appendix is meant to serve as a brief overview of how window functions work. Window functions make many typically difficult tasks  difficult to solve using standard SQL, that is  quite easy. For a complete list of window functions available, full syntax, and in-depth coverage of how they work, please consult your vendor’s documentation.  Grouping Before moving on to window functions, it is crucial that you understand how grouping works in SQL—the concept of grouping results in SQL can be difficult to master. The problems stem from not fully understanding how the GROUP BY clause works and why certain queries return certain results when using GROUP BY. Simply stated, grouping is a way to organize like rows together. When you use GROUP BY in a query, each row in the result set is a group and represents one or more rows with the same values in one or more columns that you specify. That’s the gist of it. If a group is simply a unique instance of a row that represents one or more rows with the same value for a particular column  or columns , then practical examples of groups from table EMP include all employees in department 10  the common value for these employees that enables them to be in the same group is DEPTNO=10  or all clerks  the common value for these employees that enables them to be in the same group is JOB=CLERK . Consider the following queries. The first shows all employees in department 10; the second query groups the employees in   department 10 and returns the following information about the group: the number of rows  members  in the group, the highest salary, and the lowest salary:  If you were not able to group the employees in department 10 together, to get the information in the second query, you would have to manually inspect the rows for that department  trivial if there are only three rows, but what if there were three million rows? . So, why would anyone want to group? Reasons for doing so vary; perhaps you want to see how many different groups exist or how many members  rows  are in each group. As you can see from this simple example, grouping allows you to get information about many rows in a table without having to inspect them one by one.  Definition of an SQL Group In mathematics, a group is defined, for the most part, as  G,  , e , where G is a set,   is a binary operation in G, and e is a member of G. We will use  s e l e c t   d e p t n o , e n a m e       f r o m   e m p     w h e r e   d e p t n o = 1 0     D E P T N O   E N A M E   - - - - - -   - - - - - - - - - -           1 0   C L A R K           1 0   K I N G           1 0   M I L L E R       s e l e c t   d e p t n o ,                 c o u n t   *     a s   c n t ,                 m a x   s a l     a s   h i _ s a l ,                 m i n   s a l     a s   l o _ s a l       f r o m   e m p     w h e r e   d e p t n o = 1 0     g r o u p   b y   d e p t n o     D E P T N O                 C N T           H I _ S A L           L O _ S A L   - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -           1 0                     3               5 0 0 0               1 3 0 0  this definition as the foundation for what a SQL group is. A SQL group will be defined as  G, e , where G is a result set of a single or self-contained query that uses GROUP BY, e is a member of G, and the following axioms are satisfied:  For each e in G, e is distinct and represents one or more instances of e. For each e in G, the aggregate function COUNT returns a value > 0.  TIP  The result set is included in the definition of a SQL group to reinforce the fact that we are defining what groups are when working with queries only. Thus, it would be accurate to replace e in each axiom with the word row because the rows in the result set are technically the groups.  Because these properties are fundamental to what we consider a group, it is important that we prove they are true  and we will proceed to do so through the use of some example SQL queries .  Groups are nonempty By its very definition, a group must have at least one member  or row . If we accept this as a truth, then it can be said that a group cannot be created from an empty table. To prove that proposition true, simply try to prove it is false. The following example creates an empty table and then attempts to create groups via three different queries against that empty table:  c r e a t e   t a b l e   f r u i t s     n a m e   v a r c h a r   1 0         s e l e c t   n a m e       f r o m   f r u i t s     g r o u p   b y   n a m e       n o   r o w s   s e l e c t e d         s e l e c t   c o u n t   *     a s   c n t       f r o m   f r u i t s     g r o u p   b y   n a m e      As you can see from these queries, it is impossible to create what SQL considers a group from an empty table.  Groups are distinct Now let’s prove that the groups created via queries with a GROUP BY clause are distinct. The following example inserts five rows into table FRUITS and then creates groups from those rows:    n o   r o w s   s e l e c t e d         s e l e c t   n a m e ,   c o u n t   *     a s   c n t       f r o m   f r u i t s     g r o u p   b y   n a m e       n o   r o w s   s e l e c t e d   i n s e r t   i n t o   f r u i t s   v a l u e s     ' O r a n g e s '     i n s e r t   i n t o   f r u i t s   v a l u e s     ' O r a n g e s '     i n s e r t   i n t o   f r u i t s   v a l u e s     ' O r a n g e s '     i n s e r t   i n t o   f r u i t s   v a l u e s     ' A p p l e '     i n s e r t   i n t o   f r u i t s   v a l u e s     ' P e a c h '       s e l e c t   *       f r o m   f r u i t s     N A M E   - - - - - - - -   O r a n g e s   O r a n g e s   O r a n g e s   A p p l e   P e a c h     s e l e c t   n a m e       f r o m   f r u i t s     g r o u p   b y   n a m e     N A M E   - - - - - - -   A p p l e   O r a n g e s   P e a c h      The first query shows that “Oranges” occurs three times in table FRUITS. However, the second and third queries  using GROUP BY  return only one instance of “Oranges.” Taken together, these queries prove that the rows in the result set  e in G, from our definition  are distinct, and each value of NAME represents one or more instances of itself in table FRUITS. Knowing that groups are distinct is important because it means, typically, you would not use the DISTINCT keyword in your SELECT list when using a GROUP BY in your queries.  TIP  We don’t pretend GROUP BY and DISTINCT are the same. They represent two completely different concepts. We do state that the items listed in the GROUP BY clause will be distinct in the result set and that using DISTINCT as well as GROUP BY is redundant.  s e l e c t   n a m e ,   c o u n t   *     a s   c n t       f r o m   f r u i t s     g r o u p   b y   n a m e     N A M E         C N T   - - - - - - -   - - - - - - - -   A p p l e                     1   O r a n g e s                 3   P e a c h                     1  FREGE’S AXIOM AND RUSSELL’S PARADOX  For those of you who are interested, Frege’s axiom of abstraction, based on Cantor’s solution for defining set membership for infinite or uncountable sets, states that, given a specific identifying property, there exists a set whose members are only those items having that property. The source of trouble, as put by Robert Stoll, “is the unrestricted use of the principal of abstraction.” Bertrand Russell asked Gottlob Frege to consider a set whose members are sets and have the defining property of not being members of themselves. As Russell pointed out, the axiom of abstraction gives too much freedom because you are simply specifiying a condition or property to define set membership; thus, a contradiction can be found. To better explain how a contradiction can be found, he devised the “Barber puzzle.” The Barber puzzle states:  In a certain town there is a male barber who shaves all those men, and only those men, who do not shave themselves. If this is true, who, then, shaves the barber? For a more concrete example, consider the set that can be described as:  For all members x in y that satisfy a specific condition  P .  The mathematical notation for this description is:  Because the previous set considers only those x in y that satisfy a condition  P , you may find it more intuitive to describe the set as x is a member of y if and only if x satisfies a condition  P . At this point let us define this condition P x  as x is not a member of x:  The set is now defined as x is a member of y if and only if x is not a member of x:  Russell’s paradox may not be clear to you yet, but ask yourself this: can the previous set be a member of itself? Let’s assume that x = y and look at the set again. The following set can be defined as y is a member of y if and only if y is not a member of y:  Simply put, Russell’s paradox leaves us in a position to have a set that is concurrently a member of itself and not a member of itself, which is a contradiction. Intuitive thinking would lead one to believe this isn’t a problem at all; indeed, how can a set be a member of itself? The set of all books, after all, is not a book. So why does this paradox exist, and how can it be an issue? It becomes an issue when you consider more abstract applications of set theory. For example, a  { x   e   y      P   x   }       x   e   x       { x   e   y          x   e   x     }   { y   e   y          y   e   y     }  “practical” application of Russell’s paradox can be demonstrated by considering the set of all sets. If we allow such a concept to exist, then by its very definition, it must be a member of itself  it is, after all, the set of all sets . What then happens when you apply the previous P x  to the set of all sets? Simply stated, Russell’s paradox would state that the set of all sets is a member of itself if and only if it is not a member of itself—clearly a contradiction. For those of you who are interested, Ernst Zermelo developed the axiom schema of separation  also referred to as the axiom schema of subsets or the axiom of specification  to elegantly sidestep Russell’s paradox in axiomatic set theory.  COUNT is never zero The queries and results in the preceding section also prove the final axiom that the aggregate function COUNT will never return zero when used in a query with GROUP BY on a nonempty table. It should not be surprising that you cannot return a count of zero for a group. We have already proved that a group cannot be created from an empty table; thus, a group must have at least one row. If at least one row exists, then the count will always be at least one.  Remember, we are talking about using COUNT with GROUP BY, not COUNT by itself. A query using COUNT without a GROUP BY on an empty table will, of course, return zero.  TIP  Paradoxes The following quote is from Gottlob Frege in response to Bertrand Russell’s discovery of a contradiction to Frege’s axiom of abstraction in set theory: Hardly anything more unfortunate can befall a scientific writer than to have one of the foundations of his edifice shaken after the work is finished…. This was the position I was placed in by a letter of Mr. Bertrand Russell, just when the printing of this volume was nearing its completion. Paradoxes many times provide scenarios that would seem to contradict established theories or ideas. In many cases these contradictions are   localized and can be “worked around,” or they are applicable to such small test cases that they can be safely ignored. You may have guessed by now that the point to all this discussion of paradoxes is that there exists a paradox concerning our definition of an SQL group, and that paradox must be addressed. Although our focus right now is on groups, ultimately we are discussing SQL queries. In its GROUP BY clause, a query may have a wide range of values such as constants, expressions, or, most commonly, columns from a table. We pay a price for this flexibility, because NULL is a valid “value” in SQL. NULLs present problems because they are effectively ignored by aggregate functions. With that said, if a table consists of a single row and its value is NULL, what would the aggregate function COUNT return when used in a GROUP BY query? By our very definition, when using GROUP BY and the aggregate function COUNT, a value >= 1 must be returned. What happens, then, in the case of values ignored by functions such as COUNT, and what does this mean to our definition of a GROUP? Consider the following example, which reveals the NULL group paradox  using the function COALESCE when necessary for readability :  s e l e c t   *       f r o m   f r u i t s     N A M E   - - - - - - -   O r a n g e s   O r a n g e s   O r a n g e s   A p p l e   P e a c h     i n s e r t   i n t o   f r u i t s   v a l u e s     n u l l     i n s e r t   i n t o   f r u i t s   v a l u e s     n u l l     i n s e r t   i n t o   f r u i t s   v a l u e s     n u l l     i n s e r t   i n t o   f r u i t s   v a l u e s     n u l l     i n s e r t   i n t o   f r u i t s   v a l u e s     n u l l       s e l e c t   c o a l e s c e   n a m e , ' N U L L '     a s   n a m e       f r o m   f r u i t s     N A M E    It would seem that the presence of NULL values in our table introduces a contradiction, or paradox, to our definition of a SQL group. Fortunately, this contradiction is not a real cause for concern, because the paradox has more to do with the implementation of aggregate functions than our definition. Consider the final query in the preceding set; a general problem statement for that query would be: Count the number of times each name occurs in table FRUITS or count the number of members in each group. Examining the previous INSERT statements, it’s clear that there are five rows with NULL values, which means there exists a NULL group with five members.  - - - - - - - -   O r a n g e s   O r a n g e s   O r a n g e s   A p p l e   P e a c h   N U L L   N U L L   N U L L   N U L L   N U L L     s e l e c t   c o a l e s c e   n a m e , ' N U L L '     a s   n a m e ,                 c o u n t   n a m e     a s   c n t       f r o m   f r u i t s     g r o u p   b y   n a m e     N A M E                         C N T   - - - - - - - -   - - - - - - - - - -   A p p l e                           1   N U L L                             0   O r a n g e s                       3   P e a c h                           1  While NULL certainly has properties that differentiate it from other values, it is nevertheless a value and can in fact be a group.  TIP  How, then, can we write the query to return a count of 5 instead of 0, thus returning the information we are looking for while conforming to our definition of a group? The following example shows a workaround to deal with the NULL group paradox:  The workaround is to use COUNT *  rather than COUNT NAME  to avoid the NULL group paradox. Aggregate functions will ignore NULL values if any exist in the column passed to them. Thus, to avoid a zero when using COUNT, do not pass the column name; instead, pass in an asterisk  * . The * causes the COUNT function to count rows rather than the actual column values, so whether the actual values are NULL or not NULL is irrelevant. One more paradox has to do with the axiom that each group in a result set  for each e in G  is distinct. Because of the nature of SQL result sets and tables, which are more accurately defined as multisets or “bags,” not sets  because duplicate rows are allowed , it is possible to return a result set with duplicate groups. Consider the following queries:  s e l e c t   c o a l e s c e   n a m e , ' N U L L '     a s   n a m e ,                 c o u n t   *     a s   c n t       f r o m   f r u i t s     g r o u p   b y   n a m e     N A M E                       C N T   - - - - - - - - -   - - - - - - - -   A p p l e                         1   O r a n g e s                     3   P e a c h                         1   N U L L                           5 s e l e c t   c o a l e s c e   n a m e , ' N U L L '     a s   n a m e ,                 c o u n t   *     a s   c n t       f r o m   f r u i t s     g r o u p   b y   n a m e      u n i o n   a l l   s e l e c t   c o a l e s c e   n a m e , ' N U L L '     a s   n a m e ,                 c o u n t   *     a s   c n t       f r o m   f r u i t s     g r o u p   b y   n a m e     N A M E               C N T   - - - - - - - - - -   - - - - - - - - -   A p p l e                             1   O r a n g e s                         3   P e a c h                             1   N U L L                               5   A p p l e                             1   O r a n g e s                         3   P e a c h                             1   N U L L                               5       s e l e c t   x . *       f r o m       s e l e c t   c o a l e s c e   n a m e , ' N U L L '     a s   n a m e ,                 c o u n t   *     a s   c n t       f r o m   f r u i t s     g r o u p   b y   n a m e                     x ,                   s e l e c t   d e p t n o   f r o m   d e p t     y     N A M E               C N T   - - - - - - - - - -   - - - - - - - - - -   A p p l e                               1   A p p l e                               1   A p p l e                               1   A p p l e                               1   O r a n g e s                           3   O r a n g e s                           3   O r a n g e s                           3   O r a n g e s                           3   P e a c h                               1   P e a c h                               1   P e a c h                               1   P e a c h                               1   N U L L                                 5   N U L L                                 5   N U L L                                 5   N U L L                                 5  As you can see in these queries, the groups are in fact repeated in the final results. Fortunately, this is not much to worry about because it represents only a partial paradox. The first property of a group states that for  G, e , G is a result set from a single or self-contained query that uses GROUP BY. Simply put, the result set from any GROUP BY query itself conforms to our definition of a group. It is only when you combine the result sets from two GROUP BY queries to create a multiset that groups may repeat. The first query in the preceding example uses UNION ALL, which is not a set operation but a multiset operation, and invokes GROUP BY twice, effectively executing two queries.  If you use UNION, which is a set operation, you will not see repeating groups.  TIP  The second query in the preceding set uses a Cartesian product, which only works if you materialize the group first and then perform the Cartesian. Thus, the GROUP BY query when self-contained conforms to our definition. Neither of the two examples takes anything away from the definition of a SQL group. They are shown for completeness, and so that you can be aware that almost anything is possible in SQL.  Relationship Between SELECT and GROUP BY With the concept of a group defined and proved, it is now time to move on to more practical matters concerning queries using GROUP BY. It is important to understand the relationship between the SELECT clause and the GROUP BY clause when grouping in SQL. It is important to keep in mind when using aggregate functions such as COUNT that any item in your SELECT list that is not used as an argument to an aggregate function must be part of your group. For example, if you write a SELECT clause such as this:   then you must list DEPTNO in your GROUP BY clause:  Constants, scalar values returned by user-defined functions, window functions, and noncorrelated scalar subqueries are exceptions to this rule. Since the SELECT clause is evaluated after the GROUP BY clause, these constructs are allowed in the SELECT list and do not have to  and in some cases cannot  be specified in the GROUP BY clause. For example:  Don’t let this query confuse you. The items in the SELECT list not listed in the GROUP BY clause do not change the value of CNT for each DEPTNO, nor do the values for DEPTNO change. Based on the results of the preceding query, we can define the rule about matching items in the SELECT list and the GROUP BY clause when using aggregates a bit more precisely:  s e l e c t   d e p t n o ,   c o u n t   *     a s   c n t       f r o m   e m p s e l e c t   d e p t n o ,   c o u n t   *     a s   c n t       f r o m   e m p     g r o u p   b y   d e p t n o     D E P T N O     C N T   - - - - - - -   - - - -             1 0         3             2 0         5             3 0         6 s e l e c t   ' h e l l o '   a s   m s g ,                 1   a s   n u m ,                 d e p t n o ,                   s e l e c t   c o u n t   *     f r o m   e m p     a s   t o t a l ,                 c o u n t   *     a s   c n t       f r o m   e m p     g r o u p   b y   d e p t n o     M S G         N U M   D E P T N O   T O T A L   C N T   - - - - -     - - -   - - - - - -   - - - - -   - - -   h e l l o         1           1 0         1 4       3   h e l l o         1           2 0         1 4       5   h e l l o         1           3 0         1 4       6  Items in a SELECT list that can potentially change the group or change the value returned by an aggregate function must be included in the GROUP BY clause. The additional items in the preceding SELECT list did not change the value of CNT for any group  each DEPTNO , nor did they change the groups themselves. Now it’s fair to ask: exactly what items in a SELECT list can change a grouping or the value returned by an aggregate function? The answer is simple: other columns from the table s  you are selecting from. Consider the prospect of adding the JOB column to the query we’ve been looking at:  By listing another column, JOB, from table EMP, we are changing the group and changing the result set. Thus, we must now include JOB in the GROUP BY clause along with DEPTNO; otherwise, the query will fail. The inclusion of JOB in the SELECT GROUP BY clauses changes the query from “How many employees are in each department?” to “How many different types of employees are in each department?” Notice again that the groups are distinct; the values for DEPTNO and JOB individually are not distinct, but the combination of the two  which is what is in the GROUP BY and SELECT list, and thus in the group  is distinct  e.g., 10 and CLERK appear only once .  s e l e c t   d e p t n o ,   j o b ,   c o u n t   *     a s   c n t       f r o m   e m p     g r o u p   b y   d e p t n o ,   j o b     D E P T N O   J O B                 C N T   - - - - - -   - - - - - - - - - -   - - - -           1 0   C L E R K                   1           1 0   M A N A G E R               1           1 0   P R E S I D E N T           1           2 0   C L E R K                   2           2 0   A N A L Y S T               2           2 0   M A N A G E R               1           3 0   C L E R K                   1           3 0   M A N A G E R               1           3 0   S A L E S M A N             4  If you choose not to put items other than aggregate functions in the SELECT list, then you may list any valid column you want in the GROUP BY clause. Consider the following two queries, which highlight this fact:  Including items other than aggregate functions in the SELECT list is not mandatory, but often improves readability and usability of the results.  s e l e c t   c o u n t   *         f r o m   e m p     g r o u p   b y   d e p t n o       C O U N T   *     - - - - - - - - -                   3                   5                   6     s e l e c t   c o u n t   *         f r o m   e m p     g r o u p   b y   d e p t n o , j o b         C O U N T   *     - - - - - - - - - -                     1                     1                     1                     2                     2                     1                     1                     1                     4  TIP  As a rule, when using GROUP BY and aggregate functions, any items in the SELECT list  from the table s  in the FROM clause  not used as an argument to an aggregate function must be included in the GROUP BY clause. However, MySQL has a “feature” that allows you to deviate from this rule, allowing you to place items in your SELECT list  that are columns in the table s  you are selecting from  that are not used as arguments to an aggregate function and that are not present in your GROUP BY clause. We use the term feature loosely here as its use is a bug waiting to happen. As a matter of fact, if you use MySQL and care at all about the accuracy of your queries, we suggest you urge them to remove this, ahem, “feature.”  Windowing Once you understand the concept of grouping and using aggregates in SQL, understanding window functions is easy. Window functions, like aggregate functions, perform an aggregation on a defined set  a group  of rows, but rather than returning one value per group, window functions can return multiple values for each group. The group of rows to perform the aggregation on is the window. DB2 actually calls such functions online analytic processing  OLAP  functions, and Oracle calls them analytic functions, but the ISO SQL standard calls them window functions, so that’s the term used in this book.  A Simple Example Let’s say that you want to count the total number of employees across all departments. The traditional method for doing that is to issue a COUNT *  query against the entire EMP table:  s e l e c t   c o u n t   *     a s   c n t       f r o m   e m p         C N T   - - - - -         1 4  This is easy enough, but often you will find yourself wanting to access such aggregate data from rows that do not represent an aggregation, or that represent a different aggregation. Window functions make light work of such problems. For example, the following query shows how you can use a window function to access aggregate data  the total count of employees  from detail rows  one per employee :  The window function invocation in this example is COUNT *  OVER  . The presence of the OVER keyword indicates that the invocation of COUNT will be treated as a window function, not as an aggregate function. In general, the SQL standard allows for all aggregate functions to also be window functions, and the keyword OVER is how the language distinguishes between the two uses. So, what did the window function COUNT *  OVER    do exactly? For every row being returned in the query, it returned the count of all the rows in the table. As the empty parentheses suggest, the OVER keyword accepts additional clauses to affect the range of rows that a given window function  s e l e c t   e n a m e ,                 d e p t n o ,                 c o u n t   *     o v e r       a s   c n t       f r o m   e m p     o r d e r   b y   2     E N A M E                 D E P T N O         C N T   - - - - - - - - - -       - - - - - -   - - - - - -   C L A R K                         1 0           1 4   K I N G                           1 0           1 4   M I L L E R                       1 0           1 4   S M I T H                         2 0           1 4   A D A M S                         2 0           1 4   F O R D                           2 0           1 4   S C O T T                         2 0           1 4   J O N E S                         2 0           1 4   A L L E N                         3 0           1 4   B L A K E                         3 0           1 4   M A R T I N                       3 0           1 4   J A M E S                         3 0           1 4   T U R N E R                       3 0           1 4   W A R D                           3 0           1 4  considers. Absent any such clauses, the window function looks at all rows in the result set, which is why you see the value 14 repeated in each row of output. Hopefully you are beginning to see the great utility of window functions, which is that they allow you to work with multiple levels of aggregation in one row. As you continue through this appendix, you’ll begin to see even more just how incredibly useful that ability can be.  Order of Evaluation Before digging deeper into the OVER clause, it is important to note that window functions are performed as the last step in SQL processing prior to the ORDER BY clause. As an example of how window functions are processed last, let’s take the query from the preceding section and use a WHERE clause to filter out employees from DEPTNO 20 and 30:  The value for CNT for each row is no longer 14, it is now 3. In this example, it is the WHERE clause that restricts the result set to three rows; hence, the window function will count only three rows  there are only three rows available to the window function by the time processing reaches the SELECT portion of the query . From this example you can see that window functions perform their computations after clauses such as WHERE and GROUP BY are evaluated.  s e l e c t   e n a m e ,                 d e p t n o ,                 c o u n t   *     o v e r       a s   c n t       f r o m   e m p     w h e r e   d e p t n o   =   1 0     o r d e r   b y   2     E N A M E             D E P T N O           C N T   - - - - - - - - - -   - - - - - -     - - - - - -   C L A R K                     1 0               3   K I N G                       1 0               3   M I L L E R                   1 0               3  Partitions Use the PARTITION BY clause to define a partition or group of rows to perform an aggregation over. As we’ve seen already, if you use empty parentheses, then the entire result set is the partition that a window function aggregation will be computed over. You can think of the PARTITION BY clause as a “moving GROUP BY” because unlike a traditional GROUP BY, a group created by PARTITION BY is not distinct in a result set. You can use PARTITION BY to compute an aggregation over a defined group of rows  resetting when a new group is encountered , and rather than having one group represent all instances of that value in the table, each value  each member in each group  is returned. Consider the following query:  This query still returns 14 rows, but now the COUNT is performed for each department as a result of the PARTITION BY DEPTNO clause. Each employee in the same department  in the same partition  will have the same value for CNT, because the aggregation will not reset  recompute  until a  s e l e c t   e n a m e ,                 d e p t n o ,                 c o u n t   *     o v e r   p a r t i t i o n   b y   d e p t n o     a s   c n t       f r o m   e m p     o r d e r   b y   2       E N A M E               D E P T N O             C N T   - - - - - - - - - -   - - - - - -       - - - - - -   C L A R K                       1 0                 3   K I N G                         1 0                 3   M I L L E R                     1 0                 3   S M I T H                       2 0                 5   A D A M S                       2 0                 5   F O R D                         2 0                 5   S C O T T                       2 0                 5   J O N E S                       2 0                 5   A L L E N                       3 0                 6   B L A K E                       3 0                 6   M A R T I N                     3 0                 6   J A M E S                       3 0                 6   T U R N E R                     3 0                 6   W A R D                         3 0                 6  new department is encountered. Also note that you are returning information about each group, along with the members of each group. You can think of the preceding query as a more efficient version of the following:  Additionally, what’s nice about the PARTITION BY clause is that it performs its computations independently of other window functions, partitioning by different columns in the same SELECT statement. Consider the following query, which returns each employee, their department, the number of employees in their respective department, their job, and the number of employees with the same job:  s e l e c t   e . e n a m e ,                 e . d e p t n o ,                   s e l e c t   c o u n t   *     f r o m   e m p   d                     w h e r e   e . d e p t n o = d . d e p t n o     a s   c n t       f r o m   e m p   e     o r d e r   b y   2       E N A M E             D E P T N O         C N T   - - - - - - - - - -   - - - - - -   - - - - - -   C L A R K                     1 0             3   K I N G                       1 0             3   M I L L E R                   1 0             3   S M I T H                     2 0             5   A D A M S                     2 0             5   F O R D                       2 0             5   S C O T T                     2 0             5   J O N E S                     2 0             5   A L L E N                     3 0             6   B L A K E                     3 0             6   M A R T I N                   3 0             6   J A M E S                     3 0             6   T U R N E R                   3 0             6   W A R D                       3 0             6 s e l e c t   e n a m e ,                 d e p t n o ,                 c o u n t   *     o v e r   p a r t i t i o n   b y   d e p t n o     a s   d e p t _ c n t ,                 j o b ,                 c o u n t   *     o v e r   p a r t i t i o n   b y   j o b     a s   j o b _ c n t    In this result set, you can see that employees in the same department have the same value for DEPT_CNT, and that employees who have the same job position have the same value for JOB_CNT. By now it should be clear that the PARTITION BY clause works like a GROUP BY clause, but it does so without being affected by the other items in the SELECT clause and without requiring you to write a GROUP BY clause.  Effect of NULLs Like the GROUP BY clause, the PARTITION BY clause lumps all the NULLs into one group or partition. Thus, the effect from NULLs when using PARTITION BY is similar to that from using GROUP BY. The following query uses a window function to count the number of employees with each distinct commission  returning –1 in place of NULL for readability :      f r o m   e m p     o r d e r   b y   2     E N A M E                 D E P T N O       D E P T _ C N T   J O B               J O B _ C N T   - - - - - - - - - -       - - - - - -       - - - - - - - -   - - - - - - - - -   - - - - - - -   M I L L E R                       1 0                     3   C L E R K                       4   C L A R K                         1 0                     3   M A N A G E R                   3   K I N G                           1 0                     3   P R E S I D E N T               1   S C O T T                         2 0                     5   A N A L Y S T                   2   F O R D                           2 0                     5   A N A L Y S T                   2   S M I T H                         2 0                     5   C L E R K                       4   J O N E S                         2 0                     5   M A N A G E R                   3   A D A M S                         2 0                     5   C L E R K                       4   J A M E S                         3 0                     6   C L E R K                       4   M A R T I N                       3 0                     6   S A L E S M A N                 4   T U R N E R                       3 0                     6   S A L E S M A N                 4   W A R D                           3 0                     6   S A L E S M A N                 4   A L L E N                         3 0                     6   S A L E S M A N                 4   B L A K E                         3 0                     6   M A N A G E R                   3 s e l e c t   c o a l e s c e   c o m m , - 1     a s   c o m m ,                 c o u n t   *   o v e r   p a r t i t i o n   b y   c o m m     a s   c n t       f r o m   e m p      Because COUNT *  is used, the function counts rows. You can see that there are 10 employees having NULL commissions. Use COMM instead of *, however, and you get quite different results:  This query uses COUNT COMM , which means that only the non-NULL values in the COMM column are counted. There is one employee with a      C O M M                 C N T   - - - - - -   - - - - - - - - - -             0                     1         3 0 0                     1         5 0 0                     1       1 4 0 0                     1           - 1                   1 0           - 1                   1 0           - 1                   1 0           - 1                   1 0           - 1                   1 0           - 1                   1 0           - 1                   1 0           - 1                   1 0           - 1                   1 0           - 1                   1 0 s e l e c t   c o a l e s c e   c o m m , - 1     a s   c o m m ,                 c o u n t   c o m m   o v e r   p a r t i t i o n   b y   c o m m     a s   c n t       f r o m   e m p     C O M M                 C N T   - - - -   - - - - - - - - - -         0                     1     3 0 0                     1     5 0 0                     1   1 4 0 0                     1       - 1                     0       - 1                     0       - 1                     0       - 1                     0       - 1                     0       - 1                     0       - 1                     0       - 1                     0       - 1                     0       - 1                     0  commission of 0, one employee with a commission of 300, and so forth. But notice the counts for those with NULL commissions! Those counts are 0. Why? Because aggregate functions ignore NULL values, or more accurately, aggregate functions count only non-NULL values.  TIP  When using COUNT, consider whether you want to include NULLs. Use COUNT column  to avoid counting NULLs. Use COUNT *  if you do want to include NULLs  since you are no longer counting actual column values, you are counting rows .  When Order Matters Sometimes the order in which rows are treated by a window function is material to the results that you want to obtain from a query. For this reason, window function syntax includes an ORDER BY subclause that you can place within an OVER clause. Use the ORDER BY clause to specify how the rows are ordered with a partition  remember, “partition” in the absence of a PARTITION BY clause means the entire result set .  WARNING  Some window functions require you to impose order on the partitions of rows being affected. Thus, for some window functions, an ORDER BY clause is mandatory. At the time of this writing, SQL Server does not allow ORDER BY in the OVER clause when used with aggregate window functions. SQL Server does permit ORDER BY in the OVER clause when used with window ranking functions.  When you use an ORDER BY clause in the OVER clause of a window function, you are specifying two things:  How the rows in the partition are ordered What rows are included in the computation  Consider the following query, which sums and computes a running total of salaries for employees in DEPTNO 10:   WARNING  Just to keep you on your toes, I’ve included a sum with empty parentheses. Notice how TOTAL1 and TOTAL2 have the same values. Why? Once again, the order in which window functions are evaluated answers the question. The WHERE clause filters the result set such that only salaries from DEPTNO 10 are considered for summation. In this case, there is only one partition—the entire result set, which consists of only salaries from DEPTNO 10. Thus TOTAL1, and TOTAL2 are the same.  Looking at the values returned by column SAL, you can easily see where the values for RUNNING_TOTAL come from. You can eyeball the values and add them yourself to compute the running total. But more importantly, why did including an ORDER BY in the OVER clause create a running total in the first place? The reason is, when you use ORDER BY in the OVER clause, you are specifying a default “moving” or “sliding” window within the partition even though you don’t see it. The ORDER BY HIREDATE clause terminates summation at the HIREDATE in the current row. The following query is the same as the previous one, but uses the RANGE BETWEEN clause  which you’ll learn more about later  to explicitly specify the default behavior that results from ORDER BY HIREDATE:  s e l e c t   d e p t n o ,                 e n a m e ,                 h i r e d a t e ,                 s a l ,                 s u m   s a l   o v e r   p a r t i t i o n   b y   d e p t n o     a s   t o t a l 1 ,                 s u m   s a l   o v e r       a s   t o t a l 2 ,                 s u m   s a l   o v e r   o r d e r   b y   h i r e d a t e     a s   r u n n i n g _ t o t a l       f r o m   e m p     w h e r e   d e p t n o = 1 0     D E P T N O     E N A M E       H I R E D A T E             S A L   T O T A L 1   T O T A L 2   R U N N I N G _ T O T A L   - - - - - -     - - - - - -     - - - - - - - - - - -   - - - - -   - - - - - -   - - - - - -   - - - - - - - - - - - - -           1 0     C L A R K       0 9 - J U N - 1 9 8 1     2 4 5 0       8 7 5 0       8 7 5 0                     2 4 5 0           1 0     K I N G         1 7 - N O V - 1 9 8 1     5 0 0 0       8 7 5 0       8 7 5 0                     7 4 5 0           1 0     M I L L E R     2 3 - J A N - 1 9 8 2     1 3 0 0       8 7 5 0       8 7 5 0                     8 7 5 0  The RANGE BETWEEN clause that you see in this query is termed the framing clause by ANSI, and we’ll use that term here. Now, it should be easy to see why specifying an ORDER BY in the OVER clause created a running total; we’ve  by default  told the query to sum all rows starting from the current row and include all prior rows  “prior” as defined in the ORDER BY, in this case ordering the rows by HIREDATE .  The Framing Clause Let’s apply the framing clause from the preceding query to the result set, starting with the first employee hired, who is named CLARK:  1. Starting with CLARK’s salary, 2450, and including all employees hired before CLARK, compute a sum. Since CLARK was the first employee hired in DEPTNO 10, the sum is simply CLARK’s salary, 2450, which is the first value returned by RUNNING_TOTAL.  2. Let’s move to the next employee based on HIREDATE, named KING,  and apply the framing clause once again. Compute a sum on SAL starting with the current row, 5000  KING’s salary , and include all prior rows  all employees hired before KING . CLARK is the only one hired before KING, so the sum is 5000 + 2450, which is 7450, the second value returned by RUNNING_TOTAL.  s e l e c t   d e p t n o ,                 e n a m e ,                 h i r e d a t e ,                 s a l ,                 s u m   s a l   o v e r   p a r t i t i o n   b y   d e p t n o     a s   t o t a l 1 ,                 s u m   s a l   o v e r       a s   t o t a l 2 ,                 s u m   s a l   o v e r   o r d e r   b y   h i r e d a t e                                           r a n g e   b e t w e e n   u n b o u n d e d   p r e c e d i n g                                               a n d   c u r r e n t   r o w     a s   r u n n i n g _ t o t a l       f r o m   e m p     w h e r e   d e p t n o = 1 0     D E P T N O   E N A M E     H I R E D A T E             S A L   T O T A L 1   T O T A L 2   R U N N I N G _ T O T A L   - - - - - -   - - - - - -   - - - - - - - - - - -   - - - - -   - - - - - -   - - - - - -   - - - - - - - - - - - - -           1 0   C L A R K     0 9 - J U N - 1 9 8 1     2 4 5 0       8 7 5 0       8 7 5 0                     2 4 5 0           1 0   K I N G       1 7 - N O V - 1 9 8 1     5 0 0 0       8 7 5 0       8 7 5 0                     7 4 5 0           1 0   M I L L E R   2 3 - J A N - 1 9 8 2     1 3 0 0       8 7 5 0       8 7 5 0                     8 7 5 0  3. Moving on to MILLER, the last employee in the partition based on  HIREDATE, let’s one more time apply the framing clause. Compute a sum on SAL starting with the current row, 1300  MILLER’s salary , and include all prior rows  all employees hired before MILLER . CLARK and KING were both hired before MILLER, and thus their salaries are included in MILLER’s RUNNING_TOTAL: 2450 + 5000 + 1300 is 8750, which is the value for RUNNING_TOTAL for MILLER.  As you can see, it is really the framing clause that produces the running total. The ORDER BY defines the order of evaluation and happens to also imply a default framing. In general, the framing clause allows you to define different “subwindows” of data to include in your computations. There are many ways to specify such subwindows. Consider the following query:  s e l e c t   d e p t n o ,                 e n a m e ,                 s a l ,                 s u m   s a l   o v e r   o r d e r   b y   h i r e d a t e                                           r a n g e   b e t w e e n   u n b o u n d e d   p r e c e d i n g                                               a n d   c u r r e n t   r o w     a s   r u n _ t o t a l 1 ,                 s u m   s a l   o v e r   o r d e r   b y   h i r e d a t e                                             r o w s   b e t w e e n   1   p r e c e d i n g                                             a n d   c u r r e n t   r o w     a s   r u n _ t o t a l 2 ,                 s u m   s a l   o v e r   o r d e r   b y   h i r e d a t e                                           r a n g e   b e t w e e n   c u r r e n t   r o w                                             a n d   u n b o u n d e d   f o l l o w i n g     a s   r u n _ t o t a l 3 ,                 s u m   s a l   o v e r   o r d e r   b y   h i r e d a t e                                             r o w s   b e t w e e n   c u r r e n t   r o w                                             a n d   1   f o l l o w i n g     a s   r u n _ t o t a l 4       f r o m   e m p     w h e r e   d e p t n o = 1 0     D E P T N O   E N A M E         S A L   R U N _ T O T A L 1   R U N _ T O T A L 2   R U N _ T O T A L 3   R U N _ T O T A L 4   - - - - - -   - - - - - -   - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -           1 0   C L A R K       2 4 5 0               2 4 5 0               2 4 5 0               8 7 5 0               7 4 5 0           1 0   K I N G         5 0 0 0               7 4 5 0               7 4 5 0               6 3 0 0               6 3 0 0           1 0   M I L L E R     1 3 0 0               8 7 5 0               6 3 0 0               1 3 0 0               1 3 0 0  Don’t be intimidated here; this query is not as bad as it looks. You’ve already seen RUN_TOTAL1 and the effects of the framing clause UNBOUNDED PRECEDING AND CURRENT ROW. Here’s a quick description of what’s happening in the other examples: RUN_TOTAL2  Rather than the keyword RANGE, this framing clause specifies ROWS, which means the frame, or window, is going to be constructed by counting some number of rows. The 1 PRECEDING means that the frame will begin with the row immediately preceding the current row. The range continues through the CUR-RENT ROW. So what you get in RUN_TOTAL2 is the sum of the current employee’s salary and that of the preceding employee, based on HIREDATE.  TIP  It so happens that RUN_TOTAL1 and RUN_TOTAL2 are the same for both CLARK and KING. Why? Think about which values are being summed for each of those employees, for each of the two window functions. Think carefully, and you’ll get the answer.  RUN_TOTAL3  RUN_TOTAL4  The window function for RUN_TOTAL3 works just the opposite of that for RUN_TOTAL1; rather than starting with the current row and including all prior rows in the summation, summation begins with the current row and includes all subsequent rows in the summation.  This is the inverse of RUN_TOTAL2; rather than starting from the current row and including one prior row in the summation, start with the current row and include one subsequent row in the summation.  [ [ s q l c k b k - A P P - A - N O T E - 1 1 ] ]  TIP  If you can understand what’s been explained thus far, you will have no problem with any of the recipes in this book. If you’re not catching on, though, try practicing with your own examples and your own data. It’s usually easier to learn by coding new features rather than just reading about them.  A Framing Finale As a final example of the effect of the framing clause on query output, consider the following query:  s e l e c t   e n a m e ,                 s a l ,                 m i n   s a l   o v e r   o r d e r   b y   s a l     m i n 1 ,                 m a x   s a l   o v e r   o r d e r   b y   s a l     m a x 1 ,                 m i n   s a l   o v e r   o r d e r   b y   s a l                                           r a n g e   b e t w e e n   u n b o u n d e d   p r e c e d i n g                                               a n d   u n b o u n d e d   f o l l o w i n g     m i n 2 ,                 m a x   s a l   o v e r   o r d e r   b y   s a l                                           r a n g e   b e t w e e n   u n b o u n d e d   p r e c e d i n g                                               a n d   u n b o u n d e d   f o l l o w i n g     m a x 2 ,                 m i n   s a l   o v e r   o r d e r   b y   s a l                                           r a n g e   b e t w e e n   c u r r e n t   r o w                                               a n d   c u r r e n t   r o w     m i n 3 ,                 m a x   s a l   o v e r   o r d e r   b y   s a l                                           r a n g e   b e t w e e n   c u r r e n t   r o w                                               a n d   c u r r e n t   r o w     m a x 3 ,                 m a x   s a l   o v e r   o r d e r   b y   s a l                                             r o w s   b e t w e e n   3   p r e c e d i n g                                               a n d   3   f o l l o w i n g     m a x 4       f r o m   e m p     E N A M E           S A L           M I N 1         M A X 1         M I N 2         M A X 2         M I N 3         M A X 3         M A X 4   - - - - - -     - - - - -       - - - - - -     - - - - - -     - - - - - -     - - - - - -     - - - - - -     - - - - - -     - - - - - -   S M I T H           8 0 0             8 0 0           8 0 0           8 0 0         5 0 0 0           8 0 0           8 0 0         1 2 5 0   J A M E S           9 5 0             8 0 0           9 5 0           8 0 0         5 0 0 0           9 5 0           9 5 0         1 2 5 0   A D A M S         1 1 0 0             8 0 0         1 1 0 0           8 0 0         5 0 0 0         1 1 0 0         1 1 0 0         1 3 0 0   W A R D           1 2 5 0             8 0 0         1 2 5 0           8 0 0         5 0 0 0         1 2 5 0         1 2 5 0         1 5 0 0   M A R T I N       1 2 5 0             8 0 0         1 2 5 0           8 0 0         5 0 0 0         1 2 5 0         1 2 5 0         1 6 0 0   M I L L E R       1 3 0 0             8 0 0         1 3 0 0           8 0 0         5 0 0 0         1 3 0 0         1 3 0 0         2 4 5 0   T U R N E R       1 5 0 0             8 0 0         1 5 0 0           8 0 0         5 0 0 0         1 5 0 0         1 5 0 0         2 8 5 0   A L L E N         1 6 0 0             8 0 0         1 6 0 0           8 0 0         5 0 0 0         1 6 0 0         1 6 0 0         2 9 7 5   C L A R K         2 4 5 0             8 0 0         2 4 5 0           8 0 0         5 0 0 0         2 4 5 0         2 4 5 0         3 0 0 0    OK, let’s break this query down: MIN1  The window function generating this column does not specify a framing clause, so the default framing clause of UNBOUNDED PRECEDING AND CURRENT ROW kicks in. Why is MIN1 800 for all rows? It’s because the lowest salary comes first  ORDER BY SAL , and it remains the lowest, or minimum, salary forever after.  MAX1  The values for MAX1 are much different from those for MIN1. Why? The answer  again  is the default framing clause UNBOUNDED PRECEDING AND CURRENT ROW. In conjunction with ORDER BY SAL, this framing clause ensures that the maximum salary will also correspond to that of the current row. Consider the first row, for SMITH. When evaluating SMITH’s salary and all prior salaries, MAX1 for SMITH is SMITH’s salary, because there are no prior salaries. Moving on to the next row, JAMES, when comparing JAMES’s salary to all prior salaries, in this case comparing to the salary of SMITH, JAMES’s salary is the higher of the two, and thus it is the maximum. If you apply this logic to all rows, you will see that the value of MAX1 for each row is the current employee’s salary.  MIN2 and MAX2  The framing clause given for these is UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING, which is the same as specifying empty parentheses. Thus, all rows in the result set are considered when computing MIN and MAX. As you might expect, the MIN and MAX values for the entire result set are constant, and thus the value of these columns is constant as well.  B L A K E         2 8 5 0             8 0 0         2 8 5 0           8 0 0         5 0 0 0         2 8 5 0         2 8 5 0         3 0 0 0   J O N E S         2 9 7 5             8 0 0         2 9 7 5           8 0 0         5 0 0 0         2 9 7 5         2 9 7 5         5 0 0 0   S C O T T         3 0 0 0             8 0 0         3 0 0 0           8 0 0         5 0 0 0         3 0 0 0         3 0 0 0         5 0 0 0   F O R D           3 0 0 0             8 0 0         3 0 0 0           8 0 0         5 0 0 0         3 0 0 0         3 0 0 0         5 0 0 0   K I N G           5 0 0 0             8 0 0         5 0 0 0           8 0 0         5 0 0 0         5 0 0 0         5 0 0 0         5 0 0 0  MIN3 and MAX3  The framing clause for these is CURRENT ROW AND CURRENT ROW, which simply means use only the current employee’s salary when looking for the MIN and MAX salary. Thus, both MIN3 and MAX3 are the same as SAL for each row. That was easy, wasn’t it?  MAX4  The framing clause defined for MAX4 is 3 PRECEDING AND 3 FOLLOWING, which means, for every row, consider the three rows prior and the three rows after the current row, as well as the current row itself. This particular invocation of MAX SAL  will return from those rows the highest salary value. If you look at the value of MAX4 for employee MARTIN, you can see how the framing clause is applied. MARTIN’s salary is 1250, and the three employee salaries prior to MARTIN’s are WARD’s  1250 , ADAMS’s  1100  and JAMES’s  950 . The three employee salaries after MARTIN’s are MILLER’s  1300 , TURNER’s  1500 , and ALLEN’s  1600 . Out of all those salaries, including MARTIN’s, the highest is ALLEN’s, and thus the value of MAX4 for MARTIN is 1600.  Readability + Performance = Power As you can see, window functions are extremely powerful as they allow you to write queries that contain both detailed and aggregate information. Using window functions allows you to write smaller, more efficient queries as compared to using multiple self-join and or scalar subqueries. Consider the following query, which easily answers all of the following questions: “What is the number of employees in each department? How many different types of employees are in each department  e.g., how many clerks are in department 10 ? How many total employees are in table EMP?”  s e l e c t   d e p t n o ,                 j o b ,                 c o u n t   *     o v e r     p a r t i t i o n   b y   d e p t n o     a s   e m p _ c n t ,                 c o u n t   j o b     o v e r     p a r t i t i o n   b y   d e p t n o , j o b     a s   j o b _ c n t ,    Returning the same result set without using window functions would require a bit more work:                c o u n t   *     o v e r         a s   t o t a l       f r o m   e m p     D E P T N O   J O B                     E M P _ C N T         J O B _ C N T             T O T A L   - - - - - -   - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -           1 0   C L E R K                             3                     1                   1 4           1 0   M A N A G E R                         3                     1                   1 4           1 0   P R E S I D E N T                     3                     1                   1 4           2 0   A N A L Y S T                         5                     2                   1 4           2 0   A N A L Y S T                         5                     2                   1 4           2 0   C L E R K                             5                     2                   1 4           2 0   C L E R K                             5                     2                   1 4           2 0   M A N A G E R                         5                     1                   1 4           3 0   C L E R K                             6                     1                   1 4           3 0   M A N A G E R                         6                     1                   1 4           3 0   S A L E S M A N                       6                     4                   1 4           3 0   S A L E S M A N                       6                     4                   1 4           3 0   S A L E S M A N                       6                     4                   1 4           3 0   S A L E S M A N                       6                     4                   1 4 s e l e c t   a . d e p t n o ,   a . j o b ,                   s e l e c t   c o u n t   *     f r o m   e m p   b                     w h e r e   b . d e p t n o   =   a . d e p t n o     a s   e m p _ c n t ,                   s e l e c t   c o u n t   *     f r o m   e m p   b                     w h e r e   b . d e p t n o   =   a . d e p t n o   a n d   b . j o b   =   a . j o b     a s   j o b _ c n t ,                   s e l e c t   c o u n t   *     f r o m   e m p     a s   t o t a l       f r o m   e m p   a     o r d e r   b y   1 , 2     D E P T N O   J O B                     E M P _ C N T           J O B _ C N T             T O T A L   - - - - - -   - - - - - - - - -   - - - - - - - - - -     - - - - - - - - - -   - - - - - - - - - -           1 0   C L E R K                             3                       1                   1 4           1 0   M A N A G E R                         3                       1                   1 4           1 0   P R E S I D E N T                     3                       1                   1 4           2 0   A N A L Y S T                         5                       2                   1 4           2 0   A N A L Y S T                         5                       2                   1 4           2 0   C L E R K                             5                       2                   1 4           2 0   C L E R K                             5                       2                   1 4           2 0   M A N A G E R                         5                       1                   1 4           3 0   C L E R K                             6                       1                   1 4           3 0   M A N A G E R                         6                       1                   1 4           3 0   S A L E S M A N                       6                       4                   1 4           3 0   S A L E S M A N                       6                       4                   1 4    The nonwindow solution is obviously not difficult to write, yet it certainly is not as clean or efficient  you won’t see performance differences with a 14-row table, but try these queries with, say, a 1,000- or 10,000-row table, and then you’ll see the benefit of using window functions over multiple self-joins and scalar subqueries .  Providing a Base Besides readability and performance, window functions are useful for providing a “base” for more complex “report-style” queries. For example, consider the following “report-style” query that uses window functions in an inline view and then aggregates the results in an outer query. Using window functions allows you to return detailed as well as aggregate data, which is useful for reports. The following query uses window functions to find counts using different partitions. Because the aggregation is applied to multiple rows, the inline view returns all rows from EMP, which the outer CASE expressions can use to transpose and create a formatted report:          3 0   S A L E S M A N                       6                       4                   1 4           3 0   S A L E S M A N                       6                       4                   1 4 s e l e c t   d e p t n o ,                 e m p _ c n t   a s   d e p t _ t o t a l ,                 t o t a l ,                 m a x   c a s e   w h e n   j o b   =   ' C L E R K '                                   t h e n   j o b _ c n t   e l s e   0   e n d     a s   c l e r k s ,                 m a x   c a s e   w h e n   j o b   =   ' M A N A G E R '                                   t h e n   j o b _ c n t   e l s e   0   e n d     a s   m g r s ,                 m a x   c a s e   w h e n   j o b   =   ' P R E S I D E N T '                                   t h e n   j o b _ c n t   e l s e   0   e n d     a s   p r e z ,                 m a x   c a s e   w h e n   j o b   =   ' A N A L Y S T '                                   t h e n   j o b _ c n t   e l s e   0   e n d     a s   a n a l s ,                 m a x   c a s e   w h e n   j o b   =   ' S A L E S M A N '                                   t h e n   j o b _ c n t   e l s e   0   e n d     a s   s m e n       f r o m       s e l e c t   d e p t n o ,                 j o b ,                 c o u n t   *     o v e r     p a r t i t i o n   b y   d e p t n o     a s   e m p _ c n t ,                 c o u n t   j o b     o v e r     p a r t i t i o n   b y   d e p t n o , j o b     a s   j o b _ c n t ,                 c o u n t   *     o v e r         a s   t o t a l         f r o m   e m p    The previous query returns each department, the total number of employees in each department, the total number of employees in table EMP, and a breakdown of the number of different job types in each department. All this is done in one query, without additional joins or temp tables! As a final example of how easily multiple questions can be answered using window functions, consider the following query:                    x     g r o u p   b y   d e p t n o ,   e m p _ c n t ,   t o t a l     D E P T N O   D E P T _ T O T A L   T O T A L   C L E R K S   M G R S   P R E Z   A N A L S   S M E N   - - - - - -   - - - - - - - - - -   - - - - -   - - - - - -   - - - -   - - - -   - - - - -   - - - -           1 0                   3           1 4             1         1         1           0         0           2 0                   5           1 4             2         1         0           2         0           3 0                   6           1 4             1         1         0           0         4 s e l e c t   e n a m e   a s   n a m e ,                 s a l ,                 m a x   s a l   o v e r   p a r t i t i o n   b y   d e p t n o     a s   h i D p t ,                 m i n   s a l   o v e r   p a r t i t i o n   b y   d e p t n o     a s   l o D p t ,                 m a x   s a l   o v e r   p a r t i t i o n   b y   j o b     a s   h i J o b ,                 m i n   s a l   o v e r   p a r t i t i o n   b y   j o b     a s   l o J o b ,                 m a x   s a l   o v e r       a s   h i ,                 m i n   s a l   o v e r       a s   l o ,                 s u m   s a l   o v e r   p a r t i t i o n   b y   d e p t n o                                                   o r d e r   b y   s a l , e m p n o     a s   d p t R T ,                 s u m   s a l   o v e r   p a r t i t i o n   b y   d e p t n o     a s   d p t S u m ,                 s u m   s a l   o v e r       a s   t t l       f r o m   e m p     o r d e r   b y   d e p t n o , d p t R T       N A M E           S A L   H I D P T   L O D P T   H I J O B   L O J O B         H I       L O   D P T R T   D P T S U M           T T L   - - - - - -   - - - - -   - - - - -   - - - - -   - - - - -   - - - - -   - - - - -   - - - -   - - - - - -   - - - - - -   - - - - - -   M I L L E R     1 3 0 0     5 0 0 0     1 3 0 0     1 3 0 0       8 0 0     5 0 0 0     8 0 0       1 3 0 0       8 7 5 0     2 9 0 2 5   C L A R K       2 4 5 0     5 0 0 0     1 3 0 0     2 9 7 5     2 4 5 0     5 0 0 0     8 0 0       3 7 5 0       8 7 5 0     2 9 0 2 5   K I N G         5 0 0 0     5 0 0 0     1 3 0 0     5 0 0 0     5 0 0 0     5 0 0 0     8 0 0       8 7 5 0       8 7 5 0     2 9 0 2 5   S M I T H         8 0 0     3 0 0 0       8 0 0     1 3 0 0       8 0 0     5 0 0 0     8 0 0         8 0 0     1 0 8 7 5     2 9 0 2 5   A D A M S       1 1 0 0     3 0 0 0       8 0 0     1 3 0 0       8 0 0     5 0 0 0     8 0 0       1 9 0 0     1 0 8 7 5     2 9 0 2 5   J O N E S       2 9 7 5     3 0 0 0       8 0 0     2 9 7 5     2 4 5 0     5 0 0 0     8 0 0       4 8 7 5     1 0 8 7 5     2 9 0 2 5   S C O T T       3 0 0 0     3 0 0 0       8 0 0     3 0 0 0     3 0 0 0     5 0 0 0     8 0 0       7 8 7 5     1 0 8 7 5     2 9 0 2 5   F O R D         3 0 0 0     3 0 0 0       8 0 0     3 0 0 0     3 0 0 0     5 0 0 0     8 0 0     1 0 8 7 5     1 0 8 7 5     2 9 0 2 5   J A M E S         9 5 0     2 8 5 0       9 5 0     1 3 0 0       8 0 0     5 0 0 0     8 0 0         9 5 0       9 4 0 0     2 9 0 2 5   W A R D         1 2 5 0     2 8 5 0       9 5 0     1 6 0 0     1 2 5 0     5 0 0 0     8 0 0       2 2 0 0       9 4 0 0     2 9 0 2 5    This query answers the following questions easily, efficiently, and readably  and without additional joins to EMP! . Simply match the employee and their salary with the different rows in the result set to determine:  Who makes the highest salary of all employees  HI  Who makes the lowest salary of all employees  LO  Who makes the highest salary in the department  HIDPT  Who makes the lowest salary in the department  LODPT  Who makes the highest salary in their job  HIJOB  Who makes the lowest salary in their job  LOJOB  What is the sum of all salaries  TTL  What is the sum of salaries per department  DPTSUM  What is the running total of all salaries per department  DPTRT   M A R T I N     1 2 5 0     2 8 5 0       9 5 0     1 6 0 0     1 2 5 0     5 0 0 0     8 0 0       3 4 5 0       9 4 0 0     2 9 0 2 5   T U R N E R     1 5 0 0     2 8 5 0       9 5 0     1 6 0 0     1 2 5 0     5 0 0 0     8 0 0       4 9 5 0       9 4 0 0     2 9 0 2 5   A L L E N       1 6 0 0     2 8 5 0       9 5 0     1 6 0 0     1 2 5 0     5 0 0 0     8 0 0       6 5 5 0       9 4 0 0     2 9 0 2 5   B L A K E       2 8 5 0     2 8 5 0       9 5 0     2 9 7 5     2 4 5 0     5 0 0 0     8 0 0       9 4 0 0       9 4 0 0     2 9 0 2 5  Appendix B. Common Table Expressions  Many of the queries presented in this cookbook go beyond what is possible using tables as they are typically available in a database, especially in relation to aggregate functions and window functions. Therefore, for some queries, you need to make a derived table—either a subquery or a common table expression  CTE .  Subqueries Arguably the simplest way to create a virtual table that allows you to run queries on window functions or aggregate functions is a subquery. All that’s required here is to write the query that you need within parentheses and then to write a second query that uses it. The following table illustrates the use of subqueries with a simple double aggregate—you want to find not just the counts of employees in each job, but then identify the highest number, but you can’t nest aggregate functions directly in a standard query. One pitfall is that some vendors require you to give the subquery table and alias, but others do not. The following example was written in MySQL, which does require an alias. The alias here is HEAD_COUNT_TAB after the closing parenthesis. Others that require an alias are PostgreSQL and SQL Server, while Oracle does not:  s e l e c t   m a x   H e a d C o u n t     a s   H i g h e s t J o b H e a d C o u n t   f r o m     s e l e c t   j o b , c o u n t   e m p n o     a s   H e a d C o u n t   f r o m   e m p   g r o u p   b y   j o b     h e a d _ c o u n t _ t a b  Common Table Expressions CTEs were intended to overcome some of the limits of subqueries, and may be most well known for allowing recursive queries to be used within SQL. In fact, enablng recursion within SQL was the main inspiration for CTEs. This example achieves the same result as the subquery we saw earlier—it finds a double aggregate:  Although this query solves a simple problem, it illustrates the essential features of a CTE. We introduce the derived table using the WITH clause, specifying the column headings in the parentheses, and use parentheses around the derived table’s query itself. If we want to add more derived tables, we can add more as long as we separate each one with a comma and provide its name before its query  the reverse of how aliasing usually works in SQL . Because the inner queries are presented before the outer query, in many circumstances they may also be considered more readable—they make it easier to study each logical element of the query separately in order to understand the logical flow. Of course, as with all things in coding, this will vary according to circumstances, and sometimes the subquery will be more readable. Considering that recursion is the key reason for CTEs to exist, the best way to demonstrate their capability is through a recursive query. The query that follows calculates the first 20 numbers in the Fibonacci sequence using a recursive CTE. Note that in the first part of the anchor query, we can initialize the values in the first row of the virtual table:  w i t h   h e a d _ c o u n t _ t a b     j o b , H e a d C o u n t     a s       s e l e c t   j o b , c o u n t   e m p n o     f r o m   e m p   g r o u p   b y   j o b       s e l e c t   m a x   H e a d C o u n t     a s   H i g h e s t J o b H e a d C o u n t   f r o m   h e a d _ c o u n t _ t a b  The Fibonacci sequence finds the next number by adding the current and previous numbers; you could also use LAG to achieve this result. However, in this case we’ve made a pseudo-LAG by using two columns to account for the current number and the previous. Note the keyword RECURSIVE, which is mandatory in MySQL, Oracle, and PostgreSQL but not in SQL Server or DB2. In this query, the index1 column is largely redundant in the sense of not being used for the Fibonacci calculation. Instead, we have included it to make it simpler to set the number of rows returned via the WHERE clause. In a recursive CTE, the WHERE clause becomes crucial, as without it the query would not terminate  although in this specific case, if you try deleting it, you are likely to find that your database throws an overflow error when the numbers become too large for the data type . At the simple end of the spectrum, there’s not a lot of difference between a subquery and CTE in terms of usability. Both allow for nesting or writing more complicated queries that refer to other derived tables. However, once you start nesting many subqueries, readability is lessened because the meaning of different variables is hidden in successive query layers. In contrast, because a CTE arranges each element vertically, it is easier to understand the meaning of each element.  Summing Up The use of derived tables dramatically extends the range of SQL. Both subqueries and CTES are used many times throughout the book, so it is important to understand how they work, especially as they each have a particular syntax that you need to master to ensure success. The recursive  w i t h   r e c u r s i v e   w o r k i n g T a b l e       f i b N u m ,   N e x t N u m b e r ,   i n d e x 1     a s     s e l e c t   0 , 1 , 1   u n i o n   a l l   s e l e c t   f i b N u m + n e x t N u m b e r , f i b N U m , i n d e x 1 + 1   f r o m   a n c h o r   w h e r e   i n d e x 1 < 2 0       s e l e c t   f i b N u m   f r o m   w o r k i n g T a b l e   a s   f i b  CTE, which is now available in the vendor offerings in this book, is one of the biggest extensions to have occurred within SQL, allowing for many extra possibilities.   Index  Symbols %  modulus  function  SQL Server , SQL Server %  wildcard  operator, Solution * character in SELECT statements, Solution +  concatenation  operator  SQL Server , SQL Server, SQL Server _  underscore  operator, Discussion   concatenation  function  DB2 Oracle PostgreSQL , Discussion, DB2, PostgreSQL, and Oracle  A abstraction, axiom of, Groups are distinct ADDDATE function  MySQL , MySQL, MySQL, MySQL, MySQL ADD_MONTHS function  Oracle , Oracle, Oracle, Oracle aggregate functions  multiple tables and, Problem-Discussion NULL values and, Problem, Paradoxes WHERE clause, referencing in, Discussion  aliases  for CASE expression, Discussion inline views, Discussion referencing aliased columns, Problem  alphabetizing strings, Problem-PostgreSQL alphanumeric strings  converting to numbers, Problem-Discussion   determining whether a string is alphanumeric, Problem-MySQL mixed, Problem-Discussion sorting mixed, Problem-Discussion  anti-joins, Discussion AS keyword, Solution asterisk  *  character in SELECT statements, Solution asterisk  *  character with COUNT function, Solution, Discussion averages, computing, Problem-See Also AVG function, Solution-See Also axiom of abstraction, Groups are distinct axiom of specification, Groups are distinct axiom schema of separation, Groups are distinct axiom schema of subsets, Groups are distinct  B Barber Puzzle, Groups are distinct Benford's law, Problem-Discussion binary, converting whole numbers to, Problem-Discussion  C calendars, creating, Problem-MySQL, PostgreSQL, and SQL Server Cartesian products, Problem, Solution CASE expression, Solution, Discussion, DB2, MySQL, PostgreSQL, and SQL Server, Discussion, MySQL and PostgreSQL, Solution CAST function  SQL Server , SQL Server CEIL function  DB2 MySQL Oracle PostgreSQL , Discussion CEILING function  SQL Server , Discussion, Solution   COALESCE function, Solution, Solution, Discussion, Solution, SQL Server, Discussion columns  adding headers to double pivoted result sets, Problem-Discussion concatenating, Problem naming, Problem retrieving a subset of columns from a table, Problem retrieving all rows and columns from a table, Problem  common table expressions  CTEs , Preface, Common Table Expressions composite subqueries, converting scalar subqueries to  Oracle , Problem- Discussion CONCAT function  MySQL , MySQL, MySQL, MySQL concatenation  column values, Problem operator  +   SQL Server , SQL Server, SQL Server operator     DB2 Oracle PostgreSQL , Discussion, DB2, PostgreSQL, and Oracle  CONCAT_WS function  MySQL , MySQL, MySQL conditional logic in SELECT statements, Problem CONNECT BY clause  Oracle , Oracle, Oracle  in hierarchical structures, Oracle, Oracle WITH clause and, Oracle  CONNECT_BY_ISLEAF function  Oracle , Oracle, Oracle CONNECT_BY_ROOT function  Oracle , Oracle, Oracle constraints, listing, Problem correlated subquery, MySQL COUNT function, Solution, Solution-Solution, COUNT is never zero COUNT OVER window function, Solution   count star, Discussion create table as select  CTAS , Oracle, MySQL, and PostgreSQL CREATE TABLE command, DB2 CREATE TABLE … LIKE command  DB2 , DB2 cross-tab reports  creating  SQL Server , Problem-Discussion unpivoting  SQL Server , Problem-Solution  CTAS  create table as select , Oracle, MySQL, and PostgreSQL CTEs  common table expressions , Preface, Common Table Expressions CUBE extension, Oracle, Oracle, DB2, and SQL Server CUME_DIST function, MySQL CURRENT_DATE function  DB2 MySQL PostgreSQL , PostgreSQL and MySQL, DB2, MySQL, and SQL Server  D data dependent keys, sorting on, Problem data dictionary views  Oracle , Problem DATE function  DB2 , DB2 date manipulation, Date Manipulation-Summing Up  comparing records using specific parts of a date, Problem-Discussion creating a calendar, Problem-MySQL, PostgreSQL, and SQL Server determining all dates for a particular weekday throughout a year, Problem-SQL Server determining quarter start end dates for a, Problem-SQL Server determining the date of first last occurrences of specific weekday in month, Problem-PostgreSQL and MySQL determining the first last days of a month, Problem-SQL Server determining the number of days in a year, Problem-SQL Server, Problem   determining whether a year is a leap year, Problem-SQL Server extracting units of time from date, Problem-Discussion filling in missing dates, Problem-SQL Server identifying overlapping date ranges, Problem-Discussion listing quarter end dates for the year, Problem-PostgreSQL, MySQL, and SQL Server searching on specific units of time, Problem-Discussion  DATEADD function  SQL Server , SQL Server, SQL Server DATEDIFF function  MySQL SQL Server , MySQL DATENAME function  SQL Server , SQL Server, SQL Server DATEPART function  SQL Server , SQL Server, SQL Server, SQL Server, SQL Server, PostgreSQL, MySQL, and SQL Server dates, ORDER BY clause and  DB2 , DB2 and Oracle DATE_FORMAT function  MySQL , MySQL, MySQL DATE_TRUNC function  PostgreSQL , PostgreSQL, PostgreSQL, PostgreSQL DAY function  DB2 , SQL Server, DB2, DB2 DAY function  MySQL , MySQL, MySQL DAY function  SQL Server , SQL Server, SQL Server DAYNAME function  DB2 MySQL SQL Server , DB2 and MySQL DAYOFWEEK function  DB2 MYSQL , PostgreSQL and MySQL, DB2 DAYOFYEAR function  DB2 MySQL SQL Server , DB2-DB2, DB2, MySQL-SQL Server DAYS function  DB2 , DB2 DECODE function  Oracle , Discussion DEFAULT keyword, Discussion DEFAULT VALUES clause  PostgreSQL SQL Server , Discussion DELETE command, Problem, Solution   deleting records all, Problem duplicate, Problem-Discussion with NULLs  PostgreSQL MySQL , Discussion with NULLs  DB2 Oracle SQL Server , Solution referenced from another table, Problem-Discussion referencing nonexistent records from another table, Problem referential integrity violations, Problem single, Problem specific, Problem  delimited data, converting to IN-list, Problem-PostgreSQL delimited lists, creating, Problem-Oracle DENSE_RANK function  DB2 Oracle SQL Server , Solution, Oracle, Oracle DENSE_RANK OVER window function  DB2 Oracle SQL Server , Discussion, Solution, Solution DENSE_RANK window function, DB2, MySQL, PostgreSQL, and SQL Server DEPT table structure, Tables Used in This Book DICTIONARY view, Solution DISTINCT keyword  alternatives to, Discussion, Traditional alternatives SELECT list and, Discussion, Traditional alternatives, Groups are distinct uses for, MySQL, Solution, Discussion  double aggregate, Subqueries duplicates  deleting, Problem-Discussion   suppressing, Problem-Traditional alternatives  dynamic SQL, creating, Problem-Discussion  E EMP table structure, Tables Used in This Book equi-join operations, Discussion, Problem EXCEPT function, DB2, PostgreSQL, and SQL Server, Solution, DB2, Oracle, and PostgreSQL EXTRACT function  PostgreSQL MySQL , PostgreSQL and MySQL extreme values, finding, Problem  F FETCH FIRST clause  DB2 , DB2 Fibonacci sequence, Common Table Expressions forecasts, generating simple, Problem-PostgreSQL foreign keys, listing, Problem-Discussion framing clause, Solution Frege's axiom, Groups are distinct Frege, Gottlob, Groups are distinct FULL OUTER JOIN command, DB2, MySQL, PostgreSQL, and SQL Server  G GENERATE_SERIES function  PostgreSQL   parameters, PostgreSQL uses, PostgreSQL, PostgreSQL, PostgreSQL, PostgreSQL  GETDATE function  SQL Server , DB2, MySQL, and SQL Server GROUP BY clause, Traditional alternatives, Grouping   GROUP BY queries, returning other columns in, Problem-Discussion grouping, Grouping-Relationship Between SELECT and GROUP BY  COUNT function and, Solution defined, Definition of an SQL Group-COUNT is never zero SELECT clause and, Discussion, Relationship Between SELECT and GROUP BY-Relationship Between SELECT and GROUP BY SUM function and, Solution testing for existence of a value within a group, Problem-Discussion by time units, Problem-Discussion  GROUPING function  DB2 Oracle SQL Server , SQL Server and MySQL, Oracle, DB2, and SQL Server, Discussion GROUPING SETS extension  DB2 Oracle , Oracle, DB2, and SQL Server- Oracle, DB2, and SQL Server GROUP_CONCAT function, MySQL, MySQL, MySQL  H hierarchical queries, Hierarchical Queries-Summing Up creating hierarchical view of a table, Problem-Oracle determining which rows are leaf branch root nodes, Problem-Oracle expressing a child-parent-grandparent relationship, Problem-Oracle expressing a parent-child relationship, Problem-Discussion finding all child rows for given parent row, Problem  histograms  horizontal, Problem-Discussion vertical, Problem-Discussion  HOUR function  DB2 , DB2  I IF-ELSE operations, Problem   implicit type conversion, DB2 IN-lists, converting delimited data into, Problem-PostgreSQL indexes, listing, Problem information schema  MySQL PostgreSQL SQL Server , Problem inline views  naming, Discussion referencing aliased columns with, Discussion  inner joins, Discussion, Problem INSERT ALL statement  Oracle , Oracle INSERT FIRST statement  Oracle , Oracle INSERT statement, Solution, Discussion inserting into a column, Problem inserting records  blocking, Problem copying rows from one table to another, Problem with default values, Problem-Discussion into multiple tables, Problem-MySQL, PostgreSQL, and SQL Server new records, Problem with NULL values, Problem  INSTR function, Oracle, Oracle, Oracle INSTR function  Oracle , Solution integrity, deleting records violating, Problem INTERSECT operation, Solution-Discussion ISNUMERIC function, SQL Server ITERATE command  Oracle , Oracle ITERATION_NUMBER function  Oracle , Oracle  J   JOIN clause, Discussion joins  about, Discussion aggregates and, Problem-DB2, Oracle, and SQL Server anti-, Discussion equi-, Discussion, Problem inner, Discussion, Problem scalar subqueries and, Solution selecting columns, Discussion self-, Discussion, Solution  K KEEP extension  Oracle , Oracle, Oracle, Oracle keys  data dependent, Problem foreign, Problem-Discussion preserving, Oracle  knight values, Problem-Oracle Kyte, Tom, Discussion  L LAG OVER window function  Oracle , DB2, MySQL, PostgreSQL, SQL Server, and Oracle-Discussion, Solution-Discussion, Solution LAG window function, Solution LAST function  Oracle , Oracle, Oracle LAST_DAY function  MySQL Oracle , Oracle, MySQL, Oracle, MySQL, Oracle LEAD OVER window function  Oracle   default behavior, Discussion   duplicates and, Discussion options, Discussion, Discussion, Discussion self-joins and, Discussion-Discussion, Solution, Solution uses, DB2, MySQL, PostgreSQL, SQL Server, and Oracle, Discussion, Solution  leap years, Problem-SQL Server LEN function, SQL Server LENGTH function, Solution, DB2, Oracle, MySQL, and PostgreSQL LIKE operator, Solution LIMIT clause  MySQL PostgreSQL , MySQL and PostgreSQL, MySQL LIST_AGG function, DB2 logarithms, Solution loop functionality limits, in SQL, Working with Strings LPAD function  Oracle PostgreSQL MySQL , Oracle, PostgreSQL, and MySQL LTRIM function  Oracle , Oracle  M matrices, creating sparse, Problem MAX function, Solution, Oracle, Solution MAX OVER window function, DB2, Oracle, and SQL Server, Discussion maximum values, finding, Problem-See Also median absolute deviation, finding outliers with, Problem-Discussion MEDIAN function  Oracle , Oracle medians, calculating, Problem-MySQL MERGE statement, Inserting, Updating, and Deleting, Solution merging records, Problem-Discussion metadata queries, Metadata Queries-Summing Up   describing data dictionary views in an Oracle database, Problem listing a table's columns, Problem listing constraints on a table, Problem listing foreign keys without corresponding indexes, Problem-Discussion listing indexed columns for a table, Problem listing tables in a schema, Problem using SQL to generate SQL, Problem-Discussion  MIN function, Solution, Solution MIN OVER window function  DB2 Oracle SQL Server , Discussion, DB2, Oracle, and SQL Server, Discussion minimum values, finding, Problem-See Also MINUS operation, Oracle, Oracle, Solution, DB2, Oracle, and PostgreSQL MINUTE function  DB2 , DB2 MODEL clause  Oracle , Oracle, Problem-Discussion, Solution-Discussion modes, calculating, Problem-See Also modifying records  changing row data, Problem copying rows from one table to another, Problem modifying values in a table, Problem using queries for new values, Discussion with values from another table, Problem-PostgreSQL, SQL Server, and MySQL when corresponding rows exist, Problem  modulus  %  function  SQL Server , SQL Server MONTH function  DB2 MySQL , DB2, DB2, PostgreSQL and MySQL MONTHNAME function  DB2 MySQL , DB2 and MySQL, DB2 multiple tables, inserting data into, Problem-MySQL, PostgreSQL, and SQL Server   multiple tables, retrieving data from, Working with Multiple Tables- Summing Up  adding joins to a query without interfering with other joins, Problem-See Also Cartesian products and, Problem combining related rows, Problem-Discussion comparing, Problem-MySQL and SQL Server finding rows in common between two tables, Problem joins when aggregates are used, Problem-DB2, Oracle, and SQL Server nonmatching rows, Problem NULLs in operations comparisons, Problem outer joins when using aggregates, Problem-Discussion retrieving rows from one table that do not correspond to rows in another, Problem retrieving values from one table that do not exist in another, Problem- MySQL returning missing data from multiple tables, Problem-Discussion stacking one rowset atop another, Problem-Discussion  N n-1 rule, Discussion names, extracting initials from, Problem-MySQL new records, inserting, Problem NEWID function, SQL Server NEXT_DAY function  Oracle , Oracle-Oracle NOT EXISTS, Solution NOT IN operator, MySQL NROWS function  DB2 SQL Server , DB2, MySQL, and SQL Server NTILE window function  Oracle SQL Server , Solution   NULL paradox, Paradoxes NULLs  aggregate functions and, Problem AVG function and, Discussion comparisons to, Discussion COUNT function and, Discussion finding null values, Problem inserting records with, Problem MIN MAX functions and, Discussion NOT IN operator and, MySQL OR operations and, MySQL overriding a default value with, Problem removing  DB2 Oracle SQL Server , Solution removing  PostgreSQL MySQL , Discussion sorting and, Problem-Discussion SUM function and, Discussion, Discussion transforming into real values, Problem window functions and, Effect of NULLs  NULLS FIRST extension, Oracle NULLS LAST extension, Oracle numbers queries, Working with Numbers-Summing Up  aggregating nullable columns, Problem averages, Problem-See Also averages without high low values, Problem-DB2, Oracle, and SQL Server calculating a median, Problem-MySQL calculating a mode, Problem-See Also changing values in a running total, Problem-Discussion   converting alphanumeric strings into numbers, Problem-Discussion converting whole to binary  Oracle , Problem-Discussion counting rows in a table, Problem-See Also counting values in a column, Problem determining the percentage of a total, Problem-DB2, Oracle, and SQL Server finding anomalies using Benford's law, Problem-Discussion finding outliers using the median absolute deviation, Problem-Discussion finding the min max value in a column, Problem-See Also generating a running product, Problem generating a running total, Problem percentage relative to total, Problem-Discussion smoothing a series of values, Problem subtotals for all combinations, Problem-MySQL subtotals, simple, Problem-PostgreSQL summing values in a column, Problem-See Also  O ORDER BY clause, Solution, Discussion, Discussion, Discussion, DB2 and Oracle   see also sorting query results   outer joins  OR logic in, Solution Oracle syntax, Solution, Oracle when using aggregates, Problem-Discussion  outliers, median absolute deviation for finding, Problem-Discussion OVER keyword, Discussion  P   PARTITION BY clause, Partitions-Partitions patterns, searches for matching, Problem percent  %  operator, Solution percentage calculations, Problem-DB2, Oracle, and SQL Server, Problem- Discussion PERCENTILE_CONT function, DB2 and PostgreSQL-MySQL, SQL Server PIVOT operator  SQL Server , Problem-Discussion pivot tables, Tables Used in This Book pivoting  about, Discussion inter-row calculations, Problem-Discussion MODEL clause  Oracle , Problem-Discussion multiple rows, results into, Problem-Discussion one row, results into, Problem-Discussion ranked result sets, Problem-Discussion reverse, Problem-Discussion subtotals, result sets with, Problem-Discussion  PRIOR keyword  Oracle , Oracle  Q QUARTER function  DB2 MySQL , DB2 quotes, embedding within string literals, Problem  R RAND function, DB2 RANDOM function, PostgreSQL random records, retrieving, Problem   ranges, Working with Ranges-Summing Up  filling in missing values, Problem-Discussion finding differences between rows in same group partition, Problem- Discussion generating consecutive numeric values, Problem-PostgreSQL locating range of consecutive values, Problem-DB2, MySQL, PostgreSQL, SQL Server, and Oracle locating the beginning end of a range of consecutive values, Problem- Discussion  RANK OVER window function, Solution RATIO_TO_REPORT function  Oracle , Discussion reciprocal rows, searching for, Problem-Discussion records  merging, Problem-Discussion sorting  see sorting query results   RECURSIVE keyword, Common Table Expressions referential integrity, deleting records violating, Problem REGEXP_REPLACE function, Discussion REPEAT function, DB2 REPEAT function  DB2 , DB2 REPLACE function, Oracle, SQL Server, and PostgreSQL, Working with Strings   see also strings   REPLICATE function  SQL Server , SQL Server reports, queries for creating, Reporting and Reshaping-Summing Up  calculating simple subtotals, Problem-PostgreSQL calculating subtotals for all possible expression combinations, Problem- MySQL creating a predefined number of buckets, Problem   creating a sparse matrix, Problem creating buckets of data, of a fixed size, Problem-Discussion creating horizontal histograms, Problem-Discussion creating vertical histograms, Problem-Discussion grouping rows by units of time, Problem-Discussion identifying rows that are not subtotals, Problem-Discussion performing aggregations over a moving range of values, Problem- PostgreSQL and SQL Server performing aggregations over different groups partitions simultaneously, Problem-Discussion pivoting a result set into multiple rows, Problem-Discussion pivoting a result set into one row, Problem-Discussion pivoting a result set to facilitate inter-row calculations, Problem- Discussion pivoting a result set with subtotals, Problem-Discussion returning non-GROUP BY columns, Problem-Discussion reverse pivoting a result set, Problem-Discussion reverse pivoting a result set into one column, Problem-Discussion suppressing repeating values from a result set, Problem-Discussion using case expressions to flag rows, Problem-Discussion  result set, transposing  Oracle , Problem-Discussion retrieving records, Retrieving Records-Summing Up  concatenating column values, Problem finding null values, Problem finding rows that satisfy multiple conditions, Problem limiting the number of rows returned, Problem-Discussion providing meaningful names for columns, Problem referencing an aliased column in the WHERE clause, Problem   for reports  see reports, queries for creating  retrieving a subset of columns from a table, Problem retrieving a subset of rows from a table, Problem retrieving all rows and columns from a table, Problem returning n random records from a table, Problem searching for patterns, Problem transforming nulls into real values, Problem using conditional logic in a SELECT statement, Problem  reverse pivoting result sets, Problem-Discussion robust statistics, DB2, Oracle, and SQL Server ROLLUP extension of GROUP BY  DB2 Oracle , Solution, Problem, Solution row generation, dynamic, Problem ROWNUM function  Oracle , Oracle, Oracle, Discussion rows  copying from one table to another, Problem finding rows that satisfy multiple conditions, Problem limiting the number of rows returned, Problem-Discussion parsing serialized data into, Problem-Discussion retrieving a subset of rows from a table, Problem retrieving all rows and columns from a table, Problem  ROW_NUMBER function  Oracle , Oracle ROW_NUMBER function  SQL Server , SQL Server ROW_NUMBER OVER window function  DB2 Oracle SQL Server   ORDER BY clause and, DB2, Oracle, and SQL Server uniqueness of result, Discussion uses, DB2, Solution-Discussion, Solution, Solution RPAD function, Oracle and PostgreSQL, Discussion   RTRIM function  Oracle PostgreSQL , Oracle and PostgreSQL RULES subclause  Oracle , Discussion running products, Problem running totals, Problem, Problem-Discussion Russell's Paradox, Groups are distinct Russell, Bertrand, Groups are distinct  S scalar subqueries  converting to composite  Oracle , Problem-Discussion joins and, Solution referencing in WHERE clause, Problem  scripts, generating, Problem-Discussion searching, Advanced Searching-Summing Up  determining which rows are reciprocals, Problem-Discussion finding knight values, Problem-Oracle finding records with highest lowest values, Problem generating simple forecasts, Problem-PostgreSQL incorporating OR logic when using outer joins, Problem-DB2, MySQL, PostgreSQL, and SQL Server investigating future rows, Problem-See Also paginating through a result set, Problem-Discussion patterns, Problem ranking results, Problem selecting top n records, Problem shifting row values, Problem-Discussion skipping n rows from a table, Problem suppressing duplicates, Problem-Traditional alternatives   SECOND function  DB2 , DB2 SELECT function, Solution SELECT statements, Solution  see also retrieving records  * character in, Solution conditional logic in, Problem DISTINCT keyword and, Discussion, Traditional alternatives, Groups are distinct GROUP BY and, Discussion, Relationship Between SELECT and GROUP BY-Relationship Between SELECT and GROUP BY partial, Tables Used in This Book  self-joins  alternatives to, Discussion, Solution, Discussion uses, Discussion, Solution  separation, axiom schema of, Groups are distinct serialized data, parsing into rows, Problem-Discussion SET differences, Solution SHOW INDEX command, MySQL, MySQL SIGN function  MySQL PostgreSQL , PostgreSQL and MySQL sorting query results, Sorting Query Results-Summing Up  on data-dependent key, Problem mixed alphanumeric data, Problem-Discussion by multiple fields, Problem NULLS and, Problem-Discussion returning in a specified order, Problem-Discussion by substrings, Problem  SOUNDEX function, Solution specification, axiom of, Groups are distinct   SPLIT_PART function, PostgreSQL, PostgreSQL, PostgreSQL, PostgreSQL star  *  character in SELECT statements, Solution START WITH clause  Oracle , Oracle, Oracle Stoll, Robert, Groups are distinct strings, Working with Strings-Summing Up  alphabetizing, Problem-PostgreSQL alphanumeric, sorting mixed, Problem-Discussion comparing strings by sound, Problem-Discussion converting alphanumeric strings to numbers, Problem-Discussion converting delimited data into a multivalued IN-list, Problem- PostgreSQL counting the occurrences of a character in a string, Problem creating a delimited list from table rows, Problem-Oracle determining whether alphanumeric, Problem-MySQL embedding quotes within string literals, Problem extracting elements from unfixed locations, Problem-Discussion extracting initials from a name, Problem-MySQL extracting the nth delimited substring, Problem-PostgreSQL finding text not matching a pattern, Problem-Discussion identifying strings that can be treated as numbers, Problem-MySQL mixed alphanumeric, Problem-Discussion ordering by a number in a string, Problem-Discussion ordering by parts of a string, Problem-Discussion parsing an IP address, Problem-Discussion parsing into rows, Problem-Discussion removing unwanted characters from, Problem-Discussion separating numeric and character data, Problem-Discussion   traversing, Problem-Discussion walking a string, Problem-Discussion  STRING_AGG function, PostgreSQL and SQL Server, PostgreSQL, SQL Server STRING_SPLIT function, SQL Server, SQL Server STR_TO_DATE function  MySQL , MySQL subqueries, Problem-Discussion, Subqueries subsets, axiom schema of, Groups are distinct SUBSTR function  DB2 MySQL Oracle PostgreSQL , DB2, MySQL, Oracle, and PostgreSQL, MySQL, DB2, Oracle, MySQL, and PostgreSQL, Oracle, SQL Server, PostgreSQL, Oracle, Oracle SUBSTRING function  MySQL , MySQL SUBSTRING function  SQL Server , SQL Server, SQL Server, SQL Server, SQL Server, SQL Server substrings  extracting the nth delimited substring, Problem-PostgreSQL sorting query results by, Problem  SUBSTRING_INDEX function  MySQL , MySQL, MySQL, MySQL, MySQL subtotals  calculating for all combinations, Problem-MySQL calculating simple, Problem-PostgreSQL pivoting result set with, Problem-Discussion  SUM function, Discussion, Discussion SUM OVER window function  DB2 Oracle SQL Server , DB2, Oracle, and SQL Server, DB2, MySQL, PostgreSQL, and SQL Server, Discussion, Solution, DB2, Oracle, and SQL Server, Solution summing column values, Problem-See Also   SYS_CONNECT_BY_PATH function  Oracle , Oracle, Oracle, Oracle, Oracle, Oracle, Oracle, Oracle  T tables, creating with same columns as  existing table, Problem  time, grouping rows by, Problem-Discussion TOP keyword  SQL Server , SQL Server TO_BASE function  Oracle , Discussion TO_CHAR function  Oracle PostgreSQL , PostgreSQL, PostgreSQL, Oracle, Oracle, Oracle TO_NUMBER function  Oracle PostgreSQL , Oracle TRANSLATE function, Oracle, SQL Server, and PostgreSQL, Working with Strings   see also strings   transposing result sets  Oracle , Problem-Discussion trimmed mean, Problem, DB2, Oracle, and SQL Server TRUNC function  Oracle , Oracle, Oracle, Oracle TRUNCATE command, Discussion  U underscore  _  operator, Discussion UNION ALL operation, Solution-Discussion, Oracle, DB2, Oracle, and PostgreSQL-MySQL and SQL Server, DB2, Paradoxes UNION operation, Discussion, Discussion UNPIVOT operator  SQL Server , Problem-Solution UPDATE statement, Solution-Discussion  V   VALUE function, Oracle  W WHERE clause  determining whether a string is alphanumeric, MySQL finding rows that satisfy multiple conditions, Solution RECURSIVE with, Common Table Expressions referencing an aliased column in, Problem retrieving a subset of rows from a table, Solution ROWNUM with, Oracle  whole numbers, converting to binary, Problem-Discussion wildcard  %  operator, Solution window functions, Preface, Window Function Refresher-Providing a Base  advantages, Discussion, Discussion, Readability + Performance = Power- Readability + Performance = Power NULLs and, Effect of NULLs partitions, Partitions-Partitions platforms supporting, Solution, Solution referencing in WHERE clause, Discussion reports and, Providing a Base-Providing a Base timing of, DB2, MySQL, PostgreSQL, SQL Server, and Oracle, Discussion  WITH clause  DB2 SQL Server , DB2, PostgreSQL, and SQL Server, DB2, PostgreSQL, and SQL Server, DB2, MySQL, PostgreSQL, and SQL Server WITH clause  SQL Server , SQL Server WITH ROLLUP  SQL Server MySQL , SQL Server and MySQL  Y   YEAR function  DB2 MySQL SQL Server , DB2, DB2 Young, Kay, Problem  Z Zermelo, Ernst, Groups are distinct   About the Authors Anthony Molinaro is a data scientist at Johnson & Johnson. In his current role he is a manager in the Observational Health Data Analytics group within Janssen R&D. His primary areas of research are nonparametric methods, time-series analysis, and large-scale database characterization and transformation. He is a member of the open science OHDSI community. Anthony holds a BA in mathematics and an MA in applied mathematics & statistics from CUNY Hunter College. He resides in New York with his wife Georgia and his two daughters, Kiki and Connie. Robert de Graaf graduated as an engineer and worked in the manufacturing industry after completing his studies. While working as an engineer, Robert discovered the power of statistics for solving real-world problems, and completed a master’s degree in statistics in time to benefit from the data science boom. He has worked for RightShip as their senior data scientist since 2013, and is the author of Managing Your Data Science Projects  Apress .   Colophon The animal on the cover of SQL Cookbook is a starred agama or roughtail rock agama  Stellagama stellio . These lizards can be found in Egypt, Turkey, Greece, and other countries surrounding the Mediterranean Sea, and are often present in rocky mountainous and coastal regions with arid or semi-arid climates. Starred agamas are diurnal and can often be found on rocks, trees, buildings, and other habitats that allow for climbing and hiding. Starred agamas lay anywhere from 3 to 12 eggs per clutch, and they grow to about 30–35 cm in length. This species is characterized by strong legs and —like many other agamids—the ability to change color depending on their mood or the surrounding temperature. Both males and females typically have gray or brown bodies with colorful spots along their back and sides. Unlike other lizards, agamids such as the starred agama cannot regenerate their tails if they lose them. Though they can be skittish, starred agamas are not usually aggressive toward humans and become quite tame if handled from a young age. They are commonly kept as pets, and can be fed a combination of insects and various leafy greens. Small groups of agamas can be housed together if the terrarium is large enough, but males need to be kept separate from one another to prevent fighting. The IUCN does not list the starred agama as a species of concern, and its population is stable. Many of the animals on O’Reilly covers are endangered; all of them are important to the world. The cover illustration is by Karen Montgomery, based on a black and white engraving, loose plate, source unknown. The cover fonts are Gilroy Semibold and Guardian Sans. The text font is Adobe Minion Pro; the heading font is Adobe Myriad Condensed; and the code font is Dalton Maag’s Ubuntu Mono.

@highlight

This second edition applies a highly practical approach to Structured Query Language (SQL) so you can create and manipulate large stores of data. Based on real-world examples, this updated cookbook provides a framework to help you construct solutions and executable examples in severalflavors of SQL, including Oracle, DB2, SQL Server, MySQL, andPostgreSQL. SQL programmers, analysts, data scientists, database administrators, and even relatively casual SQL users will find SQL Cookbook to be a valuable problem-solving guide for everyday issues. No other resource offers recipes in this unique format to help you tackle nagging day-to-day conundrums with SQL. The second edition includes, Fully revised recipes that recognize the greater adoption of window functions in SQL implementations.