Mathematics for   3D Game Programming  and Computer Graphics   Third Edition   Eric Lengyel   Course Technology PTR  A part of Cengage Learning   Australia   Brazil   Japan   Korea   Mexico   Singapore   Spain   United Kingdom   United States            Mathematics for 3D Game Programming  and Computer Graphics, Third Edition  By Eric Lengyel     Publisher and General Manager,  Course Technology PTR:  Stacy L. Hiquet    Associate Director of Marketing:  Sarah Panella    Manager of Editorial Services:  Heather Talbot    Marketing Manager:  Jordan Castellani    Senior Acquisitions Editor:  Emi Smith    Cover Designer:  Mike Tanamachi    Proofreader:  Mike Beady       Printed in China  1 2 3 4 5 6 7 13 12 11       2012 Course Technology, a part of Cengage Learning.    ALL RIGHTS RESERVED. No part of this work covered by the copyright  herein may be reproduced, transmitted, stored, or used in any form or by  any means graphic, electronic, or mechanical, including but not limited to  photocopying, recording, scanning, digitizing, taping, Web distribution,  information networks, or information storage and retrieval systems, except  as permitted under Section 107 or 108 of the 1976 United States Copyright  Act, without the prior written permission of the publisher.   For product information and technology assistance, contact us at  Cengage Learning Customer & Sales Support, 1-800-354-9706   For permission to use material from this text or product,  submit all requests online at cengage.com permissions   Further permissions questions can be emailed to   permissionrequest@cengage.com         All trademarks are the property of their respective owners.  All images   Cengage Learning unless otherwise noted.    Library of Congress Control Number: 2011924487   ISBN-13: 978-1-4354-5886-4   ISBN-10: 1-4354-5886-9  eISBN-10: 1-4354-5887-7     Course Technology, a part of Cengage Learning  20 Channel Center Street  Boston, MA  02210  USA     Cengage Learning is a leading provider of customized learning solutions  with office locations around the globe, including Singapore, the United  Kingdom, Australia, Mexico, Brazil, and Japan. Locate your local office at:  international.cengage.com region     Cengage Learning products are represented in Canada by Nelson  Education, Ltd.     For your lifelong learning solutions, visit courseptr.com   Visit our corporate website at cengage.com              Contents   Preface      What’s New in the Third Edition  Contents Overview  Website and Code Listings  Notational Conventions   Chapter 1   The Rendering Pipeline   1.1  Graphics Processors  1.2  Vertex Transformation  1.3  Rasterization and Fragment Operations   Chapter 2   Vectors   2.1  Vector Properties  2.2  The Dot Product  2.3  The Cross Product  2.4  Vector Spaces  Chapter 2 Summary  Exercises for Chapter 2   Chapter 3  Matrices   3.1  Matrix Properties  3.2  Linear Systems  3.3  Matrix Inverses  3.4  Determinants  3.5  Eigenvalues and Eigenvectors  3.6  Diagonalization   xiii  xiii  xiv  xvii  xvii  1  1  4  6   11  11  15  19  26  29  30  31  31  34  40  47  54  58   iii    iv      Chapter 3 Summary  Exercises for Chapter 3   Chapter 4   Transforms   4.1  Linear Transformations   4.1.1  Orthogonal Matrices  4.1.2  Handedness  4.2  Scaling Transforms  4.3  Rotation Transforms   4.3.1  Rotation About an Arbitrary Axis   4.4  Homogeneous Coordinates   4.4.1  Four-Dimensional Transforms  4.4.2  Points and Directions  4.4.3  Geometrical Interpretation of the w Coordinate   4.5  Transforming Normal Vectors  4.6  Quaternions   4.6.1  Quaternion Mathematics  4.6.2  Rotations with Quaternions  4.6.3  Spherical Linear Interpolation   Chapter 4 Summary  Exercises for Chapter 4   Chapter 5  Geometry for 3D Engines   5.1  Lines in 3D Space   5.1.1  Distance Between a Point and a Line  5.1.2  Distance Between Two Lines   5.2  Planes in 3D Space   5.2.1  Intersection of a Line and a Plane  5.2.2  Intersection of Three Planes  5.2.3  Transforming Planes   5.3  The View Frustum  5.3.1  Field of View  5.3.2  Frustum Planes   5.4  Perspective-Correct Interpolation   5.4.1  Depth Interpolation  5.4.2  Vertex Attribute Interpolation   5.5  Projections   5.5.1  Perspective Projections  5.5.2  Orthographic Projections   Contents   62  64  67  67  68  70  70  71  74  75  76  77  78  78  80  80  82  86  89  91  93  93  93  94  97  98  99  101  102  103  106  107  108  110  111  112  116          5.5.3  Extracting Frustum Planes  5.6  Reflections and Oblique Clipping  Chapter 5 Summary  Exercises for Chapter 5   Chapter 6   Ray Tracing   6.1  Root Finding   6.1.1  Quadratic Polynomials  6.1.2  Cubic Polynomials  6.1.3  Quartic Polynomials  6.1.4  Newton’s Method  6.1.5  Refinement of Reciprocals and Square Roots   6.2  Surface Intersections   6.2.1  Intersection of a Ray and a Triangle  6.2.2  Intersection of a Ray and a Box  6.2.3  Intersection of a Ray and a Sphere  6.2.4  Intersection of a Ray and a Cylinder  6.2.5  Intersection of a Ray and a Torus   6.3  Normal Vector Calculation  6.4  Reflection and Refraction Vectors   6.4.1  Reflection Vector Calculation  6.4.2  Refraction Vector Calculation   Chapter 6 Summary  Exercises for Chapter 6   Chapter 7   Lighting and Shading   7.1  RGB Color  7.2  Light Sources   7.2.1  Ambient Light  7.2.2  Directional Light Sources  7.2.3  Point Light Sources  7.2.4  Spot Light Sources   7.3  Diffuse Reflection  7.4  Specular Reflection  7.5  Texture Mapping   7.5.1  Standard Texture Maps  7.5.2  Projective Texture Maps  7.5.3  Cube Texture Maps  7.5.4  Filtering and Mipmaps   v   118  120  126  129  131  131  131  132  135  136  139  140  141  143  144  145  147  148  149  150  151  153  154  157  157  158  158  159  159  160  161  162  164  166  167  169  171    vi      Contents   7.6  Emission  7.7  Shading Models   7.7.1  Calculating Normal Vectors  7.7.2  Gouraud Shading  7.7.3  Blinn-Phong Shading   7.8  Bump Mapping   7.8.1  Bump Map Construction  7.8.2  Tangent Space  7.8.3  Calculating Tangent Vectors  7.8.4  Implementation   7.9  A Physical Reflection Model   7.9.1  Bidirectional Reflectance Distribution Functions  7.9.2  Cook-Torrance Illumination  7.9.3  The Fresnel Factor  7.9.4  The Microfacet Distribution Function  7.9.5  The Geometrical Attenuation Factor  7.9.6  Implementation   Chapter 7 Summary  Exercises for Chapter 7   Chapter 8   Visibility Determination   8.1  Bounding Volume Construction   8.1.1  Principal Component Analysis  8.1.2  Bounding Box Construction  8.1.3  Bounding Sphere Construction  8.1.4  Bounding Ellipsoid Construction  8.1.5  Bounding Cylinder Construction   8.2  Bounding Volume Tests   8.2.1  Bounding Sphere Test  8.2.2  Bounding Ellipsoid Test  8.2.3  Bounding Cylinder Test  8.2.4  Bounding Box Test   8.3  Spatial Partitioning   8.3.1  Octrees  8.3.2  Binary Space Partitioning Trees   8.4  Portal Systems   8.4.1  Portal Clipping  8.4.2  Reduced View Frustums   174  175  175  176  177  178  178  180  180  185  187  187  191  192  195  198  200  205  209  211  211  212  215  217  218  220  221  221  222  226  228  230  230  232  235  236  238          Chapter 8 Summary  Exercises for Chapter 8   Chapter 9   Polygonal Techniques   9.1  Depth Value Offset   Chapter 10  Shadows   9.1.1  Projection Matrix Modification  9.1.2  Offset Value Selection  9.1.3  Implementation   9.2  Decal Application   9.2.1  Decal Mesh Construction  9.2.2  Polygon Clipping   9.3  Billboarding   9.3.1  Unconstrained Quads  9.3.2  Constrained Quads  9.3.3  Polyboards   9.4  Polygon Reduction  9.5  T-Junction Elimination  9.6  Triangulation  Chapter 9 Summary  Exercises for Chapter 9   10.1  Shadow Casting Set  10.2  Shadow Mapping   10.2.1  Rendering the Shadow Map  10.2.2  Rendering the Main Scene  10.2.3  Self-Shadowing   10.3  Stencil Shadows   10.3.1  Algorithm Overview  10.3.2  Infinite View Frustums  10.3.3  Silhouette Determination  10.3.4  Shadow Volume Construction  10.3.5  Determining Cap Necessity  10.3.6  Rendering Shadow Volumes  10.3.7  Scissor Optimization   Chapter 10 Summary  Exercises for Chapter 10   vii   240  244   245  245  246  247  248  249  250  252  254  254  257  258  260  264  267  274  277   279  279  281  281  283  284  286  286  291  294  299  303  307  309  314  315    viii      Chapter 11  Curves and Surfaces   11.1  Cubic Curves  11.2  Hermite Curves  11.3  Bézier Curves   11.3.1  Cubic Bézier Curves  11.3.2  Bézier Curve Truncation  11.3.3  The de Casteljau Algorithm   11.4  Catmull-Rom Splines  11.5  Cubic Splines  11.6  B-Splines   11.6.1  Uniform B-Splines  11.6.2  B-Spline Globalization  11.6.3  Nonuniform B-Splines  11.6.4  NURBS   11.7  Bicubic Surfaces  11.8  Curvature and Torsion  Chapter 11 Summary  Exercises for Chapter 11   Chapter 12  Collision Detection   12.1  Plane Collisions   12.1.1  Collision of a Sphere and a Plane  12.1.2  Collision of a Box and a Plane  12.1.3  Spatial Partitioning  12.2  General Sphere Collisions  12.3  Sliding  12.4  Collision of Two Spheres  Chapter 12 Summary  Exercises for Chapter 12   Chapter 13  Linear Physics  13.1  Position Functions  13.2  Second-Order Differential Equations   13.2.1  Homogeneous Equations  13.2.2  Nonhomogeneous Equations  13.2.3  Initial Conditions   13.3  Projectile Motion  13.4  Resisted Motion   Contents   317  317  320  322  322  326  327  329  331  334  335  340  342  345  348  350  355  357  361  361  362  364  366  366  371  372  376  378  379  379  381  381  385  388  390  394          ix   13.5  Friction  Chapter 13 Summary  Exercises for Chapter 13   Chapter 14  Rotational Physics   14.1  Rotating Environments  14.1.1  Angular Velocity  14.1.2  The Centrifugal Force  14.1.3  The Coriolis Force   14.2  Rigid Body Motion   14.2.1  Center of Mass  14.2.2  Angular Momentum and Torque  14.2.3  The Inertia Tensor  14.2.4  Principal Axes of Inertia  14.2.5  Transforming the Inertia Tensor   14.3  Oscillatory Motion  14.3.1  Spring Motion  14.3.2  Pendulum Motion   Chapter 14 Summary  Exercises for Chapter 14   Chapter 15  Fluid and Cloth Simulation   15.1  Fluid Simulation   15.1.1  The Wave Equation  15.1.2  Approximating Derivatives  15.1.3  Evaluating Surface Displacement  15.1.4  Implementation   15.2  Cloth Simulation   15.2.1  The Spring System  15.2.2  External Forces  15.2.3  Implementation   Chapter 15 Summary  Exercises for Chapter 15   Chapter 16  Numerical Methods   16.1  Trigonometric Functions  16.2  Linear Systems   16.2.1  Triangular Systems  16.2.2  Gaussian Elimination   396  400  402  405  405  405  407  408  410  410  413  414  422  426  430  430  434  436  438  443  443  443  447  450  453  457  457  459  459  461  462  463  463  465  465  467    x      Contents   16.2.3  LU Decomposition  16.2.4  Error Reduction  16.2.5  Tridiagonal Systems   16.3  Eigenvalues and Eigenvectors  16.4  Ordinary Differential Equations   16.4.1  Euler’s Method  16.4.2  Taylor Series Method  16.4.3  Runge-Kutta Method  16.4.4  Higher-Order Differential Equations   Chapter 16 Summary  Exercises for Chapter 16   Appendix A  Complex Numbers   A.1  Definition  A.2  Addition and Multiplication  A.3  Conjugates and Inverses  A.4  The Euler Formula   Appendix B  Trigonometry Reference   B.1  Function Definitions  B.2  Symmetry and Phase Shifts  B.3  Pythagorean Identities  B.4  Exponential Identities  B.5  Inverse Functions  B.6  Laws of Sines and Cosines   Appendix C  Coordinate Systems  C.1  Cartesian Coordinates  C.2  Cylindrical Coordinates  C.3  Spherical Coordinates  C.4  Generalized Coordinates   Appendix D  Taylor Series   D.1  Derivation  D.2  Power Series  D.3  The Euler Formula   Appendix E  Answers to Exercises   Chapter 2   470  477  479  483  490  490  492  493  495  496  498  499  499  499  500  501  505  505  506  507  507  508  509  513  513  514  516  520  523  523  525  526  529  529       xi   Chapter 3  Chapter 4  Chapter 5  Chapter 6  Chapter 7  Chapter 8  Chapter 9  Chapter 10  Chapter 11  Chapter 12  Chapter 13  Chapter 14  Chapter 15  Chapter 16         Index      529  530  530  530  531  531  531  531  532  532  532  533  534  534  535    This page intentionally left blank            Preface   This  book  illustrates  mathematical  techniques  that  a  software  engineer  would  need to develop a professional-quality 3D graphics engine. Particular attention is  paid to the derivation of key results in order to provide a complete exposition of  the subject and to encourage a deep understanding of the mechanics behind the  mathematical tools used by game programmers.    Most of the material in this book is presented in a manner that is independent  of the underlying 3D graphics system used to render images. We assume that the  reader is familiar with the basic concepts needed to use a 3D graphics library and  understands how models are constructed out of vertices and polygons. However,  the book begins with a short review of the rendering pipeline as it is implemented  in the OpenGL library. When it becomes necessary to discuss a topic in the con- text of a 3D graphics library, OpenGL is the one that we choose due to its availa- bility across multiple platforms.  Each chapter ends with a summary of the important equations and formulas    derived within the text. The summary is intended to serve as a reference tool so  that  the  reader  is  not  required  to  wade  through  long  discussions  of  the  subject  matter in order to find a single result. There are also several exercises at the end  of  each  chapter.  The  answers  to  exercises  requiring  a  calculation  are  given  in  Appendix E.   What’s New in the Third Edition   The following list highlights the major changes and additions in the third edition.  Many minor additions and enhancements have also been made, including updates  to almost all of the figures in the book.      A discussion of oblique near plane clipping has been added to the view frus-  tum topics covered in Chapter 5.   xiii    xiv      Preface      Chapter 10 now begins with a discussion of shadow casting set determination   before going into discussions of shadow generation techniques.  In addition to the stencil shadow algorithm, the shadow mapping technique is  now covered in Chapter 10.          The discussion of the inertia tensor in Chapter 14 has been expanded.     Chapter 15 has been expanded to include an introduction to cloth simulation   in addition to its discussion of fluid surface simulation.      A fast method for calculating the sine and cosine functions has been added to   the beginning of the numerical methods coverage in Chapter 16.   Contents Overview   Chapter 1: The Rendering Pipeline. This is a preliminary chapter that provides  an  overview  of  the  rendering  pipeline  in  the  context  of  the  OpenGL  library.  Many of the topics mentioned in this chapter are examined in higher detail else- where in the book, so mathematical discussions are intentionally avoided here.   Chapter 2: Vectors. This chapter begins the mathematical portion of the book  with a thorough review of vector quantities and their properties. Vectors are of  fundamental importance in the study of 3D computer graphics, and we make ex- tensive use of operations such as the dot product and cross product throughout  the book.   Chapter 3: Matrices. An understanding of matrices is another basic necessity of  3D game programming. This chapter discusses elementary concepts such as ma- trix representation of linear systems as well as more advanced topics, including  eigenvectors and diagonalization, which are required later in the book. For com- pleteness, this chapter goes into a lot of detail to prove various matrix properties,  but an understanding of those details is not essential when using matrices later in  the book, so the uninterested reader may skip over the proofs.   Chapter 4: Transforms. In Chapter 4, we investigate matrices as a tool for per- forming transformations such as translations, rotations, and scales. We introduce  the  concept  of  four-dimensional  homogeneous  coordinates,  which  are  widely  used in 3D graphics systems to move between different coordinate spaces. We  also study the properties of quaternions and their usefulness as a transformation  tool.    Contents Overview      xv   Chapter 5: Geometry for 3D Engines. It is at this point that we begin to see  material presented in the previous three chapters applied to practical applications  in  3D  game  programming  and  computer  graphics.  After  analyzing  lines  and  planes in 3D space, we introduce the view frustum and its relationship to the vir- tual  camera.  This  chapter  includes  topics  such  as  field  of  view,  perspective- correct interpolation, and projection matrices.   Chapter 6: Ray Tracing. Ray tracing methods are useful in many areas of game  programming,  including  light  map  generation,  line-of-sight  determination,  and  collision  detection.  This  chapter  begins  with  analytical  and  numerical  root- finding techniques, and then presents methods for intersecting rays with common  geometrical  objects.  Finally,  calculation  of  reflection  and  refraction  vectors  is  discussed.   Chapter 7: Lighting and Shading. Chapter 7 discusses a wide range of topics  related to illumination and shading methods. We begin with an enumeration of  the different types of light sources and then proceed to simple reflection models.  Later,  we  inspect  methods  for  adding  detail  to  rendered  surfaces  using  texture  maps, gloss maps, and bump maps. The chapter closes with a detailed explana- tion of the Cook-Torrance physical illumination model.   Chapter 8: Visibility Determination. The performance of a 3D engine is heavi- ly dependent on its ability to determine what parts of a scene  are visible. This  chapter presents methods for constructing various types of bounding volumes and  subsequently testing their visibility against the view frustum. Large-scale visibil- ity determination enabled through spatial partitioning and the use of portal sys- tems is also examined.   Chapter  9:  Polygonal  Techniques.  Chapter  9  presents  several  techniques  in- volving the manipulation of polygonal models. The first topic covered is decal  application  to  arbitrary  surfaces  and  includes  a  related  method  for  performing  vertex depth offset. Other topics include billboarding techniques used for various  special effects, a polygon reduction technique, T-junction elimination, and poly- gon triangulation.   Chapter 10: Shadows. This chapter discusses shadow-casting sets and the two  prominent  methods  for  generating  shadows  in  a  real-time  application,  shadow  mapping and stencil shadows. The presentation of the stencil shadow algorithm is  particularly detailed because it draws on several smaller geometric techniques.    xvi      Preface   Chapter 11: Curves and Surfaces. In this chapter, we examine of a broad varie- ty of cubic curves, including Bézier curves and B-splines. We also discuss how  concepts pertaining to two-dimensional curves are extended to three-dimensional  surfaces.   Chapter 12: Collision Detection. Collision detection is necessary for interaction  between  different  objects  in  a  game  universe.  This  chapter  presents  general  methods for determining whether moving objects collide with the static environ- ment and whether they collide with each other.   Chapter 13: Linear Physics. At this point in the book, we begin a two-chapter  survey of various topics in classical physics that pertain to the motion that objects  are likely to exhibit in a 3D game. Chapter 13 begins with a discussion of posi- tion functions as solutions to second-order differential equations. We then inves- tigate projectile motion both through empty space and through a resistive medi- um, and close with a look at frictional forces.   Chapter 14: Rotational Physics. Chapter 14 continues the treatment of physics  with a rather advanced exposition on rotation. We first study the forces experi- enced by an object in a rotating environment. Next, we examine rigid body mo- tion and derive the relationship between angular velocity and angular momentum  through the inertia tensor. Also included is a discussion of the oscillatory motion  exhibited by springs and pendulums.   Chapter 15: Fluid and Cloth Simulation. We continue with the theme of phys- ical simulation by presenting a physical model for fluid motion based on the two- dimensional wave equation and cloth motion based on a spring-damper system.   Chapter  16:  Numerical  Methods.  The  book  finishes  with  an  examination  of  numerical  techniques  for  calculating  trigonometric  functions  and  solving  three  particular types of problems. We first discuss effective methods for finding the  solutions to linear systems of any size. Next, we present an iterative technique for  determining the eigenvalues and eigenvectors of a 3 3  symmetric matrix. Final- ly,  we  study  methods  for  approximating  the  solutions  to  ordinary  differential  equations.   Appendix  A:  Complex  Numbers.  Although  not  used  extensively,  complex  numbers do appear in a few places in the text. Appendix A reviews the concept  of complex numbers and discusses the properties that are used elsewhere in the  book.    Website and Code Listings      xvii   Appendix B: Trigonometry Reference. Appendix B reviews the trigonometric  functions  and  quickly  derives  many  formulas  and  identities  that  are  used  throughout this book.   Appendix  C:  Coordinate  Systems.  Appendix  C  provides  a  brief  overview  of  Cartesian  coordinates,  cylindrical  coordinates,  and spherical  coordinates.  These  coordinate  systems  appear  in  several  places  throughout  the  book,  but  are  used  most extensively in Chapter 14.   Appendix  D:  Taylor  Series.  The  Taylor  series  of  various  functions  are  em- ployed in a number of places throughout the book. Appendix D derives the Tay- lor series and reviews power series representations for many common functions.   Appendix E: Answers to Exercises. This appendix contains the answer to every  exercise in the book having a solution that can be represented by a mathematical  expression.   Website and Code Listings   The official website for this book can be found at the following address:      http:  www.mathfor3dgameprogramming.com    All of the code listings in the book can be downloaded from this website. Some  of  the  listings  make  use  of  simple  structures  such  as Triangle  and Edge  or  mathematical  classes  such  as Vector3D  and Matrix3D.  The  source  code  for  these can also be found on the website.    The language used for all code that is intended to run on the CPU is standard  C++. Vertex shaders and fragment shaders that are intended to run on the GPU  use the OpenGL Shading Language  GLSL .   Notational Conventions   We  have  been  careful  to  use  consistent  notation  throughout  this  book.  Scalar  quantities are always represented by italic Roman or Greek letters. Vectors, ma- trices, and quaternions are always represented by bold letters. A single compo- nent of a vector, matrix, or quaternion is a scalar quantity, so it is italic. For ex- ample, the x component of the vector v is written  xv . These conventions and other  notational standards used throughout the book are summarized in the table on the  next page.    xviii   Preface         Quantity Operation  Scalars  Angles  Vectors  Quaternions  Matrices  RGB Colors  Magnitude of a vector  Conjugate of a complex number z or a  quaternion q  Transpose of a matrix  Determinant of a matrix   Time derivative   Binomial coefficient   Floor of x  Ceiling of x  Fractional part of x   Sign of x   Closed interval  Open interval  Interval closed at one end and open at  the other end  Set of real numbers  Set of complex numbers  Set of quaternions   Notation Examples  Italic letters: x, t, A, ,   Italic Greek letters: , ,   Boldface letters: V, P, x, ω  Boldface letters: q,  1q ,  Boldface letters: M, P  Script letters: , , ,   Double bar:  P    2q    Overbar: z , q   Superscript T:  det M or single bars:  M    TM    x  t      x  t       d dt    !    Dot notation:  n n !      k k n k  !    x    x    frac x          x  sgn  x if  1, 0    x 0 if  0,      x 1, if  0         a b x a x b  ,      x b x a a b     ,       x x a a b b ,        b a b x a x   ,          Chapter 1   The Rendering Pipeline   This chapter  provides a preliminary review of the rendering pipeline. It covers  general  functions,  such  as  vertex  transformation  and  primitive  rasterization,  which are performed by modern 3D graphics hardware. Readers who are familiar  with these concepts may safely skip ahead. We intentionally avoid mathematical  discussions in this chapter and instead provide pointers to other parts of the book  where  each  particular  portion  of  the  rendering  pipeline  is  examined  in  greater  detail.   1.1  Graphics Processors   A typical scene that is to be rendered as 3D graphics is composed of many sepa- rate objects. The geometrical forms of these objects are each represented by a set  of vertices and a particular type of graphics primitive that indicates how the ver- tices  are  connected  to  produce  a  shape.  Figure  1.1  illustrates  the  ten  types  of  graphics primitive defined by the OpenGL library. Graphics hardware is capable  of rendering a set of individual points, a series of line segments, or a group of  filled polygons. Most of the time, the surface of a 3D model is represented by a  list of triangles, each of which references three points in a list of vertices.    The  usual  modern  3D  graphics  board  possesses  a  dedicated  Graphics  Pro- cessing Unit  GPU  that executes instructions independently of the Central Pro- cessing  Unit   CPU .  The  CPU  sends  rendering  commands  to  the  GPU,  which  then performs the rendering operations while the CPU continues with other tasks.  This is called asynchronous operation. When geometrical information is submit- ted to a rendering library such as OpenGL, the function calls used to request the  rendering operations typically return a significant amount of time before the GPU  has  finished  rendering  the  graphics.  The  lag  time  between  the  submission  of  a  rendering command and the completion of the rendering operation does not nor- mally cause problems, but there are cases when the time at which drawing com-        1    2      1. The Rendering Pipeline   0  1  2  3  Points  0 2  4  1  0  1  1  5  3  4  7  6  0  1  4  6  3  2  6  7  4  0  1  Line Strip  2  3  2  3  5 Triangle Strip  0  1  4  5  Quad Strip  Lines  0  5  3  2  Triangles  2  3  4  5  Quads  5  4  3  Line Loop  2  1  5  4  3  2  Triangle Fan  1  0  6     5  4 Polygon  0  0  1  2  3  Figure 1.1. The OpenGL  library  defines  ten  types of  graphics primitive.  The numbers  indicate the order in which the vertices are specified for each primitive type.   pletes needs to be known. There exist OpenGL extensions that allow the program  running on the CPU to determine when a particular set of rendering commands  have finished executing on the GPU. Such synchronization has the tendency to  slow down a 3D graphics application, so it is usually avoided whenever possible  if performance is important.    An application communicates with the GPU by sending commands to a ren- dering library, such as OpenGL, which in turn sends commands to a driver that  knows how to speak to the GPU in its native language. The interface to OpenGL  is called a Hardware Abstraction Layer  HAL  because it exposes a common set    1.1  Graphics Processors      3   of  functions  that  can  be  used  to  render  a  scene  on  any  graphics  hardware  that  supports  the  OpenGL  architecture.  The  driver  translates  the  OpenGL  function  calls into code that the GPU can understand. A 3D graphics driver usually im- plements OpenGL functions directly to minimize the overhead of issuing render- ing commands. The block diagram shown in Figure 1.2 illustrates the communi- cations that take place between the CPU and GPU.    A 3D graphics board has its own memory core, which is commonly called  VRAM  Video Random Access Memory . The GPU may store any information in  VRAM, but there are several types of data that can almost always be found in the  graphics board’s memory when a 3D graphics application is running. Most im- portantly,  VRAM  contains  the  front  and  back  image  buffers.  The  front  image  buffer contains the exact pixel data that is visible in the viewport. The viewport is  the area of the display containing the rendered image and may be a subregion of  a window, the entire contents of a window, or the full area of the display. The   CPU  Main Memory  Vertex data Texture data Shader parameters  Rendering commands  Command buffer  Application  OpenGL or  DirectX  Graphics Driver  GPU  Video Memory  Image Buffers  Depth stencil  Buffer  Texture Maps  Vertex Buffers     Figure 1.2. The communications that take place between the CPU and GPU.    4      1. The Rendering Pipeline   back image buffer is the location to which the GPU actually renders a scene. The  back buffer is not visible and exists so that a scene can be rendered in its entirety  before being shown to the user. Once an image has been completely rendered, the  front  and  back  image  buffers  are  exchanged.  This  operation  is  called  a  buffer  swap and can be performed either by changing the memory address that repre- sents the base of the visible image buffer or by copying the contents of the back  image  buffer  to  the  front  image  buffer.  The  buffer  swap  is  often  synchronized  with the refresh frequency of the display to avoid an artifact known as tearing.  Tearing occurs when a buffer swap is performed during the display refresh inter- val, causing the upper and lower parts of a viewport to show data from different  image buffers.    Also stored in VRAM is a block of data called the depth buffer or z-buffer.  The depth buffer stores, for every pixel in the image buffer, a value that repre- sents how far away the pixel is or how deep the pixel lies in the image. The depth  buffer is used to perform hidden surface elimination by only allowing a pixel to  be drawn if its depth is less than the depth of the pixel already in the image buff- er. Depth is measured as the distance from the virtual camera through which we  observe the scene being rendered. The name z-buffer comes from the convention  that the z axis points directly out of the display screen in the camera’s local coor- dinate system.  See Section 5.3.     An  application  may  request  that  a  stencil  buffer  be  created  along  with  the  image buffers and the depth buffer. The stencil buffer contains an integer mask  for each pixel in the image buffer that can be used to enable or disable drawing  on a per-pixel basis. The operations that can be performed in the stencil buffer  are described in Section 1.3, later in this chapter. An advanced application of the  stencil buffer used to generate real-time shadows is discussed in Chapter 10.    For the vast majority of 3D rendering applications, the usage of VRAM is  dominated by texture maps. Texture maps are images that are applied to the sur- face of an object to give it greater visual detail. In advanced rendering applica- tions, texture maps may contain information other than a simple pixel image. For  instance, a bump map contains vectors that represent varying slopes at different  locations on an object’s surface. Texture mapping details, including the process  of bump mapping, are discussed in detail in Chapter 7.   1.2  Vertex Transformation   Geometrical  data  is  passed  to  the  graphics  hardware  in  the  context  of  a  three- dimensional  space.  One  of  the  jobs  performed  by  the  graphics  hardware  is  to    1.2  Vertex Transformation      5   transform  this  data  into  geometry  that  can  be  drawn  into  a  two-dimensional  viewport. There are several different coordinate systems associated with the ren- dering  pipeline—their  relationships  are  shown  in  Figure  1.3.  The  vertices  of  a  model are typically stored in object space, a coordinate system that is local to the  particular  model  and  used  only  by  that  model.  The  position  and  orientation  of  each model are often stored in world space, a global coordinate system that ties  all of the object spaces together. Before an object can be rendered, its vertices  must  be  transformed  into  camera  space   also  called  eye  space ,  the  space  in  which the x and y axes are aligned to the display and the z axis is parallel to the  viewing direction.  See Section 5.3.  It is possible to transform vertices from ob- ject space directly into camera space by concatenating the matrices representing  the  transformations  from  object  space  to  world  space  and  from  world  space  to  camera  space.  The  product  of  these  transformations  is  called  the  model-view  transformation.    Once a model’s vertices have been transformed into camera space, they un- dergo a projection transformation that has the effect of applying perspective so  that geometry becomes smaller as the distance from the camera increases.  Pro-   World Space  Object Space  Model-view transformation  Camera Space  Projection  Homogeneous  Clip Space  Viewport transformation  Window Space     Figure 1.3. The coordinate spaces appearing in the rendering pipeline. Vertex positions  are submitted to the graphics library in object space and are eventually transformed into  window space for primitive rasterization.    6      1. The Rendering Pipeline   1,1  jections  are  discussed  in  Section  5.5.   The  projection  is  performed  in  four- dimensional homogeneous coordinates, described in Section 4.4, and the space in  which the vertices exist after projection is called homogeneous clip space. Ho- mogeneous clip space is so named because it is in this space that graphics primi- tives are clipped to the boundaries of the visible region of the scene, ensuring that  no  attempt  is  made  to  render  any  part  of  a  primitive  that  falls  outside  the  viewport.  In  homogeneous  clip  space,  vertices  have  normalized  device  coordinates.    The term normalized pertains to the fact that the x, y, and z coordinates of each  vertex  fall  in  the  range  ,  but  reflect  the  final  positions  in  which  they  will  appear  in  the  viewport.  The  vertices  must  undergo  one  more  transformation,  called the viewport transformation, that maps the normalized coordinates to the  actual  range  of  pixel  coordinates  covered  by  the  viewport.  The  z  coordinate  is  usually mapped to the floating-point range  0,1, but this is subsequently scaled to  the  integer  range  corresponding to  the number  of  bits  per  pixel  utilized  by  the  depth buffer. After the viewport transformation, vertex positions are said to lie in  window space.    A graphics processor usually performs several per-vertex calculations in ad- dition to the transformation from object space to window space. For instance, the  OpenGL lighting model determines the color and intensity of light reaching each  vertex and then calculates how much of that is reflected toward the camera. The  reflected color assigned to each vertex is interpolated over the area of a graphics  primitive  in  the  manner  described  in  Section  5.4.2.  This  process  is  called  per- vertex  lighting.  More-advanced  graphics  applications  may  perform  per-pixel  lighting to achieve highly detailed lighting interactions at every pixel covered by  a  graphics  primitive.  Per-vertex  and  per-pixel  lighting  are  discussed  in  Sec- tions 7.7 and 7.8.  Each vertex may also carry with it one or more sets of texture coordinates.    Texture coordinates may be explicitly specified by an application or automatical- ly generated by the GPU. When a graphics primitive is rendered, the texture co- ordinates are interpolated over the area of the primitive and used to look up col- ors in a texture map. These colors are then combined with other interpolated data  at each pixel to determine the final color that appears in the viewport.   1.3  Rasterization and Fragment Operations   Once a model’s vertices have been clipped and transformed into window space,  the  GPU  must  determine  what  pixels  in  the  viewport  are  covered  by  each    1.3  Rasterization and Fragment Operations      7   graphics primitive. The process of filling in the horizontal spans of pixels belong- ing to a primitive is called rasterization. The GPU calculates the depth, interpo- lated vertex colors, and interpolated texture coordinates for each pixel. This in- formation, combined with the location of the pixel itself, is called a fragment.    The process through which a graphics primitive is converted to a set of frag- ments is illustrated in Figure 1.4. An application may specify that face culling be  performed as the first stage of this process. Face culling applies only to polygonal  graphics primitives and removes either the polygons that are facing away from  the camera or those that are facing toward the camera. Ordinarily, face culling is  employed as an optimization that skips polygons facing away from the camera   backfacing polygons  since they correspond to the unseen far side of a model.    A graphics application specifies how the fragment data is used to determine  the final color and final depth of each pixel during rasterization. This process is  called fragment shading or pixel shading. The final color may simply be given by  the  product  of  an  interpolated  vertex  color  and  a  value  fetched  from  a  texture  map, or it may be the result of a complex per-pixel lighting calculation. The final  depth  is  ordinarily  just  the  unaltered  interpolated  depth,  but  advanced  3D  graphics hardware allows an application to replace the depth with the result of an  arbitrary calculation.    Figure 1.5 illustrates the operations performed for each fragment generated  during  rasterization.  Most  of  these  operations  determine  whether  a  fragment  should be drawn to the viewport or discarded altogether. Although these opera- tions occur logically after fragment shading, most GPUs perform as many tests as  possible before performing fragment shading calculations to avoid spending time  figuring out the colors of fragments that will ultimately be discarded.   Graphics primitives  Face Culling  Rasterization  Fragments  Fragment Shading  Fragment Operations     Figure 1.4. A graphics primitive is converted to a set of fragments during rasterization.  After shading, fragments undergo the operations shown in Figure 1.5.    8      1. The Rendering Pipeline   Fragment  Pixel  Ownership Test  Scissor Test  Alpha Test  Stencil Test  Depth Test  Blending  Figure 1.5. Operations performed before a fragment is written to the image buffer.   Image buffer       The first fragment operation performed, and the only one that cannot be disa- bled,  is  the  pixel  ownership  test.  The  pixel  ownership  test  simply  determines  whether a fragment lies in the region of the viewport that is currently visible on  the display. A possible reason that the pixel ownership test fails is that another  window  is  obscuring  a  portion  of  the  viewport.  In  this  case,  fragments  falling  behind the obscuring window are not drawn.    Next, the scissor test is performed. An application may specify a rectangle in  the viewport, called the scissor rectangle, to which rendering should be restrict- ed. Any fragments falling outside the scissor rectangle are discarded. A particular  application of the scissor rectangle in the context of the stencil shadow algorithm  is discussed in Section 10.3.7.  If the scissor test passes, a fragment undergoes the alpha test. When the final    color of a fragment is calculated, an application may also calculate an alpha val- ue  that  usually  represents  the  degree  of  transparency  associated  with  the  frag- ment. The alpha test compares the final alpha value of a fragment to a constant  value that is preset by the application. The application specifies what relationship  between the two values  such as less than, greater than, or equal to  causes the  test to pass. If the relationship is not satisfied, then the fragment is discarded.    After the alpha test passes, a fragment moves on to the stencil test. The sten- cil test reads the value stored in the stencil buffer at a fragment’s location and  compares  it  to  a  value  previously  specified  by  the  application.  The  stencil  test  passes only if a specific relationship is satisfied  e.g., the stencil value is equal to    1.3  Rasterization and Fragment Operations      9   a particular value ; otherwise, the stencil test fails, and the fragment is discarded.  An application is able to specify actions to be taken in the stencil buffer when the  stencil test passes or fails. Additionally, if the stencil test passes, the value in the  stencil buffer may be affected in a way that depends on the result of the depth test   described next . For instance, an application may choose to increment the value  in the stencil buffer if the stencil test passes and the depth test fails. This func- tionality is used extensively by one of the shadow-rendering techniques described  in Chapter 10.  The final test undergone by a fragment is the depth test. The depth test com-   pares the final depth associated with a fragment to the value currently residing in  the depth buffer. If the fragment’s depth does not satisfy an application-specified  relationship with  the  value  in  the  depth  buffer,  then  the  fragment  is  discarded.  Normally,  the  depth  test  is  configured  so  that  a  fragment  passes  the  depth  test  only if its depth is less than or equal to the value in the depth buffer. When the  depth test passes, the depth buffer is updated with the depth of the fragment to  facilitate hidden surface removal for subsequently rendered primitives.    Once the pixel ownership test, scissor test, alpha test, stencil test, and depth  test have all passed, a fragment’s final color is blended into the image buffer. The  blending operation calculates a new color by combining the fragment’s final col- or and the color already stored in the image buffer at the fragment’s location. The  fragment’s alpha value and the alpha value stored in the image buffer may also  be used to determine the color that ultimately appears in the viewport. The blend- ing operation may be configured to simply replace the previous color in the im- age buffer, or it may produce special visual effects such as transparency.      This page intentionally left blank    Chapter 2   Vectors   Vectors are of fundamental importance in any 3D game engine. They are used to  represent points in space, such as the locations of objects in a game or the verti- ces of a triangle mesh. They are also used to represent spatial directions, such as  the orientation of the camera or the surface normals of a triangle mesh. Under- standing how to manipulate vectors is an essential skill of the successful 3D pro- grammer.    Throughout this book, we encounter vectors of various types, usually repre- senting two-dimensional, three-dimensional, or four-dimensional quantities. For  now,  we  make  no  distinction  between  vectors  representing  points  and  vectors  representing directions, nor do we concern ourselves with how vectors are trans- formed from one coordinate system to another. These topics are extremely im- portant in 3D engine development, however, and are addressed in Chapter 4.   2.1  Vector Properties   We assume that the reader possesses a basic understanding of vectors, but it is  beneficial  to  provide  a  quick  review  of  properties  that  are  used  extensively  throughout this book. Although more abstract definitions are possible, we usually  restrict ourselves to vectors defined by n-tuples of real numbers, where n is typi- cally 2, 3, or 4. An n-dimensional vector V can be written as   =V  V V , 1  2   ,  ,  V  ,n      2.1    iV  are called the components of the vector V. We have used  where the numbers  numbered subscripts here, but the components will usually be labeled with the  name  of  the  axis  to  which  they  correspond.  For instance,  the  components  of  a  three-dimensional point P could be written as   yP , and   zP .   xP ,   11            12            2. Vectors    2.2    The vector V in Equation  2.1  may also be represented by a matrix having a     single column and n rows:   =  V  V  1  V 2     V   n         .   We treat this column vector as having a meaning identical to that of the comma- separated list of components written in Equation  2.1 . Vectors are normally ex- pressed  in  these  forms,  but  we  sometimes  need  to  express  vectors  as  a  matrix  consisting of a single row and n columns. We write row vectors as the transpose  of their corresponding column vectors:   T  =V  [ V V 1  2    ] .   V  n   2.3      A vector may be multiplied by a scalar to produce a new vector whose com- ponents retain the same relative proportions. The product of a scalar a and a vec- tor V is defined as   =  =  ,     a  aV aV  V V a   2.4   a = − , we use the slightly simplified notation −V to represent the   In the case that  negation of the vector V.    Vectors add and subtract componentwise. Thus, given two vectors P and Q,  we define the sum  +P Q as   aV   ,  .   1  ,  n  2  1  +  +  =  +  1  ,  P Q  P Q P Q 1   2.5     The difference between two vectors, written  −P Q, is really just a notational sim- P plification of the sum    With the above definitions in hand, we are now ready to examine some fun- damental properties of vector arithmetic.   P Q n    Q .     + −   ,  .   ,  n  2  2  +  Theorem 2.1. Given any two scalars a and b, and any three vectors P, Q, and  R, the following properties hold.         + P Q Q P    + P Q R P Q R     a    b      = +  =    +  +  +         2.1  Vector Properties   13                      c         =P P   ab a b     + = + P Q P Q  a a a  d      e     + = + P  P P a b a b  Using  the  associative  and  commutative  properties  of  the  real  numbers,  these  properties are easily verified through direct computation.    given by the formula   The magnitude of an n-dimensional vector V is a scalar denoted by  V  and is   The magnitude of a vector is also sometimes called the norm or the length of a  vector. A vector having a magnitude of exactly one is said to have unit length, or  may simply be called a unit vector. When V represents a three-dimensional point  or direction, Equation  2.6  can be written as   = V  2  V  i  .   n  = 1  i  V  =  V  2 x  +  V  2 y  +  V  2 z  .    2.6     2.7      A  vector  V  having  at  least  one  nonzero  component  can  be  resized  to  unit  length through multiplication by 1 V . This operation is called normalization and  is used often in 3D graphics. It should be noted that the term to normalize is in no  way related to the term normal vector, which refers to a vector that is perpen- dicular to a surface at a particular point.     The magnitude function given in Equation  2.6  obeys the following rules.      Theorem 2.2. Given any scalar a and any two vectors P and Q, the following  properties hold.             0≥P   0=P  if and only if  a=P + ≤ P Q   a    b    c   a  d    P   P Q       ,0  =P  0,0,  +     Proof.    a   This  follows  from  the  fact  that  the  radicand  in  Equation   2.6   is  a  sum  of   squares, which cannot be less than zero.    14   2. Vectors         P + Q  Q    P Q .  Geometrically,  this  Figure  2.1.  The  triangle  inequality  states  that  follows from the fact that the length of one side of a triangle can be no longer than the  sum of the lengths of the other two sides.   P Q  +  ≤  +  P  0,0,  =P  b   Suppose that  0=P . Conversely, if we assume    . Then the radicand in Equation  2.6  evaluates to  , then each component of P  zero, so  must be zero, since otherwise the sum in Equation  2.6  would be a positive  number.   0=P  ,0   c   Evaluating Equation  2.6 , we have the following.   P a  =  =  =  =  n    = 1  i  2  a  a P 2 i  2  n    = 1  i  2  P i  2  P i  n   i P  = 1  a  a      2.8     d   This is known as the triangle inequality since a geometric proof can be given  if we treat P and Q as two sides of a triangle. As shown in Figure 2.1,  +P Q  forms the third side of the triangle, which cannot have a length greater than  the sum of the other two sides.      We will be able to give an algebraic proof of the triangle inequality after in- troducing the dot product in the next section.    2.2  The Dot Product   15   2.2  The Dot Product            The dot product of two vectors, also known as the scalar product or inner prod- uct, is one of the most heavily used operations in 3D graphics because it supplies  a  measure  of  the  difference  between  the  directions  in  which  the  two  vectors  point.   ⋅P Q, is the scalar quantity given by the formula   Definition 2.3. The dot product of two n-dimensional vectors P and Q, written  as        2.9    P Q  .         ⋅  n  PQ i  i  =   = 1  i  This definition states that the dot product of two vectors is given by the sum of  the products of each component. In three dimensions, we have   ⋅  P Q  =  P Q x  x  +  P Q y  y  +  P Q z  .   z   2.10    The dot product   ⋅P Q may also be expressed as the matrix product   T  P Q  =  [  P P 1 2    ]  P n   2.11    2  Q 1 Q  Q  n            ,      which yields a 1 1×  matrix  i.e., a scalar  whose single entry is equal to the sum in  Equation  2.9 .    Now for an important theorem that reveals the ubiquitous utility of the dot  product.      Theorem 2.4. Given two n-dimensional vectors P and Q, the dot product  satisfies the equation        where α is the planar angle between the lines connecting the origin to the points  represented by P and Q.   P Q P Q   2.12    cosα  =  ,      ⋅  ⋅P Q    16   2. Vectors               P  α  P − Q  Q     Figure 2.2. The dot product is related to the angle between two vectors by the equation  P Q P Q  cosα  =  .   ⋅  Proof. Let α be the angle between the vectors P and Q, as shown in Figure 2.2.  By the law of cosines  see Appendix B, Section B.6 , we know   −  P Q  2  =  P  2  +  Q  − 2 2  P Q  cosα  .    2.13    This expands to   n    = 1  i     −  P Q i  i    2  =  +  2  P i  Q  2 i  −  2  P Q  cos  α  .   n    = 1  i  n    = 1  i  All the   2  iP  and   2  iQ  terms cancel, and we are left with   − 2  PQ i  i  = − 2  P Q  cos  α  .   n    = 1  i  Dividing both sides by  2−  gives us the desired result.     2.14     2.15      A couple of important facts follow immediately from Theorem 2.4. The first  is that two vectors P and Q are perpendicular if and only if  P Q . This follows  from the fact that the cosine function is zero at an angle of 90 degrees. Vectors  whose dot product yields zero are called orthogonal. We define the zero vector,  ≡0 ⋅0 P always equals zero.    , to be orthogonal to every vector P, since   0,0,  ,0  =  0  ⋅   2.2  The Dot Product      17   Q  Q  Q  Q  P  Q  Q  P Q  ⋅  <  0  P Q  ⋅  >  0     Figure 2.3. The sign of the dot product tells us whether two vectors lie on the same side  or on opposite sides of a plane.   The second fact is that the sign of the dot product tells us how close two vec-   tors are to pointing in the same direction. Referring to Figure 2.3, we can consid- er the plane passing through the origin and perpendicular to a vector P. Any vec- tor lying on the same side of the plane as P yields a positive dot product with P,  and any vector lying on the opposite side of the plane from P yields a negative  dot product with P.    ing theorem.   Several additional properties of the dot product are presented by the follow-     Theorem 2.5. Given any scalar a and any three vectors P, Q, and R, the fol- lowing properties hold.               ⋅ = P Q Q P        ⋅ ⋅ P Q P Q   a a     = ⋅ + ⋅ ⋅ + P Q R P Q P R  ⋅ = P P P   2 ⋅ ≤ P Q P Q     a    b      c    d    e    ⋅ =  Proof. Parts  a ,  b , and  c  are easily verified using the associative and commu- tative properties of the real numbers. Part  d  follows directly from the definition  of  P  given in Equation  2.6  and the definition of the dot product given in Equa- tion  2.9 . Part  e  is implied by Theorem 2.4 since cos  α ≤ .    1   18   2. Vectors               2P  when we take the dot product of a vector P with it- 2P  all have  2P  be-    We use the notation  self. Thus, by part  d  of Theorem 2.5, we can say that  identical meanings. We use italics instead of boldface in the expression  cause it is a scalar quantity.  Part   e   of  Theorem  2.5  is  known  as  the  Cauchy-Schwarz  inequality  and    gives us a tool that we can use to provide the following algebraic proof of the  triangle inequality.   2P , and   ⋅P P,   Proof of Theorem 2.2 d .  Triangle Inequality  Beginning with  calculate   +P Q , we can   2  +  P Q  2  = = ≤ =  ⋅      + + P Q P Q     + + ⋅ P Q P Q 2 2 2 + + P Q P Q 2     + P Q 2  ,  2  2     where Theorem 2.5 e  has been used to attain the inequality. Taking square roots,  we arrive at the desired result.    The  situation  often  arises  in  which  we  need  to  decompose  a  vector  P  into    components that are parallel and perpendicular to another vector Q. As shown in  Figure 2.4, if we think of the vector P as the hypotenuse of a right triangle, then  the perpendicular projection of P onto the vector Q produces the side adjacent to  the angle α between P and Q.    by  knowing the angle α:   Basic trigonometry tells us that the length of the side adjacent to α is given  P . Theorem 2.4 gives us a way to calculate the same quantity without   cosα  To obtain a vector that has this length and is parallel to Q, we simply multiply by  the unit vector Q Q . We now have the following formula for the projection of P  onto Q, which we denote by projQ P.   P  cosα  ⋅= P Q Q  .   proj  Q  P  =  ⋅ P Q Q 2    Q   2.16     2.17     2.18     2.3  The Cross Product   19            P  Q     α  ⋅P Q Q  Figure 2.4. The length of the projection of the vector P onto the vector Q is given by  ⋅P Q Q  because   P Q P Q  cosα  =  .   ⋅  The  perpendicular  component  of  P  with  respect  to  Q,  denoted  by  perp Q P,  is  simply the vector left over when we subtract away the parallel component given  by Equation  2.18  from the original vector P:   perp  Q  = −  P P  P  Q  .   proj Q ⋅ P Q Q 2  = −  P   2.19     2.20    The projection of P onto Q is a linear transformation of P and can thus be    expressed as a matrix-vector product. In three dimensions, projQ P can be com- puted using the alternative formula   proj  Q P  =  1 Q  2  y  Q Q Q Q Q 2 x x Q Q Q Q Q 2 y y Q Q Q Q Q 2 z  y  x  y  x  x  z  z  z  z        P x P y P z                   .   2.3  The Cross Product   The  cross  product  of  two  three-dimensional  vectors,  also  known  as  the  vector  product, returns a new vector that is perpendicular to both of the vectors being  multiplied together. This property has many uses in computer graphics, one of    20   2. Vectors                  which is a method for calculating a surface normal at a particular point given two  distinct tangent vectors.   Definition 2.6. The cross product of two 3D vectors P and Q, written as  ×P Q,  is a vector quantity given by the formula       P Q P Q P Q P Q P Q y   2.21    P Q  P Q y  =  −  ×  −  −  .      ,  ,  x  y  x  y  x  x  z  z  z  z  A commonly used tool for remembering this formula is to calculate cross prod- ucts by evaluating the pseudodeterminant   where i, j, and k are unit vectors parallel to the x, y, and z axes:   ×  P Q  =  j P y  k i P P z x Q Q Q  x  y  z  ,   = = =  i j k  1,0,0 0,1,0 0,0,1  .    2.22     2.23    We call the right side of Equation  2.22  a pseudodeterminant because the top  row of the matrix consists of vectors, whereas the remaining entries are scalars.  Nevertheless,  the  usual  method  for  evaluating  a  determinant  does  produce  the  correct value for the cross product, as shown below.   j P y  k i P P z x Q Q Q  y  x  z  =     i  P Q P Q y  z  z  −  y     −     j  P Q P Q x  z  z  −  x     +     k  P Q x  y  −  P Q y  x         2.24    The cross product  ×P Q can also be expressed as a linear transformation derived  from P that operates on Q as follows.   ×  P Q  =  0   P z  − P  y  − P z 0 P x  Q P y − P Q x Q 0             x  y  z            2.25     2.3  The Cross Product   21              As mentioned previously, the cross product  ×P Q produces a vector that is  perpendicular to both of the vectors P and Q. This fact is summarized by the fol- lowing theorem.   Theorem 2.7. Let P and  Q be  any two 3D vectors. Then     P Q Q .  0  =  ×     ⋅  P Q P  ⋅ =  ×     0   and   Proof. Applying the definitions of the cross product and the dot product, we have  the following for    P Q P:    ×  ⋅     ×  P Q P     ⋅ = = =  −  z  z  y  ,  P Q P Q P Q P Q P Q y z P P Q P P Q x 0.  , −  x +  −  x  y  y  z  z  z  x  − P P Q P P Q P P Q P P Q y  P Q y +  P  −  −  ⋅  x  x  y  x  y  x  x  y  y  z  z  z  z  x      2.26    The fact that    ×     ⋅  =  P Q Q  is proven in a similar manner.    0  The same result arises when we consider the fact that given any three 3D vectors  P,  Q,  and  R,  the  expression    P Q R  may  be  evaluated  by  calculating  the  determinant    ×  ⋅     ×  P Q R  ⋅     =  P y  P P z x Q Q Q R R  R  x  y  x  y  z  z  .    2.27    If any one of the vectors P, Q, or R can be expressed as a linear combination of  the other two vectors, then this determinant evaluates to zero. This includes the  cases in which  =R P or  =R Q.     Like the dot product, the cross product has trigonometric significance.      Theorem 2.8. Given two 3D vectors P and Q, the cross product  ×P Q satisfies  the equation        where α is the planar angle between the lines connecting the origin to the points  represented by P and Q.    2.28    P Q  P Q  sin α  ×  =  ,       22   2. Vectors                  Proof. Squaring  ×P Q , we have   ×  P Q  2  = = =       z  z  ,  −  − P Q P Q P Q P Q P Q P Q y z − P Q P Q y y z   + P Q P 2 2 2 z y x − P Q P Q 2 x  − , y y x x z x         + − + − P Q P Q P Q P Q 2 z x x x z         + + + + P Q P P P Q 2 2 2 2 2 x x y z y − − P Q P Q P Q P Q 2 . 2 y x  y 2  2 z  2  x  y  x  y  y  y  y  x  z  z  z  z  z     2  x      2.29    By adding and subtracting  tion, we can write   P Q 2 x  2 x  +  P Q 2 y  2 y  +  P Q 2 z  2  on the right side of this equa- z  ×  P Q  2  =  P Q Q Q 2 z  2 z     +  P 2 y     P 2 x   − P Q P Q y y x ⋅ P Q P Q 2  + + −  x 2     +  2 x + P Q z   2.  +  2  2 y    z        =   2.30    Replacing the dot product with the right side of Equation  2.12 , we have   ×  P Q  2  2  cos  α  = = =  2  2  P Q P Q P Q  2  2     2  2  2  2  − P Q   − α 1 cos 2 α . sin  2      2.31    Taking square roots proves the theorem.      As shown in Figure 2.5, Theorem 2.8 demonstrates that the magnitude of the  cross  product  ×P Q  is  equal  to  the  area  of  the  parallelogram  whose  sides  are  formed by the vectors P and Q. As a consequence, the area A of an arbitrary tri- 3V  can be calculated us- angle whose vertices are given by the points  ing the formula   2V , and   1V ,   A =  1 2     −  V V 1  2     ×     V V .   −  1  3      2.32      We know that any nonzero result of the cross product must be perpendicular  to the two vectors being multiplied together, but there are two possible directions  that satisfy this requirement. It turns out that the cross product follows a pattern  called the right hand rule. As shown in Figure 2.6, if the fingers of the right hand    2.3  The Cross Product   23         Figure 2.5. This parallelogram has base width  Q  and height  these two lengths is equal to  ×P Q  and gives the area of the parallelogram.   P  . The product of   P  α  P  sin α  Q  ×P Q  Q  P  ×P Q    sin α  P  Q     Figure 2.6. The right hand rule provides a way for determining in which direction the  cross product points. When the vectors P and Q are interchanged, their cross product is  negated.   are aligned with a vector P, and the palm is facing in the direction of a vector Q,  then the thumb points along the direction of the cross product  ×P Q.  The unit vectors i, j, and k, which point in the directions of the positive x, y,    and  z  axes,  respectively,  behave  as  follows.  If  we  order  the  axes  in  a  circular  fashion so that i precedes j, j precedes k, and k precedes i, then the cross product  of two of these vectors in order yields the third vector as follows.   = × j i × = j k × = k i  k i j      2.33     24   2. Vectors    2.34                The cross product of two of the vectors in reverse order yields the negation of  the third vector as follows.   × = − k j i × = − i k j × = − i k j     Several additional properties of the cross product are presented by the fol-    lowing theorem.      Theorem 2.9. Given any two scalars a and b, and any three 3D vectors P, Q,  and R, the following properties hold.                     × = − × Q P P Q         = × × P Q P Q   a a     + × = × + × P Q R P Q P R  × = = P P 0 0,0,0       × ⋅ = × ⋅ = P Q R R P Q Q R P    ⋅ = × × = × × P Q P P Q P 2P  × − Q P Q P    a    b      c    d    e      f                      ⋅  Proof. Parts  a  through  d  follow immediately from the definition of the cross  product and the associative and commutative properties of the real numbers. Part   e  can be directly verified using Equation  2.27 . For part  f , we first observe  that   ×  P Q P  ×        × = × − P P Q   [ = − − × P Q P     = × × P Q P    ×  .  ]      2.35    Direct computation of the x component gives us      × ×  P Q P     x  = = =         z  z  P Q P Q P Q P Q P Q P Q , y y   − P Q P Q P z z y     − P Q P Q P P 2 y y x  − − y   P Q P Q P x y + ,  − z −   P Q 2 z  z −  x +  x    ,  y  y  x  x  x  x  x  y  z  z  z  ×     P  x  x      2.36    which  isn’t  quite  what  we  need,  but  we  can  add  and  subtract  a  achieve our desired result, as follows:   P Q   term  to  2 x  x   2.3  The Cross Product   25               +  P 2 y  − + +  x    P Q 2 z   = P 2 y   = P 2 x = P Q 2  x  y      + P Q P P Q x y z z     + − P Q P Q 2 2 z x x x     − + P P Q P Q P Q 2 2 z x y     − ⋅P Q P x  +  +  x .  y    − P Q P Q P P Q 2 y x x   P Q P z x  z +  x  y  y  z  z  x      2.37    The y and z components can be checked in a similar manner.       ×  =R  0,1,1  1,1,0  ≠ ×  , and   =Q ,     By part  a  of Theorem 2.9, the cross product is not a commutative operation.  Because reversing the order of the vectors has the effect of negating the product,  the cross product is labeled anticommutative. Additionally, it is worth noting that  the cross product is not an associative operation. That is, given any three 3D vec-   tors P, Q, and R, it may be true that   × P Q R P Q R . As an example, let  . First calculating   =P 1,0,1 i j k 1 1 0 0 1 1 j k i − 1 1 1 0 1 1  × P Q R, we have   P Q R     ×   2.38    1, 1,1  P Q  1,0,1  = −  ×  =  ×  =  =  ×  −  ×  .            Now calculating   P Q R , we have   ×     ×     ×  Q R  =  =  − 1,1, 1  i j k 0 1 1 1 0 1 j k i 0 1 1 − 1 1 1  ×  P Q R  ×        =  = −  1,1,0  ,    2.39    which yields a different result.          26      2.4  Vector Spaces   2. Vectors   The vectors we have dealt with so far belong to sets called vector spaces. An ex- amination of vector spaces allows us to introduce concepts that are important for  our study of matrices in Chapter 3.         + = + =  P 0 0 P P.   sum  +P Q is an element of V.   and any element P in V, the product aP is an element of V.   Definition 2.10. A vector space is a set V, whose elements are called vectors,  for  which  addition  and  scalar  multiplication  are  defined,  and  the  following  properties hold.                                      a   V is closed under addition. That is, for any elements P and Q in V, the     b   V is closed under scalar multiplication. That is, for any real number a     c   There exists an element in V called 0 such that for any element P in V,     d   For  every  element  P  in  V,  there  exists  an  element  Q  in  V  such  that     e   Addition  is  associative.  That  is,  for  any  elements  P,  Q,  and  R  in  V,     f   Scalar multiplication is associative. That is, for any real numbers a and     g   Scalar  multiplication  distributes  over  vector  addition.  That  is,  for  any  P Q.     h   Addition  of  scalars  distributes  over  scalar  multiplication.  That  is,  for     real  number  a,  and  any  elements  P  and  Q  in  V,  any real numbers a and b, and any element P in V,    P Q R P Q R .    b, and any element P in V,    P Q 0.     P Q  = +  a b    P .     a b  =P  P.   P a  ab  P  +  +  +  +  =  +  +  =  +  +  =  a  b  a  a                                     Many of the properties required of vector spaces are  mentioned in Section  2.1 and are easily shown to be satisfied for vectors having the form of n-tuples of  n .  real numbers. We denote the vector space consisting of all such n-tuples by  3 .  For instance, the vector space consisting of all 3D vectors is denoted by  Every vector space can be generated by linear combinations of a subset of    vectors called a basis for the vector space. Before we can define exactly what a  basis  is,  we  need  to  know  what  it  means  for  a  set  of  vectors  to  be  linearly  independent.    2.4  Vector Spaces      27   2  ,  }  Definition  2.11.  A  set  of  n  vectors { e e , 1 a , where at least one of the  , , there do not exist real numbers  1 n zero, such that          Otherwise, the set {  e  is called linearly dependent.  ,  e   is  linearly  independent  if  , ia  is not    2.40    a a ,  e n n  e 2 2  e 1 1    .   =  +  +  +  }  0  a  a  a  ,     e e , 1  2  n  2  n    An n-dimensional vector space is one that can be generated by a set of n line- arly independent vectors. Such a generating set is called a basis, whose formal  definition follows.     Definition 2.12. A basis  for a vector space V is a set of n linearly independ- }  for which, given any element P in V, there exist  ent vectors  real numbers  1      { = e e , 2 a  such that  a a , ,  e , n   2.41    e n  e 1 1  P  +  +  +  =  , ,  a  a  a  e     2  n  n  1  2  2  .   Every basis of an n-dimensional vector space has exactly n vectors in it. For in- 3 ,  stance, it is impossible to find a set of four linearly independent vectors in  and a set of two linearly independent vectors is insufficient to generate the entire  vector space.    n . We assign special terms to those that have certain properties.   There are an infinite number of choices for a basis of any of the vector spaces   { = e e Definition 2.13. A basis  ,  1   onal if for every pair   j≠ , we have  j  with i e  e ,  ,i  ,  n  2  ⋅  e  j  i  =  0  .   }  for a vector space is called orthog-  The fact that the dot product between two vectors is zero actually implies that the  vectors are linearly independent, as the following theorem demonstrates.   Theorem 2.14. Given two nonzero vectors  1e  and  2e , if  1 2e  are linearly independent.   ⋅ e e  2  =  0  , then  1e  and   Proof. We suppose that  1e  and  2e  are not linearly independent and arrive at a con- tradiction. If  1e  and  2a    2e  are linearly dependent, then there exist scalars   1a  and    28   2. Vectors         a+  =  2        e  a  e 2 2  = −  a a 1  e . But then  1  0. Note that  2a  cannot be zero since it would require that  1a     2 a a e   1 1  e such that  1 1 also be zero. Thus, we can write  0≠ , a contradiction.   This theorem shows that if we can find any n orthogonal vectors in a vector space  V, then they form a basis for V.    A more specific term is given to a basis whose elements all have unit length.  For convenience, we introduce the Kronecker delta symbol  ijδ , which is defined  as   = −  e  e     ⋅  2  2  1  2  δ  ij  1, ≡  0,   if if  = ≠  i i  j j  ; .      2.42    { = e e e Definition 2.15. A basis  , ,    normal if for every pair   ⋅ j  we have  i ,i e  ,  1  2  }  for a vector space is called ortho- = j  ijδ  .   n e  i j k  is obviously an orthonormal basis for  , ,  }  The set { example of an orthonormal basis for  −  3  is given by the three vectors   3 . A slightly less trivial  ,0 ,   2 2  2, 2  ,0  , and  0,0,1 .   2, 2 2 2 There is a simple method by which a linearly independent set of n vectors    n . The basic idea is to subtract  can be transformed into an orthogonal basis for  away the projection of each vector onto the vectors preceding it in the set. What- ever  vector  is  left  over  must  then  be  orthogonal  to its  predecessors.  The  exact  procedure is as follows.   Algorithm  2.16.  Gram-Schmidt  Orthogonalization.  Given  a  set  of  n  linearly  ′ =   independent  vectors  { ′ ′ e e , 2 1  { = e e ,  ′ ⋅ = e  such that  , e e i  } ,  this  algorithm  produces  a  set   e , , 2  whenever i 0  j≠ .   1 ′ j  }  ′ n  ,  n  ′ =e  e .  1    A.  Set  1 i = .    B.  Begin with the index  2   C.  Subtract the projection of  store the result in  i′e . That is,      ⋅ ′ e e i e   D.  If i n< , increment i and loop to step C.   ′ e i  =  −  2 k  e  − 1  = 1  k  i  i  ′ k  ′ k  e  .   ′ ′ e e ie  onto the vectors  1 , 2  e  from  ,  ,  ′ i− 1  ie  and    2.43     Chapter 2 Summary   29                        Chapter 2 Summary   Dot Products  The dot product between two n-dimensional vectors P and Q is a scalar defined  by   ⋅  P Q  =  PQ PQ P Q i  2  1  1  i  2  +  =  +    +  P Q n  .   n  n    = 1  i  The dot product is related to the angle α between the vectors P and Q by the for- mula   P Q P Q  =  ⋅  cosα  .   Vector Projections  The projection of a vector P onto a vector Q is given by   and the component of P that is perpendicular to Q is given by   proj  ⋅=Q P Q P Q 2  Q ,   perp  Q  = −  P P  P  Q  .   proj Q ⋅ P Q Q 2  = −  P  Cross Products  The cross product between two 3D vectors P and Q is a 3D vector defined by   ×  P Q  =  P Q P Q P Q P Q P Q y  ,  ,  x  y  x  x  z  z  z  z  y  −  −  −  P Q y  x  .   This can also be written as the matrix-vector product   ×  P Q  =  0   P z  − P  y  − P z 0 P x  P Q y − P Q x Q 0             x  y  z        .   The magnitude of the cross product is related to the angle α between the vectors  P and Q by the formula    2. Vectors   30         ×  P Q  =  P Q  sin α  .   1  ,    e ,  { = e e ,  Gram-Schmidt Orthogonalization  A  basis  ′ nalized by constructing a new set of vectors   ⋅ ′ e e i e  ′ e i  =  −  e  − 1     n  2  i  i  2 k  k  = 1  ′ 1  { = e e , ′ k  ′ k  e  .   }   for  an  n-dimensional  vector  space  can  be  orthogo- }  using the formula   e , ,  ′ 2  ′ n  Exercises for Chapter 2  Q  and   1.  Let   2,2,1  =  −  1, 2,0  . Calculate the following.   =P ⋅P Q  ×P Q    a     b     c   projP Q   e e e  1  2  3  = 2 2 = − =  ,0 , 2 2 − 1,1, 1 − − 0, 2, 2     2.  Orthogonalize the following set of vectors.               3.  Calculate  the  area  of  the  triangle  whose  vertices  lie  at  the  points  1,2,3 ,    for any two vectors V and W.   −  2,2,4  , and  7, 8,6− +  .   4.  Show that   5.  Prove that for any three 3D vectors P, Q, and R,   V W V W  V W    2  ×  =  ⋅  2  2  2  × ×  P Q R P R Q Q R P.   =  −  ⋅  ⋅              6.  Prove that for any two vectors P and Q,   −  P Q  ≥  −  P Q ,   and show that this implies the extended triangle inequality,   −  P Q  ≤  +  P Q  ≤  +  P Q .    Chapter 3   Matrices   In a 3D graphics engine, calculations can be performed in a multitude of different  Cartesian  coordinate  spaces.  Moving  from  one  coordinate  space  to  another  re- quires the use of transformation matrices. We casually referred to matrices at var- ious places in Chapter 2; and in this chapter, we acknowledge the importance of  matrices in 3D graphics programming by presenting a more formal exposition of  their  properties.  The  process  of  transforming  points  and  direction  vectors  from  one coordinate space to another is described in Chapter 4.   3.1  Matrix Properties   An  n m×   matrix  M  is  an  array  of  numbers  having  n  rows  and  m  columns.  If  n m= , then we say that the matrix M is square. We write  ijM  to refer to the entry  of M that resides at the i-th row of the j-th column. As an example, suppose that  F is a 3 4×  matrix. Then we could write   =  F  F 11 F 21 F 31        F 12 F 22 F 32  F 13 F 23 F 33  F 14 F 24 F 34        .    3.1    j=  are called the main diagonal entries of the matrix. A  The entries for which i square matrix whose only nonzero entries appear on the main diagonal is called a  diagonal matrix.    matrix for which the   the matrix F in Equation  3.1  is   The transpose of an n m×   matrix M, which we denote by   TM , is an m n×    . The transpose of     j  entry is equal to   jiM   i.e.,   M=  M  ,i  T ij  ji          31    32   3. Matrices            T     =  F  F  31  F 32  .  F  33  F  34 1n ×  matrices , scalar multiplica-   As with vectors  which can be thought of as  tion is defined for matrices. Given a scalar a and an n m×  matrix M, the product  aM is given by   F 21 F 22 F 23 F 24  F 11 F 12 F 13 F 14   3.2           M M  =  a  a  =  aM aM  aM         11  21  n 1  aM aM  12     aM aM 22    aM    n  2  aM  1  m  2  m  nm         .    3.3    Also in a manner similar to vectors, matrices add entrywise. Given two n m×  ma- trices F and G, the sum  +F G is given by  + +  +  F m 1 F 2  G 11 G  G 12 G  F 12 F 22  F 11 F 21  + +  +  + +  +  F G  G 1 G  =  +  .    3.4    21  22     m  m  m  2       G  nm  G  n  2  G  n 1  F nm  F n  2  F n 1                Two matrices F and G can be multiplied together, provided that the number    of columns in F is equal to the number of rows in G. If F is an n m×  matrix and    G is an m p×  matrix, then the product FG is an n p×  matrix whose   j  entry is  given by   ,i  m        ij     FG  F G ik  =  Another way of looking at this is that the   product of the i-th row of F and the j-th column of G.    MI  =  ,i  .   = 1  kj  k  There is an n n×  matrix called the identity matrix, denoted by  nI , for which  n= I M M for any n n×  matrix M. The identity matrix has the form  n    j  entry of FG is equal to the dot    3.5    =  I  n  1 0 0 1  0 0     0 0    1                  .    3.6     3.1  Matrix Properties      33   We usually drop the subscript n and denote the identity matrix simply by I, since  the size of the matrix can be inferred from the context.    follow.   Several additional properties of matrices are given by the two theorems that   Theorem 3.1. Given any two scalars a and b and any three n m×  matrices F,  G, and H, the following properties hold.               =  a   + F G G F     b       + = + + F G H F G H           =F ab a b F   c       + = + a a a F G F G   d      e     + = + a b a b F F  F  +  +        As with vectors, these properties are easily verified through direct computation  using the associative and commutative properties of the real numbers.   Theorem 3.2. Given any scalar a, an n m×  matrix F, an m p×  matrix G, and a  p q×  matrix H, the following properties hold.               a= a FG   F G       = FG H F GH     T = G F   FG T T   a      b      c            Proof.    a   Using  the  definition  for  matrix  multiplication  given  by  Equation   3.5 ,  the      ,i    j  entry of     aF G is   [       F G  a  ]  ij        F a  G  kj  ik  m    = k 1 m    k  = 1 m  =  =  =  =    a F G  ik  kj     kj  a  a   = k 1   FG  F G ik    ij  .         3.7     34   3. Matrices      b   Again using Equation  3.5 , the    j  entry of       FG H is   ,i  [        FG H  ]  ij  =     FG     H  ik  kj  F G H il  lk  kj      =     G H  lk  kj  p  k  = 1  p    k  = 1 p  =  =  =  m  l      F il  = k 1 m    = 1        F il = 1 [   F GH  = 1 m  l  l  lj  GH ]    ij     .            FG     T ij  =  =  =  =     ji     FG m   = k 1 m  F G  jk  ki  T ik   = 1   G F T  F G T kj    T  k            c   Applying  Equation   3.5 ,  and  reversing  the  indexes  whenever  a  transpose   operation is added or removed, we have for the    ,i    j  entry of      T FG    .    ij   3.9    3.2  Linear Systems   Matrices provide a compact and convenient way to represent systems of linear  equations. For instance, the linear system given by the equations     can be represented in matrix form as   3 4  x x  + −  2 3  y y  13  = − = 7  − 3 + 6 − = −   x 5  z z z  3 4 1        2 − 3 0  − x 3       y 6    − z 1        =  − 13 7 − 5              .    3.8     3.10     3.11     3.2  Linear Systems   35         ,  x y z   of  unknowns  is  called  the  coefficient  The  matrix  preceding  the  vector  , matrix, and the column vector on the right side of the equals sign is called the  constant vector. Linear systems for which the constant vector is nonzero  like the  example above  are called nonhomogeneous. Linear systems for which every en- try of the constant vector is zero are called homogeneous.    Finding  solutions  to  a  system  of  linear  equations  can  be  achieved  by  per- forming elementary row operations on the matrix formed by concatenating the  coefficient matrix and the constant vector.   Definition 3.3. An elementary row operation is one of the following three op- erations that can be performed on a matrix.            a   Exchange two rows.   b   Multiply a row by a nonzero scalar.   c   Add a multiple of one row to another row.           For the example given by Equation  3.11 , the augmented matrix formed by con- catenating the coefficient matrix and constant vector is   3 4 1        2 − 3 0  − 3 6 − 1  − 13 7 − 5        .    3.12      Elementary row operations modify the augmented matrix representation of a  linear system in such a way that the solution to the system is not affected, but it  becomes much easier to calculate. When solving a linear system using elemen- tary  row  operations,  our  goal  is  to  transform  the  coefficient  matrix  into  its  re- duced form, defined as follows.      Definition 3.4. A matrix is in reduced form if and only if it satisfies the follow- ing conditions.              a   For every nonzero row, the leftmost nonzero entry, called the leading     b   Every  nonzero  row  precedes  every  row  of  zeros.  That  is,  all  rows  of     zeros reside at the bottom of the matrix.   entry, is 1.       36   3. Matrices                           nonzero entry in column j.    c   If  a  row’s  leading  entry  resides  in  column  j,  then  no  other  row  has  a    i> , the columns  1j    d   For every pair of nonzero rows  1i  and  2i  such that  2 i    and  2j  containing those rows’ leading entries must satisfy  2 j  j> .  1     1  This definition tells us that the leading entries of a matrix in reduced form move  to the right as we move downward through its rows. Furthermore, any column  containing a leading entry of a row has a 1 at that location and zeros everywhere  else.   Example 3.5. The following matrix is in reduced form.              1 0 0 1 0 0 0 0         − 3 0 0 2 1 0 0 0            1 0 0 3 0 0 1 0 0 2 0 0 0 0 0 1                             3.13     3.14      However, the matrix       is not in reduced form because the leading entry of the third row does not fall to  the right of the leading entry of the second row. Furthermore, the fourth col- umn, which contains the leading entry of the fourth row, is not zero everywhere  else.      Algorithm  3.6  describes  which  elementary  row  operations  to  apply  to  the  augmented matrix representation of a linear system in order to transform its coef- ficient matrix into its reduced form.    1 +  augmented matrix M  Algorithm 3.6. This algorithm transforms an  representing a linear system into its reduced form. At each step, M refers to the  current state of the matrix, not the original state.     n×  n   3.2  Linear Systems      37            no such row exists for which   kjM ≠ , then skip to step H.     i≥  for which  kjM  has the largest absolute value. If    0 i≠ , then exchange rows k and i using elementary row operation  a      A.  Set the row i equal to 1.    B.  Set the column j equal to 1. We will loop through columns 1 to n.    C.  Find the row k with k     D.  If k   under Definition 3.3.    E.  Multiply row i by 1     F.  For each row r, where 1 r       G.  Increment i.    H.  If  j   times row i to row r.  This step clears each entry above and below row i in column j to 0 using  elementary row operation  c .       n< , increment j and loop to step C.     j  entry of M to 1 using ele-     mentary row operation  b .     ijM . This sets the    ≤ ≤  and r  i≠ , add   rjM−  ,i  n          The procedure performed by steps C and D is known as pivoting. In addition    to its ability to remove zeros from the main diagonal, pivoting is absolutely es- sential for numerical stability. The following example demonstrates the applica- tion of Algorithm 3.6 to the nonhomogeneous linear system given by Equation   3.11 . After the augmented coefficient matrix is reduced, the solution to the sys- tem becomes obvious.   Example 3.7. Solve the nonhomogeneous linear system     3 4 1        2 − 3 0  − x 3       y 6    − z 1        =  − 13 7 − 5              .               Solution. We first form the augmented matrix  − 13 7 − 5  − 3 6 − 1  2 − 3 0  3 4 1           .          3.15     3.16    We must now pivot  using steps C and D  so that the row containing the largest  entry in the first column appears in the first row. We therefore exchange the first  two rows. To produce a leading entry of 1, we then multiply the first row by 1 4, as  follows.    38   3. Matrices    3.17     3.18                      Applying step F of Algorithm 3.6, we now eliminate the other nonzero entries in  the first column.   ⎯⎯⎯⎯⎯⎯⎯→  Exchange rows 1 and 2 1 Multiply new row 1 by  4  1   3  1    − 3 4 2 0  3 2 − 3 − 1  7 4 − 13 − 5           ⎯⎯⎯⎯⎯⎯⎯→   row 1 to row 2  row 1 to row 3  − × Add  3  − × Add  1   1 0 0        − 3 4 17 4 3 4  3 2 − 15 2 − 5 2  7 4 − 73 4 − 27 4           Moving to the second row, we multiply by  4  ⎯⎯⎯⎯⎯⎯→  Multiply row 2 by   4 17  17  to obtain a leading entry of 1.  − 3 4 1 3 4  7 4 − 73 17 − 27 4  3 2 30 17 5 2  − −           1 0 0         3.19    Again applying step F, we eliminate the other nonzero entries in the second col- umn.   ⎯⎯⎯⎯⎯⎯⎯→   row 2 to row 1  row 2 to row 3  Add  Add   × 3   4 − × 3   4  1 0 0 1 0 0        3 17 − 30 17 − 20 17  − − −  25 17 73 17 60 17            3.20    Finally, we apply the same steps to the third row, as follows.   ⎯⎯⎯⎯⎯⎯⎯→  Multiply row 3 by   17 20  −        1 0 0 1 0 0       3 17 − 30 17 1  1 0 0 0 1 0 0 0 1  − 25 17 − 73 17 3 − 2 1 3               ⎯⎯⎯⎯⎯⎯⎯→  ×    row 3 to row 1 ×  row 3 to row 2  − 3 Add  17 30 Add    17   3.21    The  coefficient  matrix  has  now  been  completely  transformed  into  its  reduced  form. The reduced augmented matrix represents the equation    3.2  Linear Systems   39                     from which the solution to the original system is immediate:   1 0 0 0 1 0 0 0 1        x       y    z        =  − 2   1  3          ,   x y z  = − 2 = 1 = 3.        In the previous example, we found that the reduced form of the coefficient  matrix was equal to the identity matrix. In such a case, the corresponding linear  system has exactly one solution. When the reduced coefficient matrix has one or  more rows of zeros, however, the corresponding system may have no solution at  all, or may have infinitely many solutions. If the entry in the constant vector cor- responding to a row of zeros in the coefficient matrix is not zero, then the system  has no solution because that row equates zero to a nonzero number. In the re- maining  case  that  the  entry  in  the  constant  vector  is  zero,  there  are  infinitely  many solutions to the linear system that must be expressed in terms of arbitrary  constants. The number of arbitrary constants is equal to the number of rows of  zeros, and arbitrary constants are assigned to variables corresponding to columns  of the reduced coefficient matrix that do not contain a leading entry.   Example 3.8. Solve the following homogeneous linear system.        Solution. The augmented matrix representation of this system is given by    3.22     3.23       3.24     3.25    2  x  y  + + y y  +  3  = 3 0 − = 0 − =   0  z z z  x  2 1 0 1 1 3        3 0 − 1 0 − 1 0        .   Using Algorithm 3.6 to calculate the reduced form gives us the matrix    40               Since this matrix has a row of zeros, we can assign an arbitrary value to the vari- able corresponding to the third column since it does not contain a leading entry;  in this case we set z  a= . The first two rows then represent the equations   so the solution to the system can be written as   1 0 0 1 0 0        2 0 − 1 0 0 0        .   x  =  + a 0 2 − = ,  y a 0  x     y   z      =  a  − 2 1 1          .       3. Matrices    3.26     3.27     3.28      Homogeneous  linear  systems  always  have  at  least  one  solution—the  zero  vector. Nontrivial solutions exist only when the reduced form of the coefficient  matrix possesses at least one row of zeros.   3.3  Matrix Inverses   1  −  =  MM M M I.  The  matrix   An n n×  matrix M is invertible if there exists a matrix, which we denote by  1−M ,  1−M   is  called  the  inverse  of  M.  Not  such  that  every matrix has an inverse, and those that do not are called singular. An exam- ple  of  a  singular  matrix  is  any  one  that  has  a  row  or  column  consisting  of  all  zeros.   =  − 1  Theorem 3.9. A matrix possessing a row or column consisting entirely of zeros  is not invertible.    ,r r  entry of the product FG is given by   Proof. Suppose every entry in row r of an n n×  matrix F is 0. For any n n×  ma- trix G, the   . Since each of  rkF  is 0, the    ,r r  entry of FG is 0. Since the inverse of F would need to pro- the  duce a 1 in the    ,r r  entry, F cannot have an inverse. A similar argument proves  the theorem for a matrix possessing a column of zeros.    1Σ n  F G rk  kr  =  k   3.3  Matrix Inverses   41                 Using this theorem, we will be able to show later in this section that any ma- trix possessing a row that is a linear combination of the other rows of the matrix  is singular. The same is true for the columns of a matrix due to the following fact.   Theorem 3.10. A matrix M is invertible if and only if   TM  is invertible.   Proof. Assume M is invertible. Then   1−M  exists, so we can write     M M  I   =  =     − 1  I  T  T  =     T  M M  − 1 T      3.29     3.30     3.31     3.32    and     Therefore,   vertible, then    and     Therefore,         observation.         − 1 T  M M  T     =  MM  − 1 T     =  T  I  =  I.   −M  is the inverse of    1 T  T 1−M  exists, so we can write     M M  =           − 1  T  T           T  M M  − 1  T  T     =  T  I  =  I   TM . Similarly, if we assume that   TM  is in-        T  M     − 1     T  =  M M M  T  T     − 1  T     =  T  I  =  I.          T  M  − 1      is the inverse of M.   T  Before proceeding to a method for calculating inverses, we make one more   Theorem 3.11. If F and G are n n×  invertible matrices, then the product FG is  invertible, and    − G F .  1  FG    1 −  =  − 1  Proof. We can verify this theorem through direct computation using the fact that  matrix multiplication is associative:   − G F 1  − 1     FG G F F G G G I.    − 1  − 1  − 1  =  =     =         3.33     42   3. Matrices           A method similar to that used to transform a matrix into its reduced form  see  Algorithm 3.6  can also be used to calculate the inverse of a matrix. To find the   matrix M  by concatenat- n× inverse of an n n×  matrix M, we first construct an  2n ing the identity matrix to the right of M, as shown below.    M  =  M M  M         11  21  n 1  n  n  1  12     M M M M 22 2    M    M  n  2  nn  1 0 0 1  0 0     0 0    1               3.34    Performing elementary row operations on the entire matrix M  until the left side  n n×  matrix becomes the identity matrix  nI  yields the inverse of M in the right  side n n×  matrix. This process is known as Gauss-Jordan elimination and is illus- trated in Algorithm 3.12.              no such row exists for which   Algorithm 3.12. Gauss-Jordan Elimination. This algorithm calculates the in- verse of an n n×  matrix M.      A.  Construct the augmented matrix M  given in Equation  3.34 . Through-  out this algorithm, M  refers to the current state of the augmented ma-        trix, not the original state.    B.  Set the column j equal to 1. We will loop through columns 1 to n.    ijM  has the largest absolute value. If    C.  Find the row i with i 0 , then M is not invertible.      j≠ , then exchange rows i and j using elementary row operation  a     D.  If i under  Definition  3.3.  This  is  the  pivot  operation  necessary  to  remove      zeros from the main diagonal and to provide numerical stability.      j  entry of M  to 1 using ele-    E.  Multiply row j by 1       mentary row operation  b .  rjM−   times row j to row r.    F.  For each row r where 1 r This step clears each entry above and below row j in column j to 0 using      elementary row operation  c .      G.  If  j  n< , increment j and loop to step C.   j≥  such that  ijM ≠  . This sets the    ≤ ≤  and r  j≠ , add   jjM  ,j  n              The implementation of Algorithm 3.12 is straightforward and has the benefit  that  it  can  determine  whether  a  matrix  is  invertible.  The  following  example  demonstrates the inner workings of the algorithm.    3.3  Matrix Inverses   43                     3.35     3.36     3.37    Example 3.13. Calculate the inverse of the 3 3×  matrix M given by              Solution. Concatenating the identity matrix to M, we have   =  M  3 2   6 0  − 1 3   8 − 3 2        .   M  =  3 2   6 0  − 1 3   8 1 0 0 − 3 0 1 0 2 0 0 1  We now apply steps C through F of the algorithm for   ⎯⎯⎯⎯⎯⎯⎯→  Exchange rows 1 and 2 1 Multiply new row 1 by  6  ⎯⎯⎯⎯⎯⎯⎯→   row 1 to row 2  − × Add  2   Add row 1 to row 3  ⎯⎯⎯⎯⎯⎯→  Multiply row 2 by   1 3  .        1j = .  0 0 1 0 0 0 0 1 0 0 1  1 6 − 1 6  1 3  1 6                1 6 − 1 6 1 6 − 1 2  1 9  1 9  0 0 1 0 0 1                0 1   3 2  − 1 3  1 0   0 3  0 3    − 1 2 8 2 − 1 2 9 3 2  1 0 0 1 0 3       1 0 0 1 0 0        − 1 2 3 3 2 − 1 2 3 − 15 2  0 1 0  0 1 3 0 0 1 3 − 1  3j = .  1 0 0 1 0 0        − 1 2 3 1  0 1 3 2 15  1 6 − −  1 9 1 15  0 0 − 2 15         ⎯⎯⎯⎯⎯⎯⎯→   row 2 to row 3  − × Add  3    3.38    Finally, we apply the algorithm for   ⎯⎯⎯⎯⎯⎯⎯→  Multiply row 3 by   2 15  −  Applying the same steps for   2j =  gives us the following.    44   3. Matrices    3.39     3.40                      ⎯⎯⎯⎯⎯⎯⎯→   row 3 to row 1  row 3 to row 2  × 1 Add    2 − × Add  3   1 0 0 0 1 0 0 0 1        1 15 − 1 15 2 15  2 15 4 45 − 1 15  − 1 15 2 5 −  2 15           The right side 3 3×  matrix is now equal to the inverse of M:   − 1  M  =  1 45  3 − 3 6        6 4 − 3  − 3 18 − 6        .    To understand why Algorithm 3.12 supplies the inverse of a matrix, we need     the following theorem.   ′M  be the n n×  matrix resulting from the performance of an  Theorem 3.14. Let  ′ =M EM, where E is  elementary row operation on the n n×  matrix M. Then  the n n×  matrix resulting from the same elementary row operation performed  on the identity matrix.   Proof. We shall give separate proofs for each of the three elementary row opera- tions listed in Definition 3.3.    a   Let E be equal to the identity matrix after rows r and s have been exchanged.   Then the entries of E are given by   E  ij   =     δ δ δ  ij  sj  rj  , , ,  if  if  if   i i i  ≠ = =  r r s   and  ; ,  ≠  i  s  ;       where   ijδ  is the Kronecker delta symbol defined by Equation  2.42 . The en-  tries of the product EM are then given by      EM     ij  =  E M ik  kj  =  n    = 1  k  M M M        , , ,  ij  sj  rj  if  if  if   i i i  ≠ = =  r r s   and  ; .  ≠  i  s  ;    Thus, rows r and s of the matrix M have been exchanged.    3.41     3.42     3.3  Matrix Inverses   45    b   Let E be equal to the identity matrix after row r has been multiplied by a sca-  lar a. Then the entries of E are given by                               3.43     3.44     3.45     3.46    E  ij  =    δ , ij aδ  ij  ,  i if  i if   ≠ =  r r  ;   .  The entries of the product EM are then given by      EM     ij  =  E M ik  kj  n    = 1  k  M ij aM   =    ,  ,  ij  i if  i if   ≠ =  r r  ;   .  Thus, row r of the matrix M has been multiplied by a.      c   Let E be equal to the identity matrix after row r has been multiplied by a sca-  lar a and added to row s. Then the entries of E are given by   E  ij  =    δ δ  ij  ij  , +  aδ  rj  ,  i if  i if   ≠ =  s s  ;   .  The entries of the product EM are then given by      EM     ij  =  E M ik  kj  n    = 1  k   =    ij  M M aM  , +  ij  ,  rj  i if  i if   ≠ =  s s  ; .     Thus, row r of the matrix M has been multiplied by a and added to row s.    The matrix E that represents the result of an elementary row operation per-   formed on the identity matrix is called an elementary matrix. If we have to apply  k  elementary  row  operations  to  transform  a  matrix  M  into  the  identity  matrix,  then   =I E E k  E M ,   1  k− 1   3.47    1  2  ,  ,  E E  E   are  the  elementary  matrices  corresponding  to  , where  the  matrices  the same k row operations applied to the identity matrix. This actually shows that  E  is equal to the inverse of M, and it is exactly what we  the product  get when we apply the k row operations to the identity matrix concatenated to the  matrix M in Equation  3.34 .   E E  k − 1  1  k  k   46   3. Matrices               If a matrix M is singular, then finding elementary matrices   E  that  ,   satisfy Equation  3.47  is impossible. This is true because singular matrices are  exactly those whose rows form a linearly dependent set, as the following theorem  states.   E E  ,  ,  2  1  k  Theorem 3.15. An n n×  matrix M is invertible if and only if the rows of M  form a linearly independent set of vectors.   Proof. Let the rows of M be denoted by  in two parts.   R R  T 1  ,  T 2  R . We prove this theorem  ,  ,  T n   a   We prove that if M is invertible, then the rows of M form a linearly inde- pendent set of vectors by proving the contrapositive, which states that if the  rows of M form a linearly dependent set of vectors, then M must be singular.  So assume that the rows of M are linearly dependent. Then there exists a row  r that can be written as a linear combination of k other rows of the matrix as  follows.   R  T r  =  a  1  R  T s 1  +  a  R  T s 2  2  +  R  a  +  k  T s k      3.48    The values of     trix M other than row r. Let the n n×  matrix  matrix  representing  the  addition  of  write   ia  are scalars, and the values of  is  index k rows in the ma- iE  be equal to the elementary  is   to  row  r.  Then  we  can   ia   times  row     where    3.49   ′M  is equal to M, except that row r has been replaced by all zeros. By   E M  =M E E k  k− 1  1  ′ ,   Theorem 3.9, the matrix   ′M  is singular, and thus M is singular.    b   Now assume that the rows of M form a linearly independent set of vectors.  We first observe that performing elementary row operations on a matrix does  not  alter  the  property  of  linear  independence  within  the  rows.  Running  through Algorithm 3.12, if step C fails, then rows j through n of the matrix at  that  point  form  a  linearly  dependent  set  since  the  number  of  columns  for  nR  have at least one nonzero entry is less than the  which the rows  number of rows itself. This is a contradiction, so step C of the algorithm can- not fail, and M must be invertible.    jR  through   T  T   3.4  Determinants   47               This theorem tells us that every singular matrix can be written as a product of    elementary matrices and a matrix that has a row of zeros. With the introduction  of  determinants  in  the  next  section,  this  fact  allows  us  to  devise  a  test  for  singularity.   3.4  Determinants   The determinant of a square matrix is a scalar quantity derived from the entries of  the matrix. The determinant of a matrix M is denoted by det M. When displaying  the entries of a matrix, we replace the brackets on the left and right of the matrix  with vertical bars to indicate that we are evaluating the determinant. For example,  the determinant of a 3 3×  matrix M is written as   det  =M  M M M  11  21  31  M M M  12  22  32  M M M  13  23  33  .   The value of the determinant of an n n×  matrix is given by a recursive formu-     −   la.  For  notational  convenience,  let  the  symbol  1 matrix whose entries consist of the original entries of M after deleting the i-th  row  and  the  j-th  column.  For  example,  suppose  that  M  is  the  following  3 3×   matrix.   jM   denote  the      − × 1  { },i  n  n     Then   {  }2,3M  is the following 2 2×  matrix.   =  M  1 2 3 4 5 6 7 8 9                 { }2,3  M   =    1 2 7 8         The formula for the determinant is recursive and can be expressed in terms of the  following definition.   Definition 3.16. Let M be an n n×  matrix. We define the cofactor  matrix entry       ijM  as follows.       ≡ −M 1  }, { M   i j  det              +  i  j  ijC     ijC M  of the       3.53     3.50     3.51     3.52     48   3. Matrices                    Using cofactors, a method for calculating the determinant of an n n×  matrix  can be expressed as follows. First, define the determinant of a 1 1×  matrix to be  the entry of the matrix itself. Then the determinant of an n n×  matrix M is given  by both the formula    3.54     3.55     3.56    and the formula   det  n  = M  = 1  i  M C  ik  ik       M    det  n  = M  = 1  j  M C  kj  kj       M ,   ≤ ≤ .  Remarkably,  both  where  k  is  an  arbitrarily  chosen  constant  such  that 1 k formulas give the same value for the determinant regardless of the choice of k.  The determinant of M is given by the sum along any row or column of products  of entries of M and their cofactors.    An explicit formula for the determinant of a 2 2×  matrix is easy to extract  from Equations  3.54  and  3.55 :   n  a c  b d  =  ad  −  bc  .   We also give an explicit formula for the determinant of a 3 3×  matrix. The fol- lowing is written as one would evaluate Equation  3.55  with   1k = .   a a a  11  21  31  a a a  12  22  32  a a a  13  23  33  =  a  11  =  a 11 +  22  32  a a   a a 22   a  13  a a  23  33  −  a  − 33 a a 21 32  a a 23 −  12  a a   32 a a 22  21  31  −  31  23  a a 33    12  a    +  a  13  a a  21  31  a a 21 33  −  a a 23  31  a a  22  32        3.57    Clearly, the determinant of the identity matrix  nI  is 1 for any n since choos- 1k =  reduces Equation  3.55  to     ing    We can derive some useful information from studying how elementary row  operations  see Definition 3.3  affect the determinant of a matrix. This provides a  way of evaluating determinants that is usually more efficient than direct applica- tion of Equations  3.54  and  3.55 .   =I n  det  det  .  − 1  I  I  11  n   3.4  Determinants   49                        Theorem 3.17. Performing elementary row operations on a matrix has the fol- lowing effects on the determinant of that matrix.              a   Exchanging two rows negates the determinant.   b   Multiplying a row by a scalar a multiplies the determinant by a.   c   Adding  a  multiple  of  one  row  to  another  row  has  no  effect  on  the     determinant.            Proof.    a   We prove this by induction. The operation does not apply to 1 1×  matrices,  but for a 2 2×  matrix, we can observe the result through direct computation.   c a  d b  =  −  cb ad  = −     ad  −     cb  = −  a c  b d      3.58      Now, for an n n×  matrix, we can assume that the result is true for all ma- trices  up  to  size      − .  Let  G  represent  the  result  of  exchanging  1 s≠ ,  rows r and s of a matrix F. Choosing another row k such that k evaluation of Equation  3.55  gives us   r≠  and k    − × 1  n  n     n    j  = 1   − × 1  det  G  =  G C  kj  kj     G     =       − 1  k  G+ j  kj  det  {  }, G .  k j   3.59    n    = 1  j  Since  = − det  },k jG  is an   { { F    −  matrix, we know by induction that  1  for each j. Thus, det  = −G  det  F.   }, k j  n  n     det  {  }, k jG     b   Let G represent the result of multiplying row k of a matrix F by the scalar a.   Then evaluation of Equation  3.55  gives us   det  G  =  G C  kj  kj     G     n    = 1  j  n    = 1  j  =  aF C  kj  kj       F .    3.60    Thus, det  a=G  det  F.    Before we can prove part  c , we need the following corollary to part  a .    50   3. Matrices         Corollary 3.18. The determinant of a matrix having two identical rows is zero.   Proof. Suppose the matrix M has two identical rows. If we exchange these rows,  then no change has been made to the matrix, but the determinant has been negat- ed. So det  M, and we must therefore have det  0=M .    = −M  det  Proof of Theorem 3.17 c . Let G represent the result of adding the scalar a times  row r of a matrix F to row k of F. Then evaluating Equation  3.55  gives us   det  G  =  G C  kj  kj     G     n    = 1  j  n    = 1  j  =     F kj  +    aF C  rj  kj     F     =  det  F  +  a  F C rj  kj       F .   n    = 1  j   3.61    1Σ k    F  is equivalent to the determinant of the matrix F with the  The sum  entries in row k replaced by the entries of row r. Since this matrix has two identi- cal rows, its determinant is zero by Corollary 3.18. Therefore, det  F.    F C rj  =G  det     kj  =  j    Since  elementary  matrices  are  representative  of  elementary  row  operations  performed on the identity matrix, we can deduce their determinants from Theo- rem 3.17. An elementary matrix that represents an exchange of rows has a deter- minant of  1− , an elementary matrix that represents a row multiplied by a scalar a  has a determinant of a, and an elementary matrix that represents a multiple of one  row added to another row has a determinant of 1. These are the exact numbers by  which the determinant of any matrix is multiplied when the corresponding ele- mentary row operations are performed on them. We can therefore conclude that  if E is an n n×  elementary matrix, then det E M for any n n×  matrix  M since multiplication by E performs the elementary row operation on M. This  result leads us to the following two important theorems.   det det  =EM  Theorem 3.19. An n n×  matrix M is invertible if and only if det  0≠M .   Proof. Suppose that M is invertible. Then M can be written as a product of ele- mentary matrices, each having a nonzero determinant. Since the determinant of a    3.4  Determinants      51   product  of  elementary  matrices  is  equal  to  the  product  of  the  determinants  of  those matrices, the determinant of M cannot be zero. Now suppose that M is sin- gular. Then M can be written as a product of elementary matrices and a matrix  having a row of zeros because the rows of M must be linearly dependent. Since  the determinant of a matrix possessing a row of zeros is zero, the determinant of  the product is also zero.    Theorem 3.20. For any two n n×  matrices F and G, det  =FG  det det  F G.   Proof. If either F or G is singular, then FG is singular and the equation holds  since both sides are zero. Otherwise, both F and G can be factored completely  into elementary matrices. Since the determinant of a product of elementary ma- trices is the product of the determinants, the equation holds.      Theorem 3.19 gives us a test for singularity. Once we know that the determi- nant of an n n×  matrix M is not zero, we can use the following formula to calcu- late the entries of   1−M .      Theorem 3.21. Let F be an n n×  matrix and define the entries of an n n×  matrix  G using the formula        where   G jiC F  is the cofactor of    1−=G F .     ji det  . Then    3.62    C=  F F   T  F  ,               ij  ij  Proof. Using the multiplication formula for FG, we have      FG     ij  =  n  k  kj  = 1 n    F G ik   CF  jk det = 1 1  det  F  ik  n  k  = 1  k  =  =     F F  F C ik  jk       .   F      3.63    If i  3.54 , so multiplying by 1 det F gives us    j= , then the summation gives the determinant of F equivalently to Equation  j≠ , then the summation   . If i 1  FG     ij =   52   3. Matrices            gives the determinant of a matrix equal to F except that row j has been replaced  by the entries in row i. Since the matrix has two identical rows, its determinant is  zero, and thus   . Since the main diagonal entries of FG are 1 and all the  0 remaining entries are 0, FG is the identity matrix. A similar argument proves that  GF is the identity matrix, so   1−=G F .    ij =  FG       Using  Equation   3.62 ,  we  can  derive  explicit  formulas  for  the  inverses  of  matrices having sizes that are commonly used in computer graphics. The inverse  of a 2 2×  matrix A is given by      A  22  − A 21 The inverse of a 3 3×  matrix B is given by   1 det  A  A  =  −  1  − A 12 A 11  .        3.64    − 1  B  =  1 det  B  B B 22 33 B B 23 B B 21  32  31        − − −  32  B B 23 B B 21 33 B B 22  31  32  B B 13 B B 11 33 B B 12  31  − − −  B B 12 B B 13 B B 11  33  31  32  B B 12 B B 13 B B 11  23  21  22  − − −  22  B B 13 B B 11 23 B B 12  21        .    3.65    The inverse of a matrix M can be expressed as  CM  is used to denote the matrix of cofactors of the entries of    ij    tion    ijC=M C cofactor of every entry of M, we can use the entries of the matrix  the determinant of M more efficiently. Equation  3.55  can be written as   M, where the nota- TM . That is,  M .  Since  calculating  det M  also  requires  that  we  calculate  the  CM  to evaluate   C det  M        T  det  M  =  M C  kj  kj     M     n    = 1  j  n    = 1  j  n    = 1  j  =  =  M C  kj  jk  T  M        M  kj  C  M  .    jk         3.66    Thus, the determinant can be evaluated by choosing any row k of the matrix M  and summing the products with the entries of the k-th column of the matrix  CM .  For  the 3 3×   matrix  B,  we  have  the  following  expression  for  1−B   in  which  we  have chosen   1k = .    3.4  Determinants   53                     C  B  =  B B 22 33 B B 23 B B 21  32  31        − − −  32  B B 23 B B 21 33 B B 22  31  32  B B 13 B B 11 33 B B 12  31  − − −  B B 12 B B 13 B B 11  33  31  32  B B 12 B B 13 B B 11  23  21  22  − − −  22  B B 13 B B 11 23 B B 12  21        − 1  B  =  C  B    j     C  B  j  1  n    = 1  j  B 1      3.67      One final observation that we make in this section concerns linear systems of  =Mx r, where x is a vector of n unknowns and r is a vector of n con- the form  stants. If the matrix M is invertible, then the solution to this system is given by  =x M r. Again using the notation  CM  to denote the matrix of cofactors of the  entries of   TM , we can write   1−  The k-th component of x is thus given by the formula   = Mx det  C M  r  .   x  k  =  =  1 M det 1 M det  n    i  = 1 n    = 1  i     C  M     r i  ki  C  ik     M     r i  .   ikC M  does not depend  By the definition given in Equation  3.53 , the quantity  on  any  entries  in  the  k-th  column  of  the  matrix  M.  Comparing  the  summation  1Σ n M  to Equation  3.54 , we see that it is equal to the determinant of the  C matrix whose k-th column is equal to the vector r and whose other columns are  equal to those of the matrix M. Defining the notation   r i        ik  =  i        M r M       ≡  [  k  1    M  k  − 1  r M  k  + 1    M  n  ] ,    3.70    where   jM  represents the j-th column of M, we can write Equation  3.69  as   det      kx = M r k M  det  .   Equation  3.71  is known as Cramer’s rule. Since it requires a determinant    calculation for each unknown in a linear system, using Cramer’s rule is far less    3.68     3.69     3.71     54   3. Matrices               efficient  than  simply  inverting  the  coefficient  matrix  and  multiplying  it  by  the  constant vector. Cramer’s rule does, however, tell us that if the coefficients and  constants in a linear system are all integers and det , then the unknowns  must all be integers.   1= ±M  3.5  Eigenvalues and Eigenvectors   For every invertible square matrix, there exist vectors that, when multiplied by  the matrix, are changed only in magnitude and not in direction. That is, for an  n n×  matrix M, there exist nonzero n-dimensional vectors  V  such that  ,  V V 1 2  ,  ,  n  iλ  are called the eigenvalues of the matrix M, and the vectors   The scalars  called the eigenvectors that correspond to those eigenvalues.     3.72  to read   The eigenvalues of a matrix can be determined by first rearranging Equation   iV  are   λ=MV i  i  V .  i     M I V 0,   λ−  =   i  i   3.72     3.73    where I is the n n×  identity matrix. For this equation to be true for nonzero vec- iλ−M I must be singular. This is necessary because otherwise  tors  we could invert   iV , the matrix       3.74   iλ−M I is singular, its determi- contradicting the assumption that  nant must be zero, so we can calculate the eigenvalues  iλ  by solving the equation   i ≠V 0. Since   V M I iλ  0 0,   i  −    1 −  =  iλ−M I and write  =     det     λ− M I     =  0 .    3.75    The degree n polynomial in λ given by Equation  3.75  is called the charac-   teristic polynomial of the matrix M. The roots of this polynomial yield the eigen- values of the matrix M.   Example 3.22. Calculate the eigenvalues of the matrix       M  .      1 3   =    1  − 1          3.76     3.5  Eigenvalues and Eigenvectors   55                  Solution. The matrix   λ−M I is given by  − 1 =  3   M I λ  −  λ  1 − − 1  .       λ  Evaluating the determinant of   λ−M I produces the characteristic polynomial    1  − − 1  − .  3      −  λ  λ      3.77    Simplifying this polynomial and setting it equal to zero gives us   λ − = ,  4 0 2   3.78    from which it follows that the eigenvalues of M are  1  λ =  and  2  λ = − .    2  2    Once the eigenvalues have been determined, the corresponding eigenvectors  are  calculated  by  solving  the  homogeneous  system  given  by  Equation   3.73 .  iλ−M I is singular, its reduced form has at least one row of ze- Since the matrix  ros,  so  there  are  infinitely  many  solutions.  An  obvious  property  of  Equation  iV  is an eigenvector corresponding to the eigenvalue  iλ , then any   3.72  is that if  iaV  is also an eigenvector. Thus, eigenvectors are always written  scalar multiple  in terms of an arbitrary constant, which if desired, may be chosen so that the ei- genvector has unit length.   Example 3.23. Calculate the eigenvectors of the matrix       M  .      1 3   =    1  − 1         Solution.  In  Example  3.22,  we  found  that  the  matrix  M  has  the  eigenvalues  λ =   and  λ = − .  Corresponding  eigenvectors  are  found  by  solving  the  linear  2 1 system   λ−  M I V 0. For the eigenvalue  1  λ =  we have    i  =  2  2  2  i   3.79     3.80    − 1  3   1 − 3      =  V 1  0     0    ,   and for the eigenvalue  2  λ = −  we have   2               56   These systems yield the solutions   3 1   3 1       =  V  2  0     0    .   V 1  V  2  1   =    a 1 1   =  b − 3   ,   3. Matrices    3.81     3.82    where the scalars a and b are arbitrary nonzero constants.      In general, the eigenvalues of a matrix, given by the roots of its characteristic  polynomial,  are  complex  numbers.  This  means  that  the  corresponding  eigen- vectors  can  also  have  complex  entries.  A  type  of  matrix  that  is  guaranteed  to  have real eigenvalues and therefore real eigenvectors, however, is the symmetric  matrix.   Definition 3.24. An n n×  matrix M is symmetric if and only if   for all  i and j. That is, a matrix whose entries are symmetric about the main diagonal  is called symmetric.   M M=  ij  ji  The eigenvalues and eigenvectors of symmetric matrices possess the proper-    ties given by the following two theorems.   Theorem 3.25. The eigenvalues of a symmetric matrix M having real entries  are real numbers.   Proof. Let λ be an eigenvalue of the matrix M, and let V be a corresponding ei- V. Multiplying both sides of this equation on the left  genvector such that  by the row vector   TV  gives us   λ=MV  T  V MV V V  λ  T  =  =  T  V V,  λ   3.83    where the overbar denotes complex conjugation, which for vectors and matrices  is performed componentwise. Since the product of a complex number a bi+  and    3.5  Eigenvalues and Eigenvectors   57                     its conjugate a bi−  is equal to the real number  number. By showing that the product  clude that λ is real. We can examine the conjugate of   TV V is a real  TV MV is also a real number, we can con-  b+ , the product   TV MV to get   a  2  2  =  T  T  V MV V MV,    3.84   =M M because the matrix M has real entries.  TV MV is a 1 1×  matrix, it is equal to its own transpose. We   where we have used the fact that  Since the quantity  may thus write   T  V MV V MV  T     =     T  =  T  V M V.   T  Because the matrix M is symmetric,   T =M M, so we now have   T  V MV V MV,   T  =  showing that the quantity  real number. This proves that the eigenvalue λ must be real.    TV MV is equal to its own conjugate and is therefore a   Theorem 3.26. Any two eigenvectors associated with distinct eigenvalues of a  symmetric matrix M are orthogonal.   2V  be  1V  and  Proof. Let  1λ  and  2λ  be distinct eigenvalues of the matrix M, and let  V   and  the  associated  eigenvectors.  Then  we  have  the  equations  1 1 λ=MV  V . We can show that   λ=MV 1  V V  λ 1  T 1  2  2  2  λ 1  V V  T 1  2  2  2  1  T  λ= V V  by writing  T 1     V V λ 1 2     MV V T 1 V MV T 1 2 V V λ 2 ,  T 1     2  2  2  = = = =  where we have used the fact that   T =M M. This tells us that      λ 1  λ−  2     V V  T 1  2  =  ,  0  but the eigenvalues  1λ  and  2λ  are distinct, so we must have  quantity is simply the dot product   ⋅V V , the eigenvectors are orthogonal.   1  V V  T 1  . Since this   2  2  0=   3.85     3.86     3.87     3.88     58   3. Matrices   3.6  Diagonalization         Recall that a diagonal matrix is one that has nonzero entries only along the main  ijM =   whenever  diagonal.  That  is,  an  n n×   matrix  M  is  a  diagonal  matrix  if  0 j≠ . Given a square matrix M, if we can find a matrix A such that  1−A MA is a  i diagonal matrix, then we say that A diagonalizes M. Although not true in gen- eral, the following theorem states that any n n×  matrix for which we can find n  linearly independent eigenvectors can be diagonalized.      ,  V V 1 2  Theorem 3.27. Let M be an n n×  matrix having eigenvalues  1 λ λ , , suppose  that  there  exist  corresponding  eigenvectors  n linearly independent set. Then the matrix A given by    ]        i.e.,  the  columns  of  the  matrix  A  are  the  eigenvectors  nalizes M, and the main diagonal entries of the product  values of M:     =A V V  V  [  ,           n  1  2  2  ,  λ , and  , V   that  form  a  ,    n   3.89    V    diago- V V , 1 2 1−A MA are the eigen-  ,  n           − 1  A MA  =  .       3.90    λ 1 0  0            0 0 λ 0 2    λ 0    n           1−A MA is a diago- Conversely, if there exists an invertible matrix A such that  nal matrix, then the columns of A must be eigenvectors of M, and the main di- agonal entries of   1−A MA are the corresponding eigenvalues of M.   Proof. We first examine the product MA. Since the j-th column of A is the ei- genvector  jV  is an eigenvector,  we have   jMV . Since  V , so the product MA can be written as   jV , the j-th column of MA is equal to  λ=MV  j  j  j  MA  =  [  λ 1  V 1  λ  2  V  2    ]  n  =  [  V V  1  2    ]  V  n  V λ n λ  1  0     0      0 0 λ 0 2    λ 0    n            3.6  Diagonalization   59                     =  A  λ 1 0  0            0 0 λ 0 2    λ 0    n           .  Since the eigenvectors  the product   1−A MA can be written as   jV  are linearly independent, the matrix A is invertible, and   − 1  A MA A A  − 1  =  λ 1 0  0            0 0 λ 0 2    λ 0    n         =  λ 1 0  0            0 0 λ 0 2    λ 0    n     .      Now  we  prove  the  converse  assertion  that  any  invertible  matrix  A  that  diag- onalizes M must be composed of the eigenvectors of M. Suppose that D is an  =D A MA  for  some  n n×   matrix  A.  Then  we  n n×   diagonal  matrix  such  that  may write   1−  =AD MA.    3.93    jV  denote the j-th column of A, and let  1  Let  tries of D. The product AD is given by   d d ,  2  d  be the main diagonal en- ,  ,  n  AD V V  1  2  =  [    ]  V  n  =  [  d  V 1  1  d  V  2  2    V  n  d  1  0     0  d  n     0 0 d 0 2    d 0 ] ,    n            and the product MA is given by  [  =MA MV MV  1  2  MV  n  ] .   Equating the j-th column of AD with the j-th column of MA demonstrates that  d=MV jV  is an eigenvector of M corresponding to the ei- V , and thus each  j genvalue  jd .    j  j   3.91     3.92     3.94     3.95     60   3. Matrices               Since the eigenvectors of a symmetric matrix M are orthogonal, the matrix A    whose columns are composed of unit-length eigenvectors of M is an orthogonal  A . The diagonal matrix D consisting of the  matrix and therefore satisfies  eigenvalues of a symmetric matrix M can thus be expressed as     =D A MA.    3.96    − =A  T  T  1  Example 3.28. Find a matrix that diagonalizes the matrix     =  M  2 1 1 1 0 0        0   0  − 1    .         Solution. The characteristic polynomial for M is  + λ 2  = − + = − + λ  λ 2 2    1  M I λ  λ 3    det  −           − λ 2 − λ 3  1 +    .  1  The roots of this polynomial give us the eigenvalues   λ 1  λ  2  λ  3  = − 1 += 3 2 −= 3 2  5  5  .   The eigenvector  the homogeneous linear system   1V  corresponding to the eigenvalue  1λ  is given by the solution to            3 1 0 1 2 0 0 0 0       Reducing the coefficient matrix gives us  1 0 0 0 1 0 0 0 0                 =  V 1  =  V 1  0     0   0      .   0     0   0      ,    3.97     3.98     3.99     3.100     3.101     3.6  Diagonalization   61                     and the solution is thus given by   V 1  =  a  0     0   1     .   For the eigenvalue  2λ , we need to solve the system   5  1  − 2  1  0            5  − − 1 2  1  0  0  0  5  − − 5 2            =  V  2  0     0   0     .   This reduces to   and our second eigenvector is given by   Similarly, the eigenvector   0  1  0            + 2 1 0  5  − − 1 2  0  0  1  0  0            =  V  2  0     0   0     ,   1  5  V     =  b   3V  is equal to   2  1  5     =  c    − 2 1 0  V  3     .             .    3.102     3.103     3.104     3.105     3.106     62   3. Matrices   We choose the constants a, b, and c so that the eigenvectors have unit length. A  quick test verifies that the eigenvectors are orthogonal as expected since the ma- trix M is symmetric. Define the matrix A as   A  2  2   =         ≈  V V 1 V V 1 0 0.851 0 0.526 1  0  3  V V  3 − 0.526 0.851  0           .    3.107    A is an orthogonal matrix that diagonalizes M:   − 1  A MA A MA  T  =  .     3.108     − 1   =       0  0  5  3  + 2  0  0  0  0  5  3  − 2            Chapter 3 Summary   Matrix Products  If F is an n m×  matrix and G is an m p×  matrix, then the product FG is an n p×   matrix whose      j  entry is given by   ,i  Determinants  The determinant of an n n×  matrix M is given by the formulas      FG     ij  m  =   k  = 1  F G ik  kj  .   det  n  = M  = 1  i  M C  ik  ik       M                   and    Chapter 3 Summary   63                           ijC M  is the cofactor of   where  ijM  defined by  The determinant of a 2 2×  matrix is given by          = −M 1     ijC  +  i  j  det  { }, M .  i j  det  n  = M  = 1  j  M C  kj  kj       M ,   a c  b d  =  ad  −  bc  ,   and the determinant of a 3 3×  matrix is given by   a a a  11  21  31  a a a  12  22  32  a a a  13  23  33  =  a    11 +  a a 22   a  13  − 33 a a 21 32  a a 23 −    − a 32 12   a a 31 . 22     a a 21 33  −  a a 23  31        Matrix Inverses  An n n×  matrix M is invertible if and only if the columns of M form a linearly  independent set. Equivalently, M is invertible if and only if det The entries of the inverse G of an n n×  matrix F can be calculated by using the  explicit formula   0≠M .   Using this formula, the inverse of a 2 2×  matrix A is given by   G  ij  C=       ji det  F F  .   − 1  A  =  1 det  A  A  22  − A 21  − A 12 A 11  ,       and the inverse of a 3 3×  matrix B is given by  − − −  B B 22 33 B B 23 B B 21  B B 23 B B 21 33 B B 22  B B 13 B B 11 33 B B 12  1 det  − − −  B  B  =  − 1  32  31  31  31  32  32           B B 12 B B 13 B B 11  33  31  32  B B 12 B B 13 B B 11  23  21  22  − − −  22  B B 13 B B 11 23 B B 12  21        .   Eigenvalues and Eigenvectors  The eigenvalues of an n n×  matrix M are equal to the roots of the characteristic  polynomial given by    64   3. Matrices               det       λ−M I .   An eigenvector V associated with the eigenvalue λ of the matrix M is given by  the solution to the homogeneous linear system  =  M I V 0.    λ−        The eigenvalues of a real symmetric matrix are real, and the eigenvectors corre- sponding to distinct eigenvalues of a real symmetric matrix are orthogonal.   V  are linearly independent eigenvectors of an n n×  matrix M, then  ,  Diagonalization  If  the matrix A given by   V V 1 2  ,  ,  n  diagonalizes M, meaning that   =A V V  1  2  [  V  n  ]    − 1  A MA  =  λ 1 0  0            0 0 λ 0 2    λ 0    n         ,   where  1  λ λ ,  2  λ  are the eigenvalues of M.  ,  ,  n  Exercises for Chapter 3   1.  Calculate the determinants of the following matrices.    a    2   − 3  7 1 2          c    1 2  − 3 2 0        3 2 1 2 0     0 0 1         b     d    0 0 1 0 1 0 1 0 0                 7 5   17 2  10 14    1 64 2         2.  Calculate the inverses of the following matrices.    Exercises for Chapter 3      65    b     d             1 0 0 0 2 2 3 0 8 1 0 0 4 0 1 0 3 0 0 1 7 0 0 0 1                         a     c          2 0 0 0 3 0 0 0 4                 cos 0 sin        θ  θ  0 1 0  θ  −  sin 0 cos  θ           4  x  2  x  + + 3 − − x + + 3  y y y  2 3 4  z z z  = = =  0 0   0  0 0 2   5 2 3  − 4 3 2            3.  Solve the following homogeneous linear system.   4.  Calculate the eigenvalues of the following matrix.   5.  Let  M  be  an  n n×   matrix  whose  rows  are  given  by  the  vectors  R . Prove that if the rows of M form a linearly independent set,  R R , then the rows of the matrix EM, where E is an elementary matrix, also form  a linearly independent set.   T 1  T n  T 2  ,  ,  6.  An upper triangular matrix M is one for which   j> . That  is, all the entries below the main diagonal are zero. Prove that the determi- nant of an upper triangular matrix is equal to the product of the entries on  the main diagonal.   ijM =  whenever i  0  7.  Let  D  be  an  n n×   diagonal  matrix  whose  main  diagonal  entries  are  d  as shown below. Show that the inverse of D is also a diagonal  ,  d d , 1 1 matrix, and that its main diagonal entries are given by   d , ,1 n  ,1  d  d  .   ,  n  2  2  1     =  D  d 1 0  0            0 0 d 0 2    d 0    n            This page intentionally left blank    Chapter 4   Transforms   Throughout any 3D graphics engine architecture, it is often necessary to trans- form a set of vectors from one coordinate space to another. For instance, vertex  coordinates  for  a  model  may  be  stored  in  object  space,  but  need  to  be  trans- formed  to  camera  space  before  the  model  can  be  rendered.  In  this  chapter,  we  concern ourselves with linear transformations among different Cartesian coordi- nate frames. Such transformations include simple scales and translations, as well  as arbitrary rotations.   4.1  Linear Transformations   Suppose  that  we  have  established  a  3D  coordinate  system  C  consisting  of  an  origin and three coordinate axes, in which a point P has the coordinates  x y z .  , The  values  x,  y,  and  z  can  be  thought  of  as  the  distances  that  one  must  travel  along each of the coordinate axes from the origin in order to reach the point P.  Suppose now that we introduce a second coordinate system C′ in which coordi- x y z  in C.  , nates  That is, suppose we can write   ′  can be expressed as linear functions of coordinates   ′ ′ x y z , ,  ,  ,  1  ′ + x x y z U x V y W z T 1 ′ + y x y z U x V y W z T ′ + z x y z U x V y W z T 3  + + +  + + +  = = =  , , ,  , , ,                1  1  3  3  2  2  2  2     4.1   This constitutes a linear transformation from C to C′ and can be written in matrix  form as follows.   .   3          ′ x  y  ′ z     ′ =     1  1  1  U V W x         U V W y     U V W z          2  3  2  3  2  3  +  T  1  T 2  T   3           4.2    67    68   4. Transforms         The coordinates  x′,  y′, and  z′ can be thought of as the distances that one must  travel along the axes in C′ to reach the point P. The vector T represents the trans- lation from the origin of C to the origin of C′, and the matrix whose columns are  the vectors U, V, and W represents how the orientation of the coordinate axes is  changed when transforming from C to C′. Assuming the transformation is invert- ible, the linear transformation from C′ to C is given by   x     y   z      =  1  1  U V W  1  U V W  U V W    3  3  2  2  3  2        − 1  ′ x ′ y ′ z                   −  T  1  T 2  T   3      .          4.3    In Section 4.4, we will combine the 3 3×  matrix and translation vector T into    a  single 4 4×   transformation  matrix.  Before  we  reach  that  point,  we will  focus  solely on linear transformations for which  ≡T 0, in which case the vectors U, V,  and W represent the images in C′ of the basis vectors  1,0,0 ,  0,1,0 , and  0,0,1   in C.    Multiple  linear  transformations  can  be  concatenated  and  represented  by  a  single  matrix  and  translation.  For  example,  vertex  coordinates  may  need  to  be  transformed from object space to world space and then from world space to cam- era space. The two transformations are combined into a single transformation that  maps object-space coordinates directly to camera-space coordinates.   4.1.1  Orthogonal Matrices  Most 3 3×  matrices arising in computer graphics applications are orthogonal. An  orthogonal matrix is simply one whose inverse is equal to its transpose.   Definition 4.1. An invertible n n×  matrix M is called orthogonal if and only if  − =M M .   T  1  As the following theorem demonstrates, any matrix whose columns form an or- thonormal set of vectors is orthogonal.   Theorem  4.2.  If  the  vectors  n n×  matrix constructed by setting the j-th column equal to  orthogonal.   V   form  an  orthonormal  set,  then  the  , ≤ ≤  is   jV  for all 1  V V 1 2  j n  ,  ,  n   4.1  Linear Transformations   69                  Proof. Suppose that the vectors  be the n n×  matrix whose columns are given by the  thonormal,  entry  of  the  matrix  product  =M M I. Therefore,   V V 1 2 ijδ  is the Kronecker delta symbol. Since the   TM M  is  equal  to  the  dot  product  1−  V  form an orthonormal set, and let M  , jV ’s are or-   j   ⋅V V ,  we  have  i  jV ’s. Since the   =M M .     where   V V  ijδ  ,i  =  ,  ,  ⋅  T  T  n  j  j  i  Orthogonal matrices also possess the property that they preserve lengths and an- gles when they are used to transform vectors. A matrix M preserves length if for  any vector P we have   A matrix that preserves lengths also preserves angles if for any two vectors  and  2P  we have   1P    =MP  P .      MP MP 2  1      ⋅     =  ⋅  P P .  1 2  The following theorem proves that an orthogonal matrix satisfies Equations  4.4   and  4.5 .   Theorem 4.3. If the n n×  matrix M is orthogonal, then M preserves lengths and  angles.   Proof. Let M be orthogonal. We will first show that the dot product between two  vectors  1P  and  2P  is preserved by a transformation by M, and then use that result  to show that M preserves lengths. Examining the dot product between the trans- formed vectors gives us      MP MP      ⋅     =     MP MP  1    T  2  =  P M MP .  T 1 2  T  Since M is orthogonal,   2  1 − =M M , so   T  1  P M MP T 1 2  T  =  P P T 1 2  =  ⋅  P P .  1 2  This also implies that the length of a vector P is preserved when transformed by  the matrix M since   P P.    2 = ⋅  P    Since  orthogonal  matrices  preserve  lengths  and  angles,  they  preserve  the  overall structure of a coordinate system. Orthogonal matrices can thus represent    4.4     4.5     4.6     4.7     70   4. Transforms            only combinations of rotations and reflections. Rotations are discussed in detail  in Section 4.3. A reflection transform  also called an inversion transformation   refers to the operation performed when points are mirrored in a certain direction.  For example, the matrix   1 0 0 1 0 0        0   0  − 1        4.8    reflects the z coordinate of a point across the x-y plane.   1  2  ⋅     ×  >  2V , and   V V V 3  4.1.2  Handedness  In three dimensions, a basis  for a coordinate system given by the 3D vectors  3V  possesses a property called handedness. A right-handed basis is  1V ,  one for which   . That is, in a right-handed coordinate system, the  0 1V  and  2V  points  which follows the  direction in which the cross product between  3V  points. If   right hand rule  forms an acute angle with the direction in which  V V V . If   × V V V is an orthonormal right-handed basis, we have  0 ,  1 3 then the basis  is left-handed.    Performing  an  odd  number  of  reflections  reverses  handedness.  An  even  number of reflections is always equivalent to a rotation, so any series of reflec- tions can always be regarded as a single rotation followed by at most one reflec- tion. The existence of a reflection within a 3 3×  matrix can be detected by exam- ining the determinant. If the determinant of a 3 3×  matrix M is negative, then a  reflection is present, and M reverses the handedness of any set of basis vectors  transformed by it. If the determinant is positive, then M preserves handedness.    An orthogonal matrix M can only have a determinant of 1 or  1− . If det the matrix M represents a pure rotation. If det sents a rotation followed by a reflection.   1=M ,  , then the matrix M repre-  1= −M  =  ×  <     ⋅  2  3  1  2  4.2  Scaling Transforms   a′ =P To scale a vector P by a factor of a, we simply calculate  sions, this operation can also be expressed as the matrix product   P. In three dimen-  ′ =  P  P a 0 0   x   P a 0 0 y   a P 0 0     z          .       4.9     4.3  Rotation Transforms   71            Figure 4.1. Nonuniform scaling.      This is called a uniform scale. If we wish to scale a vector by different amounts  along the x, y, and z axes, as shown in Figure 4.1, then we can use a matrix that is  similar to the uniform scale matrix, but whose diagonal entries are not necessari- ly all equal. This is called a nonuniform scale and can be expressed as the matrix  product   ′ =  P  P a 0 0   x   P b 0 0 y   c P 0 0     z          .       4.10      A slightly more complex scaling operation that one may wish to perform is a  nonuniform scale that is applied along three arbitrary axes. Suppose that we want  to scale by a factor a along the axis U, by a factor b along the axis V, and by a  factor c along the axis W. Then we can transform from the   ,U V W  coordinate  system to the   i j k  coordinate system, apply the scaling operation in this sys- , , tem using Equation  4.10 , and then transform back into the   ,U V W  coordinate  system. This gives us the following matrix product.            ,  ,  ′ =  P  x  x  x  U V W a U V W 0 0           U V W U V W b 0 0      c U V W U V W 0 0            y  y  y  y  y  x  x  z  z  z  z  z  x  y  z        − 1  P x P y P z                  4.11    4.3  Rotation Transforms   We  can  find 3 3×   matrices  that  rotate  a  coordinate  system  through  an  angle θ  about the x, y, or z axis without much difficulty. We consider a rotation by a posi-   72   4. Transforms                  tive angle about the axis A to be that which performs a counterclockwise rotation  when the axis A is pointing toward us.    First,  we  will  find  a  general  formula  for  rotations  in  two  dimensions.  As  shown in Figure 4.2, we can perform a 90-degree counterclockwise rotation of a  2D vector P in the x-y plane by exchanging the x and y coordinates and negating  the new x coordinate. Calling the rotated vector Q, we have  . The  vectors P  and Q  form  an  orthogonal  basis  for  the  x-y  plane.  We  can  therefore  express any vector in the x-y plane as a linear combination of these two vectors.  ′P  that results from the rota- In particular, as shown in Figure 4.3, any 2D vector  tion of the vector P through an angle θ can be expressed in terms of its compo- nents that are parallel to P and Q. Basic trigonometry lets us write   = −Q  P P ,y x  This gives us the following expressions for the components of   ′P .   ′ = P P  cos  θ  +  Q  sin  θ  .   ′ = P x ′ = P y  P x P y  cos cos  − +  θ P y θ P x  sin sin  θ θ     P   ′ =    cos sin  θ θ  − θ sin θ cos      P   We can rewrite this in matrix form as follows.     The 2D rotation matrix in Equation  4.14  can be extended to a rotation about  the z axis in three dimensions by taking the third row and column from the identi- ty matrix. This ensures that the z coordinate of a vector remains fixed during a    rotation about the z axis, as we would expect. The matrix   that performs a  rotation through the angle θ about the z axis is thus given by     z θR  R  z     θ     =  θ θ  cos sin 0        − θ sin θ cos 0  0 0 1        .   Similarly, we can derive the following 3 3×  matrices       y θR perform rotations through an angle θ about the x and y axes, respectively:     x θR     and       that    4.12     4.13     4.14     4.15     4.3  Rotation Transforms   73         R  x     θ     =  1 0 0 cos 0 sin        θ θ  0 − θ sin θ cos        R  y     θ     =  θ  cos 0 sin     −   θ  0 sin 1 0 0 cos  θ  θ    .      y  ,y x−   4.16    Figure 4.2. Rotation by 90 degrees in the x-y plane.   y  ′P  Q  cosθ  P  Q  s i n  θ  P  θ  ,x y  x     x     Figure 4.3. A rotated vector  vector P and the 90-degree counterclockwise rotation Q of the original vector.   ′P  can be expressed as the linear combination of the original    74   4. Transforms            4.3.1  Rotation About an Arbitrary Axis  Suppose that we wish to rotate a vector P through an angle θ about an arbitrary  axis whose direction is represented by a unit vector A. We can decompose the  vector P into components that are parallel to A and perpendicular to A as shown  in Figure 4.4. Since the parallel component  the projection of P onto A  remains  unchanged during the rotation, we can reduce the problem to that of rotating the  perpendicular component of P about A.    projection of P onto A.   Since A  is  a  unit  vector, we  have  the  following  simplified  formula  for  the   The component of P that is perpendicular to A is then given by   proj  A P A P A   =        ⋅  perp  A P P A P A.   = −  ⋅         4.17     4.18    Once we rotate this perpendicular component about A, we will add the constant  parallel component given by Equation  4.17  to arrive at our final answer.    The rotation of the perpendicular component takes place in the plane perpen- dicular to the axis A. As before, we express the rotated vector as a linear combi- nation of perp A P and the vector that results from a 90-degree counterclockwise  rotation of perp A P about A. Fortunately, such an expression is easy to find. Let α      ⋅A P A     P  A  α  P A P A  −        ⋅     Figure 4.4. Rotation about an arbitrary axis.    4.4  Homogeneous Coordinates   75            be the angle between the original vector P and the axis A. Note that the length of  perp A P is equal to   because it forms the side opposite the angle α shown  in  Figure  4.4.  A  vector  of  the  same  length  that  points  in  the  direction  that  we  want is given by  ×A P.    We can now express the rotation of perp A P through an angle θ as   sin α  P  [  −  P A P A  ⋅        ]  cos  θ  +     ×  A P     sin  θ  .    4.19    Adding projA P to this gives us the following expression for the rotation of the  original vector P about the axis A.  ×  P cos  4.20       Replacing  ×A P  and  ⋅A A P   in  Equation   4.20   with  their  matrix  equivalents  given by Equations  2.25  and  2.20  respectively, we have      − 1 cos  A A P    +    A P  sin  ′ =  P  +  θ  θ  θ              ⋅  ′ =  P  P  cos  θ  +  1   0  0         0 1 0 A 2 x A A x A A x  y  z  +  0   0  1   A A x A 2 y A A y  y  z  y  0   A z  − A       cos  P  θ  z  A A x z A A y A 2 z  =  −  z  A 0 A  x  A y − A 0  x        P  sin  θ    − 1 cos  θ     .      4.21    Combining these terms and setting  formula for the matrix  axis A.    θAR     c   gives us the following   that rotates a vector through an angle θ about the    and   sin  θ  s  =     AR     θ     =  c − −    + − 1   c A A   c A A    c A + −  x  y  x  z  2 x sA sA  z  y          1   1    1    1  − c −    c A A x   + − 1   c A A  − y   c A +  y  z  sA 2 y sA  z  x    1   1  − − c  x    c A A z   c A A y   + − 1  + − z   c A  y  x  sA sA 2 z            4.22    4.4  Homogeneous Coordinates   Up to this point, we have dealt only with transforms that can be expressed as the  operation of a 3 3×  matrix on a three-dimensional vector. A series of such trans- forms could be represented by a single 3 3×  matrix equal to the product of the  matrices corresponding to the individual transforms. An important transform that  has been left out is the translation operation. A coordinate system is translated in    76   4. Transforms            space without otherwise affecting the orientation or scale of the axes by simply  adding  an  offset  vector.  This  operation  cannot  be  expressed  in  terms  of  a 3 3×   matrix. Thus, to transform a point P from one coordinate system to another, we  usually find ourselves performing the operation   ′ = P MP T,   +   4.23     where  M  is  some  invertible 3 3×   matrix  and  T  is  a  3D  translation  vector.  Per- forming two operations of the type shown in Equation  4.23  results in the rather  messy equation      ′ = + P M M P T 1 + =  1       2     +  M M P M T T ,  2  1  2  2  1  T 2 +   4.24    requiring  that  we  keep  track  of  the  matrix  component  translation  component  forms.   n−M M   as  well  as  the  T   at  each  stage  when  concatenating  n  trans- n  M T n  − + 1  n  n  1  4.4.1  Four-Dimensional Transforms  Fortunately,  there  is  a  compact  and  elegant  way  to  represent  these  transforms  within a single mathematical entity. We can do this by extending our vectors to  four-dimensional homogeneous coordinates and using 4 4×  matrices to transform  them. A 3D point P is extended to four dimensions by setting its fourth coordi- nate, which we call the w coordinate, equal to 1. We construct a 4 4×  transfor- mation matrix F corresponding to the 3 3×  matrix M and the 3D translation T as  follows.   =  F         M  0  =         T  1  21  11  M M M 31 0         22  12  M M M 32 0  23  13  M M M 33 0  y  x  T T T z 1             4.25    ,  P P P x z   transforms the x, y, and z co- Multiplying this matrix by the vector  ordinates of the vector in exactly the same way as Equation  4.23  and leaves a 1  in the w coordinate. Furthermore, multiplying two transformation matrices of the  form  shown  in  Equation   4.25   yields  another  matrix  of  the  same  form  that  is  equivalent to the pair of transforms performed in Equation  4.24 .     If we solve Equation  4.23  for P, we have   ,1  ,  y   4.4  Homogeneous Coordinates   77             4.26     We would therefore expect the inverse of the 4 4×  matrix F from Equation  4.25   to be   P M P M T.   1  =  − 1  ′  −  −  − 1  F  =          − 1  M  0  −  − M T 1  =          − M 1 11 − M 1 21 − M 1 31 0          − M 1 12 − M 1 22 − M 1 32 0  − M 1 13 − M 1 23 − M 1 33 0         − − −  − 1  − 1  M T M T − M T 1         x  y  z  1          ,    4.27    and the following computation verifies that this is true.   − 1  FF  =  − 1  M  −  − M T 1  1  M  0  0  I  3  0                     =  =  0  1               T  1  =  I  4         0  1  MM  − 1  M M T T  − 1  +  −               1             4.28    4.4.2  Points and Directions  We have now come to a point where it is necessary to make a distinction between  vectors that represent points in three-dimensional space and vectors that represent  directions  in  three-dimensional  space.  Unlike  points,  direction  vectors  should  remain invariant under translation.  To transform direction vectors using the same 4 4×  transformation matrices    that we use to transform points, we extend direction vectors to four dimensions  by setting the w coordinate to 0. This nullifies the fourth column of the matrix F    78   4. Transforms         in Equation  4.25 , leaving only the upper left 3 3×  portion of the matrix to affect  the direction vector.  The difference between two points P and Q having a w coordinate of 1 re-   sults in a direction vector  −Q P having a w coordinate of 0. This makes sense  because  −Q P  represents  the  direction  pointing  from  P  to  Q,  which  we  would  expect not to be affected by a translation.   4.4.3  Geometrical Interpretation of the w Coordinate  The  w  coordinates  of  the  four-dimensional  vectors  with  which  we  have  been  working  so  far  have  a  meaning  that  goes  beyond  their  utility  during  transfor- mations using 4 4×  matrices. Before, we extended a three-dimensional point to  four-dimensional space by adding a 1 in the w coordinate position. Now, we de- fine a mapping that works in the reverse direction. Suppose we have a 4D point  =P   whose  w  coordinate  is  not  0.  Then  we  define  the  image  of P  in  three-dimensional space, which we denote by P , as the projection of P into the  three-dimensional space in which   1w =  using the formula   x y z w ,  ,  ,  =P  x y z w w w  ,  ,  .    4.29    As shown in Figure 4.5  but without the z axis to make visualization easier , the  3D point P  corresponds to the point where the line connecting the point P to the  1w = . Thus, any scalar multiple of the 4D vector  origin intersects the space where  P represents the same point in three-dimensional space. The importance of this  projection in 3D graphics is discussed in detail in Section 5.5.   4.5  Transforming Normal Vectors   In addition to its position in space, a vertex belonging to a polygonal model usu- ally carries additional information about how it fits into the surrounding surface.  In particular, a vertex may have a tangent vector and a normal vector associated  with it. When we transform a model, we need to transform not only the vertex  positions, but these vectors as well.    Tangent vectors can often be calculated by taking the difference between one  vertex and another, and thus we would expect that a transformed tangent vector  could be expressed as the difference between two transformed points. If M is a  3 3×  matrix with which we transform a vertex position, then the same matrix M  can  be  used  to  correctly  transform  the  tangent  vector  at  that  vertex.   We  limit    4.5  Transforming Normal Vectors   79         w  =P  x y z w ,  ,  ,  wPP  1w =  y     x  Figure 4.5.  A  4D  point  P  is  projected  into  three-dimensional  space  by  calculating  the  point where the line connecting the point to the origin intersects the space where   1w = .   ourselves to 3 3×  matrices in this section since tangent and normal directions are  unaffected by translations.  Some care must be taken when transforming normal  vectors, however. Figure 4.6 shows what can happen when a nonorthogonal ma- trix M is used to transform a normal vector. The transformed normal can often  end up pointing in a direction that is not perpendicular to the transformed surface.  Since tangents and normals are perpendicular, the tangent vector T and the    normal vector N associated with a vertex must satisfy the equation  0 . We  must also require that this equation be satisfied by the transformed tangent vector  ′T  and the transformed normal vector  ′N . Given a transformation matrix M, we  ′ =T MT.  We  would  like  to  find  the  transformation  matrix  G  with  know  that  which the vector N should be transformed so that   ⋅ =N T  ′  ′ N T  ⋅  =     GN MT      ⋅    0 =  .    4.30    A little algebraic manipulation gives us    80   4. Transforms         N  MN     Figure 4.6. Transforming a normal vector N with a nonorthogonal matrix M.      GN MT      ⋅     = =      T T      GN MT N G MT   . T 0=   4.31    −  T  T  T  T     =   1 T  N G MT   is satisfied if   0=N T G M I. We therefore  Since  , the equation  =G M . This tells us that a normal vector is correctly trans- conclude that  formed using the inverse transpose of the matrix used to transform points. Vec- tors that must be transformed in this way are called covariant vectors, and vec- tors  that  are  transformed  in  the  ordinary  fashion  using  the  matrix  M   such  as  points and tangent vectors  are called contravariant vectors.  − =M M , and thus   M. There-   fore, the inverse transpose operation required to transform normal vectors can be  avoided when M is known to be orthogonal, as is the case when M is equal to  one of the rotation matrices   If the matrix M is orthogonal, then   AR  presented earlier in this chapter.   zR , or   xR ,    1 T  yR ,   M  =  T  −  1  A quaternion is an alternative mathematical entity that 3D graphics programmers  use to represent rotations. The use of quaternions has advantages over the use of  rotation  matrices  in  many  situations  because  quaternions  require  less  storage  space,  concatenation  of  quaternions  requires  fewer  arithmetic  operations,  and  quaternions are more easily interpolated for producing smooth animation.   4.6.1  Quaternion Mathematics  The set of quaternions, known by mathematicians as the ring of Hamiltonian qua- ternions and denoted by , can be thought of as a four-dimensional vector space  for which an element q has the form   4.6  Quaternions    4.6  Quaternions   81               = +  w xi  +  yj  +  zk  .    4.32    =  q  ,  w x y z , , s= +  q  v, where s represents the scalar part cor- A quaternion is often written as  responding to the w-component of q, and v represents the vector part correspond- ing to the x, y, and z components of q.  The set of quaternions is a natural extension of the set of complex numbers.    Multiplication of quaternions is defined using the ordinary distributive law and  adhering to the following rules when multiplying the “imaginary” components i,  j, and k.   2  i  = ij jk ki  = = − j k 1 2 2 = − = k ji = − = kj i = − = ik j      4.33    2  2  =  +  +  +  w  x i 2  Multiplication of quaternions is not commutative, and so we must be careful to  q z k multiply terms in the correct order. For two quaternions    1 2q q  is given by  q and  , the product  1     − z z 1 2     + i z y 1     + j z x 1 2     − z w k 1  z k 2 = + + +  w w 1 w x 1 2 w y 1 w z 1 2  x x 1 2 x w 1 x z 1 2 x y 1  y y 1 y z 1 2 y w 1 y x 1 2  y j 2 q q 1  − + − +  − − + +  w x i 1 1   4.34    y j 1  =  +  +  +  .      2  2  2  2  2  2  1  2  2  2  When written in scalar-vector form, the product of two quaternions  q and   v  can be written as  2  s=  +  2  2  q  1  s=  1  +  v   1  q q 1  2  =  s s 1 2  −  ⋅  v v 1  2  +  s  1  v  2  +  s  v  1  2  +  ×  v  1  v .  2   4.35    Like complex numbers  see Appendix A , quaternions have conjugates, and     they are defined as follows.   Definition 4.4. The conjugate of a quaternion  q q by   s= −  v.   s= +  v, denoted by q, is given   A short calculation reveals that the product of a quaternion q and its conjugate q  is equal to the dot product of q with itself, which is also equal to the square of the  magnitude of q. That is,    82   4. Transforms               and   qq qq q q  = ⋅ =  =  q  2  =  2q  .    4.36    This leads us to a formula for the multiplicative inverse of a quaternion.   Theorem 4.5. The inverse of a nonzero quaternion q, denoted by  by        .   q     1  − = q 2q  1−q , is given    4.37    Proof. Applying Equation  4.36 , we have   qq  − = 1  qq q 2  =  2  2  q q  =  1    − = q q 1  qq q 2  =  2  2  q q  =  1 ,    4.38     4.39    thus proving the theorem.    4.6.2  Rotations with Quaternions  3   A rotation in three dimensions can be thought of as a function φ that maps  onto  itself.  For φ  to  represent  a  rotation,  it  must  preserve  lengths,  angles,  and  handedness. Length preservation is satisfied if  P .     =P  φ           φ  The angle between the line segments connecting the origin to any two points  and  2P  is preserved if  P   1 Finally, handedness is preserved if  × φ   4.42     Extending  the  function  φ  to  a  mapping  from    onto  itself  by  requiring  that    φ s    v  allows us to rewrite Equation  4.41  as     P P .  1  P P .  1 2   4.41    = +  s φ  φ⋅  P 2  P 2  P 1  φ  φ  =  =  ×  +  v                                ⋅  2   4.40   1P     4.6  Quaternions   83                     φ  P 1     ⋅     φ  P 2     =       P P .  1  ⋅  2  φ   4.43    1P   and   2P   as  quaternions  with  zero  scalar  part  enables  us  to  combine  Treating  P P .  We  can  therefore  Equations   4.42   and   4.43   since  1 write  the  angle  preservation  and  handedness  preservation  requirements  as  the  single equation   = − ⋅ P P 1 2  P P 1 2  ×  +  2     φ  P 1        φ  P 2     φ=       P P .  1  2  A function φ that satisfies this equation is called a homomorphism.     The class of functions given by    q P  φ     =  − qPq ,  1   4.44     4.45    where q is a nonzero quaternion, satisfies the requirements stated in Equations   4.40  and  4.44 , and thus represents a set of rotations. This fact can be proven  by first observing that the function φq preserves lengths because      P     φ  q  =  qPq  −  1  =  q P q  −  1  =  P  q q q 2  =  P .    4.46    Furthermore, φq is a homomorphism since  − qP q qP q 1 2  P 2  φ q  P 1  φ  =  − 1                 q  1  =  qP P q 2  1  − 1  =  φ  q       P P .  1  2   4.47      We now need to find a formula for the quaternion q corresponding to a rota- φ=q tion through the angle θ about the axis A. A quick calculation shows that  aφ q  for any nonzero scalar a, so to keep things as simple as possible, we will concern  ourselves only with unit quaternions.    have   v be a unit quaternion. Then   v, and given a point P, we   − = − 1  s= +  Let   q  q  s  qPq  − = 1  s      + v P   = − ⋅ + v P ⋅ + = − v P s = + P s s 2 2      − v s      + × − v P v P s s     × + ⋅ − + v P v v P P Pv s s s 2     × + − × × ⋅ v P v P v v P v .  −       × v P v    After applying Theorem 2.9 f  to the cross product  × × ⋅ v P v.     v P 2  × + v P  v P v, this becomes     qPq  − = 1  −  +  2  2     s  s           2   4.48     4.49     84   4. Transforms                  Setting   t=v A, where A is a unit vector, lets us rewrite this equation as   qPq  − = 1  2  s  −  2  t  P  +  2  st  × +  A P  2  t 2     ⋅  A P A.             4.50    When we compare this to the formula for rotation about an arbitrary axis given in  Equation  4.20 , we can infer the following equalities.   2  s  2  − t st 2 t 2 2  = θ cos = θ sin = − 1 cos  θ      4.51      The third equality gives us   − 1 cos     t  θ  2  .   =  =  sin  θ 2 The  first  and  third  equalities  together  tell  us  that  = s is satisfied by these values for s and t.     We have now determined that the unit quaternion q corresponding to a rota- tion through the angle θ about the axis A is given by   = ,  so  we  must  have  2 1  verifies that the second equality     θ .  The fact that sin 2  2sin cos   4.52    cos  t+  =  2  θ  θ  θ  s     2  =  q  cos  +  A  sin  θ 2  θ 2  .    4.53    It should be noted that any scalar multiple of the quaternion q  in particular, −q   also represents the same rotation since        q P q a a        − 1  =  qP a  The product of two quaternions     2q q  represents the rotation resulting from first rotating by  cally, the product  1 and then by  1q . Since   1q  and   − 1  − qPq .  1  =q a 2q  also represents a rotation. Specifi- 2q     4.54       q q Pq 1  2  1  − 2     q  − = 1 1     q q P q q 1 1  2  2          1 − ,    4.55    we can concatenate as many quaternions as we want to produce a single quater- nion representing the entire series of rotations. Multiplying two quaternions to- gether requires 16 multiply-add operations, whereas multiplying two 3 3×  matri-   4.6  Quaternions   85                  ces together requires 27. Thus, some computational efficiency can be gained by  using  quaternions  in  situations  in  which  many  rotations  may  be  applied  to  an  object.  It is often necessary to convert a quaternion into the equivalent 3 3×  rotation    matrix, for instance, to pass the transform for an object to a 3D graphics library.  We  can  determine  the  formula  for  the  matrix  corresponding  to  the  quaternion  q A by using Equations  2.25  and  2.20  to write Equation  4.50  in matrix  t form.  This is nearly identical to the technique used in Section 4.3.1.  This gives  us   = +  s              2  s  2  t  qPq  − 1  =  2  s  2  t  0 − 0  0 0 −  2  s  2  t  +  t A 2 2 2 x t A A 2 2 t A A 2 2  x  x  y  z  t A A 2 2 x t A 2 2 2 y t A A 2 2  y  y  z  − 0 0       +  P            t A A 2 2 z t A A 2 2 y t A 2 2 2 z  0 stA 2 z − stA 2       P  x  z  .  y  z  − stA 2 0 stA  2  x  stA 2 y − stA 2 0  x        P     4.56    Writing the quaternion q as the four-dimensional vector  w s= ,   =q . Since A is a unit vector,    , and   tA=  tA= x  ,   x  y  z  y  w x y z , ,  ,  , we have   2  y  +  2  z  =  t A 2  2  = .  t  2   4.57    tA= z +  2  x  Rewriting Equation  4.56  in terms of the components w, x, y, and z gives us   2  w  −  2  x  2  y  −  2  z  qPq  − 1  =  2  w  −  2  x  2  y  −  2  z  − 0 0  0 − 0  +  0   wz 2  −  wy 2  − wz 2 0 wx 2  wy 2 − wx 2 0        +  P  2 2 2  2  x xy xz        w xy y 2 yz  2 2 2  2  −  2  x xz yz z 2  2 2 2  Since q is a unit quaternion, we know that  w = −  −  −  −  2  2  2  2  w  x  z  1 2  x  2  y  2  x −  2  +  +  2  y  +  2  z  2  2  y  −  2  z  2  .   0 0 −  P        2  y  −  2  z  .  P     4.58         = , so we can write  1   4.59    Using this equation and combining the three matrices gives us the following for- mula for the matrix   qR , the rotation matrix corresponding to the quaternion q:    86   4. Transforms            qR  =  2  − y 1 2 2   + xy 2  −  xz 2   − z 2 wz 2 wy 2  − xy 2 − x 1 2 2 + yz 2  2 − 2  wz z 2 wx  2  xz 2 yz 2 − x 1 2  + − 2  2 2 −  wy wx y 2  2  .          4.60    4.6.3  Spherical Linear Interpolation  Because quaternions are represented by vectors, they are well suited for interpo- lation. When an object is being animated, interpolation is useful for generating  intermediate orientations that fall between precalculated key frames.    ternions  1q  and   The simplest type of interpolation is linear interpolation. For two unit qua-  2q , the linearly interpolated quaternion     tq   is given by       t    = − 1     +  t  q    The function     tq as t varies from 0 to 1. As shown in Figure 4.7,  length of  function    changes smoothly along the line segment connecting   2q    does not maintain the unit  2q , but we can renormalize at each point by instead using the   1q  and   1q  and    4.61       tq  q .  t 2  q  1      t  q  =    1   1  − −       t t  q q  1  1  + +  t t  q q  2  2  .    4.62       tq  q q      t     t  1q  2q  Figure 4.7. Linear interpolation of quaternions.       4.6  Quaternions      87   θ  cos  − 1     q      t  ⋅  q     1      ⋅ Figure 4.8. Graph of  t function given by Equation  4.62 .   cos  q     −  1     q , where  1     tq   is the normalized linear interpolation   t     1  −  ⋅     q  cos      t  1q  and    given by Equation  4.62  does not trace out the arc between   2q , shown in Fig- Now we have a function that traces out the arc between  ure 4.7 as a two-dimensional cross-section of what is actually occurring on the  surface of the four-dimensional unit hypersphere.    Although linear interpolation is efficient, it has the drawback that the func- tion     tq 2q  at    q  shown in Figure 4.8 demonstrates  a constant rate. The graph of  1 that the rate at which the angle between     tq 1q  changes is relatively slow at   and  the endpoints where    We would like to find a function     tq 2q , preserves unit length, and sweeps through the angle between  constant rate. If  1q  and  generate quaternions forming the angle θt between     tq to 1.    forming  the  angle θt  with  write     tq  1q  and  2q  at a  2q  are separated by an angle θ, then such a function would  1q  as t varies from 0    that interpolates the quaternions  1q  and   1t = , and is the fastest where   Figure 4.9 shows the quaternion    lying on the arc connecting   1q ,  and  forming  the  angle   2q ,  1q  and  2q .  We  can   t−   with   t =  and   1q  and   t = .  1 2     tq   and     1θ   as   0            t  q  =      a t  q  1  +      b t  q   2   4.63       a t   and  by  letting  along the directions  length     a t  by constructing similar triangles. The perpendicular distance from  to the line segment connecting the origin to     lying  2q . As shown in Figure 4.9 a , we can determine the  1q   . The perpen-     b t   represent  the  lengths  of  the  components  of  1q  and   2q  is equal to   1 sinθ     tq  q   88   4. Transforms    to this line segment is equal to       t  q  sin  θ    1  t−    . Using     dicular distance from     tq similar triangles, we have the relation  = q  Since   1=q  1   and       t =  q  1 , we can simplify this to       a t q  1      t sin q    θ 1 θ sin  1  −     t  .   sin      a t  =    − θ 1 θ sin     t  .          4.64     4.65       a t  θt   1θ  t−        tq  2q  sin    1θ  t−     1q  s i n θ  1q  sinθt  sinθ     tq   a   O   b   O  θt   1θ    b t  t−     2q     Figure 4.9. Similar triangles can be used to determine the length of  a  the component of     tq  that lies along the  direction of    that lies along the direction of   1q  and  b  the component of      tq  2q .    Chapter 4 Summary   89                  Figure 4.9 b  shows the  same procedure used to find the length  given by      b t , which is       b t  =  sin sin  θt θ  .    4.66       tq    as    4.67     4.68      We  can  now  define  the  spherical  linear  interpolation  function  follows.   sin      t  q  =     t    − θ 1 θ sin  +  q  1  sin sin  θt θ  q   2  θ  =  −  1  cos       ⋅q q ,  1  2  The angle θ is given by   and thus, sinθ can be replaced by   θ =  −     ⋅q q 1    2  sin     4.69   if desired. Since the quaternions q and −q represent the same rotation, the signs  ⋅ q q 0 .  This  also  of  the  quaternions  1 ensures that the interpolation takes place over the shortest path.   2q   are  usually  chosen  such  that   1q   and   ≥  1     2  2  Chapter 4 Summary   Orthogonal Matrices  − =M M . A ma- An invertible n n×  matrix M is called orthogonal if and only if  trix whose columns form an orthonormal set of vectors is orthogonal. Orthogonal  matrices  preserve  lengths  and  angles,  and  thus  perform  only  rotations  and  reflections.   T  1  Scaling Transforms  A  scaling  operation  in  three  dimensions  is  performed  using  the  transformation  matrix   a 0 0 b 0 0 0      0 .  c                    90   4. Transforms   = = , then this matrix represents a uniform scale, which can also be per-  If a b c formed using scalar multiplication.   Rotation Transforms   Rotations through an angle θ about the x, y, and z axes are performed using the  following transformation matrices.   R  x     θ     =  R  y     θ     =  R  z     θ     =  1 0   0 cos  0 sin   θ cos   0  − sin  θ cos   θ sin  0    θ  θ θ  0 − θ sin θ cos θ 0 sin 1 0 0 cos − θ sin θ cos 0  θ 0 0 1                    A rotation through an angle θ about an arbitrary axis A is performed using the  transformation matrix   AR     θ     =  c − −    + − 1   c A A   c A A    c A + −  x  y  x  z  2 x sA sA  z  y          1   1    1    1  − c −    c A A x   + − 1   c A A  − y   c A +  y  z  sA 2 y sA  z  x    1   1  − − c  x    c A A z   c A A y   + − 1  + − z   c A  y  x  sA sA 2 z  ,         c where   =  cos  θ  s  and   =  sin  θ  .   Homogeneous Coordinates  A  vector  P  representing  a  three-dimensional  point  is  extended  to  four- dimensional homogeneous coordinates by setting the w coordinate to 1. A vector  D representing a three-dimensional direction is extended to homogeneous coor- dinates by setting the w coordinate to 0.   A 3 3×  transformation matrix M and a 3D translation vector T can be combined  using the 4 4×  transformation matrix    Exercises for Chapter 4   91                  =  F  21  11  M M M 31 0         22  12  M M M 32 0  23  13  M M M 33 0  y  x  T T T z 1         .   Normal  vectors  must  be  transformed  using  the  inverse  transpose  of  the  matrix  used to transform points.   Quaternions  The unit quaternion corresponding to a rotation through an angle θ about the unit  axis A is given by   =  q  cos  +  A  sin  θ 2  θ 2  .   A  quaternion  q  applies  a rotation  transformation  to a  point  P  using  the homo- morphism  the  quaternion  =q  ′ =P  is equivalent to the transformation performed by the 3 3×  matrix   transformation  performed  by   qPq .  The   w x y z , ,  1−  ,  qR  =  2  − y 1 2 2   + xy 2  −  xz 2   − z 2 wz 2 wy 2  − xy 2 − x 1 2 2 + yz 2  2 − 2  wz z 2 wx  2  xz 2 yz 2 − x 1 2  + − 2  2 2 −  wy wx y 2  2  .         Spherical Linear Interpolation  Two quaternions  1q  and   2q  are spherically interpolated using the formula   sin      t  q  =     t    − θ 1 θ sin  +  q  1  sin sin  θt θ  q ,  2  where 0  1t≤ ≤ .   Exercises for Chapter 4   1.  Calculate  the 3 3×   rotation  matrices  that  perform  a  rotation  of  30  degrees   about the x, y, and z axes.   2.  Exhibit a unit quaternion that performs a rotation of 60 degrees about the   axis  0,3,4 .    92      3.  Prove Equation  4.35 .   4. Transforms   4.  Let N be the normal vector to a surface at a point P, and let S and T be tan- S T N. Given an invertible 3 3×  ma- gent vectors at the point P such that  × =    trix M, show that   M M S T , supporting the fact  that normals are correctly transformed by the inverse transpose of the matrix  M. [Hint. Use Equation  2.25  to write the cross product    ×MS MT  as   MS MT       det  − 1 T  ×  ×  =                                   MS MT  ×           =  0       MS z      − MS   y  −     MS 0 MS           z  x    −     y    MS   MS MT .  0        x  Then find a matrix G such that   G  0 S z − S        y  z  − S 0 S  x  S y − S 0  x        =  0     MS z     − MS        y  and finally use Equation  3.65  to show that   −     z     MS 0 MS x =G           det    −     x  ,   y    MS   MS M 0           1 T − M M .]    Chapter 5   Geometry for 3D Engines   This  chapter  develops  the  mathematics  that  describe  lines  and  planes  in  three- dimensional space, and it discusses topics such as finding the intersection of two  such entities and calculating the distance between them. We then introduce the  view frustum and examine some of the important mathematics governing the vir- tual camera through which we see our game universe.   5.1  Lines in 3D Space   Given two 3D points  1P  and  points parametrically as   2P , we can define the line that passes through these       t    = − 1  P    1 P  t  +  t  P ,  2   5.1     5.2    where the parameter t ranges over all real numbers. The line segment connecting  1P  and  2P  corresponds to values of t between 0 and 1.    A ray is a line having a single endpoint S and extending to infinity in a given  direction V. Rays are typically expressed by the parametric equation      t  P  = +  S V,   t  where t is allowed to be greater than or equal to zero. This equation is often used  to represent lines as well. Note that this equation is equivalent to Equation  5.1  if  we let   1=S P  and   V P 2  P .  1  =  −  5.1.1  Distance Between a Point and a Line  The distance d from a point Q to a line defined by the endpoint S and the direc- tion V can be found by calculating the magnitude of the component of  −Q S that  is perpendicular to the line, as shown in Figure 5.1. Using the Pythagorean theo-              93    94   5. Geometry for 3D Engines               −Q S  Q  d  S  proj    V Q S −     V     Figure 5.1. The distance d from a point Q to the line  length of the perpendicular component of  −Q S with respect to the line.   t+S V is found by calculating the   rem, the squared distance between the point Q and the line can be obtained by  subtracting the square of the projection of  −Q S onto the direction V from the  square of  −Q S. This gives us    =  −  −           [  ]  2  2  2  d  Q S  =     −  Q S     2  −  − Q S proj V     ⋅ − Q S V V  2      2 V .       Simplifying  a  bit  and  taking  the  square  root  gives  us  the  distance  d  that  we  desire:   =  d     −  Q S     2     [ ⋅ − Q S V  ] 2    2  − V  .   5.1.2  Distance Between Two Lines  In two dimensions, two lines are either parallel or they intersect at a single point.  In three dimensions, there are more possibilities. Two lines that are not parallel  and do not intersect are called skew. A formula giving the minimum distance be- tween points on skew lines can be found by using a little calculus.    ametric functions   Suppose that we have two lines, as shown in Figure 5.2, defined by the par-   5.3     5.4     5.5    P 1 P 2    t t    1  2       = =  S S  1  2  + +  t 1 t  V 1 V ,  2  2   5.1  Lines in 3D Space   95               P 1     t  1     −  P 2     t  2       1tP  1       2tP  2       1tP Figure 5.2. The distance between skew lines  1     P t the parameters  1t  and  2t  minimizing  2 2  P 1  −        t  1     and  .     2tP 2         is calculated by finding   where  1t  and  2t  range over all real numbers. Then the squared distance between a   can be written as the fol- point on the line  lowing function of the parameters  1t  and  2t .        and a point on the line     2tP 2    1tP 1    2  =  −                 P 1  t  1  P  2  t  2     f  t  1  ,  t  2     Expanding the square and substituting the definitions of the functions    2tP 2   gives us       5.6      and     1tP 1     f  t  1  ,  t  2     ⋅  P 2     t  2     = =  P 1   S     1  =  S  2 1     2  2      + P t t 1 2   + + V t 2 1 1   − ⋅ S S 2 1 2 + + t V t 2 2 2 1 1   − ⋅ S S 2 1    2   S 2 + t 1 S V 1 1 1 + t  − P 2 1 + V t 2 ⋅ V S 1 ⋅ + ⋅ V S  1  2  1  2  2 S  2    t 1   2 + 2 2 +  ⋅ V S t 2 2 1 + + t V 2 2 2 2 ⋅ V S t  2  1  2     2  + ⋅ t t 1 2 1 S V t 2 2 ⋅ + t t 1 2  V V ⋅ 2   V V .   2  2  1  The  minimum  value  attained  by  the  function  f  can  be  found  by  setting  partial  derivatives  with  respect  to  1t   and  2t   equal  to  zero.  This  provides  us  with  the  equations   and   ∂ = f ∂ t  1  ∂ = f ∂ t  2  t V 2 2 1 1  +  S V 2 1 1  ⋅  −  2  ⋅  V S  1  2  −  t 2  ⋅  V V  1  2  2  =  0     t V 2 2  2 2  +  S V 2  2  2  ⋅  −  2  V S  2  ⋅  1  −  t 2  1  ⋅  V V  1  2  =  0 .    5.7     5.8     5.9     96   5. Geometry for 3D Engines            After removing a factor of two, we can write these equations in matrix form as  follows.   V 2 1 ⋅  V V  1  2      −  ⋅ V V 1 − V 2 2  2  t t         1  2    =           S S  2  2  − −       S V 1 1 S V 1  ⋅ ⋅  2          5.10    Solving this equation for  1t  and  2t  gives us   t t      1  2      V 2 1 ⋅  V V  1  2      −  ⋅ V V 1 − V 2 2  2  1   2     ⋅  V V  1  2  −  V V 2 1  2 2  −  − 1         − −  2    S     S  2 − V 2 2 ⋅ V V  1  2  ⋅ ⋅    S V  1 1    S V  1 2 ⋅ V V 1 V 2 1  2  =  =    S   S  2  2         − −       S V 1 1 S V 1  ⋅ ⋅  2  .        5.11    Plugging these values of  1t  and  2t  back into the function f gives us the minimum  squared distance between the two lines. Taking a square root gives us the actual  2V  have unit length, then  distance that we want. If the direction vectors  V =  and  Equation  5.11  simplifies a bit since  2 1 2V V  is zero, then the lines are parallel, in which    2 2 1 case the distance between the two lines is equal to the distance between any point  on one of the lines and the other line. This is illustrated in Figure 5.3. In particu- 1S  to the  lar, we can use Equation  5.3  to measure the distance from the point  line    or the distance from the point   If the quantity    1V  and  V = .  1 2 2  2S  to the line     2tP 2    1tP 1  V V    .     2  −  1     ⋅  1  2  1S    1tP  1       2tP  2        Figure 5.3. The distance between parallel lines is given by the distance from a point on  one line to the other line.    5.2  Planes in 3D Space   97   5.2  Planes in 3D Space         Given a 3D point P and a normal vector N, the plane passing through the point P  and perpendicular to the direction N can be defined as the set of points Q such  that  . As shown in Figure 5.4, this is the set of points whose differ- ence with P is perpendicular to the normal direction N. The equation for a plane  is commonly written as   N Q P    0 =  −     ⋅  Ax By Cz D  +  +  +  = ,  0   5.12    where A, B, and C are the x, y, and z components of the normal vector N, and  D = − ⋅N P. As shown in Figure 5.5, the value  D N  is the distance by which  the plane is offset from a parallel plane that passes through the origin.    the equation   The normal vector N is often normalized to unit length because in that case   =  ⋅  +        d  D  N Q   5.13   d = , then the  gives the signed distance from the plane to an arbitrary point Q. If  d > , we say that the point Q lies on the positive side  point Q lies in the plane. If  of  the  plane  since  Q  would  be  on  the  side  in  which  the  normal  vector  points.  d < , we say that the point Q lies on the negative side of the plane.  Otherwise, if  It  is  convenient  to  represent  a  plane  using  a  four-dimensional  vector.  The    , DN  is used to denote the plane consisting of points Q satis- shorthand notation  .  If  we  treat  our  three-dimensional  points  instead  as  four-  fying  0D  N Q  =  +  0  0  0  ⋅  N  P  Q     Figure 5.4. A plane is defined by the set of points Q whose difference with a point P,  known to lie in the plane, is perpendicular to the normal direction N.    98   5. Geometry for 3D Engines         N  D N  O  Figure 5.5. The value of D in Equation  5.12  is proportional to the perpendicular dis- tance from the origin to the plane.      dimensional  homogeneous  points  having  a  w  coordinate  of  1,  then  Equation   5.13  can be rewritten as d = ⋅L Q, where  . A point Q lies in the plane  if   L Q .  0  =L N  , D  =  ⋅  5.2.1  Intersection of a Line and a Plane  Finding the point where a line intersects a plane is a common calculation per- formed by 3D engines. In particular, it is used extensively during polygon clip- ping, which is discussed in detail in Sections 8.4.1 and 9.2.2.  S V represent a line containing the point S and running parallel    to the direction V. For a plane defined by the normal direction N and the signed  distance D from the origin, we can find the  point where the line intersects the  plane by solving the equation   = +  Let      t  P  t  ⋅  N P      t D  +  =  0      5.14     5.2  Planes in 3D Space   99                  for t. Substituting   t+S V for      tP   gives us     ⋅ +  N S N V     ⋅  + t D  =  0 ,   and after solving this for t, we arrive at     −  =  t  ⋅ + N S ⋅ N V   D  .   ⋅  =  N V  S V  produces  the  Plugging  this  value  of  t  back  into  the  line  equation  0 , then the line is parallel to the plane  the plane  point of intersection. If  normal N is perpendicular to the line direction V . In this case, the line lies in the  plane itself if    We may also express the value of t given in Equation  5.16  in terms of the  four-dimensional representation of a plane. Given a plane   ; otherwise, there is no intersection.   , we have   =L N  0D  N S  ⋅ +  , D  P  =  t     t  = +  Since S is a point, its w coordinate is 1. However, since V is a direction vector,  its extension to homogeneous coordinates requires that we assign it a w coordi- nate of 0  as discussed in Section 4.4.2 . This confirms that Equation  5.17  is  equivalent to Equation  5.16 .   5.2.2  Intersection of Three Planes  Regions of space are often defined by a list of planes that form the boundary of a  convex polyhedron. The edges and vertices belonging to this polyhedron can be  found by performing a series of calculations that determine the points at which  sets of three planes intersect.  N  be three arbitrary planes.    We  can  find  a  point  Q  that  lies  in  all  three  planes  by  solving  the  following  system.   =L ,   =L 3  , and   =L 1  Let   , D 1  , D  , D  N  N  1  3  2  3  2  2  = −  t  ⋅ ⋅  L S L V  .   1  L Q 0 L Q 0 L Q   0  = = =  ⋅ ⋅ ⋅  2  3   5.15     5.16     5.17     5.18    This can be written in matrix form as    100   5. Geometry for 3D Engines            MQ  −  = −  −   D 1 D D  2  3        ,   =  Q M  − 1  −  −  −   D 1 D D  2  3           where the matrix M is given by         N M N N  =                  1  2  3  x  x  x         N N N  1  2  3         y  y  y         N N N  1  2  3         .         z  z  z  Assuming that the matrix M is invertible, solving for the point Q as follows pro- duces the unique point where the three planes intersect.   0=M  , then the three planes do not intersect at a point.  If M is singular  i.e., det This happens when the three normal vectors all lie in the same plane, an example  of which is shown in Figure 5.6.    5.19     5.20     5.21    Figure 5.6. Three planes do not necessarily intersect at a point.       5.2  Planes in 3D Space   101         1N  2N  V  O  V N N  =  ×  1  2     Figure 5.7. Two planes having normal vectors  2N  intersect at a line running in the  direction V. A point on this line can be found by finding the intersection point with a  third plane passing through the origin and having normal V.   1N  and   =L 1  =L  1  2  2  2  1  =  ×  N  N  , D  , D 1   and     When two nonparallel planes   intersect, they  do so at a line. As shown in Figure 5.7, the direction V in which the line of inter- section runs is perpendicular to the normals of both planes and can thus be ex- V N N . To form a complete description of a line, we also need to  pressed by  provide a point that lies on the line. This can be accomplished by constructing a  V  that passes through the origin and whose normal direction  third plane  is V. We can then solve for the point where all three planes intersect, which is  guaranteed to exist in this situation.    Using Equation  5.21 , we can compute a point Q that lies on the line of in- tersection as follows.   =L  ,0  2  3  =  Q            1  N N 2 V  x        x  x                      z  y  y  1  1  N N 2 V  N N 2 V  − − 1 D  1  − D  0         2L  intersect is given by  P           2  y  z  z   5.22    The line where the two planes   1L  and      t  =  +  Q V.   t  5.2.3  Transforming Planes  Suppose that we wish to transform a plane using a 3 3×  matrix M and a 3D trans- lation vector T. We know that we can transform the normal direction N using the  inverse transpose of M, but we also have the signed distance from the origin D to  worry about. If we know that a point P lies in the original plane, then we can cal-   102   5. Geometry for 3D Engines            culate the signed distance D′ from the transformed plane to the origin using the  equation   D          − 1 T  − 1 T      ′ = − + M N MP T         = − − M N MP M N T = − N M MP N M T T − ⋅ = D      ⋅   − − N M T . 1  1 T        − 1  − 1  T  T  T  −      5.23   Recall from Equation  4.27  that the inverse of the 4 4×  matrix F constructed     from the 3 3×  matrix M and the 3D translation vector T is given by      We therefore have for the transpose of   1−F    − 1  F  =         − 1  M  −  − 1  M T  0  1     F  − 1 T     =            M  −   1 T  −  − 1  M T  .          .          0  1   5.24     5.25    ,  D   1 T  N N N  − 1  and the 4D vector   − ⋅N M T is exactly the dot product between the fourth row of  The quantity    −F . This shows that we may treat planes as  four-dimensional vectors that transform in the same manner as three-dimensional  normal  vectors,  except  that  we  use  the  inverse  transpose  of  the  4 4×   transfor-  transforms using the 4 4×  matrix F as  mation matrix. Thus, the plane   1 T  5.26    =L N ′ =L  , D    z D ,  L.   F     ,  −  x  y  5.3  The View Frustum   Figure  5.8  shows  the  view  frustum,  the  volume  of  space  containing  everything  that is visible in a three-dimensional scene. The view frustum is shaped like a  pyramid whose apex lies at the camera position. It has this shape because it rep- resents the exact volume that would be visible to a camera that is looking through    5.3  The View Frustum      103   C  n  f     Figure 5.8. The view frustum encloses the space bounded by the near plane lying at a  distance n from the camera, the far plane lying at a distance f from the camera, and four  side planes that pass through the camera position C.   a rectangular window—the computer screen. The view frustum is bounded by six  planes, four of which correspond to the edges of the screen and are called the left,  right, bottom, and top frustum planes. The remaining two planes are called the  near and far frustum planes, and define the minimum and maximum distances at  which objects in a scene are visible to the camera.  The view frustum is aligned to camera space. Camera space, also called eye    space, is the coordinate system in which the camera lies at the origin, the x axis  points to the right, and the y axis points upward. The direction in which the z axis  points  depends  on  the  3D  graphics  library  being  used.  Within  the  OpenGL  li- brary, the z axis points in the direction opposite that in which the camera points.  This forms a right-handed coordinate system and is shown in Figure 5.9.  Under  Direct3D, the z axis points in the same direction that the camera points and forms  a left-handed coordinate system.    5.3.1  Field of View  The projection plane, shown in Figure 5.10, is a plane that is perpendicular to the  camera’s viewing direction and lies at the distance e from the camera where the  1x = . The distance e, which  left and right frustum planes intersect it at  is  sometimes  called  the  focal  length  of  the  camera,  depends  on  the  angle α   x = −  and   1   104      5. Geometry for 3D Engines   y  O  z  x     Figure 5.9. Camera space in OpenGL.   x = − 1  1x =  e  α 2  α 2  z  x     Figure 5.10. The distance e from the camera to the projection plane depends on the hori- zontal field of view angle α.    5.3  The View Frustum   105            formed between the left and right frustum plane. The angle α is called the hori- zontal field of view angle.    is given by the trigonometric relation   For a desired horizontal field of view α, the distance e to the projection plane   =  e  1   α  .      2  tan   5.27    Larger  fields  of  view  are  equivalent to  shorter  focal  lengths.  A  camera  can  be  made to “zoom in” by diminishing the field of view angle, thus causing a longer  focal length.  The aspect ratio of a display screen is equal to its height divided by its width.    For example, a 640 480  pixel display has an aspect ratio of 0.75. Since  most  displays are not square, but rectangular, the vertical field of view is not equal to  the horizontal field of view. The bottom and top frustum planes intersect the pro- a= ± , where a is the aspect ratio of the display. This forms the  jection plane at y triangle shown in Figure 5.11, and thus the vertical field of view angle β is given  by   ×  =  β  2tan  − 1     a e     .    5.28      tion plane at a distance e from the camera whose edges lie at   The four side planes of the view frustum carve a rectangle out of the projec- a= ± .   x = ±  and y  1  y  y  a=  z  e  β 2 β 2  Figure 5.11. The vertical field of view angle β depends on the aspect ratio a.   y  a= −      106      5. Geometry for 3D Engines   L  e  f t    P  l a  n  e  Far Plane  0,0,1  Right Plane  e − ,0, 1  e−  − ,0, 1  Near Plane  x  0,0, 1−  O  z  Figure 5.12. View frustum plane normal directions in OpenGL camera space.      The OpenGL function glFrustum   requires that we specify a rectangle at the  distance n from the camera, where n is the near plane distance. Scaling our rec- tangle  by  a  factor  of n e,  we  place  the  left  edge  at  x ,  the  right  edge at  an e x n e .   = − , and the top edge at y  , the bottom edge at y  n e =  an e  = −  =  5.3.2  Frustum Planes  The camera-space normal directions for the six view frustum planes are shown in  Figure 5.12. The inward-pointing normal directions for the four side planes are  found by rotating the directions along which the sides point 90 degrees toward  the center of the frustum. The four side planes each pass through the origin, so  0D = . The near plane lies at a distance n from the origin in the  they each have  n= − . The far plane lies at a  same direction in which its normal points, so it has D   5.4  Perspective-Correct Interpolation      107   distance f from the origin in the opposite direction in which its normal points, so  it has D f= . The four-dimensional plane vectors corresponding to the six sides  of the view frustum are summarized in Table 5.1. In this table, the normal direc- tions for the four side planes have been normalized to unit length.       Plane  Near  Far   Left   Right   Bottom   Top   , DN − − 0,0, 1, n 0,0,1, f  e 2  e  1  + e 2  e  +  1  −  ,0,  −  ,0,  1 2  e  1  + 1 2  e  +  1  ,0     ,0     2  e  2  a  2  e  2  a  e + e +  2  −  ,  −  ,  a + a +  2  e  2  a  e  2  a  ,0     ,0     −  0,  −  0,  Table 5.1. View frustum plane vectors in OpenGL camera space in terms of the focal  length e, the aspect ratio a, the near plane distance n, and the far plane distance f.   5.4  Perspective-Correct Interpolation   When a 3D graphics processor renders a triangle on the screen, it rasterizes it one  scanline at a time. The vertices of a triangle, in addition to their positions in cam- era space, carry information such as lighting colors and texture mapping coordi- nates, which must be interpolated across the face of the triangle. When a single  scanline of a triangle is drawn, the information at each pixel is an interpolated  value derived from the values known at the left and right endpoints.    As shown in Figure 5.13, correct interpolation across the face of a triangle is  not linear since equally spaced steps taken on the projection plane correspond to  larger steps taken on the face of a triangle as the distance from the camera in- creases.  Graphics  processors  must  use  a  nonlinear  method  of  interpolation  for  texture-mapping  coordinates  to  avoid  distortion  of  the  texture  map.  Although  modern hardware now interpolates other types of information associated with a    108      5. Geometry for 3D Engines   Figure  5.13.  Equally  spaced  steps  taken  on  the  projection  plane  correspond  to  larger  steps taken on the face of a triangle as the distance from the camera increases. Thus, cor- rect interpolation across the face of a triangle is not linear.      vertex, such as lighting colors, older graphics cards simply use linear interpola- tion since the difference is not as noticeable as it is with texture maps.   5.4.1  Depth Interpolation  It is important to note that the z coordinates  representing the depth  of points on  the face of a triangle are interpolated linearly by 3D graphics hardware, contrary  to  the  perspective-correct  method  presented  in  this  section.  An  explanation  for  this follows in Section 5.5.1, which discusses the perspective projection matrix.  Figure 5.14 shows a line segment lying in the x-z plane that corresponds to a    single scanline of a triangle. During rasterization, points on this line segment are  sampled by casting rays through equally spaced points on the projection plane,  which represent pixels on the display screen. Assuming that the segment does not  belong to a line that passes through the origin  in which case the triangle would  be viewed edge-on and would thus not be visible , we can describe the line with  the equation   +  ax bz  = ,  c   5.29       where   c ≠ .  0   5.4  Perspective-Correct Interpolation   109               1,x z  1  1,p  e−  e  O  z  ,x z  2  2  2,p  e−  x     Figure 5.14. The line segment corresponding to a single scanline of a triangle is sampled  by casting rays through equally spaced points on the projection plane.   ,x z  that lies on the line, we can cast a ray from the origin  the    Given a point  ,x z  and determine where it intersects the projec- camera position  to the point  tion plane. The z coordinate at the projection plane is always equal to  e− . We can  find the x coordinate p on the projection plane corresponding to the point  ,x z  by  using  the  following  relationship  derived  from  the  similar  triangles  shown  in  Figure 5.14.   Solving this for x and it plugging back into Equation  5.29  lets us rewrite our  line equation as follows.   It is convenient for us to manipulate this equation further by writing it in such a  way that 1 z appears on one side:   p x  −= e z     −      +  ap b z   e   =  c     1 z  = −  ap ce  b + .  c   5.30     5.31     5.32     110   5. Geometry for 3D Engines               Let us call the endpoints of the line segment     images on the projection plane  some t satisfying 0 jection plane. We would like to find the z coordinate of the point  the ray cast through the point  p 3  , and their  , for  1 2 1t≤ ≤ , be the x coordinate of an interpolated point on the pro- ,x z  where  3 e−  intersects the face of the triangle. Plugging    and  3z  into Equation  5.32  gives us  2  ,x z 2 2     = − t p 1  1,x z  and  1  e− . Let   e−  and     = − 1    t p  2,p  3,p  1,p  tp  tp  +  +  p  3  3  1  1 z  3  = −  = −  b c   − −  t  +    1  ap 3 ce ap 1 ce b ap 1 c ce   − +  +    1  t    1     1 z  2  t  .  = −     1 z  1  =  t  +  b ap 2 ce c − + − t         ap 2 ce  +  b c  t          5.33    This result demonstrates that the reciprocal of the z coordinate is correctly inter- polated in a linear manner across the face of a triangle.   5.4.2  Vertex Attribute Interpolation  Vertices carry information such as lighting colors and texture mapping coordi- nates that from here on are collectively referred to as vertex attributes. Each ver- tex attribute must be interpolated across the face of a triangle when it is raster- ized. Suppose that the endpoints of a scanline have depth values of  1z  and  2z , and  possess scalar attributes  1b  and  2b , respectively. We would expect the interpolated  attribute value  3b  to form the same proportion with the total difference along the  line segment as does the interpolated depth value  3z . That is, the equation   should be satisfied. Substituting the value   b b  3  2  − −  b 1 b 1  =  z z  3  2  1  − z −   z  1  =  z  3  1   − + t     t  1 z  2    1  1 z  1  given by Equation  5.33  and solving for  3b  gives us    5.34     5.35                 5.5  Projections   Multiplying the numerator and denominator by  tor of  3z  from the right-hand side of the equation as follows.   1 2  1 z z  allows us to extract a fac-  =  b  3  b z 1 2 z  2    1   1    − + t   − + t  b z t 2 1 z t 1  .   =  b  3  b 1 z 1 1 z  1    1    − +  t    1    − +  t  t  t  2  b z 2 1 z 2   − +  t  =  z  3    1  b 1 z  1      b z  2  2  t         111    5.36     5.37    This demonstrates that the value b z can be linearly interpolated across the face  of a triangle. Graphics processors first calculate the linearly interpolated value of  1 z when rasterizing a scanline. The reciprocal is then calculated and multiplied  by the linearly interpolated value of b z to obtain the perspective-correct interpo- lated value of any vertex attribute b.   5.5  Projections   To  render  a  three-dimensional  scene  on  a  two-dimensional  display  screen,  we  need to determine where on the screen each vertex in the scene should be drawn.  As we have already seen, we can determine where a vertex located at a position P  falls  on  the  projection  plane  by  calculating  where  the  ray  cast  from  the  origin  toward the point P intersects it. The x and y coordinates of the projected point are  given by the formulas   = −  x  P x    and    y  = −  P y  .   e P z  e P z   5.38    zP  is negative since the camera points in the nega-   Remember that the value of  tive z direction.     Applying the above formula to the z coordinate would always result in a pro- jected depth of  e− . Useful depth information is needed, however, to perform hid- den surface removal, so 3D graphics systems instead use homogeneous coordi- nates to project vertices in four-dimensional space.    112   5. Geometry for 3D Engines         5.5.1  Perspective Projections  A perspective projection that maps x and y coordinates to the correct place on the  projection plane while maintaining depth information is achieved by mapping the  view frustum to a cube, as shown in Figure 5.15. This cube is the projection into  3D space of what is called homogeneous clip space. It is centered at the origin in  OpenGL and extends from negative one to positive one on each of the x, y, and z  axes. The mapping to homogenous clip space is performed by first using a 4 4×   projection matrix that, among other actions, places the negative z coordinate of a  camera-space point into the w coordinate of the transformed point. Subsequent  division by the w coordinate produces a three-dimensional point having normal- ized device coordinates.   be a homogeneous point in camera space that lies inside    ,1 the view frustum. The OpenGL function glFrustum   takes as parameters the  t=   left edge x of the rectangle carved out of the near plane by the four side planes of the view  n= − , so we can calculate the projected x and y  frustum. The near plane lies at z coordinates of the point P on the near plane using the equations   b= , and the top edge y  r= , the bottom edge y  l= , the right edge x  P P P x z  Let   =P  ,  ,  y  Any point in lying in the view frustum satisfies l plane.  We  want  to  map  these  ranges  to  the [  ]1,1−  = −  x  P x    and    y  = −  n P z  .   P y  n P z ≤ ≤  on the near  ≤ ≤  and b x  range  needed  to  fit  the  view    5.39    y  r  t  Figure 5.15. The perspective projection maps the view frustum to the cube representing  homogeneous clip space.       5.5  Projections   113   frustum into homogeneous clip space. This can be accomplished using the simple  linear functions   and   and                        ′ =  x     x  −  l    2 − r  l  −    1  ′ =  y     − y b    2 − t b  −  .  1  ′ =  x  n 2 − r l      −  P x P z      −  r r  + −  l l     ′ =  y  n 2 − t b      −  P y P z      −  + t b − t b  .   Substituting the values of x and y given in Equation  5.39  and simplifying yields   f  P z  − ≤  ]1,1−    Mapping  the  projected  z  coordinate  to  the  range [   involves  somewhat  more complex computation. Since the point P lies inside the view frustum, its z  ≤ − , where n and f are the distances from the  coordinate must satisfy  camera to the near and far planes, respectively. We wish to find a function that  f− → .  Note that such a mapping reflects the z axis; there- maps  fore, homogeneous clip space is left-handed.  Since z coordinates must have their  reciprocals interpolated during rasterization, we construct this mapping function  so that it is a function of 1 z, consequently allowing projected depth values to be  interpolated linearly. Our mapping function thus has the form   n− → −  and   1  n  1  ′ =  z  + .  B  A z  We  can  solve  for  the  unknowns  A  and  B  by  plugging  in  the  known  mappings  n− → −  and   f− →  to get   1  1  − = 1  +  B    and  1  =  +  B  .   A − n  A − f  A little algebra yields the following values for A and B:    5.40     5.41     5.42     5.43     5.44     5.45                       and   114   5. Geometry for 3D Engines      =  B  A  2nf −   and   f n The z coordinate is thus mapped to the range [ 1 P z  ′ = −  nf −  2 f  −          n  z     =  + n − .  n  f f ]1,1−  by the function  + f − f  n n  +  .     point   Equations  5.42 ,  5.43 , and  5.47  each contain a division by  =P ′   is equivalent to the 4D homogeneous point   ′ ′ x y z , ,  ′   5.46     5.47    zP− . The 3D   ′  P  = −  ′ x P z  ,  −  ′ y P z  ,  −  ′ z P z  ,  −  P z    zx P′−  zy P′− ,   , and   zz P′−   giv-  after division by the w coordinate. Since the values of  en by the equations    5.48     5.49     5.50     5.51     5.52    ′− x P z  =  ′− y P z  =  l  n 2 − r n 2 − t b  +  P x  +  P y  + r l − r l + t b − t b  P z  ,   P z  ,   ′− z P z  = −  f f  + −  n n  −  P z  2 f  nf −   n  are linear functions of the coordinates of the point P, we can use a 4 4×  matrix  frustumM  to calculate the point   ′P  as follows.   ′ = P M  =  P  frustum  n 2 − t b  0  0  0  + l r − r l + t b − t b + f − f − 1  −  n 2 − l r  0  0  0               0  0  0  P x P y P z 1                               n n  −  nf −  2 f  n   5.5  Projections      115   The matrix   frustumM  in Equation  5.52  is the OpenGL perspective projection    matrix generated by the glFrustum   function. Camera-space points are trans- formed by this matrix into homogeneous clip space in such a way that the w co- ordinate holds the negation of the original camera-space z coordinate. When in- terpolating  vertex  attributes   see  Section  5.4.2 ,  it  is  actually  this w  coordinate  whose reciprocal is interpolated, serving as the value of z in Equation  5.37 .  Figure  5.16  illustrates  how  the  depth  in  the  z  coordinate  is  mapped  from    camera space to normalized device coordinates  NDC  by the standard projection  matrix given by Equation  5.52  and the division by the projected w coordinate.  The z coordinates inside the view frustum  i.e., points between the near and far  planes  in camera space are mapped to the range [  in NDC. Interestingly, the  infinite  range  of  z  coordinates  beyond  the  far  plane  in  camera  space  is  com- pressed into the finite range    in NDC, and the finite range of z coordinates  closer to the camera than the near plane in camera space is expanded to the infi- nite  range   −∞ −   in  NDC.  All  of  the  points  behind  the  camera  actually  get  moved, counterintuitively, to the range    − ∞  in front of the camera in NDC.   ]1,1−  + 1, f n − f n    , 1        ,  + f n f n  f−  0  z+  −  2fn f n + n−  Camera Space  Beyond Far Plane  View Frustum  Behind Camera  Normalized  Device Coordinates  Behind Camera  Beyond Far Plane  View Frustum  Closer Than Near Plane  ∞  z+  f f  + −  n n  1  0  1−  −∞     Figure 5.16. This diagram illustrates how z coordinates are mapped from camera space to  normalized device coordinates by the standard perspective projection matrix.    116   5. Geometry for 3D Engines           It is possible to construct a view frustum that is not bounded in depth by al- lowing the far plane distance f to tend to infinity. The resulting projection matrix  infiniteM  is given by   M  infinite  =  M  lim →∞ f  frustum  =   5.53    n 2 − l r  0  0 0            0  n 2 − t b 0 0  + r l − r l + t b − t b − 1 − 1  0  0 − 2 0  n            .   This is a perfectly valid projection matrix that allows objects to be rendered at  any depth greater than or equal to n. Furthermore, it allows vertices having a w  coordinate  of  0  to  be  rendered  correctly.  The  interpretation  of  a  camera-space   is that of a point that lies infinitely far from the camera  point  , in the direction   , y Q Q Q . Transforming Q with the matrix   Q Q Q , x  ,0 , y  =Q  x  z  z  n 2 − r l  0  0 0            0  n 2 − t b 0 0  + l r − r l + t b − t b − 1 − 1  n 2 − l r n 2 − t b  Q  x  Q  0  0 − 2 0  n            y  x  Q Q Q z 0                =            z  Q  infiniteM  gives us  + l r − r l + t b − t b z  Q  ,   z  +  +            y − −  Q Q  z   5.54       M Q  infinite  =  which  produces  a  projected  point  having  the  maximum  z  coordinate  of  1  after  division by its w coordinate. This ability to project points lying at infinity is re- quired by the shadow-rendering technique described in Chapter 10.   5.5.2  Orthographic Projections  An orthographic projection, also known as a parallel projection, is one in which  no perspective distortion occurs. As shown in Figure 5.17, camera-space points  are always mapped to the projection plane by casting rays that are parallel to the  camera’s viewing direction.    The  view  volume  for  an  orthographic  projection  is  defined  by  a  rectangle  lying in the x-y plane and near and far plane distances. Since there is no perspec- tive distortion, depth values for a triangle in an orthographic projection can be  interpolated linearly. Thus, our mapping to normalized device coordinates can be    5.5  Projections   117   x  l=  x  r= z  f= −              and   x  z  z  n= −    Figure  5.17.  In  an  orthographic  projection,  points  are  simply  moved  to  the  projection  plane along the camera’s viewing axis.   performed linearly on all three axes. The functions mapping the x and y coordi- nates from the ranges [   are given by   ],l r  and [  ]1,1−  ],b t  to the range [ + l −   l  2 −  ′ =  r r  −  x  x  r  l  ′ =  y  2 − t b  y  −  + t b − .  t b n− → −  and  1 ]1,1−  ]  − −  to the range [ ,f + n − .  n  − 2 −  ′ =  f f  −  n  z  z  f   5.55     5.56     5.57    In a similar manner, but negating z so that  z coordinate from the range [  n  f− → , we can map the   using the function   1  Writing these three functions in matrix form gives us    118   5. Geometry for 3D Engines         ′ = P M P  ortho  =   5.58    r  l  2 −  0  0  0               2 − t b  0  0  0  0  0  0  − 2 −  f  n  −  −  −  + l r   − l r + P t b  x  − P t b y  + f n P  z  − f n 1             1  .          The matrix   orthoM  in Equation  5.58  is the OpenGL orthographic projection    matrix  generated  by  the  glOrtho    function.  Note  that  the  w  coordinate  re- mains 1 after the transformation, and thus no perspective projection takes place.   5.5.3  Extracting Frustum Planes  It is remarkably simple to extract the four-dimensional vectors corresponding to  the six camera-space view frustum planes from an arbitrary projection matrix M.  The technique presented here derives from the fact that the planes are always the  same in clip space. They are actually rather trivial since, as shown in Figure 5.18,  each plane’s normal is parallel to one of the principal axes.   x = − 1  1x =  1z =  1,0,0  − 1,0,0  0,0, 1−  0,0,1  Figure 5.18. These are the normal vectors for the left, right, near, and far planes bound- ing the cube-shaped homogeneous clip space. The normal vectors for the top and bottom  planes point in and out of the page.   z = − 1      5.5  Projections      119   Let   ′L  be one of the six planes that bound clip space. The inverse of the ma-   trix  M  transforms  from  clip  space  into  camera  space.  Since  planes  are  trans- formed  by  the  inverse  transpose  of  a  matrix,  the  camera-space  plane  L  corre- ′L  is given by  sponding to the clip space plane    ′ =  ′ L M L .   L M   5.59     1  =  − 1     T  T  −        The clip-space plane vectors are listed in Table 5.2. Since each plane vector con- tains two nonzero entries, and these entries are all  1± , we can write each camera- space view frustum plane as a sum or difference of two columns of the matrix  TM , which is equivalent to the sum or difference of two rows of the matrix M.   Plane  Near  Far  Left  Right  Bottom  Top   , DN   0,0,1,1   0,0, 1,1− 1,0,0,1   − 1,0,0,1 0,1,0,1   − 0, 1,0,1           Table 5.2. Clip-space plane vectors.   near far left right bottom top  = = = = = =  3  4  4  4  3  M M M M M M M M M M 2 M M   2  + − + − + −  4  1  4  4  1  iM  to represent row i of the matrix M, we have the fol-   Using the notation  lowing formulas for the camera-space view frustum planes. These do not produce  plane vectors having unit normals, so they need to be rescaled.       5.60    These equations are valid for any projection matrix, with the exception of the far  plane  for  the  infinite  projection  matrix  given  by  Equation   5.53 .  It  should  be    120      5. Geometry for 3D Engines   noted, however, that if the focal length and aspect ratio are known for a particular  view frustum, then the formulas in Table 5.1 provide a significantly more effi- cient way of calculating normalized frustum planes.   5.6  Reflections and Oblique Clipping   Many scenes contain a reflective surface such as a mirror or a body of water for  which a reflection image needs to be rendered. The typical way in which reflec- tions are shown in a scene is to establish a separate image buffer called the re- flection buffer to hold the result of rendering the objects in the scene that are vis- ible in the reflection. The reflected scene is first rendered into the reflection buff- er, and then the main scene is rendered into the main image buffer. When the ge- ometry  representing  the  reflective  surface  is  rendered,  colors  from  the  corre- sponding pixels in the reflection buffer are read and used to contribute to the final  image.    The reflected scene is rendered through a virtual camera that is the reflection  of the main camera through the plane of the reflection, as shown in Figure 5.19.   Reflection plane  z  z  y  y  Figure 5.19. The upper view frustum represents the actual camera rendering a scene that  contains a reflection plane. The virtual camera used to render the reflection is represented  by the lower view frustum, and it is itself a reflection of the upper view frustum. The x  axis points out of the page for both view frustums, and consequently, the camera-space  coordinate system for the camera rendering the reflection is left-handed.       5.6  Reflections and Oblique Clipping      121   Since  this  virtual  camera  is  a  reflection,  the  coordinate  system  changes  from  right-handed to left-handed, and some steps need to be taken in order to account  for this. In OpenGL, it is convenient to call the glFrontFace   function to re- verse the winding order of front-facing triangles for culling purposes.    In the process of rendering from a virtual camera, it is possible that geometry  lies closer to the camera than the plane representing the reflective surface. This  typically happens when an object straddles the reflection plane and parts on the  opposite side of the plane are flipped backwards in the reflection. If such geome- try is rendered in the reflection, it can lead to unwanted artifacts in the final im- age, as shown in Figure 5.20.    The  simplest  solution  to  this  problem  is  to  enable  a  user-defined  clipping  plane  to  truncate  all  geometry  at  the  reflective  surface.  Unfortunately,  even  though  most  GPUs  support  generalized  user-defined  clipping  operations,  using  them requires that the vertex or fragment programs be modified—a task that may  not  be  convenient  since  it  necessitates  two  versions  of  each  program  be  kept  around to render a particular geometry. Furthermore, the necessary modifications  tend to be slightly different across various GPUs.   A  B  C    Figure 5.20. In this scene, a reflection is rendered about a plane coincident with the water surface.  In the left image, no clipping is performed at the reflection plane, and multiple artifacts appear. At  locations A and B, the portions of the posts that extend below the water surface are seen extending  upwards in the reflection. At location C, some polygons belonging to submerged terrain are visible  in  the  reflection.  As  shown  in  the  right  image,  clipping  at  the  reflection  plane  removes  these  unwanted artifacts.  Image from the C4 Engine, courtesy of Terathon Software LLC.     122   5. Geometry for 3D Engines           In  this  section,  we  describe  a  trick  that  exploits  the  view  frustum  clipping  planes  that  already  exist  for  every  rendered  scene.1  Normally,  every  geometric  primitive is clipped to the six sides of the view frustum by the graphics hardware.  Adding a seventh clipping plane that represents the reflective surface almost al- ways  results  in  a  redundancy  with  the  near  plane,  since  we  are  now  clipping  against a plane that slices through the view frustum further away from the cam- era. Instead, we look for a way to modify the projection matrix so that the con- ventional near plane is repositioned to coincide with the reflective surface, which  is generally oblique to the ordinary view frustum. Since we are still clipping only  against six planes, such a modification gives us our desired result at absolutely no  performance cost.   be the plane shown in Figure 5.21, having coordi-   nates specified in camera space, to which we would like to clip our geometry.  The camera should lie on the negative side of this clipping plane, so we can as- wC < . The plane C will replace the ordinary near plane of the view  sume that  frustum. As shown in Table 5.2, the camera-space near plane is given by the sum  of the last two rows of the projection matrix M, so we must somehow satisfy   C C C C  =C  Let   0  ,  ,  ,  w  x  y  z  =  C M M .  3  4  +   5.61    We cannot modify the fourth row of the projection matrix because perspective  projections use it to move the negation of the z coordinate into the w coordinate,   Far plane  C  Near plane  O     Figure 5.21. The near plane of the view frustum is replaced with the arbitrary plane C.                                                          1 For a more detailed analysis, see Eric Lengyel, “Oblique Depth Projection and View  Frustum Clipping”, Journal of Game Development, Vol. 1, No. 2  Mar 2005 , pp. 5–16.    5.6  Reflections and Oblique Clipping   123               and  this  is  necessary  for  perspective-correct  interpolation  of  vertex  attributes.  Thus, we are left with no choice but to replace the third row of the projection ma- trix with     After making the replacement shown in Equation  5.62 , the far plane F of  the view frustum becomes   M C M .  4  ′ = 3  −  − F M M −  ′ 3 4 M C.  2  = =  4   5.62     5.63    0  ,0,  =P  ⋅ =  F P  xC  or   ⋅ =C P  x y w ,   for which   This fact presents a significant problem for perspective projections because the  yC  is nonzero. This  near plane and far plane are no longer parallel if either  is extremely unintuitive and results in a view frustum having a very undesirable  shape. By observing that any point  0  implies that  , we can conclude that the intersection of the near and far  we also have  planes occurs in the x-y plane, as shown in Figure 5.22 a .    Since the maximum projected depth of a point is achieved at the far plane,  projected  depth  no  longer represents  the  distance  along the z  axis,  but  rather a  value corresponding to the position between the new near and far planes. This  has  a  severe  impact  on  depth-buffer  precision  along  different  directions  in  the  view frustum. Fortunately, we have a recourse for minimizing this effect, and it is  to make the angle between the near and far planes as small as possible. The plane  C possesses an implicit scale factor that we have not yet restricted in any way.  Changing the scale of C causes the orientation of the far plane F to change, so we  need to calculate the appropriate scale that minimizes the angle between C and F  without  clipping  any  part  of  the  original  view  frustum,  as  shown  in  Figure  5.22 b .    Let  ing the original projection matrix M . The corner  opposite the plane   ′ =C M C be the projection of the new near plane into clip space  us- ′Q  of the view frustum lying    1 T ′C  is given by      −  ′ =Q  sgn     C  ′ x     ,sgn     C  ′ y     ,1,1  .    5.64     For most perspective projections, it is safe to assume that the signs of  are the same as  Once  we  have  determined  the  components  of  counterpart  Q  by  computing   yC′  yC , so the projection of C into clip space can be avoided.   ′Q ,  we  obtain  its  camera-space  =Q M Q .  For  a  standard  view  frustum,  Q  coin-   xC′ and   xC  and   1−  ′   124   5. Geometry for 3D Engines          a    b   F  Q  C  uC  F  x  x     Figure 5.22.  a  The modified far plane F given by Equation  5.63  intersects the modi- fied near plane C in the x-y plane.  b  Scaling the near plane C by the value u given by  Equation  5.66  adjusts the far plane so that the angle between the near and far planes is  as small as possible without clipping any part of the original view frustum. The shaded  area represents the volume of space that is not clipped by the modified view frustum.   cides with the point furthest from the plane C where two side planes meet the far  plane.  F Q .  0   The only part of Equation  5.63  that we can modify is the scale of the plane C,  so we introduce a factor u as follows:   To force the far plane to contain the point Q, we must require that   ⋅ =  =  F M  2  4  −  u  C.    5.65     5.6  Reflections and Oblique Clipping   125   Solving the equation   ⋅ =  F Q  for u yields   0  Replacing C with uC in Equation  5.62  gives us   =  u  2  ⋅ M Q C Q  4 ⋅  .   M  ′ = 3  u  −  C M ,  4              and this produces the optimal far plane orientation shown in Figure 5.22 b . For  perspective  projection  matrices,  we  have  ,  so  Equation   5.67   simplifies to   0,0, 1,0  M  =  −  4  M  ′ = 3  zQ− 2 ⋅ C Q  +  C  0,0,1,0  .     Equation   5.68   is  implemented  in  Listing  5.1.  It  should  be  noted  that  this  technique for optimizing the far plane also works correctly in the case that M is  the  infinite  projection  matrix  given  by  Equation   5.53   by  forcing  the  new  far  plane to be parallel to one of the edges of the view frustum where two side planes  meet.  See Exercise 7.    Listing  5.1.  The  ModifyProjectionMatrix    function  modifies  the  standard  OpenGL  per- spective projection matrix so that the near plane of the view frustum is moved to coincide with a  given arbitrary plane specified by the clipPlane parameter.    5.66     5.67     5.68    if  x > 0.0F  return  1.0F ;  if  x < 0.0F  return  -1.0F ;  return  0.0F ;   inline float sgn float x   {        }    void ModifyProjectionMatrix const Vector4D& clipPlane   {                Grab the current projection matrix from OpenGL.  glGetFloatv GL_PROJECTION_MATRIX, matrix ;   matrix[16];  q;   float      Vector4D      126   5. Geometry for 3D Engines                                         }                  Calculate the clip-space corner point opposite the clipping plane     using Equation  5.64  and transform it into camera space by     multiplying it by the inverse of the projection matrix.  q.x =  sgn clipPlane.x  + matrix[8]    matrix[0];  q.y =  sgn clipPlane.y  + matrix[9]    matrix[5];  q.z = -1.0F;  q.w =  1.0F + matrix[10]    matrix[14];      Calculate the scaled plane vector using Equation  5.68      and replace the third row of the projection matrix.  Vector4D c = clipPlane *  2.0F   Dot clipPlane, q  ;  matrix[2] = c.x;  matrix[6] = c.y;  matrix[10] = c.z + 1.0F;  matrix[14] = c.w;      Load it back into OpenGL.  glMatrixMode GL_PROJECTION ;  glLoadMatrix matrix ;   Chapter 5 Summary   Lines  A line passing through the point  pressed as   0P  and running parallel to the direction V is ex-  The distance from a point Q to the line       t  P  t  V.   = + P 0    tP [   ⋅ − Q P V   is given by  ] 2  −  2    0 2  V  .   =  d     −  Q P 0     Planes  A plane having normal direction N and containing the point  0P  is expressed as   ⋅ +  N P  =  0D  ,    Chapter 5 Summary   127                  D = − ⋅N P  . This can also be expressed as  , DN  , where L is the 4D  0  and P is a homogeneous point with a w coordinate of 1. The dis-  where  vector  tance from a point Q to a plane L is simply   ⋅L Q.   L P  ⋅ =  0  Planes must be transformed using the inverse transpose of a matrix used to trans- form points.   Intersection of a Line and a Plane  = P The parameter t where a line      t  +  Q V intersects a plane L is given by   The View Frustum  The focal length e of a view frustum having a horizontal field of view angle α is  given by   t L Q L V  ⋅ ⋅  .   = −  t  =  e  1   α  .      2  tan  For a display having an aspect ratio a, the rectangle carved out of the near plane  at a distance n from the camera is bounded by x   and y  an e  n e  = ±  = ±  .   Perspective-Correct Interpolation  In a perspective projection, depth values  1z  and  linearly interpolating their reciprocals:   2z  are correctly interpolated by   Perspective-correct vertex attribute interpolation uses the similar formula   1 z  3  =  1 z  1      − + 1 t  1 z  2  t  .   b z  3  3  =  b 1 z  1        1    − +  t  b z  2  2  t   ,     where  1b  and  2b  are vertex attribute values.  Perspective Projections  The  perspective  projection  matrix  space into clip space is given by   frustumM   that  transforms  points  from  camera    128   5. Geometry for 3D Engines               0  0  0            n 2 − t b  M  frustum  =  n 2 − l r  0  0  0               + l r − l r + t b − t b + f − f − 1  −  0  0  0        ,         n n  −  nf −  2 f  n  where n and f are the distances from the camera to the near and far planes, and l,  r,  b,  and  t  are  the  left,  right,  bottom,  and  top  edges  of  the  viewing  rectangle  carved out of the near plane.   An infinite view frustum can be constructed by allowing the far plane distance f  to tend to infinity. The corresponding projection matrix   infiniteM  is given by   M  infinite  =  M  lim →∞ f  frustum  =  n 2 − l r  0  0 0  0  n 2 − t b 0 0  + l r − r l + t b − t b − 1 − 1  0  0 − 2 0  n            .   Oblique Near-Plane Clipping   A perspective projection matrix M can be modified so that the near plane is re- wC < , by constructing a new  placed by any camera-space clipping plane C, with  projection matrix   ′M  as follows,   0  1  2  M  M M +     ′ = − zQ 2  ⋅ C Q             ′Q  is given by Equation  5.64 .   0,0,1,0  M  C  4  ,   where   =Q M Q , and   1−  ′   Exercises for Chapter 5   129   Exercises for Chapter 5   1.  Determine a 4D vector   , DN   corresponding to the plane that passes through   the three points  1,2,0 ,  2,0, 1− , and  3, 2, 1  − − .   2.  Find  an  expression  for  the  parameter  t  representing  the  point  on  the  line      t  P  = +  S V that is closest to another point Q.   t  3.  Show that the distance d from a point Q to the line   P     t  = +  S V can be ex-  t  pressed as        d  × = Q S V  −     .   V  4.  The  horizontal  field  of  view  angle  for  a  particular  view  frustum  is  75 de- grees.  Calculate  the  corresponding  vertical  field  of  view  angle  for  a  1280 1024   pixel display.   ×  5.  Calculate the left, right, bottom, and top planes for a view frustum having a   horizontal field of view of 90 degrees and an aspect ratio of 0.75.   6.  Suppose that z coordinates in homogeneous clip space occupied the range  . In a manner similar to that used to derive the matrix in  n− →   0  [ ]0,1  instead of [ Equation   5.52 ,  derive  a  perspective  projection  matrix  that  maps  and   f− → .  1  ]1,1−  7.  Suppose that the third row of the infinite projection matrix given by Equa- tion  5.53  is modified so that the view frustum has the oblique near plane  C . Show that the optimal far plane given by Equations  5.65   and  5.66  is parallel to the right frustum plane.   − − 1,0, 1, 1  =         This page intentionally left blank    Chapter 6   Ray Tracing   The term ray tracing refers to any algorithm that follows beams of light to de- termine with which objects they interact in the world. Applications include light  map  generation,  visibility  determination,  collision  detection,  and  line-of-sight  testing. This chapter describes how the points of intersection where a ray strikes  an object can be found and how to alter the path of a ray when it strikes a reflec- tive or refractive surface.   6.1  Root Finding   The problem of finding the points at which a line defined by the equation      t  P  = +  S V   t   6.1    intersects a surface generally requires finding the roots of a degree n polynomial  in t. For planar surfaces, the degree of the polynomial is one, and a solution is  easily found. For quadric surfaces, such as a sphere or cylinder, the degree of the  polynomial is two, and a solution can be found using the quadratic equation. For  more complex surfaces, such as splines and tori, the degree of the polynomial is  three or four, in which case we can still find solutions analytically, but at much  greater computational expense.    Analytic solutions to polynomials of degrees two, three, and four are present- ed  in  this  section.  Complete  derivations  of  the  solutions  to  cubic  and  quartic  equations are beyond the scope of this book, however. We also examine a numer- ical root-finding technique known as Newton’s method.   6.1.1  Quadratic Polynomials  The roots of a quadratic polynomial in t can be found by using a little algebraic  manipulation to solve the equation           131    132   6. Ray Tracing                     Subtracting c from both sides and then dividing by a gives us   We can complete the square on the left side of the equation by adding  both sides as follows.   24b 2  a  to   Writing the left side of the equation as a square and using a common denomina- tor on the right side gives us   2  at  +  bt  + = .  c 0  +  2  t  b a  t  c = − .  a  +  2  t  +  t  b a  b 2 a 4  2  = − +  c a  b 2 a 4  2     +  t      2  b a 2      2  b  =  ac  .   − 4 a 4 2  − ± b  =  t  −  4  ac  .   b 2 a 2   6.2     6.3     6.4     6.5     6.6    Taking square roots and then subtracting  2b a from both sides yields    is called the  This is the well-known quadratic formula. The quantity  0D > ,  discriminant of the polynomial and reveals how many real roots it has. If  0D = , then there is one real root, and it is given  then there are two real roots. If  0D < ,  there  are  no  real  roots.  by  Evaluating  the  discriminant  allows  us  to  determine  whether  a  ray  intersects  an  object without actually calculating the points of intersection.   .  For  the  remaining  case  in  which   b a 2  = −  D b  ac  4  t  2  =  −  6.1.2  Cubic Polynomials  A cubic equation having the form  +  3     t  2  at  +  bt  + =   c 0   6.7     where  we  have  performed  any  necessary  division  to  produce  a  leading  co- efficient  of  1   can  be  shifted  to  eliminate  the  quadratic  term  by  making  the  substitution    6.1  Root Finding   133                   6.8     6.9     6.10    This gives us the equation    where   t  a x= − .  3  3  x  +  px q  + = ,  0  = −  p  2  +  b  a  1 3 a  2 27  1 3  =  q  3  −  + .  ab c  = −  3  + −  q  D  r  s  1 2 1 2  1 108 1 108  x 1 x x  2  = + s r + = ρr ρ s 2 + = ρ r ρs 2  The discriminant D of a cubic polynomial is given by   Once a solution x to Equation  6.9  is found, we subtract  3a  to obtain the solu- tion t to Equation  6.7 .      By setting   = −   6.11    27  D  −  .   p  q  4  2  3  = −  3  − −  q  D  ,    6.12    we can express the three complex roots of Equation  6.9  as     where  ρ  is  the  primitive  cube  root  of  unity  given  by  ρ 2   We can simplify our arithmetic significantly by making the substitutions   = − −  = − +  .    3 2  3 2  ρ  ,   1 2  1 2  i  i  3  .   Note  that    6.13    ′ =  p  = −  +  2  a  1 9 a  b  1 3 1 ab 6  ′ =  q  =  1 27  3  −  +  1 2  c  .   p 3 q 2   6.14     134   6. Ray Tracing                  The discriminant is then given by   Setting   lets us express r and s as   D  = −  108  ′  p  3  +  ′  q  2       .   ′  D  =  D 108  = −     ′  p  3  +  ′  q  2       3  = − + − = − − −  ′ q ′ q  3  ′ D ′ D  r s  .    6.15     6.16     6.17      As with quadratic equations, the discriminant gives us information about how  0D′ < , the value of  1x  given in Equation  many real roots exist. In the case that   6.13  represents the only real solution of Equation  6.9 .  s= , so there are two real solutions, one of    which is a double root:   0D′ = , we have r  In the case that   x 1 x x , 2  3  = =  r 2   ρ  +     = − .  r  ρ  2     In  the  remaining  case  that    6.18   0D′ > ,  Equation  6.13  yields  three  distinct  real    solutions. Unfortunately, we still have to use complex numbers to calculate these  solutions. An alternative method can be applied in this case that does not require  complex arithmetic. The method relies on the trigonometric identity   r  4cos  3  θ  −  3cos  θ  =  θ cos3  ,    6.19    which can be verified using the Euler formula  see Exercise 1 at the end of this  3 ,  chapter . Making the substitution  gives us    in Equation  6.9  with   m 2 cos  = −  m  =  p  θ  x  +  3  3  θ  2  8  m  pm  cos     6.20    Note that p must be negative in order for D′ to be positive.  Replacing p with  23m−    32m  out of the first two terms yields  + = .  q 0   and factoring    6.21    4cos  3cos  cos  m  −  2  θ  θ  θ        3  3  + = .  0  q   6.1  Root Finding   135                        Applying Equation  6.19  and solving for cos3θ gives us  ′ q ′ p  − q − p 0D′ > , Equation  6.16  implies that   − q m 2 3  2 27  θ cos3  < −  − −  =  =  =  ′  ′  3  2  3  .   , thereby guaranteeing that  Since  3 the right side of Equation  6.22  is always less than 1 in absolute value. The in- verse cosine is thus defined, and we can solve for θ to arrive at   q  p  =  θ  1 cos 3  −   1    ′−   ′− q p  3  .   Therefore, one solution to Equation  6.9  is given by   Since     θ cos 3  +  2  πk     =   for any integer k, we can write   m 2 cos  θ  =  2  −  ′  p  cos  θ  .   x 1   θ cos 3  =     =  θ  k  cos  1 3  −   1    ′−   ′− q p  3  −  π 2 3  k  .   Distinct  values  of cos kθ   are  generated  by  choosing  three  values  for  k  that  are  k = ± , we can express the remaining  congruent to 0, 1, and 2 modulo 3. Using  two solutions to Equation  6.9  as   1   6.22     6.23     6.24     6.25     6.26    x  2  =  2  −  ′  p  cos  x  3  =  2  −  ′  p  cos   + θ   − θ   π 2 3 π 2 3         .   6.1.3  Quartic Polynomials  A quartic equation having the form   4  t  +  3  at  +  2  bt  +  ct d  + =   0   6.27     where  again  we  have  performed  any  necessary  division  to  produce  a  leading  coefficient  of  1   can  be  shifted  to  eliminate  the  cubic  term  by  making  the  substitution    136   6. Ray Tracing                  This gives us the equation    where   t  a x= − .  4  4  x  +  2  px  +  qx  + = ,  0  r  3 8 a 3  = −  p  2  a  +  b  =  1 8 = −  q  r  −  1 2 a 4  3 256  + ab c  +  1 16  a b 2  −  + .  ac d  1 4   6.28     6.29     6.30    Once a solution x to Equation  6.29  is found, we subtract  4a  to obtain the solu- tion t to Equation  6.27 .    cubic equation   The roots of the quartic equation are found by first finding a solution to the   −  3  y  2  y  −  ry  +  p 2  4  2  rp q  = .  0  − 8 0q ≥ , then the solutions to the quar-   6.31    Let y be any real solution to this equation. If  tic equation are equal to the solutions to the two quadratic equations   2  x x  + −  x x  2 2  y y  − + − − + +  p p  y y  2  y y  − = r 0 − = .  r 0  2   6.32   0q < , then the solutions to the quartic equation are equal to the solutions to the     If  two quadratic equations   2  2  2  x x  + −  x x  2 2  y y  − + + − + −  p p  y y  2  2  y y  − = r 0 − = .  r 0   6.33    6.1.4  Newton’s Method  The Newton-Raphson iteration method, usually just called Newton’s method, is a  numerical  technique  that  can  find  roots  of  an  arbitrary  continuous  function  by  iterating a formula that depends on the function and its derivative.    6.1  Root Finding      y  137       f x  x  ,n    f x  n     nx1nx +  x     Figure 6.1. The tangent to a function tends to intersect the x axis closer to a root of the  function.   Suppose that we wish to find the root of the function f graphed in Figure 6.1.    For now, let us assume that we have an initial guess  0x  for the root of the function   more is said about how to choose this value shortly . The slope of the tangent   0 . We  line to the curve at the point  can write the equation for this tangent line as follows.        is given by the derivative     f x    x′  ,x 0      −  =  −              f  ′  0  f  x  0  x  x  0      6.34      f x  0  y     Notice that this line intersects the x axis at a point that is much closer to the actu- 0y =   al  root  of f  than  our  initial  guess  gives us the refinement formula   0x .  Solving  Equation   6.34   for x  when      x  i  + = 1  x  i  −    f x i   ′ f x  i       ,    6.35    where we have relabeled x with  ple times produces a sequence  tions, approach the root of f.   1ix +  and  0x  with  ix . Applying this formula multi- x x x  whose values, under the right condi- , 0  ,  ,  2  1   138   6. Ray Tracing                 Newton’s  method  converges  extremely  quickly  and  thus  requires  very  few  iterations  to  exceed  any  desired  precision.  We  can  in  fact  show  that  Newton’s  method converges quadratically, which means that with each iteration, the num- ber of significant digits in an approximated root roughly doubles. We prove this  claim by first setting       g x  =      f x     ′ x f  .    6.36    Let r be the actual root of the function f to which we are converging. We define  iε   to be the error between the i-th approximation  − .  r  ix  and the root r:    6.37    =  x  ε     i  i  Using this in Equation  6.35  allows us to write    .     g x  ε     We can approximate the function  series  see Appendix D  as follows.   i  ε  + = 1i   g x  with the first three terms of its Taylor    6.38    −  i  i    g x  i     =    g r  +  ε  i     ≈      g r  +      ε g r i  ′  +      ′′ g r     6.39    ε 2 i 2  The first and second derivatives of       g x  are given by       ′ g x  = − 1         ′′ g x  =  2          ′′ x f x f [ ]     ′ x f 2         ′ f x f x  [  f  ′′      x  ]  2  −  [  ′ f [  ]     x 2     ′ x f  [ ]      f x f 4  ′′′      x  +  ′      x f  f  ′′      x  ]  .    6.40        0 f r = , these expressions simplify greatly when evaluated at r. The func-  Since  tion g and its first two derivatives produce the following values at r.       g r     ′ g r     ′′ g r  = =  0 1  = −  ′′ ′      r     r     f f   6.41     6.1  Root Finding   139                  Plugging these into Equation  6.39  gives us   Finally, substituting this into Equation  6.38  yields     g x  i     ≈  ε  i  −  ε 2 i 2  ′′ ′      r     r  f f  .   ε  + 1  i  ≈  ε 2 i 2  ′′ ′      r     r  f f  .     Newton’s method is not guaranteed to converge to a solution. In particular, if  the initial guess is chosen at a point where the derivative of the function is zero,  then the tangent line is horizontal and does not intersect the x axis, preventing us  from proceeding any further. The initial guess has to be somewhat close to the  actual root to guarantee a convergence. When searching for the intersection of a  ray with a complex object, we can usually find a good initial guess by first inter- secting the ray with the surface of a relatively simple bounding volume. For ex- S V intersects a torus, we can first  P ample, to find where a ray defined by  find a value of t where the ray intersects a box bounding the torus, and then use  this value of t as our initial guess for the torus intersection.   = +     t  t  6.1.5  Refinement of Reciprocals and Square Roots  Most  modern  CPUs,  as  well  as  most  graphics  hardware,  have  instructions  that  can approximate the reciprocal of a number and the reciprocal square root of a  number to at least a few bits of precision. The results produced by these instruc- tions can be refined to greater precision using Newton’s method.    function   The  reciprocal  of  a  number  r  can  be  found  by  calculating  the  root  of  the   since   f     1 r = . Plugging this function into Equation  6.35  gives us   0      f x  −= x  1  −   r  x  n  + 1  r  − − x 1 n − − x 2 n − rx  n  −     2       .  =  =  x  n  x  n  This formula can be iterated to produce a high-precision reciprocal of the number      r, provided that each  f x  attains a   ix > . This is due to the fact that the function   0   6.42     6.43     6.44     6.45     140   6. Ray Tracing   0x = . Enforcing this condition on the first refinement  1x  allows us  0x   must  fall.   singularity at  to  determine  the  interval  inside  which  our  initial  approximation  Since  1x  must be greater than zero, we have    rx−   6.46    > ,  0  2  x        0  0  which yields the following restriction on  0x .  2 <   r  <  0  x     0  Thus, the initial approximation cannot be worse than double the reciprocal of r.    the positive root of the function   The reciprocal of the square root of a number r can be found by calculating   Plugging this function into Equation  6.35  gives us       f x  −= x  2  − .  r  x  n  + 1  =  x  n  −  =  1 2  x  n  − − x r 2 n − − x 2 3 n   −  rx  3    .   2 n  <  0 x  0  <  3 r  .   This sequence converges as long as each  must satisfy   ix > , so our initial approximation   0  0x    Once the reciprocal square root has been calculated to acceptable precision, the  square  root  of  r  can  be  calculated  using  a  single  multiplication  because  r  = ⋅ r    1     r  .   6.2  Surface Intersections   Computing the point at which a ray intersects a surface is central to ray tracing.  We define a ray    using the equation      tP     t  P  = +  S V,   t   6.51     6.47     6.48     6.49     6.50                    6.2  Surface Intersections   141               where S represents the ray’s starting position and V represents the direction in  which the ray points. In this section, we present specific solutions for the inter- section of a ray with a few common types of objects  additional objects are left as  exercises . With the exception of the triangle, intersections are computed in ob- ject space, the space in which the natural center of an object coincides with the  origin and the object’s natural axes are aligned to the coordinate axes. Intersec- tions with arbitrarily oriented objects are performed by first transforming the ray  into object space. Once an intersection is detected, information such as the point  of intersection and the normal vector at that point can be transformed back into  world space.   6.2.1  Intersection of a Ray and a Triangle   2P .  A triangle is described by the position in space of its three vertices  We determine the plane in which the triangle lies by first calculating the normal  vector N as follows.   0P ,  1P , and   =  N P P 0  1  −        ×     P  2  −    P   0   6.52    The signed distance d to the origin is given by the negative dot product of N with  0P  to construct the 4D plane vec- any point in the plane, so we choose the vertex  L N N P . As discussed in Section 5.2.1, the value of t corresponding to  tor  the point where the ray in Equation  6.51  intersects the plane L is given by   − ⋅  =  ,  0  = −  t  ⋅ ⋅  L S L V  .    6.53    ⋅  =  L V  , then no intersection occurs. Otherwise, plugging this value of t back  If  0 into Equation  6.51  produces the point P where the ray intersects the plane of  the triangle.    We now have the problem of determining whether the point P lies inside the  triangle’s edges. We do so by calculating the barycentric coordinates of P with  respect to the triangle’s vertices  0P ,  1P , and  2P . The barycentric coordinates repre- sent a weighted average of the triangle’s vertices and are expressed as the scalars  0w ,   2w  such that   1w , and   where   +  w w w 0  1  +  0w  with   − 1 w w  −  1  2  , we can write   =  P  w 0 = . Replacing  2 1  +  P 0  P w 1 1  +  w  2  P ,  2   6.54     142   6. Ray Tracing   P    = − 1 w w = + P 0  1 w 1  P 0 P P 1 0    −  −    2  + P w 1 1     + w  2  + P 2  P w 2 2   − P .  0  We perform the remainder of our calculations relative to the point  0P  by defining                         6.55     6.56     6.57     6.58     6.59    Equation  6.55  now becomes   = − R P P 0 − = Q P P 0 1 = − Q P P .  2 0  2  1  =  R  Q w 1  1  +  w  Q .  2  2  Taking the dot product of both sides of Equation  6.57  first with  with   1Q  and then   2Q  gives us the two equations  = =  R Q R Q  ⋅ ⋅  1  2  w w Q 2 1 1 2   Q Q w 1  + ⋅  1  2    ⋅ Q Q 1 2   + w Q  2    ,  2 2  which are written in matrix form as   Q 2 1 ⋅ Q Q  1      2  2  =  Q Q 2 2  ⋅ 1 Q      w 1 w            2w  as follows.   2  ⋅ ⋅  R Q R Q  .       1  2  We can now easily solve for   1w  and   w 1 w  2          Q 2 1 ⋅ Q Q  1      2  =  =  Q Q  2 1  2 2  −  − 1  Q Q 2 2  ⋅ 1 Q  2      1   Q Q  ⋅  1     2  2          1  2      ⋅ R Q ⋅ R Q Q 2 2 − ⋅ Q Q  1  2  − ⋅ Q Q 1 Q 2 1  2  ⋅ ⋅  R Q R Q         2  1        0w ,    6.60    −  w w 1  If the vertices   = − 1w 0 0P ,  1P , and   The point R lies inside the triangle if and only if all three weights  ≤ .  2 1 are nonnegative. Since  2P  have any associated attributes, such as a color or    texture coordinate set, then the interpolated value of those attributes at the point  2w . For instance, if the texture  R can be calculated using the weights  0P ,  1P , and  2,s t coordinates  , and  2 2P , then the texture coordinates  ,s t  at the point R are given by   0w ,   are associated with the vertices   , this implies that   1w , and   w w+  1w , and   0,s t 0  1,s t 1  2w    ,   1  2   6.2  Surface Intersections   143               = s w s 0 0 = t w t 0 0  + +  + w s w s 1 1 2 2 + w t w t 2 2 . 1 1     6.2.2  Intersection of a Ray and a Box  A box is described by the six plane equations  = = =  = = =  0 0 0  x y z  x y z     r x r r z  y    ,  0 x  where  xr ,  yr , and  zr  represent the dimensions of the box. At most three of these  planes need to be considered for intersection by the ray since at least three planes  must face away from the ray’s direction V. We can determine which planes need  to be tested by examining the components of V one at a time. For instance, if  xV = , then we know that the ray cannot intersect either of the planes  0x =  or  r=  because V is parallel to them. If  xV > , then we do not need to test for an  x r=  since it represents a back side of the box from  intersection with the plane  x xV < , then we do not need to test for an inter- the ray’s perspective. Similarly, if  0x = . The same principle applies to the y and z compo- section with the plane  nents of V.    Once we have found the point where a ray intersects a plane, we must check  that the point falls within the face of the box by examining the two coordinates  corresponding to the directions parallel to the plane. For instance, the value of t  corresponding to the point where the ray given by Equation  6.51  intersects the  plane   r=  is given by   0  0  x  x  x  To lie within the corresponding face of the box, the y and z coordinates of the  point    must satisfy      tP  r x  =  t  S  x  .   − V  x  ≤ ≤  [ [  P P      t     t  ] ]  0 0  ≤ ≤  y  r r z  y  z  .   If either of these conditions fails, then no intersection takes place within the face.  If both conditions pass, then an intersection has been found, in which case there  is no need to test any other planes since no closer intersection can occur.    6.61     6.62     6.63     6.64     144                        6. Ray Tracing    6.65    6.2.3  Intersection of a Ray and a Sphere  A sphere of radius r centered at the origin is described by the equation   +  2  x  2  y  = .  2  r  2  + z    tP  Substituting  the  components  of  the  ray  gives us     in  Equation   6.51   for  x,  y,  and  z      S  x  +  tV  x     2  +     S  y  +  tV  y     2  +     S  z  +  tV  z     2  = .  r 2   6.66    Expanding  the  squares  and  collecting  on  t  yields  the  following  quadratic  equation.  +  +  −  +  +  +  +  +  +  2  2  r  =   0   6.67    S  2 x  S  2 y  S  2 z     2  S V x  x    S V t z  z    V t  2 z    V  2 x  S V y  y  V  2 y  The coefficients a, b, and c used in Equation  6.2  can be expressed in terms of  the vectors S and V as follows.   = = =  a V b 2 S c  2   ⋅ S V − r 2 2        =  t  − − b a 2  D     2  =  D b  −  tells us whether the ray intersects the  Calculating the discriminant  0D = ,  sphere. As illustrated in Figure 6.2, if  0D > ,  then  there  are  two  distinct  then  the  ray  is  tangent  to  the  sphere;  and  if  points of intersection. If the ray intersects the sphere at two points, then the point  closer to the ray’s origin S, which corresponds to the smaller value of t, is always  given by   ac 4 0D < , then no intersection occurs; if    6.68     6.69    The  intersection  of  a  ray  and  an  ellipsoid  can  be  determined  by  replacing   because a is guaranteed to be positive.    Equation  6.65  with the equation  +  2  x  m y 2  2  +  n z 2  2  =  r  2  ,    6.70    where m is the ratio of the x semiaxis length to the y semiaxis length, and n is the  ratio of the x semiaxis length to the z semiaxis length. Plugging the components    6.2  Surface Intersections   145            0D <  0D =  0D >  r     Figure 6.2. The discriminant D indicates whether a ray intersects a sphere. If  no intersection occurs. If  0D > , then the ray intersects the sphere at two distinct points.   0D < , then  0D = , then the ray is tangent to the sphere at a single point. If   of the ray into this equation yields another quadratic polynomial whose coeffi- cients are given by   2 z  = = =  a V b 2 S c  2 y  + 2  m V 2 +  + n V 2 S V m S V x y y + n S 2  x m S 2  +  2 y  2 x     2 x  2 z  + n S V 2 z − r  .  2     z     Again, the discriminant indicates whether an intersection occurs. If so, the inter- section parameter t is given by Equation  6.69 .   6.2.4  Intersection of a Ray and a Cylinder   The lateral surface of an elliptical cylinder whose radius on the x axis is r, whose  radius on the y axis is s, whose height is h, and whose base is centered on the  origin of the x-y plane  see Figure 6.3  is described by the equation   2  x  + 0  m y 2 2 ≤ ≤ z  = h ,  2  r      6.71     6.72     146   6. Ray Tracing            z  h  r  s  y     Figure 6.3. Object space for an elliptical cylinder.   x     tP    S  x  where m r s= components of the ray   . If r  s= , then the cylinder is  circular and   1m = . Substituting the    in Equation  6.51  for x and y gives us   +  tV  x     2  +    m S  2  +  tV  y  y     2  = .  r 2   6.73    Expanding  the  squares  and  collecting  on  t  yields  the  following  quadratic  equation.     V  2 x  +    m V t  2 y  2  2  +       S V m S V t x  +  2  y  y  x  2  +  S  2 x  +  m S 2  2 y  −  2  r  =   0   6.74    As  with  the  sphere,  the  discriminant  indicates  whether  an  intersection  occurs.  Solutions to this equation give the values of t where the ray intersects the infinite  cylinder  centered  on  the  z  axis.  The  z  coordinates  of  the  points  of  intersection  must be tested so that they satisfy 0 z   In the context of collision detection, the problem arises in which we need to  know whether a moving sphere intersects a line segment representing an edge of  a polygonal model. The problem is transformed into determining whether a ray  intersects a cylinder with a given radius and arbitrary endpoints. This situation is  discussed in Section 12.2.   ≤ ≤ .  h   6.2  Surface Intersections   147                        6.2.5  Intersection of a Ray and a Torus  A  cross  section  of  the  surface  of  a  circular  torus  having  primary  radius  1r   and  secondary radius  2r  is shown in Figure 6.4. The circle of radius  1r  lying in the x-y  plane represents the center of another circle of radius  2r  perpendicular to the first,  which is revolved about the z axis. The equation describing the revolved circle is   where the value of s is the distance to the primary circle in the x-y plane:   2  s  +  2  z  = ,  r 2 2  =  s  +  2  x  2  y  − .  r 1  Substituting this into Equation  6.75  and expanding the square gives us   2  x  +  2  y  +  2  z  +  r 2 1  −  r 2 2  −  r 12  +  2  x  2  y  = .  0  Isolating the radical and squaring again yields the following equation for a torus.      2  x  +  2  y  +  2  z  +  r 2 1  −  =  r 14 2  +  2  x  2  y           2    r 2 2    tP  Substituting  the  components  of  the  ray  gives us     in  Equation   6.51   for  x,  y,  and  z         S x =  + tV x r 14 2       2    S  x  + +    S tV  y  x  +    2  tV +  y       S  2  y  + +    S tV  z  y  +    2  tV .       2  z  +  r 2 1  −  2  r 2 2         6.79     6.75     6.76     6.77     6.78    z  2r  1r     Figure 6.4. A torus and its cross section.    148   6. Ray Tracing                     After considerable algebraic simplification, this can be expressed as the quartic  equation   4  at  +  3  bt  +  2  ct  +  dt  + = ,  e 0   6.80    where   4  = = =  a V   b V 4   V S c 2  2  2  ⋅ 2  S V +    r 2 1  = =  d e  z  +  + r S V 8 2 z 1 + S S 4 4 x y + S S 2   x  2    4 z +  4 S 2 y  +       2  −  − r 2 2    S − r 2 2 − r 2 2  ⋅ S V   + r 2 1   r S 2 1  −    2 z  −  r 2 2  r 2 1 2        +    r V 2 1  4  2 x     V  2 y  +       S V   2  ⋅  4  S  2 x  +  S  2 y  S  2 z  −  r 2 1  −  r 2 2         .       6.81    After  dividing  by  a  to  obtain  a  leading  coefficient  of  1,  this  equation  can  be  solved using the method presented in Section 6.1.3. If the vector V is normalized,  then the division by a is unnecessary, and the calculations for b and c simplify to   = =  b c       4 2  ⋅ 2  S V + S    r 2 1     −  −  r 2 2  4  r 2 1    1  −  V  2 z     +     ⋅  S V .  2     4   6.82    6.3  Normal Vector Calculation   It  is  sometimes  convenient  to  represent  a  surface  using  an  implicit  function    f x y z  whose value is zero at any point  x y z  on the surface and whose val- , ue is nonzero elsewhere. An example of such a function is that of an ellipsoid:      ,  ,  ,    f x y z ,  ,     =  2  2  x a  +  2  2  y b  +  2  2  z c  − .  1   6.83    Suppose that   Using the implicit function representation, it is possible for us to derive a general  formula for the normal direction at any point on a surface.      f x y z =  for any  f x y z  represents a surface S, so that    point on S. Let C be a curve defined by differentiable parametric functions     x t ,     y t , and      z t  which lies on the surface S. Then the tangent vector T to the curve  C at the point    is given by       y t      x t      z t  0        ,  ,  ,  ,  ,  ,   6.4  Reflection and Refraction Vectors   =T      x t  ,      y t  ,      z t  .   d dt  d dt  d dt  Since the curve C lies on the surface S, T is also tangent to the surface S. Also,  df dt =   every- since  where on the curve C. Using the chain rule, we can write       z t =   for  any  value  of  t,  we  know  that         f x t      y t  0  0     ,  ,  =  0  df dt  =  ∂ f dx ∂ x dt  +  ∂ f dy ∂ y dt  +  ∂ f dz ∂ z dt  =  ∂ f ∂ x  ,  ∂ f ∂ y  ,  ∂ f ∂ z  ⋅  T.    6.85    ∂ ∂ ∂ ∂ ∂ ∂   f z Because its dot product with T is always zero, the vector  must be normal to the surface S. This vector is called the gradient of f at the point  , where the symbol ∇ is the del operator  x y z  and is usually written  , defined by     f x y z ,  ∇  y  x     f  f  ,  ,  ,  ,    We can now express the formula for the normal vector N to a surface defined  by the equation     f x y z =  as   0     ,  ,  Continuing the example given in Equation  6.83 , we have the following expres- sion for the normal to the surface of an ellipsoid.   ∇  =  i  ∂ ∂ x  +  j  ∂ ∂ y  +  k  ∂ ∂ z  .   =N ∇    f x y z ,  ,     .   =N  x 2  2 a  ,  y 2  2 b  ,  z 2  2 c     149    6.84     6.86     6.87     6.88                      6.4  Reflection and Refraction Vectors   When a beam of light strikes the surface of an object, part of its energy is ab- sorbed by the surface, part of its energy is reflected away from the surface, and  part of its energy may be transmitted through the object itself. Chapter 7 discuss- es this interaction in detail. This section explains how the direction of reflection  and refraction can be calculated for a ray that intersects  a shiny or transparent  surface.    150   6. Ray Tracing            6.4.1  Reflection Vector Calculation  The direction of the reflection of light on a shiny surface  such as a mirror  fol- lows the simple rule that the angle of incidence is equal to the angle of reflection.  As  shown  in  Figure  6.5,  this  is  the  same  as  saying  that  the  angle  between  the  normal vector N and the direction L pointing toward the incoming light is equal  to the angle between the normal vector and the direction R of the reflected light.    We assume that the vectors N and L have been normalized to unit length. To  derive a formula that gives us the reflection direction R in terms of the light di- rection L and the normal vector N, we first calculate the component of L that is  perpendicular to the normal direction:   perp  N L L N L N.   = −  ⋅         6.89    The  vector  R  lies  at  twice  the  distance  from  L  as  does  its  projection  onto  the  normal vector N. We can thus express R as   = − R L = − L   = 2  L 2perp [ ⋅ − 2 ⋅ N L N L  L N L N    N   −     .  ]     6.90    L N L N  −        ⋅  L     ⋅N L N     R  N  α  α  Figure 6.5. The direction of reflection R forms the same angle with the normal vector N  as the direction L pointing toward the incoming light. It is found by subtracting twice the  component of L that is perpendicular to N from L itself.       6.4  Reflection and Refraction Vectors   151                  6.4.2  Refraction Vector Calculation  Transparent surfaces possess a property called the index of refraction. According  to Snell’s law, the angle of incidence θL and the angle of transmission θT  shown  in Figure 6.6  are related by the equation  =  η  L  sin  θ  L  η  T  sin  θ  T,    6.91       where ηL is the index of refraction of the material that the light is leaving, and ηT  is the index of refraction of the material that the light is entering. The index of  refraction of air is usually taken to be 1.00. Higher indexes of refraction create a  greater bending effect at the interface between two materials.    We assume that the normal vector N and the direction toward the incoming  light L have been normalized to unit length. We express the direction T in which  the transmitted light travels in terms of its components parallel and perpendicular  to the normal vector. As shown in Figure 6.6, the component of T parallel to the  cosθ . The component of T perpendicular  normal vector is simply given by  T − G sinθ , where the vector G is the unit  to the normal vector can be expressed as  length vector parallel to perp N L. Since L has unit length,  perp  sinθ  , so   N  L  −  =  N  T  L  We can now express the refraction vector T as   =  G  L  perp N θ sin  L  =  L N L N       − sin  ⋅ θ  L  .   = −  T  N  cos  θ  T  = −  N  cos  θ  T  −  −  θ T [  G sin sin  sin θ θ  T  L  ] L N L N .   −        ⋅  = −  T  N  cos  θ  T  −  [  ] L N L N .   −        ⋅  η η  L  T   6.92     6.93     6.94    Using Equation  6.91 , we can replace the quotient of sines with η  ηL  T :   Replacing cosθT  with  place sinθT with   η T  η  L  − 1 sin θ  sin  2 L gives us   θ  T   and  then  using  Equation   6.91   again  to  re-  T  = −  N  −  1  2  sin  θ  L  −  [  ] L N L N .   −        ⋅   6.95    η η  2 L 2 T  η η  L  T   152   6. Ray Tracing         perp N L  L  G  N  θL  θT  G −  sinθ  T  ηLηT  −  N  cosθ  T  T     Figure 6.6. The angle of incidence θL and the angle of transmission θT are related by  Snell’s law, given in Equation  6.91 . The refraction vector T is expressed in terms of its  components parallel and perpendicular to the normal vector N.   Replacing   2  sin θL with   − 1 cos  2  θ  L  = −  1     ⋅  N L  finally yields   2     =  T  η η  L  T       ⋅ −  N L  −  1  η η  2 L 2 T  −     ⋅  N L     2  1            −  N  L.   η η  L  T   6.96    η>L  If η  T, then it is possible for the quantity inside the radical in Equation     6.96  to be negative. This happens when light inside a medium having a higher  index of refraction makes a wide angle of incidence with the surface leading to a  medium having a lower index of refraction. Specifically, Equation  6.96  is only  valid when sinθ L. If the quantity inside the radical is negative, a phe- nomenon known as total internal reflection occurs. This means that light is not  refracted, but is actually reflected inside the medium using Equation  6.90 .   η η T  ≤L   Chapter 6 Summary   153   Chapter 6 Summary   Analytic Root Finding  Solutions  to  the  quadratic  equation  formula:   2  at  +  bt  + =   are  given  by  the  quadratic  c  0              − ± b  =  t  −  4  ac  .   b 2 a 2  x  n  + = 1  x  n  −    f x n   ′ f x  n       .   x  n  + = 1  x  n     2  −  rx  n     ,      x  n  −  3  rx   2 .   n  Cubic and quartic equations can also be solved analytically.   Numerical Root Finding      f x   can  be  found  numerically  using  Newton’s  method,  Roots  of  a  function  which refines an approximate solution  nx  using the formula   The refinement formula for the reciprocal  nx  of a number r is   and the refinement formula for the reciprocal square root  nx  of a number r is   n     x  + = 1  1 2 Intersection of a Ray and a Sphere  t The points where a ray  the solutions of the quadratic equation  ⋅  = +     t  P  +     V t 2 2  2     Normal Vector Calculation  The  normal  vector  at  a  point    f x y z =  is given by  =N ∇  0     ,  ,  S V intersect a sphere of radius r are given by   S V     t  +  2  S  −  2  r  =  .  0  ,   f x y z ,  x y z   on  a  surface  defined  by  the  function  , ,  .      Reflection Vector Calculation  The reflection R of a vector L across the normal vector N is given by    154   6. Ray Tracing   Exercises for Chapter 6               2=     N L N L.   −  ⋅     R  Transmission Vector Calculation  The direction T in which light is transmitted when leaving a medium having in- dex of refraction ηL and entering a medium having index of refraction ηT is given  by   =  T  η η  L  T       ⋅ −  N L  −  1  −     ⋅  N L     1    2     −  N  η η  2 L 2 T       η η  L  T  L,   where L is the direction pointing toward the incident light, and N is the surface  normal.   1.  Use  the  Euler  formula   which  states  that   αie  =  cos  + α i  sin  α     to  verify  the   trigonometric identity  =  −  3  θ  3cos  4cos    [Hint. Equate the real components of the equation    θ cos3  θ  .      3  θie      3 θ i  e=  .]   2.  Use  Newton’s  method  to  approximate  the  root  of  the  function     f x =      ln  x  x+ − .  7  3.  Find a general formula that can be used to refine an approximation  nx  of the   p-th root of a number r using Newton’s method.   4.  Let   0P ,  1P , and   Show that each of the barycentric coordinates  the triangle is given by the ratio of the area of the subtriangle  ing P and the two vertices   2P  be the three vertices of the triangle T shown in Figure 6.7.  iw  of a point P lying inside  iU  formed us-  to the area of the triangle T.      and        2 mod3    1 mod3  i+P  i+P  5.  Let   1w ,   2w , and   3w  be the barycentric coordinates of a point P with respect to  2P . Let N be the direction normal to  r+P N are   a triangle whose vertices are  the triangle. Show that the barycentric coordinates of the point  the same as those of the point P for any scalar r.   0P ,  1P , and   6.  Calculate  the  unit  length  surface  normal  to  the  paraboloid  defined  by     f x y z ,  ,     =  2  2  x  +  2  3  y  − =  at the point  1,2,14  0  z  −  .    Exercises for Chapter 6      155   0P    Figure 6.7. The triangle used in Exercise 4.   1P  = +  7.  Derive  the  polynomial  whose  roots  give  the  values  of  t  at  which  the  ray     t S V intersects a cone whose radius  at the base  is r, whose height  P is h, and whose base is centered on the origin of the x-y plane as shown in  Figure 6.8.   t  2P  1U  0U  P 2U  z  h  r  r  x  y     Figure 6.8. The cone used in Exercise 7.    156   6. Ray Tracing   8.  The critical angle at the interface between two media is the smallest angle  of incidence at which total internal reflection occurs. Determine the critical  angle for a beam of light traveling upward through water toward the surface  where it meets the air. The index of refraction of water is 1.33, and the index  of refraction of air is 1.00.          Chapter 7   Lighting and Shading   This chapter describes the mathematics used to illuminate and shade a surface.  The term lighting or illumination is often used to describe the process by which  the color and intensity of light reaching a surface is determined. The term shad- ing normally describes the methods used to determine the color and intensity of  light reflected toward the viewer for each point on a surface. This color depends  on the properties of the light sources illuminating the surface as well as the re- flective characteristics of the surface itself.    The  interaction  between  light  and  a  surface  is  a  complex  physical  process.  Photons can be absorbed, reflected, or transmitted when they strike the surface of  a  material.  To  model  this  interaction using  the  whole  of  today’s  knowledge  of  physics would be far too computationally time-consuming. Instead, we must set- tle for models that approximate the expected appearance of a surface. We begin  this chapter with simple models that are widely used because they are computa- tionally efficient and produce acceptable results, but really are not physically ac- curate.  Later,  we  examine  more  costly  techniques  that  more  closely  model  the  true physical interaction of light with a surface.   7.1  RGB Color   A precise model describing the reflection of light by a surface would account for  every wavelength of light in the visible spectrum. However, the cone cells in the  human  eye  are  generally sensitive  to  three  different  overlapping regions  of  the  visible spectrum corresponding to the colors red, green, and blue. Thus, TVs and  computer displays are able to produce a wide range of colors by combining red,  green, and blue light in different proportions. For instance, yellow is produced by  blending equal parts red and green. This system is commonly referred to as RGB  color.  Colors  that  are  made  up  of  more  than  one  wavelength  of  light,  such  as  brown, can also be simulated using RGB color.        157    158      7. Lighting and Shading     The lighting models presented in this chapter utilize the RGB color system.  The intensity of reflected light at a point on a surface is calculated for red, green,  and blue wavelengths simultaneously. Since the same operations are performed  for  each  of  these  components,  we  express  our  mathematical  formulas  using  a  three-component entity that we simply call a color.    Colors  are  expressed  as  triplets  of  red,  green,  and  blue  components  whose  values range from 0 to 1. These colors represent both the spectral composition of  light, which determines what color the eye perceives, as well as the intensity of  light. We denote colors by script letters to distinguish them from vectors. A sin- gle red, green, or blue component of a color  is denoted by using a subscript r,  g, or b  hence, we can write    A color  can be multiplied by a scalar s to produce a new color:     sC sC sC  C C C   7.1    =  =   .   .   s              ,  ,  ,  ,  b  g  r  g  b  r  Addition and multiplication of colors are performed componentwise. That is, for  two colors  and , we have  + =   =   C D C , g C D C D C D  D C D   7.2         + ,       +  +  b .     ,  ,     g  b  r  r  g  g  b  b  r  r    Color  multiplication,  either  by  another  color  or  by  a  scalar,  is  also  called  modulation. The color of a pixel belonging to a rendered triangle is usually de- termined through some combination of colors from multiple sources. The color  of a pixel on the face of a triangle is commonly derived from the product of a  color looked up in a texture map and another color that is interpolated among the  triangle’s vertices. In this case, we say that the texture color is modulated by the  vertex color.   The color that we calculate for any point on a surface is the sum of contributions  from all the light sources that illuminate the surface. The standard types of light  sources supported by 3D graphics systems come in four varieties: ambient, direc- tional, point, and spot. This section describes each of these types of light sources  and how they contribute to the radiation present at a point in space.   7.2.1  Ambient Light  The ambient light present at a certain location is the low-intensity light that arises  from the many reflections of light on all nearby surfaces in an environment. Us-  7.2  Light Sources    7.2  Light Sources   159         ing ambient light provides a rough approximation of the general brightness of an  area and replaces the complexities of calculating all the interobject reflections in  a scene.    Ambient light appears to come from every direction with equal intensity, and  thus illuminates every part of an object uniformly. The color  of the ambient  light is usually a constant in a scene, but it may also be a function of spatial posi- tion. For instance, one can use a three-dimensional texture map to store samples  of the ambient light on a regular grid that permeates a region of the world.   7.2.2  Directional Light Sources  A directional light source, also known as an infinite light source, is one that radi- ates light in a single direction from infinitely far away. Directional lights are typ- ically used to model light sources such as the sun, whose rays can be considered  parallel.  Since  they  have  no  position  in  space,  directional  lights  have  infinite  range, and the intensity of the light they radiate does not diminish over distance,  as does the intensity of point lights and spot lights.   7.2.3  Point Light Sources  A point light source is one that radiates light equally in every direction from a  single point in space. The intensity of light naturally decreases with distance ac- cording  to  the  inverse  square  law.  The  fixed-function  features  of  OpenGL  and  Direct3D both provide a generalization of this concept that allows us to control  the  intensity  of  light  radiated  by  a  point  light  source  using  the  reciprocal  of  a  quadratic polynomial.    of light reaching a point in space Q is given by   Suppose that a point light source has been placed at a point P. The intensity    =    1 k d l  +  k  c   ,  0  +  2  k d q   7.3    ck ,   lk , and   where  0  is the color of the light, d is the distance between the light source and Q  −P Q  , and the constants   i.e., d = qk  are called the constant, linear,  and quadratic attenuation constants.    In the newer programmable shading environments provided by OpenGL and  Direct3D, any kind of fall-off function can be achieved, and it’s often the case  that a point light’s intensity is intentionally made to become zero beyond a cer- tain distance from the light. This limits the light’s volume of influence so that  objects too far from the light to receive significant illumination don’t have to be    160   7. Lighting and Shading            rendered for that light source. This by itself helps game engines run faster, but an  even more aggressive optimization for point lights is described in Section 10.4.7.   7.2.4  Spot Light Sources  A spot light is similar to a point light but has a preferred direction of radiation.  The intensity of a spot light is attenuated over distance in the same way that it is  for  a  point  light  and  is  also  attenuated  by  another  factor  called  the  spot  light  effect.    direction R. The intensity  of light reaching a point in space Q is given by   Suppose that a spot light source has been placed at a point P and has a spot   0  is the color of the light; d is the distance between the light source and  lk , and  qk  are the attenuation constants; and L is the unit length direction   where  ck ,  Q;  pointing from Q toward the light source:   =    { − ⋅ R L max + + k d k l  } ,0 p k d 2 q  c   ,  0  =  L  − −  P Q P Q  .    7.4     7.5    The exponent p controls how concentrated the spot light is. As shown in Figure  7.1, a large value of p corresponds to a highly focused spot light having a sharp  falloff,  whereas  a  smaller  value  of  p  corresponds  to  a  less  concentrated  beam.  The spot light is most intense when  = −R L and gradually falls off as the angle  between R and −L increases. No radiation from a spot light reaches a point for  which the angle between R and −L is greater than 90 degrees.     Figure 7.1. The spot light exponent p in Equation  7.4  controls how concentrated the  beam of a spot light is. From left to right, the spot light exponents used to illuminate the  ground are 2, 10, 50, and 100.    7.3  Diffuse Reflection      7.3  Diffuse Reflection   161   A diffuse surface is one for which part of the light incident on a point on the sur- face is scattered in random directions. The average effect is that a certain color of  light, the surface’s diffuse reflection color, is reflected uniformly in every direc- tion. This is called the Lambertian reflection, and because light is reflected equal- ly in every direction, the appearance of the Lambertian reflection does not de- pend on the position of the observer.    As shown in Figure 7.2, a beam of light having a cross-sectional area A illu- minates the same area A on a surface only if the surface is perpendicular to the  direction in which the light is traveling. As the angle between the normal vector  and the light direction increases, so does the surface area illuminated by the beam  of light. If the angle between the normal vector and light direction is θ, then the  θ. This results in a  surface area illuminated by the beam of light is equal to  decrease in the intensity of the light per unit surface area by a factor of cosθ.  The value of cosθ is given by the dot product between the normal vector N    and the unit direction to the light source L. A negative dot product means that the  surface is facing away from the light source and should not be illuminated at all.  Thus, we clamp the dot product to zero in our illumination calculations.    We can now begin to construct a formula that calculates the color of light   that is reflected toward the viewer from a given point Q on a surface. This formu- i  of each of n lights illuminating the point  la is written in terms of the intensity  Q, which is constant for directional light sources and is given by Equations  7.3   and  7.4  for point and spot light sources. The reflected light is modulated by the   cos  A  N  θ  A  L  A cos  θ     Figure 7.2. The surface area illuminated by a beam of light increases as the angle θ be- tween the surface normal and direction to the light increases, decreasing the intensity of  incident light per unit area.    162   7. Lighting and Shading         surface’s  diffuse  reflection  color  .  Adding  the  contributions  from  n  light  sources  and  considering  the  ambient  intensity  ,  we  can  express  the  diffuse  component of our lighting formula as     diffuse  =       +  i  max  {  ⋅  N L  i  } ,0 ,   n  i= 1   7.6    where the unit vector   iL  points from Q toward the i-th light source.   7.4  Specular Reflection   In addition to the uniform diffuse reflection, surfaces tend to reflect light strongly  along the path given by the reflection of the incident direction across the surface  normal. This results in the appearance of a shiny highlight on a surface called a  specularity. Unlike the diffuse reflection, the specular reflection visible on a sur- face depends on the position of the viewer.  Figure 7.3 shows the normal vector N at a point Q on a surface, the unit di-   rection to viewer vector V, the unit direction to light vector L, and the direct re- flection  vector  R  calculated  using  Equation   6.90 .  Specular  highlights  are  the  most  intense  when  the  reflection  direction R  points toward  the  viewer  and  de-   R  L  V  N  αα  Q  Figure 7.3.  The  intensity  of  the  specular reflection  is  related  to  the  angle  between  the  direction to viewer vector V and the direct reflection vector R corresponding to the direc- tion to light vector L.       7.4  Specular Reflection   163         crease  in  intensity  as  the  angle  between  R  and  the  direction  to  the  viewer  V  increases.    A model that produces a believable  but having almost no real physical basis   rendition of specular highlights uses the expression     max  {  ⋅  R V  ,0  }   m  ⋅ >  N L       0   7.7     0  ⋅ >N L  to calculate the specular contribution from a single light source, where  is the  surface’s specular reflection color,  is the intensity of the incident light, and m is  called the specular exponent. The expression    is a boolean expression  that evaluates to 1 if true and 0 otherwise. This prevents specular highlights from  showing up at points on a surface that face away from the light source.  The specular exponent m controls the sharpness of the specular highlight. As    shown in Figure 7.4, a small value of m produces a dull highlight that fades out  over a relatively large distance, and a large value of m produces a sharp highlight  that fades out quickly as the vectors V and R diverge.    An alternative formulation of specular highlights that requires less calcula- tion in some cases makes use of a direction called the halfway vector. Shown in  Figure 7.5, the halfway vector H is the vector lying exactly halfway between the  direction to viewer vector V and the direction light vector L. Specular highlights  are the most intense when H points in the direction of the normal vector N. Using  ⋅R V in Equation  7.7  with the dot prod- this model, we replace the dot product  ⋅N H. This produces different results in terms of the rate at which the specu- uct  lar highlights diminish, but still retains the general characteristics of our original  model.     Figure  7.4.  The  specular  exponent  m  in  Equation   7.7   controls  the  sharpness  of  the  specular highlight seen on a surface. From left to right, the specular exponents used to  shade the tori are 2, 10, 50, and 100. The specular reflection color  is white.    164   7. Lighting and Shading            H  N  L  V  α  α  Q  Figure 7.5. The angle between the normal vector N and the halfway vector H can also be  used to determine specular intensity.        Adding the contributions from n light sources, we can express the specular  component of our lighting formula as     specular  =      i  max  {  ⋅  N H  }   m  ,0  i  ⋅  N L  i  >     ,   0   7.8    n    i= 1  where   iH  is the halfway vector for the i-th light source given by   H  i  =  i  L V L V  + +  i  .    7.9    7.5  Texture Mapping   One or more texture maps may be applied to a surface to achieve greater detail,  as  shown  in  Figure  7.6.  At  each  point  on  a  surface,  a  texel   texture  pixel   is  looked up in each texture map and combined in some way with the lighting for- mula. In the simplest case, a sample from a diffuse texture map is looked up and  used  to  modulate  the  diffuse  reflection  color.  More  advanced  applications  are  discussed later in this chapter.    7.5  Texture Mapping   165            Figure 7.6. Applying a texture map adds detail to a surface.  Image from the game The  31st, courtesy of Terathon Software LLC.             Let the color  represent a filtered sample from a texture map at a point on a  surface.  Using  this  color  to  modulate  the  diffuse  reflection  color  produces  the  following augmented version of Equation  7.6 .     diffuse  =     +    i  max  {  ⋅  N L  } ,0    i   7.10    n    i= 1    Just as a texture map can be used to modulate the diffuse component of the  lighting formula, we can also use a texture map to modulate the specular compo- nent. Such a map is sometimes called a gloss map and determines the intensity of  the specularity at each point on a surface. Using the color  to represent a filtered  sample from the gloss map, we can augment the formula for the specular contri- bution as follows.     specular  =      i  max  {  ⋅  N H  }   m  ,0  i  ⋅  N L  i  >       0   7.11    n    i= 1    The actual color sampled from the texture map is determined by texture co- ordinates  applied  to  an  object.  Texture  coordinates  are  either  precomputed  and  stored  with  each  vertex  of  a  triangle  mesh  or  calculated  at  runtime  to  produce  some special effect. The texture coordinates are then interpolated using Equation   5.37  across the face of a triangle when it is rendered. There may be from one to    166      7. Lighting and Shading   four coordinates at each vertex, and they are labeled s, t, p, and q.1 The next few  sections describe the different varieties of texture maps and how texture coordi- nates are used to look up a texel in each type.   7.5.1  Standard Texture Maps  One,  two,  or  three  texture  coordinates  may  be  used  to  look  up  texels  in  one-,  two-,  or  three-dimensional  texture  maps.  As  shown  in  Figure  7.7,  the  entire  width, height, and depth of a texture map corresponds to coordinate values lying  between 0 and 1 in the s, t, and p directions, respectively.    a   0   b   1  t  0  0  s  s  1  1   c   1  t  0  0  s  0  1  1 p     Figure  7.7.  Texture  space  for   a  1D  texture maps,   b  2D texture maps,  and   c   3D  texture maps.     A one-dimensional texture map can be thought of as a two-dimensional tex- ture map that is only a single pixel in height. Likewise, a two-dimensional texture  map can be thought of as a three-dimensional texture map that is only a single  pixel in depth. When t and p coordinates are not specified, they are assumed to be  zero.                                                          1 Originally, texture coordinates were labeled s, t, r, and q in OpenGL. However, the let- ter r conflicted with the label for the red channel of a color when used as a swizzle or  mask in a shader program, so the label used for the third texture coordinate was replaced  with the letter p.  See the OpenGL Shading Language specification, Section 5.5.     7.5  Texture Mapping   167            7.5.2  Projective Texture Maps  The fourth texture coordinate is used for projective texture mapping, an applica- tion of which is described later in this section. The q coordinate behaves in much  the same way the w coordinate does for homogeneous points and is assumed to  be one when not specified. The interpolated s, t, and p coordinates are divided by  the interpolated q coordinate. For a scanline whose endpoints have texture coor- t p q , we can use Equation  5.37  to calculate  s s t p q  and  , dinates  2 1 2 interpolated values  3s  and  3q  at some intermediate parameter  . The quo- tient of these two values gives the following expression for the s coordinate used  to sample the texture map.   ]0,1  u ∈  [  ,  ,  ,  ,  ,  2  1  1  2  1  =  s  =  s q  3  3    1  −     u    1  −     u  s z q z  1  1  1  1  +  u  +  u  s z q z  2  2  2  2      7.12    s t , ,0,  ,s t  used to sample the projected image.   Similar expressions give the projected t and p texture coordinates.    One application of projective texture maps is the simulation of a spot light  that projects an image onto the environment. As shown in Figure 7.8, the project- ed image becomes larger as the distance from the spot light increases. The effect  is achieved by using a 4 4×  texture matrix to map the vertex positions of an ob- q  such that division by q produces the correct  ject to texture coordinates  2D texture coordinates  Suppose that a spot light has been placed at the point P and points in the di-   rection Z. Let the unit vectors S and T lie in the plane perpendicular to Z such  that they are aligned to the directions in which the s and t axes of the projected  ,1   texture image should be oriented  see Figure 7.8 . Each vertex position  belonging to a surface illuminated by the spot light must first be transformed into  the coordinate system in which the spot light lies at the origin, and the x, y, and z  axes correspond to the directions S, T, and Z. This can be accomplished using  the inverse of the matrix whose columns are the vectors S, T, Z, and P. If S and  T are orthogonal  i.e., the projected image is not skewed , the transformation is  given by   x y z , ,  M  1  =  x  x  S T Z x 0         y  y  S T Z y 0  z  z  S T Z z 0  − ⋅ S P − ⋅ T P − ⋅ Z P 1         .    7.13     168   7. Lighting and Shading            t  s  Z  T  P  S     Figure 7.8. A projective texture map can be used to simulate a spot light that projects an  image onto the environment.   Z.     Note  that  this  matrix  transforms  into  a  left-handed  coordinate  system  since  × = − S T   Now we need to multiply the matrix in Equation  7.13  by a second matrix  that performs the projection. Just as we define the focal length of the view frus- tum,  we  can  define  the  focal  length  of  the  spot  light  projection  in  terms  of  an  apex angle α. The focal length e is given by   =  e  1   α  .      2  tan  Let  a  be  the  aspect  ratio  of  the  texture  map,  equal  to  its  height  divided  by  its  width. Every vertex position should be projected onto the plane lying at a dis- tance e from the spot light, where we want to map the interval [  in the x di- rection to [ ]0,1 .  The matrix   ]0,1 , and we want to map the interval [  ]  in the y direction to [  ]1,1−  ,a a−   7.14     7.15    M  2  =  e 2 0 0 0         0 e a 2 0 0  1 2 0 1 2 0 0 0 1 0             7.5  Texture Mapping      169   performs this mapping and causes the projection to occur when the s and t coor- dinates are divided by the q coordinate of the result. Combining the matrices giv- en in Equations  7.13  and  7.15 , the 4 4×  texture matrix M used to implement a  projected spot light image is given by   =M M M .   2  1  7.5.3  Cube Texture Maps  Another method of texturing an object is enabled through the use of a cube tex- ture  map.  Cube  texture  maps  are  often  used  to  approximate  an  environmental  reflection on the surface  of a model. Shown in Figure 7.9, a cube texture map  consists of six two-dimensional components that correspond to the faces of a cu- be. The s, t, and p coordinates represent a direction vector emanating from the  center of the cube that points toward the texel to be sampled.   , ,s t p     Figure 7.9. A cube texture map consists of six components that correspond to the faces  of a cube.     Which face to sample is determined by the sign of the coordinate having the  largest absolute value. The other two coordinates are divided by the largest coor- dinate and remapped to the range [ ]0,1  using the formulas listed in Table 7.1 to  ′ . These coordinates are then used to sample  ,s t′ produce 2D texture coordinates  the two-dimensional texture map for the corresponding face of the cube texture  map. Figure 7.10 shows the orientation of the cube map axes relative to each of  the six faces.    Texture coordinates used in conjunction with cube texture maps are typically  generated  at  runtime.  For  instance,  environment  mapping  can  be  performed  by  calculating  the  reflection  of  the  direction  to  the  camera  and  storing  it  in  the  , ,s t p  coordinates at each vertex of a triangle mesh. The reflection direction cal- culation  is  normally  implemented  in  hardware,  so  this  can  be  done  very  efficiently.    170      7. Lighting and Shading   Face   Positive x   Negative x   Positive y   Negative y   Positive z   Negative z               +  −  −  s′  p s 2 p s 2 s t 2 s t 2 s p 2 s p 2  −  +  +        1 2 1 2 1 2 1 2 1 2 1 2  t′   1 2 1 2 1 2 1 2 1 2 1 2           +  −  +  t s 2 t s 2 p t 2 p t 2 t p 2 t p 2 ,s t′ ′  used to sample a texel in   +           +  −  Table 7.1. Formulas used to calculate the 2D coordinates  one of the six faces of a cube texture map.   t′  z+  t′  x+  s′  s′  t′  x−  s′  s′  t′  s′  y−  z−  y+  t′  s′  t′  Figure 7.10. Orientation of the cube map axes relative to each of the six faces.       7.5  Texture Mapping   171     One application of cube texture maps on some graphics hardware is that of  normalizing vectors. A normalization cube map is a cube texture map that, in- stead of storing color images in each of its six faces, stores an array of vectors  that are encoded as RGB colors using the following formulas.            red  green  blue  += x 2 += y 2 += z 2  1  1  1     The vector stored at each pixel of a face of the cube map is the unit length vector  , ,s t p  that causes that pixel to be sampled. The use of a normalization cube map  becomes  desirable  when  performing  per-pixel  lighting  because  interpolation  of  surface normals across the face of a triangle inexorably produces normal vectors  whose length is less than unity.   7.5.4  Filtering and Mipmaps  When a model is rendered with a texture map applied to its surface, it is almost  never the case that the resolution of a texture map matches the resolution of the  viewport in which it is displayed. As a model moves closer to the camera, the  relative resolution of the viewport increases compared to that of the texture map.  Using only one sample from the texture map at each pixel results in a blocky ap- pearance, so rendering hardware normally fetches four samples from the texture  map at each pixel and blends them together. In a process called bilinear filtering,  the four samples are blended using a weighted average that depends on the exact  texture coordinates corresponding to the pixel being rendered.    sampled using the texture coordinates   Suppose a two-dimensional texture map having width w and height h is being   ,s t  and make the following definitions.   i j α β  = = = =  − ws   − ht    frac   frac  1   2 1   2 − ws − ht       1 2 1 2     The bilinearly filtered texture value  is given by    7.16     7.17     172   7. Lighting and Shading              Figure 7.11. These are the largest seven mipmap images for a particular texture map con- taining dirt and stones. Each smaller image is exactly half the width and half the height of  the preceding image. Although not shown in its entirety here, the mipmap chain contin- ues to an image that is only one pixel in size.   =           − − β α 1 1     + − α β 1     i  ,  j  i  ,  + 1  j    + α 1 + αβ   −     β  + 1,  i  + 1  j   ,  + 1,  i  j      7.18     represents the value stored in the texture map at the integral texel co- ,i j .   where  j ,i ordinates    As a model moves away from the camera and the relative resolution of the  viewport decreases compared to that of the texture map, the area of a single pixel  can cover a region enclosing many texels in the texture map. Even if bilinear fil- tering is applied, the low sampling resolution often leads to severe aliasing arti- facts. The solution to this problem is to generate prefiltered versions of a texture  map at lower resolutions. As shown in Figure 7.11, each smaller image is exactly  half the width and half the height of the image that is one size larger. The array of  texture images is called a mipmap.2 Since the sum of the infinite series   1  + +  1 1 4 16  +  1 64  +    7.19                                                           2 The term mipmap is derived from the Latin phrase multum in parvo, meaning “much in  a small place”.    7.5  Texture Mapping   173         3, adding mipmap images to a texture map increases the storage requirements   is  4 by only one-third of the texture map’s original size.    When  using  mipmaps  and  bilinear  filtering,  rendering  hardware  chooses  a  ∂ ∂S y ,  mipmap  image  at  each  pixel  by  examining  the  derivatives  where x and y are the viewport coordinates of the pixel, and S represents the in- terpolated components of the texture coordinate set at the pixel. The largest im- age in a mipmap is called level 0, and smaller images are numbered sequentially.  Larger  texture  coordinate  derivatives  cause  higher-numbered  mipmap  images  being used. Let n and m be the base-2 logarithms of the width and height of a  two-dimensional texture map  whose width and height are thus 2 n and 2 m . Let    s x y  and    t x y  be functions that map viewport coordinates x and y to texture      coordinates  s  and  t,  and  define  .  The    and  level-of-detail parameter λ is determined by calculating     u x y ,    v x y ,    s x y ,  ∂ ∂S x    t x y ,    and   =  =  2  2              ,  ,  m  n  =  ρ  x  =  ρ  y  ∂ v ∂ x ∂ v ∂ y  2  2          2  2                  ∂ u ∂ x  ∂ u ∂ y [  2  +  +            =  λ  log max  ρ ρ , x  y     ]  .    7.20          ]  0,max  When using bilinear filtering  or no filtering , the value of  λ is rounded to the  [ ,n m . Four texture samples are  nearest integer and clamped to the range  then  fetched  from  the  corresponding  mipmap  image  level  and  blended  using  Equation  7.18 .    As a model moves toward or away from the camera, abrupt changes in the  mipmap level may be unsightly, so rendering hardware provides a mode called  trilinear filtering in which two mipmap levels are sampled  using bilinear filter- 2  are sampled from mipmap  ing  and blended together. Texture values  levels  λ   and     1 , respectively, and blended using the formula     = − 1 frac  1  and   λ +      7.21        λ      λ  frac  +            2  1  to arrive at the final texture value .    Mipmapping for one-dimensional and three-dimensional texture maps oper- ates by considering one or three texture coordinates in Equation  7.20 . For cube  texture  maps,  mipmapping  operates  independently  for  each  of  the  six  two- dimensional faces.    174      7.6  Emission   7. Lighting and Shading   Some  objects  may  emit  light  in  addition  to  reflecting  it.  To  give  an  object  the  appearance of emitting a uniform glow, we add an emission color  to our light- ing formula. This emission color can also be modulated by an emission map that  determines the color and intensity of the glow at each point on a surface. Using  the color  to represent a filtered sample from the emission map, the emission  component of the lighting formula is given by the simple expression   7.22     Figure 7.12 demonstrates the application of an emission map to the surface of a  model in addition to an ordinary texture map.       emission =   .    a     b          Figure  7.12.   a   The  left  image  is  an  ordinary  texture  map,  and  the  right  image  is  an  emission map.  b  The model on the left has only the ordinary texture map applied to it.  The model on the right includes the emission map. Unlike the ordinary texture map, the  emission  map  is  unaffected  by  the  direction  of  the  surface  normal,  and  it  determines  which parts of the surface appear to give off a glow.  Image from the game The 31st,  courtesy of Terathon Software LLC.     7.7  Shading Models   175   7.7  Shading Models         Information about the surface of a model, such as the positions of points on the  surface and the normal vectors at those points, are stored only for each vertex of  a triangle mesh. When a single triangle is rendered, information known at each  vertex is interpolated across the face of the triangle, as discussed in Section 5.4.2.  Conventional lighting pipelines calculate diffuse and specular illumination only  at the vertices of a mesh. More modern graphics hardware enables the calculation  of the entire illumination formula at every individual pixel drawn to the display.  The manner in which lighting is determined for the surface of a triangle, com- bined with any number of texture maps, is called shading.   7.7.1  Calculating Normal Vectors  To apply the lighting formula to a triangle mesh, we need to have a representa- tion of the surface normal at each vertex. We can calculate the normal vector for  a single triangle by using the cross product. The unit-length normal vector N of a  triangle whose vertices lie at the points  0P ,  1P , and  2P  is given by   =  N       P 1 P 1  − −  P 0 P 0       × ×       P P  2  2  − −  P 0 P 0       .    7.23    This assumes that the vertices are oriented in a counterclockwise fashion when  the normal points toward the viewer, as shown in Figure 7.13.    normal vectors of all triangles that share that vertex. Using the formula   The normal vector at a single vertex is typically calculated by averaging the   2P  0P  1P     Figure 7.13. The vertices of a triangle should be oriented in a counterclockwise fashion  when the normal vector points toward the viewer.    176   7. Lighting and Shading            2N  3N  Figure 7.14. By averaging the unnormalized normal vectors of each triangle sharing a  vertex, a vertex normal can be calculated that is influenced more strongly by triangles  with greater area.   1N      7.24    4N  N  vertex  =  k  i     = 1 k  = 1  i  N  i  N  i     vertexN   for a vertex shared by k triangles results in a  iN  of each of the   to calculate the normal vector  vertex normal that is influenced equally by the normal vector  triangles surrounding it.    An alternative formulation, illustrated in Figure 7.14, makes use of the fact  that the cross product of two vectors is proportional to the area of the triangle that  they  form.  By  using  the  unnormalized  triangle  normals  calculated  with  the  equation   =  N P P 0  1  −        ×     P 2  −    P   0   7.25    instead of Equation  7.23  and then averaging using Equation  7.24 , we can cal- culate a vertex normal that is more strongly influenced by triangles with greater  area. This method produces more appealing vertex normals for some models.   7.7.2  Gouraud Shading  The interpolation of lighting values calculated at each vertex across the face of a  triangle is known as Gouraud shading. Before the advent of graphics hardware    7.7  Shading Models   177            capable of performing per-pixel lighting calculations, diffuse and specular colors  were calculated only at each vertex of a triangle mesh. This method calculates the  colors     primary    secondary  n  = +  +       i {  max      = 1  N H  ⋅  n  i  i  =    = 1  i  max  {  ⋅  N L  } ,0  i  }   m  ,0  i  ⋅  N L  i  >       0   7.26    at each vertex and interpolates them across the face of a triangle. The color  of  a pixel is then calculated using the equation   =     primary      1      2    +     k  secondary  ,    7.27    i  represents a color sampled from one of k texture maps, and the  where each  operation  is one of several available texture combination operations that include  modulation and addition.   7.7.3  Blinn-Phong Shading  Instead of interpolating lighting values calculated at each vertex, the Blinn-Phong  shading model interpolates the vertex normal N, the direction to the light source  L, and the direction to the viewer V across a triangle and evaluates the lighting  formula at each pixel. The halfway vector H is calculated using Equation  7.9  at  every pixel.    Graphics hardware that can perform complex calculations on a per-pixel ba- sis   a  process  called  pixel  shading  or  fragment  shading   can  be  configured  to  evaluate the entire expression   =     emission  +    +    specular  diffuse n    i= 1    i        =     +  +     ⋅  N L  i     +       ⋅  N H  i  m        ⋅  N L  i  >     0         7.28    at each pixel composing the face of a triangle. In the interests of simplicity, we  have omitted the maximum functions here, but it should be noted that the diffuse  i  of  and specular dot products in this equation are clamped to zero. The intensity  each of the n light sources is still calculated at each vertex and interpolated across  the face of a triangle. These values and the interpolated normal vector are used to    178      7. Lighting and Shading   7.8  Bump Mapping   evaluate    at  each  pixel.  Of  course,  not  every  component  of  Equation   7.28   needs to be present.    An advantage that Blinn-Phong shading possesses over Gouraud shading is  that it does a far better job of modeling specularity due to the fact that the dot  ⋅N H is evaluated at every pixel. When a sharp specular highlight falls in  product  the  interior  of  a  triangle,  Gouraud  shading  produces  poor  results  because  the  specular component calculated at the triangle’s vertices is unrepresentative of the  true values existing elsewhere on the face of the triangle.    A problem that arises  when using Blinn-Phong shading is that interpolated  normal vectors do not retain the unit length that they have at the vertices. Dense- ly tessellated models for which the normal vectors belonging to neighboring ver- tices differ in direction by only a small amount may not produce visually unac- ceptable artifacts, but most models exhibit a noticeable darkening of the specular- ity in the interior of each triangle. This problem is solved by explicitly normaliz- ing the interpolated normal vectors either through direct calculation or by using a  normalization cube map  see Section 7.5.3 .   The surface detail that an observer perceives when an object is viewed from any  direction other than edge-on is generally determined by the way in which its sur- face is illuminated. The illumination at each pixel rendered is determined by the  normal vector used during the evaluation of the lighting formula. So far, we have  been limited to calculating normal vectors only at the vertices of a triangle mesh  and using a smoothly interpolated normal vector elsewhere. This coarse resolu- tion prevents us from illuminating any details that are smaller in size than a typi- cal triangle in a mesh. Bump mapping is a technique that presents the illusion of  greater detail to the viewer by using a texture map to perturb the normal vector at  each pixel.   7.8.1  Bump Map Construction  High-resolution information about how the normal vector is perturbed is stored in  a two-dimensional array of three-dimensional vectors called a bump map or nor- mal  map.  Each  vector  in  the  bump  map  represents  the  direction  in  which  the  normal vector should point relative to the interpolated normal vector at a point  inside the face of a triangle. The vector  0,0,1  represents an unperturbed normal,  whereas any other vector represents a modification to the normal that affects the  result of the lighting formula.    7.8  Bump Mapping   179              A  bump  map  is  typically  constructed  by  extracting  normal  vectors  from  a  height map whose contents represent the height of a flat surface at each pixel. To  derive the normal vector corresponding to a particular pixel in the height map, we  first calculate tangents in the s and t directions, which are based on the difference    j   to  represent  the  in  height  between  adjacent  pixels.  Using  the  notation  j  in a w h×  pixel height map, we can express the  ,i value stored at coordinates      jT ,i , aligned to the s and t directions, respectively,  tangent vectors   and  as follows.     ,H i  ,i j  S             S T  i j , i j ,       = =  1,0, 0,1,    + aH i   aH i j ,    − j 1,   + − 1    − aH i 1,   − aH i j ,    j   1     The constant a is a scale factor that can be used to vary the range of the height  zS  and  zT   values, controlling how pronounced the perturbed normals are. If we let        jN ,i ,i j denote the z components of   is  , then the normal vector  calculated using the cross product   jT ,i   and   S              i  ,  N     j  =       i i  , ,  S S       j j  × ×       i i  , ,  T T       j j  =  − S S 2 z  − T , z z + T 2 z  ,1 + 1  .   The components of each normal vector are encoded as an RGB color using the  relations given in Equation  7.16 . Figure 7.15 shows a grayscale height map and  the corresponding bump map calculated using Equation  7.30 .    7.29     7.30             Figure 7.15. A height map and the corresponding bump map containing perturbed nor- mal vectors. A pastel purple color is prevalent in the bump map since the unperturbed  normal vector  0,0,1  corresponds to the RGB color      ,1 .   1 2  1  2,   180   7. Lighting and Shading         7.8.2  Tangent Space   Since  the  vector  0,0,1   in  a  bump  map  represents  an  unperturbed  normal,  we  need it to correspond to the interpolated normal vector that we would ordinarily  use  in  the  lighting  formula.  This  can  be  achieved  by  constructing  a  coordinate  system at each vertex in which the vertex normal always points along the positive  z axis. In addition to the normal vector, we need two vectors that are tangent to  the surface at each vertex in order to form an orthonormal basis. The resulting  coordinate  system  is  called  tangent  space  or  vertex  space  and  is  shown  in  Figure 7.16.    Once a tangent-space coordinate system has been established at each vertex  of a triangle mesh, the direction to light vector L is calculated at each vertex and  transformed into the tangent space. The tangent-space vector L is then interpolat- ed across the face of a triangle. Since the vector  0,0,1  in tangent space corre- sponds to the normal vector, the dot product between the tangent-space direction  to light L and a sample from a bump map produces a valid Lambertian reflection  term.    The tangent vectors at each vertex must be chosen so that they are aligned to  the texture space of the bump map. For surfaces generated by parametric func- tions,  tangents  can  usually  be  calculated  by  simply  taking  derivatives  with  re- spect  to  each  of  the  parameters.  Arbitrary  triangle  meshes,  however,  can  have  bump maps applied to them in any orientation, which necessitates a more general  method for determining the tangent directions at each vertex.   7.8.3  Calculating Tangent Vectors  Our goal is to find a 3 3×  matrix at each vertex that transforms vectors from ob- ject space into tangent space. To accomplish this, we consider the more intuitive  problem of transforming vectors in the reverse direction from tangent space into  object space. Since the normal vector at a vertex corresponds to  0,0,1  in tangent  space, we know that the z axis of our tangent space always gets mapped to a ver- tex's normal vector.    We want our tangent space to be aligned such that the x axis corresponds to  the s direction in the bump map and the y axis corresponds to the t direction in  the bump map. That is, if Q represents a point inside the triangle, we would like  to be able to write   −  Q P 0  =     s  −     T    + −  t     t  0  s  0  B,    7.31     7.8  Bump Mapping   181               and   =N  0,0,1  =T  1,0,0     Figure 7.16. Tangent space is aligned to the tangent plane and normal vector at a vertex.   0,s t 0  0P  is the position  where T and B are tangent vectors aligned to the texture map,   are the texture coordinates at that  of one of the vertices of the triangle, and  vertex. The letter B stands for bitangent, and it represents the direction orthogo- nal to the tangent vector T in the tangent plane to the surface.3    0P ,  1P , and  points  0,s t 1,s t , and  ,  1 0 ing relative to the vertex  0P , so we let   Suppose  that  we  have  a  triangle  whose  vertex  positions  are  given  by  the  2P , and whose corresponding texture coordinates are given by  . Our calculations can be made much simpler by work-  2,s t 2  1  Q P 1 Q P 2  = =  2  − −  P 0 P   0  s t , 1 t s ,  2  1  2  = =  s s  1  2  − −  s t , 0 1 s t , 0  2  − t 0 − t  0  .   Q Q  1  2  = =  s s  T 1 T  2  + +  B t 1 B  t  2   7.32     7.33     7.34    We need to solve the following equations for T and B.                                                          3 In some texts, the term binormal is still used to describe the tangent direction B, but this  is a misnomer often retained for historical reasons or out of ignorance. As discussed in  Section 15.8, a binormal forms part of the local coordinate system following a curve in  which there is a single tangent direction and two orthogonal normal directions.    182   7. Lighting and Shading               This is a linear system with six unknowns  three for each T and B  and six equa- tions  the x, y, and z components of the two equations . We can write this in ma- trix form as follows.        7.35                             =     1  1  1  1  x  y  z  2  x  2  y  2  z  t t  2  T x B  x         T z B  z        Q Q      s 1 s  2      T y B  y  Q Q  Q Q      Multiplying both sides by the inverse of the   T x B  x      T y B  y  =  T z B  z      1 −  s t 1 2  s t 2 1  t 2 − s      2  1  − t s 1         ,s t  matrix, we have                          Q Q  Q Q  Q Q  1  1  y  x  2  2  x  y       1  2  .       z  z   7.36    0P ,  1P , and   This gives us the  unnormalized  T and B tangent vectors for the triangle whose  2P . To find the tangent vectors for a single vertex, we av- vertices are  erage the tangents for all triangles sharing that vertex in a manner similar to the  way in which vertex normals are commonly calculated. In the case that neighbor- ing triangles have discontinuous texture mapping, vertices along the border are  generally already duplicated since they have different mapping coordinates any- way. We do not average tangents from such triangles because the result would  not accurately represent the orientation of the bump map for either triangle.    Once we have the normal vector N and the tangent vectors T and B for a ver- tex, we can transform from tangent space into object space using the matrix   T   T  T    x  y  z  B B B  x  y  z  N N N  x  y  z        .    7.37    To transform in the opposite direction  from object space to tangent space—what  we want to do to the light direction , we can simply use the inverse of this matrix.  It is not necessarily true that the tangent vectors are perpendicular to each other  or to the normal vector, so the inverse of this matrix is not generally equal to its  transpose.  It  is  safe  to  assume,  however,  that  the  three  vectors  will  at  least  be  close to orthogonal, so using the Gram-Schmidt algorithm  see Algorithm 2.16   to orthogonalize them should not cause any unacceptable distortions. Using this  process, new  still unnormalized  tangent vectors   ′B  are given by   ′T  and   ′ = − T T N T N ′ ′ = − B B N B N T B T .   ⋅ ⋅  −        ⋅  ′             7.38     7.8  Bump Mapping   183         Normalizing  these  vectors  and  storing  them  as  the  tangent  and  bitangent  for  a  vertex lets us use the matrix   ′ T x ′ B x N  x        T B N  ′ y ′ y  y  ′ T z ′ B z N  z            7.39    ′×N T  can be used to obtain m ′B , where   to transform the direction to light from object space into tangent space. Taking  the dot product of the transformed light direction with a sample from the bump  map then produces the correct Lambertian diffuse lighting value.  It is not necessary to store an extra array containing the per-vertex bitangent    m = ±  represents  since the cross product  the handedness of the tangent space. The handedness value must be stored per- ′×N T  may point in the wrong direc- vertex since the bitangent  tion. The value of m is equal to the determinant of the matrix in Equation  7.39 .  ′T  as a four- One may find it convenient to store the per-vertex tangent vector  dimensional entity whose w coordinate holds the value of m. Then the bitangent  ′B  can be computed using the formula  wT′ ′ =    ′B  obtained from     N T ,    7.40    B  ×  1     ′  where the cross product ignores the w coordinate. This works nicely for vertex  programs by avoiding the need to specify an additional array containing the per- vertex m values.    Code that demonstrates how per-vertex tangent vectors can be calculated for  an arbitrary mesh is shown in Listing 7.1 This code calculates the tangent and  bitangent directions for each triangle in a mesh and adds them to a cumulative  total  for  each  vertex  used  by  the  triangle.  It  then  loops  over  all  vertices,  or- thonormalizes the tangent and bitangent for each one, and outputs a single four- dimensional  tangent  vector  for  each  vertex  whose  fourth  coordinate  contains  a  handedness value.                    184      7. Lighting and Shading   const Point2D *texcoord, long triangleCount,   Listing 7.1. This code generates an array of vertex tangents for an arbitrary input mesh.    const Vector3D *normal,   const Triangle *triangle, Vector4D *tangent    Vector3D *tan1 = new Vector3D[vertexCount * 2];  Vector3D *tan2 = tan1 + vertexCount;  ZeroMemory tan1, vertexCount * sizeof Vector3D  * 2 ;   for  long a = 0; a < triangleCount; a++   {   long i1 = triangle->index[0];   long i2 = triangle->index[1];   long i3 = triangle->index[2];    const Point3D& v1 = vertex[i1];   const Point3D& v2 = vertex[i2];   const Point3D& v3 = vertex[i3];   const Point2D& w1 = texcoord[i1];   const Point2D& w2 = texcoord[i2];   const Point2D& w3 = texcoord[i3];   void CalculateTangentArray long vertexCount, const Point3D *vertex,      {                                                                        float r = 1.0F    s1 * t2 - s2 * t1 ;            float x1 = v2.x - v1.x;   float x2 = v3.x - v1.x;   float y1 = v2.y - v1.y;   float y2 = v3.y - v1.y;   float z1 = v2.z - v1.z;   float z2 = v3.z - v1.z;   Vector3D sdir  t2 * x1 - t1 * x2  * r,  t2 * y1 - t1 * y2  * r,    Vector3D tdir  s1 * x2 - s2 * x1  * r,  s1 * y2 - s2 * y1  * r,      float s1 = w2.x - w1.x;   float s2 = w3.x - w1.x;   float t1 = w2.y - w1.y;   float t2 = w3.y - w1.y;    t2 * z1 - t1 * z2  * r ;    s1 * z2 - s2 * z1  * r ;    7.8  Bump Mapping   185                    }   tan1[i1] += sdir;  tan1[i2] += sdir;  tan1[i3] += sdir;  tan2[i1] += tdir;  tan2[i2] += tdir;  tan2[i3] += tdir;  triangle++;                                               }   for  long a = 0; a < vertexCount; a++   {   const Vector3D& n = normal[a];   const Vector3D& t = tan1[a];       Gram-Schmidt orthogonalize.    tangent[a] =  t - n * Dot n, t  .Normalize  ;      tangent[a].w =  Dot Cross n, t , tan2[a]  < 0.0F  ? -1.0F : 1.0F;       Calculate handedness.   }      delete[] tan1;   7.8.4  Implementation   During shading, bump mapping operations can be divided into those calculated  for each vertex and those calculated for each pixel. At each vertex, we must cal- culate the direction to the camera V and the direction to the light L and transform  them into tangent space using the matrix in Equation  7.39 . The vertex shader  shown in Listing 7.2 performs these calculations for a surface illuminated by a  directional light source  for which L is constant .  The tangent-space vectors V and L are interpolated over the face of each tri-   angle. The fragment shader must normalize these and use Equation  7.9  to calcu- ⋅N H are then  late the normalized halfway vector H. The dot products  calculated for every fragment, where the normal vector N is  sampled from the  bump map. The results of these dot products are finally used to calculate the dif- fuse and specular components of the standard shading equation.   ⋅N L and    186      7. Lighting and Shading   Listing 7.2. This vertex shader performs the calculations necessary for bump mapping.   vertexPosition;  normal;    tangent;              The object-space vertex position.       The object-space vertex normal.        The object-space vertex tangent.             The tangent-space view direction.  view;         The tangent-space light direction.  light;     mvpMatrix[4];      The model-view-projection matrix.  cameraPosition;     The object-space camera position.  lightDirection;     The object-space light direction.             in vec4   in vec3   in vec4   out vec3      out vec3      uniform vec4    uniform vec3    uniform vec3      void main    {                                    }                Transform the vertex into clip space.  gl_Position = vec4 dot mvpMatrix[0], vertexPosition ,         dot mvpMatrix[1], vertexPosition ,  dot mvpMatrix[2], vertexPosition ,  dot mvpMatrix[3], vertexPosition  ;      Calculate the bitangent B =  N x T  * T.w.  vec3 bitangent = cross normal, tangent.xyz  * tangent.w;      Transform V into tangent space.  view = cameraPosition - vertexPosition;  view = vec3 dot tangent, view , dot bitangent, view ,     dot normal, view  ;         Transform L into tangent space.  light = vec3 dot tangent, lightDirection ,     dot bitangent, lightDirection , dot normal, lightDirection  ;    7.9  A Physical Reflection Model   187   7.9  A Physical Reflection Model         The manner in which we have calculated the reflection of light on a surface be- fore this point is computationally cheap and produces visually pleasing results in  many cases, but it is not an accurate model of the physically correct distribution  of reflected light. Achieving greater realism requires that we use a better model  of  a  surface’s  microscopic  structure  and  that  we  apply  a  little  electromagnetic  theory.   7.9.1  Bidirectional Reflectance Distribution Functions  In general, our goal is to model the way in which the radiant energy contained in  a beam of light is redistributed when it strikes a surface. Some of the energy is  absorbed by the surface, some may be transmitted through the surface, and what- ever energy remains is reflected. The reflected energy is usually scattered in eve- ry direction, but not in a uniform manner. A function that takes the direction L to  a  light  source  and  a  reflection  direction  R,  and  returns  the  amount  of  incident  light from the direction L that is reflected in the direction R is called a bidirec- tional reflectance distribution function  BRDF .    The precise definition of a BRDF requires that we first introduce some ter- minology  from  the  field  of  radiometry,  the  study  of  the  transfer  of  energy  via  radiation. The radiant power  energy per unit time  emitted by a light source or  received  by  a  surface  is  called  flux  and  is  measured  in  watts   W .  The  power  emitted by a light source or received by a surface per unit area is called flux den- sity and is measured in watts per square meter    . The flux density emitted  by a surface is called the surface’s radiosity, and the flux density incident on a  surface is called the irradiance of the light.  Figure 7.17 illustrates a situation in which a light source is emitting P watts    of power toward a surface of area A. The power received by the surface is equal  to the power emitted by the light source, but the flux densities received and emit- ted are different because of the Lambertian effect. The area of the beam is equal  ⋅N L , where N is the unit surface normal and L is the unit direction-to-light  to  vector. The flux density Φ E emitted by the light source is thus given by   2W m −  A        ⋅  Φ E  =  P ⋅N L     .      A   7.41    Since the flux density Φ I incident on the surface is equal to  P A, we have the  relation    188   7. Lighting and Shading         A     ⋅N L     N  L  A     Figure 7.17. The flux density incident on an area A of a surface is equal to the flux densi- ty of an incident light beam scaled by a factor of   ⋅N L.   r  θ  l  r  A  ω  Figure 7.18. Planar angles are equal to the arc length that they sweep out divided by the  radius  of  the  circle.  Similarly,  solid  angles  are  equal  to  the  surface  area  that  subtends  them divided by the square of the radius of the sphere.      Φ  E= ΦI       ⋅N L .    7.42    The direction from which light illuminates a surface is defined in terms of    solid angles, the three-dimensional analog of planar angles. As Figure 7.18 illus- trates,  the  measure  of  a  planar  angle θ in  radians  is  given  by  the  arc  length  l  swept out on a circle divided by the radius r of the circle: θ . Extending this  to three dimensions, the measure of a solid angle ω corresponding to an area A on  the surface of a sphere of radius r is defined as  . The unit of solid angle  measure  is  the  steradian,  abbreviated  sr.  Since  the  surface  area  of  a  sphere  of   ω A r  l r=  =  2   7.9  A Physical Reflection Model   189            2  4πr , there are 4π steradians in the solid angle representing   radius r is equal to  the entire sphere.    A differential solid angle dω can be written in terms of the differential azi- muthal angle dθ and the differential polar angle dφ. As shown in Figure 7.19, the  circle at the polar angle φ that lies parallel to the x-y plane and passes through the  φ. Thus, the differential arc length in the azimuthal  point  direction on this circle is equal to  sinr φdθ. Multiplying this by the differential  arc  length r dφ  in  the  polar  direction  gives  us  the  following  expression  for  the  differential surface area dA.   r θ φ  has radius  sinr ,  ,  Dividing  by  angle dω:   2r   gives  us  the  expression  for  the  corresponding  differential  solid   = dA r  2 sin    φdθ dφ  dω  =  sin  φdθ dφ  .     7.43     7.44    ⋅  ⋅  − 1  − 2  Radiance is the term used to describe the flux density of radiation per unit    solid  angle  and  is  measured  in  watts  per  square  meter  per  steradian   . The irradiance  flux density  Φ I of the light received by a differ- W m sr   ential  area  dA  on  a  surface  is  equal  to  the  following  integral  of  the  radiance  IC L  received by the area, where the direction to light L ranges over the unit  hemisphere Ω above the surface.  The angles θ and φ are the azimuthal and polar  angles corresponding to the direction L.          z  sinr  φ  r  φ  r dφ r ×  φdθ  sin  x     Figure  7.19.  The  differential  surface  area  at  the  point  r 2 sin  φdθ dφ.   r θ φ   on  a  sphere  is  equal  to  ,  ,   190   7. Lighting and Shading                        Φ  I  =  =  I     Ω 2  0  C π   0  π        L 2  dω    C θ φ ,  I  sin  φdφdθ         7.45     7.46    For the same reason that the flux density received by a surface and the flux densi- IC  re- ty emitted by a light source are related by Equation  7.42 , the radiance  ceived by a surface and the radiance  EC  emitted by a light source are related by   C  I  =  C  E     ⋅  N L     =  C  E  cos  φ  .   We can therefore rewrite Equation  7.45  as         =     ⋅  I  E  Φ  C π  The bidirectional reflectivity      Ω 2  =  π  0  0  dω  L N L   2  C θ φ ,     E  cos sin  φ  φdφdθ  .    7.47      ρ V L  at a point on a surface is a function of    the direction to viewer V and the direction to light L. It is equal to the ratio of the  differential reflected radiance   RdC  to the differential incident irradiance  Φ Id  :      ,     ρ  V L  ,     =  dC d Φ  R  I  =  C  E  dC     R ⋅  L N L     .      dω   7.48    The function  light reflected in a specific direction from a surface using the equation     ρ V L  is the BRDF that we use to calculate the radiance of the      ,  dC  R  =     ρ  V L  ,     C  E         L N L  ⋅     dω  .    7.49    Directional, point, and spot light sources illuminate a point on a surface from a  single  direction.  Thus,  instead  of  integrating  Equation   7.49   to  determine  the  RC V  from n sources reflected in the direction to viewer V, we  amount of light  simply sum over the discrete directions to light         iL :   C  R  n       V  =  = 1  i     ρ  V L  ,  i     C  i       N L .   ⋅  i   7.50      Up to this point in our discussion of BRDFs, we have not said anything about  color. In addition to the incoming and outgoing light directions, a BRDF should  be a function of the wavelength of the light. Applications requiring accurate re- flection models across the entire spectrum typically evaluate a BRDF at several    7.9  A Physical Reflection Model   191            wavelengths and then fit a curve to the resulting numbers. For real-time computer  graphics, we find it sufficient to treat our BRDFs as functions that take the RGB  color of the incident light and return the RGB color of the reflected light. From  this point on, we assume that all operations involving a BRDF take place for each  of the red, green, and blue components of light.     7.8  can be reproduced by defining the RGB-color BRDF  as   The  diffuse  and  specular  reflection  formulas  given  in  Equations   7.6   and        V L  ,     =  +          ⋅ N H ⋅ N L  m  .    7.51     7.52    The term bidirectional means that the function  should be invariant when the  directions  V  and  L  are  exchanged.  That  is,    should  satisfy  the  reciprocity  property        V L  ,     =       L V  ,       required by the fact that reversing the direction that light travels along a certain  path  should  not  produce  different  results.  The  function    given  by  Equation   7.51  does not satisfy the bidirectional requirement, however, and therefore can- not be physically correct.    Another physical law violated by Equation  7.51  is conservation of energy.  Any physically correct BRDF must not reflect more light from a point on a sur- face than is incident at that point. We can divide the reflected energy given by the  BRDF  into diffuse and specular components by writing    ,     + − 1   7.53    V L  V L    =      k  k              ,  ,     s  where  is the surface’s diffuse reflection color and k represents the fraction of  the incident light that is diffusely reflected. The remaining fraction 1 k−  of the  incident light is either absorbed or makes up a specular reflection. These effects  are modeled by the function   s , which is described in the next section.   7.9.2  Cook-Torrance Illumination  The  Cook-Torrance  illumination  model4 produces  a  realistic  specular  reflection  by  treating  a  surface  as  being  composed  of  planar  microscopic  facets  called                                                          4  Robert  L.  Cook  and  Kenneth  E.  Torrance,  “A  Reflectance  Model  for  Computer  Graphics,” ACM Transactions on Graphics, Vol. 1, No. 1  January 1982 , pp. 7–24.    192   7. Lighting and Shading            Figure 7.20. Surface roughness is characterized by how much the slopes of the micro- facets vary.      microfacets. Each microfacet is treated as a perfect reflector that obeys the reflec- tive laws of electromagnetic theory. The roughness of a surface is characterized  by  the  slopes  of  the  microfacets.  As  shown  in  Figure  7.20,  a  rough  surface  is  composed of microfacets having greatly varying slopes, whereas the microfacets  for a relatively smooth surface have only small slopes.    of the BRDF given in Equation  7.53 .   Cook and Torrance use the following formula for the specular component   s       V L  ,     =       V L  ,       s            V L V L , ,     ⋅ ⋅ N V N L  G     D π      7.54     is the Fresnel factor, which describes the amount and color of light reflected as  a  function  of  the  angle  of  incidence;  D  is  the  microfacet  distribution  function,  which returns the fraction of microfacets oriented in a given direction; and G is  the geometrical attenuation factor, which accounts for self-shadowing of the mi- crofacets.  Since  the  microfacets  are  perfect  reflectors,  only  those  microfacets  whose normal vectors point in the direction of the halfway vector H contribute to  the specular reflection.  The π  appearing  in  the  denominator  of  Equation   7.54   is  a  normalization    factor that accounts for the fact that the incident flux density Φ I at a surface for a  constant emitted radiance  EC  is given by   Φ  I  =  C  E    Ω     ⋅  N L     dω  =  2  π π     0 0  cos sin  φ  φdφdθ  =  πC  .   E   7.55    7.9.3  The Fresnel Factor  The interaction of an electromagnetic wave and a surface results in a reflected  wave and a transmitted wave. The energy contained in the reflected wave is equal  to the energy contained in the incident wave minus the energy contained in the    7.9  A Physical Reflection Model   193               transmitted wave  which is quickly absorbed by opaque materials . The electric  field of the incident light can be decomposed into components that are polarized  with  respect  to  the  plane  containing  the  surface  normal  N  and  the  direction  to  light L. The component parallel to this plane is called p-polarized, and the com- ponent perpendicular to this plane is called s-polarized. The Fresnel factors giv- sF  of the amount of light re- ing, for a single wavelength, the fractions  flected for these components are   pF  and   =  F  p  2  2  tan tan       θ θ  1  1  − +  θ θ  2  2           7.56    and   2     =  F s  sin sin where  1θ  is the angle of incidence and  2θ  is the wavelength-dependent angle of  transmittance. For unpolarized light, we simply average these to obtain the Fres- nel factor    7.57    θ θ  θ θ  ,   1  2  1  2  2       − +       λF  corresponding to the wavelength λ:  sin 2 sin    θ θ 2 cos − The angle of incidence  1θ  is equal to   tan 1 2 tan  − +  θ θ                F  =  +  2  2  1  2  2  1  1  λ       θ θ  − +  θ θ  2  2           .   1  1    ⋅L H  since every microfacet con-   tributing to the specular reflection is oriented such that its normal vector points  along the halfway vector H. It turns out that we can write the Fresnel factor in  ⋅L H and the indexes of refraction  1η  and  2η  of the two materials by ap- terms of  plying  some  trigonometric  identities  and  using  Snell’s  law.  Factoring  the  sine  function out of Equation  7.58  gives us        7.59    − +  + −                 F  +  =     2  2  2  1  2  2  2  1  λ  sin 1 2 sin  θ θ  θ θ  θ θ  1  θ θ  1  cos cos       .  1    2  2  Applying the trigonometric identities for sums and  differences of angles to the  sine factors yields    7.58    sin sin       θ θ  1  1  − +  θ θ  2  2       θ θ  1  1  sin sin  θ θ  2  2  =  =  1  sin sin η η  θ θ 1 cos cos  cos cos θ θ  2  λ  2  λ  θ θ − +  2  − + 2 cos cos  cos cos θ θ  1  1  ,      7.60     194   7. Lighting and Shading                        We can express   cosθ  in terms of   cosθ  and η by writing Snell’s law in the form   2  where Snell’s law has been used to obtain   =  η  λ  =  sin sin  θ θ  1  2  .   η 2 η 1  1  η 1  − 1 cos  2  θ  1  =  η  2  − 1 cos  2  θ  2     cos  θ  2  =  −  1    − 1 cos     .   2  θ  1  1 η 2 λ  and solving for   cosθ :  2  Defining the variable g as   =  g  η  λ  cos  θ  2  =  η  2 λ  − + 1     ⋅L H   2     lets us express the quotient of the sine functions as  − ⋅ L H + ⋅ L H  sin sin  − +  g g  θ θ  θ θ            =     1  2  1  2  .   A  similar  procedure  allows  us  to  express  the  cosine  factors  in  terms  of  g  and  ⋅L H. We begin by applying angle sum and difference identities:   Again using the variable g defined in Equation  7.64 , we can write this as   cos cos       θ θ  1  1  + −  θ θ  2  2       =  =  cos cos cos cos  θ θ θ θ  1  1  1  1  cos cos cos cos  θ θ θ θ  2  2  2  2  − + − +  θ θ  2  2  1  sin sin η η  θ θ 1 sin sin  λ  λ  sin sin θ 2 θ  2  2  2  .     cos cos       θ θ  1  1  + −  θ θ  2  2       =  =  =  1  1  θ g cos θ g cos θ g cos θ g cos 1      ⋅ L H      ⋅ L H  1  − + − + g g  2  2 λ 2 λ    − η 1 cos   − η 1 cos + g η 2 λ − g η 2 λ + ⋅ L H − ⋅ L H  − +       2       2  2  θ θ  2  2  1. 1      7.61     7.62     7.63     7.64     7.65     7.66     7.67     7.9  A Physical Reflection Model   195               The  Fresnel  factor  can  now  be  entirely  expressed  in  terms  of  follows.   ⋅L H  and   λη   as      F  λ  V L  ,     =       g g  1 2       2  2  L H L H  − ⋅ + ⋅          [ [       ⋅ ⋅  L H L H         g g  + ⋅ − ⋅  L H L H       − +  ] 1 ] 1  2  2  +  1          7.68      ,V L   simply consists of the function   The RGB color Fresnel factor  evaluated at red, green, and blue wavelengths.  λF .    We can make a couple of observations about the behavior of the function  ⋅L H  ap- First,  as  the  angle  of  incidence  approaches  90  degrees,  the  value  of  λF  approaches 1. This means that at grazing an- proaches 0, and thus the value of  gles, all the incident light is reflected, leaving none to be absorbed by the surface.  ⋅L H  Second, for normal incidence in which the incident angle is 0, the value of  is 1, and   λF  reduces to   ,    λF V L       λη  if all that  This gives us a convenient way of deriving an approximate value for  is known about a material is the specular color  reflected at normal incidence.  Solving Equation  7.69  for      F  λ     =  L H   =    η η  λ  λ  − 21  + 1   .   λη  yields  + 1 − 1  =  η  λ       F F  λ  λ       .   =  L H  =  L H   7.69     7.70    λη  has been calculated with this equation by setting the value of  Once a value of     λF =L H  at  red,  green,  and  blue  wavelengths  equal  to  the  red,  green,  and  blue  components of , it can be used in Equation  7.68  to calculate reflectance for  any other angle of incidence.   7.9.4  The Microfacet Distribution Function  Given a halfway vector H, the microfacet distribution function returns the frac- tion of microfacets whose normal vectors point along the direction H. For rough  surfaces, the Beckmann distribution function5 given by    ⋅ N H   m 2  m 4                                                        5 Petr Beckmann and André Spizzichino, The Scattering of Electromagnetic Waves from  Rough Surfaces, Macmillan, 1963.   − 1 2   N H 2  1 N H   7.71    V L  exp  mD            ⋅  =              ,        ⋅  4  2   196      7. Lighting and Shading   describes  the  distribution  of  microfacet  orientations  in  terms  of  the  root  mean  square slope m. Large values of m correspond to rough surfaces and thus produce  a wide distribution of microfacet orientations. As shown in Figure 7.21, smaller  values of m correspond to smoother surfaces and produce relatively narrow dis- tributions, which result in a sharper specularity.  The function given by Equation  7.71  is isotropic, meaning that it is invari-   ant under a rotation about the normal vector N. As long as the angle between the  direction  to  viewer  V  and  direction  to  light  L  remains  constant,  and  the  angle  between each of these vectors and the normal vector remains constant, the distri- bution  of  microfacets  also  remains  constant.  Many  surfaces,  however,  possess  different degrees of roughness in different directions. These surfaces are called  anisotropic reflectors and include materials such as brushed metal, hair, and cer- tain fabrics.        a     b    N  N  L  L        Figure 7.21. Microfacet distributions given by Equation  7.71  modeling  a  a rough sur- face using    and  b  a relatively smooth surface using   0.25 .   m =  m =  0.6   7.9  A Physical Reflection Model   197              We  can  modify  the  microfacet  distribution  function  to  account  for  aniso- tropic surface roughness by changing Equation  7.71  to     −           2  2  exp       ⋅ T P m 2 x  1  +    T P m  ⋅ 2 y    ⋅ − N H 2     ⋅ N H 2  1  ,           m m 4 x  y  ⋅  N H     4     D  m     V L  ,     =   7.72    1    where m is a two-dimensional roughness vector, T is the tangent to the surface  xm , and P is the normalized  aligned to the direction in which the roughness is  projection of the halfway vector H onto the tangent plane:   Figure  7.22  shows  a  disk  rendered  with  both  isotropic  and  anisotropic  surface  roughness values. Some surfaces exhibit roughness at multiple scales. This can  be  accounted  for  by  calculating  a  weighted  average  of  microfacet  distribution  functions   =  P  − −  H N H N H N H N  ⋅ ⋅            .      D  V L  ,     =  m w D  i  i  n  = 1  i     V L ,     ,   7.73     7.74    iw  sum to unity.  where multiple roughness values  Figure 7.23 shows two objects rendered with different values of m and another  object rendered using a weighted sum of those same values.   im  are used and the weights     Figure 7.22. A disk rendered using the anisotropic distribution function given by Equa- xm   are  0.1   iso- tion   7.72 .  For  each  image  tropic , 0.12, 0.15, and 0.2. The tangent vectors are aligned to concentric rings around the  center of  the disk—they  are  perpendicular  to  the  radial direction  at  every  point on  the  surface.   .  From  left  to  right  the  values  of   ym =  0.1   198   7. Lighting and Shading           Figure 7.23. Copper vases rendered with isotropic microfacet distributions. The first two  m =   center . The right- images use a single roughness value of  1 most image combines these using the weights     left  and   and   0.25 .  0.6  m = 2 w = 2  0.1 w = 1  0.4  7.9.5  The Geometrical Attenuation Factor   Some  of  the  light  incident  on  a  single  microfacet  may  be  blocked  by  adjacent  microfacets before it reaches the surface or after it has been reflected. This block- ing results in a slight darkening of the specular reflection and is accounted for by  the geometrical attenuation factor. Blocked light is essentially scattered in ran- dom directions and ultimately contributes to the surface’s diffuse reflection.    We  can  derive  an  estimate  of  how  much  light  is  blocked  due  to  surface  roughness by assuming that microfacets always form V-shaped grooves. Figure  7.24 a  illustrates a situation in which light reflected by a microfacet is partially  blocked by an adjacent microfacet. In this case, light is blocked after being re- flected.  Reversing  the  direction  in  which  the  light  travels  exhibits  the  case  in  which  light  is  blocked  before  reaching  the  microfacet,  as  shown  in  Figure  7.24 b .    The application of a little trigonometry leads us to a formula giving the frac- tion of light reflected by a microfacet that still reaches the viewer after being par- tially blocked by an adjacent microfacet. As shown in Figure 7.25, we would like  to determine the portion x of the width w of a microfacet that is visible to the  viewer. We first observe that   =  w  1 sin  ,   α   7.75    and that by the law of sines  see Appendix B, Section B.6 ,    7.9  A Physical Reflection Model   199                  L  H  V  V  H  L   a    b     Figure 7.24.  a  Light reflected by the left  microfacet is partially blocked by the right  microfacet.  b  Light is blocked by the right microfacet before reaching the left micro- facet.   We can express each of the sine functions in Equations  7.75  and  7.76  as co- sine functions that have been shifted by  2π  radians by writing   =  x  γ 2sin   + β π  sin  .      2      − = α π α sin cos 2     + = β π β cos sin 2     − = π γ γ sin cos 2  = = =  ⋅ ⋅ ⋅  N H V H N V   .  1G  reaching the viewer as  ⋅ N H N V  2     ⋅     =  G 1  =  x w     ⋅ V H  .   =  G  2     2  =  N H N L  ⋅     ⋅ ⋅ L H     .   x w  Using the dot products corresponding to each of the cosine functions lets us ex- press the fraction of light     When  light  is  blocked  before  reaching  a  microfacet,  we  can  calculate  the  2G  that still reaches the viewer by simply exchanging the vectors V and  fraction  L in Figure 7.25 to obtain     The three possible cases pertaining to light reflected by a microfacet are that  the light is completely unobstructed  the fraction of light reaching the viewer is    7.76     7.77     7.78     7.79     200   7. Lighting and Shading         L  N  H  1  γ  V  x  β  w  γ α  α  Figure  7.25.  The  fraction  of  light  reflected  from  the  left  microfacet  that  reaches  the  viewer is equal to x w. The halfway vector H is normal to the microfacet surface since  only microfacets possessing that orientation contribute to the specular reflection.      one , that some of the reflected light is blocked, and that some of the incident  light is blocked. We account for all three cases by defining the geometrical atten- uation factor as the minimum fraction of light that reaches the viewer:   G     V L  ,  { =   min 1,  {  }  G G 1 2   ⋅ 2  , N H N V  ⋅        ⋅ L H  =  min 1,     2  ,  N H N L  ⋅  ⋅     ⋅ L H     }  .    7.80    ⋅L H. This is allowable because, by  We have changed the denominator of  the definition of the halfway vector, the angle between L and H is equal to the  angle between V and H, and thus   V H L H.   1G  to   = ⋅  ⋅  7.9.6  Implementation  Ray tracing applications can directly apply Equation  7.54  in its entirety when- ever a ray intersects a surface. For real-time applications where greater efficiency  is required, we need to sacrifice a little precision for better performance. For suf- ficiently  tessellated  surfaces,  evaluating  Equation   7.54   at  each  vertex  might  produce  good  results,  but  architectural  geometry  in  games  generally  does  not    7.9  A Physical Reflection Model   201               possess  such  tessellation.  Modern  GPUs  can  evaluate  Equation   7.54   at  every  pixel with a  fragment program. We  can avoid many of the microfacet shading  calculations by using texture maps to essentially store lookup tables that are in- dexed by quantities such as    Adding a texture map factor  and a gloss map factor  to Equation  7.53   and substituting the BRDF  into Equation  7.50  gives us the following formula  for the color of light  reflected toward the viewer by a surface illuminated by a  single light source, where  is the color of the light and k is the fraction of light  that is reflected diffusely.   ⋅N H and   ⋅L H.   =        ⋅  N L     [  k    +    1  −     k    s     V L  ,     ]     7.81    Substituting Equation  7.54  for      s V L  ,      gives us   =    k       ⋅  N L       + − 1     k       V L  ,     mD     V L ,   π      V L G   ⋅ N V  ,     .    7.82          ,       ,V L   depends is   The only quantity on which the Fresnel factor     ⋅L H, and    the  only  quantity  on  which  the  isotropic  microfacet  distribution  function  ⋅N H. Given a normal-incidence specular reflection color   mD V L  depends is  and  a  microfacet  root  mean  square  slope  m,  we  can  construct  a  texture  map  ⋅L H, respectively, and whose  ⋅N H and  whose s and t coordinates correspond to  V L color values represent the product  , , . An example of such a   texture map is shown in Figure 7.26.  For small values of m, the value of the microfacet distribution function  mD  is    ⋅N H is near 1. To maximize the resolution of the useful  significant only when    information in the texture containing the products  , we map  the range [ , where x is the value of  ⋅N H for which   for some small threshold ε. We cannot find the  value of x analytically, but we can apply Newton’s method  see Section 6.1.4  to  the function    ]0,1  of s texture coordinates to the range [    V L , ],1x  V L  V L  V L  ε=  mD  mD  mD  π  π  π                          ,  ,      f x  =  1 πm x 4 2  4  exp  − x 2 m x 2  1 2          −  ε  .    7.83    The refinement formula used to find the value of x for which  by       0 f x =  is given    202   7. Lighting and Shading            1.0  ⋅L H  0.0  0.9  ⋅N H  1.0    mD           Figure 7.26. A texture map representing the product  nate  corresponds  to  the  quantity  quantity  = color   . The s coordi- ,  and  the  t  coordinate  corresponds  to  the  ⋅L H. This image was generated using the normal-incidence specular reflection        and the microfacet root mean square slope  0.8,0.6,0.1  N H  V L  V L  m =  0.2  10    −  π  9  .         ,  ,  ⋅  x  + 1  i  =  x  i  −  =  x  i  −      f x i     ′ x f i m x 2 3 i − m x 2 4 2  i    − 2 1 4    − 1  x  2 i     2 2 m x i  πεm x e 4 i  2     .    7.84    Using an initial value of  formula since the slope of the function      0 f x =  is known, we map values of  ue of x for which  to the range [  x =  may require several iterations of this refinement  0 1 1x = . Once the val- ],1x    ]0,1  using the formula   ⋅N H from the range [      f x  may be steep at   =  s  N H −  ⋅ 1  − x  x  .    7.85    It is convenient for us to perform the microfacet lighting calculations in tan-   =N   and,  for  calculations  pertaining  to  gent  space  since,  in  this  setting,  anisotropic microfacet distributions,  . The vertex shader shown in List- ing 7.2 can be used again to transform the view direction V and light direction L   1,0,0  0,0,1  =T   7.9  A Physical Reflection Model   203               In  tangent  space  without  bump  mapping,   into tangent space for each vertex. The fragment shader shown in Listing 7.3 can  then be used to implement isotropic microfacet shading.  zL   ,  zH . The specular component of Equation  7.82  becomes  ,  = N H    ⋅ =N L  ,  and   N V  ⋅ =  zV  G     ⋅  s  specular    = − 1     k       H  ,z  ⋅  L H      7.86    ,           ,zH  ⋅L H      represents  the  product     that  is  looked  where  up in a texture map. The fragment program shown in Listing 7.3 calculates the    ⋅L H halfway vector H, performs a texture fetch to obtain the value of  ,  and multiplies it by the precomputed value of   . The geometrical attenua- ,G V L  sometimes makes a subtle contribution and may be omitted.  tion factor  When present, its value is calculated in tangent space using the formula   1 k−  V L  V L  ,zH  mD      π              ,  ,             V L V  z       G  V L  ,     =  min    V L  ,  z  z       H 2 z ⋅ L H  and using the saturation operation to clamp the result to the range [ For anisotropic microfacet distributions, we can use a 3D texture map whose    p coordinate corresponds to the quantity   ⋅T P , where P is the projection of the  halfway  vector  H  onto  the  tangent  plane.  In  tangent  space,  Equation   7.73   becomes   ]0,1 .     2  and thus   =  P  H H x + H  , 2 x  ,0 y H 2 y  ,      ⋅  T P     2  =  H 2 x + H 2 x  .   2 y  H       Dm V L   The 3D texture map contains the product  is  the  anisotropic  distribution  function  given  by  Equation   7.72 .  A  fragment  shader  almost  identical  to  that  shown  in  Listing  7.3  can  be  used  to  implement  anisotropic microfacet shading. The only changes are that a 3D texture map is  used instead of a 2D texture map, and the value given by Equation  7.89  is add- ed for the third texture coordinate.   , where   V L  V L  D    π              m  ,  ,  ,   7.87     7.88     7.89     204      7. Lighting and Shading   Listing  7.3.  This  fragment  shader  performs  the  calculations  necessary  for  isotropic  microfacet  shading.  The  uniform  parameter  named  diffuse  contains  the  product  k,  the  uniform  parameter  named  specular  contains  the  product   ,  and  the  uniform  parameter  named  ]0,1 .  The  2D  range  contains  the  scale  and  bias  used  to  map  the  values  of      is  bound  to  the  sampler  named  texture  map  containing  the  product  microfacetTexture.   ⋅N H  to  the  range [  1 k−  V L  V L  mD    π              ,  ,  view;    light;       Tangent-space view direction.    Tangent-space light direction.      diffuse;     Diffuse material color.  specular;     Specular material color.  range;   microfacetTexture;     The look-up texture sampler.      Scale and bias for look-up texture.               vec2  txtr;   in vec3   in vec3     uniform vec3      uniform vec3    uniform vec2      uniform sampler2D     void main    {                                                }      Normalize V and L.  vec3 vdir = normalize view ;  vec3 ldir = normalize light ;      Calculate H.  vec3 hdir = normalize vdir + ldir ;       Scale and bias N*H.  txtr.x = hdir.z * range.x + range.y;      Calculate L*H.  txtr.y = dot ldir, hdir ;      Look up product F V,L D V,L  pi and divide by N*V.  vec3 color = texture2D microfacetTexture, txtr .xyz   vdir.z;      Calculate geometrical attenuation  may be omitted .  color *= saturate min vdir.z, ldir.z  * 2.0 * hdir.z   txtr.y ;       Multiply specular by  1-k C and add kCD N*L .  gl_FragColor.xyz = color * specular + diffuse * ldir.z;    Chapter 7 Summary   205   Chapter 7 Summary   Point Light Source Attenuation  The intensity  of a point light source at a distance d from its position is given by               0  is the color of the light, and the constants   ck ,   lk , and   qk  control the at-  where  tenuation.   Spot Light Source Attenuation  The intensity  of a spot light source at a point Q lying at a distance d from the  light’s position is given by   =    1 k d l  +  k  c   ,  0  +  2  k d q  =    { − ⋅ R L max + + k d k l  } ,0 p k d 2 q  c   ,  0  lk , and  qk  are the attenuation constants; R is  where  0  is the color of the light;  the direction in which the spot light is pointing; L is the unit vector pointing from  Q to the light position; and the exponent p controls the rate at which the intensity  falls off as the angle between R and −L increases.   ck ,   Ambient and Diffuse Lighting  The  ambient  and  diffuse  contribution  to  the  illumination  color  calculated  at  a  point Q on a surface is given by the expression     diffuse  =       +  i  max  {  ⋅  N L  i  } ,0 ,   n  i= 1  where  is the surface’s diffuse reflection color, N is the normal vector to the  surface,  i  is the inten- sity of the i-th light at the point Q, and  represents the ambient light color.   iL  is the unit vector pointing from Q toward the i-th light,   Specular Lighting  The specular contribution to the illumination color calculated at a point Q on a  surface is given by the expression    206   7. Lighting and Shading              specular  =      i  max  {  ⋅  N H  }   m  ,0  i  ⋅  N L  i  >     ,   0  n    i= 1  iH  is the unit halfway vector at  where  is the surface’s specular reflection color;  iL  and the direction  the point Q, which lies halfway between the direction to light  to  the  viewer;  and  m  controls  the  sharpness  of  the  specularity.  The  expression    N L  evaluates to 1 or 0, depending on whether the surface is facing the  light.    0  >  ⋅  i  Standard Shading Equation  The reflected color  calculated at a point Q on a surface illuminated by n lights  is given by       +  =  +  n    i= 1    i        ⋅  N L  i     +       ⋅  N H  i  m        ⋅  N L  i  >     0  ,      where the dot products  involved are defined as follows.   ⋅N L  and   i  ⋅N H  are clamped to zero, and the quantities   i  = emission color  = texture map color     = diffuse reflection color    = specular reflection color  m  = specular exponent    = ambient light color        = gloss map color    = emission map color  i   = color of i-th light at Q  iL   = direction vector to i-th light  iH   = halfway vector for i-th light  N  = normal vector   Bump Mapping  The tangent T and bitangent B for a triangle whose vertices lie at the points  1P , and  2P  are calculated using the formula  − t s 1    Q   Q    Q   Q    Q   Q  t 2 − s  T y B  T x B  T z B  1 −                 =  ,   s t 2 1  s t 1 2     1  1  2  2  1  1  2  2  x  y  x  x  y  y  z  z  z                         0P ,    Chapter 7 Summary   207   where   Q P P ,  0  1  1  =  −  Q P 2  2  =  −  P , and  0                    The direction-to-light vector L and halfway vector H are transformed from object  space to tangent space using the matrix   s t , 1 t s ,  2  1  2  = =  s s  1  2  − −  s t , 0 1 s t , 0  2  − t 0 − t  0  .   ′ T x ′ B x N  x        T B N  ′ y ′ y  y  ′ T z ′ B z N  z        ,   where   ′T  and   ′B  are orthogonal to N and each other.   Bidirectional Reflectance Distribution Functions  The radiance  R  of the light reflected in the direction V from a surface illuminat- ed by n lights is given by     R  n       V  =       i= 1  V L  ,  i       i     ⋅  N L  i     ,   i  is the radiance of the i-th light source. The BRDF  can be divided into   where  diffuse and specular components by writing        V L  ,     =  k      + − 1     k    s     V L  ,    ,   where k is the fraction of light that is reflected diffusely.   Cook-Torrance Illumination  The  specular  component  of  the  BRDF  used  in  the  Cook-Torrance  illumination  model is given by      V L  ,     =       V L  ,       s            V L V L , ,     ⋅ ⋅ N V N L  G     D π  ,   where  is the Fresnel factor, D is the microfacet distribution function, and G is  the geometrical attenuation factor.    208   7. Lighting and Shading               Fresnel Factor  The Fresnel factor for a single color is given by     L H    L H  L H L H  − ⋅ + ⋅  V L  1 2  g g  [ [                 F  =  ⋅ ⋅        ,     2  2  λ      + ⋅ − ⋅  L H L H       − +  ] 1 ] 1  2  2  g g  +  1  ,       where g is defined by     The index of refraction   g  η=  2 λ  − + 1     ⋅L H .   2     λη  can be calculated using the equation   η  λ  += 1 − 1  S S  λ  λ  ,   where  is the specular reflection color at normal incidence.   Microfacet Distribution Functions  The microfacet distribution function  mD  for isotropic surfaces is given by   mD     V L  ,     =  1 N H  ⋅        4  2  4  m  exp    N H m 2  − 1 2   N H 2    ⋅  ⋅        ,       where m is the root mean square slope of the microfacets. For anisotropic surfac- es, the microfacet distribution function becomes    2  −           2  exp       ⋅ T P m 2 x  1  +    T P m  ⋅ 2 y    ⋅ − N H 2     ⋅ N H 2  1  ,           m m 4 x  y  ⋅  N H     4  D  m     V L  ,     =  1    xm  and   ym  represent the root mean square slopes parallel and perpendicu- where  lar to the tangent direction T. The vector P is the normalized projection of the  halfway vector H onto the tangent plane.   Geometrical Attenuation Factor  The geometrical attenuation factor is given by the formula     ⋅ ⋅ L H  N H N V     ⋅ L H  =   min 1,  V L  {  G  2  2              ,  ,     ⋅  ⋅  N H N L  ⋅     }     and accounts for the incident or reflected light for a microfacet that is blocked by  adjacent microfacets.    Exercises for Chapter 7      Exercises for Chapter 7   209   1.  A point light source has attenuation constants   qk = . At  what distance from the light source is the radiant intensity one-fourth that of  the intensity at a distance of one meter?   lk = , and   1ck = ,   0  1 2  0,0,10   and radiating energy in the direction   2.  A  spot  light  source  positioned  10  meters  above  the  origin  at  the  point  =P =  is configured  = .  so that no distance attenuation takes place by setting  0     = 1,1,1   and the spot exponent is 8, then  If the color of the light is white   0 what is the radius of the circle lying in the x-y plane where the intensity of      the light is 50 percent gray   ⋅N H to be a positive number when   = 3.  Describe how it is possible for   − 0,0, 1 1ck =  and   k=   ?   R  k  1 2  1 2  1 2  ,  ,  q  l  ⋅ >N L   0  ⋅N L is a   term in the illumination   negative number, thus necessitating the   formula.   4.  Let L be the normalized direction to the light source and V be the normal- ized direction to the viewer at a surface point where the unit normal vector  is N. Show that         ⋅  N H     m     N L N V   2 1  ⋅ + ⋅   ⋅ + L V     2  m  2  ,        =       where H is the halfway vector defined by Equation  7.9 , and m is an arbi- trary specular exponent.   5.  Write a program that calculates vertex normals and vertex tangents for an  arbitrary triangle mesh. Assume that the triangle mesh is specified such that  each of n triangles indexes three entries in an array of m vertices. Each entry  in the vertex array contains the position of the vertex and two-dimensional  texture-mapping coordinates.   6.  Modify Listing 7.3 so that it performs bump mapping as well as isotropic   microfacet shading.  Implement a simple ray tracer that calculates diffuse and specular reflections  using  Equations   7.6   and   7.8 .  The  ray  tracer  should  be  able  to  model  spheres and should support directional, point, and spot light sources.   7.   8.  Extend the ray tracer from Exercise 7 to implement Cook-Torrance micro-  facet shading.    This page intentionally left blank    Chapter 8   Visibility Determination   When it comes to the performance of a real-time 3D engine, the single most im- portant component of the rendering architecture is visibility determination. Given  a particular camera position and orientation, every engine must be able to effi- ciently determine which parts of the world are potentially visible and therefore  should be rendered. This problem is usually attacked from the opposite perspec- tive—the  engine  determines  which  parts  of  the  world  are  definitely not visible  and renders whatever is left over.    Most engines perform visibility determination at multiple levels. The general  goal is to determine what world geometry cannot possibly intersect the view frus- tum. At the smallest scale, 3D hardware performs backface culling to eliminate  individual  triangles  that  face  away  from  the  camera.  At  the  level  above  that,  bounding volume tests are usually performed to determine whether an object lies  completely outside the view frustum. Moderate-size groups of geometry can be  culled from the visible set by organizing areas of the world into tree structures  such as binary space partitioning  BSP  trees or octrees. At the largest scale, en- tire regions of world geometry can be eliminated by using a technique known as  a portal system.   8.1  Bounding Volume Construction   Bounding volumes are constructed so that they enclose all the vertices belonging  to a triangle mesh, thereby ensuring that every triangle in the mesh is also con- tained in the bounding volume. The bounding volume should be made as small as  possible so that it falls completely outside the view frustum as often as possible,  thus enabling the object it contains to be culled from the visible set of geometry  as often as possible.    Figure 8.1 a  shows a box bounding a set of points that represent the vertices  of a triangle mesh. The box is aligned to the coordinate axes, but the vertices are        211    212   8. Visibility Determination   y   a   y   b         x  x     Figure 8.1. A bounding volume aligned to the coordinate axes is usually a poor choice  for most vertex distributions.   distributed  in  such  a  way  that  the  box  enclosing  them  contains  a  lot  of  empty  space. As Figure 8.1 b  demonstrates, choosing a bounding box that is aligned to  the natural axes of the data set can greatly reduce the size of the box. We present  a method for determining the natural alignment in the next section.   8.1.1  Principal Component Analysis   We can reduce the size of each of our bounding volumes by determining a coor- dinate system that is naturally aligned to the set of vertices belonging to each tri- angle mesh. We can calculate these coordinate axes by using a statistical method  called principal component analysis. Principal component analysis allows us to  find a coordinate space in which a set of data composed of multiple variables,  such as the x, y, and z coordinates stored in an array of vertex positions, can be  separated into uncorrelated components. The primary principal component of the  data is represented by the direction in which the data varies the most.  To determine the natural coordinate system for an arbitrary set of N vertices    P , where  P P , , we first calculate the mean  average  position  1 2 m using the formula   x y z , i  =P i  , N  ,  ,  i  i  1 N = m iN = 1  P .  i   8.1    We then construct a 3 3×  matrix C called the covariance matrix as follows.    8.1  Bounding Volume Construction   213    8.2                =  1 N C iN = 1       T P m P m   i      −  −  i  The covariance matrix is a symmetric matrix made up of the following six unique  entries.   C  11  =  C  22  =  C  33  =  1 N 1 N 1 N  N    i  = 1 N    = i 1 N    = 1  i           −  x m i  x     2  C  12  =  C  21  =     x m y m i  x  i  y  −  −         −  y m i  y     2  C  13  =  C  31  =     −  x m z m i  x  i  z  −         −  z m i  z     2  C  23  =  C  32  =     −  y m z m i  y  i  z  −             8.3    1 N 1 N 1 N  N    i  = 1 N    = i 1 N    = 1  i  The entries of the covariance matrix represent the correlation between each pair  of the x, y, and z coordinates. An entry of zero indicates no correlation between  the two coordinates used to calculate that entry. If C is a diagonal matrix, then all  three  coordinates  are  completely  uncorrelated,  meaning  that  the points  are  dis- tributed evenly about each axis.     We want to find a basis to which we can transform our set of vertices so that  the covariance matrix is diagonal. If we apply a transformation matrix A to each  of the points { }iP , then the covariance matrix  ′C  of the transformed set of points  is given by   ′ =  C     AP Am AP Am  i  i  −  −         T  A P m P m A  T  T  i  i  −  −            i  N  = 1 N    1 N 1  N = 1 ACA  i  =  =  T  .      8.4    Thus, we require an orthogonal transformation matrix A whose transpose diago- nalizes the matrix C. Since C is a real symmetric matrix, we know by Theorem  3.26 that its eigenvectors are orthogonal. The matrix whose rows consist of the  eigenvectors  of  C  meets  our  requirements  and  maps  our  vertices  into  a  space  where their coordinates are uncorrelated.    We have now turned the problem of finding the natural axes of a set of points  into that of calculating the eigenvectors of the covariance matrix. One possible  way to do this is to first calculate the eigenvalues given by the roots of the char-   214   8. Visibility Determination   acteristic polynomial, a cubic in the case of the 3 3×  covariance  matrix. Fortu- nately, since the covariance matrix is symmetric, it has only real eigenvalues  see  Theorem 3.25 , and we can therefore use the method presented in Section 6.1.2  to explicitly calculate all of them. Finding the corresponding eigenvectors is then  achieved by solving three homogeneous linear systems, as in the following ex- ample. Alternatively, a numerical method may be used to calculate the eigenval- ues and eigenvectors, as discussed in Section 16.3.   Example 8.1. Determine the natural axes for the following set of points.              Solution. We first calculate the average position m:   The covariance matrix C is then given by   P 1 P 2 P 3 P 4  = − − 1, 2,1 = 1,0,2 − = 2, 1,3 − = 2, 1,2     =  m  P i  1 4  4  i= 1  =  −  1, 1,2  .   =  C        3 2 1 2 3 4  1 2 1 2 1 4  .   3 4 1 4 1 2         8.5     8.6    The  eigenvalues  of  the  covariance  matrix  are  the  roots  of  the  characteristic  polynomial:   det     −  λ C I     =  3 2  λ  − 1 2 3 4  1 2  λ  1 2 − 1 4  3 4 1 4 −  1 2  λ  = − +  λ 3  λ 2  5 2  −  7 8  +  λ  .     1 16   8.7                 8.1  Bounding Volume Construction   215            Explicitly solving for the roots of the characteristic polynomial using the method  presented in Section 6.1.2 gives us the following eigenvalues.   = = =  λ 1 λ λ  3  2  2.097 0.3055 0.09756      8.8     8.9    The eigenvectors, which we call R, S, and T here, are found by solving the linear   i systems   I V 0. Omitting the details of these calculations, the unit-length  eigenvectors of the matrix C are   λ−  C  =  i  R  − 0.833   = − 0.330  − 0.443          =  S  − 0.257 0.941 − 0.218              T  0.489   = − 0.0675  − 0.870          ,   and these represent the natural axes of the set of vertices   iP .    In the remainder of this chapter, we use the letters R, S, and T to represent    the natural axes of a set of vertices. The direction R always represents the princi- pal axis, which corresponds to the largest eigenvalue of the covariance matrix.  The directions S and T represent the axes corresponding to the second largest and  the smallest eigenvalues, respectively. That is, if  1λ ,  2λ , and  3λ  are the eigenvalues  corresponding to the vectors R, S, and T, respectively, then   ≥  ≥  .   λ  λ  λ 1  3  2  8.1.2  Bounding Box Construction   ,  , N  P P 2  P  for a triangle mesh, we can now cal- , Given a set of vertex positions  1 culate the directions R, S, and T corresponding to the natural axes of the object.  To construct a bounding box, we need to determine the minimum and maximum  extents of the vertex set along these three directions. These extents immediately  produce  the  six  planes  of  the  bounding  box;  other  types  of  bounding  volumes  require a little more computation.    tion  imum values. The six planes of the bounding box are then given by   To find the extents, we simply compute the dot product of each vertex posi- iP  with the unit length vectors R, S, and T, and take the minimum and max-   216   8. Visibility Determination                  ⋅  S  R  { } − P R , min i ≤ ≤ i N 1 } { − ⋅ P S , min i ≤ ≤ i N 1 } { − P T T , min i ≤ ≤ i N 1  ⋅  −  ⋅  R  { } P R ,max i ≤ ≤ i N 1 } { P S ,max i ≤ ≤ i N 1 { } T ,max ≤ ≤ i N 1  ⋅  ⋅  P T   . i  − S  −   8.10    Example 8.2. Calculate the six planes of the naturally aligned bounding box  for the set of points given in Example 8.1.   Solution. The natural axes for this set of points are given by Equation  8.9 . The  dot products of each of the four points with the directions R, S, and T are listed  below.   ⋅ ⋅ ⋅ ⋅  P R 1 P R 2 P R 3 P R 4  = 1.05 = − = − = −  1.72 2.67 2.22  ⋅ = − ⋅ = − ⋅ = − ⋅ = −  P S 1 P S 2 P S 3 P S 4  1.84 0.693 2.11 1.89  ⋅ = − ⋅ = − ⋅ = − ⋅ = −  P T 1 P T 2 P T 3 P T 4  1.22 1.25 1.56 0.695      8.11    Using the minimum and maximum values of  to the direction R are given by   i ⋅P R, the two planes perpendicular   R  ,2.67  −  R  ,1.05  .    8.12    Similarly, the planes perpendicular to the S and T directions are given by   S ,2.11 T ,1.56  − − S , 0.693 − − T , 0.695  .     8.13      The dimensions of the bounding box are given by the differences between  the minimum and maximum dot products in each of the directions R, S, and T.  The center Q of the bounding box is the point at which the three planes lying  halfway between each pair of opposing faces intersect. We assign to the scalars  a,  b,  and  c  the  average  extent  in  the  R,  S,  and  T  directions,  respectively,  as  follows.    8.1  Bounding Volume Construction   217               min ≤ ≤ i N 1  {  ⋅  P R i  }  +  {  ⋅  P R i  }  max ≤ ≤ i N 1  {  } ⋅ P S i  min ≤ ≤ i N 1  2 + max ≤ ≤ i N 1  {  } P S i  ⋅  {  } P T i  ⋅  min ≤ ≤ i N 1  {  } P T i  ⋅  max ≤ ≤ i N 1     =  a  =  b  =  c  2 +  2   8.14    ,  and  . Using Equation  5.21  to calculate the point of intersection provides us   The  three  planes  that  divide  the  box  in  half  are  given  by  , c−T with the following expression for the center Q.   ,   , a−R  , b−S  Q  =  a  R  +  b  S  +  c  T    8.15    8.1.3  Bounding Sphere Construction  Bounding  spheres  are  commonly  used  in  tests  for  object  visibility  due  to  the  speed with which such a test can be performed. As with all bounding volumes,  we should construct bounding spheres that are as tight as possible so as to mini- mize the occurrence of its intersection with the view frustum. Achieving an abso- lutely optimal bounding sphere in all cases turns out to be a hard problem that we  do not discuss here, but we are able to construct bounding spheres that are ac- ceptably efficient without requiring an excessively complex algorithm.  P  by  P P , ,   We begin constructing a bounding sphere for a set of points  1 2 kP  and  lP  represent- first calculating the principal axis R and locating the points  ing  the  minimum  and  maximum  extents  in  that  direction   i.e.,  we  locate  the  points  having  the  least  and  greatest  dot  product  with  R .  We  then  construct  a  sphere whose center Q and radius r are given by   , N  =  =  Q  r  P k  P l  + 2 −  P Q .  k   8.16    That is, the center of the sphere lies halfway between the points producing the  minimum and maximum extents in the R direction, and the radius is the distance  from the center to either of those points.    Although it is a good approximation to the final bounding sphere, the sphere  P . We must  , given by Equation  8.16  may not enclose all the points  1 therefore  test  each  of  the  points { }iP  to  make  sure  they  fall  inside  the  sphere.   P P 2  , N  ,   218   8. Visibility Determination               iP  r′  ′Q  Q  r  G     Figure 8.2. The initial bounding sphere determined by the extents of the set of points in  the direction of the principal axis is expanded to include any points in the set that lie out- side of the sphere.   Whenever  a  point  is  encountered  that  lies  outside  the  sphere,  we  expand  the  sphere by adjusting the center Q and radius r to enclose the previous sphere and  the exterior point, as shown in Figure 8.2. A point   iP  lies outside the sphere if   We expand the sphere by placing the new center  previous center Q and the exterior point  previous sphere at a point G given by   −  P Q i  >  2  2  r  .    8.17   ′Q  on the line connecting the  iP . The new sphere is then tangent to the   which  also  lies  on  the  line  containing  Q  and  halfway between the points G and  the new center to either of these points:   ′Q   is  placed  iP , and the new radius r′ is the distance from   iP .  The  new  center   =  G Q  −  r  − −  P Q i P Q i  ,   G P i  ′ =  Q  + 2 −  ′  r  =  P Q .  i  ′   8.18     8.19    8.1.4  Bounding Ellipsoid Construction  An ellipsoidal bounding volume may be appropriate for a triangle mesh having  an elongated shape. To determine a good bounding ellipsoid for a set of vertices  P , we need to calculate the lengths of the three semiaxes of the ellip- P P , 1 2  , N  ,   8.1  Bounding Volume Construction   219               soid aligned to the natural axes R, S, and T. We can transform the problem into  that of finding a bounding sphere by scaling the vertex positions in these direc- tions so that their bounding box becomes a cube. Once the bounding sphere of  the scaled set is known, we scale its radius by the reciprocal amount in each di- rection to derive the semiaxis lengths.    To scale the vertex positions so that they are bounded by a cube, we need to  know the distance between the planes representing the minimum and maximum  extents in each natural axis direction. These distances are equal to the dimensions  of  the  standard  bounding  box,  which  are  given  by  the  differences  between  the  iP  with the vectors R, S, and  minimum and maximum dot products of the points  T. Calling these distances a, b, and c, respectively, we have   = = =  a b c  max ≤ ≤ i N 1 max ≤ ≤ i N 1 max ≤ ≤ i N 1  { { {  } − P R i } − P S i } − P T i  ⋅ ⋅ ⋅  } { ⋅ P R min i ≤ ≤ i N 1 } { ⋅ P S min i ≤ ≤ i N 1 } { ⋅ P T   . min i ≤ ≤ i N 1   8.20    To transform the vertex set into one bounded by a cube, we need to scale their  positions by 1 a in the R direction, by 1 b in the S direction, and by 1 c in the T  direction. As stated in Equation  4.11 , the matrix M that performs this scale is  given by   =  [  M R S T  ]  [  ] T R S T ,    8.21    a 1   0  0    0 b 1 0  0 0 c 1        where  we  have  replaced  the  inverse  operation  for  the  rightmost  matrix  by  a  transpose operation since the vectors R, S, and T are orthonormal.    Once each of the points { }iP  has been transformed by the matrix M, we cal- culate  the  bounding  sphere  for  the  set  of  points  .  Once  the  center  Q of this sphere is known, we  can  calculate the center of the bounding  ellipsoid of the original set of vertices by transforming Q back into the unscaled  1−M Q, where the in- coordinate space. The ellipsoid center is simply given by  verse of M is   MP MP 2  MP ,  ,  ,  N  1  − 1  M  =  [  R S T  R S T .  T  ]   8.22    ]  a 0 0 b 0 0 c 0 0              [   220   8. Visibility Determination               The lengths of the semiaxes of the bounding ellipsoid are calculated by scaling  the radius r of the bounding sphere calculated for the points { }iMP . The semiaxis  lengths corresponding to the directions R, S, and T are given by ar, br, and cr,  respectively.   8.1.5  Bounding Cylinder Construction   ,  , N  P P 1 2  A  cylindrical  bounding  volume  is  represented  by  its  radius  and  the  two  points  corresponding to the centers of its endcaps. The endcaps of a cylinder bounding  P  coincide with the planes of the bounding box that  , the set of points  are  perpendicular  to  the  principal  axis  R.  Most  of  the  calculations  involved  in  determining  the  bounding  cylinder  for  a  triangle  mesh  lie  in  finding  the  circle  iP  onto the plane containing the natural  that bounds the projection of the points  axes S and T.    We  find  the  bounding  circle  in  a  manner  similar  to  the  way  we  calculate  iP  parallel to the R  bounding spheres, except that the component of each point  direction is ignored. Instead of working directly with the points { }iP , we remove  the projection of each   iP  onto R and work with the points {  }iH  given by   H P i  =  i  −     ⋅  P R R.  i      8.23    lH  that have the least and greatest dot products  We first locate the points  with the vector S.  Recall that the axis S corresponds to the second largest eigen- value of the covariance matrix.  The initial center Q and radius r of the bounding  circle are given by   kH  and   =  =  Q  r  H H  k  l  + 2 −  H Q .   k  H Q  −  i  2  >  r  2     We then proceed exactly as we would when calculating a bounding sphere. We  iH   check each point to make sure it falls inside the bounding circle. When a point  for which   is encountered, we expand the bounding circle so that it has a new center  new radius r′ given by    8.24     8.25    ′Q  and    8.2  Bounding Volume Tests   221            where   G H  i  ′ =  Q  ′  r  =  H Q ,   ′  + 2 − i  =  G Q  −  r  i  H Q H Q  − −  i  .    8.26     8.27    The radius of the bounding cylinder is the same as the radius of the circle    bounding the set of points { }iH . The center Q of the bounding circle lies in the  plane perpendicular to the direction R but passing through the origin. The centers  of  the  cylinder’s  endcaps  are  found  by  projecting  Q  onto  the  bounding  box  planes corresponding to the least and greatest dot products of the points { }iP  with  the direction R. Calling the endpoints  + +  2Q , we have  ⋅ ⋅  1Q  and  } { P R R min i ≤ ≤ i N 1 { } P R R.  max i ≤ ≤ i N 1  Q Q Q Q   8.28    = =     1  2  8.2  Bounding Volume Tests   Now that we have seen how to construct a variety of bounding volumes, we turn  our attention to the methods used to determine whether each type is visible. All  the  techniques  presented  in  this  section  reduce  the  problem  of  intersecting  a  bounding volume with the view frustum to that of intersecting a point or a line  segment with a properly modified view frustum. This is accomplished by moving  the planes of the view frustum outward by appropriate amounts, which are de- termined differently for each type of bounding volume.   8.2.1  Bounding Sphere Test  A sphere of radius r intersects the view frustum if its center lies inside the view  frustum or lies within a distance r of any of the six sides of the view frustum. The  gray  region  shown  in  Figure  8.3 a   corresponds  to  the  volume  in  which  the  sphere’s  center  must  lie  whenever  it  is  visible.  The  boundary  of  this  region,  formed  by  rolling  the  sphere  around  the  outside  edges  of  the  view  frustum,  is  parallel to one of the frustum planes everywhere except at the corners, where it is  rounded. As Figure 8.3 b  shows, we can approximate the exact volume of visi- bility by moving each of the six frustum planes outward by a distance r.    222      r  8. Visibility Determination   r      a    b   Figure 8.3.  a  The yellow region corresponds to the volume, in addition to the view frus- tum itself, in which the center of a sphere of radius r must lie whenever it is visible.  b   We can approximate the exact volume of visibility by  moving each of the six frustum  planes outward by a distance r.     Given  a  sphere  of  radius  r  whose  center  resides  at  the  point  Q  in  camera  space, we compute the 4D dot products of the homogeneous extension of Q with  the six frustum planes listed in Table 5.1. Since the frustum plane normals point  inward, a negative dot product indicates that Q lies outside the visible volume of  space. If any one of the dot products is less than or equal to  r− , then the sphere  does not intersect the view frustum at all, and the object bounded by it should be  culled from the visible set of geometry. Otherwise, some part of the sphere prob- ably lies inside all six frustum planes, the exception being the case shown in Fig- ure 8.4. Near the edges of the view  frustum, some spheres that are not visible  may not be culled because they do not fall far enough outside any single frustum  plane. This infrequent occurrence is normally tolerated to preserve the simplicity  of the visibility test. We examine a small enhancement that reduces this effect in  Section 8.4.2.   8.2.2  Bounding Ellipsoid Test  When testing the visibility of a sphere, we move each of the six frustum planes  outward by the radius of the sphere and test whether the sphere’s center lies on  the positive side of these modified planes. A similar method can be used to test  the visibility of an ellipsoid, but since an ellipsoid does not possess the isotropic  symmetry that a sphere does, the effective radius of the ellipsoid is different for  each frustum plane.    8.2  Bounding Volume Tests   223            Figure 8.4. Near the edges of the view frustum, some spheres that are not visible are not  culled because they do not fall far enough outside any single frustum plane.      Suppose that an object is bounded by an ellipsoid whose semiaxes are given    by the mutually perpendicular vectors R, S, and T, as shown in Figure 8.5, where  R,  S,  and  T  are  parallel  to  the  principal  axes  of  the  bounded  object  but  have  magnitudes equal to the semiaxis lengths of the ellipsoid. A point P on the sur- face of the ellipsoid can be expressed in terms of the three vectors R, S, and T as  follows.   =  P R  cos sin  θ  φ  +  S  sin sin  θ  φ  +  T  cos  φ     8.29    This expression represents a spherical coordinate system aligned to the axes of  the ellipsoid. The angle φ represents the angle that the point P makes with the  vector T. The angle θ represents the angle that the projection of P onto the plane  containing the vectors R and S makes with the vector R. Over the entire surface  of the ellipsoid, φ ranges from 0 to π, and θ ranges from 0 to 2π.    Given a unit direction vector N, we would like to find the point P on the sur- face of the ellipsoid whose projection onto N has the greatest magnitude. This  would  give  us  the  effective  radius  effr   of  the  ellipsoid  with  respect  to  a  plane  whose normal vector is N. Since N has unit length, the magnitude of the projec- ⋅P N. We wish to find the angles φ and θ that  tion of P onto N is simply given by  maximize this quantity, so we set partial derivatives to zero as follows.      ∂ ⋅ ∂ P N φ     =     ⋅  R N     cos cos  θ  φ  +     ⋅  S N     sin cos  θ  φ  −     ⋅  T N     sin  φ  =  0      8.30     224   8. Visibility Determination                  N  R  S  effr  P     Figure 8.5. A bounding ellipsoid whose semiaxes are given by the mutually perpendicu- lar vectors R, S, and T  where T points out of the page . The effective radius of the ellip- soid with respect to a plane is equal to the maximum distance from the ellipsoid’s center  to any point on the surface projected onto the plane’s normal.      ∂ ⋅ ∂ P N θ     = −     ⋅  R N     sin sin  θ  φ  +     ⋅  S N     cos sin  θ  φ  =  0      8.31    In our derivation of an expression for the quantity   ⋅P N, we make use of the     trigonometric identity   2  tan  α  + = 1 sec  2  α  ,    8.32    which can be transformed into the identities   sin  α  =  cos  α  =  tan tan 2 1 2  tan  α α  +  1  .   α  +  1  Equation  8.31  can be rewritten as        ⋅  S N     cos  θ  =     ⋅  R N     sin  θ  ,   allowing us to express tanθ as   tanθ  =  ⋅ ⋅  S N R N  .   Equation  8.30  can be rewritten as    8.33     8.34     8.35     8.2  Bounding Volume Tests   225      ⋅  T N     sin  φ  =     ⋅  R N     cos cos  θ  φ  +     ⋅  S N     sin cos  θ  φ  ,    8.36                   allowing us to express tan φ as  ⋅ ⋅  tan  φ  =  R N T N 1 2  tan ⋅ R N ⋅ T N ⋅ R N ⋅ T N ⋅ R N ⋅ T N  =  =  =  =  θ  ⋅ ⋅ ⋅ ⋅  sin  S N T N R N T N   + 1 tan  tan  +  θ  2  cos  θ  +  +  θ     1 1 2  tan tan  2  θ θ  + +  1 1      ⋅ S N ⋅ T N    θ  2  ⋅ ⋅  S N R N          +  1,      8.37    where Equation  8.35  has been used in two steps. Using the identities given by  Equation  8.33 , the value of   ⋅P N can now be written as     +  ⋅  ⋅     =    P N R N 1 2  =  cos sin  θ     ⋅      + S N φ φ tan [ θ tan 2  +  1  tan  φ  +  1  φ  θ  sin sin    ⋅ +  R N S N  ⋅  φ     ⋅  T N    tan  θ  cos ]  + ⋅   T N .      8.38    Substituting  expressions  from  Equations   8.35   and   8.37   for  tanθ  and  tan φ  gives us   ⋅  P N  =  + ⋅  T N  2  2        2     2  +   2    ⋅ ⋅ S N R N R N  ⋅ +  ⋅ ⋅ T N R N  ⋅ ⋅ S N R N       ⋅ ⋅ T N R N            ⋅ + ⋅ + R N S N ⋅ ⋅ 2 S N R N         ⋅ ⋅ T N R N               ⋅ + ⋅ + S N R N 2 2         ⋅ + ⋅ + S N R N 2  T N  ⋅  2     1  +   1   ⋅ T N 2      ⋅ T N   ⋅ T N     1   2    +  2  +  1  ,     2  =  =   8.39     226   8. Visibility Determination            which yields the relatively simple expression     +  =  effr = ⋅        ⋅  ⋅     +     ⋅     2  2  2  S N  P N  R N  T N .    8.40       Equation   8.40   provides  the  effective  radius  of  an  arbitrary  ellipsoid  with  respect to a plane having unit normal direction N. Since the near and far planes  are  parallel,  the  ellipsoid’s  effective  radius  for  those  two  planes  is  the  same.  Thus, to test whether an ellipsoid falls outside the view frustum, we need to cal- culate at most five effective radii. As with the sphere test, we compute the four- dimensional dot products of the ellipsoid’s center with each of the frustum plane  effr− , then the ellipsoid is  vectors. If any single dot product is less than or equal to  not visible. Otherwise, the object bounded by the ellipsoid should be drawn.   8.2.3  Bounding Cylinder Test  We reduced the problem of intersecting a sphere or an ellipsoid with the view  frustum  to  that  of  testing  whether  a  point  fell  on  the  positive  side  of  frustum  planes that were offset by the bounding volume’s effective radius. To intersect a  cylinder  with  the  view  frustum,  we  instead  reduce  the  problem  to  determining  whether a line segment is visible in a properly expanded frustum.    As with the ellipsoid test, we must determine the effective radius of a bound- ing cylinder with respect to each of the view frustum planes. The effective radius  depends on the cylinder’s orientation and ranges from zero  when the cylinder is  perpendicular to a plane  to the actual radius  when the cylinder is parallel to a  1Q   plane . Suppose that we are given a cylinder of radius r whose endpoints lie at  2Q . We define the vector A to be the unit vector parallel to the axis of the  and  cylinder:   =  A  2  Q Q Q Q  − −  2  1  1  .   As shown in Figure 8.6, the effective radius  effr  of the cylinder with respect to a  plane having unit normal direction N is given by     8.42   where α is the angle formed between the vectors A and N. This can also be writ- ten as   sin  r eff  =  α  ,   r   8.41     8.43    r eff  2  α  = =  r r  − 1 cos − 1     ⋅A N .  2      8.2  Bounding Volume Tests   227            N  A  α  r  1Q effr  2Q     Figure 8.6. The effective radius of a bounding cylinder.   ⋅L Q  and     We perform the visibility test by visiting each of the six view frustum planes,  beginning with the near and far planes since they are parallel and thus share the  same  effective  radius.  For  each  frustum  plane  L,  we  first  calculate  the  4D  dot  ⋅L Q . If both dot products are less than or equal to the value  products  effr−  corresponding to the plane L, then we immediately know that the cylinder is  not visible, and the test exits. If both dot products are greater than or equal to  effr− , then we cannot draw any conclusions and simply proceed to the next plane.  effr− , and the    other dot product is greater than   In the remaining case that one of the dot products is less than   3Q  such that   1  2  effr− , we calculate the point  L Q  = −  effr  ⋅     3   8.44       and replace the exterior endpoint with it. This effectively chops off the part of the  3Q ,  cylinder that is now known to lie outside the view frustum. To find the point  we use the parametric line equation  =   8.45   1t≤ ≤  represents the axis of the cylinder. Substituting the right  3Q  in Equation  8.44  allows us to solve for the value     Q Q ,       t  Q  Q  +  −  where the range 0 side of this equation for  of t:      t  2  1  1  3  =  t  + ⋅ L Q r eff   − ⋅ L Q Q  1  1  2  .       8.46     Note that the difference  into Equation  8.45  gives us our new endpoint  endpoint with it, we continue to the next plane.   2−Q Q  has a w coordinate of 0.  Plugging this back  3Q . After replacing the exterior   1   228   8. Visibility Determination           If we visit all six planes of the view frustum and never encounter the case  effr− , then the cyl- that both endpoints produce a dot product less than or equal to  inder is probably at least partially visible. Of course, this means that we do not  have to replace any endpoints for the last plane that we visit. As soon as we know  r that at least one endpoint   for the final plane, we know  eff that part of the cylinder intersects the view frustum.   iQ  satisfies   L Q  > −  ⋅  i  8.2.4  Bounding Box Test   When determining whether a box intersects the view frustum, we have a choice  between reducing the problem to that of testing a point or to that of testing a line  segment. If the bounding box extents in the primary axis direction R are signifi- cantly greater than those in the S and T directions, then we may choose to test a  line segment. For bounding boxes whose dimensions are roughly equal, we favor  the point test.    We assume in this section that the magnitudes of the vectors R, S, and T rep- resenting the principal axes of the object bounded by the box are equal to the di- mensions of the box itself. To reduce the problem of intersecting a box with the  view frustum to that of testing whether its center lies inside the expanded frustum  planes, we need a way to determine the box’s effective radius. As shown in Fig- ure 8.7, we can calculate the effective radius  effr  of a box with respect to a plane  having unit normal direction N using the formula   r = eff  1 2       R N S N T N .   + ⋅  +  ⋅  ⋅   8.47    N  R  1 2  ⋅R N  1 2  Q  S  1 2  ⋅S N  1 2     Figure 8.7. Calculating the effective radius of a box.    8.2  Bounding Volume Tests   229            effr  ⋅ ≤ −  , then the box is not visible.   Once the effective radius is known, we proceed in exactly the same manner as we  would  to  test  an  ellipsoid.  For  each  frustum  plane  L,  we  calculate  the  4D  dot  product between the plane and the center Q of the bounding box. If for any plane  L Q In the case that the length of R is much greater than the lengths of S and T, a    box may not be rejected in many situations when it lies far outside the view frus- tum. An instance of this case is demonstrated in Figure 8.8. To circumvent this  problem, we can reduce the box intersection test to a line segment intersection, as  is done for cylinders.    the endpoints   In terms of the bounding box center Q and its primary axis R, we can express   2Q  of the line segment representing the box as   1Q  and   The effective radius  effr  with respect to a plane having unit normal direction N is  given by   1  Q Q R Q Q R.   + −  = =  2  1 2 1 2  r = eff  1 2       S N T N ,   +  ⋅  ⋅   8.48     8.49    S  R  Figure 8.8. This example demonstrates that using the point test for a box having one di- mension much larger than the other two can result in the failure to reject a box that lies a  significant distance outside the view frustum.       230      8. Visibility Determination   8.3  Spatial Partitioning   2  2Q .   1Q  and   ⋅R N  term appearing in Equation  8.47  is now absent since it is rep-  where the  resented by the line segment connecting    We now proceed in exactly the same manner as we would to test a cylinder.  ⋅L Q   and  For  each  frustum  plane  L,  we  first  calculate  the  4D  dot  products  ⋅L Q . If both dot products are less than or equal to the value  effr−  corresponding  to the plane L, then we immediately know that the box is not visible, and the test  effr− , then we cannot draw  exits. If both dot products are greater than or equal to  any conclusions and simply proceed to the next plane. When one of the dot prod- effr− , we calculate  ucts is less than  the  point    using  Equations   8.45   and   8.46 ,  and  re- place the exterior endpoint with it. If we are able to visit all six frustum planes  without encountering the case that both endpoints produce a dot product less than  or equal to   effr− , then the box is probably at least partially visible.   effr−  and the other dot product is greater than   3Q   such  that   L Q  = −  effr  ⋅  3  1  It is possible to increase the efficiency for which the visibility of a large number  of  objects  is  determined  by  organizing  them  into  a  structure  whose  properties  allow large regions of space to be culled from the visible set of geometry using  very simple tests. This practice is called spatial partitioning and comes in two  popular varieties that we discuss in this section: octrees and binary space parti- tioning  trees.  Both  methods  are  usually  applied  only  to  static  world  geometry  since computation of the data structures involved is generally too expensive to  perform at runtime.   8.3.1  Octrees  Suppose that all the geometry belonging to an entire world or to a particular re- gion of a world is contained within a rectangular box B. An octree is a structure  that partitions this box into eight smaller, equal-size rectangular boxes called oc- tants. These smaller boxes are further subdivided into eight even smaller octants,  and  the  process  continues  to  some  maximum  number  of  iterations  called  the  depth  of  the  octree.  Each  octant  is  linked  to  the  box  from  which  it  was  parti- tioned, and each object in the world is linked to the smallest octant that complete- ly contains it  which may be the original box B .    Figure  8.9 a   illustrates  the  two-dimensional  analog  of  an  octree,  called  a  quadtree, constructed for an area containing a single object. Figure 8.9 b  shows  how the corresponding data structure is organized. Each node in a quadtree struc- ture has at most four subnodes—octrees can have up to eight. As this example    8.3  Spatial Partitioning      231    a    b   Root  E  K  G  F  H  B  D  A  C  A  B  C  D  E  F  H  G  K     Figure 8.9.  a  A quadtree constructed for an area containing a single object.  b  The data  structure representation of the quadtree.   demonstrates, if no world geometry intersects a quadrant  or an octant in an oc- tree , then that quadrant is not subdivided. Furthermore, any quadrant that does  not completely contain any objects is deleted from the tree. We always assume  that any missing quadrants are empty.    Organizing geometry into a tree structure has the benefit that whenever we  can determine that a node of the tree is not visible, then we immediately know  that  every  subnode  of  that  node  is  also  not  visible  and  can  simultaneously  be  culled.  Chapter 12 discusses how a similar property of tree structures benefits  collision detection.  Visibility determination for the octree begins by testing the  box surrounding the root node for intersection with the view frustum. If the cam- era is known to always lie within the boundary of the octree, then it can be as- sumed  that  the  root  node  is  always  visible.  When  any node’s  bounding  box is  determined to be visible, we consider each object linked to that node by testing  its bounding volume for visibility. We then perform the same test for any existing  subnodes  of  the  visible  node.  When  a  node’s  bounding  box  fails  the  visibility  test, we ignore all objects linked to that node and any subnodes belonging to that  node.    We can use the fact that the bounding boxes at each level of an octree all  have the same orientation to our advantage. For any given camera position and  orientation, we transform the axes of the octree into camera space and calculate  the five effective radii  one for the near and far planes and four corresponding to    232      8. Visibility Determination   the side planes  of the box B bounding the entire structure. If  effr  is the effective  radius of the box B with respect to a particular view frustum plane, then the ef- fective  radius  of  any  box  residing  one  level  deeper  within  the  tree  is  simply  r eff 2 . This saves us from having to use Equation  8.47  to calculate effective ra- dii  for  every  octant  at  every  level—calculating  it  once  at  the  beginning  is  sufficient.   8.3.2  Binary Space Partitioning Trees  A Binary Space Partitioning  BSP  tree is a structure that divides space into two  regions at each level. Unlike the planes that partition octrees, the planes partition- ing a BSP tree can be arbitrarily oriented. A BSP tree is constructed for a set of  objects by choosing a partitioning plane, sometimes called a splitting plane, and  sorting the geometry into two groups: objects lying on the positive side of the  plane  also called the positive halfspace  and objects lying on the negative side of  the plane  the negative halfspace .    Traditionally, the partitioning planes of a BSP tree have been aligned to the  polygons  that  make  up  the  world  geometry.  Figure  8.10  illustrates  a  two- dimensional example of a region containing several polygons that determine the  structure of the BSP tree. One polygon is chosen to represent the splitting plane  at each level, and the remaining polygons are sorted into positive and negative  groups. Any polygons intersecting the plane are split into two polygons that lie in  the positive and negative halfspaces. The positive and negative groups are then  partitioned,  and  the  process  continues  for  each  halfspace  until  no  polygons  remain.    a   B  D  A  C   b   A  + B  − C  D  +     Figure 8.10.  a  A traditional BSP tree and  b  the associated data structure.    8.3  Spatial Partitioning   233           The large number of polygons and curved surfaces used in modern 3D en- gines  makes  the  traditional  BSP  tree  impractical.  In  a  somewhat  modified  ap- proach, we create one splitting for each object instead of each polygon. As shown  in Figure 8.11, the splitting plane for an object is aligned so that it is perpendicu- lar to the object’s principal axis T corresponding to the smallest dimension of its  bounding box. This minimizes the distance that the object extends away from the  splitting plane. After a splitting plane has  been chosen for an object, the other  objects are sorted into those that lie completely within the positive halfspace and  those that lie completely within the negative halfspace. Any objects that straddle  the splitting plane are added to both the positive and negative groups. The half- spaces are recursively partitioned until no objects remain.    For each splitting plane of a BSP tree, we need to determine the visibility of  each halfspace and the visibility of the object associated with the plane. This re- quires that we have a way to determine whether a plane K intersects the view  frustum. The simplest approach would be to test the eight vertices of the view  frustum in world space against the plane K by calculating the 4D dot products  and comparing them to zero. If all eight dot products have the same sign  mean- ing that all eight points lie on the same side of the plane , then the plane does not  intersect  the  view  frustum.  Fortunately,  we  can  find  a  better  method  by  trans- forming the plane K into homogeneous clip space and utilizing the cubic sym- metry of the view frustum in that space  see Section 5.5.1 .    A plane K can be transformed from world space to homogeneous clip space  using the formula   K     ′ =    PM    1 −  T  K,       8.50    R  T  Figure 8.11. An object’s splitting plane is aligned so that it is perpendicular to the ob- ject’s principal axis T corresponding to the smallest dimension of its bounding box.       234   8. Visibility Determination         where P is the projection matrix and M is the transformation from world space to  camera space. The components of each vertex of the view frustum in clip space  ′K  is the one  are  1± . The vertex producing the greatest dot product with the plane  ′K .  having component signs that match the signs of the x, y, and z components of  ′K  is the one having component  The vertex producing the least dot product with  ′K . The greatest dot product  maxd signs opposite those of the components of   and  the least dot product  mind  are thus given by   d d  max  min  = K = −  ′ x K  + ′ x  ′ K y − K  + ′ y  ′ K z − K  + ′ z  ′ K w + K  ′ .  w   8.51    d  ≤ , then the view frustum lies entirely on  0   As shown in Figure 8.12, if  max the negative side of the plane K. This means that nothing on the positive side of  ≥ , then the view frustum lies entirely on  0 the plane is visible. Similarly, if  min the  positive  side  of  the  plane  K,  and  thus  nothing  on  the  negative  side  of  the  ≥  is satisfied, then  0 plane is visible. If neither of the conditions  max the plane K intersects the view frustum, and we cannot cull either halfspace.   ≤  or  min 0  d  d  d  maxd  mind  K     Figure 8.12. Let  maxd frustum vertex with the plane K. If  max 0 pletely on one side of K, so the other side is not visible.    be the greatest dot product and least dot product of any  ≥ , then the view frustum lies com-  ≤  or  min   and  mind  d  d  0   8.4  Portal Systems      8.4  Portal Systems   235   A portal system is an extremely powerful technique that can be used to quickly  eliminate  massive regions of world geometry from  the visible set. The general  idea is surprisingly simple—the world is divided into many disjoint zones that are  connected by portals. A portal is represented by a convex polygon through which  one region can be seen from another. The advantage of a portal system is that any  region of space that cannot be seen through a series of portals is never even con- sidered for rendering. When determining what parts of a world are visible, using  a portal system allows us to touch only a small fraction of the entire data set be- cause any geometry that lies on the opposite side of an invisible portal is ignored.    Figure 8.13 illustrates how visibility determination is carried out for a portal  system. We first locate the zone in which the camera resides—this zone is always  considered visible. We then examine each of the portals leading out of the zone  containing the camera. For each portal that intersects the view frustum, we con- sider the zone to which it connects visible. Each portal leading out of the con- necting zone, excluding any leading back to the first zone, is then tested for visi- bility, but this time against a view frustum that has been reduced in size by the  boundary of the portal through which we are looking. This technique is applied  recursively until no new portals are visible.   Figure 8.13. Only regions of space that can be seen through a series of portals are con- sidered visible.       236      8. Visibility Determination     The zones connected by portals may be further organized into tree structures,  and the objects residing in these regions may still have bounding volumes. The  visibility of large regions determined by the portal system is a large-scale culling  process that should be supplemented by smaller-scale visibility determination in  each zone.   8.4.1  Portal Clipping  Whenever  the  camera  looks  through  a  portal  connecting  to  another  zone,  we  know that the volume of visibility in that zone is smaller than the whole view  frustum. Thus, we can reject a larger number of objects during smaller-scale visi- bility testing by using a smaller view frustum. The near and far planes remain the  same, but the side planes of the new view frustum are replaced by a set of planes  that represents the intersection of the original view frustum and the sides of any  polygonal portals through which we are looking.    As a convention, the plane containing a portal must have a normal direction  that points toward the camera, and the vertices of the portal must be wound coun- terclockwise, as shown in Figure 8.14. Consequently, portals are one-way in the  sense that if a portal leads from zone X to zone Y, then the same portal does not  lead backward from zone Y to zone X. When the camera lies on the negative side  of a plane containing a portal, that portal is never considered visible. Two-way  visibility between two zones requires that each zone have a portal leading to the  other.    Whenever we consider a portal leading out of a zone, we are interested only  in the visible area of that portal. The visible area of a portal is equal to the area  that intersects the current view frustum, which may be the original view frustum  or a reduced view frustum. To determine what area of a portal is visible, we clip   Figure 8.14. The vertices of a portal are wound counterclockwise about the normal of the  plane containing them. Here, the normal points out of the page.       8.4  Portal Systems   237               its polygon against the planes bounding the current view frustum. Clipping a pol- ygon against a plane removes the portion of the polygon lying on the negative  side of the plane, resulting in a new polygon whose interior lies completely on  the positive side of the plane. Clipping a polygon against every plane of the cur- rent  view  frustum  effectively  chops  off  any  part  lying  outside  the  volume  of  space that is visible to the camera.  V   ,   n and  connect  to  form  a  convex  polygon.  When  we  clip  this  polygon  against  a  1n +   vertices.  We  plane  L,  we  produce  a  new  convex  polygon  having  at  most  begin the clipping process by classifying all of the vertices into three categories:  those lying on the positive side of L, those lying on the negative side of L, and  iV  is classified as ly- those considered to be lying in the plane L itself. A vertex  ing in the plane if its dot product with L satisfies   Suppose we need to clip a portal whose vertices lie at the points   V V 1 2  ,  ,  ≤  0    ε− < ⋅ L V i ε ≈   8.52    0.001  for some small constant ε  typically,   . This prevents problems associat- ed with round-off error that would otherwise wreak havoc on our visibility tests  by destroying the convexity of the view frustum. If no vertices lie on the positive  side of the plane L, then the portal is not visible, and we do not render anything  in  the  zone  to  which  it  connects.  If  no  vertices  lie  on  the  negative  side  of  the  plane L, then no clipping is necessary. Otherwise, we visit every pair of neigh- boring vertices, looking for edges having one positive vertex and one negative  vertex. As shown in Figure 8.15, new vertices are added to the polygon where  edges intersect the clipping plane, and vertices lying on the negative side of the  plane are removed. Vertices lying on the positive side of the clipping plane or  lying in the clipping plane itself are not affected.    and that the vertex   iV  lies on the positive side of the clipping plane L,   1i+V  lies on the negative side of L, or equivalently,   Suppose that the vertex   A point W lying on the line segment connecting   1i+V  can be expressed as   ⋅ ⋅  L V i L V i  >  0 ≤ −  + 1  ε  .   W      t  =  V i  +     t  V i  + 1  iV  and  −    V ,   i   8.53     8.54    where  the  parameter  t  satisfies  0 L W  , we have       0 = t  ⋅  1t≤ ≤ .  Solving  for  the  value  of  t  that  yields    238   8. Visibility Determination            L  Figure 8.15. When a portal is clipped against a plane, new vertices are added where edg- es intersect the plane, and vertices lying on the negative side of the plane are removed.  Vertices  lying  on  the positive  side  of  the  clipping  plane  or  lying  in  the  clipping  plane  itself are not affected.      =  t  ⋅  L V i − L V V i     ⋅  i  .    1  +   8.55     Note that the difference  ue back into Equation  8.54  gives us our new vertex W.   i+−V V  has a w coordinate of 0.  Substituting this val-  1  i  8.4.2  Reduced View Frustums  Given a clipped portal, we wish to calculate the planes surrounding the volume of  space visible through that portal. This enables us to perform visibility determina- tion against a view frustum that is smaller than the original view frustum, result- ing  in  a  greater  number  of  objects  being  culled.  Fortunately,  the  camera-space  iL   plane corresponding to an edge of a portal is simple to calculate. The plane  passing through the origin and the two portal vertices   1i+V  is given by   iV  and   =  L  i  V i V i  + 1  + 1  × ×  V i V i  ,0  .    8.56    For  a  portal  having  n  vertices,  we  use  Equation   8.56   to  calculate  the  n  side  nL , we wrap around by set- planes of our reduced view frustum.  For the plane  1i+V  is very  ting   V .  If the distance between any two portal vertices   iV  and   n+ =V  0  1   8.4  Portal Systems   239            small,  then  round-off  errors  can  cause  convexity  problems,  so  we  discard  any  plane   iL  for which   V  + − 1i  V  i  2  <  ε  ,    8.57    where ε is a small constant that can be adjusted to produce acceptable results.    The side planes of a reduced view frustum can meet at highly acute angles.  As shown in Figure 8.16, this can impact the effectiveness of bounding volume  visibility tests because objects lying far from the view frustum still may not lie on  the negative side of any single frustum plane. We can eliminate this problem by  detecting cases in which adjacent frustum planes meet at a small angle and add- ing an extra plane to the view frustum whenever such cases occurs.  3N  added to the view    Figure 8.16 shows a new plane having normal direction  1N  and  2N . The vec- frustum between two adjacent planes having normal vectors  3N   is  constructed  by  first  calculating  the  average   unnormalized   direction  tor  2+N N . We then subtract  between  2×N N  to ensure that the new  the projection of this average onto the direction  plane contains the line at which the two original planes intersect. This gives us  the following expression for   2N , which is simply given by the sum   1N  and   1  1  3N .   1  2  = =  A N N B N N      + × − −  1 A A B B A A B B       =  ⋅ ⋅  2  3  N      8.58    3N  1N  2N  Figure 8.16. Side  planes  of  the  reduced view  frustum  that  meet  at  an  acute  angle  can  impact the effectiveness of bounding volume visibility tests. The bounding sphere shown  here does not fail the visibility test even though it lies far outside the view frustum.       240   8. Visibility Determination                  Since it passes through the origin in camera space, the new plane has a w coordi- nate of 0.  The situation demonstrated in Figure 8.16 can be avoided by constructing an    2N  sat- extra plane whenever two adjacent frustum planes having normals  ,  where  α  represents  an  acuteness  threshold.  The  isfy  the  condition  extra planes do not actually contribute to the shape of the view frustum since they  are coincident with the lines at which previously existing planes intersect. They  should be used only for visibility testing within a single zone and should not par- ticipate in the clipping of any portals leading to other zones.   1N  and   N N  < 2 α  ⋅  1  Chapter 8 Summary   Principal Components  The principal axes R, S, and T of a set of N vertices  1 eigenvectors of the covariance matrix C defined by   P P 2  ,  P  are given by the  ,  , N  where the mean position m is given by   =  1 N C iN = 1       T P m P m ,  i      −  −  i  1 N = m iN = 1  P .  i  If  1λ ,  2λ , and  3λ  are the eigenvalues corresponding to the vectors R, S, and T, re- spectively, then   ≥  ≥  .   λ  λ  λ 1  3  2  Bounding Boxes  The two planes perpendicular to the principal axis A that bound the set of verti- ces  1  P  are given by  ,  P P 2  , N  ,  A  − , min ≤ ≤ i N 1  {  } P A i  ⋅  −  A  ,max ≤ ≤ i N 1  {  ⋅  P A .  i  }  The center Q of a bounding box is given by  A   where   Q  A  +  =  k  k  2  1  1  +  2  k  A ,  3  3  min ≤ ≤ i N 1  {  ⋅  P A i  j  }  +  {  ⋅  P A i  }  j  max ≤ ≤ i N 1  ,   =  jk  2   Chapter 8 Summary   241                  and   1A ,   2A , and   3A  are the unit-length principal axes.   The effective radius  effr  with respect to a plane having normal direction N of a  bounding box whose dimensions and orientation are described by the vectors R,  S, and T is given by   r = eff  1 2  ⋅ + ⋅ + ⋅  R N S N T N .   Bounding Spheres  A bounding sphere for the set of vertices  1 the points  mary axis R and setting the initial center Q and radius r to   P  is constructed by locating  , lP  that produce the least and greatest dot products with the pri-  kP  and   P P 2  , N  ,  For any point  the values   iP  satisfying   −  P Q i  2  >  r  2  , we replace the center and radius with   where G is defined as   A bounding sphere having center Q and radius r is not visible if for any view  frustum plane L we have   L Q  ≤ −  .   r  ⋅  Bounding Ellipsoids  P  is constructed by trans- , A bounding ellipsoid for the set of vertices  forming into a space in which the box bounding the set is a cube, constructing a  bounding sphere in that space, and then performing the reverse transformation to  scale the sphere to the original dimensions of the bounding box.   P P 1 2  , N  ,  =  =  Q  r  P k  P l  + 2 −  P Q .  k  G P i  ′ =  Q  + 2 −  ′  r  =  P Q ,  i  ′  =  G Q  −  r  − −  P Q i P Q i  .    242   8. Visibility Determination               The effective radius  effr  with respect to a plane having normal direction N of a  bounding ellipsoid whose semiaxis lengths and orientations are described by the  vectors R, S, and T is given by   effr =     ⋅  R N     2  +     ⋅  S N     2  +     ⋅  T N .   2     A bounding ellipsoid having center Q is not visible if for any view frustum plane  L we have   ⋅ ≤ −  L Q  .   effr  Bounding Cylinders  A  bounding cylinder  for  the  set  of  vertices  }iH  using the formula  calculating the points { ⋅  =  −     H P i  i     P R R,  i     P P 1 2  ,  P   is  constructed  by  first  ,  , N  }iH  having center Q and radius r, the endpoints   where R is the unit vector parallel to the primary axis. After finding a bounding  circle for the points { 2Q   of the bounding cylinder are given by  + +  1Q  and   Q Q Q Q  } { P R R min i ≤ ≤ i N 1 { } P R R.  max i ≤ ≤ i N 1  = =  ⋅ ⋅     2  1  The effective radius  effr  with respect to a plane having normal direction N of a  bounding cylinder is given by   where A is the unit vector parallel to the axis of the cylinder given by   r eff  r=  −  1       2 ⋅A N ,   =  A  2  Q Q Q Q  − −  2  1  1  .   A bounding cylinder is not visible if the line segment connecting the endpoints  1Q  and   2Q  is completely clipped away by the view frustum planes.   Binary Space Partitioning  BSP  Trees  We can determine whether a world-space plane K intersects the view frustum by  transforming the plane into homogeneous clip space using the formula    Chapter 8 Summary   243                     K     ′ =    PM    1 −  T  K,      where P is the projection matrix and M is the transformation from world space to  camera  space.  The  greatest  dot  product  maxd   of  any  ′K  are given by  frustum vertex with the plane  ′ + = K K z ′ = − − K y    and  least  dot  product  mind  ′ K y − K  ′ K w + K  + ′ z  ′ x K  + ′ x  d d  ′ .  w  max  min     d  ≤  or  min 0  If  max the other side is not visible.   d  ≥ , then the view frustum lies completely on one side of K, so  0  Portal Systems  V  against a plane L, we add a  V V , When clipping a portal having vertices  n 1 2 1i+V  lying on opposite sides  iV  and  new vertex between any two adjacent vertices  of L. The new vertex W is given by   ,  ,  where the parameter t is given by   The plane  given by   iL  passing through the origin and the two portal vertices   iV  and   1i+V  is   An extra plane may be added to the view frustum to improve bounding volume  2N  meet at  visibility determination when planes having normal directions  an acute angle. The new plane passes through the origin and has the normal di- rection   3N  given by   1N  and   =  W V i  +     t  V i  + 1  −    V ,   i  =  t  ⋅  L V i − L V V i     ⋅  i  .    1  +  =  L  i  V i V i  + 1  + 1  × ×  V i V i  ,0  .   2  1  = =  A N N B N N      + × − −  1 A A B B A A B B       =  ⋅ ⋅  2  3  N  .    244      Exercises for Chapter 8  1.  Given two spheres   8. Visibility Determination   1S  and   2S  centered at the points   2Q , and having  radii  1r  and  2r , respectively, determine the center Q and radius r of the small- est single sphere that encloses both  1S  and  2S . Account for the cases that the  two spheres are disjoint, that the two spheres intersect, and that one of the  spheres encloses the other.   1Q  and   2.  Determine formulas for the center Q and radius r of the optimal bounding  sphere  for  a  cone  whose  radius   at  the  base   is  s,  whose  height  is  h,  and  whose  base  is  centered  on  the  origin  of  the  x-y  plane  as  shown  in  Figure  8.17. Consider the two cases that s h<  and s h≥ .   z  h  s  x  y     Figure 8.17. The cone used in Exercise 2.   3.  Determine the effective radius  effr  of a box whose edges are described by the   with respect to a plane hav-  2,0,1  =R  S ,   =  vectors  ing unit normal direction   − 1,0, 2 = N  , and  , 3 3 3 3  −  =T ,  3 3  0,1,0 .   4.  Write programs that construct a bounding box, a bounding sphere, a bound-  ing ellipsoid, and a bounding cylinder given an array of n vertex positions.   5.   Implement  a  portal  system  that  can  clip  the  view  frustum  to  an  arbitrary  convex polygon and perform visibility tests against the reduced frustum.    Chapter 9   Polygonal Techniques   This chapter discusses several techniques that involve the manipulation of polyg- onal  models.  A  3D  graphics  engine  often  needs  to  create  polygonal  models  in  real-time  in  addition  to  working  with  models  that  have  been  preprocessed  in  some way. We begin this chapter with techniques pertaining to decal construction  and  billboarding,  operations  usually  performed  on  the  fly.  Subsequent  sections  discuss  preprocessing  methods  such  as  polygon  reduction  and  triangulation,  which are normally performed by a tool that generates structures used for render- ing at a later time.   9.1  Depth Value Offset   Many  games  need  to  render  special  effects  such  as  scorch  marks  on  a  wall  or  footprints on the ground that are not an original part of a scene, but are created  during gameplay.  A method for creating these is discussed in Section 9.2.  The- se types of decorative additions are usually decaled onto an existing surface and  thus consist of polygons that are coplanar with other polygons in a scene. The  problem  is  that  pixels  rendered  as  part  of  one  polygon  rarely  have  exactly  the  same interpolated depth value as pixels rendered as part of a coplanar polygon.  The  result  is  an  undesired  pattern  in  which  parts  of  the  original  surface  show  through the decaled polygons.  The  goal  is  to  find  a  way  to  offset  a  polygon’s  depth  in  a  scene  without    changing its projected screen coordinates or altering its texture-mapping perspec- tive. Most 3D graphics systems contain some kind of polygon offset function to  help achieve this goal. However, these solutions generally lack fine control and  usually incur a per-vertex performance cost. In this section, we present an alter- native  method  that  modifies  the  projection  matrix  to  achieve  the  depth  offset  effect.        245    246   9. Polygonal Techniques               9.1.1  Projection Matrix Modification  Let  us  first  examine  the  effect  of  the  standard  OpenGL  perspective  projection    . To simplify the matrix given in  matrix on an eye space point  ,1 Equation  5.52  a bit, we assume that the view frustum is centered about the z  axis so that the left and right planes intersect the near plane at x , and the  top and bottom planes intersect the near plane at  y , where e is the focal  length and a is the aspect ratio. Calling the distance to the near clipping plane n  and the distance to the far clipping plane f, we have   P P P x z  an e  =P  n e  = ±  = ±     ,  ,  y  e 0  0  0           0 e a  0  0  0 0 + f − f − 1  n n  −  −  0 0 2 f  fn − n 0           P x P y P z 1            =              −  f f    + −  eP x   e a P y n − n −  P z  P z           .   2 f  fn − n  To finish the projection, we need to divide this result by its w coordinate, which  has the value   zP− . The resulting point   ′P  is given by    9.1     9.2    ′ =  P        + f  − f   −  eP x P z   P z     −  e a P y  +  n 2   n P f  z  fn −     n  .             It is clear from Equation  9.2  that preserving the value of   zP−  for the w co-   ordinate will guarantee the preservation of the projected x and y coordinates as  well. From this point forward, we shall concern ourselves only with the lower- right 2 2×  portion of the projection matrix, since this is the only part that affects  the z and w coordinates.    nate by introducing a factor of 1 ε+ , for some small ε, as follows.   The projected z coordinate may be altered without disturbing the w coordi-    − + 1     ε  f f  + −  n n  − 1        −  2 f  fn − n 0        P z 1          =          − + 1     ε  f f  + − −  n n P z  −  P z  2 f  fn − n            9.3     9.1  Depth Value Offset   247                  After  dividing  by  w,  we  arrive  at  the  following  value  for  the  projected  z  coordinate.     ′ = + P 1 z  =  + −  f f  fn −  ε  + −     +  f f +  n 2   n P f n 2 +   n P f  fn −  n     z  z  ε    + n −   n  n f f  Comparing this to the z coordinate in Equation  9.2 , we see that we have found a  way to offset projected depth values by a constant   ε + f n − .  f n  9.1.2  Offset Value Selection  Due to the nonlinear nature of the z-buffer, the constant offset given in Equation   9.4  corresponds to a larger difference far from the camera than it does near the  camera. Although this constant offset may work well for some applications, there  is no single solution that works for every application at all depths. The best we  can do is choose an appropriate ε, given a camera-space offset δ and a depth val- zP , that collectively represents the object that we are offsetting. To determine a  ue  formula for ε, we examine the result of applying the standard projection matrix  from Equation  9.1  to a point whose z coordinate has been offset by some small  δ as follows.   n n  + f − f − 1  −        −  2 f  fn − n 0           + P δ z 1      =  + −  f f     n n −  −     + P δ z    + P δ z     −        2 f  fn − n          Dividing by w, we have the following value for the projected z coordinate.   ′ = P z  =  f f f f  + − + −     +  P z  fn n 2    + δ n fn n 2   − n P f  +  n  z     f  −  +    n fn 2 − n P f z      1 +  −  1 δ P z         = −  ε  2 f  fn δ   + n P P z      z   .     +     δ  Equating this result to Equation  9.4  and simplifying a bit, we end up with    9.4     9.5     9.6     9.7                    or   248   9. Polygonal Techniques     A good value of δ for a particular application can be found with a little ex- perimentation. It should be kept in mind that δ is a camera-space offset, and thus  zP   gets  larger.  For  an  m-bit  integer  depth  buffer,  we  becomes  less  effective  as  want to make sure that   since smaller values of ε will not yield an offset significant enough to alter the  integer depth value. Substituting the right side of Equation  9.7  for ε and solving  for δ gives us   ≥  ε  2 − 1m  − f  + f  n n        2  ≥  δ  kP 2 z − kP z     1  δ  −≤ kP 2 z + kP 1 z  ,   =  k  − n f − .      2 1m  fn   9.8     9.9     9.10     9.11    where the constant k is given by   Equation  9.9  gives us the minimum effective value for δ when offsetting a pol- ygon toward the camera  the usual case , and Equation  9.10  gives us the maxi- mum effective value for δ when offsetting a polygon away from the camera.   9.1.3  Implementation  Listing 9.1 demonstrates how the projection matrix shown in Equation  9.3  may  be implemented under OpenGL. The LoadOffsetMatrix   function takes the  same six values that are passed to the OpenGL function glFrustum  . It also  takes the values for δ and   zP  that are used to calculate ε.    9.2  Decal Application      249   Listing 9.1. This code modifies the OpenGL projection matrix so that it offsets depth values by  the constant ε given by Equation  9.7 .   float     matrix[16];    float n, float f, float delta, float pz       Retrieve the projection matrix.  glGetFloatv GL_PROJECTION_MATRIX, matrix ;      Set up standard perspective projection.  glMatrixMode GL_PROJECTION ;  glFrustum l, r, b, t, n, f ;   void LoadOffsetMatrix float l, float r, float b, float t,    {                                    }      Modify entry  3,3  of the projection matrix.  matrix[10] *= 1.0F + epsilon;      Send the projection matrix back to OpenGL.  glLoadMatrix matrix ;      Calculate epsilon with Equation  9.7 .  float epsilon = –2.0F * f * n * delta     f + n  * pz *  pz + delta  ;   9.2  Decal Application   Effects such as scorch marks on walls or footprints on the ground are commonly  implemented by creating a new object, called a decal, that coincides with an ex- isting  surface  and  rendering  it  using  a  depth  offset  technique  such  as  that  dis- cussed in Section 9.1. Applying a decal to the interior of a planar surface is sim- ple,  but  difficulties  arise  when  applying  decals  to  the  more  complex  surfaces  used in today’s games to represent curved objects and terrain patches. In this sec- tion, we present a general method for applying a decal to an arbitrarily shaped  surface and concurrently clipping the decal to the surface’s boundary. An exam- ple of the technique we present is shown in Figure 9.1.    250      9. Polygonal Techniques     Figure 9.1. A blast mark decal applied to a curved surface.  Image from the C4 Engine,  courtesy of Terathon Software LLC.    9.2.1  Decal Mesh Construction  We begin with a point P that lies on an existing surface and a unit normal direc- tion N that is perpendicular to the surface at that point. The point P represents the  center of the decal and may be the point at which a projectile has hit the surface  or the point where a character’s foot has stepped upon the ground. A unit tangent  direction T must also be chosen to determine the orientation of the decal. This  configuration is illustrated in Figure 9.2.    Given the point P and the directions N and T, we have an oriented plane that  is tangent to the surface geometry at P. We can carve a rectangle out of this plane  that represents the area of our decal by constructing four boundary planes that are  parallel to the normal direction N. Let w and h be the width and height of the de- cal. Then the 4D vectors corresponding to the four border planes are given by    9.2  Decal Application   251            d  d  N  T  B  P  Figure 9.2. The configuration of a decal.      left  =  T  ,  − ⋅  T P               w 2  h 2     T P      + ⋅  w 2 − ⋅  B P      h 2  + ⋅   B P ,     right  = −  T ,  bottom  =  B  ,  top  = −  B  ,  front back    = − N ,   = N d ,    + ⋅ N P d   − ⋅ N P   ,  where  = × B N T.  We  generate  a  triangle  mesh  for  the decal  object  by  clipping  nearby surfaces to the four boundary planes. We also want to clip to front and  back planes to avoid bleeding through to parts of the same surface mesh that may  be inside the boundary planes but far in front of or behind the point P. The 4D  vectors corresponding to the front and back planes are given by   where d is the maximum distance that any vertex in the decal may be from the  tangent plane passing through the point P.    The  mesh  construction  algorithm  proceeds  as  follows.  First,  we  identify  which surfaces in the world could potentially be affected by the decal. This may    9.12     9.13     252   9. Polygonal Techniques            ⋅  ε  <  be determined by locating each surface whose bounding volume reaches within a  certain distance of the point P. For each potentially affected surface, we individ- ually examine every triangle in the surface’s mesh. Let M denote the unit normal  direction corresponding to the plane of a triangle in the mesh. We throw out any  N M  for some fixed positive value ε since these triangles  triangles for which  are facing away from the decal’s normal direction N. The remaining triangles are  clipped to the planes given by Equations  9.12  and  9.13  and stored in a new  triangle mesh.    When a triangle overlaps any of the planes and needs to be clipped, we inter- polate the normal vectors as well as the vertex positions so that we can later ap- ply coloring to the clipped vertices that reflects the angle between each vertex’s  normal direction and the decal’s normal direction. This has the effect of smoothly  fading the decal texture in relation to each triangle’s orientation relative to the  plane of the decal. We assign an alpha value to each vertex using the equation   ]0,1 .   where R is the  possibly unnormalized due to interpolation  normal vector corre- sponding to the vertex. This maps the dot product range [  to the alpha value  range [   Texture  mapping  coordinates  are  applied  to  the  resulting  triangle  mesh  by  measuring the distance from each vertex to the planes passing through the point  P and having normal directions T and B. Let Q be the position of a vertex in the  decal’s triangle mesh. Then the texture coordinates s and t are given by   ],1ε  −  ε  ⋅ N R R − 1  ε  ,   alpha  =  =  s  =  t  T Q P  −  ⋅        B Q P  −  ⋅        w  h  +  +  1 2 1 2  .    9.14     9.15    9.2.2  Polygon Clipping  Each triangle belonging to a surface that could potentially be affected by the de- cal is treated as a convex polygon and clipped to each of the six boundary planes,  one at a time. Clipping a convex polygon having n vertices to a plane results in a  1n +  vertices. Thus, polygons that have been  new convex polygon having at most  clipped  against  all  six  planes  may  possess  as  many  as  nine  vertices.  Once  the    9.2  Decal Application   253         clipping process is complete, each polygon is treated as a triangle fan and added  to the decal’s triangle mesh.    To clip a convex polygon against an arbitrary plane, we first classify all the  vertices belonging to the polygon into two categories: those lying on the negative  side of the plane and those lying on the positive side of the plane or in the plane  itself.  This differs from the method used to clip portals in Section 8.4.1 in that  we do not have a separate classification for vertices lying in the plane.  If all the  polygon’s vertices lie on the negative side of the plane, then the polygon is dis- carded.  Otherwise,  we  visit  every  pair  of  neighboring  vertices  in  the  polygon  looking for edges that intersect the clipping plane. As shown in Figure 9.3, new  vertices  are  added  to  the  polygon  where  such  intersections  occur,  and  vertices  lying on the negative side of the plane are removed.    and that the vertex  segment connecting   1V  lies on the positive side of the clipping plane K  2V  lies on the negative side of K. A point W lying on the line  1V  and   Suppose that the vertex   2V  can be expressed as  W    V V ,       t  −  =  +  V 1     t  1  2   9.16    2V  K  W  1V     Figure 9.3.  When  a  polygon  is  clipped  against  a  plane,  new  vertices  are  added  where  edges  intersect  the  plane,  and  vertices  lying  on  the  negative  side  of  the  plane  are  re- moved.    254   9. Polygonal Techniques         where the parameter t satisfies 0 given by   1t≤ ≤ . The value of t for which   ⋅  K W      0 = t   is   =  t  ⋅  K V 1   −  K V V  1  ⋅  2  .       9.17     Note that the difference  of t back into Equation  9.16  gives us our new vertex W.   2−V V  has a w coordinate of 0.  Substituting this value   1  9.3  Billboarding   Many  special  effects  are  implemented  by  applying  a  two-dimensional  texture  map to a flat polygon that is always oriented to face the camera. This technique is  called billboarding and is an effective way to create the illusion that a flat object  has volume. This section examines methods for calculating the vertices of bill- board polygons in different situations.   9.3.1  Unconstrained Quads  An unconstrained quad is a four-sided rectangular polygon that is free to rotate in  any  direction.  Unconstrained  quads  are  typically  used  to  create  special  effects  such as particle systems, smoke trails, and lens flare coronas.    We billboard an unconstrained quad by forcing its vertices to lie in a plane  that is perpendicular to the direction in which the camera is pointing. Let the vec- tors R and U denote the unit-length world space right direction and up direction  of the current camera view.  These correspond to the camera space x and y axes,  respectively.   The  quad  that  we  wish  to  billboard  is  defined  by  the  following  quantities.    a   The world space position P corresponding to the center of the quad.   b   The width w and height h of the quad. These may be changed over time to   produce the effect of an expanding or shrinking billboard.    c   The angle θ by which the quad should be rotated relative to the camera’s ori- entation. This may be changed over time to produce the effect of a spinning  billboard. If θ is constant, then the quad rotates with the camera about the  view direction.   Using these quantities, we define the vectors X and Y as follows.    9.3  Billboarding   255   cos  θ  +  R  sin  θ  U  X  Y  =  w 2 = −         h 2      θ    w   2  h  +  2   sin  R  cos  U       θ    The rotation θ is typically quantized to some number of possible angles so that a  θ = ,  lookup table may be used for the sine and cosine functions. Of course, if  0 then the expressions for the vectors X and Y reduce to   As illustrated in Figure 9.4, the four vertices  given by   1Q ,   2Q ,   3Q , and   4Q  of the quad are   1  Q P X Y Q P X Y  = + = −  + −  3  2  Q P X Y Q P X Y.   = − = +  + −  4   9.18     9.19     9.20                =  X  R  =  Y  U   .  w 2 h 2  U  1Q  X  θ  P  2Q  Y  3Q  4Q  R     Figure 9.4. Calculating the vertices of an unconstrained billboarded quad.    256   9. Polygonal Techniques            These vertices are arranged in a counterclockwise winding order so that the front  of the quad faces the camera. The corresponding two-dimensional texture map- ping coordinates are given by   s t , 1 1 s t , 3  3  = =  1,1 0,0  s s  2  4  , ,  t t  2  4  = =  0,1 1,0  .    9.21    Billboarded quads whose vertices derive from the vectors X and Y given by    Equation   9.18   are  always  aligned  to  the  plane  of  the  camera.  As  Figure  9.5  demonstrates, this alignment can differ significantly from the plane perpendicular  to the true direction from the quad’s center to the camera position. When hun- dreds  or  thousands  of  small  particles  are  being  rendered,  one  may  wish  to  use  Equation  9.18  for efficiency, but large quads may look better if oriented to face  the actual camera position instead of the plane of the camera.    We  align  a  quad  so  that  it  faces the  camera  position  by  presenting  a  more  computationally expensive formulation of the vectors X and Y. Let the vector C  denote the world space camera position. Assuming that the center P of the quad  does  not  lie  on  the  line  containing  C  and  running  in  the  direction  U,  we  can  calculate   =  Z  − − × × = ×  C P C P U Z U Z B Z A   .  =  A   9.22    Figure 9.5. A billboarded quad that is aligned to the plane of the camera may differ sig- nificantly from a quad that directly faces the camera position.       9.3  Billboarding   257               The  vector  Z  is  the  unit  vector  that  points  from  the  quad’s  center  toward  the  camera position. Calculating the cross product with U produces orthogonal vec- tor A lying in the plane of the billboard. If  ×U Z is close to zero, then we can use  the alternate formula   The vectors A and B form an orthogonal pair of unit vectors that we can use to  express the vectors X and Y:   =  B  × × = ×  Z R Z R A B Z   .  cos  θ  +  A  sin  θ  B  X  Y  =  w 2 = −         h 2      θ    w   2  h  +  2   sin  A  cos  B.       θ     9.23     9.24    Using these in Equation  9.20  produces the vertices of the billboarded quad.   9.3.2  Constrained Quads   We now consider how to orient a quad that is constrained to rotate only about the  z axis. An example of how such a quad might be used is to render the fire texture  for a torch. In this case, the fire is always pointing upward, but the plane of the  quad rotates to face the camera. As long as the camera does not view the quad  from sharply above or below, this produces the convincing illusion that the fire  has volume.    tered at the point P, we define the vector X as   Suppose that the camera resides at the world space point C. For a quad cen-  =  X  −  P C C y  ,  y  x  −  P x  ,0  .    9.25    As shown in Figure 9.6, this vector is constructed by taking the difference be- tween the camera position and the center of the quad, projecting it onto the x-y  0=X plane,  and  rotating  it  90  degrees  counterclockwise  about  the  z  axis.  If  ,  then the camera is either directly above or directly below the quad. In this case,  the quad is being viewed on edge and therefore should not be rendered. Other- wise, we calculate the four vertices   4Q  of the quad as follows.   3Q , and   2Q ,   1Q ,    258   9. Polygonal Techniques         y  X  2w  C  C  x  P− x  x     P  C  y  P− y  Figure  9.6.  Calculating  the  vertices  of  a  billboarded  quad  that  is  constrained  to  rotate  about the z axis.   Q P  = +  1  Q P  = −  3  w 2 w 2  X X X X  +  −  0,0,  0,0,  h 2 h 2  Q P  = −  2  Q P  = +  4  w 2 w 2  X X X X  +  −  0,0,  h 2 h 2  0,0,      9.26    The texture mapping coordinates are the same as those for an unconstrained quad  given by Equation  9.21 .   ,  , N  P P 2  9.3.3  Polyboards  P  can be given some thick- , A polyline defined by a series of N points  1 ness r by constructing a polyboard that traces the polyline in the manner shown  in Figure 9.7. One application of such a polyboard is to render a lightning bolt  whose path is defined by a set of points. Another application is to render a mo- tion-blurred particle for which a number of intermediate positions have been cal- culated between its position on the previous frame and its current position.    lying at a distance r from  the point  and the tangent direction of the polyline at  is given by   iP  defining the polyline, we generate two polyboard vertices  iP . The direction of the line on which these vertices and  iP  lie should be orthogonal to both the direction to the camera position  iZ  to the camera   iP . The unit direction   For each point    9.3  Billboarding   259                  1P  2P  3P  r 4P     =  Z  i  − −  C P i C P i  ,   =  T i  P i P i  + 1  + 1  − −  P i P i  − 1  − 1  ,   =  T 1  T N  =  P 2 P 2 P P  N  N  − − − −  P 1 P 1 P P  .   N  − 1  N  − 1  i  G P i H P i  = =  i  + −         T Z i   T Z .  i  × ×  i  i  r r  Figure 9.7. A polyboard of radius r that traces a polyline.   where C is the camera position. A unit tangent vector  the point   iP  using the formula   iT  may be calculated for   or in the case that   iP  is an endpoint,   The  two  polyboard  vertices  given by   iG   and   iH   corresponding  to  the  point   iP   are  then    9.27     9.28     9.29     9.30     260      9. Polygonal Techniques     Figure 9.8. Polyboards are used to render the curved beams of light in this screenshot.  Shorter polyboards are also used to render the particles flying away from the blast point.   Image from the C4 Engine, courtesy of Terathon Software LLC.    2H , ,  NH  is perpendicular to the direction to the camera. Figure 9.8 demonstrates   Each  edge  of  the  polyboard  constructed  using  the  vertices  NG ,  beams of light rendered using this technique.   2G ,   1G ,   1H ,   9.4  Polygon Reduction   When a model consisting of a large number of triangles is rendered far from the  camera, it is likely that many of the triangles make no perceptible contribution to  the resulting image. By reducing the number of rendered triangles as the distance  from the camera to the model increases, we can reduce the amount of computa- tion needed to process the mesh as well as the amount of data sent to the graphics  hardware.    9.4  Polygon Reduction      261     A common method used to reduce the number of triangles in a mesh is the  edge collapse technique. This method works by locating edges within a triangle  mesh whose removal would not cause a large change in the shape of the model.  The process of removing an edge is called an edge collapse and is performed by  merging the edge’s two endpoints. As illustrated in Figure 9.9, one endpoint re- mains  stationary,  and  the  other  endpoint  is  moved  to  the  same  location  as  the  first. Thus, there are two ways in which an edge can be collapsed, depending on  which endpoint remains stationary. The two triangles sharing the collapsed edge  are eliminated, and any triangles using the moved vertex are stretched to fill in  the space left behind. Of course, since the two endpoints now occupy the same  location, the one that was moved can simply be eliminated. Thus, a single edge  collapse results in the removal of two triangles, one edge, and one vertex from  the mesh.    We  decide  which  edges  to  collapse  in  a  triangle  mesh  by  calculating  two  costs for each edge. A cost is assigned to each endpoint of an edge based on how  much  the  appearance  of  the  triangle  mesh  would  be  altered  if  the  edge  is  col- lapsed by removing that endpoint. Endpoints having the lowest collapse cost de- termine  which  edges  are  the  first  to  be  eliminated.  If  it  is  known  that  an  edge  should definitely not be eliminated, then the collapse costs of its endpoints can be  set to some large value to indicate this.  There are many possible ways to calculate edge collapse costs. The method    presented  in  this  section  assigns  costs  based  on  a  combination  of  the  edge’s  length and the flatness of the triangle mesh on both sides of the edge around the  endpoint being considered for elimination. Suppose that we wish to calculate the  2V .  cost of eliminating the vertex   1V  in Figure 9.10 by collapsing it into the vertex   Figure 9.9. An edge collapse merges the two endpoints of the edge and eliminates the  triangles that share the edge.       262   9. Polygonal Techniques               E  2V  1V  3V  D  3V  B  A     Figure 9.10. Calculating the collapse cost.   1V  by averaging the normals  We first calculate the normal vector N for the vertex  of the surrounding triangles  see Section 7.7.1 . We then define the vector D to  be   where E is the direction pointing from   =  D  × ×  N E N E  ,   2V :   1V  to  −  =  E V V .  1  2   9.31     9.32    It should be noted that if any of the edges leading away from the vertex   1V  and the  The direction D is perpendicular to both the normal to the surface at  edge that we are considering. It will be used to determine on which side of the  edge a point lies.  1V     1V  should not be eliminated because doing  are not shared by two triangles, then  1V  does lie in the  so would change the shape of the triangle mesh’s boundary. If  interior of the mesh, then for each of the two triangles sharing the edge that con- 3V  of the triangle that does not lie on the  nects  edge to determine whether the triangle lies on the positive side or negative side of  the edge. If the condition   2V , we examine the vertex   1V  and   D V V 1  3  −  ⋅        ≥  0     9.33     9.4  Polygon Reduction   263         Let   posT  and   is satisfied, then the triangle lies on the positive side of the edge; otherwise, it lies  on the negative side of the plane. We must have one of each, so if both triangles  lie on the positive side or both triangles lie on the negative side, then the edge  should not be collapsed.  posT  represent the unit-length normal vector of the triangle lying on the    negT  represent the unit-length normal vector of  positive side of the edge, and let  the triangle lying on the negative side of the edge. We estimate the flatness of the  triangle mesh on either side of the edge being considered for collapse by compar- negT  to those of the other triangles using the vertex  ing the normal vectors  1V . As we examine these triangles, we maintain a value d corresponding to the  smallest dot product found between the normal of any triangle occupying space  posT  and between the normal of any  on the positive side of the edge and the vector  triangle occupying space on the negative side of the edge and the vector  negT . A  value of d near one indicates that the mesh is  mostly flat on either side of the  edge,  but  a  small  value  of d  indicates  that  large  angles  exist  between  triangles  1V . If d falls below some threshold corresponding to the maxi- sharing the vertex  2V  should not  mum surface roughness allowed, then the edge connecting  be collapsed. Otherwise, we assign the cost c to the edge using the formula      9.34   To clarify the procedure for calculating the value of d, suppose that a triangle    2V  , and has the unit- has vertices  length normal vector T. We classify the vertices A and B as lying on the positive  side of the edge, on the negative side of the edge, or on the edge itself by examin- ing the dot products   1V , A, and B  where neither A nor B is equal to   1V  and   E .     1  =  −  d  c     = ⋅ = ⋅    D A V 1   D B V   1 .  − −       a b   9.35     The quantities a and b represent the distances from the plane containing the edge  ε>   or b ε>   for  some  and  having  normal  vector  D  to  the  points  A  and  B.  If  a small distance ε, then we consider the corresponding point to lie on the positive  ε< − , then we consider the correspond- side of the edge. Similarly, if a ing point to lie on the negative side of the edge. Points lying within the distance ε  of the edge are considered to be lying on the edge itself. If either A or B lies on  the positive side of the edge, then we replace the minimum dot product d with the  dot product   ε< −  or b  pos  ⋅T T  if it is smaller:  ←  d  min  {  d  ,  ⋅T T  }pos .    9.36     264   9. Polygonal Techniques         Figure 9.11. The edge collapse cost calculation allows the collapse of an edge between  two triangles having largely differing orientations as long as the triangle mesh is reasona- bly flat on both sides of the edge.      If either A or B lies on the negative side of the edge, then we replace d with the  dot product   neg  ⋅T T  if it is smaller:  ←  d  min  {  d  ,  ⋅T T  }neg .    9.37    It is possible that both of the operations given by Equations  9.36  and  9.37  are  performed for a single triangle.    The edge collapse cost calculation presented in this section allows the col- lapse of an edge such as that shown in Figure 9.11. As long as the triangle mesh  is reasonably flat on both sides of the edge, a collapse may occur along an edge  between two triangles having largely differing orientations.  Figure 9.12 shows the original triangle mesh for a chunk of terrain and the    same surface after 35 percent of its triangles have been eliminated using the edge  collapse  technique.  Notice  how  edges  in  regions  of high  triangle  concentration  and regions of relative flatness were the first edges chosen to be removed.   9.5  T-Junction Elimination   Suppose that a scene contains two polygons that share a common edge, as shown  in Figure 9.13 a . When two such polygons belong to the same model, the verti- ces representing the endpoints of the common edge are not ordinarily duplicated  unless some vertex attribute  such as texture coordinates  is different for the two  polygons. Vertices shared by multiple polygons are usually stored once in an ar- ray and referenced multiple times by the polygons that use them. Graphics hard- ware  is  designed  so  that  when  adjacent  polygons  use  exactly  the  same  coordi- nates for the endpoints of shared edges, rasterization produces sets of pixels that    9.5  T-Junction Elimination      265          Figure 9.12. The left image shows a chunk of terrain made up of 938 faces generated  directly from an underlying data field. In the right image, unimportant edges have been  collapsed, reducing the number of faces to 606.  Image from the C4 Engine, courtesy of  Terathon Software LLC.    are precise complements of each other. Along the shared edge, there is no over- lap between the pixels belonging to one polygon and those belonging to the oth- er, and there are no gaps where pixels do not belong to either polygon.    A problem arises when adjacent polygons belong to different objects. Each  object has its own copy of the endpoint vertices for the shared edge, and these  vertices may differ greatly in each object’s local coordinate space. When the ver- tices  are  transformed  into  world  space,  floating-point  round-off error  may  pro- duce slightly different positions for each object. Since the vertex coordinates are  no longer exactly equal, a seam may appear when the polygons are rasterized.    A larger problem occurs when two polygons have edges that fall within the  same line in space but do not share the same endpoints, as illustrated in Figure  9.13 b . In such a situation, a vertex belonging to one polygon lies within the in-    a    b   Figure 9.13.  a  Two polygons share an edge and both endpoint vertices.  b  Two poly- gons share an edge but do not share endpoint vertices. The location where a vertex of one  polygon lies on the edge of another polygon is called a T-junction.       266   9. Polygonal Techniques         terior of an edge belonging to the other polygon. Due to the shape that the edges  form, the location at which this occurs is called a T-junction. Because the adja- cent edges do not share identical endpoints, T-junctions are a major cause of vis- ible seams in any real-time graphics engine that does not take measures to elimi- nate them.    In this section, we describe how to detect possible sources of seams in com- plex  3D  scenes  and  how  to  modify  static  geometry so  that  visible  artifacts  are  avoided. The removal of seams is absolutely necessary in order for graphics en- gines to employ stencil shadow techniques for global illumination  see Section  10.4.1 . When T-junctions are eliminated, new vertices are added to existing pol- ygons. A method for triangulating arbitrary polygons is described in Section 9.6.    Given an immovable object A in our world, we need to determine whether  there exist any other immovable objects possessing a vertex that lies within an  edge of object A. We consider only those objects whose bounding volumes inter- sect the bounding volume of object A. Let object X be an object that lies close  enough to object A to possibly have adjacent polygons. We treat both objects as  collections of polygons having the greatest possible number of edges. We per- form triangulation of these polygons after the T-junction elimination process to  avoid the creation of superfluous triangles.    Before we locate any T-junctions, we first want to find out if any of object  A’s vertices lie very close to any of object X’s vertices. We must transform the  vertices  belonging  to  both  objects  into  some  common  coordinate  space  and  search for vertices separated by a distance less than some small constant ε. Any  XV   of  object  X  should  be  vertex  XV   have  the  exact  same  coordinates.  This  procedure  is  moved  so  that  sometimes called welding.    Once existing vertices have been welded, we need to search for vertices of  object X that lie within a small distance ε of an edge of object A but do not lie  within the distance ε of any vertex of object A. This tells us where T-junctions  2P  be endpoints of an edge of object A, and let Q be a vertex of  occur. Let  1P  and  2d   between  the  point  Q  and  the  line  passing  object  X.  The  squared  distance  through  1P  and  2P  is given by   AV   of  object  A  that  is  this  close  to  a  vertex   AV   and   2  d  =     −  Q P 1     2  −  [     −  Q P 1   P 2      ⋅ −  P 2 P 1  −   2     ]  2  P 1  .    9.38    2  2  d  ε< , then we know that the point Q lies close enough to the line containing  If  the edge of object A, but we still need to determine whether Q actually lies be-   9.6  Triangulation   267         2P .  We  can  make  this  determination  by  measuring  the  projected  1P  and   1P  to Q onto the edge formed by   1P   and   tween  length t of the line segment connecting  2P . This length is given by     =  t  −Q P  1 cos  α  ,   where α is the angle between the line segment and the edge. Using a dot product  to compute the cosine, we have    9.39     9.40    =  t     −  Q P 1 P      ⋅ −  2  2  P P 1  −     P 1  .   t  >  ε<  or   If t P 2 edge  formed  by  vertex should be added to the polygon of object A between  1P  and  Q’s location.   − − , then the point Q does not lie within the interior of the  P ε 1 2P .  Otherwise,  we  have  found  a  T-junction, and  a  new  1P   and  2P  precisely at   9.6  Triangulation   Triangulation is the process by which a polygon is divided into triangles that use  the same array of vertices and collectively cover the same area. Polygons must be  triangulated before they can be passed to the graphics hardware. A polygon hav- 2n −   triangles.  Convex  polygons  are  ing  n  vertices  is  always  decomposed  into  particularly easy to triangulate—we simply choose one vertex and connect edges  to every other nonadjacent vertex to form a triangle fan like the one shown in  Figure 9.14. Polygons that are not convex or possess three or more collinear ver- tices cannot generally be triangulated in this way, so we have to employ more  complicated algorithms.   Figure 9.14. A convex polygon can be triangulated by connecting edges from one arbi- trarily chosen vertex to every other nonadjacent vertex, creating a triangle fan.       268      9. Polygonal Techniques     A modeling system may produce a list of polygons that might be convex or  concave. After static world geometry has been processed by performing welding  and  T-junction  elimination,  any polygon  may  also  contain  several  vertices  that  are  collinear   or  at  least  nearly  collinear   with  some  of  its  other  vertices.  This  prevents us from using a simple fanning approach that might ordinarily be used  to  triangulate  a  convex  polygon.  We  are  instead  forced  to  treat  the  polygon  as  concave.  The algorithm that we describe takes as input a list of n vertices wound in a    2n −  triangles. At each itera- counterclockwise direction and produces a list of  tion, we search for a set of three consecutive vertices for which the corresponding  triangle is not degenerate, is not wound in the wrong direction, and does not con- tain any of the polygon’s remaining vertices. The triangle formed by such a set of  three vertices is called an ear. Once an ear is found, a triangle is emitted, and the  middle  vertex  is  disqualified  from  successive  iterations.  The  algorithm  repeats  until only three vertices remain. This process of reducing the size of the triangu- lation problem by removing one ear at a time is called ear clipping.    In order to determine whether a set of three vertices is wound in a counter- 0N   of  the  clockwise  direction,  we  must  know  beforehand  the  normal  direction  3P  represent the  2P , and  1P ,  plane containing the polygon being triangulated. Let  positions of the three vertices. If the cross product       − − P P P P  points in  1 3 2 1 0N ,  then  the  corresponding  triangle  is  wound  the  same  direction  as  the  normal  counterclockwise. If the cross product is near zero, then the triangle is degener- ate. Thus, two of our three requirements for a triangle are satisfied only if   ×              −  −  P 3  P 2    × P 1 ε ≈ for some small value ε  typically,    Our third requirement is that the triangle contains no other vertices belonging  3N   to  the  polygon.  We  can  construct  three  inward-facing  normals  corresponding to the three sides of the triangle, as follows.   2N ,  and   P N 1   9.41    0.001  1N ,    .   >  ε        ⋅  0  1  N N N N N N  = = =  2  0  0  × × ×         P 1 P 2    P 2   P 3   P P   1  − − −  3  3    As shown in Figure 9.15, a point Q lies inside the triangle formed by  1P ,  3P  if and only if    Since  we  have  to  calculate  the  normals  given  by  Equation   9.42   for  each  triangle,  we  can  save  a  little  computation  by  replacing  the  condition  given  by    9.42   2P , and   N Q P i  } { 1,2,3 .    for   > −  i ∈  −  ε        ⋅  0  i   9.6  Triangulation   269         3P  3N  1N  2N  Q  1P  2P  ε     Figure 9.15.  A  point  Q  lies  in  the  interior  of  a  triangle   or  nearly  on  its  boundary   if  N Q P i  } { 1,2,3 .    for   i ∈  > −  −  ε        ⋅  i  Equation  9.41  with the equivalent expression     N P 3  ⋅  1  −  P 1     >  ε  .    9.43    3P  lies on the positive side of the edge con-  This determines whether the point  necting  1P  and  2P .  The  implementation  shown  in  Listing  9.2  maintains  a  working  set  of  four    consecutive vertices and at each iteration determines whether a valid triangle can  be formed using the first three vertices or the last three vertices of that group. If  only one of the sets of three vertices forms a valid triangle, then that triangle is  emitted, and the algorithm continues to its next iteration. If both sets of three ver- tices  can  produce  valid  triangles,  then  the  code  selects  the  triangle  having  the  larger smallest angle. In the case that neither set of three vertices provides a valid  triangle, the working set of four vertices is advanced until a valid triangle can be  constructed.    The method presented in Listing 9.2 was chosen so that the output of the al- gorithm would consist of a series of triangle strips and triangle fans. Such a tri- angle structure exhibits excellent vertex cache usage on modern graphics proces- sors.  The  implementation  also  includes  a  safety  mechanism.  If  a  polygon  is  passed to it that is degenerate, self-intersecting, or otherwise nontriangulatable,  then the algorithm terminates prematurely to avoid becoming stuck in an infinite  loop. This happens when the code cannot locate a set of three consecutive verti- ces that form a valid triangle.    270      9. Polygonal Techniques   Listing 9.2. The TriangulatePolygon   function takes an arbitrary planar polygon having n  vertices and triangulates it, producing at most  Parameters       vertexCount  The number of vertices.  vertex   2n −  triangles.   A pointer to an array of n  Point3D structures representing the polygon’s  vertices.  The polygon’s normal direction.  A pointer to an array of  triangulation are stored.   2n −  Triangle structures where the results of the        normal  triangle   return  x ;   for  ;;   {   if  ++x == vertexCount  x = 0;   if  active[x]   }   const float epsilon = 0.001F;    static long GetNextActive long x, long vertexCount, const bool *active   {            }    static long GetPrevActive long x, long vertexCount, const bool *active   {            }    long TriangulatePolygon long vertexCount, const Point3D *vertex,    {               bool *active = new bool[vertexCount];  for  long a = 0; a < vertexCount; a++  active[a] = true;    long triangleCount = 0;  long start = 0;  long p1 = 0;   for  ;;   {   if  --x == -1  x = vertexCount - 1;   if  active[x]   }    const Vector3D& normal,   Triangle *triangle    return  x ;    9.6  Triangulation      271                                                                                    triangle->index[0] = m1;  triangle->index[1] = p1;  triangle->index[2] = p2;  triangleCount++;   {      Only three vertices remain.           break;  }     long p2 = 1;  long m1 = vertexCount - 1;  long m2 = vertexCount - 2;    bool lastPositive = false;  for  ;;   {   if  p2 == m2                      const Point3D& vp1 = vertex[p1];   const Point3D& vp2 = vertex[p2];   const Point3D& vm1 = vertex[m1];   const Point3D& vm2 = vertex[m2];   bool positive = false;   bool negative = false;        Determine whether vp1, vp2, and vm1 form a valid triangle.     if  n1 *  vp1 - vp2  > epsilon                              {           for  long a = 0; a < vertexCount; a++                  {      Look for other vertices inside the triangle.   if   active[a]  &&  a != p1  &&  a != p2  &&  a != m1             positive = true;  Vector3D n2 =  normal %  vp1 - vm1 .Normalize   ;  Vector3D n3 =  normal %  vp2 - vp1 .Normalize   ;     {   const Vector3D& v = vertex[a];   if   n1 *  v - vp2 .Normalize   > -epsilon      Vector3D n1 = normal %  vm1 - vp2 .Normalize  ;   &&  n2 *  v - vm1 .Normalize   > -epsilon           272      9. Polygonal Techniques                                                                                              }   positive = false;               }                 }     n1 = normal %  vm2 - vp1 .Normalize  ;   &&  n3 *  v - vp1 .Normalize   > -epsilon       {     break;  }   negative = true;  Vector3D n2 =  normal %  vm1 - vm2 .Normalize   ;  Vector3D n3 =  normal %  vp1 - vm1 .Normalize   ;                           Determine whether vm1, vm2, and vp1 form a valid triangle.     if  n1 *  vm1 - vp1  > epsilon                                                   If both triangles are valid, choose the one having     if   positive  &&  negative           {           for  long a = 0; a < vertexCount; a++                               }     {      Look for other vertices inside the triangle.                        }   if   active[a]  &&  a != m1  &&  a != m2  &&  a != p1    {   const Vector3D& v = vertex[a];                }   if   n1 *  v - vp1 .Normalize   > -epsilon       {     break;  }   {   float pd =  vp2 - vm1 .Normalize   *  vm2 - vm1 .Normalize  ;   float md =  vm2 - vp1 .Normalize   *  vp2 - vp1 .Normalize  ;   &&  n2 *  v - vm2 .Normalize   > -epsilon   &&  n3 *  v - vm1 .Normalize   > -epsilon        the larger smallest angle.   negative = false;    9.6  Triangulation      273                                                                                    false;    if  fabs pd - md  < epsilon   {     if  lastPositive  positive =     else negative = false;      }   else  {     if  pd < md  negative =     else positive = false;      }  }     false;                            if  positive                                else if  negative                            {      Output the triangle m1, p1, p2.                        }   active[p1] = false;  triangle->index[0] = m1;  triangle->index[1] = p1;  triangle->index[2] = p2;  triangleCount++;  triangle++;    p1 = GetNextActive p1, vertexCount, active ;  p2 = GetNextActive p2, vertexCount, active ;  lastPositive = true;  start = -1;   {      Output the triangle m2, m1, p1.                       active[m1] = false;  triangle->index[0] = m2;  triangle->index[1] = m1;  triangle->index[2] = p1;  triangleCount++;  triangle++;    m1 = GetPrevActive m1, vertexCount, active ;  m2 = GetPrevActive m2, vertexCount, active ;  lastPositive = false;    274   9. Polygonal Techniques               break;   start = -1;      polygon without finding a valid triangle.       }     else  {        Exit if we've gone all the way around the         if  start == -1  start = p2;     else if  p2 == start               Advance working set of vertices.                    }  }    delete[] active;  return  triangleCount ;   m2 = m1;  m1 = p1;  p1 = p2;  p2 = GetNextActive p2, vertexCount, active ;                                         }   Chapter 9 Summary   Depth Value Offset  To offset the depth of a vertex whose z coordinate is roughly  the   where   zP  by a distance δ,   3,3  entry of the perspective projection matrix should be multiplied by 1 ε+ ,   = −  ε  2 f  fn δ   + n P P z      z   .     +     δ  Decal Application  A decal of width w and height h centered at the point P, having normal direction  N and tangent direction T, should be clipped to the planes   left  =  T ,  − ⋅  T P      w 2      right  = −  T ,      w 2  + ⋅   T P       Chapter 9 Summary   275   bottom  front  ,  =   B     = −  N  h 2 d ,  − ⋅  B P + ⋅     N P     top  = −  B  ,  back  =  N  ,  d        + ⋅  h 2 − ⋅  B P    N P  ,         where  = × B N T and d is the maximum distance that any vertex in the decal may  be from the tangent plane passing through the point P. The texture coordinates  for a decal vertex Q are given by   =  s  =  t  T Q P  −  ⋅        B Q P  −  ⋅        w  h  +  +  1 2 1 2  .   Billboarding  The vertices of an unconstrained billboarded quad of width w, height h, and ori- entation θ centered at the point P may be calculated using  + −  Q P X Y Q P X Y,   Q P X Y Q P X Y  = + = −  = − = +  + −     1  2  3  4  cos  θ  +  R  sin  θ  U  X  Y  =  w 2 = −         h 2      θ    w   2  h  +  2   sin  R  cos  U,       θ    and  the  directions  R  and  U  are  the  world  space  right  and  up  directions  of  the  camera view. The vertices of a billboarded quad constrained to rotate only about  the z axis are given by   Q P  = +  1  Q P  = −  3  w 2 w 2  X X X X  +  −  0,0,  0,0,  h 2 h 2  Q P  = −  2  Q P  = +  4  w 2 w 2  X X X X  +  −  0,0,  0,0,  h 2 h 2    ,                 where   where    276   9. Polygonal Techniques   =  X  −  P C C y  ,  y  x  −  P x  ,0  ,   and C is the world space camera position.   T-Junction Elimination  The squared distance  2P  is given by   2d  between the point Q and the line passing through  1P  and   2  d  =     −  Q P 1     2  −  [     −  Q P 1   P 2      ⋅ −  P 2 P 1  −   2     ]  2  P 1  .   2  t  −  P 2  < <  ε<  lies within the interior of the edge formed by  1P  and  d A point Q satisfying  2 − 2P  if  ε ε , where t is given by      ⋅ −  P 1  P 1  −  =  −  .         t     2  Q P 1 P  P P 1  2  Triangulation  A point Q lies inside  or near the boundary of  a triangle defined by the three  vertices  1P ,   for  i ∈  2P , and  3P  belonging to a polygon if and only if   } { 1,2,3 , where   N Q P i  > −  −  ε        ⋅  i  0N  is the polygon’s normal direction. The triangle is wound counterclock-  and  wise and is nondegenerate if   1  N N N N N N  = = =  2  3  0  0  0  × × ×         2  P P 3 P 1  − − −    P 1   P 2   P   3 ,    N P 3  ⋅  1  −  P 1     >  ε  .                                 Exercises for Chapter 9      Exercises for Chapter 9   277   f =  1.  Suppose that the distance to the near plane is   1n = , and the distance to the   for a particular view frustum. Calculate by what value   3,3  entry of the projection matrix should be multiplied in order to off- z = −  toward the camera by a distance   far plane is  the   set a model centered at a depth of  of 0.2.   100  20  2.  Calculate the least distance d by which the model in Exercise 1 can be offset   toward the camera if a 16-bit depth buffer is used.   3.  Write a program that applies a decal to a surface. Assume that the decal is  described  by  its  center  P,  a  normal  direction  N,  a  tangent  direction  T,  its  width w, and its height h. The program should construct a decal object by  clipping  an  arbitrary  triangle  mesh  to  the  planes  bounding  the  decal  and  should then calculate texture coordinates for each vertex in the decal object.   4.   Implement a particle system for which each particle is rendered as a textured  quad centered at the particle’s position. Each particle should be described by  its position P in world space, its radius r, its window-space orientation θ,  and its velocity V.    This page intentionally left blank    Chapter 10   Shadows   Shadows are an essential component of any rendered scene that attempts to de- pict a realistic environment because they provide many visual cues about the lo- cation of objects in 3D space. The methods used to generate shadows in real-time  applications  fall  into  two  broad  categories.  The  first  category  is  called shadow  mapping  or  shadow  buffering,  and  it  is  an  image-based  algorithm  that  uses  a  depth image generated from the location of a light source. The second category is  known  as  stencil  shadows   due  to  its  use  of  the  stencil  buffer ,  or  sometimes  shadow volumes, and it is a geometric technique that derives volumes of space  for which light is blocked by shadow-casting objects. In this chapter, we provide  an introduction to both types of shadow rendering. There are several variations of  the  shadow  mapping  technique   and  this  is  still  an  active  area  of  research   for  which we do not go into the details, but we do provide details for the shadow  volumes technique because it is more mature, and there is a generally accepted  best way to implement it.   10.1  Shadow Casting Set   In Chapter 8, we discussed methods for determining whether an object is visible  to the camera, and we presumed that we could ignore any object that didn’t inter- sect the view frustum when we rendered a scene. However, as soon as we intro- duce a shadow-casting light source, the set of objects that can be directly seen by  the camera may no longer be the full set of objects that needs to be considered.  There  could  be  objects  outside  the  view  frustum,  and  thus  not  directly  visible,  that cast shadows into the view frustum onto other objects that are visible. Ignor- ing  these  objects  would  cause  visible  shadows  to  appear  and  disappear  as  the  camera moves and objects enter or exit the view frustum.    The set of shadow-casting that we need to consider is clearly a superset of  the set of visible objects, and the position of the light source relative to the view  frustum determines which additional objects must participate in shadow genera-        279    280      L  10. Shadows   Figure 10.1. Any objects that could cast shadows into the view frustum must intersect the  convex hull enclosing the view frustum and the position L of the light source. The blue  lines represent the edges of the view frustum between planes that face toward the light  source and planes that face away from the light source.      tion. In the case that the light source is actually inside the view frustum, we do  not need to consider any more than the visible set of objects because shadows can  only be cast out of the view frustum. For the only other case, that the light source  lies outside the view frustum, we need to be able to identify objects that are posi- tioned between the light source and the view frustum in such a way that shadows  could fall upon visible objects. This can be achieved by considering the convex  hull enclosing the view frustum and the light source, as shown in Figure 10.1.  For an object to cast any part of its shadow into the view frustum, it must inter- sect this region of space.    We construct the convex hull enclosing the view frustum and the light source  by assembling a set of planes for which the intersection of all the positive half- spaces  represents  the  shadow-casting  region.  First,  we  test  the  light  position  against the six planes of the view frustum  see Table 5.1  by taking the dot prod- uct between the four-dimensional plane vector and the homogeneous light posi- tion with a w coordinate of one. The planes for which this dot product is positive  form  part  of  the  boundary  of  the  convex  hull.  Then,  for  each  pair  of  adjacent  frustum planes, if one has a positive dot product and the other does not, then we  calculate a new plane defined by the edge between those two frustum planes and  the  position  of  the  light  source,  making  sure  that  the  plane’s  normal  direction  faces inward.    10.2  Shadow Mapping      281     In the case that an infinite view frustum is being used, the far plane is ig- nored, and the edges that would lie between the far plane and any of the four side  planes never participate in the construction of a new plane. The shadow-casting  region is infinitely large in this case, but it is still convex and properly bounded.    Once  the  bounding  planes  of  the  shadow-casting  region  have  been  deter- mined, we test for object intersection just as we would for the ordinary view frus- tum. For each plane, we check to see whether the object lies completely on the  negative side of any plane, and if it does, then it is rejected as a potential shadow  castor.   10.2  Shadow Mapping   The technique known as shadow mapping is so named because a scene is ren- dered from the perspective of a light source to generate  a special shadow map  that is subsequently used in the ordinary rendering pass from the camera’s per- spective. Instead of three-component color, each pixel in the shadow map holds a  single  number  representing  the  depth  of  the  associated  point  in  the  scene  with  respect to the light source, as shown in Figure 10.2. Since it is an image-based  technique, shadow mapping can be used to generate shadows for objects that use  the alpha test to cut holes in their surfaces, as is often done for things like the  leaves on a tree. Using the stencil shadow technique for these kinds of objects is  impractical.   10.2.1  Rendering the Shadow Map  In order to render a shadow map, we first determine the region of space in which  shadow castors may be positioned, as described in the previous section. We then  create a bounding box for that region that is aligned to the light source’s coordi- nate axes, as shown in Figure 10.3. The z axis points in the opposite direction that  the light is shining, and the x and y axes represent the horizontal and vertical di- rections in the shadow map. Shadow mapping is most easily implemented for an  infinite light or spot light because each has a specific lighting direction. Shadow  mapping for point lights is more difficult, but recent advancements in graphics  hardware has made this more practical.1    After the aligned bounding box has been determined, we position the camera  at the light source’s location, point it in the direction of the light, and set up an                                                         1 For instance, complete cube shadow maps can be rendered in a single pass using ge- ometry shaders, and depth-based cube maps are supported in OpenGL 3.0 and later.    282      10. Shadows        Figure  10.2.  The  left  image  shows  a  scene  in  which  shadows  have  been  generated  using  the  shadow mapping technique. The right image shows the shadow map in grayscale, where brighter  values represent a greater depth from the perspective of the light source. Where the shadow map  appears  to  be  missing  pieces  of  the  terrain,  geometry  has  actually  been  culled  because  it  lies  outside the shadow casting region illustrated in Figure 10.1.  Image from the C4 Engine, courtesy  of Terathon Software LLC.    z =  0  z  y  O  z  z=  max     Figure 10.3. A shadow map is rendered in the coordinate system of the light source. The  z−  axis  points in the direction that the light is shining and represents depth. The x and y axes are aligned to  the s and t directions in the shadow map.  The x axis points out of the page in this figure.     10.2  Shadow Mapping   283         Let   orthographic projection that precisely encloses the bounding box. For each object  that is to be rendered in the shadow map, the vertex shader needs to transform the  vertices  into  the  camera’s  local  coordinate  system  and  apply  the  projection,  as  would normally be done for the main camera.  objectM  be the 4 4×  matrix that transforms points in the space of the object    lightM  be the  being rendered into a common world-space coordinate system. Let  matrix that transforms points in the space of the light source into world space.  Then points are transformed from object space to light space through the matrix  −M M . The orthographic projection is then applied by multiplying  1 product  light by the matrix   object  M  proj  =  y  max  y  min  ,    10.1    x  max  x  min  2 −  0  0  0               0  2 −  0  0  0  0  0  −  2  z  max  max  max  max  −  −  x x y y  + − + −  x x y y  min  min  min  min  max − 1  1               t  f  r  ,   ,   ,   b  max  z=  ,  min  x=  y=  where  the  minimum  and  maximum  x  and  y  values  represent  the  extents  of  the  bounding box in light space, and  maxz  represents the z coordinate of the maximum  projM  is the projection matrix given by Equation  5.58  with  depth in light space.   x= y= 0n = .  When rendering the shad- l min M M M  to  ow map, the vertex shader should apply the matrix product  each vertex.    The viewport should be set up to render into a depth-only render target for  which the depth buffer has been allocated as a texture map whose pixels use a  depth  format.  The  viewport  transformation  should  be  set,  using  the  glView- port    function  in  OpenGL,  to  the  dimensions  of  the  shadow  map’s  render  target.   , and   − 1 light  object  max  max  proj  10.2.2  Rendering the Main Scene  During the ordinary rendering pass from the main camera, texture coordinates for  the  shadow  map  are  generated  by  transforming  vertices  into  the  light  source’s  coordinate space, applying the orthographic projection, and then applying a scale  and bias to produce normalized texture coordinates for the shadow map. Three    284   10. Shadows         coordinates are generated during this transformation, the s and t coordinates that  are normally used to access a two-dimensional texture map and a p coordinate  that represents the depth of the vertex in the space of the shadow map. These co- ordinates  are  interpolated  across  the  face  of  a  triangle,  and  the  p  coordinate  is  ,s t  coordinates. If the  compared to the depth stored in the shadow map at the  depth p is greater, then the point corresponding to the pixel being drawn lies in  shadow.  Most GPUs have the functionality for making this comparison built into  the  hardware,  and  it  is  enabled  in  OpenGL  by  making  a  call  to  the  glTex- Parameteri    function  to  set  the  value  of  GL_TEXTURE_COMPARE_MODE  to  GL_COMPARE_REF_TO_TEXTURE for the shadow map texture.     given by   The  viewport  transformation  used  to  calculate  shadow  map  coordinates  is   M  viewport  =  0 0 1 1 2 2 0 0 1 1 2 2 0 0 1 1 2 2 0 0 0 1            .       10.2    − 1 light  proj  object  M  viewport  projM ,   lightM ,  and   M M M  should be precalculated one  The entire matrix product  time per object and stored as a constant accessible to the vertex shader.  The ma- trices  objectM   should  be  identical  to  those  used  in  the  shadow  map generation phase.  The vertex shader should apply this matrix to an object- s t p q  texture coordinates that  space vertex position in order to generate the  , , are passed to the fragment shader and used to sample the shadow map. The q co- ordinate is normally going to be one all the time, so the fourth row of the matrix  need not participate.   ,  10.2.3  Self-Shadowing  A well-known problem that occurs with the shadow mapping technique is a self- shadowing artifact often called shadow acne, as illustrated in Figure 10.4. This  problem  is  due  to  the  finite  precision  available  for  storing  depth  values  in  the  shadow map. A conventional integer depth buffer stores 24 bits per pixel,2 and  the values are evenly spaced between the minimum and maximum depths.  Float- ing-point  depth  buffers  are  also  available  on  recent  GPUs,  and  the  spacing                                                          2 A depth buffer is usually combined with a stencil buffer that stores 8 more bits of in- formation per pixel in an interleaved fashion, for a total of 32 contiguous bits per pixel.    10.2  Shadow Mapping      285     Figure 10.4. In the left image, a depth offset is used to prevent self-shadowing artifacts. Without  this offset, striped shadowing artifacts can be seen on the concrete and rock in the right image.   Image from the C4 Engine, courtesy of Terathon Software LLC.       between representable values varies with depth.  When a surface is rendered at  an oblique angle relative to the direction of the light, the depths of many pixels in  a small neighborhood may be quantized to the same value in the shadow map. As  shown in Figure 10.5, this can result in some of the pixels being shadowed while  others are not.    The most straightforward solution to the self-shadowing problem is to apply  an offset to the values in the shadow map to make them appear slightly deeper  than they would normally be. This eliminates the shadow artifacts by moving the  shadow-casting surface underneath the actual surface that we render by a small  distance.  However,  as  the  surface  of  an  object  becomes  more  oblique  with  re- spect  to  the  light  direction,  a  greater  offset  must  be  used  in  order  to  fix  the  problem.    Fortunately, OpenGL provides a function called glPolygonOffset   that  applies a depth offset that depends on the camera-space slope of the surface at  each pixel. The following code solves the self-shadowing problem in most cases:   glEnable GL_POLYGON_OFFSET_FILL ;  glPolygonOffset 1.0F, 1.0F ;   It’s possible to use larger values to handle more problematic scenes, but values  that are too large result in shadows appearing to be disconnected from the objects  that are casting them.    286      10. Shadows   Lit  Shadowed  z  k= z k= +  1 k= +  z  2  Figure 10.5. This figure demonstrates how the finite precision of the depth buffer leads  to self-shadowing artifacts. Since the depth stored in a shadow map can only take on spe- k +  here, any surface not perpendicular  cific integer values, represented by k,  to the light direction goes in and out of its own shadow.   1k + , and   2     10.3  Stencil Shadows   The stencil shadows technique can be used to render accurate shadows for fully  dynamic scenes using any type of light source residing at any location. Unlike  shadow mapping, however, stencil shadows require a significant amount of geo- metrical computation that must usually be performed by the CPU. The advantage  is that the shadows are as accurate as the polygonal representation of the models  that cast them, completely avoiding aliasing artifacts.   10.3.1  Algorithm Overview  Using  an  idea  that  was  first  conceived  in  the  1970s,3  the  stencil  buffer  can  be  employed to generate extremely accurate shadows in real time. Two decades af- ter the algorithm’s invention, 3D graphics hardware finally advanced to the point                                                         3  Frank  Crow,  “Shadow  Algorithms  for  Computer  Graphics”,  Proceedings  of  SIG- GRAPH, 1977, pp. 242–248.    10.3  Stencil Shadows      287   where stencil shadows became practical, but several unsolved problems still ex- isted that prevented the algorithm from working correctly under various condi- tions. These problems have now been solved, and stencil shadows can be robust- ly implemented to handle arbitrarily positioned point lights and infinite direction- al lights having any desired spatial relationship with the camera.    The basic concept of the stencil shadow algorithm is to use the stencil buffer  as a masking mechanism that prevents pixels in shadow from being drawn during  the rendering pass for a particular light source. This is accomplished by rendering  an  invisible  shadow  volume  for  each  shadow-casting  object  in  a  scene  using  stencil operations that leave nonzero values in the stencil buffer wherever light is  blocked.  Once  the  stencil  buffer  has  been  filled  with  the  appropriate  mask,  a  lighting pass only illuminates pixels where the value in the stencil buffer is zero.    As shown in Figure 10.6, an object’s shadow volume encloses the region of  space  for  which  light  is  blocked  by  the  object.  This  volume  is  constructed  by  finding  the  edges  in  the  object’s  triangle  mesh  representing  the  boundary  be- tween lit triangles and unlit triangles and extruding those edges away from the  light source. Such a collection of edges is called the object’s silhouette with re- spect to the light source. The shadow volume is rendered into the stencil buffer  using operations that modify the stencil value at each pixel depending on whether  the depth test passes or fails. Of course, this requires that the depth buffer has  already been initialized to the correct values by a previous rendering pass. Thus,  the scene is first rendered using a shader that applies surface attributes that do not  depend  on  any  light  source,  such  as  ambient  illumination,  emission,  and  envi- ronment mapping.   L  Figure 10.6.  An  object’s  shadow  volume  encloses  the  region  of  space  for  which  light  emitted by the light source L is blocked by the object.       288      10. Shadows   0  1−  1  1  1+  1+  1+  C  0     Figure 10.7. Numbers at the ends of rays emanating from the camera position C repre- sent the values left in the stencil buffer for a variety of cases. The stencil value is incre- mented when front faces of the shadow volume pass the depth test, and the stencil value  is decremented when back faces of the shadow volume pass the depth test. The stencil  value is not changed when the depth test fails.     The original stencil algorithm renders the shadow volume in two stages. In  the first stage, the front faces of the shadow volume  with respect to the camera   are  rendered  using  a  stencil  operation  that  increments  the  value  in  the  stencil  buffer whenever the depth test passes. In the second stage, the back faces of the  shadow volume are rendered using a stencil operation that decrements the value  in the stencil buffer whenever the depth test passes. As illustrated in Figure 10.7,  this technique leaves nonzero values in the stencil buffer wherever the shadow  volume  intersects  any  surface  in  the  scene,  including  the  surface  of  the  object  casting the shadow.    There  are  two  major  problems  with  the  method  just  described.  The  first  is  that no matter what finite distance we extrude an object’s silhouette away from a  light source, it is still possible that it is not far enough to cast a shadow on every  object in the scene that should intersect the shadow volume. The example shown  in Figure 10.8 demonstrates how this problem arises when a light source is very    10.3  Stencil Shadows      289   L  d  d  Figure  10.8.  No  matter  what  finite  distance  d  an  object’s  silhouette  is  extruded  away  from a light source L, moving the light close enough to the object can result in a shadow  volume that cannot reach other objects in the scene.      close  to  a  shadow-casting  object.  Fortunately,  this  problem  can  be  elegantly  solved by using a special projection matrix and extruding shadow volumes all the  way to infinity.    The second problem shows up when the camera lies inside the shadow vol- ume or the shadow volume is clipped by the near plane. Either of these occur- rences can leave incorrect values in the stencil buffer, causing the wrong surfaces  to be illuminated. The solution to this problem is to add caps to the shadow vol- ume geometry, making it a closed surface, and using different stencil operations.  The two caps added to the shadow volume are derived from the object’s triangle  mesh as follows. A front cap is constructed using the unmodified vertices of tri- angles facing toward the light source. A back cap is constructed by projecting the  vertices of triangles facing away from the light source to infinity. For the result- ing  closed  shadow  volume,  we  render  back  faces   with  respect  to  the  camera   using a stencil operation that increments the stencil value whenever the depth test  fails, and we render front faces using a stencil operation that decrements the sten- cil value whenever the depth test fails. As shown in Figure 10.9, this technique  leaves nonzero values in the stencil buffer for any surface intersecting the shad- ow  volume  for  arbitrary  camera  positions.  Rendering  shadow  volumes  in  this  manner is more expensive than using the original technique, but we can deter- mine when it’s safe to use the less-costly depth-pass method without having to  worry about capping our shadow volumes.    290      10. Shadows   0  C  1+  0  1  1+  1 1+  0     Figure 10.9. Using a capped shadow volume and depth-fail stencil operations allows the  camera to be inside the shadow volume. The stencil value is incremented when back fac- es of the shadow volume fail the depth test, and the stencil value is decremented when  front faces of the shadow volume fail the depth test. The stencil value does not change  when the depth test passes.     The details of everything just described are discussed throughout the remain- der of this section. In summary, the rendering algorithm for a single frame runs  through the following steps.   A.  Clear the frame buffer and perform an ambient rendering pass. Render the  visible scene using any surface shading attribute that does not depend on any  particular light source.   B.  Choose a light source and determine what objects may cast shadows into the  visible region of the world. If this is not the first light to be rendered, clear  the stencil buffer.    10.3  Stencil Shadows   291         C.  For each object, calculate the silhouette representing the boundary between  triangles facing toward the light source and triangles facing away from the  light  source.  Construct  a  shadow  volume  by  extruding  the  silhouette  away  from the light source.   D.  Render the shadow volume using specific stencil operations that leave non-  zero values in the stencil buffer where surfaces are in shadow.   E.  Perform a lighting pass using the stencil test to mask areas that are not illu-  F.  Repeat steps B through E for every light source that may illuminate the visi-  minated by the light source.   ble region of the world.   For a scene illuminated by n lights, this algorithm requires at least   1n +  ren-   1n +  passes may be necessary if surface-shading calcu- dering passes. More than  lations for a single light source cannot be accomplished in a single pass. To effi- ciently render a large scene containing many lights, one must be careful during  each pass to render only objects that could potentially be illuminated by a partic- ular light source. An additional optimization using the scissor rectangle can also  save a significant amount of rasterization work—this optimization is discussed in  Section 10.3.7.   10.3.2  Infinite View Frustums   To ensure that shadow volumes surround every last bit of space for which light is  blocked by an object, we must extrude the object’s silhouette to infinity. Using a  standard perspective projection matrix would cause such a shadow volume to be  clipped by the far plane. To avoid this unwanted effect, we can actually place the  far plane at an infinite distance from the camera.    tion 5.5.1, has the form   The standard OpenGL perspective projection matrix   frustumM , derived in Sec-  M  frustum  =   10.3    n 2 − l r  0  0  0             0  n 2 − t b 0  0  + r l − r l + t b − t b + f − f − 1  n n  −  0  0  −  2 f  fn − n 0       ,         292   10. Shadows            where n is the distance to the near plane, f is the distance to the far plane, and l, r,  b, and t represent the left, right, bottom, and top edges of the rectangle carved out  of the near plane by the view frustum. By evaluating the limit as f tends to infini- ty, we obtain the matrix   M  infinite  =  M  lim →∞ f  frustum  =   10.4    n 2 − l r  0  0 0            0  n 2 − t b 0 0  + l r − r l + t b − t b − 1 − 1  0  0 − 2 0  n            .   The  matrix  ,  x y z w  to the clip-space point  ,  ,  clipP  as follows.   infiniteM   transforms  a  4D  homogeneous  eye-space  point   eye =P           z  z  x  eye  0  0  0  n  =  +  =  =  +  infinite  0 0  P clip                                n 2 − l r  n 2 − l r n 2 − t b  + l r − l r + t b − t b − 1 − 1  + l r − l r + t b − t b nw 2 z   10.5    M P  y − − z −  x     y   z     w    n 2 − t b 0 0  0 − 2 0 0w >   it is normally the case that            1w =  , the resulting z coordinate of  Assuming  clipP  is always less than the resulting w coordinate of  clipP , ensuring that projected  points are never clipped by the far plane. A point at infinity is represented by a  4D  homogeneous  vector  having  a  w  coordinate  of  0  in  eye  space.  For  such  a  point,   , and the perspective divide produces a 3D point in nor- malized device coordinates having the maximal z value of 1.    In practice, the limitations of hardware precision can produce points having a  normalized  z  coordinate  slightly  greater  than  1.  This  causes  severe  problems  when the z coordinate is converted to an integer value to be used in the depth  buffer  because  the  stencil  operations  that  depend  on  the  depth  test  to  render  shadow volumes may no longer function correctly. To circumvent this undesira- ble effect, we can map the z coordinate of a point at infinity to a value slightly  less than 1 in normalized device coordinates. The z coordinate of a 3D point D in  normalized device coordinates is mapped from a value   to a  − , where ε is a small positive constant, using the  value  relation   zD′ in the range [  zD  in the range [  − 1,1 ε  ]1,1−  P clip  P clip  =  ]           w  z   10.3  Stencil Shadows   293    10.6     10.7             D  ′ = z     D  z  +    21  ε  − 2  − .  1  We need to find a way to modify the z coordinate of  clipP  in order to perform this  mapping as points are transformed from  eye space into clip space. We can re-   write  Equation   10.6   as  an  adjustment  to    zD   with    P clip    by  replacing    and   P clip  P clip  P clip  clip                 w  w  z  z  z   as follows.   − 21  2   1    −  ε  +       ′ P clip   P clip Plugging in the values of   P clip   ′ P clip − z        z  z     =           zD′ with   ′P     w      P clip   P clip  and   P − − z −  w   clip w nw 2 z  and simplifying yields    − + 1    z ε      P  ′ clip  =  =        z  z  z  ′P  clip     z  Solving for       given by Equation  10.5 , we have  21     − 2  1 .   +  −  ε   10.8      nw ε  −    .   2   10.9    We  can  incorporate  this  mapping  into  the  projection  matrix  Equation  10.4  as follows to arrive at the slightly tweaked matrix  actually use to render a scene.   infiniteM   given  by  ′M  that we   infinite  M  ′ infinite  =  n 2 − r  l  0  0 0            0  n 2 − t b 0 0  + l r − r l + t b − t b − ε 1 − 1  0  0   − n ε 0     2                10.10    For graphics hardware that supports depth clamping,4 the use of the matrix    ′M  given by Equation  10.10  is not necessary. The depth clamping function- infinite ality  in  OpenGL  allows  a  renderer  to  force  depth  values  in  normalized  device  coordinates to saturate to the range [ , thus curing the precision problem at  the infinite far plane. When depth clamping is enabled using the function call   ]1,1−                                                         4  Depth  clamping  became  a  core  feature  of  OpenGL  in  version  3.2.  It  was  previously  available through the GL_ARB_depth_clamp and GL_NV_depth_clamp extensions.    294   10. Shadows                   glEnable GL_DEPTH_CLAMP ;   infiniteM  given by Equation  10.4  can safely be used.   the projection matrix    The question of depth buffer precision arises when using an infinite projec- tion matrix. It is true that placing the far plane at infinity reduces the number of  discrete depth values that can occur within any finite interval along the z axis, but    P  that uses  in most situations this effect is small. Consider the function  frustumM   given  in  Equation   10.3   to  map  an  eye-space  point  the  matrix  =P P P P , ,1 z y x   to its corresponding depth in normalized device coordinates:   frustum  d     ,  d  frustum        P  =       M M  frustum  frustum       P P    z  =  + −  f f  +  n 1 n P z  fn 2   − n f   .     w   P   by  using  the  matrix   We  obtain  a  different  function  Equation  10.4  to map an eye-space point P to its normalized depth:   infinite  d  infiniteM   given  by    10.11     10.12    d  infinite     P     =       M P infinite M P  infinite       z  w  = + 1     2  n    .   1 P z  1P  and  Given two eye-space points  d values produced by the functions   2P , we can compare the differences in depth  frustum   as follows.   d  and   infinite  d  frustum     P 2     −  d  frustum     P 1     =  2 f  fn   −  n n       1 P 2        −  1   P 1            z  −  1 P 2     z  1   P 1     z  z        d  infinite     P 2     −  d  infinite     P 1     =  2   10.13    2P  to a range that is a factor   frustumM  maps the points  1P   This demonstrates that the standard projection matrix  n−  larger than the range to which the  and  infiniteM ,  thus  equating  to  points  are  mapped  by  the  infinite  projection  matrix  greater precision. For practical values of f and n, where f is much larger than 1  n−  is close to unity, so the loss of precision  and n is much smaller than 1,  is not a significant disadvantage.               f  f  f  f  10.3.3  Silhouette Determination  The  stencil  shadow  algorithm  requires  that  the  models  in  our  world  be  closed  triangle  meshes.  In  mathematical  terms,  the  surface  of  any  object  that  casts  a    10.3  Stencil Shadows      295   2  N  ,  ,  3  1  , M  T T ,  V V 1 2  shadow must be a two-dimensional closed manifold. What this boils down to is  that every edge in a mesh must be shared by exactly two triangles, disallowing  any holes that would let us see the interior of the mesh.    Edge  connectivity  information  must  be  precomputed  so  that  we  can  deter- mine a mesh’s silhouette for shadow volume rendering. Suppose that we have an  V  and an  , indexed triangle mesh consisting of an array of N vertices  T . Each triangle simply indicates which three ver- , array of M triangles  1 tices it uses by storing three integer indexes  1i ,  2i , and  3i . We say that an index  pi   precedes an index  qi  if the number p immediately precedes the number q in the  → → → . For instance,  2i  precedes  3i  and  3i  precedes  1i , but  2i   cyclic chain 1 2 does not precede  1i .  1iV ,    2iV , and  3iV  to which they refer are wound counterclockwise about the triangle’s  normal vector. Suppose that two triangles share an edge whose endpoints are the  bV  as shown in Figure 10.10. The consistent winding rule enforc- vertices  aV  precedes the  es the property that for one of the triangles, the index referring to  bV  pre- index referring to  cedes the index referring to    As demonstrated in Listing 10.1, the edges of a triangle mesh can be identi- fied by making a single pass through the triangle list. For any triangle having ver- tex  indexes  1i ,  2i ,  and  3i ,  we  create  an  edge  record  for  every  instance  in  which  i<  and store the index of the current triangle in the edge rec- i< ,  2 i i 1 ord. This procedure creates exactly one edge for every pair of triangles that share   The indexes  1i ,  2i , and  3i  are ordered such that the positions of the vertices   bV , and that for the other triangle, the index referring to   i< , or  3 i  aV  and   aV .   1  2  3  1i  aV 3i 3i  1i  2i bV  2i     Figure 10.10. When consistent winding is enforced, it is always the case that the indexes  bV  of exactly one of the two triangles sharing an edge sat- referring to the vertices  isfies the property that the index referring to   aV  precedes the index referring to   aV  and   bV .    296   10. Shadows            i> ,  2 i  aV  and   bV , duplicating any edges that are shared by multiple pairs of   two vertices  triangles.    Once we have identified all the edges, we make a second pass through the  triangle list to find the second triangle that shares each edge. This is done by lo- i>  and matching it to an edge hav- i cating triangles for which  1 ing the same vertex indexes that has not yet been supplied with a second triangle  index.    Armed with the edge list for a triangle mesh, we determine the silhouette by  first calculating the dot product between the light position and the plane of each  triangle. For a triangle whose vertex indexes are  1i ,  2i , and  3i , the  unnormalized   outward-pointing normal direction N is given by  −  i> , or  3 i  ×  −  =  1  3  2         10.14       N V i  2    V    i 1  V i  3  V i 1  since the vertices are assumed to be wound counterclockwise. The 4D plane vec- tor F corresponding to the triangle is then given by   =  F  N N N  ,  ,  y  x  z  ,  − ⋅ N V .   i 1   10.15    wL ≠ ; and for infinite directional light sources,   Let L represent the 4D homogeneous position of the light source. For point    wL = . A triangle  light sources,  faces  the  light  source  if  .  Otherwise,  the  triangle  faces  away  from  the  light source. The silhouette is equal to the set of edges shared by one triangle fac- ing the light and one triangle facing away from the light.   F L  ⋅ >  0  0  0  Listing 10.1. The BuildEdges   function examines an array of indexed triangles and constructs  an array of edge records that refer back to the triangles that share them. The return value is the  number of edges written to the array edgeArray.  Parameters     triangleCount   The  number  of  triangles  in  the  array  pointed  to  by  the  triangle- Array parameter.  A pointer to an array of Triangle structures describing the polygonal  mesh.  A pointer to a location in which a pointer to the edge array is returned.         triangleArray   edgeArray   long BuildEdges long vertexCount, long triangleCount,     const Triangle *triangleArray, Edge **edgeArray   {     long maxEdgeCount = triangleCount * 3;    10.3  Stencil Shadows      297   unsigned short *firstEdge =  [vertexCount + maxEdgeCount];   new unsigned short unsigned short *nextEdge = firstEdge + vertexCount;   for  long a = 0; a < vertexCount; a++  firstEdge[a] = 0xFFFF;      First pass over all triangles. This finds all the edges satisfying     the condition that the first vertex index is less than the second      vertex index when the direction from the first vertex to the second      vertex representsa counterclockwise winding around the triangle to      which the edge belongs. For each edge found, the edge index is     stored in a linked list of edges belonging to the lower-numbered     vertex index i. This allows us to quickly find an edge in the second     pass whose higher-numbered vertex index is i.   long edgeCount = 0;  const Triangle *triangle = triangleArray;  for  long a = 0; a < triangleCount; a++   {   long i1 = triangle->index[2];   for  long b = 0; b < 3; b++              {   long i2 = triangle->index[b];   if  i1 < i2        {     Edge *edge = &edgeArray[edgeCount];                                                                edge->vertexIndex[0] =  unsigned short  i1;  edge->vertexIndex[1] =  unsigned short  i2;  edge->faceIndex[0] =  unsigned short  a;  edge->faceIndex[1] =  unsigned short  a;   firstEdge[i1] = edgeCount;    long edgeIndex = firstEdge[i1];   if  edgeIndex == 0xFFFF   {          }   else  {       for  ;;                                                                                      298   10. Shadows                  {   long index = nextEdge[edgeIndex];   if  index == 0xFFFF            {     break;  }   nextEdge[edgeIndex] = edgeCount;   edgeIndex = index;     }       }   nextEdge[edgeCount] = 0xFFFF;  edgeCount++;                                                                                               }   i1 = i2;     }   triangle++;     }      Second pass over all triangles. This finds all the edges satisfying      the condition that the first vertex index is greater than the second      vertex index when the direction from the first vertex to the second      vertex represents a counterclockwise winding around the triangle to     which the edge belongs. For each of these edges, the same edge should     have already been found in the first pass for a different triangle.      So we search the list of edges for the higher-numbered vertex index     for the matching edge and fill in the second triangle index. The     maximum number of comparisons in this search for any vertex is the     number of edges having that vertex as an endpoint.   triangle = triangleArray;  for  long a = 0; a < triangleCount; a++   {   long i1 = triangle->index[2];   for  long b = 0; b < 3; b++        {   long i2 = triangle->index[b];                                                                                     10.3  Stencil Shadows      299   edgeIndex = nextEdge[edgeIndex]    Edge *edge = &edgeArray[edgeIndex];    if  i1 > i2                              {   for  long edgeIndex = firstEdge[i2]; edgeIndex != 0xFFFF;                      }     {     if   edge->vertexIndex[1] == i1  &&            }     {     break;  }    edge->faceIndex[0] == edge->faceIndex[1]     edge->faceIndex[1] =  unsigned short  a;                                                                                   }   i1 = i2;     }   triangle++;     }   delete[] firstEdge;  return  edgeCount ;   10.3.4  Shadow Volume Construction  Once the set of an object’s silhouette edges has been determined with respect to a  light source, we must extrude each edge away from the light’s position to form  the object’s shadow volume. Such an extrusion may be accomplished by making  use of widely available vertex programming hardware exposed by shading lan- guages such as GLSL.    For a point light source, the extrusion of the silhouette edges consists of a set  of quads, each of which has the two unmodified vertices belonging to an edge  and two additional vertices corresponding to the extrusion of the same edge to  infinity.  For  an  infinite  directional  light  source,  all  points  project  to  the  same  point at infinity, so the extrusion of the silhouette edges can be represented by a  set of triangles that all share a common vertex. We distinguish between points    300      10. Shadows   that should be treated normally and those that should be extruded to infinity by  using 4D homogeneous coordinates. A w coordinate of 1 is assigned to the un- modified vertices and a w coordinate of 0 is assigned to the extruded vertices.  The vertex program performing the extrusion utilizes the information stored in  the w coordinate to perform the appropriate vertex modifications.    Before we examine the extrusion method, we must prepare the appropriate  quad list or triangle list  depending on whether we are using a point light or infi- nite directional light . We need to make sure that the vertices of each extrusion  primitive are wound so that the face’s normal direction points out of the shadow  volume.  Suppose  that  a  silhouette  edge  E  has  endpoints  A  and  B.  The  edge- finding code presented in Listing 10.1 associates the triangle for which the verti- ces A and B occur in counterclockwise order as the first triangle sharing the edge  E. Thus, if the first triangle faces toward the light source, then we want the verti- ces A and B to occur in the opposite order for the extruded primitive so that its  vertices  are  wound  counterclockwise.  If  the  first  triangle  faces  away  from  the  light source, then we use the vertices A and B in the same order for the extruded  primitive. Table 10.1 lists the vertices of the extrusion of the edge E for point  light sources and infinite directional light sources for the cases that the first trian- gle associated with the edge E faces toward or away from the light source.         Facing of First  Triangle   Toward light  source   Away from light  source   y  y  Point Light Source   Extrusion is a list of  quads   =V 1 =V 2 =V 3 =V 4 =V 1 =V 2 =V 3 =V 4  B B B x z A A A x z A A A z x B B B x A A A x z B B B x B B B x z A A A x z  ,1 ,1 ,0 ,0 ,1 ,1 ,0 ,0  , , , , , , , ,  , , , , , , , ,                    y  y  y  y  y  y  z  z  Infinite Light Source   Extrusion is a list of tri- angles   =V 1 =V 2 =V 3  B B B , x z A A A , x z y 0,0,0,0    ,1 ,1  , ,       y  =V 1 =V 2 =V 3  y  , ,  A A A , x z B B B , x y 0,0,0,0    z  ,1 ,1       Table 10.1. Given a silhouette edge E having endpoints A and B, this table lists the ob- ject-space vertices of the extruded shadow volume face corresponding to E. The first tri- angle associated with the edge E is the triangle for which the vertices A and B occur in  counterclockwise order.      10.3  Stencil Shadows      301     We can write a couple of simple vertex shaders to perform edge extrusion  and transformation to clip space. In each of the shaders that follow, we assume  that we have access to a uniform variable named mvpMatrix containing the four  rows of the product of the projection matrix and model-view matrix and another  uniform  variable  named  lightPosition  containing  the  object-space  light  position.    The vertex shader shown in Listing 10.2 demonstrates a safe way to extrude  vertices away from a point light source, where by “safe”, we mean that it is im- mune to floating-point round-off errors. A similar vertex shader for infinite light  sources is shown in Listing 10.3.   Listing 10.2. This vertex shader extrudes vertices having a w coordinate of 0 away from a point  light source and leaves vertices having a w coordinate of 1 unchanged. Vertex positions are then  transformed into homogeneous clip space.   vertexPosition;     The object-space vertex position.  mvpMatrix[4];      The model-view-projection matrix.     The object-space light position.  lightPosition;       in vec4     uniform vec4    uniform vec3      void main    {                  }   float t =  vertexPosition.w < 0.5  ? 1.0 : 0.0;  vec4 extrudedPosition = vec4 vertexPosition.xyz - lightPosition * t,     vertexPosition.w ;                           gl_Position = vec4 dot mvpMatrix[0], extrudedPosition ,         dot mvpMatrix[1], extrudedPosition ,  dot mvpMatrix[2], extrudedPosition ,  dot mvpMatrix[3], extrudedPosition  ;          Listing  10.3.  This  vertex  shader  extrudes  vertices  having  a  w  coordinate  of  0  away  from  an  infinite light source and leaves vertices having a w coordinate of 1 unchanged. Vertex positions  are then transformed into homogeneous clip space.       in vec4   uniform vec4    uniform vec3     vertexPosition;      The object-space vertex position.  mvpMatrix[4];      The model-view-projection matrix.  lightDirection;     The object-space light direction.    10. Shadows   302      void main    {                    }          float t =  vertexPosition.w < 0.5  ? 1.0 : 0.0;  vec4 extrudedPosition =   vec4 vertexPosition.xyz + lightDirection, vertexPosition.w ;  extrudedPosition = vertexPosition - extrudedPosition * t;   gl_Position = vec4 dot mvpMatrix[0], extrudedPosition ,         dot mvpMatrix[1], extrudedPosition ,  dot mvpMatrix[2], extrudedPosition ,  dot mvpMatrix[3], extrudedPosition  ;     In  the  case  that  shadow  volume  caps  must  be  rendered  for  a  point  light  source  see the next section , a vertex shader similar to the one in Listing 10.2  should be used to transform vertices belonging to triangles that face away from  the light. As demonstrated in Listing 10.4, extruded cap vertices can be obtained  by simply subtracting the x, y, and z coordinates of the light’s position from the  vertex’s position and assuming that the result has a w coordinate of 0. As shown  in Figure 10.11, the silhouette extrusion for an infinite light source always comes  to a point, so caps are never necessary.   Listing 10.4. This vertex shader extrudes vertices belonging to a shadow volume cap away from a  point light source.  Note that the extruded position is only a three-dimensional vector here.  Vertex  positions are then transformed into homogeneous clip space.   vertexPosition;   mvpMatrix[4];   lightPosition;       The object-space vertex position.     The model-view-projection matrix.     The object-space light position.       in vec4   uniform vec4    uniform vec3      void main    {              }          vec3 extrudedPosition = vertexPosition.xyz - lightPosition;   gl_Position = vec4 dot mvpMatrix[0].xyz, extrudedPosition ,         dot mvpMatrix[1].xyz, extrudedPosition ,  dot mvpMatrix[2].xyz, extrudedPosition ,  dot mvpMatrix[3].xyz, extrudedPosition  ;    10.3  Stencil Shadows      303   Figure 10.11. A cylinder illuminated by an infinite light source and the shadow volume  formed by the extrusion of its silhouette.  Image from the C4 Engine, courtesy of Tera- thon Software LLC.       10.3.5  Determining Cap Necessity  As mentioned earlier, a completely closed shadow volume having a front cap and  a back cap must be rendered whenever the camera lies inside the shadow volume,  or the faces of the silhouette extrusion could potentially be clipped by the near  plane. We wish to render this more expensive shadow volume as infrequently as  possible, so a test for determining when it is not necessary would be useful.  The near rectangle is the rectangle carved out of the near plane by the four    side planes of the view frustum. As shown in Figure 10.12, we can devise a test    304   10. Shadows         to determine whether the shadow volume might be clipped by the near plane by  constructing the set of planes that connect the boundary of the near rectangle to  the light source. We call the volume of space bounded by these planes and by the  near plane itself the near-clip volume. Only a point inside the near-clip volume  can have an extrusion away from the light source that intersects the near rectan- gle. Thus, if an object is known to lie completely outside the near-clip volume,  then we do not have to render a capped shadow volume.    When constructing the near-clip volume, we consider three cases: 1  the light  source  lies  in  front  of  the  near  plane,  2   the  light  source  lies  behind  the  near  plane, and 3  the light source is very close to lying in the near plane. Let W be  the transformation matrix that maps eye space to world space, and suppose that  our light source lies at the 4D homogeneous point L in world space. We consider  1wL =   to be lying in the near plane if its distance  a point light source  for which  to the near plane is at most some small positive value δ. For an infinite direction- wL =  , we consider the distance to the near plane to be  al light source  for which  the length of the projection of the light’s normalized direction vector  L L L   x z onto the near plane’s normal direction. In either case, we can obtain a signed dis- tance d from the light source to the near plane by calculating   0  ,  ,  y     =  d  − W L 1     ⋅  − − 0,0, 1,  n  .    10.16    L  n  C     Figure 10.12. The near-clip volume is bounded by the planes connecting the near rectan- gle to the light position L. If an object lies completely outside the near-clip volume, then  its shadow volume cannot intersect the near rectangle, so it is safe to render it without  caps.    10.3  Stencil Shadows   305               δ> , then the light source lies in front of the near plane; if d  δ< − , then the  If d light source lies behind the near plane; otherwise, the light source lies in the near  plane.  In the case that the light source lies in the near plane, the near-clip volume is    defined by the planes  . These two planes are  coincident but have opposite normal directions. This encloses a degenerate near- clip volume, so testing whether an object is outside the volume amounts to de- termining whether the object intersects the near plane.    tices of the near rectangle. In eye space, the points  corners of the near rectangle are given by   If the light source does not lie in the near plane, we need to calculate the ver- 3R  at the four   − − 0,0, 1, n  2R , and   0,0,1,n  =K   and   0R ,   1R ,   K  =  0  1  R R R R  0  1  2  3  ,  = = − = − =  n e an e  − n , − n e an e , , an e n e , , − − , ,  − an e  n e  n − n  n ,      10.17    where n is the distance from the camera to the near plane; a is the aspect ratio of  the viewport, equal to its height divided by its width; and e is the camera’s focal  length, related to the horizontal field-of-view angle α by Equation  5.27 . These  four  points  are  ordered  counterclockwise  from  the  camera’s  perspective.  For  a  light source lying in front of the near plane, the world-space normal directions  iN , where 0  3i≤ ≤ , are given by the cross products      ×     =     −  ′ i  ′    i  i     N    − 1 mod 4  R R   10.18   i′R   is  the  world-space  vertex  of  the  near  rectangle  given  by  where  each  ′ =R WR . For a light source lying behind the near plane, the normal directions  are simply the negation of those given by Equation  10.18 . The corresponding  world-space planes   iK  bounding the near-clip volume are given by   L L L x  L  ,  ,  w  y  z  i  i  −    R ,   ′ i  K  i  =  1 N  i     N  i        ,  x  N  i        ,  y  N  i     −  ⋅  N R  i  ′ i  ,  z  .    10.19    We close the near-clip volume by adding a fifth plane that is coincident with the  near plane and has a normal pointing toward the light source. For a light source  lying in front on the near plane, the fifth plane   K W  =  4     −   1 T  4K  is given by  − − 0,0, 1, n  ,    10.20     306      10. Shadows   −  =  W   1 T  W.    and for a light source lying behind the near plane, the fifth plane is given by the  negation of this vector.  Remember that if W is orthogonal, then     We determine whether a  shadow-casting object lies completely outside the  near-clip  volume  by  testing  the  object’s  bounding  volume  against  each  of  the  iK . If the bounding volume lies completely on the negative side of any  planes  one plane, then the object’s shadow volume cannot intersect the near rectangle.  In the case that an object is bounded by a sphere having center C and radius r, we  do not need to render a capped shadow volume if    Figure  10.13  demonstrates  that  for  point  light  sources,  bounding  volumes  lying behind the light source from the camera’s perspective may often be mistak- en for those belonging to objects that might cast shadows through the near rec- tangle. This happens when the bounding volume lies outside the near-clip vol- ume, but does not fall completely on the negative side of any one plane. We can  improve this situation substantially by adding an extra plane to the near-clip vol- ume for point lights. As shown in Figure 10.13, the extra plane contains the light  position L and has a normal direction that points toward the center of the near  5N  is given by  rectangle. The normal direction    −   for any i.   ⋅ < −  K C   1 T  N W   10.21    0,0,  ,1n  L,   −  =  r     −  i  5   a    b   L  L  Figure 10.13.  a  The near-clip volumes tends to be somewhat thin, so objects behind the  light source are sometimes not excluded by plane tests.  b  Adding an extra plane to the  near-clip volume for point light sources enables more objects to be classified as outside  the near-clip volume.       10.3  Stencil Shadows   307         and the corresponding plane   5K  is given by   K  5  =  1 N  5     N  5        ,  x  N  5        ,  y  N  5     ,  z  −  ⋅  N L  5  .    10.22    5K  is added to the near-clip volume boundary for point light sources  The plane  regardless of whether the light position is in front of, behind, or in the near plane.   10.3.6  Rendering Shadow Volumes  Now that we can determine an object’s silhouette with respect to a light source,  construct a shadow volume by extruding the silhouette edges away from the light  source,  and  decide  whether  front  and  back  caps  are  necessary,  we  are  finally  ready to render the shadow volume into the stencil buffer. We assume that the  frame buffer has already been cleared and that an ambient rendering pass  or a  depth-only pass  has been performed to initialize the depth buffer. This section  concentrates  on the operations necessary to illuminate the scene using a single  light source, and these operations should be repeated for all light sources that can  affect the visible region of the world being rendered.    First, we must clear the stencil buffer, configure the stencil test so that it al- ways passes, and configure the depth test so that it passes only when fragment  depth values are less than those already in the depth buffer. This can be done in  OpenGL using the following function calls.   glClear GL_STENCIL_BUFFER_BIT ;  glEnable GL_STENCIL_TEST ;  glStencilFunc GL_ALWAYS, 0, ~0 ;  glEnable GL_DEPTH_TEST ;  glDepthFunc GL_LESS ;   We are only going to be drawing into the stencil buffer, so we need to disable  writes to the color buffer and depth buffer as follows.   glColorMask GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE ;  glDepthMask GL_FALSE ;   Shadow volume faces are rendered using different stencil operations depending  on  whether  they  face  toward  or  away  from  the  camera,  and  modern  graphics  hardware can be configured to perform different operations for front-facing and    308      10. Shadows   back-facing polygons.5 So that no faces are skipped even when they face away  from the camera, we make the following call to disable face culling.   glDisable GL_CULL_FACE ;     For a shadow volume that does not require capping because it cannot possi- bly intersect the near rectangle, we modify the values in the stencil buffer when  the depth test passes. The stencil value is incremented for fragments belonging to  front-facing polygons and is decremented for fragments belonging to back-facing  polygons. These operations are performed by the following function calls, where  the DrawShadowVolume   function renders all of the polygons belonging to the  shadow volume.   glStencilOpSeparate GL_FRONT, GL_KEEP, GL_KEEP, GL_INCR_WRAP ;  glStencilOpSeparate GL_BACK, GL_KEEP, GL_KEEP, GL_DECR_WRAP ;  DrawShadowVolume  ;     If a shadow volume does require capping, then we modify the values in the  stencil  buffer  when  the  depth  test  fails.  The  stencil  value  is  incremented  for  fragments belonging to back-facing polygons and is decremented for fragments  belonging  to front-facing polygons   the  opposite  of  the  depth-pass  operations .  These  operations  are  accomplished  using  the  following  function  calls.  In  this  case, the DrawShadowVolume   function renders the polygons belonging to the  shadow volume’s caps as well as its extruded silhouette edges.   glStencilOpSeparate GL_FRONT, GL_KEEP, GL_KEEP, GL_DECR_WRAP ;  glStencilOpSeparate GL_BACK, GL_KEEP, GL_KEEP, GL_INCR_WRAP ;  DrawShadowVolume  ;     Once shadow volumes have been rendered for all objects that could poten- tially  cast  shadows  into  the  visible  region  of  the  world,  we  perform  a  lighting  pass  that  illuminates  surfaces  wherever  the  stencil  value  remains  zero.  We  re- enable writes to the color buffer, re-enable face culling, change the depth test to  pass only when fragment depth values are equal to those in the depth buffer, and                                                          5 Two-sided stencil operations became a core feature of OpenGL in version 2.0. Previ- ously, the same functionality was available through the GL_EXT_stencil_two_side  and GL_ATI_separate_stencil extensions.    10.3  Stencil Shadows      309   configure the stencil test to pass only when the value in the stencil buffer is zero  using the following function calls.   glColorMask GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE ;  glEnable GL_CULL_FACE ;  glDepthFunc GL_EQUAL ;  glStencilFunc GL_EQUAL, 0, ~0 ;  glStencilOp GL_KEEP, GL_KEEP, GL_KEEP ;   Since  the  lighting  pass  adds  to  the  ambient  illumination  already  present  in  the  color buffer, we need to configure the blending function as follows.   glEnable GL_BLEND ;  glBlendFunc GL_ONE, GL_ONE ;   After the lighting pass has been rendered, we clean up by resetting a few render- ing states back to those needed by the ambient pass for the next frame using the  following function calls.   glDepthMask GL_TRUE ;  glDepthFunc GL_LEQUAL ;  glStencilFunc GL_ALWAYS, 0, ~0 ;   10.3.7  Scissor Optimization  When using an attenuated light source, it is usually convenient to define a range r  beyond which the light source does not contribute any illumination to the world.  Although this is not a physically correct model, using an attenuation function that  vanishes at a distance r from the light’s position allows us to quickly cull any  light  source  whose  sphere  of  illumination  does  not  intersect  the  view  frustum.  When a light source’s sphere of illumination is visible, the area within the view- port that could possibility be affected by the light source may not be the entire  viewport. By projecting the sphere of illumination to the image plane and using  the scissor rectangle to limit our drawing to the projected area of influence, we  can avoid a significant amount of superfluous rendering of both shadow volumes  and illuminated surfaces.  Suppose that we have a point light source whose center lies at the point L in    eye space and whose range is r, as shown in Figure 10.14. We wish to find four  planes, two parallel to the x axis and two parallel to the y axis, that pass through    310   10. Shadows            L  r  r  P  z−  e  C  x = − 1  Q  1x =  Figure 10.14. For a point light source at the position L having range r, we calculate the  four planes that pass through the camera position C and are tangent to the light’s sphere  of  illumination.  By  calculating  the  intersection  of  each  tangent  plane  with  the  image  plane lying at a distance e from the camera, we can limit our drawing to an area smaller  than the full size of the viewport.      the  camera  position   the  origin  in  eye  space   and  are  also  tangent  to  the  light  source’s bounding sphere. Once these planes have been determined, we can lo- cate their intersections with the image plane to find the rectangular boundary of  the projection of the light source’s bounding sphere.    We assume that the tangent planes parallel to the y axis have a unit-length  normal  vector  N  whose  y  coordinate  is  0.  Since  the  planes  pass  through  the  origin, each can be represented by a 4D vector  . We wish to cal- culate values of   zN  such that the following conditions are satisfied.   xN  and   =T  ,0,  ,0  N  N  x  z  ⋅ =  T L N+  2 x  r   =   2 1 z  N   10.23     10.24     10.3  Stencil Shadows   311                              By expanding the dot product and rearranging slightly, we can rewrite Equation   10.23  as   N L  z  z  = −  r N L x  .   x  Squaring both sides of Equation  10.25  and making the substitution  we have   N  2 z    1  −   2 N L 2 z  x  =  2  r  −  2  rN L x  x  +  N L .  2 2 x x  This can be rewritten as a quadratic equation in      +  L 2 x    L N 2 z  2 x    + − 2     rL N  x  x  xN  as follows.  =   + 0  L 2 z  −  r  2  The discriminant D is given by   =  D  4     r L 2 2 x     −  L 2 x  +  L 2 z      2  r  −  L 2 z     .    2  r  +  ≤  L 2 z  L 2 x  0D ≤  precisely when    i.e., when the origin falls within the parallel  projection  of  the  sphere  onto  the  x-z  plane .  When  this  happens,  we  know  the  light source’s bounding sphere fills the entire viewport, and we do not continue.  0D > , then we can solve Equation  10.27  using the quadratic formula to    If  obtain   N  x  =  ± +  rL 2 x   L 2 2 x ± rL x + L 2 x  D   L 2 z D 4 L 2 z  .   =  −= r N L x  x  .   N  z  L  z  This gives us two values for  by making a small adjustment to Equation  10.25 :   xN . The corresponding values for   zN  are calculated   The point P at which the plane T is tangent to the sphere is simply given by   P L N r − rN  = − = L  x  ,0,  L  z  x  −  rN  z  ,1  .    10.25   = − 1  ,  2 x  N   10.26     10.27     10.28     10.29     10.30     10.31     312   10. Shadows                  0  We only want to consider planes whose point of tangency with the light source’s  zP < , then we have found a plane  bounding sphere lies in front of the camera. If  that  may  allow  us  to  shrink  the  scissor  rectangle.  We  now  need  to  determine  where the tangent plane intersects the image plane.    As shown in Figure 10.14, the image plane is perpendicular to the z axis and  lies at a distance e from the camera. On the image plane, the area of the viewport  corresponds to x coordinates in the range [  and y coordinates in the range  [ ] ,a a− , where a is the aspect ratio given by the height of the viewport divided by  its width. Any point Q lying in the image plane has coordinates  . A  point Q lying in the plane tangent to the light source’s bounding sphere satisfies  N Q , so we can solve for x:   ]1,1−  x y ,  Q  −  =  =  0  e  ,  ⋅  This x coordinate can be mapped to the viewport coordinate x′ using the formula   =  x  N e z N  x  .   ′ = +  l  x  x  1  + 2  ,  w   10.32     10.33    where l is the left edge of the viewport and w is the viewport’s width, both in  pixels.    Given  a  value  x′  calculated  using  Equation   10.33 ,  we  need  to  determine  L<   or  whether it represents a left-side boundary or a right-side boundary. If  xN >  , then x′ represents a left-side boundary because the point  equivalently, if  , then  x′ represents a  of tangency falls to the left of the light source. If  right-side  boundary.  Since  the  value  x′  may  lie  outside  the  viewport   if  ]1,1 [ x∉ −  ,  we  calculate  the  left  and  right  edges  of  the  scissor  rectangle  as  follows.   L>  P x  P x  0  x  x  .  scissor left scissor right  .  = =    ′ x l , max   ′ x l w , min    +        10.34    The two tangent planes parallel to the x axis are found in an almost identical  , whose     manner. Each of these planes is represented by a 4D vector  0, nonzero components are given by the following formulas.   N N  ,0  ,  y  z  rL  y  ±  r L 2 2 y  N  y  =     − L 2 y  L 2 y +  + L 2 z      L 2 z  2  r  −  L 2 z         10.3  Stencil Shadows                  313    10.35     10.37     10.38     10.39    N  z  =  − r N L  y  y     L  z  =  y  N e z N a y  ,   ′ = +  b  y  1  y  + 2  h  ,   The point of tangency P is given by     =  −   10.36   zP < ,  then  the  y  coordinate  where  each  plane  intersects  the  image  plane  is   rN L  rN  ,1  0,  P  L  .   ,  y  y  z  z  −  0 If  given by   where the viewport’s aspect ratio a has been added to the denominator. Finally,  the viewport coordinate y′ is calculated using the formula   where b is the bottom edge of the viewport and h is the viewport’s height, both in  pixels.  yN >  ,  then  y′  represents  a  bottom-side  L<   If     or  equivalently,  if  P y y , then y′ represents a top-side boundary. As with the left and  L> boundary. If  P y right sides, the values of y′ should be clamped to the viewport’s range as follows.   0  y  .  scissor bottom scissor top  .  = =    max   min    ′ y b , +     ′ y b h ,    Using the values given by Equations  10.34  and  10.39 , the OpenGL scis- sor  rectangle  is  enabled  and  set  to  the  appropriate  values  using  the  following  function calls.   glEnable GL_SCISSOR_TEST ;  glScissor scissor.left, scissor.bottom,      scissor.right - scissor.left, scissor.top - scissor.bottom ;   The scissor rectangle affects the clear operation as well, so once rendering has  been  completed,  scissor  test  should  either  be  disabled  or  the  scissor  rectangle  should set back to the entire viewport rectangle by making the following call.   glScissor l, b, w, h ;    314   10. Shadows   Chapter 10 Summary               Shadow Mapping  A shadow map is generated by placing the camera at the light position, orienting  it to the direction of the light, and using the projection matrix   M  proj  y  max  y  min  x  min  2 −  0  0  0  =  x  max              ]   and  [  0  2 −  0  0  0  0  0  −  2  z  max  max  max  max  −  −  x x y y  + − + −  x x y y  min  min  min  min  max − 1  1  ,                ,  x  x  min  where  [ bounding box for the shadow casting region, and  maxz senting the maximum depth of the bounding box.   ]   are  the  extents  of  the  light-space-aligned   is the z coordinate repre-  max  max  min  y  y  ,  Silhouette Determination  2F  is part of an ob- An edge shared by two triangles lying in the planes  ject’s silhouette with respect to the light position L if the dot products  1 ⋅F L and  2 ⋅F L have opposite signs. For point light sources,  wL ≠ , and for infinite direc- tional light sources,   1F  and   wL = .  0  0  Shadow Volume Construction  The vertices of a silhouette edge E having endpoints A and B are listed in Table  1wL =  , an edge vertex V is  10.1. For a point light source at the position L  where  extruded using the formula   ′ =  V  V  L  w  +  −  V  x  L V , x  y  −  L V , y  z  −  L  z  ,0  .   For an infinite light source at the position L  where  extruded using the formula   wL =  , an edge vertex V is   0  V  wV′ =     +  V L L.   −      Exercises for Chapter 10   315               Determining Cap Necessity  The near-clip volume is bounded by the planes connecting the near rectangle to  iN  for  the world-space light position L. The four world-space normal directions  the near-clip volume are given by   N  i  =     R R  −  ′ i  ′      − 1 mod 4  i     ×     L L L x  ,  ,  y  z  −    R ,   ′ i  L  w  i  i′R   is  the  world-space  vertex  of  the  near  rectangle  given  by  where  each  ′ =R WR , W is the transformation from camera space to world space, and the  i iR   are  given  by  Equation   10.17 .  The  corresponding  world-space  values  of  planes   iK  bounding the near-clip volume are given by   K  i  =  1 N  i     N  i        ,  x  N  i        ,  y  N  i     −  ⋅  N R  i  ′ i  ,  z  .   The near-clip volume is closed by adding a fifth plane that is coincident with the  near plane and has a normal pointing toward the light source. For a light source  lying in front on the near plane, the fifth plane   K W  =  4     −   1 T  4K  is given by  − − 0,0, 1, n  .   For an object that is bounded by a sphere having center C and radius r, we do not  need to render a capped shadow volume if    for any i.   ⋅ < −  K C  r  i  1.  Use a technique similar to that described in Section 9.1 to derive the    entry of a projection matrix based on the matrix   10.10   that  offsets  depth  values  at  a  camera-space  depth  amount δ.   infinite   3,3   ′M  given by Equation  zP   by  a  small   2.  Write a program that renders a stencil shadow for a triangle mesh illuminat- ed by a single point light source. Assume that the triangle mesh is specified  such that each of n triangles indexes three entries in an array of m vertices.  The program should precalculate an edge list, determine the edges belonging  to the model’s silhouette with respect to the light source, and render the ex- truded silhouette edges using the stencil buffer operations described in Sec- tion 10.3.6.   Exercises for Chapter 10    This page intentionally left blank    Chapter 11   Curves and Surfaces   Curved geometry has become commonplace in 3D graphics engines due to mod- ern hardware’s ability to render the high number of vertices and faces needed to  convincingly render smoothly varying surfaces. In addition to geometrical mod- eling, curves may be employed as paths along which certain objects travel. This  chapter examines several classes of three-dimensional cubic curves and then dis- cusses how they can be used to produce bicubic parametric surfaces.   11.1  Cubic Curves   Due  to  the  balance  that  they possess  between  simplicity  and  flexibility,  curves  defined by cubic polynomials have earned widespread use by computer graphics  applications.  In  the  sections  that  follow,  we  examine  several  classes  of  cubic  curves and compare their properties.    sentation   The  fundamental  form  of  a  cubic  curve  is  given  by  the  parametric  repre-  where a, b, c, and d are constant vectors, and  responding to the parameter value t. Writing the components of  we have       t  Q  = +  a b  t  +  2  c  t  +  d ,  t 3   11.1      tQ  is the point on the curve cor-    tQ  separately,   x      Q t     Q t     Q t  y  z  = = =  a a a  x  y  z  + + +  b t x b t y b t z  + + +  2  2  c t x c t y c t 2 z  + + +  3  3  d t x d t y d t 3. z     It is convenient for us to write this as the following matrix product.    11.2    317               318   11. Curves and Surfaces            Using a more compact notation, we can write      CT ,  t  =Q      t     . The deriva-    tQ , which gives the tangent direction to the curve at t, is easy to calcu-  where C represents the matrix of coefficients and  tive of  late in this form since the matrix C is constant. Thus, we can write   t t 1, ,  T  t  ,  3  2      t  ≡      t  Q  =  a a a        x  y  z  b b b  x  y  z  c c c  x  y  z  d d d  x  y  z  1 t t 2 t  3                        ′      t  Q  =  C T      t  =  C  d dt  0 1 t 2 t 3 2                .    11.3     11.4     11.5      A long, curving path is generally composed of several smaller cubic “pieces”  that are connected together at their endpoints. At the points where two adjacent  pieces of a curve join together, there are the notions of parametric continuity and  nC  is used to represent n-th order parametric  geometric continuity. The symbol  nG  is used to represent n-th order geometric continui- continuity, and the symbol  1C  continuity if their tangent vectors are equal  ty. The two curves are said to have  in both magnitude and direction at the join point. If the tangent vectors point in  1G  conti- the same direction but have different magnitudes, then the curves have  nC  continuity if their n-th derivatives are  nuity. In general, two curves meet with  nG  continuity if their n-th derivatives are non- equal, and two curves meet with  nC  con- zero and point in the same direction but do not have the same magnitude.  0C  and  0G  con- tinuity implies  tinuity are equivalent and simply mean that the curves share a common endpoint.    The  classes  of  cubic  curves  that  we  examine  in  this  chapter  are  defined  in  terms of certain geometrical constraints such as the endpoint positions  i.e., the  1t =   or endpoint tangent directions  i.e., the values of  t =  and  values of     t′Q  at  1t =  . Since an arbitrary cubic curve has four coefficients, we  need  four  constraints  in  order  to  define  a  particular  curve.  Calling  these  con- straints  1g ,  2g ,  3g , and  4g , we can express the curve   nG  continuity unless the n-th derivatives are zero.      tQ  at  t =  and      tQ  as   0  0   11.1  Cubic Curves   319                         t  Q  = + + +           a a a a  1  2  3  4  + + + +  2  b t 1 b t 2 b t 3 b t 4  + c t 1 + c t 2 + c t 3 + c t 4  2  2  2  3  + d t 1 + d t 2 + d t 3 + d t 4     3  3  3  2  g 1   g   g 3   g .  4  This is simply a weighted sum of the four geometrical constraints. The polyno-  are called the blending functions. Equation  11.6  can  mials  be written in matrix form as   d t i  b t i  c t i  +  +  +  a  3  2  i      t  Q  =  [  g  1  g  2  g  3  ]  g  4  a a a a  1  2  3  4         2  b 1 b b b  3  4  2  c 1 c c c  3  4  d d d d  1  2  3  4  1 t t 2 t  3                      .   We can write this more compactly as       =Q t      GMT ,  t  where the matrix G defined by   [ G g  =  1  g  2  g  3  ]  =  g  4               g g g  1  1  1         x  y  z         g g g  2  2  2         x  y  z         g g g  3  3  3         x  y  z         g g g  4  4  4                  x  y  z  is called the geometry matrix, and the 4 4×  matrix M defined by    11.6     11.7     11.8     11.9     11.10    =  M  a a a a  1  2  3  4         2  b 1 b b b  3  4  2  c 1 c c c  3  4  d d d d  1  2  3  4            is called the basis matrix. In most of the discussions that follow, there is a con- stant basis matrix M pertaining to each class of cubic curve, and the shapes of  particular curves in each class are determined solely by the geometry matrix G.    320   11. Curves and Surfaces               11.2  Hermite Curves   A cubic Hermite curve is defined by two endpoints  directions  geometry matrix, we can express a Hermite curve   2P , and the tangent  2T  at those endpoints. Using these four quantities to define the   1P  and   1T  and      tH  as         1 t t 2 t         H  3  ,       t  H  =  [  P 1  P  2  T T M 1  2  ]   11.11    HM  is a 4 4×  basis matrix that we need to determine. The geometry matrix  [ P T T . By imposing the geometrical constraints, we obtain  2  P 1  1  2  ]  where  H =G is  the four equations  H H H H  P T T M 2 P T T M 2 P T T M 2 P T T M   2 Writing this as the single equation   P 1 P 1 P 1 P 1      0     1     ′ 0     ′ 1  = = = =  ] ] ] ]  [ [ [ [  2  1  2  1  1  2  1  2  1,0,0,0 1,1,1,1 0,1,0,0 0,1,2,3  H  H  H  H  = = = =  P 1 P 2 T 1 T .  2   11.12    [  P 1  P  2  T T M 1  2  H  ]  [  P 1  P  2  ] T T ,  1  2   11.13    1 1 0 0 0 1 1 1 0 1 0 2 0 1 0 3            =     we deduce that   HM  must be given by  1 1 0 0 0 1 1 1 0 1 0 2 0 1 0 3  M  =         H         − 1  =  1 0 0 0 0 1 0 0         − 3 3 − 2 − 1  2  − 2  1   1   .    11.14    The basis matrix   HM  provides the coefficients of the blending functions, al-   lowing us to write the Hermite curve as the weighted sum of the geometrical con- straints  1P ,  2P ,  1T , and  2T :  t 2   3    = − t 1 3  − t 3 2   11.15        t    t t    1    1  H  +  −  −  +  +  +              t  t  t  2  2  2  2  T .  2  P 2  T 1  P 1   11.2  Hermite Curves      321   0  1t = .   Figure 11.2 shows two Hermite curves   The blending functions are shown in Figure 11.1. As expected, only the weight  t = , and only the weight corresponding to  2P  is  corresponding to  1P  is nonzero at  nonzero at    endpoint. If the geometry matrix corresponding to the curve  [ P T T , then  P 2 1 1   is  equal  to [     tH curve  1u = .  achieved if    that share a common   is given by  1G  continuity is achieved if the geometry matrix for the  1C   continuity  is   T T   with  u 2  0u > ,  and       1 tH      1 tH      tH   and   P 2  P 3  ]  ]  3  2  2  2  1  t − 1 3  2  +  t 2  3  t    t− 2 3 2       1t  t−   2    2 1t  t−     1  t     Figure 11.1. Blending functions for the Hermite class of cubic curves.   0  1P      1 tH  2u− T  2P      tH  2  3P  2T  3T  1−T Figure 11.2. Two Hermite curves sharing the endpoint     2P .    322   11. Curves and Surfaces   11.3  Bézier Curves   Although we shall limit ourselves to studying the cubic variety, a Bézier  pro- nounced BAY-ZEE-AY  curve can be defined for any polynomial degree n. Giv- 1n +  points  P , called the control points of the curve, the degree n  , en  Bézier curve      tB  is given by the parametric function   P P 0 1  ,  ,  n  where the blending functions   ,n kB      t  are the Bernstein polynomials defined by       t  B  n  =   k  =  0  B  n k ,      t  P ,  k  B  n k ,  =    1  −     t  k  t  − n k     n k          n   =   k    n !   − k n k !  .      !   11.16     11.17     11.18    with the binomial coefficient   The first and last control points,  , interior  control  points  stein polynomials can be generated by the recurrence relation   nP , are interpolated by the curve, and the  P   are  approximated  by  the  curve.  The  Bern- ,  0P  and  n− 1  P P 1 2  ,     n k ,  B      t    = − 1  B = ,  and  0,0 1  tB  11.19   n n> .  As  shown  in  Figure  11.3,  where  this recurrence resembles Pascal’s triangle, but with the modification that each  value is the weighted average of the two closest values above it instead of the  sum.   n kB =   whenever     t B k <   or k  +  ,   0  0  − 1,  − 1,  − 1  n  k  k  ,  11.3.1  Cubic Bézier Curves  The cubic Bézier curve has four control points whose positions are blended to- gether by evaluating Equation  11.16  for   3n = :       t  P k      t  B  B  3  =   = k 0   = − 1  k  3,    t  3  P 0  +    t 3 1  −     t  2  P 1  +  2  t 3    1  −     t  P 2  +  t  3  P .  3   11.20                    11.3  Bézier Curves   323               and   1   1 − t     1 t−     t  t  t   1 − t     1t 23  t−      1 − t     1 t−   2  t   1 − t     2 1t  t−     t  2t   1 − t    1 t−   3  t   1 − t     3 1t  t−   2  t  3t    Figure 11.3. The  Bernstein  polynomials,  generated  by  the  recurrence relation given in  Equation  11.19 , can be calculated using a method similar to that used to calculate bi- nomial coefficients in Pascal’s triangle. Each value is the weighted average of the two  closest values above it, where the weights are t and 1 t− .  For values on the left and right  edges of the triangle, the missing value above it is assumed to be zero.    The geometry matrix for a cubic Bézier curve is  Equation  11.20 , we can derive the basis matrix  and write      tB  as follows.   [  P 0  B =G P . From  3 BM  for the cubic Bézier curve   P 2  P 1  ]      t  B  =  [  P 0  P 1  P  2  ]  P 3   11.21    1 0 0 0         − 3 3 0 0  3 − 6 3 0  − 1     3   − 3     1    1 t t 2 t  3           The four Bernstein polynomials appearing in Equation  11.20  are shown in  0P  and  3P , we must     Figure 11.4. Since the Bézier curve interpolates the endpoints  have   B  3,  k      0  1, =  0,   if  if   k k  = =  0;   1,2,3;  B  3,  k      1  0, =  1,   k if  k if   = =  0,1,2;   3.   11.22     11.23     324   11. Curves and Surfaces               1  3,0B  3,3B  3,1B  3,2B  0  t     1  Figure 11.4. The blending functions for the cubic Bézier curve. The functions  degree 3 Bernstein polynomials.   3,kB  are the   An additional property of the Bernstein polynomials is that they sum to unity for  all values of t:   B  3,  k      t  =  1 .   3    =  0  k   11.24      Figure  11.5  shows  some  of  the  shapes  that  a  Bézier  curve  may  assume.  A  useful property of the Bézier curve is that it is entirely contained within the con- vex hull of its control points. That is, the smallest polyhedron containing all four     tB  also contains every point on the curve be- control points of a Bézier curve  1t = . This is a consequence of the fact that the Bernstein polyno- tween  mials are nonnegative on the interval [ ]0,1  and that they sum to unity.     tB ,  giving  the  tangent  direction  to  the    The  derivative  of  a  Bézier  curve  curve, can be expressed as   t =  and   0  ′      t  B  =  [  P 0  P 1  P  2  − 3 9 − 9 3         1 t t 2              .   ]  P 3         − 3 3 0 0  6 − 12 6 0 1t = , we find    = P P 0 1   = P .  P 3 2  − −  3 3       t =  and      0     1  0 B B  ′ ′   11.25     11.26    Examining the derivative at    11.3  Bézier Curves      325   1P  2P  2P  1P  0P  0P  1P  2P  3P  3P  0P  3P  0P  3P  1P  2P     Figure 11.5. A variety of Bézier curves having control points  0P ,  1P ,  2P , and  3P .   This reveals that the tangent directions at the endpoints are multiples of the dif- ferences between the endpoints and the adjacent interior control points. This pro- vides  us  with  a  mechanism  for  easily  translating  between  the  Bézier  form  and  Hermite form of a cubic curve. To translate from Bézier to Hermite  where we  0P  and  3P  , we simply use the  are now calling the endpoints of the Hermite curve  1T  and  2T  corresponding to the  values given by Equation  11.26  as the tangents  3P , respectively. To translate from Hermite to Bézier, we solve  endpoints  Equation  11.26  for the interior control points as follows.   0P  and       11.27    P 1  =  P 0  +  P  2  =  P 3  −  T 1 3 T 2 3      326      11. Curves and Surfaces   11.3.2  Bézier Curve Truncation  Equation   11.27   is  also  useful  for  calculating  the  interior  control  points  for  a  Bézier  curve  that  exactly  matches  another  Bézier  curve  on  an  interval [ ] .  This  process  is  called  truncation  and  is  illustrated  in  Figure  11.6.  Suppose  we  2P , and  3P   wish to truncate a Bézier curve  to the interval [  having the control  3Q . The new parameter u is related to the parameter t by  0Q ,  1Q ,  points  the function     ]  by creating a new Bézier curve    having the control points   1,t t 0 2Q , and       Q uB      P tB   11.28    0P ,  1P ,       t u  1,t t 0    t u 0  +  −  =  .      t  t  1  0  The endpoints   0Q  and   3Q  of the new Bézier curve are simply   0  Q B Q B  11.29     2Q  are obtained using Equation  11.27 , but we  The interior control points  must be careful to calculate the tangents with respect to the parameter u. Since  the curves   1Q  and      Q uB   are coincident,       P tB   and   t t  P  P  3         0   1 .    = =  2Q  3Q  2P  3P  1P  1Q      Q uB  0Q      P tB  0P  Figure 11.6. A Bézier curve  ed to the interval [ 3Q .  1Q ,   2Q , and   1,t t 0      P tB  ]  to create a new Bézier curve    having the control points     having the control points   3P  is truncat- 0Q ,   2P , and     Q uB  0P ,     1P ,    11.3  Bézier Curves   327               B  Q      u  =  B  P       t u        .   Thus, applying the chain rule, we have   B  Q      u  d du  =  =  d dt   t 1  B −  P          t u     ′ P     t  B 0     The tangents  0T  and  3T  to the curve  Q uB       0       1  T B 0 T B 3  ′ Q ′ Q  = =  = =  t t     1  1   at  − −  t t  1  t  d     t u du   − + t 0 0u =  and          ,  B B  ′ P ′ P       t t  0  0  0  1     and the control points   1Q  and   2Q  are therefore    t  =  Q  0  +  1  Q Q  =  1  0  +  Q Q  =  2  3  −  =  Q  3  −  T 0 3 T 3 3     t  0     t  0  − 3 − 3  B  ′ P     t  0     B  ′ P     t  1       .     t  1     .     t u 0 1u =  are given by    11.30    11.3.3  The de Casteljau Algorithm  The de Casteljau algorithm provides a geometrical construction by which we can  ]0,1 .  subdivide a Bézier curve into two parts at an arbitrary parameter value  During the construction, we obtain the four control points corresponding to both  components of the subdivided curve.   Suppose that we split a Bézier curve    2P , and  3P  at the parameter value t     R vB tively. Equations  11.29  and  11.32  provide the control points  3Q  of the curve   1P ,  0P ,   having the control points       and  Q uB ],1s , respec- 2Q , and  1Q ,   s=  to create two new Bézier curves  ]0,s  and [ 0Q ,    coinciding with the original curve on the intervals [      :  Q uB      P tB  t ∈  [   11.31     11.32     11.33    Q B  =  0  Q B  =  1  Q B  =  2  Q B  =  3  P 0 s 3 s 3      0     0  =  +  −      s     s  .  P  P  P  P  B  ′ P      0  B  ′ P      s      328   11. Curves and Surfaces                  Evaluating the functions  las for the interior control points of   PB  and   2Q  gives us the following formu-  Q  1  P′B  for  1Q  and      .  Q uB     = − P s 1 0     = − Q s 1 ]   + P P s s 0 1 [     − P s s 1 1  + P s 1 + P   s 1 [   + − s 1 ] + P s 2  0  Q  2    = − 1   = − 1  [     1   Q  1  s s  − +     s  P 1  +  P s 2   11.34    ]   2R , and    11.35   3R  of the   We repeat a similar procedure for the control points  curve       R vB :   0R ,   1R ,   R  0  =  B  P      s     s  1  P  s  1  =  +  ′ P  B  B  R  − 3 − 3 P   . 3     R vB Formulas  for  the  interior  control  points  of  functions       1     1  PB  and   R  R  B  B  B  ′ P  =  =  =  −  1  s  P  P  2  3      s      1  P′B  as follows.  R  2  R  1    = − 1   = − 1  [     1 [     1  s s  − −  s s      11.36     are  found  by  evaluating  the   + + + +  P s 3 R   s 3 [   − s 1 R s      = − P s 1 2     = − P s 1 2   + P P s 2 1   + P P s  11.38   2 1 0=Q R . This is the point where the line  .  If  we  evaluate    11.37    ]    P 2  P 3  ] ]  +  s  s     2  3  =  B      P s      P tB  2Q   and   1R   is  tangent  to  the  curve    and compare it to Equations  11.35  and  11.38 , we see that   Finally, we take a look at the value of  segment  connecting      P sB  11.39       The entire procedure that we just went through leads us to the formulation of  the de Casteljau algorithm. As illustrated in Figure 11.7, we begin by connecting  3P ,  creating  three  line  0P ,  1P ,  adjacent  pairs  of  the  four  control  points     1    1 0P ,  1P , and  2P  by linearly interpolating  segments. We then construct the points  the endpoints of each of the line segments using the parameter value s as follows.     11.40    2P ,  and     1  R .  s 1    1    1  Q  +  −  +  −  =  s  s  s        2  P   + i 1      P 1 i  P i            11.4  Catmull-Rom Splines   329   1P  1P    1  2P  0 =P    2  Q  2  1 =P    2  R  1  0P    3 0R 3Q  0 =P    1  Q  1  2 =P    1  R  2  0=P Q  0  3=P R  3     Figure 11.7. A Bézier curve is subdivided into two components at the parameter value  s =  . The green points are those constructed by the de Casteljau algorithm.   1 2  This process recurs by connecting these new points and interpolating at the pa-    3 rameter value s until we are left with only one point  0P . In general, we have the  recurrence formula   =    1  −     s    P i    − 1  k  +  s      − ,  P k 1 + i 1   11.41    where we have equated  subdivided Bézier curve are given by   P . The control points of the two components of the  i      P k i i ≡P    0  i      Q P i 0   R P i  = =  3  i  −  i    .    11.42    11.4  Catmull-Rom Splines  1n +  points { 3n ≥ , a Catmull-Rom spline inter- P  with  P P , , , 1 0 } P P P , ,   using  a  piecewise  cubic  curve.  The  tangent  n− 2 1 1 iT  at each point  iP  is given by   Given a set of  polates  the  points { direction   }  ,  n   330   11. Curves and Surfaces            =  T i     P i  + 1  −  P i  − 1     .   1 2  We can express each piece  curve having the endpoints       tC iP  and   i   of the spline, where 1 1i+P  and the tangents   C  i      t  =  [  P i  P i  + 1  T T M i  + 1  i  H  ]   11.43    2 1i+T :   ≤ ≤ − , as a Hermite  i n iT  and  1 t t 2 t   11.44    .                 3  We would like to find a basis matrix  matrix   CRG  as four points, so we observe the following.   CRM  that allows us to express the geometry      [  ]  [  + 1  + 1  =  P i  P P i i  T T i i  0  − 1  2   0   1  2 CRM  must  Substituting this into Equation  11.44  shows us that the basis matrix  be the product of the rightmost matrix in Equation  11.45  and the Hermite basis  matrix   0 0 1 0 0 1 0 0  HM . Thus,    11.45    P P i i         P i  + 1  − 1  ]  +  2  − 1 2 0 1 2 0     M  CR  =  1 2  0 0 2 0 0 2 0 0         − 1 0 1 0  0 1 0     − 1 0 0   0 1 0     1 0 0    − 3 3 − 2 − 1  2 − 2 1 1         =  1 2  0 2 0 0         − 1 0 1 0  2 − 5 4 − 1  − 1   3  − 3   1   ,    11.46    and we can express the pieces of the Catmull-Rom spline as  1 t t 2 t  P M i      t  P i  P i  P i  C  =  CR  + 1  − 1  ]  [     +  2  3  i                ,    11.47    ] . Figure 11.8 shows an  where the geometry matrix is  example of a Catmull-Rom spline and illustrates how the tangent at each point is  parallel to the line segment connecting the two neighboring points.   =G  P P i i  P i  P i  CR  + 1  − 1  [  +  2   11.5  Cubic Splines      331   3P  2P  5P  0P  4P  1P  6P     Figure 11.8. A Catmull-Rom spline interpolates a set of points in such a way that the  tangent direction at each point is parallel to the line segment connecting the two neigh- boring points.   11.5  Cubic Splines   The piecewise cubic curves that we have examined up to this point exhibit local  control, meaning that if the geometrical constraints are modified for one of the  cubic functions composing the curve,  then only that piece of the curve and its  immediate neighbors can be affected. We now examine a different kind of curve  called a cubic spline. Cubic splines exhibit global control through the fact that  moving one of the control points affects the entire curve.    A cubic spline is a set of piecewise cubic polynomials that interpolate a given  2C   continuity  everywhere.  Cubic  splines  require  no  set  of  points  and  maintain  geometrical constraints, such as tangent directions or control points, in addition  to the points that they interpolate. We derive the cubic spline as a set of scalar  iS x . This can be extended to a parametric interpolation of a set of 3D  functions  points by constructing cubic splines for each coordinate independently.  y   Suppose  we  have  a  set  of  n x +< x  for 0 i i 1 {         S x S x , 0 ]1 [ x x + ,i .  i  }   where  ≤ ≤ − . We wish to find a set of n cubic polynomial functions  i n 1   x− iS x  is defined on the interval  S , , n  }    where each function   1n +   points {  , 0      x y , 1        ,  ,n  x  x  y  ,  ,  0  1  1  1   332   11. Curves and Surfaces                   11.48    11.49    11.50            We define the constants   i  i  i  i  + 1  + 1  + 1  + 1                x x x               = S + i 1 ′= S + i 1 ′′= S + i 1    S x i   ′ S x i   ′′ S x + i i 1 ih  and  ik  as follows for 0 h k  − x i −   y i  x i y  = =  + 1  + 1  i  i  i  i  ≤ ≤ − .  i n 1     11.51   We  construct  the  cubic  spline  interpolating  the  points { =   by  choosing  x y , n i i } 1 {     − values for the second derivatives of the functions  =  that cause the condi- S x n i i 0 tions listed in Equations  11.48 ,  11.49 , and  11.50  to be satisfied. We begin  with the set of functions   } 0  + 1  i      ′′ S x i  =     x  + 1  i  −     x  +     x  −    ,   x  i   11.52    ′′ i  i  y h y  ′′ y + i 1 h  i  where  the  constants   11.50   is  satisfied  regardless  of  their  eventual  values.  Integrating  we have   ′′ ′′   have  not  yet  been  determined,  but  Equation  , 1   twice,       iS x′′  ′′ 0  y  y  ,  n      S x i  =     x  + 1  i  −     x  3  +     x  −  x  i     3  +  C x D  +  i  ,   i   11.53    ′′ y i h 6  i  ′′ y + i 1 h 6  i  iC  and   where  place the arbitrary linear polynomial  + − 1  iD are the constants of integration. For later convenience, we re- C x D+  with a different linear polynomial,  i i   x B x i    A x i   11.54    −  +  ,   x        i  i      S x i  =     x  + 1  i  −     x  3  +     x  −  x  i     3  +    A x i  + 1  i  −     x  +    B x i  −    .   x  i   11.55    Applying the requirements that  the pair of equations      y=  and   i    S x i   1  +  i  += y  allows us to write  i 1  ′′ y + i 1 h 6  i   S x i  i    to obtain   ′′ y i h 6  i  y  i  y  + 1  i  =  =  ′′ y i 6 ′′ y + i 1 6  +  h  2 i  A h i  i  +  h  2 i  B h i  i  ,    11.56     11.5  Cubic Splines   333                  from which we can deduce the following values of   iA and   iB .   =  =  A i  B  i  −  i  i  y h y + i 1 h  i  i  ′′ y h i 6 ′′ y h + i 1 6  −  i      11.57    Plugging these values into Equation  11.55  gives us       S x i  =     x  3  +     x  −  x  i     3  ′′ y i h 6 i y   h  i  i     x  i  −  −  + 1 ′′ y h i i 6  +  ′′ y + i 1 h 6 i −  x     x  + 1  i         +  y + i 1 h i      −  ′′ y h + i i 1 6         x  −     .   x  i   11.58    Differentiating, we have   ′′ y + i 1 h 2   ′ S x i  i      ′ S x i  = −     x  + 1  i  −     x  2  +     x  −  x  i     2  +     ′′ i  y  −  ′′ + i 1  y    .    11.59    k h  i  i  +  h i 6  ′′ y i h 2  i  By applying the requirement that  system of   1n −  equations.      ′= S + i 1     x  + 1  i  + 1  i    , we arrive at the following   h y i  ′′ i  +     2  h  i  +     h  + 1  i  ′′ + i 1  y  +  h y + i 1  ′′ + i  2  =  6  0  ≤ ≤ −  n  i  2      11.60    k h  + 1  i  + 1  i      −  k h  i  i  ;      n  ,  ,  i  y  y  y  ′′ 0  0i =  and   1n +  unknowns   1n −  unknowns is written in matrix form as   ′′ ′′ , the solution set to the system given  , Since there are  1 by Equation  11.60  is a two-dimensional space. We can reduce this to a single  ny′′ at  solution by choosing any values we like for the second derivatives  the  endpoints  and  moving  the  terms  in  which  they  appear  to  the  right  side  of  1n −  equations  Equation  11.60  for  having  m 0 0 h m h 1  0 0  n= − . The resulting system of   ′′ y 1 ′′ y 2  ′′ y − n ′′ y n        0y′′ and   p   p     p   p                     11.61                      h n m  0 0   m h  h y 0  − n 0  0 0  0 0  0 0  0 0  h 1  −  =  −  h  h  2  ,   ′′ 0  ′′ n  y  − 1  − 1     −  −  −  −  −  −  n  n  n  n  n  n  1  2  2  2  3  2  1  2  0  2  3  3          where          334   11. Curves and Surfaces   2,5  4,4  3,4  1,1  5,2     Figure 11.9. A natural cubic spline interpolates a set of points with   2C  continuity.   m  i  p  i  =  =  2  6        h i k h  +  + 1  i  + 1  i  h i −   1 + k h i  i  .        11.62    y  ′′ i  − n = i 1  Plugging the values { } 0  The matrix appearing in Equation  11.61  is tridiagonal and diagonally dominant,  so  the  values  { } 1   can  easily  be  found  using  the  method  described  in  Section 16.2.5.     into Equation  11.58  gives us the pieces of the  ny′′ at the ends of the curve may be  cubic spline. The second derivatives  = ,  the  curve  is  arbitrarily  chosen  and  are  usually  set  to  zero.  When  0 called a natural cubic spline. An example of a natural cubic spline is shown in  Figure 11.9.   0y′′ and   ′′= y n  n = i  ′′ 0  y  ′′ i  y  11.6  B-Splines   The  Catmull-Rom  spline  and  the  natural  cubic  spline  both  interpolate  a  set  of  points without requiring any information in excess of the points themselves. The  1C  continui- Catmull-Rom spline exhibits the local control property and provides  2C  continuity, but at the cost of local control  ty. The natural cubic spline provides  since moving one point changes the entire curve. We now examine the B-spline,  2C  continuity eve- a curve that possesses the local control property and provides  rywhere. The trade-off is that a B-spline does not generally interpolate a set of  points, but only approximates their positions.    11.6  B-Splines     335   11.6.1  Uniform B-Splines   Like Hermite and Bézier curves, each piece of a B-spline can be expressed as a  cubic  curve  in  terms  of  a  basis  matrix  and  geometry  matrix.  The  letter  “B”  in  B-spline  stands  for  “basis”  and  distinguishes  the  curve  from  the  natural  cubic  spline, which does not use the basis and geometry matrix formulation. The ge- BSG  used by the B-spline is the same as that used by the Catmull- ometry matrix  Rom spline:   [  =G     BS  P i 1n +  control points {     tQ  corresponding to the pair of points   Given a set of  cubic curves  pieces is expressed as the weighted sum   P P i i  P P 0 1  + 1 }  P i  − 1  ,  ,  +  n  2  i  ] .   P , a B-spline is composed of   ,  2n −   1i+P . Each of these   iP  and    11.63     11.64    Q  i      t  3  =   k  =  0      B t k  P + − i k 1  ,        2  3  ,  n−  Q  n−Q      0 ,   and   Q      1 0Q  The  set  of  points   , and thus a curve having   2C  continuity.      0 ,  kB t   are  determined  by  imposing  the  constraint   where  the  blending  functions  that the entire curve possess  } {     Q   0   where  the  pieces  of  the  2 B-spline join together are called knots. We also classify as knots the endpoints of      1n +  control points pos- the curve,  2 1 1n −  knots. A B-spline is called uniform if the knots are spaced at equal  sesses  parameter values along the entire curve. At this point, we are only considering  tQ  of the curve corresponds to a parameter range of  the case that each piece  [ ]0,1 , so we are dealing with uniform B-splines. Nonuniform B-splines, in which  the knots may not be equally spaced with respect to the parameterization, are dis- cussed  in  Section  11.6.3.  Figure  11.10  shows  the  six  knots  belonging  to  a  B-spline curve having eight control points and thus five cubic pieces.    knot, leading to the following equations.   kB t  are found by requiring   The blending functions   2C  continuity at each             i  Q Q Q  i ′ i ′′ i      1     1     1  + 1  = Q i ′= Q + i 1 ′′ = Q + i 1      0     0       0   11.65          Expanding the first of these requirements with Equation  11.64 , we have    336   11. Curves and Surfaces            P1  Q1 t   P2  P6  P5  P3  Q2 t   Q5 t   Q4 t   Q3 t   P7  P4     P0  Figure 11.10. A B-spline curve constructed using the eight control points  diamonds indicate the positions of the six knots corresponding to the values of     1iQ .   iP . The gray   and      0iQ  B  0      P 1 − i 1 = B  0      + B 1 1     + P 0 i  P i B 1  + B     0      1 2 P i  + 1  P i +  + 1 B      + B 1 3     P 0 i  +  2  2  P + i 2 + B      0  3  P .  i 3  +   11.66    iP ,  Since this equation must be satisfied for arbitrary choices of the control points  the coefficients of each point in the equation must be equal on both the left and  right sides. Three points appear on both sides of Equation  11.66  and two more  appear only on one side, so we obtain the following five equalities.       1     1     1     1  0  B B 1 B B  3  2  = 0 = 0 = 0 = 0 =   0  − − − −  0  B B 1 B B  3  2      0     0     0     0  Applying the same procedure to the first and second derivatives, we also have    11.67     11.6  B-Splines     ′ B 0 ′ B 1 ′ B 2 ′ B 3      1     1     1     1  = 0 = 0 = 0 = 0 =   0  ′− B 0 ′− B 1 ′− B 2 ′− B 3      0     0     0     0  337    11.68        1     1     1     1  ′′ B 0 ′′ B 1 ′′ B 2 ′′ B 3      0     0     0     0  ′′− B 0 ′′− B 1 ′′− B 2 ′′− B 3  = 0 = 0 = 0 = 0 = .   11.69     0     3B t   This gives us 15 equations, but the coefficients of  amount  to  16  unknowns.  We  remedy  this  deficiency  by  forcing  the  blending  t = , giving us the final equation  functions to sum to unity at         11.70   0 By solving the linear system represented by Equations  11.67 ,  11.68 ,  11.69 ,  and  11.70 , we obtain the following blending functions for the uniform B-spline.   2B t , and   0 + B 1      0B t ,       1B t ,   = .  1      0      0      0       B  B  B  +  +  3  2  0      B t 0      B t 1      B t 2      B t 3  =  =  =  =       1  − t 6 − t 4 6  3  2 6 +  t 3 6  +  3  t 3  t 3 6  + t 1 3  2  −  3  t 3  M  BS  =  1 6  1 4 1 0         − 3 0 3 0  3 − 6 3 0  − 1   3  − 3   1   .       11.71     11.72    The basis matrix   BSM  is thus     and          338   11. Curves and Surfaces         1B  2B  1  2 3  1 6  0  0B  3B  t     1  Figure 11.11. The blending functions for the uniform B-spline.                 0B t ,       1B t ,   2B t ,  and   The  blending  functions   3B t   are  shown  in  Fig-   ure 11.11.  A  major  difference  between  these  blending  functions  and  those  for  Hermite curves, Bézier curves, and Catmull-Rom splines is that more than one  function is nonzero at both endpoints. The fact that the control points are not in- terpolated, but only approximated by the knots, is a consequence of this property  of the blending functions.    Control points may be replicated, but doing so incurs the cost of one degree  of  continuity  each  time  the  same  control  point  appears  consecutively  along  a  B-spline curve. The benefit is that more control over where the curve goes is ac- quired. One location at which control point replication is particularly useful is at  the endpoints. Consider the case in which the first control point is replicated three  times  so  that    of  the  B-spline  curve  is  then given by   P .  The  first  component  2      1 tQ  P 0  P 1  =  =  Q  1      t  = =      P B t 0 0 [     + B t 0      + B t 1     + B t 1          = + P P B t B t 3 2 2 1 ]         + P P B t B t 3 . 2 3 0  P 3      11.73    0  Q  1t = , we see that   0P  and  3P . Plugging in the      t =  and  1 = + P . The curve  P 5 3 0 6 0P  to  3P . Similar-  traces out the first sixth of the straight line running from  nP  of a B-spline curve three times results in   tracing out the last sixth of the straight line running  nP .  Figure  11.12  shows  the  same  B-spline  shown  in  Figure  11.10   This is a linear interpolation between the two points  values  Q 1     1 tQ ly, replicating the last control point  the final component  from  with its first and last control points both replicated three times.   3n−P   to   P  and  0      0 =  −Q 2n      t  1 6  1   11.6  B-Splines     339   Figure 11.12.  The  same  B-spline  shown  in  Figure  11.10  with  its  first  and  last  control  points replicated three times each. The green diamonds represent the knots. The compo- nents    are straight lines.    and       9 tQ      1 tQ  Q2 t   Q1 t   P0,1,2  P0  P3  Q3 t   P4  P1  Q1 t   P2  P8  P7  P5  P8  P7  P3  Q4 t   Q2 t   Q8 t   P9,10,11  Q9 t   Q7 t   P6  Q6 t   Q5 t   P9  Q7 t   Q5 t   P4,5,6 Q4 t   Q6 t   Q3 t         Figure 11.13. The same B-spline shown in Figure 11.10 with one of its interior control  points replicated three times. The green diamonds represent the knots.    340   11. Curves and Surfaces                 Figure 11.13 shows the same B-spline curve again, but this time with one of  its  interior  points  replicated  three  times.  The  curve  interpolates  the  replicated  0C  continuity at that point. This is equivalent to  control point, but only exhibits  two separate B-spline curves for which the last control point of the first curve is  equal to the first control point of the second curve and each is replicated three  times.   11.6.2  B-Spline Globalization   Each piece  [ t ∈ values  in terms of a global parameter u by assigning  it  tQ  of a uniform B-spline is defined over the range of parameter   0,1 1n +  control points, we can define each piece       . For a curve having   i   Q  i     u     =  Q  i     − u t  i=  and writing    .   i    i uQ      compose the same curve using the range of parameter values  The pieces  [   n∈ − . We can write Equation  11.74  in terms of the B-spline basis func- u 1 1, tions as follows.    11.74     11.75     Q  i     u     =     − B u t k  i     P + − i k 1     3    =  0  k       i uQ  , the point   iP  affects at most four pieces of the curve, and few- Any one of the control points  er than four only if it occurs near the beginning or end of the sequence of control  1B .  points. For the piece  The same point is weighted by the blending function  , the  1i 3B  for the  blending function  iP  does not contribute to any other piece of the  piece      j uQ i< −  or  curve, we can say that its weight is zero for any piece  i> + . It is possible for us to construct a weighting function  j iN u  that is al- iP  for every piece of the curve. Since each  ways used as the weight for the point  piece   iP  is weighted by the blending function      u+Q     u−Q  u  is defined over the parameter range   , and the blending function   2B  for the piece   . Since the point   0B  for the piece    where     1   i uQ      u−Q  iN u  as   ,i  2  2i  1i  [              j  t    N u  i        ,       , ,  i  + 1   ,  − 1  i  −  i  2           − B u t 0 − B u t i 1 − B u t 2 − B u t 3 0,    =       1 t + , we define  i    ;  ∈ [ [ [ [  i  i  i  t  t t t t  ∈ ∈ ∈ ∈  u , if  + 1 t u if  , + i 1 u t , if  i t u if  , − 2 otherwise.  − 1  i  i  + 2   ;   ;  − 1  i    ;      11.76     11.6  B-Splines           341    11.77     11.78    This allows us to express the entire curve as the following weighted sum of all of  the   1n +  control points.   Of course, any single piece  we can write     i uQ      is still only affected by four control points, so    Q      u  n  =   =  0  k      N u  k  P k      Q  i      u  3  =   =  k  N + − i k 1  P + − i k 1  .   0           iN u  possesses   iN u  is shown in Figure 11.14. Since it is  The shape of the blending function  composed  of  shifted  versions  of  the  four  blending  functions  shown  in  Figure  11.11, the function  The values  it  are called knot values since they correspond to the global pa-   rameter  value  at  each  of  the  curve’s  knots.  The  collection  of  knot  values  { t  is called the knot vector. The uniformity of the B-spline corresponds  t + −  is the same for any choice of i. This limita- to the fact that the difference  1i tion is removed for nonuniform B-splines—the only restriction is that the differ- ence between consecutive knot values be nonnegative.   2C  continuity.   , n  t 1,  }  t  t  ,  0  i  2it −  1it −  it  1it +  2it +  Figure 11.14. The global blending function  iN u  given by Equation  11.76 . Each of  the four components is a shifted version of one of the uniform B-spline blending func- tions shown in Figure 11.11.         u      342   11. Curves and Surfaces            11.6.3  Nonuniform B-Splines  A nonuniform B-spline is a generalization of the uniform B-spline in which the  knot values are not required to be equally spaced. As with uniform B-splines, a  P   is  nonuniform  B-spline  defined  by  a  set  of  ≤ ≤ − . The only restriction on  i n composed of  iP  is that it is not less than the  the knot value  it  corresponding to the control point  preceding  knot  value    of  the  spline  is  expressed  as  the  weighted sum   1n +   control  points {   where 1    2n −  cubic curves   1it − .  Each  piece     i uQ    i uQ  P P 0 1  }  2     ,  ,  ,  n  Q  i     u     3  =   =  0  k  N  + − i k  1,3     u     P + − i k 1  ,    11.79    where the per-control-point blending functions  recursive formula, known as the Cox-de Boor algorithm.        ,3iN u  are given by the following   N  i  ,0     u     N  i k ,     u        ,  t  − 1  i  ∈  [  i  t  u if   1, =  − 2 0, otherwise    − u t  =  i k ,     −  2  i  N + − i k      u − 1 − t −  i  2  2  t  +     t  + − i k 1  −     u  k  i  + 1,  N t + − i k 1  − 1 −    t     u − 1  i      11.80    i  i  i  i  i  2  2  +  −  ,  ,  t  t  t  t  t              − 1  + 1  1, −  , [      , [   t ,i      ,3iN u  is zero. The blending functions   iN u   given  by  Equation   11.76 ,  the  function   It is allowable for consecutive knot values to be equal, so the convention that di- vision by zero yields zero is used in Equation  11.80 . As with the global blend- ,3iN u   used  to  ing  function  iP   has  four  separate  components  covering  the  ranges  weight  the  control  point  [ , and [  1 t + t . These components can be precomputed  i i for a particular knot vector and control point index. Outside the range     ,  ,3iN u  are always nonnega- the function  tive and always sum to unity, so a nonuniform B-spline is contained within the  convex hull determined by its control points.    Maintaining  consistency  with  globally-parameterized  uniform  B-splines,  a  1i−P   piece   1 t + through  .  However,  the  four  i     i uQ blending  functions  corresponding  to    collectively  require  the  eight  knot    2t−   1 uQ values      5nt −   through  through  5t ,  and  the  last  piece  u−Q 5n +  knot  1n +  control points requires  2nt + . Thus, a nonuniform B-spline having      values. We begin the knot vector at the index  2−  so that the piece  i uQ  conven- iently begins at  it .     i uQ 2i+P   and  is  defined  only  over  the  range     of  a  nonuniform  B-spline  depends  only  on  the  control  points     depends  on  the  knot  values     depends  on  the  knot values   4it + .  The  first  piece   3it −   through        ∈  2n  ,i  u  [        t  t  t  ,  −  +  2  2  i  i   11.6  B-Splines     343   P1  Q1 u   t1 P0  P6  P5  P7  t6  Q5 u   t5  P4  Q4 u   t4  Q3 u      t2  P2  Q2 u   t3  P3  0,0,0,0,1,2,3,4,5,5,5,5   representing  knot  values   Figure 11.15. A nonuniform B-spline possessing the 8 control points  7P  and  using  the  knot  vector { 2t −   through  9t .  These are the same control points used by the uniform B-spline shown in Figure 11.10,  but the curve has now been modified so that it interpolates its first and last control points.  The green diamonds represent the knots corresponding to the knot values shown next to  them.   0P  through   }    Although it is by no means a necessity, the first four and last four knot values  1nt − , respectively. This guarantees the nice property that  are usually set to  1t  and  the  first  and  last  knots  are  coincident  with  the  first  and  last  control  points,  as  i=  for  shown in Figure 11.15. We recover the uniform B-spline by assigning  it every i. We may modify this so that the spline interpolates its first and last con- trol points by setting       11.81    t  i  1,  = i ,   − n   1,  if  2 if 2 n if   − ≤ ≤ i 1; ≤ ≤ − i n 2; − ≤ ≤ + i n 1    2.    A knot value that is repeated m times is said to have multiplicity m. As the      difference between knot values  it  and  i uQ   t becomes shorter. When   is reduced to a single point. Eve-   1it +  decreases, the length of the piece   , the piece  1    i uQ  t += i     i   344      11. Curves and Surfaces   P1  Q1 u   t1 P0  t2  P2  Q2 u   P6  P5  P3  P7  t6  Q5 u   t3 = t4 = t5  P4     Figure 11.16. A nonuniform B-spline having an interior knot value of multiplicity 3. The  knot vector is { 4P , but  only with   0,0,0,0,1,2,2,2,3,3,3,3 . The curve interpolates the control point   0C  continuity.   }  i  2  +  t  }  =  1i+P .    , then the control point   For the knot vector {  0,0,0,0,1,1,1,1 , the blending functions   ry time a knot value is repeated, a degree of continuity is lost at the correspond- ing knot. As shown in Figure 11.16, if the knot value  it  has multiplicity 3  so that  = 1i+P  is interpolated by the curve, but there is  t t + i i 1 0C  continuity at that point. If the multiplicity is increased to 4, as shown in  only  Figure 11.17, then the curve actually breaks at  ,3iN  given by the    ,3iB . Thus, a  Cox-de Boor algorithm are equivalent to the Bernstein polynomials  curve having this knot vector is a Bézier curve. The two separate components of  the curve shown in Figure 11.17 are both Bézier curves since the multiplicities of  the knot values at their endpoints are 4.    A major advantage that nonuniform B-splines have over uniform B-splines is  that  it  is  possible  to  insert  a  control  point  corresponding  to  a  new  knot  value  without  changing  the  shape  of  the  curve.  Suppose  that  we  have  a  knot  vector  { nP .  To  add  a  new  knot  value  t − 2 1n+′P  such that the  ′∈ t curves determined by the original control points and the new control points are   } + t , n ,  and  control  points  ]1   , we must find a new set of control points  0′P  through  t t + ,j j  0P  through   2   11.6  B-Splines     345   P1  P7  t6  Q5 u   t1 P0  Q1 u   P2  P4  t2 = t3 = t4 = t5   P6  P5  P3  Figure 11.17. A nonuniform B-spline having an interior knot value of multiplicity 4. The  knot vector is {  0,0,0,0,1,1,1,1,2,2,2,2 . There is a discontinuity at  u  t= .   }  2     coincident. The new control points are given by the following formulas, a process  known as Böhm subdivision.      ′  t + 1  i  − t −  t  2  − i t  i  −  2      P i  − 1  +  ′  t + 1  i  − t −  t  2  − i t  i  −  2  P i  ,  if   j  ≤ ≤ +  i  j    2   11.82    if   i  ≤ −  j  1  if   i  ≥ +  j  3  ′ = P i  , −  P  i       P  i  1  ,  − 1   We again use the convention that division by zero yields zero.  This process re- places two original control points with three new control points and leaves the  rest alone. Böhm subdivision can be used to increment the multiplicity of a knot  by setting  t  ′ =  .  t + 1j  11.6.4  NURBS  Nonuniform B-splines can be made even more flexible by extending them to ho- iP , and we  mogeneous coordinates. A weight  express each control point as   iw  is assigned to each control point    346   11. Curves and Surfaces                        =P i  w x w y w z w  ,  ,  ,  i  i  i  i  i  i  i  .    11.83    As usual, the control point’s position in 3D space is obtained by dividing by the  w coordinate. Since a piece    of the nonuniform B-spline is expressed as     i uQ     Q  i     u     3  =   =  0  k  N  + − i k  1,3     u     P + − i k 1  ,   the w coordinate at some point along the curve is given by   [  Q  i     u     ]  w  3  =   =  0  k  N  + − i k  1,3       u w  .   + − i k 1  The 3D position     i uQ      at the parameter value u is therefore    11.84     11.85    3    =  0  k  Q  i      u  =  N  + − i k  1,3      u w  + − i k 1  x  + − i k 1  ,  y  ,  z  + − i k 1  + − i k 1  .    11.86    N  + − i k  1,3      u w  + − i k 1  3    =  0  k  This can also we written as   where   Q  i      u  3  =   =  0  k  R  + − i k 1      u x  ,  y  + − i k 1  + − i k 1  + − i k 1  ,  z  ,    11.87    R  + − i k 1      u  =      u w + − i k 1     u w  + − l 1  i  1,3  + − i k N  i  + − l  1,3  .   N 3   =  0  l   11.88    Since  points  on  the  curve  are  expressed  as  a  ratio  of  two  polynomials,  these  curves are called nonuniform rational B-splines, or NURBS.  The weights affect how strongly the associated control points influence the    iw  causes the curve  shape of the curve. As shown in Figure 11.18, a larger weight  iP , and a smaller weight causes the curve to  to be pulled toward the control point  move away from the control point. Like the control points, the weights only af- fect at most four pieces of the entire curve, so the influence of a single weight is  isolated to a local portion of the entire curve.    11.6  B-Splines     347   P3  w3 = 4  w3 = 2  P1  w3 = 1 w3 = 1 2 w3 = 1 4  P0  P2  P4     Figure 11.18. A nonuniform rational B-spline. The different curves show what happens  as the weight corresponding to the control point   3P  changes.     All of the curves described in this chapter are invariant with respect to any  translation, rotation, or scaling transformation. That is, transforming the geomet- rical constraints  e.g., the control points  and generating the curve produces the  same  results  as  generating  the  curve using  the  untransformed  geometrical  con- straints and then transforming the result. NURBS are also invariant with respect  to a homogeneous projection transformation. The curve generated by the homo- geneous control points after projection is the same as the projection of the curve  generated using the unprojected control points. This property can be gained by a  nonuniform B-spline by promoting it to a NURBS curve in which every weight  has been assigned a value of 1.    NURBS have been widely adopted by computer modeling systems because  of their generality. NURBS can represent any of the other types of curves dis- cussed in this chapter, and unlike nonrational curves, can represent conic sections  exactly.1                                                          1  See  David  F.  Rogers  and  J.  Alan  Adams,  Mathematical  Elements  for  Computer  Graphics, Second Edition, McGraw-Hill, 1990.    348   11. Curves and Surfaces   11.7  Bicubic Surfaces         Our  knowledge  of  cubic  curves  can  be  readily  extended  to  bicubic  surfaces.  tQ   of  a  cubic  curve  required  four  geometrical  Whereas  a  single  component  3i+G ,  a  single  component  constraints    of  a  bicubic  surface,  called a patch, requires 16 geometrical constraints  . The gen- 3 eral parametric representation of a surface patch is given by   Q jG  through      , ij s t ,i  iG   through   +G j+ 3,       i  i  Q  ij     s t ,     3  3  =   k  =  0  =  0  l      B s B t k       l  G  + i k j ,  +  l  ,    11.89    2B , and  where the parameters s and t range from 0 to 1, and the functions  3B  are the blending functions for the type of cubic curve on which the surface  patch is based. Calling the basis matrix corresponding to the blending functions  M, we can write Equation  11.89  in the form   0B ,   1B ,   j  j  j  j  j  j  j  j  j  j  j  j  j  j  j  j  2  3  2  3  2  3  2  3  2  3  2  +  +  +  +  +  +  +  +  T  T  ,  ,     3,  3,  3,  3,  2,  2,  2,  2,  t  r ij        + 1  + 1  + 1  s  + 1  ≡  =  S  S  1,  M  s s ,      s      s         Q s t ,   11.90        MT ,  t  G r i , G r + i 1, G r + i G r + i  G r i , G r + i 1, G r + i G r + i  G r i , G r + i 1, G r + i G r + i  G r  i ,  G r +  i 1,  G r + i  G r  + i     ≡ T , and the index r represents one of the  t t t where  1, , ,  3  ,   . The geometrical constraint matrix G for a bicu- x, y, or z coordinates of  Q ij s t × ×  array of coordinates.  bic surface patch is a 4 4 3   A bicubic Bézier surface patch is defined by 16 control points. The surface  passes through four of these points at the corners of the patch, and the remaining  12 control points influence the shape of the interior of the patch. A simple exam- 0C  continuity at  ple is shown in Figure 11.19. Two adjacent Bézier patches have  the edge where they meet whenever they share the same four control points along  1G  continuity across the edge if the adjacent control points  that edge. They have  1C   on either side of the edge are collinear with the control points on the edge, and  is achieved if the distances to the control points on either side of the edge are  equal, ensuring that the tangent vectors have equal magnitude. When four Bézier  1C  continuity at that point requires that each pair  patches meet at a single point P,  1C   continuity  and  that  the  eight  nearest  control  of  adjacent  patches  meet  with  points are coplanar with P.     is obtained  by finding two tangent vectors and then calculating their cross product. The tan-   The normal vector at a point on a bicubic surface patch      , ij s t  Q   11.7  Bicubic Surfaces   349            Figure 11.19. A Bézier surface patch is defined by 16 control points. This particular sur- face passes through the 12 control points lying on the boundary of the patch. The remain- ing four control points determine the shape of the patch’s interior. In general, a Bézier  surface passes through only the four control points at the corners of the patch.         , gent vectors are found by taking the derivatives of  ij s t t. Using Equation  11.90 , we can write the derivatives as   Q   with respect to s and      Q s t ,  r ij     =     Q s t ,  r ij     =  T  S  d ds     s  T     S      s      ∂ ∂ s ∂ ∂ t  T  M G MT  r      t  T  M G M T  r  d dt          t  ,        11.91    where  r  again  represents  one  of  the  x,  y,  or  z  coordinates.  The  normal  vector  N   is then given by    ,   ij s t  N  ij     s t ,     =  Q  ij     s t ,     ×  Q  ij     s t ,    .    11.92    ∂ ∂ s  ∂ ∂ t   350   11. Curves and Surfaces                  11.8  Curvature and Torsion   In this section, we investigate quantities that characterize the amounts by which  an arbitrary path through space curves and twists. In the process, we are able to  construct  an  orthogonal  coordinate  system  at  each  point  along  a  curving  path  such that one axis is parallel to the tangent direction.    Let     κ t  of  direction  is,      tP   represent  a  twice-differentiable  parametric  curve.  The  curvature     tP  is defined to be the magnitude of the rate at which the unit tangent      ˆ tT  changes with respect to distance s traveled along the curve. That   where ds is the differential length given by       κ t  =  ˆ T      t  =  d ds      t  ,   d dt  ˆ T ds dt  =  ds      t dt  ,   P  d dt  and the unit tangent vector       ˆ tT  can be expressed as   ˆ T      t  =      t     t  T T  =      t  P      t  P  d dt d dt  d dt  =      t  .   P ds dt     κ t   quantifies  how  much  a  curve  bends  at  the  point  . For a straight line, whose tangent vector always points in the same direc-  Intuitively,  the  curvature     tP tion, the curvature is zero as would be expected.     Rearranging Equation  11.95 , we can write the first derivative of      tP   as   d dt      t  P  =      ˆ T .  t  ds dt  Since the curvature depends on the derivative of the tangent direction, we would  like to see how it relates to the second derivative of  . The derivative of the     tN  that is orthogonal to the tan- unit tangent vector       ˆ tT  points in a direction      tP   11.93     11.94     11.95     11.96     11.8  Curvature and Torsion   351                            t    d dt  gent vector itself  assuming that the derivative is not zero . This can be seen by  ˆ T first observing that   1  and then calculating       t  ˆ T  ≡  ⋅  =  0  ˆ T      t  ⋅  ˆ T      t  =  ˆ T  2      t  ⋅      ˆ T .  t     d dt   11.97       tN  can be thought of as a normal direction to the curve   The direction  . It  always points inward with respect to the direction in which the curve is bending.     Evaluating the derivative of       ˆ tT , we have      tP  Using Equation  11.96  to replace the first derivative of      tP   gives us   ˆ T      t  =  d dt  ds d dt dt  2  2      t  P  −  2  d s d 2 dt dt 2     ds dt          t  P  .   2  2  d dt      t  P  −  d s 2 dt 2  ˆ T      t  .   ˆ T      t  =  d dt  ds dt  Solving for the second derivative of    yields   2  2  =  P  ˆ T      t      t  d ds d dt dt dt     ˆ tT  points in the direction   +      ˆ T .  t     tN , we can write   Since the derivative of      tP d s 2 dt 2  d dt  ˆ T      t  =  ˆ T      t      ˆ N ,  t  d dt       ˆ tN   has  unit  length.  Using  the  definition  of   where   11.93 , we rewrite Equation  11.100  as      κ t   given  by  Equation   2  2  d dt      t  P  =  ˆ T      t  +      κ t  d s 2 dt 2  2  ds dt              ˆ N .  t   11.102       tP   given by   If we take the cross product of the first and second derivatives of  Equations  11.96  and  11.102 , we obtain    11.98     11.99     11.100     11.101     352   11. Curves and Surfaces                         t  P  ×      t  P  =  ˆ T      t  ×  ˆ T      t  +      κ t  d dt  2  2  d dt  ds dt  2  ds dt          ˆ N      t      d s 2   dt 2  3       ˆ T  =      κ t  ds dt          t  ×  ˆ N      t  .         11.103             ˆ tT  and   ˆ tN  are both unit vectors, the magnitude of their cross product is  Since  unity. Thus, upon using Equation  11.94  to replace the quantity ds dt, we arrive  at the following expression for     κ t .       κ t  =  ′  P      t      t ′ P  ′′× P     3 t      11.104    Let us consider the curvature of a circle of radius ρ. Such a circle lying in the     x-y plane can be expressed parametrically as       t  P  =  ρ  cos , sin ,0  t ρ  t  .    11.105    Applying Equation  11.104 , we see that the curvature is       κ t  =  −  ρ  sin , cos ,0  t ρ  ρ  t sin , cos ,0  × − t ρ  − t cos , 3 t  −  ρ  ρ  sin ,0  t  =  1 ρ  ,    11.106    1  =      ρ t      κ t     tP  or simply the reciprocal of the radius of the circle. For a general curve, we call   the radius of curvature. As shown in Figure 11.20, the  the quantity  radius of curvature at a point   corresponds to the radius of a circle that is     tP tangent to the curve at   and lies in the plane determined by the directions      ˆ tT  and  ˆ tN . This plane is called the osculating plane, and the circle is called  the osculating circle.     gives the acceleration of a  particle following the path at time t. Examining Equation  11.102  more closely,  we observe   The second derivative of the position vector      tP           t  a  =      t  P  =      v t  ˆ T      t  +  2  2  d dt  d dt  2  [  ]     v t     ρ t      ˆ t N ,    11.107    ds dt   is the scalar speed at time t. The coefficients  Ta  and  Na  de-  where     v t fined by   =   11.8  Curvature and Torsion   353            ˆ tT      ˆ     tN      1 κ t     tP  Figure 11.20. The osculating circle lies in the plane determined by the tangent direction      ˆ ˆ tT  and the normal direction  tN . The radius of the osculating circle is the reciprocal of  the curvature     κ t .           =  =  a  T  a  N  d     v t dt [ ]     v t     ρ t  2      11.108    are called the tangential and centrifugal components of the acceleration, respec- tively. The centrifugal component agrees with the acceleration corresponding to  the centrifugal force given by Equation  14.8 .    We can complete a three-dimensional orthonormal basis at a point  defining the unit binormal       ˆ tB  as      tP   by   ˆ B      t  =  ˆ T      t  ×      ˆ N .  t   11.109        ˆ tB  is called the Frenet  The coordinate system having the axes  frame. The derivatives of the axes with respect to the distance s along a path can      ˆ tT ,  we  be  written  in  terms  of  the  axes  themselves.  For  the  tangent  direction  have   ˆ tN , and       ˆ tT ,         354   11. Curves and Surfaces                  ˆ T      t  =  ˆ T      t  ˆ N      t  =      κ t      ˆ N .  t  d ds  d ds   11.110    The derivative of the binormal can be written as   ˆ B      t  =  ˆ T      t  ×  ˆ N      t  +  ˆ T      t  ×      ˆ N .  t   11.111    d ds  d ds  d ds  Since the derivative of the tangent direction is parallel to the normal direction,  the  first  cross  product  is  zero.  The  derivative  of  the  normal  direction  must  be  perpendicular to the normal direction itself  because it has constant length  and  can therefore be expressed as a linear combination of the tangent and binormal      τ t ,  we  simplify  Equation  directions.  Thus,  using  the  functions   11.111  as follows.      α t   and   d ds  ˆ B      t  =  ˆ T  ×      t     τ t      α t     t    ˆ N  = −  ˆ T      t  +      τ t  ˆ B      t         11.112    Finally, the derivative of the normal direction yields   ˆ N      t  d ds     =  ×  =  ˆ B      t      t  d ds d ˆ ˆ T B ds         ˆ = − t τ t N         ˆ − = t τ t B  ×  ˆ T      t     +      t  ˆ B     ˆ × t T     ˆ κ t T      t  ˆ + B     t .  ×  d ds     × t      ˆ T t     κ t     This shows that the value of     α t  in Equation  11.112  is  the three relations   ˆ N      t      κ t−   11.113    .  Taken together,   ˆ T      t  =      κ t  ˆ N      t  ˆ N      t  =      τ t  ˆ B      t  −      κ t  ˆ T      t  d ds d ds d ds  ˆ B      t  = −      τ t  ˆ N      t      11.114    are called the Frenet formulas.    Chapter 11 Summary   355                  The quantity       τ t  is called the torsion of the curve and pertains to the amount    by which the Frenet frame twists about the tangent direction as it travels along a  ˆ tN , we  path. By taking the dot product of both sides of Equation  11.112  with  obtain the following explicit formula for the torsion.            τ t  = −      ˆ ⋅N t      B   t   11.115    ˆd ds      For a planar curve, the vectors  the curve, so  Thus, the torsion of planar curves is zero everywhere.   ˆ tN  always lie in the plane containing      ˆ tB  is constant except for discontinuities that occur when      0 κ t = .       ˆ tT  and   Chapter 11 Summary   Cubic Curves  Several classes of cubic curves can be expressed in the form       =Q t      GMT ,  t  where G is the geometrical constraint matrix associated with the class of cubic  curve, M is the constant basis matrix, and  . Table 11.1 summa- rizes  the  geometrical  constraint  matrices  and  basis  matrices  discussed  in  this  chapter.   t t 1, ,      t  T  ≡  t  ,  2  3  Nonuniform B-Splines  A nonuniform B-spline having the  vector  { + t t , , n ≤ ≤ − . Each piece  i n 1  }   is  composed  of  2   i uQ  is defined as   − 2 2  − 1     t  t  ,  ,  0  1n +  control points {  , 2n −   cubic  curves   P  and the knot  ,  where   P P 0 1  } n   i uQ     ,  ,  Q  i     u     N  + − i k  1,3     u     P + − i k 1  ,   3  =   0  = k     [  where the blending functions   ,3iN u  are given by the Cox-de Boor algorithm:  u if   ∈     t  t  ,  − 1  i  N  i  ,0     u     N  i k ,     u     i  1, =  − 2 0, otherwise    − u t  =  i k ,     −  2  i  N + − i k      u − 1 − t −  i  2  2  t  +     t  + − i k 1  −     u  k  i  + 1,  N t + − i k 1  − 1 −    t     u − 1  i  .    356      11. Curves and Surfaces   Class   Geometrical Constraint   Basis Matrix M   Matrix G   Hermite   [  P 1  ] P T T   2  1  2  Bézier   [  P 0  P 1  P 2  ] P   3  Catmull-Rom   [  P i  − 1  P P i i  + 1  P i  +  2  ]    Uniform B-spline   [  P i  − 1  P P i i  + 1  P i  +  2  ]    1 0   0 0  0 1   0 0  − 3 1   0 3  0 0   0 0  − 1 0   0 2  1 0   0 0  − 3 1   0 4  1 3   0 0   1 2  1 6  − 3 3 − 2 − 1 3 − 6 3 0 2 − 5 4 − 1 3 − 6 3 0        2  − 2  1   1  − 1   3  − 3   1  − 1   3  − 3   1  1   3  − 3   1         Table  11.1.  Geometrical  constraint  matrices  and  basis  matrices  for  various  classes  of  parametric cubic curves.   =P i  w x w y w z w  ,  ,  ,  i  i  i  i  i  i  i  } ,  a  nonuniform  rational   R  + − i k 1       u x  ,  y  + − i k 1  + − i k 1  + − i k 1  ,  z  ,   NURBS  For  a  set  of  control  points  { B-spline is defined as  Q  u           3  i  =   k  =  0  where      R  + − i k 1     u     =       u w + − i k 1     u w  + − l 1  i  1,3  + − i k N  i  + − l  1,3  .   N 3   =  0  l   Exercises for Chapter 11   357                  Bicubic Surfaces  A bicubic surface patch is defined as  = S  r  T        S      s      s    ijQ s t ,     ≡ t      M G MT ,  t ,  M  is  the  4 4×   basis  matrix  corre- where  sponding to the class of cubic curve on which the patch is based, and r represents     , × ×   array  of  control  one  of  the  x,  y,  or  z  coordinates  of  ij s t point coordinates.   .  G  is  the 4 4 3  t t 1, ,  s s ,  Q  T  1,  ≡  ,   s  t  ,  ,  T  3  2  2  3  r  The normal vector   N     , ij s t   to the surface of a bicubic patch   Q     , ij s t   is given by   N  ij     s t ,     =  Q  ij     s t ,     ×  Q  ij     s t ,    .   ∂ ∂ s  ∂ ∂ t  Curvature and Torsion  The curvature     κ t  of a curve   The radius of curvature is      ρ t The torsion      τ t  is defined as   =  1      κ t  .      tP      κ t   is given by  ′′× P     3 t      t ′ P  P  =  ′      t  .       τ t  = −      ˆ ⋅N t      B ,  t  ˆd ds  ˆ tN  is the unit normal vector given by the normalized derivative of the        where  unit tangent direction       ˆ tT , and  ˆ B      t  =  ˆ T      t  ×      ˆ N .  t  Exercises for Chapter 11      tB  1.  Suppose  that   2    is  a  quadratic  Bézier  curve  having  the  three  control   points  0P ,  1P , and  2P . That is,      t 2 1      t    1  B  −  =  +     P 0  t  2  2  −     t  P 1  Determine the four control points  curve   2  t  P .  2  + 0′P  through   3′P  such that the cubic Bézier    358   11. Curves and Surfaces               t  3  ′ P   3     tB  2     B  3      t  =    1  −     t  3  ′ P 0  +    t 3 1  −     t  2  ′ P 1  +  2  t 3    1  −     P  ′ 2  t  +  is exactly coincident with the quadratic Bézier curve  called degree elevation.    .  This process is   0P ,  1P ,   2.  Suppose that the de Casteljau algorithm is used to split a Bézier curve hav- t = . Find the  QM  that transforms the control points of the original curve into the  3Q  for the curve coinciding with the interval  RM  that transforms the control points of the origi- 3R  for the curve coinciding   2P , and  3P  at the parameter value   ing the control points  matrix  control points  ]1 [ , and find the matrix  20, nal curve into the control points  with the interval [    2 ,1 . That is, find matrices   QM  and  ] P M   Q 3  Q Q Q Q  RM  such that   2Q , and   2R , and   0Q ,   0R ,   1Q ,   1R ,   P 1  P  P  =  ]  [  [  ]  1 2  1  0  3  2  1  0  2     and      [  R  0  R R  1  2  R  3  ]  =  [  P 0  P 1  P 2  ]  P M .  R 3  3.  A  Kochanek-Bartels  spline  extends  the  formulation  of  the  Catmull-Rom  iβ , to  iP .  Hence, Kochanek-Bartels splines are  iP   iP  and the tangent direc-  spline by allowing three parameters, tension  iτ , continuity  iγ , and bias  be specified at each control point  sometimes called TCB splines.  For a cubic curve interpolating the points  and  tion   ,1iT  corresponding to  1i+P  are given by   1i+P , the tangent direction  ,2iT  corresponding to the point      − β  + γ 2    1     1     1     1    1    1  T i  −  +  =  −  β  τ  τ  ,1  i  i  i  i  +    1  −  τ     1  + 1  i     1  +  β  i  T i  ,2  =  i  −  − γ 2 γ + i 1 2    1  +    1  −  τ  + 1  i  +     1  −  + 1  i  γ 2        − 1  −  P i     −  P i     + 1  i  + 1  − P P i i     P i     β  + 1  + 1  P i      i  P i  +  2  −    P .  i  + 1   Note that the tangent direction used at a point  for both of the curves for which   iP  is an endpoint.    iP  is not necessarily the same    a   For what values of   iτ ,   iγ , and   iβ  does the Kochanek-Bartels spline re-  duce to the Catmull-Rom spline?    Exercises for Chapter 11   359                   b   Under what conditions does the tangent direction  1i+P  match the tangent direction  2i+P ?   terpolating  terpolating   iP  and  1i+P  and   ,2iT  for the curve in- i+T  for the curve in-  1,1  =G   c   Find the basis matrix   KBM  corresponding to the curve interpolating   iP   1i+P   that  describes  the  Kochanek-Bartels  blending  functions.  As- and  ] . [Hint.  sume that the geometry matrix is  Use  a  method  similar  to  that  which  produces  the  Catmull-Rom  basis  matrix in Equation  11.46 .]     uQ   be  a  nonuniform  B-spline  lying  in  the  x-y  plane  having  control  .  Suppose  the  knot  0,0,0,0,1,1,1,1 .  Use  Böhm  subdivision  to  insert  a  new  knot  at   =P points  0 vector  is { t′ =  and determine the new control points  0′P  through  4′P .   ,  and   1,2 }  =P 2  =P 3  =P 1  2,2  0,0  3,0  P i  P i  P i  P i  ,   ,   KB  + 1  − 1  [  +  2  1 2  4.  Let   5.  Calculate the curvature     κ t  and the torsion       τ t  of the helix given by   6.  Given a path   3C  continuity, show that             t  P  =      t  P  d ds  t ct  .   t r   having   r cos , sin ,    tP d 2 ds      t  P  ×  2      ⋅  d 3 ds  3      t  P  =  [      κ t  ]  2      τ t ,       where     κ t  is the curvature of the path and       τ t  is the torsion of the path.    This page intentionally left blank    12   Collision Detection   Every 3D game is filled with the action of moving objects. Except when an ob- ject is emitting a force field that affects its surroundings, interaction between two  objects generally occurs only when they attempt to occupy the same space at the  same time. The process by which game engines determine when such events oc- cur  is  called collision detection.  With  the  exception  of  those  that  take  place  in  deep  space,  most  games  need  to  determine  when  a  collision  occurs  between  a  moving object and the environment. The complex geometrical shapes that mov- ing objects may possess are usually approximated by simple bounding volumes  in order to reduce the cost of collision detection calculations.    Suppose  that  the  position  of  a  moving  object  is  known  at  the  time  that  a  frame is rendered, and that we are able to calculate the position to which the ob- ject would move if it is unobstructed before the next frame is rendered. Since the  time between frames is usually small, it is commonly assumed that objects travel  along straight lines during the time between frames, even if it is known that an  object is following a curved path. Thus, the general collision detection problem is  determining  whether  the  extrusion  of  an  object’s  surface  along  a  line  segment  intersects  some  part  of  the  environment.  Very  small  moving  objects  are  often  treated as points, reducing the collision detection problem to  a ray intersection  calculation.  For  larger  objects,  finding  the  exact  point  where  the  object  makes  contact with a complex environment can be extremely difficult. For that reason,  surfaces of moving objects are often approximated by simpler bounding volumes.   12.1  Plane Collisions   Detecting  a  collision  between  a  moving  object  and  a  single  infinite  plane  amounts to the problem of determining what point on the object would be in con- tact  with  the  plane  at  the  time  of  a  collision.  We  can  then  represent  the  entire  moving object by that point in a ray intersection calculation. Being able to detect        361    362   12. Collision Detection                  collisions  with  infinite  planes  is  useful  in  environments  that  are  partitioned  in  some way  see Section 12.1.3 , so we examine the calculations involved in de- termining  when  a  sphere  or  box  collides  with  an  infinite  plane  in  this  section.  Later, we discuss the more difficult, but very practical method of determining the  collision of a sphere with an arbitrary environment.   12.1.1  Collision of a Sphere and a Plane  As shown in Figure 12.1, when a sphere is in contact with a plane L  on the posi- tive  side ,  the  distance  from  the  center  of  the  sphere  P  to  the  plane  is  r,  so  L P  . Writing the plane L as the 4D vector   ⋅ =  r  the relationship   ⋅ =L P  r  =L N  , D  ,    can be written as  ⋅ +  N P  = D r  .   ⋅ +  N P  − =  D r  0  ,   If we move r to the left side of the equation, then this is equivalent to    12.1     12.2     12.3    which is the same as stating that the point P lies on the plane   ′L  given by    12.4   ′L  is parallel to L, but it has been shifted by the distance r in the direc-  .   N  L  − ,D r  ′ =  Suppose  that  the  center  of  a  sphere  of  radius  r  moves  from  the  point  1P  at  t =  to the point  2P  at the time  1t = , and that we wish to determine whether   The plane  tion of its normal.    time   0  P  r  ′L L     Figure 12.1. A sphere of radius r is in contact with a plane L when its center lies on the  plane   ′L  that has been shifted by a distance r.    12.1  Plane Collisions   363                        it collides with a plane L. We assume that the sphere is not initially intersecting  1P  lies on the positive side of a plane since  the plane and that the starting point  . If it is  the negative side represents the interior of some structure. Thus,  also the case that  , then the sphere remains on the positive side of the  1t≤ < , in which case we know that no collision  plane during the time interval 0 occurs.      of the sphere’s center at time t is then given by   The position      tP  L P 2  L P 1  ≥  ≥  r  r  ⋅  ⋅  where V is the velocity of the sphere:   A collision occurs between the sphere and the plane   =L N  , D   if the equation   ′L  is defined by Equation  12.4   has a solution t such that 0   where  stituting the value given by Equation  12.5  for   , we have      tP  1t≤ < . Sub-      t  P  =  P 1  +  t  V,   =  V P 2  −  P .  1  ′⋅ L P      0 = t     ′  ⋅  L P 1  +     ′  ⋅  L V     t  =  0  .   = −  t  ′⋅ L P 1 ′⋅ L V  .    12.5     12.6     12.7     12.8     12.9    Solving for t yields   Remember that the vector V represents a direction and therefore has a w coordi- 0 ,  then  the  sphere  is  nate  of  0,  so  the  denominator  is  equal  to  moving parallel to the plane, so no intersection occurs. Otherwise, the sphere col- lides with the plane at the time t given by Equation  12.9 . The point C at which  the sphere makes contact with the plane is given by   ⋅N V.  If   N V  =  ⋅  =  C P     t  −  N  r   12.10    since this point lies at a distance r from the sphere’s center in the direction oppo- site that of the plane’s normal N.    364   12. Collision Detection            12.1.2  Collision of a Box and a Plane  Determining whether a moving box collides with a plane can be accomplished  using a method similar to that used to determine whether a sphere collides with a  plane. The difference is that we must offset the plane by the effective radius of  the box, introduced in Section 8.2.4. Furthermore, the box can make contact with  the plane at more than one point. It is possible that an edge of the box collides  with the plane or that the box meets the plane directly parallel to one of its faces.    Suppose that a box has edges whose lengths and orientations are described  by the vectors R, S, and T. The effective radius  effr  of the box with respect to a  plane having normal direction N is given by  + ⋅    R N S N T N .    12.11    r = eff  +        ⋅  ⋅  1 2  1Q  be the position of the box’s center at time   1t = , as shown in Figure 12.2. Then the position   0  2Q  be its position     tQ  of the box is given   t = , and let   Let  at time  by   where V is the velocity of the box:       t  Q  =  Q  1  +  t  V,   V Q Q .  1  2  −  =  To find an intersection with the plane   =L N  , D  , we calculate    12.12     12.13    1Q  2Q  effr  ′L  L     Figure 12.2. Whether a moving box collides with a plane can be determined by shifting  the plane by the box’s effective radius.    12.1  Plane Collisions   365    12.14     12.15                = −  t  ′⋅ L Q 1 ′⋅ L V  ,   ′ =  L  N  − , D r eff  .   where   ′L  is the plane parallel to L that has been offset by a distance  effr :   1  2  0  ≥  ≥  ′⋅ L Q  ′⋅ L Q  t =   i.e.,   ′L  at time   Again, we assume that the box is not initially intersecting the plane and that its  0 center lies on the positive side of   . Therefore, if  0   is  also  satisfied,  then  the  box  remains  on  the  positive  the  condition  side of the plane L, and no collision occurs.    Once we have determined that a collision between the box and the plane has  1t≤ <  , we  occurred  because the value of t given by Equation  12.14  satisfies 0 must determine the point or set of points at which contact has been made. If all  ⋅T N  are nonzero, then no edge of the  three of the quantities  box is parallel to the plane L. In this case, the collision must occur at one of the  box’s vertices. We can find a general formula for the position of the vertex that  makes contact with the plane by examining expressions for all eight of the box’s  vertices. The position Z of each vertex of the box is given by   ⋅S N , and   ⋅R N ,   =  Z Q      t  ±  R  1 2  ±  ±  S  1 2  T.   1 2   12.16    To find the vertex closest to the plane, we choose signs such that the dot product  ⋅L Z is minimized. This occurs when the quantities ± ⋅R N, ± ⋅S N, and ± ⋅T N are  all negative; so if any one is positive, we choose the corresponding negative sign  in Equation  12.16 . The point of contact C is then given by     ] T N T .     S N S  R N R   12.17    C Q      t  sgn  sgn  =  −  +  +                 ⋅  ⋅  ⋅  [ 2 sgn 1  ⋅R N ,   In the case that exactly one of the quantities   ⋅T N  is zero,    the corresponding axis of the box is parallel to the plane, and any collision must  2C  of the edge are given by modifying  occur at an edge. The endpoints  Equation  12.17  so that both signs are chosen for the term containing the zero  dot product. For instance, if      t  , then we have     ] S N S T .   ⋅S N , and   T N [ − 2 sgn 1  1C  and   R N R   12.18    0    sgn  Q  C  =  =  ±  +  1,2           ⋅  ⋅  ⋅  ⋅R N ,  This  modification  is  taken  one  step  further  when  two  of  the  quantities  ⋅S N , and  ⋅T N  are zero. In this case, the collision occurs at a face of the box  whose vertices are given by modifying Equation  12.17  so that both signs are    366   12. Collision Detection            ⋅  ⋅  0  =  T N   and   chosen  for  both  of  the  terms  containing  zero  dot  products.  For  instance,  if  4C  of the face in contact  S N with the plane are given by  =  , then the vertices   ] R N R S T .   3C , and    12.19    ± ±  2C ,   1C ,       t  Q  C  =  −  0           ⋅  1,2,3,4  [ 2 sgn 1  12.1.3  Spatial Partitioning  Being able to determine  whether an object collides with a plane is essential to  fast  collision  detection  in  a  spatially  partitioned  environment.  Since  regions  of  octrees and BSP trees are separated by planes, we can usually tell that a moving  object does not collide with large parts of the world without having to perform  collision detection tests with the actual geometry in those regions.  Suppose that an object moves from the point  1P  to the point  2P  during a single      represent  a  plane  that  partitions  the  world  geometry  in  frame.  Let  some way, and suppose that the moving object has an effective radius of  effr  with  respect to that plane. We say that the object lies completely on the positive side  of the plane L if its position P satisfies   =L N  , D  and we say that the object lies completely on the negative side of the plane L if  its position P satisfies   ⋅ ≥L P  effr  ,   ⋅ ≤ −  L P  effr  .    12.20     12.21    1P  and   2P  represent positions of the object for which it lies  If both of the points  completely on the positive side of the plane, then we know that no part of the  object ever crosses into the negative side of the plane L. Similarly, if both of the  points  1P  and  2P  represent positions of the object for which it lies completely on  the negative side of the plane, then we know that no part of the object ever cross- es into the positive side of the plane L. When these cases occur, we can avoid  performing collision detection calculations between the moving object and any  geometry that lies on the opposite side of the plane L.   12.2  General Sphere Collisions   We now study a powerful technique for determining when a moving sphere col- lides with an arbitrary static environment. The method presented in this section is  quite capable of serving as the entire collision detection system for a 3D game    12.2  General Sphere Collisions      367   engine, so long as it is acceptable to approximate moving objects by their bound- ing spheres. It can also be employed to detect collisions between a moving sphere  and any other arbitrarily complex moving object by subtracting velocities.    The collision detection method is based on the fact that the center of a sphere  of radius r in contact with another object lies at exactly the distance r from the  surface of the object. If we consider a sphere in contact with a polygonal model,  the set of all possible centers forms a surface having three kinds of components.  First, the set of centers for which a sphere is in contact with a single face of the  model  consists  of  the  interior  of  the  face  moved  outward  in  the  face’s  normal  direction by the radius r. Second, the center of a sphere in contact with a single  edge  of  the  model  lies  on  the  cylinder  of  radius  r  having  the  edge  as  its  axis.  Third, the center of a sphere in contact with a single vertex of the model lies on  the sphere of radius r centered at the vertex position. We can determine when a  moving sphere collides with the model by determining when the ray representing  the motion of the sphere’s center intersects the expanded surface of the model, as  illustrated in Figure 12.3.    polygonal model is summarized by the following three steps.   The procedure for determining whether a sphere of radius r collides with a   A.  Determine whether the sphere’s center intersects any of the faces of the mod- el after they have been moved outward by the distance r. If it does intersect a  face, then skip the next two steps.   C  r     Figure 12.3. A sphere of radius r collides with a polygonal model when its center C in- tersects the expansion of the surface by the distance r.    368      12. Collision Detection   B.  Determine whether the sphere’s center intersects any of the cylinders of radi- us r corresponding to the expanded edges of the model. If it does intersect an  edge, skip the third step.   C.  Determine whether the sphere’s center intersects any of the spheres of radius   r corresponding to the expanded vertices of the model.     When  performing  intersections  with  the  edge  cylinders,  we  do not  have  to  worry about whether the intersection occurs on the exterior surface because an  intersection with the interior surface would be preceded along the ray by a face  intersection   see  Figure  12.4 .  Likewise,  an  interior  intersection  with  a  vertex  sphere would be preceded by either a face intersection or an edge cylinder inter- section.    A ray intersection with a triangular face of a model can be accomplished us- ing the method discussed in Section 6.2.1. Each face’s plane needs to be offset by  the distance r to determine the point of ray intersection. The barycentric coordi- nates of that point can then be calculated using the original vertex positions of the  triangle  see Chapter 6, Exercise 5 . A ray intersection with a vertex sphere can  be  performed  using  the  method  discussed  in  Section  6.2.3  after  translating  the  vertex’s position to the origin. Calculating the intersection of a ray and an edge  cylinder  is  slightly  more  complicated  since  the  cylinder  can  have  an  arbitrary  orientation.   Figure 12.4. A ray intersection with the interior surface of an edge cylinder must be pre- ceded  by  a  face  intersection,  in  which  case  the  cylinder  intersection  calculation  would  never  have  been  performed.  Thus,  cylinder  intersections  can  be  assumed  to  lie  on  the  exterior of the expanded surface. A similar argument applies to vertex spheres.       12.2  General Sphere Collisions   369               t 1E  and   2E . It is convenient to translate our coordinate system by   Suppose  we  need  to  determine  at  what  parameter  value  t  the  ray given  by       t = + P S V intersects a cylinder of radius r corresponding to the edge having  1−E  so  endpoints  that one end of the cylinder is centered at the origin. A point P lies on the lateral  surface of the infinite cylinder aligned to the edge if its distance from the axis  A E E  is equal to r. Using the distance formula derived in Section 5.1.1, we  can describe the set of points on the surface of the infinite cylinder as follows.   =  −  2  1  Replacing P with the translated ray  P  = − S E . Expanding this and collecting terms, we obtain the quadratic  S where  0 1 + at bt 2 2 equation   + = , where  c  0  2  r  =  =  2  P  2  P  2        −  −  A P   2    proj   ⋅ P A A 2     t − E  gives us  [   ⋅ − S  +     0  2  1  ] 2  ,   V A t A 2  2  r  =     S  0  +     t  V        2  ⋅ V A A 2   S A V A 0  ⋅  ⋅     =  a V  2  −  b  =  ⋅ −  S V 0  =  c  S  2 0  −  2  r  −  2  .        A 2   S A 0 2  ⋅ A     =  −  2  4D  The discriminant      tells us whether the ray intersects the infinite  D > , we must also check that the point of intersection falls within  cylinder. If  the edge. Since the value of a is always positive, the parameter t corresponding to  the first intersection along the path followed by the ray is given by   4 0  ac  b  −  − − b  2     t  =  ac  b a     t − P The signed length L of the projection of  1 ]1     − E A t A  [ = P  L     .   .   E  onto the vector A is equal to  ⋅   12.22     12.23     12.24     12.25     370      12. Collision Detection   The ray intersects the portion of the cylinder corresponding to the edge if L is  positive and less than  A , so we simply need to check that     E A  ⋅ <      t  P  A  <  −  0  .   [  ]  2  1    When determining whether a swept sphere collides with a complex geomet- rical model, we want to avoid as many ray-triangle, ray-cylinder, and ray-sphere  intersects as possible. The first step should always be to determine whether a col- lision  would occur  with  the  model’s  bounding  sphere.  For  a  moving  sphere  of  radius r and a model having a bounding sphere of radius R, we need to intersect a  ray with a sphere of radius R r+ . The point of intersection is irrelevant—we only  need to know whether an intersection occurs.    If  the  bounding  sphere  test  passes,  we  must  determine  whether  the  swept  sphere collides with a face, edge, or vertex of the model. To avoid unnecessary  intersection tests, these components of a model should be sorted into some kind  of hierarchical structure, such as an octree, and stored in an efficiently traversable  format ahead of time. Creating separate structures for faces, edges, and vertices  helps reduce memory access costs since edge and vertex intersects do not need to  be performed if a face intersection is found.    Not all of a model’s edges and vertices need to be considered for collision  detection. As shown in Figure 12.5, the cylinder surrounding an edge where two  faces meet at an exterior angle of less than or equal to 180 degrees lies complete- ly inside the expanded surface. Thus, no part of the cylinder contributes to the  collision surface, and the edge can be safely ignored. A similar principle applies  to vertices. If a particular vertex is not the endpoint of any eligible edge, then it  must also lie completely inside the expanded surface.  2E     meet at an exterior angle less than or equal to 180 degrees, we need to know for   To  determine  whether  two  faces  sharing  an  edge  with  endpoints   1E  and   Figure 12.5. When two faces meet at an exterior angle of less than 180 degrees, the cyl- inder surrounding the shared edge lies completely inside the expanded collision surface.  In this case, the cylinder does not need to be considered for collision detection.       12.3  Sliding   371         1E  and   2E  occur in counterclockwise order.  which of the two faces the vertices   For each edge structure created by the BuildEdges   function shown in List- ing  10.1,  the  triangle  for  which  the  vertices  occur  counterclockwise  is  always  2E  oc- listed first.  Let  2N  be the normal to the face for which the  cur in counterclockwise order, and let  2E  occur in clockwise order. The two faces meet at an exterior  vertices  angle less than or equal to 180 degrees if   1N  be the normal to the face for which the vertices   1E  and   1E  and   [  N  1  ×     E  2  −  E  1     ]  ⋅  N  2  ≥  0  .    12.26    12.3  Sliding   When a moving object collides with a stationary part of the environment and is  not destroyed as a consequence of the collision, most games allow the object to  slide along the surface of the geometry that it hit. This is especially useful when  the moving object is a character under user control, since sliding avoids the frus- tration of getting stuck whenever a player runs into something.    The distance by which an object slides over a surface during the single frame  that  it  collides  with  part  of  the  environment  is  determined  by  the  angle  with  which the object struck the surface. As shown in Figure 12.6, a typical sliding  implementation may choose to move an object to the point on the surface that is  closest to the point at which it would have reached had the surface not been there   1P  N  Q  3P  2P     Figure 12.6. The part of the path from  2P  that lies beyond the point of collision Q is  projected onto the direction perpendicular to the normal vector N to determine how far an  object should slide.   1P  to    372   12. Collision Detection         to obstruct its motion. The difference between this point and the point at which  the object hits the surface is perpendicular to the normal direction at the point of  collision.  Suppose an object attempts to move from the point  1P  to the point  2P  during a    single frame, but collides with the expansion of some surface at the point Q. If  the unit normal direction to the surface at the point Q is N, then we can project  the untraveled portion of the object’s path onto the direction perpendicular to the  surface to find a new destination  3P  by calculating  ]  −  =  −  P Q N N.  2   12.27    P 3  P  [           ⋅  2  3P , so the pro- Of course, we need to consider possible collisions between Q and  cess  repeats  until  either  no  collision  occurs  or  the  sliding  distance  falls  below  some minimum threshold.    When  an  object  collides  with  a  face  of  a  model  at  a  point  Q,  one  may  be  tempted to interpolate the vertex normal vectors using the barycentric coordinates  of the point Q to obtain the normal direction there. This should be avoided not  only because it creates a discontinuity in the normal direction at the cylindrical  edges and spherical vertices, but because it prevents the calculation of an accu- rate sliding direction. Using a normal vector that is not truly perpendicular to the  expanded  surface  causes  the  sliding  direction  to  either  take  the  moving  object  away from the surface or causes it to point inward, in which case another colli- sion occurs immediately when attempting to slide.   12.4  Collision of Two Spheres   Suppose that two spheres are in motion and have a constant linear velocity during  1t = . We assume that the spheres  a time interval beginning at  are  not  already  intersecting  and  that  neither  sphere  contains  the  other.  Let  the  2P  represent the initial and final positions of the first sphere’s cen- points  1P  and  2Q  be the initial and final positions of the second sphere’s cen- ter, and let  ter, as shown in Figure 12.7. We define the velocity vectors   t =  and ending at   PV  and  QV  as   1Q  and   0  P  P 2  V V Q Q .  1  − P 1 −  = =  Q  2   12.28      tQ  of the second   The position  sphere’s center are then given by      tP   of the first sphere’s center and the position    12.4  Collision of Two Spheres   373                  2P  2Q  1P  1Q  QV  PV     Figure 12.7. Detecting a collision between two moving spheres.       t     t  P Q  = =  P 1 Q  1  + V t P + V .  t Q  Let  Pr  and  Qr  be the radii of the two spheres. We wish to determine whether  r+  at some  . If so, then the spheres are tangent to each other at time t, and a col-    tQ      the distance d between the centers  time  lision has taken place. We examine the squared distance between  given by      tQ  is ever equal to  P r    tP     tP   and    and    0,1  t ∈  [  Q  Substituting the values given by Equation  12.29  for      tP   and      tQ , we have   2  d  =      t  P  −      t  Q  2  .   2  d  =  +  P V Q V .  2 1  t  t  Q  P  1  −  −  − A P Q − B V V   Q  = =  P  1  1  For convenience, we define   so that Equation  12.31  can be written as    12.29     12.30     12.31     12.32     374   12. Collision Detection                  Using the quadratic formula to solve for t gives us the formulas   2  d  2  = =  + +  A B t A t 2 2     ⋅  A B     +  t B 2  2  .   −     ⋅  A B     −  −     ⋅  A B     +  =  t  1  =  t  2  2  −    B A  2  2  −  2  d  2  −    B A  2  2  −  2  d        .           2   2  ⋅  A B B A B B  ⋅   12.33     12.34    2  P  r  =  0  Since   +  gives us the times  1t  and  2t  when the two spheres are tangent, if  Setting  r d Q ever. It is possible that the value inside the radical is negative, in which case the  B = ,  meaning  that  either  both  spheres  never  collide.  It  is  also  possible  that  spheres are stationary or that both are traveling in the same direction at the same  speed and thus cannot collide.  2B  is not negative, the value of  1t  is always less than or equal to the    value  of  2t .  The  time  1t   represents  the  instant  at  which  the  spheres  are  tangent  while they are still approaching each other. The time  2t , however, represents the  instant at which the spheres are tangent while they are moving away from each  other. Since we assume that the spheres are not intersecting to begin with, we are  only interested in the time  1t  when they first collide. Thus, we only need to calcu- late the following time t to determine when a collision occurs.      − ⋅ = A B     −  t     ⋅  A B     2  2     − B A B 2  2  −     r P  +  r Q     2         12.35     0,1 , then no collision occurs during our time inter-  If t does not fall in the range [ val of interest.  It  is  possible  to  determine  that  a  collision  cannot  occur  without  evaluating    2d  is minimized can  Equation  12.35 . The time t at which the squared distance  be found by setting the derivative of the right side of Equation  12.33  to zero as  follows.   B t + 22     2  ⋅  A B     =    0   12.36    Solving for t produces the following time at which the distance between the cen- ters of the spheres is the least.    12.4  Collision of Two Spheres   375                  Plugging this time into Equation  12.33  yields the smallest distance ever separat- ing the centers of the two spheres:   >     +     2  2  r P  r Q  , then we know that the two spheres can never collide.     tP  d If    Once we have determined that a collision has occurred at time t, we can cal-    tQ  of the two spheres at that time by plugging t into  culate the centers  Equations  12.29 . As shown in Figure 12.8, the point of contact C lies on the     tP , and  is  thus  line  segment  connecting  given by      tQ   at  a  distance  Pr   from      tP    and    and   where N is the unit length normal vector pointing from      tP   to      tQ :   = − A B   t  ⋅ B  2  2  d  =  2  A    2    ⋅ − A B B  2  .   =  C P      t  +  r P  N,   =  N      t     t  Q Q  − −      t     t  P P  .    12.37     12.38     12.39     12.40       tP  Pr  N  C     tQ     Figure 12.8. The point of contact C where two spheres meet lies on the line connecting  their centers at the time of the collision.    376   12. Collision Detection   Chapter 12 Summary               Collision of a Sphere and a Plane  A sphere of radius r whose center moves from the point  point  2P  at time   at time   , D  =L N 1t =  collides with a plane  ′⋅ L P 1 ′⋅ L V  = −  ,   t  L where   ′ =  N  − ,D r  .   1P  at time   t =  to the   0  Collision of a Box and a Plane  A box described by the vectors R, S, and T whose center moves from the point  1Q  at time   at  time   1t =  collides with a plane   t =  to the point   2Q  at time   =L N  , D  0  = −  t  ′⋅ L Q 1 ′⋅ L V  ,   L where   ′ =  N  − , D r eff   and  effr  is the effective radius of the box, given by   r =  eff  1 2       R N S N T N .   + ⋅  +  ⋅  ⋅  When a box collides with the plane at a point, the position C of the vertex mak- ing contact with the plane is given by     ] T N T ,     S N S  R N R  C Q  sgn  sgn  +  +  −  =                 ⋅  ⋅  ⋅  where   Q      t  =  +  Q  1    Q Q .   2  1      t    t  [ 2 sgn 1 −  General Sphere Collisions  Two faces sharing an edge with endpoints  less than or equal to 180 degrees if     ×  −     [  ]  E  2  E  1  N  1     ⋅  N  2  ≥  0  ,   1E  and   2E  meet at an exterior angle   1N  is the normal to the face for which the vertices   1E  and   2N  is the normal to the face for which the vertices   2E  occur in coun- 1E  and   where  terclockwise order, and  2E  occur in clockwise order.    Chapter 12 Summary   377      t  P  A  ray  edge with endpoints   = +  S V  intersects  an  infinite  cylinder  of  radius  r  representing  the   t  1E  and   2E  at the parameter value   where               − − b  2  −  ac  ,   =  t  b a        2  ⋅ V A A 2   S A V A 0  ⋅     ⋅     A 2   S A 0 2  ⋅ A  2     −  a  b  =  V  2  −  =  ⋅ −  S V 0  −  =  2  r  c  S  2 0 = A E 2 = − S  − E 1 S E 1.      The intersection occurs between the edge’s endpoints if     E A  ⋅ <      t  P  A  −  <  0  .   ]  [  2  0  1  Sliding  If an object traveling from the point  Q, then the point  3P  to which it should slide is given by    P Q N N,  2  1P  to   P 3  P  −  −  =  ]  [        ⋅  2  where N is the unit normal vector at the point Q.   2P  collides with a surface at the point   Collision of Two Spheres  A sphere of radius  Pr  moving from the point  1P  at time  1t =  collides with another sphere of radius  Qr  moving from the point  point   t =  to the point  2P  at time  1Q  to the   2Q  at time   0     − ⋅ = A B     −  t     ⋅  A B     2  2     − B A B 2  2  −     r P  +  r Q     2     ,   where   − A P Q 1 − B P 1  = =  1 P     2     −       Q Q .   −  1  2   378   12. Collision Detection   Exercises for Chapter 12   1.  Determine the time t when a sphere having a radius of two meters collides  t =   and  it     if  its  center  lies  at  the  origin  at  time   with  the  plane  moves with a constant velocity of  2,0,1 m s.   10 m  x =  0  2.  Suppose a collision occurs at the point Q on the surface of a cylinder of ra- dius r whose ends are centered at the origin and the point A. Find an expres- sion for the unit normal vector N at the point Q.   3.  Write a program that determines whether two spheres collide within a given  time  interval.  The  program  should  take  as  parameters  the  initial  positions  and velocities of the two spheres. If a collision occurs, the program should  calculate the point of contact at the time of collision.          Chapter 13   Linear Physics   Simulating the accurate motion and interaction of dynamic objects adds a perva- sive  feeling  of  realism  to  a  game  and  can  usually  be  achieved  without  overly  complex mathematics. This chapter and Chapter 14 discuss several general topics  in classical mechanics that apply to game programming. We begin with an exam- ination of linear motion, which refers to any motion that is not taking place in a  rotating environment.   13.1  Position Functions   A position function provides the 3D position of an object as a function of time.  Time is usually measured relative to some starting point when the position of an  object is known. For instance, suppose that an object is traveling in a straight line  t =  is known to  with a constant velocity  be  0x , then its position     tx    0v . If the position of the object at time    at any time afterward is given by    13.1        t  +  =  x  x  0  v .  t 0  0    A velocity function describes  the  3D  velocity  of  an  object  as  a  function  of  time. The velocity function     tv  of an object is given by the derivative of the po- sition function with respect to time. The time derivative is commonly denoted by  placing a dot above the function being differentiated:   Since  the  velocity  of  the  object  whose  position  is  given  by  Equation   13.1   is  constant, its velocity function     tv   is simply given by       t  v  =      t   x  =      t .   x  d dt      t =  v  v .  0   13.2     13.3    379               380   13. Linear Physics               An object undergoing a constant acceleration  0a  has the velocity function     13.4   The acceleration function     ta  of an object, which describes the object’s 3D ac- celeration  as  a  function  of  time,  is  given  by  the  derivative  of  the  velocity  function:   a .  t 0      t  +  =  v  v  0      t  a  =      t   v  =      t   x  =      t .   x  2  2  d dt    We  can  integrate  any  velocity  function  to  determine  the  distance d  that  an  object has traveled between times  1t  and  2t  as follows.    13.5     13.6    Integrating Equation  13.4  from time zero to time t, we have   d  t  2  =  v  t  1      t dt     +    t dt  a  0  d  t     v 0 v t  0  +  =  =    Adding the distance d to an initial position  0x , the position function     tx formly accelerating object is given by  x        t  +  +  =  v  a  x  .   1 2  a  t  t  t     .  2  2  0  0  0  0  1 2  0   13.7     of a uni-   13.8      It is often the case that we are aware of the forces acting on an object, and we  want to find a function that predicts the future position of the object. The sum of  F  acting on an object is equal to the object’s mass m times  the forces  , N , its acceleration     ta :   F F 1  ,  2  N  F  i  = 1  i          t m t m t .        x  =  =  a   13.9        tF i  Each force   may be a constant, a function of the object’s position, or a func- tion of the object’s velocity. Equation  13.9  is a second-order differential equa-   is  the  object’s  position  function.  The  next  section  re- tion  whose  solution  views the general solutions to second-order differential equations, and solutions  to specific force equations are discussed at various places throughout this chapter  and Chapter 14.      tx   13.2  Second-Order Differential Equations   381   13.2  Second-Order Differential Equations   A second-order linear ordinary differential equation in the function     x t  is one of  the following form.               2  2  d dt  d dt      x t  +  a      x t  +      bx t  =      t     f   13.10    Using prime symbols to denote derivatives, we can write this in a slightly more  compact form as       ′′ x t  +      ax t  ′  +      bx t  =      t  .   f   13.11    In this chapter, a and b are always constants; but in general, they may be func- tions of t.   13.2.1  Homogeneous Equations  The function  ential equation is called homogeneous. Before attempting to find a solution  to the equation       t  is identically zero in many situations, in which case the differ-    x t    f      ′′ x t  +      ax t  ′  +  bx t      0 = ,    13.12    2x  we  make  a  couple  of  important  observations.  First,  suppose  that  the  functions          1x t  and  1Ax t  and  t  are solutions to Equation  13.12 . Then the functions      t  are also solutions, where A and B are arbitrary constants. Furthermore, the  2Bx     Ax t  is also a solution to Equation  13.12  since we can write  function  1     + Ax t      + Bx t 2 ] [             ′ ′′ ′ + + + t t a Ax t Bx 2 2 1 [             ′ ′′ = + + bx t A x t ax t 1 1 = ⋅ + ⋅ = B A    13.13   0 0. 0    x t   to  Equation   13.12   becomes  evident  upon  making   [     b Ax t 1 [ ] ′′ + B x 2  ]     t     ′ t 2  Bx 2 + ax  +     t      t       Bx  bx  +  ′′ 1  ]     2  1    A  general  solution  the substitution     The first and second derivatives of     x t  are given by   .   rt      x t  e=   13.14     382   13. Linear Physics                            13.15     13.16     13.17     13.18     13.19     13.20    and substitution into Equation  13.12  yields  +  +  rt  rt  r e 2  are  rt  be  = .  0  Multiplying both sides by   rte −  eliminates the exponentials, and we have   Equation  13.17  is called the auxiliary equation and has the solutions       ′ x t     ′′ x t  = =  rt  re r e 2  rt  ,   2  r  +  ar b  + = .  0  r 1  r 2  = − +  2  a  −  b 4  = − −  2  a  −  b 4  .   a 2 a 2  1 2 1 2      x t  =  r t 1  Ae  +  Be  r t 2  .   r Unless  1  r= , the general solution to Equation  13.12  is thus given by   2  Example 13.1. Solve the differential equation        x t        ′′ x t      ′ x t  +  −  5  6        = .  0  Solution. The auxiliary equation is   which has the solutions  1 is therefore given by   r− r 2 5  13.21   r = . The general solution to Equation  13.20   r =  and  2  + = ,  6 0  2  3      x t  =  2  t  Ae  +  3  t  Be  ,    13.22    where A and B are arbitrary constants.    r If  1  r= , then it must be true that   a  2  2  b= 4  , so Equation  13.12  can be written     as    13.2  Second-Order Differential Equations   383      +      ′′ x t  a 2 4 It is a simple task to verify that the function  te −=        ax t      x t  +  ′      2a  t         x t  = .  0  is  a  solution  to  Equation   13.23 ,  so  the  general  solution  to  Equation   13.12   r when  1  r=  is given by   2      x t  =  rt  Ae  +  Bte  rt  ,   = = .  r r 1 2  2  a  If   b− 4  r where we have set  < , then the roots of the auxiliary equation are complex. The solu- 0   tion given by Equation  13.19  is still correct, but it requires the use of complex  arithmetic. We can express the solution entirely in terms of real-valued functions  by using the formula   + = α βi  e  α  e     cos  + β i  sin  β        13.26     see Appendix A, Section A.4 . Assuming that a and b are real numbers, the roots  1r  and  2r  of the auxiliary equation are complex conjugates, so we may write   r 1 r 2  = + βi α = − ,  α βi  α  β  a = − 2 1 4 2  =  −  b a  2  .   The solution given by Equation  13.19  can now be written as       x t    − α βi t  = = =  Ae Ae e αt        +   + Be α βi t   + βt i cos   + A B cos  αt [    sin βt    + Be βt αt     + − A B i    βt cos ] βt . sin  −  i  sin  βt       This solution can be expressed using two real constants   1C  and   2C  by setting    13.23     13.24     13.25     13.27     13.28     13.29                      where    384   13. Linear Physics                         13.30     13.31     13.32     13.33     13.34    = =  A B  1 2 1 2       1  + −  C C i 2 C C i 2  1      .   Plugging these values into Equation  13.29  yields       x t  =    e C αt  1  cos  +  βt C  2  sin  βt     .   Example 13.2. Solve the differential equation           ′′ x t      x t  +  4     = .  0        Solution. The auxiliary equation is   r which has the solutions  1 en by   i=  and  2 r 2  = − . The solution to Equation  13.32  giv-  i 2  2  r + = ,  4 0      x t  =  2  it  Ae  +  Be −  2  it     is  valid,  but  we  can  also  express  the  solution  entirely  in  terms  of  real-valued  functions by using Equation  13.31  with   0α =  and   β =  as   2      x t  =  C  1  cos2  + t C  2  t sin 2  ,    13.35    where   1C  and   2C  are arbitrary constants.    Equation  13.31  can be transformed into an alternate solution involving only   and     a single trigonometric function by introducing the constant  writing     D C  C  =  +     2 1  1 2  2 2      x t De  =  αt C  1  D   cos  βt  +  sin  βt  C 2 D   .      13.36    1C  and   Suppose that  the angle opposite the side of length  the hypotenuse, so   2C  are the lengths of the legs of a right triangle and that δ is  1C   see Figure 13.1 . Then D is the length of    13.2  Second-Order Differential Equations   385                        D  δ  2C sin δ C D   and   =  1C     C 1 D C 2 D  =  sin  δ  =  cos  δ  .   = Figure  13.1.  In  this  triangle,  Equation  13.36  in the form given by Equation  13.39 .   cosδ C D  2  1  .  This  enables  us  to  write    13.37     13.38     13.39    Plugging these into Equation  13.36  yields       x t  =  αt  De  cos  βt  sin  δ     +  sin  βt  cos  δ     .   Using an angle sum identity  see Appendix B, Section B.4 , this is equivalent to       x t  =  αt  De  sin     βt  +    .   δ  13.2.2  Nonhomogeneous Equations  Differential equations of the form  +  ′  +      ax t      ′′ x t     t  is not identically zero are called nonhomogeneous.    13.40        bx t      t  =  f     for which the function  The solution to a nonhomogeneous differential equation has the form   f      x t  =      g t  +   13.41      g t  is the general solution to the corresponding homogene-  p t      ,       ′′ x t  +      ax t  ′  +   13.42      p t  is called a particular solution to the nonhomogeneous equa-  bx t      0 = .   where the function  ous equation   The function  tion and satisfies    386   13. Linear Physics                      ′′ p t  +      ap t  ′  +      bp t  =      t  .   f   13.43     is in fact a solution to Equation  13.40 , we simply plug it   To see that  in:       g t  +      p t      ′′ g t  +  [             ′ ′ ′′ + + a g t p t p t         ′ ′′ = + + ag t g t         = + = t f f t . 0  [ ]     + + b g t         ′′ + p t bg t  ]     p t     + ap t  ′  +      bp t      13.44      There are several methods for finding the particular solution to a nonhomo- geneous differential equation. The method that we present in this section is called  the method of undetermined coefficients and is sufficient for the nonhomogene- ous equations encountered later in this chapter. The general idea upon which the  method of undetermined coefficients is based is to guess at the form of the par-    p t  using the knowledge that we possess about the form of the  ticular solution     p t   to  be  a sum  of  terms  that  function      t .  have the same form as  Each term is multiplied by an unknown coefficient for which we attempt to find a     p t  into the nonhomogeneous equation. If coefficients can  solution by plugging     p t  satisfies Equation  13.40 , then a particular solu- be determined for which  tion has been found. The following examples illustrate this technique in detail.       t  or whose derivatives have the same form as       t .  It is  usually  effective  to  choose   f  f  f  Example 13.3. Solve the differential equation        x t        ′′ x t      ′ x t  +  −  5  6     =  t 12  − .  4      13.45    Solution. We have already found the general solution  equation in Example 13.1:      g t  to the homogeneous       g t  =  2  t  Ae  +  Be  3  t  .    13.46    The nonhomogeneous portion of Equation  13.45  is a linear polynomial, so we  presume that the particular solution has the form   where  the  coefficients  D,  E,  and  F  need  to  be  determined.  Plugging  Equation  13.45  produces       p t  =  2  Dt  +  + ,  Et F   13.47      p t   into    13.2  Second-Order Differential Equations   387                           t 12  − = =  4 2 6  D Dt  −  2    5 2   + −  +    Dt E + D 10 6  +    6   E t  2  Dt + 2  +  +  Et F − + D E 5    6  F  .    13.48    Equating the coefficients of like terms from each side, we find that       2 t= p t Thus, the function  complete solution is given by   2E = , and   0D = ,   13.49   +  is a particular solution to Equation  13.45 . The  1  1F = .       x t  = =      g t Ae t 2  + +      p t Be t 3  +  t 2  + ,  1  where A and B are arbitrary constants.    Example 13.4. Solve the differential equation           ′′ x t      x t  =  +  4     12sin  t  .        Solution. We have already found the general solution  equation in Example 13.2:      g t  to the homogeneous   Equivalently, we could write   =  A  cos2      + t B g t    g t  in the form   t sin 2  .       g t  =    t sin 2    + .  δ  C      p t  =  D t E  sin  +  cos  t  ,   Since  the  nonhomogeneous  portion  of  Equation   13.51   is  a  sine  function,  we  presume that the particular solution has the form   where the coefficients D and E need to be determined. Plugging  tion  13.51  produces   12sin  t  = − =  + D t E cos sin D t E t 3 cos . 3 sin  − +  t     4  D t E  sin  +  cos  t        13.55     13.54      p t  into Equa-   13.50     13.51     13.52     13.53     388   13. Linear Physics   Equating  the  coefficients  of  the  sine  and  cosine  terms  from  each  side,  we  find  that   4D =  and   0E = .   t   is a particular solution to Equation  13.51 . The   =      4sin p t Thus, the function  complete solution is given by      x t     =  or, equivalently,   A  cos2  + t B  t sin 2  +  4sin  t         x t  =    t sin 2  C  +  δ     +  4sin  t  ,   where A, B, C, and δ are arbitrary constants.    13.2.3  Initial Conditions   In every solution to a second-order differential equation presented so far, there  have been two arbitrary constants. These constants allow for the specification of  certain initial conditions that dictate the values of     x t  and  t = . Sup- 0 pose that the initial value of     x t  is required to be  0x  and the initial value of      x t′      x t   is required to be  0v . Then the arbitrary constants appearing in the function  can be determined by examining the following system of equations.    when       x t′                  0     0  x ′ x  = x 0 =   v 0  This is demonstrated in the following examples.      Example 13.5. Solve the differential equation        subject to the initial conditions         ′′ x t      ′ x t  +  −  6  5      x t  =   0        0     0  x ′ x  = 3 = .  0               13.56     13.57     13.58     13.59     13.60     13.61     13.2  Second-Order Differential Equations   389               Solution. The general solution to the differential equation has already been found  in Example 13.1:         x t The derivative of     x t  is given by      ′   x t  =  2  t  Ae  +  3  t  Be  .   =  2  Ae  2  t  +  3  Be  3  t  .   Imposing the initial conditions given by Equation  13.61 , we have       0     0  x ′ x  = + = A B 3 = .  + = B A 0 3 2  9A =  and   B = − .  6      x t  =  2  t  9  e  −  6  e  3  t  .    Solving this linear system yields   Thus, the solution to the differential equation that satisfies the initial conditions is  given by      Example 13.6. Solve the differential equation        subject to the initial conditions         ′′ x t      x t  =  +  4        0     0  x ′ x  = 0 = .  6              12sin  t        13.67    Solution. The general solution to the differential equation has already been found  in Example 13.4:   + t B  t sin 2  +  4sin  t  .    13.69        x t  =  A   The derivative of     x t  is given by  A t 2 sin 2        ′ x t  cos2  = −  +  B t 2 cos2  +  4cos  t  .    13.70     13.62     13.63     13.64     13.65     13.66     13.68     390   13. Linear Physics                     Imposing the initial conditions given by Equation  13.68 , we have      = = A 0 + = ,  = B 4 6 2  13.71   1B = . Thus, the solution to the differen- from which we immediately deduce that  tial equation that satisfies the initial conditions is given by the simplified function   x ′ x      0     0      x t  =  t sin 2  +  4sin  t  .     13.72    13.3  Projectile Motion   In this section, we examine the motion of objects that are influenced only by the  force of gravity. The convention used in this chapter is that the z axis points up- ward in world space, so the downward acceleration of gravity g is the vector   =  g  − 0,0, g  ,    13.73    where the scalar g is approximately  ject in a gravitational field experiences a downward force of mg.    0v  at time    of a projectile having initial position   The position     tx  t =  is given by   0  9.8 m s  on the surface of the earth. An ob-  2  0x  and initial velocity       t  x  =  x  0  +  v  t  0  +  g .  t 2  1 2   13.74    Since  the  x  and  y  components  of  g  are  0,  only  the  z  component  of  Equation      z t  to represent the components of   13.74  is quadratic. Using     tx     y t , and   , we have      x t ,       x t     y t     z t  = = =  x y z  0  0  0  + + +  v t x v t y v t z  −  gt  2  ,   1 2   13.75    0x ,   0y , and  0z  are the components of the initial position and   where  are the components of the initial velocity.    When  a  projectile  attains  its  maximum  height,  its  vertical  velocity  is  zero.  We can determine the time t at which this occurs by solving the equation   yv , and   xv ,   zv         z t  =  v  z  −  gt  =  0  .    13.76                 13.3  Projectile Motion   391   Thus, a projectile reaches its maximum height at time   Plugging this time into the function      maximum height h attained by a projectile.   z t  gives us the following expression for the    13.77     13.78    Example 13.7. A projectile is launched from a platform 10 meters above the  ground with an initial speed of 50 m s in a direction forming an angle of 70 de- grees with the horizontal plane  see Figure 13.2 . What is the maximum height  above the ground attained by the projectile?   =  t  zv g  .   =  h  z  0  +  zv 2 g 2     0v  70   10 m  Figure 13.2. The projectile used in Example 13.7.      Solution. The projectile’s initial height  0z  and initial upward velocity  by   zv  are given   z v  0  z  = =  10 m 50sin 70    ≈  47.0 m s  .    13.79    Plugging these values into Equation  13.78  and using the value  we have   123 m  h ≈  .    9.8 m s  for g,   2   392   13. Linear Physics              The horizontal distance that a projectile travels before returning to the height  from  which  it  was  launched  is  called  the  projectile’s  range.  If  a  projectile  is  z = , then the time t at which it lands is  launched from a horizontal plane at  0 given by the solution to the equation  − zv t  13.80   t = , corresponding to the time when the projec-  = .  0  gt  One solution to this equation is  tile was launched. The other solution is   0  0  1 2     2  and as we would expect, this is twice as long as it takes for the projectile to reach  its maximum height. If we assume that the projectile follows a path lying in the  x-z plane, then plugging this time into the function     x t  and subtracting the initial  x coordinate  0x  gives us the following expression for the range r of a projectile.    13.81     13.82    Example 13.8. A projectile is launched with an initial speed of 30 m s in a di- rection forming an angle of 40 degrees with the ground  see Figure 13.3 . As- suming the ground is flat down range, how far does the projectile travel before  landing?   =  t  2 zv g  ,   =  r  v v 2 x g  z     0v  40     Figure 13.3. The projectile used in Example 13.8.   Solution. We assume that the projectile is launched from the origin and that the  path of the projectile lies in the x-z plane. The  xv  and  zv  components of the initial  velocity are given by                      13.3  Projectile Motion   v v  x  z  = =  30cos40 30sin 40    ≈   ≈  23.0 m s   19.3 m s.  393    13.83    Plugging these values into Equation  13.82  and using the value  the range of the projectile is 90.4 meters.    9.8 m s  for g,   2    Given an initial speed s at which a projectile is launched, we can determine at  what angle the initial velocity vector should point in order for the projectile to  reach a particular maximum height or to have a particular range. For motion in  the x-z plane, the components of the initial velocity are given by   where  α  is  the  angle  formed  between  the  initial  trajectory  and  the  horizontal  zv  into Equa- plane. Given a desired maximum height h, we can plug the value of  tion  13.78  and solve for α to obtain   Given a desired range r, we can plug the values of  xv  and  as follows.   zv  into Equation  13.82    = =  v v  x  z  s s  α cos   α sin ,  =  α  sin  −  1    1 s    − g h z  2  0      .     =  r  2  s 2 g  sin cos  α  α  =  α sin 2     s 2 g  =  α  − 1  1 sin 2  rg s 2  .    13.84     13.85     13.86     13.87    Solving for α gives us      −     =  α  sin  sin  π α  , there are two angles that produce the range r in Equation  Since   13.86 :  the  angle  α  given  by  Equation   13.87   and  its  complementary  angle  α− . If the values inside the inverse sine functions in Equations  13.85  and  2π  13.87  are greater than 1, then the initial speed s is not great enough to achieve  the desired maximum height or range.             394   13. Linear Physics   Example 13.9. A projectile is launched from the ground with an initial speed  of 65 m s  see Figure 13.4 . Assuming that the ground is flat, at what angle α  should the projectile be launched so that it lands 400 meters down range?   0v  α  400 m  13.4  Resisted Motion     Figure 13.4. The projectile used in Example 13.9.   34  65  .  The  complementary  angle   r = Solution. Plugging the values   into Equation  13.87 , we have     would  also  result  in  the  projectile  α ≈ 56 traveling a distance of 400 m. If we use the angle α, then the initial velocity is  given by    and  β =  400  s =  v v  x  z  = =  65cos34 65sin34    ≈   ≈  53.9 m s 36.3 m s.       13.88    In the previous section, we neglected any kind of resistance to the motion of an  object. In reality, an object’s velocity is slowed by the medium through which it  is moving, whether it be air, water, or some other substance. A precise physical  formulation  of  resisted  motion  is  complicated,  but  a  decent  approximation  is  achieved by assuming that resistance produces a force that acts in the direction  opposite that in which an object is moving and is proportional to the magnitude  of the object’s velocity.    encing resistance from the surrounding medium is given by   The force equation for an object of mass m influenced by gravity and experi-  m  g  −   x mk          t m t ,    x  =   13.89    where mk  is a constant describing the strength of the resistance. This can be re- written as the following second-order nonhomogeneous differential equation.    13.4  Resisted Motion   395                        The method of undetermined coefficients provides the following particular solu- tion to Equation  13.90 .   Adding the general solution to the homogeneous differential equation, we have   where the vectors A and B are arbitrary constants that can be determined by es- 0x  and initial velocity  tablishing initial conditions. Specifying the initial position  0v , we have     Setting these equal to the values given by the functions     tx gives us the system   .   0   and     tx   at time    13.93   t =   0      t   x  +   x k      t  =  g        t  x  = g k  t         t  x  =  +  A B  e  −  kt  + g k  t  ,       0     0  x  x  = =  0  x v  0  + = A B x gB + = k k  v ,  0  −  =  A x  −  =  B  −  0 g k 2  g k 2 v 0 k  +  v 0 k     from which we can derive the following expressions for A and B.   The position function  given by      tx   for an object moving through a resistive medium is       t  x  =  +  x  0  +  t  g k  k  v 0 k  − 2  g    1  −  kt  −  e    .   The velocity function     tv   is given by the derivative of     tx  :    13.90     13.91     13.92     13.94     13.95     13.96     396   13. Linear Physics                    Over  time,  the  velocity  of  an  object  whose  motion  is  being  resisted  ap- proaches a constant called the terminal velocity. The terminal velocity  Tv  is given  by the limit of the velocity function     tv   as t tends to infinity:       t  v  =      t   x  = +  −  v  0  g k      g k      e  −  kt  .   =  v  T  lim →∞ t      t  v  = g k  .    13.97     13.98      Although it is not apparent from Equation  13.96 , the position function for  an object moving through a resistive medium does converge to the familiar Equa- tion  13.74  as the constant k approaches zero. This can be seen by evaluating the  limit       t  x  =  lim → k 0      +  x  0  +  t  g k  − 2  g    1  v k 0 k  −  kt  −  e         .    13.99    Replacing the exponential function with its power series  see Appendix D, Equa- tion  D.11  , we have       t  x  =  lim → k 0  lim → k 0         lim  → k  0 + x  0  =  =  =  +  x  0  +  x  0  g k g k  t  t  +  g  − 2  v k 0 k  +     v k  0  −  g        −  kt  t k      x  0  +  v  t  0  −  v k  t  0  2  +  g t  1 2  + −         k t 2 2 2! t 2 2!    +  2  −  +  k t 3 3 3! kt 3 3!  −  +  v k  0  −  g  + −  −  k t 4 4 4! k t 2 4 4! kt 3   3!      −        k t 2 4 4!  + −         1 2  .  v  t  0  +  2  g t  1 2      13.100    13.5  Friction   Friction is the well-known force that arises when two surfaces are in contact. We  discuss  two  types  of  friction  in  this  section:  kinetic  friction  and  static  friction.  Kinetic friction occurs between two surfaces that are in motion relative to each  other and has the effect of resisting that motion. Static friction refers to the force  that holds a stationary object in place when it is in contact with another surface.    13.5  Friction     397     The  forces  resisting  the  motion  of  one  object  sliding  across  the  surface  of  another  object  are  very  complex,  but  it  turns  out  that  the  net  kinetic  frictional  force  KF  can usually be approximated quite accurately using the simple formula      F K  = −  μ N K  ,    13.101    where N is the normal component of the force by which the object is bound to the  surface  usually gravity , and  Kμ  is called the coefficient of kinetic friction. The  minus sign appears in Equation  13.101  because the kinetic friction force always  acts in the direction opposite that in which an object is moving across a surface.  The coefficient of kinetic friction  Kμ  is a positive constant that depends on the  types of the surfaces in contact with each other. Typical values of  Kμ  for various  surfaces are listed in Table 13.1 at the end of this section.   Example 13.10. Suppose that a 10-kg block is sliding down a plane that is in- clined at an angle of 30 degrees. If the coefficient of kinetic friction is  0.5 ,  determine the block’s acceleration.   Kμ =  Kμ N−  sinmg  θ  mg  cos  θ  mg  θ    Figure 13.5. The block used in Example 13.10.   Solution. Let m be the mass of the block, and let θ be the angle by which the  plane is inclined. As shown in Figure 13.5, the block is acted on by a gravitation- al force and a resisting force due to friction. The gravitational force can be divid- ed into components that are parallel to the plane and perpendicular to the plane.  The parallel component  GF  is given by  =  GF  mg  sin  θ      13.102        398   13. Linear Physics                  and pulls the block across the plane. The perpendicular component produces the  force holding the block to the plane:  =  N mg  cos  θ  .    13.103       The force  KF  due to kinetic friction is given by   F  K  = −  μ N K  = −  μ mg K  cos  θ      13.104    and acts in the direction opposite that of  GF . The acceleration a of the block is  equal to the net force acting on it divided by its mass:   =  a  F G  F  K  + m  =  g  sin  θ  −  μ g K  cos  θ  .    13.105    Plugging in the angle of inclination and coefficient of kinetic friction, we obtain  the result      a =  9.8 m s  2     1 ⋅ − 2     ⋅  0.5 9.8 m s  2     ⋅  3 2  ≈  0.656 m s  2  .    13.106    Notice that the mass of the block is inconsequential.    The static friction force prevents an object on a surface from moving by op- SF  that     posing any tangential force that may be acting on it. The maximum force  can be exerted due to static friction is given by   F S  = −  μ N S  ,    13.107    Sμ   is  called  the  coefficient  of  static  friction.  where  N  is  the  normal  force  and  Again, we use a minus sign to indicate that the force acts in the direction opposite  Sμ  for various sur- that of any force trying to move the object. Typical values of  faces are listed in Table 13.1.  SF  given by    As soon as a force on an object exceeds the maximum value of  Equation  13.107 , the object begins to move, and the static friction force is re- F< placed by the kinetic friction force  KF . It is often the case that  K F , so less  S force is required to move an object once it has been set in motion than was re- quired to initiate the motion.        13.5  Friction     399   Surfaces  Aluminum on aluminum  Aluminum on steel  Copper on steel  Steel on steel  Nickel on nickel  Glass on glass  Copper on glass  Oak on oak  parallel to grain   Oak on oak  perpendicular to grain   Rubber on concrete  dry   Rubber on concrete  wet    Kμ   1.40  0.47  0.36  0.57  0.53  0.40  0.53  0.48  0.32  0.90  0.25   Sμ   1.10  0.61  0.53  0.74  1.10  0.94  0.68  0.62  0.54  1.00  0.30   Table  13.1.  Typical  values  of  the  coefficient  of  kinetic  friction  static friction   Sμ .   Kμ   and  coefficient  of   Example 13.11. A block is resting on a horizontal plane for which the coeffi- cient of static friction is given by  . Determine by what angle the plane  needs  to  be  inclined  before  the  block  begins  sliding  under  the  influence  of  gravity.   Sμ =  0.5  Solution. We need to determine when the component of the gravitation force that  is parallel to the plane exceeds the static friction force. This occurs when   mg  sin  θ  =  μ N μ mg S  S  =  cos  θ  ,   where θ is the angle of inclination. Solving for θ, we have   =  θ  tan  μ− 1  S  ≈  26.6   .           13.108     13.109     400   13. Linear Physics   Chapter 13 Summary   Force Equation  The acceleration     ta the forces acting on it:    of an object multiplied by its mass m is equal to the sum of   Second-Order Differential Equations  The general solution to the homogeneous second-order differential equation   is given by   where                           N  F  i  = 1  i          t m t m t .        x  =  =  a      ′′ x t  +      ax t  ′  +  bx t      0 =        x t  =  r t 1  Ae  +  Be  r t 2  ,   r 1  r 2  = − +  2  a  −  b 4  = − −  2  a  −  b 4  .   a 2 a 2  1 2 1 2      x t  =  rt  Ae  +  Bte  rt  .   α  β  a = − 2 1 4 2  =  −  b a  2  .   r If  1  =  r 2  = , then the general solution is given by  r  If  1r  and  2r  are complex numbers, then the general solution can also be written as       x t  =    e C αt  1  cos  +  βt C  2  sin  βt     ,   where    Chapter 13 Summary   401                        This is equivalent to the solution      x t     =  D  sin     βt  +     ,   δ  where   =  =  D  δ  C  2 1  C  2 2  − 1  sin  .     + C 1 D  Projectile Motion  The position     tx   of a projectile is given by the function       t  x  =  x  0  +  v  t  0  +  g ,  t 2  1 2  0x  is the initial position,    is the  where  acceleration of gravity. The maximum height h attained by the projectile is given  by   0v  is the initial velocity, and   g  − 0,0, g  =  and the range r of the projectile is given by   Resisted Motion  The position function  given by      tx   for an object moving through a resistive medium is       t  x  =  +  x  0  +  t  g k  k  v 0 k  − 2  g    1  −  kt  −  e    ,   where k represents the intensity of the damping force. The terminal velocity  Tv  is  given by   =  h  z  0  +  zv 2 g 2  ,   =  r  v v 2 x g  z  .   v  T  = g k  .    402   13. Linear Physics            Friction  The force of kinetic friction  KF  is given by     = −  F K  μ N K  ,   where  Kμ  is the coefficient of kinetic friction. The kinetic friction force acts in  the direction opposite that of the motion.   The maximum force of static friction   SF  is given by  = −  μ N S  ,   F S  Sμ  is the coefficient of static friction. The static friction force acts in the   where  direction opposite that of any tangential force trying to move an object.   Exercises for Chapter 13   1.  Solve the differential equation          ′′ x t  −      ′ x t  6  +      x t  9  =  t 9  + .  3  2.  Solve the differential equation       x t      ′′ x t  +  16    subject to the initial conditions     0  x  =   0  =  and  3  x′     0  = .  1  3.  A projectile is launched from a platform 20 meters above the ground with an  initial speed of 20 m s in a direction forming an angle of 45 degrees with the  horizontal plane. What is the maximum height above the ground attained by  the projectile? Assume that the acceleration of gravity has magnitude g.   4.  For  what  period  of  time  does  the  projectile  in  Exercise  3  travel  before  it   lands on the ground?   g  =  5.  Suppose a projectile is launched from the origin and travels toward a point P  in the x-z plane as shown in Figure 13.6. Assuming an acceleration of gravi- 0v  would the projectile have to be  ty  launched so that it strikes the point P under the constraint that its path at- tains a maximum vertical difference h with the straight line connecting the  origin and the point P?   , at what initial velocity   − 0,0, g   Exercises for Chapter 13      403   0v  h  P  z  O  x     Figure 13.6. The projectile launched in Exercise 5.   6.  A rock is dropped from rest at 50 meters above the ground and allowed to  fall straight down through a resistive medium. Suppose that  , and use  k Newton’s  method   see  Section  6.1.4   to  approximate  the  time  t  when  the  rock hits the ground.   − 11s  =  7.  An object of mass M is hanging from a rope that runs over a frictionless pul- ley and connects to another object of mass m lying on an inclined plane that  forms an angle θ with the horizontal  see Figure 13.7 . The coefficient of  kinetic friction on the incline is  Kμ . Assuming that M is much larger than m,  determine the downward acceleration a of the hanging object. [Hint. Both  masses are being accelerated, so the sum of the forces acting on the system  should be set equal to      M m a  .]   +  m  M     Figure 13.7. The system used in Exercise 7.    This page intentionally left blank    Chapter 14   Rotational Physics   This chapter continues the survey of physics that begins in Chapter 13. We now  enter the domain of rotational mechanics to examine the behavior of rotating ob- jects and the forces experienced in a rotating environment. Rotational physics has  a  wide  range  of  applications  in  game  programming,  from  interaction  between  players  and  objects  in  the  environment  to  space  combat  simulations.  Virtually  any object that is flying through the air or otherwise not resting on a surface is  probably  rotating,  and  thus  would  benefit  from  an  accurate  simulation  of  its  motion.   14.1  Rotating Environments   This section discusses the physics that apply to an object in a rotating environ- ment.  A  rotating  environment  refers  to  any  frame  of  reference  that  is  rotating  about  some  axis  and  includes  everything  from  a  merry-go-round  to  the  planet  Earth. We begin with the introduction of angular velocity, and then we investi- gate the forces experienced by an object in the rotating reference frame.   14.1.1  Angular Velocity  Suppose that a particle of mass m is rotating about an axis parallel to the unit vec- tor A because it is attached to the axis by a string of length r  see Figure 14.1 .  Let  the  vectors  X  and  Y  be  unit  vectors  lying  in  the  plane  perpendicular  to  A  such  that  the  axes  X,  Y,  and  A  form  a  right-handed  coordinate  system   i.e.,     θ t  represent the counterclockwise angle that the projection of  X Y A . Let  the string onto the X-Y plane makes with the vector X at time t. The angular ve- locity of the particle is defined to be the rate at which this angle is changing, and  is usually denoted by ω:   × =              ω t  =       θ t  =      θ t .   d dt   14.1    405    406   14. Rotational Physics               A  r  m  Y  O  X     Figure 14.1. The angular velocity of a particle is a vector that is parallel to the axis of  rotation A and whose magnitude is equal to the rate of change of the angle formed in the  plane perpendicular to the axis.   The angular velocity is often written as a vector that is parallel to the axis of rota-    tω  is defined  tion A and has the magnitude  as   . The vector angular velocity      ω t          t ω t  =  ω  A  =      A θ t  .    14.2      The speed at which a rotating particle moves through space is calculated by  multiplying the particle’s angular velocity by its distance from the axis of rota- tion. For the particle shown in Figure 14.1, the speed     v t  is given by       v t  =      ω t r  .    14.3    However, this tells us nothing about what direction the particle is moving. Let the  vector function     tr  represent the position of the particle relative to a fixed origin  lying on the axis of rotation. As illustrated in Figure 14.2, the linear velocity vec- tor     tv   of the particle is given by       t  v  =      t  ×      t     r  ω   14.4     14.1  Rotating Environments   407               tω  α  O    tv      t×ω      t  r     tr     Figure 14.2. The linear velocity     tω  and the position     tr .    is equal to the cross product of the angular velocity   since the distance from the particle to the axis of rotation is equal to  and the velocity     tv axis.   α ,   is always perpendicular to the direction pointing toward the   r      sin t  14.1.2  The Centrifugal Force  We continue to consider the example in which a particle is fastened by a string to  the axis about which it is rotating. The linear acceleration     ta  of the particle is  equal to the derivative of its linear velocity with respect to time. Taking the time  derivative of the function     tv  v   given by Equation  14.4 , we have      t   14.5        t .       t      t      t   ω  ω  +  ×   r    Since     tr  a  =  ×  =      r t  is equal to the linear velocity     tv     t      t      t      t   ω  ω  +  =  ×  a  r   of the particle, we can write       t  ] .   r  [  ×  ×      t     t×ω   ω     t  r   14.6    [  r  ×  ×  ω  ω      t      t      t  If the angular velocity is constant, then the   term of the acceleration is  ] zero. The   term, however, is always present and points in the  direction from the particle toward the axis of rotation  see Figure 14.3 . This part  of the acceleration arises from the tension in the string connecting the particle to  the  axis  of  rotation.  The  particle  itself  experiences  an  equal  but  opposite  force  known as the centrifugal force. The centrifugal force, given by   F centrifugal  = −         t  ω  ×  [  ω      t  ×      t  ]     ,   r  m   14.7     408   14. Rotational Physics               tω  α  O      t×ω      t  r     tr  m     ω      t  ×  [ ω      t  ×  r  ]       t  Figure 14.3. The centrifugal force.      is responsible for the well-known effect that causes objects in a rotating system  to move away from the axis of rotation. In the case that     tr    tω  are per- pendicular, the centrifugal force can be expressed as the scalar    and   F centrifugal  =  mω r 2  =  2  mv r  ,    14.8    where r is the radial distance from the particle to the axis of rotation.   14.1.3  The Coriolis Force  We now consider a somewhat more complicated situation in which a particle is  moving on the surface of a rotating object. Suppose that a particle of mass m is     tω .  Further  suppose  that  the  rotating  about  some  axis  with  angular  velocity  particle is also moving relative to the rotating system with a velocity  . Then    of  the  particle  for  a  stationary  observer  outside  the  system  is  the  velocity  given by       tv r     tv      t  =      t  ×      t  +  r  v  ω    where     tr  is the position of the particle relative to some origin lying on the axis   is rotating with the system, a stationary ob- of rotation. Since the velocity  server sees the particle accelerating with respect to a fixed coordinate system ac- cording to the function       tv r   14.9    v  r      t ,   a  f      t  =      t  ×  ω  v  r      t  +  a  r      ,  t   14.10     14.1  Rotating Environments   409           is  the  acceleration  of  the  particle  in  the  rotating  reference       t  =  v      t  a  r  r  a  = =  = ×      t       v t      ω t  where  frame. The total linear acceleration     ta  of the particle is thus given by                  × × +   ω r ω r t t t t                 + + ×  ω ω r r t t t t    is equal to the linear velocity     tv Since     tr     × =   r a t    tF   of the particle, we can write      t  The force       t     t      t      t      t      t      t      t      t      t  + ×  a v  ω 2   ω  ω  ω  +  ×  +  ×  ×  +  +  a  .   a  v  r  [  ]  r  r  r  r  f  .   14.12     14.11    a  =  =        experienced by the particle is therefore  [                     × × ×  ω ω r F t m t m t t t m t             + + ω m t t m t 2 .     tF r  ω a  + ×  v  r  r  r      t  ]     14.13     on the object ap-  In the reference frame of the rotating system, the force  pears to be the following.          t m t  =  =  −  a  F r  r          − ×  ω F t m t     − × v ω m t 2  ω          r t m t     t     r  ×  [      t  ω  ×      t  ]  r      14.14    As expected, the centrifugal force shows up again, but there is also a new term  called the Coriolis force that acts on the particle in a direction perpendicular to its  velocity  in  the  rotating  reference  frame   see  Figure  14.4 .  The  Coriolis  force,  given by         m t   14.15    = − 2      t ,   F Coriolis  ω  ×  v  r      ×ω m t  v      t  r  2     tr      tv r     tω  α  O  Figure 14.4. The Coriolis force.             410   14. Rotational Physics   arises only when the particle is moving within the rotating system. It is this force  that  is  responsible  for  the  large-scale  cyclonic  motion  of  certain  weather  phe- nomena. For instance, hurricanes rotate counterclockwise in the northern hemi- sphere  and  clockwise  in  the  southern  hemisphere  because  the  cross  product  in  Equation  14.15  changes sign at the equator.   14.2  Rigid Body Motion   We define a rigid body to be a system of particles that are absolutely fixed with  respect to each other and thus share the same angular velocity. A solid object can  be thought of as a collection of an infinite number of particles, each having an  infinitesimal mass. Since the particles composing a rigid body do not move with  respect to each other, the centrifugal and Coriolis forces do not apply when the  object is rotating. The only motions that a rigid body may undergo are the linear  motion associated with the path along which it travels through space and the an- gular  motion  that  it  experiences  because  it  is  rotating  about  some  axis.  In  this  section, we investigate the rotational properties of a rigid body and the effects of  external forces on this rotation.   14.2.1  Center of Mass  When a rigid body rotates freely in the absence of any external forces, it does so  about an axis that passes through the body’s center of mass. The center of mass is  the point within the rigid body at which a force could be applied in any direction  without causing any net torque when that point is considered the origin.    Suppose that a rigid body is composed of some number of particles whose  position and mass are known. The total mass M of the system of particles is given  by      14.16    M  m=  ,   k  k  km  is the mass of the k-th particle, and the summation is taken over all of  where  the particles belonging to the system. Let  kr  denote the position of the k-th parti- cle. The center of mass C of the system is defined to be   C  1 =  M  k  m  k  r .  k   14.17    For a solid object, we compute the total mass of a continuous volume using the  integral    14.2  Rigid Body Motion   411        dm r  represents the differential mass at the position r, and V is the vol- where  ume occupied by the object. If the density at the position r is described by the  function       ρ r , then this integral can be written as   The center of mass for a solid object is then computed using the integral   M  =   V  dm      r ,   M  =   V      r  ρ  dV  .   =  C  1 M    V  r ρ      r  dV  .    14.18     14.19     14.20    Example 14.1. Calculate the center of mass of a cone of radius R, height h, and  constant density  ρ, whose base is centered at the origin on the x-y plane  see  Figure 14.5 .   z  h  R  x  y     Figure 14.5. The cone used in Example 14.1.   Solution. We use cylindrical coordinates. The radius      the cone at a height z above the x-y plane is given by   r z  of a cross section of       r z  =     − h z    R h  .    14.21                    412   14. Rotational Physics   We calculate the total mass of the cone using Equation  14.19  to integrate over  the volume it occupies. The differential volume dV  in cylindrical coordinates is  given by                        so the integral that we need to evaluate is   where the integrand represents the differential mass of a disk at height z above  the x-y plane. Replacing      r z  with the value given by Equation  14.21 , we have   dV r dr dθ dz  ,   =  M  h  =   0      ρπ r z  [  ] 2  dz  ,   =  M ρπ     − h z     2  dz  hR 2  h 2 0 ρπR h 2  .  =  1 3      14.22     14.23     14.24    Due to the cylindrical symmetry of the cone, the x and y components of the cen- ter of mass are clearly zero. The z component of the center of mass is found by  applying Equation  14.20 :   =  zC  1 h M      π r z  2      0 0  0  ρzr dr dθ dz  .    14.25    Evaluating the integral over θ leaves us with   We  next  integrate  over  r  and  replace   14.21 :   =  C  z  ρπ 2 M      h r z     0  zr dr dz  .    14.26    0     r z   with  the  value  given  by  Equation     − z h z     2  dz  =  C  z  =  2  2  ρπR Mh 2 ρπR Mh 2  h    0 h    0     h z 2  −  2  hz  2  +  3  z     dz  .     14.27     14.2  Rigid Body Motion   413    14.28                   Finally, integrating over z, we obtain   Thus, the center of mass of the cone is given by   0,0,  4h  .    =  C  z  2  ρπR h 2 M 12  h = .  4 =C  m=p  14.2.2  Angular Momentum and Torque  Recall that the linear momentum p of a particle having mass m moving at a ve- locity v is given by  v. Just as angular velocity is the rotational analog of  linear  velocity,  there  exists  a  quantity called  angular  momentum  that  serves  as  the rotational analog of linear momentum.    velocity of  The angular momentum   Suppose that a particle of mass m is rotating about some axis with an angular     tω  and that the position of the particle is given by the function     tr .      tL  of the particle is defined to be     where       is the linear momentum of the particle.    Differentiating both sides of Equation  14.29  gives us       t m t  p  =  v  L  p  r      t  =      t  ×      t ,    14.29          Since      v t t cross product       r t  =   r   L      t  =       r t    tr  ×  p  +      t    tp  ,  the  vectors  ×    and   is zero. Thus,       t  p      t  r  ×      t  .    p   14.30      point  in  the  same  direction,  so  the    L      t  =      t  r  ×      t   p  =          t m t  ×   v  .    14.31     is equal to the net force    acting on the particle, so we can   r    tF  The vector  write      m tv  The quantity on the right side of Equation  14.32  is called the torque     being applied to the particle:    L      t  =      t  r  ×      .  t  F      t  τ  =      t  r  ×      F .  t   14.32      tτ     14.33     414   14. Rotational Physics               Torque is the rotational analog to linear force and induces an angular accelera- tion. If the net torque acting on a particle is zero, then the angular  momentum  remains constant because    L      t  =      t  .   τ   14.34    14.2.3  The Inertia Tensor  Angular momentum is related to angular velocity in a much  more complicated  way than linear momentum is related to linear velocity. In fact, the angular mo- mentum  vector  and  the  associated  angular  velocity  vector  do  not  necessarily  point in the same direction. The relationship between these two quantities is the  topic of this section.    equal to the sum   The  angular  momentum  of  a  rigid  body  composed  of  a  set  of  particles  is       t  L  =      t  ×  p  k      t ,   r  k    k   14.35        tr k   represents the position of the k-th particle,      tp k   represents the mo- where  mentum of the k-th particle, and the summation is taken over all the particles be- longing to the system. Since the linear momentum      t   can be written as      t ,       t m      t m   14.36    ω  p  =  =  ×  v  r     k  k  k  k  k      tp k  the angular momentum becomes        t  L  =     k  m  r  k  k      t  ×  [      t  ×  ω  r  k      t  ] .    14.37    Using the vector identity given by Theorem 2.9 f ,   ×  P Q P  ×        = × × =  P Q P  2P  Q P Q P,   −        ⋅   14.38    the angular momentum can also be written as  [  −  =    m r 2 k      t      t      t  ω  L     k  r    k      t  ⋅  ω      t  ]  r  k  k      t     .     14.39    Dropping  the  function-of-t  notation  for  the  moment,  we  can  express  the  i-th  component of L by    14.2  Rigid Body Motion   415                        =  L  i    k  m r ω  2 k  k  i      −  3        r  k  i     r  k     = 1  j  ω  j  j  .       We can express the quantity   iω  as   ω  i  3  =   = 1  j  ω δ j  ij  ,   ijδ  is the Kronecker delta defined by Equation  2.42 . This substitution al-  where  lows us to write   iL  as   L  i  =     m  k     r ω δ 2 k j  ij  −     r  k      i  r  k     ω  j  j     3  = 1  j  k 3  =     ω  j  m δ r 2 ij k  k     = 1  j  k  −     r  k      i  r  k     j  .        The sum over k can be interpreted as the    ,i    j  entry of a 3 3×  matrix :            i  r  k  r  k  j  .      =    ij    k  m δ r 2 ij k  k     −  This allows us to express   iL  as   and thus the angular momentum      tL  can be written as   L  i  =   ,   ω  ij  j  3  = 1  j      t  L  =  ω      t  .    14.40     14.41     14.42     14.43     14.44     14.45     acting on a rigid body to the body’s angular acceleration   The entity  is called the inertia tensor and relates the angular velocity of a    rigid  body  to  its  angular  momentum.  The  inertia  tensor  also  relates  the  torque     tτ . Dif- ferentiating both sides of Equation  14.45  gives us      .  t   14.46        t      t      t      t   L  ω    α  =  α  =  =  τ       Written as a 3 3×  matrix, the inertia tensor is given by    416   14. Rotational Physics                     where  giving     integral   =   m k  k  2 k  y 2 k − −  + z x y k x z k  k  k        − x y k k + z x 2 2 k k − y z k  k  − − x 2 k  x z k k y z k k + y  2 k        ,   =r k  k  k  ,  z  y  x .  Clearly,    is  a  symmetric  matrix.  The  diagonal  entries  , where  k 33  are called the moments of inertia with respect to the x, y, and z  11 ,  22 , and  axes,  respectively.  The  off-diagonal  entries  are  called  the  products  of  inertia.  Equation  14.47  can also be expressed as   3E  is the  3 3×  identity matrix, and the operation ⊗ is the tensor product     m r 2 k  k  − ⊗  E r k  3    r ,  k  = I  k  r k    ⊗ =  r k    x 2 k x y k x z k  k  k  x y k y 2 k y z k  k  k  x z k k y z k z 2 k  k        .     ij     =    V  2  δ r ij  −  r r dm i  j      r ,        ij     =    V  2  δ r ij  −    r r ρ i  j      r  dV  .   For  a  continuous  mass  distribution,  Equation   14.43   is  formulated  as  the        dm r  represents the differential mass at the position r, and V is the vol- where  ume occupied by the rigid body. If the density at the position r is described by  the function       ρ r , then this integral can be written as     Because the inertia tensor is a summation, the inertia tensor for a collection  of objects is simply the sum of the inertia tensors for each object calculated indi- vidually. This property is sometimes useful in the calculation of inertia tensors  for complex objects that can be broken into simpler pieces.  See Exercise 5.    Example  14.2.  Calculate  the  moment  of  inertia  about  the  z  axis  of  a  solid  sphere of radius R that is centered at the origin and has a uniform density ρ.    14.47     14.48     14.49     14.50     14.51     14.2  Rigid Body Motion   417     Solution. The moment of inertia about the z axis is equal to the   inertia tensor . We need to evaluate the integral     33     =    V  2  r  −  2  z  ρdV  .       3,3  entry of the    14.52    2  2  r  The quantity  spherical coordinates is equal to  ential volume dV  in spherical coordinates is given by   z−  is equal to the squared distance from the z axis, which in  φ, where φ is the polar angle. The differ-  sin  r  2  2  = dV r  2 sin  φdr dθ dφ  ,    14.53    so Equation  14.52  becomes   2  r  2  sin    φ ρr  2  sin  φdr dθ dφ  =    33     π π R  2      0 0 0 2  π π R      0 0 0  =  ρ  4  r  3  sin  φdr dθ dφ  .      14.54    Evaluating the integrals over r and θ, we have   =    33  πρR  5  2 5  3  sin  φdφ  =  πρR  5  2 5    − 1 cos     2  φ  sin  φdφ  .    14.55    π    0  π    0  By making the substitutions  maining integral as follows.   = −  u  cos  φ  and   du  =  sin  φdφ  , we can evaluate the re-    33  πρR  5  2 5    1  −  2  u     du  1    1  − 5  =  =  πρR  8 15     The volume of the sphere is given by  inertia as   = 3V  4  3  πR  , so we can write the moment of     33  =  2 5  ρVR  2  =  mR  2  ,   2 5  where m ρV=   is the mass of the sphere.     14.56     14.57                       418   14. Rotational Physics              Due to the symmetry of the sphere, its moments of inertia about the x and y  5 mR . Furthermore, the products of inertia are zero, so the  axes are also equal to  inertia tensor  of a sphere has the form   2  2  Consequently,  the  angular  momentum  of  a  rotating  sphere  may  be  written  in  terms of a scalar moment of inertia   =    2  mR 0 0  2 5        2  0 mR 0  2 5  0 0 mR  2        .   2 5  = I     t  L  2  mR 2 5 =  :      ω .  I t   14.58     14.59    Example 14.3. Calculate the inertia tensor of a solid cylinder of radius R and  height h that is aligned to the z axis, centered at the origin, and has a uniform  density ρ  see Figure 14.6 .   z  2h  2h  R  x  y     Figure 14.6. The cylinder used in Example 14.3.   Solution. We first calculate the moment of inertia about the z axis using cylindri- cal coordinates to evaluate the integral     −  =     2  2  ρdV  .    14.60    s  z       33    V   14.2  Rigid Body Motion   419                      We have used  2s  to represent the squared distance from the origin to avoid con- z−   s fusion with the radial distance r in cylindrical coordinates.  The quantity  2 2 is equal to the squared distance from the z axis, which in cylindrical coordinates  is simply  2r . The differential volume dV  in cylindrical coordinates is given by   dV r dr dθ dz  ,   =   14.61    so Equation  14.60  becomes   r dr dθ dz 3    33  =  ρ  h  2 2  π R     − h 2 0 0 πρhR . 4  =  1 2      14.62    V πhR=  2 , so we can write the moment of   The volume of the cylinder is given by  inertia as       where m ρV= z axis, we must have  x axis by evaluating the integral   = 11  33  =  1 2  ρVR  2  =  mR  2  ,   1 2   14.63     is the mass of the cylinder. Since a cylinder is symmetric about the   . We can calculate the moment of inertia about the  22  s Making the substitutions  2  =  2  r  =  2  x  2  r  2  cos  θ  , we have      2  x  ρdV  .     11     −  =  2  V  s   +  and  z  2   14.64      11  =  ρ  2  r  +  2  z  −  2  r  2  cos    θ r dr dθ dz     h  2 2  π R      h 2 0 0 π R h 2 2  −      2 0 0  h  −  =  ρ  3  r  2  sin  θ dr dθ dz  +  ρ  z r dr dθ dz 2  .    14.65    h  2 2  π R      2 0 0  h  −  Evaluating the integrals for the variables r and z in the first term, and evaluating  all three integrals in the second term gives us     11  =  1 4  ρhR  4  2  sin  θ dθ  +  1 12  πρh R  3  .  2   14.66    2  π    0  Using the trigonometric identity    420   14. Rotational Physics                         see Appendix B, Section B.4 , we can evaluate the remaining integral:    14.67     14.68     14.69     14.71    2  sin  θ  −= θ 1 cos2     2  2  sin  θ dθ  2  π    0     1 2  −  −  1 4  1 2    θ dθ cos2 ]  π  θ sin 2  2 0  2  π    0  1 2 π  θ .  =  = =       11  =    22  = =  4  πρhR + mR 2  1 4 1 4  +  1 12  3  πρh R 2  1 12 mh  .  2     The moment of inertia about the x and y axes is therefore given by   The product of inertia  12  is equal to the integral     12  =    V  −  xyρdV  = −  ρ  h  2 2  π R      2 0 0  h  −  3  r  sin cos  θ  θ dr dθ dz  .    14.70    Since   sin cos  θ  θ dθ =  0 ,   2  π    0  it is the case that  of inertia are equal to zero, so the inertia tensor  of a cylinder has the form   . It can also be shown that all of the other products       12  21  0  =  2  mR  1 4  2  mh  1 12  =    + 0 0  0 + 0  0 0 mR  2        1 2  ,   2  mR  1 4  2  mh  1 12   14.72    =        where m ρV=   is the mass of the cylinder.      Nonzero products of inertia arise when we consider a solid box that rotates  about an axis passing through one of its vertices. The significance of an inertia  tensor that is not diagonal is discussed in Section 14.2.4.    14.2  Rigid Body Motion   421   Example 14.4. Calculate the inertia tensor of a solid box having dimensions a,  b, and c that is aligned to the coordinate axes, has one vertex at the origin, and  has a uniform density ρ  see Figure 14.7 .         z  c  a  b  x  y    Figure 14.7. The box used in Example 14.4.      2  x  +  2  y  ρdV    z  2  dx dy dz    11  −     ρ     2  r V c b a    0 0 0 b    0  =  =  =  = =  c    0  ρac y dy  2  +  ρab z dz  2  + ρab c 3   ρabc b 2  3  ρabc 1 3   + c . 2  1 3 1 3     Solution. The moment of inertia about the x axis   11  is given by the integral   The volume of the box is given by V abc as   =  , so we can write the moment of inertia    14.73     422   14. Rotational Physics   where m ρV= inertia about the y and z axes:    is the mass of the box. Similar calculations yield the moments of   The product of inertia  12  is given by the integral   =    11    3 m b  1  2  +  2  c     ,      22  33  = =  1 3 1 3    m a   m a  2  2  + +  2  2  c b       .   = −    12  xyρdV V c b a   ρ    0 0 0 b a   0 0 ρa b c 2 2  = −  xy dx dy dz  = −  ρc  xy dx dy  = −  1 4  = −  mab  .   1 4  = − = −     13  23  mac mbc  .   1 4 1 4   14.74     14.75     14.76     14.77     14.78    Similar calculations yield the remaining two unique products of inertia:   The inertia tensor  of a box is therefore given by   =       2    m b − 1 4 − 1 4  2  + c mab mac  1 3        − 1 4   m a − 1 4  mab + c 2 mbc  1 3     2  − 1 4 − 1 4   m a  mac mbc + b 2  ,            2  1 3  where m ρV=   is the mass of the box.    14.2.4  Principal Axes of Inertia  Because the angular momentum  equation      tL  and angular velocity      tω  are related by the       t  L  =  ω      t  ,    14.79                          14.2  Rigid Body Motion   423                  tω  is an eigenvector of the inertia  the two vectors are parallel precisely when  tensor . Since the inertia tensor is a symmetric matrix, it has three real eigen- values, and the associated eigenvectors are orthogonal  see Section 3.5 . The ei- genvalues of the inertia tensor are called the principal moments of inertia, and the  associated eigenvectors are called the principal axes of inertia. If a rigid body is  rotating about one of its principal axes of inertia, then its angular momentum is  given by       t  L  =      ω ,  I t   14.80    where I is the principal moment of inertia associated with the principal axis.    If the inertia tensor is a diagonal matrix, as it is for a sphere and a cylinder,  then the principal moments of inertia are the same as the diagonal entries, and the  principal axes of inertia are simply the x, y, and z axes. If the inertia tensor is not  a diagonal matrix, then we must calculate its eigenvalues and eigenvectors to de- termine the principal axes, as demonstrated in the following example.   Example 14.5. Determine the principal axes of inertia for a solid cube having  side length a that is aligned to the coordinate axes and has one vertex at the  origin.   Solution. The inertia tensor  for a box is given by Equation  14.78 . Setting the  lengths in all three dimensions equal to each other produces the inertia tensor for  a cube:   The determinant     2  3  = −  −    2  ma ma 1 4 ma 1 4  2  2  − 2 3 −  2  2  ma 1 4 ma 2 ma 1 4  − − 2 3  2  2  ma 1 4 ma 1 4 ma 2    .      I  ma 2 3 − 1 4 − 1 4  2  − ma 2 ma  2  − 1 4 ma 2 3 − 1 4  ma 2 − 2 ma 2  I  − 1 4 − 1 4 ma 2 3  2  ma ma 2 − 2  I  =  0 ,    14.81     14.82    yields the characteristic polynomial whose roots are the eigenvalues of . Since  the determinant is not affected by adding a multiple of one row to another row,  we can subtract the first row from the second row to simplify our calculations:    424   14. Rotational Physics                     Factoring   2  11  12 ma  I−  out of the second row and setting  b  =  ma  2   gives us   1 4  2  ma 2 3 − ma 11 12 − ma 1 4  − I + 2 2  I  − 1 4 ma 11 12 − 1 4  ma 2 − 2 ma 2  I  −  2  1 4  ma 0 ma 2  −  I  2 3  =  0 .      11 3  − b I     8 3  − b I − 1 − b  − b 1 − b  − b 0 − b I  8 3  =  .  0  Evaluating the resulting determinant, we have    − 8 3 + b 22 9 − b I  − b I − 13 3 − b I  − b I − b I − b I    bI              I    11 3  = = =  11 3 11 3         11 3  b  0  8 3  2 3     2  2  − b I   2 .        −  2  b 2     The principal moments of inertia  1I ,  2I , and  3I  are thus given by       14.85     14.83     14.84     14.86    I I I  1  2  3  = = =  2  2  = = =  b b b  11 3 11 3 2 3  ma 11 12 ma 11 12 ma 2 1 6  .     To find the principal axis of inertia corresponding to the eigenvalue  3I , we need  to solve the homogeneous linear system   b Again using the constant   =  3  ma − 1 4 − 1 4  2  − ma ma  I 2  2  2 3        − 1 4 ma − 1 4  ma − 2 ma  2  I 2  3  2 3  2  2  − 1 4 − 1 4 ma  ma ma − 2  I  3  x y z                   2 3  ma b 2 − b − b  1 4        2   and substituting the value  − b b 2 − b  x       y    z        − b − b b 2  0.   =  =  0.    14.87    I  3  b=  2 3  , we have    14.88    The reduced form of this system is    14.2  Rigid Body Motion   425    14.89     14.90     14.91                      1 0 0 1 0 0        − x 1       − y 1    z 0        =  0,   1  − b I − b − b  8 3        − b − b I − b  1  8 3  − b − b − b I  1  x y z                   8 3  =  0.   1 1 1 0 0 0 0 0 0        x       = y    z        0.   z  y  = = . This tells us that the vector  1,1,1 , a diagonal of the cube, rep- and thus x resents the principal axis corresponding to the principal moment of inertia  3I . The  principal axes corresponding to the eigenvalues  1I  and  2I  are found by solving the  system   Every entry of this matrix is the same, so the reduced form of the system is   Therefore, the y and z components of each principal axis may be chosen arbitrari- = − − .  ly  but not such that both are zero . The value of x is then given by x z  is perpendicular to the vector  1,1,1 , so the  Any vector of the form  principal axes corresponding to the principal moments of inertia given by  1I  and  2I  can be any orthogonal pair in the plane perpendicular to the cube’s diagonal.    − − y  z y z , ,  y  If a rigid body is not rotating about one of its principal axes, then the angular     tL  are not parallel. In      tω  and the angular momentum vector     velocity vector  this situation, the vector      tω  at the rate      tL  rotates about the axis      0 ≡  t      t      t   L  ω  L  =  ×  .   The resulting angular acceleration changes the axis of rotation, an effect called   precession. Since  L   is given by       t  =  α      t  , the angular acceleration     tα     t  − L 1      t      t      t  ] .   ω  L    =  ×  − 1  [  =  α   14.92     14.93    To counter this angular acceleration and prevent the axis of rotation from chang- L  must be applied in the opposite  ing, a torque equal in magnitude to       ×ω t      t   426   14. Rotational Physics                  direction. Therefore, the motion of a rotating rigid body can be described by the  equation   N  τ  = 1  i  i      t  −      t  ×      t  L  ω  =  α       t  =  θ       t  ,    14.94    τ τ , 1  where   14.94  is the rotational analog of Equation  13.9 .   τ  represent the external torques acting on the body. Equation  ,  , N  2  14.2.5  Transforming the Inertia Tensor  Given an invertible 3 3×  transformation matrix M that transforms points from one  coordinate system to another coordinate system with the same origin, an inertia  tensor  is transformed according to the formula   ′ = M M    1− .      14.95    It’s useful to think of this product as first transforming in reverse from the new  1−M , applying the iner- coordinate system to the original coordinate system using  tia tensor  in that coordinate system, and then transforming back into the new  coordinate system using M.    To  transform  an  inertia  tensor  into  a  coordinate  system  with  a  different  origin, we can use a formula known as the parallel axis theorem. Let s be an off- set vector representing the difference between the new origin and the old origin.  Then, starting with the formula for the inertia tensor given in Equation  14.48 ,  we replace r with  +r  +  2    s E  3  −     r k  + ⊗ +     s     r k     s   .     14.96    Expanding this summation, we have   ′  =      k  m r 2 k k  E  3  +  −    k  m  r k k  m  r k k  2      k ⊗ − r k     m    k  ⋅  s E    r k k     3  +   k ⊗ − ⊗ s  s     m s  2  E  3  k      k     m  r k k  −     m k    k     ⊗  s  s  .    14.97    This  equation  contains  the  two  terms  from  the  original  summation  given  by  Equation  14.48  for , so we can substitute  for these terms to get   s to obtain     r m   k  ′ =  k    k      14.2  Rigid Body Motion   427            ′  =      +     −     k  m  2     k  m  r k k     r k k     ⋅  +  s E     3  ⊗ − ⊗  s  s     k  m  k     m s  k  2  E  3  −  r k k     m k    k     ⊗  s  s  .    14.98    Now,  if  the  origin of  the  coordinate  system  coincides  with  the  center  of  mass,  k m r  is equal to the point  0,0,0 . This allows us to make  then the summation  a tremendous simplification because all of the terms in Equation  14.98  contain- ing this summation vanish. We therefore can use the formula   k k  ′ =      +    m s  2  E s  − ⊗  s  3         14.99    to  transform  an  inertia  tensor  from  a  coordinate  system  in  which  the  center  of  mass lies at the origin to another coordinate system in which the new origin lies  at the point s in the original coordinate system. Note that the sign of s does not  matter because it is squared in both terms where it appears in Equation  14.99 . A  translation by a certain distance in one direction produces the same inertia tensor  as a translation by the same distance in the opposite direction.    It’s important to understand that Equation  14.99  can only be applied once  to an inertia tensor in order to move it away from the center of mass. After the  inertia tensor has been moved, it no longer uses a coordinate system in which the  origin  coincides  with  the  center  of  mass,  but  that  condition  must  be  true  for  Equation  14.99  to be valid. However, it is possible to recover the inertia tensor  ′  if the vector s is known, once again allowing   from the offset inertia tensor  Equation  14.99  to be used to perform a new offset.   Example 14.6. Determine the inertia tensor for an axis-aligned box of constant  density  ρ  in  a  coordinate  system  where  the  box’s  center  of  mass  lies  at  the  origin.   Solution. We already calculated the inertia tensor for a box in Example 14.4, but  it was in a coordinate system where the origin coincided with one of the corners  ′   in  Equation  of  the  box.  We  can  treat  this  as  the  transformed  inertia  tensor   14.99  and recover the inertia tensor about the center of mass by solving for   with an offset   . This gives us   =s  ,  ,  a 2  b 2  c 2   428   14. Rotational Physics               =      m b − 1 4 − 1 4  1 3           2  2  + c mab mac     −  m  a b c , 2 2 2  ,  2  −  E  3  − 1 4   m a − 1 4  mab + c 2 mbc  1 3     2  − 1 4 − 1 4   m a  ⊗  2  mac   mbc    +  b 2  a b c , 2 2 2  ,  1 3 a b c , 2 2 2  ,      .   After adding corresponding matrix entries, we have for the inertia tensor of a box   with side lengths a, b, and c  about its center of mass      +  2  c  =    2    m b 0 0  1 12        0   m a 2 0  1 12     +  2  c  0 0   m a 2  1 12  .          +  2  b     Example 14.7. Find the inertia tensor of a dome, having constant density ρ and  semiaxis lengths a, b, and c as shown in Figure 14.8, in a coordinate system  where center of mass coincides with the origin.   c  a  b     Figure 14.8. The dome used in Example 14.7.   Solution. The total mass of the dome is  center of mass can be calculated using the integral   ρπabc  = 3m  2  , and the z coordinate of the   mC  z  =  ρabc  2  1  − 1  w  2  − − 2 v w 1  2       −  0  − 1  w  2  −  − − 2 v w 1  2  wdu dvdw  =  abc  ,  2   14.100    π 4  where we have made the substitutions    14.2  Rigid Body Motion   429               u  =  x a y = v b zw = c  du  =  dx  =  dv  dy     dw  =  dz  .  1 a 1 b 1 c   14.101    3 8  After  dividing  by  m,  we  find  the  center  of  mass  to  be  located  at  the  point  0,0, c . Instead of calculating the inertia tensor  about the center of mass, we  ′  about the origin at the center of the dome’s base  calculate the inertia tensor  and then use Equation  14.99  to find  when the offset is  . The mo- ments of inertia for a dome with the origin at the center of the base are given by  the integrals   0,0, c 3 8  =s      11  =  ρabc       22  =  ρabc       33  =  ρabc  − 1  w  2  − − 2 v w 1  2        1  0  1  0  1     −  − 1  w  2  −  − − 2 v w 1  2  − 1  w  2  − − 2 v w 1  2  −  − 1  w  2  −  − − 2 v w 1  2  − 1  w  2  − − 2 v w 1  2        0  −  − 1  2  w  −  − − 2 v w 1  2     b v 2 2  +  c w du dvdw 2  2  =    ρabc b  2  +  2  c    ,      2  a u 2  +  c w du dvdw 2  2  =    ρabc a  2  +  2  c    ,         π 2 15  π 2 15  π 2 15     2  a u 2  +     b v du dvdw 2 2  =    ρabc a  2  +  2  b    .    14.102    Substituting the mass m, this gives us the inertia tensor      +  2  c  ′ =    2    m b 0 0  1 5        0   m a 2 0  1 5     +  2  c  0 0   m a 2  1 5  .            +  2  b   14.103    In order to obtain the inertia tensor  about the center of mass, we must solve  . The adjustment to the inertia tensor is given  Equation  14.99  with  by   0,0, c 3 8  =s  2  s  E s  3  2    − ⊗ =     s  c 9 64 0 0  2  0 c 9 64 0  0 0 0        ,    14.104     430   and so   14. Rotational Physics   2  mb  1 5  19 320  2  mc  =          + 0 0  2  ma  1 5  19 320  2  mc  0 + 0  0 0   m a 2  1 5    .          +  2  b   14.105    14.3  Oscillatory Motion   The motion of an object is oscillatory if it repeats over a period of time by mov- ing  back  and  forth  through  the  same  region  of  space.  Such  behavior  is  often  caused by a restoring force that may be constant or may act on an object with  greater magnitude as the object moves further away from some equilibrium posi- tion. We examine oscillatory motion in this chapter because it shares some char- acteristics with rotational motion, such as angular velocity. The motion of a pen- dulum, discussed in Section 14.3.2, is an example of an object that rotates about a  point with an oscillatory nature.   14.3.1  Spring Motion   Oscillatory motion is exhibited by an object having mass m that is attached to the  end  of  a  spring  whose  natural  length  is  d   see  Figure  14.9 .  Suppose  that  the  spring is aligned to the z axis and that one end is attached to an immovable object  d= .  Let  the  mass  be  attached  to  the  other  end,  which  coincides  with  the  at  z origin.  Ignoring  gravity  for  the  moment,  when  the  spring  is  stretched  or  com- pressed so that its length is greater than or less than d, a restoring force is exerted  by the spring that is proportional to the displacement of the mass from its natural  resting position. If the position of the mass along the z axis is z, then the restoring  force F in that direction is given by   F  = − .  kz   14.106    This formula is known as Hooke’s law. The constant k is a property of the spring  corresponding to its stiffness. A larger value of k means that more work is re- quired to move the mass attached to the end of the spring.    function of time by examining the differential equation   The position of a mass attached to the end of a spring can be determined as a       mz t    = −      kz t  .    14.107                 14.3  Oscillatory Motion   431               z  m  z  d=  z =  0     Figure 14.9. A mass attached to the end of a spring.   The general solution to this equation is       z t  =  A ωt B  sin  +  cos  ωt  ,    14.108    =  k m  where ω  is called the angular frequency of the oscillations, measured in  radians per unit time. The frequency f corresponding to the number of oscilla- tions per unit time, measured in hertz  Hz  when the unit of time is the second, is  related to the angular frequency by the equation   The period P of the oscillations is equal to the time that passes between each rep- etition of the motion and is given by the reciprocal of the frequency:   =  f  ω π 2  .   =  P  =  π 2  π 2 ω  m k  .    14.109     14.110    The constants A and B in Equation  14.108  must be determined by imposing    initial conditions. Suppose that the initial position of the mass is  0z  and the initial  velocity of the mass is  0v . Since    432   14. Rotational Physics                        we can easily deduce   where       0     0  z  z  = =  B Aω ,   vA = 0 ω = B z 0 .        z t  =  C  sin     ωt  +     ,   δ  =  C  =  δ  v 2 0 ω 2 − sin 1  +  z  2 0  z 0 C  .     As discussed in Section 13.2.1, we may express Equation  14.108  in the form   The constant C represents the amplitude of the oscillations and corresponds to the  largest distance that the mass is ever displaced from its equilibrium position. The  constant δ represents the phase of the oscillations and corresponds to the initial  position of the mass.   Example 14.8. Determine the frequency and amplitude of a 2-kg mass attached  . Suppose that the mass  to a spring having a restoring constant of  t =  with  was previously being pulled downward and that it is released at time  an initial displacement of  0   and an initial velocity of  0  v = −  z = −  3 kg s  1m s  4 m  k =  0 .   2  Solution. The angular frequency ω is given by   Dividing by 2π radians gives us the frequency f in oscillations per second:   =  ω  =  k m  6 rad s 2  .   =  f  =  ω π 2  6 π  4  ≈  0.195 Hz  .    14.111     14.112     14.113     14.114     14.115     14.116     14.3  Oscillatory Motion   433                     The amplitude C of the oscillations can be found by using Equation  14.114 :   =  C  v 2 0 ω 2  +  z  2 0  =  5 6 3  ≈  4.08 m  .     14.117    Suppose that a mass m attached to the end of a vertical spring is now acted   to Equa-    upon by gravity. Adding the constant downward gravitational force  mg− tion  14.107  gives us       mz t    = −       kz t mg  −  .    14.118    The restoring force of the spring and the gravitational force are balanced when  they are equal in magnitude and act in opposite directions. Thus, the mass expe- riences no net force when     Solving for       z t  gives us the equilibrium position of the hanging mass:    14.119     14.120    −       kz t mg  =  .       z t  = −  mg k  .   = −  If the mass lies at the position z move.    Equation  14.120  is in fact a particular solution to Equation  14.118 . Add- ing this to the general solution to the homogeneous problem given by Equation   14.108 , we have    and has no velocity, then it will never   mg k      z t  =  A ωt B  sin  +  cos  ωt  −  .   mg k z=  and       0z  0   14.121    v=  , produces  0  Imposing the same initial conditions as before,      0z the same value for A but a different value for B:   vA = 0 ω = B z  0  +  mg k  .    14.122    When we write Equation  14.121  in the form    434   14. Rotational Physics                   z t  =  C  sin     ωt  +  δ     −  mg k  ,    14.123    the amplitude C and phase δ are given by Equation  14.114  with the modifica- tion that  0z  is replaced by  . The influence of gravity has the effect of  increasing the oscillation amplitude and advancing the phase angle corresponding  to the initial displacement.   0z mg k  +  14.3.2  Pendulum Motion  Suppose that an object of mass m under the influence of gravity is attached to a  massless rod of length L hanging from a fixed point coinciding with the origin as  shown in Figure 14.10. We assume that the rod is able to pivot freely about its  fixed end and that the mass is able to move in the x-z plane. Let I be the moment  of inertia of the object with respect to the y axis  about which the mass rotates . If  all of the mass is concentrated at a single point, then    object with the force mg, exerting a torque     tτ     = t m   The resulting angular acceleration     tα  is      τ t I   represent the position of the object. Gravity pulls downward on the    given by  g.   Let     tr   14.124     14.125        t m  I mL=  × I      t      t  2 .   α  ×  =  =  .   g  τ  r  r      and     tα  Since     tτ lum  rotates,  we  can  write  them  as  scalar  quantities   14.125  can then be written as    are always perpendicular to the x-z plane in which the pendu-    α t .  Equation       τ t   and       α t  =       θ t  = −  sin      θ t  ,   mgL  I   14.126    Equation  14.126  cannot be solved analytically for the function   where     θ t  is the counterclockwise angle between the pendulum and the negative  z axis.     θ t  due to    the presence of the sine function. We can, however, transform the equation into a  sinθ t   with  the  first  term  of  its  power  form  that  can  be  solved  by  replacing  series:             θ t  = −  mgL  I      θ t  .    14.127     14.3  Oscillatory Motion   435               O  z  θ  sinmg  θ  L  m  mg  x     Figure 14.10. The plane pendulum.   Equation  14.127  approximates the motion of a pendulum for which the angle     θ t  is always small. The solution to Equation  14.127  is given by      14.128      + ,  δ      θ t  sin  ωt  A  =     where the angular frequency ω is   and the constants A and δ are determined by initial conditions. The period P of  the oscillations is given by   =  ω  mgL  ,   I  =  P  =  π 2  π 2 ω  I  mgL  .   =  ω  g L  =  P  π 2  L g  .    14.129     14.130     14.131    For a point mass, we have    436   14. Rotational Physics   Chapter 14 Summary                  Centrifugal Force  The centrifugal force experienced by an object in a rotating environment is given  by       t    tω  is the angular velocity and     tr  F centrifugal  = −  ω  m     ×  [      t  ×      t  ]     ,   r  ω  where  an origin through which the axis of rotation passes. In the case that  are perpendicular, the centrifugal force can be expressed as the scalar    is the position of the object relative to     tω  and     tr    Coriolis Force  The Coriolis force experienced by an object in a rotating environment is given by   F centrifugal  =  mω r 2  =  2  mv r  .   F Coriolis  = − 2      m t  ω  ×      t ,   v  r  where       tv r   is the velocity of the object relative to the rotating reference frame.   Center of Mass  The center of mass C of a solid object whose density at the point r is      en by   ρ r  is giv-  =  C  1 M    V  r ρ      r  dV  ,   where M is the total mass of the object.   Angular Momentum  The angular momentum     where     tr axis of rotation passes, and       p     tL  of a particle is given by       t  L  =      t  r  ×      t ,   p   is the position of the object relative to an origin through which the       t m t  =  v   is the linear momentum of the particle.    Chapter 14 Summary      437    acting on a particle is given by      F ,  t  Torque  The torque     tτ   where  particle is equal to the time rate of change of its angular momentum:      is the force applied at the position     tr     tF      t      t      t      t   L  ×  =  =  .   τ  r  τ  . The net torque acting on a   2  ij       −  =  ,i    δ r ij    r r ρ i    j  entry of the inertia tensor  of a rigid body is given by   Inertia Tensor  The     where      The inertia tensor  for an object of mass m can be translated from a coordinate  system in which the center of mass lies at the origin to a coordinate system in  which the center of mass lies at a point s using the parallel axis theorem:     ρ r  is the density at the point r.     m s  E s  − ⊗      r  dV  ′ =  +      .   ,      s  V  2  j  3  The inertia tensor relates the angular velocity to the angular momentum and the  angular acceleration to the torque:  L τ      t     t  = =      ω t     . α t     z t  of a mass m attached to an oscillating spring having restoration     Spring Motion  The position      constant k is given by    where          z t  =  C  sin     ωt  +     ,   δ  =  C  =  δ  sin  2 0  mv k − 1  +  z  2 0  z 0 C  ,      438   14. Rotational Physics            0z  is the initial position, and  0v  is the initial velocity.  Pendulum Motion  A pendulum consisting of a mass m suspended from a rod of length L obeys the  equation of motion       α t  =       θ t  = −  sin      θ t  ,   mgL  I  where     θ t  is the angle formed with the vertical direction, and I is the moment of  inertia of the mass. Small oscillations of the pendulum have an angular frequency  ω given by   =  ω  mgL  .   I  Exercises for Chapter 14   1.  An ant is walking radially outward with a velocity v on the surface of a disk  rotating counterclockwise with an angular velocity ω. At a distance r from  the center of the disk, what is the total  magnitude F of the forces experi- enced by the ant?   2.  Suppose that a block of mass m is resting on the surface of a rotating disk at  a distance r from the axis of rotation. If the coefficient of static friction at  Sμ , determine the angular velocity at which the disk must ro- the surface is  tate to cause the block to begin sliding outward.   3.  Calculate the center of mass C of a cylinder of radius R and height h whose  base  is  resting  at  the  origin  on  the  x-y  plane  if  the  density  is  given  by      1 = + r ρ  r h .  z  4.  Calculate the moment of inertia about the z axis for the annular cylinder of  2R , and height h shown in Figure 14.11. Let m   inner radius  be the mass of the cylinder, and assume a uniform density ρ.   1R , outer radius   5.  Calculate  the  inertia  tensor  of  an  axis-aligned  capsule  about  its  center  of  mass.  A  capsule  is  a  solid  cylinder  with  height  h   in  the  z  direction   and  semiaxis lengths a and b  along the x and y axes, respectively  that has two  identical dome-shaped endcaps with semiaxis lengths a, b, and c, as shown    Exercises for Chapter 14      439   2R  1R  z  h  c  h  Figure 14.11. The annular cylinder used in Exercise 4.      a  b     Figure 14.12. The capsule used in Exercise 5.      in Figure 14.12. Let m be the total mass of the capsule and assume a uniform  density ρ. [Hint. Combine the inertia tensors for a cylinder and two domes  in the appropriate way.]   6.  Suppose that an object of mass m is hanging from a rope of negligible mass  that is wrapped around a cylindrical spool many times  see Figure 14.13 . If  the cylinder has mass M and radius R, determine at what rate a the object  accelerates downward under the influence of gravity. Assume that the rope  does not slip as it unwinds from the spool. [Hint. As gravity pulls on the ob- ject, it creates a tension T in the rope that is counteracted by the cylinder, so    440      14. Rotational Physics   R  M  m        Figure 14.13. The system used in Exercise 6.      the force equation is ma mg T inder that induces an angular acceleration α. Use the fact that a Rα=  − . The tension T exerts a torque on the cyl-  .]   =  7.  A spherical ball of mass m and radius R is placed on an incline that forms an  angle θ with the ground  see Figure 14.14 . The coefficient of static friction  Sμ . If the ball rolls down the incline under the influence of  at the surface is  gravity without slipping, determine its acceleration a. [Hint. Two forces are  acting on the ball, gravity and the frictional force, whose sum is equal to ma.  The frictional force also exerts torque on the ball, inducing an angular accel- eration α. Use the fact that a Rα=   as the ball rolls down the incline.]   8.  Suppose  that  a  box  of  uniform  density  having  mass  m  is  resting  on  the  Sμ   see Figure 14.15 . The  ground where the coefficient of static friction is  box has a square base of length and width d, and the box’s height is h. De- termine the minimum height z at which a force   applied directly to  the horizontal center of a side of the box would cause the box to begin top- pling over. [Hint. Equate the torques induced by the pull of gravity on the  center of mass and the force F about the bottom edge on the side opposite  that where the force is applied.]   F μ mg  <  S   Exercises for Chapter 14   441         R  m  θ  Figure 14.14. The ball used in Exercise 7.   F  z  h  O  m  d  Figure 14.15. The box used in Exercise 8.          This page intentionally left blank    Chapter 15   Fluid and Cloth Simulation   The animation of a two-dimensional fluid and a two-dimensional cloth are two  effects that can be added to a game engine to provide a large visual impact for a  relatively small amount of implementation effort. Although both fluid and cloth  simulation can become very complex in advanced implementations, an elemen- tary simulator for each type of animation is not difficult to construct. The math- ematics behind these kinds of systems turn out to be somewhat simple, and the  bulk of the implementation ends up being the bookkeeping for the actual triangle  meshes composing the fluid and cloth surfaces. In this chapter, we describe basic  ways of achieving fluid and cloth simulation, and we provide sample implemen- tations that can be used to animate triangle meshes.   15.1  Fluid Simulation   The worlds presented by many games contain regions covered by a fluid surface.  Whether it be a pool of water, a vat of deadly acid, or a pit of molten lava, we  would like the fluid surface to behave in a physically realistic manner. We can  accomplish this by modeling the way in which disturbances propagate through  the fluid as waves. In this section, we introduce the well-known wave equation  and apply it to real-time simulation of fluid surfaces.   15.1.1  The Wave Equation  The wave equation is a partial differential equation that describes the motion of  each point on a one-dimensional string or a two-dimensional surface experienc- ing  a  constant  tension.  We  can  derive  the  one-dimensional  wave  equation  by  considering a flexible elastic string that is tightly bound between two fixed end- points lying on the x axis  see Figure 15.1 . We assume that the string has a con- stant linear density  mass per unit length  ρ and experiences a constant tension T  that acts in the tangential direction.        443    444   15. Fluid and Cloth Simulation   z           x     Figure 15.1. A string having linear density ρ is tightly bound between two endpoints and  experiences a constant tension T.    ,  Let the function     z x t  represent the vertical displacement of the string at the    horizontal position x and at time t. When the string is displaced in the z direction,  the tension produces a force at each point along the string that results in an accel-  ,x t   F  experienced by a  eration. Newton’s second law dictates that the net force  s=   and  = + s small  segment  of  the  string  lying  between  x x x   at  any  time t  is  Δ equal to the product of its mass and its acceleration     ,x t a . Since the linear densi- ty of the string is ρ, the mass of the segment is equal to  Δρ x, and we have      a  x t ,  = F        , x t ρ x Δ  .        H s t , V s t ,       = =  T T  θ cos θ sin .    As shown in Figure 15.2, we can divide the force experienced by each endpoint  of  the  segment  lying  between  x x Δ   into  horizontal  and  vertical   ,V x t . Let θ represent the angle between the tangent to  components  s= . Since the tension T acts in  the string and the x axis at the endpoint where x  ,H s t  and vertical component  the tangential direction, the horizontal component   ,V s t  are given by    ,H x t  and   s=   and   = +  x  s              θ+ Δθ  Let  x the endpoint where    + V s cal component  by    represent the angle between the tangent to the string and the x axis at  x Δ . The horizontal component   and verti-  of the tension experienced at this endpoint are given   = + s  Δ , x t   Δ , x t    H s  +   15.1     15.2     15.1  Fluid Simulation   445                   ,V s t     T  Δθ θ+ x s = +  x Δ  θ  x  s=   ,H s t        Figure 15.2. The forces experienced at each endpoint of the segment lying between x and   x Δ  can be divided into horizontal and vertical components.   = +  x  s  s=      H s   V s  + +  x t Δ , x t Δ ,       = =  T T    θ cos   θ sin  + +    θ Δ   θ Δ .     15.3      For small motions, we assume that the net horizontal force is zero so that the  segment  accelerates  only  in  the  vertical  direction.  Thus,  for  the  segment  lying  between x  s=  and   = +  x  s  x Δ , we require that     x t H s t Δ , ,    H s  +  −        = .  0     ,H x t .  The  net  vertical  force  acting  on  the  segment  lying  between  x s  Consequently, the function H is independent of x, so we can write  of  s=   and    x x  produces an acceleration that is given by the z component of Equation  Δ  15.1 . Since the vertical acceleration is equal to the second derivative of the po- sition function     = +   ,  z x t , we have  ∂= ∂ t  a s t , z        2  2    z s t ,     =    V s  +    − x t Δ , ρ x Δ     V s t ,     .   Multiplying both  sides  by  the  density  ρ  and  taking  the  limit  as Δx  approaches  zero gives us    15.4      H t  instead   ρ  2  2  ∂ ∂ t    z s t ,     =  lim → x Δ 0    V s  +  −     V s t ,     .     x t Δ , x Δ   15.5     15.6    The right side of Equation  15.6  is equal to the definition of the partial deriva- tive of V with respect to x evaluated at s, so we can rewrite it as    446   15. Fluid and Cloth Simulation                          Using the values of   ,V s t  in terms of  press         H t  and     H t  as follows.    ,V s t  given by Equation  15.2 , we can ex-     Since θ is the angle formed between the tangent to the string and the x axis, tanθ  is equal to the slope of the function     z x t  at s. Therefore,    ,  ρ  2  2  ∂ ∂ t    z s t ,        V s t ,     .   ∂= ∂ x     V s t ,     =      H t  tan  θ        V s t ,     =      H t    z s t ,     ,   ∂ ∂ x   15.7     15.8     15.9    and Equation  15.7  becomes   Since   2  2     ρ  =      ∂ ∂ t  ∂ ∂ x    z s t ,      H t  ∂ ∂ x    H t  does not depend on x, we can write  ∂ 2 ∂ x        z s t H t  ∂ ∂ t  =  ρ     ,  2  2  2    z s t ,     .        15.10      z s t ,    .    15.11      sion T. Letting  2c  =  For small motions, cosθ is close to 1, so we approximate      H t  with the ten-  T ρ  , we now arrive at the one-dimensional wave equation:   z 2  ∂ 2 ∂ t  =  2  c  ∂ z 2 ∂ .  x 2   15.12    The two-dimensional wave equation is obtained by adding a second spatial term  to Equation  15.12  as follows.  ∂ 2 ∂ t   15.13    ∂ 2 ∂ y  ∂ 2 ∂ x  z 2  z 2  z 2  =  +  c     2            The constant c has dimensions of distance per unit time and thus represents a ve- locity. A fact that we do not prove here is that c is actually the velocity at which  waves propagate along a string or through a surface. This makes sense since the  wave  speed  increases  with  tension  experienced  by  the  medium  and  decreases  with the density of the medium.    15.1  Fluid Simulation   447           Equation  15.13  does not account for any forces other than the surface ten- sion. Thus, the average amplitude of the waves on the surface never diminishes  as it does for a real-world fluid. We can add a viscous damping force to the equa- tion by introducing a force that acts in the direction opposite that of the velocity  of a point on the surface to obtain   z 2  ∂ 2 ∂ t  =  2  c  z 2  ∂ 2 ∂ x      +  z 2  ∂ 2 ∂ y      −  μ  ∂ z ∂ t  ,    15.14    where the nonnegative constant μ represents the viscosity of the fluid. The value  of μ generally controls how long it takes for waves on a surface to calm down. A  small value of μ allows waves to exist for a long time, as with water, but a large  value of μ causes waves to diminish rapidly, as for a thick oil.   15.1.2  Approximating Derivatives   The  two-dimensional  wave  equation  with  viscous  damping  given  by  Equation   15.14   can  be  solved  analytically  using  separation  of  variables.  The  solution,  however, is quite complex and would require a significant amount of computa- tion for a real-time simulation. We instead choose to use a numerical technique to  model the propagation of waves over a fluid surface.    Suppose that our fluid surface is represented by a triangle mesh whose verti- ces are arranged on an n m×  regular grid as shown in Figure 15.3. Let d be the  distance between adjacent vertices in both the x and y directions, and let t be the  time interval between consecutive calculations of the fluid’s state. We denote the  displacement of a vertex in the mesh by    j k , where i and j are integers satis- z i , ≤ <   that  represent  the  spatial  coordinates,  and  k  is  a  fying  0 i nonnegative integer that represents the temporal coordinate. That is,    j k  is  z i , equal to the displacement of the vertex lying at the point    We impose the boundary condition that the vertices lying on the edge of the  surface  are  fixed  at  a  displacement  of  zero.  The  displacement  of  the  interior  points can be calculated by using Equation  15.14  and approximating the deriva- tives using the differences in the displacements of adjacent vertices. As illustrat- ed in Figure 15.4, we can approximate the x-axis-aligned tangent to the surface at    a vertex having coordinates   j  by calculating the average ratio of Δz to Δx be- tween that vertex and its immediate neighbors in the x direction. Using this tech- nique and the fact that Δx    id jd  at the time kt.   d= , we define the derivative  z  ∂ ∂  as follows.   ≤ <   and  0  j m  ,i  n  x     ,  ,  ,   448   15. Fluid and Cloth Simulation               j m=   cid:3   y  1j =  d  j =  0 i =  0  d 1i =  x   cid:2   i  n=     Figure  15.3.  A  fluid  surface  is  represented  by  a  triangle  mesh  whose  vertices  are  ar- ranged on an n m×  regular grid.     z i  ,     −  j k ,  −  1,     j k ,    z i  +  1,  j k ,  −    z i  ,     j k ,    d  ∂ ∂ x    z i  ,     =  j k ,    z i d    − d 2  +  2 j k ,       z i  +  1,  j k ,    z i  −  1,  =      15.15    ∂ ∂  at the vertex having coordinates      We define the derivative  z j  in a similar  manner by calculating the average ratio of Δz to Δy between that vertex and its  immediate neighbors in the y direction. As with the x direction, Δy d= , so we  have   ,i  y  ∂ ∂ y    z i  ,     =  j k ,    z i  ,  +  1,  k  j    z i  ,  −  1,  k  j       − d 2  .    15.16    ∂ ∂  by calculating the average difference  We can define the temporal derivative  z in the displacement of a vertex between the current time and the previous and  succeeding times at which the displacement is evaluated. The time between eval- uations is t, so the average ratio of Δz to Δt is given by   t  ∂ ∂ t    z i  ,     =  j k ,    z i  ,  j k ,    + − 1 t 2    z i  ,  j k ,  −    1  .    15.17     15.1  Fluid Simulation   449               z Δ x Δ  z  i  =  z −− i 1 d  x z ,i  i  z Δ x Δ  =  z  i  z  i  + − 1 d  x  z− , 1  i  i  − 1  z Δ x Δ  =  z  i  z −− i + 1 1 d 2  x  z+ , 1  i  i  + 1     Figure 15.4. The x-axis-aligned tangent to the surface can be approximated by calculat- ing the average ratio of Δz to Δx between that vertex and its immediate neighbors.     Second derivatives can be approximated by employing the same method used  to approximate the first derivatives. This is done by calculating the average ratios  of the differences between the first derivatives to one of the spatial or temporal  coordinates. To illustrate, we consider the second derivative at the vertex having  coordinates   ∂ ∂   between  first derivatives at this vertex is given by     j   with  respect  to  x.  The  average  difference   Δ z  ,i  x        Δ  ∂  ∂ x    z i  ,  j k ,  =         ∂ ∂ x    z i  +  1,  j k ,     −    z i  −  1,     j k ,  ∂ ∂ x  2  .    15.18    Substituting the value given by Equation  15.15  for the derivatives with respect  to x, we have the following.  +  −             z i  ,  j k ,    z i  ,  j k ,  2,  j k ,    z i  2,    − z i d 2    z i  +  2,  j k ,       z i  −  2,  j k ,        15.19    Δ  ∂  ∂ x    z i  ,  j k ,      =    =    − j k , d 2  −  2   +  −  2    j k z i , , d 4 Δ z        Dividing by d gives us the ratio of  second derivative:   ∂ ∂  to Δx, which we use to define the   x  ∂ 2 ∂ x  2    z i j k ,  ,     =    z i  +  2,  j k ,     −  2     +    z i  −  2,  j k ,       z i j k , 4 2  , d  .    15.20     450   15. Fluid and Cloth Simulation                  This formula requires that we use the displacements of neighbors lying two verti- ces away from the vertex where we wish to calculate the second derivative. For- tunately, the adjacent neighbors are not used, so we can scale the coordinate sys- tem about the vertex lying at     j  by one-half. Using the nearest neighbors and  cutting the distance Δx in half, we obtain the following equivalent formula for the  second derivative with respect to x.  +  ,i  +  −  −             z i  1,  j k ,  1,  j k ,    z i    z i  ,     =  j k ,   15.21    2    z i j k , , d  2  The  following  similar  formulas  give  the  second  derivatives  with  respect  to  the  spatial coordinate y and the temporal coordinate t.     z i j k ,  ,     =    z i j k ,  ,     =    z i j ,  +  1,  k     −  2     +    z i  ,  −  1,  k  j       z i  ,  j k ,    + − 1    z i j k ,  2     +    z i j k ,  ,  −    1    z i j k , , d  2  , t 2   15.22     15.23    ∂ 2 ∂ x  2  ∂ 2 ∂ y  2  2  2  ∂ ∂ t           15.1.3  Evaluating Surface Displacement  Using the first derivative with respect to t given by Equation  15.17  and the se- cond  derivatives  given  by  Equations   15.21 ,   15.22 ,  and   15.23 ,  the  two- dimensional wave equation with viscous damping given by Equation  15.14  can  be written as follows for the vertex having coordinates      j .   ,i    z i  ,  j k ,    + − 1  2     +    z i  ,  j k ,  −    1  j k ,    z i , t 2 j k 1, ,     +  −  2  =   z i  +  −  1,  j k ,       z i  ,  +  1,  k  j     −     +    z i  ,  −  1,  k  j       z i  2  c  +  2  c  −  μ    z i  ,  j k ,    + − 1 t 2       z i j k , , d 2   j k z i , , d 2 j k ,  −  2    z i  ,    1      15.24    We would like to be able to determine the future displacement    j k +  occur- z i , ring after the time interval t has passed, given that we already know the current  displacement    z i j k  and the previous displacement      j k − . Solving Equa- z i , , 1 tion  15.24  for    z i    j k +  yields  ,    1    1  , ,  ,  ,   15.1  Fluid Simulation   451                    z i  ,  j k ,  +    1  =  2  − c t d 4 8 2 2 + μt 2    z i  ,     +  j k ,    z i  ,  j k ,  −    1  2 2  μt μt    − +  +  +  2  c t d 2 2 2 + μt 2  [    z i  +  1,  j k ,     +    z i  −  1,  j k ,    z i  ,  +  1,  k  j     +    z i  ,  −  1,  k  j     ] ,    15.25    which provides exactly what we need. The constants preceding each term can be  precomputed, leaving only three multiplications and four additions to be calcu- lated at each vertex in the mesh.  If the wave velocity c is too fast, or the time interval t is too long, then suc-   cessive iterations of Equation  15.25  cause the displacements to diverge toward  infinity. To keep the displacements finite, we need to determine the exact condi- tions under which Equation  15.25  is stable. These conditions are revealed when  we impose the requirement that any vertex displaced and held away from an oth- erwise flat surface should move toward the surface when released.  Suppose that we have an n m×  array of vertices for which    j z i , ,0     =  for every vertex except the one having coordinates       j ,i z i j 0 ,1 0 0 vertex  at      h=   and  z i ,i , 0 0 where h is a nonzero displacement. Now suppose that the vertex at   ,i 0 leased  at  time  2t.  When   15.25  is zero, so we have     =  and  0 . Let the    h= ,  j ,1 0   j  is re-   is  evaluated,  the  third  term  of  Equation     be  held  in  place  such  that     z i    z i  ,2  ,0           j  j  j  ,  ,  ,  0  0  0  0  0  0    z i  ,  0     =  j  0  ,2  2  − c t d 4 8 2 2 + μt 2 − c t d 2 8 2 2 + μt 2  =  2  +  μt h  .    z i  ,  0    ,1  j  0  +    z i  ,  0     j  0  ,0  μt μt  − +  2 2      15.26    For the vertex to move toward the surrounding flat surface, its displacement must  be smaller at time 2t than it was at time t. Thus, we must require that  = .  h   Plugging in the value given by Equation  15.26  for    z i  , we have    15.27      z i    z i    ,1  ,2  ,2  <        j  j  j  ,  ,  ,  0  0  0  0  0  0  Thus,   − 2 8  c t d 2 2 + μt 2  2  +  μt h  <  h  .   − 2 8  − < 1  c t d 2 2 + μt 2  2  +  μt  <  1 .    15.28     15.29     452   15. Fluid and Cloth Simulation                     Solving for c, we find   0  < <  c  μt  + .  2  d t 2   15.30    This tells us that for any given distance d between adjacent vertices and any time  interval t between consecutive iterations of Equation  15.25 , the wave velocity c  must be less than the maximum value imposed by Equation  15.30 .    Alternatively, we may calculate a maximum time interval t given the distance  d  and  the  wave  velocity  c.  Multiplying  both  sides  of  Equation   15.29   by    μt−   2 +  and simplifying yields   The left inequality simply requires that  impose in any case. The right inequality yields the quadratic expression   t > , a condition that we would naturally   0  <  0  2  c t 4 d  2  2  <  μt  + .  2  2  c t 4 d  2  2  −  μt  − < .  2 0  ±  μ  =  t  + μ c d 32 2 2 c d 8 2 2  2  .    15.31     15.32     15.33    Using the quadratic equation, the roots of the polynomial are given by   Since  the  coefficient  of  the  quadratic  term  in  Equation   15.32   is  positive,  the  corresponding parabola is concave upward, and the polynomial is therefore nega- tive when t lies in between the two roots. The value under the radical in Equation   15.33  is larger than μ, so the lesser of the two roots is negative and can be dis- carded. We can now express the restriction on the time interval t as   +  μ  0  < <  t  + μ c d 32 2 2 c d 8 2 2  2  .    15.34      Using  a  value  for  the  wave  velocity  c  falling  outside  the  range  given  by  Equation  15.30  or a value for the time interval t falling outside the range given  by  Equation   15.34   results  in  an  exponential  explosion  of  the  vertex  dis- placements.    15.1  Fluid Simulation   453               15.1.4  Implementation  An implementation of Equation  15.25  for a fluid surface requires that we store  two buffers, each containing an n m×  array of vertex positions. At each frame,  one of the buffers contains the current vertex positions, and the other buffer con- tains  the  previous  vertex  positions.  When  we  evaluate  new  displacements,  we  replace each vertex in the buffer containing the previous vertex positions with the  new vertex position. The buffer containing the current vertex positions then be- comes the buffer containing the previous vertex positions, so we actually alter- nate which buffer is used to render each frame.    To perform lighting calculations, we need to know the correct normal vector  at each vertex and possibly the correct tangent vector at each vertex. At the ver- tex having coordinates     j , the  unnormalized  x-axis-aligned tangent vector T  and y-axis-aligned tangent vector B are given by   ,i  Substituting the formulas for the partial derivatives given by Equations  15.15   and  15.16 , we have   =  T  1,0,    z i  ,  j k ,  =  B  0,1,    z i  ,  j k ,  .         ∂ ∂ x ∂ ∂ y  =  T  1,0,  =  B  0,1,    z i  +  1,  j k ,    z i  −  1,  j k ,    z i  ,  +  1,  k  j    z i  ,  −  1,  k  j    − d 2   − d 2        .    15.35     15.36    = ×  N T B,   The   also  unnormalized   normal  vector  N  is  then  simply  given  by  which can be expressed as follows.   i  j  =  N  1 0  0 1    z i  +  1,  j k ,    z i  −  1,  j k ,    z i  ,  +  1,  j    z i  ,  −  1,  k  j        k   − d 2   − d 2   − z i  k    z i  +  1,  j k ,  = −    − d 2  1,  j k ,       z i  ,  +  1,  k  j    z i  ,  −  1,  k  j     −  ,  ,1      15.37      − d 2   454   15. Fluid and Cloth Simulation         Multiplying the vectors T, B, and N by 2d does not change the direction in which  they point but does eliminate the divisions, yielding the following formulas.   = = =  T B N      + z i d j k 1, 2 ,0, ,     + j d z i k 1, 0,2 , ,       − − j k z i z i , 1,    − − j k z i , 1,   − − k j z i , 1,     + z i j k 1, , , ,      j  −  1,  k     −    z i  ,  +  1,  k  j     ,2  d      15.38      Listing  15.1  demonstrates  how  a  fluid  surface  simulation  might  be  imple- mented. It is important to realize that the time interval between evaluations of the  fluid displacement must be constant. The frame rate for most games varies con- siderably, so some mechanism should be used to ensure that the position of the  surface is updated only after enough time has passed in situations when the frame  rate is high.    When an object interacts with the fluid surface  e.g., a rock is thrown into it ,  it should cause a disturbance. The surface can be displaced by explicitly modify- ing the current and previous positions of the vertices surrounding the point where  the interaction takes place. Displacing the vertex nearest to the point of impact  and, by a lesser amount, the eight nearest neighbors generally produces pleasing  results.   Listing 15.1. This code implements a two-buffer surface displacement algorithm. The constructor  of the Fluid class takes the size of the vertex array, the distance d between adjacent vertices, the  time interval t, the wave velocity c, and the viscosity  μ. The  renderBuffer member variable  indicates which buffer should be rendered for the  current  frame—it  alternates  between  0  and 1  during each call to the Fluid::Evaluate   function.   private:    long     long     class Fluid  {                              float        long                width;  height;   Vector3D     *buffer[2];  renderBuffer;   Vector3D    Vector3D     *normal;  *tangent;  k1, k2, k3;    15.1  Fluid Simulation      455        public:    void Evaluate void ;   normal = new Vector3D[count];  tangent = new Vector3D[count];   width = n;  height = m;  long count = n * m;   Fluid long n, long m, float d, float t, float c, float mu ;  ~Fluid  ;   buffer[0] = new Vector3D[count];  buffer[1] = new Vector3D[count];  renderBuffer = 0;               };    Fluid::Fluid long n, long m, float d, float t, float c, float mu   {                                                                  Initialize buffers.  long a = 0;  for  long j = 0; j < m; j++   {   float y = d * j;   for  long i = 0; i < n; i++                   Precompute constants for Equation  15.25 .  float f1 = c * c * t * t    d * d ;  float f2 = 1.0F    mu * t + 2 ;  k1 =  4.0F - 8.0F * f1  * f2;  k2 =  mu * t - 2  * f2;  k3 = 2.0F * f1 * f2;   buffer[0][a].Set d * i, y, 0.0F ;  buffer[1][a] = buffer[0][a];  normal[a].Set 0.0F, 0.0F, 2.0F * d ;  tangent[a].Set 2.0F * d, 0.0F, 0.0F ;  a++;   {              456      15. Fluid and Cloth Simulation   }     }   delete[] tangent;  delete[] normal;  delete[] buffer[1];  delete[] buffer[0];       }    Fluid::~Fluid    {          }    void Fluid::Evaluate void   {                                                          Apply Equation  15.25 .  for  long j = 1; j < height - 1; j++   {   const Vector3D *crnt = buffer[renderBuffer] + j * width;  Vector3D *prev = buffer[1 - renderBuffer] + j * width;      for  long i = 1; i < width - 1; i++             }   prev[i].z = k1 * crnt[i].z + k2 * prev[i].z +       k3 *  crnt[i + 1].z + crnt[i - 1].z +  crnt[i + width].z + crnt[i - width].z ;   {        }      Swap buffers.  renderBuffer = 1 - renderBuffer;      Calculate normals and tangents.  for  long j = 1; j < height - 1; j++   {   const Vector3D *next = buffer[renderBuffer] + j * width;       Vector3D *nrml = normal + j * width;  Vector3D *tang = tangent + j * width;    for  long i = 1; i < width - 1; i++      {    15.2  Cloth Simulation   457   nrml[i].x = next[i - 1].z - next[i + 1].z;  nrml[i].y = next[i - width].z - next[i + width].z;  tang[i].z = next[i + 1].z - next[i - 1].z;            }           }             }   15.2  Cloth Simulation   A flag blowing in the wind and a cape trailing behind a character are two exam- ples of animation that can be achieved using cloth simulation. This topic can get  very complex, but a basic simulation of a rectangular sheet of cloth can be im- plemented fairly easily and with realistic results. This section describes the fun- damental design of a simple cloth simulator.   15.2.1  The Spring System  Our cloth is composed of an array of point particles arranged in a regular two- dimensional grid formation. We simulate the motion of only these particles, and  then fill each grid square with triangles to render the cloth. In order to give the  cloth cohesion and to control its motion, each particle is connected to several of  its neighboring particles by a virtual spring and damper. Each spring has the ef- fect of maintaining a specific distance between particles, and each damper pre- vents neighboring particles from acquiring wildly different velocities.    Figure 15.5 shows the connections made for a single particle in the interior of  a cloth mesh. First, springs and dampers are established between the particle and  its immediate neighbors in the left, right, up, and down directions, as shown by  the red lines in the figure. These connections are what give the cloth its primary  structure, and they prevent the particles from flying apart or collapsing into a sin- gle  point.  However,  they  do  nothing  to  prevent  unwanted  situations  such  as  a  cloth folding over on itself to form an infinitely sharp crease. To limit the amount  of bending that can occur, springs and dampers are also established between the  central particle and its neighbors two grid points away in the left, right, up, and  down directions, as shown by the green lines in the figure. With these eight con- nections for each particle, the cloth behaves pretty well, but there is still one pos- sibility that we would like to prevent. A shearing motion can arise because the  distances between the particles remain the same if the grid squares are deformed  into a rhombus shape. To eliminate this case, we add four more connections be-    458   15. Fluid and Cloth Simulation            y  d  d  x  Figure 15.5. The central particle is connected to its four immediate neighbors  red lines   to give the cloth cohesion, to its four neighbors two grid points away  green lines  to limit  bending, and to its four diagonal neighbors  blue lines  to prevent shearing.      tween the central particle and its diagonal neighbors, as shown by the blue lines  in the figure. For particles near the boundary of the mesh, any connections that  can’t be made because some neighbors don’t exist simply aren’t made, and fewer  springs and dampers are used to control their motions.  Let P and Q represent the positions of two immediately neighboring particles    connected by a spring and damper, and let d be the rest length of the spring. The  distance d is the distance that the spring would like to maintain between the two  particles, so if the actual distance is anything else, then the particles experience a  force    due to the spring given by   springF  F spring  =  k  spring     −  Q P  −  d     − −  Q P Q P  ,    15.39    k  spring   is the spring constant  see Section 14.3.1 . The force   where   is experi- enced by the particle at P, and the force   is experienced by the particle at  Q. For the springs that connect particles that are two grid points apart or particles  that are diagonal from each other, the rest length used in Equation  15.39  be- comes 2d and    A force  F ties d  , respectively.   is exerted by the damper if there is a difference in the veloci-  dtQ , and it is given by   2d damper   and d  springF  dtP  −F  spring  F damper  =  k  damper     −Q d dt  P d dt     ,    15.2  Cloth Simulation   459         k  F  damper  damper  damper   is experienced by the particle at Q.    is a positive constant that determines how strong the damper is. As   is experienced by the particle at P, and the   where  with the spring force, the force  −F force    In  order  to  finely  tune  the  behavior  of  our  cloth,  we  can  choose  different  spring and damper constants for the different types of connections in the cloth.  For example, we might use a large spring constant for the long springs connect- ing particles two grid points apart to make the cloth highly resistant to bending.  It’s important not to go too high, however, because strong springs have a tenden- cy to introduce unwanted vibration into the simulation.   15.2.2  External Forces  If all of the particles in our cloth are initially placed so that all of the springs have  their rest lengths, then nothing would ever move in our cloth simulation. In order  to see some animation, we need to apply some external forces, the most obvious  of which is gravity. Each particle in the cloth experiences a force    F  gravity m=  g,    15.40    2     −  =   .   0,0, 9.8 m s  where m is the mass of the particle, and g is the acceleration of gravity  which  would normally be  g   After gravity, the most common force applied to a cloth is due to wind, or  more precisely, the difference between the velocity of the cloth and the velocity  of the air. For a particle at the point P where the unit normal direction to the cloth  is N, the force due to the wind is given by     ⋅P d dt Here,  W  is  the  velocity  of  the  wind,  and  wind   is  a  constant  that  controls  how  quickly  the  wind  accelerates  the  cloth,  which  is  an  adjustable  parameter  that  could depend on factors such as the heaviness of the air or whether any air blows  through the cloth. The dot product with the normal causes the force to be greatest  when  the  wind  direction is  perpendicular  to  the  tangent  plane  of  the  cloth  and  least when the cloth is nearly aligned to the wind direction. We take the absolute  value because it doesn’t matter which side of the cloth that the wind strikes.    15.41    N .   W     wind  wind  F  =  −  k  k  15.2.3  Implementation  For each particle in our cloth, we store a three-dimensional position and a three- dimensional velocity. We animate our cloth by updating the positions and veloci-   460   15. Fluid and Cloth Simulation            ties of all the particles at a fixed time interval Δt. This time interval is independ- ent of the actual frame rate at which a scene is being displayed, so the number of  simulation steps taken during any one rendering frame can vary. A time interval  between 5 and 20 milliseconds is typical and generally produces good results.    During  a  single  simulation  step,  a  particle’s  new  position  is  calculated  by  considering its current velocity and the set of forces acting on the particle. Once  the new position is known, we calculate the new velocity  to be used in the next  simulation step  by simply dividing the difference between the old and new posi- tions by the time interval Δt.    We can iterate through all of the particles and calculate the external forces  iP , whose  for each one separately. For the i-th particle, whose current position is  externF   surface normal is  exerted on the particle is given by   iN , and whose current velocity is   iV , the external force   F extern  =  g m  +  k  wind     −  W V N .   i  i     ⋅   15.42    If we were to calculate the spring and damper forces while iterating over the par- ticles,  then  we  would  end  up  calculating  the  force  exerted  by  each  connection  twice, which is hardly efficient. There is also an inconsistency in the number of  connections that each particle has that makes a per-particle accumulation of the  spring and damper forces an unattractive approach. Instead, we initialize an array  of forces, with one entry per particle, to the value given by Equation  15.42 . We  then iterate over all of the connections in the entire cloth system, calculate the  force for each one, and apply the force to the two particles it connects. The force  exerted at one end of the connection is the negation of the force exerted at the  other end.    Once the total force  i′P  using  the new position   iF  has been accumulated for each particle, we determine   ′ = P i  +  P V i i  Δ  t  + F i m 2     Δ  t    2  .    15.43    After  all  of  the  positions  have  been  updated,  new  normal  and  tangent  vectors  need to be calculated, both for shading purposes and, in the case of the normal  vector, for use in Equation  15.42  during the next simulation step. Since the tex- ture map would typically be aligned to the grid over which the cloth is construct- ed, we can compute tangents and bitangents using a central difference method, as  opposed to running something similar to the code shown in Listing 7.1.    Chapter 15 Summary   461   Chapter 15 Summary  The Wave Equation  The two-dimensional wave equation for a surface experiencing a viscous damp- ing force is   z 2  ∂ 2 ∂ t  =  2  c  z 2  ∂ 2 ∂ x      +  z 2  ∂ 2 ∂ y      −  μ  ∂ z ∂ t  .   The constant c is the speed at which waves propagate through the medium, and  the constant μ represents the viscosity of the medium.   Approximating Derivatives for a Fluid Surface  The first derivative of a function    d z x     dx      z x d    − d 2  +  ≈       z x d  −     ,   z x  can be approximated by the formula   where d represents some constant step size. The second derivative of    approximated by the formula      z x  can be   d 2 dx  2      z x  ≈    z x d  +     −  2  +    z x d  −     .       z x d 2  j k +  of a point on the surface of a fluid after a  ,  Evaluating Fluid Surface Displacement  The future displacement  time t has passed is calculated using the equation  − 2 + 2  − c t d 4 8 2 2 + μt 2    z i    z i    z i  j k ,  j k ,    1    1  +  +  =     ,  ,  ,  2    z i  ,  j k ,  −    1  μt μt    +  2  c t d 2 2 2 + μt 2  [    z i  +  1,  j k ,     +    z i  −  1,  j k ,  +    z i  ,  +  1,  k  j     +    z i  ,  −  1,  k  j     ] ,   where d is the distance between neighboring vertices in the triangle mesh.   Stability of the Numerical Method for a Fluid  Given a constant time step t, the wave speed c must satisfy   0  < <  c  μt  + .  2  d t 2                  462   15. Fluid and Cloth Simulation   Given a constant wave speed c, the time step t must satisfy   +  μ  0  < <  t  + μ c d 32 2 2 c d 8 2 2  2  .   Internal Forces for a Cloth Particle  A particle of mass m at a point P connected to another particle at the point Q ex- periences the forces   F spring  =  k  spring     −  Q P  −  d     − −  Q P Q P     F damper  =  k  damper     −Q d dt  P d dt     ,   where d is the rest length of the spring connecting them.   External Forces for a Cloth Particle  A particle of mass m having a velocity V experiences the force   F extern  =  g m  +  k  wind     −  W V N ,      ⋅  where g is the acceleration of gravity, W is the velocity of the wind, and N is the  surface normal at the particle’s location.   Exercises for Chapter 15   1.  Suppose that the fluid surface displacement of each vertex in a triangle mesh  is evaluated 20 times per second. If the distance between neighboring verti- ces is 0.1m and the viscous damping constant is  , what is the maxi- mum wave speed for which Equation  15.25  is numerically stable?   − 11s  =  μ  2.  Suppose  that  the  distance  between  neighboring  vertices  of  a  fluid  surface  mesh is 0.1m and the viscous damping constant is  , as in the previ- ous exercise. What is the maximum time interval between consecutive eval- uations that allows a stable wave speed of 2 m s?   − 11s  =  μ  and                      Chapter 16   Numerical Methods   During the course of 3D graphics development, problems often arise that require  us to numerically calculate the solution to some kind of mathematical model. In  this chapter, we start with an effective technique for simultaneously calculating  the  sine  and  cosine  functions.  We  then  discuss  numerical  methods  for  solving  three classes of problems. First, we discuss techniques for solving arbitrary linear  systems and linear systems having a special form. Second, we examine methods  for finding the eigenvalues and eigenvectors of a symmetric matrix. Lastly, we  introduce classical procedures for approximating the solutions to ordinary differ- ential equations.   16.1  Trigonometric Functions   The  sine  and  cosine  functions  are  frequently  used  in  games  and  computer  graphics, so it’s good to have a fast way of calculating them. Furthermore, it’s  often the case that the sine and cosine of an angle are both needed at the same  time, so a method that produces both values together for the price of calculating  either one separately is very attractive. Such a method exists, and it combines a  lookup table with a simple refinement based on a trigonometric identity.    Suppose that we wanted to calculate the sine and cosine of an arbitrary angle  θ and that we have access to a lookup table containing precomputed values of the  sine  and  cosine  functions  for  n  evenly  distributed  values  in  the  range [   0,2π ,  where n is a power of two. We can express the angle θ as the sum α β+ , where   α  =  =  π n θ 2 n π 2 α θ .     −         16.1   Here, the angle α is the result of rounding the angle  θ  down to the nearest multi- ple of 2π n, and the angle β is simply what’s left over.      β       463    464   16. Numerical Methods            The values of sin α and cosα are fetched from our lookup table. As long as n    is chosen to be large enough, the angle β is always very small, so it only takes a  few terms of a Taylor series  see Appendix D  to calculate sin β and cos β to the  full precision of a 32-bit floating-point number. For  , the following for- mulas are sufficient:   256  n =  sin  β  = −  β  cos  β  = − 1  +  +  β 3 3! β 2 2!  β 5 5! β 4 4!  .      With the sines and cosines of the angles α and  β in hand, we calculate the  sine and cosine of the angle θ  using the angle sum formulas   sin cos       + +  α β α β       = =  sin cos cos cos  α α  β β  + −  cos sin sin sin  α α  β β      see Appendix B, Section B.4 . Since we took the absolute value of the angle θ,  we need to negate the value of the sine function if θ is negative.    The code for implementing this method is shown in Listing 16.1. We use a  256-entry lookup table containing Vector2D objects, where the i-th entry holds  π i in the x and y components, respectively.  the cosine and sine of the angle  2 256   16.2     16.3    Listing  16.1.  This  code  calculates  the  cosine  and  sine  of  the  32-bit  floating-point  value  f  and  returns  them  in  the  x  and  y  components  of  a  two-dimensional  vector,  respectively.  The  lookup  table from which the values of sin α and cosα are fetched is a global variable named trigTable.   Vector2D CosSin float f   {                          Determine the index i for the lookup table.  float a = fabs f  * 40.74366543F;    float i = floor a ;      40.74366543 = 256   2pi      Determine the angle beta.  float b =  a - i  * 0.0245436926F;        0.0245436926 = 2pi   256      Look up the sine and cosine of alpha, masking the index with     n - 1 so it stays within a single period.  const Vector2D& alphaCosSin = trigTable[ long  i & 255];          16.2  Linear Systems   465      Calculate the sine and cosine of beta.  float b2 = b * b;  float sine_beta = b - b * b2 *  0.1666666667F - b2 * 0.008333333333F ;  float cosine_beta = 1.0F - b2 *  0.5F - b2 * 0.04166666667F ;       Use the angle sum identities to calculate the sine and cosine     of theta. If theta < 0, then negate the sine.  float sine = alphaCosSin.y * cosine_beta + alphaCosSin.x * sine_beta;  float cosine = alphaCosSin.x * cosine_beta - alphaCosSin.y * sine_beta;  return  Vector2D cosine,  f < 0.0F  ? -sine : sine  ;                       }   16.2  Linear Systems   In Chapter 3, we discussed a method for solving linear systems by transforming  the augmented coefficient matrix to reduced form. In this section, we more close- ly  investigate  the  problem  of  solving  nonhomogeneous  linear  systems  and  pay  particular attention to implementation details. The general problem that we ex- =Mx r, where M is an n n×  invertible matrix representing the  amine is written  1n ×  vector of constants. Our  coefficients of a set of linear equations, and r is an  goal is to find the   1n ×  vector x for which the equation   =Mx r is satisfied.   16.2.1  Triangular Systems   A triangular system is one for which the coefficient matrix is either lower trian- gular or upper triangular, as defined by the following.   Definition  16.1.  A  lower  triangular  matrix  L  is  a  square  matrix  for  which  ijL =  when i j< . That is, a lower triangular matrix has nonzero entries only on  and below the main diagonal.   0  Definition  16.2.  An  upper  triangular  matrix  U  is  a  square  matrix  for  which  ijU =  when i j> . That is, an upper triangular matrix has nonzero entries only  on and above the main diagonal.   0   466   16. Numerical Methods   Triangular systems can be solved quite easily using direct substitution. In the  =Lx r, where L is an n n×  lower triangular matrix, we     case of the linear system  can write                        From the first row in the coefficient matrix, we can immediately see that   L 11 L 21  L  n 1            0 0 L 0 22    L L    n  2  nn  x 1 x 2  x  n                      =  r 1 r 2  r n                .   =  x 1  r 1 L 11  .   =  x  2  1 L  22     r 2  −  L x 21 1    .   =  x  i  1 L  ii   − r i   i  − 1    = 1  k  L r ik k   .     If we solve the equation represented by the second row of the coefficient matrix  for  2x , we have   We already know the value of  1x , so it can be substituted into Equation  16.6  to  obtain the value of  2x . Continuing this process, we observe the general formula   This process is called forward substitution. For an n n×  upper triangular matrix  U, a similar process, called backward substitution, allows us to solve the linear  system   =Ux r. In this case, we can write  U U U U 22 2    U 0  U  11  0     0        12  n 1  n  nn  x 1 x 2  x  n                      =  r 1 r 2  r n                .   The last row of the coefficient matrix tells us that   =  x  n  r n U  nn  .    16.4     16.5     16.6     16.7     16.8     16.9     16.2  Linear Systems   467         By substituting into preceding rows, we obtain the general backward substitution  formula   =  x  i  1 U  ii   − r i   n    U r ik k = + k i 1   .      16.10      In the remainder of this section, we examine two methods for solving general  linear systems. Each method transforms the problem into one in which triangular  systems appear. Forward and backward substitution can then be used to obtain a  solution.   16.2.2  Gaussian Elimination  Suppose we have a nonhomogeneous linear system of n equations having n un- =Mx r.  By  performing  elementary  knowns  row operations  see Definition 3.3  on the coefficient matrix M, we can reduce  the linear system to   x   that  can  be  written  as  ,  x x , 1  ,  n  2  ′=Ux r ,   jj  ij  j  M M  j> . If    to row i for each i  The process of transforming the linear system  r   is  known  as  Gaussian  elimination.  For  each  column    16.11     where U is an upper triangular matrix, and the new constant vector  ′r  is the result  ix  are then calculated  of performing the same row operations on r. The values of  using the backward substitution formula given by Equation  16.10 .  =Mx r into the linear system    =  ,  we  ′=Ux 1,2, ijM  below the main diagonal by adding row j multiplied by  eliminate the entries  − jjM = , we must exchange row j with anoth- er row below it before performing the eliminations in column j. It is generally  true that the best numerical stability is achieved by exchanging rows so that the  jjM  is maximized, so we search for the largest entry on or be- absolute value of  low the main diagonal as we process each column. As mentioned in Chapter 3,  this is called pivoting.  Since multiplying any row of the matrix M and the corresponding entry of    the vector r by a nonzero scalar does not alter the solution to the linear system,  we  can  normalize  each  row  of M  so  that  its  largest  coefficient  is  1± .  This  im- proves numerical stability by placing all of the rows on equal ground, avoiding  the possibility that one row dominates the others during pivoting because it has  been scaled by a large value. Normalizing the rows for this reason is called im- plicit pivoting.   n  0  ,   468      16. Numerical Methods   The SolveLinearSystem   function shown in Listing 16.2 solves a linear    =Mx r using Gaussian elimination and implicit pivoting. A  system of the form  disadvantage of Gaussian elimination is that the constant vector r must be known  at the time that the coefficient matrix is transformed into an upper triangular ma- trix. If the solution to the system is desired for multiple values of r  e.g., to calcu- late the inverse of M , then the entire elimination process must be redone. This  limitation is circumvented by LU decomposition, which is discussed in the next  section.   Listing  16.2.  The  SolveLinearSystem    function  solves  the  linear  system  r  using  Gaussian elimination. The return value is false if the matrix M is singular and true otherwise.  Parameters       The size of the matrix M.  A pointer  to  the  entries of  the  matrix  M. The  entries  must  be  stored  in  column- major order. This matrix is transformed into the matrix U appearing in Equation   16.11 .  A pointer to the constant vector r. The solution vector x is returned in this array.   n  m   r      =Mx   *entry = m + i;   bool SolveLinearSystem int n, float *m, float *r   {                                         float *rowNormalizer = new float[n];  bool result = false;       Calculate a normalizer for each row.  for  int i = 0; i < n; i++   {   const float  float maxvalue = 0.0F;     for  int j = 0; j < n; j++                if  maxvalue == 0.0F     }   {   float value = fabs *entry ;      }     if  value > maxvalue  maxvalue = value;  entry += n;   rowNormalizer[i] = 1.0F   maxvalue;   goto exit;         Singular    16.2  Linear Systems      469                                                                                       {      }   maxvalue = p;  pivotRow = i;   {   float p = fabs m[j * n + i]  * rowNormalizer[i];   if  p > maxvalue           }        Perform elimination one column at a time.  for  int j = 0; j < n - 1; j++   {      Find pivot element.   int pivotRow = -1;   float maxvalue = 0.0F;   for  int i = j; i < n; i++                      if  pivotRow != j                                        float denom = 1.0F   m[j * n + j];   for  int i = j + 1; i < n; i++          {   if  pivotRow == -1         Exchange rows.   for  int k = 0; k < n; k++                float temp = r[j];          }     {   float temp = m[k * n + j];      }     {   float factor = m[j * n + i] * denom;     r[j] = r[pivotRow];  r[pivotRow] = temp;    rowNormalizer[pivotRow] = rowNormalizer[j];   m[k * n + j] = m[k * n + pivotRow];  m[k * n + pivotRow] = temp;   goto exit;     Singular   r[i] -= r[j] * factor;    470      16. Numerical Methods      m[k * n + i] -= m[k * n + j] * factor;    for  int k = 0; k < n; k++     }         }       Perform backward substitution.  for  int i = n - 1; i >= 0; i--   {   float sum = r[i];   for  int k = i + 1; k < n; k++  sum -= m[k * n + i] * r[k];    }   r[i] = sum   m[i * n + i];   result = true;    exit:  delete[] rowNormalizer;  return  result ;                                       }   16.2.3  LU Decomposition  Suppose again that we have a linear system of n equations that can be written as  =Mx r. If we can find two matrices L and U, where L is a lower triangular ma- =LU M, then the linear system  trix and U is an upper triangular matrix, such that  =Mx r can be written as     L Ux    =  r.       16.12   =Mx r into the problems of  =Ux y. The solutions to  =Ly r    =Ly r and then solving the system   This transforms the problem of solving the system  solving the system  both of these systems is easily calculated using forward substitution  for  and backward substitution  for  The pair of triangular matrices L and U whose product yields M is called the    LU decomposition of M. Once determined, the LU decomposition of a matrix can  be repeatedly used to solve linear systems having the same coefficient matrix M  and different constant vectors r. In particular, we can calculate the j-th column of  1−M  by setting  i r   We need an algorithm that determines the matrices L and U such that   δ= , where δ is the Kronecker delta symbol.   =Ux y .   ij   16.2  Linear Systems   471                     L 11 L 21  L  n 1            0 0 L 0 22    L L    n  2  nn  U 11 0  0               n  n  1  12     U U U U 22 2    U 0    nn         =  M M  M         11  21  n 1  n 1  n  12     M M M M 22 2    M    M  n  2  nn         .   16.13    When examining how the matrix product LU produces each entry of the matrix  M, we observe the following two summations.   M  ij  =  L U ik  ,  kj  i if   ≤  j     M  ij  =  L U ik  ,  kj  if   i  ≥  j     i    = 1  k  j    = 1  k   16.14     16.15    n+   unknown  values,  and  Equations   16.14   and   16.15   give  a  total  of   j= .   The  nonzero  entries  of  L  and  U  represent   Both  equations  are  valid  for i 2n 2n   equations relating those unknowns. We therefore expect that n of the unknowns  2n  unknowns.  may be arbitrarily chosen, and we can then solve for the remaining  For the method that we present here, known as Doolittle’s method, we set all of  the diagonal elements of L to unity. That is,   iiL  ≡  1,  =  .  n 1,2,  ,  i   16.16     A similar method in which the diagonal elements of U are set to unity is known  as Crout’s method.  To make efficient usage of storage space, we write the val- ues of the remaining nonzero entries of L and U in a single matrix D as follows.   D  11  21  U   L  =  L 31     L   n 1  22  12  U U L 32  L  n  2  n 1  n  n  2  23  13      U U U U U U 33 3    U L                 16.17      j  entry of the matrix M and entries of D in the same column above   3  nn  n   j  entry of the matrix D using only the  ijD  and in  ijU   and  applying   ijD .  Solving  Equation   16.14   for     Doolittle’s method determines the     ,i the  same  row  to  the  left  of  Equation  16.16  gives us   ,i   472   16. Numerical Methods               i  1  =  ijL  gives us  ML U 11 1 U  L  =  i 1  ij  jj  ;      U  1  j  U  ij  =  =  M  ;  1  j  M  ij  −  i  − 1    = 1  k  L U ik  kj  ,  i if   >  1.     16.18    ijU  requires the entries of U in the j-th column above row i and  The calculation of  the entries of L in the i-th row to the left of the main diagonal. Similarly, solving  Equation  16.15  for   M  ij  −  L U ik  kj  , if   j  >    1.  j  − 1    = 1  k       16.19    ijL  requires the entries of L in the i-th row to the left of column   The calculation of  j and the entries of U in the j-th column above and on the main diagonal.  The general procedure for producing the matrix D is to calculate the columns    from left to right. For each column j, we first use Equation  16.18  to calculate  ≤ ≤ . These values are subsequently used in Equation  16.19  to calcu- ijU  for 1 i ijL  at the location  ijL  for  late    j   that  ijM  originally occupied since  entry of the matrix D.    The division in Equation  16.19  requires that we pivot when performing LU  decomposition. We do so for each column j by choosing the largest possible divi- sor from the candidates   j + ≤ ≤ . It is possible to store each value  1j  ijM  is only used in the calculation for the    ijP  given by   ijU  or   i n  ,i   16.20    =  P M ij  ij  − 1  j  −   L U ik  kj     = 1 j= , Equation  16.20  yields   k  j≥ . When i  j> , Equation  16.20  yields   for i jjU  given by Equation  16.18 ; and  when i ijL  given by Equation  16.19 , except that the  ijP  having the largest absolute value  division is not performed. Once the value of  has been identified, we exchange the row in which it appears with row j to move  ijP  in col- ijP  to the main diagonal where it becomes  umn j below the main diagonal are then divided by  ijL . All of this  produces the LU decomposition of a matrix M that is actually the LU decomposi- tion of a permutation of the rows of M. We must keep track of the row exchanges  so  that  they  can  be  accounted  for  when  using  the  matrix  D  to  solve  a  linear  system.   jjU . All of the other entries   jjU  to obtain    16.2  Linear Systems   473         The LUDecompose   function shown in Listing 16.3 performs in-place LU    decomposition of a given n n×  matrix M. Pivoting is performed using the nor- malized rows of M in a manner similar to that used in Gaussian elimination. In  addition  to  returning the decomposed  matrix  D  given  by  Equation   16.17 ,  the  function returns an array of indexes that indicate how the rows were permuted  during the decomposition. All of this information is subsequently passed to the  LUBacksubstitute   function shown in Listing 16.4 to solve a linear system.    After a matrix M has been decomposed into the product LU, its determinant  can be calculated using the equation  U.   16.21     det det 1=L , and the right side reduces  Since the diagonal entries of L are all unity, det to  det± U. Which sign we choose depends on the number of row exchanges per- formed during the decomposition. The LUDecompose   function returns a pari- p = ±  in the  detSign parameter indicating whether the number of row ex- ty  changes performed was even or odd. Since each row exchange negates the de- terminant  see Theorem 3.17 , this value enables us to calculate the determinant  of M using the formula   = ±M  det  L  1  det  M  =  p  det  U  =  p U  .   ii  n  = 1  i   16.22    Listing 16.3. The LUDecompose   function performs the LU decomposition of an n n×  matrix  M. The decomposition is performed in place—the matrix D given by Equation  16.17  is returned  in the space occupied by M. This function also returns an array of indexes that indicate how the  rows were permuted during the decomposition process. The matrix D and the permutation array  are passed to the LUBacksubstitute   function  see Listing 16.4  to solve linear systems. The  LUDecompose   function returns false if the matrix M is singular and true otherwise.  Parameters     n    m     index   The size of the matrix M.  A pointer to the entries of the matrix M. The entries must be stored in column- major order.  A pointer to an array of size n where the row permutation information can be  stored.     detSign  A pointer to a location where the parity of the row exchanges can be stored. This   may be nullptr if this information is not needed.   bool LUDecompose int n, float *m, unsigned short *index, float *detSign   {    474      16. Numerical Methods                                                                                       goto exit;   entry += n;    *entry = m + i;   {   float value = fabs *entry ;   if  value > maxvalue  maxvalue = value;    }     rowNormalizer[i] = 1.0F   maxvalue;  index[i] = i;   float *rowNormalizer = new float[n];  float exchangeParity = 1.0F;  bool result = false;       Calculate a normalizer for each row.  for  int i = 0; i < n; i++   {   const float  float maxvalue = 0.0F;     for  int j = 0; j < n; j++                if  maxvalue == 0.0F       }       Perform decomposition.  for  int j = 0; j < n; j++   {   for  int i = 1; i < j; i++                     Find pivot element.   int pivotRow = -1;   float maxvalue = 0.0F;   for  int i = j; i < n; i++          {      Evaluate Equation  16.20 .   float sum = m[j * n + i];        Singular   {      Evaluate Equation  16.18 .   float sum = m[j * n + i];   for  int k = 0; k < i; k++  sum -= m[k * n + i] * m[j * n + k];    }     m[j * n + i] = sum;    16.2  Linear Systems      475   m[j * n + i] = sum;    sum = fabs sum  * rowNormalizer[i];    for  int k = 0; k < j; k++  sum -= m[k * n + i] * m[j * n + k];         if  sum > maxvalue           }     maxvalue = sum;  pivotRow = i;   goto exit;     Singular                                                                                       {      }                          if  pivotRow != j                                             Divide by pivot element.   if  j != n - 1           }    if  detSign  *detSign = exchangeParity;   {   if  pivotRow == -1         Exchange rows.   for  int k = 0; k < n; k++                unsigned short           }     {   float temp = m[k * n + j];      }      temp = index[j];   m[k * n + j] = m[k * n + pivotRow];  m[k * n + pivotRow] = temp;   index[j] = index[pivotRow];  index[pivotRow] = temp;    rowNormalizer[pivotRow] = rowNormalizer[j];  exchangeParity = -exchangeParity;   {   float denom = 1.0F   m[j * n + j];   for  int i = j + 1; i < n; i++  m[j * n + i] *= denom;  }    476      result = true;   exit:  delete[] rowNormalizer;  return  result ;             }   16. Numerical Methods   Listing  16.4.  The  LUBacksubstitute    function  takes  the  LU-decomposed  matrix  D  and  permutation array returned by the LUDecompose   function  see Listing 16.3  and uses them to  solve  a  linear  system  of n  equations  r  is  solved  using  Equation   16.7 , and then the system  Parameters       The size of the matrix D.  A pointer to the entries of the matrix D. This should be the same pointer that was  passed to the m parameter of the LUDecompose   function.   =Ly y is solved using Equation  16.10 .   r.  First,  the  system   =Mx  =Ux  n  d   index  A  pointer  to  the  array  of  row  permutation  indexes  returned  by  the  LUDecom-  pose   function.  A pointer to an array of n constant values representing the vector r for which the  linear system  A pointer to the array in which the n solutions representing the vector x are to be  returned.   r is to be solved.   =Mx           r   x    const float   *r, float *x    void LUBacksubstitute int n, const float *d, const unsigned short *index,    {                             for  int i = 0; i < n; i++  x[i] = r[index[i]];       Perform forward substitution for Ly = r.  for  int i = 0; i < n; i++   {   float sum = x[i];   for  int k = 0; k < i; k++  sum -= d[k * n + i] * x[k];    }       Perform backward substitution for Ux = y.  for  int i = n - 1; i >= 0; i--   {   x[i] = sum;    16.2  Linear Systems   477    float sum = x[i];   for  int k = i + 1; k < n; k++  sum -= d[k * n + i] * x[k];    }   x[i] = sum   d[i * n + i];           }               16.2.4  Error Reduction  =Mx r and obtained the solution  Suppose that we have solved a linear system  0=x x . Due to round-off error, it is usually the case that  0x  is slightly different  0=Mx r , where  0r  is slightly dif- from the true solution to the system, and thus  ferent from the original constant vector r. Calling the true solution to the system  x, we can write   0  Δ = x x  x and  where  this equation gives us   −  0  Δ = r  r 0  −  r. Subtracting the original system     M x  +   Δ x  = +  r  r,  Δ  Δ=M x  Δ  r.   M x Mx  Δ =  0  −  r    16.23   =Mx r from    16.24     16.25    If we solve Equation  16.23  for Δr and plug it into Equation  16.24 , then we  arrive at the following linear system.   The entire right side of this equation is known, so we can solve for the error vec- tor Δx and subtract from our original solution  0x  to obtain a better answer.    The LURefineSolution   function shown in Listing 16.5 solves the sys- tem given by Equation  16.25  using the same LU decomposition needed to solve  =Mx r. The result is then used to improve the original solu- the original system  0x . The right side of Equation  16.25  is evaluated in double precision since  tion  its value may become very small during its computation. We need both the origi- nal  coefficient  matrix M  and  the  LU-decomposed  matrix D  given  by  Equation   16.17 .  The code  assumes  that  the  matrix  M  has  already  been  copied  and  de- composed  into  the  matrix  D  using  the  LUDecompose    function  shown  in  Listing 16.3.    478   16. Numerical Methods   r.   =Mx  Listing 16.5. The LURefineSolution   function uses Equation  16.25  to improve the solution  x to the linear system  Parameters       The size of the matrix M.  A pointer  to  the  entries of  the  matrix  M. The  entries  must  be  stored  in  column- major order.  A pointer to the entries of the matrix D. This should be the same pointer that was  passed to the m parameter of the LUDecompose   function.   n  m   d      index  A  pointer  to  the  array  of  row  permutation  indexes  returned  by  the  LUDecom-  pose   function.  A pointer to an array of n constant values representing the vector r for which the  linear system  A  pointer  to  the  array  containing  the  n  solutions  representing  the  vector  x.  This  function refines these solutions.   r was originally solved.   =Mx           r   x    *index, const float *r, float *x     const unsigned short  void LURefineSolution int n, const float *m, const float *d,    {                            }   float *t = new float[n];    for  int i = 0; i < n; i++   {   double q = -r[i];   for  int k = 0; k < n; k++  q += m[k * n + i] * x[k];    }    LUBacksubstitute n, d, index, t, t ;  for  int i = 0; i < n; i++  x[i] -= t[i];    delete[] t;   t[i] =  float  q;          16.2  Linear Systems      479   16.2.5  Tridiagonal Systems  =Mx r frequently arises in which each equa- A particular type of linear system  tion has only three nonzero coefficients and those coefficients are centered on the  main diagonal of M. This special form of the coefficient matrix is given the fol- lowing name.   ijM =   whenever  Definition  16.3.  A  square  matrix  M  is  tridiagonal  if  j− > . That is, a tridiagonal matrix has nonzero entries only on the main di- i agonal and immediately above and below the main diagonal.   1  0  A tridiagonal matrix having the property that its diagonal elements are larger than  the sum of the remaining elements in their rows is described using the following  term.   Definition 16.4. Let M be the tridiagonal matrix     =  M  b 1 a 2 0          c 1 b a  2  3  2  0 0 c  0 0 c 0 b 0 3     3     .                   M is diagonally dominant if  nc ≡ .  0  b  i  >  a  i  +  c  i   for all i, where we assume  1 0  a ≡  and    16.26    Suppose we have a linear system   =Mx r of n equations, where M is a tridi-   agonal matrix. It turns out that such a linear system can be solved very efficient- ly. Furthermore, if M is diagonally dominant, then we can prove that a solution  to the linear system must exist.     Expanding the equation   =Mx r, we can write   0 0  0 0  0 0  a  − n 1 0  b n a  − 1  n  − 1  c n b  n  b 1 a  2  0 0           c 1 b  2  0 0  0 c  2  0 0                       x 1 x 2   − 1  x n x  n           =  r 1 r 2   − 1  r n r n                    .       16.27     480   16. Numerical Methods                           The first two rows of the matrix M represent the equations   b x 1 1  +  c x 1 2  =   r 1   16.28    and   We  can  solve  Equation   16.28   for   16.29  to obtain   a x 2 1  +  b x 2  +  c x 2 3  = .  r 2  2 1x   and  substitute  the  result  into  Equation    16.29    b  2  −  a  2  x  2  +  c x 2  3  =  r 2  −  a  2      c 1 b 1      r 1 b 1  ,   which  now  contains  only  two  unknowns  instead  of  three.  Continuing  this  pro- cess, we can write each of the equations as   where   iβ  and   iρ  are constants given by the recurrence formulas   β x i  i  +  c x i  + 1  i  = ,  i  ρ  β  i  =  b  i  −  a  i  ρ  i  = −  r i  a  i  − 1  − 1  i  c i β ρ β  i  i  .    − 1  − 1  =  x  n  ρ β  n  n  .   =  x  i  ρ β  i  i  −  c i β  i  x  .  + 1  i  The equation corresponding to the last row of the matrix M becomes  giving us the value of  nx :   Plugging this value back into Equation  16.31  for  1nx − , and in general,   n= −  gives us the value of   1  i    An implementation of this algorithm is shown in Listing 16.6. The algorithm  c β  calculated with Equation  is begun with  i  16.32  is saved for later use in Equation  16.34 . This implementation assumes   r= . Each value of   b=  and   ρ 1  β  1  1  1  i   16.30     16.31     16.32    β x n  n  ρ=  ,  n   16.33     16.34     16.2  Linear Systems   481            iβ  is never zero, which is guaranteed to be true if the matrix M is diagonally  that  dominant.  The  fact  that  a  diagonally  dominant  matrix  is  always  invertible  is  summarized by the following theorem.   Theorem 16.5. Let M be an n n×  diagonally dominant tridiagonal matrix. Then  =Mx r is always solvable, and as a corollary, the matrix M is  the linear system  invertible.   Proof. Let the entries of M be named as shown in Equation  16.26 . Since M is  iβ   diagonally dominant,   and is therefore never zero.  given by Equation  16.32  always satisfies  1i >   b For  1 that   c> c . Now assume that for any  1  1i = , this is trivially true since  β iβ , we have     for  all i.  We  will  show  that the  value  of   −> c i 1  . For   β i >  =  +  >  a  b  β  c  − 1  1  i  i  i  i  i  β  i  =  b  i  −  a  i  c i β  − 1  − i 1 c i β  i  − 1  − 1  a  i   − 1   ≥  b  i  −  a  i  >  a  i  +  c  i  −  =  c  i  +  a  i  − 1  − 1  i  c i β c i β  i  − 1  − 1   .      16.35    i  − 1  β  −> c i 1  , the quantity  1 c> i  . By in- Since  ix  can  duction, this shows that  always be calculated using Equation  16.34 . The inverse of the matrix M can be  1−M  one at a time.  found by solving the system n times, producing the columns of  The j-th column of   −  for all i. Consequently, the value of each   1−M  is found by setting  i r   is positive, and thus   δ= .    β− 1  c>  β  β  c  − 1  ij  i  i  i  i  i   482   16. Numerical Methods   =Mx  n  a, b, c   r given by Equation  16.27 .   Listing  16.6.  The  SolveTridiagonalSystem    function  solves  a  tridiagonal  system  of  n  equations having the form  Parameters       The size of the tridiagonal matrix M.  Pointers to arrays containing the coefficients  ia ,  arrays are accessed using zero-based indexes, so  and c[n - 1] do not exist and are never accessed.  A pointer to an array of n constant values representing the vector r for which the  linear system  A pointer to the array in which the n solutions representing the vector x are to be  returned.   ≤ ≤ .  These  ic , where 1 i .  The coefficients a[0]   ib , and  1b= b[0]  r is to be solved.   =Mx  x   r   n         const float   *c, const float *r, float *x    float recipBeta = 1.0F   b[0];  x[0] = r[0] * recipBeta;      Allocate temporary storage for c[i] beta[i].  float *t = new float[n - 1];   void SolveTridiagonalSystem int n, const float *a, const float *b,    {                                    }   recipBeta = 1.0F    b[i] - a[i] * t[i - 1] ;  x[i] =  r[i] - a[i] * x[i - 1]  * recipBeta;   for  int i = 1; i < n; i++   {     for  int i = n - 2; i >= 0; i--  x[i] -= t[i] * x[i + 1];   t[i - 1] = c[i - 1] * recipBeta;   delete[] t;       }          16.3  Eigenvalues and Eigenvectors   483   16.3  Eigenvalues and Eigenvectors         Eigenvalues and eigenvectors were introduced in Section 3.5. We have studied  how they are important for performing principal component analysis  see Section  8.1.1  and for determining principal axes of inertia  see Section 14.2.4 . Both of  these  problems  required  calculating  the  eigenvalues  and  eigenvectors  of  a 3 3×   symmetric matrix, and we restrict our discussion to that particular problem in this  section.1     Recall from Section 3.6 that a symmetric matrix M can be written as   =M A DA,   T   16.36    where D is a diagonal matrix whose entries are the eigenvalues of M, and A is an  orthogonal matrix whose columns are the eigenvectors of M. Our strategy in this  0M  of  section is to apply a series of transformations to a given symmetric matrix  the form   k     =M R M R ,  k   16.37   kR  is an orthogonal matrix, in such a way that each iteration moves the  where  kM   closer  to  being  diagonal.  Once  the  off-diagonal  entries  have  been  matrix  made  sufficiently  small   perhaps  even  zero  to  machine  precision ,  we  are  left  with the following.   − 1  T k  k     =M R R  T m  m  T m    R M R R  T 1  − 1  2  1  0     R  16.38   m mM  are the eigenvalues of  R   are  the  corresponding  eigen-  2  1  m  R R  After m iterations, the diagonal entries of the matrix  0M ,  and  the  columns  of  the  product  vectors.  kR  to be a rotation matrix that annihilates one of the    We choose each matrix  1k−M   when  Equation   16.37   is  evaluated.  three  distinct  off-diagonal  entries  of  0M   is  known  as  the  Jacobi  The  use  of  this  process  to  diagonalize  the  matrix  method. Each iteration sets a symmetric pair of off-diagonal entries to zero, but  also undoes previous annihilations. We will show, however, that the off-diagonal  entries become smaller in magnitude as a group and eventually vanish.  kR  may assume one of the follow-   ing three forms, where s and c represent the sine and cosine of a rotation angle θ.                                                         1 For a treatment of larger and nonsymmetric matrices, see William H. Press et al., Nu- merical Recipes in C, Cambridge, 1988.   0M , the rotation matrix   For a 3 3×  matrix    484   16. Numerical Methods                                   12     R  c   = − s  0    s c 0 1  0   0 ,       13     =  R  c 0 − s        s  0   1 0 ,  0    c        23  =  R  1 0 0        0 c − s  0 s c            16.39    Suppose that we use one of the matrices    matrix  entries of     ′M , we obtain the following relationships.   ′M  through the formula    pqR  to transform the matrix M into the  ′ =M R MR . By explicitly calculating the    Tpq  pq        if   i  ≠  p   and   i  ≠  q ;      16.40         −  M M = M = M  ii cM sM  − +  sM cM  iq  iq  ip  ip  ,  ′ = ii ′ ip pi ′ iq qi , ′ = pp ′ = qq  M  M  M  ′ ,pq qp  =  c M 2  pp  +  s M 2  qq  2  scM     pq  s M 2  pp  +  c M 2  qq    pq  +    2  +  scM       −  2  pp  qq  M  sc M  pqR  to annihilate the    c     −     s M 2     pq  We use the rotation matrix  need to choose the angle θ so that      ,p q  entry of M and therefore   pqM ′ = . Equation  16.43  thus becomes   0  Using the trigonometric identities   2  s  M  =  2  c  − sc  M  qq  .   − pp M  pq  sin 2 cos2  α α  = =  2sin cos − cos  α α  α sin  2  2  α      see Appendix B, Section B.4 , we define u as   =  u  1 θ tan 2  c  =  2  2  − s sc 2  M  =  − pp M 2  M  qq  .   pq  We could now determine the angle θ by calculating  can be found much more efficiently by observing that   − 2 tan u 1 1 1  . However, c and s   2  t  +  ut 2  − = ,  1 0   16.41     16.42     16.43     16.44     16.45     16.46     16.47     16.3  Eigenvalues and Eigenvectors   485                     and   t where   =  s c  =  tan  θ  . Applying the quadratic formula, we have   = − ±  u  t  u  + .  2 1   16.48    For best numerical stability, we want to choose the smaller of the two angles of  rotation represented by this equation. The smaller value of t is given by      t  =    .  0u = .  If u is so large that  1t =  when   In this case, we need    θ ≈  , we assign  produces a floating-point infinity  possible when  cause        u 1=  so that       sgn 0    u 1 2  + − 1  sgn  =  u  u  0  t  2  2u    be-   16.49         u  sgn  2  u  + − 1  u     2  2  u u  + + 1 + + 1  u u  =  sgn u 2      u + + 1     u  Using the identity  2 t pute the values of c and s as follows.   + = 1 1  c  2    see Appendix B, Section B.3 , we can now com-    When calculating the entries of  then solve Equation  16.43  for   ppM  and      ct  s ′M , we simply assume that    16.52   pqM ′ = . We can   0  lim →∞ u  u  + = .  2 1 1 u  1 2  t  +  1  c  =  =  2  s  qqM :  − sc − sc  s  2  2  c  2  c  M  pq  M  .   pq  M  pp  =  M  qq  +  M  qq  =  M  pp  −  Plugging  this  value  of  Equation  16.42  gives us the much simpler expressions   qqM   into  Equation   16.41   and  this  value  of   ppM   into    16.50     16.51     16.53     486   16. Numerical Methods   and                  M  ′ = pp  c M 2  +  s M 2  pp  pp  −  =  M  pp  tM  pq      2  s  −  2  c  − sc  M  pq  −  2  scM  pq      M  ′ = qq  s M 2  qq      2  s  +  2  c  − sc  =  M  qq  +  tM  .  pq  M  pq  +  c M 2  qq  +  2  scM  pq             16.54     16.55      To see that the Jacobi method converges to a diagonal matrix, we examine  the sum of the squares of the distinct off-diagonal entries. For the matrix M, the  sum S of these three entries is   =  S M M M   16.56   . Using Equation  16.40  to calculate the same sum S′ for the ma-  2 pq  ,   2 ip  2 iq  +  +  ≠  p q ,  i  where  trix   ′M  gives us   ′  S  = =    cM M 2 ip  ip +  − M  sM 2 . iq     2  +     sM cM  ip  +  iq     2  +     M     ′ pq  2  iq      16.57    2  Thus, choosing a nonzero entry to serve as  pqM  guarantees that the sum of the  pqM . Over many iterations, the  squares of the off-diagonal entries decreases by  sequence of sums decreases monotonically and has a lower bound of zero, so it  must converge to zero.  The  CalculateEigensystem    function  shown  in  Listing  16.7  imple-   ments the Jacobi method for finding the eigenvalues and eigenvectors of a 3 3×   symmetric matrix M. It annihilates the    1,3  entry, and  finally the    2,3  entry. This process of cycling through the off-diagonal entries,  each iteration of which is called a sweep, is repeated until the total size of the off- diagonal entries falls below a small positive threshold or a maximum number of  sweeps have been executed.    1,2  entry of M, then the     16.3  Eigenvalues and Eigenvectors      487   Listing  16.7.  The  CalculateEigensystem    function  calculates  the  eigenvalues  and  eigen- vectors of a 3 3×  symmetric matrix.  Parameters     The 3 3×  matrix for which eigenvalues and eigenvectors are to be calculated. This  matrix must be symmetric.   m        lambda  A pointer to an array where the three eigenvalues are to be returned.  r   A  3 3×   matrix  whose  columns  contain  the  eigenvectors  upon  return.  The  i-th  column corresponds to the i-th eigenvalue returned in the lambda array.   const float epsilon = 1.0e-10F;  const int maxSweeps = 32;    void CalculateEigensystem const Matrix3D& m, float *lambda, Matrix3D& r   {                                                     float m11 = m 0,0 ;  float m12 = m 0,1 ;  float m13 = m 0,2 ;  float m22 = m 1,1 ;  float m23 = m 1,2 ;  float m33 = m 2,2 ;    r.SetIdentity  ;  for  int a = 0; a < maxSweeps; a++   {      Exit if off-diagonal entries small enough.   if   Fabs m12  < epsilon  &&  Fabs m13  < epsilon  &&          Annihilate  1,2  entry.   if  m12 != 0.0F                      {   float u =  m22 - m11  * 0.5F   m12;   float u2 = u * u;   float u2p1 = u2 + 1.0F;   float t =  u2p1 != u2  ?       float c = 1.0F   sqrt t * t + 1.0F ;   float s = c * t;     u < 0.0F  ? -1.0F : 1.0F  *  sqrt u2p1  - fabs u    : 0.5F   u;    Fabs m23  < epsilon   break;              488      16. Numerical Methods                                                                                    {   float temp = c * r i,0  - s * r i,1 ;      }   r i,1  = s * r i,0  + c * r i,1 ;  r i,0  = temp;   m11 -= t * m12;  m22 += t * m12;  m12 = 0.0F;     m23 = s * m13 + c * m23;  m13 = temp;              float temp = c * m13 - s * m23;         for  int i = 0; i < 3; i++             }                                         Annihilate  1,3  entry.   if  m13 != 0.0F                                                {   float u =  m33 - m11  * 0.5F   m13;   float u2 = u * u;   float u2p1 = u2 + 1.0F;   float t =  u2p1 != u2  ?       float c = 1.0F   sqrt t * t + 1.0F ;   float s = c * t;             float temp = c * m12 - s * m23;         for  int i = 0; i < 3; i++            m11 -= t * m13;  m33 += t * m13;  m13 = 0.0F;     m23 = s * m12 + c * m23;  m12 = temp;     {   float temp = c * r i,0  - s * r i,2 ;     r i,2  = s * r i,0  + c * r i,2 ;          u < 0.0F  ? -1.0F : 1.0F  *  sqrt u2p1  - fabs u    : 0.5F   u;    16.3  Eigenvalues and Eigenvectors      489     u < 0.0F  ? -1.0F : 1.0F  *  sqrt u2p1  - fabs u    : 0.5F   u;          }       }     r i,0  = temp;     m22 -= t * m23;  m33 += t * m23;  m23 = 0.0F;                 Annihilate  2,3  entry.   if  m23 != 0.0F                                                     }    lambda[0] = m11;  lambda[1] = m22;  lambda[2] = m33;   {   float u =  m33 - m22  * 0.5F   m23;   float u2 = u * u;   float u2p1 = u2 + 1.0F;   float t =  u2p1 != u2  ?       float c = 1.0F   sqrt t * t + 1.0F ;   float s = c * t;             float temp = c * m12 - s * m13;         for  int i = 0; i < 3; i++             }   m13 = s * m12 + c * m13;  m12 = temp;     {   float temp = c * r i,1  - s * r i,2 ;      }   r i,2  = s * r i,1  + c * r i,2 ;  r i,1  = temp;                                                                           }    490   16. Numerical Methods   16.4  Ordinary Differential Equations                  In  this  section,  we  study  methods  for  numerically  solving  first-order  ordinary  differential equations. We can always write such equations in the form     ′ y x     =    f x y ,     ,    16.58    where f is a function that we are able to evaluate for any given values of x and y.  Most differential equations encountered in a physical simulation are second-order  or higher, but we will be able to show that the ability to solve first-order equa- tions also gives us the ability to solve equations of any order by writing them as a  system of first-order equations.   16.4.1  Euler’s Method  Euler’s method is an extremely simple technique for approximating values of the      y x   to  the  differential  equation  given  by  Equation   16.58 .  Coupled  solution  with this simplicity is low accuracy, so we describe Euler’s method now only as  an introduction to later discussions of more effective methods.    mate the value of the function y at  Writing the derivative     y x , and we wish to approxi- + , where h is some small step size.  h  Suppose that we know an initial state  0   0  as a finite difference, Equation  16.58  becomes    y x    y x′  y=   0  =  −  x  x  y     0   16.59    0  + h h  0  =    f x y ,    .   Solving for    y x  0     h+ , we have    y x    =    This gives us the state   repeated. The general formula for Euler’s method is thus   0   h y x ,  hf x y ,    from which the process can be    16.60    x y , 1  0    +  +  h  h  .   y  x     1  0  0  +     =  +        Let  us  consider  as  an  example  a  projectile  moving  under  the  influence  of     gravity. Its equation of motion is   x y  + 1  i  + 1  i  = =  + +  x i y  i  h hf x y ,     i  i     .       ′ y t  =  v  0  − ,  gt   16.61     16.62     16.4  Ordinary Differential Equations   491         where t is time, y represents the height of the projectile,  0v  is the initial vertical  velocity, and g is the  positive  acceleration of gravity.  We assume the horizon- tal  velocity  is  constant.   We  can  use  Euler’s  method  to  move  from  the  point  t y  to the point     ,i     by evaluating the equation   y+ , 1  + 1     t  i  i  i  y  + = 1  i  y  i  +    h v  0  −     .   gt   16.63    = , which we know to be  0  Figure  16.1  shows  the  exact  solution  to  Equation   16.62   for    and     0 y 2 , and the approximation to the  0.1s .  projectile’s position calculated using Euler’s method with a step size of  The minimal accuracy of Euler’s method is clearly demonstrated by the diver- gence of the two curves. We could improve the situation by decreasing the step  size h, but doing so requires more evaluations of Equation  16.61 .   6 m s      y t  h =  v t 0  gt  −  =  1 2  v = 0  y  Figure  16.1.  The  solution  to  the  differential  equation  v = 0 Euler’s method with a step size of   = ,  0 . The piecewise curve is the approximation calculated using   9.8 m s  6 m s  , and   0.1s  g =  h =  =  .   y  v  2  0      ′ y t     0  x   −   with   gt   492   16. Numerical Methods                     16.4.2  Taylor Series Method  Any method for approximating the solution to a differential equation by taking  one step at a time assumes the form     +  =  +           hF x y ,  i  i  ,    16.64      y x  i    y x  i  h     where the function F is some function that produces an approximation to the de- rivative of y over the interval [ h+ . For Euler’s method, the function F is  simply the function f. To find a function F that achieves greater accuracy than  that provided by Euler’s method, we consider the Taylor series  see Appendix D   of    y x  x x ,i  h+  :   ]     i  i    y x  i  +     h  =    y x  i     +    hy x  ′  i     +  ′′     y  x  i     +        3  y  x  i     +.    16.65    h 2 2!  For a differential equation written in the form of Equation  16.58 , the derivatives  of        y x  can all be calculated using the relationship    .           x n      − 1  x y ,  =  y  f  n      16.66    By taking      y x  h+  1k −  derivatives, we can calculate the Taylor series approximation of   to k-th order in the step size h, yielding   i    y x  i  +     h  ≈  y  i  +     hf x y ,  i  i     +  ′     f  x y , i  i     +  +     k      − 1  f  x y , i  i     ,    16.67    =    y x     i  i  y  . When   where   16.67  in the form of Equation  16.64 , we have     +  =  +          y x  i    y x  i  h  hT x y ,  k  i  i    ,   1k = , this reduces to Euler’s method. Writing Equation    16.68    where   T x y  is defined as  k  ,  i  i           T x y , k  i  i     =    f x y ,  i  i     +  ′     f  x y , i  i     +  +     k      − 1  f  x y , i  i     .    16.69    This is known as the k-th order Taylor series method.    of   Since y is a function of x, we must be careful to evaluate the total derivatives    f x y  in the Taylor series. The first derivative is      ,  h 3 3!  h k  k !  h k k  − 1 !  h 2 2!  h 2 2!   16.4  Ordinary Differential Equations   493                  ′     f  x y ,     =    f x y ,     +    f x y ,     ∂ ∂ y  dy dx  .   ∂ ∂ x   16.70    Since   dy dx  =    f x y ,    , this becomes   ′     f  x y ,     =    f x y ,     +    f x y ,       f x y ,     .    16.71    ∂ ∂ x  ∂ ∂ y    f x y  quickly become very messy, but we could theoreti- Higher derivatives of  cally compute them to construct the k-th order Taylor series approximation. The  function f may have a form that enables easy calculation of its derivatives.      ,  16.4.3  Runge-Kutta Method  Because of the necessity of calculating derivatives, the Taylor series method is  not commonly used. Everything that we have examined so far in this section has  served as a prelude to our discussion of the Runge-Kutta method, a reliable and  accurate technique for numerically solving most differential equations that arise  in physical simulations appearing in a 3D graphics application.  1iy +  by choosing  iy  to      the function F in Equation  16.64  to be one that evaluates  f x y  at multiple  , points and takes a weighted average to approximate the derivative of  y. In gen- eral, the function F has the form   The Runge-Kutta method determines how to step from         F x y ,  i  i        w f u v ,  j  j  j     ,   m  =   = 1  j   16.72    i        x y , and  ,i  f x y  is evaluated, each point          jw  is the weight associated with the j-th point. The  F x y  matches a k-th order Taylor series  T x y  given by Equation  16.69 . This is accomplished without hav- k  where m is the number of points at which  lies near the point     points and weights are chosen so that    function  ing to evaluate derivatives of f.    er a two-stage Runge-Kutta method in which the function F has the form   The value of m is called the number of stages of the method. We first consid-  u v ,j  ,    ,i     ,  i  i  i  j     F x y ,  i  i     =     w f x y , 1  i  i     +    w f x  2  i  +  ah y ,  i  +     ahf x y ,  i  i        .    16.73    1w ,  We would like to choose  order  Taylor  series  function  ah y goal, we expand  , i    f x  +  i  2w , and a so that this function matches the second-     T x y   as  closely  as  possible.  To  achieve  this  2 + ahf x y ,   in a Taylor series as follows.   ,i          i  i  i   494   16. Numerical Methods                          f x  i  +  ah y ,  i  +        i     ahf x y , ∂ ∂ x  ah  i     +  =  f x y ,    i  i     f x y   ,  i  i     +  f x y   ,  i  i     f x y   ,  i  i     +  R      16.74    ∂ ∂ y      The remainder term R involves only higher powers of ah. Using this expansion,  the function F can be written as      F x y ,  i  i     =  w ah  2     +  i  i  2        +    w w f x y , 1 ∂ ∂ x  f x y ,    +     i  i      ∂ ∂ y  f x y ,    i  i     f x y ,    i  i     +  w R .   2   16.75    The Taylor series function   T x y  is given by  2  ,i  i           T x y , 2  i  i     =    f x y ,  i  i     +    f x y ,     +    f x y ,       f x y ,      16.76     .     h 2  ∂ ∂ x          ∂ ∂ y  Equating like terms in Equations  16.75  and  16.76   ignoring the term contain- ing R , we see that the weights   1w  and  2w  must satisfy  + w w 1 aw    = 1 = .  1 2  2  2   16.77      = 2 1 2       = − w 1 1 1 2  a  w    and   .  The  value  of  a  is  unrestricted,  but  we  Thus,  should use a quantity that keeps the second point sampled in Equation  16.73  in  the neighborhood of the point       F x y  into Equation  16.64 .   0w =  and produces the following step after plugging   a   x y .  ,i  Choosing  ,i  a =  forces      1 2  1  i  i  y  + 1  i  =  y  i  +   hf x    i  +  h 2  ,  y  i  +    f x y ,  i  i     h 2          16.78    Equation   16.78   is  called  the  modified  Euler’s  method.  If  we  instead  choose  1a = , then the weights are equal, and we have   y  i  + = 1  y  i  +    f x y ,  i  i     +    f x  i  +  h y ,  i  +     hf x y ,  i  i        ] .    16.79    [  h 2  Equation   16.79   is  called  the  improved  Euler’s  method  and  is  also  known  as  Heun’s method.    16.4  Ordinary Differential Equations   495                    Runge-Kutta  methods  having  a  greater  number  of  stages  are  derived  in  a  manner similar to that used to derive the two-stage method, except that higher- order Taylor series expansions are equated. Without concerning ourselves with  the details of the long and uninteresting derivation, we state a popular four-stage  Runge-Kutta method, often called the RK4 method, as follows.   y  i  + = 1  y  i  +  [     K x y ,  1  i  i     +  2  K x y ,  2  i  i        +  2  K x y ,  3  i  i        +     K x y ,  4  i  i     ]     16.80    h 6            K x y ,  1  i  i  K x y ,  2  i  i  K x y ,  3  i  i  K x y ,  4  i  i       =  =       =  =  i  i  ,    f x y , i  + f x    f x     f x  +  +    h 2 h 2 h y ,  ,  i  i  +  y  i  +  y  i  i +  i  i  1        K x y ,  h 2 h 2 hK x y ,    K x y , i 2           i  3  i  i           The RK4 method is usually more than adequate for the types of real-time simula- tions encountered in a 3D game application. The calculation of Equation  16.80   is  very  straightforward  and  also  rather  efficient  for  the  accuracy  that  the  RK4  method provides.   16.4.4  Higher-Order Differential Equations   We  mentioned  earlier  that  a  higher-order  differential  equation  could  be  trans- formed into a system of first-order differential equations, allowing us to solve it  numerically using the methods already presented. First, let us consider a second- order differential equation   This can be expressed as the following pair of first-order equations.   ′′     y     x  =    f x y y ,  ,  ′     .     ′ y x   ′ z x       = =      z x   f x y z , ,  0        Given initial conditions  ing Euler’s method by applying the following step formula.   0  0    y x   0  y=   and    z x  z= , we can solve this system us-   16.81     16.82     16.83     496   16. Numerical Methods                  x i y z  i  + 1  + 1  i  + 1  = = =  + + +  x i y z  i  i  h hz hf x y z ,  i    ,  i  i        i  ′ z 1 ′ z 2      x     x      x     x  z z  2  3  = =  =  z  ′ n      x   y x′=    f x z z ,  ,  1  2     ,  ,  z  ,  n  In  general,  an  n-th  order  differential  equation   y   can be written as the system of n first-order equations         n     x  =    f x y y ,  ,  ′  ,   16.84    1      y − n  ,         where  x press this as the vector first-order differential equation     ,  and  so  on  to       y x      x  2z  nz  1z  =  ,   x        =  y     − 1n        x  .  We  can  ex-    where      x  z  =       x z ,  2      x  z  1   ,  ,  z  n   and   ′        =      , z ,   x  f  z    x    x            f  x  ,  z     =  z z  2  3      x     x  z  2  .            f x z ,  ,  1   ,  ,  z  n     The vector analog of Equation  16.64  is     +  =        z  x  i  h  z     +  F h     x  i  ,    z ,  i  x  i   16.85     16.86     16.87     16.88      xF     where  method, or Runge-Kutta method that is simply calculated componentwise.   z  is a vector function representing an Euler method, Taylor series  i  ,i  Chapter 16 Summary   Linear Systems  The solution to a linear system  trix, can be found by forward substitution:   =Lx r, where L is an n n×  lower triangular ma-   Chapter 16 Summary   497                  The solution to a linear system  trix, can be found by backward substitution:   =Ux r, where U is an n n×  upper triangular ma-  =  x  i  1 L  ii   − r i   i  − 1    = 1  k  L r ik k   .     =  x  i  1 U  ii   − r i   n    U r ik k = + k i 1   .     A matrix M can be decomposed into the product LU, where L is lower triangular  =Mx r  and  U  is  upper  triangular,  using  Doolittle’s  method.  The  linear  system  r, which can be solved in two stages by first using for- then becomes  =Ux y.  ward substitution to solve   =Ly r and then backward substitution to solve   L Ux    =     Eigenvalues and Eigenvectors  The eigenvalues and eigenvectors of a 3 3×  symmetric matrix M can be numeri- cally  calculated  by  applying  the  Jacobi  method  to  diagonalize  M.  When  M  is   pqR  given by Equation  16.39 , the  transformed by one of the rotation matrices  new entries of M are given by      if   i  ≠  p   and   i  ≠  q ;           M M = M = M  ,  ii cM sM  ′ = ii ′ ip pi ′ iq qi , ′ = pp ′ = qq ′ pq qp  ,  M M M  M M =  pp  qq 0,  ip  ip − +  − +  sM cM  iq  iq  tM tM  pq  pq     where t  s c= .   Ordinary Differential Equations  The first-order ordinary differential equation  ed using Euler’s method as follows.  + = 1  +  y  y        i  i  hf x y ,  i  i            ′ y x  =    f x y ,      can be approximat-  The  improved  Euler’s  method,  also  known  as  Heun’s  method,  uses  the  step  formula    498   16. Numerical Methods   y  + = 1  i  y  i  +    f x y ,  i  i     +    f x  i  +  h y ,  i  +     hf x y ,  i  i        ] .   [  h 2  The RK4 method has the following formulation.   y  + = 1  i  y  i  +     +  2  K x y ,  2  i  i        +  2  K x y ,  3  i  i        +     K x y ,  4  i  i     ]    i  1     [  K x y ,  h 6 K x y ,  1  i  i  K x y ,  2  i  i  K x y ,  3  i  i  K x y ,  4  i  i            i       =  =       =  =  i  i  ,    f x y , i  + f x    f x     f x  +  +    h 2 h 2 h y ,  ,  i  i  +  y  i  +  y  i  i +  i  i  1        K x y ,  h 2 h 2 hK x y ,    K x y , i 2           i  3  i  i           Exercises for Chapter 16   1.  Extend the Jacobi method to find eigenvalues and eigenvectors for an n n×   symmetric matrix M. Modify Listing 16.7 so that it cycles through all of the  off-diagonal entries, annihilating them one at a time.     2.  Calculate the second total derivative of     f x y x  necessary to implement         ,  the third-order Taylor series method.   Implement  the  improved  Euler’s  method   Heun’s  method   and  apply  it  to  the case of a projectile under the influence of gravity. Show that this method  −  no matter what step  gives the exact solution to the equation  size is used.       ′ y t  gt  =  v  0  Implement the RK4 method for first-order differential equations.   Implement  the  vector  form  of  the  RK4  method  and  apply  it  to  the  exact  equation of motion for a pendulum given by Equation  14.126 .               3.   4.   5.       Appendix A   Complex Numbers   A.1  Definition   The set of complex numbers  is a field containing the set of real numbers  and  the “imaginary” number i. The number i is defined to be the square root of  1− :     Thus, the square root of any negative number  n−  can be written as   i = − .  1  A complex number z is one of the form   − = n  i n  .   z  = + ,  a bi  where a and b are real numbers. The number a is called the real part of z, denot- Re z ,  and  the  number  b  is  called  the  imaginary  part  of  z,  denoted  by  ed  by      0a = , then the number z is  Im z . If  purely imaginary.       0b = , then the number z is purely real. If   A.2  Addition and Multiplication   The sum of two complex numbers a bi+  and c di+  is given by      +  a bi     +     + c di     =     + a c     +       b d i  +  .    A.4    The product of two complex numbers can be calculated by using the distributive  property and the fact that  2  i = − . The product of a bi+  and c di+  is given by      1 + c di  ac bd   A.5    a bi    bc i  ad  +  −  +  +  =  .                      A.1     A.2     A.3    499                              500   A. Complex Numbers   Addition and multiplication of complex numbers are both commutative and asso- ciative. This means that for any three complex numbers  1z ,  2z , and  3z , the follow- ing properties hold.   z  a    b      c    d      + z 2 + z =    1 z 1 z z 1 2 z z 1 2  = z   + 2 z z 2 1 = z  +   z 2 1 = z z   z     3  1  3  z z 2 3        +     z  2  +        z  3  1  A.3  Conjugates and Inverses   The conjugate of a complex number z  = +  is denoted by z  and is defined as  a bi = − .  a bi   A.6    z  The conjugate of z has the same components as the number z itself, except that  the imaginary part is negated. Taking the product of z and its conjugate z  yields   zz  =     a bi a bi  −  +         =  2  a  +  b  2  .    A.7    Thus, the product zz  is a real number that reflects the magnitude of the number z.  We use this to define the absolute value of a complex number, which is some- = +  is denoted  times called the modulus. The modulus of a complex number z by  z  and is defined as   a bi  =  z  zz  =  2  a  +  2  b  .    A.8    a  bi  2z  Let  1z  = +  and   If z is purely real, then this definition reduces to that of the ordinary absolute val- ue for a real number.    z determine the value of the quotient  1 nominator by the conjugate of  2z . This gives us  + a bi c 2  z ≠ . We can  z  by multiplying the numerator and de- 2  = +  be complex numbers such that   + a bi c di + c di c di  − c di d 2  + a bi + c di   A.9       +  z z  − −  z z  di  =  =  =  =  .   0  c  z           ⋅  1  2  2  1  2  2  2  We now have a way to define the inverse of a nonzero complex number z, which  we denote by   1z − , as follows.    A.4  The Euler Formula   As shown below, the product of a complex number z and its inverse is 1.   − = 1  z  z z     2  − = 1  zz  zz z 2  =  zz zz  =   1  A.4  The Euler Formula   501    A.10     A.11    A  fascinating  property  of  complex  numbers  ties  exponential  and  trigonometric  functions together. For any real number x representing a radian angle of measure,  we have the following identity.   ixe  =  cos  x  +  i  sin  x      A.12    This equation is known as the Euler formula and can be used to derive a multi- tude of trigonometric identities  see Appendix B, Section B.4 . The formula can  ixe  into its power series and collecting real  be verified by expanding the function  and imaginary terms, as shown in Appendix D, Section D.3.  The complex plane is a 2D coordinate system having a real axis and an imag-   inary axis that are perpendicular to each other. As shown in Figure A.1, a com- plex number z can be uniquely identified by its absolute value and the angle that  it forms with the real axis in the complex plane. This angle is called the argument  of a complex number and is denoted by arg z. One possible value of the argument  of z  = +  is given by   a bi  arg  z  tan     = sgn      tan  − 1  b a     b  − 1  b a  ,  π 2 +  ,  if   a  >  0;  if   a  =  0;     sgn      b π  ,  if   a  <  0.   A.13    Any angle differing from the value given by Equation  A.13  by a multiple of 2π  is also correct.    We can now express any complex number z as   z  re=  iθ  ,    A.14                       502   A. Complex Numbers                  Im  z  z  arg z  Re     Figure A.1. A complex number z can be expressed in terms of its distance  z  from the  origin and the angle arg z that it forms with the real axis in the complex plane.   z=  and  where r 2π, we know that   =  θ  arg  z  . Since the sine and cosine functions have a period of   iθe  =    e + i θ  2  πk        for any integer k.    quantity  nz  can be written as   The Euler formula is useful for raising a complex number to a power. The   =  n  z  r e n inθ  =  n  r     cos  + nθ i  sin  nθ    .   In particular, we can calculate the n-th roots of a complex number z by writing      =  re  1  n  z    i θ  +  2  πk        1  n  =  n  r  cos      θ  πk  + 2 n  +  i  sin  πk  θ  + 2 n   ,     where k is an integer. Choosing  ber z. A root ρ is called primitive if the smallest positive power m yielding  mρ is m n= .     The n-th roots of unity can be calculated using the formula   −  produces all n roots of the num- z=    0,1,  =  n  1  k  ,   A.15     A.16     A.17     A.18    2  πki n  e  =  cos  +  i  sin  2  πk n  2  πk n      A.4  The Euler Formula   503         since  and   1r =  and  0 2ρ  are given by   θ =  in this case. For example, the three cube roots of unity   0ρ ,  1ρ ,   ρ  0  =  1  ρ 1  =  cos  +  i  sin  = − +  π 2 3 π 4 3  π 2 3 π 4 3  1 2 1 2  i  i  3 2 3 2  .   ρ  2  =  cos  +  i  sin  = − −   A.19    2ρ  are both primitive roots of unity, and that   ρ= .  Note that  1ρ  and  1 In general, a primitive n-th root of unity generates all the n-th roots of unity when  raised to the powers 1,2,    ,n .    and   ρ=  ρ 2 1  ρ  2 2  2   This page intentionally left blank    Appendix B   Trigonometry Reference   B.1  Function Definitions   For the angle α shown in Figure B.1, the trigonometric functions are defined as  follows.   The relationships among the trigonometric functions listed below follow imme- diately from the definitions.   sin  α  tan  α  =  =  sec  α  =  y r y x r x  cos  α  cot  α  csc  α  =  =  x r x y r =   y  tan  α  sec  α  =  =  sin cos 1 cos  α α  α  cot  α  csc  α  =  =  1 tan 1 sin  α     α  r  x  α  y      B.1     B.2    505   Figure B.1. Equation  B.1  defines the trigonometric functions in terms of the angle α  shown in this triangle.               506   B. Trigonometry Reference   B.2  Symmetry and Phase Shifts   The cosine function is an even function, meaning that it is symmetric about the y  axis.  The  sine  and  tangent  functions  are  odd  functions,  meaning  that  they  are  symmetric about the origin. We thus have the following identities.                     The cosine function produces the same value at an angle α that the sine func- . That is, the graph of the cosine function is identi- 2π  radians. We can     tion does at the angle  cal to the graph of the sine function shifted to the left by  thus formulate the following phase shift identities.   α π+  2  Using the symmetry properties given by Equation  B.3 , we can also state   Shifting the sine or cosine function by a value of π simply negates the values     of the function. This gives us   Again using the symmetry properties of the functions, we can also state   α  sin cos tan         − − −  α α α         = − = = −  sin α cos tan  α     sin cos tan         + + +  α π α π α π         2 2 2  = = − = −  α cos sin cot  α α     sin cos tan         π π π  − − −  2 2 2         α α α  = = =  α cos α sin α cot  .   sin cos tan         + + +  α π α π α π         = − = − =  α sin α cos α tan .     sin cos tan         − − −  π α π α π α         = sin = − = −  α cos tan  α α  .    B.3     B.4     B.5     B.6     B.7                       B.3  Pythagorean Identities   507   B.3  Pythagorean Identities   The  following  identities  arise  directly  from  the  definitions  given  in  Equation   B.1  and the fact that   = .  2  +  y  x  r  2  2  If the angle α satisfies 0  ≤ ≤  α π  2 , then we can write   2  2  2  sin tan cot  α α α  2  + α cos + = 1 sec + = 1 csc  = 1 α 2 α  2     sin  α  =  − 1 cos  2  α  =  cos  α  =  − 1 sin  2  α  =  1 2 1 2  cot  α  +  1  .   tan  α  +  1  B.4  Exponential Identities   The Euler formula states   This relationship can be used to derive several trigonometric identities simply by  applying the laws of exponents. The angle sum and difference identities are given  by the equation   αie  =  cos  + α i  sin  α  .        + α β i  e  =  e e αi  βi  .   Expanding this using Equation  B.10  yields   cos     +  α β     +  i  sin     +  α β     =     cos  + α i  sin  α      cos  + β i  sin  β     .    B.12    By equating the real and imaginary components of one side to those of the other,  we can infer the following.       sin cos cos cos  cos sin sin sin  α β α β  sin cos   B.13    + −  α α  β β  + +  = =  α α  β β             The angle difference identities are derived by negating β as follows.    B.8     B.9     B.10     B.11     508   B. Trigonometry Reference                  sin cos       − −  α β α β       = =  sin cos cos cos  α α  β β  − +  cos sin sin sin  α α  β β      B.14    When the angles α and β are the same, the angle sum identities become   α sin 2 α cos2  2  α α  α sin  = 2sin cos = cos  B.15   = ,  we  can  rewrite  cos2α  in  the  following  1  −  α  .   2  2  sin  α  +  2  cos  α  Using  the  fact  that  ways.   Solving these for   2  sin α and   α cos2 α cos2  = − =  1 2sin α 2cos  2  α 2 −   1  2  cos α gives us  −= 1 cos2 += α 1 cos2  sin  α  α  2  2  2  cos  α  .   2   B.16     B.17    B.5  Inverse Functions     f α  The  inverse    which  are listed in Table B.1.       − 1      x    f α   returns  the  angle  α  for  f x= . The domains and ranges of the inverse trigonometric functions     of  a  trigonometric  function      Function  sin cos tan  x− 1   x− 1   x− 1    Domain  ]1,1− [   ]1,1− [      Range  π π 2, 2 ]0,π   [ π π 2,  2  ]     ]     [  −  [  −  Table B.1. Domains and ranges of inverse trigonometric functions.     As shown in Figure B.2, the inverse sine of x is equal to the acute angle α in  a triangle having an opposite side of length x and a hypotenuse of length 1. Since    B.6  Laws of Sines and Cosines   509               Figure B.2. A triangle representing the inverse sine function.   we know that the third side of the triangle has length  values of the other trigonometric functions at the angle   1 x− , we can derive the  2 sin x− 1  as follows.   Applying  the  same  technique  for  the  inverse  cosine  and  inverse  tangent  func- tions, we have the following.   1  1 x−  2  x     α                 cos sin  − 1  tan sin  − 1       x  x  =  =  − x −  1  2  x     1  2  x  sin cos  − 1  tan cos  − 1  sin tan  − 1  cos tan  − 1  x  x  x  x            =  =  =  =  −  1  2  x  1  2  x  − x x 2 1 2  x  x  +  1     +  1  sin  α  sin  β  =  z c y =   c   B.18     B.19     B.20    B.6  Laws of Sines and Cosines   Consider the triangle shown in Figure B.3 and observe the following.    510   B. Trigonometry Reference               α  y  b  c  γ  a π γ−  β  z  π γ− x     Figure B.3. For the triangle having side lengths a, b, and c, and angles α,  β, and γ, the  law of sines is given by Equation  B.24 , and the law of cosines is given by Equation   B.29 .   Solving these for c allows us to form the equality   The following observations may also be made.   z sin  α  =  y sin  β  .   sin  − π γ  sin  − π γ              =  z a y =   b  a sin  α  =  b sin  .   β  =  Thus, z a side of Equation  B.21  by b y yields the law of sines:   . Multiplying the left side of Equation  B.21  by a z and the right   y b  The same relationship can be derived for the pair of angles α and γ or the pair of  angles β and γ, so we can write    B.21     B.22     B.23     B.6  Laws of Sines and Cosines   511                          Now observe the following Pythagorean relationships in the triangle shown  in Figure B.3.   Solving the first equation for  us   2y  and substituting into the second equation gives   a sin  α  =  b sin  β  =  c sin  .   γ  2  2  x    + +  2  2  y y  = =  b c  2  2        a  +  x  2  c  = =      + a x + b a 2 2  2  2  + b + ax 2  − .  2  x     cos     − π γ     x = .  b  x  = − b  cos  γ  .   The value of x can be replaced by observing   Since   cos     − π γ     = −  cos  γ , we have   Plugging this into Equation  B.26  produces the law of cosines:   2  c  =  2  a  +  2  b  −  2  ab  cos  γ  .   Of course, this reduces to the Pythagorean theorem when γ is a right angle since  cos    = .  2 0  π   B.24     B.25     B.26     B.27     B.28     B.29     This page intentionally left blank    Appendix C   Coordinate Systems   C.1  Cartesian Coordinates   A Cartesian coordinate system is characterized by three mutually perpendicular  axes, usually named x, y, and z. As shown in Figure C.1, a point P can be ex- pressed as   C.1     where i, j, and k are unit vectors parallel to the three axes. The scalars x, y, and z  are the Cartesian coordinates of the point P.   k,  z  j y  i x  P  +  +  =  k  P  z  y  x  i  Figure C.1. Cartesian coordinates.   j          513    514   C. Coordinate Systems               The gradient operator ∇ has the following form in Cartesian coordinates.   In other coordinate systems in which a point P has coordinates u, v, and w, where    v x y z u , , the gradient operator  we can write  follows the chain rule to become   w w x y z ,    u x y z ,    , and     ,   =  =  =  v        ,  ,  ,  ∇  ≡  i  ∂ ∂ x  +  j  ∂ ∂ y  +  k  ∂ ∂ z     ∇ ∇  ′ =  u  +  ∇  v  +  ∇  w  ∂ ∂ u  ∂ ∂ v  ∂ ∂ w  .    C.2     C.3    C.2  Cylindrical Coordinates   A point P is represented by the quantities r, θ, and z in cylindrical coordinates.  As shown in Figure C.2, r is equal to the radial distance between P and the z axis.  The angle θ is called the azimuthal angle, or simply the azimuth, and is equal to  the counterclockwise angle formed between the x axis and the line connecting the  projection of P onto the x-y plane to the origin. The z coordinate has the same  meaning as it does in Cartesian coordinates.   k  r  θ  P  z  i  Figure C.2. Cylindrical coordinates.   j      C.2  Cylindrical Coordinates   515                  The x and y Cartesian coordinates corresponding to a point having cylindrical     coordinates   r θ z  are given by  ,  ,  = =  x y  r r  θ cos θ   sin .  The cylindrical coordinates r and θ can be written in terms of the Cartesian coor- dinates x and y as follows.    r x y z ,   θ x y z ,  y    sgn  cos   C.5         +  =  =  x  y  − 1     ,  ,        2  2  x +  2  x  2  y  The azimuthal angle θ can also be expressed as    C.4     C.6      θ x y z ,  ,     − 1     − 1  tan     = sgn      tan  y x   y  y x  ,  π 2 +  ,  x if   >  0;  if   x  =  0;    sgn       y π  ,  if   x  <  0.   In both Equations  C.5  and  C.6 , the value of θ satisfies  π θ   A  point  P  having  cylindrical  coordinates  Cartesian basis vectors i, j, and k as follows.   − ≤ ≤ .    π  r θ z   is  written  in  terms  of  the  ,  ,  =     P  r  cos  θ     i  +     r  sin  θ     +  j  k  z   C.7    Taking partial derivatives with respect to the coordinates r, θ, and z, and normal- izing gives us the unit vectors ˆr, ˆθ, and ˆz at the point P in the cylindrical coordi- nate system:   =     cos  θ     i  +     sin  θ     j    = −  sin  θ     i  +     cos  θ     j  =  ˆ r  ˆ θ  =  =  ˆ z  ∂ ∂ P r ∂ ∂ P r ∂ ∂ P θ ∂ ∂ P θ ∂ ∂ P z ∂ ∂ P z  =  k  .      C.8                    516   C. Coordinate Systems   The gradient operator in cylindrical coordinates is given by      ′ =  ∇ ∇    r x y z ,  ∂ ∂ θ Using the definitions given in Equation  C.5  for    r x y z  and      ∇  and  tain the following for the gradients   ∂ ˆ ∂z z   ,   θ x y z ,    θ x y z ,    r x y z ,  ∂ ∂ r    .   , ,  ∇  ∇  +  +  .         ,  ,  ,   C.9    θ x y z , we ob-  ,  ,     ∇    r x y z ,  ,     =  ∂ r ∂ x  +  j  ∂ r ∂ y  +  k  ∂ r ∂ z  i  i  =  = =  x i cos ˆ r  x + +  2  θ  +  j  2  y j  sin  θ  y +  2  x  2  y  ∇    θ x y z ,  ,     =  +  k  ∂ θ ∂ z x + y θ cos r  2  2  x     j  i  i  ∂ θ ∂ y +  j  +  ∂ θ ∂ x − y + y θ sin r  2  +      j  i  2  x  −   1 ˆ θ r  =  =  =             C.10     C.11     C.12    Thus, the gradient operator can be written as   ∇  ′ =  ˆ r  ∂ ∂ r  +  1 ˆ θ r  ∂ ∂ θ  +  ˆ z  ∂ ∂ z  .   C.3  Spherical Coordinates   A point P is represented by the quantities r, θ, and φ in spherical coordinates. As  shown in Figure C.3, r is equal to the distance from the origin to the point P. The  angle θ is the azimuth representing the angle formed between the x axis and the  line connecting the projection of P onto the x-y plane to the origin  just as in cy- lindrical  coordinates .  The  angle φ is  called  the  polar  angle  and  represents  the    C.3  Spherical Coordinates   517            k  θ  P  φ  r  i  Figure C.3. Spherical coordinates.   j     angle formed between the z axis and the line connecting P to the origin. The po- ≤ ≤ .  lar angle φ always satisfies 0 φ π   , coordinates   x y z  corresponding to a point having spherical  ,  The Cartesian coordinates   r θ φ  are given by  ,  ,  ,  The spherical coordinates  x y z  as follows.  dinates  ,   r x y z ,   θ x y z ,  ,  ,       =  =  = = =  x y z  θ θ  r r r  φ sin cos φ sin sin φ cos .     r θ φ  can be written in terms of the Cartesian coor- ,  ,   C.13    +  2  x  2  +  2  z  sgn     y  − 1  cos  y    x +  2  x  2  y  z y  +  2  x  2  +  2  z       φ x y z ,  ,     =  − 1  cos   C.14     518   C. Coordinate Systems                     The azimuthal angle θ can also be expressed as shown in Equation  C.6 , and the  polar angle φ can also be expressed as     φ x y z ,  ,       =      − 1  tan  π  2,  − 1  tan  2  x  2  y  ,  + z  + z  2  x  2  y  +  π  ,  if   z  <  0.  if   z  if   z  >  =  0;  0;      C.15      A point P having spherical coordinates  tesian basis vectors i, j, and k as follows.   r θ φ  is written in terms of the Car- ,  ,  =     P  r  sin cos  φ  θ     i  +     r  sin sin  φ  θ     j  +     r  cos  φ     k    C.16    Taking partial derivatives with respect to the coordinates r, θ, and φ, and normal- izing gives us the unit vectors ˆr,  ˆθ, and  ˆϕ at the point P in the spherical coordi- nate system:   =  ˆ r  ˆ θ  =  ϕ ˆ  =  ∂ ∂ P r ∂ ∂ P r ∂ ∂ P θ ∂ ∂ P θ ∂ ∂ P φ ∂ ∂ P φ  =     sin cos  φ  θ     i  +     sin sin  φ  θ     j  +     cos  φ     k    = −  sin  θ     i  +     cos  θ     j  =     cos cos  φ  θ     i  +     cos sin  φ  θ     j    + −  sin  φ     k  .    C.17    The gradient operator in spherical coordinates is given by   ∇ ∇  ′ =    r x y z ,  ,     +  ∇    θ x y z ,  ,     +  ∇  ∂ ∂ r  Using  the  definitions  given  in  Equation   C.14   for      ∇ φ x y z , we obtain the following for the gradients  ,   ∇ φ x y z ,    .   , ,  ∂ ∂ θ  .   ,       φ x y z ,  ∂ ∂ φ     r x y z ,  ,     ∇ r x y z , ,   ,  ,   C.18        θ x y z   and  ,     θ x y z , , and   , ,   C.3  Spherical Coordinates   519               ∇    r x y z ,  ,     =  +  k  ∂ r ∂ z +  j  + +  2  θ  z j  2  2  x θ sin sin  φ  + +  2  2  + cos  z φ  y y k  i  i  j  +  ∂ r ∂ x  ∂ r ∂ y x y i sin cos ˆ r  φ  +  x  2  =  = =  ∇    θ x y z ,  ,     =  +  k  z y  +  2  x  2  +  2  z      C.19    +  k  j  2  x  +  j  ∂ θ ∂ z x + y θ cos   φ r sin   2  i  i  i  2  2  j  +  ∂ θ ∂ y +  ∂ θ ∂ x − y + y θ sin φ r sin ˆ θ  x     −      =  =  =         φ  1 r sin ∂ φ ∂ x  i  +  j  ∂ φ ∂ y  +  k  ∂ φ ∂ z  2  x  +    + y 2 + z 2 cos sin  2  φ r  +  k  − x 2 cos cos  x + θ  2 y +  j  φ r  =  =  i 1 ˆ ϕ r  θ  +  k  −  φ  sin r  ∇    φ x y z ,  ,     =  =  i     2  x  +  2  y  +  xz z 2  +  j     2  y  yz z 2     2  x  +  2  y  +  2  x  +  2  y   C.20        C.21     C.22    Thus, the gradient operator can be written as  ∂ ∂ θ  ′ = r∇ ˆ  1 sin  ∂ ∂ r  φ  ˆ θ  +  r     +  ϕ ˆ  1 r  ∂ ∂ φ  .    520   C. Coordinate Systems   C.4  Generalized Coordinates                  x u u u ,     Let S be a coordinate system in which points are described by three coordinates  1u ,  2u , and  3u , and let    z u u u  be functions that  transform coordinates in S to the corresponding Cartesian coordinates x, y, and z.  Then a point P having coordinates  1u ,  2u , and  3u  in S can be written as     y u u u , and       y u u u ,    x u u u ,    z u u u ,   C.23    k   .  P  =  +  +                    j  i  ,  ,  ,  ,  ,  ,  ,  ,  ,  3  2  1  2  3  1  1  2  3  1  2  3  1  2  1  2  3  3  The contravariant basis vectors  1e ,  2e , and  3e  for the coordinate system S are giv- en by the partial derivatives of P with respect to the coordinates  1u ,  2u , and  3u  as  follows.   =  e  1  =  =  e  2  e  3  ∂ P ∂ u ∂ P ∂ v ∂ P ∂ w  =  =  =  ∂ ∂ u ∂ ∂ v ∂ ∂ w    x u u u ,  ,  1  2  3     i  +    y u u u ,  ,  1  2  3     +  j    x u u u ,  ,  1  2  3     i  +    y u u u ,  ,  1  2  3     j  +  ∂ ∂ u ∂ ∂ v ∂ ∂ w     k     k  3  2  1  ,    z u u u ,  ∂ ∂ u ∂   z u u u , ∂ v ∂ + ∂ w    z u u u ,  ,  ,  1  2  3  1  2    x u u u ,  ,  1  2  3     i  +    y u u u ,  ,  1  2  3     j     k   3   C.24      The scalar quantities   ijg  defined by   g ≡ ij  ⋅e i  e   j   C.25    ij  ji  g  g=  constitute the nine components of the metric tensor, at most six of which are dis- . The metric tensors corresponding to Cartesian coordinates,  tinct since  cylindrical coordinates, and spherical coordinates are displayed in Table C.1.    The metric tensor is used in the generalized formula for the dot product be- tween  two  vectors  in  an  arbitrary  coordinate  system.  The  dot  product  between  two vectors a and b having coordinates in S is given by   The squared magnitude of a vector v is given by its dot product with itself, so we  have   3  3  ⋅ =  a b  = 1  i  = 1  j  g a b ij i  j  .   =  v  3  3  ⋅ =  v v  = 1  i  = 1  j  g v v ij i  j  .    C.26     C.27     C.4  Generalized Coordinates   521            Coordinate System   Cartesian coordinates   Cylindrical coordinates   Spherical coordinates      [  ]  =  ijg  Metric Tensor  1 0 0 0 1 0 0 0 1 1 0 0 1 0 0       0 0 1 0 sin 0                  0 r 2 0  ijg  ijg  =  =  r  ]  ]  2  [  [           2  φ  0 0 r 2           Table C.1. Metric tensors.   This establishes a metric in the coordinate system S and reveals the source of the  metric tensor’s name. If the vector v represents the coordinate difference between  two points, then the metric tensor is used in Equation  C.27  to obtain a  not gen- erally Euclidean  measure of distance between the two points.    To calculate the Euclidean distance between two points, we integrate differ- ential distances along a straight-line path. Straight lines are not generally given  by  linear  functions  of  the  coordinates,  so  we  consider  an  arbitrary  parametric  path     tu  in the coordinate system S. The length L of the path over the interval in  ], [ a b∈ t which    is given by   =  L  b    a  u d dt  dt  1 2  ⋅  u u d d dt dt      dt  b  =         =    a b  a  3  3    = 1  i  = 1  j  g  ij  i  du du dt dt  j      1 2  dt  .   2  ds  3  3  =   = 1  i  = 1  j  g du du ij  i     j   C.28     C.29    The quantity    522   C. Coordinate Systems                     is called the line element and characterizes the differential unit of length in the  coordinate system S. The line element is a generalization of the Pythagorean the-  of Equation  C.29  in Cartesian  orem, of which the familiar form  coordinates is a special case.    mutually perpendicular , we have   In  an  orthogonal  coordinate  system   in  which  the  basis  vectors  are  always   1Σ i  dx  ds  =  3 =  2 i  2  ijδ  is the Kronecker delta. In such a coordinate system, the metric tensor is   where  diagonal, and we define the scale factors   ih  as   The line element reduces to   The volume element dV  in an orthogonal coordinate system is defined as   e  i  ⋅  e  j  =  g δ ij  ,   ij  h i  g≡  .   ii  2  ds  3  =   = 1  i  h du 2 i  2 i  .   3  = ∏   h du i  i  dV  = 1  i   C.30     C.31     C.32     C.33    and characterizes the differential unit of volume. The volume V of space bounded  u by the intervals   ]  is given by   ] u , and   u ,   ∈  ∈  ∈  a b 3, 3  a b 1, 1  a b , 2  [  ]  [  [  2  1  3  2  =  V  b  3  a  3    b  2  a  2    b 1  a 1    dV  =  b 3  a  3    b  2  a  2    b 1  a 1    h h h du du du 1 2 3  2  1  3  .    C.34    The line elements and volume elements corresponding to Cartesian coordinates,  cylindrical coordinates, and spherical coordinates are listed in Table C.2.       Coordinate System  Cartesian coordinates  Cylindrical coordinates  Spherical coordinates   2  2  Line Element  dz dx   2 + dz dr dr φdθ 2  + dy r dθ 2 2 r sin 2  + + +  2  2  2    2  +  r dφ 2  2     Volume Element  dxdy dz  r dr dθ dz  r 2 sin  φdr dθ dφ   Table C.2. Line elements and volume elements.    Appendix D   Taylor Series   D.1  Derivation       f x  be a function whose first n derivatives exist on some interval I. Sup- c=  in I using a degree n       f x  near the value x  Let  pose that we wish to approximate  polynomial   whenever  x  is  small.  The  derivatives  of  lowing.   np  −     c  +  a  2     x  −     c  2        n  n  x  c  a  −  +  +      x   evaluated  at  x  ≈          D.1   f x c=   are  the  fol-      x  so that  np     = x  +  a  0  n    a x 1  p  We can determine the coefficients       ′ p c n     ′′ p c n  a 1 a 22  = =  =  n     n a !          c p n n ia  by requiring that      p c n     ′ p c n     ′′ p c n      = f c     ′= f c     ′′= c f  =          c n  .           c n n  f  p  The polynomial   np      x  is thus given by       x  =      f c  +  ′       c  x  f  −     c  +  p  n  −     c  x  2  +    +  −     c  x  n  .    D.4    f        ′′ c 2!  f            c n n !   D.2     D.3    523                     524   D. Taylor Series                          We define the error term  tion       x  and the actual function value   nr  np      x  to be the difference between the approxima-  f         f x  so that        ′′ c 2!     x  +  +  c  r n  .  n     −     c  x  2  +        f x  =      f c       ′ + f c           c n n !  x  −  x  −  c  f  +      D.5    Let       g z  be the function defined by       g z  =      f x  f  −  f        ′′ z 2!  2  ′  f  f        z  z  x  −  −  −  −  −       z      − z           z n n !     0 g x =  and, using Equation  D.5 , that   x          x  − −  x x  z c       r n  −  −  x  + 1  + 1  z     .  n  n  n        D.6        0 g c = . The   It is easily verified that  derivative of       g z  simplifies significantly to the following.        − x z 1     − c x n          z !      ′ g z  = −  + 1 n  +  −  +  n  x  z        f  n  n     n  + 1  By Rolle’s theorem, there exists a  0z  between x and c such that  uating   nr  and solving for     g z′   0      x  yields      + z 1 0   + 1 !  n n       =  f         x  r n     x  −     c  n  + .  1  If a function       f x  is infinitely differentiable, then we may state       x  = .  0  lim →∞ n  r n      x     r n   D.7      g z′   0  = . Eval- 0   D.8     D.9    We can therefore express any such function        ′′ c 2!      f x      f c  =  −  +  c  x  x     f      f x  as the infinite series   −     c  2  +  −     c  x  3  +    f        ′′′ c 3!       ′ + f c         c k k !  x     f  =  ∞    =  0  k  −     c  k  .  This is known as the Taylor series expansion of the function       f x .       D.10     D.2  Power Series   D.2  Power Series                  Equation  D.10  can be used to derive power series expansions for common func- xe  is equal to its own de- tions by using  rivative and  0 1  0c = . Because the exponential function   e = , its power series is given by   x  e  = + + 1  x  +  x 2 2!  x 3 3!  +  x 4 4!  +    ∞  =   k  =  0  x k  k !  .  For the sine function, we first observe the following.  = 0 = 1 = 0 = − 1  x sin x cos x sin x cos      f 0     ′ f 0     ′′ f 0     ′′′ 0      f x     ′ f x     ′′ x     ′′′ x  = = = − = −  f f  f        The power series for the sine function is thus given by            + −    sin  x  = −  x  −  +  x 3 3!   − 1   k 2  x 5 5! x k k 2   + 1 !  + 1     x 7 7!  .  =  ∞    =  0  k  x 6 6!  + −    cos  x  = − 1  +  x x 2 4 4! 2!     − x 1 k 2     k 2 !  −  k  .  ∞  =   k  =  0      f x  =  1 +   x  1  Similarly, the power series for the cosine function is given by   Another interesting function is   because it is the derivative of  rivatives of       f x  are the following.   ln 1 x+  on the interval          1,− ∞ . The first few de-     525    D.11     D.12     D.13     D.14     D.15     526   D. Taylor Series                     In general, the k-th derivative of       f x  is given by   which when evaluated at      f x  is given by  ries for the function   0x =  produces           k 0    = −    1  f  k  k  . Thus, the power se- !  This series converges on the interval   . Integrating both sides, we arrive at  the following power series for the natural logarithm of 1 x+  on the same interval.    1,1−  ′      x  f  =  ′′      x  f  =  ′′′      x  f  =  2     3     − 1 + x 2 + x − 6 + x    1    1    1     4             x k  =  f      − 1   + x 1  k    k ! + k 1  ,   1 +  1  x  = − +  1  x  2  x  −  3  x  + −    =  ∞      − 1  k  =  0  k  k  x  .       ln 1  +     x  = −  x 4 4  −  + 1  x  +  x 2 2   − 1 + k     ∞  =  k  0  k  x 3 3 x k 1  =  + −        D.16     D.17     D.18     D.19    D.3  The Euler Formula   The Euler formula expresses the following relationship between the exponential  function and the sine and cosine functions.   ixe  =  cos  x  +  i  sin  x     D.20    This can be verified by examining the power series of the function  ixe :    D.3  The Euler Formula         ∞  ix  e  =  .   i x k k k ! i= − , and  4 1  =  0  k  1  i = − ,  3i  Using the fact that  2 nary terms of this series as follows.    − x 1 k     k 2 !    =  e        ix  ∞  =  k  0  2  k  +  i  ∞    =  0  k       − 1   k 2  + 1  x k k 2   + 1 !     i = , we can collect the real and imagi-  Comparing this to Equations  D.13  and  D.14  confirms the result.   527    D.21     D.22     This page intentionally left blank    Appendix E   Answers to Exercises   1.   2.    a   2−    b   2,1, 6−    c   ′ =e  ′ = e e ,  3 2  − − −   , 4 2 9 9 − − 1, 1, 2  e ,  2 1  ′ =e  4 9     ,  1  Chapter 2   3.  17.5   Chapter 3      0  − 1  8  1  8 1 0 0 0 1 0 0 0 1 0 0 0         − 4  − 3  − 7   1      1.    a  22   b   1−    c  1   d  0   2.    a       b    0 0 1 2 0 0 1 3 0 0 1 4              1 3 8     −   3 8  0 1 2 0   c    θ  cos 0 sin     −   θ  0 sin 1 0 0 cos  θ  θ           d       a  =        1 − 2 1  x       y    z       λ = − ,  2 λ = ,  3  2  1  1  λ =   5  3.   4.        529    530      Chapter 4   E. Answers to Exercises   0 3 2 1 2  0 − 1 2 3 2        R ,   y  =   3 2  0  −  1 2  0 1 0  1 2 0 3 2        R ,   z  =  3 2 1 2 0        −  1 2 3 2 0     0 0 1        1.   R  x  =  1 0 0          2.   = ±  q  +  3 2  0,  3 10  ,  2 5       Chapter 5   1.  Any scalar multiple of  2,1,0, 4−    Bottom:   0,  ,  4 5  ; Top:   0,  ,0  3 5     ; Right:   −  −  ,0  ;   2 2  ,0,  2 2 − −  ,  4 5  2.   t    ⋅ = Q S V     − V  2     4.  63.1 degrees  −  5.  Left:   ,0,  2 2  6.   n 2 − l r  0  0  0               n 2 − t b  0  0  0  ,0  2 2 ,0− 3 5 + l r − r l + t b − t b f −  −  n  f − 1  0  0  0                  −  nf −  f  n  Chapter 6   2.  5.3271783     + = 1  3.   x  x  n  n  1 p  p  + − 1  p  rx        6.   − 0.315,0.946, 0.0788  −                7.   V  2 x  +  V  2 y  −  V  2 z  2  t  +  2  S V x  x  +  S V y  y  +      2  2  r h +     r h  +  S  2 x  +  S  2 y  r h  S  z  −  2  r      S  z      −  2  r  =  0  r h   − V r   z  r h  S  z  t          531   1.   r If neither sphere encloses the other,  d = Q Q  Q Q , where   r 1  −  =  +  r        2  1  1     1 2  d  r 1  = + + −Q Q .   2  1     r 2   and   − d s  2.   If s  If s  3.   r = eff  2  2  =  h< ,  r  + h h 2 s=  and  h≥ , r 5 3 1.443   6  ≈   and   Q  =  − 0,0,h r  .   =Q  0,0,0  .   8.  49 degrees   Chapter 7   1.  3.16 meters   2.  4.35 meters   Chapter 8   Chapter 9   1.  1.001   2.  0.006   Chapter 10   1.      ε     −  1   δ   P P z z         +     δ   532   E. Answers to Exercises   P ,  P 1  ′ = 2  P 1  2 3  +  1 3  P ,  2  ′ =P  3  P   2   and   M  R  =  1 8  1 0 0 0   3 2 0 0  3 4 4 0   1 2 4 8             α α  00 i 10 + i 1  − −  − α 00 i − α α 11 10 + i i 1 + α α 01 11 + i i 1 α 01 + i 1  + −  4 4  ,            2 α  00 i + − α 6 10 + i 1 + α 2 6 11 i  α 2   − α α 00 11 i i − − α 10 01 + + i i 1 1 − α 01 + i 1     + − 1  γ  k  j  i  1     ′ =P ,   3  i  β .   ′ =P 3,0 ,  4     2 ,1 5  Chapter 11  ′ =P  1.      2.   3.   0  Q  1 3  +  =  M  P 0  1 8  ′ = P P ,  1 0  2 3 8 4 2 1 0 4 4 3 0 0 2 3 0 0 0 1 = τ  a   iγ + =   0        γ  =   0   b    =  β  1  i  i  i          c    M  KB  =  0   2 1  2 0   0   11 i  − 00 i  α  α 00 i − α α 11 i 0  =    1  −  τ  jk  i      + − 1  α   where  ′ =P  0,0  0  ′ =P ,   1  2 ,1 1      κ t  =  r +  2  r  2  c  ,      τ t  =     i  1   ′ =P ,  c +  2  2  r  2 ,2 3     2  c  4.   5.   Chapter 12  t =  1.   4 s     1 r      2.   =  N  −  Q  ⋅ Q A A 2   A      Chapter 13      + x t     3cos4 x t t  Ae  1.   2.   =  =  3  t  Bte +  3  t  + +   t 1  t sin 4     3.  30.2 m       533   4.  3.93 s   v  0  t ≈  =  a  =  g P h 8   6.1 s g +  M m  [  ,0,  P z  x  +  4  h     −  M m     sin  θ  +  μ  K  cos  θ     ]    Chapter 14  =  1.   F mω ω r 2  2  +  v 24     =  ω  Sμ g r        =C =  I  1 2  5 9  0,0, h   m R 2 1  +  R  2 2          5.   6.   7.   2.   3.   4.            5.  Let   m  cylinder    be  the  mass  of  the  cylinder,  and  let   domem   be  the  mass  of  one   dome-shaped endcap. The diagonal entries of the inertia tensor  are   = =  =   11   22   33  m m  m  2 5  2 5  2 5  dome  dome  dome         2  2  b a  2  a         + +  +  2  2  c c  2  b  + +  3 4  3 4  +  1 4  m hc dome m hc  dome m  cylinder  + +    2  a  1 2  1 2  2  2  m h dome m h dome   + b  .  2  + +  1 4  1 4  m cylinder m  cylinder  b a  2  2  + +  1 12  1 12  m cylinder m  cylinder  h h  2  2     The  off-diagonal  entries  are  zero.  In  terms  of  the  total  mass  m  of  the  capsule, the diagonal entries of the inertia tensor  are   [   m b [   m a [   m a  2 5 2 5 2 5  2  2  2  + + +  2  2  2  c c b         + 3 4 + 3 4 ] +  2  ] + + h 1 2 ] + + h 2 1 2 [   m a 2 1 4  h  hc hc h 3 + c 3  4  [ m b 1 4 [ m a 1 4 ]   .  4  h  h 3 + c 3 h 3 + c h 3 4 + b 2  2  2  + +  2  2  h h  1 12 1 12  ] ]    = = =      11  22  33  4  4  4  h  h  c 2 + c 3 c 2 + c 3 c 2 + c h 3 g I mR  6.   =  a  +  1  =  2  +  1  g M m  2      534   E. Answers to Exercises   7.   =  a  g +  θ sin I mR  2  1  =  5 sin g 7  θ     Chapter 15   8.   =  z  d μ 2 S     1.  1.43 m s   2.   0.0357 s   Chapter 16  ∂ 2 ∂ x  2.   2          f x y ,     +    f x y ,     2    f x y ,     +  [    f x y ,     ]  2    f x y ,       ∂ 2 ∂ ∂ x y  ∂ 2 ∂ y 2  2  +  ∂ ∂ x  ∂ ∂ y    f x y ,       f x y ,     +    f x y ,     ∂  ∂ y    f x y ,             Index     A  acceleration, 409   angular acceleration, 414, 415, 425  centrifugal component, 353  tangential component, 353   acceleration function, 380, 400  alpha test, 8  ambient light, 158–59, 205, 287  amplitude, 432  angular acceleration, 414, 415, 425   of pendulum, 434   angular frequency, 431  angular momentum, 413, 423, 436  angular velocity, 405–7  aspect ratio, 105, 128, 246  asynchronous operation, 1  attenuation constants, 159, 160, 205  auxiliary equation, 382  azimuthal angle, 189, 514, 516   B  backward substitution, 466, 497  barycentric coordinates, 141–43, 154  basis matrix, 319, 356  Beckmann distribution function, 195  Bernstein polynomial, 322, 323  Bézier curve, 322–29  basis matrix, 323  blending functions, 324        control point, 322, 325, 327  de Casteljau algorithm, 327–29, 358  degree elevation, 358  geometry matrix, 323  truncation, 326   bicubic surface, 348, 357   geometrical constraint matrix, 348  normal vector of, 348, 357   bidirectional reflectance distribution   function  BRDF , 187–91, 207   bilinear filtering, 171  billboarding, 254–60, 275   constrained quads, 257–58  polyboard, 258–60  unconstrained quads, 254   binary space partitioning  BSP  tree,   232–34  halfspace, 232  splitting plane, 232   binomial coefficient, 322  binormal vector  of curve, 353   bitangent vector, 181, 183, 206  blending, 9  blending functions, 319  Blinn-Phong shading, 177–78  Böhm subdivision, 345, 359  bounding box   construction, 215–17   535    536      Index   visibility test, 228–30   bounding cylinder   construction, 220–21  visibility test, 226–28   bounding ellipsoid   construction, 218–20  visibility test, 222–26   bounding sphere   construction, 217–18  of cone, 244  visibility test, 221–22   bounding volume   bounding box, 215–17, 228–30, 240  bounding cylinder, 220–21, 226–28,   bounding ellipsoid, 218–20, 222–26,   bounding sphere, 217–18, 221–22,   construction, 211–21  principal component analysis, 212–  242   241   241   15   visibility determination, 221–30   box   bounding box, 215–17, 228–30  collision with plane, 364–66, 376  effective radius, 228, 364  inertia tensor, 421, 427  ray intersection, 143   B-spline, 334–47   basis matrix, 337  blending functions, 337  globalization, 340–41  knot, 335  knot value, 341  knot vector, 341  nonuniform B-spline, 342–45, 355  nonuniform rational B-spline    NURBS , 345–47, 356  uniform B-spline, 335–40   buffer swap, 4  bump map, 4, 178–86   calculating tangent vectors, 180–83  construction, 178–79  tangent space, 180   C  camera space, 5, 103, 116  capsule   inertia tensor, 438   Cartesian coordinates, 513–14  Catmull-Rom spline, 329–30   basis matrix, 330  geometry matrix, 330   Cauchy-Schwarz inequality, 18  center of mass, 410–13, 436   of cone, 411   central processing unit  CPU , 1  centrifugal acceleration, 353  centrifugal force, 407–8, 436  characteristic polynomial, 54  clipping   ear clipping, 268  polygon clipping, 252–54  portal clipping, 236–38, 243   cloth simulation, 457–60  coefficient of kinetic friction, 397  coefficient of static friction, 398  cofactor, 47, 51, 52, 63  collision detection   box and plane, 364–66, 376  collision of two spheres, 372–75, 377  general sphere collisions, 366–71  sliding, 371–72, 377  sphere and plane, 362–63, 376   complex number, 56, 81, 383, 499–503   argument of, 501  conjugate of, 500  imaginary part, 499  modulus of, 500  real part, 499   complex plane, 501  cone   center of mass, 411          537   ray intersection, 155   continuity   geometric, 318  parametric, 318   contravariant vector, 80  control point   Bézier curve, 322, 325, 327  nonuniform B-spline, 342  uniform B-spline, 335, 340   convex hull, 324  Cook-Torrance illumination model,   191–92, 207  Fresnel factor, 192–95, 201, 208  geometrical attenuation factor, 192,   198–200, 203, 208   microfacet distribution function, 192,   195–97, 201, 208   coordinate space   camera space, 5, 103, 116  object space, 5, 141, 180, 207  tangent space, 180, 207  window space, 6  world space, 5   Coriolis force, 408–10, 436  covariance matrix, 212  covariant vector, 80  Cox-de Boor algorithm, 342, 355  Cramer’s rule, 53–54  critical angle, 156  cross product, 19–20, 29   anticommutative property, 25  magnitude of, 22, 29  properties of, 24–25   Crout’s method, 471  cube   principal axes of inertia, 423   cube texture map, 169–71   normalization cube map, 171, 178   cubic spline, 331–34   natural cubic spline, 334   curvature, 350–55, 357  curve   basis matrix, 319  Bézier curve, 322–29  binormal vector, 353  blending functions, 319  B-spline, 334–47  Catmull-Rom spline, 329–30  cubic spline, 331–34  curvature of, 350–55, 357  Frenet frame, 353  geometric continuity, 318  geometry matrix, 319  global control, 331  Hermite curve, 320–21  local control, 331  nonuniform B-spline, 342–45, 355  nonuniform rational B-spline    NURBS , 345–47, 356   normal vector, 351  osculating circle, 352  osculating plane, 352  parametric continuity, 318  radius of curvature, 352, 357  tangent vector, 350  torsion of, 354–55, 357  uniform B-spline, 335–40   cylinder   bounding cylinder, 220–21, 226–28  effective radius, 226, 227  inertia tensor, 418  ray intersection, 145–46, 368–70,   377   cylindrical coordinates, 514–16   D  de Casteljau algorithm, 327–29, 358  decal application, 249–54, 274  del operator, 149  depth buffer, 4, 248, 284, 308–10  depth interpolation, 109–11  depth test, 9  depth value offset, 245–49, 274  determinant, 47–54, 62, 473    538      Index   and handedness, 70   diagonal dominance, 479  diagonal matrix, 31  diagonalization, 58, 64  differential equation, 381–90, 400, 490–  96, 497  auxiliary equation, 382  Euler’s method, 490–91, 497  homogeneous, 381–85  initial conditions, 388–90  nonhomogeneous, 385–88  particular solution, 385  Runge-Kutta method, 493–95, 498  Taylor series method, 492–93  undetermined coefficients, method   of, 386   diffuse lighting, 161–62, 205  directional light source, 159, 300  discriminant, 132, 133, 144  dome   inertia tensor, 428   Doolittle’s method, 471  dot product, 15, 16, 29   properties of, 17  sign of, 17   driver, 2   E  ear clipping, 268  edge collapse, 261  edge connectivity, 295  effective radius   of box, 228, 241, 364  of cylinder, 226, 227, 242  of ellipsoid, 222, 224, 242   eigensystem, numerical method, 483–89  eigenvalue, 54, 63   of covariance matrix, 213  of inertia tensor, 423   eigenvector, 54, 63   of covariance matrix, 213  of inertia tensor, 423   orthogonal eigenvectors, 57   elementary matrix, 45  elementary row operations, 35, 44, 49  ellipsoid   bounding ellipsoid, 218–20, 222–26  effective radius, 222, 224   emission, 174, 287  emission map, 174  Euclidean distance, 521  Euler formula, 134, 154, 501–3, 507,   526   Euler’s method, 490–91, 497   improved Euler’s method, 494, 497  modified Euler’s method, 494   eye space. See camera space   F  face culling, 7  far plane, 103, 107, 124, 246, 292  field of view, 104–7, 128  filtering   bilinear filtering, 171  trilinear filtering, 173  fluid simulation, 443–57  flux, 187  flux density, 187  focal length, 104, 105, 128, 246  force, 380, 400, 414   centrifugal force, 407–8, 436  Coriolis force, 408–10, 436  restoring force, 430   forward substitution, 466, 496  fragment, 7  fragment operation   alpha test, 8  blending, 9  depth test, 9  pixel ownership test, 8  scissor test, 8  stencil test, 8   fragment shading, 7, 177  Frenet formulas, 354          539   Frenet frame, 353  Fresnel factor, 192–95, 201, 208  friction, 396–99   kinetic friction, 396, 402  static friction, 396, 402   frustum plane extraction, 119–21  frustum planes, 107–8   G  Gaussian elimination, 467–70  Gauss-Jordan elimination, 42  generalized coordinates, 520–22  geometric continuity, 318  geometrical attenuation factor, 192,   198–200, 203, 208   geometry matrix, 319, 356  glFrontFace   function, 122  glFrustum   function, 107, 113, 116,   248   glOrtho   function, 119  gloss map, 165  glPolygonOffset   function, 285  glScissor   function, 314  glTexParameteri   function, 284  glViewport   function, 283  Gouraud shading, 176–77  gradient, 149, 514, 516, 518  Gram-Schmidt orthogonalization, 28,   30, 182   graphics primitive, 1  graphics processing unit  GPU , 1  gravity, 390, 401, 434   H  halfspace, 232  halfway vector, 163, 192, 195, 197,   203, 206   Hamiltonian quaternions, ring of, 80  handedness, 70  hardware abstraction layer  HAL , 2  helix, 359  Hermite curve, 320–21   basis matrix, 320  blending functions, 321  geometry matrix, 320   Heun’s method, 494  homogeneous clip space, 6, 113, 116,   120, 233   homogeneous coordinates, 6, 75–78, 90  Hooke’s law, 430   I  identity matrix, 32  image buffer, 3  implicit pivoting, 467  improved Euler’s method, 494, 497  index of refraction, 151, 193, 208  inertia tensor, 414–22, 437  moment of inertia, 416  of annular cylinder, 438  of box, 421, 427  of capsule, 438  of cylinder, 418  of dome, 428  of sphere, 416  principal axes of inertia, 422–26  principal moment of inertia, 423  product of inertia, 416  transforming, 426–30   infinite light source. See directional   infinite projection matrix, 117, 129, 292   light source   tweaked, 293   inner product. See dot product  intersection   ray and box, 143  ray and cone, 155  ray and cylinder, 145–46, 368–70,   377   ray and sphere, 144–45, 153  ray and torus, 147–48  ray and triangle, 141–43   inversion transform. See reflection   transform    540      Index   invertible matrix, 40, 50  irradiance, 187   J  Jacobi method, 483, 497   K  kinetic friction, 396, 402  knot, 335  knot value, 341   multiplicity, 343   knot vector, 341  Kockanek-Bartels spline, 358  Kronecker delta, 28, 44, 69, 415, 470,   522   L  Lambertian reflection, 161, 187  law of cosines, 511  law of sines, 509–11  light source, 158–60   ambient light, 158–59  directional light source, 159, 300  point light source, 159–60, 205, 300  spot light source, 160, 205   lighting   diffuse lighting, 161–62, 205  specular lighting, 162–64, 205   line, 93–96, 127   distance between point and line, 93–  94, 127   distance between two lines, 94–96  skew lines, 94  line element, 522  linear physics, 379–99  linear system, 34, 53, 465–82, 496  backward substitution, 466, 497  coefficient matrix, 35  constant vector, 35  error reduction, 477–78  forward substitution, 466, 496  Gaussian elimination, 467–70   homogeneous system, 35  LU decomposition, 470–77  nonhomogeneous system, 35  reduced form, 35  triangular system, 465–67  tridiagonal system, 479–82  linear transformation, 67–68  linearly dependent vectors, 27  linearly independent vectors, 27  lower triangular matrix, 465  LU decomposition, 470–77   M  matrix   addition, 32  characteristic polynomial of, 54  determinant of, 47–54, 62  diagonal matrix, 31  diagonalization of, 58, 64  elementary matrix, 45  identity matrix, 32  inverse of, 40, 42, 51–52, 63  invertible matrix, 40, 50  lower triangular matrix, 465  main diagonal entries, 31  multiplication, 32, 62  orthogonal matrix, 68–70, 89  properties of, 33–34  scalar multiplication, 32  singular matrix, 40, 47  square matrix, 31  symmetric matrix, 56  transpose of, 31  tridiagonal matrix, 479  upper triangular matrix, 65, 465   metric tensor, 520–21  microfacet, 192, 198  microfacet distribution function, 192,   195–97, 201, 208  anisotropic, 197, 203, 208  isotropic, 196, 201, 208   mipmap, 172–73          541   model-view transformation, 5  modified Euler’s method, 494  modulation, 158  moment of inertia, 416  motion   oscillatory motion, 430–35  pendulum motion, 434–35, 438  projectile motion, 390–94, 401  resisted motion, 394–96, 401  rigid body motion, 410–30  spring motion, 430–34, 437   N  natural cubic spline, 334  near plane, 103, 107, 113, 128, 129,   246, 292  oblique, 123–27, 129   near rectangle, 304  near-clip volume, 305  Newton’s method, 136–39, 153, 154,   201, 403  reciprocal calculation, 139, 153  reciprocal square root calculation,   140, 153   Newton-Raphson iteration. See   Newton’s method   nonuniform B-spline, 342–45, 355   Böhm subdivision, 345, 359  control point, 342  Cox-de Boor algorithm, 342   nonuniform rational B-spline  NURBS ,   345–47, 356   normal map. See bump map  normal vector, 161, 175, 205   calculating, 148–49, 153, 175–76  of bicubic surface, 348, 357  of curve, 351  transforming, 79, 92   normalization cube map, 171, 178  normalized device coordinates, 6, 113   O  object space, 5, 141, 180, 207  oblique near plane, 123–27, 129  octree, 230–32, 370  OpenGL library, 1, 103, 113, 159, 246,   248, 291, 308, 314   orthogonal matrix, 68–70, 89  orthographic projection, 117–19  orthographic projection matrix, 119  orthonormal basis, 28, 180  oscillatory motion, 430–35   amplitude, 432  angular frequency, 431  phase, 432   osculating circle, 352  osculating plane, 352   P  parallel axis theorem, 426  parallelogram, area of, 22  parametric continuity, 318  particular solution, 385  Pascal’s triangle, 322  patch, bicubic, 348  pendulum motion, 434–35, 438  per-pixel lighting, 6  perspective projection, 113–17  perspective projection matrix, 116, 128,   246, 291   perspective-correct interpolation, 108–  12, 128  depth interpolation, 109–11  vertex attribute interpolation, 111–  12, 116, 128   per-vertex lighting, 6  phase, 432  Phong shading, 177–78  physics   linear physics, 379–99  rotational physics, 405–35   pivoting, 467, 472   implicit pivoting, 467    542      Index   pixel ownership test, 8  pixel shading. See fragment shading  plane, 97–102, 127   intersection of line and plane, 98–99,   128   intersection of three planes, 99–101  intersection of two planes, 101  transforming, 101–2, 128   point light source, 159–60, 205, 300  polar angle, 189, 516  polarization, 193  polyboard, 258–60  polygon   backfacing polygon, 7  clipping, 252–54  depth value offset, 245–49  portal, 235  triangulation, 267–74   polygon reduction, 260–64  portal, 235  portal clipping, 236–38, 243  portal system, 235–40   reduced view frustum, 238–40   position function, 379, 401  precession, 425  primitive root, 133, 502  principal axes of inertia, 422–26   of cube, 423   principal component analysis, 212–15,   240  covariance matrix, 212  primary principal component, 212   principal moment of inertia, 423  product of inertia, 416  projectile motion, 390–94, 401  projection, 112–21   orthographic projection, 117–19  perspective projection, 113–17   projection matrix   frustum plane extraction, 119–21  infinite projection matrix, 117, 129,   292   orthographic projection matrix, 119  perspective projection matrix, 116,   128, 246, 291   projection plane, 105, 109, 110, 112,   117   projection transformation, 5  projective texture map, 167–69  Pythagorean theorem, 93, 511, 522   Q  quadratic formula, 132, 153  quadtree, 230  quaternion, 80, 91  conjugate of, 81  inverse of, 82  linear interpolation, 86  multiplication, 81  rotation, 82–86, 91  spherical linear interpolation, 86–89,   91   R  radiance, 189  radiometry, 187  radiosity, 187  radius of curvature, 352, 357  rasterization, 7  ray, 93, 140   intersection with box, 143  intersection with cone, 155  intersection with cylinder, 145–46,   368–70, 377   intersection with sphere, 144–45, 153  intersection with torus, 147–48  intersection with triangle, 141–43   ray tracing, 131–52  reflection, 121–22  reflection buffer, 121  reflection transform, 70  reflection vector, 150, 153  refraction vector, 151–52, 154  resisted motion, 394–96, 401          543   restoring force, 430  RGB color, 157–58  right hand rule, 22  rigid body motion, 410–30   center of mass, 410–13, 436   RK4 method. See Runge-Kutta method  Rolle’s theorem, 524  root finding, 131–40   cubic polynomials, 132–35  quadratic polynomials, 131–32  quartic polynomials, 135–36   rotation transform, 71–75   about arbitrary axis, 74–75, 90  about x-axis, 72, 90  about y-axis, 72, 90  about z-axis, 72, 90   rotational physics, 405–35  Runge-Kutta method, 493–95, 498   S  scalar product. See dot product  scale factor, 522  scaling transform, 70, 89  nonuniform scale, 71  uniform scale, 71   scissor rectangle, 8, 310–14  scissor test, 8  shading, 157, 175   Blinn-Phong shading, 177–78  Gouraud shading, 176–77  Phong shading, 177–78   shadow acne, 284  shadow casting set, 279–81  shadow mapping, 281–85  shadows   shadow mapping, 281–85  stencil shadow algorithm, 286–316   silhouette, 287, 294–99   edge extrusion, 300–303   singular matrix, 40, 47  skew lines, 94  sliding, 371–72, 377   Snell’s law, 151, 193, 194  solid angle, 188  spatial partitioning, 230–34, 366   binary space partitioning  BSP  tree,   232–34   octree, 230–32   specular exponent, 163, 206  specular lighting, 162–64, 205  sphere   bounding sphere, 217–18, 221–22  collision of two spheres, 372–75, 377  collision with plane, 362–63, 376  general sphere collisions, 366–71  inertia tensor, 416  ray intersection, 144–45, 153   spherical coordinates, 516–19  spherical linear interpolation, 86–89, 91  splitting plane, 232  spot light source, 160, 205  spring motion, 430–34, 437  square matrix, 31  static friction, 396, 402  stencil buffer, 4, 286, 308–10  stencil shadow algorithm, 286–316   rendering shadow volumes, 308–10  scissor optimization, 310–14  shadow volume caps, 304–8  shadow volume construction, 300–  303   silhouette determination, 294–99   stencil test, 8, 308–10  steradian, 188  symmetric matrix, 56   T  tangent space, 180, 207  calculating, 180–83   tangent vector, 179, 180, 183, 206   calculating, 180–83  of curve, 350   tangential acceleration, 353  Taylor series, 138, 523–27    544      Index   Taylor series method, 492–93  TCB spline. See Kockanek-Bartels   spline  tearing, 4  tensor   inertia tensor, 414–22, 437  metric tensor, 520–21   terminal velocity, 396, 401  texel, 164  texture coordinates, 6, 165  texture map, 4, 164–73  bump map, 178–86  cube texture map, 169–71  emission map, 174  gloss map, 165  mipmap, 172–73  projective texture map, 167–69  standard texture map, 166   T-junction elimination, 264–67, 268  torque, 413, 426, 434, 437  torsion, 354–55, 357  torus   ray intersection, 147–48  total internal reflection, 152  transform   reflection transform, 70  rotation transform, 71–75  scaling transform, 70, 89  translation, 75   translation, 75  triangle   area of, 22  ray intersection, 141–43   triangle inequality, 14  triangular system, 465–67  triangulation, 267–74  tridiagonal matrix, 479   diagonal dominance, 479  tridiagonal system, 479–82  trigonometric functions, 505–11  exponential identities, 507–8  inverse functions, 508–9   numerical calculation, 463–65  Pythagorean identities, 507  symmetry and phase shifts, 506   trilinear filtering, 173   U  undetermined coefficients, method of,   386   uniform B-spline, 335–40  control point, 335, 340   upper triangular matrix, 65, 465   V  vector   addition and subtraction, 12  bitangent vector, 181, 183, 206  components of, 11  contravariant vector, 80  covariant vector, 80  halfway vector, 163, 192, 195, 197,   203, 206   magnitude of, 13  normal vector, 161, 175, 205  normalization, 13  orthogonal vectors, 16  projection of, 18, 29  reflection vector, 150, 153  refraction vector, 151–52, 154  scalar multiplication, 12  tangent vector, 179, 180, 183, 206  unit length, 13  zero vector, 16   vector product. See cross product  vector space, 26   basis of, 26, 27  orthogonal basis, 27  orthonormal basis, 28   velocity   angular velocity, 405–7  terminal velocity, 396   velocity function, 379       545         vertex attribute interpolation, 111–12,   vertex space. See tangent space  video random access memory  VRAM ,   116, 128   3–4   view frustum, 102–8, 120, 128, 279   frustum planes, 107–8  reduced view frustum, 238–40   viewport, 3  viewport transformation, 6  viscosity, 447, 461  visibility test   bounding box, 228–30  bounding cylinder, 226–28  bounding ellipsoid, 222–26   bounding sphere, 221–22   volume element, 522   W  wave equation, 443–47, 461  w-coordinate, geometrical   interpretation, 78   welding, 266, 268  window space, 6  world space, 5   Z  z-buffer. See depth buffer  zero vector, 16  zone, 235    This page intentionally left blank    Like the Book?  Let us know on Facebook or Twitter!  facebook.com courseptr  twitter.com courseptr  Fan us on Facebook or Follow us on Twitter to learn about upcoming books, promotions, contests, events and more!

@highlight

This updated third edition illustrates the mathematical concepts that a game developer needs to develop 3D computer graphics and game engines at the professional level. It starts at a fairly basic level in areas such as vector geometry and linear algebra, and then progresses to more advanced topics in 3D programming such as illumination and visibility determination. Particular attention is given to derivations of key results, ensuring that the reader is not forced to endure gaps in the theory. The book assumes a working knowledge of trigonometry and calculus, but also includes sections that review the important tools used from these disciplines, such as trigonometric identities, differential equations, and Taylor series.The third edition expands upon topics that include projections, shadows, physics, cloth simulation, and numerical methods. All of the illustrations have been updated, and the shader code has been updated to the latest high-level shading language specifications