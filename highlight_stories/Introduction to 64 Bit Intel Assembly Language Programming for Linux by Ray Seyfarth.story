Introduction  Bit Intel Assembly   to 64   Language Programming   for Linux     Introduction   to 64 Bit Intel Assembly  Programming   for Linux   Language   Ray Seyfarth   October 27, 2011    of Computing   Ray Seyfarth  School  University  Hattiesburg,  MS 39406  USA   of Southern   Mississippi   to 64 Bit Intel Assembly   Language   Programming   Seyfarth, Ray  Introduction  Includes  index.  ISBN-13: 978-1466470033  ISBN-10: 1466470038   @201 1  Ray Seyfarth  reserved. This work may not  All rights  or in part  without  for brief excerpts   the written  in connection   be translated   or copied   in whole   permission  with reviews   holder,  of the copyright  analyses.   or scholarly   except    Preface   over 3 decades  a period   with 32 bit   from a 16 bit   processors   into the current   series  in addition   to a greatly   of processors which   textbooks   tend to focus on   expanded  the history   has evolved  The Intel CPU architecture  CPU with no memory protection,  through  architectures  with sophisticated  support all  operation  64 bit mode of  and generally  introduced  to the  access  on the past.   the old modes of  operation.  conclude   to 1  megabyte   of internal   concepts   Assembly   with a discussion   on the 32 bit mode. Students   of 16 bit CPUs with segment   allowing   are  registers  focus   memory. This is an unnecessary   With the x86-64 architecture  there  are essentially  purpose,   obsolete  with the glaring   is almost a complete   and more reg­ of   from the past.  Segment  registers  ister usage is completely  general  the repeat- Both these changes  mmg.   contribute   string   loops which use specific   registers  assembly   to simpler   language   program­  exception   and have no operands.   departure   There are now 16 general   purpose   integer   registers   with  a   few spe­  ns. The archaic  register   stack of the 8087 has been   by a well-organized   model providing   16 floating   point regis­  instructio  cialized  superseded  ters with the floating  In fact the AVX extensions  simplify coding even more.   point instructions   for the SSE and AVX extensions.   even allow a three operand   syntax which can   Overall   the x86-64 assembly   language   programming   is simpler   than   its predecessors.  a few short years. Together  64 bit assembly  language.   The dominant mode of operation   will be 64 bits within   these trends indicate that   it is time to teach   The focus in this textbook   is on early hands-on   use of 64 bit assembly   prograrnmmg.   There is no 16 or 32 bit programming   and the discussion   Ill    IV   PREFACE   focused on explaining   the origin   of the old register  names   of the history is  and the few non-orthogonal  is to get students   The intention   involved   features of the instruction   set.   and the gdb debugger  computer  understood   from the start.   at this time, but the assignments  for this book is beginning   The primary target   from the very first chapter. Not every statement   with using the yasm assembler  using  the   There are assignments  will be fully  possible.  pro­ stu­  to assembly   assembly   are still   language   programming,   introduction   and for  a gentle   grammers  dents should study chapters  on memory mapping  skipped  if desired.   1 ,  2,  3,  5,  6,   7, 8, 9, 10  and 1 1 .  Chapter   4  to the rest of the book and can be   is not critical   Chapters   12 through   1 5  are significa 15 is about data structures  in  assembly  studying data structur after exposure   .   The  final   in assembly  four chapters   language focus on high performance   ntly more  in  and is an excellent   adjunct to   depth. Chapter   es in C C++. The subject   will be much clearer   programming,  in­  cluding   discussion   of SSE and AVX programming.   The author provides   for classroom   instruction   along with   PDF slides  at http:    sample code and errata    rayseyfa  rth.com asm.   If you find errors   in the book or have suggestions   for improvement,   please   email the author as ray.seyfart Thank you for buying the book   h@gmail.com.   and I hope you find something   inter­  esting   and worthwhile inside.    Acknow ledgernents   No book is created  indebted  book.   to numerous   in isolation.   certainly   no exception. I am   This book is  for information   and assistance   with this   sources   Dr.  Paul Carter's  PC assembly  language   language  programming.   His book is a free PDF   book was used by this author   from his web site.  This   is a 195 page book   which covers   language   and is a great start at 32 bit assembly   to study 32 bit assembly  file downloadable  the basics  language.   of assembly   on  this   While working  and O'Hallaron  the features  of their observations  assists  efficiency   with writing   should study their work.   I found the Intel   manuals   by Drs. Bryant  of Carnegie Mellon about how gee takes advantage   book, I  discovered  a treatise   of   of the x86-64 architecture   to produce   efficient   code. Some   have helped me understand  better  assembly   the CPU better  in   code. Programmers   interested   which   to be an  of the CPU. Unfortunately   invaluable resource.  They  the documents   provide   together   which,   along with the huge   makes it difficult   on all the instructions   details  cover 32 bit and 64 bit instructions  number of instructions,  from these manuals.  starting  selected  but  an assembly  equivalent manuals   consider  programmer  from AMD .   I hope that reading   the  most   point, but a short book cannot cover many instructions.  what I   important instructions   to learn assembly   this book  will   programming  make a good  I have  for general  use,  manuals  or   will need to study the Intel   I thank my friends Maggie and Tim Hampton for their  editing   con­  tributions  to  the   book.   I am  indebted  of Southern   University   to my CSC 203 -Assembly   Language   Mississippi   for their contributions   class at  the  to this book.   v    Vl   ACKNOWLEDGEMENTS   in the original   Teaching 64 bit assembly  errors  wish to thank Chris Greene,  errors   in the book.   language   has uncovered   a few mistakes and   Create Space book from July 2011 .  In particular  and Brandon Wolfe for locating   Evan Stuart   I   Last I thank my wife,   Phyllis,   and  my sons, David and Adam, for   their encouragement and assistance.  for the cover design  for both  this   Phyllis   and the Create Space book.   and Adam are responsible    Contents   Preface   Acknowledgements   1 Introduction   1 . 1  Why study assembly  1.2 What is a computer?   language?  .  .  .   1 .2.1 Bytes . . . . . .   1 .2.2 Program  execution   .   1.3  Machine  1 .4 Assembly  1.5 Assembling   language  . . .  .  language  . .  .   and linking   2 Numbers   2 . 1  Binary numbers  .  2.2 Hexadecimal  numbers  2.3 Integers   . . . . . . .    .   2.3.1 Binary addition  2.3.2 Binary multiplication   .   2.4 Floating   point numbers . . .    2.4.1 Converting  2.4.2 Converting  2.4.3 Floating  2.4.4 Floating   decimal numbers  floats to decimal  .   to floats   point addition  .  point multiplication   .  .   3 Computer memory   3.1 Memory mapping .   Vll   iii   v   1  2  4  4  4  5  6  8   11  1 1   13  16  18  19  20  23  24  24  25   27  27    Vlll   CONTENTS   memory model in Linux   3.2 Process  3.3 Memory example . . . . . .   3.4 Examining   .  memory with gdb   with gdb  3.4.1 Printing  3.4.2 Examining   memory   28  30  32  32  34   4 Memory mapping in 64 bit mode   register   37  .  4.1 The memory mapping  37  38  4.2 Page Map Level 4 .  .  .  .  .  .  .  39  4.3 Page Directory  Pointer  39  Table .  4.4 Page Directory  4.5 Page Table .  .  .  .  .  .  .  .  .  .  39  4.6 Large pages .  .  .  .  .  .  .  .  .  .  40  40  4. 7 CPU Support   for Fast Lookups   Table   5 Registers   5.1 Moving a constant into a register  5.2 Moving values  .  5.3 Moving values from a register  5.4 Moving data from one register   into memory  to another   43  45  .  .  .  .  .  .  46  49  49   from memory into registers   6  A little bit of math  6.1 Negation  . .   .. . .  6.2 Addition  .  .  6.3 Subtraction  6.4 Multiplication  6.5 Division  6.6 Conditional  6.7 Why move to a register?   . . . .    .   . . . .    move instructions   .   7 Bit operations   .   7.1 Not operation  7.2 And operation  7.3 Or operation  7.4 Exclusive  7.5 Shift operations .  .  .  .  7.6 Bit testing  7. 7 Extracting   or operation   and setting  and filling a bit   field .   5 1   51  52  54  55  57  57  58   61  61  62  63  64  65  67  68    CONTENTS   8 Branching and looping   8.1 Unconditional  8.2 Conditional   jump . . . .    jump .  .  .  .  .  .   8.2. 1  Simple if statement  8.2.2 If  else statement  8.2.3 If else-if   else statement  with conditional   jumps .   .  .   .   8.3 Looping   8.3.1 While loops . .   loops  8.3.2 Do-while  8.3.3 Counting  loops   8.4 Loop instructions  8.5 Repeat string  8.5.1 String   .  .  .   array   instructions   . . . . .    instructions   .   9 Functions   . .    9.1 The stack  9.2 Call instruction  9.3 Return instruction  9.4 Function  parameters  9.5 Stack  frames  9.6 Recursion   and return   value   10 Arrays   10.1 Array address  10.2 General  10.3 Allocating  10.4 Processing   pattern   computation   .  .  .  .  for memory references   .  .   arrays . . . .   arrays . . . . . . . . . . .    .   the array   . . . . . .    10.4.1 Creating  10.4.2  10.4.3  10.4.4  10.4.5   Filling  Printing  Finding  Main program   the array   with random  numbers   the array  the minimum value . . . . .    . .. . . . . . . .    .  .   for the array minimum   10.5 Command line parameter   array . .. . . . .    .   .  .   IX   71  71  73  74  75  75  76  76  80  82  82  83  83   89  89  90  91  91  92  94   99  99  101  103  104  104  105  106  107  107  109   115  115  116   11 Floating point instructions   1 1 . 1  Floating  1 1 .2  Moving data   point registers   to from floating   point  registers  .   .  .  .  .  .  .  .  .  .  .  .  .    X   CONTENTS   116  1 17  1 17  1 18  119   1 1 .2.1 Moving scalars  1 1.2.2 Moving packed data   . . .    . .. . .. . . . .    11.3 Addition  1 1.4 Subtraction  1 1 .5 Multiplication  1 1 .6 Conversion .  .  .  .  .  .  .  .  . 1 19   .  .  .  .  .  .  .  .  .   and division   .   1 1 .6.1 Converting  1 1.6.2 Converting floating   to a different   length   floating   point .  1 1 9    1 1.7 Floating  1 1.8 Mathematical   functions   point comparison   1 1 .8.1 Minimum and maximum .  1 1.8.2 Rounding  .  .  1 1.8.3 Square roots .   1 1.9 Sample code .  .  .  .  .  .   1 1.9.1 Distance in  1 1 .9.2 Dot product  1 1 .9.3 Polynomial   3D  of 3D vectors  .  evaluation   .  .  .  .  .   point to from integer 120  120  .  .  .  .  121  122  122  123  123  123  124  124   12 System calls   12.1 32 bit system calls  12.2 64 bit system calls  12.3 C  wrapper   functions  open system call   12.3.1  12.3.2 read and write system calls  1 2.3.3 lseek system call  1 2.3.4 close system call .  .  .  .  .  .  135   13 Structs   13.1 Symbolic  1 3.2 Allocating   names for offsets .  .  .  and using an array of structs   .  .  .  .  .  138  140   14 Using the C stream 1 0 functions   a file . .   14.1 Opening  14.2 fscanf and fprintf  14.3 fgetc and fputc .  14.4 fgets  and  fputs .  14.5 fread and fwrite .   129  130  130  131  132  133  134   137   143  1 44  145  1 45  146  147    CONTENTS   14.6 £seek and ftell .  14.7 £close .  .  .  .  .   15 Data structures   XI   148  149   .  .  .  .  .  .  .  .  .  .   15.2 Doubly-linked lists .  .  .  .  .  .  .  .  .  .   List  node   node structure   the front of the list   Doubly-linked list   a new list .  .  .  .  .  .  .   number into a list  . . . . .    15.2.1  15.2.2 Creating  15.2.3 Inserting at  15.2.4 List traversal   structure  . .   15.1.1  15.1.2 Creating  an empty list  15.1.3  Inserting a  15.1.4 Traversing the  list  .   151  15.1 Linked lists .  .  .  .  .  .  .  .  .  .  151  152  152  153  153  156  157  157  158  159  15.3 Hash tables . . . . . . . . . . . . . .   160  161  161  162  162  163  164  165  166  167  167  168  169  170   15.3.1  15.3.2  15.3.3 Hash table node structure  15.3.4 Function  to  find  15.3.5 Insertion  15.3.6 Printing  15.3.7   15.4.1 Binary tree node and tree structures  15.4.2 Creating an  15.4.3 Finding a key  15.4.4  15.4.5 Printing  the keys   code  .  .  .  .  .  .  the hash table  Testing the hash table .   in a tree . . .  .  Inserting a key  into the  tree  .  in order . .    A good hash function  A good hash function   for integers  .  for strings  .   a value in the hash table   empty tree . .  .   and array   .   15.4 Binary trees .  .  .  .  .  .  .  .  .  .  .   optimiza  16 High performance assembly programming  tion strategies   16.1 General  16.2 Use a better  16.3 Use C or C++ . . . . . . . .   16.4 Efficient  16.5 Common subexpression  16.6 Strength  16.7 Use registers efficiently  . . . . . . .    algorithm  .  .   use of cache . . . . .    elimination   reduction   . .  .   .   .   175  175  176  177  177  179  179  180    instructions   .  .  .  .  .  .  .  .  .  .  .  .  .  .   186   17.1 C function .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  17.2 Counting  17.3 Precomputing  17.4 Using the popcnt  instruction   .  .  .  .  .  .  .  .  .  .  .   .  .  .  .  .  .  .  .  .  .   the number of bits in each byte .   in assembly   1  bits   Xll   CONTENTS   . . . .   loops to branch at the bottom .   . . . . . .  .   180  180  181  183  183  183  184  184  185  185  execution 185   code outside   loops  .   stack frames . .. . . . . . .    . . . . . . . . . . . . .    .  .   dependencies   to allow super-scalar   .   16.8 Use fewer branches  16.9 Convert  16.10Unroll loops  .  16. 1 1 Merge loops . . .  .  16.12Split loops . . . .   16.13Interchange  16.14Move loop invariant  16.15Remove recursion  . . .  .  16.16Eliminate  16.17Inline  16.18Reduce  16.19Use specialized   functions   loops .   17 Counting bits in an array   18 Sobel filter   18.1 Sobel in  C  .  18.2 Sobel  computed   using SSE instructions   .   19 Computing Correlation   19.1 C implementation  1 9.2 Implementation  19.3 Implementation   207  . . . . . . . . . . . .   207  208  211   using SSE instructions  using AVX instructions   .  .   A Using gdb   .  .  .  . . . . .   break points   A.1 Preparing  for gdb .  A.2 Starting .  .  .  .  A.3 Quitting  A .4 Setting  A.5 Running .  .  .  .  .  A.6 Printing  A.7 Examining  A.8 Examining   a trace of stack frames   registers  memory . . . . . .   .   .  .   .·   189  189  190  193  194   197  198  199   217  217  219  219  219  219  220  222  223    CONTENTS   B Using scanf and printf   B.l scanf .  B.2 printf . . . . . .    .   C Using macros in yasm   line macros  C.l Single  C.2 Multi-line  macros .  C .3 Preprocessor   variables   D Sources  for   more information   .  free assembly  book .   D .1 yasm user manual  .  .  .  .  .  .  .  .  .  .  .  D.2 nasm user manual . . . . . . . . . .   D.3 Dr. Paul Carter's  Level Programming  D .4 64 bit Machine  D.5 GDB  Manual  . ..  .  D.6 DDD Manual . . .  .  D .  7  Intel   Documentation   .   Xlll   225  225  227   229  229  230  232   233  233  233  233  233  234  234  234    XIV   CONTENTS    Chapter 1   Introduction   language  Core processors   programming   and the AMD   for the   While assembly language   is no longer   of CPUs like the Intel   to assembly   architecture   This book is an introduction  x86-64  Athlon and Opteron processors.  widely  used  maximum efficiency in core functions  applications  form some functions   where maximum efficiency   in general   purpose   programming,  in scientific   it is still   The goal of this  book   which cannot be handled in  is to teach general   a high-level  of assembly   principles   language.   lan­  used to produce   computing   and in other   is needed.   It is also used to per­  guage programming.  ming in a high level  language  exposure   It targets people   to assembly   language.   withsome experience   in program­  ideally C or C++ , but with no prior   Assembly   language  is   inherently   non-portable   and this text focuses   system,   compilers,   code for the Linux operating  on writing  ity of excellent  assemblers  are the same on x86-64 systems  BSD and Mac OS  X operating  dards,  with library  programming   systems  though there are differences   Differences  and system  call  for Windows systems will  be  detailed   differences.   regardless  use the   and debugger  between   due to the free availabil­  s. The instructions   of the operating   same function   system and  call stan­  Windows and Linux  along   between   assembly   as the work unfolds.   The primary   goal of   this text is to learn how to write functions   from C or C++ programs.  This  understanding  understa  focus should  implements  benefit in using high level languages.   give the reader  a high level language.   nding will be of lasting   of how a compiler   This   callable  an increased   A secondary   goal of this text is to introduce   the reader to   using SSE   1    2   CHAPTER 1 .  INTRODUCTION   and AVX instructions to increase and  of the SIMD capabilities.   it generally   requires   . The coming trend is for the size of SIMD registers   assembly   language   to take advantage   1 . 1  Why study assembly   language?   fads in programming   In a time when the latest  high-level languages  implemented  is clearly  write portable programs  time. It seems that worrying  relic from a by-gone  language   programming?   to learn to   using byte-code   tend to be object-or  iented  interpreters,  the trend  with high reliability  in record   era. So why would anyone want to learn assembly   about memory usage and CPU cycles   is a   Assembly   language   has some of the worst "features"   programming  assembly  language  every CPU has its   versions   ing. First,   code. Certainly   child for  language   is the poster  own assembly   known in  comput non-portable  and ma;ny of them have more than one. The most common example  is the  The  Intel CPU family along with the  latest  In each of these modes there are differences  addition  even the function  from that  used  in  not impossible   additional  in x86-64   differences.  Linux systems   language.  Further  differs   in 16 bit, 32 bit and 64 bit modes.   chips can operate   the operating   in the assembly   AMD CPU collection.   call interface  Microsoft Windows systems.  Portability   system imposes   quite similar   in assembly   language.   is difficult   of these   employed   if   In   like Java   the programmer   like pointer   errors.   Pointers   An even  worse   issue with assembly  language   problems   In modern languages   bility.  many possible  programmer  bly language  Furthermore  while assembly  which bears no syntactic   language   can be blissfully unaware  where every variable access  is  high level language syntax  mathematical  machine   of them. Contrast   essentially   access.  syntax,   resembles   a pointer   is a sequence  resemblance   of individual  to the problem   is relia­ is protected   programming  from  exist in Java,  but the  this to assem­  being solved.   Assembly   language   is generally   accepted   than higher  level languages. While experience  is probably twice as slow  to write  assembly   makes it more  code and adds to the cost of maintenance  even for experts.  This   .   expensive   to be much slower to write  can increase one's speed,   it   So what is good about assembly  The typical   claim is that assembly   language?  language   is more efficient   than high   instructions    1.1. WHY STUDY ASSEMBLY LANGUAGE?   3   language   assembly   programmer   understand   do excellent   programmers   .  A  skilled   coder can write code which   assembly  writers   are no match for a good compiler.   by a compiler.  optimization   and  The  quite well. On the   the CPU architecture  is the Atlas  Automatically   level languages uses less CPU time and less memory than that  produced  However modern C and C++ compilers  beginning  compiler  other hand an assembly  markable results.    library  ear Algebra  Software The Atlas matrix multiplication  CPU performance.  well in C.  So,  at least 4 times as efficient  can offer performance  true that assembly  benefits,  to outperform  tasks.  takes intimate  we will point out some general  programs.   achieve  Tuned Lin­ over 95% of the possible  is probably   C C++ for most general  knowledge   of the  CPU to achieve these   gains.  efficient   A good example   Furthermore   it is unlikely   code written   which can   strategies   for writing   as similar   assembly   language   In this book   purpose   function   achieve   with similar skills can   while it is   it   re­  One advantage   of assembly language   is that it can do things not   pos­  sible in high level languages.  interrupts  features  application   are  essential  programming.   and managing   Examples   of this include handling   hardware   memory mapping features  of   a CPU. These  though not required   for   in an operating   system,   So far we have seen that   assembly   use than higher  to well-trained   level languages and  programmers.   What benefit is there for most   people?   language  only offers  benefits   in special   is much more difficult  to   cases   language   to study assembly   can aid in  selecting   The  primary  reason   helps when  programming in   is to learn how a  CPU works.  This  high level language s. Un­ derstanding how the  compiler  implements  language  understanding  the  translation  guage is fundamental  Without  ily a mathematical concept  mathematical  have limits   a programming  mathematical  executes  and can have unexpected  behavior.   language,  obeying  the computer   studying assembly   exterior   language   in understanding why bugs behave the way they  is primar­  the features  features for efficiency.  from high level language to  machine   More importantly   of a high level   laws. Underneath   instructions   this  which   lan­ do.   machine    4   CHAPTER 1. INTRODUCTION   1 . 2  What is a computer?   is a machine   A computer  unit of computer  computers  as bits. Collections  other information.  computers   to process   simply   for processing   bits. A bit is an individual   storage which can   take on  2 values: 0 and 1 .  We use   but all the information   information,  of bits can represent  Humans interpret   characters,  these bits as informat  numbers,   or any   ion, while   is represented   manipulate   the bits.   1.2 . 1  Bytes   access   memory in 8 bit chunks.  Each   a "byte". The main memory of a computer   each byte having a separate  depends   memory address.  on the hardware   is 0 and the last address   8 bit quantity   is  is effectively  an array  The first  byte  and software   Modern computers  called  of bytes with  address  m use.   A byte can be interpreted as   a binary number.   The binary number   decimal   1 equals the   instruction the   0101010 a machine  onto the run-time stack.  upper case letter  in the computer all a matter of interpretation.   computer  The number  85   .  The letter   number 85. If this number   is interpreted  will push the value of the rbp register   as   can also be interpreted   as the   "U" could be part   of a string   in memory.  It  's   "U". The number 85 could be part of a larger number   1.2. 2  Program execution   in execution   A program  of the program.  The following  which simply exits  with status   a range  12 bytes   occupies   5 :   of addresses   for the instructions   constitute   a very simple   program    1 . 3. MACHINE LANGUAGE   5   Address Value  4000b0 184  4000b1 1  4000b2 0  4000b3 0  4000b4 0  4000b5 187  4000b6 5  4000b7 0  4000b8 0  4000b9 0  4000ba 205  4000bb 128   The addresses   are listed   in hexadecimal,   though they could have   with the equivalent   started  decimal  number  values are more informative in this  case,  ues in the hexadecimal  operatin with addresses  the beginning of  of memory.   g system maps a program  with the rightmost  the 12 byte program   representation.   4194480. The hexadecimal   since there are numerous  0 val­ This gives a clue to the way the   into memory. Pages of memory begin  3 hexadecimal   "digits"   equal to 0, so   is fairly close to   the start of a page   1 . 3  Machine language   has a collection   of instructions   in memory and fetched,  of a program.   The sequence   it can execute.  and  interpreted  of bytes  like  program.  You would have to enter   language"   It   a "machine  language.  of your program.  of all data used in your program.   instruction   You would have  A more realistic   12 byte   the execution   are stored  program  is called  to use machine   Each type of computer  These instructions  executed during  the previous  would be quite painful  the correct  bytes for each  to know the addresses  program  depends  the computer  it is executed. Furthermore  you add, delete   would have branching  instructions.  to branch to  into memory when  on where  to branch  to can  change when   loads your program   The address   the address   or change instructions   in your program.   The very first computers   were programmed in machine   language , but    6   CHAPTER 1 .  INTRODUCTION   soon figured out ways to make the task easier.   mov to indicate   the selection   The first improve­ in­ of a particular   people started   of instructions  the need to calculate  addresses   names  and insulates  the   and data in a program.   names to represent  Using  symbolic  programmer   using symbolic   people  words  like  ment is  to  use  struction.  In  addition  addresses  prevents  from changes   in the source   code.   1 .4 Assembly   language   Very early in the history  symbolic  language,  sidered  guages are considered   assembly  eliminating   languages.   of computing    1950s , programmers  This rapidly  replaced  are con­ lan­  while assembly   the use of machine   work. Machine languages   developed   a lot of tedious   "first-generation"   programming   languages,  "second-generation"  .   Many programs   continued   to be written   in assembly language   "third-generation"    in the  languages nearly 100%  were typically  systems  for the UNIX   language   .after   of C as the primary   operating   of Fortran and Cobol   the invention  late 1950s. In particular  until the creation  assembly  operating  system.  The source   code for the 12 byte program   from earlier   is listed   below:   Program : exit   Executes the exit system call   No input   Output: only the exit status  $? in the shell    segment . t ext  global _start   _start:   mov eax ,1  mov ebx, 5   int Ox80   1 is the exit syscall number  the status value to return  execute   a system call    1.4. ASSEMBLY LANGUAGE   7   You will observe   the use of ";"  to   signal   the start of comments   in this   program.  Some of the comments  end-of-line commen on each assembly   ts. It  is   instruction.   are stand-alone   comments   and others  to place end-of-line comments   are   fairly common   Lines of assembly   code consist   of labels   in column 1, but this is not required.   and  instructions.  A label establishes   A label   usually  starts  a symbolic name  by itself  more to   to the current   point in the assembler.   A label on a line   must have a colon after it, while the colon is optional  the line.   if there is   Instructions   can be machine   instructions  , macros or instructions   to   the assembler. Instructions  usually  1 .  Most people  a pattern  column.   establish   are placed  of starting   further right than column  all instructions  in the same   The statement   "segment  .   text" is an instruction  to   the assembler   rather than   itself  data or  section.   a machine  instructions  In Linux this is where the instructions   instruction.  it are to be placed   in the . text segment  of a program   following   the  or   are located.   This statement indicates that   The statement   "global  an assembler  bler, called  pseudo-op  informs  known to the linker  function is  system runs a program  typical  C  _start function   program   in the C library.   program   directiv  e or a   _start"   is another  instruction  to the assem­  . This  pseudo opcode  pseudo-op that the label _start is to be made   the assembler   when the  program   is linked. The _start   the most basic   "entry   point"   for a Linux program.   When the   it transfers   control   to the _start function.   A   has a main function which is called   indirectly   via a   The line beginning   with _start is a label.   up to this  point,   the label ref  ers to location   Since no code has been  0 of the program's   generated  text segment.   The remaining   3  lines   are symbolic   opcodes  g  the  3  ex­ The first instruction  moves the   representin  in the program.   instructions  1 into register  ebx. The final instruction   ecutable  constant  register  generates  bered Ox80 which is the  way  Linux handles  code works on both 32 bit and 64 bit Linux systems.    a software  32  bit   5 into  interrupt  num­  This  system calls.   eax while the second moves the  constant    8   CHAPTER 1 .  INTRODUCTION   1 . 5  Assembling   and linking   We use the yasm assembler  source   code file:   to produce   an object   file from an assembly   yasm -f elf64 -g dwarf2 -1 exit. lst  exit.asm  The yasm assembler   is modeled after the   nasm assembler.   yasm pro­  properly   code which works   duces object  while nasm did not produce  The -f elf64 option  with Linux and gee. The -g dwarf2 option  format, which is essential  for a listing   file which shows   acceptable   selects   The yasm command produces   with the gdb and ddd debuggers,  code for debugging   testing.  a 64 bit output format which is compatible   during   selects  for use with a debugger.   the dwarf2 debugging  The -1 exit . 1st asks   the generated  an object  and data in a form ready to link with  instructions   file named exit. o ,  which   code in hexadecimal.   the generated   contains  other code from  program   other object   files or libraries.   In the case of an  assembly  needs to be done with ld:   with the _start function   the linking   ld  -o  exit   exit. o    The -o exit option   that option,   gives a name to the executable  ld produces   a file named a .  out. If the assembly   file produced   by   defines   main rather   than _start,   then the linking   needs to be   ld. Without  program  done using gee:   gee -o exit  exit In  this  call main   . o    case gee will incorporate  its own version  from _start .  from _start  or indirectly   You can execute   the program   using:   of _start and will   .  exit    1 . 5. ASSEMBLING AND LINKING   9   Exercises   language   1 .  Enter the assembly   program  ble and link it. Then  execute  the program  non-zero  indicates  an  error.  0 status.   status   from this chapter   and assem­  and enter echo $?. A   Change the program   to yield  a   2. Modify the assembly   program   Assemble  the executables?   it and link it using  gee.   to define main rather than   _start.  What is the difference  in size of   3. In  C and many other language  the shell 0 for the status   s, 0 means false and 1  or non-zero means success   of a process       means true.  In  and non-zero  means an error.  for true. Why  did the writer  true?   Shell if statements  essentially  of the first shell decide to use 0 for   use 0    10   CHAPTER 1. INTRODUCTION    Chapter 2   Numbers   All information  can be interpreted  will discuss  point numbers.   binary   in a computer is  stored   as collections   in a variety  numbers, hexadecimal   of ways as numbers.  numbers,   integers   and floating   of bits. These bits  In this chapter   we   2 . 1  Binary numbers   We are used to representing  numbers  In this represent Similarly binary  and 1  as the   ation,  numbers  "digits"   a number   in the decimal   place-value  like 1234 means 1 * 103 + 2* 102 + 3 *  10+4.  in a place-value   system.   system using 0  of 10.   and powers of 2  rather  than powers   are represented   Let's consider   the binary number 101011 1 1 .  This is an 8 bit number   so the highest   power of 2 is 27. So this number is   101011 1 1  = 27 + 25 + 23 + 22 + 2 + 1  = 128 + 32 + 8 +  = 175   4 + 2 + 1   The bits of  least significant  175 has its bits defined below.   an  8 bit number are numbered   from 0 to 7  with  0   being the   bit and 7 being the most signific  ant bit. The number   The conversion   from binary to decimal   is straightforward.   It takes a   little   more ingenuity  to  convert   from decimal   to binary.   Let's examine   11    12   .CHAPTER 2. NUMBERS   bit value  1 I 0 I 1 I 0 I 1  bit position 7  6  5  4  3   1  1 I 1 I  2  1  0   the number 741 .  The highest  29 = 512. So we have   power of 2 less than  or equal to   741   is   Now we need to work on 229. The highest   power of 2 less than 229 is   27 = 128. So we now have   741 = 512 + 229  = 29 + 229   741 = 512 + 128 + 101   = 29 + 27 + 101   The process  is 26 = 64. So we get   continues   with 101. The highest   power of 2 less than 101   7 41 = 512 + 128 + 64 + 37   = 29 + 27 + 26 + 37  Next we can find that 37 is greater   than 25 = 32, so   7 41 =  512 + 128 + 64 + 32 + 5   =  29 + 2 7 + 26 + 25 + 5   Working on the  5 we see that   741 = 512 + 128 + 64 + 32 + 4 + 1   =  29 + 2 7 + 26 + 25 + 22 + 1  = 1011 100101   Below is 741 expressed  bit value I o I o I o I o I o I o I 1 I o I 1 I 1 I 1 I o I o I 1 I o I 1 I  bit position 15 14 13 12 11 10 9  8  7  6 5  4  3 2  1  0   as  a 16 bit integer.    2.2. HEXADECIMAL NUMBERS   13   A binary constant   can be represented   in the yasm assembler  by  ap­  "b" to the end of a string   of O's and 1 's. So we could represent   pending  741 as 1 0 1 1100101b.   An alternative   method for converting   a decimal   division   by 2. At each step, the remainder   number to binary is  the next   yields   by repeated  higher   bit.   Let's convert 7 41 again.   division remainder bits   741 2  370  1  370 2  185  0  1  185 2  92  0  92 2  46  46 2  23  0  23 2  11  1  1  11 2  5  5 2  2  1  0  2 2  1  1 2  0  1   1  01  101  0101  00101  100101  1100101  11100101  011100101  1011100101   The repeated   algorithm  tify  guess?  powers of 2 less than  It is also easy to program.   division   is easier   since you don't have to iden­  or equal to the number under question.   2 . 2  Hexadecimal   numbers   tedious   get pretty   if the string   are a fairly effective   way of representing  a string   fairly common to work with 64 bit integers.  Entering   Binary numbers  but they can  it  is  64 bits followed by a  "b" would be tough.  Decimal  numbers  more compact  but it is not immediately  bits are O's and 1 's in  a  A hexadecimal   representation,   number. Enter  hexadecimal.  number is a number in base 16. So we need "digits"   is long. In a 64 bit computer   are a much   decimal   a number as   of bits,   . .    apparent  what   from 0 to 15. The digits  from 10-15 are represented  use lower case letters.  adecimal  the lower case x tends to make the numbers   from 0-9 are just  by the  letters   Fortunately   numbers   like in decimal.   The digits   'A' through   'F'. We can also  both yasm and C C++ represent   using the prefix Ox. You could probably   hex­ use OX but   more visually obvious.    14   CHAPTER 2. NUMBERS   Let's consider   the value of Oxala. This number uses a which means   10, so we have   Oxal a  = 10 * 162 + 1 * 16 + 10   =  10 * 256 + 16 + 10  =  2586   Converting a   decimal  one used before for binary  power of 1 6  and divide by  convert  40007 4096   40007 to hexadecimal.  =  9 with a remainder   number to hexadecimal  numbers  that number to get the correct   of 3143, so we have   The first power of 16 to use is 163 = 4096.   follows a pattern   "digit"  except   like the   that we have to find the highest   . Let's   40007 = 9 * 163 + 3143   3143 162 = 3143 256 = 12 with a remainder   of 71, so we get   40007 = 9 * 163 + 12 * 162 + 71   71 16 =  4 with a remainder   of 7, so the final result   is   40007 = 9 * 163 + 12 * 1 62 + 4 * 16 + 7 = Ox9c47   As with conversion to binary we can perform repeated   division   and   build the number by keeping the   remainde rs.   hex  division remainder   40007 16  2500  7  7  4  2500 16  156  47  12  c47  156 16  9  9 16  0  9  9c47   Converting   back and forth between   decimal   and binary or decimal   Computers   a bit painful.   and hexadecimal is  but why would you want to  convert  from  you are entering  a  which matches  and need to use it in your program,  want to represent   decimal  If  simply enter it  in the form  at the number 1027  If you  number.   value in the assembler,   tion. If you're looking   enter it as a decimal   can do that quite handily,  to hexadecimal?   in the computer, then your choices   your interpreta  some pattern   of bits    2.2. HEXADECIMAL NUMBERS   15   are binary and hexadecimal.  for  fairly short binary strings.  binary   strings.   Binary is pretty  Hexadecimal   obvious   to use, but only   is more practical   for longer   The bottom line is conversion   between   binary and hexadecimal   is   needs to do. This task is made easier   since each   all that one normally  hexadecimal  a "nibble" hexadecimal.   represents   .  Consult  the   "digit"   exactly   4 bits  frequently  between   referred to as   binary and   table below to convert   Hex Binary  0  0000  1  0001  2  0010  3  001 1   4  0100  5  0101  6  0110  7  0111  8  1000  9  1001  a  1010  b  1011  c  1 100  d  1 101  e  1 1 10  f  1 1 1 1    Let's now consider   converting   5 = 0101 and b = 1 0 1 1 ,  so we get   Ox1a5b t o  binary. 1 = 000 1 ,  a = 1010,   Ox1a5b = 0001 1010 0101 1 0 1 1  = 000 1 1 010010 1 10 1 1b   Below Ox1a5b is shown with   each bit position   labeled:   bit value  bit position   1  lolololtltloltlololtloltl1lolt  0  15 14 13 12 11 10 9  8  7  6 5  4  3  2  1    16   CHAPTER 2. NUMBERS   2.3 Integers   On the x86-64 architecture  bytes in length.  Furthermore  signed or unsigned:  values   for each type of integer.   integers   can be  1   for each length   Below is a table listing   byte, 2 bytes,  the numbers  minimum  and   4 bytes,  can be either   maximum   or 8   0   -128   Variety Bits Bytes  Minimum  unsigned 8  1  signed 8  1  unsigned 16  2  signed 16  2  unsigned 32  4  signed 32  4  unsigned 64  8  signed 64  8  -922337203685  -32768   0   0   0   Maximum   255  127  65535  32767   4294967295   -2147483648  2147483647   1844674407370  9551615   4775808 9223372036854775807   The range of 64 bit integers   is large enough for most needs.   Of course   there are exceptions,   Unsigned   integers   like 20! =  51090942171709440000.  are precisely   the binary   numbers   discussed  complemen is the sign bit. If the sign bit is 0, the   format called   "two's   t".   earlier.   If the sign bit is 1 ,  the number is negative.   The most   are stored   in a useful   Signed integers  The first bit of a signed integer  number is positive.  obvious  way  bits  to  store   to store  negative  the absolute value   numbers  of the number.   would  be   to use the remaining   31  sign bit   value   0   Let's consider   8 bit signed   and what we would get if we used   the existing circuitry  we store   to  add 2   -1 with a sign bit and then the value we would   Let's add -1  and   get   1 .  Well, if   integers  such integers.   - 1  =  1000 0001  1 =  00,00 0001   -1+1 =  1000 0002    2.3. INTEGERS   17   as a  sign   bit and invert   the bits for   Oops! We end up with -2 rather   than 0.  8 bit numbers  value part of the number:   Let's try storing   the absolute   - 1  =  1 1 1 1  1 1 10  1 =  0000 0001   -1+1 =  1 1 1 1   1 1 1 1    - 1  =  1 1 1 1  1 110  4 =  0000 0 100   -1+4 =  0000 0010 =  2   Now this is interesting:  sounds somewhat   is actually  Let's try a different   -0, rather  pair of numbers:   hopeful.   the result   than 0. This   Too bad! It was close.  absolute  arithmetic.  numbers   value for the number. This is referred to as "two's   What we need it to add one to the complemented  complement"   It works out well using the same circuitry   as for unsigned   and is mainly a matter of interpretation.   So let's convert   -1 to its two's complement   format .   - 1  1 for the sign bit   0000001 for the absolute  1 1 1 1 1 10 for  the  1 1 1 1 1 1 1    complement   value   -1 = 1 1 1 1 1 1 1 1    after adding 1 to the complement  after prefixing the sign bit   Using two's complement   numbers   negative   the largest   this back, complement   the rightmost  +  1 = 1 0000000 = 128, so 10000000   8 bit integer  is  7 bits and add  = -128.  in the table of minimum and maximums that the  all  1 larger   in absolute   and adding 1. The complement   a   value than the maximums.  yields  1 with a bunch of O's.   1 1 1 1 1 1 1    To convert   1 0000000.  1 .  This  gives  You  may have noticed  minimum values were  This is due to complementing  string  The result  and the   is that the largest   value is -2n-l.   smallest   value for ann-bit signed   integer   is 2n-l - 1   of 1 's and adding 1 to that yields  a   single   Now let's convert   the number -750 to a signed   binary number.   750 = 512 + 128 + 64 + 32 + 8 + 4 + 2 = 1011 10 1 11 0b    18   CHAPTER 2. NUMBERS   this as a 15 bit binary   Now expressing  track of the bits  we get 000 0010 1 1 10 1 110. Next we invert  get 1 1 1  1 1 0 1  0001 0001 .  Finally  the sign bit to   get -750 = 1 1 1 1  1 10 1  0001 0010 = OxFD12.   we add 1 and prefix the number with   to help keep   the bits to   number  with spaces   value OxFA13 from a 16 bit signed   the hexadecimal  value. Start by converting   Next let's convert  integer to a decimal  to binary:  1 100. Add 1 to get the 2's complement this to decimal  = -1517.   1024 + 256 + 128 + 64 + 32 + 8 + 4 + 1   1 11 1010 0001 0011. Then invert the  bits:   000 0101 1 1 10  = 1517, so OxFA13   : 000 0101 1 1 10 1 1 0 1 .  Convert   the  rightmost   15 bits   Let's add -750 and -1517 in binary:   1 1 1 1  1 1 0 1  0001  0010  1 1 1 1  1010  0001   001 1    1 1 1 1 1  0 1 1 1  0010 0101   the leading   1 bit  a result   of a  carry . The 16 bit sum  We can ignore  is 1 1 1 1  0 1 1 1  0010 0101, which is negative.  Inverting  15  bits: 0000 1 000 1 101  1010.  Next adding 1 to get the two's complement :  0000 1000 1 101 1 0 1 1 .  Sothenumber is2048+128 + 64 + 1 6 + 8+ 2 + 1  =  2267. So we have -750 + -1517 = -2267.   the lower-most   2.3.1 Binary addition   Performing binary addition  binary numbers   is a lot like decimal   addition.   Let's add 2   The  first   pair of bits was easy.  Adding  the second   value of 2, but 2 = 10b, so we place a 0 on the bottom and carry  a 1   pair of   bits gives a   1010 1 1 1 1    + 1 10 1 0010   1   1   1000 1 1 1 1    + 0101 1010   01    2.3. INTEGERS   19   We continue   in  the  same   way:   1   1000 1 1 1 1    + 01011010   001   1   1000 1 1 1 1    + 0 1 0 1 1 0 1 0    1001   1   1000 1 1 1 1    + 0101 1010   01001   1000 1 1 1 1    + 01011 0 1 0   1 1101001   *   1010101   10101   1010101   1010101   1010101  1 10 11 1 11001   2.3.2 Binary multiplication   is also much like decimal   Binary multiplication  tiply one bit at a time of the second number  these products  are trivial.  just skip it. For 1 bits, you simply copy the top  number  columns.   You are multiplying   to the left. Of  course  these  by either   0 or 1. In the case of 0, you   down staggered   multiplica  by the top number   in the correct   tion. You mul­  and write   "products"   After copying   the top  number   enough times,   you add all the partial   products.   Here is an example:    20   CHAPTER 2. NUMBERS   2.4 Floating point numbers   The x86-64 architecture  numbers:  IEEE 754 format. Below are the pertinent characteristics   of floating  in   32 bit, 64 bit and   80 bit numbers.   3 different   supports   varieties   of these types:   point   These numbers are stored   Variety Bits Exponent Exponent  float  32  8  double 64  1 1   long double 80  15   127  23  "'7 digits  1023  52  "'16 digits  16383  64  19 digits   Bias Fraction   Precision   these different   The IEEE format treats   length  way, but with different  lengths  order bit is the sign bit. A negative  the remaining  number has a binary  type to reduce the number of bits   exponent   involved.   numbers   in the same   for the fields.  In each format the highest   number has its sign bit set to 1 and   and a fraction. We will focus on   the float   bits are just like the corresponding   positive number.  Each   31 30   23 22   sign bit exponent   value   0   The exponent   small  numbers  to  be  negative.  127 is the "exponent bias" for 32 bit floating   The actual   for  a float  stored,  exponent   is an 8  bit field. To allow large numbers  the exponent   or  as positive or   is interpreted  of the  8 bit field minus 127.   is  the value   point numbers.   The fraction   field of a float holds a small surprise.   Since 0.0 is defined   field equal to 127 and fraction   have at least one 1 bit, so the IEEE 754   as all bits set to 0, there is  no need to worry about representing  an exponent  numbers  bit to save space.  is interpreted  field to be effectively  making exponent   the fraction  This allows  trick made possible   as 1 .  00000000000000000000000.   fields of OxOO and OxFF special.   field set to all O's. All other   format uses an implicit   24 bits. This is a clever   So if the fraction   0.0 as   by   1   field is 000000000000000000000  00, it   A number with exponent   to OxOO is defined to be 0. In­  field equal  to store a negative   0. An exponent   of OxFF is   ngly, it is possible   teresti used to mean either   negative   or positiv  e infinity. There are more details    2.4. FLOATING POINT NUMBERS   21   for a complete   description   of IEEE 754, but this is sufficient   for   required  our needs.   To illustrate   floating   point data, consider   the following   assembly   file   segment . data   zero dd  0 . 0   one dd  1 . 0   neg! dd  -1. 0   dd  1 .  75  a  dd  1 22 . 5   b  d  e   dd 1 . 1    dd  10000000000. 0    not a program,   This  is  . data segment. The dd command specifies  Other options include  word .  A word is 2 bytes, a double word  is  bytes.   it is simply a definition  in the  db  data byte , dw  data word  and dq  data quad­ is 8   4 bytes and a quad-word   a double word data item.   of 7 f loat values   Now consider   the listing file   produced   by yasm   1  2  3 00000000 00000000  4 00000004 0000803F  5 00000008 000080BF  6 OOOOOOOC OOOOE03F  7 00000010 OOOOF542  8 00000014 CDCC8C3F  9 00000018  F9021550   %line 1+1 fp.asm  [sect ion  . data]  zero dd 0 . 0   one dd 1 . 0   neg1 dd - 1. 0   a  dd 1 .  75  b  dd 122. 5   d  dd 1 . 1   e  dd 10000000000  . 0    The zero variable is   stored   as expected   -all 0 bits.  The   other numbers   them and you get 3F800000.   one -the bytes are backwards!  might be  a little  surprising.  Look  at  nt byte is 3F.  Reverse  The most significa the other 7 bits of  The sign bit is 0. The exponent  field  consists  of  the most significa that the exponent  remaining  1.0 * 2  =  1 .0.   nt byte and the  first  bit  field is   127 and the actual binary   bits are the binary fraction   field -all O's. Thus  the   is 0. The  value is   of the next byte. This means   exponent    22   CHAPTER 2. NUMBERS   There is only 1 negative   value shown: -1.0. It differs   in only the sign   bit from 1 .0.   You will notice   that 1 .75  and 122.5 have a significa  nt number of O's   field. This is because   . 75 and .5 are both expressible   as   in the fraction  sums of negative   powers of 2.   0.75 =  0.5 + 0.25 =  2-l + 2-2   On the other hand 1 . 1  is a repeating  binary.  similar to   sequence  expressing   of bits when expressed  1 11 in decimal:   somewhat   This is   in   1 11 =  0.090909   ...   Looking at 1 . 1  in the proper order 1 . 1  ==  Ox3F8CCCCD.  0 and the fraction field in binary  like  the  1 100.   The exponent  is 000 110011001 1001 1001101 .  It looks  pattern   up and that the repeated   last bit has been rounded   is   is   1 . 110 =  1 .0001100 1 100110011001100 .. '2   Having seen that floating  that integers   might suspect  Consider   the following   are backwards   also. This is indeed true.   code which defines some 32 bit integers   point numbers are backwards, then you   segment data   zero dd  0  one  dd  1  neg1  dd  -1  a  b  d  e   dd  175  dd  4097  dd  65536  dd  100000000   The associated   listing   file shows the bits generated   for each number.   backwards. Notice   The bytes are  in memory. The first byte is the least significant  to consider  first.   this as Ox00001001, but the CPU stores   byte. We would prefer  least significant   byte   that 4097 is represented   as Ox01 100000   1  2   %line 1+1 int. asm  [section  . data]    2.4. FLOATING POINT NUMBERS   23   3 00000000 00000000  4 00000004 0 1000000  5 00000008 FFFFFFFF  6 OOOOOOOC  AFOOOOOO  7 00000010 0 1 100000  8 00000014 00000100  9 00000018 OOE1F505   zero dd 0  one  dd  1  neg1 dd -1  a dd 175  b dd 4097  d dd  65536  e dd 100000000   2.4.1 Converting decimal numbers to floats   Let's work on an example  -121.6875 to decimal.   to see how to do the   conversion. Let's convert   First let's note that the sign bit is 1 .  Now we will work on 121.6875.  of the number: 121 =  It's fairly easy  to  x = 0 .  abcdefgh, where the   portion  work on the fraction.   we have a binary fraction   the  integer   1 1 11 001b. Now we need to   convert   Let's suppose  indicate   either  letters  that multiplying   a 0 or a   1 .  Then 2*x =  a .  bcdefgh. This indicates  2 will expose a bit.   a fraction by   ·   We have 2 x 0.6875 =  1 .375 so the  first   bit to the right   of the  binary   point is 1 .  So far our number is 1 1 11001. 1b.   Next multiply   the next fraction: 2 x 0.375 =  0.75, so the   next bit is   0. We have 1 1 1 1001.1 0b   Multiplying   1 1 11001.101b .    again:  2 x 0.75 =  1.5, so the next bit is 1 .  We now have  again: 2 x 0.5 = 1, so the last bit is !leaving   1 1 11001.1 0 1 1b   =  - 1 1 11 001.1 0 1 1b .  We need to get this   Multiplying  So our number -121.6875  notation   into exponential   with a power of 2.   - 12 1.6875   =  -1 1 11001. 1011  = - 1 . 1 110011011  * 26  The sign bit is 1 ,  the fraction  without   We now have all the pieces.   the implied  127+6 =  133 =  10000101. So our number is   1  is 1 1100 110110000000000000   and  the   exponent  field is   1 100001 0 1  1 1 10011 0 1 1 0000000000000.   Organized   into nibbles,   this is 1 100 0010 1 1 1 1  001 1  0 1 1 0  0000 0000    24   CHAPTER 2. NUMBERS   0000 or Oxc2f36000. Of course if  you  see  reversed:  . 0060f3c2.   this in a listing   it will be   2 .4. 2  Converting floats to decimal   An example  te how to convert  Let's work on the float value Ox43263000.   will illustra  a  float to a decimal   number.   The sign bit is  0,  010000 1 1 0  which  is  134, so the binary  is 010 0 1 10 001 1  0000 0000  0000  is 1 .  0100 1 1000 1 1 .    so the number is positive.   exponent   The exponent  field is  is 7. The fraction   field   0000, so the fraction   with implied   1   1 .01001 1000 1 12 * 27 =  10100110.00112  =  166 + 2-3 + 2-4  =  166 + 0.125 + 0.0625  =  166.1875   2.4.3 Floating point addition   Let's add the numbers   point numbers,   we must first   convert  the   In order to add two floating  numbers  and add the numbers.   to binary   Finally   real numbers.   Then we   we need to convert   need to align the binary  points  back to floating  point.  41.275 and 0.315. In hexadecimal  these num­ Ox4225199a to  field  is  com­ bit from the next nibble.  This is   . The exponent   and  a  0   bers are Ox4225199a and Ox3ea147ae. Now let's convert  a binary number with a binary exponent posed of the first two nibbles  100001 002 =  132, so the exponent  with the understood  1  bit is   is 132-127 =  5. The fractional  part   1 .01001010  001 1001 1001  10102   So we have   Ox4225199a =  1 .010010100011001100110102 * 25   =  101001.0100011001100110102    2.4. FLOATING POINT NUMBERS   25   Similarly   Ox3ea14 7ae has an   exponent   field of the first 2 nibbles   and   a 1 from the third nibble.  yielding  IS   an exponent of   So the exponent   field  is   0 1 1 1 1 1012 = 125   -2. The fractional   part with the understood   1 bit   1.010000101000111101011102   So we have   Ox3ea147ae = 1.010000101000111101011102   * 2-2   = 0.01010000101000111101011102   Now we can align the numbers   and add   101001.0100011001 10011010   +   0 .010100001010001 1 1 10101110   10100 1 .10010 1 1100001010010101110   Now we have too many bits   to store in a 32 bit float. The rightmost   7 bits will be rounded    dropped in this case  to get   101001. 1001011100001010012  * 25  = 1.0100 1 1001011100001010012   So the exponent   is 5 and the  exponent   field is again 132. Dropping   the leading   0, we get Ox42265c29   which is 41.59  approximately   some  bits  case we could try   to add 1.0 to a number   .  of precision  on the   You should  be   able to see that we  lost   number. In an extreme   smaller  like 1038 and have no effect.   2.4.4 Floating point multiplication   point multiplication   Floating  imal multiplication.  sion and just focus on the multiplication   Let's skip the  floating   of 7.5 and 4.375.   point to from   can be performed in binary much like dec­  binary conver­  7.5   *  4.375   1 1 1.12   100.0112   1 11 12  1 1 1102  1 1 11000002  100000.1 1012    26   CHAPTER 2. NUMBERS   Exercises  1. Convert   a. 37  b. 350   the following   integers   to binary.   c. -65  d. -427   2. Convert   the following 16 bit signed   integers   to decimal.   a. 0000001010101010b  b. 1 1 1 1 1 1 1 1 1 1 1  01101b  d. Oxffcc   c. Ox0101   the following   integers   to binary.   3 .  Convert  a. Ox015a  b. Oxfedc   16 bit unsigned  c. Ox0101  d. Oxacdc   4. Convert   the following   numbers   to 32 bit floating  point.   a. 1 .375  b. 0.041015625   c. -571.3125  d. 4091.125   5. Convert   the following   numbers   point to decimal.   a. Ox3F82000  b. OxBF82000   from 32 bit floating  c. Ox4F84000  d. Ox3C86000   6. Perform the binary addition   of 2 unsigned   integers   below. Show   each carry as a 1 above the proper position.   000100101 100 1 0 1 1   +11 10 1 10 11 1 10 1 0 1 1    7. Perform   numbers.  number.  number.   the binary multiplication   of the following   Show each  row   1 is multiplied  You may omit rows where a 0 is multiplied   where  a   unsigned  times the top  times the top   binary   1011001 0 1 1    *   1101101   8. Write an assembly   "program"   data values using   dw and dd for all the numbers    data only  defining  in exercises   1-4.    Chapter 3   Computer rnernory   In this  chapter we  will discuss  mapping to give each process  Linux system manages  the  memory  for  of this chapter  debugger.   how a modern computer  a protected   is a discussion   of how to examine   a process.   address  space  and how the  A practical   memory using the gdb   performs memory   benefit   3 . 1  Memory mapping   The memory of a computer  byte of memory has an address.  byte at address   1 ,  and so on until the last   The first byte is at address  byte of the computer  0, the second  's memory.   can be considered   an array of bytes. Each   In modern CPUs there are hardware  address  which starts   to give each process  people  same time.  they are using memory at different   run a program  These processes   a protected   can each   perceive   mapping  space.  This   registers   which are used   means that multiple   at address  the same "logical"   at the  Ox4004c8  addresses,  while   "physical"  on an x86-64   addresses.   CPU can map pages of   The hardware   mapping   registers   sizes -4096  bytes and   2 different  for the kernel and  4 KB pages for most other uses.  In  recent   CPUs there is also support   for  1 GB pages.   2 megabytes. Linux uses 2 MB pages   some of the more   The operation   the address-from a process's logical  consider   address  only 4 KB pages. Then an address   is translated  based   address.  on the   Let's   of the memory system is to translate  to a physical   the upper bits of   27    28   CHAPTER 3. COMPUTER MEMORY   address   within the page. Suppose   a  reference is  Since 4096 = 212, the offset  1 2  bits  Ox220 . The page number   Ox4000002220.   page number and the address  made to logical  within the page is  the  is the rest of the bits  Oc=x4000002 . A hardware  registers this page number to a physical  Ox780000000. Then the two addresses  are combined  address     translates   right-most   page address,  let's  say   Ox780000220.   register    or multiple   to get the physical   Amazingly   the CPU generally   performs the translations   without  slow­  'the users in several   ing  down  and  this  benefits  benefit is memory protection.  writing  protected  process  from writing,   from other user processes.   from malicious   users  can't   read other users'   is protected   or poorly   data.   User processes are limited   only their own pages. This means that the operating   to reading  system is   and   ways. The most obvious   coded user programs. Also each user   In addition   to protection   There are instructions   used by the operating   system to manage the  are not discussed  in this   hardware  book.  Our   mapping   registers.   focus is on programming   These instructions  user processes.  if we are  this improves   So why bother   to discuss paging,   not discussing   the instruc­  When you write software   tions to manage paging? Primarily  of the computer.  the end of an array, you sometimes  you only get a segmentation  enough past the end of the array to cause the CPU to reference a page  table entry which is not mapped into your process.   get a segmentation   data beyond  fault . However   fault when  your   which accesses   address   logic:al   reaches  far   one's understanding   3.2 Process memory model in Linux   is divided   into 4 logical  The  stack is mapped to the highest  and on x86-64 Linux this is Ox7fffffffffff  is selected  based   regions:  address  or 131 TB. This  on the maximum number of bits allowed   In Linux memory for  a  process  data, heap and stack.  process  address  logical  decision  extend bit 48 through   in  is 4 7 bits of all  1 bits. The  addresses  have to   was made to not use bit 48, since canonical   being 48 bits. This address   bits 49-63.   addresses   text,  of a   In figure 3.1 we see the arrangement   we have the text segment   of the various memory segments.    .text for yasm . This   At the lowest address  segment   is shown starting   at  0, though both _start and main are  at    29   131TB   3.2. PROCESS MEMORY MODEL IN LINUX   that the lowest ad­  . It appears   higher addresses dress in an x86-64 process  segment  data segment  segment. Above these two segments  and stack   does not typically   is placed   segments.   immediately   is Ox400000.  need to grow, so the   The text   above the text  are the heap  with the . data seg­ data. Above that is   initialized   starts   The data segment  ment which contains  the . bss segment  by symbol". The . bss segment  is statically  in the executable  when the process  contents   file. Instead  is loaded  of the . bss segment   allocated   The heap is not really   which stands for "block  contains   started  data   data which   in a process,   but is not stored   this data is allocated   into memory. The initial   0   are all 0 bits.   in a data structures   cussed  namically  to allocate  the new operator  large sizes.  swap space.   region   resizable  memory to a process  in C++. In x86-64   The limit is imposed   a heap in the sense dis-Figure 3.1: Process  course.  of memory which is   is a dy-memory layout   Instead   used   through functions   like malloc in  C and   Linux this  region  of physical   by the  sum   can grow to very   memory and   The final segment   of a process   is the stack segment. This segment   is   in size by the   restricted  not a large amount of space,  large arrays  run-time  and return   addresses.   Linux kernel, typically   but as long as the programmer   to 16 megabytes. This is  avoids putting   on the stack it serves   the purpose  stack keeping track of function  calls,   quite well of managing  parameters, local   variables   the   Given  the   top of the stack as Ox7fffffffffff   and the stack size   the lowest valid stack  address   to 1 6  megabytes we  see  that   limited  Ox7fffff000000.  operating system responding  the faulting address  ognizes  to Ox7fffffffffff,  page of memory   4096 bytes  to  the   is  The stack automatically grows  the  system rec­  to a page fault. The operating  as being in the range from Ox7fffff000000  for the stack and allocates   which is only used  process.   when needed  by   a new   This simple   memory layout is not entirely   accurate. There are shared   files which can be mapped into a process   after the program  is   object  loaded which will result   in regions   in the heap range being used to  to    30   CHAPTER 3. COMPUTER MEMORY   store instructions  memory regions   into a process.   and data. This region   is also used for mapping   shared   If you wish to examine   the memory used by one of your processes,   you can execute  by your process id.  To see the memory   "cat  proc 999 maps" where 999 needs to be replaced   shell process,  enter   used by your   Here is a sample assembly   program   with several   memory items defined:   cat  proc $$ maps   3.3 Memory example   . data  segment  4  dd  4 . 4   dd  t imes  10 dd 0  1 '  2  dw  Oxfb  db  "hello world",  0  db   a  b  c  d  e  f   g  h  i   main:   . bs s   segment  1  resd  10  resd  100  resb   segment  global   . text  main   push  mov  sub   rbp  rbp ,  rsp,   rsp  1 6    eax,   eax   xor  leave  ret   l et the linker know about main   set up a stack frame for main  set rbp to point to the stack fram·  leave some room for local variable�  leave rsp on a 16 byte boundary  set rax to 0 for return value  undo the  stack   frame manipulations   After assembling the program we get the   following   listing  file:    3.3. MEMORY EXAMPLE   31       04000000  CDCC8C40  OOOOOOOO 01000200  FB  68656C6C6F20776F72- 6C6400   %line 1+1 memory. asm  [section  . data]  a  dd  4  b  dd 4 . 4   c t imes 10 dd 0  d  dw 1 ,  2  e db Oxfb  f db "hello world",  0   1  2  3 00000000  4 00000004  5 00000008  6 00000030  7 00000034  8 00000035  9 00000035  1 0   1 1   1 2  00000000     13 00000004     14 0000002C     1 5   16  1 7   1 8   19 00000000  20 00000001 4889E5  2 1  00000004  22 00000008  23 OOOOOOOA  C9  24 OOOOOOOB   4883EC10  31CO   55   C3   [section  . bss]  g resd 1  h resd 10  i resb 100   [section  . text]  [global  main:   main]   push rbp  mov rbp , rsp  sub rsp, 1 6   xor eax, eax  leave  ret   You can see from the listing   the relative addresses   we have a double  bytes of a are reversed   of the defined data  word   4 bytes  named a   compared  to  what   Notice that  the   elements. In the data section  at location  0.  you might prefer.  Following  b at relative  Ox408ccccd.  7 bits of the "first"  Ox8c. So the exponent  2. The fraction  1 .0001100 11001 1001 1001  a is a double word defined  address  Then the  sign   101 * 22 =  4.4.   as  a floating   point value named   4.  The  bytes for  exponent   b are also reversed. Consider  it  field is the rightmost   bit is  0,  the   as   byte, Ox40, with the leftmost bit of the next byte,  of   field is Ox81 = 129, which is a binary   field  with the implied   initial  1 bit  is Ox8ccccd. So b =   exponent   The next data item is the array c defined with the times pseudo-op   which has 1 0  double word locations.   The relative   location   for c is 8 and    32   CHAPTER 3. COMPUTER MEMORY   c consists  Ox30.   of 40 bytes,   so the  next   item after c is at relative   address  48 or   Following   c is the length   2 array d with values   1 and 2. Array d is of   type word so each value is 2 bytes.  reversed   for each word of d.   Again you can see that the bytes  are   The next data item is the byte  variable  After e is the byte array f which is initialized  I have added a  end in null bytes.   null byte explicitly   e with initial  with a string.   value Oxfb.  Notice  that  in yasm do not   to f .  Strings   terminal   After the data segment   I have included   a bss segment   with 3 variables.   addresses   as  part of the bss segment.   the bss data  items  will  be  means "reserve"   loaded into memory beginning   double word. With  word. The next bss item ish which has   double words. The last bss item is i which has 100 reserved   with their relative   These are listed  After linking  with g defined by resd op-code which  resd the number 1 means 1 double  10 reserved  bytes.  to the start of the  bss  program   All these data items   are shown   starts.   segment. They  will   all have value 0  when the   in the listing   with addresses relative   3.4 Examining memory with  gdb   we will focus on using the gdb print  p  and examine  print some data values   command which can     x    enough to print various forms of C expressions.  Examine   In this section  commands. Print is a simple  and is versatile  is strictly  arrays   for printing  types.   of various   data from memory and is quite useful   for printing   3 .4 .1  Printing with gdb   The format for the p command is either  where FMT is a single  mat choices   defining   letter   are   p expression or p FMT expression   the format of data to print. The for­   3.4. EXAMINING MEMORY WITH GDB   33   letter format    default    d  decimal  X  hexadecimal  t  binary  u  unsigned  f  floating  point  1  instruction  c  character  s  string  a  address   Let's see a few commands   in action   in gdb:            gdb  p  a  $32 = 4   gdb  p a &a  $33 = Ox601018   gdb  p  b  $34 = 1082969293   gdb  p f b  $35 = 4 .4000001   gdb  p a &b  $36 = Ox60101c   gdb  p x  &b  $37 = Ox60101c   gdb  p a  &c  $39 = Ox601020     gdb  p a &d  $40 = Ox601048     gdb  p a &e  $41 = Ox60 1 04c     gdb  p a  &f  $42 = Ox60104d     gdb   p a  $43 = Ox601070      gdb  p a &h  $45 = Ox601074     gdb  p a &i   &g    34   CHAPTER 3. COMPUTER MEMORY   $46 = Ox60109c     We see that gdb handles   a perfectly.  It gets the type right and the  . Notice that a is   It needs the If option to print b correctly at address   Ox601018 which is 24 bytes after the start of a page  a, though there is  see that the data  until f which   length.  located  in memory. gdb will prohibit  no hardware  restriction  to  the  segment  starts  segment  are placed back to back in memory with no gaps.   accessing  previous   in memory one after another   at Ox60104d and extends   to Oc601058. There is   24  bytes.  We   with g at address   memory before   a gap until the bss   variables   which starts   are placed   Ox601070. The bss data  items   3.4.2 Examining memory   Notice that there are no length  doubles  p. The examine   command handles   this job readily.   specifiers   with p. If you want to print   in memory it could be done with some mental gymnastics   with   The format for examine   is x NFS address where N is a number  of   1   ,  F is a single   items to print  default  command and S is the size of each memory location.  picked some size letters  yasm. Here are the size options:   which conflict   letter   Unfortunately gdb  in   with some of the size options   format as used in the print   letter SIZe bytes   b  byte  1  h  halfword 2  w  word  4  g  giant 8   Here are some examples   of examining   memory:    gdb  x w &a  Ox601018  : Ox4   gdb  x fw &b  Ox60101c   gdb  x fg &b  Ox60101c  : 5 .3505792317228316e-315   gdb  x 10dw &c    : 4 .4000001    3.4. EXAMINING MEMORY WITH GDB   35   &d   Ox601020  :  0  0  0  0  Ox60 1030  :  0  0  0  0  Ox601040  :  0  0   gdb   x 2xh  Ox601048  : Ox000 1  Ox0002   gdb  x 12 cb &f  Ox60104d   :  1 04 ' h '10 1  ' e '108 ' 1 '108 ' 1 ' 11 1  ' o' 32 ' ' 119' . . .   Ox601055  : 1 14 ' r '108 ' 1 '100 ' d ' O  ' \000'   gdb  x s &f  Ox60104d  : "hello world"   Things match what you expect   b with the correct   I first printed  bytes . gdb interpreted  a double  getting  field is quite useful   for dumping   the wrong exponent   memory.   8 bytes of memory starting   format and size.   if you use the correct  size and then with the giant size  8  at the address  of b as  The use of the count   and fraction.    36   CHAPTER 3. COMPUTER MEMORY   Exercises   1 .  Write a data-only program   like the one in this chapter  in the data section array of 10 8 byte integers  and a string  integers  bss section,  command to print the 8 byte integers  section.  hexadecimal,  the 2  byte integers  values, and the string  as a string.   in the  Use gdb's examine   terminated   ,  an array of 5 2 byte   by 0 in the   as unsigned   to define an   data   in   2. Assuming   that the stack size limit is 16MB, about how large can  an array of doubles inside  Do not use   a C++ function.   you declare  the keyword static.   3. Find out the stack size limit using the ulimi t command in bash.   If bash is not your shell, simply type in bash to start a sub-shell.   4. Print the   value of rsp in gdb. How many bits are required   to store   this value?    Chapter 4   Melllory Inapping in 64 bit  In ode   we discuss   chapter   In this  lated to physical  for translation   is stored   addresses   the details  in  the   x86-64 architecture.  in the CPU and some of it is stored   of how virtual addresses  are trans­  Some  of the   data   in memory.   4.1 The memory mapping register   named this register   "Control  Register  that it is a pointer  to the top level of  memory which define the  translation  sees  to physical   your program   3" or just   view of CR3  is   Well the CPU designers  CR3.  A simplified  a hierarchical  from virtual  dresses.  let's consider  Somewhere   first how the  kernel   The CPU retains   in the   collection of  tables in  addresses    the addresses   quite a few page translations  CPU starts   all this translation  an initial  and CR3  is filled  with   of the operating  prepared   system,   internally,  process.   the address   hierarchy   the hierarchy. This table is given the illustrious   tables  is   of the translation  of the top level table  in  name "Page Map Level4" or PML4. When the CPU is switched  memory mapping on  by using CR3  to fetch the address  for  future use.   the next memory reference  it  of PML4. Surely it must retain   starts  PML4's address   to using   ad­ but   37    38   CHAPTER 4. MEMORY MAPPING IN 64 BIT MODE   4.2 Page Map  Level   4   A virtual   address   can be broken into fields like   63-48  47-39 38-30   this:  29-21   20-12  1 1-0   unused  PML4 page page page  page  offset   index directory  directory  table   pointer index index  index   Here we see   that a virtual   or logical   address   is broken into   6 fields.   The   16 bits are ignored. They are supposed   top-most  of bit 47, but they are not part of the  address  unused bits are  12  bit  address like  it was OxlfO to yield a   Ox7fffff008000 which is combined   translation.  the  translation  a  process  with the offset  let's say   physical  address   of the translation   page offset.  The result   of Ox7fffff0081f0.   four 9  bit fields   which undergo   Following  and finally   will be a physical   to be a sign extension   Pages of memory are 212 =  4096 bytes,   sense. What about those 9  bit fields?  you can store 512 addresses  each of the 4 types  of  storing   so the 12 bit offset makes  in a page and 512 = 29, so 9  bit fields allow  mapping   in a page of memory.   Well, addresses   are 8 bytes so   tables   Bits 47-39 of a virtual   address   as used as an index into the PML4 table.   an entry   is valid or not.   The PML4 table is essentially  point to pages of memory,  used for other purposes  Generally   not all entries   like indicating  in the PML4 will be valid.  that CR3 has the physical   whether   an array  of  so the rightmost   512 pointers.  12 bits of each pointer  can be   These pointers   Let's suppose   address  that bits 47-39 of our sample address   Ox4ffff000. Then  are Ox001, then we   let's suppose  would have an array in memory at Ox4ffff000 and we would access  the  second entry  index 1  to get the address  pointer  -Ox3467000.  PML4 at Ox4ffff000  Ox3466000  Ox3467000  Ox3468000   of a page directory   0   2   table   511   unused    4.3. PAGE DIRECTORY POINTER TABLE   39   4.3 Page Directory   Pointer   Table   pointer   memory translation  tables.  Each  of   The next level in the  page directory  512 pointers.  that our sample address  has  the  computer  will fetch the third  lead next to a page directory   These pointers are   to page directory  value Ox002 for bits 38-30. Then the  table to   entry of the page directory  table at address   of  an array of   these tables  is  also   hierarchy   Ox3588000.   tables.   pointer   Let's assume   is the collection   4.4 Page Directory   Table   tables.   The third level in the memory translation  page directory  which point  value OxOOO for bits 29-21 .  Then the computer  the page directory   Each of these tables   to page tables.   Let's assume that our sample address  will fetch the first entry of   has the   hierarchy  collection  is also an array of 512 pointers,   is the   of   table to lead next to a page table at address   Ox3678000.   Page Directory   Pointer Table   at Ox3467000  Ox3587000  unused  Ox3588000   0  1  2   511   unused   Page Directory Table   at Ox3588000  Ox3678000  Ox3579000   unused   0  1  2   5 1 1    unused   4.5 Page Table   The fourth and last level in the memory translation  tion of page tables.   Again each of these tables   is an array of 512 pointers   hierarchy   is the   collec­   40   CHAPTER 4. MEMORY MAPPING IN 64 BIT MODE   to pages. Let's assume that our sample address  bits 20-12. Then the computer  to lead next to a page at   Ox5799000.   address   will fetch the last entry of the page table   has the value Ox1ff for   Page Table  at Ox3678000  Ox5788000  Ox5789000  Ox578a000   0  1  2   5 1 1   Ox5799000   After using 4 tables   was originally  the original  referenced.   -say Oxfa8. This yields   we reach the address  Then we can   or in the page offset  bits 1 1-0  of  of Ox5799fa8.   address   a final physical   of the page of memory which   4.6 Large pages   4096 bytes. The CPU designers   for large pages using three levels   The normal size page  is  support  By using 3 levels  page offset field. This makes large pages 221 =  2097152 bytes.   there are 9 + 12 =  21 bits left for the within   of the existing   translation   of tables,   have added   tables.   4. 7 CPU Support for Fast Lookups   too slow if done every time by traversing   would be entirely  all these tables. Instead   This process  through  performed, the CPU  adds  lation  Lookaside  many times without   this translation   whenever   into a cache called   a page translation   has been  a "Trans­ will be  used  the table lookup process.  with a vir­  It is presented   this page   A TLB operates   going back through  much like  a  tual page address and  produces  roughly  takes from 10 to 100 cycles.  Typical   or failure within  1 2 of a clock cycle. In the case of a failure the memory search   a physical page  address   miss rates are from 0.01% to 1%.   hash table.   Buffer" or TLB . .  Then hopefully   Clearly   there is a limit to the number of entries  Core 2 series   of 16 entries   in the TLB for a CPU.  in a level 1 TLB and 256   has a total   The Intel    4. 7. CPU S UPPORT FOR FAST LOOKUPS   41   in a level 2 TLB. The Core i7 has 64 level 1 TLB entries   entries  level 2 entries.   The AMD Athlon II CPU has 1024 TLB   Given the relatively   small number of TLB entries   and 512  entries.   in a CPU it seems  2 MB  pages   for   Linux supports   like it would be a good idea to migrate  programs.  option.  memory regions  performance   using the SHM__HUGETLB  of processes  using   adjusting   It requires   to allocating  the use of 2 MB pages through  the system parameters and   its HUGETLB  allocating  shared   option.  This   could improve the   large arrays.    42   CHAPTER 4. MEMORY MAPPING IN   64 BIT MODE   Exercises   you were given the opportunity  the memory  hierarchy for a new CPU. We have seen that 4 KB pages  pages  217 =  131072   1 .  Suppose  mapping  seem  a little  bytes. How  many  many bits  would  be  How would you break up the bit fields of virtual   small. Suppose you  made  the   of a page table?  addresses?   would fit in such a page? How   for the addressing   64 bit pointers   to redesign   required   2. Having much   larger pages   mapping system  with  for memory mapping  mapping   seems desirable.   Let's design  a  220 =  1 048576 bytes but use partial  of page  system with 3 levels  tables. Design  a  space.   memory  pages   with at least   48 bits of usable   virtual   address   tables    Chapter 5   Registers   While the memory is relatively   fast, there  is   of bytes which software  uses   an  array   memory is essentially   Computer  for instructions  and  data.  a need for a- small amount of faster data to permit  instructions  is perhaps  memory is  the CPU has   faster. One type of faster  memory is  10 times as fast as main memory.  A  the CPU's registers.   Cache might be several   The x86-64  CPUs   only a few registers.  have 16 general   the CPU to execute   cache memory, which  second type of faster   megabytes,   but   purpose  These floating   64 bit registers  and 16  point registers   are either   register   point registers.   There is also a floating   or floating point values.   on the CPU model and can operate   modern floating  128 or 256 bits depending  integer  which we will not use in this book. The CPU has a 64 bit instruction  pointer  the address  to execute.  There  is  also  flags register  additional  mean that a regist using registers  addresses.   which we probably  is only 4   much smaller, than if instructions   won't use. Having 16 registers    rip  which contains   bits. This makes instructions   of the next instruction   rflags   .  There are   had to use only memory   on multiple   point register  stack   er's "address"   registers   a 64  bit   The 16 general  purpose  registers   are 64 bit values stored   can access the   CPU. Software  bit values  the registers  finally   and 8 bit values.   have evolved   to 64 bit registers.   registers   within the  as 64 bit values, 32 bit values, 16  from the 8088 CPU,  and   Since the CPU evolved  from 16 bit registers   to 32 bit registers   On the 8088 registers were   more special purpose   than general   purpose:   43    44   CHAPTER 5. REGISTERS     ax -accumulator   for numeric   operations     bx - base register    array access      ex -count register    string   operations      dx -data register     s i - source   index     di -destination   index     bp - base pointer    for function   frames      sp -stack pointer   For the x86-64 architecture   In addition  for the low byte of  dl and dh for the halves   the 2 halves of   the first 4  registers   can be accessed  ax, ah for the high byte of ax, and bl, bh, cl, eh,   using al   When the 386   of bx, ex and dx.  CPU was designed  as eax, ebx, e cx, edx,  names to access   bits and renamed  could also use the original  registers.  to individual   bytes of the  upper   The 8 bit registers   were also retained   the registers   were expanded  to 32   esi, edi, ebp, and esp. Software   to lower 16 bits of each of the  allowing   without   access   of the registers.   halves  the registers  registers   were expanded   to 64 bits  were added. The names used   general   are rax, rbx, rex, rdx, rsi, rdi, rbp, and   purpose  64 bit registers   and 8 additional  to access the  rsp for the compatible  you might  expect  you  can  still  rax register  You  r8-r15 as byte, word, double  word  can also access  by  appending   collection and  use ax to access   b,  w or d to the register  name.   along with eax to access   the lowest word of the   registers   the lower half of the register.   r8-r15 for the 8 new registers.   registers   As   The rflags register   is a 64 bit register,  generally   sufficient to refer to eflags. In addition   but currently   only the lower   used, so it is   32 bits are  the flags  register  instructions  register   to determine   what action   to take.   is usually   Instead  are used which internally access   not referred to directly.   1 or more flags of the  flags   conditional   Moving data seems to be a fundamental   task in assembly   language.   In the case of moving  mand is mov. It can move constants, addresses   to from the integer   values   registers, the basic com­  and memory contents  into    5.1. MOVING A CONSTANT INTO A REGISTER   45   registers,  a register   move data from 1 register  into memory.   to another   and move the contents   of   5 . 1  Moving a constant into a register   referred to as an immediate   The first type of move is to move a constant into a register.  usually  as part of the  for most instruCtions.  values.   operands  The mov instruction   instruction.   value. It consists   Immediate   also allows   A constant is   can be 1 ,  2 or 4 bytes   of some bytes stored   8 byte immediate   mov  rax, 100  mov  eax, 100   Surprisingly,   these two instructions  operations   value 100 into rax. Arithmetic  references  are zero-extended  moving constants.   to 8 bytes.   have the same effect -moving the   and moves with 4 byte register   Below is a gdb session   illustrating   mov  rax , Ox1a1a1a1a1a1a1a1a  mov  eax, 100  mov  rax, Ox1a1a1a1a1a1a1a1a  mov  rax , 100    gdb  list 2 1, 24  2 1   22  23  24   gdb  break 2 1   Breakpoint 1  at Ox400508: file test.asm, l ine 2 1.   gdb  run  Starting program:  home seyfarth teach  ing asm test   1 ,  main      at test. asm : 21  mov  rax, Ox1a1a1a1a1a1a1a1a   mov  eax, 1 00   Breakpoint  2 1    gdb  nexti  22   gdb  print x  $2 = Ox1a1a1a1a1a1a1a1a   gdb  nexti  23   gdb  print x   $rax   $rax   mov  rax, Ox1a1a1a1a1a1a1a1a    46   CHAPTER 5. REGISTERS   mov rax, 1 00   $3 = Ox64   gdb  nexti  24   gdb  print x  $4 = Ox1a1a1a1a1a1a1a1a   gdb  nexti  25   gdb  print x  $5 = Ox64   mov rax,  0   $rax   $rax   You can   see that the gdb prompt is  gdb . The first command entered  24 of the source   IS "list 2 1, 24". This command lists line 21 through  file. You can abbreviate   "list" as "1".   The next command is "break 21" , which sets a break point   at line 21.  as "b". A break point is a statement  which  the control   in  executed.  Instead   when the program  passed back to the debugger.   "break" can be abbreviated  will not be  executed  will  be  the debugger  reaches   line 21. It breaks   there without   running   starts   the program,   processing   After issuing   the "run" command  instructions   until it  that instruction.   executing   The next command is "nexti" which means execute   the next instruc­ "nexti" can be  abbreviated   as "ni".   the debugger.   tion  and return to  After executing  imal. "print"  large value is to show that moving to eax is sufficient   that move, the value of register  can be abbreviated   as "p". The purpose   for small  values.   rax is printed   in hexadec­  of loading  the   You can follow the sequence   of statements and observe  rax. It  turns   that moving   is stored   100 into eax will  clear  bit constant  100. Also the instruct into rax is 3 bytes long. The shorter  be tempted  the rest   out the top half of  in the instruction  ion to move into eax is 1 byte long  and   stream for the moves which move  the move  You might   to move 100 into al, but this instruction   instruction   of the register  is preferable.   does not clear out   out that a 32   .   5 . 2  Moving values from memory into registers   In order to move a value from memory into a register,  address   of the value. Consider   the code below   you must use the   segment . data    5.2.  MOVING VALUES FROM MEMORY INTO REGISTERS 47   a  b   dq  dq   175  4097   The label a is will be replaced  the following   by the address  statement   instruction.   Consider   in the . text section.   of a if included   in an   mov  rax ,  a   has a  32  bit   The instruction  address  received   of a when the program  the value Ox601018.   constant  is executed. When tested,   field which is replaced   with the   the rax register   The proper syntax to get the value of a, 175, is   given below:   mov  rax, [a]   This is technically  is " load constant"   a different  and the latest one is  "load   from the other   instruction   from memory" .   mov. The other   Let's throw in an add instruction   and do something real.   segment . data  dq  175  dq  4097  segment . text  global  main   a  b   main:   mov rax, [a]  mov  a into rax  add  rax, [b]  add b to rax  xor  rax, rax  ret   You will notice   that my main routine   fore there is no need to establish  stack pointer  the debugger.   to be a multiple   calls no other function.   There­ a stack frame and no need to force the  in   of 16. Here is the result   of running this    gdb  b main  Breakpoint   gdb  r  Starting program:  home  seyfarth teaching asm add1   1 at Ox4004c0: f ile add1. asm , line 7 .     48   CHAPTER 5.  REGISTERS   a into rax  mov   add  rax, [b]  add b to rax   mov  rax, [a]   Breakpoint 1 ,  main      at add1. asm : 7   7   gdb  n  8   gdb  p $rax  $ 1  = 175   gdb  n  9   gdb  p $rax  $ 2  = 4272   gdb  p  a  $3 =  175   gdb  p  b  $4 = 4097   gdb  p a+b  $5 = 4272   xor rax , rax   We see that the correct   sum is placed   in rax by the add instruction.   gdb knows about the labels   We also see that  and b, and can even compute  by yasm does not inform gdb of the data types,  variables  expressions   Still,  .   can be quite convenient  word integers.   are double   their sum. Unfortunately   in the code. It can print  the code produced   a   so gdb assumes that  the  to print arithmetic   this ability   There are other ways to move data from memory into a register,   but   this is sufficient for simpler  addresses  in registers  arrays.   programs.   and using registers   The other   methods   involve  to hold  indexes   or offsets  in   storing   You can move integer   values less than  8 bytes   in size into a register.   specify a an 8 bit register   bits of the register arc   such as al or a 1 6  bit register   such as ax,  unaffected. However it you specify   If you  the remaining  a  32  bit  register  or may not be what   you wish.   such as eax, the  remaining  bits  are   set to 0. This may   Alternat  ively you can use move and sign extend    movsx    or move and.   64 bit register   zero extend   movzx  to control  use the  instruction.  sign extend a   There is one surprise  double word: movsxd.   as  a destination   and add a length   - a separate   instruction   qualifier  to the  to move and   the process.   In these cases you would   Here are some examples:    5.3. MOVING VALUES FROM A REGISTER INTO MEMORY 49   movsx rax, byte [data]  movzx rbx, word [sum]  movsxd rex, dword [count]   move byte, sign extend  move word, zero extend  , sign extend  move  dword  5.3 Moving values from a register into memory   to memory is very similar   to moving from   -you simply swap the operands so that the memory   Moving data from a register  memory to a register address   is on the left  destination mov  [a]  ,  rax    .   5.4 Moving data from one register   to another   Moving data from one register  simply place 2  register   to another  names as operands   is done as you might expect - to the mov instruction.   mov  rbx, rax ; move value in rax to  rbx    50   Exercises   CHAPTER 5. REGISTERS   1 .  Write an assembly   program   to define 4 integers  positiv  e values and 2 negative  using hexadecimal   values.   e numbers   in the . data section.   Give two of these integers  Define one of your positiv Write instructions  and add them  with  single-step  modified.   to load the 4 integers  into 4 different  the sum being left in a register.   Use gdb to  each register  as  it is   through your program  and   inspect   notation.  registers   program   2 .  Write an assembly  1 ,  2 ,  4 and 8 bytes.  extension  for the shorter  in  a memory location.   to define   4 integers  -one each of length   Load the 4 integers into   4 registers   using sign   values. Add the values and store the sum    Chapter 6   A little bit of math   mathematical  operation   is addition.   we have discussed  multiplication   and  division   it is   So far the  only  With negation, addition,  possible  integer   to write some interesting  arithmetic.   subtraction,  programs.   For now we will   stick with   6 . 1  Negation   The neg instruction  can be either  a general purpose  register  precede a   the two's complement  or a memory  specifier   of its operand,  reference. You can  from the following   memory reference   with a size   performs   table:   which   Specifier Size in bytes  1  byte  2  word  dword  4  qword   8   The neg instruction   it is possible   to do conditional   The following   code snippet   sets  the sign flag   operations  illustrates    ZF , so   SF  and the zero flag  afterwards.  a few variations   of neg:   neg  neg  neg   rax  dword [x]  byte [x]   negate the value in rax  negate a  4 byte integer  negate a byte at x   at  x   51    52   CHAPTER 6. A LITTLE BIT OF MATH   6. 2 Addition   Integer  addition  has 2 operands:  source and   the destina  is performed  a destination   using the add instruction.  and a source.   It adds the contents  of the   This instruction   The source   tion and stores the  be an immediate   result   operand can   value  constant  of 32 bits,   in the destination.   a memory reference  ory reference  reference.   or a register.   The destination   can be either  a mem­  or a register.   Only one of the operands   can be a memory   The add instruction   sets or clears   flags in the rflags register   several  These flags can  be   following   of the operation.   the add. The overflow   overflows. The sign flag   based on the results  tional statements  addition  The zero flag  ZF  is set if the result  is 0. Some other flags are set related  to performing binary-coded-decimal  arithmetic.  versus  are special   used in condi­ flag  OF  is set if the  result.   numbers  are the same.  There    SF  is set to the sign bit of the   add for signed   There is no special  since the operations  instructions   num�ers  unsigned  and unsig'hed    inc , which can be used to   and multiplication.   There is a special   instruction   for division   signed   increment  a register or   a memory location.   add 1 to either   Here is a sample program   with some add instructions   .   segment . data  dq  151  dq  310   a  b  sum  dq  0   segment . text  global main   main:   push rbp  mov rbp, rsp  sub  rsp, 1 6   set rax to 9  mov rax, 9  add  [a] ' rax  add rax to a  mov rax , [b]  get b into rax  add  rax, 10  add 10  to rax  add  rax, [a]  add the contents  mov  [sum], rax save the sum in  sum   of a    6.2. ADDITION   53   mov  rax ,  0  leave  ret   Below is a gdb session   illustrating   this program.    gdb   b 1 1   Breakpoint   gdb  run  Starting program:  home seyfarth teaching asm a  1 at Ox4004c8: f ile add2. asm , l ine 1 1.   dd2   1 ,  main   at add2. asm :1 1   mov  rax ,  9 set rax to  9   add  [a], rax  add rax to a   Breakpoint  1 1    gdb   ni  1 2     gdb  p  $'rax  $ 1  =  9   gdb  ni  13   gdb  p  a  $2 = 160   gdb  ni  14   gdb  p $rax  $ 3  = 310   gdb  ni  15   gdb  p $rax  $4 = 320   gdb  ni  1 6    gdb  p $rax  $5 = 480   gdb  ni  17   gdb  p sum  $6 = 480   mov   mov  rax, [b]  get b into rax   add  rax, 10  add 10 to rax   add  rax , [a]  add the contents   of a   mov  [sum] , rax save  the sum in sum   rax,  0    54   CHAPTER 6. A LITTLE BIT OF MATH   6.3 Subtraction   subtraction   Integer  tion has 2 operands of the source   is performed using the sub instruction.  :  a destination  from the destination   It subtracts  and a source.  and stores the  result   This instruc­ the contents  destination.  value  constant  of 32 bits,   The source operand   can be an immediate   in the   a memory reference  ory reference  reference.   or a register.   The destination   can be either  a mem­  or a register.   Only one of the operands   can be a memory   The sub instruction   sets or clears   ZF  like add. Some other flags  are set  related   flag  OF , the sign flag  to   the overflow    SF , and the zero flag  performing   binary-coded-decimal   arithmetic.   unsigned   As with addition there   subtract for signed   dec  which can  There is a decrement instruction   is no special   numbers.   either   a register   or a value in memory.  code with  some   Here is come   sub instructions:   numbers   versus   be used to decrement   segment . data  dq  100  dq  200   a  b  diff dq  0   segment . text  global main   main:   push rbp  mov  rbp, rsp  sub rsp, 1 6   mov  rax, 10  sub  [a] ' rax  subtract 10 from a  sub  [b]    rax  subtract 10 from b  mov  rax, [b]  move b into rax  sub rax, [aJ.  set  rax  to b-a  mov  [diff] '  mov rax, 0  leave  ret   rax move the difference to diff   Here is a gdb session   illustrating   the sub instructions  :    6.4. MULTIPLICATION   55    gdb  b 1 1   Breakpoint 1  at Ox4004c8: f ile sub. asm , l ine 1 1.   gdb  run  Starting   program:  home seyfarth teaching a  sm sub   sub  [a] , rax  subtract   10 from a   sub  [b], rax  subtract 10 from b   mov  rax, [b]  move b into rax   sub  rax, [a]  set rax to b-a   mov  rax , 10   Breakpoint 1 ,  main   at sub . asm :1 1   1 1    gdb  ni  1 2    gdb  p $rax  $ 1  = 10   gdb  ni  13   gdb  p  a  $2 = 90   gdb  ni  14   gdb  p  b  $3 = 190   gdb  ni  1 5    gdb  p $rax  $4 = 190   gdb  ni  1 6    gdb   p $rax  $5 = 100   gdb  ni  17   gdb  p diff  $6 = 100   mov  rax ,  0   6.4 Multiplication   mov  [diff], rax move the difference to diff   of unsigned   Multiplication  tion, while multiplication  instruction   is fairly simple,   of signed   integers   is performed  integers   but we will skip it in favor of imul.   is done using imul . The mul   using the mul instruc­   56   CHAPTER 6. A LITTLE BIT OF MATH   The imul instruction,   unlike   add and sub, has 3 different   forms.  One   form has 1 operand  and destina  .  sources   operands   the source   tion  and the third form has 3 operands   operand , a second has 2 operands   source   destination  and 2   version   multiples   the value in rax by the   in rdx: rax. The source   The 1 operand  result  and stores the  ory reference.  The  reason  bit integers  integers  tion. The low order bits of the answer are in rax and the high order bits  are in rdx.   is that  you are using large 64 bit  Then you need this instruc­  a 128 bit result. Perhaps  all128 bits of the product.   or a mem­ could be a register  two 64   yields  and need   for using 2 registers   multiplying   operand   source   imul  mov  mov   qword [data]  [high], rdx  [low], rax   multiply rax by  data  store upper part of product  store lower part of product   Note that  a warning   issued   yasm requires   the quad-word   during   testing, but did the   attribute  correct   It  operation.   for the source.   Quite commonly   64 bit products  forms will allow selecting any  tination   register.   are sufficient   and either   of the  registers  as the des­  other   of the general   purpose   The two-operand   form allows   specifying the source operand   as a regis­  ter, a memory reference  times the destination   or an immediate  and the result   register   value. The source   is placed   in the   is multiplied  destination.   imul  imul  imul   rax , 100  r8, [x]  r9, r10   multiply rax by 100  multiply rax by x  multiply r9 by r10   The three-operand   form is the only form where  . Instead   the destination   register  the second operand,   is not one of the factors in the  product which is either  third operand which must be an immediate  value.   a  register   or a memory reference, is  multiplied  by   the   imul  imul   rbx, [x] , 100  rdx, rbx, 50   store 100*x in  rbx  store 50*rbx in  rdx   The carry flag  CF  and the overflow flag  OF  are set when the  multiply  you explicitly   64 bits  unless   product   . The   a smaller   request   exceeds    6.5. DIVISION   57   zero flag and sign flags are undefined,  negative   requires   result   an additional operation.   so testing   for a zero, positive or   6 . 5  Division   Division  returns  behaves a little  that it uses   is different  2 results:   from the other mathematics  a quotient  like the inverse   and a remainder.  of the   rdx: rax for the dividend.   operations  in that it  The idi v instruction   single operand   imul instruction   in   The idi v instruction   uses a single   source   operand   which can be either   or a memory reference.  similarly   a register  operates  on unsigned  rdx and rax with rdx holding  stored   in rax and the remainder   numbers.  the most significa  in rdx.  is stored   The dividend   is the two registers   nt bits. The quotient   is   The unsigned   division instruction   di v   mov  rax, [x]  mov  rax, 0  idiv [y]  mov  [quot] , rax  store the quotient  mov  [rem], rdx  store the remainder   x will be the dividend  0  out rax, so rdx: rax -- rax  divide by y   The idi v instruction   does not set any status   flags, so testing  the   results   must be done separately.   6.6 Conditional move instructions   of conditional   move instructions   which can be used   than using branching.   rather   There are a collection  profitably  perform branch prediction  other times. Incorrect  interrupting  conditional move   the instruction   predictions  pipeline,   instructions   which will be correct   Branching causes   the CPU to  and incorrect  slow down the CPU dramatically   sometimes   by   The conditional   move instructions   struction.  as the mov, except that there is no provision   There are a variety   to avoid branching  have operands   the mov in­ much like  of them which all have the   same 2 operands   in simple   cases.   for immediate   operands.   so it is worthwhile   to learn to use    58   CHAPTER 6. A LITTLE BIT OF MATH   Instruction  effect  cmovz  move if zero flag set  move if zero flag not set  not zero   cmovnz  was negative  move if result  cmovl  move if result  was negative  cmovle  move if result  was positiv cmovg  result  cmovge   was positive or zero   e   or zero   There are lot more symbolic   patterns   which have essentially   the same   meaning,   but these are an adequate   collection.   The following   code snippet   converts   the value in rax to its absolute   value:   mov  neg  cmovl   rbx, rax  rax  rax, rbx   save original value  negate rax  replace   rax if negative   The  code   below loads a number from memory, subtracts  100 and   replaces  the  difference with   0 if the difference   is negative:   mov rbx, 0  mov  rax, [x]  get x from memory  add  rax , 100  subtract  cmovl rax, rbx  set rax to 0 if  rax was negative   100 from X   set rbx to 0   6. 7 Why move to   a register?   Both the  ory. Alternatively  perform  cation.  In  instruction   this case  it  is better.   add and sub instructions   can operate   on values stored   in mem­  you  could   explicitly   move the value into a register,   the operation   and then move the result  is 1 instruction  versus   back to the memory lo­ that 1  3. It's seems obvious   Now if the value from memory is used in more than 1 operation,   it   which is fairly natural.   might be faster to move it into a register  mization  programmer  this code is not going to be executed  billions  quired  will   first. This is a simple opti­ the  If  are in which registers .  of times, then the time re­  that case don't overwhelm yourself   to keep track of which   It has the disadvantage   not matter.  In   of requiring   probably   variables    6. 7. WHY MOVE TO A REGISTER?   59   with optimization  tricks.  apart, then keep it simple.   If the 2  uses   are more than a few instructions    60   CHAPTER 6. A LITTLE BIT OF MATH   Exercises   1 .  Write an assembly   2 points   language  program  in the  plane   between  each, stored  Remember   in memory.  the Pythagorean Theorem!   to compute   the distance   squared   identified   as  2 integer   coordinates   2. If we could   do floating point division,  would have you   this exercise  connecting   the slope of the line segment   compute  you are to store the difference  and the difference  integers  the line segment  is not. You should use a conditional   l  infinite   in y coordinates   in memory. Leave register   it vertica  stored   in another.   in x coordinates   or undefined  move to set the   value of rax.   slope  and 0 if it   in 1 memory location  The input points  are  value 1 if   rax with  the   2 points.   Instead   3. Write an assembly   language   Use memory locations  numbers from   grades.  different  memory and also store the remainder   to compute   program  for the 4 grades.   the average  Make the grades  all  in  0 to 100. Store the average of the 4 grades   of 4   from the division   in memory.   4. Write an assembly   stored   program   language   the cost of elec­  to compute  for a home. The cost per  kilowatt   hour will be an integer   in a memory location.   tricity  number of pennies  used will also be an integer stored  be $5 .00 plus the cost per kilowatt hour times the number of kilo­ watt  hours  number of hours over 1000· to 0 if the number of hours over 1000  is negative.  and the number of pennies   hours  The kilowatt  in memory. The bill amount will   over 1000. You  can use a conditional   Move the number of dollars   into one memory location   move to set the   into another.    C-hapter 7   Bit operations   is a machine   to process   numbers. In this chapter we   bits. So far we have discussed  using  will learn about a handful   of   represent   A computer  bits to  computer  for the bits like  signed   instructions   on bits without  which operate  or unsigned  integer  s.   any implied meaning   Individual   bits have the values 0 and 1 and are frequently  ­  as false for 0 and true for 1. Individual  tions.  to one of 2 mutually  cell in Conway's game of Life.   A bit might mean male or female or any assignment  sets. A bit could  represent   exclusive   bits could have other interpreta  of an entity   an individual   interpreted   as numbers   with limited   of numbers  in 4 bits. Is it worth  the   range. Suppose  you  in the range of 0 to 15. Then each  to store your   trouble   data occurs  billions   Sometimes  need to process  number could be stored  numbers  in  like C++? Perhaps  memory. Still  space.  So   4 bits when 8  bit bytes are readily   available in a language   not if you have access   to a machine   it might  be  nice   to store the numbers   with  suffic ient  on disk in half the   you might need to operate   on bit   fields.   7.1 Nat operation   is a unary operation,   meaning that it has only 1   The not operation  operand.  cal statement word. C has two version   The everyday   . In assembly   interpretation   of not is the opposite  we apply not to all the  bits  of  a   of a  logi­  language   of not, " ' "  and "-"  " ! "  is used for the op-  61    62   CHAPTER 7. BIT OPERATIONS   distinguish   of true or false, while applies   posite  common  to  not and "-" as the  "bit-wise"  not.  guage not instruction  illustrating  of not.   inverts each bit   nots by referring   the meaning   to  all  the   the two   We will use "-" since the assembly   lan­  of a word. Here are some examples,   to " ! "  as the "logical"   bits of a word. It is   -o == 1  - 1  ==  0  - 10101010b == 0101010 1b  -oxffOO == OxOOff   The not instruction  and the destination  source  and quad-words  in  trating   registers   its use.   has  a single   operand  which  serves   as both the   . It can applied   to bytes,   words,  double   or in memory. Here is a code snippet   words  illus­  mov rax, 0  not  rax  mov  rdx, 0  mov rbx, 15  div rbx   not rax   f or divide   rax ==  Oxffffffffffffffff  preparing  will divide by 15  Oxf   unsigned  rax --Ox1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1   rax --Oxeeeeeeeeeeeeeeee   divide   7.2 And operation   in programming   is also applied   The and operation  is common to test for both of 2 conditions  you can  We will stick with the single  instruction   do an and operation   and operation.  Here is a truth table for the and operation:   the bit-wise   of each pair of bits in  2 variables  & notation,   since the assembly   matches   - & in C.  and   in 2 contexts. First it   language   being true - &&  in C. Secondly   & 0  1  0  0  0  1  0  1   Applied   to some bit fields we get:    7.3. OR OPERATION   63   1 1001100b & 0000 1 1 1 1b == 00001100b  1 1001100b & 1 1 110000b ==  1 1000000b  Oxabcdefab  & Oxff ==  Oxab  Ox0123456789abcdef & OxffOOffOOffOOffOO   ==  Ox010045008900cd00   You might notice   that the   examples   illustrate   using & as a  bit field   the right operand   Wherever   selector.  the bit from the left operand.  left operand,  "masks"   used to select   but in these examples   bits.  snippet   has  a 1   bit, the operation  same thing about the   selected   You could say the   the right operand   has more obvious   Below is a code   illustrating   the use of the and instruction  :   mov  rax, Ox12345678  mov  rbx, rax  and  rbx, Oxf  mov  rdx, 0  mov  rex, 1 6   idiv rex  and  rax, Oxf   rbx has the low nibble Ox8  prepare to divide  by 1 6   rax  has  rax has the nibble Ox7   Ox1234567   It is a little   sad to use a divide   just to shift the number 4 bits to the   right,   but shift operations   have not been   discussed   yet.   7.3  Or   operation   operation   The or  ings.  First  true -I I  in C .  Secondly  in 2 variables - assembly   language   is the final bit operation  it is common to test for either  or   with logical   you can do an or operation   I in C. We will stick with the single   and bit-wise   mean­ both  of 2 conditions  being  of each pair of bits  I notation,  since the   and instruction   matches   the bit-wise   and operation.   You need to be aware that the "or" of everyday   used to mean 1 or the other but not both. When someone  you want of cup  should  of "decaf"  "Yes". The "or" of programming   means one or the other or both.   , you probably   or "regular"  speech is commonly  asks  you  not answer   if   Here is a truth table   for the or operation:   0  1   0  0  1  1  1  1    64   CHAPTER 7.  BIT OPERATIONS   Applied   to some bit fields we get:   1 1001100b I 0000 1 1 1 1b == 1 10011 1 1b  1 1001100b I 1 1 110000b == 1 1 1 1 11oob  Oxabcdefab I Oxff == Oxabcdefff  Ox0123456789a  bcdef I OxffOOffOOffOOffOO   == Oxff23ff67ffa  bffef   You might notice   that the examples   illustrate  has a 1 bit, the operation   the right operand   Wherever  ing bit of the left operand. Again, since or is commutative,  the same thing about the left operand,  obvious   we could say  but the right operands have more   masks.   using I as a bit setter.   sets the correspond­  Here is a code snippet   using the or instruction   to set some   bits:   mov  or  or   rax , Ox1000  rax,  1  rax, OxffOO   make the number odd  set bits 1 5-8   7.4 Exclusive or operation   The final bit-wise  everyday  operator is "-".   concept   operation  of 1 or  the   is exclusive-  or. This operation   matches  the   other but not both. The C exclusive-or   Here is a truth table for the exclusive-or   operation:   From examining   also be called  '�not  flipper". Consider  to flip in the left operand.   the truth table you can see that exclusive-or  equals". In my terminology   could  exclusive-or  is a "bit­ which bits   the right operand   as a mask which selects  these examples:   Consider   b  -1 1 1 1 1 1 1 1  -00000001b 00010000b  b --1 0 1 0 1 01 0b   00010001b  01010101 0 1 1 101 1 1b  -0000 1 1 1 1b --0 1 1 11000b  Oxaaaaaaaa -Oxffffffff -- Ox55555555  Ox12345678   -Ox12345678   == OxOOOOOOOO    7.5. SHIFT OPERATIONS   The x86-64   exclusive-or   instruction   is named xor. The most common   use of xor is as an idiom for setting  moving 0 into a register  requires  the intended   which requires   requires   3 bytes.   register  Observe some uses of xor:   You can get the same result   using the 32 bit version   only 2   bytes for the instruction.   a register   to 0. This is done because   7 bytes for a 64  bit  register,  while   65   xor  of   mov  rax, Ox1234567812345678  xor eax, eax  mov  rax, Ox1234  xor rax, Oxf   set  to 0   change to Ox123b   7.5 Shift operations   for the and instruction   In the code example  the effect of converting  have been obtained more simply  by shifting  right 4 bits.  Shifting  is an  building   values with bit fields.   excellent   Ox12345678   into Ox1234567.   I divided   the register's contents  to the  bit  fields  and for   tool for extracting   by  16 to achieve  This effect could   there are 4 varieties   of shift instructions:   left  sal : shift right  shr , and shift  right  sar . The shl and sal left instructions   are actually   In the x86-64 architecture  shift left  shl , shift arithmetic  arithmetic  the same  instruction.  the newly vacated positions  number,   while shr introduces   The sar instruction   propagates  on the left which preserves  0 bits from the left.   the sign of the   the sign bit into   15   I  .1 I 0 I I I 0 I 1 I I I  o l o  I II o I I I II o l t i ii o I  . I I I   I I l I 0 I 0 I I I 0 I l I I I 0 I I  0    shr   Figure 7.1 :  Shifting right 1 bit at  a time   There are 2 operands   is the  register  of bits  to shift. The number to  shift can be 8, 16, 32 or 64 bits in length.   for a shift instruction.   or memory location   The first operand   to shift and the second is the number   The    66   CHAPTER 7.  BIT OPERATIONS   number of bits can be an immediate  no other choices   for the number of bits to shift.  shift left operator   C contains  a   value or the c l  register. There are    > > .    < <  and a shift right operator  on the data  shift right in C  depends   of logical   or arithmetic   The decision  type being  shifted.   Here are some examples   of shifting:   10101010b >> 2 == 001 0 1010b  1001100 1b <<  4 == 100 1 1 00 1 0000b  Ox12345678  >> 4 == Ox0 1234567  Ox1234567  << 4 == Ox12345670  Oxabcd >> 8 ==  OxOOab   To extract   a bit field from a word, you first  bit of the field is in the least significant   the right most  0  and then and the word with a value having a string of  through  example   n - 1 where n is the number of bits in the  field  to extract   shift the word right until   bit  bit position  1 bits in bit 0  to extract. For  four bits, and then and with Oxf.   bits 4-7, shift right   position,   the value. The  first  step  is  to   you first need to clear the  bits   proper number   To place some bits  into   then or the new field  into  with  the  shift the mask left to align the mask  with  field. Negate the mask to form an inverted mask. And the value with  the inverted mask to clear out the bits. Then shift the new value left the  proper number of bits and or this with the  value.   and  build the mask  Then  at bit  0.  the value to hold the new   of l 's for the  field   width starting   It's time to see some examples:   I want bits 8-15  rax now holds Ox56   mov rax, Ox12345678  shr rax, 8  and  rax, Oxff  mov rax, Ox12345678 I want to replace  bits 8-15  mov rdx , Ox a a  rdx holds replacement f ield  mov  rbx , Oxff  I need an 8 bit  mask  Shift mask to align  @ bit 8  shl rbx, 8  rbx is the inverted mask  not rbx  Now bits 8-15 are all 0  and  rax, rbx  shift the new bits to align  shl rdx, 8  rax now has Ox1234aa78  or  rax , rdx    7.6. BIT TESTING AND SETTING   67   set also includes   The x86-64 instruction  right  ror  instructions.  bit string  rotating  bit string   into proper position  the proper number of bits in the opposite  will be left in the register   while preserving  direction or memory location.   for testing   These could be used to shift particular   rotate   parts of a   the bits. After   left  rol  and rotate   , the original   7.6 Bit testing and setting   to extract   instructions   It takes several  to extract  you need  a single bit.  and shifting as just  illustrated.  use the bit test instruction   bts  or the bit test and reset instruction    bt  and either   or insert   However   field. Sometimes   or insert  a  bit  This can be done using masking  it can be simpler   and quicker   to   the bit test and set instruction   btr .  has  2 operands.   The first operand   The bt instruction   a register which contains   64 bit word in memory or  second operand  1 for the word size which is either  an  register.  The  bit being tested.   bt instructions   is the bit number from  0 to the number of bits minus  value or a value in  a   immediate   set the carry flag   CF  to the value of the   is a 16, 32 or  the bit to test. The   The bts and btr instructions  operate  bit  in  the   same fashion as   similarly. Both in-.  bt. They differ in   somewhat   structions  test  the current  that bts sets the bit  One particular   possibil  to 1 and btr sets the bit to 0.   ity for using these instructions   is to imp  lement   membership   n is the universe  size.  A   a word and bit number  in  memory   a set of fairly large size where the members of the set are integers from 0  to n - 1  where  determining  bit in the word. Following  used to store the vall.1e of the carry flag into  set_ instructions  Insertion  and  using  translates   the setc instruction  can be  an 8 bit register.  flags in the eflags register.   bts to set the correct  bit.  Removal of an element  into using btr to clear the  correct   test translates  the correct   into the set translates into   for each of the condition   the bt instruction   the word and bit number   determining   bit in memory.   and testing   of the set   There are   into   In the  code  below   we assume  that  the  memory  for  the   set is at a   named data and that the bit number to work on is in   rax. The code preserves   rax and performs   testing,   insertion  and   memory location  register  removal.    68   CHAPTER 7. BIT OPERATIONS   mov rbx,  rax  shr rbx,  6  mov rex,  rax  and rex , Ox3f  xor edx, edx  bt [data+8* setc  dl  bts [data+8*r btr [data+8*rbx]  copy bit number to rbx  qword number of data to test  copy bit number to rex  extract  rightmost  set rdx to 0  test bit  edx equals the tested bit  set the bit, insert into set  clear the bit, remove   bx], rcx  , rcx   rbx] , rex   6 bits   You will notice   the use of data+8*rbx where we have previously   times 8 allows  at data in memory. The instruction   only a variable name. The use of a register  ray starting  for multiplying  specified  8 for a quad-word  data array.   by data. Use  2 for a word array, 4 for a double word array and  index into the   options  by 2, 4 or 8 to be added to the address   an index register   rbx holds the quad-word   array. Register   used  an ar­ indexing  format includes   Operating   on the quad-word   of the set  in   memory as opposed   to mov­ we   ing  to  a  register  will not  need  to  do only one   is  likely  test, insert   of these operations.   to be the fastest choice,   since  in  real  code   and then remove in 1 function   call. We will   7. 7 Extracting and filling   a bit field   stored   bit field you need to shift the field so that its least significant   we need  in a memory location.   0 and then mask the field with  an  mask. Let's suppose   To extract a  bit is in  position  the appropriate  a quad-word  word, we need to shift  it right 23 bits to get the least significant  bit  of length 29. The simplest  the proper position.  way to  get a proper mask  29 1 bits  is using the value Oxlfffffff.  Seven f 's  is 28 bits and the 1 gives a total of 29 bits. Here is the code to do the  work:   with  bits 23-51 from  the quad­  Then, after loading   and operation   The bit field  is   to extract   into   mov rax, [sample] move quad-word into rax  shr rax, 23  and rax , Oxlfffffff  mov [field] , rax  save the f ield   shift to align bit 23 at 0  select the 29 low bits    7. 7. EXTRACTING AND FILLING A BIT FIELD   69   Now suppose   we wish to fill in bits 23-51 of sample with the bits in   f ield. The easy method is to rotate  right and then left to clear  29  register   the field back into   bits, or in  the   to get   bits 23-51 .  Here is the code:   the value to align the field, shift   field, and then  rotate   the   mov rax, [sample] move quad-word into rax  rotate to align bit 23 at 0  ror rax, 23  wipe out 29  bits  shr rax, 29  move bits back into alignment  shl rax, 29  or  rax, [field]  trusting the f ield is  29 bits  rol rax , 23  mov [sample], rax  store the f ields in memory   realign the bit f ields    70   Exercises   CHAPTER 7. BIT OPERATIONS   1. Write an assembly   program  in memory. Use repeated   code rather   than a loop.   to count all the 1 bits in a byte stored   2. Write an  assembly   program   to swap 2 quad-words in   memory using   xor. Use the   following   algorithm:   a  =  a - b  b =  a - b  a  =  a - b   3. Write an assembly   program   to move a quad-word stored in memory   into a register  of the word. Use either  register   so that   and then compute the exclusive-or   ror or rol to manipulate   of the  8  bytes  the bits of the   the original   value is retained.   4. Write an assembly   program   to dissect   a double stored   in memory.   floating   This is a 64  bit  memory location.  value into a second memory location.  the implicit  location.   point value. Store the sign bit  in  one  after subtracting  the bias  field with  into a third memory   1 bit at the front of the bit string   Store the exponent   Store the fraction   5. Write an assembly   program  arithmetic   and bit   to perform  a product   of 2  float  . Start with 2 float   values  values   using integer  in memory   operations in memory.   and store  the  product    Chapter 8   Branching and looping   statements   added a little   any branching  move instructions  the CPU's pipeline   So far we have not  used  the conditional  while preserving  be tedious  each bit in a byte. In the next chapter we  be fool-hardy to process  instructions.  coping   with variable sized arrays. We need loops.   an array of 1  million   It might be possible   instructions   to process   to repeat   flexibility   in our code. Using  to the code  that it can  or   each byte in a quad-word   contents. We have seen   will work with arrays. It would   elements   by repeating   the   to do this, but it would be painful   In many programs   you will need to test for a condition  based on the results. The conditional  is several  are fairly trivial.  to branch to one alter­  one of 2 actions  if the 2 actions  long, then we need  native  branching.  to branch around the code for the  first alternative.  ts.  and unconditional  branch statemen  the CPU to handle the second alternativ e by not  need   After completing   a conditional   the second alternat  jump statement   while allowing   ive we will typically   If each action   and perform   move is efficient   We need conditional   instructions   8 . 1  Unconditio  nal jump   The unconditional  goto statement .  necessity  languages  in assembly  .   However   jump instruction  clearly   there is    jmp  is the assembly version  of the   no shame in using jmp. It is a   language,   while goto can be avoided in higher level   71    72   CHAPTER 8. BRANCHING AND LOOPING   The basic   form of the j mp instruction   is   j mp  label   a rip relative   jumping forwards or backwards   jump instruction.  value and is encoded   where label is a label in the program's text segment.  The assembler  will generate  uses an 8 bit signed immediate  allows  of relativ requires  variety it  can  specifies   e jump in 64 bit mode  a total of 5 bytes. Fortunately  the shorter   jump  relative  in 2 bytes. This   about 127 bytes. The next variety   value and  out which   form. The programmer   uses a 32 bit signed   use and chooses   The simplest   immediate   a label.   simply   the  assembler  figures   The effect of the jmp statement   is that the CPU transfers   control   to   the instruction  except when  can jump to an  address  a conditional  an address  isn't sensible,  this more efficiently.   at the labeled   address.   This is generally   not too exciting   used with a conditional   jump. However, the jmp instruction   contained   in a register   or memory location.  Using   move one could manage to use an unconditional jump   to  to implement a conditional   jump. This   contained in a register   since there are conditional   jump statements   which handle   There is one more possibility   which is more interesting  -implementing   a value from 0 to 2. Then you can form an array of instruction   . Suppose  you have   a variable i which is known to   a switch statement contain  addresses  based on the value of i .  Here is an example:   and use a jmp instruction   to jump to the correct   section   of code   segment . data   switch : dq  main. caseO   dq  main. case1  dq  main. case2   i ;   dq  2   segment . t ext  global main   tell l inker about main   main:   . caseO:   mov rax, [i]  j mp  [swi tch+rax*8] switch   i     move i to rax   mov rbx, 100   go here if i --0    8.2. CONDITIONAL JUMP   73   go here if i --1   mov  rbx, 102   go here if  i 2   jmp  . end   mov rbx, 101  jmp  . end   . easel:   . case2:   . end :   xor eax, eax  ret   are referred to as "local"   In this code we have used a new form of label with a dot prefix. These  They are defined within  the range  regular  the local l-abels could be used for all  a function and this would allow using the same local labels   Basically   labels.   labels.   labels  of enclosing  labels  inside  in multiple  to the . cas eO label inside   functions.   Also we used main. cas eO outside   of main to refer   main.   From this example   we see  that  an   unconditional   some forms  of conditional   and less confusing,   jump instruction  jumps. Though  in larger  switch   can be used to implement  conditional  statements  jump to.   jumps are more direct  it might be advantageous   to build an array of locations   to   8.2 Conditional jump   instruction   l jump we need an   To use a conditiona This could be an arithmetic  just to learn whether  2 numbers  in a register.  which subtracts  its  second  storing   The x86-64 CPU provides   or bit operation.   are equal might   the difference.   wipe out a needed value    cmp    a compare instruction  from its first and sets flags without   which can set some flags.   operand   However   doing a subtraction   There are quite a few conditiona  l jump instructions   with the   general   pattern:   j CC  label ;  jump to locat ion   The CC part of the instruction  condition codes.  such as the zero flag, the sign flag, and the carry flag. Below are some  useful   name represents  codes are based on specific   any of a wide variety of  flags in eflags   jump instructions.   conditional   The condition    74   CHAPTER 8. BRANCHING AND LOOPING   instruction  JZ  JnZ  Jg  Jge  jl  jle  JC  JnC   meanmg  aliases  flags  jump if zero Je  ZF=l  jump if not zero Jne ZF=O  jump if> zero jnle ZF=O SF=O  jump if> zero jnl SF=O  j urn p if < zero Jnge JS SF=l  jump if< zero Jng ZF=l or SF=l  jump if carry jb jnae CF=l  jump if not carry jae jnb CF=O   '   It is   possible   jumps. It is probably  to assembly  translated  C code  and  translate  section   discusses   to generate  "spagh  etti" code using jumps and conditional  best to stick with high level coding structures  language.   The general   is to start with   strategy   it  to assembly.   The rest  of the   conditional   jump   how to implement   C if statemen ts.   8 . 2 . 1  Simple if statement   Let's consider  Suppose we are implementing   how to implement   the equivalent  C code:   the following   of a C simple   if statement  .   Then the direct   translation   to assembly   language   would be   if   a  <  b   {   temp = a ;   a =  b ;   b = temp;   }   mov rax, [a]  mov rbx, [b]  cmp rax, rbx  j ge in_ order  mov [temp] , rax  mov [a]' rbx  mov [b] , rax   in_ order:   You will notice  jump used greater   that the if  than or equal to. Perhaps   condition   it would appeal   to you more   was less than, but the conditional    8.2. CONDITIONAL JUMP   75   to use j nl rather than j ge .  The effect is identical  mnemonic  is  select   name which makes the most sense to   ion  with not . You should   part of the assembly   the instruction   but  the   instruct  less than   you.   8.2.2 If else statement   It is fairly  simple  C if   common to do 2 separate  statement with an   else clause:   actions  based  on  a   test. Here is a   This code is simple enough that a conditional  to be a faster solution assembly  language:   , but nevertheless   move statement   is likely   here is  the  direct   translation   to   if   a  <  b   {  max =  b ;    } else {   max =  a ;    }   mov rax, [a]  mov rbx, [b]  crop  rax, rbx  j nl else  mov [max], rbx  j mp  end i f    else: mov [max] , rax  endi f:   8.2.3 If else-if else   statement   i f     a  <  b  result = 1 ;      {   } else if    a  >  c     {   result = 2 ;    } else {   Just as in C C++ you can have an if statement  can continue to do tests in the else  clause  statements. Here is a short if else-if else   statement   inC :    for the else clause,   you   of assembly   code conditional    76   CHAPTER 8. BRANCHING AND LOOPING   result   = 3 ;    }   This code is possibly  but simplicity  is bliss.   a good candidate   for 2 conditional   move statemen ts,   Here is the assembly   code for this:   mov rax, [a]  mov rbx, [b]  cmp rax, rbx  j nl else_ if  mov qword [result]  j mp  end if   , 1   mov rex, [c]  cmp rax, rex  j ng  else  mov qword [result]  j mp end if   , 2   mov qword [result]  , 3   else if:   else:   endif:   It should  be   clear that an arbitrary   sequence   of tests can be used  to   simulate multiple  clauses  in C.   else-if   8.3 Looping   with conditional jumps   The jumps and conditional  jumps introduced  forward. By jumping backwards, it is possible  loops.  loops.  break statements with loops.   we discuss  while loops,  how to implement   In this section  We also discuss   a variety of  ing  the effects of C's continue and   to produce   do-while   loops and count  so far have been jumping   8 . 3 . 1  While loops   The most basic type of loop is possibly  like this in C:   the while loop.  It   generally looks    8.3. LOOPING WITH CONDITIONAL JUMPS   77   whil e    condition   {   statements;   }   C while   loops support   the break statement   which gets out of the loop   programming   and the continue statement which immediately goes  the loop. Structured  However  fully, are frequently  variables.  using condition variables   to some problems  tives based on setting  to implement   back to the top of  favors avoiding  break   They are substantially  and faster.   they can be effective  clearer   than alterna easier   solutions   and, used  care­  and continue.   condition   in assembly than   Counting 1 bits in a memory quad-word   The general  and add bit 0 of the value at each  1 bits. This loop needs to be done 64  loop:   strategy is to shift the bits of a  quad-word  1  bit at  a time  a loop to the sum of the  Here is the C code for the   iteration of   times.   The program   that values  be  pointless to  store these values   this loop with only the minor change  of the loop. It  would  the loop .   in memory during   during the execution   below implements   are in registers   sum = 0 ;   i  = 0 ;   while    i  < 64   {   sum += data  & 1 ;   data  = data >> 1 ;   i++;   }   segment . data   data dq  Oxfedcba987654321 0   sum  dq  0   main:   segment . t ext  global main   push rbp    78   CHAPTER 8. BRANCHING AND LOOPING   mov  sub   rbp , rsp  rsp, 16   Register usage   rax: bits being examined  rbx: carry bit after bt, setc  rex: loop counter , 0-63  rdx: sum of 1 bits   mov rax, [data]  xor ebx, ebx  xor ecx, ecx  xor edx, edx   while:   cmp rex, 64  j nl  end_ while  bt  rax, 0  setc bl  add  edx, ebx  shr rax, 1  inc rex  j mp  while   mov  [sum] , rdx  xor eax, eax  l eave  ret   end_while:   The first instruction   of the loop is cmp which is comparing  the inverse   jump selected,   j nl ,  matches   i  rex    of the   64. The conditional  this is   versus  · C condition instruction of  is the typical   . Hopefully   the loop is a jump to the first statement  translation   of a while loop.   less confusing   than using j ge. The last  of the loop. This   Coding this  in  language   assembly  quite matching our   C  and running  file named countbi  yasm syntax.  The   ts. s which is unfortunately  not  assembler   for gee, gas, uses the   gee -03 -S countbi   ts. c yields   an    8.3. LOOPING WITH CONDITIONAL JUMPS   79   AT&T syntax which differs  the source and  are  made  program   by gee:  produced   to instruction   destination   from the Intel syntax used by yasm. Primarily  operands are reversed and some slight  mnemonics.   changes  Here is the loop portion  of   the   movq data %rip , %rax  movl $64, %eex  xorl %edx, %edx   . 12 :    movq  %rax, %rsi  sarq %rax  andl $ 1, %esi  addq %rsi, %rdx  subl $ 1, %ecx  j ne  . 12   You will   notice   that  the compiler  eliminated   one jump instruction   of the loop. Also the compiler   In fact it discovered   that the  counting   by  did not do  up to 64   the test to the  end   down from 64 to 0.   shifting  a compare  instruction.  of i was not important,  only  decremented  jump after the decrement. Overall the  instructions,  As  stated  can learn a lot from studying  interested  in efficiency  You could certainly  but if you can't improve on the compiler with C.   while the hand-written   in the introduction   copy the generated   you  may  be   the number of iterations   mattered,  so  it   Thus it was possible   to do a conditional  compiler  generated  a   loop with 6   assembly   loop used 8 instructions.   a good compiler  the  compiler's   generated   is hard to beat . You   code. If  you  are   able to do better   code  and  do   than the compiler.  exactly   the same,   's code then you should  stick   compiler   There is one additional  speed up code consider and did 8  iterations  The  compiler   tends to  registers  iteration.  1 bit in  6 instructions.  instruction  perhaps   this is 3 times as  fast.   pipeline   option,   -funroll-all-lo  ops which   ably. In this case the compiler used more  of a loop which  added  up  8   bits in each   did 8  bits  in   24 instructions   where before it  did   This is about twice as  fast. In addition   is used more effectively   in the unrolled   the  version, so   Optimization  issues   like loop unrolling   are highly   dependent  on the   CPU architec  ture. Using  the   CPU in 64 bit mode gives 16 general-   80   CHAPTER 8. BRANCHING AND LOOPING   while 32 bit mode gives only 8 registers.   with more registers.   purpose  registers  is much  easier  series  of the effect of loops interrupting  to see what works best on a particular  CPU.   use of a queue of micro-opcodes  the CPU pipeline.   processors'   Other details   like the Intel Core i  might eliminate   most   Testing is required   Loop unrolling   8.3.2 Do-while loops   that the compiler   last section   We saw in the  do-while loop. The while structure  jump at the top of the loop  the loop. It is always possible  at the bottom.   to convert   translates   converted a while loop into  directly into a  jump at the bottom  a loop to use a conditional   of  jump   conditional   and an unconditional   a   A  C do-while loop looks like   do {   statement s;   } while  condition  ;   A do-while always executes   Let's look at a program   the body of the loop at least once.  implementing   a search in  a character   array,   terminated  not execute  loop:   by a  0 byte.  We  the loop if   will do an explicit   test before the loop to  C  code for the   the first character   is 0. Here is the   i  = 0 ;   c  = data[i];  i f     c ! =  0    do {   ==  x   break;   if     c  i++;  c  = data[i];   } while   c ! =  0  ;  n  =  c  ==  0  ?   - 1  : i ;    Here's   an assembly   implementation   of this code:   data  n   section . data  db  dq   11hello  0   world11,  0    8.3. LOOPING WITH CONDITIONAL JUMPS   81   needle db  'w '    main:   section . text  global main   push rbp  mov  rbp , rsp  sub  rsp, 16   Register usage   rax: byte of data array  rbx: byte to search for  rex: l oop counter , 0-63.   mov bl, [needle]  xor  ecx, ecx  mov  al, [data+rcx]  cmp  al,  0  j z   end_while   cmp  al, bl  j e   found  inc rex  mov  al, [data+rcx]  cmp  al,  0  j nz  while   while:   end while:   mov  rex, - 1    found: mov  [n], rex  xor eax, eax  leave  ret   The assembly   code looks   simpler   than the C code. The C code would   look better  with  a  necessary  proper character   while loop. The conditional   operator   in the assembly   code, since the conditional   in  C was not  jump on finding the   jumps past the movement   of -1  to rex.    82   CHAPTER 8. BRANCHING AND LOOPING   It might seem rational   the only  thing which can't be done in a high level language.  we should   techniques,  or to do some­ are to improve efficiency  Bearing  that in mind,  and efficiency.   to try to use more structured   try to strike a balance   to use assembly   structure   between   reasons   but   8. 3. 3  Counting loops   The normal counting  implement  addition.   InC we might use   any type  of loop.   loop in  C is the for loop, which can be  used  wish to  do array   Let's assume that  we   to   f or     i   =  0 ;  i  < n ;  i++   {   e [i] = a [i] + b [i];   }   Translated   into assembly   language   this loop might  be   mov  rdx, [n]  xor eex , eex  f or : cmp  rex, rdx  j e   end_ for  mov rax, [a+rex*8]  add  rax, [b+rcx*8]  mov  [e+rcx*8]  inc rex  j mp  for   , rax   end for:   Once again   it is possible   to do a test  on   rdx being 0 before   executing   the  loop.  to be placed   at the end of the loop.   This could allow the compare   and conditional   jump statements   8.4 Loop instruction  s   There is a loop instruction  the rex register  by decrementing  0. Unfortunately,  it  is  rex and  use   of variants  until the register  from  jump. Furthermore   which operate  reaches  1 explicitly   j nz to perform the conditional   about 5 times faster to subtract   along with a couple   and branching   the loop    8.5. REPEAT STRING  ARRAY  INSTRUCTIONS   83   is limited   instruction  that it can branch backwards  to  be worth using.  doesn't seem   to branching   to a  8 bit immediate   field, meaning   or forwards about 127 bytes. All in all,  it   Despite  Consider  occurrence   the forgoing  the following  of a specific   tale of gloom, perhaps  code  which  character:   you still   wish to use loop.   looks in an array for the right-most   mov ecx , [n]   more: cmp [data+rcx-1] , al   j e   found  loop more  f ound: sub ecx , 1   mov [loc] , e cx   8.5 Repeat string  array  instructions   repeat    rep  repeats   instruction   The x86-64  ber of times specified  of variants  occur during the execution  setting  and finding a specific   array elements  to  value in an array.   in the count register  termination  of the loop. The repeat instructions  one array to another,   based on conditions  which may   a string   rex . There are a handful   which allow early   instruction   value, copying   a specified   allow   the num­  8 . 5 . 1  String instructions   There are a handful of string  arrays are  suffixed  4 or 8 bytes .  elements  instructions   The string     1 ,  2 ,    instructions.  with b, w, d or q to indicate   use registers   The ones which step through   the size of the array   rax, rsi and rdi for special   rax or its sub-registers   Register   purposes.  hold a specific  value. Resister  the destination  index.  All of the string   rsi is the  None of the string  working   operations   eax, ax and al are used to  and rdi is   source index  instructions  with 1 ,  2 or 4 byte quantities   register  need operands.   are encoded  Combined  fairly simple   in 1 byte, while the 8 byte variants   are encoded   as  2 bytes.   with a 1 byte repeat   instruction,   this effectively encodes some   loops in 2 or 3 bytes.   It is   hard to beat  a  repeat.    84   CHAPTER 8. BRANCHING AND LOOPING   The string   operations   update the source   and  or destination   registers   after each use.  This  DF is 0  then  each use. If DF is 1  then  the   are increased  registers   the registers   updating   is managed by the direction   flag  DF . If  by the size of the data item after   are decreased   after each use.   Move   specified   The movsb instruction  the address  or 8  byte  is not stored  item is moved, the rdi and rsi registers  depending   on the size of the data item.   data elements   in a register   moves bytes from the address  by rdi.. The other movs instructi  specified  ons move 2, 4   by rsi to   using from [rdi] to [rsi]. The  data   moved  and no flags are affected. After each data   are advanced 1 ,  2, 4 or 8 bytes   Below is some code to move 100000 bytes from one array to another:   lea rsi ,  [source]  lea rdi, [destination]  mov  rex, 100000  rep movsb   moves the byte in  variants   The stosb instruction  ified by rdi. The other  ory. No flags are affected. A repeated  value. You could also use stosb in non-repeat  the automatic   destination   updating.   register   register   store can fill an array with a single  loops taking advantage   of   move data from ax, eax or rax to mem­  al to the address  spec­  Here is some code to fill an array with 1000000 double words all equal   mov  eax,  1  mov  ecx , 1000000  lea rdi, [destination]  rep  stosd   Store   to 1 :    Load   The lodsb instruction  the al register.   The other variants   moves the byte   from the address   specified   by rsi to   move more bytes of data into ax,  eax    8.5. REPEAT STRING  ARRAY  INSTRUCTIONS   85   or rax. No flags are affected.  loading  However you can use lods instructions  in other loops  of the automatic   Repeated   register   seems to be of little  use.   source   taking advantage   updating.  data from 1 array to another   removing   Here is a loop which copies   characters   equal to 13:   lea rsi ,  [source]  lea rdi, [destination]  mov  ecx, 1000000   more: lodsb   cmp  al, 13  j e   skip  stosb   skip: sub  ecx , 1  j nz  more   Scan   The scasb instruction  ing the byte in al. It uses the rdi register.  the C strlen   searches   function:   through   an array looking   for a byte match­  Here is an implementation of   segment . text  global strlen   strlen : cld   prepare to  incre  ment rdi   mov  rex, -1  maximum number of iterations  xor  al, al  repne scasb  mov  rax, -2  sub  rax, rex  ret   will scan for 0  repeatedly  start at -1, end 1 past the end   scan for 0   The function   starts   by setting   rex to - 1 ,  which would allow quite a   long repeat  rex about 264 times in order to reach 0. Memory would   loop since  the   code uses   repne to loop. It would decrement   run out first.   It just so   happens   that the Linux C ABI places   the first parameter   to   in rdi, so strlen starts   a function  scan. The standard way to return a  value  place the length   there.   with the   proper address   set for  the   is to place it in rax, so we    86   CHAPTER 8. BRANCHING AND LOOPING   Compare   The empsb instruction  compares  with repe which will continue  in e ex reaches  comparison   is complete.   0 or two different   values   of 2 arrays. Typically   to compare   values until either   it is used  the count   values are located.   At this point the   This is almost good enough to write a version  terminated   of the C stremp func­ by 0 and lengths   strings   are not   tion, but stremp expects  usually   known for C strings.   It is good enough for memcmp:   segment . text  global mememp   mememp : mov  rex,  rdx   repe cmpsb  compare until end or difference  cmp  rex,  0  j z   equal  reached  - 1 ]   movzx eax, byte [rdi  movzx ecx, byte [rsi - 1 ]   sub  rax, rex  ret   the end   equal: xor eax, eax   ret   In the memcmp function the repeat loop advances   the rdi and rsi   registers  one  extend instructions  memcmp returns  implemented   too many times. Thus there is a -1 in the move and zero  is sufficient   2 bytes. Subtraction   to get  the   0, a positive or a negative   value. It  was designed   since  to be   with a subtraction   yielding   the return   value.   Set  clear direction   The clear direction  means to process  set direction  are supposed  sets it.   cld instruction  clears  addresses  with  the  increasing  sets the direction   std instruction  to clear the   direction   the direction   flag to 0,  which   string operations.  flag to 1 .  Programmers   The   flag before   exiting any   function   which    8.5. REPEAT STRING  ARRAY  INSTRUCTIONS   87   Exercises   I.e.   1 .  Write an assembly   program   to compute   the dot product   of 2 arrays,   n-1   p = Lai * bi   should be double   i=O  word arrays in memory and the dot   should  be  stored  in memory.   Your arrays  product   2. Write an assembly   ing all the computed  memory. Fibonacci   program to compute  numbers   Fibonacci   Fibonacci  numbers  in  a quad-word   array in   stor­  numbers are defined   by   f ib{O  = 0  f ib{l  = 1  f ib  i  = f ib i-1    + f ib i -2  fori >  1   What is the largest   i for which you can compute   f ib i ?   3. Write an assembly   program   to sort an array of double words using   bubble sort. Bubble sort is defined as   do  {   swapped  for    i = 0 ;  i  < n-1 ;  i++    {   = false;   if    a [i] > a [i+1] }  {   swap a [i] and a [i+1]  swapped   = true;   }   }   } while  swapped  ;    4. Write an assembly   program   ory is a palindrome.  being reversed, like "refer". Use at least  one   A palindrome   repeat   to determine  is a string   stored  which is the   if a string   in mem­  same after   instruction.    88   CHAPTER 8. BRANCHING AND LOOPING   5. Write an assembly   program   to perform  a "find and replace"  oper­  ation on a string  in memory. Your program  should  array and an output array. Make your program  every oc­ currence   of "amazing" with "incredible".   replace   have an input   6.  A Pythagorean   triple   is a set of three integers   a,  b and c such that   a2 + b2 = c2. Write an assembly  c stored  integers   in memory has 2 smaller  a Pythagorean triple.   program   to determine   if an integer,   integers   a and b making the 3   If so, then place a and b in memory.    Chapter 9   Func tions   we will discuss   how to write assembly   from C or C++ and how to call C functions   In this chapter  be called  the C or C++ compiler  it is usually  might be a few algorithms which are  write 90%  language.   functions  from assembly.  Since  does a very good job of code generation,  in assembly.  There  so we might  in assembly   in C or C++ and write a few functions   best done in assembly,   to write complete   not important   generally   of a program   programs   which can   It is also useful  programs   to call C functions  full access   assembly  input values from stdin and we will use print£ to print results.  This  will allow us to write more useful   to all  C libraries  programs.   . We  will   use scanf to   from assembly.  This   gives your   9 . 1  The stack   use for the run-time  earlier   but it is an inte­ stack,  that the stack extends   We stated   to   of using functions.  address:   So far we have had little  gral  part  the highest  Inspection  top stack address  values for other processes  Perhaps  avoid rogue code which modifies   this is a result   possible  of the memory map using "cat   p  Ox7fffffffffff.   This is not quite true.   roc $$ maps" shows the   is Ox7fffa6b79000   for my bash process   and different   always matching the   pattern   Ox7fffXXXXXOOO.   of "stack randomization"   which is an attempt   to   stack values.   Items are pushed onto the stack using the push instruction.  The effect   89    90   CHAPTER 9. FUNCTIONS   8 from the stack pointer   of push is  to subtract  value being pushed at that address.  Initially  the stack pointer  set to Ox7ffffffff000  or some  system when  a process  creased  Ox7fffffffeff8 through   On the first push, rsp would be de­  is started.   Ox7fffffffe  address   to Ox7fffffffeff8 and an 8 byte value would  be  placed   in bytes   ending in 000  by the operating   rsp and then place  the   would be   fff.  onto the stack by the operating   Many different   values  are  pushed   These include   system.  and values defining  parameters   for the program.   things   the environment    a  collection  of variable  names  the command line  like the search  path   and   Values can be removed   from the stack using the pop instruction.   pop   in the reverse  pattern  by the stack pointer   of push. It moves the value at   rsp  to a register   or memory location   the location   and   operates  specified  then adds 8 to rsp.   You can push and pop smaller  the stack remains   works as long as  operation.  word push may fail. It is simpler   So if you push a word and then push a quad-word, the quad­  to push and pop only 8   byte quantities.   than 8 bytes,   values  bounded appropriately   for the current   at some peril.   It   9. 2 Call instruct ion   The assembly  be like   instruction   to call a function   is call. A typical   use would   call my_function   The operand   my_function is a label in the   text segment   of a program.   the call instruction   The effect of  following  associated  the "return  address" .  Another   the call onto the stack and to transfer  with my _function. The address pushed   the instruction  to the address  control  onto the stack is called   way to implement  a call would be   is to push the address of   push next_ instruction  jmp  my_function   next_ instruct ion:   While this does work, the call instruction  which we will generally   ignore.   has much  more   capability    9.3. RETURN INSTRUCTION   91   9.3 Return instruction   To return  pops the address  address.  return   address.   from a function   you use the ret instruction.   This instruction   In the previous example   the stack and transfers control  next_instruc  tion is the label for the   to that   from the top of   9.4 Function parameters   and return value   which  might   be integer   values, floating   of data values, addresses   of arrays  , or any other   Most function have parameters  point values, addresses  type of data or address.  operate  a return value which is commonly   on different   The parameters   data with each call. In addition most   allow us to use a function  functions  have  or failure.  "System  V Ap­  of success   to   an indicator   call protocol called the   x86-64   System V ABI. Unfortunately  the "Microsoft x64 Calling   Linux uses a function  Binary Interface"  or  called   plication  uses  a different  protocol  In both protocols  ters. Linux allows  which  Windows  lows the first 8 floating point  registers  rameters   some of the parameters  to functions  the first 6 integer  parameters  allows the first 4  using different   xmm0-xmm7, while Windows allows  xmm0-xmm3.  to be passed in registers   parameters   registers   . Linux al­ to  be passed in floating  pa­  are passed   Windows   Convention"  .   in regis­  pointer   the first 4 floating point   to be passed in registers,   and register   Both  Linux   rax for integer  and Windows use register  values.  Both Linux and Windows  expect   xmmO for floating   the stack pointer   point return   return   values   to be maintained   means that the  hexadecimal   in functions   on 16 byte boundaries· in memory.  This  value for rsp should end in 0. The reason for this requirement  is  to  allow local variables  alignments  SSE and AVX instructions.  leaving  something  your function  16 byte bounding   for  rsp  should either  push  on  a 16 byte boundary. If  it seems wise to stick with the   calls any external  requirement  it ending with an 8. Conforming functions   a call would then decrement   from rsp to get it  back   or subtract   Executing   to be placed   at 16  byte   function,   .  The first 6 integer   parameters   in a function under Linux are passed   in registers  r8 and r9 for the_ first 4 integer  parameters.   rdi, rsi, rdx, rex, r8 and r9, while Windows uses rex, rdx,  more   If a function  requires    92   CHAPTER 9. FUNCTIONS   parameters, they are pushed onto the stack in   reverse   order.   like scanf and printf which have a variable  number   of   floating   point parameters   in the function   FUnctions  parameters  call using the rax register.  For 32 bit  programs   pass the number  of   the protocol   is different  . Registers   not available,  in registers. These programs   so there is not much value in passing   function   use the stack for all parameters  We are finally   ready for  "Hello   World!"   r8-r15 are  parameters  .   section . data   msg:  db  11Hello   World! 11 ,0x0a,O   sect ion . text  global main  extern printf   main:   push  rbp  mov rbp, rsp  lea rdi, [msg] parameter 1 for printf  xor eax,  eax 0 f loating point parameters  call printf  xor eax, eax  return 0  pop rbp  ret   We use the "load effective address"   tive address  be done with mov, but lea allows specifying more  items  so that we could load the address    lea  to load the effec­ to print with printf into rdi. This could also  in the brackets   of an array element.   instruction   of the message   Interestin  gly when the system starts   a program   in _start the param­  eters to _start are pushed onto the stack.  main are in registers like any other C function.   However, the parameters   to   9 . 5  Stack frames   One of the most useful  backwards   through   features   of the gdb debugger   the functions   which have been called   is the ability  bt or   command   to trace    9.5. STACK FRAMES   93   this trick each function    . To perform  backtrace rbp to a 2 quad-word  rbp along with the return  You might notice  rbp, mov rbp, rsp" in the hello world program.  pushes  makes rbp point to that object.   rbp immediately   address.   object on the stack identifying   below the return address.   must keep a pointer   in  the previous  value of  the sequence   "push   The first instruction  The second instruction   Assuming   be a linked   obey this rule of   all functions  instructions,  there  will  each function  invocation.  identify  location  and use other information  in the executable  number for this return  address.   the funCtion  based on the  stored   The debugger   list of objects   with the standard 2  on the stack -one for  the list to  address    can traverse through   of the return   to identify   starting   the line   called   These 2 quad-word   objects   are  simple  examples  of   "stack frames".   for the function   which do not call other functions   In functions  might all fit in registers.  variables  local variables  or if the function calls other functions,  need to be some space on the stack for these local  space for the local  to leave 32 bytes for local variables   variables,   in the stack frame do this:   variables  If there are too  many   then there might   you simply subtract from rsp. For example    leaf functions ,  the local   . To allocate   Be sure to subtract a multiple  stack alignment  .   of 16 bytes to avoid possible   problems  with   To establish a   stack frame, you use   the following   2 instructions   at the   push rbp  mov  rbp, rsp  sub  rsp, 32   start of   a function:   push rbp  mov  rbp, rsp   The effect of the these 2 instructions  can be undone using   and a possible   subtraction   from rsp   leave   just before  standard 2 instru�tion   a ret instruction.   prologue   For a leaf function   there is no need to do the   and no need for  the leave instruction.    94   CHAPTER 9. FUNCTIONS   They can  also be  omitted  able to trace backwards   in general  though the stack frames.   though it will prevent   gdb from being   When you have local variables in the stack frame it makes sense to   these variables   access  This can be done by using yasm's equ pseudo-op. The following  sets up  symbolic   names for 0 and 8 for two local variables.   using names rather   than adding 8 or 16 to rsp.   Now we can easily   save 2 registers in   x and y prior to a function   call using   X  y   equ  equ   0  8   mov  [rsp+x]  , r8  mov  [rsp+y]  , r9   With any function   protocol   you must specify which registers  must be  rbx, rbp and   For the System V ABI, registers   in  a function.   preserved  r12-15  that registers   must be preserved,   while the Windows calling   convention requires   rbx, rbp, rsi ,  rdi and r12-15 must be preserved.   9.6 Recursion   techniques   in computer  program­ which calls itself.   is a function  into smaller problems.  Frequently   The   same function.   So you break   solving   can be solved   recursion   the fundamental   problem  A recursive  function  is to break a problem   One of  ming is recursion.  focus of  these smaller problems  by the  the problem  such a small problem  is called  a  "base case" .  see if you have reached  case, then you prepare  the  into subproblems  calls you assemble solutions  to  problems.   calls.  problems   that it is easy to  solve.   and make recursive   functions   larger   into smaller  problems  repeatedly   you reach   and eventually  The easy to solve problem   Recursive  the base case or not. If you have reached  easy solution.  If not   typically   you break the   the base  problem   start by testing   to   As you return   from recursive   from solutions to  smaller   Recursive   functions   generally   require   storage for each stack frame. Using  the  can help in debugging.   _   stack frames with local variable  complete   stack frame protocol    9.6. RECURSION   95   Using the function call protocol   it is   easy enough to write recursive   As usual,  recursive   functions   test for a base case prior to   functions.  making a recursive  call.   The factorial   function   can be defined recursively   as   f n  = { � * f n -1    if n <= 1  if n > 1   Here is a program  n!.   to read an integer   n, compute   n! recursively   and print   segment . data  dq  0   X  scanf format db  " %ld", O   printf_format db  " fact %ld  =  %ld", Ox0a , O    segment . t ext  global main  global fact  extern scanf  extern printf   main:   tell linker about main  tell world about fact  resolve scanf and  scanf from l ibc   push rbp  mov  rbp, rsp  lea rdi, [scanf_format] set arg 1 for scanf  set arg 2 f or scanf  lea rsi ,  [x]  set rax to 0  xor eax, eax  call scanf  mov  rdi, [x]  call fact  lea rdi, [printf_format] ; set arg 1 for printf  set arg 2 for printf  mov  rsi ,  [x]  set arg 3 to be x !   mov rdx,  rax  set rax to 0  xor eax, eax  call printf  xor eax, eax  leave  ret   move x for f act call   set return value to 0    96   f act:  n   equ  push  mov  sub  cmp  j g   mov  leave  ret   mov  dec  call  mov  imul  leave  ret   greater:   CHAPTER 9. FUNCTIONS   re curs ive function   make room for storing n  compare argument  i f  n <= 1 ,  return 1  set return value to  1   with 1   8  rbp  rbp , rsp  rsp, 16  rdi,  1  greater  eax, 1 ·    [rsp+n]  , rdi  rdi  fact  rdi , [rsp+n]  rax, rdi   save  n  call fact with n-1   restore original n  multiply fact n- 1  *n   You will notice   that I have set   rax prior to calling   The value of rax is the number of floating  make a call to a function  In the fact function   with a variable  I have used an   number of parameters.  equate for the variable n. The  defines the label n to have the value 8. In the body   point parameters   equ statement  function  call. The reference [rsp+n]  flexibility   to [rsp+8]  in  coding while  being   is equivalent   clearer.   , but it allows   more   I save the value of n on the stack prior to making a recursive   of the   scanf and printf.  when you    9.6. RECURSION   Exercises   97   1 .  Write an assembly   program   to produce   a billing report   of customer   giving   for an electric  using scanf  records  the customer   details  0  and a  number   of a name   data will consist   the terminal   The number of kilowatt   will be $20.00   equal to 1000 or $20.00   hours is  if the number of  plus 1 cent   1000 if the usage is greater  after dividing   by 100 to print the amounts   than 1000. Use   Write and use a function   to  compute   The customer   not including   per customer.   It should read a series   company.  and print one output line per customer  and the amount of the bill.   up to 64 characters  of kilowatt  hours  an integer. The cost for a customer  kilowatt hours is less than  or  per  kilowatt  hour  over  quotient  and remainder  as normal dollars  the bill amount  in pennies .  2. Write an assembly  program   by calling the  C library  a bubble sort function  stored  allocated. The number of elements  be stored  the array elements  function to print the array content before  equal to 20, call your print function   in the . bss segment   to generate   and cents.   function   filling   in  a memory location. Write a function   to fill, sort and print should  to loop through  Write  a   the array with random integers.   s. If the array size is less than or   and after printing.   an array   of random integers   random , to sort the array using   and to print the array. The array should be   and does not need to be dynamically   triple   3. A  Pythagorean   is a set of  three  that a2 + b2 =  c2. Write an assembly  Pythagorean  a number   integers  program  where c <= 500. Use a function   is a Pythagorean triple.   a, b and c such  to print all the  to test whether   triples   4. Write an assembly   program   to keep track of 10 sets   of size 1000000.   should read accept the following  and quit. The program   add,  commands:  to  should have a function  which it is and return  0, 1,   and determine   on the string   read. After reading   add your program   set number from 0 to 9 and an element   number from   Your program  union,  print  read the command string  2 or 3 depending  should read a  0 to 999999  to have a fu:p.ction   and insert   the element  to add an element   into the proper set. You need  union  to a set. After reading    98   CHAPTER 9. FUNCTIONS   should read 2 set numbers   your program  equal to the union of the 2 sets. You need a set union function.  After reading  should print all the elements  the set. You can assume  that the set has only a few elements. After  reading   quit your program  should  exit.   print your program   and make the first set be   of   5. A sequence   of numbers is   called bitonic   if it consists   of an increasing   or if the  sequence  can  sequence   sequence   Write an assembly   followed by a decreasing   of an increasing  program   until it consists  sequence.  into an array and print out whether   sequence  be rotated  decreasing  of integers  bitonic  should be 100. You need  to  write  numbers into  the  sequence  array.   array and a second to determine  Your bitonic   2 functions: one to read the  whether  the  rotate  the   or not. The maximum number of elements   not actually   is bitonic.   test should   followed by a   is   in the array   to read a sequence  the  sequence   6. Write an assembly   program   and compute their greatest  rithm,   which  is   to read two 8 byte integers  common divisor   using Euclid's  algo­  with scanf   based on the recursive  if b = 0   d   b  { a  gc a,  .  gcd b, a mod b  otherwise   definition   of left and right paren­  7. Write an assembly   program   to read a string  determine whether   the string   contains   a balanced  set of   theses and  parentheses.  a character  it is the empty string  consists  by a sequence  example   or if it  of balanced   of a balanced   You can read the string with  array of length   80. A set of parentheses   scanf using "%79s" into   if   is balanced  of a left parenthesis followed   sets and a right parenthesis.  Here's   an            " .  "            set of parentheses:    Chapter 1 0    Arrays   of memory cells   of a specific   type. This   The start address   is the lowest   label used when defining   an   collection   An array is a contiguous  means that an array has a start address.  address  by the  array in the text or bss segment.   in the array and is identified   Elements   of the array are accessed   being 0 as in C. Subsequent  final index   of an array of size n is n-1 .    indices   index  by index with the smallest  addresses . The   access higher memory   It would be possible   to define arrays with different   starting   indices.   for Fortran is for arrays to start at index 1 and you   In fact the default  However it  can define the range of indices  is quite natural  to use 0 as  the first index for arrays. The assembly  code  is simpler in  this way which  helps   high level languages.   C artd C++.  with efficiency in   in  many   10.1 Array address   computation   There can be arrays  bytes, words, double words,   defined later .  structs   of many types of data. These include   the basic types:   and quad-words.   We can also   have arrays   of   Array elements   are of a  specific  type   so each array element   occupies   number of bytes of memory. This makes   it simple   to compute   any array element. Suppose that the array a with base   base uses m bytes per element, then element   a [i] is located   at   the same  the  location  of  address  base  + i*m.   99    100   CHAPTER 10. ARRAYS   Let's illustrate   the indexing   of arrays using the following   program:   . bss   segment  resb  resd  align  resq  segment  global   100  100  8  100  . text  main   a  b   c   main:   rbp  rbp, rsp  rsp, 1 6    push  mov  sub  leave  ret   let the l inker  know   about main   The program   has 3 arrays of different   types. We will run gdb and   array elements   to see the effect. Unfortunately  It know the location   print  addresses  of various  gdb is unaware of the types of variables.  a, b and c by name and, without  is a double word  integer named yld and ygcc to use instead of ld and gee to link programs. These  scripts  prepare  invoking   macros for gdb which will be automatically  loaded when   . To overcome this problem   gdb using the ygdb script.   it assumes that each  I have written   the  type,   of variables   scripts   knowing   Here is ygdb session:    gdb  p  a  $ 1  =  unsigned char *    Ox6010d8 " "    gdb  p &a [1]  11 11  $2 =   unsigned char *    Ox6010d9   gdb  p &a [2]  $3 =   unsigned char *  Ox6010da 11 11   gdb   p  b  $4 =   int *    Ox60113c   gdb   p &b [1]  $5 =   int *  Ox601140   gdb  p  &b[2]  $6 =   int *  Ox601 144    10.2. GENERAL PATTERN FOR   MEMORY REFERENCES 101    gdb  p  c  $7 =  long *    Ox6012d0   gdb  p &c [1]  $8 =  long *  Ox6012d8   gdb  p &c [2]  $9 =  long *    Ox6012e0   The macros used by ygdb essentially   treat every variable  of a. You can see from the first  in memory. Next   1 byte intervals   as an array.   pattern   When we use "p a", it prints  the address  3 results  a are at  that the elements of  we see the same  words  int in C and gdb  and that the  intervals  an array of quad-word integers  elements   in memory. Finally   are placed at 8 byte intervals.   repeated   array elements   at 4 byte  c which is  we see the  results  for inspecting   long in C and gdb  and that these array   are placed   for array b which is an array of double   10.2 General pattern   for memory references   So far we have used array references  the options  as   for memory references.   in sample code without   discussing   A memory reference   can be expressed   [label] the value contained   at label   [label +2*ind] the value contained   at the memory address   obtained   by   times 2  adding the label and index register   [label+4*ind] the value contained at  the memory   address   obtained by   times 4  adding the label and index register   [label +8*ind] the value contained  at  the memory address   obtained   by   adding the  label   and index register   times 8   [reg] the value contained   at the memory address   in the register   [reg+k*ind] the  value  adding the register   contained  at  the  memory  address  and index register times   k   obtained   by   [label +reg+k*ind] the value contained at the  times k   memory address  by adding the  label,  the register   and index register   obtained    102   CHAPTER 10. ARRAYS   [number+reg+k*ind] the  value  by adding the number,   at the memory address  and index register  times   the register   contained   ob­  tained  k   flexibility  it is possible   in array accesses. For arrays in the  to use the label along with an  index  size  as long as the array  with a multiplier  siz;e is 1 ,  2, 4 or 8 . With arrays passed into functions,  the   for the array element   in a register. Therefore the form using a label is   we could use a base register   along with. an  index   Any of the 16 general  or an index register,   however   purpose   it is unlikely   that you would use   registers  may  be  used   as a base   This allows  a   lot  of  text and data segments  register  element  address must  not possible.  register.  register  the stack pointer   be placed  Instead   as an index register.   register  example   Let's look at an   using a base register  we wish to copy an array to another   Let's suppose  Then the two array addresses  rsi  and the number of array elements  Let's assume that the arrays   register.  and an index  array in  a function.    rdi and ·  could be the first 2 parameters  rdx.  third parameter  .   are double word arrays   could be the   segment . text  global copy_array   copy_array:   xor ecx, ecx   more: mov  eax, [rsi +4*rcx]   , eax  mov  [rdi +4*rcx]  add  rex, 1  cmp  rex, rdx  j ne  more  xor eax, eax  ret   In the   copy _array function   we used the parameters   We used rsi as the base  address  register for   for the destination   as they were pro­ and   the source array  array. For both ac­  vided.  rdi as the base address  cesses  arrays  to see if there are more elements   we used rex as the index register  have 4 byte elements. This allows  to copy.   register   with a multiplier  use to compare   of 4 since the  rex versus  rdx    10.3. ALLOCATING ARRAYS   103   Note that   multiplying  0 cost to using the multiplier.   by 2, 4 or 8 is a shift of 1, 2 or 3 bits,   Alternatively   we could add 4   so there   is effectively  to e cx in each   loop iteration   after shif  The last pattern   would be useful   you had an array of structs with  then the number part of the  a pointer,  the struct  within  element  register could   define the address   each struct   the struct, while the base register   and index   of a particular  struct   in the array.   ting rdx left 2 positions.  for accessing   an array of structs.   having a character   If  array and  could be the offset of   reference   10.3 Allocating arrays   The simplest  C library malloc function. The prototype   memory in assembly  for malloc is   way to allocate   is probably   to use the   void *malloc  long size  ;    to the allocated   memory, while   malloc returns  in malloc returning   a pointer   on 16 byte boundaries,  needing   for arrays   On success  failure results  is bounded   except  type of object  A VX instructions calling  the free function    . The memory can be returned  returned   with the pointer   for any  for  for potential  reuse by  by malloc   0. The memory returned  which is useful as an address   by malloc   to  be on 32 byte boundaries   void free   void *ptr   ;    Here is an assembly   segment   to allocate   an array of 1000000000  bytes   extern malloc   mov rdi, 1 000000000  call malloc  mov  [pointer]  ,  rax   to using allocated   There are several   advantages  vious one is that you can have arrays  you can compute  array of the correct  data or bss segment, you have to know the  size  the program  or guess .   of exactly   size. If you use statically defined   arrays either in  needed before running   the size of array needed in your code and  allocate   the right size. Frequently   an  the   arrays.  The most ob­   104   CHAPTER 10. ARRAYS   the assembler,   due to size   Another   imposed   less obvious   yasm reports   or operating   array of 3 billion   reason for using  allocated   arrays  is  on the data and bss sections by  either  limitations  linker  system.  you try to allocate an  an array of 2 billion  seconds  with a  2 GB array. In addition  file exceeded  to assemble  about 10 thousand  bytes.   both  the  object  size. It is much faster  less than 1 second   using malloc and the executable   FATAL: out  of memory when  with  bytes or greater. It succeeds  104   2 billion  and link a program   on a 2.4 GHz Opteron system   to assemble   bytes in   and link a test program  file and the executable   bytes in the bss segment. It took approximately   size was   The program   using malloc was modified   and still  assembled  milliseconds.  memory other than  using   and linked   There is no more practical   allocated   memory.  not to attempt   in less than 1 second.   to allocate   20 billion  It executed  way to use large amounts of   bytes  in 3   The user should be cautioned   to assemble   programs   This will   with large static  quired.  far more than 100 seconds  process.  even if they are allocated. Disk thrashing   memory needs on a  computer  cause disk thrashing while assembling  computer  during   crippling the  to use arrays larger   Also it can be quite painful   and linking,  using   than memory   with  less  RAM  than   and nearly   is not cool.   the   re­  10.4 Processing arrays   an example   arrays. This application   application  Here we present  process  allocates  the array with random numbers by calling  minimum value in the array.  it prints   with several  functions  an array  using   which  malloc,  fills  random and computes  the  equal to 20,   the values in the   array size is   less than or   If the   array.   10.4.1 Creating the array   The array  is created  tion is perhaps  size  by   too short to be a separate   function.   4 to get the number of bytes in the array  and   It multiplies   the array  then calls malloc.   using the create function   shown below. This func­  array= create  size  ;    create:    10.4. PROCESSING ARRAYS   105   push rbp  mov rbp, rsp  imul rdi, 4  call malloc  leave  ret   10.4.2 Filling  the   array with random numbers   and its size. It also stores   uses storage   The f ill function  pointer  3 variables  maintain  using "mov [rdi +rcx*4]  of the array and rex contains   the 1 6  byte alignment   require   on the stack for local copies   of the array   24 bytes of storage,   a local variable   These  so we subtract 32 from rsp to   on the stack.   of the   stack. We store data in   , rax", where rdi holds the address   the array  of the start  element.   the index of the current  array   local labels.  is between   Here  we   use several   A  local  label   beginning   normal labels.  . array, . size, . i and . more are local.   with a dot. Their  scope  tion, labels  these same labels  application.   in other functions, which simplifies   the coding of this   is a  label  So in the f il l  func­ This allows   reusing   f il l    array, size   ;   f il l:  . array equ  0  . size equ  8  . i   equ  16   push rbp  mov  rbp, rsp  sub  rsp, 32  mov  [rsp+. array] , rdi  mov  [rsp+. s ize] , rsi  xor  ecx, ecx   . more mov  [rsp+. i] , rex   call random  mov  rex, [rsp+. i]  mov  rdi, [rsp+. array]  , eax  mov  [rdi +rcx*4]  inc rex    106   CHAPTER 1 0. ARRAYS   rex, [rsp+. size]  . more   emp  j l   leave  ret   10.4.3 Printing the array   the array is done with print£. The print function:   Printing  f ill, needs to save 3 values on the  The code is somewhat  into a register rather  that  the data segment  the print£ call. You will also notice  labels.   just like  function.  are loaded  You will notice  is used to store the print£ format in  a spot  near  that I have reused several  local   to f ill, except  than values being stored   that array values  in the array.   stack since it calls another   similar   print  array, size  ;    print:  . array equ  0  . size equ  8  . i equ  16   push rbp  mov rbp , rsp  sub rsp, 32  mov  [rsp+. array] , rdi  mov  [rsp+. size], rsi  xor eex , e ex  mov  [rsp+. i], rex  segment . data   . format :   db  " %10d", Ox0a, O   segment . text   . more lea rdi, [ .format]   mov  rdx, [rsp+. array]  mov  rex, [rsp+. i]  mov  esi, [rdx+rex*4]  mov  [rsp+. i] , rex  call print£  mov rex, [rsp+. i]    1 0.4. PROCESSING ARRAYS   107   inc rex  mov  [rsp+ . i] , rex  cmp  rex, [rsp+. size]  j l   . more  leave  ret   10.4.4 Finding the minimum value   does not call any other functions, so there is no real need   The min function  for a stack frame and no need to align the stack  conditional  pipeline.   move instruction   at a 16 byte boundary. A   is used to avoid interrupting   the instruction   min:   X  = min   array, size   ;   mov  eax, [rdi]  mov rex, 1   . more mov r8d, [rdi +rcx*4]   cmp  r8d, eax  cmovl eax, r8d  inc rex  cmp  rex, rsi  j l   . more  ret   10.4.5 Main program for the array minimum   The main program  variables  array size,  outline   the behavior.   is shown below. It uses stack space for the local   . array and . size. It uses a command line parameter  for the  in the code  which is discussed   in the next section.   Comments   main:  . array equ  0  . size equ  8   push rbp  mov  rbp, rsp    108   CHAPTER 10. ARRAYS   . nosize:   sub rsp, 1 6    set default size  mov  ecx, 10  mov  [rsp+. size], rex   --  a size   g   check f or argv [1] providin cmp  edi, 2  j l   . nosize  mov  rdi, [rsi+8]  call ato i   mov  [rsp+. s ize] , rax   create the  array  mov rdi, [rsp+. size]  call create  mov  [rsp+.array], rax   f ill the array with random numbers  mov  rdi, rax  mov rsi ,  [rsp+. size]  call f i l l    i f  size <= 20 print the array  mov  rsi ,  [rsp+. size]  cmp  j g   mov  call   rsi ,  20  . toobig  rdi, [rsp+ . array]  print   . toobig:   . format:   print the minimum  segment . data   db  "min: %ld", Oxa , O   segment . text  mov rdi, [rsp+.array]    10.5. COMMAND LINE PARAMETER ARRAY   109   mov  rsi ,  [rsp+. size]  call min  lea rdi, [ . format]  mov rsi ,  rax  call print£   leave  ret   1 0 . 5  Command line parameter   array   available to a C program   as parameters   The command line parameters are  to main. The number of  to main and an array of character  main. The first parameter  run. The remaining  the rest of the command line.  patterns  the command line with all  the   parameters   like * . dat   command line parameters   is the first argument   to  is always the name of the executable   is the second argument  file being   pointers   This expansion   are the expansion   by the user's   makes it convenient  shell replaces  that   shell of  to use  part of   on the command  line.  The   matching file names.   Here is a simple   C  program to   print the command   line parameters:   include     int main   int argc, char *argv []    {   int i ;   f or   i = 0 ;  i  < argc; i++   {   printf  11 %s\n11, argv [i]   ;    }  return 0 ;    }   .  args  hello  world   When executed   as " . args hello world", it prints    110   CHAPTER 10. ARRAYS   The argv array is passed like all C arrays by placing  or on the stack.   the array in a register   the address  of  In the case of   is in register   rsi. Below is a translation   though  the   assembly   code takes advantage   of the program  of the fact that   the first element  of  argv its address  to assembly,  there is a NULL pointer   at the end of the argv array.   segment . data   f ormat db  " %s ", Ox0a , O    main: push rbp   segment . text  global  main  extern printf   mov  sub  mov  mov   rbp, rsp  rsp, 1 6   rex, rsi  rsi ,  [rex]   start_loop:  l ea  mov  call  mov  add  mov  cmp  j nz  end_loop :   rdi, [format]  [rsp], rex  printf  rex, [rsp]  rex,  8  rsi ,  [rex]  rsi ,  0  start_loop   xor eax, eax  leave  ret   let the linker know  about  reso lve printf  from  prepare stack frame for main   main   l ibc   move argv  to  rex  get f irst argv string   save argv   restore rsi  advance to next pointer in argv  get next  argv  string   end with NULL pointer    10.5. COMMAND LINE PARAMETER ARRAY   111   Exercises   1. Write 2 test programs: one to sort an   array of random 4 byte in­ of   should use the C library   using bubble sort and a second program  using the qsort function  function   tegers  random 4 bytes integers  Your program  a  number supplied  number is the size of the array  number of 4 byte integers your program  using random.   on the command line from ASCII to long. This   . Then  the array using malloc and fill the array   can allocate  You call qsort like this   to sort an array  from the C library.  atol to convert   qsort   array, n ,  4 ,  compare  ;    address   of a comparison   is the number of array elements  bytes of each element. The fourth parameter   The second parameter  the third is the size in  is the  will accept two parameters. Each will be a pointer  integer. The  comparison  function  should  return  a  positive  to do is subtract   negative,  s. All you have  the  second  integer  from   value based on the ordering   Your comparison   to a  4  byte   function.   function   the first.   2 integer  to sort and   of the   0 or   2. Write a program   to use qsort to sort an array of random integers  search   the array.   to search   function   be given as a command  line   for numbers in  parameter.   should use random0 %1000 for values in the array.   the array should   and use a binary  The size of  Your program  This will make it simpler  the array and sorting  numbers  read, your  program  either  that the number was not found.   report   to enter   values   to search  should enter a loop reading   for. After building   it, your program  with scanf until scanf fails to return   a 1. For each   number   should call your binary search function and  that the number was found at  a particular  index or   3. Write an assembly   program to compute the Adler-32 checksum   value for the sequence  at a time until end of file.  The   prototype   for fgets is   of bytes read using fgets to read 1 line   char *fgets  char *s, int size, FILE *fp   ;     112   CHAPTER 1 0. ARRAYS   The parameter  segment.  s. The parameter  following   s is a character   array which should be  in  the   bss   The parameter   size is the number of bytes in the array   fp is a pointer   and you need stdin. Place the   line in your code to tell the linker   about stdin   extern  stdin   fgets will return  when it fails. You are to read until it fails. The Adler-32  is computed   s when it succeeds and   the parameter  will return 0   checksum   by   long adler32  char *data, int len   {   long a =  1' b =  0 ;   int i ;   for   i =  0 ;  i  < len; i++    {  a =   a + data[i]  % 6552 1;  b =   b  + a  % 6552 1;   }  return  b << 16  I a ;    }   Your code should  the function  again restarts   shown for 1 line, it works for that line, but calling  . . .    it   compute   1 checksum   for the entire file.  If you use   4. Write a test program   t o  evaluate   how well the hashing   function   below works.   int multipliers[] =  {   1 23456789,  234567891 ,   345678912,  4567891 23 ,  567891234,    10.5. COMMAND LINE PARAMETER ARRAY   113   678912345,  789123456,  891234567   } ;    int  {   }   hash   unsigned   char *S     unsigned  int i = 0 ;    long h   = 0 ;    while   s [i]   {   h =  h +  s [i]  i++;   }  return h % 9999 1 ;    * multipliers[i%8];   using scan£   of strings   it should call   should read a collection   into a charac­ should read until scan£ fails  hash  written   Your test program  "%79s" where you are reading  with the format string  of 80 bytes.  ter  array  Your program  to return 1 .  As it reads each string    to get a number h from 0 to 99990. It should  increment  assembly h of an array of integers  location  the data, this array contains  location  to a particular  many of these  array entries  how many have 2 entries,  same location,  through  the index there.  this could be done using   in the array. What we want to know is  1 entry,  words map to  the  next step  is  another   have 0 entries,  etc. When multiple   it is called  a  the array collision   There should be no more than 1000 collisions,   how  how many have   of size 99991. After entering  all   a count of how many words mapped   counts and increment   n" . So the   "collisio  array by   to go   in   so   for     i  =   0 ;  i  < 99991; i++    {   k =  collisio ns[i];  if     k  >  count[k]++;   999    k  = 999;    1 14   }   CHAPTER 10. ARRAYS   loop the count array has   interesting   data. Use a   this array and print the  index   and the value   previous  step through   After the  loop  to  for all non-zero  An interesting   locations.  file to test is " usr  share diet words".   5. Write an assembly   program   to read a sequence  if the first number entered   scanf and determine  of the other  numbers  as a sum of some  exists. You can assume that there will be no  Suppose  the numbers  Suppose the numbers  solutions  of integers  can be formed  and print a solution  if it  are 20, 12, 6, 3 ,  and 5. Then 20 = 12 + 3 + 5.  are 25, 1 1 ,  17, 3. In this case there are  no   more than 20 numbers.   using   .    Chapter 1 1    Floating point instructions   the 8087 to per­  arithmetic.   Many early computers  lacked   The 8088 CPU used  a floating point  coprocessor  called  form floating  point  chip and perf ormed floating  ment continued until  the  486  which  The 8087 used instructions  point values. These instructions  are  still  there is a completely  sixteen  mode. We will  study the newer   part of modern CPUs, though   256 bits for the Intel Core i series  in 64 bit   a coprocessor  interna a stack of 80 bit floating   point operations  contained   point facility available which  has   in software. This arrange­  which manipulated   instructions.   128 bit registers   separate   floating   the 8087   lly.   Architectures   If you study the Intel  find many instructions   64 and IA-32  you  will  named ST   0    , ST   1    , . . . .  or. There are newer instructions  such  as   Manual,  registers  coprocess with Streaming SIMD Extensions   These instructions   SSE  registers  SIMD is an acronym for "Single Instruction   such as fadd which work with  are for the math  addsd which work  xmmO, xmm1 ,  . . .  xmm15 .    -Multiple   Data". These   Software   Developers   instructions are   the focus of this chapter.   1 1 . 1  Floating point registers   point registers   1 value or multiple   There are 16 floating  either  xmm1 ,  ... and xmm15. These registers  ating on a single   which serve dual purposes  are xmmO,  values.  The names for these registers  oper­ values.  When   or on a vector of   each register   can be used with instructions   value  in   holding   1 15    116   CHAPTER 1 1 .  FLOATING POINT INSTRUCTIONS   used as a vector an XMM register  doubles.   can be used as  either   4 f loats or 2   of computers   The Core i  series  which doubled   tensions  some new instructions.  you need to use a register  register   occupies   the Advanced   introduced   the size of the floating  To use the full 256 bits   8   Vector Ex­ point registers  and add  f loats or  4 doubles   name from ymmO, ymm1, ... ymm15. Each XMM   the first 128 bits of the corresponding   YMM register.   For most of this chapter   the discussion  refers   In  all  operate  probably   cases the same instruction  on twice as  many data values.  be more confusing than  accepting  it as a rule.   can  be  used   Stating this repeatedly  would   only to XMM registers.  with YMM registers   to   1 1 .2 Moving data to from floating   point regis­  ters   are 128 bits on most x86-64 CPUs   The SSE registers  A VX register or multiple  data value and instructions  as "packed"  data.   s . These registers  operations    256 bits for the  at a time  can be used to do 1 operation  for moving 1  instructions  referred to   at a time. There  are   from moving multiple   data items,   1 1 .2 .1 Moving scalars   movss which moves 32  bit   for moving scalar   and movsd which moves 64  bit  move a floating   There are two instructions  to from SSE registers:   floats   These two instructions  lower part of a XMM register  There is no implicit  the destination.   Here is a sample:    1 value  floating  floating   point values  point values  point values  doubles    .   floating  value from memory to from the   or from one XMM register   to another.   data conversion -after movss a 32 bit value exists   in   movss  movsd  movss   xmmO, [x]  [y] , xmm1  xmm2, xmmO   move value at x into xmmO  move value from xmm1 to y  move from xmmO to xmm2    11.3. ADDITION   1 1 7    1 1 .2.2 Moving packed data   packed data and floating   for loading   There are instructions  integer  packed data. We will concentrate  You can move packed floats or packed doubles.  moving aligned  movaps for moving four floats  XMM registers.  packed data to from YMM  registers moves  twice as many   packed data. The aligned  and movapd for moving  versions   are movups and movupd.  values.   here on packed floating   The  unaligned   or unaligned   point  point data.   There are instructions  instructions   for  are   Moving   two doubles  using   data means that it is on a 16 byte boundary in   memory.   by using align 16 for an array in the data section.   for an array in the bss section   does not do the   by malloc will be on 16 byte boundaries.   be arranged   Aligned  This can  The alignb pseudo-op  job properly.  Your program  aligned  of CPUs the unaligned  the data is aligned. Here is a sample   move to an unaligned   Arrays allocated  will fail with a segmentation   fault if you attempt   to use an   address.   Fortunately   on the Core i series   moves are just as fast as the aligned   moves when   movups xmm.O, [x] move 4 f loats to xmmO  movups ymmO, [x] move 8 floats to ymmO  movups ymm1, [x] move 4 doubles to ymm1  movupd [a], xmm15 move 2 doubles to a   1 1 .3 Addition   The scalar   The instructions  varieties.  addsd to add two doubles.  destination  while  the  add instruction  so testing   destination  the floating   operand.   for adding floating   add instructions   point data come in scalar   and packed  are addss to add two floats and  operand  and   Both these operate on a source   The source  must  be   can be in memory or in an XMM register  in an  XMM  register.   Unlike the integer   point  add   instructions   do not  set   any flags,   must be done using a compare   instruction.   The packed add instructions are   addps which adds 4 floats from the   to 4 floats in the destination   and addps which adds  in the destination using  can be either   XMM registers.  memory or an XMM register, while   Like the   2 doubles from   adds the source   to 2 doubles   tion must be an XMM register. Using packed adds with YMM   adds either   8 pairs of floats or   4 pairs of doubles.   source  the source  . scalar  the destina registers    118   CHAPTER 11. FLOATING POINT INSTRUCTIONS   , xmmO store sum in c   movss xmmO, [a] load a  addss xmmO, [b] add b to a  movss  [c]  movapd xmmO, [a] load  2 doubles from a  addpd xmmO, [b] add a [0] +b [0] and a [1] +b [1]  movapd [c], xmmO store 2 sums in  c  movupd ymmO, [a] load  4 doubles from a  addpd ymmO, [b] add 4 pairs of numbers  movupd [c], ymmO store 4 sums in c   1 1. 4  Subtraction   scalar   The scalar   operates   like addition   Subtraction  packed floats or doubles.  the  source  subtracts  float from the destination  the source  double from  subtracts  be either in  an XMM register.  instructions.   memory or in an XMM register  No flags are affected   on either  subtract instructions   floats or doubles  are subss which  float and subsd which  double.   The source  can  must be   the destination   by the floating   or   , while the destination   point subtraction   The packed subtract instructions are   subps which subtracts   4 source   from 2 doubles   floats from 4 floats in the destination  source doubles  Again the source can  be in memory or in an XMM register, while  the  destination  registers   must be an XMM register. Using packed subtracts  with YMM   in the destination   8 floats or 4 doubles.   using XMM registers.   and the subpd which  subtracts   subtracts   either   2   movss xmmO, [a] load a  b from a  subss xmmO, [b] subtract  movss [c] , xmmO store a-b in  c  movapd xmmO, [a] load 2 doubles from a  subpd xmmO, [b] subtract  movapd [c], xmmO store 2 differences in  c  movapd ymmO , [a] load 4 doubles from a  subpd ymmO ,  [b] subtract  movapd [c] , ymmO store 4 differences in  c   4 doubles from b   a [O]-b[O] and a [1] -b [1]    11 .5. MULTIPLICATION   AND DIVISION   119   1 1 . 5  Multiplica  tion and division   and division   Multiplication  traction  port floats and  doubles  basic mathematical   in that they operate  and they support   instructions   for floating   follow the same pattern   on memory or register   as addition  operands.  They  and packed data.  The   and sub­ sup­  point data are   scalar   double  float   double  float   effect  instruction  addsd add scalar  addss  add scalar  addpd add packed double  addps add packed float  subsd  subtract scalar  subss  subtract  scalar  packed double  subpd subtract  packed float  subps subtract  mulsd  multiply  scalar  scalar  mulss  multiply  packed double  mulpd multiply  mulps multiply  packed float  divsd divide  divss divide  divpd  divide  divps divide   scalar  scalar  packed double  packed float   double  float   double  float   1 1.6 Conversion   It is relatively  teger to  another,  to floating  length integer  tions presented   common to need to convert  floating  point to integer. Converting  from one   numbers  point to another,   from one length  point or from floating   from one length   from integer   in­  to another   is accomplished   using the various move instruc­  so far. The other operations   take special   instructions.   1 1.6.1 Converting to a different length floating point   There are 2 instructions  converts   floats  to  one float to a double and cvtps2pd   cvtss2sd which  doubles:  which converts 2 packed   to convert    120   CHAPTER 1 1 .  FLOATING POINT INSTRUCTIONS   floats to 2 packed doubles.  XMM register  Similarly   while the  2 instructions  convert   can  be a memory location  must be an XMM register.  doubles   destination   The source   or an   converts a double to a float and cvtpd2ps  2 packed floats.  an XMM register.   It  has   the same restriction   to floats: cvtsd2ss which  converts 2 packed doubles  that the destination   must be   to   cvtss2sd  addsd  cvtsd2ss  movss   xmmO, [a]  xmmO, [b]  xmmO , xmmO  [c], xmmO   get a into xmmO as a double  add a double to a  convert to f loat   1 1.6.2 Converting floating point to from integer   point to integers by   round­  word integer  word integer.   floating   which convert   · There are 2 instructions  ing: cvtss2si which converts a float to a double or  quad  and cvtsd2si which converts a double  to a double or quad  or a memory location,  The  source  can be an XMM register  · destination  must be a general  register.  which convert   by truncating:   purpose  cvttss2si and cvttsd2si.  which convert   while the   There are 2 instructions   integers  word integer   cvtsi2ss which  converts  a  double  or  quad  cvtsi2sd which converts  source can  destination  source  the size  location  the size.   to floating  point:  to a float and  to a double.  The  or a memory location,  while the  When using a register  for the  name. When using a memory  specify   be a general  must be an XMM register.  in the register  or "qword"   is  implicit  add "dword"   to the instruction to   a double or quad word integer   you need to   register   purpose   There are 2 instructions   cvtss2si  cvtsi2sd  cvtsi2sd   eax, xmmO  xmmO , rax  xmmO, dword   ; convert  ; convert  [x] ; convert   to  dword  qword  to double  dword integer   integer   1 1 . 7  Floating point comparison   The IEEE 754 specification  of "Not   for floating  These 2 types are   a Number" or NaN.   point arithmetic   includes   2 types   quiet NaNs and signaling    1 1.8. MATHEMATICAL FUNCTIONS   121   NaNs. A quiet NaN  QNaN  is a value which can be safely  propagated  through code without  raising  an  exception.  always raises  nessed a program  signal.   NaN  SN aN   you have wit­ by 0 error which is caused by a   when it is generated.   failing with a divide   an exception   A signaling   Perhaps   Floating   point comparison   d". An ordered comparison  An unordered   is QNaN or  SNaN.   operand   is considered  causes a   to  be either  floating   "ordered"  point exception   or  if  causes an   comparison  ,   uses unordered   comparisons  for only SNaN. The gee compiler   "unordere either  exception  so I will   do the same.   The unordered   floating point   comparison  for comparing   instructions  doubles.   are ucomiss for   floats and ucomisd   while the second operand   The first operand  comparing  can be memory or  must be an XMM  register,  an XMM register.  They set  the  zero  flag and carry flag to  indicate  than, equal or greater  choice after a comparison,  point conditional  floating  jumps.   flag, parity   at least 1 operand   the type of result: unordered   than. A conditional   jump seems like a natural   but we need  some   is NaN , less   different   instructions   for   instruction  jb  jbe  Ja  Jae   meaning  jump if<  floating  jump if<=  floating  jump if>  floating  jump if>=  floating   point  JC Jnae CF=l or ZF=l   point  jnbe ZF=O CF=O   '   point  jncjnb CF=O   flags  point   JC Jnae CF=l   aliases   movss xmmO, [a]  mulss xmmO, [b]  ucomiss xmmO, [e]  j be  less_eq jmp if  a*b  <=  c   1 1 . 8  Mathematical functions   like sine, cosine   The 8087 coprocessor  implemented  a useful  of transcendental  functions  in the  modern  are no longer  the these functions.   CPUs, but they use the floating  recommended.   point register  functions   still  stack and  exist for   nt. These instructions   collection   and arctange  Instead   library   efficient   exist    122   CHAPTER 1 1 .  FLOATING POINT INSTRUCTIONS   The SSE instructions  include   floating   rounding,   point functions  and compute   to compute  min­ square  roots  and   imum and maximum, perform  reciprocals   of square roots.   1 1 .8.1 Minimum and maximum   minimums   instructions  and maximums for floats and   The minimum and maximum scalar  to compute  to  do the same for doubles.  The first operand  XMM register,  register  register.     must be an   destination  source  can be either  an XMM   are minss and maxss  minsd and maxsd   or a memory location.   while the second operand   The result   is placed in the  destination   There are packed versions     or 2 doubles   of the minimum and maximum instructions  minps, maxps, minpd and maxpd which operate on either  4 floats  versions an  XMM  register  memory for the second.  double versions   :   the ps   .  The packed instructions  require  XMM register  and  either  an  4 results    the pd versions for the first operand   The float versions   compute 2 results.   compute   while the   or   movss xmmO, [x] move x into xmmO  maxss xmmO, [y] xmmO bas max  x , y   movapd xmmO, [a] move a [0] and a [1] into xmmO  minpd xmmO , [b] xmmO[O] bas min a[O] , b[O]    xmm0[1] bas min a[1] ,b[ 1]     1 1 .8.2 Rounding   for rounding   4 instructions   The SSE instructions  include  numbers to whole numbers: roundss which rounds 1 float, roundps  which rounds 4 floats, roundsd  rounds 2 doubles.  second operand can be either  There is a third  operand which  selects  view of the possible   and roundpd which  an XMM  register,   or  a memory location.  mode. A simplified  below:   modes is in the table   which rounds 1 double   an XMM register   The first operand   a rounding   rounding   must be   floating   while the   point    11.9. SAMPLE CODE   123   giving   mode meanmg  0  round,  1  round down  2  round up  3  round toward 0  truncate    ties to even numbers   1 1.8.3 Square roots   4 square root instructions:  roots,   2 float square   sqrts s  which   1 float square   include  The SSE instructions  root, sqrtps which computes  computes  1 double  sqrtsd which computes  2 double square  an XMM register,  or a memory location.  packed instruction   roots. As normal the first operand  and the second operand can   with a memory reference.   Bounding   square   root and sqrtpd which computes   destination    must be   to 16 byte boundaries   is required   for   be either   an XMM register   1 1 . 9  Sample code   Here we illustrate  practica  l functions.   some of the instructions   we have covered   in some fairly   1 1. 9 . 1  Distance in 3D   We can compute  arrays   with x, y and z coordinates.   The 3D distance formula is   distance   in 3D using a function which accepts   2 float   distance3d  :    x1-x2  �2   x from second point   movss xmmO, [rdi]  x from f irst point  subss xmmO, [rsi] subtract  mulss xmmO, xmmO  movs s  xmml, [rdi+4] y from f irst point  subss xmml, [rsi+4]  subtract y from second point  muls s  xmml, xmm1  movss xmm2, [rdi+8] z from f irst point  subss xmm2, [rsi+8]  subtract z from second point  mulss xmm2, xmm2    y1-y2   - 2     z1-z2  - 2     124   CHAPTER 1 1 .  FLOATING POINT INSTRUCTIONS   xmmO, xmml  addss  addss  xmmO,  xmm2  sqrtss xmmO,  xmmO  ret   add x and y parts  add z part   11.9.2 Dot product of 3D vectors   The dot product  computed   by   of two 3D vectors   is used frequently   in graphics  and is   d = XIX2 + YIY2 + ZIZ2·   Here is a function   computing the   dot product   of 2 float vectors   passed   as 2 arrays   dot_product:   movss xmmO, [rdi]  mulss xmmO, [rsi]  movss xmm1, [rdi+4]  mulss xmm1, [rsi+4]  addss xmmO, xmm1  movss xmm2, [rdi+8]  mulss xmm2, [rsi+8]  addss xmmO, xmm2  ret   1 1 .9.3 Polynomial evaluation   The evaluation of a polynomial  ways. First is the obvious   definition:   of 1 variable could be done at least 2   A more efficient   way to compute   the value is using Horner's Rule:   bn =pn   bn-1 = Pn-1 + bnx  bn-2 = Pn-2 + bn-IX   bo = Po+ b1x    1 1. 9. SAMPLE CODE   125   Then P x  =  bo.   Written as a function with  an array   of double coefficients   as the  first   parameter  degree    rdi , a value for x  as the second parameter    xmm.O  and the     rsi  we have:  of the polynomial  as the   third parameter   horner: movsd  movsd  cmp  j z    more: sub   mulsd  addsd  j nz   xmm1 ,   xmm.O ,  esi ,  0  done  esi, 1  xmm.O,  xmm.O,  more   done: ret   xmm.O  [rdi+rsi*8]   use xmm1  as  x  accumulator for b  k  is  the degree 0 ?    xmm1  [rdi +rsi*8]   b_k *  X  add p_k    126   CHAPTER 1 1 .  FLOATING POINT INSTRUCTIONS   Exercises   1 .  Write a program   testing   a function   to compute   sin x . The formula   for sin x    is given as the Taylor's series:   sin   x  =  x -  x3 x5 x7  31   + 5! - 7! · · ·   doubles.   work with   Your program   read  should  at a time using scanf . The first number is x and the   Your function should  2 numbers  second number is the number of terms of the expansion  Your program  computes  until scanf fails to return 2.   and print the value it  continue   using scanf. The reading   should call your sine function   and computing   should   to compute.   2. Write a program   to compute   the area of a polygon.   You can use   this formula for the area:   n-1   A = 2 L  XiYi+l   1  i=O  have 3 parameters.  should   -Xi+lYi    The first   parameter   of doubles holding  x values.   The second is an array of   y values. The third is the value n. Your arrays   should  0. The number of vertices  will   n of both arrays   be read using scanf.   be repeats   holding  be size n + 1 and location   Your area function  is an  array  doubles  should  of location  Then your program  the coordinates  and print the area.   using scanf. Lastly   should  allocate   arrays of size n + 1 and read  your program   should compute   3. Write a program   to approximate   the definite   integral   of a polyno­  mial function of degree  of degree   5 is defined by 6 coefficients   5 using the trapezoidal  Po,Pl, . . .  p5, where   rule. A polynomial   2  3  4  5  P x = Po+ PIX+ P2X + P3X + P4X + Psx         The trapezoidal  rule states  f   x   can be   approximated   that the integral  as   from a to b of a function   f a  + f  b     b _ a    2    1 1.9. SAMPLE CODE   127   collection   of sub-intervals   To use this to get a good approximation  from a to b into a  rule on each sub-int of a and b. Then it should read the number of sub-intervals  Last it should read the coefficients  po,Pl, . .  · P5· Then it should  approximate integral.   n.  of the polynomial  the computation and   you divide the interval  and use the trapezoidal  should read the values   erval. Your program   in the order   perform   print the    128   CHAPTER 1 1 .  FLOATING POINT INSTRUCTIONS    Chapter 1 2    Systen1 calls   call is essentially   a function   call which changes   the CPU into   mode and executes   a function   on Linux it runs in user mode   which is part of the kernel. When  which means that it is   do arithmetic,  do   only "safe"   instructions.   It can move data within the  branching,  call  functions,   . . .  , but there are   which  your   program   program   by preventing user programs   to read or write directly   can't do directly. For example  to the disk  input or  from executing  is directly  setting  page   prohibited   action   it would   device,   ons. Another   to executing   A  system  kernel  you run a process  limited  program,  instructions  be unsafe to allow any  so this is prevented  output instructi mapping  reg  isters.   When a user program   needs to do something   like open a disk file, it   makes a system call. This changes  mode where the CPU can execute  input  kernel  open the file and then open it, performing  required   of the program.   will verify that   open function   on behalf   the user program   and output instructions.   any input or output   has permission  instructio  The  to  ns   the CPU's operating   mode to kernel   The Linux system call interface   is different   for 32 bit mode and 64 bit   mode. Under 64 bit Linux the 32 bit interface is still  32 bit applications  and this will work to some extent   available to support  for 64 bit programs.   129    130   CHAPTER 12. SYSTEM CALLS   1 2 . 1  32 bit system calls   the system call you must place the system call number  to effect the call: int   Each system call is defined in· " usr I include   execute  eax and use the software  interrupt  Ox80. System calls have parameters  ecx,  edx,   instruction  which are placed in registers   esi, edi, and ebp. Return values are placed   asm unistd_32. h". To   in eax.   ebx,   in register   Here is a system call to write to stdout:   hello: db  "Hello world! " ,OxOa   segment . data   segment . text   mov  eax , 4  mov  ebx, 1  lea ecx, [hello]  mov rdx, 13  int Ox80   syscall  4 is write  f ile descriptor  array to write  write 13 bytes   1 2 . 2  64 bit system calls   The system calls for 64 bit Linux are different  " usr include asm u Linux and are defined in  system calls use registers  for parameters, though the registers are  ent.  The system  call  are  placed in rdi, rsi ,  rdx, r10, r8 and r9. Return values are placed in  rax. The registers  calls except that r10  has replaced   than for 32 bit  integers  nistd_64. h". Again the   are the same as in C function   rax and the parameters   number is placed  in   rex for parameter   differ­  4.   Instead  the syscall  version   of "Hello   world"   :   of using the software interrupt   instruction  to  execute   instruction,   Linux uses  a system call. Here is the 64 bit   x86-64   segment . data   hello: db  "Hello world! ", OxOa   segment. . text  global _start  start: mov  eax, 1  mov  edi, 1   1 is write  syscall  f ile descriptor    12.3. C WRAPPER FUNCTIONS   131   lea rsi ,  [hello]  array to write  mov  edx, 13  write 13 bytes  syscall  mov  eax, 60  xor edi, edi  exit O   syscall   syscall 60 is exit   function. For example   1 2 . 3  C wrapper functions  The lingua franca of UNIX is C, so every system call is usable  wrapper  which does very little  the write request.  instruction  to worry about finding the numbers  slightly   use the syscall instruction  to perform  than the explicit   You won't have  and you won't have to cope with the   way to use the system calls.   Using these functions   there is a write function   is the preferred   other than   register   different   usage.   rather   via a  C   syscall   in the C library   The Linux  system   calls are  documented   in section   2 of the on-line   to learn how to use the write system call.  "Hello  world"  program   The previous   can be rewritten   using write   msg:  db  "Hello World !" ,OxOa String to print  len:  equ  $-msg   Length of the string   manual,   so you can   do   man 2  write   and exit as   segment . data   main:   segment . text  global main  extern write ,  exit   mov  edx, len  mov  rsi ,  msg  mov  edi, 1  call write  xor edi, edi  call exit   Arg 3 is the length  Arg 2 is the array  Arg 1 i s  the fd   0 return   =  success    132   CHAPTER 12. SYSTEM CALLS   Here you will notice   assembly   that I have used a yasm equate to define len to  point, $, minus the address   of msg. equ is a   which defines a symbolic  of counting   characters   and insulates the program   name for an expression.   This saves  from slight   be the current  pseudo-op  the trouble  changes.   You might also have noticed the   use of extern to tell the linker   that   write and exit are to be defined in some other place,  the C library.   in this case from   1 2 . 3 . 1  open system call   In order  to read  this is done using the open system call:   and  write   a file, it must be opened.   For ordinary  files   int open  char  *pathna  me, int flags [ ,  int mode]   ;    The pathname is a C string   array terminated with   The flags are a set of bit patterns  read-only  the file is to be opened:  and  other  characteristics  like whether  the mode parameter  is to be created  the new file.    character   which are or'ed together  mode, write mode or read-write   a 0 byte .  to define how  mode   the file   is to be created.  defines the permissions  to   to assign   If the  file   The flags are defined in the table below:   bits meanmg   0  read-only  1  write-only  2  read and write   if needed   Ox40 create  Ox200 truncate  the file  Ox400 append   The basic  permissions  are  read,   have read permission  execute  that the file  either  permission   to read an object, write permission  permission   A process  must  to write it, and  it. Execute  for  a file means  or a script  can  be executed.  traversal   to  execute  a program  allows   write and execute.   for a directory   permission   of the directo ry.   Execute   These three   permissions   are granted   or denied   for 3 categories   of ac­  counts:  user,   group and other.   When a user  logs   in to a Linux system the    12.3.  C WRAPPER FUNCTIONS   133   user-id   the user's   the user has a group-id   shell is assigned   user's  the user. In addition  tifies the user as being in a particular  to multiple  "id" command in the shell to print  groups you belong to.   groups though only one   group of users.   A user can belong   is the active  your user-id, group-id   group. You can use the  and the  list of   which is an integer   also an integer    identifying  which iden­  The basic permissions   are 3 permissions   The permissions   for 3 groups.  This makes an ideal situation  represents   3 bits. Using 9 bits  for user, group and others. Using   are 1 bit each for read, write and execute.  for using octal numbers.  One octal "digit"  you can specify the basic permissions  yasm an octal number can  in either  write for the user  as  others   as 0. Putting all these together   "o" or "q". Thus you  could   we get 640o.   be represented by   a sequence   of digits  specify permissions   ending   for  read  and  for   6, read for the group as 4 and no permissions   The return   value from open is a file descriptor if  by a  negative   equal to 0. An error is indicated   the value is greater   is an  integer  start at   identifying the connection  for each opened   0 and increase   file. Here is some code   return.   A  file  made by open. File   than  or  descriptor  descriptors  to open a file:   segment . data   fd:  dd  0  name: db  "sample" , 0    segment . text  extern open  lea rdi, [name] pathname  mov  esi, Ox42 '  read-write create  mov rdx, 600o read-write for me  call open  cmp  eax, 0  j l   error  failed to open  mov  [fd]' eax       12.3.2 read and write system calls   The system calls to read  and  Their prototypes   are quite similar:   write data to files are   read and write.    134   CHAPTER 12. SYSTEM CALLS   int read   int f d ,  void *data, long count  ;   int write   int fd, void *data, long count  ;    The data array can be any type of data. Whatever  is the number of bytes to read or  of bytes read or written.  the extern variable errno to an integer  can use the perror function   An error is indicated by  indicating  call to print  a text version   Both functions   write.   the type of error.  You  of the error.   the type is, the count   return   the number   returning   -1 and setting   1 2 .3.3 lseek system call   or writing   When reading  a specific  be writing  bytes each. Assuming  1000 would start at  byte  quick to position  reading   and writing   the whole file.   spot in the file before   reading   or writing.   files, it is sometimes   necessary   to position   to  An example   would   record number 1000 from a file  with  records  which  are   512   that record numbers   begin with 0, then record   position   1000 * 512 = 512000.  It  This is  also   can be very  easier  than   to 5 12000 and write 512 bytes.   The lseek system call allows you   position   for read­  to set the current  is   ing or writing   in a file. Its prototype   long lseek   int f d ,  long offset, int whence  ;    is frequently   The offset parameter  of offset depends on  but the meaning  is 0, then offset is the byte position.  relative  to the current  the end of file.  the file.  read or   position.   write for   The return   simply the byte position   in the file,   the value of whence. If whence  If whence is 1 ,  then offset is  to   If whence is 2, then offset is relative   value from l seek is the position   of the next   Using lseek with offset 0 and whence equal to 2 ,  lseek will return   1 greater   a byte position  way to  determine  array and read the  entire   than the last byte of the file. This is an easy  file  as long as you have enough RAM .   the file size. Knowing the size, you  could  allocate  an   mov  edi, [fd]  xor esi, esi  set offset to 0  mov  edx, 2  set whence to 2  determine  call lseek  mov  [size] , rax   f ile size    12.3.  C WRAPPER FUNCTIONS   135   allocate an array for the f i le   mov  edi, rax  cal l  malloc  mov  [data], rax  mov  edi, [fd]  xor esi, esi  xor edx, edx  call lseek  mov  edi, [fd]  mov  esi, [data]  mov  edx, [size]  call read   set offset to 0  set whence to 0  seek  to start of f ile   read the entire f ile   1 2.3.4 close system call   or writing   a file you should   close it. The only   for the close system call is the  file   descriptor   Data read or written   without   closing   a file, it will be closed  is not  using file descriptors  so there will not by  any unwritten  data   for the file to  by   system.   If you exit a program   When you are done reading  parameter  close.  the operating  buffered  which might  result  files are that it reduces  the  per-process   in the user program,   be lost. This is not true for using FILE pointers   which can   in lost data if there is no close.   The biggest   advantages to closing   overhead in the  kernel and   avoids running   into   limit on the number of open files.   mov  edi , [f d]  call close    136   CHAPTER 12. SYSTEM  CALLS   Exercises   1 .  Write a copy program   using syscall and a second copy program   Your copy program   accept   functions.   the command line is   2 file names and an integer   using the equivalent library wrapper  should  on the command line. The  first name is the name of the input file and the second is the name  of the output file. The number on  of bytes to allocate for an array for  size a multiple  improvement. You might experime more rapidly  both input and output files will fit in buffer cache and there will  will  be no actual  the writing  in time between  be delayed. Can you measure the difference  the  syscall   of 4096  bytes  will   the number  Making the   The  challenge   to read the file and   disk I 0 required   and the library   input and output.   for your tests.   version?   version   make a very  slight  performance  nt to discover which  size works  many files,   is that  for    It is fairly simple  in yasm. A struct  different types.   to use structs  is a compound   object  Let's consider the  C struct   which can have data items of  Customer:   compatible  with   C by defining   a struct   Chapter 1 3    Structs   struct Customer   {   int id;  char name[64];  char address[64];  int balance ;    } ;   We could access  we know the offsets   the customer  for each item of the struct.   data using assembly code assuming  that   mov rdi, 136  call malloc  mov  [c] , rax  mov  [rax] , dword 7  lea rdi, [rax+4]  lea rsi ,  [name]  call strcpy  mov  rax, [c]  lea rdi, [rax+68]  lea rsi ,  [address]  call strcpy   137   size of a Customer   save the address  set the id  name f ield  name to copy to struct   address f ield  address to  copy    138   CHAPTER 13. STRUCTS   mov  mov  mov   rax, [c]  edx, [balance]  [rax+132] , edx   1 3 . 1    Symbolic names for offsets   effective but using specific   code modification and   Well that was certainly  within a struct  is not  really  ideal.  Any  require  errors  It is better  keyword  between   for starting  "struc"   to have yasm assist   is "struc". Struct   a struct   numbers   for offsets  will  might be made adding up the offsets.   to the structure   changes   and "ends true". Here is the definition   of Customer:   you with structure   definition.   The yasm  are defined   components   struc Customer   id  resd 1  name  resb 64  address resb 64  balance   resd 1  endstruc   struc Customer   . id  resd 1  . name resb 64  . address resb 64  . balance resd 1   ends true   gives us the same effect as using equ to set symbolic   Using this definition  names for the offsets. These names are globally  not be permitted  structs.  each of these names with a period like   to have id in multiple  this:   available,  Instead   so you would  you can prefix   Now we must use "Customer  . id" to refer to the offset of the id field.   is to prefix the field names with a short abbreviation   name. In addition   A good compromise  of the  struct  yasm will also define Customer  struct.  program   to initialize  a struct   This makes it easy to allocate   symbolic   to giving  _size to be the number of bytes in the  memory for the struct.   names to the offsets,   Below is a   from separate   variables.    13.1 .  SYMBOLIC NAMES FOR OFFSETS   139   segment . data   name db  " Calvin", 0  address db  " 12 Mockingbird Lane11, 0  balance   dd  12500  struc Customer   c_id resd 1  c_name resb  64  c_address resb  64  c_balance resd 1   c   main:   endstruc  0  dq  . text  segment  main  global  extern  malloc, strcpy  push  rbp  mov  rbp , rsp  rsp,  32  sub  mov  rdi, Customer  size  malloc  call  mov  [c] , rax ; save the pointer  mov  [rax+c_id] , dword 7  lea  rdi, [rax+c_name]  lea  rsi ,  [name]  call  strcpy  mov  rax, [c] ; restore the pointer  rdi, [rax+c_address]  lea  lea  rsi ,  [address]  call  strcpy  mov  rax, [c] ; restore the pointer  edx, [balance]  mov  mov  [rax+c_balance]  , edx  eax, eax  xor  leave  ret   Now this is all great but there is a possible   alignment   problem   versus   C if we make the address  balance   field 1 byte larger.  In C  from 132 to 136. In yasm it increases   increase   from 132 to 133.   this makes the offset of    140   CHAPTER13. STRUCTS   works but the struct  definition   It still  C. To do so we must place align  4 before the definition   does not match the alignment   Another   possibility   is to have a static   variable   of type Customer.   of  of c_balance.  To   do this   with default data, simply use this   c   istruc Customer  iend   If you wish to define the fields,  the data for the strings:   define them all in order.   You can shorten   c   istruc Customer  at c_id,  dd  7  at c_name , db " Calvin",  0  at c_address, db " 12 Mockingbird  at c_balance ,  dd 12500  iend   Lane" ,  0   13.2 Allocating and   using an array of structs   then you need to multiply   _size might not  match   of an array   times  the   to allocate   and will report   boundaries   number of elements   an array of structs,   the size given by Customer   enough  the value   in C. C will align each data item on   If you wish to allocate  the size of the struct  space.  But  from sizeof  struct Customer   appropriate  element  a terminal  in the struct.  8 to force the _size value to be a  multiple  quad word byte fields  4. Similarly you might need align  2 if there are any word fields.  code to declare  a  look like this   has any quad word fields then you need align  of 8. If the struct  but has some double word fields you need align   slightly   a size which will result  You can assist   changed  and allocate   align  X where X represents   having aligned   If the struct   yasm by adding   the size of the largest  data   in  each   has  no   fields.   struct   So our   item   an  array would   segment . data  struc Customer   c id  resd 1  c_name resb 65  '  69 bytes   4 bytes    13.2. ALLOCATING AND USING AN ARRAY OF STRUCTS 141   c_address resb  65  134 bytes   aligns to 136  140 bytes  141 bytes  aligns to 144   align 4  resd 1  c_balance  c_rank resb  1  align 4  endstruc  dq  0  segment . text  mov edi, 100 '  for 100 structs  mul edi, Customer_size  call malloc  mov [customers]   customers   , rax   Now to work  with   each array element  we  can   holding the  after we process   value of customers  each customer.   and add Customer   start with a register  _size to the register   segment . data   format db  "%s %s %d", Ox0a , O    segment . text  push r15  push r14  saved through calls  mov r15, 100  mov r14, [customers]; pointer saved through calls   counter   more  lea edi, [format]   lea esi, [r14+c_name]  lea rdx, [r14+c_address]  mov rex. [r14+c_balance]  call print£  add r14, Customer_size  sub r15, 1  j nz more  pop r14  pop r15  ret    142   CHAPTER13. STRUCTS   Exercises   1 .  Design a struct   to represent  a   set. The struct   will hold the maxi­  to  an array holding   size and a pointer  1 bit  per  from 0 to  of the set. Members of the set will be integers  to read commands   mum  set  element  the set size minus 1 .  Write a test  operate  "test". Each command will have an integer  with it. Your program will  remove elements   then be able to add elements   on the set. The commands   will be "add", ''remov  for membership.   test numbers   set  and   program   to the   e", and  parameter  entered   to the set,   which   possible   2.  Using the   for sets fr  om exercise   1 ,  write a program   to manip­  design  ulate multiple  and "interse k" will  add  "intersect  the elements   "add", "union", "print   commands  sets. Implement  ct". Create 10 sets with   k to set s. "union s t" will replace  s t" will replace sets with s nt. "print s" will print  of s.   size equal to 10000. "add s  set s with s U t.   3. Design a struCt   to represent large  as the data for the large integers  integers. For simplicity  use quad   18 digits   of the number.   . Each quad word  will   So 1 quad word can  .  2 quad words can   word arrays  represent  ber up to 999,999,999,999,999,999 ber up to 999,999,999,999,999,999,999,999,999,999,999,999.  ment only positive   based on addition main routine in C or  rithm using assembly   numbers.   . Compute 50!. You are permitted  C++ which will implement  code to represent   and multiplication   all long arithmetic.   store a num­ store a num­  Implement addition   the factorial  algo­  to write  a   Imple­   Chapter 14   Using the C stream 1 0  functions   from C includes   variety of functions  in many   string   callable  process   The functions  areas including  tions,  these capabilities  language.  a higher level   processing   management and graphics   handling,   network  programming.   communica­ Studying much  of  from the study of assembly   would lead us too far afield   The  stream  input   library which   and output facilities  is also quite useful   provide   an example   of   in many programs.   a wide  ,  file   In the chapter   on system calls we focused on open, read, v.rri te and  In this chap­  for system calls.   functions   close which are merely  ter we will focus  on  a  I 0. Buffered I 0 means that the application  an open   wrapper  similar   collection   of functions   file.   maintains   a data buffer for   which do buffered   Reading   using a buffered  you ask the buffered   I 0  system  I 0 system to read 1 byte. It will attempt   can be more efficient .  Let's   suppose  to read 1 byte from the buffer of already  then it reads enough bytes to fill its buffer -typically  means that 8192 reads of 1 byte can be satisfied  Reading  over 20 times as fast reading  function compared   a byte from the buffer is very fast. In fact reading   one byte at  a time using read.   to reading   1 byte at   a large file is  a time using the C stream get char   read data. If it must read,   8192 bytes. This   You should be aware that the operating   open files. When you call read to read 1 byte, the  operating  forced by the disk drive to read complete  so it must read at least   sectors,   system also uses buffers for  system is   143   by 1 actual system call.    144 CHAPTER 14. USING THE C STREAM I 0 FUNCTIONS    probably 512 bytes . Most likely   1 sector  4096 bytes and saves the data which has been read in order to make use  of the data. If the operating  a time would require  be perhaps   system did not use buffers, reading  with the disk for each  byte  than using the buffer.   10 to 20 times slower   interacting   the operating   1 byte at   which would   system reads   The net result   from this discussion   is that if your program   needs to   rather   than using the system calls.   of data, it will be faster to use the stream   read or write small quantities  I 0 facilities  to use the system calls and  your needs thereby  efficiency  by working  performance   harder.  increased   do your own buffering   It is generally  which  is tailored  for  pay for this improved  You must weigh the importance of improved  labor.   time. You will of course   possible   versus   saving   14.1 Opening   a file   The function  like the other stream I 0 functions,  the name distinct  prototype   to open a file using the stream I 0 functions  the letter  function  it   the system call wrapper   begins  with   is fopen. It,  "f" to make  The   for f open is   resembles.   FILE *fopen  char *pathname, char *mode  ;    The file to be opened is named in the first   parameter   named in the second parameter. The mode can be any of  the table below   and the mode is  the values  from   r  read only mode  r+ read and write  w  write only, truncates  w+ read and  a  write only, appends  a+ read and write,   appends   write,   or creates   truncates or  creates   or creates   or creates   The return   value is a pointer  to   a FILE object.  in the sense than you never  need  to  is a struct  "house-k  pointer  the FILE object. Most likely  pointer  to  about the file. This pointer   the buffer for the file and various   a FILE object   This is an opaque   know the components  which contains   of  a   is used in the other stream I 0 functions.   In   eeping"   data  items    14.2. FSCANF AND FPRINTF   145   language   assembly  word and use  that  quad-word  code to open a file:   sufficient   it is   as needed for function   to simply store  the   pointer  calls.   in a quad­ Here is some   segment . data   name db  11customers mode db  11w+II, O   fp  dq  0   . dat11, 0    segment . text  global fopen  lea rdi, [name]  lea rsi ,  [mode]  call fopen  mov  [fp], rax   14.2 fscanf and fprintf   scanf and printf in previous   code. scanf is a   You have encountered  function  parameter,  pointer  pairs of functions  pointer. Their prototypes   are   which calls fscanf with  a   FILE pointer   named stdin as its first   stdout as first parameter. The only difference   while printf is a function which calls fprintf with FILE  between  can work with any FILE   is that fscanf and fprintf   these   int fscanf   FILE *fp, char *format, . . .    ;   int fprintf     FILE *fp, char *format, . . .     ;    For simple   use consult   Appendix   B which discusses   scanf and printf.   use "man fscanf" or "man fprintf" or consult   a   For more information  C book.   14.3 fgetc and fputc   If you need to process  data  to use fgetc to  read  prototypes   characters   are   character   by character, it  can   and fputc to write characte  be convenient  rs. Their   int fgetc   FILE *fp   ;   int fputc    int c ,  FILE *fp   ;     146 CHAPTER 14. USING THE C STREAM I 0 FUNCTIONS   The return   value of fgetc is the character   which has been read, except   for end of file or errors  -1. The function  fputc writes  returns  the same character  EOF.  returns   when it returns   the symbolic  provided   value EOF which is  in c to the file. It   the character  unless   it has written   there is an error when it   to get a character   and do something  which   Fairly often it is   convenient  on the  character   read. For some characters   depends  give control  the character  only 1 pushed back character, but having 1 character  be  quite   over to another  back to the file stream using   useful. The  prototype for   function.   ungetc is   ungetc .  You are guaranteed   of look-ahead   can   you  may need to   This can be simplified  by giving   int ungetc   int c ,  FILE *fp   ;    Below is a loop   copying   a file from one stream to another   using fgetc   and fputc.   more rnov  rdi, [ifp]  input f ile pointer   call fgetc  crnp  eax, - 1   j e   done  rnov  rdi, rax  rnov  rsi ,  [ofp] output f ile pointer  call fputc  j rnp  more   done:   14.4 fgets and fputs   Another  line. The function  small  and fputs writes 1 line of   common need is to read lines of input and process   fgets reads 1 line of text  or less if  the  array   them line by  is too   text. Their prototypes   are   char *fgets  char *S, int size, FILE *fp   ;   int fputs  char *s, FILE *fp   ;    The first parameter   to f gets is an array of characters   line of data and the second parameter  is passed into the function   to prevent   to receive  is the size of the array. The size  buffer overflow. fgets will read   the    14.5. FREAD AND FWRITE   147   into the array. It stops reading  or end of file. If it reads a new-line   character   up to size - 1 characters  a new-line  new-line  always places  success   and a NULL pointer   in the buffer. Whether it reads  a   complete   a 0 byte at the end of the data it has   when it hits  it stores  the  not, fgets  s on  read. It returns   line or   of error or end of file.   fputs writes   the string   in s without   the 0 byte at the end of   the string.   It is your responsibility  add the 0 byte at the  end.  or EOF on error.   It returns   to place any required   new-lines  a non-negative   in the array and   number on success   following   It can be quite useful   f gets to use sscanf to read data  from the array. sscanf is like scanf except that the first parameter  fashion  array of characters which  as scanf . Using this pattern  the data  with sscanf , determine  that the data was not what you expected  read it again with sscanf with a different   it will attempt   and   is an   format string.  text from one stream to   an­  Here is some code which copies lines of   other,   skipping   lines which start with a " ;  " .    to  convert  in  the  same   gives you an opportunity to read   more lea rdi, [s]  mov esi ,  200  mov  rdx, [ ifp]  call fgets  cmp  rax,  0  j e   done  mov  al, [s]  '  .  '  '  cmp  al,  j e   more  lea rdi, [s]  mov  rsi, [ofp]  call fputs  j mp  more   done:   14.5 fread and fwrite   The fread and fwri te functions  of data. Their prototypes   are   are designed   to read and write arrays    1 48  CHAPTER 14. USING THE C STREAM I 0 FUNCTIONS   int fread  void *p, int size, int nelts, FILE *fp   ;   int fwrite  void *p, int size, int nelts, FILE *fp   ;    The first parameter   to these functions  is   an array of any type. The   is the size of   next parameter  the number  of array  elements  of array elements read  the return  value might be less than   or written.   They return   the number  In the event of an error or end of file,  nel ts or 0.   to read or write.   while the third is   each element   of the array,   Here is some code to write all 1 00 elements   of the customers   array   to a disk file   allocated array   mov  rdi, [customers]  mov  esi, Customer_size  mov  edx, 100  mov  rex, [fp]  call  fwrite   14.6 fseek and ftell   Positioning  to determine   a stream   is done using the fseek function,   the current   position.   The prototype   while ftell is used  for these functions  are   int fseek  FILE *fp, long offset, int whence  ;   long ftell  FILE *fp   ;    on the third  parameter   offset of fseek is a byte position   value which  whence to define its meaning.   The   of whence is exactly like   in lseek. If whence is 0, then offset   The second parameter  is dependent  meaning  is the byte position.  position.  The return   If whence is 1, then offset is relative  to the end of   If whence is 2, then offset is relative   file.  value of fseek is 0 for success and -1  for errors.  If there  value of  The return  there is an error.  On   is an error the variable errno is set appropriately.  ftell is the current  error it returns  - 1 .    byte position   in the file unless   to the current   Here is a function   to write a Customer   record   to a file.   void write customer     FILE *fp, struct Customer   *C,   int record_number   ;    segment . text    14.7. FCLOSE   149   global   write_customer   write_customer:  . fp  equ  0  . c   equ  8  . re c  equ  1 6   rbp  rbp, rsp  rsp, 32  [rsp+. fp], rdi  [rsp+. c] ,  rsi  [rsp+. rec], rdx  rdx, Customer_s ize  rsi ,  rdx  rdx,  0  ftell  rdi , [rsp+. c]  rsi ,  Customer_ size  rdx,  1  rex, [rsp+. fp]  fwrite   push  mov  sub  mov  mov  mov  mul  mov  mov  call  mov  mov  mov  mov  call  l eave  ret   14.7 fclose   save parameters   2nd parameter to ftell   ; whence   f close is used to close a stream.  have  data  written   in its buffer which  needs   when you call £ close and will be forgotten   This is important  to  be written.   since a stream may  This data will be   if you fail to call it.    150 CHAPTER 14. USING THE C STREAM I 0 FUNCTIONS   Exercises   1 .  Write an assembly   a new Customer   program  definition   which will create  from this chapter.   us­ Your program   and rank fields.  looking   ing the struct  prompt for and read the file name, the customer  balance  the file  with 0 in the id field. In general  the record number  for  a record.  add  a new record   the id value will be 1 greater  than  If there is no empty record,  then  's id.   the data in  Then your code should  scan  is a record   the file. Report the customer  for an empty position.   An empty position   at the end of   should   name, address,   2. Write an assembly   program   to update the balance   for a customer.   should accept from the command line the name of   The  program  a data file,  for that  customer.  The  number. Report an error   id and an amount to add to the balance  customer if the customer   's id is 1 greater   a customer   record   than  the  record   is unused  id = 0 .  data in a file,   sort  You   3. Write an assembly   program   to read the   customer   and print the data in increasing   balance order.   open the file and use   it by balance  should  to determine  array large enough to hold the entire  a time, skipping  past the unused records  sort using qsort. You can call qsort using   the number of records   in the file. It should   an  file, read the records  one at   allocate   id = 0 . Then it should   fseek to seek to the end and use ftell   qsort  struct  Customer   * C, int count, int size, compare  ;    in bytes.  The   is the number of structs   to sort and size is  The count parameter  compare parameter  is  the size of each  of a function which will accept 2 parameters, each a pointer  struct Customer.  of the 2 structs  and return  the order of the 2 balances.   to a  the balance  fields  on   will  compare   a negative,   This function   0, or positive value based   the address    Chapter 1 5    D ata structures   are widely used in application   programming.  They are   queues and heaps.   used for algorithmic   Data structures  frequently  stacks,  based on a key, referred to as a "dictiona implementing  linked  in assembly.   purposes   lists,   They are also used to implement  ry" . In this chapter   data storage   we discuss   hash tables,   doubly-linked   and binary   lists   trees   to implement structures   like   One common feature of all these data structures   is the use of structure   a "node"  which   called  nodes. The memory   contains   for these nodes will be allocated   using malloc.   data and one or more pointers   to other   1 5 . 1  Linked lists   A linked  illustra  tion of a linked   list:   list is a structure   composed   of a chain of nodes. Below is an   I  ·I 4 1   I �1191 +   You can see that the  list   has 4 nodes. Each node has a  data value   to another   node. The  last  node  of    value 0 , which is illustrated   and a  pointer  pointer  represented  placing the   as a pointer.  list's first pointer   as a filled circle.   the list has  a NULL  is  The list  by   itself   We can illustrate   the list more completely   in  a box and giving  order to the data values in  the  nodes.   it a name:   It is   This list has no obvious   151    152   CHAPTER 1 5. DATA STRUCTURES   list  D -1121 I -1 4  I ·l 16l   L--. ----'L--.  --'   unordered   either  to insert  time of insertion   order.   or possibly   ordered   by time of insertiOJ1  . It is very easy   a new node at the start of a list,   so the list could be in decreasing   The list is referenced   using the pointer   stored   at the memory location   l ist. The nodes on the list are not   labeled  in the code which maintains  these nodes  is   by using the pointers   in  the   list.   and uses the list. The  only   identified   with specific   labels  way to access   15.1 . 1  List node structure   Our list node will have 2 fields:  a data value and a  pointer  node. The yasm structure   definition   to the next   is   struc node   n_value resq 1  n_next resq 1   align  8  ends true   The alignment   instruction   is not needed with 2 quad-words  in the   structure,   but it may protect   us from confusion later.   1 5 . 1 . 2  Creating an empty list   The first decision  in designing  an empty  container.  choice  of using a NULL pointer  it may be advantageous   In this  linked  list   a container  design   is how to represent  the simplest   we  will  take   structure   as an empty list. Despite   this simplicity   to have a function   to create   an empty list.   newlist :   xor eax, eax  ret    15. 1 .  LINKED LISTS   153   1 5 . 1 .3  Inserting   a number into  a   list   will be at  the   as a NULL pointer   leaves   a small  start of the list which  in the list start pointer   stored   for   to implement   an empty list  The decision  issue for insertion.  Each  insertion  be a new pointer  means that there will  each insertion.  pass the address  is to have the insertion  insertion  to dodge the  address   of the pointer  pointer  code to assign the   There are 2 possible   of a pointer   new pointer   into the insertion  return   ways to cope with this. One way is to  function. A second way  and leave it to the  It is less confusing   the new pointer  upon return.   problem.   Here is the insertion  code:   insert:  . list  . k    l ist= insert  l ist,  k   ;    0  8  rbp  rbp , rsp  rsp, 16  [rsp+ .l ist], rdi  [rsp+. k] , rsi  edi, node_size  malloc  r8, [rsp+ . list]  [rax+n_ne r9 , [rsp+. k]  [rax+n_value]  xt], r8   , r9   equ  equ  push  mov  sub  mov  mov  mov  call  mov  mov  mov  mov  leave  ret   save l ist pointer  and k  on st ack   rax will be node pointer  get list pointer  save pointer in node  get k  save  k  in  node   1 5 . 1 .4  Traversing   the list   Traversing the list requires   using an instruction   like   mov  rbx, [rbx+n_next]   from a pointer   to advance  start by inspecting  enter the loop.  the loop if the pointer   the pointer   After processing   to see if it  is  a node we advance   to one node to a pointer   is not NULL. The print function   to the next node.   We  NULL. If it is not then we   the pointer   and repeat  below traverses    154   CHAPTER 15. DATA STRUCTURES   the list and prints  is nice to have a few registers  preserved   by print f .    each data item. The code shows a good reason why it   protected   in calls.   We depend on rbx being   subtract  save old value o f  rbx   multiples of 1 6    print:   segment . data   . print_fmt:   db  11%ld   11, 0    . newline   db  OxOa, O   segment . t ext   . rbx equ  0   rbp, rsp  rsp, 16  [rsp+.rbx], rbx  rdi,  0  . done  rbx, rdi  rdi, [ .print_fmt]  rsi, [rbx+n_value]   push rbp  mov  sub  mov  cmp  j e   mov  lea  mov  xor  eax , eax  call printf  mov  rbx, [rbx+n_next]  cmp  rbx,  0  j ne  lea  xor  call  mov  leave  ret   . more  rdi, [ .newline]  eax, eax  printf  rbx, [rsp+ . rbx]   restore rbx   . more   . done   Last  we have a main function which  creates   a list,   reads values  us­  the values into the list and prints   the list  after  each   ing scanf, inserts  insertion.   main:    1 5. 1 .  LINKED LISTS   155   . more lea rdi, [ .  scanf _fmt]   . list equ  0  . k   equ  8   segment . data   . scanf fmt:   db  " %ld" , 0   segment . text  push rbp  mov  rbp, rsp  sub  rsp, 16  call new l ist  mov  [rsp+. list], rax   lea rsi ,  [rsp+. k]  xor  eax, eax  call scanf  cmp  rax, 1  j ne  . done  mov  rdi, [rsp+ .list]  mov  rsi ,  [rsp+ . k]  call insert  mov  [rsp+ . list] , rax  mov  rdi, rax  call print  j mp  . more   . done leave   ret   through   5:   1  1  2  2  1  3  3  2  1  4  4  3  2  1   Here is a sample session   using the program,   entering   the numbers   1    156   CHAPTER 15. DATA STRUCTURES   5  5  4  3  2  1   You can see the the most recently   printed   number is at the first of the   list. By adding a function  the list,  this chapter.   we could turn this   to get and remove  pop  the first  into a stack.   This is  one   of the exercises   of  for   element   1 5 . 2  Doubly-linked   lists   list has 2 pointers   A doubly-linked  node and one points  to  manage a doubly-linked  an unused cell at the start of the list.  nodes:   the previous  list if you make the list circula  node. It becomes   r and if you retain   quite simple  to   Here is an example   4 data  list  with   for each node: one points   to the   next   list   c   -  X  4   12  16  19   �   We see that the variable list points   node of the list,   called   to the first  value,   but we never use the value.   in each node points to the next node in the list and   points   to  the   the "head node".  The head node has a  The top pointer  previous  the bottom pointer  of the head node is the last node  pointer  a stack  last-in  capable  of implementing  out  or a double-ended  queue  deque . The primary  design  the head node remains.  to the head node never changes.   is that the list is never really   Furthermore,   empty-it can be logically   once a list is created,   of this   advantage  empty but  the  pointer   node in the list.  in the list.  first-out ,  a queue  first-in first­  The previous   This makes this  list    15.2. DOUBLY-LINKED LISTS   157   15.2.1 Doubly-linked   list node structure   Our list  node  and a pointer   will have 3 fields:  to the previous   a data value, a pointer  node. The yasm structure   to the next node  definition   is   struc node   n_value resq 1  n_next resq 1  n_prev resq 1  align 8  ends true   15.2.2 Creating   a new list   The code for creating  sets its next and previous  a pointer  Here is the creation   code:   a new doubly-link  ed list allocates   pointers   to itself. The  calling   a new node and  function  receives  of the program.   which does not change during the execution   list =  newlist   ;   newl i st :   push rbp  mov  rbp, rsp  mov  edi, node size  call malloc  mov  [rax+n_n mov  [rax+n_pre leave  ret   ext] , rax  v], rax   When it returns   the empty list looks like the diagram   below:   list    158   CHAPTER 15. DATA STRUCTURES   15.2.3 Inserting   at the front of the list   you need to place the head   in the new node's   front of the list   a new node at the   next pointer  from head's next into the new node's   To insert  node's  pointer  that you can make the head node point forward to the new node and  make  the  are  illustrated  and the new   head's former next point backwards   links are numbered,   with bold lines.   in the diagram   below. The old links are in dashed lines   next slot and  place  the   slot. After doing   to the  new   previous   node. There   previous   list   4   One of the  elegant   features of the doubly-link  ed circula the first node   r list is the  is done with   exactly   of special   elimination  the same code as inserting  for insertion   Inserting  any other node.  is   The code   cases.   insert   list, k   ;   insert:  . list equ  0  . k   equ  8   push rbp  mov  rbp, rsp  sub  rsp, 16  mov  [rsp+ . list] , rdi save list pointer  mov  [rsp+. k], rsi  and k  on stack  mov  edi, node_size  call malloc  mov  r8, [rsp+ .l ist] get list pointer  get head ' s  next  mov  r9, [r8+n_next]  mov  [rax+n_next]  mov  [rax+n_prev]  mov  [r8+n_nex mov  [r9+n_prev], rax set new node' s  next' s  prev   , r9 set new node' s  next  , r8  set new node' s  prev   t], rax set head ' s  next   rax will be node pointer    15.2. DOUBLY-LINKED LISTS   159   r9 , [rsp+. k]  [rax+n_value]  get k  save  k  in  node   , r9   mov  mov  l eave  ret   15.2.4 List  tra  versal   of a doubly-linked  List traversal  a singly-linked  list.  to test the current  the end of the list.   to traversal  We do need to skip past the head node and we need  pointer  Here is the code for printing   list is somewhat   to the head node to detect   the pointer   similar   against   the list:   of   print :   print   l ist  ;    segment . data   . print_fmt:   . newline:   db  "%ld " ,0   db  OxOa, O   segment . text   . list equ  0  . rbx  equ  8   push rbp  mov rbp , rsp  sub  rsp, 1 6   mov  [rsp+. rbx] , rbx  mov  [rsp+ . list] , rdi  mov rbx, [rdi +n_next]  cmp  rbx, [rsp+ .l ist]  j e   . done   . more lea rdi, [ .  print_fmt]   value]   mov rsi ,  [rbx+n_  call printf  mov  rbx, [rbx+n_next]  cmp  rbx, [rsp+ .list]  j ne  . more   . done lea rdi, [ .newline]   call printf    160   CHAPTER 1 5. DATA STRUCTURES   rbx, [rsp+. rbx]   mov  leave  ret   1 5 . 3  Hash tables   way to implement   a dictiona  ry. The basic   you compute  ry. The purpose   A hash table is an efficient  idea is  that  dictiona an array. A perfect hash  in the array used for hashing,  must cope with keys which "collid  e".   a hash value for the  key  of the hash value is to spread  function   would map each key to a unique  we   but this is difficult   to achieve. Instead   location   for each item in the  the keys throughout   The simplest  location  in   way to cope with collisions  the illustra  the hash array.   Consider   tion below:   is to use a linked   list for each   0  1  2  3  4  5  6  7  8   In this hash table,   keys 12, 4, 16 and 9 all have hash values of 1  and   are placed  have hash values  The remaining   on the list in location  1   of the hash array. Keys 13 and 8 both   3 and are   placed  on   the list in location   3 of the array.   keys are mapped to 5 and 7.   One of the critical issues   with hashing   is to  develop   a good hashing   A hashing   same value for  hash values  aren't   function should appear almost random. It must  the  of   function.  compute  the  key, but the  keys onto lists  that the array size should be at  least  expected. Then, with a good hash function, the chains  will  be   really  We want a lot of short lists.   This means  as large as the number of keys   which matters.   a particular   key each time it is called for   important -it's the distribution   generally    15.3. HASH TABLES   161   quite  short  .   15.3.1   A good hash function for integers   this is not very important if there is no underlying  used as keys. In that case you can simply use n  mod t where  n   that a hash table size be a prime number.  to the   pattern   recommended   It is generally  However  numbers  is the key and t is the array size.  If  of the same number,   then using  Here is the hash function   a prime number fort makes sense.   there is a pattern   for the example   code:   like many multiples   hash   i  =hash    n   ;   mov  rax , rdi  and  rax, Oxff  ret   The table size is 256 in the example,   so using and gives   n  mod 256.   15.3.2   A good hash function for strings  to treat the string   for strings is   A good hash function  nomial coefficients  code below we use the  ating the polynomial  the table size  100000 in the sample code .   poly­ and evaluate p  n  for some prime number n. In the  After evalu­  prime number 191 in the evaluation.  value, you can perform a modulus   operation  using   as containing   int hash   unsigned char *S    {   unsigned  int i =  O ·  ,   l ong h = 0 ;    while    s [i]   {   h = h*191 + s [i] ;  i++;   }  return  h % 100000;   }    162   CHAPTER 1 5. DATA STRUCTURES   15.3.3 Hash table node structure   and array   the table size is 256, so we need an array  of   when the program   In the sample hash  table  256 NULL pointers  in  the  data  it is implemented  · would need a hash table creation  with O's. Below is the  for the linked   lists   declaration   starts.   Since this is  quite   small,   segment. For a more realistic   program,  we  to allocate an array   and fill it  function  of the array and the structure  definition   at each array location   .   segment . data   table times 256 dq 0   struc node   n_value resq 1  n_next resq 1  align 8  ends true   1 5 .3 .4  Function to  find  a   value in the hash table   of a hash table is to store some data associated   with   The basic purpose  a key. In the sample hash table we are simply  function below searches  found, the function  not found, it returns  a pointer   returns  0. A more realistic   to the data associated   a pointer   through   the hash table looking   for  a key. If it is  to the node with the key. If it is  would probably   program   return   storing   the key. The f ind   The f ind function   operates   the hash array for the linked  Then the function   loops through the   hash to compute   the index in  list which might hold the key being sought:  for the key.   nodes on the list looking   with the key.  by calling   p =  f ind    n   ;  p = 0 if not f ound   f ind :  . n   equ  0   push rbp  mov rbp, rsp  sub rsp, 1 6   mov  [rsp+. n] ,  rdi  call hash    15.3. HASH TABLES   163   mov  rax, [table+rax*8]  mov  rdi, [rsp+ . n]  cmp  rax, 0  j e   . done   . more cmp  rdi, [rax+n_ value]   j e   . done  mov  rax, [rax+n_next]  cmp  rax, 0  j ne  . more   . done leave   ret   15.3.5 Insertion  code   a key into the hash   to insert  the key more than once. If the key is found it skips the insertion  calls hash to  determine   The code  inserting  code. If the key is not found, the function  index for the linked  node and inserts   the  memory for a new   list to add the key to. It allocates   it at the start of the list.   table begins   by calling   f ind to avoid   insert    n   ;   insert:  . n   equ  0  . h   equ  8   push rbp  mov rbp, rsp  sub  rsp, 1 6   mov  [rsp+. n] , rdi  call f ind  cmp  rax, 0  j ne  . found  mov  rdi, [rsp+. n]  call hash  mov  [rsp+. h], rax  mov  rdi, node_size  cal l  malloc  mov  r9, [rsp+. h]  mov  r8, [ table+r9*8]    164   CHAPTER 1 5. DATA STRUCTURES   mov  mov  mov  mov   , r8   [rax+n_next]  r8, [rsp+. n]  [rax+n_valu [table+r9*8]  e], r8  , rax   . found leave  ret   15.3.6  Print ing the hash table   storage   through   the indices   from 0 through   the index number and the keys on each non-empty  r12 and r13 for safe   list.  to iterate   of a loop counter  of the hash table array and for a pointer   The print function iterates  printing  registers  the locations  nodes on each linked  which  would  require  does require  of the function  and popping   16 bytes is necessary   list.  This  saving and restoring  and popping   them for calling   these 2  registers   is more convenient   to loop through  than using registers  around each printf call.  It   functions.  the proper   Note that pushing  stack alignment  255,  It uses  through   at the  start  and end   to preserve   to preserve   pushing   the   .   You will notice   that the code switches  so that  and text segments  their point of use in the code.   printf format strings   back and forth between  placed   will be   the data  close to   i :  integer counter for table  p :  pointer for list at table[i]   print:   push rbp  mov  push  push  xor r12, r 1 2    rbp, rsp  r12  r13   . more_ table:   mov r13, [table+r12*8]  cmp r13,  0  j e   . empty  segment . data   . print 1  db  " l ist %3d: " ,0   segment . text  lea rdi, [ . print1]  mov rsi, r12  call printf    1 5.3. HASH TABLES   165   . more_list  :   segment . data   . print2 db  " %ld 11, 0    segment . text  lea rdi, [ .  print2]  mov rsi ,  [r13+n_ value]  call printf  mov r13, [r13+n_next]  cmp  r13,  0  j ne  . more_list  segment . data  . print3 db  OxOa, O   segment . text  lea rdi, [ . print3]  cal l  printf   . empty inc r12   cmp  r12, 256  j l   . more_ table  pop r13  pop  r 1 2   leave  ret   15.3.7 Testing the hash table   The main function  them  into  insertion:   for the hash   table reads  numbers   with scanf , inserts   the hash table and prints   the hash table contents   after each   main:  . k   equ  0   segment . data   . scanf_fmt:   db  11%ld", O   segment . text  push rbp  mov  rbp, rsp  sub  rsp, 16    166   CHAPTER 15. DATA STRUCTURES   . more lea rdi, [ .scan£ _fmt]   lea rsi ,  [rsp+. k]  .call  scanf  cmp  rax, 1  j ne  . done  mov  rdi, [rsp+ . k]  call insert  call print  j mp  . more   . done leave  ret   l ist 0 :  256  l ist 1 :  1025 513 257 1  l ist 2 :  258 2  l ist 3 :  3  l ist 4 :  1028 260 4  l ist 5 :  5   1 5 .4 Binary trees   Below is the printing   of the hash table contents   after inserting   1 ,  2,   3, 4, 5, 256, 257, 258,  260,   513, 1025 and 1028.   tree is a structure   A binary  root node which can have  left  in the tree can have left or right child nodes  or both .   with possibly   or right child nodes  or both . Each node   many nodes. There is a single   Generally   binary trees are built with an ordering  you  could have a   applied   to keys in   binary tree where every node  key  in the left sub-tree    keys into those less than the node's   than the node's  binary tree, often called   key  in the right sub-tre a binary search   tree, makes it possible   e . Having an   the nodes. For example  divides  and those greater  ordered  to do fast searches  nodes in increasing  Here we will present   for a key while maintaining  or decreasing   order.   the ability   to traverse   the   a binary tree   with integer   keys with the ordering   being lower keys on the left and greater  structures used  for the tree.   keys on the right.   First are the    15.4. BINARY TREES   167   15.4.1 Binary tree  node   and tree structures   The nodes in the binary  structure  definition  field as  n_value and the left and right   tree have an integer   below uses a prefix convention in naming the value   pointers   as  n_left and n_right.   value and two pointers.   The   struc node   n_value resq 1  n_left resq 1  n_right resq 1  align 8  ends true   struc tree   t_count resq 1  t_root resq 1   align  8  ends true   It would be possible   to simply use   a pointer   to the root node to rep­  the tree. However we could add features to the tree, like node   or balancing,   resent  deletion  logical  changes  the number of nodes in the tree.   to store the root in a structure  in  a tree.   We have also included   which could   change the root of the tree. It seems  us from future root  a count   insulating  in the tree structure  of   15.4.2 Creating   an empty tree   The new_ tree function allocates  the count and the root of the new tree to 0. By having the root of the tree  in a structure  tree using the pointer   the code using the binary tree   memory for a tree structure   always refers   returned   by new_tree.   and  sets   to a particular   new_ tree:   push  mov  mov  call  xor   rbp  rbp , rsp  rdi, tree s ize  malloc  edi, edi    168   CHAPTER 1 5. DATA STRUCTURES   [rax+t_root] ,  rdi  [rax+t_count], rdi   mov  mov  leave  ret   key with the key being sought. If it's   the node's  done. If the target   1 5 .4.3 Finding a key in a tree  To find a key in  a binary search tree you start with a pointer  root node and compare  a match you're  to the node's  change your pointer  than the node's  key you change  then repeat these comparisons  NULL pointer,  the  key is  a key in  a  binary  NULL if not found.   the pointer  You  with the new node. If you  ever   tree. It  returns  a  pointer   key is less than the node's   to the correct   to the node's   left child.   target   If the   key you   not in the tree. Below is the code for finding   reach a   to the   key is greater   right child.   tree  node  or   p = find   t ,  n   ;   p  =  0 i f  not f ound   f ind :   push rbp  mov  rbp, rsp  mov  rdi, [rdi +t_root]  xor eax, eax  cmp  rdi, 0  j e   . done  cmp  rsi ,  [rdi +n_ value]  j l   . goleft  j g   . goright  mov  rax, rsi  j mp  . done   mov  rdi, [rdi +n_left]  jmp  . more   . more   . goleft:   . goright:   mov  rdi, [rdi+n_right]  j mp  . more   . done leave    1 5.4. BINARY TREES   169   ret   a key into the  tree   15.4.4 Inserting  The first step in inserting  key is already  tree node is allocated,  and right child pointers  place this in the tree.   there.   a key is to use the   find function  If it is, then there is no insertion.   if the  to see  If not, then a new   its value is  set  are set to NULL Then it's time to  find where to   to the new  key value   and its left   There is a special   case for inserting   the first   node  in   the tree. If the   count  of  tree's   root pointer   is set to the new node.   nodes in the tree is 0, then the count is incremented  and  the   pointer  node's   If the tree   of the current   is non-empty   the left sub-tree.   then you start by setting   pointer  point, so set the left pointer   a current  to point to the root node. If the new key is less than the current  key, then the new node belongs  in  To handle this you  inspect  the left  child  found the insertion  new node. Otherwise update your current  pointer  the current  the current  pointer  companson   key, it must be greater than.  right child  pointer  and  your current   node's  node's  or advance   with this node. If the key is  not   and start comparisons   to the right child and repeat  the   null, you have  the   to be the left  less than   node. If it  is   node pointer   process.   pointer   either   In that case you inspect   to the pointer  of   set it the new  node's   insert   t '  n   ;    insert:  . n   equ  0  . t   equ  8   push rbp  mov  rbp, rsp  sub  rsp, 16  mov  [rsp+. t], rdi  mov  [rsp+. n] , rsi  call f ind  cmp  rax , 0  j ne  . done  mov  rdi, node_size  call malloc    170   CHAPTER 15. DATA STRUCTURES   value], rsi   mov rsi, [rsp+ . n]  mov  [rax+n_  xor edi, edi  mov  [rax+n_left] , rdi  mov  [rax+n_right] , rdi  mov rdx, [rsp+. t]  mov  rdi, [rdx+t_count]  cmp rdi, 0  j ne  . findparent  inc qword [rdx+t_count]  mov  [rdx+t_root], rax  j mp  . done   . findparent  :   . repeatf   value]   mov rdx, [rdx+t_root]  ind:  cmp  rsi, [rdx+n_  j l   . goleft  mov  r8, rdx  mov rdx, [r8+n_right]  cmp  rdx, 0  j ne  . repeatf ind  mov  [r8+n_right]  jmp  . done   , rax   . goleft:   mov  r8, rdx  mov  rdx, [r8+n_left]  cmp  rdx, 0  j ne  . repeatfind  mov  [r8+n_left] , rax   . done leave   ret   1 5.4.5 Printing the keys in order  Printing the keys of a binary tree in  order  by using  recursion the keys in the left sub-tree,  print the  key of the root node and print the keys of the right sub-tree. The use of   .  The basic idea is to print   performed   is easily    15.4. BINARY TREES   171   a special tree structure  to recursively  main print function  rec_print.   means that there needs to be a different   function   print sub-trees starting   with the pointer   is named print and the recursive   to the root.  The  function   is called   rec_print:  . t   equ   0  rbp  rbp, rsp  rsp, 1 6   rdi,  0  . done  [rsp+. t] , rdi  rdi, [rdi+n_left]  rec_print  rdi, [rsp+. t]  rsi ,  [rdi+n_value]  . data  " %ld " ,0  . t ext  rdi , [ .print]  printf  rdi , [rsp+. t]  rdi, [rdi+n_right]   push  mov  sub  cmp  j e   mov  mov  call  mov  mov  segment  db  segment  lea  call  mov  mov  call rec_print   . print   . done leave   ret   print t ;   print:   push rbp  mov  rbp, rsp  mov  rdi, [rdi +t_root]  call rec_print  segment . data  . print db  OxOa, 0  segment . text    172   CHAPTER 1 5. DATA STRUCTURES   rdi, [ .print]  printf   lea  call  leave  ret    1 5.4. BINARY TREES   173   Exercises   1 .  Modify the singly-linked   list  code   to implement a stack of strings.   Write a main routine   You  can use the C strdup function to make duplicates  that you insert.  entered  ters a loop reading  pop the top of the stack and print that  value.  equals  the  string onto the  or fgets fails to read a string.   push  scanf  exit when either   "print", then print the contents   You code should   which creates   equals "pop", then   If the string   of the stack.   If the string   strings.   a stack and en­  stack.   Otherwise   entered   of strings   2. Modify the doubly-linked   should  equals   list code to implement  read strings  "dequeue" ,   Your main routine  the string  entered  from the queue and print  then print the contents  the end of the queue. You code should exit when either  f gets fails to read a string.   of the queue. Otherwise   it. If the string   entered   add the string  scanf or   until no more are available.  then dequeue   onto   the oldest string  equals "print",   If   a queue of strings.   3 .  Modify the hash table code to implement   a hash table where you   will be the key and the integer   The string   value. Your main routine   associated   store strings and integers.  will be  its  using f gets and read the  text  again  and a number.  for the string  print an error message.  If  returns  hash table.   there is a string   2 , then add   the string   and a number   sscanf  value in the   or update the string's   If there is no number  sscanf returns   1 , then look   should read lines  using sscanf to get a string   Your code should exit when   fgets fails to read a string.   in the hash table and print its value if it there or else   4. Implement   a binary tree of strings   and use it  to read a file of text   using fgets and then   print the lines of text   in alphabetical   order.    174   CHAPTER 1 5. DATA STRUCTURES    Chapter 1 6    High performance assembly  programm ing       for  writing   efficient   x86-64   some strategies  standard   The gold   inC or C++ and compiled   language.   we  discuss   In this chapter  assembly  written  author uses gee which produces  Beating  knowing  some strategy   the compiler  requires  the instruction   executable   with a good optimizing   compiler.   The  code which is  hard  to beat.  your problem   understanding   very well and  to use   set very well. Furthermore   you will  need   or feature which is not used by   the compiler.   is the efficiency   of implementations   16.1 General   optimiza  tion strategies   few possible   There are quite  a  Many of these strategies  Some of these strategies  Here is a list   are aggressively  can be profitably  strategies:   of possible   strategies   for achieving   high performance.   applied by modern compilers.  used in high level languages.     use a better   algorithm     use C or C++     make efficient   use of cache     common subexpression   elimination   175    176CHAPTER 1 6. HIGH PERFORMANCE   ASSEMBLY PROGRAMMING     strength   reduction     use registers   efficiently     use fewer branches     convert   loops to   branch at the bottom     unroll loops     merge loops     split loops     interchange   loops     remove recursiOn     eliminate   stack frames     inline   functions     move loop invariant   code outside loops     eliminate dependencies to allow   lar execution   super-sca    use specialized   instructions   16.2 Use a b etter algorithm   optimiza  tion strategy   is to use a better   to spend many hours tuning   The most important  would be pointless  use the qsort function  Even  better  still  would  be  to  function. If you want to program  in data structures   within  minutes  and  better   and algorithms.   efficiently   achieve   write C++ code and use the STL sort   shell sort, when you could   you must become an expert   algorithm. It   performance   ..   a dictiona  If you want to implement   ry you need to consider  using a  size  has  0 1  expected  time for  O lgn  expected  a key. A red-black tree has guaranteed  to the keys in addition   hash table.  A  hash  table  finding  time. However  to simply finding keys, then a red-bla  ck tree is a good choice.   if you need to have ordered   of reasonable   lookup   access    16.3. USE C OR C++   177   Tuning code in assembly  into an O nlg n  algorithm.  factor. Only a better  constant   language will   not convert   an O n2  algorithm   Tuning can make things faster by some  algorithm   can reduce the complexity.   16.3 Use C or C++   crazy,   may seem a little   of purposes.  First   This suggestion  variety  which is not worth optimizing  and save time, while achieving  a small percentage  time. You might need to use a profiler  parts.  hours of CPU time for you to  10 seconds.   It doesn't   but you can use a compiler  for a   there is probably a   large part of your application   and you could write that code in  possibly  the same performance.   C or C++  Generally   of your code will consume   a large percentage   of the   to help locate   the time-consuming   matter much if you have a process   tune a part of the program   consuming   several  which consumes   Second you should write a C version   of your code and  compare   your   code versus C to learn whether  If you can't beat the  compiler,  goal in using assembly  be to write assembly   make things run  code to prove that you can do it.   you have done better  then why use assembly   is to   than the compiler.   language?   Your   faster. The goal should  not   Finally   you can use the -S option  file. Studying this generated   language  about how to write efficient   assembly   code.   of gee to have it produce   an assembly   code may give you some ideas   1 6 . 4  Efficient use o f  cache   is to keep the processing   goals in   computing   high performance   modern CPU like the Intel Core i7 operates   One of the  units of the CPU busy.  A  a clock speed around 3 GHz while its main memory maxes  2 1  GB sec. If your application  memory using no  cache,  then  per  cycle.  so  we're down to about 2 bytes per cycle per core from memory. Yet each of  these cores can have instructions  in 3 processing  and 2 memory processing  can retire  per cycle.  AMD Bulldozer CPUs  It   Each  CPU  The same is true for the upcoming   ran strictly  there would be roughly   The CPU has 4 cores which need to share the 2 1  GB sec,   being processed   sub-units.   out at about   7 bytes available   at   in   from data and instructions   sub-units   4 instructions    178CHAPTER 1 6. HIGH PERFORMANCE   ASSEMBLY PROGRAMMING   much more than   requires  a modern CPU. To keep   2 bytes per cycle to keep instructions  these CPU s fed requires   3 levels   of cache.   flowing in   I performed a short test   to illustrate   the effect of main memory access   cache on a Core i7 CPU. The test consisted   of executing   10 billion   or operations   versus  exclusive  can see that the time depends  of size of 8000 bytes,  through  the cache   the use of the 8 MB of cache.  is nearly   useless   on quad-words in   memory. In the plot below you   heavily   on the array size. With an array   the time as  1 .  5 seconds. The  time  steadily  grows   and a maximum   of about 5. 7 seconds   When the size is 80 million   bytes  is reached.   Time to Compute XOR   le+06   le+07   Array Size in Bytes   le+08   le+lO   forward matrix multiplication   of making efficient  Straight   A prime example   usc of cache is in the implemen­  of matrix multiplication.   tation  is O n3  where there are n rows and n columns  coded as 3 nested loops.  enough for 3 blocks  are MFLOPS ratings  matrices  using assembly   in a C program.  language   small  blocks  boost.  Below  2 1 024x1024  block sizes for multiplying  room for improvement by   There is considerable  to take advantage   to fit in cache for  a nice performance   However it can  be broken  up  into   for various   of data. It is commonly   of SSE or AVX instructions.    1 6.5. COMMON SUBEXPRESSION   ELIMINATION   179   1024x1024 Matrix Multiplication   0o� ------�-------  5�00-- ----��------1 Block size   �000�   1 6 . 5  Common subexpression  elim  ination   elimination   is generally   performed   by  optimiz­  Common subexpression  ing compilers.  If you are to  must do the same thing.  mon subexpressions.  generated  efficient   discover   code to   have any hope of beating   the compiler,   This might  be a   Sometimes   it may be hard to locate  good time to study the compiler's  is tireless   and   what it found. The compiler   you  all com­  at its tasks.  Humans  tend to   overlook things.   1 6 . 6  Strength reduction   Strength reduction  an answer. It is possible  faster to compute   means using a simpler   to computer   mathematical  x3 using pow, but it  is   technique   to get   probably   X*X*X. If you need to compute   x4, then do it in stages   x2 = x  * x ;   x4 = x2 * x2;   If you need to divide  be  done  floating   more quickly  point number by x, compute   or multiply  by shifting.   an integer  If you need to divide   of 2, this  can  more than  one   by  a power   1  x and multiply.    180CHAPTER 1 6. HIGH PERFORMANCE   ASSEMBLY PROGRAMMING   1 6 . 7  Use registers  efficiently   used values in registers.   Place commonly  place values in registers.  mode where I had all my values in registers.  using the stack for a few values. TheRe Rtack values  the level 1 cache  and  were  tells the truth.   to  I once wrote a doubly  nested  loop  in  faster code by  in   gee generated   almost as good as being in registers.  Testing   It is nearly always better   32  bit   probably remained   1 6 . 8  Use fewer branches   and will prepare   the pipeline   branch.   Modern CPUs make branch predictions  with some instructions  conditional  so it will help to try to make fewer branches.  from your compiler.  the number of branches.  compiler  It will frequently   reorder   You will learn some general   .   from one of the 2 possibilities  when there is a   The pipeline will stall   when this prediction is   Study the   wrong,  generated   code   the assembly code   to reduce  techniques  from the   1 6 . 9  Convert loops to branch at the bottom   while loop as written,   there will be a conditional   to branch past the loop and an unconditional   If you code  a  the top of the  loop  to  at the bottom of the loop to get back to the top. It is always possible  branch at the bottom.  transform the loop have a conditional  You may  to handle  need a one time use conditional  cases where the   the top of the loop   loop body should   be skipped.   jump before   jump at   jump   Here is a  C for loop converted   to a do-while loop.  First   the f or   loop:   for     i   = 0 ;  i  < n ;  i++    {   x [i] = a [i] + b [i];   }   if    n  >  0      {   i =  0 ;    Now the   do-while loop with an   additional   if:    1 6. 1 0. UNROLL LOOPS   181   do {   x [i] = a [i] + b [i];  i++;   } while    i  < n   ;    }   Please   do not adopt this style of coding   in C or C++.   The compiler   will handle for loops quite well. In fact the simplicity  might allow the  compiler  simply to get the point across   of the f or loop  code. I  presented   more quickly.   to generate   better   this in C   1 6 . 1 0  Unroll  loops   The primary   technique   doing  the   used by compilers.   loops is another  is that there   Unrolling  advantage  instructions  the CPU will have more instructions  longer  loop  if you  manage  no dependencies  open up the possibility  execute  with 16 registers  than  with   instructions  and more  will be fewer loop control  work of the loop. A second advantage  is that  with a  available to fill its pipeline  to use registers  or  code, then you  CPU  most modern CPUs  to   sections  for  a super-scalar  iterations   in parallel.  This   body. Finally   the separate   of unrolled   with little   original   multiple   between   8.   is considerably  easier   Let's consider   some code to add up  all   the numbers   in an array of   quad-wor  ds. Here  is   the assembly   code for the simplest  version:   segment . text  global add_ array   add_array  :   xor eax, eax   . add_words:   add  rax , [rdi]  add  rdi, 8  dec rsi  j g   . add_words  ret   Here is a version   with the loop unrolled   4 times:    182CHAPTER 1 6. HIGH PERFORMANCE   ASSEMBLY PROGRAMMING   segment . text  global add_ array   add_array  :   push r15  push r14  push r13  push r12  push rbp  push rbx  xor eax, eax  mov  rbx, rax  mov  rex, rax  mov  rdx, rax   . add words:   add rax, [rdi]  add  rbx, [rdi+8]  add  rex, [rdi+ 16]  add  rdx, [rdi+24]  add  rdi, 32  sub  rsi, 4  j g   . add_words  add  rex, rdx  add  rax , rbx  add  rax , rex  pop rbx  pop rbp  pop r12  pop r13  pop r14  pop r15  ret   There may have been some way to use fewer callee-sa  ve registers,   the coding.   I made simplified   but the choices  accumulating  are  combined  calls to add up an array of 10000 quad-words  simple  for the unrolled   partial  after the loop.  Executing   and 2.44 seconds   version   a  test   program   with 1000000   took 3.9 seconds  version.  There is so   for the   little   sums in rax, rbx, rex and rdx. These partial  sums   In the unrolled   code I am    1 6. 1 1 .  MERGE LOOPS   183   work to do per  bandwidth  cache.   data element   that the   2 programs   limited   with large arrays, so I tested   start becoming  memory  a size which fit easily   in   16. 1 1  Merge loops   If you have 2 for loops iterating  there is no dependence  Consider  merge the loops.   between   the following   over the same sequence  it seems like  a   of values and  no-brainer  to   the loops,   2 loops:   for   i = 0 ;  i  < 1000; i++  a [i] = b [i] + c [i];  f or   j = 0 ;  j  < 1000; j ++   d [j ]  = b [j ]  -c [j ];   This can easily   be merged to get:   for   i = 0 ;  i  < 1 000; i++   {   a [i] = b [i] +  c [i] ;  d [i] = b [i] - c [i] ;   }   In general   merging   loops can increase  and helping   the size of a loop body, decreas­  to keep  the   pipe�ne full. In   ing the overhead percentage  this case there is additional gain  rather   from loading   than twice.   the values of b and c once   1 6 . 1 2  Split loops   how merging   -well  for   loops was a good idea. Now  some loops.   If a loop is  op­  on 2 independen  We just got through discussing  we are  going  to learn the opposite  erating  This can improve performance  capacity.  structions  splitting   There is a trade-off  in the pipeline.   is better.   t sets of data, then it could be split into 2 loops.   if the combined  better  between  Sometime  merging   loop is exceeding  cache usage and more in­ is better   the cache   and sometimes   16.13 Interchange  loops   Suppose  choices:   you wish to place O's in a 2-dimensional   array in C. You have 2    184CHAPTER 1 6. HIGH PERFORMANCE   ASSEIVIBLY PROGRAMMING   }   or   f or   i =  O ·  i < n ·  i++   {   '   '   '  X [i] [j] =  0 ;    for   j =  0 ;  j < n ·  j ++   {  }   for   j =  0 ;  j < n· '  j ++   {   for   i =  0 ;  i < n ·  '  i++   {   x [iJ [jJ =  0 ;    }   }   Which is better?   In  C the second index  increments  faster than the  . On the   after x [OJ [0]. When the CPU fetches   means that x [OJ [1J is immediately   first.  This  other hand x [1] [0] is n elements  data into the cache it fetches more than  a few bytes and cache writes  to memory behave similarly, so the first loop makes more sense.  have the extreme  your RAM, then  you  second version.   may experience  This could turn into   virtual  a disk access   memory thrashing   for each array access.   misfortune   after x [OJ [OJ  of having an array which is too large  for   with the   If you   16.14 Move loop invariant code outside loops   This might be a fairly obvious  where studying the compiler's generated  invariant   code which you have overlooked.   optimization   to perform. It's another  case  some loop   code might point out   1 6 . 1 5  Remove recursion   then it will nearly always improve   Often it  is  easy  to   of a function is a recursive call. This can generally   If  it is easy to eliminate  recursion  efficiency.  action  branching  eliminate  recursive calls,   be done by  to the top of the function. On the other hand if you try to  recursion   for a function like  you will be forced to "simulate"   recursion   eliminate   quicksort   "tail"   which makes 2 non-trivial  recursion   using your own   where the  last    16.16. ELIMINATE STACK FRAMES   185   This may make things   stack.  the time spent making recursive calls  in   slower.   quicksort   is small.   In any case the effect is small,   since   1 6 . 1 6  Eliminate stack frames   functions   is for debugging.   it is not necessary   which call your own functions   to use stack frames. In fact if you  and no others   For leaf functions  have non-leaf  you can omit the frame pointers  frame pointers  stack on 16 byte boundaries,  which have local variables  or 32 byte accesses  your own code is not using those instructions,  nor frame alignment   then  from these too. The only real reason for  the  for leaving  There is a requirement  but this only becomes  with functions   on the stack  which participate  16  in aligned  fail or be slower. If you know that   are important other   than for debugging.   which can either   then neither   as issue   frame pointers   16.17 Inline   functions   compilers   As part of optimization  duces the overhead significantly.  int�rested  and write and operate   in exploring   macros which can make your code easier  much like a function   which has been in-lined.   to read   can in-line  This re­ If you wish to do this, you might be   small functions.   16.1 8 Reduce dependencies   to allow super-scalar   execution   the instruction   Modern CPUs inspect  tions which do not depend upon results  "out of order executio called  then the CPU will execute  gram will   run  more  quickly.   n". If there is less dependency  more instructions   out of order and your pro­  in your code,   stream looking   ahead for instruc­  of earlier   instructions.   This is   As an example  of   this I modified the previous   add_array   function   with unrolled  increased   loops to accumulate  the time from 2.44 seconds   to 2.75 seconds.   all 4 values   in the loop into rax. This    186CHAPTER 16. HIGH PERFORMANCE   ASSEMBLY PROGRAMMING   1 6 . 1 9  Use specialized   instructions   to apply.   instructions   seen the conditional   which is fairly spe­ There are many   move instruction  point instructions.  architecture   the packed floating  in the x86-64  A human can reorganize   So far we  have  cialized  and also  specialized  for a compiler  elements of  keep 4 partial  sums in one AVX register.  AVX register  can be done  faster, since 4 adds can be  done  also be combined  will be explored   which are more difficult  to add the  an algorithm  except to  the 4 parts of the  after the loop. This can make the adding even  can  This   This technique  performance.   like I did  with  loop   in the SSE and AVX chapters.   in one instruction.   with loop unrolling   an array somewhat   for additional   unrolling   Combining   in detail    1 6. 1 9. USE SPECIALIZED  INSTRUCTIONS   187   Exercises   1 .  Given an array of 3D points   defined in a structure  a distance   with x, y and   matrix with   z components, write a function  the distances   to compute  each pair of points.   between   2. Given a 2D array, M, of floats of   dimensions   n by 4, and a vector,   v, of 4 floats compute   Mv.    188CHAPTER 16. HIGH PERFORMANCE ASSEMBLY PROGRAMMING    Chapter 1 7    Counting bits in an array   several   we explore   In this chapter  integers.  all the 1 bits in an array of quad-word  same C  main program and  implement a different  number of 1 bits in the array. All these functions  prototype:   solutions   For each  function  implement the  same   test we use the  the   counting   to the  problem   of counting   long popcnt_array  long *a, int size  ;    17.1  C function   The first solution   is a straightf  orward C solution:   rray   long *a, int size     long popcnt_a {   int w ,  b ;   long word;  long n ;    n  = 0 ;   f or     w  =   0 ;  w  < size; w++    {   word  = a [w] ;  n  += word & 1 ;   for     b  =   1 ;  b  < 64; b++   {  n +=  word>> b   & 1 ;    189    190   CHAPTER 1 7. COUNTING BITS IN AN ARRAY   }   }  return n ;    }  The testing   consists   of calling  bytes . Compiling  14.63 seconds.   popcnt_array 1000 times with  an array  with optimiza tion level zero  With optimization   level 1 ,  it   of 100000 longs  800000   option -DO  the test  took  took 5.29 seconds, with level 2 it took 5.29 seconds  3 it took 5.37 seconds.  seconds.   Finally adding   -funroll-all-loops,   it took 4.74   again,   and with level   The algorithm can   be improved by noticing  being tested   the upper  might be 0. We can change the inner   that frequently   bits of the quad-words  for loop into a while loop:   long popcnt_array   unsigned  {   long *a, int size     i   long word;   int w, b ;   unsigned  long n ;   n ;:;;; 0 ;   for    w ;:;;; 0 ;  w  < s ize; w++   {   a [w] ;   word  ;:;;;  while   word ! ;:;;;  0     {  ;   ·n  +;:;;;  word  &  1  word >>= 1 ;    }   }  return n ;    }  Using the maximum optimiza  tion options   the  version   takes 3.34 sec­  onds. This  is   an instance of using a better   algorithm.   17.2 Counting 1 bits in assembly   It is  of working   not too hard to unroll   the loop for working   on 64 bits into 64 steps   on 1 bit. In the assembly   code which follows one fourth of the    1 7.2. COUNTING 1 BITS IN ASSEMBLY   191   bits of each word are placed  and one fourth in rdx. Then each fourth of the bits are accumulated using  different  registers.  use out-or-order   This allows  execution   in rax, one fourth in rbx, one fourth in rex   freedom for the computer   considerable   with the loop .   to   segment . text  global popcnt_array   popcnt_array:   . count words:   push rbx  push rbp  push r12  push r13  push r14  push r15  xor  eax, eax  xor ebx, ebx  xor ecx, ecx  xor edx, edx  xor r12d , r 1 2d  xor r13d ,  r 13d  xor r14d, r 14d  xor r15d , r 15d   mov  r8, [rdi]  mov  r9, r8  mov  r10, r8  mov  r 1 1, r9  and  r8, Oxffff  shr  r9, 16  and  r9, Oxffff  shr r10, 32  and  r10, Oxffff  shr  r 1 1, 48  and  r 1 1, Oxffff   mov  r12w ,  r8w  and  r12w ,  1    192   CHAPTER 1 7. COUNTING BITS IN AN ARRAY   %rep 15   add  rax , r 1 2   mov r13w ,  r9w  and  r13w ,  1  add  rbx, r13  mov  r14w, r10w  and  r14w ,  1  add  rex, r14  mov r15w ,  r11w  and  r15w ,  1  add  rdx, r15   shr r8w, 1  mov r12w, r8w  and  r12w ,  1  add  rax, r12  shr r9w,  1  mov r13w ,  r9w  and  r13w ,  1  add  rbx, r13  shr r10w ,  1  mov r14w ,  r10w  and  r14w ,  1  add  rex, r14  shr r 1 1w ,  1  mov r15w ,  r11w  and  r15w ,  1  add  rdx, r15   %endrep   add  rdi, 8  dec rsi  j g   . count_words  add  rax , rbx  add  rax, rex  add  rax, rdx  pop r15  pop r14    1 7.3. PRECOMPUTING THE NUMBER OF BITS IN EACH BYTE193   pop r13  pop r12  pop rbp  pop rbx  ret   This is an unfortunate   1 5  times.   repeats  worth it  to execute  more bytes than  the   the test  in  C  code with unrolled   This makes for function   loops.   side effect -the use of a repeat section  with  it was  only 240   of 1 123 bytes. Perhaps   2.52 seconds.   The object   file  is   1 7.3 Precomputing   the number of bits in each   byte   improvement   the number of bits in each possible   The· next algorithmic  precompute  array of 256 bytes to store the number of bits in each  the number of bits in a quad-word  quad-word   comes from recognizing  that we can  and use an  .  of the  of using the 8  bytes  into the array of bit counts and adding them up.   bit pattern   as  indices   consists   byte. The� counting   Here is the C function for adding the number of bits in the array   without   the initialization   of the   count array:   long popcnt_array   l ong *a, int size    {   int b ;   long n ;   int word;   n  = 0 ;   f or     b  =   0 ;  b  < size*8; b++   {   word=    unsigned char *   a [b];  n += count[word];   }  return n ;    }  This code took 0.24 seconds   for the test, so we have a new winner.   I    194   CHAPTER 1 7. COUNTING BITS IN AN ARRAY   tried hard to beat this algorithm  only a   tie.   using assembly   language,   but managed   1 7.4 Using the popcnt instruction   A new instruction  gives the number of 1 bits in a 64 bit register.  we can employ the technique   Core i series   included   in the   processors  So on the right computers,   is popent which   of using a specialized   instruction:   segment . text  global popent _array   popent_array:   xor eax, eax  xor r8d, r8d  xor e ex , eex   . eount_more:   popent  add  popent  add  add  emp  j l   add  ret   rdx, [rdi+rex*8]  rax, rdx  r9, [rdi+rex*8+8]  r8, r9  rex,  2  rex, rsi  . eount_more  rax, r8   We have a new winner on the   Core i7 at 0.04 seconds   which is 6 times   faster than the nearest   competitor.    1 7.4. USING THE POPCNT INSTRUCTION   195   Exercises   1. Write a function   to convert   an array of ASCII characters   to EBCDIC   and another   to convert   back to ASCII.   2. For 2 arrays   of ASCII characters   write a function   to find the longest   common substring.    196   CHAPTER 1 7. COUNTING BITS IN AN ARRAY    Chapter 1 8    Sobel filter   filter is an edge detection   The  Sobel  operation of  pixel by one 3x3 matrix to  produce  and another   in the x direction  the filter is   to process   .  Here   an edge measure  are the 2 matrices   filter used in   image processing.   The  each  of data by convolving   3x3 windows   in the x direction   Bx = [=� � �]   - 1  0  1   For an individual   pixel Ir,c the x edge measure,   Gx, is computed   by   1  1   Gx = L  L  Sx,i,j   * Ir+i,c+i    i=-1 j=-1   where we have conveniently  with -1. Similarly we compute   numbered  Gy using   the rows and columns   of Bx starting   Next we show how to get the magnitude   of the edge measure,   G,   1  1   Gy = L  L  Sy,i,j   * Ir+i,c+i    i=-lj=-1   G =  Jc2 + G2   X  y   197    198   CHAPTER 18. SOBEL FILTER   1 8 . 1  Sobel inC   include     Here is a  C function  image of arbitrary  size:   which computes   the Sobel edge magnitude   for an   def ine matrix  a , b, c  a [  b * cols   +   c   ]    void sobel   unsigned   char *data, float *output , long rows,   long eels     {   int r ,  c ;   int gx , gy;   for    r = 1 ;  r  < rows-1 ;  r++   {   for     c   = 1 ;  c  < cols- 1;  c++      {   gx = -matrix dat a , r- 1 , c- 1    + matrix data, r - 1, c+ 1    +  -2*matrix data, r , c- 1    + 2*matrix data, r , c+ 1    +  -matrix dat a , r+i, c- 1    + matrix data, r+1, c+ 1  ;   gy = -matrix data, r- i, c- 1    -2*matrix data, r- 1, c    -matrix dat a , r- 1, c+ 1    +  matrix data, r+1, c- 1    + 2*matrix data, r+ 1, c   + matrix data, r+ 1, c+ 1  ;   matrix output, r , c  =  sqrt   f loat   gx *  float   gx +   float   gy *  float   gy   ;   }   }   }   This code was compiled with   -03 optimization   and full loop unrolling.   images per second.   Testing with 1024 x 1024 images  showed  magnitude  cut down on the effect of cached images,  per second.  memory bandwidth.   the code is dominated   Clearly   Testing with 1000 different  this code produced   images to  158 images  rather   than   that it computed   161.5 Sobel   by mathematics    18.2. SOBEL COMPUTED USING SSE INSTRUCTIONS  199   18.2 Sobel computed   using SSE instructions   which manipulates   image data is byte data. The movdqu   of an algorithm   Sobel was chosen as a good example  data of many types. First  the  instruction was used to transfer 16 adjacent  were  processed  image. These pixels  to produce  central14 pixels  to Gx and Gy. Then 16 pixels  image one row down from the first 16 pixels. These pixels  in the same way adding more  to  rows down from the first  16  were  Gx and Gy were computed.  squared,  roots were computed  output array.   Gx and Gy. Finally  transferred   added  together,   for the 14 output pixels   pixels  from   one row of the   the contribution of  were transferred from the   their   were processed   16 more pixels   2  to   and their contributions   Then these contributions   were combined,   converted to 32 bit floating  point  and   square   which were placed in the   Tested on the same Core i7 computer,   this code produced  Testing with 1000 different   1063 Sobel  images this   images per second.   980 images per second,   which is about 6.2 times as fast as   magnitude  code produced  the C version.   Here are the new  instructions   used in this code:   pxor This  instruction  or memory and stores   register   performs   or  on  a  in the destina  an exclusive   128 XMM source   the result   tion register.   movdqa This  instruction   moves 128 bits of aligned   data from memory  to memory, or from a register   to a   to a register,  register.   from a register   movdqu This instruction   moves 12  from  a  register   of unaligned data   8 bits  to memory, or  from  a  register   from memory   to a   to a register,  register.   psrldq This instruction  shifts   number of bytes specified   the destination  in the second immediate   XMM register   operand.   right the   punpcklbw This instruction   unpacks the low 8 bytes   of 2 XMM registers   and intermingles  all 0 bytes to   form 8 words in the destination.   them. I used this with the second register   holding   punpckhbw This instruction  and intermingles   isters   unpacks   them.   the upper 8 bytes of 2 XMM reg­   200   CHAPTER 18. SOBEL FILTER   paddw This instruction   adds 8 16 bit integers   from the second operand   to the first operand. At least one of the operands  register   can be a memory field.   and one   must be an XMM   psubw This instruction   subtracts   the second set   of 8 16 bit integers   from   the first set.   pmullw This instruction   multiplies   the first set   times  the low order 1 6  bits of the products   of 8 16 bit integers   in   the second set and stores  the first operand.   punpcklwd This instruction   unpacks  and   interlea  ves words from the   lower halves   of 2 XMM registers   into the destination   register.   punpckhwd This instruction   unpacks   upper halves   2 of XMM registers   and interleaves  into the destination   words from the   register.   cvtdq2ps This instruction   converts 4 double word integers   into 4 double   word floating   point values.   Here is the assembly   code:   I needed to push and pop all callee  save registers from the yasm documentation .   , so I used macros   %macro multipush   1-*   %rep %0   push %1  %rotate   1  %endrep  %endmacro   %macro multipop  1-*   %rep %0   %rotate - 1   pop  %1   %endrep  %endmacro   sobel   input, output, rows, cols   ;   char input[rows]  float output[rows]   [cols]   [cols]    18.2. SOBEL COMPUTED USING SSE INSTRUCTIONS  201   boundary   of the output array will be unfilled   segment . text  global sobel, main   0  8   equ  equ   sobe l :   . eols  . rows  . output equ  1 6   . input equ  24  . bpir equ  32  . bpor equ  40   r12, r13, r14, r15   multipush rbx,  rbp ,  sub  rsp, 48  emp  rdx, 3  j l   . noworktodo  emp  rex, 3  j l   . noworktodo  mov  [rsp+.input], rdi  mov  [rsp+.output], rsi  mov  [rsp+. rows], rdx  mov  [rsp+. cols] , rex  mov  [rsp+. bpir] , rex  imul rex , 4  mov  [rsp+.bpor], rex   mov  rax, [rsp+. rows];  mov  rdx, [rsp+. cols]  sub  rax, 2  mov r8, [rsp+.input]  add  r8, rdx  mov  r9, r8  mov r 1 0 ,  r8  sub  r8, rdx  add  r10, rdx  pxor xmm13, xmm13  pxor xmm14, xmm14  pxor xmm15, xmm15   count of rows to process   address of row   address of row-1  address of row+1    202   CHAPTER 18. SOBEL FILTER   . more_rows:   . more_cols:   mov rbx, 1   f irst column to process   data f or 1st row of 3   movdqu xmmO, [r8+rbx-1]  movdqu xmm1, xmmO  movdqu xmm2, xmmO  pxor xmm9, xmm9  pxor xmm10, xmm10  pxor xmm11 ,  xmm11  pxor xmm1 2 ,  xmm1 2   psrldq xmm1, 1  psrldq xmm2, 2   shift the pixels 1 to the right  shift the pixels 2 to the right  Now the lowest 14 values of  xmmO, xmm1 and xmm2 are l ined  up properly  for applying the  top row of the 2 matri ces.   xmm3, xmm4, and   movdqa xmm3, xmm  movdqa xmm4, xmm1  movdqa xmm5, xmm2  punpcklbw xmm3, xmm13; The low  8 values are now words  punpcklbw xmm4, xmm14; in registers  punpcklbw xmm5, xmm15 ;  and xmm5  -ready for arithmetic.  psubw  xmm11 ,  xmm3  xmm11 will hold 8 values of Gx  psubw xmm9, xmm3  xmm9 will hold 8 values of Gy  paddw xmm11 ,  xmm5  Gx subtracts  left, adds right  psubw xmm9, xmm4  Gy subtracts  2  * middle pixel  psubw xmm9, xmm4  psubw  xmm9, xmm5  punpckhbw xmmO, xmm13  punpckhbw xmm1, xmm14  punpckhbw xmm2, xmm15  psubw xmm12 ,  xmmO  psubw xmm10, xmmO  paddw xmm12, xmm2  xmm10 ,  xmm1  psubw  psubw  xmm10, xmm1  xmm10 ,  xmm2  psubw   Perform the same arithmetic  storing these 6 values in  xmm12 and xmm10   Final subtraction for Gy  Convert   top 8 bytes to words    18.2.  SOBEL COMPUTED USING SSE INSTRUCTIONS  203   xmmO, [r9+rbx-1] ; data for 2nd row of 3  ; repeat  math  from 1 st row  xmm2, xmmO  ; with nothing added to Gy  xmm2,  2  xmm3, xmmO   8 values for 1st row   movdqu  movdqu  psrldq  movdqa  movdqa xmm5, xmm2  punpcklbw xmm3, x�13  punpcklbw xmm5, xmm15  psubw xmm11 ,  xmm3  psubw xmm11 ,  xmm3  paddw xmm11 ,  xmm5  paddw xmm11 ,  xmm5  punpckhbw  punpckhbw  psubw xmm12, xmmO  xmm12, xmmO  psubw  xmm12, xmm2  paddw  xmm12, xmm2  paddw   xmmO, xmm13  xmm2, xmm15   movdqu  movdqu  movdqu  psrldq  psrldq  movdqa xmm3, xmmO  movdqa xmm4, xmm1  movdqa xmm5, xmm2  punpcklbw xmm3, xmm13  punpcklbw xmm4, xmm14  punpcklbw xmm5, xmm15  psubw  xmm11 ,  xmm3  paddw xmm9, xmm3  paddw xmm11 ,  xmm5  paddw xmm9,  xmm4  paddw xmm9,  xmm4  paddw xmm9,  xmm5  xmmO, xmm13  punpckhbw   xmmO, [r10+rbx-1]; data for 3rd row  of  3  xmm1, xmmO  xmm2, xmmO  xmml,  1  xmm2,  2   8 values for 3rd row    204   CHAPTER 18. SOBEL FILTER   punpckhbw xmm1, xmm14  punpckhbw xmm2, xmm15  psubw xmm12, xmmO  paddw xmm10, xmmO  paddw xmm12 ,  xmm2  paddw xmm10, xmm1  paddw xmm10, xmm1  paddw xmm10, xmm2   sum of squares   pmullw xmm9, xmm9  square Gx and Gy values  pmullw xmm10 ,  xmm10  pmullw xmm11 ,  xmm 1 1   pmullw xmm12, xmm12  paddw xmm9, xmm 1 1   paddw xmm10, xmm12  movdqa xmm1 , xmm9  movdqa xmm3, xmm10  punpcklwd xmm9, xmm13  Convert low 4 words to dwords  punpckhwd xmm1, xmm13  Convert  high  4 words to dwords  punpcklwd xmm10, xmm13 Convert low 4 words to dwords  high 4 words to dwords  punpckhwd xmm3, xmm13  Convert  cvtdq2ps xmmO, xmm9  Convert  to f loating point  cvtdq2ps xmm1, xmm1  Convert to floating point  to f loating point  cvtdq2ps xmm2, xmm10 Convert  cvtdq2ps xmm3, xmm3  Convert  to f loating point  sqrtps xmmO, xmmO  Take sqrt to get magnitude  sqrtps xrnm1, xmm1  Take sqrt to  get magnitude  sqrtps xmm2, xmm2  Take sqrt to get  magn itude  sqrtps xrnm3, xmm3  Take sqrt to get magnitude  movups [rsi+rbx*4], xmmO  movups [rsi+rbx*4+16], xmm1  movups  movlps   [rsi+rbx*4+32], xmm2  , xmm3  [rsi+rbx*4+48]  add  rbx, 14  cmp rbx, rdx  j l   . more_cols   process 14 Sobel values    18.2. SOBEL COMPUTED USING SSE INSTRUCTIONS  205   add  r8, rdx  add  r9, rdx  add  r10, rdx  add  rsi ,  [rsp+.bpor]  sub  rax,  1  cmp  rax,  0  j g   . more_rows   1 fewer row to process   . noworktodo:   add  rsp, 48  multipop rbx,  rbp ,  ret   r12, r13, r14, r15    206   CHAPTER 18. SOBEL FILTER   Exercises   1 .  Convert  convolut  the Sobel function  ion of  an image   with a 3 x 3 matrix.   into a function   to perform an arbitrary   2. Write an assembly   function   to convert   an image   into a run-length   encoded   image.   3. Write a function   to fill  rived by using 4 �parate   an array with pseudo-random  de­ interlea  ved sequences   based on the formula   numbers   Xn+l =  aXn + c  mod m  Use m = 32 for all4 sequences.  and 214013 for the values for a and 1013904223,  2531011 for the   values for c.   Use 1664525, 22695477,   1 103515245   1 ,  12345 and    Chapter 1 9    Computing Correlation   The  final example  two variables  lation   is using   of optimization   is computing   x andy given n sample values. One way to compute   the correlation  corre­  between   But this formularequires  pute averages  intuitive formula which is more amenable   through  and a second pass to complete   two passes   the data-one pass to com­ the formula. There is a less   to computation:   The computational   formula requires   computing   the data: the sum of Xi, the sum of Yi, the sum of xt, the sum of Yt and  the sum of XiYi· After computing  of time required   these 5  sums there is a small  the computational  formula.   for implementing   amount   5 sums when you scan   1 9 .1  C implementation   The C computation   is performed   in the   corr function   given below:   include    double corr  double x [] , double y [] ,  long n      207    208   CHAPTER 1 9. COMPUTING CORRELATION   {   }   double sum_x, sum_y, sum_xx, sum_yy, sum_xy;  long i ;    sum_x = sum_y = sum_xx = sum_yy = sum_xy = 0 . 0 ;   for   i  0 ;  i < n ;  i++    {   sum_x += x [i];  sum_y += y [i];  sum_xx += x [i]*x[i];  sum_yy  +=  y [i]*y[i];  sum_xy += x [i] *Y [i] ;   }  return  n*sum_xy-sum_  x*sum_y     sqrt   n*sum_xx-sum_x*sum_x * n*sum_yy-sum_y*  sum_y   ;   The gee compiler   generated   assembly   code which used  all  16   of the  for  of the  4 iterations  the  extra   handled   also correctly   as it unrolled   the loop to process   XMM registers  loop in the main loop. The compiler  data values when the array size was not  a multiple  1 million  13.44 seconds  quite impressive   on  2 arrays  This is roughly   correlation   calls to compute   for compiled   C version.   for  the   code.   of four. Performing   of size 10000 required  5.9 GFLOPs which is   1 9 . 2  Implementation   using SSE instruction  s   A version  will execute   of the core function was written   on many modern computers.   using SSE instructions   which  Here is the SSE version:   segment . text  global corr   rdi, rsi, rdx, rex , r8, r9   rdi:  x array  rdi:  y array  rex: loop counter    19.2. IMPLEMENTATION USING SSE INSTRUCTIONS  209   rdx: n  xmmO: 2 parts  of  sum_x  xmm1: 2 parts of sum_y  xmm2: 2 parts of sum_xx  xmm3:  2 parts of sum_yy  xmm4: 2 parts  of  sum_xy  xmm5 : 2 x values -later squared  xmm6: 2  y values -later squared  xmm7: 2 xy values   corr:   . more:   xor r8, r8  mov rex, rdx  subpd xmmO, xmmO  movapd xmm1, xmmO  movapd xmm2, xmmO  movapd xmm3, xmmO  movapd xmm4, xmmO  movapd xmm8, xmmO  movapd xmm9, xmmO  movapd xmm10, xmmO  movapd xmm11 ,  xmmO  movapd xmm12, xmmO   movapd xmm5, [rdi +r8] mov x  movapd xmm6, [rsi +r8] mov y  movapd xmm7, xmm5  mov x  mulpd xmm7, xmm6  xy  addpd xmmO,  xmm5 sum_x  addpd xmm1, xmm6  sum_y  mulpd xmm5 , xmm5  XX  mulpd xmm6, xmm6  yy  addpd xmm2, xmm5  sum_ XX  addpd xmm3, xmm6  sum_yy  addpd xmm4 , xmm7  sum_xy  movapd xmm13, [rdi +r8+16] mov x  movapd xmm14, [rsi +r8+16] mov y  movapd xmm 1 5, xmm1 3  ; mov x    210   CHAPTER 1 9. COMPUTING CORRELATION   mulpd xmm15, xmm14  xy  addpd xmm8, xmm13  sum_x  addpd xmm9, xmm14  sum_y  mulpd xmm13, xmm13  XX  · mulpd xmm14, xmm14  yy  addpd xmm10, xmm13  sum_xx  addpd xmm11 ,  xmm14  sum_yy  addpd xmm12, xmm15  sum_xy  add  r8, 32  sub  rex,  4  j nz  . more  addpd xmmO , xmm8  addpd xmm1, xmm9  addpd xmm2, xmm10  addpd xmm3, xmm 1 1   addpd xmm4, xmmi2  haddpd xmmO, xmmO  sum_x  haddpd xmm1, xmm1  sum_y  haddpd xmm.2, xmm2  sum_xx  haddpd xmm3, xmm3  sum_yy  haddpd xmm4, xmm4  sum_xy  movsd xmm6, xmmO  movsd xmm7, xmm1  sum_y  cvtsi2sd xmm8, rdx  n  mulsd xmm6, xmm6  sum_x*sum_x  mulsd xmm7, xmm7  sum_y* sum_y  mulsd xmm2, xmm8  n*sum_xx  mulsd xmm3, xmm8  n*sum_yy  subsd xmm2, xmm6  n*sum_xx-sum_x* sum_x  y  subsd xmm3, xmm7  n* sum_yy-sum_y*sum_ mulsd xmm2, xmm3  denom*denom  sqrtsd xmm2, xmm2  den om  mulsd xmm4, xmm8  n*sum_xy  mulsd xmmO, xmm1  sum_x*sum_y  subsd xmm4, xmmO  n*sum_xy-sum_x* sum_y  divsd xmm4, xmm2  correlation  movsd xmmO, xmm4  need in xmmO   sum_x    1 9.3. IMPLEMENTATION USING AVX INSTRUCTIONS  2 1 1    ret   In the main loop  of   this function the movapd instruction  was used   values from the x array and again the load 2   to load 2 double precision  values from the y array. Then accumulation  xmmO -xmm4. Each of these accumulation  values -one for even indices  After this collection   of accumulations   and one for odd   registers  indices.   the movapd instruction  was used  again to load 2 more values for x and again to load 2 more values from  y. These values were used to form accumulations  xmm8 -xmm12.   was performed in   registers   held 2  accumulated   into 5 more registers:   The  first   After completing   the loop, it was time to add together   summation.   each required  to add the registers  the "horizontal add  the upper and  lower  final sums. Then the code  on 1 million   When tested   xmm8-xmm1 2  to registers  packed double", haddpd,  halves   of each of the summation  implemented   the 4 parts of  was using addpd  xmmO-xmm4. Following  this  was used to  add  instruction  to get the  registers  the formula presented  earlier.  of size 10000,   this program   step of this process   correlations   used   which is approximately   1 1 .8 GFLOPs. Now this is pretty   point results   since the CPU operates   6.74 seconds  impressive  floating  SSE instructions  was  of-order  cycle.   per cycle.  completing   execution  and   completing   at 3.4 GHz. It produced   about 3.5  This means that more than one of the  out­ at once. The CPU is performing  per   more than one SSE instruction   19.3 Implementation using AVX instructions   a new collection   called  "Ad­ or AVX. For these instructions   of instructions   an extension   named ymmO through   ymm1 5  is provided   along with   The YMM registers  values in each one. This allowed   are  256   bits each and can   a fairly easy   to operate   on 4 values   at once.   The Core i7 CPU implements  vanced Vector Extensions"  of the  XMM registers  some new instructions.  hold 4 double precision  adaptation   of the SSE function  to providing  of existing   instruct  In addition  added versions  source  operands   the larger   registers,   the AVX instructions   and a destination   ions which allowed  which did not participate   using 3 operands:  as a source   2    212   CHAPTER 19. COMPUTING CORRELATION   you named the same register    unless  structions are prefixed  with the letter  reduces  an instruction   the register   pressure   and allows   Here is the AVX version   while preserving their  of the corr function:   values.   twice . The  AVX versions  "v" . Having 3   operand   of in­  instructions   using two registers as sources   in   segment . text  global corr   rdi, rsi ,  rdx, rex, r8, r9   rdi: x array  rdi: y array  rex: loop counter  rdx: n  ymmO: 4 parts of sum_x  ymm1: 4 parts of sum_y  ymm2:  4 parts o f  sum_xx  ymm3: 4 parts of sum_yy  sum_xy  ymm4: 4 parts  of  ymm5: 4 x values -later squared  ymm6 : 4  y values -later squared  ymm7: 4 xy values   corr:   . more:   xor  r8, r8  mov  rex, rdx  vzeroall   vmovupd ymm5, [rdi+r8] mov x  vmovupd ymm6, [rsi+r8]  mov y  vmulpd ymm7 , ymm5, ymm6  xy  vaddpd ymmO, ymmO, ymm5  sum_x  vaddpd ymm1, ymm1, ymm6  sum_y  vmulpd ymm5, ymm5, ymm5  XX  vmulpd ymm6, ymm6, ymm6  yy  vaddpd ymm2, ymm2, ymm5  sum_xx  vaddpd ymm3, ymm3, ymm6  sum_yy  vaddpd ymm4, ymm4, ymm7  sum_xy    1 9.3. I.lVIPLEMENTATION USING AVX INSTRUCTIONS  213   mov x  mov y  xy  sum_x  sum_y  XX  yy  sum_xx  sum_yy  sum_xy   ymm13, [rdi+r8+32]  ymm14, [rsi+r8+32]  ymm15, ymm13, ymm14  ymm8, ymm8, ymm13  ymm9, ymm9, ymm14  ymm13, ymm13, ymm13  ymm14, ymm14, ymm14  ymm10, ymm10, ymm13  ymm11 ,  ymm11, ymm14  ymm12, ymm 1 2, ymm15  r8, 64   vmovupd  vmovupd  vmulpd  vaddpd  vaddpd  vmulpd  vmulpd  vaddpd  vaddpd  vaddpd  add  sub  rex,  8  j nz  . more  vaddpd ymmO,  ymmO ,  ymm8  vaddpd ymm1, ymm 1, ymm9  vaddpd ymm2, ymm2, ymm10  vaddpd ymm3, ymm3, ymm11  vaddpd ymm4, ymm4, ymm12  vhaddpd ymmO, ymmO, ymmO  vhaddpd ymm1, ymm1, ymm1  vhaddpd ymm2, ymm2,  ymm2  vhaddpd ymm3, ymm3, ymm3  vhaddpd ymm4, ymm4, ymm4  vextract vaddsd xmmO, xmmO, xmm5  vextract vaddsd xmm1 , xmm1 , xmm6  vmulsd xmm6, xmmO, xmmO  vmulsd xmm7, xmm1, xmm1  vextract vaddsd xmm2, xmm2, xmm8  f128 xmm9, ymm3,  1  vextract vaddsd xmm3, xmm3,  xmm9  cvtsi2sd xmm8, rdx  vmulsd xmm2, xmm2, xmm8  vmulsd xmm3, xmm3, xmm8  vsubsd xmm2, xmm2, xmm6   f 128 xmm8, ymm2,  1   f 1 28 xmm6, ymm1,  1   f 1 28 xmm5, ymmO,  1   sum_x  sum_y  sum_xx  sum_yy  sum_xy   sum_x*sum_x  sum_y*sum_y   n  n*sum_xx  n*sum_yy  n*sum_xx-sum_x*  sum_x    214   CHAPTER 19. COMPUTING CORRELATION   vsubsd xmm3, xmm3, xmm7  n*sum_yy-sum_y*sum_y  vmulsd xmm2, xmm2, xmm3  denom*denom  vsqrtsd xmm2, xmm2, xmm2  denom  vextract f 128 xmm6, ymm4, 1  vaddsd xmm4, xmm4, xmm6  vmulsd xmm4, xmm4, xmm8  n*sum_xy  vmulsd xmmO , xmmO, xmm1  sum_x*sum_y  vsubsd xmm4, xmm4, xmmO  n*sum_xy-sum_x* vdivsd xmmO, xmm4, xmm2  correlation  ret   sum_y   is accumulating   8 partial  unfortunately   did  not  it summed the first 2  values   and summed the last 2 values and   and left that sum in the  left that sum   sums for each required  sum.   sum all 4 values in a   Now the code   The vhaddpd instruction  register.  Instead  lower half  of the register  in the upper half  field", vextract the lower half of a register   of the register.  f 128, instruction   It was necessary  to move the   top half of these sums into   to use  "extract   128 bit   to prepare   for adding the 2 halves.   When tested   with one million   correlation  on 10000   calls to compute  used 3.9 seconds   6 floating  The code had many instructions   pairs of values, the AVX version  GFLOPs. This is achieving  clock cycle.  the CPU did an excellent  sets of accumulation  registers  dependency   job of out-of-order   an average of   which helped   which amounts   to 20.5  point results  in each  and   which did 4 operations   the CPU perform more instructions   in parallel.   execution.   The use of 2   most likely  reduced  the   inter-instruction    19.3. IMPLEMENTATION USING AVX INSTRUCTIONS  215   Exercises   1 .  Write an SSE function   to compute   the mean and standard   deviation   of an array of doubles.   2. Write a function   to perform  relating two   function   sequences   of doubles   in 2 arrays.   a least  squares   fit for a polynomial    216   CHAPTER 1 9. COMPUTING CORRELATION    Appendix A   Using gdb   http: I  www. gnu. org. It supports   a variety   including   is a product   The gdb debugger  site is  C, C++, Fortran,  and C++, and debugging   of the Free Software   whose web   Foundation  of languages  seems best suited   for  C   and assembly.   The debugger   gdb keeps track of source code   shortcoming   code from yasm is less than ideal.   at this point  is that yasm doesn't   lines quite well for yasm programs . Its  provide  type  of variables  which  though  adequately  do type casts to examine variables   It does provide   the address   for variables.   primary  information  allows  this requires  informat  ion.   the user to   more effort than if the assembler   provided   complete  type   One saving feature of gdb is  its  ate macros which transparently  easier.  The  process.   author has written   macro facility.   It  is  possible  to   cre­  perform type casts and make debugging  bash awk scripts   which automate  this   More extensiv  e documentation   can be found at   http:  sourceware.org gdb current onlinedocs gdb.   for gdb  A . l  Preparing   In order for gdb to be cognizant  must be  compiled  with  formation  to  the  object  code.  enable   your  code  symbol in­ With gee or g++ the -g option is used to   code and variables,  which add debugging   With yasm you also use -g but you must spec-  special  options   debugging   support.   of source   217    218   APPENDIX A. USING GDB   format which can be either   dwarf2 or stabs for Linux or   The dwarf2 option   provides   the most   ify a debugging  cv8 for Microsoft Visual Studio.  complete   compatibi  lity.  developed   called   The  author  has   each object file on the link   yld to be used for linking  ygcc for linking  the program and also  examine  .asm files, they examine  ts. For each variable  a macro which is placed   a script  when using _start for the start of  when using main. These scripts  line and, for those with matching  to locate  statemen assembly  produce  file  name beginning  initialization  file is named based on  of the link command. For example,  the init file is named " . array. gdb". Here is an example  file:   the .asm file  defined in the  with "."  which is used when debugging.  The gdb   data definition  code, the scripts   is named "array",  of an init macro   if the executable   the executable   the -o option   in  a hidden   named by   break main  macro def ine  a    unsigned char *  &a   macro define b    int *   &b   macro def ine  c    long *   &c   macro define s    unsigned char *   &s   macro define next    short *   &next   macro define val    unsigned char *   &val   macro define f    float *   &f   macro define d    double *   &d    the debugger.   The  first   upon entering   immediately   macros with the same name as variables   line of the init file sets a break on main so that you are  The  from the  to convert  the   lines create  code. Each of these macros uses a type  cast  the variable to a pointer   ready to start debugging  remaining  assembly  address of  the variable  a short.  can also use next [0], next [1], next [2], ... to access  Without  word integers.   using *next to get the value next points   using the init file, gdb will think   of the proper   name to get  the   the variables   For example   This allows   array elements.   pointer.   that all   to. You   are double   type. This allows using   next is a pointer  to    A.2. STARTING   219   A.2 Starting   The typical   way to start   gdb is   gdb program   where program  was linked. The author  similarly   is the name supplied  has prepared   in the -o option  a script   when the program  named ygdb which is invoked   ygdb program   This script  and execute   runs gdb  the commands   in the init   file.   using the -x . program. gdb option   to have gdb read   A.3 Quitting   running   The command to quit is quit which can be abbreviated  started  your program  inform you that the program  the process.   and  the  is still  the process   as q. If you have  gdb will  running,  to kill   and ask if you  wish   Enter "y" to kill   running   program   is still   and exit.   A.4 Setting break points   You can set a breakpoint  be  abbreviated  from the source   as "b". You  can  code or using a line number   set  the   either   of the file.   using the "breakpoint" command which can   breakpoint   using a label   b main  b 17   A.5 Running   of a program   as "r". If you are in the middle   You start the execution  abbreviated  will prompt you for confirmation  over.   in gdb using "run" which  can   of running   your program,   be  gdb   before killing   the process   and starting    220   APPENDIX A. USING GDB   If you   the debugger will   execute   have set a break point,  control   return   to the break point and then  you can examine  or do any gdb command.  will run to completion or until  be  a convenient   step through  a break  point,  a fault. This can  like segmentation   registers,  examine   If you have not  set   it experiences   to the debugger.   memory,   faults.   up   statements  At this point  lines of code,  the program   sometimes   While debugging   way to learn about problems  options  until completion   you have several  continue   execution   for continuing   execution.   or another break   This is done using the "continue" command which can   The first option is to  point is reached.  as "c" . .   be abbreviated   Another   possibility   is to "single  step"   through your program.  Here  execute   one machine   instruction   one source code state­  instruction.   In C C++ you probably   there are 4 options. First you can either  ment  or  fer not to step one machine  only within the same function or step into other functions  are called.  "next instruct same thing.  the debugger  debugger   at a time. You can also debug  when they  is done using "next" or  do the  "next"  returning  to the   These can be  abbreviated  all calls to functions  will execute  from the functions.   code the two instructions  as "n" or "ni". If you use   until returning   ion" . With assembly   in the same function   stepping   without   Single   would pre­  The alternative  choice   is  to use the "step" or "stepinstruction"   one source code statement   either   execute   commands   instruction   and allow debugging   command.  These  or one machine  They can be abbreviated  same effect with assembly  using "step" to debug you called  would probably  ever, you might wish to use "next" to step "through"  like printf.   code. If you write   inside   prefer   as "s" or "si". The two commands   a called   functions. How­  function.  have the  you   your own functions,   a call to a function   A.6 Printing a trace of stack frames   It's fairly common to have programs  typical   occurrence.   die while executing. Below is a fairly   seyfarth@tux: - teaching asm$ .  testcopy  Segmentation fault    A.6. PRINTING A TRACE OF STACK FRAMES   221   A segmentation fault is generally  tries to access  could be caused by going past the end of the array. Here is  running   memory which it has not mapped into the program.  This  a sample from   a error in coding where your program   gdb with this program.   Reading symbols from  home seyfarth teaching asm testcopy . . .    gdb  run  Starting program:  home seyfarth tea  ching asm testcopy   Program received signal SIGSEGV, Segmentation fault.  copy_repb      at copy. asm :12  rep movsb  1 2    gdb  bt       at copy. asm :1 2   0 copy_repb   1  Ox000000000040097e   in test  argc=<value   argv=<value   optimized out>  at testcopy. c : 27   optimized out>,   2 main  argc=<value   optimized out>, argv=<value   optimized   at testcopy . c : 4  5   Once again we get the segmentation fault, but immediately  we   function   died in the copy_repb   that the program  copy. asm. It was executing  goes backwards through the  copy _repb was called  The optimization  the backtrace command could not follow. I  recompiled  with  than -03 and got   rep movsb. The "bt" command  backtrace It reports  that  stack frames for function  from main.  level was high enough that there were variables  which   more interesting   by the test function   which was called   results:   -01 rather   calls.   see  on line 12 of the file       gdb  run  Starting   program :  home seyfarth teaching asm testcopy   Program received signal SIGSEGV, Segmentation fault.  copy_repb      at copy. asm :12  rep movsb  12   gdb   bt  0  copy_repb   1  Ox00000000004006d8 in test  name=Ox400b7d  " rep movsb",        at copy. asm :12   copy=Ox400930    , a=Ox7ffff7 ed2010 '"'    222   APPENDIX A. USING GDB   11 11  b=Ox7ffff7953010   count=100  at testcopy . c : 27   2 Ox000000000  04008d5   in main  argc= ,   argv=<value   optimized out>  at testcopy. c: 45   At this point it is possible   to print  the   values of variables   and list   code from copy. asm. We can also use the "up" command to move up  the  stack frame to the   function.   previous    gdb  up   1  Ox00000000004006d8   11 11,  copy=Ox400930  , a=Ox7ffff7ed2010  b=Ox7ffff7953010   in test  name=Ox400b7d  1111,  count=100  at testcopy. c: 27   11rep movsb11 ,   copy   a , b ,10000000 ;   27   gdb  p  a  $ 1  =  unsigned  char   *    Ox7ffff7ed2010 1111   At this point we are debugging   the test function  to copy was 10000000 while the   of test copy. c .  The   array sizes   were 1000000.   you can gain a lot of insight   from the stack frame trace.   third parameter  Frequently   A .  7 Examining registers   You can use the  This can be abbreviated   as "i r":   "info registers"   in gdb to print the integer   registers.    gdb  i  r  rax  rbx  rex  rdx  rsi  rdi  rbp  rsp  r8  r9  r10  r11   OxO 0  Ox64 100  Ox891690 8984208  Ox989680  10000000  Ox7ffff7a4b000 140737348153344  Ox7ffff7fca000 1407373539 16416  Ox7fffffffe6 Ox7fffffffe690 Ox7fffff ffe690  Ox64 100  OxO 0  Ox7fffffffe3f0 140737488348144  Ox206 5 1 8    a0 Ox7fffffffe6a0    A.B. EXAMINING MEMORY   223   r12  r13  r14  r15  rip  eflags  es  ss  ds  es  f s   gs   4196656   Ox40093f       Ox7ffff7ed2010 140737352900624  Ox400930  Ox64 100  Ox3 3  Ox40093f  Ox10206 [ PF IF RF ]  Ox33 51  Ox2b 43  OxO 0  OxO 0  OxO 0  OxO 0   This prints   out all the general purpose   registers,   the flags register,   the   segment   pointer   and size segment   registe registers since   instruction  ignored  they aren't needed in 64 bit coding.  using "info all"   or "i all"  .  This would take up much space and has not been illus­ trated.   You can print these plus the floating   point registers   rs. This book has basically   More commonly   to examine  do this using "print $rex" to print register  "print"  as "p".   you might  wish   one register.  You can   rex. You can abbreviate   The default print format is decimal   use "p x  $rex"   to print in hex­    gdb   p $rex  $1 = ·8984208   adecimal  :    gdb  p x $rex  $2  = Ox891690   A.8 Examining memory   of gdb without   by yld or ygee is different   The behavior  created  would print the value of  given a command like "print x". Using the type casting  prints   the use of the macros in the gdb init file  gdb  variables. By default  in memory   a double word at a variable's location   the variable's address   for printing   macros,   instead.   gdb    224   APPENDIX A. USING GDB   So  to print a single   array element, you  could  use   "print *x", or   "print x [0]" .  If x is an array,  You can print any location  gdb also has an "examine"   then array notation  command  abbreviated   from the array x.   "x"   which can be   makes more sense.   multiple   memory locations  . You enter the command like   used to examine  "x 100 x" to print 100 locations  append a format letter. Using x for the format letter  c means character, b means binary and  command needs an expression  what you get with a variable name with the gdb init file macros.  Without  these macros you would need to  command like "x  1 OOx &x" .   of the x array. After the number you can  means hexadecim al,  s means string.  The examine  to a memory location.   take the  address   of the variable as in a   evaluating   This is    Appendix B   Using scanf and printf   The simplest  and print£ functions.  of text  input  format.   method for input   and output is using the C library's   scan£  can handle virtually  all forms  and floating   to from integer   point   and output converting   These functions   with C++ 1 0 and  are familiar  call C++ 1 0 facilities,  while it   a need for  a slight   of C 1 0:  scan£ and print£.   It may be that modern programmers   C functions.   So there is probably   not with C. It would not be simple to  is simple  to  call  2  basic  introduction  to  the  for the 1 0 needs for learning  These are sufficient  Practical  or bit manipulating  will stick  appendix  while learning  assembly   functions  to the basics to   programming.   with no requirement   uses of assembly   workhorses   facilitate   language   will likely   writing   for 1 0. Therefore this   complete   programs   assembly   language.   be writing   computational   B . l  scanf   how to use scan£ is to show  C calls,   with a format  string   way of explaining   equivalents. scan£ is called  Depending  ry number of additional   The simplest  followed by assembly  as its first parameter.  arbitra a series  followed  are the basic format specifiers:   of conversion specifiers.  defining  by one of more letters   Each specifier   on the format  string   there can be an   parameters. Within the format string  are   is a percent   character   the type of data to   convert . Here   225    226   APPENDIX B. USING SCANF AND PRINTF   format data type   %d  4 byte integer  %hd 2 byte integer  %ld 8 byte integer  %f 4 byte floating  %If 8 byte floating  %s character   point  point   array   C string   by a character   string we   could use   So if we wish to read a double  the format string   " %lf %s" .   Each additional   parameter   followed   to receive   the data read and converted by scanf. Here is a sample C call:   for scanf is an address   of the data location   double x ;   char s [100];  n =  scanf    "%lf %s, &x,  s   ;    scanf will return   the number of items converted. In the call above it   will return  will be placed   2 if a number and a string   entered.  in the array s with a 0 at the end of the string.   are successfully   The string   Here is how to do the same thing in assembly:   segment . data  dq  0 . 0   dd  0  t imes 100 db  0   X  n  s  fmt  db  "%lf %s" , 0  ·   segment . text  l ea  rdi, [fmt]  l ea  rsi ,  [x]  l ea  rdx, [s]  xor eax, eax no f loating point parameters  call scanf  mov  [n], eax   There are a couple   of pitfalls possible.   First the format string   needs a   0 at the end and it can't be enclosed  are no floating  stored   -&x is a address  call.   in rsi so rax must be set to 0 before the   point  parameters   in the  double  quotes.   Second there   parameter  and   it is    B.2. PRINTF   B.2 printf   227   a wide variety of formats. Like scanf its   is a format string.   The format string   contains   charac­  print along with conversion specifiers   like scanf. Data printed   printf allows printing  in  first parameter  ters  to  with printf is likely  is printed.  end of the format string.  necessary  strings,   In C, the new-line   to be stored   so it  is   Here is a C print£   call   character can   in a buffer until a new-line  as \n at the  be represented  in   yasm does not support  to explicitly   add new-line   C escape characters   OxOa  and 0 bytes.   character   char name[64];  int value;  printf   " The value of %sis %d\n", name, value  ;    Here is the   same print£   call in assembly   segment . data   value dd  0  name t imes 64 db 0  fmt db  " The value of %s is %d", Ox0a, O    segment . text  lea rdi, [fmt]  lea rsi ,  [name]  mov  edx, [value]  xor eax, eax  call printf   printf can have floating  point   parameters,   so be careful   to count   them and set rax appropriate  ly.    228   APPENDIX B. USING SCANF AND PRINTF    Appendix  C   Using macros in yasm   both single   yasm provides  these  can  commonly  of assembly  utility   in practica  be used to provide  used instructions.  language   l situations.   line  macros   and multi-line   macros.   abbreviations   with meaningful   Both of  names for   While these might obscure   the mechanisms   while learning   the language   they can be  nt   of significa  C . l  Single line macros  A single  tired of seeing  for this as   line macro uses the %def ine   OxOa for the new-line   %define   newline   OxOa   preprocessor.  character.   you are  You could define  a macro   Let's suppose   From that point forward you could simply use newline  inserted  Single   line macros can have parameters.   in replacement for the macro.   OxOa  and get   Let's suppose  You might wish to compare   you wanted  a value in  a   to define a while  loop  macro.  register against  a  value and if a condition  the loop. Here is a possible   while macro:   is satisfied   jump  to the top of   %define   while  cc ,label  j mp%+cc label   The%+ allows  code like   concatenation   of tokens. After this definition   we could use   229    230   APPENDIX C. USING MACROS IN YASM   cmp rax, 20  while  l, . more    C . 2  Multi-line macros  Using a multi-line  required   cmp instruction:   %macro while 4   cmp %1, %3  j %2 %4   %endmacro   macro can simply our while macro to include  the   on the %macro line suggests  as %1, %2,  etc.   are expected.  You can even access  the   that 4 parameters   each parameter   The number 4  You can access  number of parameters  Now this definition   as %0.  leaves   the fairly pleasant   feel  of creating   an in­  struction,   since the macro invocation   does not use parentheses:   while rax, l ,  20, . more   this creates   Admittedly  learned,   an instruction  things  How about the standard   with 4 parameters  bit.  a little  of a stack frame:   but it simplifies   production   which must be   %macro function   2   global %1   % 1: push rbp   mov  rbp , rsp  sub  rsp, %2   %endmacro   %macro return 1   mov  rax, %1  leave  ret   %endmacro   We might as well simplify   the ending of a function:    C.2. MULTI-LINE MACROS   231   Now we can write a simple   program   using both macros   function main, 32  xor eax, eax   . loop inc rax   while rax, l ,  10, . loop  return 0   A fairly useful pair of macros from   and mul tipop. These were used earlier  sense to have a pair of macros  to  for use in register   intensive   functions.   the yasm manual are multipush  in the Sobel example.  callee-sa  ve registers   It makes   push and pop  all   %macro  pushsaved   push rbp  push rbx  push r12  push r13  push r14  push r15  %endmacro   %macro popsaved   pop r15  pop r14  pop r13  pop r12  pop rbx  pop rbp  %endmacro   Now these don't preserve   16 byte stack alignment,   choice would  the creation  subtracting  local variables.   be needed for some functions.  of a stack frame with pushing  from  the   stack pointer   so perhaps   a better  Maybe you could combine  of the registers   the  rest   and  and room for   to  achieve   alignment    232   APPENDIX C. USING MACROS IN YASM   C.3 Preprocessor variables   defining   yasm allows  using %assign. You could assign  later:   preprocessor   variables  a variable   which can be used in macros  i in one  spot   and modify it   %assign i  1   %assign  i i+1   For more information about yasm macros consult   the yasm web site as   http:  www. tortall.net proj ects yasm manual html index.htmlwhich  discusses   like looping   and string   topics   length.    Appendix D   Sources for more  information   D . l  yasm user manual   http:  www .tortall.net proj the location  reference   of the yasm user manual.  more about yasm.   for learning   ects yasm manual html index. html is   This is quite extensive   and a good   D . 2  nasm user  manual   Look at http: I  www. nasm. us  doc  for the nasm user manual.  software  to the yasm manual.   which nasm is based on and the documentation   This is the   is fairly similar   D.3 Dr. Paul Carter's free assembly   book   Dr. Carter has prepared  which can   be downloaded   an excellent  book  on  at http: I  www. drpaulcarter . com pcasm .   32 bit x86  programming   D.4 64 bit Machine Level Programming   Drs. Bryant and O'Hallaron  lent treatise  dissecting   of Carnegie   Mellon have provided   an excel­  how gee takes advantage   of the x86-64   architecture   233    234  APPENDIX D. SOURCES FOR MORE INFORMATION   in  a document located  http:  www . cs . cmu.edu -fp courses  15213-s07 misc asm64-handout. pdf.   at   D . 5  GDB Manual   You may find a need to learn more about gdb. Send your browser  http:   www. gnu.org software gdb do  cumentati on .   to   D . 6  DDD Manual   The ddd manual is located   at http:   www. gnu.org s ddd manual .   D . 7  Intel Documentation·   Intel provides  http:  www .intel.com product  excellent   s processor manuals .   documentation   about  their  at   processors   You should probably   review the architecture   in "Intel 64 and IA-32   Developer's Manual, Volume 1: Basic A rchitec­  Architectures  Software  tures"   are described   The instructions   in " Volume 2A: Instruc­ tion Set Reference, A-M' and " Volume 2B: Instruction Set Reference,  N-Z'. These manuals  tions would help. There  are  looking through   list can be overwhelming.   an alphabetized   are very useful, but some categorization  of instruc­  a bewildering number of   in great detail   instructions   and    Index   _start, 7, 8   486, 115  8087, 115  8088, 115   add, 47,  52  Adler-32, 1 12  and, 62  array, 99   86   cld -clear direction,  close,  135  cmov, 57  command line, 109  comment,  7  conditional  jump,  73  move, 57  conditional  correlation,  207  CR3, 37  cv8, 218   ddd, 8  dec, 54  decimal   number  to binary,  1 1 ,  13   div, 57  do-while  dwarf2, 8, 218   loop, 80   echo, 9  el£64, 8  else, 75  equ, 96, 132  equate,  exclusive  or, 64   96,  132   computation,   99   address  index,   99   Atlas,  3   base case, 94  binary constant, 13  binary number, 4, 1 1    to decimal,   1 1    bit, 4   numbering,   11   bit field, 66, 68  bt -bit test, 67  btr - bit test and reset, 67  bts -bit test and set, 67  byte, 4   cache,  43  call instruction,  90  carry flag, 56  checksum,  1 12   for loop, 82  format string,  function,   225   89   parameters,   91   235    236   INDEX   return   value, 91   gee, 8  gdb, 8, 45, 47, 53, 54, 100, 217   46   46  220  34   breakpoint,  continue,  examine,  list,  next, 220  nextinstruction,  print, 32, 46  quit, 219  run, 46, 219  single   step, 220   46, 220   5   language,   machine  main, 8  malloc, 104  memory page, 5  most significant  mov   bit, 1 1    to register,   45   46   from memory,  immediate,  register  49  sign extend,  48  to memory,  49  zero extend, 48   7   global,  goto,  71   heap, 29  hexadecimal  ,  5   idiv, 57  if, 74  immediate,  imul, 55  inc, 52  instruction,   45   5   jmp, 71   kernel, 129  kernel mode, 129   mul, 55   nasm, 8  neg, 51  not, 61   open, 132  or, 63  overflow, 52, 54, 56   38, 39  table,   pointer  table,   page directory  page directory  39  page table,  39, 40  permissions,  132  physical  address,  PML4, 37, 38  pop, 90  printf,  pseudo-op,  7  push,  89   225, 227   37, 40   large page, 40  ld, 8  least significa lodsb,  loop instruction,  lseek,   nt bit, 1 1    82   84   134   random,  104  read, 133  recursion,  register,   94  4, 43   r15, 44    INDEX   237   r8, 44   virtual   address,   37   while loop, 76  write,  133   xor, 64   yasm, 8  ygcc, 218  ygdb, 219  yld, 218   zero flag, 51, 52, 54, 57, 73   preserva  tion, 94   register  rep, 83   cmpsb, 86  movsb, 84  scasb 85  stosb,  84   '   91   address,   repeat,  83  ret - return,  return  rflags,  43,  rip, 43, 72  rotate,  67   44, 52   90   scanf,  225  segment  .bss,  .data,  21, 29  .text,  7  stack,  29   29   set, 67  shift, 65  sign flag, 5 1 ,  52, 54, 57, 73  Sobel,  197  SSE, 1 15  stabs,  218  stack,  89  stack frame, 92  status,  std -set direction,  Streaming SIMD Extensions,  struct,  sub, 54  system call, 129   1 1 5    137   86   9   TLB, 40, 41  transla  tion lookaside   buffer, 40    can be obtained at www.ICGtesting.com   the USA   CPSIA information  Printed in  LVOW071558250312  274684LV00005B 17 P   II 1 11 111   9 781466 4 70033     Con1puters have reached the linlits   of 32 bit CPUs. Nearly  any conl­  puter will run tnore efliciently with 8 gigabytes  using a 64 bit operating systern.   of IZ.AM  which requires   The latest Intel andAMD CPUs have tnore registers   and n1ore capabili­  ties when  and AVX instructions   running in 64 bit tnode.   dictates   Achieving high perfornunce using SSE   using or writing code in assetnbly language.   If you know C or C++, this book will expand  your code.   ing exactly what your con1pilcr does  with   your skills while clarifY­  The book progresses fron1 sin1plc concepts to loops, functions,   arrays,   system calls and using C  library   structs,  include data structures  programn1ing using SSE and AVX instructions.   tl.mctions. Advanced features   in assembly and exarnples  of   high perfonnancc   II GET THE MOST OUT OF YOUR COMPUTER II   Dr. Seyfarth began his career as a scientific progran1n1er in re­  NASA in 1977, using Fortran  nlote sensing and image processing at  and Assen1bly Language on a variety of 16 and 32 bit computers.  He earned his Ph.D. in Con1puter Science at the University  FLorida in 1989. Since 1990 he has been  a professor at the Uni­ versity of Southern Mississippi.   of   At Southern Miss Dr. Seyfarth teaches Assen1bly Language,   C++ ,  Algorithms, UNIX, Network Progran1ming, Parallel  gorithnls and Con1puter Graphics using OpenGL. His recent  research  and network server  design.   efforts have been in in1age processing   Al­  ISBN 9781466470033   90000 >   9 781

@highlight

This book is an assembly language programming textbook introducing programmers to 64 bit Intel assembly language. The book is intended as a first assembly language book for programmers experienced in high level programming in a language like C or C++. The assembly programming is performed using the yasm assembler (much like the nasm assembler) under the Linux operating system. The book primarily teaches how to write assembly code compatible with C programs. The reader will learn to call C functions from assembly language and to call assembly functions from C in addition to writing complete programs in assembly language. The gcc compiler is used for C programming. The book starts early emphasizing using the gdb debugger to debug programs. Being able to single-step assembly programs is critical in learning assembly programming. Highlights of the book include doing input/output programming using the Linux system calls and the C library, implementing data structures in assembly language and high performance assembly language programming. A companion web site has a collection of PDF slides which instructors can use for in-class presentations and source code for sample programs.