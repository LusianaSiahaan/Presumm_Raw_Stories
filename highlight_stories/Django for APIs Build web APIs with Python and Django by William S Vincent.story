Django for APIs  Build web APIs with Python and Django  William S. Vincent  This book is for sale at http:  leanpub.com djangoforapis  This version was published on 2020-08-13  This is a Leanpub book. Leanpub empowers authors and publishers with the Lean Publishing process. Lean Publishing is the act of publishing an in-progress ebook using lightweight tools and many iterations to get reader feedback, pivot until you have the right book and build traction once you do.    2018 - 2020 William S. Vincent   Also By William S. Vincent Django for Beginners  Django for Professionals   Contents  Introduction  Prerequisites Why APIs Django REST Framework Why this book Conclusion  Chapter 1: Web APIs World Wide Web URLs Internet Protocol Suite HTTP Verbs Endpoints HTTP Status Codes Statelessness REST Conclusion  Chapter 2: Library Website and API  Traditional Django First app Models Admin Views  1 1 2 3 4 4  5 5 6 7 8 8 9 11 12 12 13  14 14 17 19 21 24   CONTENTS  URLs Webpage Django REST Framework URLs Views Serializers cURL Browsable API Conclusion  Chapter 3: Todo API  Initial Set Up Models Django REST Framework URLs Serializers Views Consuming the API Browsable API CORS Tests Conclusion  Chapter 4: Todo React Front-end  Install Node Install React Mock data Django REST Framework + React Conclusion  Chapter 5: Blog API  Initial Set Up Model  24 27 28 29 30 31 32 33 34  36 36 40 42 44 45 46 48 48 50 53 54  56 56 57 59 63 66  67 67 68   CONTENTS  Tests Django REST Framework URLs Serializers Views Browsable API Conclusion  Chapter 6: Permissions  Create a new user Add log in to the browsable API AllowAny View-Level Permissions Project-Level Permissions Custom permissions Conclusion  Chapter 7: User Authentication  Basic Authentication Session Authentication Token Authentication Default Authentication Implementing token authentication Endpoints dj-rest-auth User Registration Tokens Conclusion  Chapter 8: Viewsets and Routers  User endpoints Viewsets Routers  72 73 74 76 77 78 82  83 83 86 90 92 94 95 99  100 100 102 103 105 106 108 109 114 118 123  125 125 131 132   Chapter 9: Schemas and Documentation  CONTENTS  Conclusion  Schemas Documentation Conclusion  Conclusion  Next Steps Giving Thanks  138  139 140 142 146  147 147 148   Introduction  The internet is powered by RESTful APIs. Behind the scenes even the simplest online task involves multiple computers interacting with one another.  An API  Application Programming Interface  is a formal way to describe two computers commu- nicating directly with one another. And while there are multiple ways to build an API, web APIs— which allow for the transfer of data over the world wide web—are overwhelmingly structured in a RESTful  REpresentational State Transfer  pattern.  In this book you will learn how to build multiple RESTful web APIs of increasing complexity from scratch using Django1 and Django REST Framework2, one of the most popular and customizable ways to build web APIs, used by many of the largest tech companies in the world including Insta- gram, Mozilla, Pinterest, and Bitbucket. This approach is also uniquely well-suited to beginners because Django’s “batteries-included” approach masks much of the underlying complexity and security risks involved in creating any web API.  Prerequisites  If you’re brand new to web development with Django, I recommend first reading my previous book Django for Beginners3. The first several chapters are available for free online and cover proper set up, a Hello World app, and a Pages app. The full-length version goes deeper and covers a Blog website with forms and user accounts as well as a production-ready Newspaper site that features a custom user model, complete user authentication flow, emails, permissions, deployment, environment variables, and more.  This background in traditional Django is important since Django REST Framework deliberately mimics many Django conventions.  1https:  www.djangoproject.com  2http:  www.django-rest-framework.org  3https:  djangoforbeginners.com    Introduction  2  It is also recommended that readers have a basic knowledge of Python itself. Truly mastering Python takes years, but with just a little bit of knowledge you can dive right in and start building things.  Why APIs  Django was first released in 2005 and at the time most websites consisted of one large monolithic codebase. The “back-end” consisted of database models, URLs, and views which interacted with the “front-end” templates of HTML, CSS, and JavaScript that controlled the presentational layout of each web page.  However in recent years an “API-first” approach has emerged as arguably the dominant paradigm in web development. This approach involves formally separating the back-end from the front- end. It means Django becomes a powerful database and API instead of just a website framework.  Today Django is arguably used more often as just a back-end API rather than a full monolithic website solution at large companies!  An obvious question at this point is, “Why bother?” Traditional Django works quite well on its own and transforming a Django site into a web API seems like a lot of extra work. Plus, as a developer, you then have to write a dedicated front-end in another programming language.  This approach of dividing services into different components, by the way, is broadly known as Service-oriented architecture4.  It turns out however that there are multiple advantages to separating the front-end from the back-end. First, it is arguably much more “future-proof” because a back-end API can be consumed by any JavaScript front-end. Given the rapid rate of change in front-end libraries– React5 was only released in 2013 and Vue6 in 2014!–this is highly valuable. When the current front-end frameworks are eventually replaced by even newer ones in the years to come, the back-end API can remain the same. No major rewrite is required.  Second, an API can support multiple front-ends written in different languages and frameworks. Consider that JavaScript is used for web front-ends, while Android apps require the Java  4https:  en.wikipedia.org wiki Service-oriented_architecture 5https:  reactjs.org  6https:  vuejs.org    Introduction  3  programming language, and iOS apps need the Swift programming language. With a traditional monolithic approach, a Django website cannot support these various front-ends. But with an internal API, all three can communicate with the same underlying database back-end!  Third, an API-first approach can be used both internally and externally. When I worked at Quizlet7 back in 2010, we did not have the resources to develop our own iOS or Android apps. But we did have an external API available that more than 30 developers used to create their own flashcard apps powered by the Quizlet database. Several of these apps were downloaded over a million times, enriching the developers and increasing the reach of Quizlet at the same time. Quizlet is now a top 20 website in the U.S. during the school year.  The major downside to an API-first approach is that it requires more configuration than a traditional Django application. However as we will see in this book, the fantastic Django REST Framework library removes much of this complexity.  Django REST Framework  There are hundreds and hundreds of third-party apps available that add further functionality to Django. You can see a complete, searchable list over at Django Packages8, as well as a curated list in the awesome-django repo9. However, among all third-party applications, Django REST Framework is arguably the killer app for Django. It is mature, full of features, customizable, testable, and extremely well-documented. It also purposefully mimics many of Django’s tra- ditional conventions, which makes learning it much faster. And it is written in the Python programming language, a wonderful, popular, and accessible language.  If you already know Django, then learning Django REST Framework is a logical next step. With a minimal amount of code, it can transform any existing Django application into a web API.  7https:  quizlet.com  8https:  djangopackages.org  9https:  github.com wsvincent awesome-django   Introduction  Why this book  4  I wrote this book because there is a distinct lack of good resources available for developers new to Django REST Framework. The assumption seems to be that everyone already knows all about APIs, HTTP, REST, and the like. My own journey in learning how to build web APIs was frustrating… and I already knew Django well enough to write a book on it!  This book is the guide I wish existed when starting out with Django REST Framework.  Chapter 1 begins with a brief introduction to web APIs and the HTTP protocol. In Chapter 2 we review the differences between traditional Django and Django REST Framework by building out a Library book website and then adding an API to it. Then in Chapters 3-4 we build a Todo API and connect it to a React front-end. The same process can be used to connect any dedicated front-end  web, iOS, Android, desktop, or other  to a web API back-end.  In Chapters 5-9 we build out a production-ready Blog API which includes full CRUD functionality. We also cover in-depth permissions, user authentication, viewsets, routers, documentation, and more.  Complete source code for all chapters can be found online on Github10.  Conclusion  Django and Django REST Framework is a powerful and accessible way to build web APIs. By the end of this book you will be able to build your own web APIs from scratch properly using modern best practices. And you’ll be able to extend any existing Django website into a web API with a minimal amount of code.  Let’s begin!  10https:  github.com wsvincent restapiswithdjango   Chapter 1: Web APIs  Before we start building our own web APIs it’s important to review how the web really works. After all, a “web API” literally sits on top of the existing architecture of the world wide web and relies on a host of technologies including HTTP, TCP IP, and more.  In this chapter we will review the basic terminology of web APIs: endpoints, resources, HTTP verbs, HTTP status codes, and REST. Even if you already feel comfortable with these terms, I encourage you to read the chapter in full.  World Wide Web  The Internet is a system of interconnected computer networks that has existed since at least the 1960s11. However, the internet’s early usage was restricted to a small number of isolated networks, largely government, military, or scientific in nature, that exchanged information electronically. By the 1980s, many research institutes and universities were using the internet to share data. In Europe, the biggest internet node was located at CERN  European Organization for Nuclear Research  in Geneva, Switzerland, which operates the largest particle physics laboratory in the world. These experiments generate enormous quantities of data that need to be shared remotely with scientists all around the world.  Compared with today, though, overall internet usage in the 1980s was miniscule. Most people did not have access to it or even understood why it mattered. A small number of internet nodes powered all the traffic and the computers using it were primarily within the same, small networks.  This all changed in 1989 when a research scientist at CERN, Tim Berners-Lee, invented HTTP and ushered in the modern World Wide Web. His great insight was that the existing hypertext12  11https:  en.wikipedia.org wiki Internet 12https:  en.wikipedia.org wiki Hypertext   Chapter 1: Web APIs  6  system, where text displayed on a computer screen contained links  hyperlinks  to other documents, could be moved onto the internet.  His invention, Hypertext Transfer Protocol  HTTP 13, was the first standard, universal way to share documents over the internet. It ushered in the concept of web pages: discrete documents with a URL, links, and resources such as images, audio, or video.  Today, when most people think of “the internet,” they think of the World Wide Web, which is now the primary way that billions of people and computers communicate online.  URLs  A URL  Uniform Resource Locator  is the address of a resource on the internet. For example, the Google homepage lives at https:  www.google.com.  When you want to go to the Google homepage, you type the full URL address into a web browser. Your browser then sends a request out over the internet and is magically connected  we’ll cover what actually happens shortly  to a server that responds with the data needed to render the Google homepage in your browser.  This request and response pattern is the basis of all web communication. A client  typically a web browser but also a native app or really any internet-connected device  requests information and a server responds with a response.  Since web communication occurs via HTTP these are known more formally as HTTP requests and HTTP responses.  Within a given URL are also several discrete components. For example, consider the Google homepage located at https:  www.google.com. The first part, https, refers to the scheme used. It tells the web browser how to access resources at the location. For a website this is typically http or https, but it could also be ftp for files, smtp for email, and so on. The next section, www.google.com, is the hostname or the actual name of the site. Every URL contains a scheme and a host.  Many webpages also contain an optional path, too. If you go to the homepage for Python  13https:  en.wikipedia.org wiki Hypertext_Transfer_Protocol   Chapter 1: Web APIs  7  at https:  www.python.org and click on the link for the “About” page you’ll be redirected to https:  www.python.org about . The  about  piece is the path.  In summary, every URL like https:  python.org about  has three potential parts:    a scheme - https   a hostname - www.python.org   and an  optional  path -  about   Internet Protocol Suite  Once we know the actual URL of a resource, a whole collection of other technologies must work properly  together  to connect the client with the server and load an actual webpage. This is broadly referred to as the internet protocol suite14 and there are entire books written on just this topic. For our purposes, however, we can stick to the broad basics.  Several things happen when a user types https:  www.google.com into their web browser and hits Enter. First the browser needs to find the desired server, somewhere, on the vast internet. It uses a domain name service  DNS  to translate the domain name “google.com” into an IP address15, which is a unique sequence of numbers representing every connected device on the internet. Domain names are used because it is easier for humans to remember a domain name like “google.com” than an IP address like “172.217.164.68”.  After the browser has the IP address for a given domain, it needs a way to set up a consistent connection with the desired server. This happens via the Transmission Control Protocol  TCP  which provides reliable, ordered, and error-checked delivery of bytes between two application.  To establish a TCP connection between two computers, a three-way “handshake” occurs between the client and server:  1. The client sends a SYN asking to establish a connection 2. The server responds with a SYN-ACK acknowledging the request and passing a connection  parameter  14https:  en.wikipedia.org wiki Internet_protocol_suite 15https:  en.wikipedia.org wiki IP_address   Chapter 1: Web APIs  8  3. The client sends an ACK back to the server confirming the connection  Once the TCP connection is established, the two computers can start communicating via HTTP.  HTTP Verbs  Every webpage contains both an address  the URL  as well as a list of approved actions known as HTTP verbs. So far we’ve mainly talked about getting a web page, but it’s also possible to create, edit, and delete content.  Consider the Facebook website. After logging in, you can read your timeline, create a new post, or edit delete an existing one. These four actions Create-Read-Update-Delete are known colloquially as CRUD functionality and represent the overwhelming majority of actions taken online.  The HTTP protocol contains a number of request methods16 that can be used while requesting information from a server. The four most common map to CRUD functionality. They are POST, GET, PUT, and DELETE.  Diagram CRUD ---- Create Read Update Delete           HTTP Verbs ---------- POST GET PUT DELETE  To create content you use POST, to read content GET, to update it PUT, and to delete it you use DELETE.  Endpoints  A website consists of web pages with HTML, CSS, images, JavaScript, and more. But a web API has endpoints instead which are URLs with a list of available actions  HTTP verbs  that expose  16https:  en.wikipedia.org wiki Hypertext_Transfer_ProtocolRequest_method   Chapter 1: Web APIs  9  data  typically in JSON17, which is the most common data format these days and the default for Django REST Framework .  For example, we could create the following API endpoints for a new website called mysite.  Diagram  https:  www.mysite.com api users https:  www.mysite.com api users    GET returns a single user   GET returns all users  In the first endpoint,  api users, an available GET request returns a list of all available users. This type of endpoint which returns multiple data resources is known as a collection.  The second endpoint  api users   represents a single user. A GET request returns informa- tion about just that one user.  If we added POST to the first endpoint we could create a new user, while adding DELETE to the second endpoint would allow us to delete a single user.  We will become much more familiar with API endpoints over the course of this book but ultimately creating an API involves making a series of endpoints: URLs with associated HTTP verbs.  A webpage consists of HTML, CSS, images, and more. But an endpoint is just a way to access data via the available HTTP verbs.  HTTP  We’ve already talked a lot about HTTP in this chapter, but here we will describe what it actually is and how it works.  HTTP is a request-response protocol between two computers that have an existing TCP connec- tion. The computer making the requests is known as the client while the computer responding is known as the server. Typically a client is a web browser but it could also be an iOS app or really any internet-connected device. A server is a fancy name for any computer optimized to work  17https:  json.org    Chapter 1: Web APIs  10  over the internet. All we really need to transform a basic laptop into a server is some special software and a persistent internet connection.  Every HTTP message consists of a status line, headers, and optional body data. For example, here is a sample HTTP message that a browser might send to request the Google homepage located at https:  www.google.com.  Diagram  GET   HTTP 1.1 Host: google.com Accept_Language: en-US  The top line is known as the request line and it specifies the HTTP method to use  GET , the path    , and the specific version of HTTP to use  HTTP 1.1 .  The two subsequent lines are HTTP headers: Host is the domain name and Accept_Language is the language to use, in this case American English. There are many HTTP headers18 available.  HTTP messages also have an optional third section, known as the body. However we only see a body message with HTTP responses containing data.  For simplicity, let’s assume that the Google homepage only contained the HTML “Hello, World!” This is what the HTTP response message from a Google server might look like.  Diagram  HTTP 1.1 200 OK Date: Mon, 03 Aug 2020 23:26:07 GMT Server: gws Accept-Ranges: bytes Content-Length: 13 Content-Type: text html; charset=UTF-8  Hello, world!  The top line is the response line and it specifies that we are using HTTP 1.1. The status code 200 OK indicates the request by the client was successful  more on status codes shortly .  18https:  en.wikipedia.org wiki List_of_HTTP_header_fields   Chapter 1: Web APIs  11  The next eight lines are HTTP headers. And finally after a line break there is our actual body content of “Hello, world!”.  Every HTTP message, whether a request or response, therefore has the following format:  Diagram  Response request line Headers...   optional  Body  Status Codes  Most web pages contain multiple resources that require multiple HTTP request response cycles. If a webpage had HTML, one CSS file, and an image, three separate trips back-and-forth between the client and server would be required before the complete web page could be rendered in the browser.  Once your web browser has executed an HTTP Request on a URL there is no guarantee things will actually work! Thus there is a quite lengthy list of HTTP Status Codes19 available to accompany each HTTP response.  You can tell the general type of status code based on the following system:    2xx Success - the action requested by the client was received, understood, and accepted    3xx Redirection - the requested URL has moved    4xx Client Error - there was an error, typically a bad URL request by the client    5xx Server Error - the server failed to resolve a request  There is no need to memorize all the available status codes. With practice you will become familiar with the most common ones such as 200  OK , 201  Created , 301  Moved Permanently , 404  Not Found , and 500  Server Error .  19https:  en.wikipedia.org wiki List_of_HTTP_status_codes   Chapter 1: Web APIs  12  The important thing to remember is that, generally speaking, there are only four potential outcomes to any given HTTP request: it worked  2xx , it was redirected somehow  3xx , the client made an error  4xx , or the server made an error  5xx .  These status codes are automatically placed in the request response line at the top of every HTTP message.  Statelessness  A final important point to make about HTTP is that it is a stateless protocol. This means each request response pair is completely independent of the previous one. There is no stored memory of past interactions, which is known as state20 in computer science.  Statelessness brings a lot of benefits to HTTP. Since all electronic communication systems have signal loss over time, if we did not have a stateless protocol, things would constantly break if one request response cycle didn’t go through. As a result HTTP is known as a very resilient distributed protocol.  The downside however is that managing state is really, really important in web applications. State is how a website remembers that you’ve logged in and how an e-commerce site manages your shopping cart. It’s fundamental to how we use modern websites, yet it’s not supported on HTTP itself.  Historically state was maintained on the server but it has moved more and more to the client, the web browser, in modern front-end frameworks like React, Angular, and Vue. We’ll learn more about state when we cover user authentication but remember that HTTP is stateless. This makes it very good for reliably sending information between two computers, but bad at remembering anything outside of each individual request response pair.  REST  REpresentational State Transfer  REST 21 is an architecture first proposed in 2000 by Roy Fielding  20https:  en.wikipedia.org wiki State_ computer_science  21https:  en.wikipedia.org wiki Representational_state_transfer   Chapter 1: Web APIs  13  in his dissertation thesis. It is an approach to building APIs on top of the web, which means on top of the HTTP protocol.  Entire books have been written on what makes an API actually RESTful or not. But there are three main traits that we will focus on here for our purposes. Every RESTful API:    is stateless, like HTTP    supports common HTTP verbs  GET, POST, PUT, DELETE, etc.     returns data in either the JSON or XML format  Any RESTful API must, at a minimum, have these three principles. The standard is important because it provides a consistent way to both design and consume web APIs.  Conclusion  While there is a lot of technology underlying the modern world wide web, we as developers don’t have to implement it all from scratch. The beautiful combination of Django and Django REST Framework handles, properly, most of the complexity involved with web APIs. However it is important to have at least a broad understanding of how all the pieces fit together.  Ultimately a web API is a collection of endpoints that expose certain parts of an underlying database. As developers we control the URLs for each endpoint, what underlying data is available, and what actions are possible via HTTP verbs. By using HTTP headers we can set various levels of authentication and permission too as we will see later in the book.   Chapter 2: Library Website and API  Django REST Framework works alongside the Django web framework to create web APIs. We cannot build a web API with only Django Rest Framework; it always must be added to a project after Django itself has been installed and configured.  In this chapter, we will review the similarities and differences between traditional Django and Django REST Framework. The most important takeaway is that Django creates websites containing webpages, while Django REST Framework creates web APIs which are a collection of URL endpoints containing available HTTP verbs that return JSON.  To illustrate these concepts, we will build out a basic Library website with traditional Django and then extend it into a web API with Django REST Framework.  Make sure you already have Python 3 and Pipenv22 installed on your computer. Complete instructions can be found here23 if you need help.  First, we need a dedicated directory on our computer to store the code. This can live anywhere but for convenience, if you are on a Mac, we can place it in the Desktop folder. The location really does not matter; it just needs to be easily accessible.  Traditional Django  Command Line $ cd ~ Desktop $ mkdir code && cd code  This code folder will be the location for all the code in this book. The next step is to create a dedicated directory for our library site, install Django via Pipenv, and then enter the virtual environment using the shell command. You should always use a dedicated virtual environment for every new Python project.  22https:  pipenv-fork.readthedocs.io en latest  23https:  djangoforbeginners.com initial-setup    Chapter 2: Library Website and API  15  Command Line  $ mkdir library && cd library $ pipenv install django~=3.1.0 $ pipenv shell  library  $  Pipenv creates a Pipfile and a Pipfile.lock within our current directory. The  library  in parentheses before the command line shows that our virtual environment is active.  A traditional Django website consists of a single project and one  or more  apps representing discrete functionality. Let’s create a new project with the startproject command. Don’t forget to include the period . at the end which installs the code in our current directory. If you do not include the period, Django will create an additional directory by default.  Command Line   library  $ django-admin startproject config .  Django automatically generates a new project for us which we can see with the tree command.  Note: If tree doesn’t work for you on a Mac, install it with Homebrew24: brew install tree.   Command Line   library  $ tree . ├── Pipfile ├── Pipfile.lock ├── config │ │ │ │ │ └── manage.py  ├── __init__.py ├── asgi.py ├── settings.py ├── urls.py └── wsgi.py  1 directory, 8 files  The files have the following roles:  24https:  brew.sh    Chapter 2: Library Website and API  16    __init__.py is a Python way to treat a directory as a package; it is empty   asgi.py stands for Asynchronous Server Gateway Interface and is a new option in Django    settings.py contains all the configuration for our project   urls.py controls the top-level URL routes   wsgi.py stands for Web Server Gateway Interface and helps Django serve the eventual web  3.0+  pages    manage.py executes various Django commands such as running the local web server or  creating a new app.  Run migrate to sync the database with Django’s default settings and start up the local Django web server.  Command Line   library  $ python manage.py migrate  library  $ python manage.py runserver  Open a web browser to http:  127.0.0.1:8000 25 to confirm our project is successfully installed.  25http:  127.0.0.1:8000    Chapter 2: Library Website and API  17  Django welcome page  First app  The typical next step is to start adding apps, which represent discrete areas of functionality. A single Django project can support multiple apps.   Chapter 2: Library Website and API  18  Stop the local server by typing Control+c and then create a books app.  Command Line   library  $ python manage.py startapp books  Now let’s see what files Django has generated.  Command Line  ├── __init__.py ├── admin.py ├── apps.py ├── migrations │ ├── models.py ├── tests.py └── views.py   library  $ tree . ├── Pipfile ├── Pipfile.lock ├── books │ │ │ │ │ │ │ │ ├── config ├── __init__.py │ ├── asgi.py │ ├── settings.py │ ├── urls.py │ │ └── wsgi.py ├── db.sqlite3 └── manage.py  └── __init__.py  Each app has a __init__.py file identifying it as a Python package. There are 6 new files created:    admin.py is a configuration file for the built-in Django Admin app   apps.py is a configuration file for the app itself   the migrations  directory stores migrations files for database changes   models.py is where we define our database models   tests.py is for our app-specific tests   views.py is where we handle the request response logic for our web app   Chapter 2: Library Website and API  19  Typically, developers will also create an urls.py file within each app, too, for routing.  Let’s build out the files so that our Library project lists out all books on the homepage. Open the text editor of your choice to the config settings.py file. The first step is to add the new app to our INSTALLED_APPS configuration.  Code   config settings.py INSTALLED_APPS = [  'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles',   Local 'books',  new  ]  Each web page in traditional Django requires several files: a view, url, and template. But first we need a database model so let’s start there.  Models  In your text editor, open up the file books models.py and update it as follows:   Chapter 2: Library Website and API  20  Code   books models.py from django.db import models  class Book models.Model :  title = models.CharField max_length=250  subtitle = models.CharField max_length=250  author = models.CharField max_length=100  isbn = models.CharField max_length=13   def __str__ self :  return self.title  This is a basic Django model where we import models from Django on the top line and then create a Book class that extends it. There are four fields: title, subtitle, author, and isbn. We also include a __str__ method so that the title of a book will display in the admin later on.  Note that an ISBN26 is a unique, 13-character identifier assigned to every published book.  Since we created a new database model we need to create a migration file to go along with it. Specifying the app name is optional but recommended here. We could just type python manage.py makemigrations but if there were multiple apps with database changes, both would be added to the migrations file which makes debugging in the future more of a challenge. Keep your migrations files as specific as possible.  Then run migrate to update our database.  26https:  www.isbn-international.org content what-isbn   Chapter 2: Library Website and API  21  Command Line   library  $ python manage.py makemigrations books Migrations for 'books':  books migrations 0001_initial.py  - Create model Book   library  $ python manage.py migrate Operations to perform:  Running migrations:  Applying books.0001_initial... OK  Apply all migrations: admin, auth, books, contenttypes, sessions  So far so good. If any of this feels new to you, I suggest you pause and review Django for Beginners27 for a more-detailed explanation of traditional Django.  Admin  We can start entering data into our new model via the built-in Django app. But we must do two things first: create a superuser account and update admin.py so the books app is displayed.  Start with the superuser account. On the command line run the following command:  Command Line   library  $ python manage.py createsuperuser  Follow the prompts to enter a username, email, and password. Note that for security reasons, text will not appear on the screen while entering your password.  Now update our book app’s admin.py file.  27https:  djangoforbeginners.com    Chapter 2: Library Website and API  22  Code   books admin.py from django.contrib import admin from .models import Book  admin.site.register Book   That’s all we need! Start up the local server again.  Command Line   library  $ python manage.py runserver  Navigate to http:  127.0.0.1:8000 admin and log in. You will be redirected to the admin homepage.  Click on the “+ Add” link next to Books.  Admin homepage   Chapter 2: Library Website and API  23  Admin add book  I’ve entered in the details for my Django for Beginners book. You can enter whatever text you want here. It’s purely for demonstration purposes. After clicking the “Save” button we are redirected to the “Books” page that lists all current entries.  Our traditional Django project has data now but we need a way to expose it as a web page. That  Admin books list   Chapter 2: Library Website and API  24  means creating views, URLs, and template files. Let’s do that now.  The views.py file controls how the database model content is displayed. Since we want to list all books we can use the built-in generic class ListView28.  Update the books views.py file.  Code   books views.py from django.views.generic import ListView from .models import Book  class BookListView ListView :  model = Book template_name = 'book_list.html'  On the top lines we’ve imported ListView and our Book model. Then we create a BookListView class that specifies the model to use and the template  not created yet .  Two more steps before we have a working web page: make our template and configure our URLs. Let’s start with the URLs.  We need to set up both the project-level urls.py file and then one within the books app. When a user visits our site they will first interact with the config urls.py file so let’s configure that first. Add the include import on the second line and then a new path for our books app.  28https:  docs.djangoproject.com en 3.1 ref class-based-views generic-display django.views.generic.list.  Views  URLs  ListView   Chapter 2: Library Website and API  25  Code  ]   config urls.py from django.contrib import admin from django.urls import path, include  new  urlpatterns = [  path 'admin ', admin.site.urls , path '', include 'books.urls'  ,  new  The top two lines import the built-in admin app, path for our routes, and include which will be used with our books app. If a user goes to  admin  they will be redirected to the admin app. We use the empty string, '', for the books app route which means a user on the homepage will be redirected directly to the books app.  Now we can configure our books urls.py file. But, oops! Django for some reason does not include a urls.py file by default in apps so we need to create it ourself. If you are on a Mac you can use the touch command; Windows users must create the file within the text editor.  Command Line   library  $ touch books urls.py  Now within a text editor update the new file.  Code  ]   books urls.py from django.urls import path from .views import BookListView  urlpatterns = [  path '', BookListView.as_view  , name='home' ,  We import our views file, configure BookListView at the empty string '', and add a named URL29 home as a best practice.  29https:  docs.djangoproject.com en 3.1 topics http urls naming-url-patterns   Chapter 2: Library Website and API  26  The way Django works, now when a user goes to the homepage of our website they will first hit the config urls.py file, then be redirected to books urls.py which specifies using the BookListView. In this view file, the Book model is used along with ListView to list out all books.  The final step is to create our template file that controls the layout on the actual web page. We have already specified its name as book_list.html in our view. There are two options for its location: by default the Django template loader will look for templates within our books app in the following location: books templates books book_list.html. We could also create a separate, project-level templates directory instead and update our config settings.py file to point there.  Which one you ultimately use in your own projects is a personal preference. We will use the default structure here. If you are curious about the second approach, check out the book Django For Beginners30.  Start by making a new templates folder within the books app, then within it a books folder, and finally a book_list.html file.  Command Line   library  $ mkdir books templates  library  $ mkdir books templates books  library  $ touch books templates books book_list.html  Now update the template file.  HTML        All books  {% for book in object_list %}   Title: {{ book.title }}   Subtitle: {{ book.subtitle }}   Author: {{ book.author }}   ISBN: {{ book.isbn }}      {% endfor %}  30https:  djangoforbeginners.com   Chapter 2: Library Website and API  27  Django ships with a template language31 that allows for basic logic. Here we use the for32 tag to loop over all available books. Template tags must be included within opening closing brackets and parentheses. So the format is always {% for ... %} and then we must close our loop later with {% endfor %}.  What we are looping over is the object containing all available books in our model courtesy of ListView. The name of this object is object_list. Therefore to loop over each book we write {% for book in object_list %}. And then display each field from our model.  Webpage  Now we can start up the local Django server and see our web page.  Command Line   library  $ python manage.py runserver  Navigate to the homepage which is at http:  127.0.0.1:8000 .  Book web page  If we add additional books in the admin, they will each appear here, too.  This was a very quick run-through of a traditional Django website. Now let’s add an API to it!  31https:  docs.djangoproject.com en 3.1 ref templates language  32https:  docs.djangoproject.com en 3.1 ref templates builtins std:templatetag-for   Chapter 2: Library Website and API  28  Django REST Framework  Django REST Framework is added just like any other third-party app. Make sure to quit the local server Control+c if it is still running. Then on the command line type the below.  Command Line  library  $ pipenv install djangorestframework~=3.11.0  Add rest_framework to the INSTALLED_APPS config in our config settings.py file. I like to make a distinction between third-party apps and local apps as follows since the number of apps grows quickly in most projects.  Code  config settings.py INSTALLED_APPS = [  'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles',   3rd party 'rest_framework',  new   Local 'books',  ]  Ultimately, our API will expose a single endpoint that lists out all books in JSON. So we will need a new URL route, a new view, and a new serializer file  more on this shortly .  There are multiple ways we can organize these files however my preferred approach is to create a dedicated api app. That way even if we add more apps in the future, each app can contain the models, views, templates, and urls needed for dedicated webpages, but all API-specific files for the entire project will live in a dedicated api app.  Let’s first create a new api app.   Chapter 2: Library Website and API  29  Command Line   library  $ python manage.py startapp api  Then add it to INSTALLED_APPS.  Code   config settings.py INSTALLED_APPS = [   Local 'books.apps.BooksConfig', 'api.apps.ApiConfig',  new   3rd party 'rest_framework',  'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles',  ]  URLs  The api app will not have its own database models so there is no need to create a migration file and run migrate to update the database.  Let’s start with our URL configs. Adding an API endpoint is just like configuring a traditional Django app’s routes. First at the project-level we need to include the api app and configure its URL route, which will be api .   Chapter 2: Library Website and API  30  Code  config urls.py from django.contrib import admin from django.urls import path, include  urlpatterns = [  path 'admin ', admin.site.urls , path 'api ', include 'api.urls'  ,  new path '', include 'books.urls'  ,  Then create a urls.py file within the api app.  Command Line  library  $ touch api urls.py  And update it as follows:  Code  api urls.py from django.urls import path from .views import BookAPIView  urlpatterns = [  path '', BookAPIView.as_view   ,  ]  ]  All set.  Views  Next up is our views.py file which relies on Django REST Framework’s built-in generic class views. These deliberately mimic traditional Django’s generic class-based views in format, but they are not the same thing.  To avoid confusion, some developers will call an API views file apiviews.py or api.py. Personally, when working within a dedicated api app I do not find it confusing to just call a Django REST Framework views file views.py but opinion varies on this point.   Chapter 2: Library Website and API  31  Within our views.py file, update it to look like the following:  Code   api views.py from rest_framework import generics from books.models import Book from .serializers import BookSerializer  class BookAPIView generics.ListAPIView :  queryset = Book.objects.all   serializer_class = BookSerializer  On the top lines we import Django REST Framework’s generics class of views, the models from our books app, and serializers from our api app  we will make the serializers next .  Then we create a BookAPIView that uses ListAPIView to create a read-only endpoint for all book instances. There are many generic views available and we will explore them further in later chapters.  The only two steps required in our view are to specify the queryset which is all available books, and then the serializer_class which will be BookSerializer.  Serializers  A serializer translates data into a format that is easy to consume over the internet, typically JSON, and is displayed at an API endpoint. We will also cover serializers and JSON in more depth in following chapters. For now I want to demonstrate how easy it is to create a serializer with Django REST Framework to convert Django models to JSON.  Make a serializers.py file within our api app.  Command Line   library  $ touch api serializers.py  Then update it as follows in a text editor.   Chapter 2: Library Website and API  32  Code   api serializers.py from rest_framework import serializers from books.models import Book  class BookSerializer serializers.ModelSerializer :  class Meta:  model = Book fields =  'title', 'subtitle', 'author', 'isbn'   On the top lines we import Django REST Framework’s serializers class and the Book model from our books app. We extend Django REST Framework’s ModelSerializer into a BookSerializer class that specifies our database model Book and the database fields we wish to expose: title, subtitle, author, and isbn.  That’s it! We’re done.  cURL  We want to see what our API endpoint looks like. We know it should return JSON at the URL http:  127.0.0.1:8000 api 33. Let’s ensure that our local Django server is running:  Command Line   library  $ python manage.py runserver  Now open a new, second command line console. We will use it to access the API running in the existing command line console.  We can use the popular cURL34 program to execute HTTP requests via the command line. All we need for a basic GET request it to specify curl and the URL we want to call.  33http:  127.0.0.1:8000 api  34https:  en.wikipedia.org wiki CURL   Chapter 2: Library Website and API  33  Command Line  $ curl http:  127.0.0.1:8000 api  [  "title":"Django for Beginners", "subtitle":"Build websites with Python and Django", "author":"William S. Vincent", "isbn":"9781735467207"  {  }  ]  The data is all there, in JSON format, but it is poorly formatted and hard to make sense of. Fortunately Django REST Framework has a further surprise for us: a powerful visual mode for our API endpoints.  Browsable API  With the local server still running in the first command line console, navigate to our API endpoint in the web browser at http:  127.0.0.1:8000 api .   Chapter 2: Library Website and API  34  Wow look at that! Django REST Framework provides this visualization by default. And there is a lot of functionality built into this page that we will explore throughout the book. For now I want you to compare this page with the raw JSON endpoint. Click on the “GET” button and select “json” from the dropdown menu.  Book API  Book API JSON  This is what the raw JSON from our API endpoint looks like. I think we can agree the Django REST Framework version is more appealing.  Conclusion  We covered a lot of material in this chapter so don’t worry if things feel a little confusing right now. First we created a traditional Django Library website. Then we added Django REST   Chapter 2: Library Website and API  35  Framework and were able to add an API endpoint with a minimal amount of code.  In the next two chapters we will build our own Todo API back-end and connect it with a React- powered front-end to demonstrate a complete working example that will help solidify how all this theory fits together in practice!   Chapter 3: Todo API  Over the course of the next two chapters we will build a Todo API back-end and then connect it with a React front-end. We have already made our first API and reviewed how HTTP and REST work in the abstract but it’s still likely you don’t “quite” see how it all fits together yet. By the end of these two chapters you will.  Since we are making a dedicated back-end and front-end we will divide our code into a similar structure. Within our existing code directory, we will create a todo directory containing our back-end Django Python code and our front-end React JavaScript code.  The eventual layout will look like this.  Diagram  todo      ├──frontend  ├──React...  ├──backend  ├──Django...  Initial Set Up  This chapter focuses on the back-end and Chapter 4 on the front-end.  The first step for any Django API is always to install Django and then later add Django REST Framework on top of it. First create a dedicated todo directory within our code directory on the Desktop.  Open a new command line console and enter the following commands:   Chapter 3: Todo API  Command Line  $ cd ~ Desktop $ cd code $ mkdir todo && cd todo  37  Note: Make sure you have deactivated the virtual environment from the previous chapter. You can do this by typing exit. Are there no more parentheses in front of your command line? Good. Then you are not in an existing virtual environment.  Within this todo folder will be our backend and frontend directories. Let’s create the backend folder, install Django, and activate a new virtual environment.  Command Line  $ mkdir backend && cd backend $ pipenv install django~=3.1.0 $ pipenv shell  You should see parentheses on your command line confirming the virtual environment,  backend , is activated.  Now that Django is installed we should start by creating a traditional Django project config, adding our first app todos within it, and then migrating our initial database.  Command Line   backend  $ django-admin startproject config .  backend  $ python manage.py startapp todos  backend  $ python manage.py migrate  In Django we always need to add new apps to our INSTALLED_APPS setting so do that now. Open up config settings.py in your text editor. At the bottom of the file add todos.   38  Chapter 3: Todo API  Code   config settings.py INSTALLED_APPS = [  'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles',   Local 'todos',  new  ]  If you run python manage.py runserver on the command line now and navigate in your web browser to http:  127.0.0.1:8000  you can see our project is successfully installed.   Chapter 3: Todo API  39  We’re ready to go!  Django welcome page   Chapter 3: Todo API  Models  40  Next up is defining our Todo database model within the todos app. We will keep things basic and have only two fields: title and body.  Code   todos models.py from django.db import models  class Todo models.Model :  title = models.CharField max_length=200  body = models.TextField    def __str__ self :  return self.title  We import models at the top and then subclass it to create our own Todo model. We also add a __str__ method to provide a human-readable name for each future model instance.  Since we have updated our model it’s time for Django’s two-step dance of making a new migration file and then syncing the database with the changes each time. On the command line type Control+c to stop our local server. Then run these two commands:  Command Line   backend  $ python manage.py makemigrations todos Migrations for 'todos':  todos migrations 0001_initial.py  - Create model Todo   backend  $ python manage.py migrate Operations to perform:  Running migrations:  Applying todos.0001_initial... OK  Apply all migrations: admin, auth, contenttypes, sessions, todos  It is optional to add the specific app we want to create a migration file for–we could instead type just python manage.py makemigrations–however it is a good best practice to adopt. Migration files are a fantastic way to debug applications and you should strive to create a migration file   Chapter 3: Todo API  41  for each small change. If we had updated the models in two different apps and then run python manage.py makemigrations the resulting single migration file would contain data on both apps. That just makes debugging harder. Try to keep your migrations as small as possible.  Now we can use the built-in Django admin app to interact with our database. If we went into the admin straight away our Todos app would not appear. We need to explicitly add it via the todos admin.py file as follows.  Code   todos admin.py from django.contrib import admin from .models import Todo  admin.site.register Todo   That’s it! Now we can create a superuser account to log in to the admin.  Command Line   backend  $ python manage.py createsuperuser  And then start up the local server again:  Command Line   backend  $ python manage.py runserver  If you navigate to http:  127.0.0.1:8000 admin  you can now log in. Click on “+ Add” next to Todos and create 3 new todo items, making sure to add a title and body for both. Here’s what mine looks like:   Chapter 3: Todo API  42  Admin todos  We’re actually done with the traditional Django part of our Todo API at this point. Since we are not bothering to build out webpages for this project, there is no need for website URLs, views, or templates. All we need is a model and Django REST Framework will take care of the rest.  Django REST Framework  Stop the local server Control+c and install Django REST Framework via pipenv.  Command Line   backend  $ pipenv install djangorestframework~=3.11.0  Then add rest_framework to our INSTALLED_APPS setting just like any other third-party applica- tion. We also want to start configuring Django REST Framework specific settings which all exist under REST_FRAMEWORK. For starters, let’s explicitly set permissions to AllowAny35. This line goes at the bottom of the file.  35http:  www.django-rest-framework.org api-guide permissions allowany   43  Chapter 3: Todo API  Code INSTALLED_APPS = [  'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles',   3rd party 'rest_framework',  new   Local 'todos',   new REST_FRAMEWORK = {  ]  }  ]  'DEFAULT_PERMISSION_CLASSES': [  'rest_framework.permissions.AllowAny',  Django REST Framework has a lengthy list of implicitly set default settings. You can see the complete list here36. AllowAny is one of them which means that when we set it explicitly, as we did above, the effect is exactly the same as if we had no DEFAULT_PERMISSION_CLASSES config set.  Learning the default settings is something that takes time. We will become familiar with a number of them over the course of the book. The main takeaway to remember is that the implicit default settings are designed so that developers can jump in and start working quickly in a local development environment. The default settings are not appropriate for production though. So typically we will make a number of changes to them over the course of a project.  Ok, so Django REST Framework is installed. What next?  Unlike the Library project in the previous chapter where we built both a webpage and an API, here we are just building an API. Therefore we do not need to create any template files or traditional Django views.  36http:  www.django-rest-framework.org api-guide settings    Chapter 3: Todo API  44  Instead we will update three files that are Django REST Framework specific to transform our database model into a web API: urls.py, views.py, and serializers.py.  I like to start with the URLs first since they are the entry-point for our API endpoints. Just as in a traditional Django project, the urls.py file lets us configure the routing.  Start at the Django project-level file which is config urls.py. We import include on the second line and add a route for our todos app at api .  URLs  Code  ]   config urls.py from django.contrib import admin from django.urls import include, path  new  urlpatterns = [  path 'admin ', admin.site.urls , path 'api ', include 'todos.urls'  ,  new  Next create our app-level todos urls.py file.  Command Line   backend  $ touch todos urls.py  And update it with the code below.   Chapter 3: Todo API  45  Code  ]   todos urls.py from django.urls import path from .views import ListTodo, DetailTodo  urlpatterns = [  path '  ', DetailTodo.as_view   , path '', ListTodo.as_view   ,  Note that we are referencing two views—ListTodo and DetailTodo—that we have yet to create. But the routing is now complete. There will be a list of all todos at the empty string '', in other words at api . And each individual todo will be available at its primary key, which is a value Django sets automatically in every database table. The first entry is 1, the second is 2, and so on. Therefore our first todo will eventually be located at the API endpoint api 1 .  Serializers  Let’s review where we are so far. We started with a traditional Django project and app where we made a database model and added data. Then we installed Django REST Framework and configured our URLs. Now we need to transform our data, from the models, into JSON that will be outputted at the URLs. Therefore we need a serializer.  Django REST Framework ships with a powerful built-in serializers class that we can quickly extend with a small amount of code. That’s what we’ll do here.  First create a new serializers.py file in the todos app.  Command Line   backend  $ touch todos serializers.py  Then update it with the following code.   46  Chapter 3: Todo API  Code   todos serializers.py from rest_framework import serializers from .models import Todo  class TodoSerializer serializers.ModelSerializer :  class Meta:  model = Todo fields =  'id', 'title', 'body',   At the top we have imported serializers from Django REST Framework as well as our models.py file. Next we create a class TodoSerializer. The format here is very similar to how we create model classes or forms in Django itself. We’re specifying which model to use and the specific fields on it we want to expose. Remember that id is created automatically by Django so we didn’t have to define it in our Todo model but we will use it in our detail view.  And that’s it. Django REST Framework will now magically transform our data into JSON exposing the fields for id, title, and body from our Todo model.  The last thing we need to do is configure our views.py file.  Views  In traditional Django views are used to customize what data to send to the templates. In Django REST Framework views do the same thing but for our serialized data.  The syntax of Django REST Framework views is intentionally quite similar to regular Django views and just like regular Django, Django REST Framework ships with generic views for common use cases. That’s what we’ll use here.  Update the todos views.py file to look as follows:   47  Chapter 3: Todo API  Code   todos views.py from rest_framework import generics from .models import Todo from .serializers import TodoSerializer  class ListTodo generics.ListAPIView :  queryset = Todo.objects.all   serializer_class = TodoSerializer  class DetailTodo generics.RetrieveAPIView :  queryset = Todo.objects.all   serializer_class = TodoSerializer  At the top we import Django REST Framework’s generics views and both our models.py and serializers.py files.  Recall from our todos urls.py file that we have two routes and therefore two distinct views. We will use ListAPIView37 to display all todos and RetrieveAPIView38 to display a single model instance.  Astute readers will notice that there is a bit of redundancy in the code here. We essentially repeat the queryset and serializer_class for each view, even though the generic view extended is different. Later on in the book we will learn about viewsets and routers which address this issue and allow us to create the same API views and URLs with much less code.  But for now we’re done! Our API is ready to consume. As you can see, the only real difference between Django REST Framework and Django is that with Django REST Framework we need to add a serializers.py file and we do not need a templates file. Otherwise the urls.py and views.py files act in a similar manner.  37http:  www.django-rest-framework.org api-guide generic-views listapiview 38http:  www.django-rest-framework.org api-guide generic-views retrieveapiview   Chapter 3: Todo API  Consuming the API  48  Traditionally consuming an API was a challenge. There simply weren’t good visualizations for all the information contained in the body and header of a given HTTP response or request.  Instead most developers used a command line HTTP client like cURL39, which we saw in the previous chapter, or HTTPie40.  In 2012, the third-party software product Postman41 was launched and it is now used by millions of developers worldwide who want a visual, feature-rich way to interact with APIs.  But one of the most amazing things about Django REST Framework is that it ships with a powerful browsable API that we can use right away. If you find yourself needing more customization around consuming an API, then tools like Postman are available. But often the built-in browsable API is more than enough.  Let’s use the browsable API now to interact with our data. Make sure the local server is running.  Browsable API  Command Line   backend  $ python manage.py runserver  39https:  en.wikipedia.org wiki CURL 40https:  httpie.org  41https:  www.getpostman.com   Then navigate to http:  127.0.0.1:8000 api  to see our working API list views endpoint.   Chapter 3: Todo API  49  This page shows the three todos we created earlier in the database model. The API endpoint is known as a collection because it shows multiple items.  There is a lot that we can do with our browsable API. For starters, let’s see the raw JSON view— what will actually be transmitted over the internet. Click on the “GET” button in the upper right corner and select JSON.  API List  API JSON  If you go back to our list view page at http:  127.0.0.1:8000 api  we can see there is additional information. Recall that the HTTP verb GET is used to read data while POST is used to update or   Chapter 3: Todo API  create data.  50  Under “List Todo” it says GET  api  which tells us that we performed a GET on this endpoint. Below that it says HTTP 200 OK which is our status code, everything is working. Crucially below that it shows ALLOW: GET, HEAD, OPTIONS. Note that it does not include POST since this is a read-only endpoint, we can only perform GET’s.  We also made a DetailTodo view for each individual model. This is known as an instance and is visible at http:  127.0.0.1:8000 api 1 .  API Detail  You can also navigate to the endpoints for:    http:  127.0.0.1:8000 api 2   http:  127.0.0.1:8000 api 3  CORS  There’s one last step we need to do and that’s deal with Cross-Origin Resource Sharing  CORS 42. Whenever a client interacts with an API hosted on a different domain  mysite.com vs  42https:  developer.mozilla.org en-US docs Web HTTP CORS   Chapter 3: Todo API  51  yoursite.com  or port  localhost:3000 vs localhost:8000  there are potential security issues.  Specifically, CORS requires the server to include specific HTTP headers that allow for the client to determine if and when cross-domain requests should be allowed.  Our Django API back-end will communicate with a dedicated front-end that is located on a different port for local development and on a different domain once deployed.  The easiest way to handle this–-and the one recommended by Django REST Framework43–-is to use middleware that will automatically include the appropriate HTTP headers based on our settings.  The package we will use is django-cors-headers44, which can be easily added to our existing project.  First quit our server with Control+c and then install django-cors-headers with Pipenv.  Command Line   backend  $ pipenv install django-cors-headers==3.4.0  Next update our config settings.py file in three places:    add corsheaders to the INSTALLED_APPS   add CorsMiddleware above CommonMiddleWare in MIDDLEWARE   create a CORS_ORIGIN_WHITELIST  43http:  www.django-rest-framework.org topics ajax-csrf-cors  44https:  github.com adamchainz django-cors-headers   52  Chapter 3: Todo API  Code   config settings.py INSTALLED_APPS = [  'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles',   3rd party 'rest_framework', 'corsheaders',  new   Local 'todos',  MIDDLEWARE = [  ]  ]     'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'corsheaders.middleware.CorsMiddleware',  new 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',   new CORS_ORIGIN_WHITELIST =    'http:  localhost:3000', 'http:  localhost:8000',  It’s very important that corsheaders.middleware.CorsMiddleware appears in the proper lo- cation. That is above django.middleware.common.CommonMiddleware in the MIDDLEWARE setting since middlewares are loaded top-to-bottom. Also note that we’ve whitelisted two domains: localhost:3000 and localhost:8000. The former is the default port for React, which we will use for our front-end in the next chapter. The latter is the default Django port.   Chapter 3: Todo API  Tests  53  You should always write tests for your Django projects. A small amount of time spent upfront will save you an enormous amount of time and effort later on debugging errors. Let’s add two basic tests to confirm that the title and body content behave as expected.  Open up the todos tests.py file and fill it with the following:  Code   todos tests.py from django.test import TestCase from .models import Todo  class TodoModelTest TestCase :  @classmethod def setUpTestData cls :  Todo.objects.create title='first todo', body='a body here'   def test_title_content self :  todo = Todo.objects.get id=1  expected_object_name = f'{todo.title}' self.assertEqual expected_object_name, 'first todo'   def test_body_content self :  todo = Todo.objects.get id=1  expected_object_name = f'{todo.body}' self.assertEqual expected_object_name, 'a body here'   This uses Django’s built-in TestCase45 class. First we set up our data in setUpTestData and then write two new tests. Then run the tests with the python manage.py test command.  45https:  docs.djangoproject.com en 3.1 topics testing tools testcase   Chapter 3: Todo API  54  Command Line  backend  $ python manage.py test Creating test database for alias 'default'... System check identified no issues  0 silenced . .. ---------------------------------------------------------------------- Ran 2 tests in 0.002s  OK Destroying test database for alias 'default'...  And that’s it! Our back-end is now complete. Make sure the server is running as we’ll be using it in the next chapter.  Command Line  backend  $ python manage.py runserver  Conclusion  With a minimal amount of code Django REST Framework has allowed us to create a Django API from scratch. The only pieces we needed from traditional Django was a models.py file and our urls.py routes. The views.py and serializers.py files were entirely Django REST Framework specific.  Unlike our example in the previous chapter, we did not build out any web pages for this project since our goal was just to create an API. However at any point in the future, we easily could! It would just require adding a new view, URL, and a template to expose our existing database model.  An important point in this example is that we added CORS headers and explicitly set only the domains localhost:3000 and localhost:8000 to have access to our API. Correctly setting CORS headers is an easy thing to be confused about when you first start building APIs.  There’s much more configuration we can and will do later on but at the end of the day creating Django APIs is about making a model, writing some URL routes, and then adding a little bit of magic provided by Django REST Framework’s serializers and views.   Chapter 3: Todo API  55  In the next chapter we will build a React front-end and connect it to our Todo API backend.   Chapter 4: Todo React Front-end  An API exists to communicate with another program. In this chapter we will consume our Todo API from the last chapter via a React46 front-end so you can see how everything actually works together in practice.  I’ve chosen to use React as it is currently the most popular JavaScript front-end library but the techniques described here will also work with any other popular front-end framework including Vue47, Angular48, or Ember49. They will even work with mobile apps for iOS or Android, desktop apps, or really anything else. The process of connecting to a back-end API is remarkably similar.  If you become stuck or want to learn more about what’s really happening with React, check out the official tutorial50 which is quite good.  Install Node  We’ll start by configuring a React app as our front-end. First open up a new command line console so there are now two consoles open. This is important. We need our existing Todo back-end from the last chapter to still be running on the local server. And we will use the second console to create and then run our React front-end on a separate local port. This is how we locally mimic what a production setting of a dedicated and deployed front-end back-end would look like.  In the new, second command line console install NodeJS51, which is a JavaScript runtime engine. It lets us run JavaScript outside of a web browser.  On a Mac computer we can use Homebrew52, which should already be installed if you followed  46https:  reactjs.org  47https:  vuejs.org  48https:  angular.io  49https:  emberjs.com  50https:  reactjs.org tutorial tutorial.html 51https:  nodejs.org en  52https:  brew.sh    Chapter 4: Todo React Front-end  57  the Django for Beginners instructions53 for configuring your local computer.  On a Windows computer there are multiple approaches but a popular one is to use nvm- windows54. Its repository contains detailed, up-to-date installation instructions.  If you are on Linux use nvm55. As of this writing, the command can be done using either cURL:  $ curl -o- https:  raw.githubusercontent.com nvm-sh nvm v0.35.3 \ install.sh  bash  $ wget -qO- https:  raw.githubusercontent.com nvm-sh nvm v0.35.3 \ install.sh  bash  Command Line  $ brew install node  Command Line  or using Wget  Command Line  Then run:  Command Line  $ command -v nvm  Install React  Close your current command line console and open it again to complete installation.  We will use the excellent create-react-app56 package to quickly start a new React project. This will generate our project boilerplate and install the required dependencies with one command!  53https:  djangoforbeginners.com initial-setup  54https:  github.com coreybutler nvm-windows 55https:  github.com creationix nvm 56https:  github.com facebookincubator create-react-app   Chapter 4: Todo React Front-end  58  To install React we’ll rely on npm57 which is a JavaScript package manager. Like pipenv for Python, npm makes managing and installing multiple software packages much, much simpler. Recent versions of npm also include npx58, which is an improved way to install packages locally without polluting the global namespace. It’s the recommended way to install React and what we’ll use here!  Make sure you are in the correct directory by navigating to the Desktop  if on a Mac  and then the todo folder.  Command Line  $ cd ~ Desktop $ cd todo  Create a new React app called frontend.  Command Line  $ npx create-react-app frontend  Diagram  todo      ├──frontend  ├──React...  ├──backend  ├──Django...  Your directory structure should now look like the following:  Change into our frontend project and run the React app with the command npm start.  57https:  www.npmjs.com  58https:  medium.com @maybekatz introducing-npx-an-npm-package-runner-55f7d4bd282b   Chapter 4: Todo React Front-end  59  Command Line  $ cd frontend $ npm start  If you navigate to http:  localhost:3000  you will see the create-react-app default homepage.  React welcome page  Mock data  If you go back to our API endpoint you can see the raw JSON in the browser at:  http:  127.0.0.1:8000 api ?format=json   Chapter 4: Todo React Front-end  60  Code  [  {  }, {  }, {  }  ]  Code  {  }, {  }, {  "id":1, "title":"1st todo", "body":"Learn Django properly."  "id":2, "title":"Second item", "body":"Learn Python."  "id":3, "title":"Learn HTTP", "body":"It's important."     src App.js import React, { Component } from 'react';  const list = [  "id":1, "title":"1st todo", "body":"Learn Django properly."  "id":2, "title":"Second item", "body":"Learn Python."  "id":3,  This is returned whenever a GET request is issued to the API endpoint. Eventually we will consume the API directly but a good initial step is to mock the data first, then configure our API call.  The only file we need to update in our React app is src App.js. Let’s start by mocking up the API data in a variable named list which is actually an array with three values.   Chapter 4: Todo React Front-end  61  "title":"Learn HTTP", "body":"It's important."  Next we load the list into our component’s state and then use the JavaScript array method map  59 to display all the items.  I’m deliberately moving fast here so if you’ve never used React before, just copy the code so that you can see how it “would” work to wire up a React front-end to our Django back-end.  Here’s the complete code to include in the src App.js file now.  }  ]  Code  {  }, {  }, {  }  ]  }     src App.js import React, { Component } from 'react';  const list = [  "id":1, "title":"1st todo", "body":"Learn Django properly."  "id":2, "title":"Second item", "body":"Learn Python."  "id":3, "title":"Learn HTTP", "body":"It's important."  class App extends Component {  constructor props  {  super props ; this.state = { list };  59https:  developer.mozilla.org en-US docs Web JavaScript Reference Global_Objects Array map   Chapter 4: Todo React Front-end  62  render   { return      {this.state.list.map item =>        {item.title}   {item.body}        }     ;  }  }  export default App;  We have loaded list into the state of the App component, then we’re using map to loop over each item in the list displaying the title and body of each. We’ve also added the id as a key which is a React-specific requirement; the id is automatically added by Django to every database field for us.  You should now see our todos listed on the homepage at http:  localhost:3000  without needing to refresh the page.  Dummy data  Note: If you spend any time working with React, it’s likely at some point you will see the error message sh: react-scripts: command not found while running npm start. Don’t be alarmed.   Chapter 4: Todo React Front-end  63  This is a very, very common issue in JavaScript development. The fix is typically to run npm install and then try npm start again. If that does not work, then delete your node_modules folder and run npm install. That solves the issue 99% of the time. Welcome to modern JavaScript development : .  Django REST Framework + React  Now let’s hook into our Todo API for real instead of using the mock data in the list variable. In the other command line console our Django server is running and we know the API endpoint listing all todos is at http:  127.0.0.1:8000 api . So we need to issue a GET request to it.  There are two popular ways to make HTTP requests: with the built-in Fetch API60 or with axios61, which comes with several additional features. We will use axios in this example. Stop the React app currently running on the command line with Control+c. Then install axios.  Command Line  $ npm install axios  Command Line  $ npm start  Start up the React app again using npm start.  Then in your text editor at the top of the App.js file import Axios.  60https:  developer.mozilla.org en-US docs Web API Fetch_API 61https:  github.com axios axios   Chapter 4: Todo React Front-end  64  Code     src App.js import React, { Component } from 'react'; import axios from 'axios';    new ...  There are two remaining steps. First, we’ll use axios for our GET request. We can make a dedicated getTodos function for this purpose.  Second, we want to make sure that this API call is issued at the correct time during the React lifecycle. HTTP requests should be made using componentDidMount62 so we will call getTodos there.  We can also delete the mock list since it is no longer needed. Our complete App.js file will now look as follows.  Code  };  }     src App.js import React, { Component } from 'react'; import axios from 'axios';    new  class App extends Component {  state = {  todos: []     new componentDidMount   {  this.getTodos  ;     new getTodos   {  axios  .get 'http:  127.0.0.1:8000 api '  .then res => {  this.setState { todos: res.data } ;  }  .catch err => {  console.log err ;  62https:  reactjs.org docs state-and-lifecycle.html   Chapter 4: Todo React Front-end  65  {this.state.todos.map item =>        {item.title}   {item.body}   } ;  }  render   { return           }     ;  }  }  export default App;  If you look again at http:  localhost:3000  the page is the same even though we no longer have hardcoded data. It all comes from our API endpoint and request now.  And that is how it’s done with React!  API Data   Chapter 4: Todo React Front-end  Conclusion  66  We have now connected our Django back-end API to a React front-end. Even better, we have the option to update our front-end in the future or swap it out entirely as project requirements change.  This is why adopting an API-first approach is a great way to “future-proof” your website. It may take a little more work upfront, but it provides much more flexibility. In later chapters we will enhance our APIs so they support multiple HTTP verbs such as POST  adding new todos , PUT  updating existing todos , and DELETE  removing todos .  In the next chapter we will start building out a robust Blog API that supports full CRUD  Create- Read-Update-Delete  functionality and later on add user authentication to it so users can log in, log out, and sign up for accounts via our API.   Chapter 5: Blog API  Our next project is a Blog API using the full set of Django REST Framework features. It will have users, permissions, and allow for full CRUD  Create-Read-Update-Delete  functionality. We’ll also explore viewsets, routers, and documentation.  In this chapter we will build the basic API section. Just as with our Library and Todo APIs, we start with traditional Django and then add in Django REST Framework. The main difference is that our API endpoints will support CRUD from the beginning which, as we will see, Django REST Framework makes quite seamless to do.  Initial Set Up  Our set up is the same as before. Navigate into our code directory and within it create one for this project called blogapi. Then install Django in a new virtual environment create a new Django project  config  and app for blog entries  posts .  Command Line  $ cd ~ Desktop && cd code $ mkdir blogapi && cd blogapi $ pipenv install django~=3.1.0 $ pipenv shell  blogapi  $ django-admin startproject config .  blogapi  $ python manage.py startapp posts  Since we’ve added a new app we need to tell Django about it. So make sure to add posts to our list of INSTALLED_APPS in the config settings.py file.   68  Chapter 5: Blog API  Code   config settings.py INSTALLED_APPS = [  'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles',   Local 'posts',  new  ]  Command Line   blogapi  $ python manage.py migrate  Model  Now run migrate for the first time to sync our database with Django’s default settings and the new app.  Our database model will have five fields: author, title, body, created_at, and updated_at. We can use Django’s built-in User model as the author provided we import it on the second line from the top.   69  Chapter 5: Blog API  Code   posts models.py from django.db import models from django.contrib.auth.models import User  class Post models.Model :  author = models.ForeignKey User, on_delete=models.CASCADE  title = models.CharField max_length=50  body = models.TextField   created_at = models.DateTimeField auto_now_add=True  updated_at = models.DateTimeField auto_now=True   def __str__ self :  return self.title  Note that we’re also defining what the __str__ representation of the model should be which is a Django best practice. This way we will see the title in our Django admin later.  Now update our database by first creating a new migration file and then running migrate to sync the database with our model changes.  Command Line   blogapi  $ python manage.py makemigrations posts Migrations for 'posts':  posts migrations 0001_initial.py  - Create model Post   blogapi  $ python manage.py migrate Operations to perform:  Running migrations:  Applying posts.0001_initial... OK  Apply all migrations: admin, auth, contenttypes, posts, sessions  Good! We want to view our data in Django’s excellent built-in admin app so let’s add it to posts admin.py as follows.   70  Chapter 5: Blog API  Code   posts admin.py from django.contrib import admin from .models import Post  admin.site.register Post   Command Line   blogapi  $ python manage.py createsuperuser  Now we can start up the local web server.  Command Line   blogapi  $ python manage.py runserver  Then create a superuser account so we can access the admin. Type the command below and enter all the prompts.  Navigate to http:  127.0.0.1:8000 admin  and log in with your superuser credentials. Click on the “+ Add” button next to Posts and create a new blog post. Next to “Author” will be a dropdown menu that has your superuser account  mine is called wsv . Make sure an author is selected. Add a title and body content then click on the “Save” button.   Chapter 5: Blog API  71  You will be redirected to the Posts page which displays all existing blog posts.  Admin add blog post  Admin blog posts   Chapter 5: Blog API  72  Let’s write a basic test for our Post model. We want to ensure a logged-in user can create a blog post with a title and body.  Tests  Code   posts tests.py from django.test import TestCase from django.contrib.auth.models import User from .models import Post  class BlogTests TestCase :  @classmethod def setUpTestData cls :   Create a user testuser1 = User.objects.create_user   username='testuser1', password='abc123'   testuser1.save     Create a blog post test_post = Post.objects.create   test_post.save    def test_blog_content self :  post = Post.objects.get id=1  author = f'{post.author}' title = f'{post.title}' body = f'{post.body}' self.assertEqual author, 'testuser1'  self.assertEqual title, 'Blog title'  self.assertEqual body, 'Body content...'   author=testuser1, title='Blog title', body='Body content...'   To confirm that our tests are working quit the local server Control+c. Then run our tests.   73   blogapi  $ python manage.py test  Chapter 5: Blog API  Command Line  Command Line  You should see output like the following which confirms everything is working as expected.   blogapi  $ python manage.py test Creating test database for alias 'default'... System check identified no issues  0 silenced . . ---------------------------------------------------------------------- Ran 1 test in 0.105s  OK Destroying test database for alias 'default'...  We are done now with the regular Django part of our API. All we really need is a model and some data in our database. Now it’s time to add Django REST Framework to take care of transforming our model data into an API.  Django REST Framework  As we have seen before, Django REST Framework takes care of the heavy lifting of transforming our database models into a RESTful API. There are three main steps to this process:    urls.py file for the URL routes   serializers.py file to transform the data into JSON   views.py file to apply logic to each API endpoint  On the command line use pipenv to install Django REST Framework.   Chapter 5: Blog API  74  Command Line  blogapi  $ pipenv install djangorestframework~=3.11.0  Then add it to the INSTALLED_APPS section of our config settings.py file. It’s also a good idea to explicitly set our permissions which by default in Django REST Framework are configured to AllowAny. We will update these in the next chapter.  Code  config settings.py INSTALLED_APPS = [  'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles',   3rd-party apps 'rest_framework',  new   Local 'posts.apps.PostsConfig',   new REST_FRAMEWORK = {  'DEFAULT_PERMISSION_CLASSES': [  'rest_framework.permissions.AllowAny',  Now we need to create our URLs, views, and serializers.  ]  }  ]  URLs  Let’s start with the URL routes for the actual location of the endpoints. Update the project-level urls.py file with the include import on the second line and a new api v1  route for our posts app.   Chapter 5: Blog API  75  Code  ]   config urls.py from django.contrib import admin from django.urls import include, path  new  urlpatterns = [  path 'admin ', admin.site.urls , path 'api v1 ', include 'posts.urls'  ,  new  It is a good practice to always version your APIs—v1 , v2 , etc—since when you make a large change there may be some lag time before various consumers of the API can also update. That way you can support a v1 of an API for a period of time while also launching a new, updated v2 and avoid breaking other apps that rely on your API back-end.  Note that since our only app at this point is posts we can include it directly here. If we had multiple apps in a project it might make more sense to create a dedicated api app and then include all the other API url routes into it. But for basic projects like this one, I prefer to avoid an api app that is just used for routing. We can always add one later, if needed.  Next create our posts app urls.py file.  Command Line   blogapi  $ touch posts urls.py  And then include the code below.   Chapter 5: Blog API  76  Code  ]   posts urls.py from django.urls import path from .views import PostList, PostDetail  urlpatterns = [  path '  ', PostDetail.as_view   , path '', PostList.as_view   ,  All blog routes will be at api v1  so our PostList view  which we’ll write shortly  has the empty string '' will be at api v1  and the PostDetail view  also to be written  at api v1  where  represents the primary key of the entry. For example, the first blog post has a primary id of 1 so it will be at the route api v1 1, the second post at api v1 2, and so on.  Serializers  Now for our serializers. Create a new serializers.py file in our posts app.  Command Line   blogapi  $ touch posts serializers.py  The serializer not only transforms data into JSON, it can also specify which fields to include or exclude. In our case, we will include the id field Django automatically adds to database models but we will exclude the updated_at field by not including it in our fields.  The ability to include exclude fields in our API this easily is a remarkable feature. More often than not, an underlying database model will have far more fields than what needs to be exposed. Django REST Framework’s powerful serializer class makes it extremely straightforward to control this.   Chapter 5: Blog API  Code   posts serializers.py from rest_framework import serializers from .models import Post  77  class PostSerializer serializers.ModelSerializer :  class Meta:  fields =  'id', 'author', 'title', 'body', 'created_at',  model = Post  At the top of the file we have imported Django REST Framework’s serializers class and our own models. Then we created a PostSerializer and added a Meta class where we specified which fields to include and explicitly set the model to use. There are many ways to customize a serializer but for common use cases, such as a basic blog, this is all we need.  Views  The final step is to create our views. Django REST Framework has several generic views that are helpful. We have already used ListAPIView63 in both the Library and Todos APIs to create a read-only endpoint collection, essentially a list of all model instances. In the Todos API we also used RetrieveAPIView64 for a read-only single endpoint, which is analogous to a detail view in traditional Django.  For our Blog API we want to list all available blog posts as a read-write endpoint which means using ListCreateAPIView65, which is similar to the ListAPIView we’ve used previously but allows for writes. We also want to make the individual blog posts available to be read, updated, or deleted. And sure enough, there is a built-in generic Django REST Framework view just for this purpose: RetrieveUpdateDestroyAPIView66. That’s what we’ll use here.  Update the views.py file as follows.  63http:  www.django-rest-framework.org api-guide generic-views listapiview 64http:  www.django-rest-framework.org api-guide generic-views retrieveapiview 65http:  www.django-rest-framework.org api-guide generic-views listcreateapiview 66http:  www.django-rest-framework.org api-guide generic-views retrieveupdatedestroyapiview   78  Chapter 5: Blog API  Code   posts views.py from rest_framework import generics from .models import Post from .serializers import PostSerializer  class PostList generics.ListCreateAPIView :  queryset = Post.objects.all   serializer_class = PostSerializer  class PostDetail generics.RetrieveUpdateDestroyAPIView :  queryset = Post.objects.all   serializer_class = PostSerializer  At the top of the file we import generics from Django REST Framework as well as our models and serializers files. Then we create two views. PostList uses the generic ListCreateAPIView while PostDetail uses the RetrieveUpdateDestroyAPIView.  It’s pretty amazing that all we have to do is update our generic view to radically change the behavior of a given API endpoint. This is the advantage of using a full-featured framework like Django REST Framework: all of this functionality is available, tested, and just works. As developers we do not have to reinvent the wheel here.  Phew. Our API is now complete and we really did not have to write much code on our own. We will make additional improvements to our API in the coming chapters but it is worth appreciating that it already performs the basic list and CRUD functionality we desire. Time to test things out with the Django Rest Framework’s browsable API.  Browsable API  Start up the local server to interact with our API.   Chapter 5: Blog API  79  Command Line  blogapi  $ python manage.py runserver  Then go to http:  127.0.0.1:8000 api v1  to see the Post List endpoint.  API Post List  The page displays a list of our blog posts—just one at the moment—in JSON format. Note that both GET and POST methods are allowed.  Now let’s confirm that our model instance endpoint—which relates to a single post rather than a list of all posts—exists.   Chapter 5: Blog API  80  Go to http:  127.0.0.1:8000 api v1 1 .  API Post Detail  You can see in the header that GET, PUT, PATCH, and DELETE are supported but not POST. And in fact you can use the HTML form below to make changes or even use the red “DELETE” button to delete the instance.  Let’s try things out. Update our title with the additional text  edited  at the end. Then click on the “PUT” button.   Chapter 5: Blog API  81  API Post Detail edited  Go back to the Post List view by clicking on the link for it at the top of the page or navigating directly to http:  127.0.0.1:8000 api v1  and you can see the updated text there as well.   Chapter 5: Blog API  82  API Post List edited  Conclusion  Our Blog API is completely functional at this point. However there is a big problem: anyone can update or delete an existing blog post! In other words, we do not have any permissions in place. In the next chapter we will learn how to apply permissions to protect our API.   Chapter 6: Permissions  Security is an important part of any website but it is doubly important with web APIs. Currently our Blog API allows anyone full access. There are no restrictions; any user can do anything which is extremely dangerous. For example, an anonymous user can create, read, update, or delete any blog post. Even one they did not create! Clearly we do not want this.  Django REST Framework ships with several out-of-the-box permissions settings that we can use to secure our API. These can be applied at a project-level, a view-level, or at any individual model level.  In this chapter we will add a new user and experiment with multiple permissions settings. Then we’ll create our own custom permission so that only the author of a blog post has the ability to update or delete it.  Create a new user  Let’s start by creating a second user. That way we can switch between the two user accounts to test our permissions settings.  Navigate to the admin at http:  127.0.0.1:8000 admin . Then click on “+ Add” next to Users. Enter a username and password for a new user and click on the “Save” button. I’ve chosen the username testuser here.   Chapter 6: Permissions  84  Admin Add User Page  The next screen is the Admin User Change page. I’ve called my user testuser and here I could add additional information included on the default User model such as first name, last name, email address, etc. But none of that is necessary for our purposes: we just need a username and password for testing.   Chapter 6: Permissions  85  Admin User Change   Chapter 6: Permissions  86  Scroll down to the bottom of this page and click the “Save” button. It will redirect back to the main Users page at http:  127.0.0.1:8000 admin auth user 67.  Admin All Users  We can see our two users are listed.  Add log in to the browsable API  Going forward whenever we want to switch between user accounts we’ll need to jump into the Django admin, log out of one account and log in to another. Each and every time. Then switch back to our API endpoint.  This is such a common occurrence that Django REST Framework has a one-line setting to add log in and log out directly to the browsable API itself. We will implement that now.  Within the project-level urls.py file, add a new URL route that includes rest_framework.urls. Somewhat confusingly, the actual route specified can be anything we want; what matters is that rest_framework.urls is included somewhere. We will use the route api-auth since that matches  67http:  127.0.0.1:8000 admin auth user    Chapter 6: Permissions  87  official documentation, but we could just as easily use anything-we-want and everything would work just the same.  Code  ]   config urls.py from django.contrib import admin from django.urls import include, path  urlpatterns = [  path 'admin ', admin.site.urls , path 'api v1 ', include 'posts.urls'  , path 'api-auth ', include 'rest_framework.urls'  ,  new  Now navigate to our browsable API at http:  127.0.0.1:8000 api v1 . There is a subtle change: next to the username in the upper right corner is a little downward-facing arrow.   Chapter 6: Permissions  88  API Log In  Since we are logged in with our superuser account at this point—wsv for me—that name appears. Click on the link and a dropdown menu with “Log out” appears. Click on it.  The upper righthand link now changes to “Log in.” So go click on that. We are redirected to Django REST Framework’s log in page. Use our testuser account here. It will finally redirect us back to the main API page where testuser is present in the upper righthand corner.   Chapter 6: Permissions  89  As a final step, log out of our testuser account.  API Log In Testuser   Chapter 6: Permissions  90  You should see the “Log in” link in the upper righthand corner again.  API Log In Link  AllowAny  Currently, any anonymous non-authorized user can access our PostList endpoint. We know this because even though we are not logged-in, we can see our single blog post. Even worse, anyone has full access to create, edit, update, or delete a post!  And on the detail page at http:  127.0.0.1:8000 api v1 1  the information is also visible and any random user can update or delete an existing blog post. Not good.   Chapter 6: Permissions  91  API Detail Logged Out  The reason we can still see the Post List endpoint and also the Detail List endpoint is that we pre- viously set the project-level permissions on our project to AllowAny in our config settings.py file. As a brief reminder, it looked like this:   Chapter 6: Permissions  92   config settings.py REST_FRAMEWORK = {  'DEFAULT_PERMISSION_CLASSES': [  'rest_framework.permissions.AllowAny',  Code  ]  }  View-Level Permissions  What we want now is to restrict API access to authenticated users. There are multiple places we could do this—project-level, view-level, or object-level—but since we only have two views at the moment let’s start there and add permissions to each of them.  In your posts views.py file, import permissions at the top from Django REST Framework and then add a permission_classes field to each view.  Code   posts views.py from rest_framework import generics, permissions from .models import Post from .serializers import PostSerializer   new  class PostList generics.ListCreateAPIView :  permission_classes =  permissions.IsAuthenticated,  queryset = Post.objects.all   serializer_class = PostSerializer   new  class PostDetail generics.RetrieveUpdateDestroyAPIView : permission_classes =  permissions.IsAuthenticated,  queryset = Post.objects.all   serializer_class = PostSerializer   new  That’s all we need. Refresh the browsable API at http:  127.0.0.1:8000 api v1 . Look what happened!   Chapter 6: Permissions  93  API Post List Logged Out  We no longer see our Post List page. Instead we are greeted with an unfriendly HTTP 403 Forbidden status code since we are not logged in. And there are no forms in the browsable API to edit the data since we don’t have permission.  If you use the URL for Post Detail http:  127.0.0.1:8000 api v1 1  you will see a similar message and also no available forms for edits.  API Detail Logged Out  Therefore at this point only logged-in users can view our API. If you log back in with either your superuser or testuser account the API endpoints will be accessible.  But think about what happens as the API grows in complexity. It’s likely we will have many more   Chapter 6: Permissions  94  views and endpoints in the future. Adding a dedicated permission_classes to each view seems repetitive if we want to set the same permissions setting across our entire API.  Wouldn’t it be better to change our permissions once, ideally at the project-level, rather than doing it for each and every view?  Project-Level Permissions  You should be nodding your head yes at this point. It is a much simpler and safer approach to set a strict permissions policy at the project-level and loosen it as needed at the view level. This is what we will do.  Fortunately Django REST Framework ships with a number of built-in project-level permissions settings we can use, including:    AllowAny68 - any user, authenticated or not, has full access   IsAuthenticated69 - only authenticated, registered users have access   IsAdminUser70 - only admins superusers have access   IsAuthenticatedOrReadOnly71 - unauthorized users can view any page, but only authenti-  cated users have write, edit, or delete privileges  Implementing any of these four settings requires updating the DEFAULT_PERMISSION_CLASSES setting and refreshing our web browser. That’s it!  Let’s switch to IsAuthenticated so only authenticated, or logged in, users can view the API. Update the config settings.py file as follows:  68http:  www.django-rest-framework.org api-guide permissions allowany 69http:  www.django-rest-framework.org api-guide permissions isauthenticated 70http:  www.django-rest-framework.org api-guide permissions isadminuser 71http:  www.django-rest-framework.org api-guide permissions isauthenticatedorreadonly   Chapter 6: Permissions  Code  config settings.py REST_FRAMEWORK = {  ]  }  'DEFAULT_PERMISSION_CLASSES': [  'rest_framework.permissions.IsAuthenticated',  new  95  Now go back into the posts views.py file and delete the permissions changes we just made.  Code  posts views.py from rest_framework import generics from .models import Post from .serializers import PostSerializer  class PostList generics.ListCreateAPIView :  queryset = Post.objects.all   serializer_class = PostSerializer  class PostDetail generics.RetrieveUpdateDestroyAPIView :  queryset = Post.objects.all   serializer_class = PostSerializer  If you refresh the Post List and Detail List API pages you will still see the same 403 status code. We have now required all users to authenticate before they can access the API, but we can always make additional view-level changes as needed, too.  Custom permissions  Time for our first custom permission. As a brief recap of where we are now: we have two users, testuser and the superuser account. There is one blog post in our database, which was created by the superuser.  We want only the author of a specific blog post to be able to edit or delete it; otherwise the blog post should be read-only. So the superuser account should have full CRUD access to the individual blog instance, but the regular user testuser should not.   Chapter 6: Permissions  96  Stop the local server with Control+c and create a new permissions.py file in our posts app.  Command Line   blogapi  $ touch posts permissions.py  Internally, Django REST Framework relies on a BasePermission class from which all other per- mission classes inherit. That means the built-in permissions settings like AllowAny, IsAuthenticated, and others extend it. Here is the actual source code which is available on Github72:  Code  class BasePermission object :  """ A base class from which all permission classes should inherit. """  def has_permission self, request, view :  """ Return `True` if permission is granted, `False` otherwise. """ return True  def has_object_permission self, request, view, obj :  """ Return `True` if permission is granted, `False` otherwise. """ return True  To create our own custom permission, we will override the has_object_permission method. Specifically we want to allow read-only for all requests but for any write requests, such as edit or delete, the author must be the same as the current logged-in user.  Here is what our posts permissions.py file looks like.  72https:  github.com encode django-rest-framework   Chapter 6: Permissions  97  Code  posts permissions.py from rest_framework import permissions  class IsAuthorOrReadOnly permissions.BasePermission :  def has_object_permission self, request, view, obj :   Read-only permissions are allowed for any request if request.method in permissions.SAFE_METHODS:  return True   Write permissions are only allowed to the author of a post return obj.author == request.user  We import permissions at the top and then create a custom class IsAuthorOrReadOnly which extends BasePermission. Then we override has_object_permission. If a request contains HTTP verbs included in SAFE_METHODS–a tuple containing GET, OPTIONS, and HEAD–then it is a read-only request and permission is granted.  Otherwise the request is for a write of some kind, which means updating the API resource so either create, delete, or edit functionality. In that case, we check if the author of the object in question, which is our blog post obj.author matches the user making the request request.user.  Back in the views.py file we should import IsAuthorOrReadOnly and then we can add permission_- classes for PostDetail.  Code  posts views.py from rest_framework import generics from .models import Post from .permissions import IsAuthorOrReadOnly  new from .serializers import PostSerializer  class PostList generics.ListCreateAPIView :  queryset = Post.objects.all   serializer_class = PostSerializer  class PostDetail generics.RetrieveUpdateDestroyAPIView :   Chapter 6: Permissions  98  permission_classes =  IsAuthorOrReadOnly,  queryset = Post.objects.all   serializer_class = PostSerializer   new  And we’re done. Let’s test things out. Navigate to the Post Detail page, which is located at http:  127.0.0.1:8000 api v1 1 . Make sure you are logged-in with your superuser account, who is the author of the post. The username should be visible in the upper righthand corner of the page.  However, if you log out and then log in with the testuser account, the page changes.  API Detail Superuser   Chapter 6: Permissions  99  API Detail Testuser  We can view this page since read-only permissions are allowed. However we can not make any PUT or DELETE requests due to our custom IsAuthorOrReadOnly permission class.  Note that the generic views will only check the object-level permissions for views that retrieve a single model instance. If you require object-level filtering of list views–for a collection of instances–you’ll need to filter by overriding the initial queryset73.  Conclusion  Setting proper permissions is a very important part of any API. As a general strategy, it is a good idea to set a strict project-level permissions policy such that only authenticated users can view the API. Then make view-level or custom permissions more accessible as needed on specific API endpoints.  73http:  www.django-rest-framework.org api-guide filtering overriding-the-initial-queryset   Chapter 7: User Authentication  In the previous chapter we updated our APIs permissions, which is also called authorization. In this chapter we will implement authentication which is the process by which a user can register for a new account, log in with it, and log out.  Within a traditional, monolithic Django website authentication is simpler and involves a session- based cookie pattern which we will review below. But with an API things are a bit trickier. Remember that HTTP is a stateless protocol so there is no built-in way to remember if a user is authenticated from one request to the next. Each time a user requests a restricted resource it must verify itself.  The solution is to pass along a unique identifier with each HTTP request. Confusingly, there is no universally agreed-upon approach for the form of this identifier and it can take multiple forms. Django REST Framework ships with four different built-in authentication options74: basic, session, token, and default. And there are many more third-party packages that offer additional features like JSON Web Tokens  JWTs .  In this chapter we will thoroughly explore how API authentication works, review the pros and cons of each approach, and then make an informed choice for our Blog API. By the end, we will have created API endpoints for sign up, log in, and log out.  Basic Authentication  The most common form of HTTP authentication is known as “Basic” Authentication75. When a client makes an HTTP request, it is forced to send an approved authentication credential before access is granted.  The complete request response flow looks like this:  74https:  www.django-rest-framework.org api-guide authentication api-reference 75https:  tools.ietf.org html rfc7617   Chapter 7: User Authentication  101  1. Client makes an HTTP request 2. Server responds with an HTTP response containing a 401  Unauthorized  status code and  WWW-Authenticate HTTP header with details on how to authorize 3. Client sends credentials back via the Authorization76 HTTP header 4. Server checks credentials and responds with either 200 OK or 403 Forbidden status code  Once approved, the client sends all future requests with the Authorization HTTP header credentials. We can also visualize this exchange as follows:  Diagram Client ------  ---------------------------------------> GET   HTTP 1.1  ---------------------------------------> GET   HTTP 1.1 Authorization: Basic d3N2OnBhc3N3b3JkMTIz  Server ------  <------------------------------------- HTTP 1.1 401 Unauthorized WWW-Authenticate: Basic  <------------------------------------- HTTP 1.1 200 OK  Note that the authorization credentials sent are the unencrypted base64 encoded77 version of  : . So in my case, this is wsv:password123 which with base64 encoding is d3N2OnBhc3N3b3JkMTIz.  The primary advantage of this approach is its simplicity. But there are several major downsides. First, on every single request the server must look up and verify the username and password, which is inefficient. It would be better to do the look up once and then pass a token of some kind that says, this user is approved. Second, user credentials are being passed in clear text—not encrypted at all—over the internet. This is incredibly insecure. Any internet traffic that is not  76https:  developer.mozilla.org en-US docs Web HTTP Headers Authorization 77https:  en.wikipedia.org wiki Base64   Chapter 7: User Authentication  102  encrypted can easily be captured and reused. Thus basic authentication should only be used via HTTPS78, the secure version of HTTP.  Session Authentication  Monolithic websites, like traditional Django, have long used an alternative authentication scheme that is a combination of sessions and cookies. At a high level, the client authenticates with its credentials  username password  and then receives a session ID from the server which is stored as a cookie. This session ID is then passed in the header of every future HTTP request.  When the session ID is passed, the server uses it to look up a session object containing all available information for a given user, including credentials.  This approach is stateful because a record must be kept and maintained on both the server  the session object  and the client  the session ID .  Let’s review the basic flow:  1. A user enters their log in credentials  typically username password   2. The server verifies the credentials are correct and generates a session object that is then  3. The server sends the client a session ID—not the session object itself—which is stored as a  4. On all future requests the session ID is included as an HTTP header and, if verified by the  5. Once a user logs out of an application, the session ID is destroyed by both the client and  stored in the database  cookie on the browser  database, the request proceeds  server  client  6. If the user later logs in again, a new session ID is generated and stored as a cookie on the  The default setting in Django REST Framework is actually a combination of Basic Authentication and Session Authentication. Django’s traditional session-based authentication system is used and the session ID is passed in the HTTP header on each request via Basic Authentication.  78https:  en.wikipedia.org wiki HTTPS   Chapter 7: User Authentication  103  The advantage of this approach is that it is more secure since user credentials are only sent once, not on every request response cycle as in Basic Authentication. It is also more efficient since the server does not have to verify the user’s credentials each time, it just matches the session ID to the session object which is a fast look up.  There are several downsides however. First, a session ID is only valid within the browser where log in was performed; it will not work across multiple domains. This is an obvious problem when an API needs to support multiple front-ends such as a website and a mobile app. Second, the session object must be kept up-to-date which can be challenging in large sites with multiple servers. How do you maintain the accuracy of a session object across each server? And third, the cookie is sent out for every single request, even those that don’t require authentication, which is inefficient.  As a result, it is generally not advised to use a session-based authentication scheme for any API that will have multiple front-ends.  Token Authentication  The third major approach–and the one we will implement in our Blog API–is to use token authentication. This is the most popular approach in recent years due to the rise of single page applications.  Token-based authentication is stateless: once a client sends the initial user credentials to the server, a unique token is generated and then stored by the client as either a cookie or in local storage79. This token is then passed in the header of each incoming HTTP request and the server uses it to verify that a user is authenticated. The server itself does not keep a record of the user, just whether a token is valid or not.  Cookies vs localStorage  Cookies are used for reading server-side information. They are smaller  4KB  in size and auto- matically sent with each HTTP request. LocalStorage is designed for client-side information. It is much larger  5120KB  and its contents are not sent by default with each HTTP request.  79https:  developer.mozilla.org en-US docs Web API Window localStorage   Chapter 7: User Authentication  104  Tokens stored in both cookies and localStorage are vulnerable to XSS attacks. The current best practice is to store tokens in a cookie with the httpOnly and Secure cookie flags.  Let’s look at a simple version of actual HTTP messages in this challenge response flow. Note that the HTTP header WWW-Authenticate specifies the use of a Token which is used in the response Authorization header request.  Diagram  Client ------  ---------------------------------------> GET   HTTP 1.1  Server ------  <------------------------------------- HTTP 1.1 401 Unauthorized WWW-Authenticate: Token  <------------------------------------- HTTP 1.1 200 OK  ---------------------------------------> GET   HTTP 1.1 Authorization: Token 401f7ac837da42b97f613d789819ff93537bee6a  There are multiple benefits to this approach. Since tokens are stored on the client, scaling the servers to maintain up-to-date session objects is no longer an issue. And tokens can be shared amongst multiple front-ends: the same token can represent a user on the website and the same user on a mobile app. The same session ID can not be shared amongst different front-ends, a major limitation.  A potential downside is that tokens can grow quite large. A token contains all user information, not just an id as with a session id session object set up. Since the token is sent on every request, managing its size can become a performance issue.  Exactly how the token is implemented can also vary substantially. Django REST Frameworks’   Chapter 7: User Authentication  105  built-in TokenAuthentication80 is deliberately quite basic. As a result, it does not support setting tokens to expire, which is a security improvement that can be added. It also only generates one token per user, so a user on a website and then later a mobile app will use the same token. Since information about the user is stored locally, this can cause problems with maintaining and updating two sets of client information.  JSON Web Tokens  JWTs  are a new, enhanced version of tokens that can be added to Django REST Framework via several third-party packages. JWTs have several benefits including the ability to generate unique client tokens and token expiration. They can either be generated on the server or with a third-party service like Auth081. And JWTs can be encrypted which makes them safer to send over unsecured HTTP connections.  Ultimately the safest bet for most web APIs is to use a token-based authentication scheme. JWTs are a nice, modern addition though they require additional configuration. As a result, in this book we will use the built-in TokenAuthentication.  Default Authentication  The first step is to configure our new authentication settings. Django REST Framework comes with a number of settings82 that are implicitly set. For example, DEFAULT_PERMISSION_CLASSES was set to AllowAny before we updated it to IsAuthenticated.  The DEFAULT_AUTHENTICATION_CLASSES are set by default so let’s explicitly add both SessionAuthentication and BasicAuthentication to our config settings.py file.  80http:  www.django-rest-framework.org api-guide authentication tokenauthentication 81https:  auth0.com  82http:  www.django-rest-framework.org api-guide settings    106  Chapter 7: User Authentication  Code  REST_FRAMEWORK = {  'DEFAULT_PERMISSION_CLASSES': [  'rest_framework.permissions.IsAuthenticated',  ], 'DEFAULT_AUTHENTICATION_CLASSES': [  new  'rest_framework.authentication.SessionAuthentication', 'rest_framework.authentication.BasicAuthentication'  ],  }  Why use both methods? The answer is they serve different purposes. Sessions are used to power the Browsable API and the ability to log in and log out of it. BasicAuthentication is used to pass the session ID in the HTTP headers for the API itself.  If you revisit the browsable API at http:  127.0.0.1:8000 api v1  it will work just as before. Technically, nothing has changed, we’ve just made the default settings explicit.  Implementing token authentication  Now we need to update our authentication system to use tokens. The first step is to update our DEFAULT_AUTHENTICATION_CLASSES setting to use TokenAuthentication as follows:  Code   config settings.py REST_FRAMEWORK = {  'DEFAULT_PERMISSION_CLASSES': [  'rest_framework.permissions.IsAuthenticated',  ], 'DEFAULT_AUTHENTICATION_CLASSES': [  'rest_framework.authentication.SessionAuthentication', 'rest_framework.authentication.TokenAuthentication',  new  ],  }  We keep SessionAuthentication since we still need it for our Browsable API, but now use tokens to pass authentication credentials back and forth in our HTTP headers. We also need to add the   Chapter 7: User Authentication  107  authtoken app which generates the tokens on the server. It comes included with Django REST Framework but must be added to our INSTALLED_APPS setting:  Code  config settings.py INSTALLED_APPS = [  'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles',   3rd-party apps 'rest_framework', 'rest_framework.authtoken',  new   Local 'posts',  ]  Since we have made changes to our INSTALLED_APPS we need to sync our database. Stop the server with Control+c. Then run the following command.  Command Line  blogapi  $ python manage.py migrate Operations to perform:  Apply all migrations: admin, auth, authtoken, contenttypes, posts, sessions  Running migrations:  Applying authtoken.0001_initial... OK Applying authtoken.0002_auto_20160226_1747... OK  Now start up the server again.  Command Line  blogapi  $ python manage.py runserver  If you navigate to the Django admin at http:  127.0.0.1:8000 admin  you’ll see there is now a Tokens section at the top. Make sure you’re logged in with your superuser account to have access.   Chapter 7: User Authentication  108  Click on the link for Tokens. Currently there are no tokens which might be surprising.  Admin Homepage with Tokens  Admin Tokens Page  After all we have existing users. However, the tokens are only generated after there is an API call for a user to log in. We have not done that yet so there are no tokens. We will shortly!  Endpoints  We also need to create endpoints so users can log in and log out. We could create a dedicated users app for this purpose and then add our own urls, views, and serializers. However user authentication is an area where we really do not want to make a mistake. And since almost all APIs require this functionality, it makes sense that there are several excellent and tested third-party packages we can use it instead.   Chapter 7: User Authentication  109  Notably we will use dj-rest-auth83 in combination with django-allauth84 to simplify things. Don’t feel bad about using third-party packages. They exist for a reason and even the best Django professionals rely on them all the time. There is no point in reinventing the wheel if you don’t have to!  dj-rest-auth  First we will add log in, log out, and password reset API endpoints. These come out-of-the-box with the popular dj-rest-auth package. Stop the server with Control+c and then install it.  Command Line   blogapi  $ pipenv install dj-rest-auth==1.1.0  Add the new app to the INSTALLED_APPS config in our config settings.py file.  Code   config settings.py INSTALLED_APPS = [  'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles',   3rd-party apps 'rest_framework', 'rest_framework.authtoken', 'dj_rest_auth',  new   Local 'posts',  ]  83https:  github.com jazzband dj-rest-auth 84https:  github.com pennersr django-allauth   Chapter 7: User Authentication  110  Update our config urls.py file with the dj_rest_auth package. We’re setting the URL routes to api v1 dj-rest-auth. Make sure to note that URLs should have a dash - not an underscore _, which is an easy mistake to make.  Code  ]   config urls.py from django.contrib import admin from django.urls import include, path  urlpatterns = [  path 'admin ', admin.site.urls , path 'api v1 ', include 'posts.urls'  , path 'api-auth ', include 'rest_framework.urls'  , path 'api v1 dj-rest-auth ', include 'dj_rest_auth.urls'  ,  new  And we’re done! If you have ever tried to implement your own user authentication endpoints, it is truly amazing how much time—and headache—dj-rest-auth saves for us. Now we can spin up the server to see what dj-rest-auth has provided.  Command Line   blogapi  $ python manage.py runserver  We have a working log in endpoint at http:  127.0.0.1:8000 api v1 dj-rest-auth login .   Chapter 7: User Authentication  111  And a log out endpoint at http:  127.0.0.1:8000 api v1 dj-rest-auth logout .  API Log In Endpoint   Chapter 7: User Authentication  112  API Log Out Endpoint  There are also endpoints for password reset, which is located at:  http:  127.0.0.1:8000 api v1 dj-rest-auth password reset   Chapter 7: User Authentication  113  API Password Reset  And for password reset confirmed:  http:  127.0.0.1:8000 api v1 dj-rest-auth password reset confirm   Chapter 7: User Authentication  114  API Password Reset Confirm  User Registration  Next up is our user registration, or sign up, endpoint. Traditional Django does not ship with built- in views or URLs for user registration and neither does Django REST Framework. Which means we need to write our own code from scratch; a somewhat risky approach given the seriousness– and security implications–of getting this wrong.  A popular approach is to use the third-party package django-allauth85 which comes with user registration as well as a number of additional features to the Django auth system such as social  85https:  github.com pennersr django-allauth   Chapter 7: User Authentication  115  authentication via Facebook, Google, Twitter, etc. If we add dj_rest_auth.registration from the dj-rest-auth package then we have user registration endpoints too!  Stop the local server with Control+c and install django-allauth.  Command Line   blogapi  $ pipenv install django-allauth~=0.42.0  Then update our INSTALLED_APPS setting. We must add several new configs:  Make sure to also include EMAIL_BACKEND and SITE_ID. Technically it does not matter where in the config settings.py file they are placed, but it’s common to add additional configs like that at the bottom.    django.contrib.sites   allauth   allauth.account   allauth.socialaccount   dj_rest_auth.registration  Code   config settings.py INSTALLED_APPS = [  'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'django.contrib.sites',  new   3rd-party apps 'rest_framework', 'rest_framework.authtoken', 'allauth',  new 'allauth.account',  new 'allauth.socialaccount',  new 'dj_rest_auth',   Chapter 7: User Authentication  116  'dj_rest_auth.registration',  new   Local 'posts',  ]  SITE_ID = 1  new  EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'  new  The email back-end config is needed since by default an email will be sent when a new user is registered, asking them to confirm their account. Rather than also set up an email server, we will output the emails to the console with the console.EmailBackend setting.  SITE_ID is part of the built-in Django “sites” framework86, which is a way to host multiple websites from the same Django project. We obviously only have one site we are working on here but django-allauth uses the sites framework, so we must specify a default setting.  Ok. We’ve added new apps so it’s time to update the database.  Command Line   blogapi  $ python manage.py migrate  Then add a new URL route for registration.  86https:  docs.djangoproject.com en 3.1 ref contrib sites    Chapter 7: User Authentication  117  Code  ]   config urls.py from django.contrib import admin from django.urls import include, path  urlpatterns = [  path 'admin ', admin.site.urls , path 'api v1 ', include 'posts.urls'  , path 'api-auth ', include 'rest_framework.urls'  , path 'api v1 dj-rest-auth ', include 'dj_rest_auth.urls'  , path 'api v1 dj-rest-auth registration ',  new  include 'dj_rest_auth.registration.urls'  ,  And we’re done. We can run the local server.  Command Line   blogapi  $ python manage.py runserver  There is now a user registration endpoint at http:  127.0.0.1:8000 api v1 dj-rest-auth registration .   Chapter 7: User Authentication  118  API Register  Tokens  To make sure everything works, create a third user account via the browsable API endpoint. I’ve called my user testuser2. Then click on the “POST” button.   Chapter 7: User Authentication  119  API Register New User  The next screen shows the HTTP response from the server. Our user registration POST was successful, hence the status code HTTP 201 Created at the top. The return value key is the auth token for this new user.   Chapter 7: User Authentication  120  API Auth Key  If you look at the command line console, an email has been automatically generated by django-allauth. This default text can be updated and an email SMTP server added with additional configuration that is covered in the book Django for Beginners87.  Command Line  Content-Type: text plain; charset="utf-8" MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Subject: [example.com] Please Confirm Your E-mail Address From: webmaster@localhost To: testuser2@email.com Date: Wed, 29 Jul 2020 20:54:26 -0000 Message-ID: <159605606600.8206.5520712009851546888@1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0\ .0.0.0.0.0.0.0.ip6.arpa>  Hello from example.com!  87https:  djangoforbeginners.com  You're receiving this e-mail because user testuser2 has given yours as an e-mail address \ to connect their account.   Chapter 7: User Authentication  121  To confirm this is correct, go to http:  127.0.0.1:8000 api v1 dj-rest-auth \ registration account-confirm-email MQ:1k0t5m:6l0l09er1p_cbxgkJWDuSw2j00M   Thank you from example.com! example.com  Switch over to the Django admin in your web browser at http:  127.0.0.1:8000 admin . You will need to use your superuser account for this. Then click on the link for Tokens at the top of the page. You will be redirected to the Tokens page.  Admin Tokens  A single token has been generated by Django REST Framework for the testuser2 user. As additional users are created via the API, their tokens will appear here, too.  A logical question is, Why are there are no tokens for our superuser account or testuser? The answer is that we created those accounts before token authentication was added. But no worries, once we log in with either account via the API a token will automatically be added and available.  Moving on, let’s log in with our new testuser2 account. In your web browser, navigate to http:  127.0.0.1:8000 api v1 dj-rest-auth login . Enter the information for our testuser2 account. Click on the “POST” button.   Chapter 7: User Authentication  122  API Log In testuser2  Two things have happened. In the upper righthand corner, our user account testuser2 is visible, confirming that we are now logged in. Also the server has sent back an HTTP response with the token.   Chapter 7: User Authentication  123  API Log In Token  In our front-end framework, we would need to capture and store this token. Traditionally this happens on the client, either in localStorage88 or as a cookie, and then all future requests include the token in the header as a way to authenticate the user. Note that there are additional security concerns on this topic so you should take care to implement the best practices of your front-end framework of choice.  Conclusion  User authentication is one of the hardest areas to grasp when first working with web APIs. Without the benefit of a monolithic structure, we as developers have to deeply understand and configure our HTTP request response cycles appropriately.  Django REST Framework comes with a lot of built-in support for this process, including  88https:  developer.mozilla.org en-US docs Web API Window localStorage   Chapter 7: User Authentication  124  built-in TokenAuthentication. However developers must configure additional areas like user registration and dedicated urls views themselves. As a result, a popular, powerful, and secure approach is to rely on the third-party packages dj-rest-auth and django-allauth to minimize the amount of code we have to write from scratch.   Chapter 8: Viewsets and Routers  Viewsets89 and routers90 are tools within Django REST Framework that can speed-up API development. They are an additional layer of abstraction on top of views and URLs. The primary benefit is that a single viewset can replace multiple related views. And a router can automatically generate URLs for the developer. In larger projects with many endpoints this means a developer has to write less code. It is also, arguably, easier for an experienced developer to understand and reason about a small number of viewset and router combinations than a long list of individual views and URLs.  In this chapter we will add two new API endpoints to our existing project and see how switching from views and URLs to viewsets and routers can achieve the same functionality with far less code.  User endpoints  Currently we have the following API endpoints in our project. They are all prefixed with api v1  which is not shown for brevity:  89http:  www.django-rest-framework.org api-guide viewsets  90http:  www.django-rest-framework.org api-guide routers    Chapter 8: Viewsets and Routers  126  Diagram  Endpoint HTTP Verb -----------------------------------------------      :pk   rest-auth registration    rest-auth login   rest-auth logout   rest-auth password reset  rest-auth password reset confirm   GET GET POST POST GET POST POST  The first two endpoints were created by us while dj-rest-auth provided the five others. Let’s now add two additional endpoints to list all users and individual users. This is a common feature in many APIs and it will make it clearer why refactoring our views and URLs to viewsets and routers can make sense.  Traditional Django has a built-in User model class that we have already used in the previous chapter for authentication. So we do not need to create a new database model. Instead we just need to wire up new endpoints. This process always involves the following three steps:    new serializer class for the model    new views for each endpoint    new URL routes for each endpoint  Start with our serializer. We need to import the User model and then create a UserSerializer class that uses it. Then add it to our existing posts serializers.py file.   Chapter 8: Viewsets and Routers  127  Code   posts serializers.py from django.contrib.auth import get_user_model  new from rest_framework import serializers from .models import Post  class PostSerializer serializers.ModelSerializer :  class Meta:  model = Post fields =  'id', 'author', 'title', 'body', 'created_at',   class UserSerializer serializers.ModelSerializer :  new  class Meta:  model = get_user_model   fields =  'id', 'username',   It’s worth noting that while we have used get_user_model to reference the User model here, there are actually three different ways to reference91 the User model in Django.  By using get_user_model we ensure that we are referring to the correct user model, whether it is the default User or a custom user model92 as is often defined in new Django projects.  Moving on we need to define views for each endpoint. First add UserSerializer to the list of imports. Then create both a UserList class that lists out all users and a UserDetail class that provides a detail view of an individual user. Just as with our post views we can use ListCreateAPIView and RetrieveUpdateDestroyAPIView here. We also need to reference the users model via get_user_model so it is imported on the top line.  91https:  docs.djangoproject.com en 3.1 topics auth customizing referencing-the-user-model 92https:  docs.djangoproject.com en 3.1 topics auth customizing specifying-a-custom-user-model   Chapter 8: Viewsets and Routers  128  Code   posts views.py from django.contrib.auth import get_user_model  new from rest_framework import generics from .models import Post from .permissions import IsAuthorOrReadOnly from .serializers import PostSerializer, UserSerializer  new  class PostList generics.ListCreateAPIView :  queryset = Post.objects.all   serializer_class = PostSerializer  class PostDetail generics.RetrieveUpdateDestroyAPIView :  permission_classes =  IsAuthorOrReadOnly,  queryset = Post.objects.all   serializer_class = PostSerializer  class UserList generics.ListCreateAPIView :  new  queryset = get_user_model  .objects.all   serializer_class = UserSerializer  class UserDetail generics.RetrieveUpdateDestroyAPIView :  new  queryset = get_user_model  .objects.all   serializer_class = UserSerializer  If you notice, there is quite a bit of repetition here. Both Post views and User views have the exact same queryset and serializer_class. Maybe those could be combined in some way to save code?  Finally we have our URL routes. Make sure to import our new UserList, and UserDetail views. Then we can use the prefix users  for each.   Chapter 8: Viewsets and Routers  129  Code  ]   posts urls.py from django.urls import path from .views import UserList, UserDetail, PostList, PostDetail  new  urlpatterns = [  path 'users ', UserList.as_view   ,  new path 'users   ', UserDetail.as_view   ,  new path '', PostList.as_view   , path '  ', PostDetail.as_view   ,  And we’re done. Make sure the local server is still running and jump over to the browsable API to confirm everything works as expected.  Our user list endpoint is located at http:  127.0.0.1:8000 api v1 users .   Chapter 8: Viewsets and Routers  130  API Users List  The status code is 200 OK which means everything is working. We can see our three existing users.  A user detail endpoint is available at the primary key for each user. So our superuser account is located at: http:  127.0.0.1:8000 api v1 users 1 .   Chapter 8: Viewsets and Routers  131  API User Instance  Viewsets  A viewset is a way to combine the logic for multiple related views into a single class. In other words, one viewset can replace multiple views. Currently we have four views: two for blog posts and two for users. We can instead mimic the same functionality with two viewsets: one for blog posts and one for users.  The tradeoff is that there is a loss in readability for fellow developers who are not intimately familiar with viewsets. So it’s a trade-off.  Here is what the code looks like in our updated posts views.py file when we swap in viewsets.   Chapter 8: Viewsets and Routers  132  Code   posts views.py from django.contrib.auth import get_user_model from rest_framework import viewsets  new from .models import Post from .permissions import IsAuthorOrReadOnly from .serializers import PostSerializer, UserSerializer  class PostViewSet viewsets.ModelViewSet :  new permission_classes =  IsAuthorOrReadOnly,  queryset = Post.objects.all   serializer_class = PostSerializer  class UserViewSet viewsets.ModelViewSet :  new  queryset = get_user_model  .objects.all   serializer_class = UserSerializer  At the top instead of importing generics from rest_framework we are now importing viewsets on the second line. Then we are using ModelViewSet93 which provides both a list view and a detail view for us. And we no longer have to repeat the same queryset and serializer_class for each view as we did previously!  At this point, the local web server will stop as Django complains about the lack of corresponding URL paths. Let’s set those next.  Routers  Routers94 work directly with viewsets to automatically generate URL patterns for us. Our current posts urls.py file has four URL patterns: two for blog posts and two for users. We can instead adopt a single route for each viewset. So two routes instead of four URL patterns. That sounds better, right?  93http:  www.django-rest-framework.org api-guide viewsets modelviewset 94http:  www.django-rest-framework.org api-guide routers    Chapter 8: Viewsets and Routers  133  Django REST Framework has two default routers: SimpleRouter95 and DefaultRouter96. We will use SimpleRouter but it’s also possible to create custom routers for more advanced functionality.  Here is what the updated code looks like:  Code   posts urls.py from django.urls import path from rest_framework.routers import SimpleRouter from .views import UserViewSet, PostViewSet  router = SimpleRouter   router.register 'users', UserViewSet, basename='users'  router.register '', PostViewSet, basename='posts'   urlpatterns = router.urls  On the top line SimpleRouter is imported, along with our views. The router is set to SimpleRouter and we “register” each viewset for Users and Posts. Finally, we set our URLs to use the new router. Go ahead and check out our four endpoints now by starting the local server with python manage.py runserver.  95http:  www.django-rest-framework.org api-guide routers simplerouter 96http:  www.django-rest-framework.org api-guide routers defaultrouter   Chapter 8: Viewsets and Routers  134  API User List  Note that the User List is the same, however the detail view is a little different. It is now called “User Instance” instead of “User Detail” and there is an additional “delete” option which is built-in to ModelViewSet97.  97http:  www.django-rest-framework.org api-guide viewsets modelviewset   Chapter 8: Viewsets and Routers  135  API User Detail  It is possible to customize viewsets but an important tradeoff in exchange for writing a bit less code with viewsets is the default settings may require some additional configuration to match exactly what you want.  Moving along to the Post List at http:  127.0.0.1:8000 api v1  we can see it is the same:   Chapter 8: Viewsets and Routers  136  API Post List  And, importantly, our permissions still work. When logged-in with our testuser2 account, the Post Instance at http:  127.0.0.1:8000 api v1 1  is read-only.   Chapter 8: Viewsets and Routers  137  API Post Instance Not Owner  However, if we log in with our superuser account, which is the author of the solitary blog post, then we have full read-write-edit-delete privileges.   Chapter 8: Viewsets and Routers  138  API Post Instance Owner  Conclusion  Viewsets and routers are a powerful abstraction that reduce the amount of code we as developers must write. However this conciseness comes at the cost of an initial learning curve. It will feel strange the first few times you use viewsets and routers instead of views and URL patterns.  Ultimately the decision of when to add viewsets and routers to your project is quite subjective. A good rule of thumb is to start with views and URLs. As your API grows in complexity if you find yourself repeating the same endpoint patterns over and over again, then look to viewsets and routers. Until then, keep things simple.   Chapter 9: Schemas and Documentation  Now that we have our API complete we need a way to document its functionality quickly and accurately to others. After all, in most companies and teams, the developer who is using the API is not the same developer who initially built it. Fortunately, there are automated tools to handle this for us.  A schema98 is a machine-readable document that outlines all available API endpoints, URLs, and the HTTP verbs  GET, POST, PUT, DELETE, etc.  they support. Documentation is something added to a schema that makes it easier for humans to read and consume. In this chapter we will add a schema to our Blog project and then add two different documentation approaches. By the end we will we have implemented an automated way to document any current and future changes to our API.  As a reminder, here is the complete list of our current API endpoints:  Diagram  Endpoint HTTP Verb -----------------------------------------------      :pk   users   users :pk   rest-auth registration    rest-auth login   rest-auth logout   rest-auth password reset  rest-auth password reset confirm   GET GET GET GET POST POST GET POST POST  98https:  www.django-rest-framework.org api-guide schemas schema   Chapter 9: Schemas and Documentation  140  Schemas  Before version 3.999, Django REST Framework relied on Core API100 for schemas but it has now switched firmly over to the OpenAPI101 schema  formerly known as Swagger .  The first step is to install both PyYAML102 and uritemplate103. PyYAML will transform our schema into the YAML-basd OpenAPI format, while uritemplate adds parameters to the URL paths.  Command Line   blogapi  $ pipenv install pyyaml==5.3.1 uritemplate==3.0.1  Next, we are presented with a choice: generate a static schema or a dynamic schema. If your API does not change often, the static schema can be generated periodically and served from static files for strong performance. However, if your API does change quite often, you might consider the dynamic option. We’ll implement both here.  First, is the static schema approach which uses the generateschema management command. We can output the result to a file called openapi-schema.yml.  Command Line   blogapi  $ python manage.py generateschema > openapi-schema.yml  If you open that file it’s quite long and not very human-friendly. But to a computer it’s perfectly formatted.  For the dynamic approach, updating config urls.py by importing get_schema_view at the top and then creating a dedicated path at openapi. The title, description, and version can be customized as needed.  99https:  www.django-rest-framework.org community 3.9-announcement 100http:  www.coreapi.org  101https:  www.openapis.org  102https:  pyyaml.org  103https:  github.com python-hyper uritemplate   Chapter 9: Schemas and Documentation  141  Code   config urls.py from django.contrib import admin from django.urls import include, path from rest_framework.schemas import get_schema_view  new  urlpatterns = [  path 'admin ', admin.site.urls , path 'api v1 ', include 'posts.urls'  , path 'api-auth ', include 'rest_framework.urls'  , path 'api v1 dj-rest-auth ', include 'dj_rest_auth.urls'  , path 'api v1 dj-rest-auth registration ',  include 'dj_rest_auth.registration.urls'  ,  path 'openapi', get_schema_view   new  title="Blog API", description="A sample API for learning DRF", version="1.0.0"   , name='openapi-schema' ,  ]  If you start the local server again with python manage.py runserver and navigate to our new schema URL endpoint at http:  127.0.0.1:8000 openapi the automatically generated schema of our entire API is available.   Chapter 9: Schemas and Documentation  142  Personally, I prefer the dynamic approach in projects.  API Schema  Documentation  Django REST Framework also comes with a built-in API documentation104 feature that translates schema into a much friendlier format for fellow developers.  Currently, there are three popular approaches here: using SwaggerUI105, ReDoc106, or the third-  104https:  www.django-rest-framework.org topics documenting-your-api  105https:  swagger.io tools swagger-ui  106https:  github.com Rebilly ReDoc   Chapter 9: Schemas and Documentation  143  party drf-yasg107 package. Since drf-yasg is quite popular and comes with a lot of built-in features, we’ll use it here.  Step one is to install the latest version of drf-yasg.  Command Line   blogapi  $ pipenv install drf-yasg==1.17.1  Step two, add it to our INSTALLED_APPS configuration in config settings.py.  Code   config settings.py INSTALLED_APPS = [  ...  3rd-party apps 'rest_framework', 'rest_framework.authtoken', 'allauth', 'allauth.account', 'allauth.socialaccount', 'rest_auth', 'rest_auth.registration', 'drf_yasg',  new   Local 'posts.apps.PostsConfig',  ]  Step three, update our project-level urls.py file. At the top of the file we can replace DRF’s get_schema_view with the one from drf_yasg as well as importing openapi. We’ll also add DRF’s permission for additional options.  The schema_view variable is updated and includes additional fields such as terms_of_service, contact, and license. Then under our urlpatterns we add paths for both Swagger and ReDoc.  107https:  drf-yasg.readthedocs.io en stable    Chapter 9: Schemas and Documentation  144  Code   config urls.py from django.contrib import admin from django.urls import include, path from rest_framework import permissions  new from drf_yasg.views import get_schema_view  new from drf_yasg import openapi  new  schema_view = get_schema_view   new  openapi.Info   title="Blog API", default_version="v1", description="A sample API for learning DRF", terms_of_service="https:  www.google.com policies terms ", contact=openapi.Contact email="hello@example.com" , license=openapi.License name="BSD License" ,   , public=True, permission_classes= permissions.AllowAny, ,  urlpatterns = [  path 'admin ', admin.site.urls , path 'api v1 ', include 'posts.urls'  , path 'api-auth ', include 'rest_framework.urls'  , path 'api v1 dj-rest-auth ', include 'dj_rest_auth.urls'  , path 'api v1 dj-rest-auth registration ',  include 'dj_rest_auth.registration.urls'  ,  path 'swagger ', schema_view.with_ui   new  'swagger', cache_timeout=0 , name='schema-swagger-ui' ,  path 'redoc ', schema_view.with_ui   new  'redoc', cache_timeout=0 , name='schema-redoc' ,     ]  Make sure the local server is running. The Swagger endpoint is now available at:  http:  127.0.0.1:8000 swagger    Chapter 9: Schemas and Documentation  145  Then confirm that the ReDoc view is also working at http:  127.0.0.1:8000 redoc .  Swagger view   Chapter 9: Schemas and Documentation  146  ReDoc view  The drf-yasg docs108 are quite comprehensive and spell out many more customizations that can be made, depending upon the needs of your API.  Conclusion  Adding documentation is a vital part of any API. It is typically the first thing a fellow developer looks at, either within a team or on an open-source projects. Thanks to the automated tools covered in this chapter, ensuring your API has accurate, up-to-date documentation only requires a small amount of configuration.  108https:  drf-yasg.readthedocs.io en stable readme.html   Conclusion  We’re now at the end of the book but only the beginning of what can be accomplished with Django REST Framework. Over the course of three different projects—Library API, Todo API, and Blog API—we have built progressively more complex web APIs from scratch. And it’s no accident that at every step along the way, Django REST Framework provides built-in features to make our life easier.  If you’ve never built web APIs before with another framework be forewarned that you’ve been spoiled. And if you have, rest assured this book only scratches the surface of what Django REST Framework can do. The official documentation109 is an excellent resource for further exploration now that you have a handle on the basics.  Next Steps  The biggest area worthy of further exploration is testing. Traditional Django tests can and should be applied to any web API project, but there is also a whole suite110 of tools in Django REST Framework just for testing API requests.  A good next step is to implement the pastebin API covered in the official DRF tutorial111. I’ve even written an updated beginners guide112 to it that features step-by-step instructions.  Third-party packages are as essential to Django REST Framework development as they are to Django itself. A complete listing can be found at Django Packages113 or a curated list on the awesome-django114 repo on Github.  109http:  www.django-rest-framework.org  110http:  www.django-rest-framework.org api-guide testing  111http:  www.django-rest-framework.org tutorial 1-serialization  112https:  learndjango.com tutorials official-django-rest-framework-tutorial-beginners 113https:  djangopackages.org  114https:  github.com wsvincent awesome-django   Conclusion  Giving Thanks  148  While the Django community is quite large and relies on the hard work of many individu- als, Django REST Framework is much smaller in comparison. It was initially created by Tom Christie115, an English software engineer who now works on it full-time thanks to open-source funding. He still leads active development. If you enjoy working with Django REST Framework, please consider taking a moment to personally thank him on Twitter116.  And thank you for reading along and supporting my work. If you purchased the book on Amazon, please consider leaving an honest review: they make an enormous impact on book sales and help me continue to produce both books and free Django content which I love doing.  115http:  www.tomchristie.com  116https:  twitter.com _tomchristie

@highlight

Django for APIs is a project-based guide to building modern APIs with Django & Django REST Framework. It is suitable for beginners who have never built an API before as well as professional programmers looking for a fast-paced introduction to Django fundamentals and best practices. In the book you’ll learn how to: Build 3 Django backends from scratch, including a Library API, Todo API, and Blog API, Connect to a React JavaScript front-end, Integrate user authentication: basic, sessions, and tokens, Add permissions and proper documentation
Use viewsets and routers for concise code, and If you’re curious about Python-based APIs, Django for APIs is a best-practices guide to writing and customizing your own quickly.