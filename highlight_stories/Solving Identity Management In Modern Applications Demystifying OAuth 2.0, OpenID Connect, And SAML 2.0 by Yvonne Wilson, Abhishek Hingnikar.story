Solving Identity  Management in  Modern Applications  Demystifying OAuth 2.0, OpenID Connect,  and SAML 2.0 — Yvonne Wilson Abhishek Hingnikar   Solving Identity   Management in Modern   Applications  Demystifying OAuth 2.0, OpenID   Connect, and SAML 2.0  Yvonne Wilson Abhishek Hingnikar   Solving Identity Management in Modern Applications: Demystifying OAuth 2.0,  OpenID Connect, and SAML 2.0  Yvonne Wilson San Francisco, CA, USA  Abhishek Hingnikar London, UK  ISBN-13  pbk : 978-1-4842-5094-5  https:  doi.org 10.1007 978-1-4842-5095-2                       ISBN-13  electronic : 978-1-4842-5095-2  Copyright   2019 by Yvonne Wilson, Abhishek Hingnikar  This work is subject to copyright. All rights are reserved by the Publisher, whether the whole or part of the  material is concerned, specifically the rights of translation, reprinting, reuse of illustrations, recitation,  broadcasting, reproduction on microfilms or in any other physical way, and transmission or information  storage and retrieval, electronic adaptation, computer software, or by similar or dissimilar methodology now  known or hereafter developed.  Trademarked names, logos, and images may appear in this book. Rather than use a trademark symbol with  every occurrence of a trademarked name, logo, or image we use the names, logos, and images only in an  editorial fashion and to the benefit of the trademark owner, with no intention of infringement of the  trademark.   The use in this publication of trade names, trademarks, service marks, and similar terms, even if they are not  identified as such, is not to be taken as an expression of opinion as to whether or not they are subject to  proprietary rights.  While the advice and information in this book are believed to be true and accurate at the date of publication,  neither the authors nor the editors nor the publisher can accept any legal responsibility for any errors or  omissions that may be made. The publisher makes no warranty, express or implied, with respect to the  material contained herein.  Managing Director, Apress Media LLC: Welmoed Spahr Acquisitions Editor: Susan McDermott Development Editor: Laura Berendson Coordinating Editor: Rita Fernando  Cover designed by eStudioCalamar  Cover image designed by Freepik  www.freepik.com   Distributed to the book trade worldwide by Springer Science+Business Media New York, 233 Spring Street,  6th Floor, New York, NY 10013. Phone 1-800-SPRINGER, fax  201  348-4505, e-mail orders-ny@springer- sbm.com, or visit www.springeronline.com. Apress Media, LLC is a California LLC and the sole member   owner  is Springer Science + Business Media Finance Inc  SSBM Finance Inc . SSBM Finance Inc is a  Delaware corporation.  For information on translations, please e-mail rights@apress.com, or visit http:  www.apress.com  rights-permissions.  Apress titles may be purchased in bulk for academic, corporate, or promotional use. eBook versions and  licenses are also available for most titles. For more information, reference our Print and eBook Bulk Sales  web page at http:  www.apress.com bulk-sales.  Any source code or other supplementary material referenced by the author in this book is available to  readers on GitHub via the book’s product page, located at www.apress.com 9781484250945. For more  detailed information, please visit http:  www.apress.com source-code.  Printed on acid-free paper   Table of Contents  About the Authors ��������������������������������������������������������������������������������������������������xvii  About the Technical Reviewers ������������������������������������������������������������������������������xix  Acknowledgments ��������������������������������������������������������������������������������������������������xxi  Introduction �����������������������������������������������������������������������������������������������������������xxv  Chapter 1: The Hydra of Modern Identity ������������������������������������������������������������������ 1 Identity Challenges ����������������������������������������������������������������������������������������������������������������������� 1 Objective ��������������������������������������������������������������������������������������������������������������������������������������� 3 Sample Application ����������������������������������������������������������������������������������������������������������������������� 6 Design Questions �������������������������������������������������������������������������������������������������������������������������� 6 Summary��������������������������������������������������������������������������������������������������������������������������������������� 7 Key Points �������������������������������������������������������������������������������������������������������������������������������� 7 Note����������������������������������������������������������������������������������������������������������������������������������������������� 7  Chapter 2: The Life of an Identity ����������������������������������������������������������������������������� 9 Terminology ���������������������������������������������������������������������������������������������������������������������������������� 9 Events in the Life of an Identity��������������������������������������������������������������������������������������������������� 11 Provisioning ��������������������������������������������������������������������������������������������������������������������������� 11 Authorization ������������������������������������������������������������������������������������������������������������������������� 12 Authentication ����������������������������������������������������������������������������������������������������������������������� 12 Access Policy Enforcement ��������������������������������������������������������������������������������������������������� 13 Sessions �������������������������������������������������������������������������������������������������������������������������������� 13 Single Sign-On  SSO  ������������������������������������������������������������������������������������������������������������� 14 Stronger Authentication ��������������������������������������������������������������������������������������������������������� 14 Logout ������������������������������������������������������������������������������������������������������������������������������������ 15  iii   Table of ConTenTs  Account Management and Recovery ������������������������������������������������������������������������������������� 16 Deprovisioning ����������������������������������������������������������������������������������������������������������������������� 17 Summary������������������������������������������������������������������������������������������������������������������������������������� 17 Key Points ������������������������������������������������������������������������������������������������������������������������������ 17  Chapter 3: Evolution of Identity ������������������������������������������������������������������������������ 19 Identity Management Approaches ���������������������������������������������������������������������������������������������� 19 Per-Application Identity Silo �������������������������������������������������������������������������������������������������� 20 Centralized User Repository �������������������������������������������������������������������������������������������������� 20 Early SSO Servers ������������������������������������������������������������������������������������������������������������������ 21 Federated Identity and SAML 2�0 ������������������������������������������������������������������������������������������ 22 WS-Fed ���������������������������������������������������������������������������������������������������������������������������������� 23 OpenID ����������������������������������������������������������������������������������������������������������������������������������� 24 OAuth 2�0 ������������������������������������������������������������������������������������������������������������������������������� 24 OpenID Connect  OIDC  ���������������������������������������������������������������������������������������������������������� 25 Standard Protocols ���������������������������������������������������������������������������������������������������������������������� 26 Summary������������������������������������������������������������������������������������������������������������������������������������� 27 Key Points ������������������������������������������������������������������������������������������������������������������������������ 27 Notes ������������������������������������������������������������������������������������������������������������������������������������������� 27  Chapter 4: Identity Provisioning ����������������������������������������������������������������������������� 29 Provisioning Options ������������������������������������������������������������������������������������������������������������������� 29 Self-Registration �������������������������������������������������������������������������������������������������������������������� 30 Identity Migration ������������������������������������������������������������������������������������������������������������������ 32 Administrative Account Creation ������������������������������������������������������������������������������������������� 36 Leverage Existing Identity Service ���������������������������������������������������������������������������������������� 38 Selecting an External Identity Service ���������������������������������������������������������������������������������������� 39 Self-Registered Identities ������������������������������������������������������������������������������������������������������ 40 Organization Identities ����������������������������������������������������������������������������������������������������������� 41 Government Identities ����������������������������������������������������������������������������������������������������������� 41 Industry Consortium Identities ���������������������������������������������������������������������������������������������� 42 Identity Provider Selection ���������������������������������������������������������������������������������������������������������� 42  iv   Table of ConTenTs  Choosing and Validating Identity Attributes �������������������������������������������������������������������������������� 44 Suggestions ��������������������������������������������������������������������������������������������������������������������������� 46 Validating Critical Attributes �������������������������������������������������������������������������������������������������� 47 Summary������������������������������������������������������������������������������������������������������������������������������������� 48 Key Points ������������������������������������������������������������������������������������������������������������������������������ 48 Notes ������������������������������������������������������������������������������������������������������������������������������������������� 49  Chapter 5: OAuth 2�0 and API Authorization ����������������������������������������������������������� 51 API Authorization ������������������������������������������������������������������������������������������������������������������������� 51 OAuth 2�0 ������������������������������������������������������������������������������������������������������������������������������������ 53 Terminology �������������������������������������������������������������������������������������������������������������������������������� 55 Roles �������������������������������������������������������������������������������������������������������������������������������������� 55 Confidential vs� Public Clients ����������������������������������������������������������������������������������������������� 56 Client Profiles ������������������������������������������������������������������������������������������������������������������������ 56 Tokens and Authorization Code ��������������������������������������������������������������������������������������������� 57 How It Works ������������������������������������������������������������������������������������������������������������������������������� 57 Authorization Code Grant ������������������������������������������������������������������������������������������������������� 57 Implicit Grant ������������������������������������������������������������������������������������������������������������������������� 64 Resource Owner Password Credentials Grant ����������������������������������������������������������������������� 67 Client Credentials Grant ��������������������������������������������������������������������������������������������������������� 69 Calling an API ������������������������������������������������������������������������������������������������������������������������� 71 Refresh Token ������������������������������������������������������������������������������������������������������������������������ 71 Guidance �������������������������������������������������������������������������������������������������������������������������������� 73 Summary������������������������������������������������������������������������������������������������������������������������������������� 74 Key Points ������������������������������������������������������������������������������������������������������������������������������ 74 Notes ������������������������������������������������������������������������������������������������������������������������������������������� 75  Chapter 6: OpenID Connect ������������������������������������������������������������������������������������� 77 Problem to Solve ������������������������������������������������������������������������������������������������������������������������� 77 Terminology �������������������������������������������������������������������������������������������������������������������������������� 79 Roles �������������������������������������������������������������������������������������������������������������������������������������� 79 Client Types ��������������������������������������������������������������������������������������������������������������������������� 79 Tokens and Authorization Code ��������������������������������������������������������������������������������������������� 79 v   Table of ConTenTs  Endpoints ������������������������������������������������������������������������������������������������������������������������������� 80 ID Token ��������������������������������������������������������������������������������������������������������������������������������� 80 How It Works ������������������������������������������������������������������������������������������������������������������������������� 82 OIDC Flows ���������������������������������������������������������������������������������������������������������������������������� 83 OIDC Authorization Code Flow ����������������������������������������������������������������������������������������������� 83 OIDC Implicit Flow ����������������������������������������������������������������������������������������������������������������� 89 OIDC Hybrid Flow ������������������������������������������������������������������������������������������������������������������� 92 UserInfo Endpoint ������������������������������������������������������������������������������������������������������������������������ 94 Summary������������������������������������������������������������������������������������������������������������������������������������� 95 Key Points ������������������������������������������������������������������������������������������������������������������������������ 96 Notes ������������������������������������������������������������������������������������������������������������������������������������������� 96  Chapter 7: SAML 2�0 �����������������������������������������������������������������������������������������������  99 Problem to Solve ������������������������������������������������������������������������������������������������������������������������� 99 Terminology ������������������������������������������������������������������������������������������������������������������������������ 100 How It Works ����������������������������������������������������������������������������������������������������������������������������� 101 SP-Initiated SSO ������������������������������������������������������������������������������������������������������������������ 102 Single Sign-On ��������������������������������������������������������������������������������������������������������������������� 103 IdP-Initiated Flow ���������������������������������������������������������������������������������������������������������������� 103 Identity Federation ��������������������������������������������������������������������������������������������������������������� 105 Authentication Brokers ������������������������������������������������������������������������������������������������������������� 107 Configuration����������������������������������������������������������������������������������������������������������������������������� 108 Summary����������������������������������������������������������������������������������������������������������������������������������� 109 Key Points ���������������������������������������������������������������������������������������������������������������������������� 110 Notes ����������������������������������������������������������������������������������������������������������������������������������������� 111  Chapter 8: Authorization and Policy Enforcement ������������������������������������������������ 113 Authorization vs� Policy Enforcement���������������������������������������������������������������������������������������� 113 Levels of Authorization and Access Policy Enforcement ����������������������������������������������������� 114 User vs� Application Authorization �������������������������������������������������������������������������������������������� 115 User Authorization ��������������������������������������������������������������������������������������������������������������� 116 Delivery ������������������������������������������������������������������������������������������������������������������������������� 117 Enforcement ������������������������������������������������������������������������������������������������������������������������ 119  vi   Table of ConTenTs  Application Authorization ���������������������������������������������������������������������������������������������������������� 119 Application Attributes ���������������������������������������������������������������������������������������������������������� 119 Authorization ����������������������������������������������������������������������������������������������������������������������� 120 Delivery ������������������������������������������������������������������������������������������������������������������������������� 120 Enforcement ������������������������������������������������������������������������������������������������������������������������ 120 Summary����������������������������������������������������������������������������������������������������������������������������������� 121 Key Points ���������������������������������������������������������������������������������������������������������������������������� 121 Notes ����������������������������������������������������������������������������������������������������������������������������������������� 122  Chapter 9: Sample Application with Custom API �������������������������������������������������� 123 Background ������������������������������������������������������������������������������������������������������������������������������� 124 Application Requirements ��������������������������������������������������������������������������������������������������� 125 Platform, Framework, and Identity Provider ������������������������������������������������������������������������ 128 API ��������������������������������������������������������������������������������������������������������������������������������������������� 129 Protect the API ��������������������������������������������������������������������������������������������������������������������� 130 API Implementation ������������������������������������������������������������������������������������������������������������� 132 Extensibility and Adding Custom Claims ����������������������������������������������������������������������������� 134 Front End ����������������������������������������������������������������������������������������������������������������������������������� 136 Front-End Functions ������������������������������������������������������������������������������������������������������������ 136 Summary����������������������������������������������������������������������������������������������������������������������������������� 140 Key Points ���������������������������������������������������������������������������������������������������������������������������� 141 Note������������������������������������������������������������������������������������������������������������������������������������������� 141  Chapter 10: Sessions �������������������������������������������������������������������������������������������� 143 Application Sessions ����������������������������������������������������������������������������������������������������������������� 143 Identity Provider Sessions ��������������������������������������������������������������������������������������������������������� 145 Multiple Sessions ���������������������������������������������������������������������������������������������������������������������� 145 Session Duration ����������������������������������������������������������������������������������������������������������������������� 146 Session Renewal ����������������������������������������������������������������������������������������������������������������������� 148 Token Renewal �������������������������������������������������������������������������������������������������������������������������� 148  vii   Table of ConTenTs  Reconstituted Sessions  ������������������������������������������������������������������������������������������������������������ 150 Summary����������������������������������������������������������������������������������������������������������������������������������� 150 Key Points ���������������������������������������������������������������������������������������������������������������������������� 150  Chapter 11: Single Sign-On ���������������������������������������������������������������������������������� 151 What Is SSO? ���������������������������������������������������������������������������������������������������������������������������� 151 How SSO Works ������������������������������������������������������������������������������������������������������������������������ 152 SSO Session Attributes ������������������������������������������������������������������������������������������������������������� 154 SSO Session Duration ���������������������������������������������������������������������������������������������������������� 154 Multiple Identity Providers ��������������������������������������������������������������������������������������������������� 155 Authentication Mechanisms ������������������������������������������������������������������������������������������������ 155 Login Page Branding ����������������������������������������������������������������������������������������������������������� 156 Summary����������������������������������������������������������������������������������������������������������������������������������� 156 Key Points ���������������������������������������������������������������������������������������������������������������������������� 156 Note������������������������������������������������������������������������������������������������������������������������������������������� 157  Chapter 12: Stronger Authentication �������������������������������������������������������������������� 159 The Problem with Passwords ��������������������������������������������������������������������������������������������������� 159 Stronger Forms of Authentication ��������������������������������������������������������������������������������������������� 160 Multi-factor Authentication �������������������������������������������������������������������������������������������������� 161 Step-Up Authentication ������������������������������������������������������������������������������������������������������� 162 Session Timeouts ���������������������������������������������������������������������������������������������������������������������� 163 Requesting Authentication Mechanisms ����������������������������������������������������������������������������������� 163 SAML 2�0 ����������������������������������������������������������������������������������������������������������������������������� 163 OIDC ������������������������������������������������������������������������������������������������������������������������������������� 164 Step-Down Authentication �������������������������������������������������������������������������������������������������������� 164 Deployment ������������������������������������������������������������������������������������������������������������������������������� 165 Summary����������������������������������������������������������������������������������������������������������������������������������� 165 Key Points ���������������������������������������������������������������������������������������������������������������������������� 165 Notes ����������������������������������������������������������������������������������������������������������������������������������������� 166  viii   Table of ConTenTs  Chapter 13: Logout ����������������������������������������������������������������������������������������������� 167 Multiple Sessions ���������������������������������������������������������������������������������������������������������������������� 167 Logout Triggers ������������������������������������������������������������������������������������������������������������������������� 169 Logout Options �������������������������������������������������������������������������������������������������������������������������� 170 Application Logout �������������������������������������������������������������������������������������������������������������������� 172 OAuth 2�0 ���������������������������������������������������������������������������������������������������������������������������������� 172 OIDC ������������������������������������������������������������������������������������������������������������������������������������������ 173 SAML 2�0 ����������������������������������������������������������������������������������������������������������������������������������� 175 Session Termination ������������������������������������������������������������������������������������������������������������������ 177 Logout and Multilevel Authentication ���������������������������������������������������������������������������������������� 177 Redirect After Logout ���������������������������������������������������������������������������������������������������������������� 177 Summary����������������������������������������������������������������������������������������������������������������������������������� 178 Key Points ���������������������������������������������������������������������������������������������������������������������������� 178 Notes ����������������������������������������������������������������������������������������������������������������������������������������� 179  Chapter 14: Account Management ����������������������������������������������������������������������� 181 Identity Attributes ���������������������������������������������������������������������������������������������������������������������� 181 Credential Reset ������������������������������������������������������������������������������������������������������������������������ 183 Account Recovery ��������������������������������������������������������������������������������������������������������������������� 183 Password Guidance ������������������������������������������������������������������������������������������������������������������ 184 Helpdesk Reset ������������������������������������������������������������������������������������������������������������������������� 184 Summary����������������������������������������������������������������������������������������������������������������������������������� 185 Key Points ���������������������������������������������������������������������������������������������������������������������������� 185 Notes ����������������������������������������������������������������������������������������������������������������������������������������� 186  Chapter 15: Deprovisioning ���������������������������������������������������������������������������������� 187 Account Termination ����������������������������������������������������������������������������������������������������������������� 187 Best Practices ��������������������������������������������������������������������������������������������������������������������������� 188 Just Do It! ���������������������������������������������������������������������������������������������������������������������������� 188 Provide a Soft Delete Technique ������������������������������������������������������������������������������������������ 188 Reserve Deprovisioned Identities ���������������������������������������������������������������������������������������� 189  ix   Table of ConTenTs  Preserve Account Record ���������������������������������������������������������������������������������������������������� 189 Data Transfer ����������������������������������������������������������������������������������������������������������������������� 190 Privacy Right to Erasure ������������������������������������������������������������������������������������������������������ 191 Certificate of Deletion ���������������������������������������������������������������������������������������������������������� 191 Secure Delete ���������������������������������������������������������������������������������������������������������������������� 192 Consider Reprovisioning Requirements ������������������������������������������������������������������������������ 193 Summary����������������������������������������������������������������������������������������������������������������������������������� 193 Key Points ���������������������������������������������������������������������������������������������������������������������������� 193 Notes ����������������������������������������������������������������������������������������������������������������������������������������� 194  Chapter 16: Troubleshooting ��������������������������������������������������������������������������������� 195 Get Familiar with the Protocols ������������������������������������������������������������������������������������������������� 195 Prepare Your Tools ��������������������������������������������������������������������������������������������������������������������� 196 Test Environment ����������������������������������������������������������������������������������������������������������������� 196 Independent Browser Windows ������������������������������������������������������������������������������������������� 196 Capture HTTP Traces ����������������������������������������������������������������������������������������������������������� 197 View HTTP Traces ���������������������������������������������������������������������������������������������������������������� 197 Make API Calls ��������������������������������������������������������������������������������������������������������������������� 198 View API Calls ���������������������������������������������������������������������������������������������������������������������� 198 View JWT and SAML 2�0 Tokens ������������������������������������������������������������������������������������������ 198 Check the Simple Things ���������������������������������������������������������������������������������������������������������� 198 Gather Information �������������������������������������������������������������������������������������������������������������������� 199 How Many Users Impacted? ������������������������������������������������������������������������������������������������ 199 Contributing Environmental Factors? ���������������������������������������������������������������������������������� 200 Which Applications Impacted? �������������������������������������������������������������������������������������������� 200 Consistent or Intermittent Issue? ���������������������������������������������������������������������������������������� 200 Worked Previously? ������������������������������������������������������������������������������������������������������������� 200 Where Does Failure Occur? ������������������������������������������������������������������������������������������������� 201 Replicate the Problem ��������������������������������������������������������������������������������������������������������������� 201 Analyzing an HTTP Network Trace �������������������������������������������������������������������������������������������� 201 Capture a Trace �������������������������������������������������������������������������������������������������������������������� 201 Check Sequence of Interaction �������������������������������������������������������������������������������������������� 202  x   Table of ConTenTs  Check Parameters in Requests ������������������������������������������������������������������������������������������� 203 Check HTTP Status Codes ��������������������������������������������������������������������������������������������������� 203 Check Security Token Contents ������������������������������������������������������������������������������������������� 204 Check for Security Token Validation Errors �������������������������������������������������������������������������� 205 Collaborating with Others ���������������������������������������������������������������������������������������������������� 205 Summary����������������������������������������������������������������������������������������������������������������������������������� 206 Key Points ���������������������������������������������������������������������������������������������������������������������������� 206 Note������������������������������������������������������������������������������������������������������������������������������������������� 206  Chapter 17: Exceptions ����������������������������������������������������������������������������������������� 207 Accounts ����������������������������������������������������������������������������������������������������������������������������������� 207 Data Restore ������������������������������������������������������������������������������������������������������������������������ 207 Account Decommission ������������������������������������������������������������������������������������������������������� 208 Orphaned Account ��������������������������������������������������������������������������������������������������������������� 209 Account Takeover ���������������������������������������������������������������������������������������������������������������� 209 Phone Lost, Damaged, or Stolen ������������������������������������������������������������������������������������������ 210 Identity Providers ���������������������������������������������������������������������������������������������������������������������� 210 Account Recovery Requests ������������������������������������������������������������������������������������������������ 210 Brute Force Attacks ������������������������������������������������������������������������������������������������������������� 211 Breached Passwords ����������������������������������������������������������������������������������������������������������� 212 System Outages ������������������������������������������������������������������������������������������������������������������������ 212 Authentication System Outage �������������������������������������������������������������������������������������������� 212 Admin Access ���������������������������������������������������������������������������������������������������������������������� 213 Provisioning Systems ���������������������������������������������������������������������������������������������������������� 213 Compromised Security Information ������������������������������������������������������������������������������������������ 214 Compromised Personal Data ����������������������������������������������������������������������������������������������� 214 Compromised Credentials ��������������������������������������������������������������������������������������������������� 215 Compromised Secrets ��������������������������������������������������������������������������������������������������������� 215 Summary����������������������������������������������������������������������������������������������������������������������������������� 216 Key Points ���������������������������������������������������������������������������������������������������������������������������� 216 Notes ����������������������������������������������������������������������������������������������������������������������������������������� 217  xi   Table of ConTenTs  Chapter 18: Less Common Requirements ������������������������������������������������������������� 219 People ��������������������������������������������������������������������������������������������������������������������������������������� 219 Family Accounts ������������������������������������������������������������������������������������������������������������������ 219 Temporary Positions ������������������������������������������������������������������������������������������������������������ 220 Status Transition ������������������������������������������������������������������������������������������������������������������ 220 No Email Address ���������������������������������������������������������������������������������������������������������������� 220 Identity Defederation ����������������������������������������������������������������������������������������������������������� 221 Accounts ����������������������������������������������������������������������������������������������������������������������������������� 221 Mergers and Acquisitions ���������������������������������������������������������������������������������������������������� 221 Account Linking ������������������������������������������������������������������������������������������������������������������� 222 Progressive Profiling ����������������������������������������������������������������������������������������������������������� 224 Impersonation���������������������������������������������������������������������������������������������������������������������� 224 Delegation ��������������������������������������������������������������������������������������������������������������������������� 225 Environment ������������������������������������������������������������������������������������������������������������������������������ 225 Shared Workstations ����������������������������������������������������������������������������������������������������������� 225 Identity Provider Discovery �������������������������������������������������������������������������������������������������� 226 Multitenant Applications ������������������������������������������������������������������������������������������������������ 227 Summary����������������������������������������������������������������������������������������������������������������������������������� 227 Key Points ���������������������������������������������������������������������������������������������������������������������������� 228  Chapter 19: Failures ��������������������������������������������������������������������������������������������� 229 Pay Attention to Process ����������������������������������������������������������������������������������������������������������� 229 Beware of Phishy Emails ����������������������������������������������������������������������������������������������������������� 230 Use Multi-factor Authentication ������������������������������������������������������������������������������������������������ 231 Stay on Top of Patches �������������������������������������������������������������������������������������������������������������� 231 Secure Your Cloud ��������������������������������������������������������������������������������������������������������������������� 232 Encrypt Sensitive Data! ������������������������������������������������������������������������������������������������������������� 232 Do Not Store Cleartext Passwords �������������������������������������������������������������������������������������������� 233 Provide Security Training to Developers ����������������������������������������������������������������������������������� 233 Vet Your Partners ����������������������������������������������������������������������������������������������������������������������� 234 Insider Threat ���������������������������������������������������������������������������������������������������������������������������� 235  xii   Table of ConTenTs  Summary����������������������������������������������������������������������������������������������������������������������������������� 236 Key Points ���������������������������������������������������������������������������������������������������������������������������� 236 Notes ����������������������������������������������������������������������������������������������������������������������������������������� 237  Chapter 20: Compliance ��������������������������������������������������������������������������������������� 241 What Is Compliance? ���������������������������������������������������������������������������������������������������������������� 241 Government-Mandated Compliance ������������������������������������������������������������������������������������ 242 Industry Compliance ������������������������������������������������������������������������������������������������������������ 243 Elective Compliance Frameworks ��������������������������������������������������������������������������������������� 244 Why Compliance ����������������������������������������������������������������������������������������������������������������������� 244 Data Protection �������������������������������������������������������������������������������������������������������������������� 244 Competitive Advantage �������������������������������������������������������������������������������������������������������� 245 Reduce Penalties ����������������������������������������������������������������������������������������������������������������� 245 Efficiency ����������������������������������������������������������������������������������������������������������������������������� 245 Compliance Landscape ������������������������������������������������������������������������������������������������������������� 246 Security Compliance ������������������������������������������������������������������������������������������������������������ 247 Privacy Compliance ������������������������������������������������������������������������������������������������������������� 247 Assessment and Certification ���������������������������������������������������������������������������������������������� 248 How to Proceed ������������������������������������������������������������������������������������������������������������������������� 249 Summary����������������������������������������������������������������������������������������������������������������������������������� 250 Key Points ���������������������������������������������������������������������������������������������������������������������������� 250 Notes ����������������������������������������������������������������������������������������������������������������������������������������� 251  Chapter 21: Looking into the Crystal Ball ������������������������������������������������������������� 253 Continued Security Challenges ������������������������������������������������������������������������������������������������� 254 Ongoing Breaches ��������������������������������������������������������������������������������������������������������������� 254 Evolving Targets ������������������������������������������������������������������������������������������������������������������� 254 Diversifying Motives ������������������������������������������������������������������������������������������������������������ 255 More Targets ����������������������������������������������������������������������������������������������������������������������������� 255 Homes and Businesses ������������������������������������������������������������������������������������������������������� 255 Cars ������������������������������������������������������������������������������������������������������������������������������������� 256 Medical Implants and Monitoring ���������������������������������������������������������������������������������������� 256  xiii   Table of ConTenTs  Robots ��������������������������������������������������������������������������������������������������������������������������������� 257 Erosion of Perimeter Protection������������������������������������������������������������������������������������������� 258 Identity – Not Just for Humans ������������������������������������������������������������������������������������������������� 258 Personal Agents ������������������������������������������������������������������������������������������������������������������� 259 Autonomous Vehicles ���������������������������������������������������������������������������������������������������������� 259 IoT Devices �������������������������������������������������������������������������������������������������������������������������� 260 Robots ��������������������������������������������������������������������������������������������������������������������������������� 260 On the Horizon �������������������������������������������������������������������������������������������������������������������������� 260 e-Identity ����������������������������������������������������������������������������������������������������������������������������� 261 Stronger Authentication ������������������������������������������������������������������������������������������������������� 262 Solutions for Smaller Devices ��������������������������������������������������������������������������������������������� 262 Easier Adoption �������������������������������������������������������������������������������������������������������������������� 262 Summary����������������������������������������������������������������������������������������������������������������������������������� 263 Key Points ���������������������������������������������������������������������������������������������������������������������������� 263 Notes ����������������������������������������������������������������������������������������������������������������������������������������� 264  Chapter 22: Conclusion ����������������������������������������������������������������������������������������� 267  Appendix A: Glossary �������������������������������������������������������������������������������������������� 269  Appendix B: Resources for Further Learning �������������������������������������������������������� 273 OAuth 2�0 ����������������������������������������������������������������������������������������������������������������������������������  273 JWT ������������������������������������������������������������������������������������������������������������������������������������������� 274 OIDC ������������������������������������������������������������������������������������������������������������������������������������������ 274 SAML ����������������������������������������������������������������������������������������������������������������������������������������� 274 Multi-factor Authentication ������������������������������������������������������������������������������������������������������� 274 Background Information ����������������������������������������������������������������������������������������������������������� 275 Privacy �������������������������������������������������������������������������������������������������������������������������������������� 275  Appendix C: SAML V2�0 Authentication Request and Response ��������������������������� 277 SAML V2�0 Authentication Request ������������������������������������������������������������������������������������������� 277 SAML V2�0 Authentication Response ���������������������������������������������������������������������������������������� 279 Response ����������������������������������������������������������������������������������������������������������������������������� 281  xiv   Table of ConTenTs  Appendix D: Public Key Cryptography ������������������������������������������������������������������ 287  Appendix E: Troubleshooting Tools ����������������������������������������������������������������������� 289 Capture an HTTP Trace �������������������������������������������������������������������������������������������������������������� 289 View a HAR File ������������������������������������������������������������������������������������������������������������������������� 290 Capture a Network Trace ����������������������������������������������������������������������������������������������������������� 291 View Security Tokens ���������������������������������������������������������������������������������������������������������������� 291 Test APIs ������������������������������������������������������������������������������������������������������������������������������������ 292  Appendix F: Privacy Legislation ��������������������������������������������������������������������������� 293 European Union ������������������������������������������������������������������������������������������������������������������������� 293 United States ����������������������������������������������������������������������������������������������������������������������������� 294 Other Countries ������������������������������������������������������������������������������������������������������������������������� 296 Notes ����������������������������������������������������������������������������������������������������������������������������������������� 296  Appendix G: Security Compliance Frameworks ���������������������������������������������������� 299 General Security Frameworks ��������������������������������������������������������������������������������������������������� 299  Center for Internet Security – Top 20 Controls �������������������������������������������������������������������� 299  Cloud Security Alliance �������������������������������������������������������������������������������������������������������� 299  ISO 27000 ���������������������������������������������������������������������������������������������������������������������������� 300  PCI DSS �������������������������������������������������������������������������������������������������������������������������������� 300 US Frameworks ������������������������������������������������������������������������������������������������������������������������� 301  CJIS Security Policy – Criminal Justice Information Services Security Policy �������������������� 301  FFIEC Information Technology Examination Handbook and Cybersecurity   Assessment Tool ������������������������������������������������������������������������������������������������������������������ 301  FISMA – Federal Information Security Management Act ����������������������������������������������������� 301  FedRAMP – Federal Risk and Authorization Management Program ����������������������������������� 302  GLBA Safeguards Rule ��������������������������������������������������������������������������������������������������������� 302 HIPAA ����������������������������������������������������������������������������������������������������������������������������������� 302  HITECH Act ��������������������������������������������������������������������������������������������������������������������������� 302  NIST ������������������������������������������������������������������������������������������������������������������������������������� 302  xv   Table of ConTenTs  SOC  Service Organization Control  ������������������������������������������������������������������������������������������� 303 SOC1 ������������������������������������������������������������������������������������������������������������������������������������ 303 SOC2 ������������������������������������������������������������������������������������������������������������������������������������ 303 Notes ����������������������������������������������������������������������������������������������������������������������������������������� 303  Index ��������������������������������������������������������������������������������������������������������������������� 305  xvi   About the Authors  Yvonne Wilson has had many roles in the software industry  related to security and identity management as a security  and identity architect; enterprise architect; director of  developer success working with identity customers; sr.  director of security governance, risk, and compliance; and  founder of cloud identity services. Yvonne was responsible  for IT security strategy and architecture at Sun Microsystems,  founded and designed the identity management services  offered through Oracle Managed Cloud Services, and  founded a developer success team for Auth0, working  with customers and overseeing the creation of an identity  management training program for customer-facing support and professional services  engineers.  In working with business teams at Sun, designing and deploying identity systems   for customers at Oracle, and while founding a developer success team at Auth0, Yvonne  had the opportunity of working with many customers, from small startups to large  enterprises. Her experience spans the implementation of SSO, identity federation,  directory services, adaptive knowledge-based authentication, and identity provisioning  as well as multilevel authentication systems with certificate-based authentication.  She has worked with OIDC, SAML 2.0, WS-Fed, OAuth2.0, and OpenID. From this  depth of experience, Yvonne realized the growing need for a basic overview of identity  management concepts that is understandable to business application owners as well as  architects and developers.    xvii   abouT The auThors  Abhishek Hingnikar is a Solutions Engineering Specialist  at Auth0. He has several years of experience designing and  demonstrating Identity Management solutions to customers  using Auth0 using OAuth 2.0, OpenID Connect and SAML  2.0. His current focus areas involve Consumer IoT, Device  Based Identity and designing solutions that explore web  based identity in peripheral domains.    xviii   About the Technical Reviewers  Jared Hanson is a software engineer with experience  across the full stack of desktop, mobile, and server- side application development. Jared is the developer of  Passport.js, the popular Node.js authentication framework,  and a contributor to the OpenID and OAuth family of  specifications. He has worked as an architect at both Auth0  and Okta, leading companies in the identity and access  management industry.      Carlos Mostek has over two decades of professional  experience developing software. He has a Master of Science in  Software Engineering and a Bachelor of Science in Aerospace  Engineering, both from the University of Minnesota. He has  had a wide breadth of software experience and expertise across  highly security-sensitive industries: defense contracting,  financial markets, and currently, identity and security.  Throughout his career, he has filled a variety of roles: test  engineer, developer, architect, manager, director, and solution  architect. Through most of his time at Auth0, he has worked  with a wide range of customers, providing him a unique view  of myriad identity-related use cases. He lives in Minnesota with  his wife and three extremely active kids. He loves spending quality time with his friends and  family, playing and coaching soccer, hiking, playing video games, and juggling fire.  xix   Acknowledgments  The best way to find yourself is to lose yourself in the service of others.  —Mahatma Gandhi  This book would not have been possible without the generous help of many friends and  coworkers who have graciously shared their expertise and knowledge to review and  improve the original draft. It has been a pleasure working with each of them over the  years, and we are fortunate and much indebted for the knowledge, wisdom, and insights  they have shared with us as well as, on occasion, the laughs.  Massive, massive appreciation and heartfelt thanks to Carlos Mostek for careful   reviews of early and later drafts of this book and contributing many corrections,  insightful additions, and helpful advice from his trove of development and IAM wisdom  as well as his experience helping many customers solve their IAM challenges over the  years.  Immense, heartfelt thanks also to Peter Stromquist for thoroughly reviewing the   draft version of this book and adding many corrections, suggesting additional ideas we’d  left out, and adding wisdom from his valuable store of development and IAM expertise  developed while designing solutions for many, many customers.  Huge, sincere gratitude to Amaan Cheval for careful reviews of the draft for this book  and contributing many corrections, clarifications, and suggestions for additional content  from his keen knowledge of IAM topics, customer challenges, and broad development  experience.  Enormous and ardent thank you to Nicolas Philippe for thorough reviews from his   extensive identity, security, and development experience; suggesting clarifications,  additional topics requiring explanation; and adding wisdom from his years of experience  with IAM as well as application development.  Titanic, sincere thanks also to Nicolás Sabena for excellent, careful reviews and   contributing much valuable guidance on troubleshooting from his extensive expertise  in IAM and development, as well as his keen ability to solve even the most puzzling  customer issues.  xxi   aCknowledgmenTs  Huge, grateful thanks to Jared Hanson for generously answering many questions and   for reviewing and contributing corrections to many chapters of this book from his deep  knowledge of identity protocols.  Massive gratitude and thanks as well to Vittorio Bertocci for graciously sharing his  extensive IAM knowledge in many forums, from which we and others have learned a  great deal, and for reviewing portions of this book with an eagle eye, providing valuable  critique on errors in content, logic, and flow as well as suggestions for improvements and  kind advice about writing.  Immense gratitude is due to Erin Richards for careful reviews, corrections, and   additions on compliance matters, adding wisdom and practical advice from her long  experience in this field as well as content on privacy and security frameworks.  Huge appreciation also to Adam Nunn for thorough reviews, corrections, and   suggestions for the compliance chapter based on his wisdom and experience in  technical audits and compliance.  Sincere gratitude to Bill Soley for commiseration during the project as well as review   and contributing suggestions and advice from his immense knowledge of security  matters.  Much appreciation also to Subra Kumaraswamy for reviewing a portion of this book   and contributing suggestions from his experience in both IAM and security.  Immeasurable and heartfelt gratitude to Laura Hill for insightful editorial reviews,  finding the logic disconnects in early drafts and making numerous suggestions for how  to cut out extraneous fluff and clarify explanations. Many thanks as well for patiently  listening and providing encouragement as this project took shape!  Colossal thanks to Terence Rabuzzi for his razor-sharp editorial reviews and advice   on everything from graphics to structure and approaches for evaluating the logic of  many sections.  Tremendous thanks to the creative eye, graphic talents, and technical knowledge of   Liliya Pustovoyt for creating diagrams to illustrate several of the concepts discussed in  the book.  We also owe a huge debt of gratitude to Rita Fernando, Susan McDermott, Laura   Berendson, and the rest of the Apress team for their patient advice, answering numerous  questions, clear guidance, and editing on the text and graphics for this project.  A final massive and heartfelt thank you is due to our dear friends and family for  their patience and support during this very long project. The kind words and voices   xxii   aCknowledgmenTs  of encouragement throughout meant a lot during the long hours of research, writing,  development, and editing.  We are incredibly grateful to all who helped make this project possible by reviewing   early drafts and contributing suggestions, advice, corrections, and additions. The text has  been immeasurably improved by our reviewers’ careful attention and many insightful  comments. We could not have done this without them. That said, a line by Albert Camus  is appropriate here: “The only real progress lies in learning to be wrong all alone.” Any  errors in the final text are solely ours. Any errata we discover after the book is published  will be noted in the Apress GitHub repo for the book, accessible via https:  www. apress.com us book 9781484250945.  xxiii   Introduction  Every day you play with the light of the universe.  —Pablo Neruda, Chilean poet, politician, and diplomat,   from Twenty Love Poems and a Song of Despair  1925   There is a significant and growing cybersecurity workforce gap. A Global Information  Security Workforce Study1 predicts a cybersecurity workforce gap of 1.8 million  individuals by 2022. At a time when the number of online services and devices that  need security is growing rapidly, this is nothing short of alarming. In order to fill this  gap, it is imperative to encourage more people to learn about this field and provide  adequate resources for them to efficiently come up to speed. Identity management is an  important component of security which is critical to protect the rapidly expanding array  of innovative online services, smart devices, bots, automated agents, and the like that are  being created.  The authors of this book are fortunate to have been a part of this field for some   time. Between the two of us, we have created and deployed a variety of different types  of applications, single sign-on, identity federation, provisioning systems for various  access control models, directory services, and various forms of strong authentication.  We have had the pleasure of working closely with many customers to understand their  unique requirements and help them design and deploy identity and access management  systems in both cloud and enterprise environments. We’ve learned many lessons from  these projects, some of them the hard way through the school of hard knocks!  We wrote this book to share what we’ve learned from our experiences. We hope to  provide others a head start based on the lessons we’ve learned. Our intent is to provide  an introduction for those who are new to identity management and inspire them to  continue learning more about this topic. We provide an overview of three identity  management protocols, namely, OIDC, OAuth 2.0, and SAML 2.0, that will be useful  for application developers who need to add authentication and authorization to their   1 www.prnewswire.com news-releases global-cybersecurity-workforce-shortage-to-reach- 18-million-as-threats-loom-larger-and-stakes-rise-higher-300469866.html  xxv   InTroduCTIon  applications and APIs. We’ve covered the problem each protocol is designed to solve,  how to initiate basic requests, and how to troubleshoot issues. A sample program  accompanies the book and illustrates some of the concepts. We’ve also provided  information on typical identity management requirements to help you identify what  to include in your project plan, things that can go wrong that should be planned for,  common mistakes, and how to approach compliance. These chapters will be valuable  for developers as well as architects, technical project managers, and members of security  teams involved with application development projects.  In terms of scope, the book is designed to provide an introduction to identity   management. We cover how the three identity protocols can be used to solve common  use cases for authentication and authorization that you will encounter in creating an  application. We don’t have space to cover every protocol, corner case, or every nuance  of the protocols. We also can’t cover every detail in the specifications for the protocols.  Our intent is to give you an overview that will help you get started and provide sufficient  background to help you more fully understand more in-depth materials.  We are extremely grateful to numerous colleagues who’ve generously contributed to   this book through reviewing original drafts and providing corrections and feedback on  what we missed, what might be misunderstood, and what is most valuable for people to  know. This project would not have been possible without their assistance and expertise,  as noted in the acknowledgements. That said, any errors are completely our own. Any  errata we discover after the book is published will be noted in the Apress GitHub repo for  the book, accessible via https:  www.apress.com us book 9781484250945.  We hope this book and the sample code are useful to you and wish you luck and   security for your application projects!  xxvi   CHAPTER 1  The Hydra of Modern  Identity  Wisdom is not a product of schooling but of the lifelong attempt to acquire it.  —Albert Einstein, theoretical physicist, from a letter dated March 24, 1954  So, you’re ready to bring your next big application idea to life. You’ve spent a lot of time  researching, developing, and perfecting the architecture, features, algorithms, and user  experience, and you’re excited to bring your solution to market. Then you start thinking  about users and realize your application needs some identity management! You start  looking into what it takes to create accounts, authenticate users, provide multi-factor  authentication, and make all this work smoothly across multiple devices. That’s when  you start to feel like you are fighting a Hydra, the mythical beast from Greek mythology  with nine heads. When any one of her heads was cut off, two more grew back in its place.  In the same way, solving one identity management challenge can lead to more if you  don’t have a good plan for how to approach identity management.   Identity Challenges While identity management is a simple concept in theory, many factors need to  work together for it to work well in practice. It requires careful planning, design, and  development to implement identity management for an application while balancing the  myriad expectations stemming from business requirements and security, not to mention  the need to provide a great user experience. Unfortunately, identity management isn’t a  one-size-fits-all proposition. There isn’t a master solution we can provide that fits every  use case.    Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2_1  1   Chapter 1    the hydra of Modern IdentIty  To give you an example, here are a few of the many disparate challenges you might   need to think about. A consumer-facing application may have users who expect the  ability to log in quickly using a social provider like Facebook. They may even want  the ability to use multiple social providers to log in to your application and still be  recognized as the same person. You’ll want to handle this requirement gracefully,  otherwise users might abandon your application because it’s a hassle to sign up and log  in. On the other hand, employee users need to access corporate applications via their  work account, and they want the convenience of single sign-on. What’s more, corporate  organizations typically have complex authorization requirements, often based on roles,  to govern permissions for what the employees in the organization can do.  An application with sensitive content might require stronger forms of authentication   than a simple password, but this requires determining which forms of authentication  provide adequate security while still being convenient for users. There are many  options for strong authentication, varying from one-time passwords generated on a  device to push notifications sent to a mobile phone or hardware security tokens with  private cryptographic keys. You need solutions that are easy for users to adopt and use  because cumbersome solutions may result in users circumventing the solution or simply  abandoning the application entirely.  If you offer multiple applications, or even a support portal in addition to your  application, your users will likely want single sign-on so they can log in once and  access multiple applications. This provides convenience to users as well as a single  place to control authentication policy. However, authentication is the gateway to your  application. It must be highly available and capable of scaling up higher than your  application s ; otherwise, it will suddenly become an obstacle rather than a gateway.  Single sign-on is not a benefit if it impedes access to your applications!  Your application design may need to accommodate various constraints from your  delivery platform. On the Web, a user may expect a browser redirect to a sign-in page  for authentication. In contrast, users of native desktop applications may prefer login  flows embedded within the application or leveraging a session provided by the underlying  operating system. Different mobile applications may use different approaches. Some  may redirect you to an identity provider to log in, but others may still prompt for your  credentials directly in the application. You’ll need to weigh the different approaches and  design for a user experience appropriate for your application’s delivery platforms.  The design of identity management for your application needs to answer all these   questions and more while taking into account the sensitivity of your application and  satisfying all the relevant business requirements. An example might help to show how   2   Chapter 1    the hydra of Modern IdentIty  bad identity decisions can negatively impact a user’s experience with an application.  Imagine you just installed a brand-new application to look at cat pictures and the sign- up  process asks for a scan of your passport and a selfie video. This would doubtless seem a bit  suspicious because it’s hard to imagine why a cat picture application needs your passport  information! A bad sign-up and login experience can hurt the usability and adoption of your  application. On the other hand, for a financial application, the need to provide a passport  for identity validation would seem more reasonable. It might even be driven by regulatory  requirements. In fact, recording a video to verify your identity is part of an innovative  onboarding experience for a challenger bank application provided by Monzo.i If you are  making a cat picture application, a frictionless social login might be the perfect solution.  However, if you are building a banking application, you’ll need a more involved sign-up  process and identity validation as well as strong authentication. The identity management  solutions for an application must match the sensitivity and type of an application.  As if that wasn’t enough, another major concern when building an application is   privacy regulations that govern the handling and protection of sensitive identity data. With  legislation like the GDPR  General Data Privacy Regulation  in the European Union and  similar legislation being enacted elsewhere, applications that collect or process user data  must comply with privacy requirements as noncompliance may incur severe penalties  in the event of a breach. The challenges outlined in the preceding paragraphs are just a  sample of what you may face in designing identity management for your application.   Objective Our objective in writing this book is to provide you with an introduction to the topic of  identity management, based on our experience building and deploying applications.  The focus is particularly on aspects of identity management for software applications,  such as creating accounts, authentication, API authorization, single sign-on, account  management, and logging users out. To set realistic expectations, identity management  is a huge topic. One book cannot make you an expert or cover everything there is to  know. The specifications for the identity protocols we’ll discuss total over 800 pages, and  they represent only a portion of the information that you need to know. We cannot hope  to cover every aspect of these protocols or every identity management use case. What  we can reasonably do is provide an introductory overview that helps you understand  common aspects of identity management needed by a typical application project,  how three standard identity protocols solve basic use cases for you, and how a sample  program solves some real-world scenarios.  3   Chapter 1    the hydra of Modern IdentIty  We will cover three popular identity protocols, namely, OAuth 2.0, OIDC, and   SAML 2.0 – specifically, what problem each is designed to solve, how they work, how  to implement authentication and authorization requests for simple cases, and how to  troubleshoot issues. We can’t cover every parameter or use case, but you should come  away with a basic understanding of what each protocol does and how it works. We hope  the text and sample program that accompanies this book give you a helpful overview  of identity management for your application development projects. We also hope you  are inspired to explore this topic further to learn about more advanced use cases and  solutions.  Appropriately designed, an identity management solution can simplify your overall   architecture. It can allow your application to delegate some responsibilities to other  components, and it can provide a single view of the user and unify access control to  simplify access issues, provide critical auditing capabilities, and more.  We’ve organized the content around the events in the life of an identity. We start out  with a discussion of account provisioning and several options for getting users set up so  they can use your application. Then we dive into API authorization and authentication  and provide an overview of three popular protocols in use today, namely, OAuth  2.0, OpenID Connect  OIDC , and Security Assertion Markup Language  SAML  2.0.  These chapters cover authenticating users and handling authorization for applications  and APIs. After covering the basic mechanics of the protocols, we have a chapter  that explains the sample program that accompanies this book and how it uses these  protocols.  The subsequent chapters cover what happens after the user logs in the first   time, with introductory information about sessions, single sign-on, stronger forms  of authentication, account management, logout, and deprovisioning. In case your  application doesn’t work perfectly the first time, we’ve included a chapter with guidance  on troubleshooting. We’ve also shared information on problematic scenarios that may  arise, and some more unusual use cases we’ve come across. We close with a quick  overview of compliance as well as some mistakes that have led to some very unfortunate  breaches. Might as well learn from the past!  We recommend reading the chapters in order, at least through Chapter 15, as many  of these chapters build on previous chapters. For the rebels in the crowd, we especially  recommend at least reading Chapters 4 through 9 in order as they have the most  dependencies on earlier content. The chapters after Chapter 15 can mostly be read in  any order. Chapter 16 on troubleshooting will be most relevant when you need to debug   4   Chapter 1    the hydra of Modern IdentIty  an issue. Chapter 18 on less common requirements might be valuable to read early on  in a project as it may help you identify items to include in your project plan. Chapters 17  and 19 cover different types of issues and will help you plan for or avoid mistakes.  In the chapters on OAuth 2.0 and OIDC, we’ve provided samples of HTTP requests  to be made by an application. We realize you may use a library or SDK to facilitate such  calls, and in fact we heartily encourage this. If so, the syntax will differ for your chosen  implementation. However, while every library or SDK will be different, the underlying  calls should be in alignment with the standard specifications. When it comes time  to troubleshoot your implementation, you’ll likely use a browser tool or debugger to  analyze the calls made, and at that point, an understanding of the underlying HTTP  requests such as we’ve shown will be useful. Even if you are merely configuring a  purchased application, an understanding of the basic requests and responses will be of  benefit for troubleshooting.  One note about naming is in order. The protocols we cover have each used different  terminology. This makes it difficult to use consistent terms for certain components. We  debated between several approaches and finally decided that in a chapter discussing a  specific protocol, we would use the terms used by that protocol, and in other chapters,  we would use more generic terms. For example, in the OAuth 2.0 chapter, we refer to an  authorization server; in the OIDC chapter, the OpenID Provider; and in the SAML 2.0  chapter, the identity provider. In the other, more general chapters, we use the term  identity provider for a service that authenticates a user for an application. One exception  is in our term for a client application. There are many names for a client application  across these protocols – client, relying party, service provider, client application. The  terms client and relying party mean different things in some specifications. To reduce  confusion for beginners, we’ve chosen to use the term “application” throughout, to  refer to an application making authentication or API authorization requests via OAuth  2.0, OIDC or SAML 2.0. This is not ideal as it ignores the fact that in more involved use  cases, OIDC and SAML 2.0 clients may not be applications but rather can also be  providers to other clients. Since our focus is on introductory, basic use cases, we decided  to make this trade-off for the sake of simplicity and consistency across chapters. We  occasionally use the term relying party where the entity referenced is a relying party  which could be a provider serving other clients rather than a simple application. We  also refer to end users as simply users, as we don’t need to differentiate between types of  users.   5   Chapter 1    the hydra of Modern IdentIty   Sample Application To complement the text, we’ve provided a sample application that uses the OIDC and  OAuth 2.0 protocols. Chapter 9 explains the sample application and how it was designed  to use the identity protocols as part of an identity management solution. We need to  give the usual caveat here. As sample code, the code samples in the book and sample  application omit various functions for the sake of simplicity. They are not production-  ready code and should not be used as a basis for production applications.    Design Questions To get started on your own application, we suggest thinking about the following  questions in preparation for reading through the following chapters:     Who are your users: employees, consumers, or a business?     How will users log in? Is there an existing account available to them   that they would like to reuse?     Can your application be used anonymously or is authentication   needed?  to provide?     What kind of delivery – Web or native – does your application intend      Will your application need to call any APIs? If so, who owns the data   that your application will retrieve?     How sensitive is the data that your application handles?     What access control requirements are needed?     How long should a user’s session last?      Is there more than one application in your system? If so, will users  benefit from single sign-on?  Don’t forget a support forum!      What should happen when users log out?     Are there any compliance requirements associated with this data?  6   Chapter 1    the hydra of Modern IdentIty   Summary Modern users expect a frictionless, well-designed experience when using an application.  Identity management should help them access an application quickly, not get in  their way. In order to achieve that, developers face a lot of questions and need to  sort through a wide range of options available to them when developing identity  management solutions for modern applications. The next chapter will help you  understand the components of an identity management solution by covering the events  in the life of an identity.   Key Points              Identity management poses many challenges to developers of  modern applications.  Identity management solutions must be appropriate for the  sensitivity, desired user experience, and delivery platforms of an  application.  Identity management is a huge topic, more than can be  covered completely in one book.     We’ll provide an overview of identity management and typical   requirements for identity management for your application.     We’ll cover three protocols – what they are used for, how they work,   and how to make a basic authentication or authorization request.     We’ll provide a sample program that illustrates some of the topics   discussed.   Note     i.  https:  monzo.com   7   CHAPTER 2  The Life of an Identity  That it will never come again is what makes life so sweet.  —Emily Dickinson in “That it will never come again”  1741   To clarify the terms used in subsequent chapters, we need to describe what an identity is  and how it is used, as well as the most common events in the life of an identity.   Terminology The concepts of an identity, an identifier, and an account are closely related but subtly  different. We use the term “identifier” to refer to a single attribute whose purpose  is to uniquely identify a person or entity, within a specific context. Email addresses,  passport numbers, driver’s license numbers, and employee numbers are all examples of  identifiers used for people. Nonhuman entities, such as agents, bots, or devices, may be  identified by an alphanumeric string of characters assigned at their time of creation or  registration within a context where they will act. Identifiers allow us to refer to a specific  person or nonhuman entity and are essential to identity management.  The term “identity” is defined as a collection of attributes associated with a specific  person or entity in a particular context. An identity includes one or more identifiers and  may contain other attributes associated with a person or entity. Human identities may  include attributes such as name, age, address, phone number, eye color, and job title.  Nonhuman identities may include attributes such as an owner, IP address, and perhaps  a model or version number. The attributes which make up an identity may be used for  authentication and authorization as well as conveying information about the identity to  applications.    Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2_2  9   Chapter 2    the Life of an identity  A given person may have more than one identity. Just as a person might take on   different personas in different social contexts, such as a parent, child, engineer, or coach,  a person can have multiple online identities as well. One might have a work identity  used to perform tasks for an employer. The identity attributes might include an identifier  issued by the employer, a department name, building location, and manager. One might  also have a variety of personal identities used for different purposes, including managing  a youth sports team or running a side business. These real-world examples demonstrate  the contextual aspect of our definition. An online identity consists of at least one  identifier and a set of attributes for a user or entity in a particular context, such as an  application or suite of applications.  An identity is associated with an account in each such context. We define an account  as a local construct within a given application or application suite that is used to perform  actions within that context. Identity attributes may be contained within an application’s  account object, or they may be stored separately and referenced from the account object.  An account may have its own identifier in addition to that of the identity associated with  it. Having an account identifier separate from the identity associated with the account  provides a degree of separation. The account identifier can be used in other application  records to make it easier for users to change the username or other identifier associated  with their account.  We will use the term “identity” when specifically referring to online identities as the  set of attributes about a person or entity. We will use the term account when referring to  an account as a construct within an application or service that has an identity associated  with it. It should be noted that an account can have more than one identity associated with  it through account linking which will be explained further in Chapter 18. To summarize,  a person logs in to use an account which has various identity attributes associated with it  and which enables them to perform actions within a system.  Nonhuman actors can certainly have identities as well. Software components   serving as agents or bots and smart devices can have identities and may interact with  other software or devices in ways that require authentication and authorization just  like human actors. In order to keep this book to a manageable size, however, we will  primarily discuss human actors and their online identities.  As you might guess, an Identity Management  IdM  System is a set of services that  support the creation, modification, and removal of identities and associated accounts,  as well as the authentication and authorization required to access resources. Identity  management systems are used to protect online resources from unauthorized access  and comprise an important part of a comprehensive security model.  10   Chapter 2    the Life of an identity   Events in the Life of an Identity With basic definitions out of the way, we can move on to the primary events in the life of  an identity, illustrated in Figure 2-1. We’ll outline the events in this chapter and then go  into each in more depth in subsequent chapters.  Figure 2-1.  Events in the Life of an Identity   Provisioning The first step in the life of an identity is its creation. The act of creating an account and  associated identity information is often referred to as provisioning. Provisioning might  be done by having users register, importing identity information from a legacy system or  leveraging an external identity service. Regardless of the mechanism used, the objective  of the provisioning phase is to establish an account with associated identity data. This   11   Chapter 2    the Life of an identity  involves obtaining or assigning a unique identifier for the identity, optionally a unique  identifier for the account distinct from that of the identity, creating an account and  associating identity profile attributes with the account.  For example, a user named Alice wishes to use some online banking services. Alice  might establish an online account at a bank by filling out an account registration form.  Alice would provide identity information including a username, a password, her name,  home address, phone number, email address, and some form of tax ID. This data would be  used to provision an online account at the bank associated with Alice’s personal identity.  Alice could create multiple online accounts at the bank for different identities. In   addition to the personal account, Alice might establish a second identity as a small  business owner with a second online account using her business identity and tax ID. The  provisioning phase establishes an online identity and account, which are then used to  access online services.   Authorization When an account is created, it is often necessary to specify what the account can do, in  the form of privileges. We use the term authorization for the granting of privileges that  govern what an account is allowed to do.  When Alice creates her online account, the bank authorizes her account to access   the application to view checking accounts. If she does not have a brokerage account  at the bank, her account would not be authorized to access the bank’s stock trading  application. Needless to say, her account would also not be authorized to view account  information for the bank’s other customers! Alice’s authorization indicates the privileges  her account has been granted. Authorization for an account is typically done at the time  an account is created and may be updated over time.   Authentication To access online content that is not publicly available, a user needs to authenticate.  A user provides an identifier to signify the account they wish to use and enters  login credentials for the account. These are validated against credentials previously  registered during the account provisioning phase. The credentials may involve  something the user knows, something the user has, and or something the user is. A  password is something the user knows. A numeric code generated from a previously  registered device, such as a mobile phone, involves something the user has. Biometric   12   Chapter 2    the Life of an identity  information such as a fingerprint is something the user is. Authentication with one  or more credentials which are validated against previously registered information  demonstrates, to some degree of confidence, a user’s right to use an account to access  protected resources.  After Alice establishes her online identity and account at the bank, she can access   the bank’s online services. To access protected resources, such as her checking  account balance, she will need to authenticate by entering the username and password  established during the registration step. The username indicates the account she wishes  to use, and knowledge of the password demonstrates her right to use the account.   Access Policy Enforcement Once a user has been authenticated and associated with an account, it is necessary  to enforce access policy to ensure any actions taken by the user are allowed by the  privileges they have been granted. We use the term access policy enforcement for the  enforcement of access policy specified by authorization. In other words, authorization  specifies what a user or entity is allowed to do, and access policy enforcement checks that  a user’s requested actions are allowed by the privileges they’ve been authorized to use.  When Alice logs in to the bank’s online retail banking application and makes a  request, the application will check she has the authorization to make the request. If  she attempts to access the stock trading services, she would be denied as she is not  authorized to access those services. In this case, the application might display a message  indicating she is not allowed to view that service, perhaps with information on how to  sign up for it.   Sessions Once a user has been authenticated and authorized, they will perform various actions  within an application. Some applications, typically traditional web applications and  sensitive applications, only allow a user to remain active for a limited period of time  before requiring the user to authenticate again. They do this by managing a session for  the user. A session tracks information such as whether the user has been authenticated,  and if so, typically also the authentication mechanism or strength level used, and when  authentication occurred, in addition to a user identifier. This enables an application to  know when the user should be prompted to reauthenticate.  13   Chapter 2    the Life of an identity  The length of time a user is allowed to remain active before reauthentication is known   as a session limit or session timeout. The session timeout settings will typically vary by  the sensitivity of the data in the application. Session limits help protect against users who  walk away from their screen without logging off and identity information that may have  changed since the session was created. A session limit that forces a user to periodically  reauthenticate provides a check that it is still the legitimate user at the keyboard. It can  also trigger a renewal of the user’s identity information and account status.  Alice’s retail banking application that provides access to her bank account may allow   only a relatively short session, measured in minutes. Another, less sensitive service  offered by the bank, such as an investment newsletter, may allow a longer session,  measured in hours or days. Each time Alice makes a request of either application, it is  necessary for the application to check if she has authenticated recently enough for the  requested transaction. If so, she can continue without authenticating again. If too much  time has elapsed since she last authenticated, she would have to authenticate again.   Single Sign-On  SSO  After a user accesses one application, they may wish to do something else involving  another application. Single sign-on  SSO  is the ability to log in once and then  access additional protected resources or applications with the same authentication  requirements, without having to reenter credentials.  When Alice accesses her bank’s web site, single sign-on would provide convenient   access to multiple banking services. If Alice signed up for the investment newsletter  service at her bank, she could log in to access first the retail banking application to view  her account balance and then access the investment newsletter without having to sign in  again.  Single sign-on is possible when a set of applications has delegated authentication   to the same entity. An authenticated session in that entity that can be used to access  multiple resources via single sign-on is often called an SSO session.   Stronger Authentication Step-up authentication and multi-factor authentication  MFA  both involve  authenticating a user with stronger forms of authentication. Some forms of  authentication, such as username-password authentication, are considered relatively   14   Chapter 2    the Life of an identity  weak because they involve a single factor, the password, which can be captured and  easily used by others. Stronger forms of authentication involve other factors, such as  something the user has and or something the user is. Authentication that requires  multiple factors at the same time is known as multi-factor authentication. Multi-factor  authentication typically involves a password as well as possession of a device such as a  laptop or mobile phone or possibly a biometric factor such as a fingerprint or voiceprint.  Step-up authentication is the act of elevating an existing authentication session to   a higher level of assurance by authenticating with a stronger form of authentication.  For example, a user might initially log in with a username and password to establish an  authentication session. Later, upon accessing a more sensitive feature or application  with higher authentication requirements, the user would be prompted for additional  credentials, such as a one-time password generated on their mobile phone. Step-up  authentication may be required when a user accesses a more sensitive application or  when they attempt to perform more sensitive transactions, like withdrawing unusually  high amounts of money.  Alice might initially log in with a username and password and be able to view  her account balance on the bank’s web site. If she later attempts to transfer a large  amount of money out of her account, she might have to step up her session and enter  a stronger authentication factor, such as a special one-time use code generated by an  application on her phone. This elevates her session to a higher level of authentication  assurance which provides a higher degree of confidence that the user requesting access  or performing a transaction is the legitimate account owner.   Logout When a user is done with an application, they should terminate their session by logging  out. At a minimum, the act of logging out should terminate the user’s application  session. If they return to the application, they would have to authenticate again before  being granted access. In situations where single sign-on is used, there may be multiple  sessions to terminate, and it is a design decision as to which sessions should be  terminated when the user logs out of one application.  The act of logging out is slightly different than a session timing out. In the former   case, the user explicitly requests that their session be terminated. When a session times  out, an application may elect to keep the session in a suspended state and reconstitute  the session if the user authenticates again.  15   Chapter 2    the Life of an identity  In a scenario where Alice has logged into her bank’s web site and viewed her bank  balance as well as a recent investment newsletter, she would have a session in the retail  banking application, in the investment newsletter application, and in the bank’s SSO  service. If she is idle for a few minutes to take a phone call, her session in the retail  banking application may time out. When she finishes her phone call, she would have to  reauthenticate to continue. When she finishes viewing her account, she would click a  “Logout” link to terminate all of her open sessions.   Account Management and Recovery During the course of an identity’s lifetime, it may be necessary to change various  attributes of the user profile for the identity. For example, a user may need to update  their email address or phone number. A user may need to update their name in some  circumstances or to periodically change their password or mobile device used in the  authentication process. In a company, a user’s profile might be updated to reflect a new  position, address, or privileges such as roles. Account management consists of features  or processes which enable users and administrators to view and update user profile  attributes associated with an identity.  A user may also forget their password or lose a device that is required for an   authentication process. If this happens, a user needs to establish new credentials. This  requires an alternate means of establishing the user’s ownership of the account before  allowing them to set new credentials. Account recovery is a mechanism to validate a user  is the legitimate owner of an account through some secondary means and then allow the  user to establish new credentials.  If Alice goes on a trip and forgets her password after being gone for a while, she   would need a means of resetting her password. She may have to enter a code using an  alternate authentication mechanism she set up previously or she may be able to trigger  an account recovery link sent to her email that will enable her to reset her credentials.  Similarly, if Alice decides to move, she would need the ability to update her profile at  the bank to reflect her new address. Throughout the lifetime of an identity, various  changes may occur, requiring the ability to update the identity profile attributes and or  reestablish new credentials.  16   Chapter 2    the Life of an identity   Deprovisioning There may come a time when it is necessary to close an account. In this case, the user’s  account and associated identity information must be deprovisioned so that it can no  longer be used. Deprovisioning may take the form of completely deleting the account  and associated identity information or simply disabling the account, to preserve  information for audit purposes.  If Alice decides at some point to terminate her relationship with the bank, she would  request that her accounts be closed. The bank would close out her checking and savings  accounts and terminate her online account so that she could no longer log in. The bank  would, however, need to keep sufficient information to meet tax reporting and audit  obligations.   Summary This chapter has introduced the concept of an account and an associated identity  and the most typical events that occur during their existence, from provisioning  and authorization to authentication and access policy enforcement, all the way to  deprovisioning. In the next chapters, we’ll dive into more detail for each event, starting  with a summarized history of approaches to identity management.   Key Points     Provisioning creates an account and associated identity.     Authentication validates a user is entitled to use an account.     Authorization specifies the privileges granted for an account.     Access policy enforcement checks that requests are within the   privileges granted by authorization.     A session and session limit are used to govern how long a user can   remain active without reauthenticating.     Single sign-on allows a user to log in once and then access additional   protected resources without reentering credentials.  17   Chapter 2    the Life of an identity     Multi-factor authentication requires authentication by multiple   forms of authentication, such as something the user knows    a password , something the user has  such as a device , and or  something the user is  such as a fingerprint .     Step-up authentication is the elevation of an existing   authentication session to a higher authentication assurance level  when a user authenticates with a stronger form of authentication.     Logout terminates an authenticated session, requiring  reauthentication to access a protected resource again.     Account management features allow a user or administrator to   update account and identity profile attributes.     Account recovery is required when a user loses the ability to   authenticate using previously established credentials.     Deprovisioning is the removal or disabling of an account and   associated identity information.  18   CHAPTER 3  Evolution of Identity  Progress  is  not  an  illusion;  it  happens,  but  it  is  slow  and  invariably  disappointing.  —George Orwell, from Inside the Whale and Other Essays  1940   Over the years, there has been an ongoing evolution in how identity information is stored  and used to enable users to access applications and the functionality they provide. You’ll  see in this chapter that each bit of progress has solved some problems but given rise to new  ones, as technology and security challenges evolved. We’ll describe some past approaches  that have been used to manage identity information and provide authentication and  authorization. We’ve selected specific technologies to highlight specific advantages and  disadvantages of each approach that may help you evaluate solutions for your project.  We’ll also discuss why you should use an industry standard protocol instead of inventing  your own solution. Subsequent chapters will then cover specific protocols in more depth.   Identity Management Approaches It’s valuable to understand the advantages and drawbacks of approaches which have  been used in the past for managing identity data, authentication, and authorization.  Many of these approaches are still in use today. This will not be an exhaustive list of  every approach or technology, but rather a curated list to illustrate the practical, real-  world benefits and drawbacks of selected approaches. As you read about each one, pay  attention to the problems each solution was designed to solve as well as the benefits and  shortcomings of each. Knowing the advantages and disadvantages of each will help you  evaluate alternatives and more effectively advocate for use of newer solutions. We’ll start  by going back in time to when applications each implemented their own authentication  and user repository.  19    Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2_3    evolution of identity  Chapter 3   Per-Application Identity Silo In the Stone Age, relatively speaking, of computer applications, each application often  implemented its own identity repository, authentication, and authorization. A large  enterprise company typically had core business applications, such as finance and  inventory control systems, and perhaps a few productivity applications. Each application  often had its own dedicated database or other storage in which user identities,  credentials, and user profile data were stored, and each application prompted the user  to log in and then validated the user’s credentials against its own repository of user  information. This meant an employee might have a different username and password  to remember for each application. It also meant that if some element of a user’s profile  changed, the profile change had to be made in multiple applications. Of course, this did  not happen reliably if a company had many applications, so user profile data invariably  became out of sync across systems. User exasperation with data integrity issues and  having to remember numerous passwords was bad enough when there were just a few  applications. As the number of applications in an enterprise grew, however, having every  application implement its own siloed identity repository and authentication solution  quickly became untenable for businesses.  This siloed approach is still used today in many consumer-facing scenarios where  a user signs up by providing an application-specific username and password. If a user  reuses the same password across multiple sites, a compromise at any one site could  put the user’s data at other sites at risk. If a user specifies a different password for  every application, they have to remember or securely store the passwords or rely on  the security of an account recovery process provided by the application. Either way,  consumer users face some of the same inconvenience with this approach experienced  earlier by corporate users.   Centralized User Repository With time, more and more software was written for a wide swathe of business functions.  This drove a need for a better approach to identity management. Many companies  implemented directory services to house and centralize user identity information.  Directory services are optimized for information that is frequently read but infrequently  modified, which is often the case for user identity data. Applications were able to use a  directory service to store user data and credentials. It was also possible for an application  to prompt a user to log in and validate the entered credentials using information in a   20   Chapter 3    evolution of identity  directory service. Large, on-site commercial business applications targeted to enterprise  environments1 often included support for this approach. This centralized approach  offered a significant improvement over the siloed, per-application approach.  The centralization of identity administration and access with a directory service  provided many advantages. Directory replication capabilities enabled applications  hosted around the world to leverage the same identity information, eliminating  data inconsistency issues. The same username and password could be used across  applications. A centralized directory service also provided a single point of control at  which to implement password policy or quickly terminate an identity if necessary. As a  result, directory services became widely adopted, at least in larger companies.  For all their advantages, however, directory services also had some disadvantages.   A directory service by itself did not maintain any sort of session for a user. The  centralization of identity information in a directory service usually meant a user had only  one username and password to remember, but the user still had to enter the credentials  into each application’s login screen because each application needed to collect user  credentials and validate them using the directory service  in the absence of additional  technology . In addition to being an inconvenience, this exposed the user’s password to  the applications. A compromise at one application might put other applications at risk.  This was bad enough when all applications involved were inside a trusted corporate  network. As companies began using cloud applications, exposing directory passwords to  cloud applications owned by others would have posed an unacceptable risk. Once again,  a better solution was needed!   Early SSO Servers Several types of what became known as identity and access management  IAM   or single sign-on  SSO  servers provided further improvement. Early SSO servers  leveraged the identity information in a directory service, but provided a layer on top  of the directory service that maintained a session to remember users that had already  authenticated. The way they worked varied, but in a typical approach, an application  could redirect a user’s browser to an SSO server to have the user authenticated there and  receive the authentication results in a secure, predetermined fashion. If a user accessed  a second application, shortly after they authenticated for the first application, the   1 Such as Oracle and SAP application suites.  21   Chapter 3    evolution of identity  second application redirected the user’s browser to the SSO server2 and the SSO server  would detect the user’s existing session and redirect them back to the application with a  success status without prompting the user for credentials again.  The introduction of single sign-on servers offered many advantages over directory  services. Users benefited from the ability to access multiple applications with a single  authentication. Security teams appreciated that the user’s static directory password  was only exposed to the SSO server, instead of to each application the user accessed.  IT departments were happy because it gave them a single place to implement  authentication policy and stronger authentication mechanisms.  Unfortunately, there were some disadvantages with early SSO servers in practice.   The interaction between applications and SSO servers was somewhat proprietary, and  SSO products were often time-consuming to implement. This meant their adoption  was more evident in larger companies with resources to integrate applications with SSO  servers. A more significant limitation was that single sign-on relied on cookies which,  due to browser restrictions on cookie access, meant the solutions worked within one  Internet domain such as www.mycompany.com. As many companies were becoming  interested in external Software-as-a-Service  SaaS  applications, this was a limiting  restriction.   Federated Identity and SAML 2.0 The explosion of new SaaS applications created challenges for managing identities. In  the blink of an eye, business teams everywhere could thumb their noses at backlogged  IT departments and sign up for SaaS applications with a credit card. Unfortunately,  there was often no good way to manage employee identities in SaaS applications. It was  difficult for a company to track accounts its employees created in SaaS systems, and  users once again had to remember a password for every application. The single sign-on  they enjoyed across internal applications didn’t extend to external SaaS applications in  other domains.  Fortunately, a new industry standard, SAML 2.0  Security Assertion Markup   Language , had been published in 2005.i It provided a solution for web single sign-on  across domains and federated identity. This happened to be perfect for enterprises with   2 As an optimization, an agent was sometimes installed in front of the application to check session  state with the SSO server and only redirect the user to the SSO server if the session state could  not be confirmed.  22   Chapter 3    evolution of identity  SaaS applications. Although the SAML 2.0 technical overview focused on a consumer-  facing use case, SAML 2.0 provided an excellent solution for enterprises needing better  control over employee identities in SaaS applications.  With SAML 2.0, SaaS applications could redirect corporate users back to a corporate   authentication service, known as an identity provider  IdP , for authentication.  Identity federation provided a way to link an identity used in an application with an  identity at the identity provider. Companies could now have the advantages of single  sign-on with both internal and SaaS applications. Users benefited by having a single  username password to remember. The enterprise had a centralized control point for  both internal and external identities and could shut off access quickly at the corporate  identity provider if needed. Password policy and multi-factor authentication could be  implemented in a single place. In this way, SAML 2.0 solved many identity headaches for  enterprises.  Despite being widely adopted, however, SAML 2.0 was no silver bullet. The protocol  was designed to cover many scenarios, making it complex to configure and implement.  While SAML 2.0 became widely adopted within enterprise environments, there was no  viable business model for it to address consumer-facing scenarios. Users were unlikely  to pay money for a consumer-facing identity service. As we’ll see later, this was solved by  making someone else entirely pay for the service! Another limitation was that SAML 2.0  only solved the problem of authentication. Applications were evolving to architectures  based on APIs. As typically implemented, SAML 2.0 solved the problem of authenticating  users but didn’t help with API authorization.   WS-Fed The Web Services Federation Language  WS-Fed  federation framework was created by  an industry coalition as part of a larger set of protocols known as the WS-∗ specifications.  The WS-Fed 1.2 specification was published as an OASIS standard in 2009ii and provided  mechanisms whereby “authorized access to resources managed in one realm can be  provided to security principals whose identities are managed in other realms.”iii It was  supported by Microsoft’s ADFS server as well as many other commercial SSO products  and provided similar functionality to SAML 2.0’s web single sign-on and federation  capability. It was taken up in many enterprise environments and, like SAML 2.0, is still in  use today in many corporate settings.  23    evolution of identity  Chapter 3   OpenID The original OpenID protocoliv is worth mentioning for its notion of user-centric identity.  With SAML 2.0 only adopted in employee-facing scenarios, consumer users were still  forced to register anew at each consumer-facing web site. A new industry group formed to  create a solution for what it termed “user-centric” identity, and this gave rise to a protocol  called OpenID. In addition to organization-controlled identity providers commonly used  with SAML 2.0 and WS-Fed, OpenID included the idea of user-controlled identity for the  consumer use case. Consumer users could even set up their own identity provider and  point applications to it for authentication. The original OpenID protocol didn’t become  widely used, but it did highlight the need for user- centric identity solutions and laid the  groundwork for another protocol named OpenID Connect, which we’ll cover shortly.   OAuth 2.0 With Web 2.0 and the rise of social media, many consumer-facing web sites were created  that allowed users to upload content such as pictures. This gave rise to use cases where  an application needed to retrieve such content on the user’s behalf. For example, a  person who uploaded photos to a social media site might want to enable another web  site that printed photos  www.photos.com  to access their photos at the social media  site. In the absence of a better solution, the user would have to share their social media  credentials with the photo printing site. If the photo printing site were compromised, it  would put the user’s social media account at risk. The user also had no control over what  the photo printing site could do once it had the user’s password for the social media  site. A solution was needed that would allow a user to authorize an application at one  web site to retrieve their content from another web site’s API, without the user having to  expose their credentials to the first site.  The OAuth protocol provided a solution for this use case. The OAuth 2.0v version of   the specification allows a user to authorize one application, known as a client  the photo  printing site , to send a request to an API, known as a resource server  the social media  site , on the user’s behalf to retrieve data at the resource server owned by the user. To do  this, the application interacts with an authorization server which authenticates a user as  part of obtaining their consent for the application to access their resources. The application  receives a token which enables it to call the resource server on the user’s behalf. OAuth 2.0  solved an important API authorization use case. Given the lack of a consumer-facing  authentication solution like SAML 2.0 and WS-Fed, and the fact that authorization servers   24   Chapter 3    evolution of identity  might need to authenticate users as part of obtaining the user’s authorization consent, it  may have been tempting to some to want to use it for more than this.  By this time, there were several social media sites on the Internet, such as Google   and LinkedIn, and they implemented OAuth 2.0 to enable consumer-facing applications  to retrieve information from a user’s Google or LinkedIn profile. The authentication step  performed by an OAuth 2.0 authorization server as part of obtaining a user’s consent  might have seemed to some like it could provide a handy authentication solution. There  had not been a viable business model earlier for general consumer-facing SAML 2.0  identity provider services. Neither the users, applications, nor anyone else were likely to  fund such services.  The rise of social media, however, provided a new possibility for a solution. Social  media providers already had to authenticate users for access to their site and when an  OAuth 2.0 authorization request was received that required authenticated user consent.  If they were to provide a general authentication service, it might attract more users to  their platform, and a consumer-facing authentication service would effectively be paid  for by the advertising that paid for the social media sites. There was one slight problem,  however. OAuth 2.0 was not designed as a general authentication service and could  not securely be used for this purpose, at least without proprietary additions to the pure  OAuth 2.0 features.  Several social providers that support OAuth 2.0 have implemented  such proprietary additions.  Another solution standard was needed.    OpenID Connect  OIDC  OpenID Connect  OIDC  was designed to provide a key feature needed for an  authentication service. Even if OAuth 2.0 authorization servers were capable of  authenticating users, the framework did not provide a standard way to securely convey  the identity of an authenticated user to an application. OIDC provided a solution for  this need. OIDC was devised as a layer on top of the OAuth 2.0 protocol to provide  information in a standard format to applications about the identity of an authenticated  user.vi This provided a solution for applications for user authentication as well as API  authorization. The implementation of OIDC by widely used social media service  providers like Google, PayPal, and Yahoo provided a solution for consumer-facing  authentication services, but there was nothing in the protocol to limit it to consumer-  facing scenarios.  25   Chapter 3    evolution of identity  OIDC offers benefits to users, application developers, and identity providers. Web  site developers can delegate the work of implementing authentication and password  reset logic to an OIDC provider. Users benefit because they can leverage one account to  log in to many sites without exposing their account credentials to those other sites. Users  have fewer usernames and passwords to manage and enjoy single sign-on. Providers  may benefit if OIDC support attracts more users to their platform. OIDC provides the  web single sign-on benefits that were attractive in SAML 2.0 and, when combined with  OAuth 2.0, provides a solution with authentication as well as the API authorization  capabilities needed by modern applications.  The previous sections provided a brief history of different solutions for managing   identities and authenticating users. We’ll close with a few words on the benefits of  standard protocols.   Standard Protocols The next several chapters will describe three commonly used industry standard identity  protocols and how they work. But first, why use an industry standard protocol? First,  as open standards, these protocols have been scrutinized for flaws by many people, so  they are less likely to have vulnerabilities than something you’d invent yourself. Second,  these protocols are widely used, providing interoperability between your application  and service providers which support the protocols. Third, if you wish to access user  profile data from services such as Google, you will have to use the standard protocols as  implemented by these services. Similarly, if your application will be used by enterprises,  the enterprise may expect your application to use one of these protocols. Fourth,  the protocols designed for authentication support single sign-on which represents  convenience for your users. Finally, using an existing protocol can save you time as many  programming languages offer SDKs that support them. So, there you have five good  reasons to use industry standard identity protocols!  If you are new to the identity space, it may at first seem a little daunting to learn   these protocols and possibly tempting to invent a simpler authentication scheme of your  own. We have two words for that: “Just Don’t!” We hope this book will make it easier  for you to understand how to use these protocols. We hate to discourage innovation,  but innovation in the authentication space should be done with care. Your innovative  energies would be better spent on the core value proposition of your application!  26   Chapter 3    evolution of identity   Summary We’ve reviewed several approaches to identity management, authentication, and  authorization. The advantages and disadvantages of each are helpful to keep in mind  when evaluating the benefits of new designs. Before deciding upon the protocol s  you  need, however, it’s helpful to consider where the information on your users will come  from and reside. This is part of identity provisioning which we’ll cover next.   Key Points      Identity management, authentication, and authorization approaches  have evolved over time.     Early approaches often involved application-specific identities and   credentials.     Centralization of identity data with directory services enabled a   single identity and credential, but this had to be entered by a user  into each application  in the absence of other complementary  technology .     Single sign-on servers provided session management so users   could log in once and access multiple applications, within the same  domain, with one authentication.     SAML 2.0 and WS-Fed provided single sign-on and federated identity   across domains.     OAuth 2.0 provides a solution for authorizing applications to call APIs.     OIDC provides a layer on top of OAuth 2.0 for authenticating users   and returning information to applications in a standard format about  the authenticated user.   Notes        i.  http:  saml.xml.org saml-specifications  ii.  http:  docs.oasis-open.org wsfed federation v1.2 os ws-  federation-1.2- spec- os.html  27   Chapter 3    evolution of identity    iii.  http:  docs.oasis-open.org wsfed federation v1.2 os ws-  federation-1.2- spec- os.html     iv.  https:  openid.net specs openid-authentication-1_1.html    v.  https:  tools.ietf.org html rfc6749    vi.  https:  openid.net specs openid-connect-core-1_0.html  28   CHAPTER 4  Identity Provisioning  The  more  identities  a  man  has,  the  more  they  express  the  person  they  conceal.  —John le Carré, from Tinker, Tailor, Soldier, Spy  1974   The first step in the life of an identity is its creation. If Descartes had lived in the time  of Internet identity, he might have quipped, “Ego signati sursum, ergo sum”  I signed  up, therefore I am . Provisioning is the act of establishing identities and accounts for  your application. As defined in Chapter 2, an identity includes at least one identifier  and various additional user profile attributes. An online account is associated with  an identity and can be used to access protected online resources. The objective of the  provisioning phase is the creation or selection of a repository of user accounts and  identity information that will be used in the authentication and authorization of users as  they access protected resources.   Provisioning Options For an application developer, the identity provisioning phase involves getting users and  creating accounts and identity profiles for them. One obvious approach for this is to have  users sign up for a local application account, but that isn’t the only possibility. A list of  approaches to consider includes     A user creates a new identity by filling out a self-registration form.     A special case of self-registration is sending select users an invitation   to sign up.  repository.     User identities are transferred from a previously existing user     Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2_4  29   ChApter 4    IdentIty provISIonIng     An identity service with an existing repository of user identities is   leveraged.     An administrator or automated process creates identities.  These approaches are not mutually exclusive; in some cases, a combination of   approaches might work best. We’ll describe each in more detail along with some  advantages and disadvantages for each.   Self-Registration One option is to have users create a new account for your application and specify their  identity information via self-service sign-up. This requires enticing users to your site,  having them fill out a registration form and then storing the collected information. This  is a common approach for consumer-facing sites and requires you to design and create  the sign-up form s . It also necessitates privacy notices about the information you  are collecting and obtaining the user’s consent for the planned use of the information  collected. You should keep the information requested to a minimum as users may  abandon the registration process if too much data is required!  With a self-registration form, you control the user sign-up experience. You can  customize the information you collect and ask the user directly for information that  may not exist elsewhere. Self-registration is more scalable, at least compared to having  administrators create accounts. On the flip side, there is work to implement and  maintain a registration form, along with procedures for obtaining user consent for the  data collection and processing. In addition, having to fill out a registration form may  deter some users from signing up. Table 4-1 summarizes some of the advantages and  disadvantages of using a registration form.  Table 4-1.  Self-Registration  Disadvantages     Ability to collect user attributes that don’t exist      May deter some prospective new users      Control over user registration experience.    Scalability through self-service.     Liability associated with storing login   from signing up.  credentials.  Advantages  elsewhere.  30   ChApter 4    IdentIty provISIonIng   Progressive Profiling  You can reduce the information a user has to enter upon sign-up by using progressive  profiling, the practice of building up user profile attributes for an identity over time,  instead of requesting them all at once. With progressive profiling, a user is asked to  provide minimal attributes when they sign up. If the user later performs a transaction  that requires more information, it is collected at that time. Alternatively, additional  information can be gathered after a certain amount of time has passed or a set number  of logins. Progressive profiling reduces the sign-up friction that a lengthy initial sign-up  form would present. It is used more often in conjunction with self- registration sign-up,  but can be used with other provisioning options.   Invite-Only Registration  A variant of the self-service registration approach is the invite-only registration flow. In  this scenario, specific users are invited to sign up. The invitation may be triggered by  another user. Some social networking sites use this approach to have users invite their  friends to join the site. The invited user gets a link which takes them to a sign-up form  where they can register. An invitation may also be triggered by an administrator of a site.  This case may involve a registration form for the user, or, if the administrator has already  provided all account data needed, it might only involve email address validation and or  a password reset. This technique might be useful to invite specific users to test an early  access  alpha  version of an application or release.  With an invite-only sign-up, access to the registration form is restricted to a select  group of users who receive an invitation. The invitation can be delivered via channels  such as email or text message and contains a link that allows the user to register.  The registration page can lock the email address or phone number to that used in  the invitation so it cannot be changed at the time of registration, if it is important to  prevent an uninvited person from stealing someone else’s invitation and signing up as  themselves. The link in the invitation can also have an expiration associated with it, if  necessary, and each invitation is usually tracked so it can only be used once.  An invite-only flow can also be used for situations where you need to create an   account in order to assign privileges to it before sending the invitation. This approach  could be used to establish employee accounts for new hires or customer accounts for  access to early access  alpha  application environments. An administrator or automated  process can create the account, assign it privileges, and then trigger the sending of   31   ChApter 4    IdentIty provISIonIng  the invitation link to the new user. The user clicks the link and provides additional  information in a registration form if needed. The information entered by the user can be  associated with the previously created account. The account is then ready for the person  to use and has the privileges previously assigned to the account by the administrator.  The invite-only flow has similar considerations to the self-registration option   described previously. It can additionally protect against registrations by hackers and  bots, unless, of course, they find a way to finagle an invitation! An invite-only registration  flow obviously requires extra work to implement the invitation mechanism as well as  access control to limit access to the invitation distribution. It may require work by an  administrator to issue the invitations or to create an automated process to do this. Some  advantages and disadvantages of the invite-only sign-up approach are shown in Table 4-2.  Table 4-2.  Invite-Only Registration  Advantages  Disadvantages     Ability to collect user attributes that don’t      the work to implement invitation mechanism   exist elsewhere.  and control access to it.     Control over user registration experience.    Some protection against registration by      the work to issue invitations.    May deter some prospective new users from   hackers and bots.  signing up.     Scalability through self-service if users      Liability associated with storing login credentials.  invite others.   Identity Migration If identities already exist elsewhere, they can be moved from one repository, such  as a legacy database, to another repository that can be used by the new application.  The advantage is that users don’t have to provide information they already entered  elsewhere, and the new repository can be quickly populated with users from the legacy  repository. While most user profile attributes can be extracted and moved, passwords  represent a challenge. Passwords are typically stored in a hashed format. Hashing  converts them to a string of random characters and this cannot be reversed to get the  original “cleartext” value. Each time the user logs in and enters their password, it is  hashed and the hashed value is compared to the password that was hashed and stored  when the user registered or last reset their password. Storing passwords in hashed   32   ChApter 4    IdentIty provISIonIng  format allows validation of entered passwords but prevents administrators with access to  password repositories from seeing cleartext passwords and makes it difficult to use the  passwords if the storage repository is compromised or stolen.  There are different algorithms for hashing passwords and different inputs passed   to the hashing algorithms such as salts and iteration counts. As a result, a password  hashed in one system cannot necessarily be imported and used by another system. If  two different systems use different hashing algorithms or different inputs to the same  algorithm, it is not possible to move a hashed password from one system to the other  and have it be usable by the new system. In such circumstances, there are a few solutions  to consider for migrating identities to a new system.   Support Legacy Hashing Algorithm  One solution is to update the new system to support the hashing algorithm s  used by  the legacy system. This requires implementing in the new system the legacy system’s  hashing algorithm s  and a means of determining which hashing algorithm to use with  each account. This will enable moving all identity data and hashed passwords from the  legacy system to the new system without requiring the users to reset a password. Table 4-3  summarizes some advantages and disadvantages of supporting legacy hashing algorithms.  Table 4-3.  Supporting Legacy Hashing Algorithms  Advantages  Disadvantages     Avoids need for password reset.    transfers all accounts in a usable   state.     Work to implement legacy hashing algorithm s .    Liability associated with storing login credentials.     Inherits any weakness associated with legacy hashing  algorithms.   Bulk Identity Migration  Another solution is to extract the users’ identity data, minus the hashed passwords, from  the legacy system and import it into the new system. The new system would then need  to send each user a unique password reset link to establish a new password for their  account in the new system. This requires the identity information in the legacy system  to include a validated email address, and that a password reset link sent via email is  deemed adequately secure for the sensitivity of the information handled by the new   33   ChApter 4    IdentIty provISIonIng  system. If other forms of communication besides email are used, the same validation and  security requirements apply. Users should be notified in advance about the migration,  so they will know to expect the password reset message and not view it as an attempted  phishing attack! If forcing users to reset their passwords is acceptable, a bulk transfer  can be done all at once, making it possible to retire the legacy system after the transfer.  Table 4-4 summarizes some advantages and disadvantages of a bulk transfer of users.  Table 4-4.  Bulk Migration of Users  Advantages  Disadvantages     transfers all users at once.    enables immediate shutdown of      transfers all accounts, even inactive accounts, unless   they are filtered out during the transfer.  legacy user repository.     requires all users to set new password via account      no latency added at login time to  check a legacy system for a user  account.     Code to transfer identities can be  independent of application code.  recovery, unless the new system can support the  legacy hashed passwords.     Migrating all users at once can cause a widespread       outage if things go wrong with the migration and  there is no backup plan. If multiple applications use the legacy repository, they  must migrate at the same time if the legacy repository  is to be shut off after migration.     Liability associated with storing login credentials.   Gradual Migration of Users  An alternative to a bulk transfer of identities is to use a mechanism that transfers  identities gradually as they log in. This requires a login mechanism that prompts users  for credentials, validates them against the legacy repository, and if validated, retrieves  identity information from the legacy repository and stores it and the entered credentials in  the new repository. The password entered by the user, after validation against the legacy  system, is hashed by the new system using its hashing algorithm and stored in the user’s  new account. This option will only migrate users who log in and requires the new system  to have direct access to the legacy system to validate the entered password and retrieve  user profile information. This is more convenient for users because no password reset is  required, but it means the legacy system must remain operational until the identities have  been migrated. This solution will not transfer inactive accounts  users who don’t log in .  34   ChApter 4    IdentIty provISIonIng  With the gradual migration approach, a subset of users may not log in and therefore  not have their identity information migrated. You can set a cutoff date for the migration  and decide what to do about any identities that have not been migrated by that date. One  possibility is to declare the unmigrated accounts inactive and abandon them. A common  approach is to use the bulk move option described previously on the inactive accounts  so you can decommission the old system. You may want to migrate only a subset of  identities that you have reason to believe will be active again in the future. If you do not  migrate all remaining identities, you should consider reserving the account identifiers  of unmigrated identities to prevent them from being used by new accounts in the future.  Chapter 15 explains why.  Of course, a user whose identity has not yet been migrated might forget their   password. The user could use the new system to enter their email and get a password  reset token or link. The user would confirm receipt of the email and be prompted to  enter a new password. The new system would create an account for the user in the new  system, with information retrieved from the legacy system for an account with matching  email address. The gradual migration of active identities, combined with bulk migration  of remaining identities and credential reset, provides a nice user experience for active  users while not abandoning infrequent users. Table 4-5 summarizes some advantages  and disadvantages of a gradual migration.  Table 4-5.  Gradual Migration of Users  Advantages  Disadvantages  Inactive accounts can be weeded out.       no password reset required  for users   who log in during migration .     requires that legacy identity store is accessible   from new application’s authentication mechanism.    Legacy identity store must remain accessible until      Spreads out risk of outages by   enough identities are transferred.  migrating identities gradually  no big  bang risk .     transfer mechanism must be maintained   throughout the gradual migration.     Can support continued use of previous   sign-up mechanisms or applications  that use the legacy identity repository  during the gradual migration.     A user’s first login after migration starts may have  some latency as identity data is transferred from  the legacy system. Implementation work cannot be easily decoupled  from the application team.         Liability associated with storing login credentials.  35    IdentIty provISIonIng  ChApter 4   Administrative Account Creation Yet another solution to consider for creating accounts and identities is to have an  administrator or automated process create them. The best approach for a situation  should take into account     The size of an organization     The frequency with which new users need to be added     Whether provisioning needs to be done across domains  The following sections provide a few variants of this solution to consider.   Manual Account Creation  Having an administrator manually create accounts for new identities will only be  practical for very small organizations  low tens of users  with an infrequent need  to add new users and few applications. For very small organizations, the work to  implement account provisioning automation may not be justified. In the absence of  automation, written procedures and checklists can be used to ensure necessary account  provisioning steps are consistently followed. If passwords are used as credentials, the  account provisioning procedures should ensure that administrators do not know the  user’s password. This can be done by sending a password reset link to the user and or  requiring a password reset upon initial login. If the organization grows or starts to need  more than a handful of applications, some form of automation will be beneficial for  consistency, accuracy, security, and trackability.   Automated Account Creation  This approach is often used for employee identities. When a new employee joins a  company, the company can automatically create an account for the employee using  identity information from a Human Resources  HR  system. If large volumes of accounts  need to be created on an ongoing basis, workflow software or specialized account  provisioning software can be used to automate account creation and provide identity  attributes for accounts.  36   ChApter 4    IdentIty provISIonIng   Cross-Domain Account Creation  In several situations, account provisioning may need to occur across domains. This can  occur when     Maintaining employee accounts in external SaaS  Software as a   Service  applications     Maintaining partner accounts in corporate identity repositories or   applications  applications     Maintaining business customer user accounts in business-facing      Maintaining guest professor or student accounts in collaborating   universities’ systems   Ideally, modern authentication protocols would convey user profile attributes to   applications in authentication tokens at the time of login, but provisioning or  synchronizing identity information across domains may still be needed if     Applications are not designed to extract identity information from   authentication tokens.  authentication tokens.  sufficiently up to date.     The identity profile information is too large to convey in      User logins are not frequent enough to keep profile information   When needed, the provisioning of accounts and identity information across domains   is still commonly done using proprietary solutions, but an industry standard protocol,  SCIM  System for Cross-domain Identity Management ,i was created in 2015 to provide a  more standard approach to sending and updating identity information from one domain  to another.  Table 4-6 shows some advantages and disadvantages of administrative account   provisioning.  37   ChApter 4    IdentIty provISIonIng  Table 4-6.  Administrative Account Creation  Advantages  Disadvantages     User doesn’t fill out registration form.    Administrator can assign privileges so      time-consuming if not automated.    requires care to ensure that only the user   account starts with needed permissions.  knows the password for the account created.     Can be automated via workflow or identity      Liability associated with storing login   provisioning software.  credentials if stored locally.   Leverage Existing Identity Service It’s also possible to leverage an identity that already exists for a user in an identity  provider service. This allows users to employ an account they already have such as at a  social provider like Facebook or Google, a corporate identity provider service operated  by their employer, or a government identity service. With this option, your application  delegates responsibility for authenticating users to an identity provider and receives  back a security token with information about the user’s authenticated session and,  optionally, attributes about the user.  Leveraging accounts in an existing identity provider service may mean less   work for users if it reduces the data they have to enter into a registration form. It also  usually means users don’t need to set up another password. This may translate to less  development work if you don’t have to implement a login form or account recovery  mechanism because all users authenticate via an identity provider service. It may also  reduce your risk somewhat if user passwords are not stored in your infrastructure. If  an identity provider service does not contain all the attributes your application needs  about the user, you can always collect additional data later. Of course, it’s a good idea to  vet an external identity service before trusting it, and use of an identity provider service  requires collaborative troubleshooting as described in Chapter 16. Table 4-7 summarizes  some advantages and disadvantages of using an external identity service.  38   ChApter 4    IdentIty provISIonIng  Table 4-7.  Leveraging an Existing Identity Service  Advantages  Disadvantages     Better user experience if it reduces      you may have to collect additional profile information   the data required to sign up.    easier for user to remember   password if identity provider account  is used frequently.     you may not have to implement  a login form or account recovery  mechanism if all users authenticate  via the identity provider service.    Less risk if you do not store user   passwords.  not available from the identity provider service.    you need to evaluate the service and availability  levels of the external identity service to ensure it  meets your needs.     May require additional development or configuration   work for each identity provider service to be used.     May require configuration work at each identity   provider service for each application you have, unless  you use an authentication broker service  described  in Chapter 7 .     May require collaborative troubleshooting with   another organization when issues occur.  In addition to existing identity provider services, you can of course set up your own,  new identity provider service for use by your application. If you choose that route, many  cloud services are available to facilitate the task, and any of the previous provisioning  options could be used to populate the new identity provider service with users.   Selecting an External Identity Service If you choose to leverage an external identity service, it’s important to consider the  strength of the identity issued by a service as well as the suitability and availability of  a provider for a particular environment. The strength of an identity is one factor in  determining how much trust can be placed in the identity, and several factors influence  the strength of an identity:     The validation of the information used to establish the identity     The identity’s implementation that prevents it from being forged or   used by others  particular domain     Recognition of certain issuers of identities as authoritative for a   39   ChApter 4    IdentIty provISIonIng  Table 4-8 provides a comparison of characteristics of strong vs. weak identities.  Table 4-8.  Characteristics of Strong vs. Weak Identities  Strong Identities  Weak Identities     Linked to a real person, who can be held accountable      Anonymous, cannot be linked to a           for actions taken with the identity. Identity attributes are validated during account issuance  process. Issued by entity recognized as authoritative for a  particular context.  real person.     Little validation of identity       attributes. Issued by an entity with little  recognized authority.     Contains mechanisms to protect against forgery or      Few protections against forgery or   unauthorized use.  unauthorized use.  The strength of an identity is based on the trustworthiness of the issuer, the   validation of identity data, the practices behind the issuing and distribution of the  identity, and in some cases, agreements, either implicit or explicit, between the issuer  and any entities trusting identity information from the issuer. The next sections provide  examples.   Self-Registered Identities A self-registered identity, such as a basic Gmail or Yahoo email account, is an example  of a weak identity. You can sign up for these accounts using any identifier that has not  already been taken, such as frodo_baggins@gmail.com or santa.claus@yahoo.com. You  do not have to supply true information in the sign-up form and the service provider  does not validate most of the identity data. Several social providers have added security  features to protect against unauthorized use of accounts, but self-registered accounts  are typically not considered authoritative for identity information due to the lack of  validation. Identity providers with self-registered accounts and little validation of  attributes are most suitable for consumer-facing applications that do not require strongly  validated identity data and would otherwise rely on self-registered information. Allowing  users to authenticate via such providers gives users convenience and the ability to reuse  a common profile.   40   ChApter 4    IdentIty provISIonIng   Organization Identities Many organizations, such as companies or universities, will issue an online identity  for their members, such as employees or students, respectively. These identities meet  some of the criteria for a strong identity. For example, in the United States, one must  show government-issued identity when starting a new job. This enables validation of the  identity attributes used to establish an online account within the company and ties the  account to a real person. Most companies implement measures in their identity service  such as minimum password length and possibly stronger forms of authentication,  to protect an account against unauthorized use. The corporate identity service is  authoritative for user login, at least within the domain of the issuing company. However,  a user typically cannot log in via their corporate identity service and access services  outside the organization and its contracted SaaS services. A user could not, for example,  expect to log in via their corporate identity service and access a government site to buy  stamps as the government site would not have any basis to trust the corporate identity  service. Organization identity services are primarily suitable for use by applications  selected by the organization to provide services to organization members.   Government Identities A government-issued online identity, such as those issued by the United Kingdom’s GOV. UK,ii Belgian eID,iii or Estonian e-identity,iv is an example of a stronger identity. These  require supplying information that is checked by a validation process. Some require  applying in person at a government office, and some can be done online. Required  documentation includes government-issued identity documents and photos that clearly  show one’s face and may include fingerprints and financial questions. The resulting  identity contains validated information and employs several security mechanisms to  prevent unauthorized use.  The GOV.UK Verify service, for example, is used within the United Kingdom to access   government services. The Belgian eID program issues an electronic identity that can be  used for identification, digitally signing documents, and logging in to public services.  Estonia issues a mandatory, secure national digital identity and card which Estonians  use to travel within the EU, as well as access e-services such as voting and logging in  to bank accounts, access medical records, file taxes, and sign documents with a digital  signature. Government-issued identities provide more strongly validated identities,   41   ChApter 4    IdentIty provISIonIng  but may be limited to users from one country and may be limited to use at the issuing  government’s services. Wider use would need international standards similar to those  for passports as well as a model for funding the incremental service operation costs.   Industry Consortium Identities The Belgian Mobile IDv project is a consortium of financial institutions and mobile  network operators to provide a strongly validated identity for anyone with a Belgian-  issued eID and a mobile phone. It’s used to register at services, digitally sign documents,  and securely log in as well as confirm transactions. The service includes a mobile  application, “itsme,” which is used to authenticate without the need for passwords. The  service is used to access Belgian government services such as social security and tax  services as well as telecom and e-banking applications.   Identity Provider Selection If you are creating a consumer-facing application that does not require validated identity  information, allowing users to authenticate via an existing self-registered identity, such  as a social provider account, offers users convenience over signing up with the same self-  registered information at multiple sites.  If you are creating an employee-facing application, however, relying on social   identity provider accounts to access company applications can be problematic because  the user owns their identity and account at these providers. The credential standards of  the provider may not meet company needs, and when an employee leaves the company,  you could not delete their account to terminate their access. If, on the other hand, a  social provider account is linked to a local application account, to enable logging in to  the application via the social provider identity, the link can be removed and the local  account disabled if an employee leaves. In the absence of such account linking, access  would often need to be removed within individual applications, and one or more  applications might be missed. For employee-facing applications, therefore, it’s best to  use an identity service where the employing organization owns the accounts. The same  logic applies to other organizations, such as educational institutions.  An organization-controlled identity service provides a single place at which the  organization can provision accounts as well as shut off accounts if an employee or  member leaves the organization. It also gives a single point at which to enforce credential   42   ChApter 4    IdentIty provISIonIng  strength policy and deploy multi-factor authentication as well as log authentication  activity. There are several cloud vendors that offer an identity service on a subscription  basis. Cloud services such as Google Apps, Azure AD, Auth0,1 Amazon Cognito, and Okta  offer cloud-based identity services. Organizations can provision employees or members  into these services and have complete control over the accounts including the ability to  quickly terminate or disable the accounts of anyone who leaves the organization.  If you are creating an application where your customers are businesses, you will likely  need to support a variety of different identity providers because each business may have its  own preferred identity provider service and want their users to sign in to your application  via their chosen identity provider. Your business-to-business  B2B  customers may ask  you to support authentication against cloud identity providers, such as those mentioned  in the previous sections, or private identity providers that they operate themselves on  their corporate network. It is best to do this via standard identity protocols such as OIDC  or SAML 2.0. Implementing authentication directly against a customer’s internally hosted  database or directory service would involve custom work for each customer and may expose  your staff to passwords or administrative access which increases your liability. Table 4-9  summarizes the types of identity providers that are most common for different scenarios.  Table 4-9.  Identity Providers for Different Customer Types  Scenario  Most Common Type s  of Identity Provider  B2C: Business to consumer  B2e: Business to employee  B2B: Business to business  Social Identity providers2 Identity services such as Azure Ad or Auth0 Application-specific repository  Identity services such as google Apps, Azure Ad, Auth0 Any oIdC or SAML 2.0-compliant identity provider  Identity services such as google Apps, Azure Ad, Auth0 Any oIdC or SAML 2.0-compliant provider controlled by the  business customer  1 Full disclosure: At the time of writing this book, the authors worked for Auth0. 2 Social Identity Providers are identity services such as are offered by Facebook, Twitter, Google,  GitHub, or LinkedIn.  43   ChApter 4    IdentIty provISIonIng  To recap, you should consider the target audience and strength of identity needed   by your application. If a strong identity is required, it must be issued by a process which  validates the information used to establish the identity and includes protections, such as  strong password requirements or multi-factor authentication, to prevent unauthorized  use of the identity. It must also be issued by an entity recognized as authoritative for the  application’s domain.   Choosing and Validating Identity Attributes The topic of provisioning invariably raises the contentious question of how to identify  a user. Email addresses have been widely adopted as identifiers, but such use is not  without issues. Using an email address as an identifier has the advantage that it includes  a domain name and thus provides built-in uniqueness across domains. This eliminates  the need for a user to find a name on each site that hasn’t been taken already. However,  users may need to change their email address for several reasons and still retain access  to their account. In addition, an email provider may reassign a previously used email  address to a new owner. For business-facing applications, some businesses do not  provide their employees with email accounts which can be an issue if an application  assumes the availability of an email address. Similarly, applications marketed to children  should recognize that some children may not have an email address.  Using a user-selected username also has advantages and disadvantages. A username   may make it easier for a person to set up multiple accounts if needed and is typically  shorter and therefore easier to type on mobile devices. A user must choose a unique  username, however, and if their favorite username is already taken on a site, they have  to choose another. It may be hard for users to remember which username was used at  each site, which may create a need for a forgotten username feature. When one company  acquires another, it often requires the merging of user repositories which may involve  eliminating duplicate usernames. Table 4-10 lists some common advantages and  disadvantages of different identifiers.  44   Table 4-10.  Advantages and Disadvantages of Account Identifiers  Advantages  Disadvantages  ChApter 4    IdentIty provISIonIng  Email: globally unique. no need to hunt for a name that isn’t taken  already. May be easier to remember than a  username.  Username: easier to set up multiple accounts at a site. May be shorter to type on mobile devices. Can be used in searches, allowing other  attributes with personal data to be  encrypted.  Phone number: globally unique  with country code . no need to hunt for a free identifier. May be easier for a user to remember than  a username.  Email: May need to be changed by user. May be reassigned by email provider to new user. May be reassigned by corporate provider to new user. terminated by employer if user leaves. not all companies issue email addresses. Children may not have email addresses. Family members may share an email address. May expose personal information  user’s name . exposure as display name may result in spam email.  Username: only unique within an application domain. Merging user repositories problematic after  acquisitions. May be harder for a user to remember which  username was used at each site. A user may want to change a username over time. May expose personal information if used for display.  Phone number: exposure as display name may cause spam calls. Might be reassigned to a new user over time. May involve a charge to obtain a phone number. More difficult to set up multiple accounts at same site. May be changed by user for various reasons. May be terminated by phone provider.  45    IdentIty provISIonIng  ChApter 4   Suggestions Some of the disadvantages listed earlier stem from using the same attribute for multiple  purposes. They can be avoided by decoupling and using a different attribute for each of  the following purposes:      Identifier for logging in     Display name     Notification communication account recovery      Internal account implementation     Linking an identity account to application records     Capturing user activity in log files     Continuous identifier for a user over time for audit purposes  The last three in the list are used for internal account implementation and should   use a unique, internal account identifier that is not impacted by a user’s need to change  profile attributes such as their email address, phone number, or their legal name. In  addition, the following suggestions can avoid some of the other disadvantages outlined  in Table 4-9:     Avoid exposing identifiers that may contain personal data.     Use an internal account identifier in log files to avoid directly   exposing personal data in logs.     Use an internal account identifier in application records.     Allow users to specify a display name for use on screens   printouts to protect privacy.      Identifiers attributes for logging in, display, and notification should  be distinct and changeable.     Allow setting multiple attributes for notification purposes, such as a   primary and secondary email, in case one becomes inoperable.  46   ChApter 4    IdentIty provISIonIng     Allowing a long username with special characters and which is   changeable by users would enable flexibility, including use of an  email address if that is easier for some users to remember, while  allowing other users to use other values. A separate profile attribute  besides the username should be used for notification contact  information.   Validating Critical Attributes In addition to using different profile attributes for different functions, it is important  to validate email addresses and other profile attributes if used in activities that impact  security and privacy. This includes attributes used for     Authorization decisions     Account recovery     Delivery of sensitive information to the user  For example, if a user profile includes an email address, and the email address  attribute is used in authorization decisions, you should implement email address  validation. Similarly, email address attributes used for notification in account recovery  or delivery of sensitive information should be validated. The same holds true if a phone  number is used for such purposes. If you import identities from elsewhere, you should  ensure email addresses or other critical attributes used for the listed functions have been  validated before accepting them.  Security and privacy-related issues can arise with unvalidated attributes. If users  can sign up using a fictitious, unvalidated email address and this attribute is used for  authorization, their fictitious email address may match authorization rules that grant  access to resources they are not really entitled to access. Validating email addresses  also prevents accidental entry of an incorrect address. Incorrect email addresses could  enable account takeover via account recovery mechanisms or result in the delivery of  sensitive information to the wrong recipient. For these reasons, it is critical to decouple  attributes for different purposes and validate any email addresses or other profile  attributes that are used in authorization decisions, account recovery mechanisms, or to  deliver sensitive information to users.  47   ChApter 4    IdentIty provISIonIng   Summary We’ve covered several approaches that can be used to establish accounts for the users  of your application, including self-registration, progressive profiling, transferring users  from elsewhere, administrative processes, and leveraging identity provider services. In  selecting a provisioning approach, you will want to consider the strength and suitability  of the identity offered by each option against the sensitivity and target audience of  your application. Once you have an idea how your users will be created, you can start  implementing authentication and access control. Modern applications are often  designed starting with APIs, so we’ll start off in the next chapter with OAuth 2.0, which is  designed for protecting APIs.   Key Points     Provisioning is the process of creating an account and associated   identity information.     Applications can create new accounts for users or leverage identities   in existing identity provider services.     Progressive profiling can be used to build up user profiles over time.     Email addresses and other attributes used for notifications to users   must be validated.      Identities can be classified as weak or strong depending on a  provider’s practices.     Weak identities are created with unvalidated information.     Strong identities are based on validated information, mechanisms  to prevent forgery and unauthorized use and are issued via secure  distribution mechanisms by authoritative providers.      In choosing identity providers, a service should match the strength of  the identity offered by the provider with the identity validation and  strength requirements of an application.     Application designers should decouple and designate appropriate  user profile attributes for each of several purposes, including login,  display, notification, and internal tracking.  48   ChApter 4    IdentIty provISIonIng   Notes           i.  https:  tools.ietf.org html rfc7644  ii.  www.postoffice.co.uk identity government-verify    iii.  https:  eid.belgium.be en what-eid  iv.  https:  e-estonia.com solutions e-identity     v.  www.belgianmobileid.be en  49   CHAPTER 5  OAuth 2.0 and API  Authorization  The possession of great power necessarily implies great responsibility.  —William Lamb, British Member of Parliament, Home Secretary, and  Prime Minister. From a speech in the House of Commons, 1817  Modern applications are often designed around APIs. APIs enable applications to reuse  logic and take advantage of innovative services. APIs provide access to valuable data or  services, so they typically need to restrict API access to authorized parties. Applications  therefore need authorization to call APIs. If an application wants to call an API on a  user’s behalf to access resources owned by the user, it needs the user’s consent. In the  past, a user often had to share their credentials with the application to enable such an  API call on their behalf. This gave the application an unnecessary amount of access, not  to mention the responsibility of safeguarding the credential! In this chapter, we will cover  how the OAuth 2.0 framework provides a better solution for authorizing applications to  call APIs.   API Authorization An application may need to call an API on behalf of a user, to access content owned  by the user, or on its own behalf if the application owns the desired content. Figure 5-1  illustrates these two cases using a sample scenario.    Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2_5  51   Chapter 5    Oauth 2.0 and apI authOrIzatIOn  Figure 5-1.  API Authorization: User-Based vs. Client-Based Flow  In this scenario, the application, WriteAPaper.com, is a specialized editor that helps   users write and edit research papers. It calls two APIs, both of which are owned by  different organizations. The first is famousquotes.com which provides validated quotes  for use in papers. The second API is at documents.com and provides a document storage  service. There is a second, mobile application that calls the documents.com API to  provide access to documents from a user’s mobile device.  When the WriteAPaper application calls the API at famousquotes.com, it does so on   its own behalf. The quotes content is not owned by the user, so the user’s consent isn’t  needed for this access. The application only needs to be a registered client authorized to  call the quotes API. When the application calls the API at documents.com, however, to  obtain a user’s documents, the request must be made on behalf of the user. In this case,  the content accessed belongs to the user, and the application must obtain the user’s  consent to retrieve the user’s documents. The client application has no right by itself to  access the user’s data at another site.  The mobile application provides read-only access to a user’s documents and   doesn’t offer access to the quotes service. It requires authorization from a user to call  the documents API and retrieve the user’s documents. We’ve included the mobile  application in the example because we’ll show in the following sections how OAuth 2.0  could enforce different privileges for the two applications.  52   Chapter 5    Oauth 2.0 and apI authOrIzatIOn   OAuth 2.0 The OAuth 2.0 Authorization Framework,i published in 2012, was designed to enable  an application to obtain authorization to call third-party APIs. With OAuth 2.0, an  application can obtain a user’s consent, to call an API on their behalf, and not need their  credentials for the API site. An application can also obtain authorization to call an API on  its own behalf if it owns the content to be accessed.  The primary use case involves a user, called a resource owner, who wishes to allow   an application to access a protected resource, owned by the resource owner, at a logically  separate site, known as the resource server. Using our example from Figure 5-1, the  resource owner  the user  has stored documents at a resource server  documents.com .  The resource owner is using the WriteAPaper application to write a paper based on  content they’ve uploaded to documents.com. The resource owner wants to grant the  WriteAPaper application access to their content at documents.com so it can retrieve the  content for use in their research paper.  Before OAuth 2.0, the usual solution involved some risks. The user had to give   the WriteAPaper application their documents.com credential so WriteAPaper could  retrieve their documents at documents.com. Once it had the user’s credentials, however,  WriteAPaper could retrieve anything from the user’s account and even modify or delete  documents as the user. There was no way for the user to restrict what the WriteAPaper  application could do! Furthermore, WriteAPaper might need to retain the password  in a decryptable form, or worse, in cleartext form, to access documents.com later. If  WriteAPaper were compromised, and the password decryption key or cleartext passwords  stolen, the user’s data at documents.com would be at risk. The user also had no way of  revoking WriteAPaper’s access to documents.com except by changing their credentials  which would revoke access for any other applications that needed access to documents. com on their behalf. The scenario without OAuth 2.0 is depicted in Figure 5- 2.  Figure 5-2.  Without OAuth 2.0  53   Chapter 5    Oauth 2.0 and apI authOrIzatIOn  OAuth 2.0 was designed to provide a better solution. It enables a user to explicitly   authorize an application to call an API on the user’s behalf, without giving their  credentials for the API site to the application and in a way that limits what the application can  do. With OAuth 2.0, when an application needs to call an API on behalf of a user, it sends an  authorization request to an authorization server for the API. An authorization server handles  access requests for an API and returns a security token that can be used by the application  to access the API. In the authorization request, the application gives an indication  known  as the “scope”  of what it wants to request from the API. The authorization server evaluates  the request and, if authorized, returns a token to the application.  If the application asks for content owned by the user, the API’s authorization server   authenticates the user and then asks the user to give their consent for the application  to access the requested data. The authentication step ensures the user providing the  consent is the owner of the resource being accessed. If the user consents to the requested  access, the application receives a token to call the API on the user’s behalf. The token  is called an access token, and it enables the application to make API requests within  the scope of what the user authorized when they gave their consent for the request.  This solution eliminates the need for the user to share credentials with the application  and gives the user more control over what the application can access.  Note: The exact  process by which the application gets the access token is described here in a simplified  form but will be explained more accurately in subsequent sections.  Figure 5- 3 shows the  solution with OAuth2.0 in the picture.  Figure 5-3.  With OAuth 2.0  54   Chapter 5    Oauth 2.0 and apI authOrIzatIOn  To recap, the OAuth 2.0 protocol provides an authorization solution, not an   authentication solution. It enables an application to call an API on its own behalf  or a user’s behalf, with the call constrained to the scope of an authorized request.  The authentication step in OAuth 2.0 validates the user is entitled to give consent  to authorize an access request for a particular resource. The OAuth 2.0 access token is  only intended for API access and not to convey information about the authentication  event or the user. The use of OAuth 2.0 is therefore appropriate for authorizing API calls  but not as an authentication solution  at least in the absence of any proprietary additions  to the base protocol, which some providers have implemented . OIDC, described in  the next chapter, can be used to authenticate a user to an application, but this chapter  focuses on describing how OAuth2.0 works for the purpose of API authorization.   Terminology To describe OAuth 2.0 in more detail, we need to describe a few terms defined by OAuth 2.0.   Roles OAuth 2.0 defines four roles involved in an authorization request:     Resource Server – A service  with an API  storing protected   resources to be accessed by an application.     Resource Owner – A user or other entity that owns protected   resources at the resource server.     Client – An application which needs to access resources at the   resource server, on the resource owner’s behalf or on its own  behalf. We’ll generally use the term application instead of client, for  consistency across chapters.     Authorization Server – A service trusted by the resource server to  authorize applications to call the resource server. It authenticates  the application or resource owner and requests consent from the  resource owner if the application will make requests on the resource  owner’s behalf. With OAuth 2.0, the resource server  API  is a relying  party to the authorization server. The authorization server and  resource server may be operated by the same entity.  55    Oauth 2.0 and apI authOrIzatIOn  Chapter 5   Confidential vs. Public Clients OAuth2.0 defines two client types:     Confidential Client – An application that runs on a protected server   and can securely store confidential secrets to authenticate itself  to an authorization server or use another secure authentication  mechanism for that purpose.     Public Client – An application that executes primarily on the user’s  client device  native application  or in the client browser and cannot  securely store a secret or use other means to authenticate itself to an  authorization server.   Client Profiles OAuth 2.0 defines three profiles based on application topologies:     Web Application – A confidential client with code executing on a   protected, back-end server. The server can securely store any secrets  needed for the client to authenticate itself as well as any tokens it  receives from the authorization server.     User Agent-Based App – Assumed to be a public client with code   executing in the user’s browser. Example: A JavaScript-based single-  page application running in the browser.     Native Application – Assumed to be a public client that is installed  and executed on the user’s device, such as a mobile application or  desktop application.  In practice, these definitions may overlap because a web application may serve up   HTML pages that contain some JavaScript, and single-page applications may have a  small back end. For further discussion on this, see the description in Chapter 6 of the  OIDC Hybrid flow.  56   Chapter 5    Oauth 2.0 and apI authOrIzatIOn   Tokens and Authorization Code OAuth 2.0 defines two security tokens and an intermediary authorization code:     Authorization Code – An intermediary, opaque code returned to  an application and used to obtain an access token and optionally a  refresh token. Each authorization code is used once.     Access Token – A token used by an application to access an API. It  represents the application’s authorization to call an API and has an  expiration.     Refresh Token – An optional token that can be used by an   application to request a new access token when a prior access token  has expired.   How It Works The OAuth 2.0 Authorization Framework specification defines four methods by which  applications obtain authorization to call an API. Each method uses a different type of  credential to represent the authorization. These credentials are known as authorization  grants. The type of authorization grant to use depends on the use case and type  of application. The four authorization grant types are     Authorization code grant      Implicit grant     Resource owner password credentials grant     Client credentials grant  The following sections will describe how each of these work.   Authorization Code Grant The authorization code grant type uses two requests from the application to the  authorization server to obtain an access token. In the first request, the user’s browser  is redirected to the authorization endpoint at the authorization server with a request  to authorize an API call to be made on the user’s behalf. The browser redirect enables  the authorization server to interact with the user to authenticate them and obtain   57   Chapter 5    Oauth 2.0 and apI authOrIzatIOn  their consent for the authorization request. After obtaining the user’s consent, the  authorization server redirects the user’s browser back to the application with an  authorization code. The application uses the authorization code to send a second,  backchannel request to the authorization server’s token endpoint to obtain an access  token. The authorization server responds with an access token issued to the application  which it can use to call the API. Figure 5-4 shows the sequence of steps.  Figure 5-4.  Authorization Code Grant Type + PKCE    1.  User  resource owner  accesses the application.    2.  Application redirects browser to the authorization server’s   authorize endpoint with an authorization request.    3.  Authorization server prompts the user for authentication and   consent.1    4.  User authenticates and provides consent for the request.    5.  Authorization server redirects the user’s browser back to the   application’s callback URL with an authorization code.  1 The mechanism by which a user is authenticated to provide consent is outside the OAuth 2.0  specification. It is shown in the diagram  steps 3 and 4  to show where it occurs in the sequence.  58   Chapter 5    Oauth 2.0 and apI authOrIzatIOn    6.  Application calls authorization server’s token endpoint, passing     7.  The authorization server responds with an access token  and   the authorization code.  optionally a refresh token .    8.  Application calls the resource server  API , using the access token.  The authorization code grant type was originally optimized for confidential clients.  The first  authorization  request redirects the user to the authorization server so it can  interact with the user. The second request could be made by the application’s back end  directly to the authorization server’s token endpoint. This enables an application back  end, which is assumed to be capable of securely managing an authentication secret,  to authenticate itself to the authorization server when exchanging the authorization  code for the access token. It also means that the response with the access token can be  delivered to the application back end, which will make the subsequent API calls. An  added side benefit is that the tokens are returned via secure backchannel response.  However, while originally optimized for confidential clients, the addition of PKCE  enables public clients to use this grant type as well.   Authorization Code Grant Type + PKCE  The authorization code grant type diagram shows the use of Proof Key for Code  Exchange  PKCE .ii PKCE is a mechanism that can be used with authorization and token  requests to ensure that the application that requested an authorization code is the same  application that uses the authorization code to obtain an access token. PKCE protects  against a malicious process, especially on mobile devices and with public clients, that  could intercept an authorization code and use it to get an access token.  To use PKCE, the application creates a cryptographically random string, called a   code verifier, that is long enough to provide sufficient protection against guessing. The  application then computes a derived value, called a code challenge, from the code  verifier. When the application sends an authorization request in step 2 in the diagram, it  includes the code challenge, along with the method used to derive it.  When the application sends the authorization code to the authorization server’s   token endpoint to get the access token in step 6, it includes the code verifier. The  authorization server transforms the code verifier value using the transformation method  received in the authorization request and checks that the result matches the code  challenge sent with the authorization request. This enables an authorization server to   59   Chapter 5    Oauth 2.0 and apI authOrIzatIOn  detect if a malicious application is trying to use a stolen authorization code. Only the  legitimate application will know the code verifier to pass in Figure 5-4’s step 6 that will  match the code challenge passed in step 2.  The PKCE specification lists two transform methods that can be used to derive the   code challenge from the code verifier, namely, “plain” and “S256.” With the “plain”  method, the code challenge and verifier are identical, so there is no protection against  the code challenge being compromised. Applications using the authorization code grant  with PKCE should use the S256 transform method which uses a base64 URL encoded  SHA256 hash of the code verifier to protect it.   The Authorization Request  Here is a sample application's API authorization request with PKCE. It would be directed  to an authorization server’s authorization endpoint.2  GET  authorize?   response_type=code & client_id=  & state=  & scope=  & redirect_uri=  & resource=  & code_challenge=  & code_challenge_method=S256 HTTP 1.1  Host: authorizationserver.com   Table 5-1 shows common parameters for the authorization request.  2 The parameters for all of the examples may vary somewhat for your specific provider. See also  the OAuth2.0 specification for additional optional parameters.  60   Table 5-1.  Authorization Request Parameters  Meaning  Chapter 5    Oauth 2.0 and apI authOrIzatIOn  Parameter  response_type  client_id  state  scope  redirect_uri  resource  code_challenge  Indicates the Oauth 2.0 grant type. “code” is used for the authorization  code grant type.  Identifier for the application, assigned when it registered with the  authorization server.  a non-guessable string, unique for each call, opaque to the  authorization server, and used by the client to track state between  a corresponding request and response to mitigate the risk of CSrF  attacks. It should contain a value that associates the request with the  user’s session. this could be done by including a hash of the session  cookie or other session identifier concatenated with an additional  unique-per-request component. When a response is received, the  client should ensure the state parameter in the response matches the  state parameter for a request it sent from the same browser.  Indicates the scope of access privileges for which authorization is  requested. For example: “get:documents”  the authorization server sends its response with the authorization  code to this callback urL at the application. For example: https%3a% 2F%2Fclient%2eapplication%2ecom%2Fcallback  Identifier for a specific apI registered at authorization server for  which the access token is requested. this parameter is defined in the  resource Indicators for Oauth 2.0 extension.iii Some implementations  may use other names, such as “audience.” primarily used in  deployments with custom apIs. this parameter isn’t needed unless  there are multiple possible apIs.  pKCe code challenge derived from the pKCe code verifier using the  code challenge method specified in the code_challenge_method  parameter, as described in Section 4.2 of the pKCe specification.iv  61  code_challenge_method  “S256” or “plain.” applications capable of using S256 must use it.   Chapter 5    Oauth 2.0 and apI authOrIzatIOn  The scope parameter is used by an application to request a scope of access   privileges. Using our WriteAPaper application example from the beginning of the  chapter, the primary, single-page application would request a scope of “get:documents  update:documents,” whereas if the mobile client only needed read access to documents,  it would only request “get:documents.”  The resource parameter was not in the original OAuth 2.0 specification. Since that  time, authorization servers have been written to handle requests for multiple APIs and,  in such cases, may support an additional parameter to indicate a specific API for an  authorization request. This parameter may be called the “resource” or “audience.”   Response  The authorization server sends a response like the following to the application’s  callback, specified in the redirect_uri parameter of the authorization request.  HTTP 1.1 302 Found Location: https:  clientapplication.com callback? code=  & state=   Table 5-2 shows the response parameters.  Table 5-2.  Authorization Response Parameters  Parameter Meaning  code  state  the authorization code to be used by the application to request an access token.  the state value, unmodified, sent in the authorization request. application must validate  that the state value in the response matches the state value sent with the initial request.   Calling the Token Endpoint  After receiving an authorization code, the application uses it in a second request to the  authorization server’s token endpoint to obtain the access token.  POST  token HTTP 1.1 Host: authorizationserver.com Content-Type: application x-www-form-urlencoded  62   Chapter 5    Oauth 2.0 and apI authOrIzatIOn  grant_type=authorization_code & code=  & client_id=  & code_verifier=  & redirect_uri=   are shown in Table 5-3.  Table 5-3.  Token Request Parameters  Parameter  Meaning  The parameters for this example request to the authorization server’s token endpoint   grant_type  Must be “authorization_code” for the authorization code grant.  code  client_id  code_verifier  the authorization code received in response to the authorization call.  Identifier for the application, assigned when it registered with the authorization  server.  the pKCe code verifier value from which the code challenge was derived. It  should be an unguessable, cryptographically random string between 43 and  128 characters in length, inclusive, using the characters a–z, a–z, 0–9, “-”, “.”,  “_”, and “~” and formed as described in Section 4.1 of the pKCe specification.v  redirect_uri  the callback urI for the authorization server’s response. Should match the  redirect_uri value passed in the authorization request to the authorize endpoint.   The response from the token endpoint will be similar to the following:  HTTP 1.1 200 OK Content-Type: application json;charset=UTF-8 Cache-Control: no-store Pragma: no-cache       {        "access_token":" ",        "token_type":"Bearer",        "expires_in": ,        "refresh_token":" "      }  63   Chapter 5    Oauth 2.0 and apI authOrIzatIOn  The parameters for the response are shown in Table 5-4.  Table 5-4.  Token Endpoint Response Parameters  Parameter  Meaning  access_token  token_type  expires_in  refresh_token  the access token to use in calling the apI. different authorization servers may  use different formats for access tokens.  type of token issued. “Bearer,” for example.  how long the token will be valid.  a refresh token is optional. It is up to an authorization server's discretion  whether to return a refresh token or not. See the refresh token section later in  this chapter for further information.   Implicit Grant OAuth 2.0 defines an implicit grant type which was optimized for use with public clients  such as single-page applications. Use of this grant type returns an access token to an  application in one request. It was designed at a time when the CORS  Cross-Origin  Resource Sharing  standardvi was not widely supported in browsers so that web pages  could only “phone home.” In other words, they could only make calls to the domain  from which the page was loaded which meant they couldn’t call an authorization  server’s token endpoint. To compensate for this limitation, the implicit grant type has  the authorization server respond to an authorization request by returning tokens to  the application in a redirect with a URL hash fragment. The interaction for the implicit  grant type is shown in Figure 5-5.  64   Chapter 5    Oauth 2.0 and apI authOrIzatIOn  Figure 5-5.  OAuth 2.0 Implicit Grant Type     1.  User  resource owner  accesses the application.    2.  Application redirects browser to the authorization server’s   authorize endpoint with authorization request.    3.  Authorization server prompts the user to authenticate and provide     4.  The user authenticates and provides consent for the authorization   consent.3  request.    5.  Authorization server redirects back to the application’s callback   URL with an access token.    6.  The application uses the access token to call the resource server  API .  Since the OAuth2.0 specification was originally published, CORS has become   supported by most browsers. Consequently, the implicit grant type isn’t needed  anymore for its original purpose. Furthermore, returning an access token in a URL hash  fragment exposes the access token to potential leakage via browser history or referer  headers. The implicit grant type with the access token returned in a URL hash fragment   3 The mechanism by which a user is authenticated to provide consent is outside the OAuth 2.0  specification. It is shown in the diagram  steps 3 and 4  to show where it occurs in the sequence.  65   Chapter 5    Oauth 2.0 and apI authOrIzatIOn  is no longer recommended for single-page applications needing an access token.4 The  authorization code grant type   with PKCE  should be used instead.  It should also be noted that after the release of the original OAuth 2.0 specification,  the OAuth 2.0 Multiple Response Type Encoding Practices specificationvii defined a new  “response_mode” parameter for authorization requests that would enable applications  to request that authorization server responses be returned in new ways. Subsequent  specifications defined new response mechanisms. The OAuth 2.0 Form Post Response  Modeviii encodes response parameters into an HTML form that is sent via HTTP-POST  to the application. At the time of writing, a draft specification exists for an OAuth 2.0  Web Message Response Modeix which leverages HTML 5 Web Messaging to return  an authorization response to an application. The implicit grant type with alternate  response modes provides new options to applications that can mitigate issues related to the  default response mode.   The Authorization Request  A sample authorization request for the implicit grant type looks like the following, with  parameters similar to the previous grant type, but a response type of “token” which  indicates use of the implicit grant type, and response_mode set to form_post:  GET  authorize?   response_type=token & response_mode=form_post & client_id=  & scope=  & redirect_uri=  & resource=  & state=  HTTP 1.1 Host: authorizationserver.com   A successful implicit grant type authorization request using the default response   mode will result in a redirect back to the application’s redirect URI with the access token,  token type, token expiration, and state values in a URL fragment which can be exposed  via referer headers and browser history. A request using the form_post response mode   4 https:  tools.ietf.org html draft-ietf-oauth-security-topics-13section-3.1.2  66   will result in the response encoded in an HTML form posted to the redirect_uri, avoiding  the URL fragment exposure.   Chapter 5    Oauth 2.0 and apI authOrIzatIOn   Resource Owner Password Credentials Grant The resource owner password credentials grant type supports situations where an  application is trusted to handle end-user credentials and no other grant type is possible. For  this grant type, the application collects the user’s credentials directly instead of redirecting  the user to the authorization server. The application passes the collected credentials to the  authorization server for validation as part of its request to get an access token.  This grant type is discouraged because it exposes the user’s credentials to the  application. It has been used for legacy embedded login pages and user migration  scenarios. In either case, a vulnerability in the application can compromise the  credentials. In addition, this grant type does not involve a user consent step, so an  application can request any access it wishes using the user’s credentials. The user has no  way to prevent abuse of their credentials.  Consequently, this grant type is primarily recommended for user migration   use cases. If users need to be migrated from one identity repository to another with  incompatible password hashes, the new system can prompt a user for their credentials,  use the resource owner password grant to validate them against the old system, and if  valid, retrieve the user profile from the old system and store it and the credentials in the  new system. This can avoid the necessity for large-scale forced password resets when  migrating identity information. If this grant type is used, the client should throw away the  user credentials as soon as it has obtained the access token, to reduce the possibility of  compromised credentials.  67   Chapter 5    Oauth 2.0 and apI authOrIzatIOn  The interaction for resource owner password grant type is shown in Figure 5-6.  Figure 5-6.  Resource Owner Password Credentials Grant Type     1.  User  resource owner  accesses the application.    2.  Application prompts the user for their credentials.5    3.  The user provides their credentials to the application.    4.  Application sends token request to the authorization server's   token endpoint, with the user’s credentials.    5.  Authorization server responds with an access token  and   optionally a refresh token .    6.  Application calls the resource server  API , using the access token.  This grant type has also been used in the past with mobile applications calling   first-party APIs. This was often done because login flows that redirected via browsers  on mobile devices were perceived as cumbersome. This has improved, and RFC 8252,  OAuth 2.0 for Native Apps,x now recommends the use of the authorization code grant,  combined with PKCE, for native applications using the system browser.  5 The mechanism by which the application obtains the user credentials is outside the OAuth 2.0  specification. It is shown in the diagram  steps 2 and 3  to provide a more complete picture of the  solution.  68   Chapter 5    Oauth 2.0 and apI authOrIzatIOn   The Authorization Request  A sample token request for the resource owner password grant type looks like the  following, with parameters similar to previous grants, but a grant type of “password” and  the username and password collected from the user. The user credentials obtained by  the application serve as the authorization for the application, and are used to request an  access token from the token endpoint.   POST  token HTTP 1.1 Host: authorizationserver.com Authorization: Basic    Content-Type: application x-www-form-urlencoded  grant_type=password & scope=  & resource=  & username=  & password=   This sample has the application authenticate to the authorization server with HTTP  Basic authentication scheme and a client ID and secret, obtained from the authorization  server. A successful request will result in a response from the token endpoint similar to  that described in the previous section for the authorization code grant.   Client Credentials Grant The client credentials grant type is used when an application calls an API to access  resources the application owns. An example is shown in Figure 5-1 with the call to the  quote service. A quote is not owned by the individual user who needs the quote, so the  call can be made on the application’s behalf. The application uses the client credentials  grant type and authenticates to the authorization server with its own credentials to  obtain an access token. The sequence diagram for this grant type is shown in Figure 5-7.  69   Chapter 5    Oauth 2.0 and apI authOrIzatIOn  Figure 5-7.  Client Credentials Grant Type     1.  Application sends authorization request including  application's credentials to the authorization server.    2.  Authorization server validates the credentials and responds with   an access token.    3.  Application calls resource server  API  using the access token.   4–6.  The steps repeat if the access token has expired by the next time   the application calls the API.  No end-user interaction with the authorization server is required for this flow. The   application credentials serve as the authorization for the application and are used to  request an access token from the token endpoint. Our sample uses a client ID and client  secret obtained when the application registered with the authorization server.   The Authorization Request  A sample token request for the client credentials grant type follows, with parameter  definitions the same as those for previous grant types but with the grant_type set to  “client_credentials”. The application authenticates in this example with a client ID and  secret registered at the authorization server, one of several options.  70   Chapter 5    Oauth 2.0 and apI authOrIzatIOn  POST  token HTTP 1.1 Host: authorizationserver.com Authorization: Basic     Content-Type: application x-www-form-urlencoded  grant_type=client_credentials & scope=  & resource=   A successful client credentials grant request will result in a response from the token   endpoint similar to that described in the previous section for the authorization code  grant.   Calling an API Once an application receives an access token, it calls the resource server and passes  the access token. The exact call varies with the API, but a typical approach is to use the  HTTP “Authorization” request header field with a bearer authentication token type in the  authorization header and the access token as shown in the following snippet:  GET  api-endpoint HTTP 1.1 Host: api-server.com Authorization: Bearer    The access token has an expiration, so it can only be used for a limited time, but  it is not a one-time-use token. As a performance optimization, an access token can  be cached by an application and reused until it expires, to avoid making a call to the  authorization server for every API call. The access token must have been granted the  appropriate scope of privileges for the API calls. This should not, however, encourage the  use of overly broad scopes!   Refresh Token OAuth 2.0 access tokens have an expiration. When an access token expires, an application  could make a new authorization request, but OAuth 2.0 defined an alternative approach  for traditional web applications and native clients that involves a refresh token. A refresh  token can be obtained from an authorization server and used to obtain a new access   71   Chapter 5    Oauth 2.0 and apI authOrIzatIOn  token when a previous access token expires. A refresh token can be used to enable  ongoing API access from native mobile applications, for example.  Refresh tokens are not used in all scenarios. There is no need for a refresh token   with the client credentials grant because an application can simply request an access  token programmatically at any time, without a need for user interaction. Static refresh  tokens are not used with public clients because they are sensitive tokens and public  clients are not capable of securely storing them. The OAuth 2.0 Threat Model and  Security Considerationsxi document proposed the notion of refresh token rotation to  detect if a refresh token has been stolen and is being used by two or more clients. This  scheme has the authorization server return a new refresh token with each access token  renewal request. The OAuth 2.0 Security Best Current Practice documentxii specifies  that authorization servers must use either refresh token rotation or sender-constrained  refresh tokens  bound to a particular client  with public clients to mitigate the risk of  compromised refresh tokens.   Refresh tokens provide a convenient way for traditional web applications and native   applications to obtain new access tokens. This facilitates use of access tokens with a  short duration, which minimizes the risk if an access token is compromised. It may be  tempting to automatically refresh an access token as soon as it expires, but in keeping  with the principle of least privilege, it is better to only refresh an access token when it is  needed, rather than always keeping a current access token on hand. In the same vein, an  application must store a refresh token securely as it is a sensitive credential.   The OAuth 2.0 specification did not include a mechanism for applications to request   refresh tokens, leaving the issuance at the discretion of authorization servers. The  handling of refresh tokens may therefore vary across individual authorization servers.  Some issue refresh tokens automatically, and others expect an application to explicitly  request a refresh token.  The OIDC specification, covered in the next chapter, includes a  mechanism for an application to request a refresh token for one specific use case.  The  ability to revoke access tokens is not a mandatory feature in the OAuth 2.0 specification,  so some authorization servers may not support it. The documentation for your chosen  authorization server should explain the implementation-specific details.  A sample call to an authorization server’s token endpoint to request a new access   token is shown in the following sample. The client must authenticate itself for the  request.  72   Chapter 5    Oauth 2.0 and apI authOrIzatIOn  POST  token HTTP 1.1 Host: authorizationserver.com  Authorization: Basic    Content-Type: application x-www-form-urlencoded  grant_type=refresh_token & refresh_token=   The access token will be returned in a response similar to that described in previous  sections. The scope parameter is optional, and if used, must be equal to, or lesser than,  the scope in the original authorization request, and the client credentials passed must be  those of the application which made the original authorization request.   Guidance The preceding sections covered an introduction to how an application requests API  authorization via OAuth 2.0. An SDK may abstract and simplify some of this interaction  or use different parameter names. You’ll need to check the documentation for your  authorization server for implementation-specific details. Even if you use an SDK,  however, it is valuable to know the form of the underlying calls for troubleshooting. In  addition, be sure to check the OAuth 2.0 specification as there are several additional  request parameters useful for more advanced use cases.  An access token is meant to be consumed by an API. The format of an access token   may vary, but an application should not depend on using data in the access token  in the  absence of proprietary extensions . An API that receives an access token must validate  it before processing the request it accompanies. The process for validating a token may  vary by authorization server implementation.  In general, it is recommended that access token duration be short-lived and a new  access token obtained when needed if the previous access token has expired. The exact  duration should be determined based on the sensitivity of the resources to be accessed.  Access tokens can be cached, for a period of time less than or equal to their expiration, as  a performance optimization and or to avoid hitting rate limits with excessive calls to an  authorization server. It is important to note that access tokens and refresh tokens must  be stored securely as they are sensitive credentials. You should utilize the secure storage  options for your platform when storing these tokens.  73   Chapter 5    Oauth 2.0 and apI authOrIzatIOn   Summary The OAuth2.0 protocol enables an application to obtain authorization to call an API  on either a user’s behalf or on its own behalf. This eliminates the requirement for users  to share their credentials with the application. It also provides the user greater control  over what the application can do and a limit on the duration of API access. The user can  revoke API access for an individual application without impacting the ability of other  applications to call the API on their behalf. Once you have an application authorized to  call an API, you’ll want to authenticate users to that application, which is covered in the  next chapter.   Key Points     OAuth 2.0 enables applications to request authorization and obtain   an access token to call APIs.     With OAuth 2.0, a user has control over API authorizations for   applications.  an API.     Scopes are used to control the access an application has when calling      The original OAuth 2.0 specification defined four grant types.     The authorization code grant type with PKCE can be used by   traditional web applications, public applications, as well as native  applications.     The OAuth 2.0 implicit grant type is not recommended to obtain an  access token with the default response mode as it exposes the access  token to potential compromise.     The OAuth 2.0 resource owner password grant type is best restricted   to legacy user migration cases as it exposes user credentials to an  application.     The client credentials grant type is for API calls where the application   owns the requested resource.     A refresh token is used to obtain a new access token when the old   access token expires.  74   Chapter 5    Oauth 2.0 and apI authOrIzatIOn   Notes        i.  https:  tools.ietf.org html rfc6749  ii.  https:  tools.ietf.org html rfc7636  indicators-02     iv.  https:  tools.ietf.org html rfc7636    v.  https:  tools.ietf.org html rfc7636    vi.  https:  www.w3.org TR cors     iii.  https:  tools.ietf.org html draft-ietf-oauth-resource-    vii.  https:  openid.net specs oauth-v2-multiple-response-   viii.  https:  openid.net specs oauth-v2-form-post-response-  types-1_0.html  mode-1_0.html    ix.  https:  tools.ietf.org html draft-sakimura-oauth-wmrm-00    x.  https:  tools.ietf.org html rfc8252    xi.  https:  tools.ietf.org html rfc6819section-5.2.2.3    xii.  https:  tools.ietf.org html draft-ietf-oauth-security-  topics-13section-4.12  75   CHAPTER 6  OpenID Connect  In  the  social  jungle  of  human  existence,  there  is  no  feeling  of  being  alive  without a sense of identity.  —Erik Erikson, German-American developmental psychologist and  psychoanalyst who coined the phrase “Identity crisis,”   from Identity: Youth and Crisis  1968   As described in the previous chapter, OAuth 2.0 provides a framework for authorizing  applications to call APIs, but isn’t designed for authenticating users to applications.   The OpenID Connect  OIDC i protocol provides an identity service layer on top of  OAuth 2.0, designed to allow authorization servers to authenticate users for applications  and return the results in a standard way. Some implementations of OAuth 2.0 added  proprietary additions to do this, but a standard solution was needed. In this chapter,  we’ll describe the problem OIDC solves in more detail and how an application can use  OIDC to authenticate a user.   Problem to Solve The scenario OIDC is designed to solve involves a user who needs to be authenticated  in order to access an application. OIDC enables an application to delegate user  authentication to an OAuth 2.0 authorization server and have it return to the application  claims about the authenticated user and authentication event in a standard format.  Figure 6-1 provides an illustration of how this works.    Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2_6  77   Chapter 6    OpenID COnneCt  Figure 6-1.  OIDC Authentication  When a user accesses an application, it redirects the user’s browser to an   authorization server that implements OIDC. OIDC calls such an authorization server an  OpenID Provider so we’ll use that term in this chapter. The OpenID Provider interacts  with the user to authenticate them  assuming they haven’t logged in already . After  authentication, the user’s browser is redirected back to the application. The application  can request that claims about the authenticated user be returned in a security token  called an ID Token. Alternatively, it can request an OAuth 2.0 access token and use it  to call the OpenID Provider’s UserInfo endpoint to obtain the claims. Because OIDC is  a layer on top of OAuth 2.0, an application can use an OpenID Provider for both user  authentication and authorization to call the OpenID Provider’s API. We’ve glossed over  a few details in this first description just to convey the basic concept. The next section  will define some additional terms so we can provide further details and a more accurate  description.  78   Chapter 6    OpenID COnneCt   Terminology OIDC defines the following terms.   Roles There are three different roles involved in the OIDC solution:     End User – The end user is a subject to be authenticated.  We will use   the term “user” for simplicity and consistency across chapters.       OpenID Provider  OP  – The OpenID Provider is an OAuth 2.0   authorization server that implements OIDC and can authenticate  a user and return claims about the authenticated user and the  authentication event to a relying party  application .     Relying Party  RP  – An OAuth 2.0 client which delegates user   authentication to an OpenID Provider and requests claims about  the user from the OpenID Provider. We will generally use the term  “application” for the relying party for consistency across chapters, but  a relying party could be another identity provider in more advanced  use cases.   Client Types The OIDC specification references the public and confidential application types  as described in the previous chapter as well as native applications, defined in the “OAuth  2.0 for Native Apps”ii best current practice document as applications installed on, and  run natively on, a user’s device.   Tokens and Authorization Code OIDC uses the authorization code, access token, and refresh token as described in the  previous chapter for OAuth 2.0 and defines an ID Token.      ID Token – A token used to convey claims about an authentication  event and an authenticated user to a relying party  application .  79    OpenID COnneCt  Chapter 6   Endpoints OIDC utilizes the authorization and token endpoints described in the previous chapter  for OAuth 2.0 and adds the UserInfo endpoint.     UserInfo Endpoint – Returns claims about an authenticated user.   Calling the endpoint requires an access token, and the claims  returned are governed by the access token.   ID Token An ID Token is a security token used by an OpenID Provider to convey claims to an  application about an authentication event and authenticated user. ID Tokens are  encoded in JSON Web Token  JWT iii format. Figure 6-2 shows a sample ID Token.  Courtesy of jwt.io  Header  algorithm and type of token  {“alg” : “RS256” , “Typ” : “JWT” }  JWT  Payload  claims  {  “iss”: “http:  openidprovider.com”, "sub": "1234567890", “aud” : “2fb3JsPMrDnQkwLEVNMDzUF”, “nonce”:”47jglw0hmxo2hg0ewhg9582lf”, “exp”: 1516239322, "iat": 1516239022, "name": ”Fred Doe", "admin": true, “auth_time”:1516239021, “acr”:”1”, “amr” : “pwd”  }  Signature  Figure 6-2.  Sample ID Token  80   Chapter 6    OpenID COnneCt  The JWT format is designed to convey claims between two parties. As a JWT, an  ID Token consists of a header, a payload, and a signature. The header section of the  ID Token contains information on the type of object  JWT  and the specific signature  algorithm used to protect the integrity of the claims in the payload. Common signature  algorithms are HS256  HMAC with SHA256  or RS256  RSA Signature with SHA256 .  The payload section contains the claims about a user and the authentication event. The  signature section contains a digital signature based on the payload section of the ID  Token and a secret key known to the OpenID Provider.  The OpenID Provider signs the JWT in accordance with the JSON Web Signature   JWS  specification.iv A relying party application can validate the signature on the ID  Token to check the integrity of the claims in it. For confidentiality, the OpenID Provider  can optionally encrypt the JWT using JSON Web Encryption  JWE v after it is signed. If  this is done, it produces a nested JWT.  The name:value pairs in the payload section of the ID Token JWT are the claims   about an authenticated user and authentication event. The OIDC specification  Section  2  defines a set of claims for ID Tokens applicable to all types of OIDC authentication  requests,vi shown in Table 6-1.  Table 6-1.  OIDC Claims in ID Tokens for All OIDC Flows  Claim  Meaning  iss  sub  aud  exp  Issuer of the ID token, identified in UrL format. the issuer is typically the OpenID  provider. the “iss” claim should not include UrL query or fragment components.  Unique  within the OpenID provider , case-sensitive string identifier for the  authenticated user or subject entity, no more than 255 aSCII characters long. the  identifier in the sub claim should never be reassigned to a new user or entity.  Client ID of the relying party  application  for which the ID token is intended. May be a  single, case-sensitive string or an array of the same if there are multiple audiences.  expiration time for the ID token, specified as the number of seconds since January 1st,  1970, 00:00:00 UtC to the time of token expiration. applications must consider an ID  token invalid after this time, with a few minutes of tolerance allowed for clock skew.   continued   81   Chapter 6    OpenID COnneCt  Table 6-1.   continued   Claim  Meaning  iat  time at which the ID token was issued, specified as the number of seconds since  January 1st, 1970, 00:00:00 UtC to the time of ID token issuance.  auth_time  time at which the user was authenticated, specified as the number of seconds since  January 1st, 1970, 00:00:00 UtC to the time of authentication.  nonce  Unguessable, case-sensitive string value passed in authentication request from the  relying party and added by an OpenID provider to an ID token to link the ID token to a  relying party application session and to facilitate detection of replayed ID tokens.  String containing an authentication method reference – used to indicate the method s  of  authentication used to authenticate the subject of the ID token. the authentication Method  reference Values specificationvii defines a set of initial standard values for this claim.  String containing an authentication context class reference – used to indicate  authentication context class for the authentication mechanism used to authenticate  the subject of the ID token. Values may be decided by OpenID provider or agreed upon  between relying party and OpenID provider and might use standards such as the draft  OpenID Connect extended authentication profile aCr values.viii  Client ID of the authorized party to which the ID_token is issued. typically not used  unless the ID token only has a single audience in the “aud” claim and that audience  is different from the authorized party, though it can be used even if the audience and  authorized party are the same.  An ID Token can contain additional claims beyond those listed in Table 6-1.   Examples of additional standard claimsix which may be added are the user’s name,  given_name, family_name, email, email_verified, locale, and picture. A list of additional  standard claims can be found in Section 5.1 of the OIDC core specification.x Specific  types of OIDC requests  flows  may involve additional claims. Custom claims can also be  defined and added by an OpenID Provider.   How It Works OIDC defines three different flows by which an application can interact with an OpenID  Provider to make an authentication request.  amr  acr  azp  82   Chapter 6    OpenID COnneCt   OIDC Flows The OIDC flows are designed around the constraints of different types of applications  and bear some similarity to the grant types defined in OAuth 2.0. The original OIDC core  specification defines the following flows:     Authorization Code Flow      Implicit Flow     Hybrid Flow  The following sections cover each of these flows in more detail.   OIDC Authorization Code Flow The OIDC Authorization Code Flow is similar to the OAuth 2.0 authorization code grant  in relying upon two requests and an intermediary authorization code. To authenticate  a user, an application redirects the user’s browser to an OpenID Provider. The OpenID  Provider authenticates the user and redirects the user’s browser back to the application  with an authorization code. The application uses the authorization code to obtain an ID  Token, access token, and optionally a refresh token, from the OpenID Provider’s token  endpoint. Figure 6-3 depicts this flow, assuming the application requested all three  security tokens and the user had no existing login session. This diagram also shows the  use of PKCE, as explained in Chapter 5.  Figure 6-3.  OIDC Authorization Code Flow  83   Chapter 6    OpenID COnneCt    1.  User accesses application  relying party .    2.  User’s browser redirected to OpenID Provider with an   authentication request.    3.  OpenID Provider interacts with the user for authentication and to   obtain consent for scope of user info request.    4.  User authenticates and gives consent and the OpenID Provider   creates or updates an authentication session for the user.    5.  User’s browser redirected back to application with authorization code.    6.  The application sends token request to OpenID Provider, with the   authorization code.    7.  The OpenID Provider responds with an ID Token, access token   and optionally a refresh token.    8.  The application can use the access token at the OpenID Provider’s   UserInfo endpoint, described later in this chapter.  The second call to the token endpoint to obtain the security tokens assumes the  application has the ability to authenticate itself to the OpenID Provider. Public client  applications that cannot securely maintain a secret for such authentication can use  Proof Key for Code Exchange  PKCE  as described in the previous chapter. The use of  PKCE is designed to mitigate the risk of an authorization code being intercepted by an  unauthorized party. The following sample requests assume the use of PKCE.   Authentication Request  An application redirects the user’s browser with an authentication request to the OpenID  Provider’s authorization endpoint such as:  GET  authorize?  response_type=code & client_id=  & state=  & nonce=  & scope=  & redirect_uri=  & code_challenge=   84   Chapter 6    OpenID COnneCt  & code_challenge_method=  HTTP 1.1 Host: authorizationserver.com   The parameters used in the example are described in Table 6-2, but may vary by   individual OpenID Provider.  Table 6-2.  OIDC Authentication Request Parameters  Meaning  Parameter  response_type  response_mode  the response type indicates which OIDC flow to use. “code” indicates  that the authorization Code Flow should be used.  an optional parameter used to request a non-default mechanism to be  used by authorization server to deliver response parameters to the client  application.  the client ID for the relying party application, obtained when it  registered with the OpenID provider  authorization server .  an unguessable value passed to the OpenID provider in the request. the  OpenID provider is supposed to return the exact same state parameter  and value in a success response. Used by the relying party application to  validate the response corresponds to a request it sent previously. this helps  protect against token injection and CSrF  Cross-Site request Forgery .  an unguessable value passed to the OpenID provider in the request  and returned unmodified as a claim in the ID token if an ID token is  requested. Used to protect against token replay.  a string specifying the claims requested about the authenticated user.  example scope: “openid%20profile%20email”  UrI where the OpenID provider directs the response upon completion of  the authentication request. example: “https%3a%2F%2Fclient%2eexam ple%2ecom%2Fcallback”  pKCe code challenge derived from the pKCe code verifier using the code  challenge method specified in the code_challenge_method parameter,  as described in Section 4.2 of the pKCe specification.xi  client_id  state  nonce  scope  redirect_uri  code_challenge  code_challenge_method  “S256” or “plain.” applications capable of using S256  Sha256 hash   must use it.  85   Chapter 6    OpenID COnneCt  The response_type parameter in the authentication request is used to indicate the   desired OIDC flow. The optional response_mode parameter governs the method by  which the response parameters are returned to the application. Unless otherwise noted,  the examples in this chapter do not include response_mode as they assume the use of  the default response mode for each flow, which returns the authorization code  and  or security tokens, depending on the response_type  using a query parameter or hash  fragment to the redirect_uri specified in the authentication request.  The scope parameter in OAuth 2.0 is used to request API privileges to be granted  via an access token. With OIDC authentication requests, the scope is used to indicate  the use of OIDC and request particular claims about the authenticated user. OIDC  authentication requests must include the “openid” scope value. Adding “profile” to the  scope value requests a set of default user profile claims such as name, family name, and  given name. Adding “email” requests the user’s email address and whether that address  has been validated. When the response_type results in the issuance of an access token,  the scope applies to the claims returned by the OpenID Provider’s UserInfo endpoint.  If an access token is not issued, the requested claims will be included in the ID Token.  Additional details on requesting claims can be found in Sections 5.4 and 5.5 of the  OpenID Connect Core specification.xii  Another optional parameter, called “nonce,” is important to mention. The nonce  value should be included if an ID Token is requested. When an application makes an  authentication request to an OpenID Provider, it should specify a unique, non-guessable  nonce value that is tied to the session an application has started for the user. One option  is to generate a random value, store it securely in the user session, and use its hash as the  nonce. When the application receives an ID Token, it must check that the token contains  the exact nonce value specified in the authentication request and that the nonce  matches the hash of the value previously stored in the session. This links an ID Token  with a user’s application session and mitigates the risk of ID Tokens being replayed.  There are several additional, optional parameters which may be passed in an   authentication request to govern how and whether an OpenID Provider prompts a user  to authenticate and provide consent, to specify preferred language s , to pass hints about  a user’s session or identifier, or to request specific user claims. See Section 3.1.2.1 of the  OpenID Core specificationxiii for further information.  86   Chapter 6    OpenID COnneCt   Authentication Response  The OpenID Provider returns a response to the redirect URI specified in the  authentication request and which must be registered with the OpenID Provider. For  the authorization code flow, the default response mode returns the authorization code  using a query parameter to the redirect URI  callback  specified in the authentication  request. It also returns the exact state value that was passed in the authentication request.   HTTP 1.1 302 Found Location: https:  clientapplication.com callback? code=  & state=   The application should check to see if the response contains any error codes and if the   state value returned with a response matches the state value it sent in its authentication  request. It can then use the authorization code to make a token request. An application  should take care to only use each authorization code once as the server is obligated to  respond with an error if an authorization code has already been used.  Token Request  The authorization code returned by an OpenID Provider is used by an application in a  token request to the OpenID Provider’s token endpoint. The following sample request  assumes a confidential client application that was registered at the OpenID Provider to  authenticate with a client secret and HTTP Basic authentication.   POST  token HTTP 1.1 Host: authorizationserver.com Content-Type: application x-www-form-urlencoded Authorization: Basic     grant_type=authorization_code & code=  & redirect_uri=  & code_verifier=   The registration for an application at an OpenID Provider may specify one of   several authentication methods to be used with token requests. Further information  on the defined authentication methods can be found in Section 9 of the OIDC Core  specification.xiv The parameters for the sample token request are shown in Table 6-3.  87   Chapter 6    OpenID COnneCt  Parameter  Meaning  Table 6-3.  OIDC Parameters for Sample Token Request  grant_type  “authorization_code” is used when exchanging an authorization code for tokens.  code  the authorization code received in response to the authentication request.  redirect_uri  Callback location at application for OpenID provider’s response from this call.  code_verifier  the pKCe code verifier value from which the code challenge in the authentication  request was derived. It should be an unguessable, cryptographically random string  between 43 and 128 characters in length, inclusive, using the characters a–Z, a–z,  0–9, “-”, “.”, “_”, and “~” and formed as described in Section 4.1 of the pKCe  specification.xv  The OpenID Provider will respond with the requested tokens in JSON format. The   following shows a sample response:  HTTP  1.1 200 OK Content-Type: application json;charset=UTF-8      Cache-Control: no-store      Pragma: no-cache {      "id_token" :  ,      "access_token" :  ,      "refresh_token" :  ,      "token_type" : "Bearer",      "expires_in" :   }  The sample response elements are described in Table 6-4.  88   Chapter 6    OpenID COnneCt  Table 6-4.  Response Elements for Token Requests  Parameter  Meaning  id_token  the ID token with user claims.  access_token  the access token for the OpenID provider’s UserInfo endpoint.  refresh_token  a refresh token, if a refresh token was requested or is returned by default.  token type  Bearer is typically used unless an OpenID provider has documented   another type.  expires_in  the lifetime of the access token, in seconds.  Before relying on claims in an ID Token, an application should validate the ID Token  following guidance provided by the issuing OpenID Provider and the validation steps in  the JWT specification.xvi The application can obtain claims about the authenticated user  from the ID Token or by using the access token to call the OpenID Provider’s UserInfo  endpoint.   OIDC Implicit Flow The implicit flow in OIDC has similarities to the OAuth 2.0 grant type of the same name.  As explained in Chapter 5, the use of the OAuth 2.0 implicit grant to obtain an access  token, at least with default response mode, is not recommended. However, that guidance  is based on the risk of exposing an access token in a URL fragment which can be leaked  via the browser history or referer header. An application that only needs to authenticate  users and can obtain user information via an ID Token does not need an access token.  In this case, the Implicit Flow may be acceptable. Figure 6-4 shows this flow with the  application receiving only an ID Token.  89   Chapter 6    OpenID COnneCt  Figure 6-4.  OIDC Implicit Flow    1.  User accesses the application  relying party .    2.  User’s browser redirected to OpenID Provider with authentication   request.    3.  OpenID Provider interacts with the user for authentication and to   obtain consent for scope of user info request.    4.  User provides login credentials and consent and the OpenID   Provider creates or updates an authentication session for the user.    5.  User’s browser redirected back to application with an ID Token.    6.  Application obtains user claims from ID Token and displays   suitable application content to the user.  An authentication request to authenticate a user with the Implicit Flow, and request   only an ID Token, will look similar to the following:  GET  authorize?  response_type=id_token & client_id=  & state=   90   Chapter 6    OpenID COnneCt  & nonce=  & scope=  & redirect_uri=  HTTP 1.1  Host: authorizationserver.com   The parameters used in the Implicit Flow authentication request have the same  definition as shown in Table 6-2, with the exception of response_type values. For the  Implicit Flow, the allowed response_type values are          “id_token” – Response contains only an ID Token.  “id_token token” – Response contains an ID Token and access token.  By default, the Implicit Flow returns all tokens via front-channel browser interaction  to the redirect URI, using a URL fragment. The use of “id_token token” response_type is  not recommended with the default response mode as it would expose an access token  to potential compromise through a referer header or the browser’s history.1 Using the  Implicit Flow with the default response mode and “id_token” response_type to return  only an ID Token avoids this risk, assuming the ID Token does not contain sensitive data.  The use of the non-default form_post response mode for applications needing only an  ID Token should be considered as the response parameters are encoded in the body of a  post response. This avoids exposing the ID Token and data in it via a URL fragment, but  this response mode may not be feasible for some applications. Public clients needing  an access token and or ID Token with sensitive elements should consider using the  Authorization Code Flow with PKCE instead.   Response  The following shows a sample response to an Implicit Flow authentication request that  used “id_token” response type to request only an ID Token. This approach can be used if  the claims in the ID Token do not contain sensitive data.  HTTP 1.1 302 Found Location: https:  clientapplication.com callback  id_token=  & state =    1 https:  tools.ietf.org html draft-ietf-oauth-security-topics-13section-3.1.2  91    OpenID COnneCt Chapter 6   OIDC Hybrid Flow The OIDC Hybrid Flow includes elements of both the Authorization Code Flow and  Implicit Flow. It is designed for applications with both a secure back end and a front  end with client-side JavaScript executing in a browser. The Hybrid Flow enables models  such as returning an ID Token and authorization code in a front-channel response to the  application front end, leaving the application back end to obtain an access token  and  optional refresh token  from the token endpoint using the authorization code. This flow  is shown in Figure 6-5.  Figure 6-5.  OIDC Hybrid Flow    1.  User accesses the application  relying party .    2.  User’s browser redirected to the OpenID Provider with   authentication request.    3.  OpenID Provider interacts with user for authentication and to   obtain consent for scope of user info request.  92   Chapter 6    OpenID COnneCt    4.  User authenticates and provides consent and the OpenID   Provider creates or updates an authentication session for the user.    5.  User’s browser redirected back to application front end with an   authorization code and ID Token.    6.  Client application validates ID Token, and if valid, back end calls  token endpoint with authorization code to get additional tokens.    7.  OpenID Provider token endpoint returns requested tokens.    8.  Client application can call OpenID Provider’s UserInfo endpoint   with access token.  The parameters for the authentication request are as defined in Table 6-2 with the   exception that the response_type for the Hybrid Flow uses three different values to govern  which tokens are returned in the response from the OpenID Provider’s authorization  endpoint. Additional tokens can be requested via the subsequent token request to the  token endpoint. Table 6-5 summarizes the possible values for response_type.  Table 6-5.  OIDC Hybrid Flow Response Types  response_type  Returned from Authorization Endpoint  “code id_token”  authorization code, id_token  “code token”  authorization code, access token – nOt recommended with default  response_mode  “code id_token token”  authorization code, id_token, access token – nOt recommended with  default response_mode  The response_types which return an access token via front-channel response from   the authorization endpoint, namely, “code token” and “code id_token token”, are not  recommended for use with the default response mode as the access token would be  exposed as a URL fragment in the browser and possibly leaked via referer headers or   93   Chapter 6    OpenID COnneCt  browser history.2 If the default response mode is used, the “code id_token” response_ type should be used to return only the ID Token and authorization code using a front- channel response to the browser. An access token, and optional refresh token, can  then be obtained from the OpenID Provider’s token endpoint via secure back-channel  interaction from the application’s back end. In practice, the hybrid flow is not widely  used. Using this flow requires an implementation that will provide both the front end  and back end information, such as nonce and state, with which to validate any responses  and security tokens they receive as well as prevent attacks such as CSRF or token  injection. Applications should consider using the Authorization Code Flow with PKCE  unless they have a specific use case that requires the hybrid flow.   A sample authentication request using the Hybrid Flow and “code id_token”   response type and default response mode is shown in the following example, with  parameter definitions similar to previous examples.  GET  authorize?   response_type=code%20id_token &client_id=  &redirect_uri=  &scope=  &state=  &nonce=  HTTP 1.1  Host: authorizationserver.com   When the application receives the response, the application back end can use the   authorization code at the OpenID Provider’s token endpoint as described in the previous  section for Authorization Code Flow.   UserInfo Endpoint An application can retrieve claims about a user from the OpenID Provider’s UserInfo  endpoint. The UserInfo endpoint, is an OAuth2.0 API endpoint, and to call it requires  an access token issued by the OpenID Provider. When requesting the access token, an  application uses the scope parameter to indicate the desired claims about the user. The   2 https:  tools.ietf.org html draft-ietf-oauth-security-topics-13section-3.1.2  94   Chapter 6    OpenID COnneCt  OpenID Provider authenticates the user and obtains their consent for the requested claims  and then issues the access token with the authorized scope for the claims to the application.  The application then uses the access token to request the claims from the UserInfo  endpoint. A sample application request to the UserInfo endpoint looks like the following:  GET  userinfo HTTP 1.1 Host: authorizationserver.com Authorization: Bearer    The OpenID Provider’s UserInfo endpoint response returns claims with a JSON   object  unless signed or encrypted responses are used . The following sample response  assumes the requested scope was "openid profile email".   HTTP 1.1 200 OK Content-Type: application json {    "sub": "1234567",    "name": "Fred Smith",    "given_name": "Fred",    "family_name": "Smith",    "preferred_username": "fred.smith",    "email": "fred.smith@example.com",     "email_verified": true,     "picture":"https:  example.com fred.smith fred.smith.jpg",   }  An application should perform any validation on responses recommended by its   specific OpenID Provider.  The UserInfo endpoint is primarily useful if the desired user profile claims are too   large for an ID Token returned via a URL fragment.    Summary The OpenID Connect protocol provides an identity layer on top of OAuth 2.0 that  supports authenticating users to applications and enables single sign-on. Adding to  OAuth 2.0, OIDC adds an ID Token and a UserInfo endpoint, which return claims  about an authentication event and the authenticated user to the application. Using   95   Chapter 6    OpenID COnneCt  OIDC allows applications to delegate user authentication to an OpenID Provider and  using OIDC and OAuth 2.0 together solves both authentication and API authorization.  However, even if you have both those bases covered, you may encounter customers that  ask you to support SAML 2.0, so we’ll cover an overview of that in the next chapter.   Key Points  users.     OIDC provides an identity layer on top of OAuth 2.0 to authenticate      OIDC enables single sign-on.     OIDC provides an ID Token and UserInfo endpoint to obtain user   profile info.  user.     OIDC defines a set of standard claims that can be obtained about a      OIDC allows for the use of additional, custom claims.     OIDC defines three grant flows for different client profiles.     OIDC provides several options for returning an authorization code  and or security tokens via front-channel or back-channel response.     Returning access tokens or refresh tokens via front-channel   responses should be avoided by using a back-channel response or  alternate response mode.     Returning sensitive information in ID Tokens via front-channel   responses should be avoided by using a back-channel response or  the UserInfo endpoint or encrypting the ID Token if encryption is  supported.   Notes        96  i.  https:  openid.net connect   ii.  https:  tools.ietf.org html rfc8252    iii.  https:  tools.ietf.org html rfc7519   Chapter 6    OpenID COnneCt     iv.  https:  tools.ietf.org html rfc7515    v.  https:  tools.ietf.org html rfc7516    vi.  https:  openid.net specs openid-connect-core-1_0.    vii.  https:  tools.ietf.org html draft-ietf-oauth-amr-   viii.  https:  openid.net specs openid-connect-eap-acr-    ix.  https:  openid.net specs openid-connect-core-1_0.    x.  https:  openid.net specs openid-connect-core-1_0.    xi.  https:  tools.ietf.org html rfc7636    xii.  https:  openid.net specs openid-connect-core-1_0.   xiii.  https:  openid.net specs openid-connect-core-1_0.  htmlIDToken  values-04  values-1_0.html  htmlStandardClaims  htmlStandardClaims  htmlScopeClaims  htmlAuthRequest  ientAuthentication    xv.  https:  tools.ietf.org html rfc7636   xvi.  https:  tools.ietf.org html rfc7519section-7.2    xiv.  https:  openid.net specs openid-connect-core-1_0.htmlCl  97   CHAPTER 7  SAML 2.0  To be trusted is a greater compliment than to be loved.  —George MacDonald, from The Marquis of Lossie  1877   The Security Assertion Markup Language  SAML  2.0i is known for providing two  important features, cross-domain single sign-on  SSO  and identity federation. SAML 2.0  has been adopted in many enterprise environments because it enabled the enterprise  to have applications used by employees, customers, and partners delegate user  authentication to a centralized enterprise identity provider. This gave the enterprise a  central place to manage and control identities. If you are writing an application for large  enterprise customers, they may expect you to support authentication using SAML 2.0.  In this chapter, we’ll provide an overview of SAML 2.0, the problem it is designed to  solve, and the cross-domain single sign-on and identity federation features in SAML 2.0.  We’ll also provide a suggestion for how to leverage newer protocols like OIDC and still  efficiently implement support for SAML.1   Problem to Solve The most common use case for which SAML is used is cross-domain single sign-  on, in our experience. In this scenario, a user needs to access multiple applications  which reside in different domains, such as application1.com and application2.com.  Without cross-domain single sign-on, a user might have to establish an account in each  application and log in to each application individually. This means potentially many  different usernames and passwords for a user to remember. If the user is a corporate   1 All unqualified uses of the term “SAML” refer to SAML 2.0.    Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2_7  99   Chapter 7    SaML 2.0  employee and the applications are SaaS applications, it would be difficult for the  enterprise to manage all the SaaS application accounts their employees might create. SAML was designed as an “XML-based framework for describing and exchanging  security information between on-line business partners.”ii SAML enables applications  to delegate user authentication to a remote entity known as an identity provider. The  identity provider authenticates the user and returns to the application an assertion with  information about the authenticated user and authentication event. If the user accesses  a second application which delegates authentication to the same identity provider, the  user will be able to access the second application without being prompted again to log  in. This capability is single sign-on.  SAML also provides a mechanism for an application and identity provider to use a  common shared identifier for a user in order to exchange information about the user.  This is known as federated identity. The federated identity can use the same identifier  across systems or it can use an opaque, internal identifier which is mapped to the  identifier used by the user in each system. We’ll see more about how these features work  in the following sections, but first, we need to specify some terms we’ll use.   Terminology The SAML specifications define the following terms:     Subject – An entity about which security information will be   exchanged. A subject usually refers to a person, but can be any entity  capable of authentication, including a software program. For the use  cases we’ll discuss, the subject is generally a user of an application.      SAML Assertion – An XML-based message that contains security   information about a subject.     SAML Profile – A specification that defines how to use SAML   messages for a business use case such as cross-domain single  sign- on.      Identity Provider – A role defined for the SAML cross-domain single  sign-on profile. An identity provider is a server which issues SAML  assertions about an authenticated subject, in the context of cross-  domain single sign-on.  100   Chapter 7    SaML 2.0     Service Provider – Another role defined for the SAML cross-domain  single sign-on profile. A service provider delegates authentication to  an identity provider and relies on information about an authenticated  subject in a SAML assertion issued by an identity provider in the  context of cross-domain single sign-on.     Trust Relationship – An agreement between a SAML service   provider and a SAML identity provider whereby the service provider  trusts assertions issued by the identity provider.     SAML Protocol Binding – A description of how SAML message   elements are mapped onto standard communication protocols, such  as HTTP, for transmission between service providers and identity  providers. In practice, SAML request and response messages are  typically sent over HTTPS using either HTTP-Redirect or HTTP-POST,  using the HTTP-Redirect and HTTP-POST bindings, respectively.   How It Works The most common SAML scenario is cross-domain web single sign-on. In this scenario,  the subject is a user that wishes to use an application. The application acts as a SAML  service provider. The application delegates user authentication to a SAML identity  provider that may be in a different security domain. The identity provider authenticates  a user and returns a security token, known as a SAML assertion, to the application. A  SAML assertion provides information on the authentication event and the authenticated  subject. We will use the term application along with service provider, for consistency  across chapters, but should note that an entity acting as an identity provider can also act  as a service provider by further delegating authentication to another identity provider. To establish the ability to do cross-domain web single sign-on, the organizations   owning the service provider  application  and identity provider exchange information,  known as metadata. The metadata information contains information such as URL  endpoints and certificates with which to validate digitally signed messages. This  data enables the two parties to exchange messages. The metadata is used to configure  and set up a trust relationship between the service provider and the identity provider  and must be done before the identity provider can authenticate users for the service  provider  application .  101   Chapter 7    SaML 2.0  Once mutual configuration of providers is in place, when a user accesses the service   provider  application , it redirects the user’s browser over to the identity provider  with a SAML authentication request message. The identity provider authenticates the  user and redirects them back to the application with a SAML authentication response  message. The response contains a SAML assertion with information about the user and  authentication event, or an error, if an error condition occurred. The identity provider  can tailor the identity claims in the assertion as needed for each service provider. Please  see Appendix C for a sample of SAML authentication request and response messages  and a description of commonly used elements within each.   SP-Initiated SSO The simplest form of cross-domain single sign-on is illustrated in Figure 7-1. In this  example, the user starts at the service provider  SP   application  so it is known as  the “SP-initiated” flow.  The diagram depicts a scenario where the user does not  have an existing authentication session at the identity provider and therefore has to  authenticate.   Figure 7-1.  SAML SP-Initiated Single Sign-On    1.  User visits a service provider  application .    2.  Service provider redirects user’s browser to the identity provider   with a SAML authentication request.    3.   Identity provider interacts with user for authentication.  102   Chapter 7    SaML 2.0    4.  User authenticates. Identity provider validates credentials.    5.   Identity provider redirects user’s browser back to the service  provider with a SAML response containing a SAML authentication  assertion. The response is sent to the service provider’s Assertion  Consumer Service  ACS  URL.    6.  The service provider consumes and validates the SAML response  and responds to the user’s original request  assuming the user was  successfully authenticated and has sufficient privileges for the request .   Single Sign-On Figure 7-1 shows the user accessing a single application. Multiple service providers can  choose to delegate user authentication to the same identity provider. When this occurs,  a user can access a first application and authenticate to the identity provider to establish  an authentication session there, as shown in Figure 7-1. The user can then use the same  browser to access a second application which relies on the same identity provider, and  when redirected to the identity provider, the identity provider will recognize the user  already has a session and won’t ask them to authenticate again. The identity provider  will simply redirect the user’s browser back to the application with a successful SAML  authentication response. This is called single sign-on, and it will be covered in more  detail in Chapter 11.   IdP-Initiated Flow Figure 7-1 showed an interaction sequence with the user starting at the service provider   application . This is called “SP-initiated” because the user initiates the interaction at  the service provider  SP . SAML also defined another flow, known as “IdP-initiated,”  where the user starts at the identity provider  IdP , and which is shown in Figure 7-2. In  this case, the identity provider redirects the user’s browser to the service provider with  a SAML response message without the service provider having sent any authentication  request. This flow is found in some enterprise environments where a user accesses  applications via a corporate portal.  When the user initially accesses the corporate portal, they are redirected to the   corporate identity provider to log in. After logging in, the user is returned to the portal   103   Chapter 7    SaML 2.0  and sees a menu of application links on the portal. Clicking one of these links redirects  the user to the identity provider, with the application URL as a parameter. The identity  provider detects the user already has an authenticated session and redirects the user’s  browser to the application, with a SAML response message as in the SP-initiated case.  The IdP-initiated flow does not require a portal, but we’ve chosen to show it as it is a  common way this flow is used.  The IdP-initiated flow with a portal is useful in enterprises because it provides single  sign-on and ensures users go to the correct URL for each application which reduces the  risk of users being phished. The IdP-initiated flow is shown in Figure 7-2.  This diagram  assumes the user does not have an existing authentication session.   Figure 7-2.  SAML IdP-Initiated Single Sign-On    1.  User visits a corporate portal.    2.  Portal redirects user’s browser to the identity provider with a   SAML authentication request.    3.   Identity provider interacts with user for authentication.    4.  User authenticates. Identity provider validates credentials.  104   Chapter 7    SaML 2.0    5.   Identity provider redirects user’s browser back to portal with  a SAML response for the portal  response 1  containing an  authentication assertion. User is logged into portal which displays  content to user, including a list of applications.    6.  The user clicks a link in the portal for an application. The link   directs the user’s browser to the identity provider with a parameter  indicating the desired service provider application. The IdP checks  the user’s session. This diagram assumes the user’s session is still  valid.    7.  The identity provider redirects the user’s browser to the service   provider’s Assertion Consumer Service  ACS  URL, with a new SAML  response  response 2  for that service provider  the application .    8.  The service provider  application  consumes the SAML response and  authentication assertion and renders an appropriate page for the user,  assuming their identity and privileges are sufficient for their request.   Identity Federation With SAML, identity federation establishes an agreed-upon identifier used between a  service provider  application  and an identity provider to refer to a subject  user . This  enables a service provider to delegate authentication of the user to an identity provider  and receive back an authentication assertion with identity claims that include an  identifier for the authenticated subject that will be recognizable by the service provider.  Figure 7-3 illustrates an example. A user named Ann Smith has an account in two  applications, application1 hosted at app1.com and application2 hosted at app2.com.   In application1, her account identifier is ann@corp.com, and in application2, her account  identifier is “ann”. Ann also has an account at a corporate identity provider where her  account identifier is ann@corp.com.  The administrators for application1 and the identity provider exchange metadata   about their environments and use it to set up federation information between  application1 and the identity provider. The same is done by the administrators of  application2 and the identity provider. In practice, the administrators of an identity  provider configure it to send assertions to each service provider that contain appropriate  identifiers and attributes for the service provider  application .  105   Chapter 7    SaML 2.0  Figure 7-3.  Identity Federation  When Ann accesses application1, it redirects her browser to her employer’s identity   provider at “corp.com”. The identity provider authenticates Ann and redirects her  browser back to application1 with an authentication assertion containing a naming  attribute identifying her as ann@corp.com. Application1 uses the same identifier for Ann,  so it recognizes her based on that identity.  When Ann accesses application2, it redirects her browser to the identity provider which  recognizes that she already has a session. If the identity provider returns an authentication  assertion identifying her as ann@corp.com, however, application2 will not recognize her as a  valid user by that name. The identity provider needs to return an appropriate identifier for  each service provider. In this case, when the identity provider delivers the authentication  assertion to application2, it needs to identify the subject of the assertion using “ann”. The link between an identity at a service provider and an identity provider can   be set up in different ways. In practice, a user’s email address is often used as the  identifier for a user at both the service provider and identity provider, but this can  be problematic as a user may need to change their email address, and it can conflict  with privacy requirements. The use of a specific identifier attribute can be requested  dynamically in a request, or an identity provider can be configured to send a particular  identifier to a service provider. It is also possible for an identity provider and service  provider to exchange information using an opaque, internal identifier for a user, that is  mapped on each side to the user’s profile. Use of a unique identifier for each federation  is privacy-friendly and prevents correlation of user activity, but isn’t common in   106   Chapter 7    SaML 2.0  practice. The approach to use is set up when the two parties exchange metadata and  configure their infrastructure to establish the relationship  often called a federation in  practice  between service provider and identity provider.   Authentication Brokers Authentication brokers can be used by applications to easily enable support for multiple  authentication protocols and mechanisms. If you are building a new application and plan  to use OIDC for authentication, you may receive requests to support SAML from business  customers who want their users authenticated at their corporate SAML identity provider.  SAML is a complex protocol, which would require significant work to implement and  support across many customers. Rather than implement SAML directly in your application  yourself, you can use an authentication broker to simplify the task of supporting SAML.2  An authentication broker allows your application to implement a newer identity protocol  like OIDC and rely on the authentication broker to communicate via different protocols to  a variety of identity providers. Figure 7-4 depicts an application implemented to use OIDC  and OAuth 2.0 with an authentication broker which communicates in turn with several  identity providers, each of which uses a different protocol. The use of an authentication  broker allows an application team to implement newer identity protocols in their  application and focus on the core features of their application instead of spending time  to directly implement and support older identity protocols requested by customers.  Figure 7-4.  Benefits of an Authentication Broker  2 Full disclosure: At the time of writing, the authors of this book worked for Auth0, a vendor of an  authentication broker service.  107   Chapter 7    SaML 2.0  If you elect not to use an authentication broker, we recommend at least using a  SAML library rather than attempting to implement SAML yourself as it is a complex  protocol to implement.    Configuration Whether you use an authentication broker or a library, Tables 7-1 and 7-2 show the  elements that typically need to be configured at the service provider  application  and  identity provider and their meaning.  Table 7-1.  Common Service Provider Configuration  Description  Single sign-on UrL of identity provider. this is where the service provider  will send its authentication requests.  Certificate s  from identity provider. Used to validate signatures on SaML  responses assertions from identity provider. also used if server provider  sends encrypted requests. Some providers allow different certificates for  the two uses.  protocol binding to use when sending requests. http-redirect for simple  requests or http-pOSt if requests are signed, which is recommended.  Whether to digitally sign SaML authentication requests and, if so, via which  signature algorithm. Signing is recommended.  request encryption  Whether to digitally encrypt a SaML authentication request.  Element  SSO UrL  Certificate  protocol binding  request signing  108   Chapter 7    SaML 2.0  Table 7-2.  Common Identity Provider Configuration  Description  Element  aCS UrL  Certificate  protocol binding  response signing  assertionConsumerService UrL of service provider. this is where it will  receive SaML authentication responses from identity provider.  Certificate s  from service provider. Used to validate signatures on SaML  requests. also needed if responses are to be encrypted. Some providers  allow different certificates for the two uses.  protocol binding to use when sending response. http-pOSt is typcally  required to accommodate signed messages.  Whether to digitally sign the SaML authentication response, the assertion,  or both and, if so, via which signature algorithm. Signing is mandatory.   response encryption Whether to digitally encrypt a SaML response.  You’ll need to consult the documentation for the authentication broker or SAML   library you’ve chosen for the specific details of where and how to configure the  preceding elements. Once both providers are configured and you have attempted a trial  authentication, it’s common for authentication to fail the first time. You can debug issues by  attempting an authentication, capturing a trace of the SAML request and response message,  and examining them. We’ve provided guidance for how to troubleshoot in Chapter 16 and  details on what to look for in the SAML request and response messages in Appendix C.   Summary SAML 2.0 provides an industry standard solution for web single sign-on and identity  federation. These key features enabled enterprises to use cloud applications and still  maintain centralized control of identities. The use of SAML eliminates exposure of  static password credentials to applications and provides users the convenience of single  sign-on. Many enterprises have implemented SAML identity providers and expect SaaS  application vendors to support it.  At this point, however, SAML is an older protocol compared to OIDC. Now that   OIDC and OAuth 2.0 exist, modern applications designed around APIs will benefit from   109   Chapter 7    SaML 2.0  implementing these newer protocols, as they provide support for both authentication  and API authorization, respectively, and identity providers that support them exist for  both consumer- and corporate-facing scenarios.  If you need to support SAML, rather than implementing it in a new application   yourself, it is more efficient to use an authentication broker service that can take care  of the SAML implementation complexity for you.3 This will enable you to implement  your application with newer protocols, yet still support customers who require older  protocols such as SAML and WS-Fed. Alternatively, you can use a library for your chosen  platform to implement such protocols. Once authentication is solved, authorization and  policy enforcement are needed to govern what a user can do, and that’s coming up in the  very next chapter.   Key Points     SAML is an XML-based framework for exchanging security   information between business partners.     SAML provided two features which became widely used: cross-   domain single sign-on and identity federation.     A SAML service provider delegates user authentication to an identity   provider.     A SAML identity provider authenticates a user and returns the   results of a user authentication event in an XML message called an  authentication response.     An authentication response contains an authentication assertion   with claims about the authentication event and authenticated user.      Identity federation establishes a common identifier for a user  between an identity provider and a service provider.  3 Full disclosure: At the time of writing, the authors of this book worked for Auth0, a vendor of an  authentication broker service.  110   Chapter 7    SaML 2.0     Business customers of applications often want to use their corporate   identity providers to authenticate their users to applications.     New applications should consider using an authentication broker   service or SAML library to simplify the task of supporting SAML.   Notes        i.  https:  wiki.oasis-open.org security FrontPage  ii.  www.oasis-open.org committees download.php 27819 sstc-  saml-tech- overview-2.0-cd-02.pdf  Section 2   111   CHAPTER 8  Authorization and Policy  Enforcement  A people that values its privileges above its principles soon loses both.  —Dwight D. Eisenhower, 34th president of the United States,   from first inaugural address  The previous chapters covered the mechanics of authorizing an API call and  authenticating a user. This chapter will discuss authorization vs. the enforcement of  access policy and how identity protocols can be used to help implement them.   Authorization vs. Policy Enforcement In governing what a user or application can do, there are two distinct functions. We  use the term authorization for the granting of privileges. In contrast, access policy  enforcement is defined as the act of checking that someone has been granted the  necessary privilege before responding to a request for a protected resource. For  example, if you buy a theater ticket, the ticket constitutes your authorization to attend  the performance. On the night of the performance, the ticket taker at the door enforces  policy by checking to ensure that only authorized patrons  with tickets  enter the theater. Authorization may be granted well in advance of a resource being requested or at the  time of requesting access. It may be done by the entity containing the requested resource  or by a trusted third party with the authorization information conveyed securely to the  policy enforcement point. Access policy enforcement is done at the time a resource  request is made and ideally at an enforcement point within or close to the protected  resource to reduce the possibility of it being bypassed.    Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2_8  113    authorization and poliCy enforCement  Chapter 8   Levels of Authorization and Access Policy Enforcement There are different levels at which authorization and access policy enforcement may be  specified and applied, respectively:     Level 1 – Whether an entity can access an application or API at all     Level 2 – What functions an entity can use in an application or API     Level 3 – What data an entity can access or operate on   Level 1 – Application or API Access  At the highest level, authorization and access policy enforcement can control whether an  entity has permission to access an application or API at all. This use case is often found  in corporate settings. For example, an employee in a marketing team probably has no  business accessing the corporate accounting system. This level of policy enforcement  may be handled within an application or by an entity in front of the application as shown  in Figure 8-1. The enforcement can be done external to an application by components  such as an authentication broker or a reverse proxy that works with an identity and  access management  IAM  system. Such systems can act as a high-level enforcement  point to deflect users who are not authorized to access an application at all. A similar  approach can be used with APIs and in both cases is useful to reduce policy enforcement  workload on target systems.    cid:56  cid:86  cid:72  cid:85    cid:37  cid:85  cid:82  cid:90  cid:86  cid:72  cid:85    cid:53  cid:72  cid:89  cid:72  cid:85  cid:86  cid:72  cid:3  cid:51  cid:85  cid:82  cid:91  cid:92  cid:3  cid:90  cid:76  cid:87  cid:75    cid:51  cid:82  cid:79  cid:76  cid:70  cid:92  cid:3  cid:48  cid:68  cid:81  cid:68  cid:74  cid:72  cid:85   Figure 8-1.  Application-Level Access Policy Enforcement   cid:44  cid:36  cid:48  cid:3  cid:54  cid:92  cid:86  cid:87  cid:72  cid:80    cid:36  cid:83  cid:83  cid:79  cid:76  cid:70  cid:68  cid:87  cid:76  cid:82  cid:81  cid:3  cid:6  cid:20  cid:3   cid:11  cid:41  cid:76  cid:81  cid:68  cid:81  cid:70  cid:72  cid:3  cid:54  cid:92  cid:86  cid:87  cid:72  cid:80  cid:12    cid:36  cid:83  cid:83  cid:79  cid:76  cid:70  cid:68  cid:87  cid:76  cid:82  cid:81  cid:3  cid:6  cid:21    cid:11  cid:44  cid:81  cid:89  cid:72  cid:81  cid:87  cid:82  cid:85  cid:92  cid:3  cid:54  cid:92  cid:86  cid:87  cid:72  cid:80  cid:12  cid:3   114   Chapter 8    authorization and poliCy enforCement   Level 2 – Functional Access  Functional-level authorization and access policy enforcement govern what an entity  can do within an application or API. For example, a junior accounting clerk in the  finance department might be able to access the corporate accounting system and enter  individual journal entries but not perform a month-end close. This level of authorization  and access policy enforcement tends to be application specific. It may leverage  information about a user stored elsewhere, such as roles or groups in a directory service,  but is often enforced within an application or API.   Level 3 – Data Access  A third level of authorization and access policy enforcement governs access to particular  subsets of data. If functional-level access policy enforcement defines the functions an  entity can do, data-level access policy further restricts access to specific data. For example,  in a sales order entry application, a user with the role “regional sales manager” may be  authorized at a functional level to view sales orders, but data-level access policy restricts  them to a specific region indicated in their user profile’s “Sales region” attribute. Data-level  access may be enforced within an application or API or in an underlying storage layer.   User vs. Application Authorization We will cover two situations that require authorization and access policy enforcement.  The first governs what a user  or entity  can do in an application, and the second controls  what an application can request of an API.   A user needs authorization to perform various functions within an application. The   application may render the application’s user interface based on a user’s authorized  privileges so it doesn’t display features a user cannot use. In addition, when a user makes  a request, the application back end or API must check that the user has the necessary  authorization for the request before executing it.  An application requires authorization to call a protected API. If the content at the   API is owned by the user of the application, the access requires the user’s authorization.  This scenario is often found in consumer-facing applications. If the content at the API  is accessed by the application on its own behalf, an authorization server grants the  authorization to the application based on permissions previously configured by the  administrator of the authorization server.   115   Chapter 8    authorization and poliCy enforCement  Regardless of the entity being authorized, there are three steps commonly involved   in controlling access:     Authorization and the specification of access policy.      Delivery of authorization information to enforcement point  if   needed      Enforcement of the access policy by the enforcement point  We will discuss these three steps first for users and then applications.   User Authorization The specification of authorization is a complex topic. So many schemes have been  invented for this over the years that covering them is outside the scope of this book.  We will assume that access policy is represented in a set of attributes associated with  a user or application and describe how OIDC and SAML 2.0 can be used to deliver  authorization information about a user to an application and how OAuth 2.0 can be  used to authorize access to APIs and how this supports access policy enforcement. The  attributes used to convey authorization for users can vary, but the most common fall into  two categories.   User Profile Attributes  A user’s identity may be granted authorization based on roles which they’ve been  assigned in a role-based access control  RBAC i model, membership in a group or access  control list  ACL , or individual user profile attributes evaluated by rules as part of an  attribute-based access control  ABAC ii, iii model. These attributes are relatively static  factors that remain the same, regardless of where the user is or what device they are  using at the time of accessing a protected resource.  If such authorization information is specified outside an application, such as in   a corporate directory service or policy service, but accessible by the identity provider  authenticating a user, these attributes can be delivered to the application by the identity  provider. If authorization is specified in the application, the identity provider can deliver  an identifier for the authenticated user to the application so it can retrieve the necessary  authorization information about the user.  116   Chapter 8    authorization and poliCy enforCement  The authorization step to grant a user privileges is typically done in advance of  the user making a request in an application. For example, if a new employee joins  a company’s finance team, the business may authorize the employee to access its  accounting application by assigning the user roles in a corporate identity system on  the new hire’s first day. For a consumer-facing application, a user may be assigned  access- related user profile attributes when they purchase a particular subscription  level for the service.   Transactional User Attributes  Authorization may also be based upon factors that are part of the user’s physical  environment at the time of authentication or accessing a protected resource. Such  factors can include the user’s geographic location, whether the user is inside or outside  a corporate firewall, or whether the user’s device is certified as adhering to certain  security configuration standards. The day of the week or time of day may be factors as  well as the strength of authentication mechanism used. These factors are captured at  the time of authentication rather than being part of the user’s profile. Such factors, if  captured by an identity provider, can also be provided to applications in the form of  claims in a security token.   Delivery For applications using OIDC, user authorization information can be delivered to  applications as claims in an ID Token or in the response from the OIDC provider’s  UserInfo Endpoint. Applications using SAML 2.0 can receive the information via  attribute statements in a SAML 2.0 assertion. User profile information such as a user’s  roles, groups, or a purchased subscription level, and factors such as a user’s IP address  or strength of authentication method, can be delivered to an application in this way.  An application can then use the information to perform access policy enforcement. An  example showing the delivery of user profile information via an ID Token to support  access enforcement is shown in Figure 8-2. In this example, the application is a movie  rental application where users can purchase different subscription levels  such as bronze,  silver, and gold  to get access to different selections of movies. The ID Token delivers to  the application the user’s purchased subscription level.  117   Chapter 8    authorization and poliCy enforCement  Figure 8-2.  Delivering Authorization Attributes to an Application    1.  User redirected to login at the OIDC OpenID Provider.    2.  The ID Token includes the user’s purchased subscription.    3.  Subscription data in ID Token is used to determine the list of   movies displayed.    4.  User selects a movie to view.    5.  Application back end checks the user has required subscription   level for their selected movie.  In the example, the information in the ID Token about a user’s subscription level is  used to display to the user the movies they are entitled to rent. It is also used to perform  access policy enforcement. Even though the front end restricted the list of movies to  what the user can view, a malicious user might find a way to get around this, so the  access policy enforcement check is made in the application back end where it cannot be  circumvented. This example uses OIDC, but applications using SAML 2.0 can follow a  similar model, obtaining authorization data from the SAML 2.0 assertion.  118   Chapter 8    authorization and poliCy enforCement   Enforcement Before relying on any information in a security token, the application must validate the  token. In the case of an ID Token, validation steps include      Validate the ID Token is a correctly formatted JWT  JSON Web Token       Validate the signature on the ID Token     Check that the token has not expired     Check the issuer is the correct OpenID Provider     Check the intended audience for the token is the application  Be sure to check the documentation for your OpenID Provider for the exact  validation steps required for their implementation. Once the ID Token has been  validated, the application can use the claims within the token for access policy  enforcement.   Application Authorization The second case of authorization and policy enforcement is that of applications calling  APIs.   Application Attributes Application requests to call APIs on a user’s behalf are authorized by the user, but  requests to call APIs on their own behalf are authorized by an authorization server based  on configured policy. This policy is typically configured in advance of an application  calling an API. Unless the number of applications or APIs is quite large, the policy  specification is often expressed by indicating the specific applications authorized to call  specific APIs and which endpoints and actions can be accessed. If OAuth 2.0 is used, the  policy may be specified in terms of scopes, such as “get:documents”.  119    authorization and poliCy enforCement  Chapter 8   Authorization An application that makes an OAuth 2.0 request for authorization to call an API specifies  its requested scopes as a parameter to the authorization request. For example, an  application requesting an access token for an OpenID provider’s UserInfo Endpoint to  retrieve user attributes might use “scope = openid profile email”. An application calling a  custom API to retrieve a user’s documents might request a scope of “get:documents”.  With the authorization code and implicit grant types, the requested API resources are  owned by the user, so the OAuth 2.0 authorization server will prompt the user, displaying  the requested scopes, and obtain the user’s consent for the application’s request before  issuing an access token. With the client credentials grant, the requested API resources  are owned by the application, and the privileges granted to each application are  specified in the authorization server  or a policy server accessed from it , and it will use  that information to decide whether a request is allowed before issuing an access token.   Delivery Regardless of whether the protected resource is owned by the user or the application,  if the request is authorized, the authorization server will issue an access token to the  application for the requested API. An authorization server may allow adding additional  custom claims to an access token, such as claims about the user, including data on  privileges such as roles. Additional claims may be useful to an API in enforcing access.  Support for extensibility via custom claims and attributes about users may vary by  individual authorization server implementations.   Enforcement An API must validate an access token and perform access policy enforcement to make  sure the application’s request is permitted before responding. The steps to validate and  obtain information about an access token will vary depending on the authorization  server’s implementation for access tokens. You should check the authorization server  documentation for details about how to validate any tokens it issues. Once the access  token has been validated, the API can use the information in the token, including any  custom claims if allowed, to perform its access policy enforcement before responding to  the request.  120   Chapter 8    authorization and poliCy enforCement   Summary Authorization involves the granting of privileges, whereas access policy enforcement  is a check done at the time a resource is requested, to validate the requestor has  been granted the requisite privileges for the request. Authorization and access policy  enforcement may be used to govern what a user can do in an application as well as  whether an application can make a request to an API. User authorization may be  based on static factors in a user’s profile and or dynamic factors evaluated at the  time of authentication, both of which can be delivered to an application in a security  token. Application authorization may be based on scopes approved by a user or an  authorization server and manifested in an access token delivered to an application and  used to call an API. In the next chapter, we’ll discuss a sample application and how it  uses OIDC and OAuth 2.0 together for authorizing access to APIs.   Key Points  resources.     Authorization is the granting of privileges to access protected      Access policy enforcement is done when a request is made and   checks if a requestor has been granted sufficient authorization for the  request.     Authorization and access policy enforcement apply to users as well   as applications calling APIs.     Authorization policy for users may be based upon user profile   attributes or dynamic factors evaluated at the time a user  authenticates or makes a request.     Authorization for applications to call APIs is granted by users or   authorization servers depending on the OAuth 2.0 grant type used.     Authorization and access policy enforcement can be specified on   multiple levels.     Claims in security tokens can be used as a basis for access policy   enforcement decisions in applications and APIs.  121   Chapter 8    authorization and poliCy enforCement   Notes        i.  https:  csrc.nist.gov projects role-based-access-control  ii.  https:  nvlpubs.nist.gov nistpubs SpecialPublications     iii.  https:  csrc.nist.gov Projects Attribute-Based-Access-  NIST.SP.800-162.pdf  Control  122   CHAPTER 9  Sample Application  with Custom API  It’s not just what it looks like and feels like. Design is how it works.  —Steve Jobs, founder of Apple Computers, as quoted in “The Guts of a  New Machine,” New York Times Magazine  The past chapters covered how certain identity protocols provide a solution for  authentication, API authorization, and application authorization. Now we can bring  together the topics from the past few chapters and describe a sample program that solves  typical identity challenges using these protocols, specifically OIDC and OAuth 2.0. In the past 3 decades, we have seen a lot of transformation in how applications   are designed and implemented. We went from traditional web applications rendering  user interfaces from the server and on-premise desktop applications to scalable  cloud services designed around APIs that talk to multiple user and machine facing  applications. A machine-first approach for the back end and experience-driven  front end is the modern standard for designing applications. From photo-browsing  applications like Imgur to banks like Monzo, we have seen the rise of highly scalable,  stateless, back-end APIs serving a user-centric front end.  We created a sample program to accompany the text and which uses OAuth 2.0 for  API authorization and OIDC to authenticate users. The following sections explain the  approach used to design the application and the rationale for identity-related design  decisions.    Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2_9  123   Chapter 9    Sample appliCation with CuStom api   Background In order to keep the example simple, we chose to build a simple document-writing  app. This type of application allowed us to cover a decent set of the problems faced by  many applications today. The application involves a stateless back-end API serving a  single-page application  SPA  and native app. Discussing every detail of how to build  and deploy modern applications is far beyond the scope of this chapter, and thus we will  focus here solely on the identity-related aspects of the application.  The application offers the following features and services:     Allows the user to write an article in Markdown.     Renders the final text from the Markdown.     Articles are owned by a single user.     An article owner can share an article with others.     Sharing is based on a simple attribute-based access control scheme.     There are two levels of access to an article, reader and editor:     Readers can view articles.     Editors can create and update articles.     When a new version of the article is created, it is published as a   versioned new document, to keep the program as simple as possible.  The sample application is similar to popular code-sharing web sites like JSFiddle or   Codepen. We made this choice so the application functionality would be familiar to most  developers which allowed us to keep the focus on demonstrating and explaining identity  management concepts.  Several measures have been taken to simplify the application. For example, the   application doesn’t support multiple users editing the same article at the same time.  Furthermore, each saved edit results in a new version. Thus if Jon created an article and  Jessie were to edit it, Jessie would get her own copy of the document. We kept the user  interface quite simple, and validation and error checking are also minimal for the sake of  simplicity. Now that we’ve covered the obligatory caveats about what isn’t included, we  can discuss what the application will do!  124   Chapter 9    Sample appliCation with CuStom api   Application Requirements In Chapter 1, we suggested several questions to ask about your project that would help  you better understand your identity management requirements. Let us now revisit those  questions for this sample application. We share the following answers to clarify the  application requirements.   Who Are Your Users: Employees or Consumers?  For the sake of simplicity, our design assumes a consumer type of user, who may wish  to enable login via a social authentication provider to access their content. The sample  application wasn’t designed for typical enterprise needs, but if it were, employee-  facing or business-to-business scenarios could use enterprise authentication providers  in a similar fashion, instead of social authentication providers. We’ll want to attract  consumer users to our application and make it as easy as possible for them to start using  our application. This question helps us understand where users will come from which  helps us sort through the provisioning options discussed in Chapter 4.   How Will Users Log In?  To demonstrate some common use cases, the application allows users to sign up for  a local account and then subsequently add the ability to link a social authentication  provider account to the local account. This enables users to log in via a social provider  account to access their documents. The application will maintain a local profile for  users and allow users to change their name, email address, and picture in the local  user profile. We want to use an industry standard protocol for authentication rather  than write custom code for every provider, so we’ll focus on OIDC for authentication,  as described in Chapter 6, and use our identity service to broker requests to social  identity providers as some aren’t compliant with this standard, and we don’t want to  write custom code for each one. This question helps us think through the authentication  protocols our application will need to support and that we’ll need a local repository of  user profile information.  125   Chapter 9    Sample appliCation with CuStom api   Can Your App Be Used Anonymously?  Users can start out anonymously and create an anonymous document. To keep the  application simple, if a user subsequently signs in, their anonymous documents are not  converted to named-owner documents and are not visible to the named account. If an  anonymous document is edited, the application creates another copy of the document.   Web-Based or Native App Format or Both?  The sample application will provide a web-based single-page application as well as a  native mobile application. This question helps us understand the scope of the project  and argues for creating an API that encapsulates the back-end business logic needed by  both front-end applications.   Does Your Application Call APIs?  Our application will call our own custom, first-party API that provides access to users’  articles. There is no use of third-party APIs at this time. This leads us to realize we need a  scheme to authorize the applications to call the API. The use of OAuth 2.0, as described  in Chapter 5, will allow us to do this in a standard way that could also be used with third-  party clients in the future, if needed. Thinking about consent, our API is a first-party API to  our front-end applications which means we don’t need to obtain user consent to call the  API. The front end and API are logically part of the same entity. If we needed to call a third- party API on the user’s behalf, our API authorization would need to obtain user consent,  but for our own API that is logically a part of the application, this is not necessary.   Does Your Application Store Sensitive Data?  The sample application assumes that the data in a user’s article might be sensitive.  As a result, the web-based application will implement a session timeout, and both  applications will provide the ability for users to enable multi-factor authentication to  better protect access to their account.   What Access Control Requirements Exist?  We first considered the capabilities of the two applications and decided that both would  offer the same functionality. Then we dove into the details of what users could do within  the applications.  126   Chapter 9    Sample appliCation with CuStom api  The goal of our application is to allow quick access to markdown documents with  features like pastebin. In order to do so, we would like to enable anonymous authors  with the ability to write and share documents. Obviously, this feature would be available  only for public documents, and such documents could be edited by the document  author or cloned and edited by someone else to create another public document. In  order to provide the ability to edit private articles, however, we’d need the user to sign up  for an account and log in to access private content.  Once logged in, users can edit their own private documents and share their   documents with others by specifying an email address domain. Each individual user can  access the documents they created as well as any documents which have been shared  with them individually or to a group to which they belong  based on email domain for  simplicity . Basing document sharing on a user’s email address’s Internet domain name  allows us to demonstrate a simple implementation of attribute-based access control  without much added complexity. A person with whom a document was shared can open  the document. If they edit it, they create another copy, of which they are the owner.   How Long Should a User Session Last?  In order to protect users who are careless about leaving open sessions, we decided the  single-page application should have a 2-hour idle timeout and an 8-hour maximum  session timeout. After session timeout, a user needs to reauthenticate. The native  application does not implement a session timeout as we assumed it is run on a device  that is usually with the user, and we want to make it convenient for quick edits. Both  applications provide a means for a user to log out.   Will Users Need Single Sign-On  If More Than One Application ?  In our sample scenario, there is only one application, so single sign-on is not needed.  If we had more than one application, or wanted single sign-on across the native and  single-page versions of our application, we could use the same identity provider for both  to provide single sign-on for users.   What Should Happen When a User Logs Out?  When a user logs out, their application session should be terminated, and the user  should be returned to a home page from which they could log in again, if desired.  127   Chapter 9    Sample appliCation with CuStom api   Are There Any Compliance Requirements?  To keep the example simple, we assume no compliance requirements. The sample does  not include a privacy notice, nor does it support any privacy requirements such as the  right to erasure. We can only do this because it’s a sample. Real applications have to  consider privacy requirements!   Platform, Framework, and Identity Provider In order to keep the applications simple and easy to understand, they are implemented  using the popular React Framework for the front end and Express.js on the back end. All  the code is written in JavaScript. This decision was made as the learnings here translate  to many frameworks in many different languages. The application components can be  easily deployed to a hosting platform such as Heroku1 or Ziet’s Now.2  The application was designed using a modern, API-first approach, so it has a custom   API for its back end. If an application delegates authentication to an OpenID Provider,  as described in Chapter 6, the access token it receives is for the OpenID Provider’s  API, specifically the UserInfo endpoint. To obtain an access token for our application’s  custom API, we need an authorization server we can configure to protect our own  API. We selected an identity provider service that supports OIDC and OAuth 2.0 so our  application can delegate authentication to it with OIDC and request authorization from  it using OAuth 2.0 to obtain access tokens for our custom API.  The identity provider service we chose can also function as an authentication   broker. Our application will delegate authentication to it, and it can in turn delegate  authentication to a variety of authentication services and return the results to our  application. Figure 7-4 in Chapter 7 shows this scenario. This allows us to efficiently  support SAML 2.0 identity providers, without having to implement SAML 2.0 directly  in our application. Our application can use the same provider to authenticate users via  OIDC and get access tokens for our custom API with OAuth 2.0.  1 www.heroku.com  2 https:  now.sh  128   Chapter 9    Sample appliCation with CuStom api   API In the old days, when starting to design an app, some people liked to start with the data  model and then build the app around it. One of the reasons to do so was to create proper  separation between the data model and control logic. The principle of abstraction is  still valuable today for good software architecture. Modern applications aim for strong  abstractions between the application front end and back end. One benefit of this is that  once the API contract has been somewhat established, it is possible to start developing  the back-end API and user-facing front end s  independently. An API Server that  implements key business logic provides a back end that can serve multiple applications  on different platforms like iOS and Android. It could also facilitate integrations with  partners and external or internal developers writing agents and additional clients on top  of the API. With these ideas in mind, we started with the API and iterated from there.  With business logic implemented to be stateless and on a server, it can be protected  and scaled easily. We recognize that API Gateways are often used in modern application  deployment environments, but again, for the sake of simplicity, we decided not to  include such an element in the sample.  There are two major concerns for a back-end service:     What actions need to be performed?     For whom?  The former is focused on the business purpose and logic of the application. In our   case, this revolves around creating and viewing documents. As a starting point, we  usually like to look at our application specification and check if everything makes sense  without a user being in the picture. It’s not that we’re suggesting not having a user model.  The exercise of being able to write the application with as little application as possible  can help us align with the stateless RESTful principle and reduce the data required in  requests to the bare essentials.  Our API centers on one resource, namely, a user’s documents, and CRUD  Create,   Read, Update, Delete  operations on the documents. In keeping with the RESTful model,  our API has an endpoint for articles and supports standard HTTP “verbs” that map to  CRUD functions.  The application is fully functional without the notion of a user, as it allows creating   documents anonymously. This might entice users to try out the app who might  otherwise balk at having to sign up for an account first. However, if we enable a user to   129   Chapter 9    Sample appliCation with CuStom api  create documents anonymously and the user later signs in, documents created before  logging in will stay anonymous and public. The trade-off we made is that allowing a user  to start anonymously means that if they upgrade to a full user later, we miss out on the  ability to integrate the information about the user with content created anonymously.  If we required authentication from the beginning, this would not be an issue, but might  dissuade users from trying the app. We decided to allow anonymous use to encourage  users to try out the application with as little effort as possible.   Protect the API With the API designed, we needed a mechanism to protect the API so that it could  only be called by our application. The client application will use OAuth 2.0, described in  Chapter 5, to obtain an access token to call our custom API. This provided an industry  standard model that could support API authorization for our current applications and  could easily be expanded in the future to support the use of our API by external, third-  party partner applications if desired.  Both our single-page application and our native application use the OAuth 2.0   authorization code grant with PKCE for API authorization, as described in Chapter 5.  Our applications and API are owned by the same entity, so the applications are first-  party clients for the API and don’t need the user’s consent for the API call. However, our  API needs information in order to enforce access policy, including information about the  user. This brings us to the users of our applications.  We elected to use OIDC to delegate user authentication to the same authorization   server that protects our API. The front-end application can redirect the user to the  OpenID Provider and get back an ID Token with claims about the user. The application  needs information such as an identifier for the authenticated user for display purposes  and their email address for notification purposes. It can use the scope parameter in the  authentication request to specify what user profile claims it needs. In this case, it will use  “oidc profile email” to get basic profile attributes and email, as described in Chapter 6. By using the same OpenID Provider for user authentication and API authorization  for our custom API, we can have the provider issue an access token with custom claims  to provide information about the user to our API. The custom API is a relying party to  the authorization server, and the custom claims in the access token will provide trusted  information to the API that it can use to enforce access policy for the users’ articles. This  brings us to the remaining scopes for the access token.  130   Chapter 9    Sample appliCation with CuStom api   OAuth 2.0 Scopes – for API Authorization  OAuth 2.0 defines scopes as a means for an application to indicate the specific privileges  it requests for an API call. The single-page application and the native application enable  the same access and will therefore require the same scopes. We defined access scopes  for the applications around the API endpoints and functions the applications would  perform. This resulted in the following scopes that the applications can request:      get:article     post:article     patch:article     patch:profile      get:author  Note that these are the privileges that the applications will use with the API, and not  privileges for users, which we’ll discuss in the next section. We registered our API in the  authorization server and defined these scopes for it. This takes care of the applications’  privileges.   User Authorization  Once we have built the application’s business logic and enabled the applications to call  the API, the next major concern is “for whom” will the API actions be done. This is a  multifaceted question, as this includes “who is the user?”, “are they allowed to perform  this action?”, “at this time?”. Attributes needed to answer these questions must be present  in the API request in order for the API to know if it should perform the requested action.  Since all of this has to be present in the request, it is lucrative to standardize and reuse  the logic that drives this.  OIDC can deliver to our application information about an authenticated user, and   OAuth 2.0 can be used to obtain an access token for the API. The access token can  contain additional claims to augment the information provided to an API. We’ll use  additional claims to provide the API information about the user, so it can enforce access  policy at the level of individual users and ensure that a user can only access the articles  they’re allowed to view. The additional information could be put into additional, custom  claims in the access token, or it could be bundled into an existing claim. User privileges  are outside the scope of the OAuth 2.0 specification, so different OAuth 2.0 providers   131   Chapter 9    Sample appliCation with CuStom api  may offer different ways of handling this. We chose to use as our provider Auth0,3 which  uses the scope claim to represent the integration of delegated and granted permissions.  In any case, the API simply needs the logic to retrieve the necessary information from  the various claims in the access tokens it will receive. Different OAuth 2.0 providers  have used different access token formats, so a helper function in the API can be used to  extract the information from claims in the token or a token introspection endpoint at the  provider, depending on the format used. This helps us encapsulate all vendor-specific  logic for validating tokens and extracting or querying claims in one place.   API Implementation Going back to our original requirements, we ideally want the access token to have  information about the user requesting an article, such as a user identifier and  permissions. In order to keep things as flexible as possible, we added to the API two  helper functions.  function getUserId token  {} - Takes a token and extracts the user_id  function hasPermission token, permission  {} - Given a token and a set of  permissions, checks if the token has all the permissions   The first function helps the API identify the user, by retrieving the identity of the user   from the “sub” claim in the token. As recommended in Chapter 4, we use an internal,  application-specific identifier for a user in all application and API logic and use separate  attributes for display and notification. This enables a user to change attributes such as  their display name or notification email address without impacting articles tied to their  identity. To keep the program simple, we didn’t implement functionality to let them  actually make such changes.  The second helper function is to check if the application and specifically the user   have the permissions to perform the requested action.  Defining and abstracting these two functions has the advantage that it encapsulates  in one place the logic to deal with any changes in token formats or information over time  or if we have to change providers for some reason.  In addition, logic is needed to validate any tokens before using them. When building   your application or API, we recommend using standard libraries for your language,   3 Full disclosure: At the time of writing this book, the authors work for Auth0.  132   Chapter 9    Sample appliCation with CuStom api  framework, platform, or provider to implement these protocols as well as validate and  consume these tokens. This simplifies your application and may help isolate your code  from vendor changes.   Processing Requests  When handling requests, we chose to have the API follow a middleware approach, which  is to handle the logic of processing a request in multiple parts. In our demo application,  we do this in the following order:      IP-based rate limiting     Check token’s validity     Extract token information     Extract request data     Handle request  If using a reverse proxy or an API Gateway, you may find that the top 3 are done   for you. If not, you’ll have to implement the steps. Your OIDC OAuth 2.0 provider may  provide libraries to help with validating and consuming tokens. For the remaining tasks,  you may have noticed that the middleware that checks for the token’s validity is early in  the list, allowing us to reject an unauthorized response as early as possible. For example,  if a user does not have a subscription that allows big files, the application can simply  respond with an error very early in the process.  It is essential for an API to validate an OAuth 2.0 access token received with a   request, before processing the request. The mechanism to validate an access token  will vary by provider and is influenced by the token format used by a provider. An  authorization server may provide a token introspection endpoint that can be used for  this purpose. Alternatively, an authorization server may use a JWT, CWT, or IronToken  access token format that supports independent validation by the resource server. The  documentation for an authorization server should indicate how an API should validate  access tokens it receives. This should include checking the issuer matches its chosen  authorization server, the expiration has not passed, and that the API is the intended  audience  recipient  for the access tokens.  There are cases where applications or APIs need meta information about a token   such as its validity, the scopes for which it was authorized, and possibly the context  surrounding issuance which includes the subject  user  who granted authorization   133   Chapter 9    Sample appliCation with CuStom api  and the client to which the token is issued. The original OAuth 2.0 specification did  not provide a means for this, but two approaches have been used, namely, a token  introspection endpoint and JWT-formatted tokens.  The OAuth 2.0 Token Introspection specificationi defines an Introspection endpoint   for authorization servers which resource servers can use to obtain token metadata.  This approach requires a call to the authorization server. Some providers have taken  an alternative approach using JWT-formatted access tokens. With a JWT access token  format, the resource server can obtain metadata about the token from claims within the  JWT payload, after validating the token. This eliminates the need to call the issuer to  validate each token. Our authorization server uses JWT-formatted access tokens so our  program can extract claims information from the access token.   Extensibility and Adding Custom Claims Somewhere along the line, you may have wondered how the custom claims will get  into the access token. This is made possible because the authorization server we chose,  Auth0, offers an extensibility feature which allows us to write custom code to tailor  the authentication and authorization process to the needs of our application. Other  providers offer similar features.  In the previous sections, we discussed the need for custom claims. In addition to   information about who the user is, we need information about the team a user belongs  to. Our application supports an access model that is loosely based on attribute-based  access control. Our application is primarily concerned with documents, and we store  permissions in the document metadata, similar to how files have permissions associated  with them in Unix-like operating systems.  In our current implementation, each file has an array in metadata with the following   shape:  {         identifier: String,         permission: String[], }  134  Identifier is either an email address or a domain name, while permission is one or   more of the following, “read,” “write,” “share,” “owner.” In the current permission model,  a complete email will be matched in its entirety with the user’s email. In the interest of    Chapter 9    Sample appliCation with CuStom api  privacy, instead of sharing the full email, a salted hash is stored and acquired. We also  allow using @domain.com identifiers which must start with the @ symbol. These allow  users to share with anyone with a specific @domain.com email. Lastly, the creator of  the file has all four permissions. To keep things simple, only the owner of a file is able  to grant “share” privilege to others. This simple model was chosen so the program  can demonstrate how attributes can be included in claims to facilitate access policy  enforcement in APIs, as described in Chapter 8.  To add claims to an access token, we will have our authorization server add an extra  nonstandard claim “https:  dev.doc team.” This claim is added to the token if the user  is part of a team. For the sake of simplicity, the team is merely a domain name, which  is hashed and salted for privacy. The extensibility feature in our chosen authorization  server allows us to use code logic to augment the token. We used a snippet of code like  the following to add a claim:  async function  user, context, callback  {     user.app_metadata = user.app_metadata  {};      user.app_metadata.teamId = user.app_metadata.teamId  async   hash getDomain user.email  ;      context.accessToken["https:  dev.doc team"] = user.app_metadata.teamId;     callback null, user, context ; }  We have found that access policy and logic vary quite a bit, and it is very common   for applications to have unique requirements in this area. We recommend checking for  some kind of extensibility feature when selecting your identity provider. If your identity  provider doesn’t support this, you’ll need to handle this logic on the back end or add this  in the provisioning step. However, since this is conveniently handled for us out of the  box in our provider, we can focus on our business logic. The same need for extensibility  applies to front-end customization as well, as most applications will want to customize  consent screens and need tailored consent management or approval logic. Having an  identity provider with some form of front-end extensibility for functions like login, sign-  up, and consent can reduce what you have to build in your application.  So far, we’ve described the API, delivering information to the API via an access token,   and how the access token is augmented with custom claims and processing the API  requests. This brings us now to the front end.  135   Chapter 9    Sample appliCation with CuStom api   Front End Separating the business logic in the API from the presentation layer allows us to build a  dynamic presentation layer to run on the client device. The advantage is that front- end  logic can focus on delivering a good user experience, while the business logic and sensitive  data are protected on the server. In the application, we use OpenID Connect  OIDC  to  delegate authentication to our authorization server. The application receives an ID Token  with claims about the user. The client can use this information about the user to tailor  the application user interface, as appropriate, based on the user’s profile and privileges.  It’s important to note that the use of user privileges on the client is purely for display  purposes. An important design assumption is that one cannot trust what happens on the  client device because developer tools, debuggers, and the like could potentially be used to  tamper with client-side logic. Information about the user’s privileges can be used to render  the user interface so it only shows features a user is allowed to use, but when the user takes  an action, the resulting requests to the server must be sanitized and validated on the server  to check if the user has the necessary permissions. Such validation and access policy  enforcement logic must execute on a protected server, where users cannot tamper with it.   Front-End Functions Keeping that in mind, on the front-end application client, the common problems to  solve are authenticating the user to the application, offering the user a graceful user  experience, and enabling logout. Thus the core tasks for the application front end are  authenticating the user, obtaining the ID Token and the access token, storing the tokens,  and then using the information acquired about the user to build the user experience.  Our application front-end therefore needs four basic functions:                  authenticate   – To authenticate the user using the identity provider  getToken   – To get a token to call an API with specific scopes   logout   – To revoke the session  getUserProfile audience, scope  – To get the user’s profile for a  specific API and scopes   There may be a need for additional helper functions depending on specific   application needs, but something akin to these four functions are commonly needed in  typical applications.  136   Chapter 9    Sample appliCation with CuStom api  The application uses OpenID Connect to authenticate users and acquire user   information from an ID Token. There are several well-designed libraries that provide  an implementation for OpenID Connect clients. In our case, we chose auth0-spa-js,   which is a library provided by our OIDC OAuth 2.0 provider, as it offers some  convenience methods on top of the basic functionality of authenticating a user and  returning claims. We recommend using a library to handle protocol details for you  and simplify your application code.   Authenticating the User  Both front-end clients use OIDC to delegate user authentication to the OpenID Provider.  There are some differences between the native app and single-page app in terms of how  they delegate authentication. On the Web, it is natural for the web-based single-page  application to redirect the user’s browser to the identity provider in order for the user to  authenticate there. However, with native applications, this may not be available, as such  applications do not run inside a browser-like runtime environment. Our native application  is designed for mobile devices and can use the underlying mobile device system’s shared  web browser to redirect the user to the identity provider to log in. Once the authentication  flow is completed, the application front end receives an ID Token and an access token.  The front end uses the information in the ID Token to obtain information about the  authenticated user, and it uses the access token for requests to the API. In addition, the  mobile app also requests and receives a refresh token which it uses to renew an access  token when it expires.   Tokens  After the user has been authenticated, the application has an ID Token, an access  token, and in the case of the native app, a refresh token. The ID Token is decoded and  validated by the application before using any of the claims in it. Then the ID Token is  stored in memory cache on the single page application and in a local store on the mobile  application. This allows the application to quickly render the user interface elements that  require user information without having to repeatedly call out to the OpenID Provider.  The access token is not stored by either application, to minimize the risk of access token  exposure. Given the nature of the application, and since access tokens are created with a  short token duration, the need to make a second call to the API within the lifetime of an  access token is deemed unlikely.  137   Chapter 9    Sample appliCation with CuStom api   Making Protected API Calls  As the user interacts with the application, it will make calls to the API, providing the  access token in the HTTP authorization header for the API request. In order to reduce the  risk if the access token were to be stolen, we configure the access token duration in the  authorization server to be short-lived. This is a trade-off between scalability and security.  A shorter duration access token means it may need to be renewed more frequently, but if  it is compromised, the window of time in which it can be used will be short.   Sessions  There are two user sessions in our sample scenario, as there is an application session for  the user as well as an identity provider session for the user.  The single-page app relies on the identity provider session for a user and, as such,   does not store data locally, beyond storing the tokens it receives in the in-memory  cache. This simplifies the application but comes with the disadvantage that every time  the application is started in the browser, it has to check with the identity provider for the  status of the user’s session.  The native app takes a different approach. The design model for the native app   allows the user session to continue until the user explicitly logs out. The native  application can continue to run on the user’s device until it is shut down. When the  user interacts with the application, it may make an API call and only then will it need  an access token. The native app can make use of a refresh token to obtain a new access  token if the old one has expired when the native app needs to make an API call. In our  current implementation, the refresh token acquired during the initial authentication is  stored in the operating system–provided secure storage implementation.  As you will learn in Chapter 10, in a typical SSO deployment, a user may have  multiple sessions including an application session, identity provider session, and  an additional session in each of any other applications they’ve authenticated to via  the same identity provider. It is desirable in some cases to have a binding between  the session at an identity provider and all the relying parties it serves, so that a given  application can be aware of changes to the user’s session in the identity provider  and vice versa. Unfortunately, at the time of writing, there is no finalized standard  way of achieving this with OIDC. So far, there is only a draft specification for session  management which we elected not to use as it has not been approved.  138   Chapter 9    Sample appliCation with CuStom api   Token Management  We abstract token management in the “getToken” method for the front end. When  the token is acquired, the application uses the “expires_in” element of the response  to compute an expected timeout for the token. This is stored along with the audience,  scope, and other metadata associated with the token. Later, when the application needs  an access token with specific scopes, the getToken method simply returns an access  token from the cache, until the token expires, at which point the application needs to  request a new access token.  The mechanism to obtain a new token varies by the type of application. The single-   page application cannot securely store a refresh token, so cannot use this method of  renewing an access token.4 It could redirect the user to the identity provider to obtain  a new token, but this can be disruptive to the user experience. To avoid this, it uses  a library from the OpenID Provider that implements a more sophisticated means of  interacting with the OpenID Provider based on HTML5 Web Messaging. It requests this  by using the web_message response_mode parameter in the authentication request.  The options available for renewing tokens may differ with your chosen identity provider.  We recommend using the method recommended by your provider. In our case, we  abstract getToken with auth0-spa-js’ getToken method. The auth0-spa-js offers a cache  implementation as well, so we do not reimplement it in the application.  On the native application, the implementation is slightly different as it can use a   refresh token. The native application uses a refresh token to call the OpenID Provider’s  token endpoint in order to obtain a new access token. The refresh token will be stored by  the native application using secure device storage, such as KeyChain on iOS.    Logout  Logout is implemented differently on the two platforms. Both applications destroy any  tokens they’ve received during the user’s session as well as any cookies and session  state set by the application. In addition, the single-page application, when logging out,  redirects to the OpenID Provider’s logout endpoint. This terminates the identity provider  session as the provider will log the user out when the logout endpoint is invoked.  The implementation for logout and session termination is vendor specific, and we  recommend checking the vendor’s documentation for their specific implementation of   4 https:  tools.ietf.org html draft-ietf-oauth-security-topics-13section-4.12  139   Chapter 9    Sample appliCation with CuStom api  any logout-related features. The native app deletes any session data, including the ID  Token and access token, and it also revokes the refresh token with a call to the identity  provider. The native application could have opted to log the user out by calling the  identity provider’s logout endpoint, but we chose not to use this option as the user  experience is different on a mobile device and doing so can break other application  sessions relying on the same OpenID Provider.  There were two other considerations related to logout. As there is only one   application in our case, there is no single logout. The implementation for single logout,  if needed, or session revocation is vendor specific, and we recommend looking into the  vendor’s documentation for their specific implementation.  As mentioned previously, different identity providers may use different token   formats. With a JWT type of access token, it is not possible to revoke the access  tokens unless the issuing provider supports a blacklist feature. If not revoked or  blacklisted, the access tokens will stay valid until they expire. In practice, it’s often  more convenient to use a short token expiration than to call the provider for each  token to check for blacklisting. Our provider uses a JWT-format access token. The  access tokens for our API are configured in the authorization server to have a  sufficiently short expiration period so we can avoid the development work and  performance impact of checking for blacklisting. Again, it is necessary to check for the  recommendations from your chosen provider on how to terminate access associated  with security tokens it has issued.   Summary We’ve covered in this chapter how we designed and built a sample application that uses  OIDC for user authentication and OAuth 2.0 for API authorization for our custom API. In  this scenario, both functions are handled by the same OpenID Provider OAuth 2.0  authorization server. We shared some key design decisions and implementation points  involved in creating the application. The following chapters will discuss additional  aspects of identity management that applications have to handle after the user has been  initially authenticated, starting with sessions.  140    Key Points  Chapter 9    Sample appliCation with CuStom api     OIDC is used to authenticate users and obtain an ID Token with   claims about the authenticated user.     OAuth 2.0 is used to obtain an access token to authorize the   application to call our custom API.     The access token returned by a social identity provider is for the   social identity provider’s API.     To obtain access tokens for our custom API, we need to obtain and   configure our own authorization server to protect it.     Our authorization server adds custom claims to the access token to   provide additional information to the API about the user.     The custom claims enable the API to enforce user-level access policy.     Both applications use the OIDC authorization code grant flow with   PKCE for a user’s initial authentication.     The native application, implemented in Cordova, uses the device’s   system browser to redirect the user to the OpenID Provider.     The single-page application uses the OIDC Implicit Flow with a  library that uses the web_message response mode for renewing  access tokens for a better user experience.     The native application uses a refresh token to obtain a new access   token if the previous access token has expired.     Each of the applications uses its own client identifier so the API can   distinguish between the two clients for access control and logging.   Note     i.  https:  tools.ietf.org html rfc7662  141   CHAPTER 10  Sessions  Everything measurable passes, everything that can be counted has an end.  Only three things are infinite: the sky in its stars, the sea in its drops of water,  and the heart in its tears.  —Gustave Flaubert, French novelist,   from The Letters of Gustave Flaubert  1980   A user’s interaction with an application over a period of time is known as a session. Upon  authenticating to an application, a user expects to navigate through the application and  perform various transactions during their session without having to authenticate every  time they do something. In order to make this possible, an application needs a way to  track that a user has been authenticated. Data about whether, when, and how a user  has authenticated may be tracked by an application along with other information it  maintains during a user’s session. Sessions and session state may be handled differently  for web applications, single-page applications, and applications that run natively on a  device, such as mobile applications. In this chapter, we’ll describe where sessions exist,  session expiration, and renewing sessions.   Application Sessions During a user’s session, an application may need to track particular information such  as in-flight transactions or how long a session can continue. With traditional web  applications, the user’s session state may be maintained on the server by assigning it a  session identifier and storing it in memory, a filesystem, database or shared service like  Redis.1 The session identifier can be stored in a cookie set by the application, which is   1 https:  redis.io     Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2_10  143   Chapter 10    SeSSionS  then sent by the browser with each request to the application server. When a request is  received, the server can use the session identifier from the cookie to retrieve the user’s  session information and process the request. Sometimes, if the session data is small  enough, it may all be stored in the cookie, eliminating the need for server-side storage.  Traditional web applications often limit the time for which they retain a session.  Session information maintained on a server typically consumes server resources. If  a user abandons a session by forgetting to log off or a client loses its connection to a  session for some reason, server resources would be wasted. In addition, a session left  open and forgotten on a user’s computer invites some risk of potentially being taken  over by a malicious actor. As a result, traditional web applications often implement  a session timeout which effectively limits how long a user’s session can last. Session  timeout might occur after a period of inactivity and  or a maximum period of time, with  the allowed session duration in either case often based in part on the sensitivity of the  application and data involved.  With single page applications and stateless back-end APIs, server-side sessions for   users are no longer required, but the concept of a session timeout persists for other  reasons. Applications are still vulnerable to the possibility that a session left open for an  extended period might be hijacked. This concern is especially relevant for applications  handling sensitive data, many business-facing applications, and applications accessed  from shared devices. Having a user reauthenticate when a session times out provides  some assurance that the authorized user is still in control of the device and session. As  applications increasingly leverage identity providers, a user’s reauthentication can renew  an identity provider session leveraged by many applications, meaning a user might not  have to actively reauthenticate to every application.  Native applications running on mobile devices have additional considerations.   The small form factor and input mechanisms on mobile phones make frequent  reauthentication a significant detractor to user experience. Especially for some  consumer-facing applications, it is desirable to remove barriers to usage and make it  easy for users to stay logged in as long as possible. Native applications often use stateless  APIs resulting in little server-side cost for allowing a user’s native application session  to continue for an extended period of time. Sensitive applications, such as banking  applications, often still implement a session timeout on mobile devices, but less-  sensitive native mobile applications may allow a session to continue for an extended  period, until a user explicitly logs out.  144   Chapter 10    SeSSionS   Identity Provider Sessions Identity providers also need to maintain a session for a user as a mechanism to  remember and recognize an authenticated user across multiple requests. One solution  is to create a session object with a session identifier and attributes such as an identifier  for the user, the authentication mechanism used, the time of authentication, and when  the session will expire. An identity provider can create a cookie in the user’s browser  that contains all the session information or just a session identifier that maps to a server-  side session data store. The browser then sends the identity provider cookie with every  request to the identity provider. When a user is redirected to the identity provider, it uses  data from the cookie to detect if a user already has an authenticated session.  This scheme helps an identity provider recognize users it has authenticated. After   successfully authenticating a user, the identity provider sets or updates in the user’s  browser a cookie with session information and returns a security token to the application.  The application may then create or update its own application session for the user. When  the application session expires, the application can check the status of the user’s session  at the identity provider. It may do this by redirecting the user’s browser to the identity  provider. Such a request will include any cookies set previously by the identity provider,  which contain the user’s session information. If the user’s session at the identity provider  is still valid, the identity provider returns a new security token to the application without  forcing the user to authenticate again. Some identity providers may support alternative  mechanisms for checking the status of the user’s session at the identity provider which  can enable an application to avoid a browser redirect when the user’s identity provider  session is still valid. Of course, if the identity provider session has expired and the user  needs to reauthenticate, the user will need to be redirected to the identity provider.   Multiple Sessions A user may have multiple sessions across different solution components. The user may  have a session in one or more applications. If an application delegated authentication to an  identity provider, the identity provider may also have a session for the user. If an application  delegates authentication to an authentication broker  explained in Chapter 7  that in turn  delegates authentication to a remote identity provider, such as a social identity provider or  corporate identity provider, there may be three architecture layers at which sessions exist.  Figure 10-1 shows three different architectural models and where authentication sessions  may exist.  Chapter 13 on Logout contains further discussion on sessions which may exist.    145   Chapter 10    SeSSionS  Authenticated user session  Figure 10-1.  Architectural Layers Where User Sessions May Exist    Session Duration Each session established for a user can be terminated at different times and for various  reasons. Sessions may time out if they are established with a specific duration. A session  may have an idle timeout where the session is invalidated if the user has been inactive  for a period of time. A session may also have a maximum session time limit which ends  the session after a period of time regardless of the user’s activity level.  With an idle session timeout, if a user takes certain types of actions tracked by the   application, the idle session timer gets reset, which extends the session. Activity in  an application may reset an application session’s idle timer, but not be visible to an  identity provider and consequently not reset an idle timeout at the identity provider. The  identity provider’s idle timeout is typically only reset by requests visible to it, such as an  authentication request from an application.  If an application enforces an idle session timeout, it can be disruptive to a user to   suddenly lose an application session, especially if the user was in the middle of entering  a lot of data for a transaction! An application can mitigate the potential for bad user  experience by tracking the session duration, providing a warning to users before the  session times out, and resetting the idle timeout if the user indicates they wish to continue.  Proactively prompting the user when a session timeout approaches and letting them renew  their session can avoid bad user experience when enforcing an idle timeout is required.  146   Chapter 10    SeSSionS  The appropriate session duration time for an application will vary based on   factors such as the sensitivity of the application or the delivery platform. For an idle  timeout, it may help to consider how long you would want to tolerate a user’s session  remaining open if the user walks away from their desk with the application open. For  applications on mobile phones carried around by their owners, it may be less likely  for an open application session to be physically accessible by others. For a maximum  session timeout, it may help to evaluate how frequently or infrequently the user should  reauthenticate to confirm they are still in control of the session as well as how frequently  user profile information might need refreshing. It’s a balance between protecting the  user and data they access and annoying the user by requiring them to authenticate too  frequently. The duration may differ for applications run on desktop laptop computers  vs. mobile phones and for consumer-facing applications vs. enterprise applications as  well as for applications with data of different sensitivity levels. It can often take some trial  and error to get it just right.  Sessions may end for reasons other than a timeout. A user may explicitly log out.  This is covered in more detail in Chapter 13. An administrator may terminate a user’s  session at an identity provider for various reasons, such as in response to a report of a  compromised credential. A user’s session might be terminated if a server is restarted. A  user’s session might exist at a server, but be irretrievable if the user deleted the cookies in  their browser that contain information about their session. The possibilities for session  termination should be considered in application designs with appropriate actions  defined for each case.  With many ways for sessions to terminate, and multiple sessions in the mix, it   is important for application designers to specify or understand the impact on other  sessions when any session is terminated. For example, if an application session expires,  should it request the termination of the user’s session at an identity provider? If a user’s  identity provider session is terminated, should that trigger the immediate termination  of a session in a related application using the same identity provider? The options to  consider may be constrained by identity provider policy when an identity provider is  controlled by an external party, but designs should still enumerate what happens for  different session termination scenarios.  An application may want to periodically check the status of a user’s session at an  identity provider. This may be done so the application can terminate its own session  when the identity provider’s session has ended. This may also be done when an  application’s session for a user has timed out, with the application checking the state of  the user’s identity provider session as part of its own session renewal process.  147   Chapter 10    SeSSionS   Session Renewal When an application’s session for a user expires, the application may wish to enable  the user to renew the session. It can do this by redirecting the user back to the identity  provider. The identity provider can authenticate the user if it doesn’t have a valid  session for them and return new security tokens to the application per the parameters  in the application’s authentication request. If the user’s identity provider session is still  valid, the user would not need to reauthenticate, and the application would receive  new security tokens based on the user’s existing session. The application can then use  information in the new security tokens when renewing the user’s application session.  Applications can use parameters in an authentication request to suppress or   force active authentication. It may be desirable, for example, to have reauthentication  occur if a certain amount of time has passed since the user last actively authenticated.  With OIDC, the optional “prompt” parameter can be added to an authentication  request to force or suppress authentication at the OpenID Provider. The optional  “max_age” parameter can be used to control how long a user can go without actively  reauthenticating. Applications using max_age should still check the auth_time claim in  the ID Token to ensure the requested max_age was followed. Use of max_age and auth_ time is useful if an OpenID Provider has a relatively long maximum or idle timeout, and a  particular application wishes more frequent authentication. With SAML 2.0, applications  can use the “ForceAuthn” attribute of the authentication request to force the identity  provider to actively authenticate the user. Such authentication request parameters give  applications some measure of control over whether the user is actively reauthenticated  when they are redirected to the identity provider.  Individual identity providers may support alternative methods for checking the   status of a user’s session at the identity provider. If a user has a valid session at an  identity provider, such methods may enable renewing an application session without  requiring a browser redirect. If a user’s identity provider session is no longer valid, the  user can then be redirected to renew the identity provider session.   Token Renewal In addition to renewing a session, an application may need to periodically renew a security  token. The application may have received an ID Token and possibly an access token to  call an API. An application may wish to periodically request a new ID Token to ensure it   148   Chapter 10    SeSSionS  has up-to-date claims for an authenticated user. An application may wish to request a new  access token because it needs to call an API and the access token it requested previously  has expired. It is considered a best practice in many cases, and especially with public  clients, to issue access tokens with short expiration times, and renew the tokens when  needed, so the need for new tokens may occur throughout a user’s session’s existence.  During an application session, an application can renew an ID Token or access token   it previously obtained from an OpenID Provider using a couple different mechanisms,  based on the type of application. Traditional web applications and native applications  may be able to obtain a refresh token for use in renewing ID Tokens and or access  tokens, but they are not required to do so. Using a refresh token to renew tokens avoids  the need to interrupt the user experience, but back channel requests with a refresh token  may not update the identity provider’s session cookie, resulting in a faster idle timeout.  Single-page applications implemented as public clients cannot securely store and  handle refresh tokens so must use an approach that doesn’t rely on refresh tokens unless  their authorization server implements measures against leaked refresh tokens such as  refresh token rotation or sender-constrained refresh tokens.2 Applications that do not  receive refresh tokens can redirect the user to the OpenID Provider when new tokens  are needed. If the user has a valid session, the application will receive new tokens. If the  user does not have a valid session, the request will trigger authentication and consent  as needed. Even applications with refresh tokens may want to use the redirect approach  periodically to update the identity provider’s session cookie and idle timeout.   Redirecting the user to the OpenID Provider and back, however, involves challenges   as it can interrupt the user experience. With single-page applications, this can result in  the loss of a user’s work unless the application saves it and restores it after the return  from the OpenID Provider. One improvement is to do the redirect using a hidden iframe  in the application and setting the “prompt” parameter to “none” to avoid interrupting  the user experience. If the user has a valid session, the application will receive new  tokens. If not, the application will receive an error response and can redirect the user  again without the “prompt=none” option to trigger authentication. An OpenID Provider  may provide an SDK to make this easier for applications.  2 The “OAuth 2.0 Security Best Current Practice” document specifies refresh token rotation and  sender-constrained refresh tokens as two mechanisms for this. https:  tools.ietf.org html  draft-ietf-oauth-security-topics-13section-4.12  149   Chapter 10    SeSSionS   Reconstituted Sessions  It can be disruptive to users to have their session time out frequently in heavily  used applications if they have to reenter several selections when they reauthenticate. An  application that needs a session timeout and falls in this category may want to provide  an improved user experience by offering a session that can be reconstituted after session  timeout. With this scheme, upon session timeout, the system invalidates the session for  further use, but retains a memory of the session and the identity associated with it, so that  the session state can be restored to its former state if the user actively reauthenticates.  Such a session is terminated and permanently deleted by an active user logout, not a  session timeout. That said, it is still desirable to have a limit for how long a session stays  in a dormant state, to reduce backward compatibility issues and to avoid storing session  data for sessions orphaned by events such as a user deleting session cookies.   Summary Applications maintain sessions for users during a user’s interaction with the application. If  applications delegate authentication to an external identity provider, there may be multiple  sessions for the user at different layers within the solution architecture. Each component  maintaining a session for a user may have one or more types of session timeout. Sessions are  a key enabler for single sign-on, which just so happens to be the topic of the next chapter.   Key Points     A user’s interaction with an application for a duration of time is a session.     Session state may contain data about the user and authentication event.      In solutions with single sign-on, a user may have multiple  authentication sessions.     Sessions may be subject to an idle and maximum timeout.     Session duration is typically based on the sensitivity of the resources   accessible from the session, the application delivery platform, and  the type of application.     A continuous authentication session can be used to remember and   reconstitute user sessions which have expired.  150   CHAPTER 11  Single Sign-On  A ripple widening from a single stone  Winding around the waters of the world.  —Theodore Roethke, American poet, from The Far Field  1964   Now that we’ve covered sessions, we can discuss single sign-on  SSO , starting with what  it is and why it is valuable. We’ll also cover how it works and considerations for attributes  of single sign-on sessions to help you design SSO for your projects.   What Is SSO? Single sign-on is the ability for a user to authenticate once and access multiple  applications without having to log in again. It is usually enabled by using an identity  provider. This chapter will focus on SSO and assumes a set of applications that use  either OIDC or SAML 2.0, use the same identity provider and are accessed via the same  browser, or, in the case of native applications, at least use the same browser when  delegating authentication to the identity provider. Once authenticated, a user enjoys  single sign-on access to applications as long as their identity provider session  SSO  session  has not expired or been terminated.  Single sign-on can aid a variety of scenarios. In consumer-facing environments,   for example, a user might enjoy single sign-on across multiple applications that allow  the user to log in via Google Sign-In.i In an enterprise environment, an employee  might enjoy single sign-on across internal and cloud applications that leveraged their  company identity provider for authentication. In universities, students, professors, and  administrators might enjoy single sign-on across university applications leveraging a  university identity provider.    Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2_11  151   Chapter 11    Single Sign-On  Single sign-on offers many benefits.  For users, single sign-on offers the convenience   of not having to authenticate as often, fewer usernames and passwords to remember,  and no exposure of their credentials to applications. Application owners can delegate  to the identity provider the work for implementing login pages, credential validation,  secure storage of credentials, and some account recovery features. For a business or  organization, single sign-on additionally provides a single place at which to implement  and enforce authentication policy, different forms of authentication, account recovery,  logging, and account termination. It’s easier to enforce best practices in a single place  than in many individual applications. SSO also improves security to the extent that users  with only one password to remember are less likely to write it down on the proverbial  sticky note or whiteboard.  There are, however, a few trade-offs with single sign-on. Implementing single   sign-on creates a gateway to your application with the potential to be a single point of  failure. A centralized service also provides a single point of attack. To mitigate these  risks, it’s essential to select an identity provider that is designed to be highly available  and implements security best practices. An identity provider also has greater visibility of  user activity and the ability to track users across sites, which can be a privacy concern.  When selecting an identity provider, users and businesses should perform due diligence  evaluation of the privacy features and security certifications of a provider before  entrusting their application’s authentication to it.   How SSO Works Single sign-on is possible with the authentication protocols discussed in this book  because an identity provider maintains a session for a user it has authenticated.  Using the example shown in Figure 11-1, a user visits application 1 which redirects  their browser to an identity provider with an authentication request. The identity  provider authenticates the user, establishes a session for the user, and creates a cookie  in the user’s browser with information about the session. Then it redirects the user’s  browser back to the application with security token s  which contain data about the  authentication event and authenticated user. The application can then create or update  its own local session  and possibly a cookie  for the user as appropriate for the type of  application.  152   Chapter 11    Single Sign-On  Figure 11-1.  Single Sign-On  If the user then visits application 2 with the same browser, the second application   detects that the user has not yet logged in to it and redirects the user to the identity  provider. The user’s browser includes the identity provider cookie with the request, so  the identity provider uses the cookie to detect the user already has an authenticated  session at the identity provider. It checks if the user’s session is still valid and, if so,  redirects the user’s browser back to the second application with the requested security  token s  without prompting the user for credentials. The second application then creates  or updates a local session for the user  and possibly a cookie  as appropriate for the type  of application it is. The user can continue to access subsequent applications or come  back to the first two, without signing in again, as long as their session at the identity  provider, often called their SSO session, remains valid.  There are various reasons that the user’s session might become invalid. It might   have timed out as described in Chapter 10. Alternatively, the session might have been  terminated at the identity provider by an administrator or if the user logged out of the  identity provider. The user might have even logged out of another application that  triggered a logout request to end the identity provider session. We’ll cover more about  logout scenarios in Chapter 13. Regardless of the reason, if a user is redirected to an  identity provider with an authentication request and their session is no longer valid, the   153   Chapter 11    Single Sign-On  identity provider will prompt the user to reauthenticate  unless the request contained  authentication request parameters to suppress active authentication .  Even with a valid SSO session, there are situations where the user still has to interact  with the identity provider. If the user visits an application that requests API authorization  to call an API on the user’s behalf, and the identity provider is also the authorization  server for the API, the identity provider will prompt the user for consent for the API access.  If the user visits an application that requires a session with a stronger or different form of  authentication than that used to establish their existing session, the user will be prompted  to meet the new application’s authentication requirements. If an application includes  in its authentication request a parameter to force authentication, the user will need to  reauthenticate. Similarly, a parameter can be used to specify a maximum length of time  that can elapse between active authentications, and this may trigger a need for a user to  reauthenticate as well. In the absence of such special cases, SSO enables a user to access  multiple applications after authenticating once, until their authentication session expires.   SSO Session Attributes When implementing single sign-on with an identity provider you control, there are  several features to configure, from session duration to the strength of the authentication  mechanisms used as well as the login page branding and mechanisms available for  terminating sessions.   SSO Session Duration The length of the SSO session, often specified in terms of maximum and idle timeouts,  should be configured, keeping in mind the sensitivity of the applications relying on  the SSO session; however, it is possible to accommodate applications with different  requirements. If an application using OIDC requires a user to actively authenticate more  frequently than an identity provider session would require, the “max_age” parameter  in the authentication request can be used to specify the maximum allowed time, in  seconds, that can elapse since the user was last actively authenticated. The use of this  parameter requires the identity provider to actively authenticate the user again if the  value of max_age in an authentication request is less than the elapsed time since the  user last authenticated. Applications should still check the auth_time claim in the ID  Token to ensure the requested max_age was followed.   154   Chapter 11    Single Sign-On  An application can enable a user to remain active in the application without   reauthenticating for a longer time than an identity provider session by using a longer  application session timeout.   Multiple Identity Providers If SSO is implemented using an authentication broker that allows for the configuration  of multiple identity providers, the broker should be configured to ensure that users  from each identity provider can only log in to the applications appropriate for them.  For example, if a company has an authentication broker with one identity provider  configured for employees and another configured for partners, the configuration should  ensure that partners cannot get access to applications intended only for employees.  This scenario is illustrated in Figure 11-2. In this example, Application 1 should only be  accessed by users authenticated by Identity Provider A. Application 2 should only be  accessed by users authenticated by Identity Provider B. An SSO session established by a  user logging in to Identity Provider B should not enable access to Application 1.   cid:36  cid:83  cid:83  cid:79  cid:76  cid:70  cid:68  cid:87  cid:76  cid:82  cid:81  cid:3  cid:20  cid:3   cid:11  cid:40  cid:80  cid:83  cid:79  cid:82  cid:92  cid:72  cid:72  cid:86  cid:12    cid:36  cid:83  cid:83  cid:79  cid:76  cid:70  cid:68  cid:87  cid:76  cid:82  cid:81  cid:3  cid:21  cid:3   cid:11  cid:51  cid:68  cid:85  cid:87  cid:81  cid:72  cid:85  cid:86  cid:12    cid:36  cid:88  cid:87  cid:75  cid:72  cid:81  cid:87  cid:76  cid:70  cid:68  cid:87  cid:76  cid:82  cid:81  cid:3    cid:37  cid:85  cid:82  cid:78  cid:72  cid:85    cid:44  cid:71  cid:72  cid:81  cid:87  cid:76  cid:87  cid:92  cid:3  cid:51  cid:85  cid:82  cid:89  cid:76  cid:71  cid:72  cid:85  cid:3  cid:36  cid:3    cid:11  cid:40  cid:80  cid:83  cid:79  cid:82  cid:92  cid:72  cid:72  cid:86  cid:12    cid:44  cid:71  cid:72  cid:81  cid:87  cid:76  cid:87  cid:92  cid:3  cid:51  cid:85  cid:82  cid:89  cid:76  cid:71  cid:72  cid:85  cid:3  cid:37  cid:3    cid:11  cid:51  cid:68  cid:85  cid:87  cid:81  cid:72  cid:85  cid:86  cid:12   Figure 11-2.  Authentication Broker with Multiple Identity Providers   Authentication Mechanisms An identity provider should be selected and configured to support the specific  authentication mechanisms required by the applications leveraging the session.  Applications can use parameters in the authentication request to specify desired classes  of authentication mechanisms. For example, one application might require only a  username password login, whereas another application might require a stronger form  of authentication such as a one-time password. Stronger forms of authentication are  discussed in the next chapter.  155    Single Sign-On  Chapter 11   Login Page Branding In terms of user experience, the login page for an SSO session should make it clear what  the user is logging in to. For example, if an employee is redirected to a corporate identity  provider, it is helpful for the login page to be branded to identify it as the corporate  login page. We’ll talk more about logout in Chapter 13, but it should be easy for users  to terminate the sessions created when they log in. If the user’s login creates an SSO  session, but the application only performs a local application logout, users may not  realize another step is needed to terminate the SSO session. In designing or configuring  login pages, it should be clear through branding and other means what the user is  logging in to and how to terminate any sessions when done.   Summary Single sign-on is the ability to log in once and access multiple applications that rely on  the same identity provider without having to reauthenticate for each application. Single  sign-on offers convenience to users and provides a centralized administration point  for authentication policy. Application owners should ensure the characteristics of a  single sign-on session at an identity provider are compatible with their requirements for  factors such as session duration and the strength of authentication required. Speaking of  authentication strength, the next chapter is going to discuss exactly that in more detail.   Key Points     Single sign-on is the ability for a user to authenticate once and  access multiple applications that delegate authentication to the  same identity provider without the user reauthenticating to each  application.     Single sign-on with an identity provider avoids exposure of user   credentials to applications.     The use of an identity provider may relieve developers of the work   to build login pages and account recovery mechanisms in each  application.  156   Chapter 11    Single Sign-On     The use of an identity provider for single sign-on provides a single   place to administer authentication policy and a single account shut-  off point.     Single sign-on can create a single point of failure if not designed to be   highly available as well as secure.      Identity providers should be configured with session settings  appropriate for the applications relying on the identity provider.   Note     i.  https:  developers.google.com identity   157   CHAPTER 12  Stronger Authentication  Come, let us hasten to a higher plane,  Where dyads tread the fairy fields of Venn,  Their indices bedecked from one to n,  Commingled in an endless Markov chain!  —Stanislaw Lem, Polish author of science fiction, philosophy,   and satire, from The Cyberiad  1965   Different methods of authentication are not considered equal. The static passwords  that still enable access to many Internet services are considered a relatively weak  authentication mechanism. Several stronger forms of authentication exist, and their  use is recommended to better protect online resources. In this chapter, we’ll discuss the  issues with static passwords and how stronger forms of authentication can be used for  multi-factor authentication and step-up authentication.   The Problem with Passwords A static password is a secret string of characters used repeatedly over time by a user  to authenticate to a particular protected resource. Static passwords are widely used  today but have several drawbacks. Short passwords may be guessed by brute force  attacks which try every possible password. Long passwords can be difficult for users  to remember, but writing them down makes them more prone to being stolen. If a  username and password are stolen, they can be used by someone far distant from the  account owner, who may not realize the password has been compromised until it is used     Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2_12  159   Chapter 12    Stronger authentiCation  to do something unauthorized. Worse, if the compromised password has been used  across multiple sites, its theft can put them all at risk. The introduction of single sign-on  makes the use of static passwords more problematic in the sense that a stolen password  may grant access to many systems.   Stronger Forms of Authentication To avoid the weakness of static passwords, there are several stronger forms of  authentication that can be used. One widely used mechanism has been to send a  one-time password  OTP  to a user via SMS text message1 or email. The OTP is often a  numeric code and is generated and sent to the user at the time of authentication. The  OTP is then entered into a login screen by the user to complete the authentication.  Alternatively, a one-time password can be generated by an application on a user  device such as a mobile phone or by a specialized OTP hardware security token. As the  name implies, a one-time password can only be used once, making it difficult for an  unauthorized party to use a stolen OTP.  Another approach involves the use of a private cryptographic key that is securely   encapsulated in a device such as a smartcard, hardware security token, or mobile  phone. The entity wishing to authenticate the user sends a challenge nonce to the  authenticator device. The secret key encapsulated in the device is used to sign the  challenge nonce. With multi-factor authenticator devices, the user has to enter a PIN or  provide a biometric factor to unlock the device before it will sign the challenge nonce.  The authenticating entity receives a message back from the device with the signed  challenge nonce and validates the signature, using previously registered information,  to ascertain whether the user  subject  possesses the authenticator device. With this  approach, authentication is based on possession of the device with the key as well as a  factor to unlock the device.  Biometric factors such as fingerprints, facial scans, retinal scans, and voice prints   can serve as stronger forms of identification but have the drawback that if used for  authentication and compromised or damaged, they cannot be reissued. In other words,  a person cannot be issued a new finger if a hacker is able to capture their fingerprint   1 At the time of writing, the security of SMS codes sent to phones is threatened by attacks on  Signaling System No. 7  SS7 , a protocol layer in the infrastructure that provides connectivity  between mobile phone networks. Your projects should evaluate the current status of this issue  before deciding to rely on SMS codes.   160   Chapter 12    Stronger authentiCation  and use it with biometric fingerprint authentication. If a biometric authentication factor  is compromised, it is necessary to either change the factors used or change what the  authentication algorithm looks for in the existing factors.  It’s worth noting that knowledge-based authentication  KBA , which involves   answering security questions, has similar risks to passwords. Answers can be guessed  or stolen by a remote entity and used without the owner’s knowledge. The strength of  authentication methods can be classified, and one example classification scheme is the  NIST 800-63 Security standardi which defines criteria for three levels of authenticator  assurance.   Multi-factor Authentication Multi-factor authentication requires the use of multiple authentication factors in order to  authenticate. These typically include something you know as well as something you have  and or something you are. The something you know can be a password or passphrase.  The something you have may be a device such as a mobile phone or a hardware security  token used for one of the authentication mechanisms described in the previous section.  The something you are can be a biometric factor such as a fingerprint, voiceprint, or  facial scan.  The use of multi-factor authentication reduces the risk if any one factor is   compromised. If authentication requires entering a static password as well as a one-time  password generated by a mobile phone, a hacker would have to steal a user’s password  and unlocked phone to impersonate the user and gain access to their account. Requiring  multiple factors for authentication therefore provides a stronger assurance that the  person authenticating is the legitimate account owner.  Authorization policy may require multi-factor authentication for certain situations.  It may be required at all times to access sensitive content such as administrative access  to production cloud servers. In other situations, multi-factor authentication may only be  required if an unusual situation is detected, such as a user attempting access from a new  device or an atypical geographic location. Some enterprise environments may require  multi-factor authentication for remote access or even in the office for more sensitive  resources.  The selection of authentication mechanisms for a solution should take into   account the sensitivity of the application and data involved as well as the usability of  the solution because users may try to circumvent mechanisms that are too onerous  or deemed overkill for a particular situation. Section 6 and specifically Section 6.2 of   161   Chapter 12    Stronger authentiCation  NIST publication 800-63-3 shows one example of how to approach the selection of an  appropriate authenticator assurance level for a deployment.ii  NIST Special Publication  800-63Biii has the accompanying list of types of authentication for each authentication  assurance level.    Step-Up Authentication When a user authenticates, an authenticated session is created with a certain level  of authentication assurance that the user is the legitimate owner of the account. For  example, if a user logs in with a static password, there is some chance the password  was stolen and the account is being used by an imposter, so the user’s session might be  considered at “level one” in terms of authentication assurance. If a user subsequently  authenticates with a stronger form of authentication such as a one-time password  generated on their mobile phone, the confidence that the user logging in is the legitimate  account owner is much higher because it would be harder for someone to impersonate  the user when their phone is required for authentication. After authenticating with  the one-time password, the user’s session might then be considered at “level two” for  authentication assurance.  Our choice of levels and names is an arbitrary example for  purposes of illustration.  Step-up authentication is the process of authenticating with a  stronger form of authentication in order to elevate the authentication assurance level of  an existing authentication session.  Authorization policy may require authentication sessions to be at a specific  authentication assurance level in order for a user to access resources or execute  transactions that involve more risk. Applications with features that vary in sensitivity  can use step-up authentication to require stronger authentication for more sensitive  transactions. For example, a user might be able to browse a retail web site anonymously,  but have to elevate their session by authenticating with a password to access previously  stored address information for a purchase delivery. In an enterprise, a manager might be  able to access the accounts payable system with a password to run reports, but then have  to step up her session by authenticating with a one-time password in order to approve  a payment for a large amount. Step-up authentication facilitates a model where the  strength of the authentication mechanism required for a situation is commensurate with  the risk inherent in the protected resources involved.  162   Chapter 12    Stronger authentiCation   Session Timeouts An identity provider may allow the configuration of multiple forms of authentication  along with a classification or level of authentication assurance for each. A user’s  authentication session may then include information about the authentication  mechanism s  used, an authentication assurance level or authentication context class,  and the session expiration. If an identity provider supports authentication sessions at  different authentication assurance levels, it may support shorter session timeouts for  elevated sessions which provide access to more sensitive resources. Shorter session  timeouts for more privileged sessions would reduce the chances of highly privileged  sessions being hijacked for malicious purposes and align with the security principle of  least privilege.   Requesting Authentication Mechanisms Applications may need a way to request an identity provider use a particular class of  authentication mechanism to achieve a desired level of authentication assurance. This  can be done with an authentication context class reference. An authentication context  involves several factors, such as the identification processes used to create an account,  the protections against credential compromise, and the authentication mechanism  used. An authentication context class represents a set of authentication methods. An  authentication context class reference is an identifier for an authentication context class.  The following sections explain how applications can request a particular authentication  context class and how identity providers can provide claims to convey the authentication  context class reference and or authentication mechanism s  used.   SAML 2.0 A SAML 2.0 authentication request can specify an application’s desired authentication  context class using the   element. A SAML 2.0 authentication  response will show the authentication context class used to authenticate a user in  the   element of the authentication assertion, if the identity provider  provides this information. The application  service provider  and identity provider must  establish in advance the definitions for different authentication context classes. The   163   Chapter 12    Stronger authentiCation  document “Authentication Context for the OASIS Security Assertion Markup Language   SAML  V2.0”v lists several predefined authentication context classes which may be used.   OIDC OIDC clients can request one or more authentication context classes, in order of  preference, using the following parameter to the authentication request:      acr_values – Authentication context class reference  An ID Token issued to an application can contain the following parameters to convey   the authentication context class and authentication methods used to authenticate  the user  subject  referenced in the ID Token.          acr – Authentication context class reference, an identifier for an  authentication context class  amr – Authentication methods reference, the identifiers for one or  more methods used to authenticate a user  The application and OpenID Provider must establish the values and meaning   for acr and amr values used. At the time of writing, there are draft specifications for  standard values for these claims. The draft specification for OpenID Connect Extended  Authentication Profile  EAP  ACR Values 1.0vi lists acr values, and the draft specification  for Authentication Method Reference Valuesvii lists proposed amr values.   Step-Down Authentication To align with the security principle of “least privilege,” one should operate at the minimum  privilege level necessary for a particular task. In an environment where sessions can exist  with different assurance levels or authentication contexts, with higher- level sessions that  enable access to more sensitive resources, users would ideally be able to “step down”  their session’s authentication assurance level when they no longer need the elevated  privileges. This reduces the damage that can be done if a session is hijacked as well as the  risk from simple human error when operating at a higher privilege level. Step-down could  be implemented with an explicit mechanism, though we have not seen this done in our  experience. It is probably more practical to simply rely on short session timeouts for more  privileged sessions as well as user logout for immediate termination of a session.  164   Chapter 12    Stronger authentiCation   Deployment There are a few deployment considerations worth mentioning. Testing multi-factor  authentication mechanisms and the use of step-up authentication with users who are  representative of the target user population is valuable to identify any usability issues  before widespread rollout. Evaluating authentication devices for their durability, and  battery life if applicable, is helpful to avoid unexpected costs for replacing broken  dead hardware devices. Depending on the type of authenticator chosen, you may have  to budget for replacing lost and damaged devices. When replacement is necessary,  you’ll also need a process for quickly but securely replacing lost or damaged devices to  restore a user’s ability to log in. Be sure to plan for secure distribution, replacement, and  revocation of authentication mechanisms as part of any deployment.   Summary Some forms of authentication are considered stronger than others. Passwords are a  relatively weak form of authentication, whereas the use of one-time passwords generated  on a device or multi-factor cryptographic authentication devices involves what are  considered stronger forms. Multi-factor authentication requires the use of multiple  authentication factors, typically something you have as well as something you know.  Step-up authentication is the act of authenticating with a stronger form of authentication  which elevates a previously existing authentication session to a higher level of  authentication assurance. Authorization policy may require a session to be at a specific  level in order to access sensitive resources. Both OIDC and SAML 2.0 allow applications  to request that an identity provider authenticate a user with a particular authentication  context class of authentication mechanisms and to receive information about the  authentication context class and or authentication method s  used to authenticate a user.  It is important to terminate higher-level sessions in a timely manner via shorter session  timeouts or logout, and conveniently, logout happens to be the topic of the next chapter.   Key Points     Static passwords are considered a weak form of authentication.     The compromise of a static password may not be noticed until   damage is done.  165   Chapter 12    Stronger authentiCation      It is harder for remote hackers to impersonate a user when  authentication requires physical devices in the user’s possession.     Multi-factor authentication relies on multiple factors, such as  something you know, something you have, and or something   you are.     Step-up authentication involves authenticating with a stronger    form of authentication to elevate the authentication assurance level  of a session.     Both SAML 2.0 and OIDC allow an application to request an   identity provider use a specified authentication context class when  authenticating users.     To support the principle of least privilege, it may be desirable to have   shorter session timeouts for elevated sessions required to access  sensitive resources.  i.  https:  pages.nist.gov 800-63-3 sp800-63b.html  ii.  https:  pages.nist.gov 800-63-3 sp800-63-3.htmlsec6    iii.  https:  pages.nist.gov 800-63-3 sp800-63b.html  iv.  www.w3.org TR webauthn     v.  https:  docs.oasis-open.org security saml v2.0 saml-  authn-context-2.0- os.pdf    vi.  https:  openid.net specs openid-connect-eap-acr-    vii.  https:  tools.ietf.org html draft-ietf-oauth-amr-  values-1_0.html  values-04   Notes           166   CHAPTER 13  Logout  Great is the art of beginning, but greater is the art of ending.  —Henry Wadsworth Longfellow, American poet and educator, from  “Elegiac Verse”  1881   Logout is probably not something that you think about very often, if ever. It might not  even be on any of your project’s planned sprints, but it should be. Implementing logout  can be more complex to design and test in some cases than login.  For many applications, it’s important for users to have a way to terminate their   session. This is especially true for shared-device environments that are used to access  sensitive applications, like ATMs, kiosks employed on a manufacturing shop floor, or a  medical facility. Terminating a session if it is no longer needed eliminates the chance  that the session can be hijacked by others. This can complement other measures in  a comprehensive security strategy and is beneficial for situations where devices are  stolen or confiscated. In this chapter, we’ll cover why logout can be complicated, what to  include when designing logout, and some implementation options.   Multiple Sessions Logout can be complex to implement in environments with single sign-on, because  there may be multiple sessions to worry about. Figure 13-1 shows three different  scenarios with the resultant authentication sessions for the user in each one. At  minimum, a user has an application session  Model 1 . If an application delegates  authentication to an identity provider  IdP , the identity provider may have an active  session for the user  Model 2 . If an application uses an authentication broker, to  facilitate handling many different identity providers and protocols, the authentication     Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2_13  167   Chapter 13    Logout  broker may also have an active session for the user  Model 3 . This means that a user  could have sessions in up to three different tiers of the solution architecture after logging  in. It is possible for an identity provider to delegate authentication to another identity  provider, so there could be even more tiers involved, but that is not common.  Authenticated user session Authenticated user session  Figure 13-1.  Multiple User Sessions  Logout is further complicated because with single sign-on  SSO , there might be   even more sessions to consider. If a user can access multiple applications via SSO,  there could be an additional session in each of those applications. This possibility is  illustrated in Figure 13-2 which shows a scenario where applications A and B delegate  authentication to an authentication broker, which in turn delegates user authentication  to an identity provider. Application C delegates authentication directly to the identity  provider. If a user accesses applications A, B, and C in short order, the user would have  five active sessions.  Model 1:  Model 2:  Model 3:  168   Chapter 13    Logout  Figure 13-2.  Sessions in Relying Parties   Logout Triggers The termination of any of a user’s sessions can be triggered by several different events.  The most obvious is when a user clicks a logout button in an application. A user may also  be able to trigger a logout of their session directly at an identity provider if it provides  such a feature. In addition to user-initiated logout, an administrator might terminate a  user’s session in either an application or identity provider. Another possibility is that a  user’s session times out if the user has been idle or logged in for too long. Then again, an  application or identity provider may receive a logout request from another component  in the environment. When any of these events occur, one or more of the user’s sessions  will be terminated. The question is – which ones should be terminated and under which  circumstances?  169   Chapter 13    Logout   Logout Options When there are multiple sessions for a user, it is necessary to decide what should happen  when any of the user’s sessions are terminated. Using the models depicted in Figure 13- 1,  if a user’s session in an application is terminated, it may be appropriate to terminate one  or more of the following, depending on where sessions exist:     Application session     Authentication broker session  if a broker is used       Identity provider session  In addition, if a user’s SSO session is terminated at an identity provider or  authentication broker, it may be appropriate to terminate one or more of the      User sessions for the user at any relying parties  applications or other   providers    For example, in Figure 13-2, when the user logs out of application A, the application   could send a logout request to the authentication broker. The authentication broker  may have other applications  relying parties  relying on its session for the user, such as  application B in the diagram. When it receives the logout request, the authentication  broker could send a logout request to application B to terminate the user’s session  there. In addition, the authentication broker could send a logout request to the identity  provider. The identity provider would see that application C relied on its session for the  user and could send a logout request to application C.  The same possibilities should be evaluated if a user’s session is terminated at an  identity provider or authentication broker for any reason. Again using Figure 13-2, if  the user’s session is terminated at the identity provider, it could send a logout request  to application C and the authentication broker because they are both relying parties to  the identity provider. Similarly, if the user’s session is terminated at the authentication  broker, it could send a logout request to the identity provider and or to one or both of the  relying party applications A and B.  In designing logout, it is necessary to consider where sessions exist and which should be   terminated when a user initiates a logout or if their session is terminated for other reasons.  One factor in the decision is the entity owning the sessions. In enterprise environments,  corporate security policy may dictate that a logout in an application must trigger the  termination of an identity provider session and possibly all the user’s open sessions in other  applications. In a consumer-facing environment where a user logs in with a social provider,   170   Chapter 13    Logout  however, it may be less justified or impossible for an application logout to terminate the  user’s session at the social identity provider. Obviously, an identity provider or authentication  broker’s supported features for logout is another factor that will influence logout design.  User experience is an important factor as well. Care should be taken to avoid   surprises for users. Terminating all application and SSO sessions for a user with one  logout provides a convenient way to terminate all access at once. This may be desirable  in an enterprise environment because if users have to log out of each application  individually, they may forget one. However, if the impact of such a logout is not clear to  a user, this may “pull the rug out” from under the user’s other application sessions that  rely on the same SSO session. An example will help illustrate this.  Using the scenario in Figure 13-2, if a user is working simultaneously in the three   applications, A, B, and C, and a logout from application A triggers the termination  of their sessions everywhere, that may prevent the user from completing in-flight  transactions in application B or C. The abrupt termination of sessions in other  applications may cause a user to lose their work there. Whether the user can continue  working in the other applications depends on how logout is implemented.  One possibility is to have the logout in application A trigger an immediate logout of   the user in applications B and C. This would require that the termination of the user’s  session at application A triggers a logout request to the authentication broker, which  is configured to send, upon its session termination, a logout request to application B.  The authentication broker could also send a logout request to the identity provider,  which in turn could send a logout request to application C. These logout messages  would effectively terminate all the user’s sessions across the three applications, the  authentication broker, and the identity provider.  Alternatively, when application A sends a logout request to the authentication   broker, the broker could simply terminate its own session for the user. In this case, the  user can continue working in application B until the user’s session in application B times  out. Upon timeout, application B would check if the user’s session is valid at the SSO  server. If the user’s session in the SSO server had been terminated, the user would need  to log in again to continue to access application B.  The decision regarding which sessions to terminate is specific to each environment   and should take into account the entity that owns a session, the user experience, and  the sensitivity of the application and security benefits of not leaving sessions open if not  needed. Once logout is implemented, it should be thoroughly tested to make sure it works  as designed. The best advice we can give is to allow plenty of time in your project for both  designing and testing logout and to start early, as it may take more time than expected. As   171   Chapter 13    Logout  shown in Figure 13-1, other entities besides applications, such as authentication brokers,  may be relying parties to identity providers. In the subsequent sections, we’ll therefore use  the broader term “relying party” in places instead of “application” to recognize all types of  entities which may be impacted by logout.    Application Logout The simplest case to implement is local application logout, which terminates a user’s  session in one individual application. For application logout, when any of the logout  triggers described in an earlier section occur, the application needs to delete any  application session information, tokens, and browser cookies set by the application. If  using OAuth 2.0 access tokens from an authorization server that supports access token  revocation, they should be revoked via the authorization server’s revocation endpoint.  Refresh tokens, if used, should be revoked as well. Local application logout by itself  does not impact any other authenticated sessions the user might have established at an  identity provider or authentication broker, but an application can choose to send logout  request messages to such other components when local application logout is triggered.   OAuth 2.0 OAuth 2.0 does not contain a logout endpoint because it is designed for authorizing an API  call, not authenticating users. Nevertheless, upon the termination of a user’s session, an  application should clean up security tokens related to the user if possible. An application  may have obtained access tokens for APIs and possibly refresh tokens as well. The OAuth  2.0 specification indicates that authorization servers SHOULD provide a mechanism  to revoke access tokens, and the OAuth2.0 Token Revocationi specification defines a  standard for this. Providing an access token revocation mechanism is not mandatory,  however, so some authorization server implementations may not support this.  If an authorization server supports access token revocation,i an application should   use its revocation endpoint to revoke access tokens authorized by a user for that  application when the user logs out or their session is terminated for any other reason. If  an access token cannot be revoked, an application that has refresh token s  for renewing   172   Chapter 13    Logout  expired access tokens should revoke the refresh tokens. Without a refresh token, when a  previously issued access token expires, the application will not be able to obtain a new  access token.  Applications that cannot revoke access tokens must rely on the access token   expiration to terminate the application’s ability to call an API. This underscores a benefit  of access tokens with short expirations.   OIDC The original OIDC specification does not define an explicit logout mechanism for an  application to request termination of a user’s session at an OpenID Provider or a way  for an OpenID Provider to notify a relying party when the OpenID Provider’s session  has terminated. At the time of writing, however, there are draft specifications for  OIDC logout which bear watching, keeping in mind that draft specifications may fail to  gain approved status or may change before being approved. You should consult your  OIDC Provider’s documentation and plans regarding any draft specifications.  The draft OpenID Connect Session Management specificationii defines a relying   party-initiated logout flow, so that upon logout at a relying party, the relying party can  send a logout request to an OIDC provider to terminate its session for the user. An  OpenID Provider receiving a logout request may confirm with the user that he or she  wishes to log out of the OIDC provider session. This confirmation feature can help  prevent inadvertently terminating a session that may still be required by the user in other  applications.  The draft OpenID Connect Session Managementiii specification also offers a   solution for a relying party application to detect when an OpenID Provider session  has terminated. It is designed to use a hidden iframe loaded from an OpenID Provider  and which has access to browser state from the OpenID Provider. This iframe is polled  from another hidden iframe loaded from the relying party application and will receive  back a status of “changed” if the user’s session at the OpenID Provider has changed. If  this occurs, the relying party application can redirect the user to the OpenID Provider  with a new authentication request using prompt=none, and if this request receives  an error response, it indicates the user session at the OpenID Provider is no longer  valid. The application can then terminate its session for the user, if appropriate.   The draft proposal for an OpenID Connect Front-Channel logout facility iv proposes  a solution for an OpenID Provider to send logout requests to relying party applications   173   Chapter 13    Logout  which could be used to notify them when the OpenID Provider session has terminated.  Front-Channel logout relies on communicating between applications and an OpenID  Provider by redirecting the user’s browser between them. This is less likely to be blocked  by firewalls, but suffers from two disadvantages. If a user has navigated away from an  application in their browser, a Front-Channel logout request to the application will fail,  and the user’s session in the application will only be logged out if the user returns to  it using the browser’s back button. In addition, a failure in a sequence of redirects for  Front-Channel logout can halt the flow before all logouts are completed.  The draft OpenID Connect Back-Channel logoutv specification provides a solution   for an OpenID Provider to send logout requests to a relying party via back-channel  communication between servers rather than via front-channel browser redirects. This  may provide a more reliable logout option than Front-Channel logout when there are  many relying parties. For this solution, relying parties register a back-channel logout URI  with an OpenID Provider. The OpenID Provider remembers all relying parties to which a  user has logged in via their OpenID Provider session. When the OpenID Provider session  for the user is terminated, the OpenID Provider sends a logout request, formatted as  a JWT and called a Logout Token, to each of the relying parties the user visited during  the session. The Logout Token is sent via back-channel communication  server to  server  using an HTTP-POST to the relying party’s back-channel logout URI previously  registered with the OpenID Provider. Upon receiving and validating a Logout Token, a  relying party removes its session for the user and returns a status response to the OpenID  Provider. This solution requires direct connectivity between the OpenID Provider and  a relying party’s back-channel logout URI. This may be problematic for applications  residing in on-premise enterprise environments behind firewalls.  It is also possible for a relying party application to detect the termination of a   user’s session at an OpenID Provider by periodically polling the OpenID Provider by  redirecting a user’s browser to the OpenID Provider with the prompt parameter in  the authentication request set to “none.” If the user does not have a valid session at  the OpenID Provider, an error status response will be returned, and the application  can terminate the user’s session in the application or redirect the user again to  reauthenticate and renew their session. This approach has the drawback that the redirect  interrupts the user experience. Repeatedly polling an OpenID Provider may also run the  risk of hitting rate limits.  A common concern is the ability to quickly terminate a user’s access to an   application. This may be needed in corporate situations if an employee has been   174   Chapter 13    Logout  terminated against their will. If the OpenID Provider for an environment supports  a capability to notify relying parties when a user’s OpenID Provider session has  terminated, this can be used. In the absence of such single logout capabilities, an  application can poll an OpenID Provider periodically as previously described. If the  user’s account in the OpenID Provider has been disabled, the application will not receive  the successful response needed to renew the session. This should effectively terminate  the user’s ability to use the application, at least with a tolerance period equal to the  application’s polling frequency.   SAML 2.0 With SAML 2.0, a service provider application can terminate a user’s session at an  identity provider by issuing a logout request message to the identity provider. Upon  receipt of the logout request message, the identity provider terminates the session it  holds for the user, identified by a subject identifier in the request and possibly a session  identifier for the session. The identity provider may also update or remove its session  cookie in the user’s browser. The identity provider then responds to the application with  a logout response message.  SAML 2.0 also provides a way for the identity provider to notify other relying parties  if a user’s session is terminated at the identity provider. Upon termination of the identity  provider session or receipt of a logout request message from a service provider, the  identity provider can send a logout request message to each of the other relying parties  with an active session for the user. The relying parties are supposed to terminate their  session and respond with a logout response message to the identity provider. If the  global logout was initiated by one service provider, the identity provider returns a logout  response message to the relying party that initiated the logout. This interaction is shown  in Figure 13-3.  175   Chapter 13    Logout  Figure 13-3.  SAML 2.0 Single Logout    1.  User initiates logout at Application 1  a relying party .    2.  Application 1 redirects user browser to Identity Provider with a   SAML Logout Request message.    3.   Identity Provider sends a SAML Logout Request message to other  relying parties, such as Application 2.    4.  Application 2 sends a SAML Logout Response message after   processing the logout.    5.   Identity Provider sends a SAML Logout Response message back to  the relying party that sent the original Logout Request.    6.  Application 1 acknowledges the logout.  Steps 3 and 4 in the preceding sequence are commonly sent via the user’s browser,   using front-channel interaction. Many SAML 2.0 identity providers reside behind  corporate firewalls, and using a front-channel implementation avoids issues with  firewalls. In a complicated logout scenario, however, with several relying parties, the  sequence may fail before it completes, leaving some sessions intact. The SAML 2.0  specification includes a back-channel logout mechanism which may be more reliable  if logout messages need to be sent to multiple parties. However, back-channel logout   176   may not be implemented in all SAML 2.0 implementations, and back-channel logout  messages require direct connectivity between the identity provider and the relying  parties, which may be challenging for components behind corporate firewalls.  Chapter 13    Logout   Session Termination There may be a need at times to quickly terminate a user’s SSO session as well as  application sessions. In corporate settings, this is often a requirement for situations  where an employee is terminated against their will. In the absence of single logout, a  user’s account can be disabled at an identity provider, but they may be able to remain  active in applications with open sessions until the applications next communicate  with the identity provider. In the case of OIDC or OAuth 2.0, this may be when the  application session and or access token expires. In the case of SAML 2.0, it will be  when the application session expires. When this occurs, the application sends a new  authentication request to the identity provider, which will fail if the user’s account is  disabled. If user termination risk is a concern, application session duration and access  token expiration should be set considering the sensitivity of applications involved and  the availability of means to quickly terminate a user’s sessions.   Logout and Multilevel Authentication If step-up or multi-factor authentication is implemented such that it is possible for a  user’s session to be at different authentication assurance levels, based on the strength of  authentication mechanisms used, it should be clear what happens when a user logs out.  A common solution is for logout to completely terminate the user’s session, regardless of  the authentication level it was at. Whatever logout behavior is chosen, it is important that  its behavior be clear to users.   Redirect After Logout A final aspect of designing logout is deciding where to send the user after logout. If  you send the user to an application home page which redirects the user to an identity  provider where the user still has a valid session, the user will be returned right back into  the application with a new session created for them. This effectively breaks the logout   177   Chapter 13    Logout  process and can waste your help desk’s time with complaints that logout doesn’t work.  For a better user experience, you can redirect to a logout confirmation page or a home  page that doesn’t automatically redirect a user to an identity provider. In addition to  carefully selecting where to send a user after logout, you should ensure that redirection  is only done to a list of whitelisted URLs to avoid vulnerabilities stemming from open  redirects.vi, vii Planning appropriate redirect URLs for logout and whitelisting them will  provide a good user experience and avoid open redirect vulnerabilities.   Summary Implementing logout can be more complex to design and test than login. There may be  multiple authentication sessions for a user, and you need to decide which to terminate  when any user session is terminated or times out. In addition to the logout behavior,  designs should specify where to send a user after logout has occurred.  We’ve now covered all the events that happen as a user logs in and out of systems.   At some point in the life of an identity, changes may occur which require identity profile  attributes to be updated. Account management enables that and is the topic of the next  chapter.   Key Points     Logout often takes more time to design and test than login.     Solution designs should specify which authentication sessions   should be terminated when a user logs out.     Designs should specify where to redirect the user after logout.     Single logout can be used to send a logout message to relying party   sessions associated with a user’s identity provider session.     There are draft specifications for logout with OIDC.     SAML 2.0 relying parties can send a logout request to terminate a   user’s session at an identity provider.     SAML 2.0 supports single logout.     The effect and scope of any logout should be clear to users.  178   Chapter 13    Logout   Notes           i.  https:  tools.ietf.org html rfc7009  ii.  https:  openid.net specs openid-connect-session-1_0.html    iii.  https:  openid.net specs openid-connect-session-1_0.html  iv.  https:  openid.net specs openid-connect-  frontchannel-1_0.html    v.  https:  openid.net specs openid-connect-backchannel-1_0.  html    vi.  https:  github.com OWASP CheatSheetSeries blob master  cheatsheets Unvalidated_Redirects_and_Forwards_Cheat_ Sheet.md    vii.  https:  cwe.mitre.org data definitions 601.html  179   CHAPTER 14  Account Management  And yet in our world, everybody thinks of changing humanity and nobody  thinks of changing himself.  —Leo Tolstoy, from “Three Methods of Reform”  It may be true, as suggested by Tolstoy, that people are unwilling to make deep internal  changes, but when it comes to identity information, it is quite common for there to be  changes! In this chapter, we’ll cover the need to support changes to an identity and its  attributes over time.   Identity Attributes A user’s identity information may change over time for multiple reasons. Some updates  will come from users themselves. You should assume that users may need to change  almost any attribute in their profile such as their email address, street address, phone  number, and even their name. Many privacy regulations, including Article 15 of the  GDPR  EU General Data Protection Regulation , mandate that users must be able to  access and correct data about themselves held by a data controller.i If you are a data  processor, you may need to help provide this capability to the data controllers who use  your service.  The need to support identity profile changes depends on where the information is  managed. If your application delegates authentication to social providers, the user may  need to update some profile attributes at the social provider. Similarly, if your application  delegates authentication to an enterprise provider, the user may need to update identity  information there. In addition to updates made by users themselves, administrators or  automated administrative processes may make updates to user identities. These updates     Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2_14  181   Chapter 14    aCCount ManageMent  often impact attributes that are controlled by the owner of the identity provider instead  of the user and may involve attributes used for access control decisions in applications  such as a job level, department, and roles or group memberships.  If user profile data in an application comes from multiple sources, it must be clear  how and where to update each attribute. An application may pull some user attributes  from an identity provider and augment that data with additional data that is collected  and managed by the application. In this case, users need to know where to update  different attributes. Any administrative or support processes for the application will also  need to know how and where to update each attribute.  When user profile data from an identity provider is cached by an application,  the necessary frequency for updating the cache must be considered. When a user  authenticates, the application may receive user profile attributes from the authenticating  identity provider. The application will have the information during a user’s login session  and can cache the information in its own repository for use when the user is offline.   A cache, however, will become stale if information changes at the identity provider  and users do not log in frequently. If up-to-date information is needed in between user  logins, it may be possible for an application to query an API for updated information.  Otherwise, periodic synchronization may be needed. Historically, such synchronization  has been done with proprietary solutions, but the System for Cross-domain Identity  Management  SCIM  protocolii was created to standardize the synchronization of  identity updates across domains, typically between corporate identity providers and  relying parties.  A special case to accommodate is the situation where a user needs to update the   attribute which serves as an identifier for their account at a remote identity provider. If a  remote provider identifier is changed, the next time the user logs in, the application will  receive the new identifier. If the application account or data is tied to the old identifier,  and the user logs in with a new identifier, the user may not be able to access the account  or data associated with the old identifier. The issue can be avoided if the identity  provider delivers to applications an internal identifier that never changes, in addition to  other user profile attributes. Alternatively, if explicit account linking is used, as described  in Chapter 18, a user may be able to unlink the old identity before the change and relink  to the new identity after the change, but this requires forethought on the part of a user  which may not be realistic!  182   Chapter 14    aCCount ManageMent   Credential Reset Users may also need to update their credentials from time to time. An application that  delegates authentication to an identity provider does not have to store credentials or  implement credential reset functionality because the credentials are at the identity provider.  An application can simply provide a link or instructions that point to the credential reset  function at the appropriate provider. If you use an identity provider service, you should be  sure to select one that supports self-service credential update and account recovery.   Account Recovery A user may forget or lose the credential to an account. In the case of a password, the user  may forget it. In the case of authenticators such as a phone or hardware security token,  they may be lost, stolen, damaged, or broken. If this occurs, a user has to prove they are  the owners of an account, via some mechanism other than the original credential, before  being allowed to set a new credential.  In many cases, an application relying on an identity provider may be able to leverage   account recovery mechanisms provided by the identity provider. It then becomes  important to select provider s  with reasonably secure self-service account recovery  mechanisms. Solutions that prompt a user for answers to previously established security  questions are problematic as the answers can often be looked up or guessed. They also  depend on the user remembering the answers, which is not always the case. Schemes  that require users to download recovery codes rely on users saving the codes in a secure  place, which also may not be dependable.  A solution that sends a password reset link to an email address previously registered  with the account avoids the drawbacks of the previous schemes. This depends, however,  on the owner of the account being able to access the email for the email address  associated with the account. Sending a one-time code via SMS to a previously registered  cellphone number in the user’s profile relies on the number being current and the  security of SMS messages. At the time of writing, vulnerabilities persist in Signaling  System 7, which connects different phone networks, that have enabled some researchers  and hackers to intercept SMS messages. Project owners should evaluate the current state  of that issue before deciding to use SMS messages. Enabling users to set up a primary  and one or more backup authentication mechanisms may provide the best defense  against any one of them becoming broken or compromised.  183   Chapter 14    aCCount ManageMent   Password Guidance If passwords are used, you may wish to provide guidance to your users on what  constitutes a good password and, where you have a choice, select identity providers  that enforce stronger password policy. Interesting new research by NIST has examined  the effectiveness of previous password guidelines.iii Security advice in the past has  recommended a mixture of lowercase and uppercase characters, numbers, and special  characters, the longer the better. Users were also advised to change their password  on a regular interval. This advice was designed to make a password hard to guess by  humans or discover by a brute force password guessing approach and mitigate risk from  compromised passwords. This research by NIST suggests that some elements of the past  guidance may not have been as effective as expected.  Their new guidance suggests that the size of a password matters more than the   password complexity as user-selected password complexity is somewhat predictable,  and rate limiting on failed password attempts may be a more effective approach. Users  are recommended to select a long passphrase that consists of several words but is  not a common or guessable phrase. Users are recommended to change a password  if there is evidence it has been compromised but rate limits on failed passwords and  checking for breached passwords may be more effective than forced periodic password  resets. Authentication services should implement rate limiting on failed login attempts  and check username password combinations against databases of known breached  passwords to protect against brute force attacks and compromised passwords. You’ll  want to use identity providers that offer such features.   Helpdesk Reset A manual, helpdesk-assisted credential reset process is expensive to provide and  can expose sensitive information. It requires the helpdesk staff to have knowledge of  secret information with which to validate an account owner. Examples of secrets that  have been used in the past are a portion of a government-issued identity number,  information on recent transactions, or answers to secret questions. This process has the  advantage of providing human assistance, but may expose sensitive information to risk  of compromise. If the sensitive information used to validate an account owner is used at  other sites, a compromise of the information at one site may allow a malicious actor to  take over a person’s accounts elsewhere. For both cost savings and security, self-service  credential reset capability should be preferred for most scenarios.  184   Chapter 14    aCCount ManageMent   Summary Identity information may need to be updated over time. Privacy regulations often  require that users have the ability to view and correct personal information held about  them. Account updates can be handled by identity providers for information managed  by them. If identity information is maintained in both an identity provider and an  application, account update mechanisms must help users make updates in the right  place. Changes to the primary identifier for a user at an identity provider may impact a  user’s ability to access application accounts tied to the old identifier. Credentials need to  be reset if compromised, forgotten, or rendered inoperable, but a user must be validated  before being allowed to reset credentials. An application may delegate credential  reset and account recovery features to an identity provider, but the integrity of the  mechanisms used by the provider should be validated. This brings us in the next chapter  to the final event in the life of an identity, which is deprovisioning.   Key Points     User identity attributes may need to change over time.     Privacy regulations may mandate a process for users to update   identity information.     Account management may be delegated to identity providers when   the attributes to be changed reside at the identity provider.      If a user changes their identifier at an identity provider, it may impact  their ability to access application accounts tied to an old identifier  unless a solution is provided for this scenario.     Credential reset and account recovery may be delegated to identity   providers for many common scenarios, but exceptional cases such as  account takeover may need to involve application owners as well.  185   Chapter 14    aCCount ManageMent   Notes        i.  https:  eur-lex.europa.eu legal-content EN TXT   HTML ?uri=CELEX:02016R0679-20160504&from=EN  ii.  https:  tools.ietf.org html rfc7644    iii.  https:  pages.nist.gov 800-63-3 sp800-63b.htmlappA  186   CHAPTER 15  Deprovisioning  The  boundaries  which  divide  Life  from  Death  are  at  best  shadowy  and  vague. Who shall say where the one ends, and where the other begins?  —Edgar Allan Poe, American author, from The Premature Burial  1844   The final event in the life of an identity is deprovisioning, when an account and  associated identity attributes are deleted or disabled so they can no longer be used.  When an account is terminated, there are several design points to consider related to  how to delete or disable accounts, what identity information to keep, and for   how long.   Account Termination An account may be terminated for several reasons. An account may be deleted by the  account owner if they no longer need to use a service. An account may also be deleted  by an administrator of a service if the account appears to have been abandoned or if  a customer has abused a service in violation of terms of service. With a paid service,  termination may result if a user fails to pay for the service. In a university setting, a  student’s account may be terminated when the student graduates. In a corporate  setting, an account may be terminated if an employee leaves the company’s employ.  Regardless of the reason, upon termination, it is necessary to render the account so  it can no longer be used to access resources. As we will see in the following sections,  simply deleting an account may not be an appropriate solution for this.    Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2_15  187   Chapter 15    Deprovisioning   Best Practices Processes for the deprovisioning of accounts and identity information should be  designed with several best practices in mind. These range from ensuring it gets done  in a timely fashion to protecting against accidental account deletion and from enabling  customers to transfer data elsewhere to satisfying privacy rights and requests for secure  deletion. The exact requirements will vary by environment. This section will describe  many common requirements associated with deprovisioning to help you identify which  might be necessary for your projects.   Just Do It! The best practice for deprovisioning is to make sure it gets done! If an account is no  longer needed, it should be disabled so it cannot be hijacked by an unauthorized user.  Unfortunately, deprovisioning is notoriously overlooked in settings that lack mature  identity management. To minimize the possibility of abandoned or unused accounts, you  should implement automation to trigger periodic account review and deprovisioning. In  a company setting, an HR system may initiate a deprovisioning workflow when a user is  terminated. In a university environment, a student information system may trigger account  deprovisioning upon graduation, at least for access reserved for current students. Even the  best automation fails at some point, however, so a periodic audit of existing accounts is  essential to find accounts that are no longer appropriate so they can be deprovisioned. In  consumer-facing environments, it may be appropriate to consider deprovisioning accounts  which have had no activity for many years.    Provide a Soft Delete Technique Human beings make mistakes. If you provide a “delete account” button, it’s almost  guaranteed that someone will delete their account by mistake. To save yourself  the trouble of restoring customer data when that occurs, you can make it harder to  erroneously delete an account by implementing a soft delete. This can take the form of  a confirmation screen  “Caution: are you sure you want to delete your account? This  cannot be undone!” , and marking an account as deleted while providing a grace period  before the account is truly deleted. During the grace period, an “undelete account”  capability should be available. You can also send a confirmation email at the beginning  of the grace period explaining that the account is marked for removal and will be   188   permanently deleted at the end of the grace period. While not foolproof, this may prevent  some accidental account removals and the work to restore mistakenly deleted accounts.  Chapter 15    Deprovisioning   Reserve Deprovisioned Identities When deprovisioning accounts, it is best to preserve a list of deleted account identifiers  and prevent each identifier from being reused by a new owner in the future. If this is  not done, a new person could create an account with a previously used identifier and  might be able to request historical data associated with that identifier to get data that  belonged to the previous owner of the account. If a deleted account identifier was used  in a single sign-on scenario and was used to access multiple applications, the owner of  a new account with the same identifier might be able to access the previous person’s  data in those applications. This is especially important if an email address is used as the  sole identifier for an account.  See Chapter 4 for why this is problematic.  By reserving  previously used identifiers and checking all new identifiers for uniqueness against both  active and deprovisioned accounts, several issues can be avoided.   Preserve Account Record You never know when unauthorized activity might be detected. It could be weeks or  even months after the fact. Because a fraud investigation may arise at any time, even  after an account has been closed, you should consider whether information should be  kept for a reasonable period of time about deleted accounts, including transactions, the  time they were submitted, the accounts that performed them, identity data linked to the  accounts, and any other information needed for forensic evidence. When an account is  deleted, it may be appropriate to preserve some account identity information along with  the date, time, and reason why an account was disabled or terminated. If an account is  terminated due to abuse, keeping sufficient records may help identify if a user attempts  to open another account, at least with the same identity data.  One caveat is that privacy regulations require that data be kept only as long as  needed for legitimate business purposes, and users have the right to request that  personal data about them be erased. These rights may conflict with the need to have  backups and audit logs. In practice, approaches are being worked out to satisfy the  intent of privacy rights as well as operational system needs. Such approaches include  minimizing data that is retained, encrypting and restricting access to retained data, and   189   Chapter 15    Deprovisioning  following defined data retention policies and procedures. Such policies and procedures  should be created with guidance from legal and privacy advisors to ensure alignment  with best current practices.   Data Transfer It may be helpful or even required to provide customers a means to download or transfer  data out of your service. Users may have this right as part of privacy legislation, such as  the GDPR  General Data Privacy Regulation . Providing such a feature may also make  customers who worry about vendor lock-in more likely to sign up because they know  if they are unhappy, they can take their data and go elsewhere. Corporate customers  will often request the ability to periodically obtain an extract of all their data to protect  themselves against a vendor failure.  For consumer users, the most scalable option is to provide a self-service means  to download customer-owned data. The feature to download data can be shown in  the “Delete account” process as an option before the account is deleted. You should  consider the data formats that will be most useful to customers. For sensitive data,  you should have a procedure to validate the requestor before providing a data dump.  Requiring step-up authentication or at least reauthentication to obtain the data is  one good precaution. This protects a user’s data if they have walked away from their  keyboard without locking their screen.  For corporate or business customers, there are a few more points to consider. It  may make sense to require the involvement of two people from the customer in the  request process to prevent a lone actor from downloading sensitive corporate data for  unauthorized purposes. Once suitable customer validation is obtained for the download  request, it should be provided in the most direct, self-service manner to minimize the  service provider’s access to the customer’s data. For example, if a data dump were  done manually by the service provider, it might be downloaded to a person’s laptop or  transferred to the customer by a channel that introduces risk.  For corporate customer data that involves user identities and passwords, the   passwords should have been stored in a hashed format and may not be usable elsewhere  if different hashing functions are used. Chapter 4 discusses options for migrating user  identity data between systems. As with consumer users, thought should be given to  the data format for a transfer as well as the security of the transfer process. Even if a  customer is leaving, providing a good experience may keep a future opportunity open.  190   Chapter 15    Deprovisioning   Privacy Right to Erasure When a user deletes their account, it may not be enough to simply delete data your  own service holds about a user. Article 17 of the GDPR provides consumers the right  to erasure, commonly referred to as the right to be forgotten, which enables a user to  request that an organization delete the data it has about the user. Under Article 19 of  the GDPR, data controllers are obligated to communicate an erasure request to any  data processors to whom they’ve given personal data. Users who wish to delete their  account may wish to exercise their right to erasure, which may require deleting data in  an application’s user repository and possibly other data processor services.  It should be noted that the right of erasure does not nullify other obligations a   business or organization may have that require keeping records, including those which  contain personal information. Article 17, paragraph 3, of the GDPR outlines several  situations where the right of erasure does not apply. These include the fulfillment of legal  obligations on the part of a data controller or processor, supporting rights for freedom of  information and establishing, exercising, or defending legal claims. Financial institutions  may have legal obligations to retain records with personal information for a period of  time after an account is closed. Healthcare organizations often are required to retain  healthcare-related records for a period after the date of service. Even small businesses  have legal obligations to retain employment and tax records for a period of time.  Balancing privacy rights and other legal obligations can be complex, so organizations  should define a data retention policy and procedures for handling erasure requests, in  consultation with legal and privacy experts.   Certificate of Deletion In addition to having procedures for disabling and terminating individual user  accounts for privacy reasons, corporate customers that terminate their use of a service  may request that their corporate account be deleted. This can include the user data  of administrative users associated with the account, application data related to the  service, and user data. Customers may request a certificate of deletion that states that  all their data has been deleted. If sensitive data is involved, including data about users,  customers may request a certificate of secure deletion. This demonstrates due diligence  to ensure data they’ve given to vendors deleted when no longer needed, which helps  protect sensitive information.  191    Deprovisioning  Chapter 15   Secure Delete It can be surprisingly complex to “completely delete” data. Simply issuing a delete  command in a database or to delete a file may not completely delete the data. In some  cases, such a delete simply removes pointers to the data, but does not alter the space on  the disk where it was stored, allowing specially written tools to recover the data.  Various techniques have been employed to effect secure deletion. One approach  is to encrypt data and throw away the encryption key. This effectively deletes the data  because it can no longer be decrypted. This approach assumes the time required to  decrypt the data using brute force mechanisms is significantly longer than the time  during which the data is likely to be valuable to data thieves. Since it is impossible to  predict how long this assumption will be true, this is not a best option.  Another method of deleting data from a disk or other magnetic storage media   involves degaussing a disk. Information is stored on disks by magnetizing the surface of  the disk with small pulses of electricity as the read write head of the disk passes over it.  A disk can be erased with a special tool called a degausser which generates a powerful  magnetic field that scrambles and removes magnetic fields on a disk. This method  may be feasible when all information on a disk needs to be removed, as when the disk  will be completely decommissioned from use. A drawback is that degaussing, as with  physical destruction of a disk, may render the disk unusable and contribute to e-waste.  Degaussing to remove only one customer’s data is also not feasible in a cloud service  where many customers’ data resides on the same disk.  When a disk stores data of many customers, one customer’s data can effectively be  erased by overwriting the data with random 0s and 1s. The question is how many times  the data must be overwritten in order to ensure that residual magnetic traces do not  allow data recovery. The US Department of Defense  DoD  5220.22-M protocol has been  cited for this. The 1995 version of this standard indicated data should be overwritten  three times. This is now considered obsolete however.i For specific sanitization details,  it has been superceded by the National Institute of Standards and Technology’s  NIST   “Special Publication 800-88: Guidelines for Media Sanitization” which indicates that for  most of today’s media, overwriting with a fixed pattern, such as all zeros, with at least one  pass is sufficient.ii This technique would require a service to create features to perform  the overwriting. Requirements for secure delete may vary by industry and country so  researching requirements for your target customer base will provide the best guidance  on secure account deletion expectations.  192   Chapter 15    Deprovisioning   Consider Reprovisioning Requirements It may be worth considering the likelihood of requests from customers to reprovision  their previously deprovisioned account and establishing policies for this. It would  constitute a security breach if an account were reprovisioned and given to someone  other than the authorized owner, so one option is to not support reprovisioning. If  reprovisioning is to be supported, you’ll need procedures for validating that a requestor  is an authorized owner of the account. Any practices to support this should also be  aligned with applicable privacy legislation.   Summary When a relationship with an employee or customer ends, you may need to do more than  just delete their account. You may need to preserve the identifier for the account and  prevent it from being used again by someone else. You should flag what data elements  are required for audit purposes and create a data retention plan in compliance with both  privacy and legal advice. You may also need to satisfy requirements for secure delete  procedures and provide certificates of deletion.  We’ve now covered the key events in the life of an identity that your implementation   will likely need to support. Since it is common during an implementation to need to  troubleshoot a few issues, the next chapter covers advice on troubleshooting techniques  for authentication and authorization issues.   Key Points     Deprovisioning deletes or disables an account and associated   identity information so it can no longer be used to access protected  resources.     Deprovisioning may be initiated by either an account owner or the   owners of a service where the account resides.     Automation and periodic account review should be used to help   identify accounts that are no longer needed.     A soft delete feature can be used to reduce accidental account   deletion.  193   Chapter 15    Deprovisioning      Identifiers for deprovisioned accounts should be reserved and not  used for new accounts.     Data retention policies and procedures should be developed in   consultation with legal and privacy experts.     Procedures may need to be created to enable customers to download   their data for use elsewhere, as part of account deprovisioning.      It may be necessary to provide customers a certificate of deletion or  to follow secure delete procedures as part of account deprovisioning.     Policies should be created for whether reprovisioning of accounts is   allowed and, if so, the procedures to follow.   Notes        i.  www.dami.army.pentagon.mil site IndustSec docs 5220.22m.pdf  ii.  https:  csrc.nist.gov publications detail sp 800-88    rev-1 final  194   CHAPTER 16  Troubleshooting  When  you  have  eliminated  the  impossible,  whatever  remains,  however  improbable, must be the truth.  —Sir Arthur Conan Doyle, British author, from   The Sign of the Four  1890   You’ve created your application, fired off your first authentication, and your hard work  blows up in a roaring flame of error messages… or worse, nothing happens, no error  messages are displayed, and you don’t have a clue where to start looking! Fear not, there  is a methodical approach to debugging authentication and authorization issues. We’ll  share an approach, tools, and techniques, and soon you’ll be solving authentication and  authorization issues with the mastery of Sherlock Holmes!   Get Familiar with the Protocols A working knowledge of the identity protocol s  you are using for authentication and API  authorization is helpful. These protocols involve browser redirects and or HTTP requests  responses between several components. Troubleshooting will be easier if you are familiar  with the expected sequence of interaction for a particular scenario. You can capture  an HTTP or network trace for a situation and compare it to the expected interaction as  described in a protocol specification and or identity provider documentation, to identify  where things are going wrong. It is particularly helpful to know     The sequence of interaction for different scenarios     The parameters expected by each protocol endpoint     The responses and error codes returned by each endpoint    Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2_16  195   Chapter 16    troubleshooting  In addition to the protocol specifications, you should know the identity provider APIs   and SDKs you are using. Vendors may extend a specification when they implement a  protocol. Using an API testing tool to try out calls with various parameters and observing  the results can give you a better understanding of the identity provider and APIs you use,  which can help when debugging issues.   Prepare Your Tools The following tools will help you debug an issue:      An environment where you can duplicate a problem and test     Two independent browser windows     Tools to capture and view HTTP traces     A tool with which to test API calls     Tools to capture and view network traces of back-end API calls     Tools for viewing and creating JWT and SAML 2.0 tokens  The next few sections will explain why each tool is necessary in more detail.   Test Environment It is often helpful to have an environment in which to duplicate a problem. For some  issues, you may be able to use your production environment to collect all the data  you need. For others, you may need an environment where you can experiment and  change settings as part of your investigation. You’ll need a test environment with an  instance of the identity provider used and with an account for a test user. Ideally, you’ll  have administrative access so you can alter configuration settings or create users with  different profiles if needed. Having a test environment in which to test and debug an  issue avoids any impact to your production system from debugging activity.   Independent Browser Windows In addition to a test environment, it is helpful to bring up two independent browser  windows. You can use two different browsers or two windows for the same browser with  “Private” or “Incognito” browsing mode so they do not share cookies between them.   196   Chapter 16    troubleshooting  One browser window is for testing the broken login issue as an end user. The other  browser window is for accessing the administrative interface of your identity provider or  application to make configuration changes. Independent browser windows ensure that  activity in one window doesn’t impact the other window and give you confusing results. It is also necessary to note how each browser handles sessions, particularly whether  it will save or reconstitute a previous session. When testing, it is best to start with a clean  browser session, unless the issue you are debugging does not occur with a new session.  A new browser session ensures that there are no cookies or state from a previous session  to confuse results. Browsers now offer the ability to restore state from a previous session  so it is best to use a new “Private” or “Incognito” browser session and start with a clean  slate each time.   Capture HTTP Traces You’ll need a browser with the ability to capture an HTTP trace. Google Chrome and  Firefox both offer dev tools features that provide a built-in ability to capture an HTTP  trace in the “Network” tab. Internet Explorer also has a built-in HTTP trace capability,  accessed by pressing F12. Safari’s Web Inspector, accessible via the “Develop” menu  option, enables you to capture network activity in the Network tab. Learn how to capture  an HTTP trace in every browser that your service officially supports so you are prepared  to debug issues on each browser.  If you are collaborating with others, it is convenient to be able to dump the HTTP   trace to an HTTP Archive format file  .har file . A .har file will capture everything,  including the cleartext value of any secret  client secret, password, API key, etc.   entered or transmitted during the capture. If you can’t avoid capturing a secret by  limiting a trace to only a part of the interaction, you should reset the secrets after capture  so you don’t expose valid secret s .   View HTTP Traces If you receive an HTTP Archive  .har  file from someone else, you’ll need a tool to view  it. A list of HTTP trace and .har file viewers as well as other useful debugging tools is  included in Appendix E. The ability to view traces sent by others is useful if you cannot  duplicate a problem yourself.  197    troubleshooting  Chapter 16   Make API Calls Another valuable tool is an API client explorer that allows you to create and send API  calls. This provides a convenient interface for learning, debugging, and testing API calls  for identity providers as well as your own APIs. Vendors of identity services  or authors  of other APIs  may provide ready-built packages with calls for their APIs that you can  import into such tools. Appendix E lists some current tools in this category. You can use  such tools to test and debug individual API calls which can facilitate finding the source of  problems.   View API Calls If you make API calls from a back-end application component or native application, you  will need a different mechanism to capture the calls as they do not go through a browser.  You can use a network web debugging proxy tool or a debugger. Appendix E lists a few  tools for this purpose.   View JWT and SAML 2.0 Tokens A tool to decode and view the security tokens received by your application is essential.  Appendix E lists a few sites which are useful for viewing JWTs and SAML 2.0 requests  responses. These tools will allow you to inspect the contents of the tokens. They may also  provide you with a way to create test tokens for sending to APIs for tests. With these tools  in place, you’re ready to start debugging.   Check the Simple Things You may save yourself some time by checking a few simple things before diving into a  detailed analysis:     Check the identity provider is accessible and not experiencing an      Check the credentials supplied are correct for the environment  test   outage.  vs. production .  198   Chapter 16    troubleshooting     Check the login account and credential are not disabled or expired by   logging in to the identity provider through another application.     Check the application is using the correct URL for the identity   provider.  identity provider.     Check the client ID in the application matches that registered in the      Check the redirect callback URL for the application matches the URL   registered in the identity provider.     Find any error messages to see if they provide valuable clues.  Once you’ve checked the simple things, if the issue is reported by someone else, ask  questions to understand the problem so you can replicate it or focus your debugging on  the most likely spot. Start by asking for a general description of what happens, followed  by questions to elicit more details on what the user did so you can replicate the situation.  Be sure to ask about any error messages displayed on the screen or in any log files. Also  ask what the user expected, because sometimes users can have an incorrect expectation  of how a system is supposed to work!   Gather Information Troubleshooting is facilitated by knowing what questions to ask. Identity solutions  involve many components, including your application, the user’s browser, and an  identity provider. There may also be APIs or an authentication hub in the mix. Any of  these components could potentially contribute to a problem. The following questions  will give you useful information to replicate the problem and or narrow down the  possible source of an issue.   How Many Users Impacted? Is the issue experienced by all users or just a few? If only a few users, the issue is most  likely caused by something unique to those users’ profiles or their environments, such  as browser configuration settings. On the other hand, if all users experience an issue, it  is probably caused by something in the components common to all users, such as the  application or the identity provider.  199    troubleshooting  Chapter 16   Contributing Environmental Factors? Does the issue occur with all browsers, devices, locations, or platforms or just one?  Testing with different browsers, devices, locations, and platforms can identify if there  are any environmental factors contributing to the issue. If an issue occurs in multiple  environments, it is probably not caused by an environmental factor, and debugging  should focus on other components such as the application or identity provider. If,  however, an issue occurs on only one browser or type of device, your inquiry should  focus on whether the browser or device could cause the issue.   Which Applications Impacted? How many applications does the issue affect? If there are multiple applications  involved in a scenario, it can be helpful to test each to see if the problem occurs in all  of them or just some applications. If all applications experience the issue, the problem  may be caused by an issue at the identity provider. If only one or some applications  experience the issue, it is probably caused by the application code configuration or the  configuration for the application s  at the identity provider.   Consistent or Intermittent Issue? Does the problem happen consistently or only intermittently? An intermittent problem  will be easier to debug if you can reduce it to a problem you can reliably reproduce. Try  checking where one instance of a component out of several could be misconfigured,  such as one application server or one firewall instance out of several. Shut them all down  and start them one at a time to see if the issue occurs consistently with one.   Worked Previously? Does the issue occur in an application that worked previously but suddenly stopped  working? If so, check for recent changes, such as the following:      Identity provider outage     Network connectivity issue     Change to identity provider API or API used by the failing application   200   Chapter 16    troubleshooting     User password expired     Recent software upgrades     Recent browser or device configuration changes     Certificate expiration or key rotation     Servers with incorrect time due to NTPi not running  These are common causes of failures of previously working systems.   Where Does Failure Occur? How much of the authentication and authorization sequence of interaction completes,  as observed during a login transaction or in an HTTP network trace? Noting where the  interaction stopped often suggests which component to investigate first.    Replicate the Problem If the issue is reported by someone else, it is valuable to replicate the problem in your own  environment. This can determine if the other person’s environment contributes to the issue.  It also provides a test environment in which to try different things to gather more information  about what causes the problem to appear. This is particularly useful if the person reporting  the problem is unable or unwilling to test different scenarios to aid debugging.   Analyzing an HTTP Network Trace An HTTP or network trace of a broken scenario is invaluable for debugging. In this  section, we’ll describe what to look for in a trace.   Capture a Trace A trace of HTTP and API calls will be one of the most valuable debugging aids. Using  a debugger or other tracing tool, perform the failing authentication, authorization, or  logout transaction starting from the beginning and going as far as you can through the  sequence. When done, stop the trace to minimize the capture of irrelevant data. If you  receive a trace captured by someone else, use a suitable tool to view it.  201    troubleshooting  Chapter 16   Check Sequence of Interaction The first thing to check is the sequence of redirects or API calls to see how much of the  expected interaction succeeded. The sequence diagrams in earlier chapters may be helpful  for this. For OIDC or OAuth 2.0, look first for a call to an “authorize” endpoint on the  authorization server. For SAML 2.0, look for a “SAMLRequest” message to the SSO URL of  the identity provider. Then look for the requests to prompt the user to log in and for a redirect  or response back to the application after the user has authenticated. For OIDC OAuth 2.0,  this will be to one of the callback URLs configured in the authorization server. For SAML  2.0, this will be a SAMLResponse message to the ACS  Assertion Consumer Service  URL  configured in the identity provider. If you do not see the complete sequence of expected calls  and responses, the place where the interaction started to deviate from normal is a clue for  where to start looking for issues. Table 16-1 provides some symptoms and possible causes.  Table 16-1.  Symptoms and Issues  Symptom  Possible Causes  user never redirected to identity provider. application has incorrect url for identity provider.  user redirected to identity provider but no  login prompt.  application sent malformed request. incorrect client iD or client secret. error in identity provider login page configuration.  user prompted to log in but receives error. user error. test with a different account.  user password has expired. Wrong password for environment. user account does not exist. identity provider lost connection to data store.  incorrect or invalid callback url for application at  authorization server  oauth 2.0 oiDC .  incorrect assertion Consumer service url for  application at identity provider  saMl 2.0 .  tokens or assertions returned to application are  malformed or do not contain information expected by  application. exchange of authorization code for token fails. application not granted necessary scopes.  user logs in without error, but not  redirected back to application.  user redirected back to application but  receives authorization error, or application  content doesn’t display.  202   Chapter 16    troubleshooting   Check Parameters in Requests Check the parameters in a request. For OAuth 2.0 or OIDC, check the following:     Request is sent to the correct endpoint at the authorization server.     Correct response_type used for the desired grant type or flow.     Scope parameter value is adequate for the requested action.     Callback URL matches what is registered in the authorization server.     A state parameter value is specified, if required by authorization server.  For SAML 2.0 requests, check the following:     Request is sent to the correct URL at the identity provider.     Request specifies the binding for a response, if required.     The correct certificates and public keys have been configured.   Check HTTP Status Codes The next step is to check the HTTP status code on the response from the authorization  server or identity provider. Table 16-2 lists some common HTTP status codes for error  scenarios and some possible causes.  Table 16-2.  HTTP Status Codes and Possible Causes  HTTP Status Code Possible Causes  400  401  403  500  503  Malformed request. Check your request has the correct parameters and valid  values for them.  unauthorized. Check the application or user has the necessary privileges for  the request.  Forbidden. Check the application or user has the necessary privileges for the  request.  internal server error. Check the configuration at the authorization server or  identity provider.  service unavailable. Check if the authorization server or identity provider service  is running and reachable.  203    troubleshooting  Chapter 16   Check Security Token Contents If the HTTP status code does not indicate there is an error, check the security token s   returned. Appendix E lists tools for viewing the contents of these security tokens. Check  the relevant security tokens to see if they are formatted correctly and they contain the  requisite information.  For ID Tokens, check          ID Token contains the correct user information in the “sub” claim.  ID Token contains any other claims expected by the application.  For Access Tokens that can be viewed, check     Scopes granted to the application are adequate for the request.     Access token contains any claims needed by an API.     Audience for the token is correct for the intended recipient API.     The access token is valid and has not expired.  For SAML 2.0 SAMLResponse messages:     Subject, Name identifier element contains a user identifier expected   by the application.      Additional attribute statements expected by the application exist.  An application may need information for authorization conveyed in custom claims.   If such authorization data is missing from an ID Token or SAML 2.0 assertion, the  user may get an “unauthorized” message or possibly a blank screen. If an API you call  requires custom claims in an access token, your program may get an error status from  the API. You should check the contents of the access token if possible. If the access  tokens are in JWT format, they can be viewed in a JWT viewer. If they are opaque strings,  however, you may need to use an introspection endpoint on the authorization server  to get information about the token. If the contents of the security tokens are correct,  another possible cause of issues is a problem validating a security token.  204   Chapter 16    troubleshooting   Check for Security Token Validation Errors After an application receives a security token, it must validate it. The security tokens  returned by OIDC and SAML 2.0 are digitally signed. They may also be digitally  encrypted. If an application cannot validate the signature on a security token  or decrypt  it if encrypted , it should log an error. Checking application logs for such errors can help  identify if this type of issue exists.  Errors with security tokens can also occur at identity providers. One identity provider   may delegate authentication for a user to another identity provider. If the first identity  provider does not receive a valid authentication token from the remote provider, it  should log the authentication failure. Identity provider logs should be consulted if errors  seem to originate at the identity provider as these logs will often have the most useful  information.  The previous sections describe a series of troubleshooting steps that will help you   solve many common causes of authentication and authorization issues. A frequent  complication with troubleshooting is that you may not own all the pieces. In such cases,  you need to collaborate with others.   Collaborating with Others If you are not able to test the application personally, or can’t replicate the problem, you  will need to ask someone who can replicate the problem to capture a trace of the issue. A  .har file or network trace can show interactions between an application and an identity  provider as well as an API if used. This can include the requests made, the parameters,  the timing of such interactions, and the responses received. Such traces are extremely  useful for debugging issues with authentication, SSO, and authorization. When you  receive a trace file, you’ll need a viewer suitable for the type of trace captured. Appendix  E includes a few such tools.  You should remember that a trace may capture sensitive data, including a username   and password typed by a user or sensitive security tokens returned to applications. If  someone sends you a trace file, you may wish to warn them about this so they can reset  a captured password or invalidate any sensitive tokens. This can reduce your liability.  Furthermore, invalidating any long-lived tokens captured and deleting trace files when  you are done troubleshooting is another good practice.  205   Chapter 16    troubleshooting   Summary This chapter described tools and approaches useful for troubleshooting many common  issues. It helps to know the protocols you are working with and to have debugging tools  that give you sufficient visibility into the authentication and authorization interactions  of your program. Collecting data about where and when the problem occurs can narrow  down the possible source of an issue. An HTTP trace, network trace, or debugger can  help you analyze the flow of traffic between components as well as the parameters in  the requests and responses. By obtaining the right tools, and asking the right questions,  you can speed up the process of debugging an issue. This completes the set of chapters  on building and debugging the code for your application. The next chapter covers some  things which can go wrong beyond the code and for which you should prepare.   Key Points     Develop a working knowledge of the specifications for the identity   protocols you use.     Prepare a suite of debugging tools.     Check the simple things first.     Gather relevant information about the problem.     Replicate the problem in your own environment if reported by      Use an HTTP or network trace to help identify where a problem   someone else.  occurs.     Check the list of symptoms and causes in this chapter.     Check for error responses from identity providers.     Check application and identity provider log files, if possible, for clues.     i.  www.ntp.org ntpfaq NTP-s-def.htm   Note  206   CHAPTER 17  Exceptions  An ounce of prevention is worth a pound of cure.  —Benjamin Franklin, American founding father, inventor,   politician, diplomat, scientist, and printer, from a letter to   The Pennsylvania Gazette  1735   The previous chapters have covered many cases where things happen as expected.  There are times, however, when failures occur or things don’t go as planned. Situations  involving exceptions require planning to handle them well. Examples include  accidentally deleted data, lost phones, system outages, or even a large-scale compromise  of user credentials. We can’t predict every problem your project may encounter, but  this chapter should provide you with a list of exception scenarios that might apply to  your environment. You can select which you’ll need to handle and define a process for  handling them. We recommend starting with the scenarios that are most likely as well  as those that would have the biggest negative impact if they were to occur. With a plan in  place, your team can respond quickly and effectively if one of these situations arises.   Accounts The cases in this section apply primarily to accounts and may require some human  involvement to assess risk or perform due diligence evaluation of a request.   Data Restore A customer may inadvertently delete their account data and then regret it. The likelihood  of this occurring can be reduced by requiring confirmation before deleting data and  implementing a soft delete as described in Chapter 15. If you support requests to restore     Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2_17  207   Chapter 17    exCeptions  deleted accounts, you should develop policies and secure practices for such requests so  they don’t provide an opportunity for a social engineering exploit. Procedures should  include evaluating the requestor, the timing of the request, and the nature of the request.  The requestor should be validated as a legitimate registered owner or administrator of  the account in the request. Requests made weeks or months after the data was deleted  or to restore data into different accounts with different owners probably need higher  scrutiny. For business accounts with multiple administrators, it may be appropriate  to require confirmation of requests from a second person. The details will vary by  application, but you’ll want to define policy and procedures to ensure unauthorized  parties cannot get access to data via data restore requests.   Account Decommission A request to terminate an account carries risk similar to a data restore request. You  need a means to validate that the person initiating such a request is legitimately  entitled to terminate the account. For consumer-facing accounts, a self-service  account decommission feature may be sufficient. Such a feature may be needed as  part of supporting privacy requirements as well. For corporate accounts with multiple  administrators, it may be useful to require a request by two authorized administrators  or implement a delay coupled with confirmation notices to all administrators in order to  prevent an unauthorized, malicious action by one disgruntled employee. Chapter 15 has  further guidance for account decommissions accompanied by requests for account data  transfers.  Also in Chapter 15 is guidance to reserve the account identifier for accounts which   have been decommissioned. It should not be possible for someone to create a new  account with the same identifier as a previously deleted account and then request the  restoration of data from a time when the original account existed. The use of an email  address as account identifier does not mitigate the risk because email addresses have  been recycled by some providers in the past.i Reserving the account identifier for a  decommissioned account for a period longer than the data retention period for backups  of deleted account data mitigates this risk at least for the local system.  208   Chapter 17    exCeptions   Orphaned Account Although rare, the person who established an account may be terminated from a  company or decease. If they were the only person associated with the account, someone  not previously associated with the account may request access to it. The legitimacy of a  requestor making such a claim needs to be validated before they are given access to an  account. For a corporate account, it may require obtaining a contact from the company’s  web site to help in validating that a requestor is a legitimate representative for the  company and authorized to take over the account. Be sure to obtain requests in writing,  validate the authenticity and authorization of requestors through independent channels,  and keep records of all requests, validation steps, and actions.  When a user of a consumer-facing site has passed away, policies vary. Some social   media sites allow family members to request an account be terminated or memorialized.  Estate executors can direct the disposition of some types of accounts such as financial  accounts. Until legal guidelines and practices governing online data and digital  inheritance mature, you should obtain legal guidance for accounts involving financial  value. For other accounts, allowing a user to specify a contact authorized to take over an  account in the event of death may be helpful.   Account Takeover The legitimate owner of an account can be locked out of their account as a result of a  compromised password, stolen phone, social engineering, or software vulnerability. If a  user calls your helpdesk and claims their account has been taken over by someone else,  you will need a process for determining the legitimate owner of the account, bearing  in mind that an unauthorized user could have viewed account details and changed  user profile information as well as passwords after taking over the account. In this case,  the legitimate owner may look like an imposter because they won’t know the current  password or profile information. Maintaining a history of past profile information  such as email addresses, not displayed in the application user interface, may help in  validating a locked-out, legitimate account owner.  209    exCeptions  Chapter 17   Phone Lost, Damaged, or Stolen If your site uses an authentication mechanism that leverages a user’s mobile phone,  you will need a process to help customers whose phone is lost, stolen, or damaged.  Depending on the authentication mechanism, a user might need to deregister an old  phone and register a new one with their account and or install an app on their new  phone. If a user’s phone is stolen and open at the time of the theft, the user’s account  may be accessible by the thief. For this case you’ll need a process to help the legitimate  owner of an account terminate the phone’s access to their account.   Identity Providers This section covers cases which may involve an identity provider.   Account Recovery Requests To assist users who’ve forgotten their password or lost a device needed to authenticate,  an identity provider may provide an account recovery mechanism. One option is  sending a “Magic Link” to a previously registered email address for the account. A magic  link is a non-guessable URL that is valid for a single use within a short time period and  allows a user to bypass authentication to access a credential reset feature. The use of  a magic link can be combined with a confirmation email indicating a credential was  reset, with instructions for what to do if this action was not taken by the legitimate  account owner. With a magic link, the user’s access to their email becomes a backup  authentication factor for account recovery.  Alternate forms of authentication can serve as a secondary authentication factor   as an alternative to relying on the security of a user’s email account. Sending one-time  codes via Short Message Service  SMS  text messages to a user’s previously registered  phone number has been a common solution. At the time of writing, however, there  have been some successful attacks based on intercepting SMS messages.ii, iii Future  projects should evaluate the threat posed by this issue before selecting an SMS-based  approach. Other approaches use a mobile app or a specialized device to generate a one- time code. An identity provider that supports multiple authentication mechanisms and  having users set them up can improve your ability to quickly adapt if one mechanism  becomes compromised.  210   Chapter 17    exCeptions  An identity provider’s account recovery mechanism can open up other risks,  depending on how it is implemented. A password reset link which immediately  invalidates the current account password could enable a person to lock someone else  out of their account. If the legitimate owner of the account has not kept their email  address up to date, they will not receive the password reset link and be locked out of  their account. A password reset link could even be used by pranksters to trigger an  account recovery SMS message or phone call in the middle of the night to wake someone  up! If a user’s email account has been compromised, a hacker could use a password  reset feature to trigger password reset emails and gain control of the user’s accounts that  use that email address. Approaches to mitigating these risks include requiring some  information from the user before triggering an account recovery action, reminding users  to keep their notification information current and not invalidating a current credential  until a reset link has been activated.   Brute Force Attacks In a brute force attack, a hacker attempts to log in with many different username  password combinations in hopes of guessing a user’s password. They may use common  or known breached passwords, and their attempts are often automated. An identity  provider can reduce the chances of brute force attacks succeeding by detecting a series  of many successive failed login attempts or failed password reset attempts against  one account from the same IP address. If either of these situations occurs, an identity  provider can slow down an attacker by techniques such as blocking an account for a  short time period or asking for multi-factor authentication  if configured . An alert can  be sent to the site administrator and an email sent to the owner of the account to alert  them about the attack. The email can indicate why the account was blocked and provide  a link for unblocking the account immediately in case the failed logins were caused by  the legitimate account owner.  If an identity provider detects a series of failed logins or failed password reset   attempts hitting multiple accounts from a single IP address, this is more suspicious, and  it may be appropriate to simply block that IP address immediately. However, corporate  customers with many users whose traffic comes from the same IP address due to  network address translation  NAT  are an exception. If enough users on the internal  network mistype their password in a set time period, it could trigger a false alarm for a  brute force attack. Whitelisting IP addresses for environments using NAT helps avoid  false alarms for brute force attacks in this case.  211   Chapter 17    exCeptions  One additional caution involves environments with an automated system that will  access a user’s account using their credentials. If the user changes their password, but  the update is not provided to the automated system, it could trigger the brute force  attack response. Reviewing an environment for such cases can prevent wasting time due  to false alarms.   Breached Passwords Breached passwords are being aggregated into massive databases that can be exploited  by hackers, including one discovered by breached identity curator 4iQ containing  1.4 billion breached, cleartext passwords.iv If a user’s password at your site is easily  guessable or has been compromised elsewhere, it could enable a hacker to take over the  user’s account on your site. Fortunately, there are databases on the Internet containing  information on breached passwords, such as “have i been pwned”v created by Troy Hunt.  An identity provider can check a user’s password against such databases when they sign  up for an account or reset their password. If the user’s password has been breached, the  identity provider can notify them and have them select a different password. An identity  provider can perform such checks when a password is initially set, at password reset, and  periodically when users log in to detect if a password has been compromised after being  set. These actions will help detect, and mitigate the risk of, breached passwords.   System Outages Evaluating the impact of identity system failures on support systems and administrative  access is recommended as part of business continuity planning.   Authentication System Outage It may be desirable to use the same authentication service for your primary web site  and a support site, so users have single sign-on  SSO  across the sites. However, if the  authentication service is unavailable, users will be locked out of both sites. It can be  annoying for customers if they are unable to access a web site and then realize they can’t  report the problem! If you have this scenario, you should plan for how to handle support  in the event of an outage to your authentication system.  212   Chapter 17    exCeptions  One approach is to rely on proactive outbound communication during an outage.   Some mechanisms to consider include a support phone number with a recorded  message to acknowledge the issue and provide updated information or a public  community support forum or status page where outage updates can be posted. In  designing processes for business continuity during an outage of an authentication  system, you’ll want to ensure that alternate processes do not rely on the primary  authentication system.   Admin Access It is helpful to evaluate your use of authentication services for your internal operations  and administrative access to your site. If single sign-on is used as a primary access  mechanism for administrative access, such access could be blocked during a failure of  the SSO system. You may need alternate authentication mechanisms to access critical  administrative functions during an outage. This includes administrative access to your  service, monitoring and alerting infrastructure, and the ability to post outage updates to  your customers. You should of course ensure an adequate level of security on all access  paths to administrative functions. Planning for an outage of authentication solutions  used for administrative access will help your team respond efficiently during an actual  outage.   Provisioning Systems Provisioning processes and systems may be less critical during an outage than  authentication systems, but if you have time-critical account provisioning or  deprovisioning processes, it may be necessary to define alternate processes for use  during an outage of a provisioning system. Once service is restored, it may be necessary  to validate that all in-flight transactions at the time of the outage were completed,  especially account removal or privilege removal transactions. A routine check after  an outage for incomplete deprovisioning transactions can help prevent incorrect  access privileges.  213   Chapter 17    exCeptions   Compromised Security Information The compromise of personal data, user credentials, and authentication secrets can have  significant consequences and requires a comprehensive response. Moreover, there may  be aggressive timeframes within which you must respond, so it is imperative to have a  response plan defined in advance.   Compromised Personal Data If the unthinkable happens and you experience a suspected or verified breach of personal  data, you need to act quickly. It is imperative that you are aware of any legal requirements  related to the exposure of personal data, have a plan worked out in advance, and have  retained any outside assistance needed to respond quickly. Your plan should define     The owner accountable for leading the response     The response team and responsibilities of each member     Clear priorities and required timeframes for the response effort     The steps to take, including preventing further damage, preserving  required evidence, assessing the damage, and identifying and fixing  the root cause as well as related damage     The process to follow for user and regulatory notification     The process to follow for public relations communications  If personal data is compromised, many privacy regulations require notification  to regulatory agencies within a certain time period. For organizations subject to the  General Data Protection Regulation  GDPR , Article 33 specifies that notification should  be made within 72 hours of becoming aware of a breach. Breach response procedures  require significant coordination. Notification may be required to multiple government  organizations, law enforcement, and users. You may need to coordinate press releases  and communications on social media. Communications may need to be vetted  internally with legal, security, and marketing teams and with a representative from your  cyber-insurance carrier if you have such a policy. The amount of communication and  collaboration for a well-coordinated, professional response can only be done in the  required timeframes by having a plan and process defined in advance, as well as training  staff on the plan along with templates, checklists, and contacts.  214   Chapter 17    exCeptions   Compromised Credentials If there is a large-scale compromise of your users’ authentication credentials, the  legitimate users need a way to reset their credentials and recover their accounts if thieves  have taken over the accounts. Relying on users calling a support center is costly and  difficult to scale and requires a secret the legitimate user and the support staff know that  the thief won’t know. Sending a password reset link to the user’s registered email address  or phone number may not work if significant time has passed between the breach and its  discovery because the thief may have altered authentication credentials and user profile  information, including notification attributes. You need a secure and scalable account  recovery process worked out in advance so that you can act in a timely manner if this  happens.   Compromised Secrets A related scenario is the compromise of other “secrets” such as OAuth 2.0 client secrets  or private keys used in the signing or decryption of security tokens. This can happen as a  result of human error, so it is wise to prepare for this possibility. An inventory should be  maintained of all such secrets used in your operations, how each is used, and recovery  steps needed if any are compromised.  Your application can facilitate recovery by dynamically retrieving the public keys   used to validate security tokens. This makes it easier to rotate them but may create  issues for caching. If your application caches dynamically retrieved public keys for  performance reasons, and invalidates the cache anytime a signature validation fails, this  could enable a denial-of-service  DoS  attack by someone sending counterfeit security  tokens with fake signatures. If caching is needed, it may be possible to reduce this risk  using a periodic refresh and by having applications only invalidate their cache upon  a validation failure once per a certain time period, rather than for each failure, and  triggering an alert for human intervention if a lot of invalid tokens are received.  If your solution includes the use of SAML 2.0 with other organizations and a private   key used to sign or decrypt SAML 2.0 messages is compromised, you need to update  configurations with new keys. If there is no dynamic mechanism to update federation  metadata, you may need to synchronize updates with another organization. You should  work out recovery processes in advance for the secrets in your environment so you can  execute quickly if needed.  215   Chapter 17    exCeptions   Summary We’ve covered several scenarios that involve some type of failure and the need to create  a response plan for them. Some, like forgotten passwords, are likely to occur. Others,  like a breach of personal data or user credentials, may never occur. The failures possible  in your environment may differ from those we outlined, but our list should help you  identify possibilities to consider. This enables you to create response plans, train your  team, and test your preparedness periodically to ensure you are ready if something  happens. Besides these failure exception cases, there are also use cases that are simply  less common, and they are the topic of the next chapter.   Key Points      It’s essential to plan for what can go wrong in an environment.     You may need a process for restoring accidentally deleted data.     You need a process for customers who wish to decommission their   account.     You should have a process to handle an orphaned account.     Users may forget or lose credentials and need an account recovery   mechanism.  been compromised.     You need a process to check for and fix accounts whose password has      You need a process to identify the legitimate account owner if   account takeover has occurred.      If your support system or administrative access depends on a single  sign-on system, you should plan for how to handle an outage.     You should have a response plan in place for situations involving   compromised personal data, user credentials, or private keys.  216   Chapter 17    exCeptions   Notes           i.  www.pcworld.com article 2052586 microsoft-is-quietly-  recycling-outlook-email-accounts.html  ii.  https:  usa.kaspersky.com blog ss7-hacked 17099     iii.  www.theguardian.com technology 2016 apr 19 ss7-hack- explained-mobile-phone-vulnerability-snooping-texts- calls  iv.  https:  medium.com 4iqdelvedeep 1-4-billion-clear-text- credentials-discovered-in-a-single-database-3131d0a1ae14    v.  https:  haveibeenpwned.com  217   CHAPTER 18  Less Common  Requirements  Two roads diverged in a wood, and I— I took the one less traveled by, And  that has made all the difference.  —Robert Frost, American poet, from “The Road Not Taken”  1916   Previous chapters covered common identity management use cases. In this chapter,  we’ll share some less common requirements that may apply to your project. Identifying  the need for them early in a project can help you avoid surprises and project delays.  We’ve organized these scenarios loosely around people, accounts, and environments.   People Several requirements stem from activities, changes, or relationships in the life of people.   Family Accounts With services that can be shared between members of a household, such as movie  streaming, it may be necessary to associate multiple family members with a family  account. This requirement can apply to insurance, digital libraries, cellular service  providers, healthcare, or other services traditionally shared among members of a  family or household. In addition, one family member may need to be informed about,  or communicate on behalf of, another person such as a minor child or an elderly  adult. For such family-oriented services, applications may need to recognize all family  members associated with an account as well as what each family member can do for  others.    Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2_18  219    Less Common requirements  Chapter 18   Temporary Positions In corporate settings, temporary accounts are sometimes needed for contractors,  interns, or partner workers. If temporary accounts are not governed by a company’s  normal account management processes, they might not be terminated when the  temporary working relationship is over. A best practice is to set an expiration date for  temporary accounts and require the manager of a temporary worker to periodically  approve renewal of the temporary account. If the account is not renewed, it should be  disabled. The sensitivity of the privileges allowed by the temporary account’s access can  determine the appropriate frequency for account review and renewal.   Status Transition Another corporate requirement involves a person who transitions from working in  one capacity to another, such as a temporary contract worker transitioning to full-time  employee status or vice versa. If temporary workers are registered and administered  separately from employees, but all sources feed into one identity provider, it might be  possible for two accounts for the same person to exist at the same time which might  cause ambiguity at best, or unauthorized access at worst. If a person can transition from  one status to another, processes should be designed to avoid duplicate accounts for the  same person.   No Email Address Many applications expect an email address attribute in a user’s profile. There may be  cases, however, where users don’t have email addresses. Some businesses do not issue  email addresses to employees who have no need to read email on the job. Parents of  younger children may not allow them to have an email address. Some organizations may  provide their users an email address but have privacy guidelines that prohibit the use of  email addresses as account identifiers. Applications may need to accommodate users  who do not have email addresses or restrictions on where an email address can be used.  220   Chapter 18    Less Common requirements   Identity Defederation It may be necessary to support account defederation while otherwise leaving an account  intact. For example, when a person terminates their relationship with an employer, they  may need to use a personal account to access resources that they previously accessed  via an account at the employer’s identity provider. If a company provides to employees  a pension program, employees might sign in to the external pension web site via their  employer’s chosen identity provider. If an employee quits their job, however, their  account at the corporate identity provider will cease to exist. The user will need their  account at the pension system to be defederated from their employer’s identity provider  so they can log in with an individual account local to the pension system. In general,  defederation is needed when a user can sever a relationship with an organization, but  is still entitled to access resources there that they previously accessed via a federated  identity.   Accounts Another category of requirements is associated with users’ accounts.   Mergers and Acquisitions Mergers and acquisitions can create identity management challenges. It is advantageous  for a company to have a single identity repository against which all users are authenticated.  When a company acquires or merges with another company, it is common for the identity  repositories of the two companies to be merged, which may require resolving duplicate  usernames to achieve username uniqueness in the new merged entity.  Changing usernames to eliminate duplicates may impact applications. When a user  is authenticated by a centralized identity provider, an identifier for the user is passed to  applications. If an application maintains a user profile or data records that contain the  user’s identifier, the identifier passed to the application from an identity provider must  match the identifier for the user in the application. If a user’s identifier is changed as  part of a merger,  mary@domain1.com becomes mary@domain2.com or “mary” becomes  “mary.smith” , an identity provider may need to translate identifiers so the user can  authenticate with a new identifier but have their former identifier passed to legacy  applications still using the old identifier.  221   Chapter 18    Less Common requirements  Alternatively, user identifier changes can be implemented in applications. This   should be done with care, however, as it may require updating data records within the  application besides the user’s profile. This can become complicated, so it may be easiest  to have an identity provider pass old usernames to legacy applications until the legacy  systems are replaced.   Account Linking A common requirement, particularly in a consumer-facing environment, is to allow a user  to sign up for an application account, entering user profile information required by the  application, and then add the ability later for the user to log in to their local account via a  social identity provider. This requirement can come about for several reasons, including     An application has a legacy data store of identities but wants to offer   users the convenience of logging in via a remote identity provider,  most commonly a social identity provider.     A user wants to try out a new application without granting the   application access to their profile at a social identity provider. If they  like the application, the user would later want to leverage their social  identity provider account to log in to the application.  Applications typically want to remove as many barriers to usage as possible. Allowing   a user to log in via a remote identity provider means the user can log in with credentials  they may use frequently and are more likely to remember than an application-specific  credential. Furthermore, if the user has an existing authentication session with the  identity provider when they access the application, the user may get right into the  application via single sign-on, for even more convenience.  Account linking can be used to link remote accounts to a local application account.   Linking is useful because accounts are associated with a particular context. For example,  a local application account with identifier “mary@gmail.com” is a different account  than an account at a remote identity provider that uses the same identifier. If a user  signs up for an application account using identifier “mary@gmail.com” and then logs  in with the identifier and credentials specified at sign-up, she will access the local  application account created as a result of her signup. However, if Mary then signs in to  the application via a social identity provider, the application will receive a security token  with various claims about Mary. The claims might include an internal identifier specific   222   Chapter 18    Less Common requirements  to that provider and a claim about her email address. However, Mary might have used a  different identifier or email address at the social provider. Unless the application has a  way to associate the social provider account attributes with the user’s local account, the  user won’t be able to access their existing application account when they sign in via the  social provider. It is risky for an application to make an automatic association between  accounts based simply on matching attributes because a remote account may not have  validated user profile data. Therefore, it is best for any linking between accounts to be  made explicitly using a process such as the following, that requires a user to authenticate  to both accounts to prove ownership of them.      The user logs in to a local application account, proving ownership of   that account.  supported for linking.     The local application provides a list of remote identity providers      The user selects the remote identity provider for a second account to   be linked, such as a social provider.     The application triggers an authentication request to the remote   identity provider to authenticate the user.     The user authenticates to the remote identity provider, proving   ownership of their account at the provider.     The application receives a security token from the remote identity   provider with claims about the user.     The application associates an identifier for the remote account with   the local account for the user.     When a user authenticates, the application searches through both the   primary account identifier and any secondary linked identifiers in  the user profiles to find the account for the user.  In this example, the linking steps establish a link between a user’s account at a   social identity provider and their previously established, local account in an application.  The user must authenticate to both accounts to prove ownership of them and give the  application the user’s identifier at the remote identity provider. The authentication  to the accounts to be linked can be done in any order, but it must be done in order to  prevent the risk of account takeover via account linking. It’s important to note that   223   Chapter 18    Less Common requirements  automatic linking of accounts that have the same value for a profile attribute such as  email address, without the explicit dual authentication step, should be avoided, to  prevent the possibility of unauthorized account takeover. If automatic account linking  is done between accounts with unvalidated attributes, such as an email address,  accounts could be erroneously linked that belong to different people. Lastly, if account  linking is implemented, it should be possible for users to unlink accounts they have  previously linked, in case the user wishes to stop using a linked account for some reason.  Implemented properly, account linking can provide a convenience for users to log in via  different identity providers and still access the same account.   Progressive Profiling Progressive profiling can be used to avoid having to collect a lot of information from a  user at once. A user can sign up for an application account with minimal information,  and progressive profiling can then add to that data over time. The gathering of additional  profile attributes can be done upon subsequent uses of the application or when it is  needed for a specific type of transaction. A user can even sign in to an application using  a remote identity provider, and the application can create a local account for them with  information from the remote provider. A user can be prompted to supply additional  profile attributes either before or after they are redirected to that identity provider, with  information from both sources merged into the local application’s profile for the user.   Impersonation Impersonation is defined as the ability of one person to log in to an application as if they  were another person and perform any task as that person. The most common use case is  the need for support personnel to log in to an application as another user and see what the  user experiences in order to troubleshoot an issue. Unfortunately, such a capability has the  potential to be abused, and it can be challenging to retrofit secure, restricted impersonation  capabilities into an existing application. To reduce the risk of unauthorized activity by  impersonators, a separate troubleshooting application can be created that restricts access  to that needed for troubleshooting. For example, it could provide view access to customer  account configuration and data, for troubleshooting, but not the ability to modify customer  data. The application should log all activity and automatic monitoring of logs for anomalous  activity should be implemented. Ideally, consent should be obtained from account owners   224   Chapter 18    Less Common requirements  before the troubleshooting application allows access to an account. Needless to say, the  troubleshooting application should be protected with adequate security measures and  granted only to authorized staff, with the list of authorized users reviewed frequently. This  approach can reduce the risk of unauthorized insider activity.   Delegation Another use case sometimes referred to as delegation is when one user needs to grant  another user the ability to act on their behalf, for a specific subset of tasks or data. A  busy executive, for example, may delegate some chores to an executive assistant. The  executive’s assistant would be granted access to perform tasks on his or her behalf. A  variant of this is when an employee goes on vacation and needs to delegate ownership of  their tasks  such as support tickets  to another person while they are away. In both cases,  one user needs to be granted access to perform specific actions on behalf of another  user. Such capabilities are best designed into an application as the granting of delegation  privileges is quite application specific. For example, an executive may wish to delegate  to an assistant the ability to approve expense reports, but only up to a certain amount.  Application logging should be delegation-aware so that all activity done by delegatees is  logged and shows both the delegating and delegated identities involved, for a full audit  trail. The task-specific nature of delegation and need for audit logging makes it best  implemented within an application itself.   Environment Last but not least, we have a few use cases related to an application’s environment.   Shared Workstations There are some environments where users log in to shared kiosks or workstations.  Such environments provide a shared device that is used by many users. Examples can  be found on manufacturing shop floors, medical offices, and point-of-sale systems.  With the same device used by multiple people, it is important to have each user log  in when they start a session and log off when they complete a session. Having users  log in at the beginning of a session is easy enough, but ensuring that a user logs out is  more challenging because users may get distracted and forget to log out before walking   225   Chapter 18    Less Common requirements  away. Implementing a session timeout after a short period of inactivity can help protect  users. Bank ATM machines provide a good example, asking after every transaction if the  user wants to do another, and if there is no response within a short period of time, the  session is immediately terminated. For applications that run in a browser, it is helpful  to use a browser that supports ephemeral sessions and to set browser policy to force  ephemeral sessions so that information from previous users’ sessions is cleaned up.  If your application may be used on shared devices, it’s also important to consider if  information could be leaked through other means, such as temporary files, and mitigate  any risks found. Such steps can prevent user sessions and data from being compromised  on shared devices.   Identity Provider Discovery With an employee-facing environment, there is usually one identity provider to  authenticate all users. In other scenarios, such as a multitenant application used by  many businesses, each business may have its own identity provider configured, and the  application may need to determine the appropriate identity provider for a user needing  to log in. This has been called identity provider discovery or home realm discovery.  When there are multiple possible identity providers, mechanisms to identify which to  use for each user include     User selects the appropriate identity provider from a list.     User enters information, and a lookup is performed to determine the   correct identity provider.     Derive the identity provider from an environment factor such as the   originating application or domain.     Obtain the identity provider from information in a browser cookie, if   available, and revert to one of the previous methods if not.  If an application has multiple identity providers configured for authenticating users,   these options can help determine the correct identity provider for a user.  226   Chapter 18    Less Common requirements   Multitenant Applications Multitenant applications serve multiple tenants with a single running instance of the  application, where a tenant is a group of related users sharing access to a group of  resources managed by the application. While multitenant applications themselves are  quite common, they pose some unique challenges related to identity management.  Users are typically authorized to access specific tenants. If a given user is authorized  to access multiple tenants, the appropriate tenant can be determined by mechanisms  such as     Requiring users to have a different identity for each tenant     Providing a tenant selection mechanism before or after login  The first option may not be very convenient for users. The second option is often   achieved by including the tenant name in the URL by which a user accesses the  application or by providing a tenant selection mechanism for the user.  In addition to routing a user to a specific tenant, there may be a requirement  to enable different authentication policies across tenants. For a business-facing  application, it may be necessary to allow the administrators for each tenant to configure  different identity-related preferences, such as password strength requirements, the  identity provider s  by which to authenticate users, or the allowed length of single sign-  on sessions. It may also be necessary to support the ability of customers to retrieve log  data but only for their tenant. In short, a multitenant application has to satisfy all the  usual identity-related requirements, but may have to provide the ability for each tenant  to have their own identity-related configuration settings.   Summary We’ve covered several less common use cases that might apply to your environment to  help you identify such requirements early in a project. In the next chapter, we’ll cover  some mistakes that have led to breaches to help you avoid a similar scenario.  227    Less Common requirements  Chapter 18   Key Points     Applications may need to accommodate family relationships,   temporary accounts, users changing status, and users who may need  to defederate their identity.     Users in some scenarios may not have email accounts.     Merging of identity repositories during company mergers may   require changing usernames and supporting legacy applications’  need for old usernames.     Account linking allows users to link multiple remote identities to one  local account and authenticate with any of them to use that account.     Progressive profiling enables an application to build up user profiles   over time.          Impersonation for support purposes has potential for abuse which  can be mitigated with customized troubleshooting applications.  If an application supports multiple identity providers, a discovery  mechanism is needed to determine the correct identity provider to  use for each user.  228   CHAPTER 19  Failures  Those who cannot remember the past are condemned to repeat it.  —George Santayana, Spanish philosopher, poet, and novelist, from   The Life of Reason, vol. 1  1905   We have covered several aspects of identity management relevant to an application  development project. Writing an application with perfect identity management will be  for naught, however, if flaws in your environment or processes introduce a vulnerability,  especially one that compromises sensitive identity data. It is often said that one can learn a  lot from failure. When it comes to identity management, however, we think it is preferable  to learn from others’ failures rather than your own! Inspired by George Santayana’s advice  about the need to learn from the past, we’ve collected stories of past security breaches and  their causes to help you avoid making such mistakes in your environment.  This chapter describes failures that resulted in significant breaches or exposure of   identity data. There may be some wonderfully interesting and obscure cryptography bugs  that have caused a breach somewhere. We won’t be covering any here because, sadly, many  breaches have been caused by very simple failures. While there are many attack vectors,  the annual Verizon Data Breach Reporti provides some valuable statistics on the top causes  behind breaches. Hacking, malware, human error, and social engineering topped the list in  the 2018 and 2019 reports. You’ll see those and more in the following stories. Take note of  the root causes in each story and avoid them in your projects!   Pay Attention to Process Our first case doesn’t involve technology or a breach of identity data, but we included it  because it underscores the importance of securing not just technology but also processes.  In 2015, Edward Hornsey, an enterprising young businessman, hit upon the idea of     Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2_19  229   Chapter 19    Failures  buying used iPhones, many of which were stolen, and returning them to Apple to take  advantage of their liberal return policy. He received shiny new replacement phones in  exchange, which he was then able to sell at a handsome profit. Surprisingly, he managed  to do this 51 times before Apple caught on! At the time, Apple did not check to see if a  returned phone had been reported stolen or was being returned by the registered owner  of the phone. Nor did Apple have any check on the number of phones returned by a single  person. This demonstrates the necessity of designing appropriate anti-fraud mechanisms  and identity checks into business processes. In case you are wondering, Apple did catch  on and fix its processes and Mr. Hornsey was duly convicted of fraud and sent to jail. Don't  try this at home!   Another classic example of an attack that involved no technology beyond charm and  chocolate, yes you read that correctly, chocolate, is the 2007 social engineering attack by  a perpetrator as yet uncaught, who purloined 21 million euros of jewels from safe deposit  boxes at ABN Amro bank in Belgium.ii The thief’s charm and gifts of chocolate were  apparently used to obtain safe deposit box keys and information about the diamonds.  Don’t shortcut security processes, even for charming, chocolate-bearing customers!  Another failure occurred in 2006 when office workers employed by The Boston Globe   newspaper mistakenly printed out lists of subscribers’ credit card and bank routing  numbers. Rather than shred the printouts, the workers placed them in a recycling bin. This  environmentally conscious newspaper used recycled paper for routing slips for the bundles  of newspapers they distribute to newspaper vendors. As you suspected, the recycled  printouts with customer credit card and bank information were used to wrap bundles  of newspapers that were then distributed all around the city of Boston.iii The newspaper  certainly earned an “A” for environmental awareness, but an “F” for data protection that  day. If you handle any identity information, avoid printing sensitive information except  where absolutely necessary. In addition, provide shredders and train all staff regularly on  data protection procedures, including shredding printouts with sensitive information.   Beware of Phishy Emails Don’t take the bait when someone is phishing! Continuing the unfortunate tale of breaches  is Anthem which suffered a breach in 2015 impacting 78.8 million records including social  security numbers, birthdays, addresses, email, and income data.iv, v, vi The Anthem breach  is suspected to have originated in a single employee inadvertently clicking a phishing  email containing malware. At the time, Anthem had on the order of 50,000 employees   230   Chapter 19    Failures  and a single person clicking a dodgy email opened up a door for hackers. Sadly, the list of  breaches caused by phishing attacks continues unabated. In 2018, UnityPoint Health fell  victim to a phishing attack, resulting in the exposure of 1.4 million patient records including  names, addresses, medical data, and possibly social security numbers and payment card  information.vii Aultman Health Foundation was compromised by phishing, impacting  over 42,000 patients.viii MedSpring Urgent Care in Austin Texas compromised over 13,000  patients’ data as a result of a successful phishing attack.ix This should underscore the  importance of security training, endpoint protection software, and procedures tools  to help employees recognize phishing attacks which may come in the form of emails,  text messages, or even voicemails. Implementing a comprehensive program of security  measures, for defense in depth, may help reduce or contain the damage if someone falls for  a phishing attack, but preventing malware in the first place is preferable.   Use Multi-factor Authentication While the causes behind some breaches do not involve technology, there are certainly  many that do. In November 2015, JP Morgan announced they’d suffered a data breach  of 83 million customers’ accounts.x At the time, it was the largest data breach suffered by  an American financial institution. This breach was the result of an attack that began with  stealing an employee’s credentials and then gaining access to the bank’s network through  a lone server that did not require multi-factor authentication. The moral of this story is one  of attention to detail. Have accurate lists of servers, check that multi-factor authentication  is required for access to all access points and sensitive resources, and repeat the checks  regularly. Rather than rely on error-prone manual processes, use automated processes to  build servers with secure configuration and automate regular security scans to ensure all  servers remain configured to build standards. Scan networks and use device management  regularly to find any equipment that does not meet secure configuration standards.   Stay on Top of Patches While we’re on the topic of staying on top of things, we should cover the 2017 Equifax  breach. This breach exposed the personal data of 143 million people. The breach  was made possible when Equifax did not act on security vulnerability notices for its  technology stack. A vulnerability in the Apache Struts technology  CVE-2017-5638 xi was   231   Chapter 19    Failures  made public on March 6th, 2017.xii A patch was promptly made available by Apache.xiii  Installing a patch requires time to update the impacted software and thoroughly test  applications relying on the patched technology. Care must be taken to ensure the  installation of a patch doesn’t cause outages or other issues. In this case, however,  aggressive attempts to take advantage of the vulnerability were already being reported in  March.xiv Unfortunately, for the victims in this breach, Equifax failed to patch its systems  for this known vulnerability. Equifax reported that its systems were breached in May of  2017, two months after the patch for the vulnerability was provided.xv, xvi, xvii The lesson  here is the necessity of knowing your technology stack, monitoring the vulnerability  announcements for each technology used, and having a process to quickly triage and  apply patches for critical vulnerabilities.  Secure Your Cloud Just because you use cloud services with rigorous security practices doesn’t give you  a free ride. If you use a cloud service, you must configure and use it securely. In 2018,  MBM, which runs a company called Limoges Jewelry  a Walmart partner , exposed  the personal information of 1.3 million customers via an improperly secured Amazon  S3 bucket. This S3 bucket contained a database backup file and left this information  publicly exposed for many weeks. The compromised information included names,  addresses, phone numbers, email addresses, plaintext passwords, and encrypted credit  card information.xviii, xix, xx A similar incident, in 2017, this time by a Verizon partner,  exposed personal information and PINs of up to 14 million Verizon customers via an  improperly secured S3 bucket.xxi Continuing the pattern, Uber exposed the personal  information of 57 million users in a vulnerable S3 bucket.xxii A Florida credit-repair  firm, National Credit Federation, exposed data including names, addresses, driver’s  licenses, dates of birth, social security numbers, and credit reports for tens of thousands  of customers in similar fashion.xxiii The moral of this story is to properly secure any S3  buckets or similar cloud storage services you use.   Encrypt Sensitive Data! Another critical lesson can be learned from the breach of Sony PlayStation Network. The  Sony attack involved 77 million accounts, 12 million of which had unencrypted data.  This resulted in the compromise of names, emails, passwords, addresses, and credit card   232   Chapter 19    Failures  numbers.xxiv, xxv The lesson here concerns the need to protect data. If you handle sensitive  data, and identity data is by definition considered sensitive, you should encrypt the data  at rest and in transit. This protection should extend to backups and log files. In addition,  logs should be scanned to ensure sensitive data isn’t leaked to log files. Twitter learned this  lesson the hard way when a bug inadvertently wrote out cleartext passwords to log files  and they didn’t discover the issue for months.xxvi Legislators around the world are reacting  to public outrage about data breaches and enacting privacy legislation with sanctions for  companies that fail to adequately protect personal data. In the event of a breach, these fines  may be avoided, or at least significantly reduced, if data is protected by proper encryption.   Do Not Store Cleartext Passwords It is risky to store passwords in cleartext. Unfortunately, numerous breaches of  cleartext passwords show that many sites have run this risk, to the detriment of their  customers. The third largest data breach in Finnish history resulted in the compromise  of usernames and cleartext passwords of 130,000 users of the New Business Center, a  site for entrepreneurs.xxvii, xxviii A breach of ClixSense, a site for viewing ads and surveys,  resulted from an unsecured older server with access to a primary database. This breach  exposed personal information such as names, email addresses, dates of birth, and IP  addresses as well as the cleartext passwords of 6.6 million users.xxix A service called “Teen  Safe,” designed to allow parents to track their children’s phone activity, compromised  the data of tens of thousands of customers. The data exposed included parent emails as  well as children’s Apple ID and cleartext password for the Apple ID. This incident was  caused by improperly secured servers in Amazon Cloud, but the impact of the breach  was compounded by passwords stored in cleartext.xxx, xxxi All we can say is, when it comes  to storing passwords in cleartext, just don’t!   Provide Security Training to Developers Secure infrastructure and practices won’t help if applications themselves contain coding  vulnerabilities. A good place to start for advice on secure coding practices is the     OWASP Top 10 Application Security Risks – 2017xxxii     OWASP Secure Coding Cheat Sheetxxxiii     OWASP Secure Coding Practices Checklistxxxiv  233   Chapter 19    Failures  how to avoid them.  These documents contain advice about the most common coding vulnerabilities and   Heartland Payment Systems suffered a data breach in 2008 that exposed 134 million   credit cards and was caused by a SQL injection attack.xxxv, xxxvi This type of attack takes  advantage of applications that do not properly validate input that is subsequently used  to form queries against back-end data systems. The Heartland breach in 2008 might have  been prevented had they heeded the 2007 version of the OWASP Top 10, which showed  injection-style attacks as number two in the list.xxxvii They are easy attacks to perform and  automate but can be prevented with proper input validation. To reduce vulnerabilities in  application code, ensure that developers are thoroughly trained on the current OWASP  Top 10 Application Security Risks and how to prevent them.xxxviii In addition, to mitigate  the risk of human error, institute code reviews and automated software vulnerability  scanning to identify vulnerabilities in your application code.   Vet Your Partners Many companies today use a dizzying array of vendors, and if their access is not properly  managed and segregated, the results can be disastrous. The retail company Target  announced in 2014 that it had been attacked, resulting in the exposure of 40 million  card numbers and personal data of 70 million customers. This attack is suspected  to have originated in the compromise of Target’s HVAC  heating, ventilation, and  air conditioning  contractor via a phishing attack which installed a Citadel Trojan.  Unfortunately, there was inadequate separation between the network access granted to  the HVAC vendor and other systems on Target’s business network. The attackers were  able to leverage the access provided to the HVAC vendor to access vulnerable systems  on Target’s network and from there to access POS  point of sale  systems where they  collected credit and debit card data. While Target had installed security tools such as  FireEye and Symantec, key monitoring features were either turned off or not monitored.  xxxix The lesson to learn from this breach is to thoroughly validate the security practices of  all partners on an ongoing basis and ensure adequate network segregation between low  sensitivity systems and systems with highly sensitive data. Applying the principle of least  privilege by granting the minimum necessary access to each actor in an environment  can provide another layer of defense. Last but not least, ensure monitoring systems are  turned on and pay attention to alerts from security monitoring systems!  234   Chapter 19    Failures  There are several more examples of breaches related to business partners. [24]7.  ai, a customer service and chat vendor used by several retailers such as Sears, Kmart,  BestBuy, and Delta, caused a breach in 2018 resulting in exposure of personal data and  credit card information for hundreds of thousands of customers of each of these large  companies.xl In 2017, Deep Root Analytics, a small professional services company used  by the Republican National Committee, mistakenly put the data of 200 million voters on  a publicly accessible server.xli, xlii To avoid a repeat of these cases, make sure to track all  partners you use, vet their security practices, and ask if they share your data with any of  their partners and how they’ve vetted their partners.   Insider Threat Some breaches are caused by insiders. The Verizon Data Breach Report for 2018  indicates that 28% of attacks are perpetrated by insiders.xliii Perhaps the most infamous  example of insider threat was not conducted for monetary gain. Edward Snowden, a  systems administration contractor working at the US National Security Agency  NSA ,  was able to exfiltrate thousands of top secret documents from a Defense Intelligence  Agency network. The exact scope of the breach may never be known, but the impact to  political strategy as well as to offensive national cybersecurity interests will be felt for  years. Snowden apparently accessed 1.7 million files using automated web-crawling  software on networks to which he was legitimately given access. He configured the  software to look for specific topics. His activity was apparently not detected because  he worked in a field office that had not yet upgraded systems to implement the latest  security controls which might have detected his activity.xliv, xlv, xlvi  The Snowden incident illustrates the threat of a malicious insider. Several lessons   can be learned from the Snowden incident. The first is to implement the classic security  principle of granting each person the least privilege required to do their job and to  design access models to enforce segregation of duties. Admittedly, this is challenging  in smaller organizations where each person has many responsibilities. A second  protection is to encrypt data at rest and in transit. A third technique is to employ security  monitoring software that can detect anomalous activity  especially high-volume data  retrieval . It usually takes significant time to tune such solutions so that they do not  generate a time-wasting volume of false positives. Data loss prevention  DLP  solutions,  which are designed to prevent exfiltration of data by detecting anomalous traffic out   235   Chapter 19    Failures  of a network or device, can also be used. Unfortunately, none of these techniques can  guarantee protection against data theft. However, if there is a breach and such solutions  are not in place, it will look much worse for the victimized organization.   Summary This chapter was a very sobering chapter to write. The number and magnitude of  breaches seem to continually get bigger and bigger. George Santayana, the Spanish  philosopher, poet, and novelist, said, “Those who cannot remember the past are  condemned to repeat it.” We hope the lessons from past breaches help you avoid  following in the footsteps of the many companies featured in the preceding sections. If  you are writing an application that contains or uses identity data, you have an obligation  to protect that data. Unlike the game of golf, there is unfortunately no handicapping  system to give beginners a break. If you are creating an application, you must follow  security best practices for the coding, deployment, and environment of the application  as well as people, processes, and partners involved in the project.  Furthermore, in today’s world, it’s not good enough to just implement   security technology. You need to be able to demonstrate diligent adherence to security-  and privacy-related policies and procedures, which is related to compliance, the topic of  our next chapter.   Key Points  malware.  passwords.     Processes should be analyzed for vulnerabilities.     Train users to recognize and avoid phishing attacks to reduce risk of      Use multi-factor authentication to mitigate the risk of compromised      Monitor for software vulnerabilities and apply patches when   vulnerabilities are announced.     Follow secure configuration guidelines for all cloud-hosted   components such as Amazon S3 buckets.  236   Chapter 19    Failures     Encrypt sensitive data at rest and in transit, including backups and   log files.     Avoid storing cleartext passwords.     Provide security training for developers.     Vet partners by checking certifications and conducting due diligence   evaluation of security practices.     Mitigate the risk of insider threat by granting minimum needed  privileges and frequently reviewing access grants as well as logs.   Notes        i.  https:  enterprise.verizon.com resources reports dbir   ii.  www.darkreading.com the-7-best-social-engineering-  attacks-ever d d-id 1319411?image_number=5    iii.  www.computerworld.com article 2560335 security0   security-snafu-at-boston-globe-exposes-subscriber-data. html     iv.  www.nytimes.com 2015 02 06 business experts-suspect-lax-  security-left-anthem-vulnerable-to-hackers.html    v.  https:  money.cnn.com 2015 02 04 technology anthem-  insurance-hack-data-security     vi.  https:  nakedsecurity.sophos.com 2019 05 13 two-chinese-  hackers-indicted-for-massive-anthem-breach     vii.  www.identityforce.com blog 2018-data-breaches   viii.  www.identityforce.com blog 2018-data-breaches    ix.  www.identityforce.com blog 2018-data-breaches    x.  https:  dealbook.nytimes.com 2014 12 22 entry-point-of-  jpmorgan-data-breach-is-identified   237   Chapter 19    Failures    xi.  https:  nvd.nist.gov vuln detail CVE-2017-5638    xii.  www.imperva.com blog cve-2017-5638-new-remote-code-  execution-rce-vulnerability-in-apache-struts    xiii.  https:  cwiki.apache.org confluence display WW S2-045    xiv.  www.imperva.com blog cve-2017-5638-new-remote-code-  execution-rce-vulnerability-in-apache-struts     xv.  www.wired.com story equifax-breach-no-excuse    xvi.  https:  blog.blackducksoftware.com equifax-apache-  struts-cve-2017-5638-vulnerability   xvii.  https:  arstechnica.com information-technology 2017 09  massive-equifax-breach-caused-by-failure-to-patch-two- month-old-bug    xviii.  www.cyber.nj.gov data-breach-alerts 20180323 walmart-  partner-mbm-company-exposes-data-on-13-million-customers   xix.  www.komando.com happening-now 446247 breach-walmart-  exposed-personal-data-of-1-3-million-u-s-shoppers    xx.  https:  threatpost.com walmart-jewelry-partner-exposes-  personal-data-of-1-3m-customers 130486    xxi.  https:  threatpost.com third-party-exposes-14-million-  verizon-customer-records 126798    xxii.  https:  blog.zwillgen.com 2017 09 05 s3-buckets-not-simple    xxiii.  https:  github.com nagwww s3-leaks   xxiv.  www.extremetech.com gaming 84218-how-the-playstation-  network-was-hacked   xxv.  www.reuters.com article us-sony-stoldendata  sony-playstation-suffers-massive-data-breach- idUSTRE73P6WB20110427   xxvi.  www.zdnet.com article twitter-says-bug-exposed-  passwords-in-plaintext   238   Chapter 19    Failures   xxvii.  https:  securityaffairs.co wordpress 71136 data-breach   finnish-user-data-breach.html   xxviii.  https:  thehackernews.com 2018 04 helsingin-  uusyrityskeskus-hack.html   xxix.  https:  thehackernews.com 2016 09 plaintext-passwords-  leaked.html   xxx.  www.idownloadblog.com 2018 05 21 teensafe-data-breach      xxxi.  www.theverge.com 2018 5 21 17375428 teensafe-app-breach-  security-data-apple-id    xxxii.  www.owasp.org index.php Top_10-2017_Top_10    xxxiii.  www.owasp.org index.php Secure_Coding_Cheat_Sheet    xxxiv.  www.owasp.org index.php OWASP_Secure_Coding_Practices_  Checklist    xxxv.  www.computerworld.com article 2527185 security0 sql-  injection-attacks-led-to-heartland--hannaford-breaches. html    xxxvi.  www.csoonline.com article 2130877 data-breach the-  biggest-data-breaches-of-the-21st-century.html    xxxvii.  www.owasp.org index.php Top_10_2007   xxxviii.  www.owasp.org index.php Category:OWASP_Top_Ten_Project    xxxix.  https:  arxiv.org pdf 1701.04940.pdf              xl.  www.cybergrx.com resources blog top-11-third-party-  breaches-of-2018-so-far-data-breach-report   xli.  www.csoonline.com article 3191947 data-breach what-is- a-supply-chain-attack-why-you-should-be-wary-of-third- party-providers.html  xlii.  https:  gizmodo.com gop-data-firm-accidentally-leaks-  personal-details-of-ne-1796211612  xliii.  https:  enterprise.verizon.com resources reports dbir   239   Chapter 19    Failures  files-2016-8           xliv.  www.businessinsider.com snowden-confirm-hacked-nsa-  xlv.  www.theguardian.com world 2014 may 22 pentagon-report-  snowden-leaks-national-security  xlvi.  www.nytimes.com 2014 02 09 us snowden-used-low-cost-  tool-to-best-nsa.html  240   CHAPTER 20  Compliance  “Compliance” is just a subset of “governance” and not the other way around.  —Pearl Zhu, from Digitizing Boardroom  2016   Mention the word “Compliance” to an application development team, and you may get  some quizzical looks. What exactly is compliance and why does it matter to application  developers? This chapter will provide a brief overview of compliance, why it’s needed,  how it benefits application providers, and how to approach it.   What Is Compliance? Compliance is conforming to a rule, such as a specification, policy, standard, or law.  Organizations set goals for, and aspire to achieve, compliance to ensure that their  policies and practices are in conformance with relevant laws, policies, and regulations  or relevant standards. While compliance may be mandated and enforced differently  across the globe, it is designed to check that measures are in place to protect the privacy  of individuals and the confidentiality, availability, and integrity of services and data. One  way of categorizing different types of compliance is     Compliance required by legislation     Compliance required by an industry     Elective compliance  For compliance that is required by legislation or a particular industry, you must   determine if the compliance requirements apply to your project and take steps to comply  if so. For elective compliance, you can determine if it is advantageous to you to comply.  A later section will explain why compliance can be beneficial for your project. If you are     Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2_20  241   Chapter 20    ComplianCe  part of a larger company, compliance requirements may be given to you by a compliance  team, possibly in conjunction with outside auditors. If you are part of a small startup  building a new application, you may wish to hire an auditor to help you understand the  requirements that apply for your type of project.   Government-Mandated Compliance Many governments have established legislation regarding privacy and data protection.i  Perhaps the most well known is the GDPR  General Data Protection Regulation .ii  Enacted in the European Union, it took effect in May of 2018. It contains 99 articles  which describe the principles underlying the GDPR, the specific provisions of the GDPR,  supervisory authorities, penalties for nonconformance, and practical matters related to  implementation. The GDPR describes a legal basis for processing personal data, outlines  the obligations of organizations which collect and process personal data, and establishes  the rights of data subjects whose personal data is being processed.  The scope of the GDPR is any product or service that processes  e.g., collects, stores,   uses, transmits, deletes  personal information  PI  of EU residents regardless of where  such information is held. This includes companies in countries outside the EU who  merely hold data about people in the EU. It applies to companies of any size, though  Article 30 of the GDPR outlines some recordkeeping exemptions for companies with  fewer than 250 employees and who meet additional criteria for data processing. The  GDPR also requires that the latest technology be used for developing applications,  privacy must be embedded into the design of the application, and the application is  released with privacy default settings. If your service is likely to be used by residents of  the EU, you need to understand and comply with the requirements stemming from this  legislation.  The GDPR is the most comprehensive change to data privacy legislation in over   20 years. Its effects are being felt globally, and other countries are establishing similar  changes. In the United States, the State of California passed the California Consumer  Privacy Act  CCPA , a bill that enhances consumer rights for residents residing in the  state. The CCPA goes into effect in January 2020 and entitles residents to know what  personal data is being collected, whether it’s sold or shared, the right to opt out to the  sale or sharing of their personal data, access to their data, and equal service and price  even if they exercise their opt-out choice. Other states, including Hawaii, Maryland,  Massachusetts, Mississippi, New Mexico, New York, Rhode Island, and Vermont, are  drafting their own consumer privacy acts.  242   Chapter 20    ComplianCe  At the US Federal level, the Federal Trade Commission  FTC  Fair Information   Practice Principles  FIPP iii is designed to ensure that the practice of collecting  information is fair and provides adequate information privacy protection. It is based on  the principles of Notice Awareness, Choice Consent, Access Participation, Integrity  Security, and Enforcement Redress. The FTC gives recommendations for maintaining  privacy-friendly, consumer-oriented data collection practices which are self-regulated.  These principles form the basis for many sectoral laws, including the Fair Credit  Reporting Act and the Right to Financial Privacy Act.  Similarly, HIPAA  Health Insurance Portability and Accountability iv and HITECH   Health Information Technology for Economic and Clinical Health v are US legislation  which apply to the handling of healthcare-related data. These frameworks may apply to  you if you process, store, or transmit any electronic healthcare data for your customers.  These are just a few examples of government-mandated requirements.   Industry Compliance Compliance requirements can stem from an industry when a consortium of companies  in an industry creates a standard and a means of enforcing it. The payment card industry  requires all organizations that handle payment card data, including credit and debit  cards, to comply with a set of standards, known as PCI DSS  Payment Card Industry  Data Security Standard .vi This set of security standards was created by the PCI Security  Standards Council, which was founded by five international credit card companies   AMEX, Discover, JCP, MasterCard, and Visa .vii The standards are designed to protect  payment card data held or processed by companies.  Compliance with PCI DSS is enforced by the individual payment brands  the   five financial institutions that founded the PCI DSS . The PCI DSS controls apply to  systems which process, store, or transmit cardholder data or authentication credentials  and also apply to any systems connected to an environment that directly contains or  processes such cardholder data. If your organization accepts, handles, or stores any type  of payment card data, or if you outsource payment processing to a third-party vendor  but can impact the security of the payment transactions in some way, you likely have  obligations under PCI DSS.  243    ComplianCe  Chapter 20   Elective Compliance Frameworks There are other security-related standards for which compliance is elective. Companies  can choose to be audited against these standards to demonstrate their practices and  operations follow the standard. For example, a company can elect to comply with the  ISO 27000  International Organization for Standardization 27000 family of standards for  information security management systems .viii Another elective security standard is from  the CSA STAR  Cloud Security Alliance Security Trust Assurance and Risk  Program.ix The  CSA STAR program provides a comprehensive list of controls known as the Cloud Controls  Matrix  CCM . Compliance with these or other elective standards is a choice. Companies  can weigh the cost and level of effort for compliance against the benefits, which can  include achieving competitive advantage, expanding into new markets or industries,  supporting a brand image, or responding to customer audit requests efficiently.   Why Compliance Compliance required by legislation or an industry is typically mandatory. Recent  years have seen the passage of privacy- and security-related legislation as a reaction  by governments to the alarming number of security breaches that have occurred. If  your project falls under the jurisdiction of legislation which requires compliance, you  must comply. Elective compliance, however, is a choice. There are several reasons why  companies choose to be certified against a set of security or privacy standards:     Protect the sensitive data they process or hold     Use certification as a competitive sales tool     Show due diligence to minimize penalties in the event of a breach     Cost savings and efficiency in handling customer audit requests  Each of these reasons can offer significant benefits, as described in the following    Data Protection The first reason for pursuing compliance with an elective standard is to ensure your  organization is doing its due diligence to protect the data for which you are under  contract to protect. This is essentially the “sleep well at night” argument for compliance.   sections.  244   Chapter 20    ComplianCe  The process of preparing for an audit initiates a thorough review of security- and  privacy-related practices. This identifies any lapses from policy or defined procedures  that might lead to vulnerabilities, so they can be fixed. Regular audits reinforce security  best practices as your organization grows and changes. Of course, passing an audit does  not guarantee an absence of security incidents. Target was certified against the PCI  DSS standard and unfortunately still suffered a significant breach.x However, a properly  implemented compliance framework and certification should reduce the risk of a  security incident and subsequent impact should an incident occur.   Competitive Advantage A second reason to obtain a compliance certification is because it can be used as a  competitive sales tool. With so many breaches in the news, and penalties for data  breaches increasing, customers are demanding more security assurances from their  vendors. Having a certification from an independent, third-party auditor can help  assuage customer concerns. This can reduce delays related to security concerns during  the sales cycle and may help close deals. Vendors with security-conscious customers  may find certification valuable for this reason.   Reduce Penalties Another good reason to obtain certification is to reduce penalties in the event of a  breach. For example, with the GDPR, the existence of a previously earned certification  is one factor taken into account when a fine is levied on an organization related to a  compromise of personal data. A certification is no guarantee against a breach, but if you  have audit evidence of due diligence in implementing best practices, you may receive  lower fines than if you do not have a certification in place.   Efficiency A final impetus to earn certification is efficiency and cost reduction. A given cloud  service today typically uses many components in its software stack and relies on a  number of cloud services. Many of the cloud services used by a company may have  visibility into its sensitive data including personal data of its customers. In order to  provide a secure service to customers, a company must ensure that every third party it   245   Chapter 20    ComplianCe  uses protects the data it shares with them. The challenge is how to obtain such assurance  efficiently from the vendors.  In the absence of any standards for privacy and security, each company would   need to define privacy and security standards and examine each of its vendors against  them. Such an examination would need to review policies and procedures for managing  employees, assets, access, physical and environmental security, software development,  operations, network security, incident management, and business continuity. The  examination would also need to check evidence that policies and procedures for  all those areas are being followed and the organization’s documented controls are  operating effectively. This is a lot of information to analyze!  The field work for such an audit can take a week or more. Even a small company  will typically have several vendors to review, and because there is always entropy in  organizations, it is wise to repeat audits at least annually. It would be very costly for a  company to conduct its own audits of every vendor it uses. From a vendor’s perspective,  it would be time-consuming to provide such evidence individually to each of their  customers. In the absence of standards, different customers would request different data  and perhaps in different formats, making the work to provide evidence to every customer  unmanageable.  Security- and privacy-related standards provide a standard list of practices and a   consistent expectation for evidence to demonstrate compliance with the standard. This  enables a company to hire an independent third-party auditor to conduct a review and  certify the company’s practices against a standard. A company’s customers can then  rely on the independent auditor’s assessment instead of conducting their own audit. A  vendor undergoes one audit  for each type of assessment  and can then share the official  audit report with all of its customers. Customers can use an auditor’s report as evidence  that they’ve done their due diligence to ensure they are using vendors who provide  an adequate level of data protection. The entire process is made more efficient and  manageable for vendors and customers alike.   Compliance Landscape Compliance frameworks are often divided into privacy and security categories, but  privacy frameworks often include some form of security requirements because security  is a prerequisite for privacy.  246   Chapter 20    ComplianCe   Security Compliance Security compliance frameworks are mandatory for some industries. Compliance  with PCI DSS is required for the Payment Card Industry. Compliance with HIPAA and  HITECH security rules is required in the United States for the healthcare industry.  FISMA is required for US government agencies and FedRAMP for cloud providers  providing services to US government agencies. Companies can also elect to be certified  for elective security compliance frameworks. A list of some security-related compliance  frameworks is provided in Appendix G.  Privacy depends on security, so it is common for privacy-related legislation to   contain security requirements. The GDPR contains articles that require security of data  and privacy by design. HIPAA in the United States has a “Security Rule” that similarly  requires data stewards to adequately protect healthcare data. When creating a security  compliance roadmap, be sure to include security requirements stemming from any  privacy-related obligations your project may have.   Privacy Compliance Many countries have now enacted privacy-related legislation to protect the rights of  individuals with respect to how their personal data is handled. In fact, over 100 countries  around the world have enacted some sort of privacy legislation.xi A few data privacy laws  and sources for identifying more are listed in Appendix F. Your project may be subject to  a region’s privacy laws if you receive, collect, process, or store data about people in that  country. In other words, you may need to comply with a country’s legislation, even if  your business does not have a legal presence in the country, as with the GDPR  General  Data Protection Regulation  in the EU.  The role you play in handling data influences your obligations. Privacy legislation   often differentiates between the responsibilities of a data controller and a data processor.  A data controller controls how personal data is used as documented in a contractual  agreement or policy. The data controller collects data from end users and has obligations  such as providing privacy notices, obtaining user consent for the use of their data, and  providing users with certain access to their data as well as the ability to correct it. A data  processor, on the other hand, processes data in accordance with instructions from a  data collector in a data processing agreement. Knowing your role as data controller or  processor is essential to understand your privacy obligations.  247   Chapter 20    ComplianCe  It is also important to determine privacy obligations early in the project cycle,  because they can impact the application design in order to give notice about the  purposes of data collection, obtain consent for how data is used, manage data retention,  and implement data correction and erasure features. Knowing such requirements early  in the project cycle is critical for a realistic project plan.  If you are writing an application that has any personal data about individuals, you  should understand the locations of your users and the privacy requirements that apply  for the jurisdictions applicable to your user population. You should also check security-  or privacy-related legislation for your industry. You need to know your role in the  handling of data, whether data collector or data processor, and the requirements for your  role. Once you have your compliance requirements, it’s time to prepare for and pursue  certification.   Assessment and Certification Some standards rely on self-assessment, but most require an audit by an independent  third-party organization certified to conduct the particular type of audit. Self-assessment  requires an organization to examine their policies and practices against the standard and  remedy any gaps. The CSA STAR framework’s first level of compliance is one example  that involves self-assessment. Even if insufficient for official certification, self-assessment  can be a useful first step in preparing for an independent, third-party audit.  For many other standards, an independent, third-party audit of policies, practices,   and operations against the standard is a requirement. The ISO 27000 family of standards,  for example, requires an independent audit for an organization to be considered  certified against these standards. When third-party assessment is required, the  organization creating a set of standards for compliance will typically certify auditors  or establish the standards for certifying them. Certified auditors then conduct the  assessments, in accordance with audit standards, to evaluate whether an organization  complies with the standards. Auditor certification ensures audits are carried out in a  rigorous, standard, and unbiased way and the use of certified auditors is required for  many certifications.  248   Chapter 20    ComplianCe   How to Proceed Once you’ve identified relevant compliance frameworks for your project, you need to  plan the work required to implement and demonstrate compliance. The following list of  activities can help you understand and organize the effort:      Identify the national, state, or industry-specific privacy legislation  applicable for the regions in which your business operates.     Research privacy and security requirements for the countries or   regions in which your users reside.              Identify cybersecurity requirements applicable for your industry.  If you supply services to public sector organizations or process  government data, check for applicable government requirements.  Identify elective security standards which may be beneficial to  demonstrate your security practices to prospective customers.     Consult with legal, privacy, or security experts if you have any   questions about which legislation or security requirements apply.     Create a data map that describes the data elements of all data   repositories and data flows for all data you handle.     Note all data elements in the map which involve personal data.     Document the reason for collecting the data and the data processing   activities to be performed with the data.     Review data processing to ensure your application collects the   minimum data required in accordance with your privacy statement.      If available, use a self-assessment tool for a compliance standard to  identify gaps that must be mitigated before an official audit.     Retain a secondary auditor for advice on what to expect or an   informal assessment before an official audit to help you prepare.     Know the scope of evidence required for an audit. For some   certifications, a year’s worth of past evidence is required.     Make a list of audit evidence required, and identify owners within   your organization for each category of evidence.  249   Chapter 20    ComplianCe     Periodically check that owners understand the evidence required  and their teams are generating the evidence needed for an audit.     Select a reputable third-party auditor with experience in your domain   and who will provide both an official audit result and an internal  report on recommended improvement activities.     Prior to an audit, get the official list from the auditor of evidence   required. Work with owners to obtain the requested evidence.     During the audit, additional information is often requested. Have   parties ready to gather additional evidence.     Conduct a postaudit assessment after an audit to identify what went   well and how to improve the process for the next audit.     Focus on one certification at a time.   Summary Privacy-related compliance is usually mandatory, by virtue of government legislation to  protect people’s privacy and personal data. Security-related compliance may be elective  in some cases, but is undertaken for several reasons: as a sales tool, to efficiently satisfy  customer demands for audits, to demonstrate due diligence and reduce penalties in the  event of a breach, or simply to help you sleep at night. There are myriad privacy laws  and security standards, but there is a lot of overlap across them. Once you’ve passed  a certification for one, you will likely be able to reuse some of the work to satisfy the  requirements of additional compliance frameworks. This chapter concludes our advice  for current projects, so in the last chapter, we’ll share our ideas about why we think  identity management will be even more important and necessary in the future.   Key Points  250     Compliance involves assessing and demonstrating adherence to a set   of controls.  legislation or industry.     Privacy- and security-related compliance may be required by    Chapter 20    ComplianCe     Security-related compliance can be chosen for security and business   advantage in scenarios where it is not mandatory.     Privacy-related legislation is mandatory for entities which meet the   criteria set out in the legislation.     Over 100 countries have enacted privacy-related legislation.xii      In the United States, privacy-related legislation is being enacted by  many states.     Certification against privacy- and security-related compliance   frameworks:     Demonstrates due diligence in protecting data you manage     Can be used as a competitive sales tool     May lessen fines in the event of a breach      Is an efficient way to respond to audit needs of individual  customers     A critical first step for compliance is building an inventory of systems   and the data they contain, along with the reason for collecting any  personal data and how the data is processed.   Notes        i.  https:  unctad.org en Pages DTL STI_and_ICTs ICT4D-  Legislation eCom- Data- Protection-Laws.aspx  ii.  https:  ec.europa.eu commission priorities justice-and- fundamental- rights data-protection 2018-reform-eu-data- protection-rules_en    iii.  http:  ftc.gov reports privacy3 fairinfo.shtm     iv.  www.hhs.gov hipaa for-professionals index.html    v.  www.hhs.gov hipaa for-professionals special-topics  hitech-act- enforcement-interim-final-rule index.html    vi.  www.pcisecuritystandards.org   251   Chapter 20    ComplianCe    vii.  www.vantiv.com vantage-point safer-payments history-of-  pci-data-security- standards   viii.  www.iso.org isoiec-27001-information-security.html    ix.  https:  cloudsecurityalliance.org star _overview    x.  https:  blogs.gartner.com avivah-litan 2014 01 20 how-  pci-failed- target-and-u-s-consumers     xi.  https:  unctad.org en Pages DTL STI_and_ICTs ICT4D-  Legislation eCom- Data- Protection-Laws.aspx    xii.    https:  unctad.org en Pages DTL STI_and_ICTs ICT4D- Legislation eCom- Data- Protection-Laws.aspx  252   CHAPTER 21  Looking into the  Crystal Ball  The future cannot be predicted, but futures can be invented. It was man’s  ability to invent which has made human society what it is.  —Dennis Gabor, Hungarian physicist, 1971 Nobel prize winner in   physics for inventing holography, from Inventing the Future  1963   If we had a crystal ball, what would it show for the future of identity management?  As the swirling mists part in our all-seeing globe, it would undoubtedly show identity  management becoming increasingly necessary in the future for several reasons. First, it  is unlikely that hackers will stop hacking, which means we’ll continue to need security  measures to protect against increasingly diverse and potentially more automated  threats. At the same time, there will be many innovative new services and devices that  will be beneficial in our lives, but they’ll need adequate identity management to reduce  the risk of them being used against us. We’ll also see a rise in autonomous entities  requiring identification, authentication, and authorization just like humans. The notion  of identity will need to spread from humans to all manner of devices, agents, and  robots acting on our behalf, and such entities will need identity management as part  of their defenses against malicious attacks. For all these reasons, the need for identity  management will be more important than ever before, and we’ll need to do a lot more to  make it easier to implement and manage effectively.    Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2_21  253   Chapter 21    Looking into the CrystaL BaLL   Continued Security Challenges For starters, it doesn’t take a crystal ball to predict that we will continue to face ever  more diverse security challenges in the future. The targets and type of cyber-attacks will  continue to diversify as hackers are inspired with new ways to obtain and take advantage  of stolen data and breached resources.   Ongoing Breaches The number of breaches and data records reported every year as compromised shows no  sign of letting up. The number of breaches covered by the Verizon Data Breach Reports  for 2015 to 2019 has hovered just over 2000.i The Gemalto Data Breach Index shows that  the incidence of identity theft in particular has increased in terms of number of records  compromised, from 707 million in 2015 to 3.3 billion in just the first half of 2018.ii It’s  important to remember that any statistics about security incidents and breaches depend  on the events being discovered and voluntarily reported and therefore likely do not  represent the whole picture. A large breach can also skew the numbers from one year to  the next. However, both common sense and the numbers reported each year indicate  that the need for cybersecurity is not going away anytime soon.   Evolving Targets The targets and methods by which stolen data is monetized have been evolving. As  one industry or avenue of theft comes under attack, consumers and service providers  implement mitigations, causing cybercriminals to pivot to easier targets. The financial  industry was an early target, but as financial institutions implemented more defenses,  the entertainment and retail industries came under increasing attack, often as a source  for stolen credit card data. Recent years have seen increased focus on healthcare and  small medium-sized businesses as well.  With the introduction of an EMV microchip in credit cards, and increasing use of   multi-factor authentication in financial services, some hackers have shifted their focus  to stealing identity data and creating new ways to monetize it. Fraudsters have used  stolen identity data to obtain medical services, commit insurance fraud, apply for tax  refunds, and even redeem loyalty club points. Hackers have successfully exploited  vulnerabilities in the Signaling System 7  SS7  system that allows interconnection  between phone networks, in order to intercept SMS text messages commonly used for   254   Chapter 21    Looking into the CrystaL BaLL  multi-factor authentication to protect access to financial accounts and other targets of  value.iii The constant adoption by attackers of new targets and techniques will require  commensurate ongoing evolution in security defenses, including identity management  mechanisms, to protect consumers and businesses.   Diversifying Motives While early hackers often hacked into systems for entertainment and bragging rights, the  motives for hackers have diversified over the years. Financial motives dominate today,  with the 2019 Verizon Data Breach Report indicating that financial motives were behind  71% of the breaches studied.iv Recent years have also seen attacks with other motives  including hacktivism, industrial espionage, cyber espionage by nation states, election  tampering for political gain, and cyberwarfare as a political tool or in support of physical  warfare. The development of comprehensive threat models and mitigation plans will  need to consider a widening array of actors and motives in addition to many new types  of targets.   More Targets There is a dizzying array of new technology available to benefit many aspects of our  life, which unfortunately also creates many new types of targets that require protection.  A wide offering of products, from home security cameras and baby monitors to smart  speakers and HVAC systems, as well as car entertainment systems, health monitoring  devices, and robots, has increased the possibility that malicious actors can threaten  our homes, businesses, cars, and even our bodies from afar. Better security, including  identity management, will be required to protect the devices in our homes and  businesses so they’re not used against us.   Homes and Businesses Smart devices for homes and businesses offer many conveniences, but require security  to prevent them from being used against their owners. Security cameras and baby  monitors have been hacked to spy on people in their homes.v Even smart dolls such  as the My Friend Cayla doll and Furby, designed to interact with children, have been  found to have significant privacy and security issues, being hackable via Bluetooth   255   Chapter 21    Looking into the CrystaL BaLL  connection.vi, vii Smart devices have also been used to enable attacks against other  resources on the same network. A particularly eye-opening example is the hack of a  network-attached sensor for an aquarium heater for a large fish tank in a Las Vegas  casino lobby.viii The sensor provided a conduit for hackers to infiltrate the casino’s  network and exfiltrate data. Without adequate security, the Internet makes it possible for  hackers anywhere in the world to leverage vulnerable network-attached devices, even  innocuous-seeming fish tank heaters, for malicious purposes.   Cars Cars now offer new infotainment systems with an increasing number of helpful services.  Passengers can view movies and play video games. Drivers benefit from onboard  navigation systems, and services like OnStar can provide communication, weather  information, emergency assistance, and remote diagnostics.ix Along with these valuable  services, however, has come a new attack surface, and security researchers have  demonstrated several exploits against it.  In July 2015, news broke of an attack against Jeep Cherokee where two security  researchers demonstrated taking control of a car driving down a highway 10 miles  away.x By exploiting a vulnerability in the Uconnect system which controls the car’s  entertainment system, they were able to send commands from their laptop to the  car’s dashboard, steering, brakes, and transmission.xi This incident was alarming by  demonstrating the potential for a security vulnerability to be exploited to inflict physical  harm on a car’s occupants. Since then, researchers have demonstrated additional  vulnerabilities by compromising a Tesla key fob to steal a Tesla, unlocking and remotely  starting cars with OnStar RemoteLink, and taking control of navigation systems in  Volkswagen and Audi vehicles.xii Cars and the services delivered to them will need to be  designed with adequate security to protect the privacy and physical safety of occupants.   Medical Implants and Monitoring A wide variety of medical devices help us treat chronic conditions and live fuller lives.  Remote patient monitoring  RPM  technologies can be used for monitoring factors such  as blood pressure and pulse, blood sugar levels for diabetes, and even heart function.xiii  Implanted cardiac devices, for example, connect to the heart and provide relief for  several heart conditions including hearts that beat too slowly, too fast, or unevenly.    256   Chapter 21    Looking into the CrystaL BaLL  A monitor often connects wirelessly to retrieve data from the device. Remote monitoring  with implanted cardiac devices provides the ability for doctors to assess patients without  physical visits and detect problems earlier. The technology designed to improve our  health, however, could potentially be used against us if not adequately secured.  In March 2019, a security vulnerability was announced for Medtronic implantable   cardiac devices  implantable cardioverter defibrillator .xiv The devices rely on  the Conexus protocol, which was not designed with any form of authentication,  authorization, or encryption. Data was transmitted in the clear, potentially allowing an  eavesdropper to gather information about a person’s condition. Most alarming, however,  was the possibility that an attacker within 20 feet could reprogram the cardiac device.  The small size of these devices means they may not have the memory or processing  power to run some of the security protocols used in less-constrained environments.  Further innovation and education will be needed to design and deploy efficient but  lightweight security protocols on extremely small capacity devices.   Robots Robots and industrial automation technologies are being designed for many industries  and offer promises of efficiency, accuracy, scale, and performing tasks in environments  dangerous to humans. Robots have been designed for surveillance, monitoring, routine  chores such as vacuuming, disaster response, education, entertainment, manufacturing,  medical applications, autonomous mobility, and research.xv The breadth of applications  for which robots have already been designed is incredible. However, security researchers  have also demonstrated security vulnerabilities in several types of robots.  Security research firm IOActive described a worrying list of security issues in robots   in a paper about a recent investigation they conducted.xvi They evaluated robots used  in homes, businesses, and industry settings, and despite it being a limited study, they  found almost 50 vulnerabilities, including inadequate authentication and authorization,  allowing unauthorized access to robots as well as the ability to install software on the  robots. Communications involving sensitive data were not secured, and encryption of  data was either missing or improperly implemented. The devices were often not secure  by default, and best practices such as changing default administrative passwords were  difficult.  257   Chapter 21    Looking into the CrystaL BaLL  Given the likely widespread use of robots in the future, this should be fairly alarming.   Microphones and cameras in robots can be taken over for cyber espionage purposes  to steal personal information or proprietary corporate information. The security of a  network can be threatened by vulnerable devices attached to the network, meaning  inadequately secured robots could potentially provide a conduit for attackers. Robots  could also be taken over and weaponized, disabled, or held for ransom. Significant  damage could be done if robotic technology is not hardened.   Erosion of Perimeter Protection The computing infrastructure used to deliver services to consumers and businesses  alike has been moving from individual data centers to cloud services and involves logic  running on myriad new types of devices and edge computing servers. This has bypassed  the layer of security once provided by enterprise network perimeters. As a result, identity  management services have become more important to protect the access to individual  infrastructure components. Organizations utilizing many services will need efficient  solutions to provision and manage identities and access privileges across a widening  portfolio of services and devices.  The combination of ongoing threats, evolving targets, a widening circle of actors  and motives, and the bypassing of traditional network perimeter protections result in  an increased need for effective identity management. At the same time, we’re seeing an  explosion in the number and types of entities which need an identity in order to securely  participate on the Internet and access services.   Identity – Not Just for Humans Most of the examples in this book have featured a human user, but there will be more  nonhuman devices and agents in our lives in the future. They will need identities and  the ability to authenticate themselves much like human users. They will also need to  authenticate the services with which they communicate. Some of them may need to  be associated with their owner’s identities, and identity management will be needed to  adequately secure them as well as the services they interact with. The following sections  provide a few examples.  258   Chapter 21    Looking into the CrystaL BaLL   Personal Agents Virtual personal assistants, customer assistants, and employee assistants will become  more capable and connected. Applications on smartphones can use virtual personal  assistants such as Siri or Google Assistant through APIs, enabling users to access app  features and shortcuts from the lock screen or in hands-free mode. Users will be able  to go beyond having assistants do simple tasks like taking notes, setting alarms, and  calling friends to enabling them to perform tasks in applications on their behalf, such as  making purchases or sending payments. Concierge applications might use information  about our habits and preferences to help with tasks like making dinner reservations or  purchasing airline tickets. Without requiring our interaction, smart applications could  help with routine chores like making preventive doctor appointments, regular purchases,  or texting a friend with whom we have a meeting to let them know we’re running late. In  corporate settings, virtual employee assistants could help with tasks such as scheduling  meetings, diagnosing problems, or analyzing data. As virtual personal assistants act  more autonomously, they may need to be authenticated and authorized just like a  human user to ensure they perform authorized tasks and not those of a hacker. They’ll  also need to be capable of authenticating the services with which they interact, to avoid  disclosing sensitive information to incorrect parties.   Autonomous Vehicles Autonomous vehicles will significantly change transportation, but lack of a driver will  shift some identity requirements from drivers to other entities. Humans may need to  identify and authenticate autonomous vehicles that give them a ride as part of mobility  as a service. Entrance gates to secured facilities may need reliable mechanisms to  authenticate autonomous vehicles, rather than drivers, when goods are delivered.  Smart cities may want to authenticate and monitor autonomous vehicles on bridges,  in tunnels, or near critical infrastructure. Autonomous vehicles may even need to  identify and authenticate each other and validate the integrity of software controlling a  nearby car, especially in tight spaces or at high speeds. Just as some networks only allow  managed devices with validated configuration to connect, cities or highways may want  to only allow authenticated and properly secured autonomous vehicles in sensitive  areas.  259    Looking into the CrystaL BaLL  Chapter 21   IoT Devices The potential applications for Internet of Things  IoT  devices are enormous. Smart  thermostats, cameras, TVs, lighting, appliances, toys, medical devices, and a fascinating  diversity of data-collecting sensors are just a few examples. IoT devices that have an  IP address with which to communicate on the Internet, will also need to authenticate  themselves to remote servers and use adequate transmission encryption before  transferring data to protect sensitive data as well as the integrity of uploaded remote  datasets. They will also need to authenticate requests coming from administrative  applications to mitigate the risk of malicious commands and software upload to  the devices. Without identity management and security measures, IoT devices can  potentially be used to spy on their environment and corrupt datasets or, worse, be  hijacked or rendered inoperable for malicious purposes.   Robots Robots will need identities for the same reason as other IoT devices. They will need  to authenticate themselves to services with which they interact, and they will need  to authenticate incoming requests to prevent the robot from being taken over for  unauthorized purposes. Robots will, in general, have significantly more capabilities and  processing power, and therefore the potential for how they can be turned to malicious  purposes may be greater than with smaller, simpler IoT devices like sensors. In addition  to being used for espionage, robots can potentially be taken over and weaponized to  cause physical harm.   On the Horizon There are several promising solutions which bear attention. Efforts by governments and  private consortiums to establish strongly validated identities, more standardized strong  authentication, and new protocols for constrained devices will be rolled out and tested  in real-world scenarios and will benefit identity management.  260   Chapter 21    Looking into the CrystaL BaLL   e-Identity We expect to see more electronic identity initiatives around the world. Governments  face the same pressures as businesses to deliver services more efficiently to distributed  populations, which typically drives pursuit of online delivery for services. At the same  time, many government services must be protected against fraud, which means their  online delivery requires well-validated electronic identity information and stronger  forms of authentication than simple passwords. This is likely to increase interest by  governments in government-issued electronic identities  e-identity  or public-private  sector collaboration for e-identities.  Several governments have already embarked on national e-identity initiatives.   Estonia has a well-established e-identity program that issues a digital identity to citizens  and residents and is used to streamline functions such as accessing government  services, paying taxes, coordinating healthcare, and voting.xvii Estonia is even working on  expanding this to create a digital nation, offering select services to remote e-residents.xviii  Belgium has issued a national digital identity which can be used for identification,  digital signature, and access with public services online.xix A consortium of mobile  phone network providers and banks in Belgium, called Belgian Mobile ID, have created  a mobile application called itsme that enables those with a Belgian e-identity  eID   and mobile phone to register at participating web sites, authenticate, confirm payment  transactions, and digitally sign documents.xx In yet another model, Sweden offers access  to some public services via electronic identities issued by banks.xxi  Electronic identity programs will face some adoption challenges. Cultural distrust of  governments or the banking industry in some countries may hinder e-identity initiatives.  Privacy and security concerns will also need to be addressed. The constitutional validity  of India’s ambitious Aadhaar electronic identity program, for example, faced a lengthy  Supreme Court challenge which hinged on security and privacy concerns.xxii However,  the need for governments to deliver public services efficiently and securely, the desire  by some businesses to leverage more strongly validated identities, and the preference by  citizens and customers to conduct more transactions online will likely drive continued  efforts by governments and private sector consortiums for citizen consumer-facing  e-identities. In addition to validated identity information, such identities will need to  support stronger forms of authentication.  261    Looking into the CrystaL BaLL  Chapter 21   Stronger Authentication We will doubtless see increased adoption of stronger forms of authentication to  mitigate the risks associated with static passwords. The recently finalized W3C  Web Authentication  webauthn  specification creates a more standardized level of  abstraction between applications and specific authenticators. Developers will be able  to implement authenticator-agnostic strong authentication, and users will gain the  ability to use authenticators of their own choosing, whether hardware security tokens  or biometric factors collected by their device. This standard is likely to facilitate the  adoption of stronger forms of authentication and reduce the use of passwords as a sole  authentication factor.   Solutions for Smaller Devices We anticipate ongoing evolution in solutions and protocols to support smaller,  constrained IoT devices that need protections such as authentication, authorization,  message integrity validation, and encryption. Devices with small amounts of RAM and  which need to minimize power consumption to conserve battery life need protocols that  are lightweight and use techniques such as minimizing round trips and overhead as well  as using cryptographic algorithms that enable the use of smaller keys and or certificates.  Entities which need to validate the likes of security messages and certificates depend on  having accurate time as well as solutions for detecting certificate revocations, but existing  solutions may not work on constrained devices. The Constrained Application Protocol   CoAP ,xxiii Transport Layer Security  TLS  1.3,xxiv and Datagram Transport Layer Security   DTLS  1.3xxv may prove useful for solutions involving such devices.   Easier Adoption We need better resources created to make correct implementation of identity  management easier for developers. The specifications we have discussed total over 800  pages. This is a lot for developers to absorb especially when you consider the number  of specifications involved, requiring developers to go back and forth between multiple  documents to coalesce advice and figure out how to apply the technology correctly in  their application and environment. Libraries will be needed that are well documented,  support a good user experience, and help developers implement the protocols  frameworks correctly. To be successful, this will require collaboration between parties   262   Chapter 21    Looking into the CrystaL BaLL  creating or promoting specifications, platform device vendors, user agent vendors   for devices with browsers or other user agents , security analysts, and those creating  libraries and SDKs. A sentiment from John Dickinson’s 1768 “The Liberty Song” says it  best: “By uniting we stand, by dividing we fall.”xxvi   Summary The future will undoubtedly bring increased and more diverse challenges to our online  security. Perimeters that provided a layer of protection in times past, especially in  enterprises, are increasingly bypassed. New threats will arise from the use of many  innovative new services and Internet-connected devices that need to be secured. At  the same time, nonhuman, autonomous entities and agents will act on our behalf and  need to be authenticated, authorized, and monitored just like humans. We’ll need  more strongly validated identity, stronger authentication, and solutions for constrained  devices as well as better resources to help developers do the right thing quickly and  easily.   Key Points  motives.     Security challenges will continue with diversified targets, actors, and      We will face more security and privacy risks from network-connected   devices in our lives such as smart home devices, car infotainment,  and medical monitoring.     The number of nonhuman entities that will need identities   and identity management will grow substantially, considering  technologies such as personal agents, autonomous vehicles, and IoT  devices including robots.     More governments and or private consortiums will issue electronic   identities based on more strongly validated identity information.     Passwords as a single authentication factor will continue to be   replaced with stronger forms of authentication.  263   Chapter 21    Looking into the CrystaL BaLL     Security protocols will need to accommodate the small memory,  processing power, and power consumption requirements of small  IoT devices to better secure them.      Identity management will become even more important in the future  to help protect innovative new services and devices.   Notes        i.  https:  enterprise.verizon.com resources reports dbir   ii.  https:  breachlevelindex.com     iii.  www.telegraph.co.uk technology 2019 02 01 metro-bank-  hit-cyber-attack-used-empty-customer-accounts      iv.  https:  enterprise.verizon.com resources reports   dbir 2019 summary-of-findings     v.  www.cbsnews.com news nest-camera-hacked-hacker-spoke-to- baby-hurled-obscenities-at-couple-using-nest-camera-dad- says     vi.  www.bbc.com news technology-38222472    vii.  www.nytimes.com 2017 12 21 technology connected-toys-  hacking.html   viii.  www.washingtonpost.com news innovations wp 2017 07 21   how-a-fish-tank-helped-hack-a-casino ?noredirect=on&utm_ term=.a22c8c331869    ix.  www.onstar.com us en articles tips top-10-reasons-  onstar-worth-it     x.  www.nytimes.com 2015 07 25 business fiat-chrysler-  recalls-1-4-million-vehicles-to-fix-hacking-issue.html    xi.  www.wired.com 2015 07 hackers-remotely-kill-jeep-  highway   264   Chapter 21    Looking into the CrystaL BaLL    xii.  www.zdnet.com article these-are-the-most-interesting-  ways-to-hack-internet-connected-vehicles    xiii.  www.cchpca.org about about-telehealth remote-patient-  monitoring-rpm    xiv.  www.fda.gov medical-devices safety-communications  cybersecurity-vulnerabilities-affecting-medtronic- implantable-cardiac-devices-programmers-and-home    xv.  https:  robots.ieee.org learn types-of-robots     xvi.  https:  ioactive.com pdfs Hacking-Robots-Before-Skynet.pdf   xvii.  www.newyorker.com magazine 2017 12 18 estonia-the-  digital-republic   xviii.  https:  e-resident.gov.ee    xix.  https:  eid.belgium.be en what-eid    xx.  www.belgianmobileid.be en   xxi.  https:  bolagsverket.se en fee e-services swedish-e-  identification-1.16393   xxii.  https:  iapp.org news a the-indian-supreme-courts-  aadhaar-judgement-a-privacy-perspective    xxiii.  https:  tools.ietf.org html rfc7252section-9   xxiv.  https:  tools.ietf.org html rfc8446   xxv.  https:  datatracker.ietf.org doc draft-ietf-tls-dtls13    xxvi.  http:  archives.dickinson.edu sundries liberty-song-1768  265   CHAPTER 22  Conclusion  I didn’t know I loved so many things and I had to wait until sixty to find it  out sitting by the window on the Prague-Berlin train watching the world  disappear as if on a journey of no return.  —Nâzim Hikmet, Turkish poet, from “Things I Didn’t Know   I Loved”  1962   The world would be a strange place without identity. It’s woven through much of our  lives and enables us to establish trust relationships with others in order to conduct  transactions. When conducting those transactions online, identity management is a core  foundation of security which in turn is a prerequisite for privacy. The complexity of how  to handle identity management well in the face of evolving technology and business  requirements has continued to unfold over time, a bit like a Mandelbrot set. We hope  this book has provided a useful introduction to identity management for those building  applications. We hope you discover you enjoy the challenges presented by this field and  are inspired to learn more. Identity management is a broad topic, and there is a lot more  to learn beyond what we could cover in this book.   We started out by introducing the types of problems faced by developers related   to identity and how trying to solve them might seem like battling a many-headed  Hydra. We covered the key events in the life of an online identity, from provisioning to  deprovisioning, and everything in between, including authentication, authorization,  policy enforcement, step-up and multi-factor authentication, logging out, and account  management. We provided more information on each of these topics in subsequent  chapters to provide an overview on the identity management capabilities a typical  application might need. Our objective was to provide an introductory, practical overview  of such topics, specifically for developers building applications delivered via the Web or     Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2_22  267   Chapter 22    ConClusion  to mobile devices. We hope we’ve provided sufficient background information to help  you get started and more easily understand other resources as you continue learning.  We’ve also shared some lessons learned based on our past experience, such as how   to approach troubleshooting and some of the typical things that can go wrong. We’ve  added some of the less common use cases we’ve come across so you can evaluate at  the beginning of your project if they might apply to your environment. Learning about  additional requirements near the end of a project is never conducive to delivering on  time!  There have unfortunately been many breaches that have compromised identity  information. We collected information on a variety of breaches and researched the  root causes to help you learn from the past. The root causes of many breaches are not  complex, but they do require diligence if they are to be avoided. Pursuing a compliance  certification can help instill the right practices to avoid oversights leading to security  incidents. We added the compliance chapter to help you identify privacy- or security- related requirements you may need to comply with, why compliance can be a beneficial  exercise, and how to approach it.  We closed with a summary of why we think knowledge of identity management will  be even more important in the future. The need for identity management will expand to  all manner of devices, bots, agents, cars, and more. That means a lot more people need  to be familiar with the requirements for identity management and how to solve them. We  hope the information in this book and the sample program helps you understand some  of the scope of what identity management entails. Most of all, we hope this encourages  you to continue to learn more about the topic, to bring the knowledge gained to bear  on your projects, and to find ways to share any new learning or techniques with others.  Ongoing collaboration across the tech community to continually improve identity  management is essential to protect our data, privacy, reputations, and even our physical  safety with the services and devices we use.  268    APPENDIX A  Glossary  The following is a list of terms and their definitions as they are used in this book. Access Token – In the context of OAuth 2.0 and OIDC, a security token used by an  application to call an API.  Account – A construct within a software application or service that usually contains or  is associated with identity information and optionally privileges and which is used to  access features within the application or service.  Application – A software application that issues requests to a server.  Application Programming Interface  API  – A software service interface that allows a  client program to request resources or actions from the software service.  Authorization Code – In the context of OAuth 2.0 and OIDC, an intermediary, opaque  code returned to an application and which represents the application’s authorization by  the user to call an API on the user’s behalf. It is used to obtain security token s .  Authorization Server – A service which implements the OAuth 2.0 protocol and enables  resource owners  users  to authorize applications to access content they own at resource  servers and which issues security tokens enabling the authorized access.  B2B  Business to Business  – A business model where services are targeted to businesses  that use the services in some way to deliver a service to their customers.  B2C  Business to Consumer  – A business model where services are targeted to  consumers who typically act on their own behalf.  B2E  Business to Employee  – A business model where services are targeted to  businesses where the users are the employees of the businesses and act on their  employer’s behalf.    Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2  269   Appendix A    GlossAry  Confidential Client – In the context of OAuth 2.0 and OIDC, an application that runs on  a protected server and can securely store confidential secrets with which to authenticate  itself to an authorization server.  Directory Server – A repository for storing, managing, and organizing information about  resources. Directory server products have often been optimized for storing information  that is frequently read but infrequently modified and used to store information about  entities such as users, access control privileges, application configurations, and network  printers. Information in directory services has been used for authentication and  authorization of users.  End User or User – A human subject using applications or services and who is  authenticated and authorized when accessing protected resources.  HS256 – Hash-based message authentication code  HMAC  using SHA256 hash  function. A symmetric cryptographic algorithm that can be used for creating and  validating a digital signature. It is one option for signing a JSON Web Token, but requires  both the issuer and validator of the token to know the same secret.  Identifier – A single identifying attribute that points to a unique individual user or entity,  within a particular context.  Identity – A set of attributes, including one or more identifiers, associated with a specific  user or entity, in a particular context.  Identity Proofing – The process of vetting a user’s identity and profile information.  Identity Provider  IdP  –  1  A general term for an entity providing an identity service  designed to authenticate users and provide assertions about an authenticated user and  the authentication event.  2  In the context of the SAML 2.0 cross-domain single sign-on  profile specification, a server which issues SAML 2.0 assertions about an authenticated  subject and authentication event.  Identity Repository – A collection of users stored in a computer storage system, such as  a database or directory service.  ID Token – In the context of OIDC, a token used to convey claims about an  authentication event and an authenticated entity to a relying party  application .  270   Appendix A    GlossAry  Internet of Things  IoT  Device – A network-attached device that has an IP address and  is capable of transferring information over a network without human interaction. Usually  refers to dedicated-purpose devices such as sensors or smart appliances as opposed to  general computing devices such as computer servers.  Least Privilege – A security principle of granting the minimum privilege level required  for a task or operating at the lowest possible privilege level for a task.  Mobile Application – An application that executes on a mobile device as a native  application.  Multitenant Application – An application deployment shared by multiple independent  customers whose data is segmented into their own area of the application’s data storage.  The separation between different customers’ data is enforced by the application and its  storage, rather than the network.  Native Application – An application installed and run natively on a computing device.  OpenID Provider – In the context of OIDC, an OAuth 2.0 authorization server that  authenticates a user and returns claims about the user and authentication event to a  relying party  application  in accordance with the OIDC specification. Applications can  delegate user authentication to an OpenID Provider.  Public Client – In the context of OAuth 2.0 and OIDC, an application that executes  primarily on the user’s client device or in the client browser and cannot securely store  secrets with which to authenticate itself to an authorization server.  Refresh Token – In the context of OAuth 2.0 and OIDC, a token that can be used by  an application to request a new access token when a prior access token has expired or  become invalid. With OIDC, a refresh request can optionally return an ID Token as well.  Relying Party – An entity that delegates authentication to an Identity Provider or  OpenID Provider or delegates authorization to an authorization server and, in either  case, relies on the results, usually in the form of security tokens. With OAuth 2.0 an API is  a relying party and with OIDC and SAML V2.0, an application is a relying party.  Resource Owner – In the context of OAuth 2.0, a user that authorizes access to protected  resources hosted at a resource server.  271   Appendix A    GlossAry  Resource Server – In the context of OAuth 2.0 and OIDC, an entity that contains  protected resources.  RS256 – RSA Signature with SHA256 hash algorithm. An asymmetric cryptographic  algorithm that can be used for creating and validating a digital signature. It is one option  for signing a JSON Web Token, and unlike HS256, does not require that the issuer and  validator of the token know the same secret.  Security Domain – A security domain is a logical construct that defines the boundaries  of one entity’s control or ownership.  Service Provider –  1  A general term for an entity providing a service, such as an  application, to a user.  2  In the context of the SAML 2.0 cross-domain single sign-  on profile specification, a client entity which requests SAML 2.0 assertions about an  authenticated subject and authentication event.  Single-Page Application  SPA  – An application with logic that executes primarily in a  browser, by dynamically altering the displayed web page, rather than making requests to  a server to render new pages to respond to user actions. A SPA is assumed to be a public  client, as defined by OAuth 2.0.  User – See the definition for end user.  Web Application or Traditional Web Application – An application with logic that  executes primarily from a protected server, by rendering new pages from the server to  respond to user actions. Traditional web applications are assumed to meet the definition  of a confidential client, as defined by OAuth 2.0.  272    APPENDIX B  Resources for Further  Learning  This appendix lists resources which may be helpful for further learning.   OAuth 2.0 OAuth 2.0 Authorization Framework: https:  tools.ietf.org html rfc6749  OAuth 2.0 Threat Model and Security Considerations: https:  tools.ietf.org html rfc6819  OAuth 2.0 for Browser-Based Apps  Draft as of this writing : https:  tools.ietf.org html draft-ietf-oauth-browser-based-apps-01  OAuth 2.0 for Native Apps: https:  tools.ietf.org html rfc8252  OAuth 2.0 Security Best Current Practice  Draft as of this writing : https:  tools.ietf.org html draft-ietf-oauth-security-topics-12  OAuth 2.0 Device Authorization Grant  Draft as of this writing : https:  tools.ietf.org html draft-ietf-oauth-device-flow-15  OAuth 2.0 Authorization Framework: Bearer Token Usage: https:  tools.ietf.org html rfc6750  Proof Key for Code Exchange by OAuth Public Clients: https:  tools.ietf.org html rfc7636  OAuth 2.0 Token Introspection: https:  tools.ietf.org html rfc7662    Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2  273   Appendix B    ResouRces foR fuRtheR LeARning  OAuth 2.0 Token Revocation: https:  tools.ietf.org html rfc7009  OAuth 2.0 Web Message Response Mode  Draft as of this writing : https:  tools.ietf.org html draft-sakimura-oauth-wmrm-00   JWT JSON Web Token  JWT : https:  tools.ietf.org html rfc7519   OIDC OIDC Specifications: https:  openid.net connect    SAML SAML specifications. See especially the core, bindings, and profile specifications: https:  wiki.oasis-open.org security FrontPage  Security Assertion Markup Language  SAML  V2.0 Technical Overview: www.oasis-open.org committees download.php 27819 sstc-saml-tech- overview- 2.0-cd-02.pdf  SAML Security and Privacy Considerations for the OASIS Security Assertion Markup  Language  SAML  V2.0: http:  docs.oasis-open.org security saml v2.0 saml-sec-consider-2.0-os.pdf   Multi-factor Authentication The FIDO Alliance: https:  fidoalliance.org fido2   WebAuthn: www.w3.org TR 2019 REC-webauthn-1-20190304   274   Appendix B    ResouRces foR fuRtheR LeARning   Background Information An explanation of cookies, including security guidance: https:  developer.mozilla.org en-US docs Web HTTP Cookies  Explanation of Cross-Origin Resource Sharing  CORS : https:  developer.mozilla.org en-US docs Web HTTP CORS  Brief outline of different approaches to authorization and access control: https:  nvlpubs.nist.gov nistpubs Legacy IR nistir7316.pdf  OWASP Top 10 – Critical security risks for web applications and how to avoid them: www.owasp.org index.php Category:OWASP_Top_Ten_Project  OWASP SAML Cheat Sheet: https:  github.com OWASP CheatSheetSeries blob master cheatsheets SAML_ Security_Cheat_Sheet.md  Two sites on open redirects: https:  github.com OWASP CheatSheetSeries blob master cheatsheets  Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md https:  cwe.mitre.org data definitions 601.html  Checking for breached passwords – I’ve Just Launched “Pwned Passwords” V2: www.troyhunt.com ive-just-launched-pwned-passwords-version-2   Privacy A map showing the location and strength of privacy legislation around the world: www.dlapiperdataprotection.com   This web site presents the articles of the GDPR in a convenient fashion: https:  gdpr-info.eu   275    APPENDIX C  SAML V2.0 Authentication  Request and Response  SAML V2.0 authentication request and response messages contain a lot of information.  We’ve assumed that most developers are using an SDK or authentication broker rather  than implementing SAML V2.0 directly in their applications, and therefore their primary  need is to understand SAML V2.0 requests and responses for troubleshooting purposes.  As explained in Chapter 16, the best way to debug issues with SAML V2.0 is to capture  an HTTP trace, extract the SAML V2.0 request and or response, and examine it. In the  following sections, we’ll explain which fields to examine and what to look for.   SAML V2.0 Authentication Request When an application needs a user authenticated by a SAML V2.0 identity provider   IdP , the application redirects the user's browser to the identity provider with a  SAML V2.0 authentication request message. An authentication request message can vary  substantially as many elements are optional. A sample request without a signature might  look like the following  text in bolded italics has been substituted for the actual values :  <samlp:AuthnRequest       xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"       Destination="IDP URL"       ID="ID"       IssueInstant="TIME ISSUED"       ProtocolBinding=          "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"    Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2  277   APPENDIx C    SAML V2.0 AUThENTICATION REqUEST AND RESPONSE        Version="2.0"       ProviderName="SERVICE PROVIDER"       AssertionConsumerServiceURL="ACS URL">     SERVICE PROVIDER     The request elements we have found most useful to check when troubleshooting   SAML V2.0 are shown in Table C-1, along with an explanation for each. A given request  may have more or fewer elements, depending on a particular service provider’s  configuration or implementation.  Table C-1.  Useful SAML V2.0 Authentication Request Elements  Name  Purpose  AssertionConsumer  ServiceURL  URL at service provider to which the identity provider’s authentication  response message should be sent. Often called the “ACS” URL.  AuthnRequest  Destination  ForceAuthn  ID  Issue Instant  Issuer  NameIDPolicy  278  Type of request. In this case, a request to authenticate a user.  URL for the recipient of the request, in this case, the IdP.  This element  was designed to prevent forwarding of messages to unintended  recipients.  This value must match the URL at which the request was  received.  Can be used by requestor to indicate the IdP should prompt the user  for credentials, regardless of the state of the user’s session at the IdP.  The ID is a unique identifier for each request.  When an IDP responds,  the value of the InResponseTo element of the response should match  the ID for the request that triggered the response.  The time at which the request was issued. Identity providers should  reject requests that are outside a certain time tolerance.  Entity which generated the request, namely, the SAML V2.0 service  provider. The IdP should check to make sure a request’s Issuer  element matches a registered service provider.  Can be used by the service provider to specify the type of identifier to  use in identifying the authenticated user. Using an email address is  common, but can conflict with privacy requirements.   continued    APPENDIx C    SAML V2.0 AUThENTICATION REqUEST AND RESPONSE  Table C-1.   continued   Purpose  Name  ProtocolBinding  ProviderName  RequestedAuthnContext  Signature  Subject  Version  The requested mechanism by which the SAML response message  should be sent over an underlying transport protocol.  In practice,  hTTP-POST is often used to avoid issues with browser URL size limits.  human-readable name of entity issuing the SAML V2.0 request  the  service provider .  Can be used by requestor to specify requirements for the  authentication context used by IdP when authenticating the user. Can  be used to request a type or strength level of authentication, as agreed  between service provider and IdP.  Signature information if request has been signed by issuer.  Used to specify the desired subject  user  for the requested  authentication assertion.  The version should be “2.0” for SAML V2.0.  A SAML V2.0 service provider  application  can send a SAML V2.0 request to an  identity provider using a few different bindings. These indicate the mechanism for  sending the message over underlying transport protocols. In practice, the HTTP- Redirect  and HTTP-POST bindings are commonly used because they do not require direct  network connectivity between the service provider and the identity provider. The HTTP- Redirect binding can be used with SAML V2.0 requests that are not digitally signed, but  production environments are recommended to use signed requests to prevent request  tampering. If a request is digitally signed, it typically needs to be sent using the HTTP-  POST binding to avoid issues with browser URL size limits. The response or assertion  from the identity provider must be digitally signed. Due to the size of a signed response,  the HTTP-POST binding is typically used for responses.   SAML V2.0 Authentication Response When an identity provider receives an authentication request, it will authenticate the  user, if necessary, and return an authentication response to the service provider in  the form of a SAML V2.0 response message which contains a SAML V2.0 assertion.   279   APPENDIx C    SAML V2.0 AUThENTICATION REqUEST AND RESPONSE  In the case of an IdP-initiated flow, an IdP may send an unsolicited authentication  response to a service provider. The SAML V2.0 response is an XML message with several  components. The exact contents of the response can vary somewhat, depending on the  nature of the request, the IdP configuration, and the information returned. Figure C-1  shows the high-level anatomy of a typical SAML V2.0 authentication response message  to help you understand the structure of these often lengthy messages.  Note: A Signature  element can be associated with an Assertion, the Response, or both. We have shown it in  the Assertion for this sample.    cid:53  cid:72  cid:86  cid:83  cid:82  cid:81  cid:86  cid:72   cid:44  cid:86  cid:86  cid:88  cid:72  cid:85    cid:54  cid:87  cid:68  cid:87  cid:88  cid:86    cid:36  cid:86  cid:86  cid:72  cid:85  cid:87  cid:76  cid:82  cid:81    cid:44  cid:86  cid:86  cid:88  cid:72  cid:85    cid:54  cid:76  cid:74  cid:81  cid:68  cid:87  cid:88  cid:85  cid:72    cid:54  cid:88  cid:69  cid:77  cid:72  cid:70  cid:87    cid:38  cid:82  cid:81  cid:71  cid:76  cid:87  cid:76  cid:82  cid:81  cid:86    cid:36  cid:88  cid:87  cid:75  cid:81  cid:54  cid:87  cid:68  cid:87  cid:72  cid:80  cid:72  cid:81  cid:87    cid:36  cid:87  cid:87  cid:85  cid:76  cid:69  cid:88  cid:87  cid:72  cid:54  cid:87  cid:68  cid:87  cid:72  cid:80  cid:72  cid:81  cid:87    cid:36  cid:87  cid:87  cid:85  cid:76  cid:69  cid:88  cid:87  cid:72   cid:36  cid:87  cid:87  cid:85  cid:76  cid:69  cid:88  cid:87  cid:72   Figure C-1.  Structure of a Sample SAML V2.0 Authentication Response  A sample SAML V2.0 authentication response is shown in the following sections.  We’ve replaced specific values with explanatory text in bolded italics and provided a  table after each snippet to indicate what’s useful to check when debugging.  280   APPENDIx C    SAML V2.0 AUThENTICATION REqUEST AND RESPONSE   Response A SAML V2.0 authentication response message starts off with “samlp:Response” and  includes the information shown in the snippet that follows and explained in Table C-2.  <samlp:Response       xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"       ID="ID"       InResponseTo="ID OF CORRESPONDING REQUEST"       Version="2.0"       IssueInstant="TIME ISSUED"       Destination="ACS URL of Service Provider">   <saml:Issuer      xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion">   ISSUER OF RESPONSE – IDENTITY PROVIDER                   Table C-2.  SAML V2.0 Authentication Response Elements Useful for  Troubleshooting  Element  Description  InResponseTo This response element should match the ID of the authentication request which   triggered the response  for service provider–initiated cases .  IssueInstant  Destination  Issuer  Status  Time at which the response was issued. This can be checked for correct time to  detect time skew issues. Service providers should reject responses that are older  than a configured time tolerance.  The Assertion Consumer Service  ACS  URL where the service provider receives the  response. Service providers should validate that the Destination URL in the response  is where they received the response.  The issuer of the response. Should match the expected identity provider.  The Status element contains the result of the authentication request.  Successful  authentication is required for a status of “Success.”  281   APPENDIx C    SAML V2.0 AUThENTICATION REqUEST AND RESPONSE   Authentication Assertion  Beginning   The beginning of the assertion element of a response contains an ID, the instant at which  the assertion itself was issued, and the identity of the assertion issuer as shown in the  following snippet and explained in Table C-3.  <saml:Assertion       xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion"       Version="2.0"       ID="ID FOR ASSERTION"       IssueInstant="TIME ASSERTION ISSUED">     ENTITY ISSUING ASSERTION   Table C-3.  SAML V2.0 Authentication Assertion Elements Useful for  Troubleshooting  Element  Description  IssueInstant  Time at which the assertion was issued. This can be checked for correct time to  detect time skew issues. Service providers should reject responses that are older  than a configured time tolerance.  Issuer  The issuer of the response. Should match the expected identity provider.   Digital Signature for Authentication Assertion  The digital signature provides integrity assurance for the signed element. The IdP  must sign either the assertion or the response when the HTTP-POST or HTTP-Redirect  binding is used, and can sign both. The typical elements to check are shown in Table C- 4.  Portions of this element are not shown for brevity.  <Signature       xmlns="http:  www.w3.org 2000 09 xmldsig">               ...       <SignatureMethod  Algorithm=          "http:  www.w3.org 2001 04 xmldsig-morersa-sha256" >                 ...       282   APPENDIx C    SAML V2.0 AUThENTICATION REqUEST AND RESPONSE      DIGITAL SIGNATURE                         CERTIFICATE                  Table C-4.  SAML V2.0 Assertion Signature Elements Useful for Troubleshooting  Element  Description  SignatureMethod  Certificate  Check that the signature algorithm used by the IdP is an algorithm  accepted by the service provider implementation.  Check that the certificate shown is correct for the IdP and matches IdP  metadata configured at service provider.   Subject  The Subject element identifies the authenticated user. A very common issue is that an  identifier specified by the identity provider in the assertion is different from the identifier  expected by a service provider  application  for the user.       <saml:NameID        Format="urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified">   USER IDENTIFIER          <saml:SubjectConfirmation       Method="urn:oasis:names:tc:SAML:2.0:cm:bearer">       <saml:SubjectConfirmationData          NotOnOrAfter="EXPIRATION FOR SUBJECT DATA"          Recipient="SERVICE PROVIDER ACS URL>"          InResponseTo="ID FROM REQUEST" >         283   APPENDIx C    SAML V2.0 AUThENTICATION REqUEST AND RESPONSE  Table C-5.  SAML V2.0 Subject Elements Useful for Troubleshooting  Element  NameID  NotOnOrAfter  Recipient  Description  Contains an identifier for the authenticated user.  Specified validity period for subject data. This time should not have already  passed when the assertion is received.  This element should match the ACS URL to which the response was delivered.  Used by a service provider to ensure it is the intended recipient of an assertion it  receives.  InResponseTo  This element should match the ID of the authentication request which triggered  the response  for service provider–initiated cases .   Conditions  The Conditions element contains conditions on the use of the assertion which should be  checked by a service provider.  <saml:Conditions       NotBefore="BEGIN VALIDITY TIME"       NotOnOrAfter="END VALIDITY TIME">             INTENDED RECIPIENT          Table C-6.  SAML V2.0 Conditions Elements Useful for Troubleshooting  Element  Description  NotBefore  Start of validity period for assertion. This time should have passed when the  assertion is received.  NotOnOrAfter  End of validity period for assertion. This time should not have already passed when  the assertion is received.  Audience  intended recipient  of the assertion. May be specified in URN format.  Used by a service provider to ensure it is the intended recipient of an assertion it  receives.  Audience  284   APPENDIx C    SAML V2.0 AUThENTICATION REqUEST AND RESPONSE   Authentication Statement  The AuthnStatement element indicates when authentication occurred, and  the AuthnContextClassRef can be used to return an indicator of the strength of  authentication mechanism used. This section of the response is not typically a frequent  cause of issues.  <saml:AuthnStatement       AuthnInstant="2019-01-19T19:11:28.407Z"       SessionIndex="SESSION INDEX">                        urn:oasis:names:tc:SAML:2.0:ac:classes:unspecified                 Table C-7.  SAML V2.0 AuthnStatement Elements Useful for Troubleshooting  Element  Description  AuthnContextClassRef  If a particular AuthnContextClassRef was requested, this can be  checked to see if it matches the requested value.   Attribute Statements  Attribute statements are used to convey additional user profile attributes about the user.  A frequent cause of issues is a mismatch between attributes expected by an application  and the attributes delivered in a SAML assertion. The specific attributes will vary across  different applications and identity providers. We have shown two attributes in the  following snippet, one for a user identifier and one for a user’s email address. The list of  attribute statements in an assertion should be checked to ensure all attributes required  by an application are delivered in the assertion.  <saml:AttributeStatement       xmlns:xs="http:  www.w3.org 2001 XMLSchema"       xmlns:xsi="http:  www.w3.org 2001 XMLSchema-instance">  285   APPENDIx C    SAML V2.0 AUThENTICATION REqUEST AND RESPONSE     <saml:Attribute Name="http:  schemas.xmlsoap.org ws 2005 05 identity claims nameidentifier"  NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:uri">                  USER IDENTIFIER                  <saml:Attribute       Name= "http:  schemas.xmlsoap.org ws 2005 05 identity claims emailaddress" NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:uri">                  USER EMAIL ADDRESS                       286    APPENDIX D  Public Key Cryptography  This appendix provides a brief description of how public and private keys are used to  encrypt and sign tokens in a public key cryptography scheme.  With public key cryptography, there is a private key and a public key. The private   key is a long string of random characters. A public key is generated from the private key.  The two keys are called a key pair. The owner of a key pair should keep the private key a  secret, but the public key is designed to be distributed to others and used as described in  the following.  To encrypt a message, the sender uses the public key of the intended recipient to   encrypt the message. Once it is encrypted, only the recipient, who holds the matching  private key, can decipher the message.  To digitally sign a message, the signer uses its private key to digitally sign the   message. The recipient of the message uses the sender’s public key to verify the signature  on the message.    Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2  287    APPENDIX E  Troubleshooting Tools  The following sections contain tools the authors have found useful for troubleshooting  issues with applications using identity protocols.   Capture an HTTP Trace An HTTP trace is essential for troubleshooting many scenarios. The following  instructions indicate how to access trace features in different browsers, at the time of  writing. A search for “How to capture an HTTP trace in  ” should  provide current instructions if the following instructions no longer apply:  Chrome     Open Developer Tools.     Click Network tab.  .har file.  Firefox     Check the “Preserve Log” option, if not already checked.     After capturing a trace, you can right-click to save the trace in a       There is a nice extension called Live HTTP Headers that is handy   with Firefox.  “about:networking”.     Alternatively, you can open a new tab in Firefox and type      The default settings are usually fine, but can be adjusted.     Click Start Logging, then do the actions which cause the issue.     Click Stop Logging, noting the location of where Firefox will save the file.    Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2  289   APPendix e    TRoublesHooTing Tools  Internet Explorer     Press F12 to bring up Developer Tools.     Click the Network tab.     Reproduce the issue.     Click the Save button.  Safari      In Safari Preferences, Advanced, turn on “Show Develop Menu in  Menu bar.”     When viewing a site, use the Develop ➤ Show Web Inspector to view.     Click the Network tab.     Turn on Preserve Log.     Use “Export” to save the HTTP trace to a .har file.   View a HAR File If you can reproduce an authentication authorization issue, you can view the HTTP  trace of the issue in your own browser. However, if you need to view an HTTP Archive file  captured by someone else, the following tools will be useful.  Caution  Remember that HTTP trace files may contain sensitive information such  as passwords or security tokens.  If the tools listed as follows are no longer available, you should be able to find new   ones by searching for “HTTP Archive View” or “How to view a .har file.”  Chrome The Chrome browser supports the ability to import a .har file.     Open Chrome Developer Tools Network tab.     Drag and drop your .har file onto the tab.  290   APPendix e    TRoublesHooTing Tools  Google .har file analyzer Google provides a web site which can be used to view HTTP Archive  .har  files. https:  toolbox.googleapps.com apps har_analyzer   Fiddler Fiddler, another useful network trace tool, can also be used to view .har files. https:  docs.telerik.com fiddler KnowledgeBase ImportExportFormats   Capture a Network Trace To capture API traffic originating from a back-end application component or native  application, you can rely on your favorite debugger or a network trace tool such as the  following:  Fiddler https:  docs.telerik.com fiddler  Charles Proxy www.charlesproxy.com    View Security Tokens The ability to view security tokens issued by identity providers greatly aids the debugging  process. Table E-1 contains some of our favorites.  Table E-1.  Useful Tools for Viewing Security Tokens  Tool  Purpose  https:  jwt.io  Tool provided by Auth0 for viewing JWT tokens  https:  samltool.com  Tool provided by onelogin for viewing sAMl tokens  https:  samltool.io  Tool provided by Auth0 for viewing sAMl tokens  291   APPendix e    TRoublesHooTing Tools   Test APIs A tool for testing API calls, without the added complexity of a client application, can aid  debugging. Table E-2 contains tools we’ve found helpful for testing calls to APIs.  Table E-2.  API Debugging Tools  Tool  Purpose  https:  getpostman.com  Tool for learning, debugging, and testing APi calls  https:  insomnia.rest   Tool for learning, debugging, and testing APi calls  292    APPENDIX F  Privacy Legislation  This section contains information on privacy-related legislation. Countries around the  world are recognizing the need to enact legislation to protect personal information. It  is beyond the scope of this book to provide a comprehensive list of privacy legislation  as the list is long and new legislation is being introduced on an ongoing basis. In fact, at  the time of writing, the privacy legislation in several countries is undergoing significant  revision, in some cases to align more closely with the GDPR.  We will provide resources in the following for learning more about the primary   privacy legislation applicable to the EU, namely, the GDPR, and legislation in the United  States, which takes a sectoral approach to privacy legislation. We’ve also provided  resources to help you find legislation applicable to other countries and to stay on top of  privacy changes around the world.  The information provided in the following does not constitute legal guidance, and  we recommend that organizations consult with legal and privacy professionals in the  development of any privacy compliance efforts.   European Union The European Union updated its 1996 Data Protection Directive with comprehensive  privacy legislation known as the EU GDPR, General Data Protection Regulation.i The  GDPR took effect in 2018 and applies to any entity that receives, stores, or processes data  about persons in the EU and includes stiff fines for noncompliance.  Note that individual countries within the EU may enact additional country-specific   legislation for implementation of the GDPR.    Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2  293   Appendix F    privAcy LegisLAtion   United States In the United States, there are several privacy-related laws rather than one single federal  privacy law. Privacy legislation in the United States uses a sectoral approach with  different laws for different industry sectors and for some individual states:     GLBA  Gramm-Leach-Bliley Act ii – Specifies privacy and security  requirements for the financial industry governing the handling and  protection of NPI  Non-Personal Information .     HIPAA  Health Insurance Portability and Accountability Act iii –   Specifies privacy and security requirements for the healthcare  industry, governing personal data as well as information about a  person’s healthcare, health status, and payment for healthcare.     FTCA  Federal Trade Commission Act iv – Protects consumers   against deceptive or unfair business practices, which may include  uses of personal data that do not conform to published privacy  notices.     FCRA  Fair Credit Reporting Act v and FACTA  Fair and Accurate   Credit Transactions Act vi – Governs protection of personal data,  including a person’s credit score, capacity for credit, and any  personal characteristics related to credit worthiness. It also obligates  financial institutions to implement measures to detect and respond  to suspected instances of identity theft, via the Identity Theft Red   Flag Rule.     CAN-SPAM  Controlling the Assault of Non-Solicited Pornography   and Marketing vii – Governs the use of unsolicited commercial  emails whose primary purpose is advertisement or promotion of  commercial products or services.     TCPA  Telephone Consumer Protection Act viii – Governs   telemarketing calls and the use of automated calls, otherwise known  as robocalls.  294   Appendix F    privAcy LegisLAtion     COPPA  Children’s Online Privacy Protection Act ix – Governs  the collection, use, and disclosure of information about children  under the age of 13 for protection from unfair or deceptive practices.  It places requirements on web sites or online services targeted to  children under 13 or which knowingly have personal data about  children under 13.     VPPA  Video Privacy Protection Act x – Originally established in   1988 and amended in 2012, it governs the protection of personal data  related to rental or sales of videos.  In addition, a patchwork of different privacy laws is being enacted in the absence of   national legislation in the United States. Two examples are     California Consumer Privacy Act  CCPA xi – California has enacted   the California Consumer Privacy Act  CCPA  which takes effect in  January 2020. The CCPA entitles California residents to know what  personal data is being collected, whether it’s sold or shared, the right  to opt out to the sale or sharing of their personal data, access to their  data, and equal service and price even if they exercise their opt-out  choice.     Vermont Data Broker Privacy Lawxii – Vermont has enacted   legislation that applies to data brokers that collect, store, aggregate,  and sell data about data subjects. This applies to brokers who don’t  have a direct relationship with the data subjects. The law requires  data brokers to be transparent about their practices by registering  with the state, secure the data they hold, and to not use personal data  to harass or discriminate against data subjects. The Vermont law also  requires free credit freezes to protect consumers whose identity has  been stolen.  For information on other states, the International Association of Privacy   Professionals has prepared a chart comparing US states’ passage of comprehensive  privacy legislation.xiii  295   Appendix F    privAcy LegisLAtion   Other Countries For information on privacy legislation in other countries, we have found the following  sites useful for identifying privacy laws in each location and tracking news on privacy  changes:     DLA Piper – Data Protection Laws of the Worldxiv     United Nations Conference on Trade and Development – Data   Protection and Privacy Legislationxv      International Association of Privacy Professionals  IAPP  –  Some  content for members only xvi  In reviewing privacy legislation, it is worth noting that in some countries, there is   different legislation for private sector businesses vs. public sector entities, and there may  be additional legislation enacted by regional governments or for specific industries. For  example, in Canada, the Personal Information Protection and Electronic Documents Act   PIPEDA xvii applies to private sector businesses in Canada, whereas the Privacy Actxviii  applies to federally regulated public bodies in Canada. In addition, some Canadian  provinces have enacted additional privacy legislation.   Notes           296  i.  https:  ec.europa.eu commission priorities justice-and- fundamental-rights data-protection 2018-reform-eu-data- protection-rules_en  ii.  www.ftc.gov enforcement statutes gramm-leach-bliley-act    iii.  www.hhs.gov hipaa index.html  iv.  www.ftc.gov enforcement statutes federal-trade-  commission-act    v.  www.ftc.gov enforcement rules rulemaking-regulatory-  reform-proceedings fair-credit-reporting-act    vi.  www.ftc.gov enforcement statutes fair-accurate-credit-  transactions-act-2003   Appendix F    privAcy LegisLAtion    vii.  www.ftc.gov tips-advice business-center guidance can-  spam-act-compliance-guide-business   viii.  www.fcc.gov tags telephone-consumer-protection-act-tcpa    ix.  www.ftc.gov enforcement rules rulemaking-regulatory-  reform-proceedings childrens-online-privacy-protection- rule    x.  www.govinfo.gov content pkg CRPT-112srpt258 html CRPT-  112srpt258.htm    xi.  https:  leginfo.legislature.ca.gov faces billTextClient.  xhtml?bill_id=201720180AB375    xii.  https:  ago.vermont.gov privacy-data-security    xiii.  https:  iapp.org resources article state-comparison-  table     xiv.  www.dlapiperdataprotection.com     xv.  https:  unctad.org en Pages DTL STI_and_ICTs ICT4D-  Legislation eCom- Data- Protection-Laws.aspx   xvi.  https:  iapp.org    xvii.  www.priv.gc.ca en   the-privacy-act    xviii.  www.priv.gc.ca en privacy-topics privacy-laws-in-canada   297    APPENDIX G  Security Compliance  Frameworks  Security frameworks provide a list of controls that represent requirements that would  reasonably be expected of an organization to adequately secure systems and information  under its control. We list here some security frameworks we have had occasion to review,  in two sections. The first section contains general security frameworks that are not  specific to an individual country or government. The second section presents several  security requirements or frameworks that are specific to the United States.   General Security Frameworks The following is a list of security frameworks, in alphabetical order.   Center for Internet Security – Top 20 Controls The CIS Controlsi are a series of 20 foundational cybersecurity controls intended to  eliminate the most common attacks.   Cloud Security Alliance The Cloud Security Allianceii has a mission to promote best practices for security  assurance for cloud providers. CSA has a three-level certification program called CSA  STAR based on a published framework of security controls known as the Cloud Controls  Matrix  CCM .    Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2  299    Security compliAnce FrAmeworkS  Appendix G   ISO 27000 ISO 27000xiii is a family of standards published by the ISO  International Organization for  Standardization  for information security management systems. Figure G-1 shows the  ISO IEC 27000 family of requirements, guidelines, and standards.   cid:57  cid:82  cid:70  cid:68  cid:69  cid:88  cid:79  cid:68  cid:85  cid:92    cid:53  cid:72  cid:84  cid:88  cid:76  cid:85  cid:72  cid:80  cid:72  cid:81  cid:87  cid:86    cid:21  cid:26  cid:19  cid:19  cid:19   cid:44  cid:54  cid:48  cid:54  cid:3  cid:50  cid:89  cid:72  cid:85  cid:89  cid:76  cid:72  cid:90  cid:15  cid:3   cid:57  cid:82  cid:70  cid:68  cid:69  cid:88  cid:79  cid:68  cid:85  cid:92    cid:21  cid:26  cid:19  cid:19  cid:20   cid:44  cid:54  cid:48  cid:54  cid:3  cid:53  cid:72  cid:84  cid:88  cid:76  cid:85  cid:72  cid:80  cid:72  cid:81  cid:87  cid:86    cid:21  cid:26  cid:19  cid:19  cid:25   cid:53  cid:72  cid:84  cid:88  cid:76  cid:85  cid:72  cid:80  cid:72  cid:81  cid:87  cid:86  cid:3  cid:73  cid:82  cid:85  cid:3   cid:38  cid:72  cid:85  cid:87  cid:76  cid:73  cid:76  cid:70  cid:68  cid:87  cid:76  cid:82  cid:81  cid:3  cid:37  cid:82  cid:71  cid:76  cid:72  cid:86    cid:21  cid:26  cid:19  cid:19  cid:28   cid:54  cid:72  cid:70  cid:87  cid:82  cid:85  cid:16  cid:86  cid:83  cid:72  cid:70  cid:76  cid:73  cid:76  cid:70  cid:3   cid:36  cid:83  cid:83  cid:79  cid:76  cid:70  cid:68  cid:87  cid:76  cid:82  cid:81  cid:3  cid:82  cid:73  cid:3  cid:21  cid:26  cid:19  cid:19  cid:20    cid:42  cid:88  cid:76  cid:71  cid:68  cid:81  cid:70  cid:72    cid:21  cid:26  cid:19  cid:19  cid:21   cid:38  cid:82  cid:71  cid:72  cid:3  cid:82  cid:73  cid:3  cid:51  cid:85  cid:68  cid:70  cid:87  cid:76  cid:70  cid:72  cid:3  cid:73  cid:82  cid:85  cid:3   cid:44  cid:81  cid:73  cid:82  cid:54  cid:72  cid:70  cid:3  cid:38  cid:82  cid:81  cid:87  cid:85  cid:82  cid:79  cid:86    cid:21  cid:26  cid:19  cid:19  cid:22   cid:44  cid:54  cid:48  cid:54  cid:3  cid:42  cid:88  cid:76  cid:71  cid:68  cid:81  cid:70  cid:72  cid:3  cid:177   cid:86  cid:83  cid:72  cid:70  cid:76  cid:73  cid:76  cid:70  cid:68  cid:87  cid:76  cid:82  cid:81  cid:15  cid:3  cid:71  cid:72  cid:86  cid:76  cid:74  cid:81    cid:21  cid:26  cid:19  cid:19  cid:23   cid:48  cid:82  cid:81  cid:76  cid:87  cid:82  cid:85  cid:76  cid:81  cid:74  cid:3  cid:68  cid:81  cid:71  cid:3   cid:80  cid:72  cid:68  cid:86  cid:88  cid:85  cid:72  cid:80  cid:72  cid:81  cid:87    cid:21  cid:26  cid:19  cid:19  cid:24   cid:44  cid:81  cid:73  cid:82  cid:54  cid:72  cid:70  cid:3  cid:53  cid:76  cid:86  cid:78  cid:3   cid:48  cid:68  cid:81  cid:68  cid:74  cid:72  cid:80  cid:72  cid:81  cid:87    cid:21  cid:26  cid:19  cid:19  cid:26   cid:42  cid:88  cid:76  cid:71  cid:72  cid:79  cid:76  cid:81  cid:72  cid:86  cid:3  cid:73  cid:82  cid:85  cid:3  cid:44  cid:54  cid:48  cid:54  cid:3   cid:36  cid:88  cid:71  cid:76  cid:87  cid:76  cid:81  cid:74    cid:21  cid:26  cid:19  cid:19  cid:27   cid:42  cid:88  cid:76  cid:71  cid:68  cid:81  cid:70  cid:72  cid:3  cid:82  cid:81  cid:3  cid:44  cid:54  cid:3   cid:38  cid:82  cid:81  cid:87  cid:85  cid:82  cid:79  cid:3  cid:36  cid:86  cid:86  cid:72  cid:86  cid:86  cid:80  cid:72  cid:81  cid:87    cid:21  cid:26  cid:19  cid:20  cid:22   cid:44  cid:81  cid:87  cid:72  cid:74  cid:85  cid:68  cid:87  cid:76  cid:82  cid:81  cid:3  cid:82  cid:73  cid:3  cid:21  cid:26  cid:19  cid:19  cid:20  cid:3   cid:68  cid:81  cid:71  cid:3  cid:21  cid:19  cid:19  cid:19  cid:19  cid:19  cid:16  cid:20    cid:21  cid:26  cid:19  cid:20  cid:23   cid:42  cid:82  cid:89  cid:72  cid:85  cid:81  cid:68  cid:81  cid:70  cid:72  cid:3  cid:82  cid:73  cid:3   cid:44  cid:81  cid:73  cid:82  cid:85  cid:80  cid:68  cid:87  cid:76  cid:82  cid:81  cid:3  cid:54  cid:72  cid:70  cid:88  cid:85  cid:76  cid:87  cid:92    cid:21  cid:26  cid:19  cid:20  cid:25   cid:44  cid:54  cid:48  cid:3  cid:50  cid:85  cid:74  cid:68  cid:81  cid:76  cid:93  cid:68  cid:87  cid:76  cid:82  cid:81  cid:68  cid:79  cid:3   cid:40  cid:70  cid:82  cid:81  cid:82  cid:80  cid:76  cid:70  cid:86    cid:21  cid:26  cid:19  cid:21  cid:20   cid:38  cid:82  cid:80  cid:83  cid:72  cid:87  cid:72  cid:81  cid:70  cid:72  cid:3  cid:73  cid:82  cid:85  cid:3  cid:44  cid:54  cid:48  cid:54  cid:3   cid:51  cid:85  cid:82  cid:73  cid:72  cid:86  cid:86  cid:76  cid:82  cid:81  cid:68  cid:79  cid:86    cid:54  cid:72  cid:70  cid:87  cid:82  cid:85  cid:3   cid:42  cid:88  cid:76  cid:71  cid:68  cid:81  cid:70  cid:72    cid:21  cid:26  cid:19  cid:20  cid:19   cid:42  cid:88  cid:76  cid:71  cid:72  cid:79  cid:76  cid:81  cid:72  cid:86  cid:3  cid:73  cid:82  cid:85  cid:3  cid:76  cid:81  cid:73  cid:82  cid:3   cid:86  cid:75  cid:68  cid:85  cid:76  cid:81  cid:74  cid:3  cid:70  cid:82  cid:80  cid:80  cid:88  cid:81  cid:76  cid:87  cid:76  cid:72  cid:86    cid:21  cid:26  cid:19  cid:20  cid:20   cid:42  cid:88  cid:76  cid:71  cid:72  cid:79  cid:76  cid:81  cid:72  cid:86  cid:3  cid:73  cid:82  cid:85  cid:3  cid:55  cid:72  cid:79  cid:70  cid:82  cid:3   cid:50  cid:85  cid:74  cid:68  cid:81  cid:76  cid:93  cid:68  cid:87  cid:76  cid:82  cid:81  cid:86    cid:21  cid:26  cid:19  cid:20  cid:24   cid:42  cid:88  cid:76  cid:71  cid:72  cid:79  cid:76  cid:81  cid:72  cid:86  cid:3  cid:73  cid:82  cid:85  cid:3   cid:41  cid:76  cid:81  cid:68  cid:81  cid:70  cid:76  cid:68  cid:79  cid:3  cid:54  cid:72  cid:85  cid:89  cid:76  cid:70  cid:72  cid:86    cid:21  cid:26  cid:19  cid:20  cid:26   cid:44  cid:54  cid:3  cid:38  cid:82  cid:81  cid:87  cid:85  cid:82  cid:79  cid:86  cid:3  cid:73  cid:82  cid:85  cid:3  cid:38  cid:79  cid:82  cid:88  cid:71  cid:3   cid:54  cid:72  cid:85  cid:89  cid:76  cid:70  cid:72  cid:86    cid:21  cid:26  cid:19  cid:20  cid:27   cid:51  cid:85  cid:82  cid:87  cid:72  cid:70  cid:87  cid:76  cid:82  cid:81  cid:3  cid:82  cid:73  cid:3  cid:51  cid:44  cid:44  cid:3  cid:76  cid:81  cid:3   cid:51  cid:88  cid:69  cid:79  cid:76  cid:70  cid:3  cid:38  cid:79  cid:82  cid:88  cid:71  cid:86    cid:21  cid:26  cid:19  cid:20  cid:28   cid:44  cid:54  cid:3  cid:38  cid:82  cid:81  cid:87  cid:85  cid:82  cid:79  cid:86  cid:3  cid:73  cid:82  cid:85  cid:3  cid:87  cid:75  cid:72  cid:3   cid:40  cid:81  cid:72  cid:85  cid:74  cid:92  cid:3  cid:56  cid:87  cid:76  cid:79  cid:76  cid:87  cid:92  cid:3  cid:86  cid:72  cid:70  cid:87  cid:82  cid:85   Figure G-1.  ISO IEC 27000 ISMS Standards Family  Each of the standards guidelines in the diagram may be purchased from ISO. A  certified, independent auditor is required to verify compliance with the framework  controls. After an audit of an organization’s evidence of compliance, a report is issued for  the audit period stating if the controls were met. Organizations that pass the audit can  place a certificate seal on their web site.   PCI DSS The PCI DSS  Payment Card Industry Data Security Standard  iv was created by the  payment card industry. Any vendor processing credit card data is expected to be  compliant with the PCI DSS standard. It also applies to other systems that can impact the  security of systems subject to PCI DSS.  300   Appendix G    Security compliAnce FrAmeworkS   US Frameworks The following frameworks are applicable to the United States. They may be applicable  to private sector organizations or applicable to government agencies and those doing  business with them. Even if they are not mandatory for your project, a lot can be learned  about best practices by studying the requirements, which may be useful in preparing for  an audit or future requirements.   CJIS Security Policyv – Criminal Justice Information Ser- vices Security Policy In the United States, the Criminal Justice Information Services  CJIS  Security Policy  governs the protections which must be provided for the handling of personal data  related to criminal justice, including fingerprints and criminal background records.   FFIEC Information Technology Examination Handbook  and Cybersecurity Assessment Toolvi The US Federal Financial Institutions Examination Council  FFIEC  unifies standards  and principles and provides security guidance for financial institutions. The FFIEC has  published the Information Technology Examination Handbook which consists of 11  booklets including one on Information Security. It has also published the Cybersecurity  Assessment Tool which includes principles and standards in the Examination  Handbook. The Cybersecurity Assessment Tool can be used as a self-assessment tool to  prepare for an examination or audit.   FISMA – Federal Information Security Management Actvii FISMA requires each US federal agency to develop, document, and implement  an agency-wide program to provide information security for the information and  information systems that support the operations and assets of the agency, including  those provided or managed by another agency, contractor, or other source. The FISMA  standards include NIST publications FIPS-199, FIPS-200, and the NIST 800 series.  301    Security compliAnce FrAmeworkS  Appendix G   FedRAMP – Federal Risk and Authorization Management  Programviii FedRAMP defines a process for the evaluation, authorization, and monitoring of the  security of cloud service providers used by US federal agencies. FedRAMP approval is  required before a cloud service can be used by a federal agency  with a few very limited  exceptions .   GLBA Safeguards Ruleix This portion of GLBA  Gramm-Leach-Bliley Act  requires financial institutions to have  measures in place to protect personal data, including names, addresses, social security  numbers, bank account, and credit card information, as well as credit and income history.   HIPAAx In the United States, the Health Insurance Portability and Accountability Act has a  security component known as the HIPAA Security Rule. This rule establishes standards  for the protection of electronic personal health information. This includes personal data  related to healthcare, health status, and payment for healthcare.   HITECH Actxi In the United States, the HITECH  Health Information Technology for Economic and Clinical  Health  Act governs the adoption of technology for managing electronic health records.  Subtitle D of this act covers the security and privacy of electronic health information.   NISTxii The National Institute for Standards and Technology in the United States is a  government body that publishes standards. The NIST cybersecurity framework is a  voluntary framework of standards, guidelines, and best practices for cybersecurity.   This framework references the NIST 800 series of publications which provide guidelines  and technical specifications for cybersecurity.  302   Appendix G    Security compliAnce FrAmeworkS   SOC  Service Organization Control   SOC1 A SOC1 report focuses on a service organization’s controls that are likely to be relevant  to an audit of the entity’s financial statements. Control objectives are related to both  business process and information technology. SOC1 reports follow the Statement on  Standards for Attestation Engagements  SSAE  18 standard.   SOC2 Service Organization Control 2 is a set of controls against which a company is audited,  related to security, privacy, confidentiality, processing integrity, and or availability. The  specific set of controls for SOC2 is defined by each company. As the SOC2 assessment  is not based on an open standard set of controls, information on the company-specific  controls is included in the SOC2 report, prepared by an auditor, after a SOC2 compliance  audit. The SOC2 report was created in part because of the rise of cloud computing and  business outsourcing of functions to service organizations. These are called user entities  in the SOC reports. Liability concerns have caused an increase in demand in assurance  of confidentiality and privacy of information processed by companies and organizations.   Notes           i.  www.cisecurity.org controls   ii.  https:  cloudsecurityalliance.org star _overview    iii.  www.iso.org isoiec-27001-information-security.html  iv.  www.pcisecuritystandards.org pci_security maintaining_    v.  www.fbi.gov services cjis cjis-security-policy-resource-  payment_security  center    vi.  https:  www.ffiec.gov cybersecurity.htm     vii.  www.dhs.gov cisa federal-information-security-  modernization-act  303   Appendix G    Security compliAnce FrAmeworkS   viii.  www.fedramp.gov     ix.  www.ftc.gov enforcement statutes gramm-leach-bliley-act;   www.ftc.gov enforcement rules rulemaking-regulatory- reform-proceedings safeguards- rule    x.  www.hhs.gov hipaa for-professionals security index.html    xi.  www.hhs.gov hipaa for-professionals special-topics  hitech-act- enforcement-interim-final-rule index.html    xii.  www.nist.gov cyberframework  304   Index  A, B Access policy enforcement, 13, 113 Account requirements, 221 account linking, 222, 224 delegation, 225 impersonation, 224 mergers and acquisitions, 221 progressive profiling, 224  API, 129  add custom claims, 134, 135 authorization, 52 back-end API, 129 client application, 130 extensibility, 135 front end  see Front-end functions  front-end application, 130 helper function, 132 Introspection specification, 134 JWT-formatted access, 133, 134 OAuth 2.0 scopes, 131 OpenID Provider, 130 processing request, 133 test, 292 user authorization, 131  Authentication, 12, 159  biometric factors, 160 deployment, 165 identity provider request, 163 knowledge-based authentication, 161 multi-factor authentication, 161  OIDC, 164 private cryptographic key, 160 SAML 2.0, 163 session timeouts, 163 static password, 159 step-down, 164 step-up, 162 stronger forms, 160  Authorization, 12  client applications, 119  attributes, 119 delivery, 120 enforcement, 120 OAuth 2.0 request, 120  policy enforcement, 113  application access, 114 data access, 115 functional access, 115  user authorization, 116  delivery, 117 enforcement, 119 profile attributes, 116 transactional attributes, 117 user vs. client application, 115  C Center for Internet Security  CIS , 299 Centralized user repository, 20, 21 Cloud Controls Matrix  CCM , 299  305    Yvonne Wilson, Abhishek Hingnikar 2019  Y. Wilson and A. Hingnikar, Solving Identity Management in Modern Applications,   https:  doi.org 10.1007 978-1-4842-5095-2   INDEX  Cloud Security Alliance  CSA , 299 Compliance  assessment and    certification, 248  competitive advantage, 245 data protection, 244 definition, 241 efficiency, 245 elective compliance   frameworks, 244  GDPR, 242 industry, 243 list of activities, 249 privacy compliance, 247 reduce penalties, 245 security compliance, 247 security privacy standards, 244  Criminal Justice Information Services    CJIS  Security Policy, 301  D Deprovisioning, 17, 187  account termination, 187 certificate of deletion, 191 data transfer, 190 delete account, 188 preserve account record, 189 preserve identities, 189 reprovision requirements, 193 right to erasure, 191 secure deletion, 192  Document-writing app, 124  code-sharing web sites, 124 compliance requirements, 128 features and services, 124 frameworks, 128 identity provider service, 128  306  management requirements, 125  access controls, 127 anonymous document    creation, 126 API calls, 126 provisioning options, 125 sensitive data, 126 session timeout, 127 single sign-on, 127 user logs out, 127 users log in, 125 web-based single-page    application, 126  platform, 128  E Environment requirements, 225  Identity Provider Discovery, 226 multitenant applications, 227 shared workstations, 225  Exceptions, 207 accounts, 207  authentication mechanism, 210 data restore, 207 decommission, 208 orphaned account, 209 takeover, 209  compromised security    information, 214  credentials, 215 personal data, 214 secrets, 215  identity provider, 210 account recovery    requests, 210  breached passwords, 212 brute force attack, 211   system outage  administrative access, 213 authentication, 212 provisioning process, 213  External identity service, 39  characteristics, 40 customer types, 43 factors, 39 government-issued online identity, 41 industry consortium, 42 organization-controlled identity, 42 organizations, 41 self-registered identity, 40 social provider accounts, 42  F Failures, 229  cleartext passwords, 233 encrypt sensitive data, 233 insiders threat, 235 multi-factor authentication, 231 pay attention to process, 229 phishy emails, 230–231 secure coding practices, 233 security vulnerability, 231 Target’s HVAC, 234  Federal Financial Institutions   Examination Council  FFIEC , 301  Federal Information Security   Management Act  FISMA , 301  Federal Risk and Authorization  Management Program   FedRAMP , 302 Front-end functions, 136  API calls, 138 helper functions, 136 logout, 139  INDEX  OpenID Connect, 137 sessions, 138 token management, 139 tokens, 137 user authentication, 137  G General Data Protection    Regulation  GDPR , 242  Gramm-Leach-Bliley Act  GLBA , 302  H Health Insurance Portability and   Accountability Act  HIPAA , 302  Health Information Technology for   Economic and Clinical   Health  HITECH , 302 HTTP Archive View  HAR file   Chrome, 290 Google, 291 Fiddler, 291  HTTP trace  Chrome, 289 Firefox, 289 Internet Explorer, 290 Safari, 290  I, J, K Identifier, 9 Identities, 258  access policy enforcement, 13 account management and recovery, 16 authentication, 12 authorization, 12 autonomous vehicles, 259  307   INDEX  Identities  cont.   definition, 9, 10 deprovisioning, 17 events in life of, 11–17 evolution of, 19–26 IoT devices, 260 logout, 15 multi-factor authentication, 15 personal agents, 259 provisioning, 11, 12 robots, 260 sessions, 13, 14 SSO, 14 step-up authentication, 15  Identity and Access Management  IAM    System, 10, 114  Identity attributes, 44–45, 181  account recovery, 183 advantages disadvantages, 44 credentials reset, 183 enterprise provider, 181 helpdesk reset, 184 password guidance, 184 SCIM protocol, 182 social providers, 181 user profile data, 182 validation, 47  Identity defederation, 221 Identity management, 19, 260  centralized user repository, 20, 21 design questions, 6 easier adoption, 262 e-identity initiatives, 261 federated identity and SAML 2.0, 22, 23 identity challenges, 1–5 OAuth 2.0, 24, 25 OIDC, 25 OpenID protocol, 24  308  per-application identity silo, 20 sample application, 6 smaller devices, 262 SSO servers, 21, 22 standard protocols, 26 stronger authentication, 262 WS-Fed, 23  Identity provisioning  administrative account creation, 36  automated account, 36 cross-domain account, 37 manual account, 36  approaches, 29 invite-only registration flow, 31 leverage external identity service, 38 migration, 32  bulk migration, 34 gradual migration approach, 35 supporting legacy hashing   algorithms, 33  progressive profiling, 31 self-registration, 30  L Logout, 15, 167  application, 172 application session, 171 authentication broker, 171 in designing, 170 identity provider session, 170 multilevel authentication, 177 multiple user sessions, 167 OAuth 2.0, 172 OIDC  back-Channel, 174 front-channel, 173 specification, 173   redirects, 177 relying party client application, 174 SAML 2.0, 175 session termination, 177 SSO, 168 triggers, 169 user sessions, 170  M Multi-factor authentication, 15  N National Institute for Standards and   Technology  NIST , 302  Network trace tool, 291 No email address, 220  O OAuth 2.0, 24, 25  access token, 73 API call, 71 with authorization, 54 authorization code grant, 57 authorization request, 60 + PKCE, 58, 59 response, 62 token endpoint, 62  client credentials, 69 client profiles, 56 confidential vs. public clients, 56 implicit grant, 64  authorization request, 66 URL hash fragment, 65  overview, 53 refresh token, 71  resource owner password    credentials, 67–68  authorization request, 69  resource server, 53 roles, 55 tokens and authorization code, 57 without authorization, 53  OpenID Connect  OIDC     protocol, 25, 77  authentication, 78 authorization code and tokens, 79 authorization code flow, 83  authentication request, 84 authentication response, 87 token requests, 87, 89  client types, 79 endpoints, 80 hybrid flow, 92–94  authentication request, 94 response_types, 93  ID Tokens, 80, 81 implicit flow, 89–91  authentication request, 90 authentication response, 91 parameters, 91  roles, 79 session management, 173–174 UserInfo endpoint, 94–95  OpenID protocol, 24  P, Q, R Payment Card Industry Data Security   Standard  PCI DSS , 300  People requirements, 219  family account, 219 temporary accounts, 220  Per-application identity silo, 20  INDEX  309   INDEX  Privacy legislation  European Union, 293 other countries, 296 United States, 294–295  Private key, 287 Proof Key for Code    Exchange  PKCE , 59  Provisioning phase, 11, 12  S SAML 2.0, 96, 99–110  assertion, 282 attribute statements, 285–286 authentication broker, 107 authentication request, 277–278 authentication response, 279–281 AuthnStatement, 285 condition, 284 configuration, 108 digital signature, 282–283 federated identity, 22, 23 identity federation, 105 identity provider, 100 IdP-initiated flow, 103, 104 overview, 99 protocol binding, 101 SAML assertion, 100 SAML profile, 100 service provider, 101 SP-initiated flow, 102 SSO, 102, 103 subject, 100, 283–284 trust relationship, 101 working principles, 101  Security Assertion Markup Language    SAML  2.0 protocol,   See SAML 2.0  310  Security challenges, 254  diversifying motives, 255 evolving targets, 254 ongoing breaches, 254  Security frameworks CIS controls, 299 CJIS Security Policy, 301 CSA, 299 FedRAMP, 302 FFIEC, 301 FISMA, 301 HIPAA, 302 HITECH, 302 GLBA, 302 ISO 27000, 300 NIST, 302 PCI DSS, 300 SOC, 303–304 US Frameworks, 301  Service Organization    Control  SOC , 303–304  Sessions, 13, 14, 143  application session, 143, 171 authentication broker, 171 continuous authentication, 150 duration, 146, 147 identity provider, 145, 170 multiple sessions, 145 relying parties, 169 renewal, 148 token renewal, 148  Single sign-on  SSO , 14, 151  authentication mechanisms, 155 benefits, 152 consumer-facing environments, 151 definition, 151 identity provider, 154 login page branding, 156   multiple identity providers, 155 servers, 21, 22 session attributes, 154 session duration, 154 trade-offs, 152 working principles, 152  Status transitions, 220 Step-up authentication, 15 System for Cross-domain Identity   Management  SCIM    protocol, 37, 182  T, U Targets, 255 cars, 256 homes and business, 255 medical implants and monitoring, 256 perimeter protections, 258 robots, 257–258  Troubleshooting, 195  API calls, 198 application issue, 200 applications impact, 200 authentication authorization, 201 capture HTTP traces, 197 cross checking, 198  INDEX  environmental factors, 200 HTTP status code, 203 identity protocol, 195 independent browser windows, 196 intermittent problem, 200 JWTs and SAML tokens, 198 parameters in a request, 203 problem replication, 201, 205 sequence of interaction, 202 symptoms and issues, 202 test environment, 196 token contents, 204 tools, 196 trace of HTTP and API calls, 201 users impacted, 199 validation errors, 205 view HTTP traces, 197  V View security tokens, 291  W, X, Y, Z Web Services Federation    Language  WS-Fed , 23 WriteAPaper application, 52, 53  311

@highlight

Know how to design and use identity management to protect your application and the data it manages. At a time when security breaches result in increasingly onerous penalties, it is paramount that application developers and owners understand identity management and the value it provides when building applications. This book takes you from account provisioning to authentication to authorization, and covers troubleshooting and common problems to avoid. The authors include predictions about why this will be even more important in the future. Application best practices with coding samples are provided. Solving Identity and Access Management in Modern Applications gives you what you need to design identity and access management for your applications and to describe it to stakeholders with confidence. You will be able to explain account creation, session and access management, account termination, and more. What You’ll Learn Understand key identity management concepts, Incorporate essential design principles, Design authentication and access control for a modern application, Know the identity management frameworks and protocols used today (OIDC/ OAuth 2.0, SAML 2.0), and Review historical failures and know how to avoid them.