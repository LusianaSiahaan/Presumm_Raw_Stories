Digital Signatures    Jonathan Katz      Digital Signatures                Jonathan Katz  Department of Computer Science University of Maryland A.V. Williams Bldg. College Park, MD 20742 USA jkatz@cs.umd.edu                         e-ISBN 978-0-387-27712-7           ISBN 978-0-387-27711-0  DOI 10.1007 978-0-387-27712-7  Springer New York Dordrecht Heidelberg London    Library of Congress Control Number: 2010927931     Springer Science+Business Media, LLC 2010  All  rights  reserved.  This  work  may  not  be  translated  or  copied  in  whole  or  in  part  without  the  written  permission  of  the  publisher   Springer  Science+Business  Media,  LLC,  233  Spring  Street,  New York, NY 10013, USA , except for brief excerpts in connection with reviews or scholarly analysis.  Use in connection with any form of information storage and retrieval, electronic adaptation, computer  software, or by similar or dissimilar methodology now known or hereafter developed is forbidden.  The use in this publication of trade names, trademarks, service marks, and similar terms, even if they  are not identified as such, is not to be taken as an expression of opinion as to whether or not they are  subject to proprietary rights.    Printed on acid-free paper    Springer is part of Springer Science+Business Media  www.springer.com     To Jill, Abigail, and Rena    Preface  As a beginning graduate student, I recall being frustrated by a general lack of acces- sible sources from which I could learn about  theoretical  cryptography. I remember wondering: why aren’t there more books presenting the basics of cryptography at an introductory level? Jumping ahead almost a decade later, as a faculty member my graduate students now ask me: what is the best resource for learning about  various topics in  cryptography? This monograph is intended to serve as an answer to these questions — at least with regard to digital signature schemes.1  Given the above motivation, this book has been written with a beginning graduate student in mind: a student who is potentially interested in doing research in the ﬁeld of cryptography, and who has taken an introductory course on the subject, but is not sure where to turn next. Though intended primarily for that audience, I hope that advanced graduate students and researchers will ﬁnd the book useful as well. In addition to covering various constructions of digital signature schemes in a uniﬁed framework, this text also serves as a compendium of various “folklore” results that are, perhaps, not as well known as they should be. This book could also serve as a textbook for a graduate seminar on advanced cryptography; in such a class, I expect the entire book could be covered at a leisurely pace in one semester with perhaps some time left over for excursions into related topics. I hope it will also prove helpful to graduate students and researchers in other ﬁelds, such as computer security or mathematics, who want to obtain a more thorough appreciation of digital signatures and known results in this area.  The only real prerequisite for this book is a previous course  at the undergraduate or graduate level  covering the basic foundations of modern cryptography. Specif- ically, I assume the reader has taken a course whose coverage and treatment of cryptography is similar to that of the textbook Introduction to Modern Cryptogra- phy [72] that I have co-authored with Yehuda Lindell. Comfortability with formal deﬁnitions and proofs is expected, and it is assumed the reader is already familiar with, e.g., the RSA and discrete logarithm problems, and the notion of one-way  1 Fortunately, the past few years have seen the publication of some excellent books providing an introduction to the ﬁeld as a whole, as well as books covering other speciﬁc topics in cryptography.  vii   viii  Preface  functions. While I have made an effort to introduce all the necessary background material as needed, the reader will ﬁnd things much more easy going if they have encountered this background material previously. The current book is divided into three sections:    Part I — Setting the Stage. This part includes relevant background material, an overview of digital signatures, and deﬁnitions of security for signature schemes. Even readers with a ﬁrm background in cryptography should skim this part of the book since the deﬁnitions given here include “non-standard” ones such as secu- rity against known- random-message attacks, and “strong” security for signature schemes.   Part II — Digital Signature Schemes without Random Oracles. Parts II and III of the book cover constructions of digital signature schemes. Part II focuses on schemes that can be proven secure without resorting to the “random oracle” model.  A brief introduction to the random oracle model is provided in Chap- ter 6.  This part begins with the important theoretical result showing that signa- tures can be constructed from any one-way function  though a complete proof is given only for the case of one-way permutations . Next, constructions based on the RSA and strong RSA assumptions are presented. Finally, some more recent constructions of signature schemes from bilinear maps are shown. To my knowledge, Part II describes essentially all known classes of signature schemes that do not rely on the random oracle model.   Part III — Digital Signature Schemes in the Random Oracle Model. The signa- ture schemes considered in Part II are, generally speaking, considered too inef- ﬁcient for practical use. Instead, more efﬁcient schemes with proofs of security in the random oracle model are used. Following a brief introduction to the ran- dom oracle model  along with a discussion of its pros and cons , we discuss the two main approaches used in constructing signatures in this setting: building signatures from identiﬁcation schemes, and designing signatures using trapdoor permutations  or variants thereof  and the “hash-and-sign” approach. Unfortunately omitted in this work is any discussion of signature schemes based on speciﬁc, “non number-theoretic” assumptions including those based on knap- sacks, lattices, coding theory, or polynomial equations. I have also decided to focus only on “standard” signature schemes and not to cover any of the multitude of vari- ants  e.g., undeniable, ring, group, homomorphic, . . . signature schemes  that are out there. From a basic theoretical perspective, however, this book is fairly comprehen- sive and will, I hope, serve as a useful primer for the more specialized literature.  Comments and Errata  I am always happy to receive feedback and constructive criticism enabling me to improve this book. I am also always grateful  though less happy  to hear about any   Preface  ix  errors or omissions. Please email any comments to jkatz@cs.umd.edu with “Digital Signatures Book” in the subject line.  Acknowledgments  It gives me great pleasure to acknowledge the unwavering support of my wife, Jill, during the time I wrote this book. I would also like to thank Yehuda Lindell and Bob Stern for allowing me to adapt some of the text from [72] for inclusion here. Finally, I would like to thank Susan Lagerstrom-Fife for her patience and encouragement  prodding?  during the course of this project.  Portions of this book were written during my sabbatical year at IBM. I am grate- ful to Tal Rabin and all the members of the crypto research group at IBM for being such wonderful hosts.  My work on this book was supported in part by the National Science Foundation under grants 0447075, 0627306, and 0716651. Any opinions, ﬁndings, conclu- sions, or recommendations expressed in this book are my own, and do not necessar- ily reﬂect the views of the National Science Foundation.  College Park, MD  Jonathan Katz March 2010    Contents  Part I Setting the Stage  1  2  Digital Signatures: Background and Deﬁnitions . . . . . . . . . . . . . . . . . . . 3 3 1.1 Digital Signature Schemes: A Quick Introduction . . . . . . . . . . . . . . . . 4 1.1.1 Properties of Digital Signatures . . . . . . . . . . . . . . . . . . . . . . . . 6 1.2 Computational Security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 1.2.1 Computational Notions of Security . . . . . . . . . . . . . . . . . . . . . 8 1.2.2 Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1.3 Deﬁning Signature Schemes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 1.4 Motivating the Deﬁnitions of Security . . . . . . . . . . . . . . . . . . . . . . . . . 11 1.5 Formal Deﬁnitions of Security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 1.5.1 Security against Random-Message Attacks . . . . . . . . . . . . . . . 14 1.5.2 Security against Known-Message Attacks . . . . . . . . . . . . . . . . 15 1.5.3 Security against Adaptive Chosen-Message Attacks . . . . . . . 16 1.6 Relations Between the Notions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 1.7 Achieving CMA-Security from Weaker Primitives . . . . . . . . . . . . . . . 19 1.7.1 CMA-Security from RMA-security . . . . . . . . . . . . . . . . . . . . . 19 1.7.2 CMA-Security from KMA-Security . . . . . . . . . . . . . . . . . . . . . 23 1.8 From Unforgeability to Strong Unforgeability . . . . . . . . . . . . . . . . . . . 27 1.9 Extending the Message Length . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 1.10 Further Reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32  Cryptographic Hardness Assumptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 2.1 “Generic” Cryptographic Assumptions . . . . . . . . . . . . . . . . . . . . . . . . . 35 2.1.1 One-Way Functions and Permutations . . . . . . . . . . . . . . . . . . . 36 2.1.2 Trapdoor Permutations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39 2.1.3 Clawfree  Trapdoor  Permutations . . . . . . . . . . . . . . . . . . . . . . 41 2.2 Speciﬁc Assumptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43 2.2.1 Hardness of Factoring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44 2.2.2 The RSA Assumption . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50 2.2.3 The Discrete Logarithm Assumption . . . . . . . . . . . . . . . . . . . . 52  xi   xii  3  4  5  Contents  2.3 Hash Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53 2.3.1 Deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53 2.3.2 The Merkle-Damg˚ard Transform . . . . . . . . . . . . . . . . . . . . . . . 54 2.3.3 Constructing Collision-Resistant Hash Functions . . . . . . . . . . 56 2.3.4 Constructing Universal One-Way Hash Functions . . . . . . . . . 58 2.4 Applications of Hash Functions to Signature Schemes . . . . . . . . . . . . 61 2.4.1 Increasing the Message Length . . . . . . . . . . . . . . . . . . . . . . . . . 61 2.4.2 Reducing the Public-Key Length . . . . . . . . . . . . . . . . . . . . . . . 64 2.5 Further Reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66  Part II Digital Signature Schemes without Random Oracles  Constructions Based on General Assumptions . . . . . . . . . . . . . . . . . . . . . 69 3.1 Lamport’s One-Time Signature Scheme . . . . . . . . . . . . . . . . . . . . . . . . 70 3.2 Signatures from One-Time Signatures . . . . . . . . . . . . . . . . . . . . . . . . . 74 “Chain-Based” Signatures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75 3.2.1 “Tree-Based” Signatures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77 3.2.2 3.2.3 A Stateless Solution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82 3.3 Signatures from One-Way Functions . . . . . . . . . . . . . . . . . . . . . . . . . . 83 3.3.1 Putting the Pieces Together . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83 3.3.2 Thoughts on the Construction . . . . . . . . . . . . . . . . . . . . . . . . . . 83 3.4 Further Reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84  Signature Schemes Based on the  Strong  RSA Assumption . . . . . . . . . 87 4.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87 4.1.1 Technical Preliminaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87 4.1.2 Outline of the Chapter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90 4.2 Signature Schemes Based on the RSA Assumption . . . . . . . . . . . . . . 90 4.2.1 The Dwork-Naor Scheme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91 4.2.2 The Cramer-Damg˚ard Scheme . . . . . . . . . . . . . . . . . . . . . . . . . 97 4.2.3 The Hohenberger-Waters Scheme . . . . . . . . . . . . . . . . . . . . . . 106 4.3 Schemes Based on the Strong RSA Assumption . . . . . . . . . . . . . . . . . 108 4.3.1 The Strong RSA Assumption . . . . . . . . . . . . . . . . . . . . . . . . . . 109 4.3.2 Security Against Known-Message Attacks . . . . . . . . . . . . . . . 109 4.3.3 The Cramer-Shoup Scheme . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112 4.3.4 The Fischlin Scheme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114 4.3.5 The Gennaro-Halevi-Rabin Scheme . . . . . . . . . . . . . . . . . . . . . 117 4.4 Further Reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118  Constructions Based on Bilinear Maps . . . . . . . . . . . . . . . . . . . . . . . . . . . 121 5.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121 5.1.1 Technical Preliminaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121 5.1.2 Outline of the Chapter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122 5.2 The Boneh-Boyen Scheme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123 5.3 The Waters Scheme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127 5.4 Further Reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131   Contents  xiii  Part III Digital Signature Schemes in the Random Oracle Model  6  7  8  The Random Oracle Model. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135 6.1 Security Proofs in the Random Oracle Model . . . . . . . . . . . . . . . . . . . 137 6.2 Is the Random Oracle Methodology Sound? . . . . . . . . . . . . . . . . . . . . 138 6.2.1 Negative Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140 6.3 The Random Oracle Model in Practice . . . . . . . . . . . . . . . . . . . . . . . . . 141 6.4 Further Reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142  Full-Domain Hash  and Related  Signature Schemes . . . . . . . . . . . . . . . 143 7.1 The Full-Domain Hash  FDH  Signature Scheme . . . . . . . . . . . . . . . . 143 7.1.1 An Instantiation Using Bilinear Maps . . . . . . . . . . . . . . . . . . . 145 7.2 An Improved Security Reduction for FDH . . . . . . . . . . . . . . . . . . . . . . 147 7.3 Probabilistic FDH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149 7.4 A Simpler Variant with a Tight Reduction . . . . . . . . . . . . . . . . . . . . . . 151 7.5 Further Reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152  Signature Schemes from Identiﬁcation Schemes . . . . . . . . . . . . . . . . . . . 155 8.1 Identiﬁcation Schemes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156 8.2 From Identiﬁcation Schemes to Signatures . . . . . . . . . . . . . . . . . . . . . 159 8.2.1 The Fiat-Shamir Transform . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159 8.2.2 Two Useful Criteria . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163 8.2.3 One-Time Signature Schemes without Random Oracles . . . . 169 8.3 Some Secure Identiﬁcation Schemes. . . . . . . . . . . . . . . . . . . . . . . . . . . 171 8.3.1 The Fiat-Shamir Scheme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172 8.3.2 The Guillou-Quisquater Scheme. . . . . . . . . . . . . . . . . . . . . . . . 176 8.3.3 The Micali Ong-Schnorr Scheme . . . . . . . . . . . . . . . . . . . . . . . 178 8.3.4 The Schnorr Scheme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180 8.4 Further Reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182  References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185  Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191   Part I Setting the Stage   Chapter 1 Digital Signatures: Background and Deﬁnitions  1.1 Digital Signature Schemes: A Quick Introduction  Loosely speaking, a digital signature scheme offers a cryptographic analogue of handwritten signatures that, in fact, provides much stronger security guarantees. Digital signatures serve as a powerful tool and are now accepted as legally binding in many countries; they can be used for certifying contracts or notarizing docu- ments, for authentication of individuals or corporations, and as components of more complex protocols. Digital signatures also enable the secure distribution and trans- mission of public keys and thus, in a very real sense, serve as the foundation for all of public-key cryptography.  A digital signature scheme is typically used by a signer and a set of potential ver- iﬁers.  Our discussion here will be relatively informal; we defer formal deﬁnitions until later.  The signer begins by running some key-generation algorithm to produce a pair of keys  pk,sk , where pk will be called the signer’s public key — for reasons that will become obvious in a moment — and sk is the signer’s private key  some- times also referred to as its secret key . The signer then publicizes its public key, and we will assume that any potential veriﬁer is in possession of  or can obtain  an authentic copy of the public key pk associated with the signer. We will not focus on the exact details of how a signer disseminates its public key; for concreteness, one can imagine that there is a public directory linking signers to their public keys, and this directory is administered in such a way that it is infeasible for someone to reg- ister a public key in someone else’s name. We stress, however, that in general there will be many signers, each with their own public key, and so any potential veriﬁer must know not only the set of valid public keys, but also which of these public keys belongs to the signer whose signature he is interested in verifying.  Once a signer has established a public key pk as discussed above, digital sig- nature schemes allow the signer to “certify”  or “sign”  a message in such a way that any other party who knows pk can verify that the message originated from the signer and has not been modiﬁed in any way. In more detail, for any message m  that we view simply as a bit-string  the signer can apply a signing algorithm to m using  J. Katz, Digital Signatures, DOI 10.1007 978-0-387-27712-7_1,   Springer Science+Business Media, LLC 2010  3   4  1 Digital Signatures: Background and Deﬁnitions  its private key sk; this results in a signature σ that can be veriﬁed by anyone who knows pk using the corresponding veriﬁcation algorithm.  It will be useful at this point to consider a prototypical usage of a digital signature scheme: Consider a software company that wants to issue software patches updates in an authenticated manner; that is, when the company needs to release a software patch it should be possible for any of its clients to recognize that the patch is authen- tic, and a malicious third party should never be able to fool a client into accepting a patch that was not actually released by the company. To do this, the company can generate a public key pk along with a private key sk, and then distribute pk in some reliable manner to its clients  perhaps bundling the public key along with the initial distribution of the software . When releasing a patch m, the company can then compute a digital signature σ on m using its private key sk, and post  m,σ  on its webpage. Each client can verify the authenticity of m before downloading it by checking that σ is a legitimate signature on m with respect to the public key pk. A malicious party might try to issue a fake patch by spooﬁng the company’s webpage and posting  m cid:48 ,σ cid:48  , where m cid:48  represents a patch that was never released by the company. This m cid:48  might be a modiﬁed version of some previous patch m, or it might be completely new and unrelated to previous patches. If the signature scheme is “secure”  in a sense we will deﬁne more carefully soon , then when the client attempts to verify σ cid:48  it will ﬁnd that this is an invalid signature on m cid:48  with respect to pk, and will therefore reject the signature. Note that in this application it is crucial that the client reject even if the forged patch m cid:48  is modiﬁed only slightly from a genuine patch m.  The above is not just a theoretical application of digital signatures, but one that is used extensively today.  E.g., Microsoft uses exactly this approach when issuing updates to its Windows operating system.   The assumption that parties are able to obtain a legitimate copy of the signer’s public key implies that the signer is able to transmit at least one message  namely, pk itself  in a reliable and authenticated manner. Given this, one may wonder why signature schemes are needed at all! The point is that reliable distribution of pk is a difﬁcult task, but using a signature scheme means that this need only be carried out once, after which an unlimited number of messages can subsequently be sent reliably. Furthermore, signature schemes themselves are used to ensure the reliable distribution of other public keys as part of a public-key infrastructure  PKI .  1.1.1 Properties of Digital Signatures  We have just seen that digital signatures provide a means of authenticating messages sent over a public channel. Signature schemes provide stronger properties as well, and we elucidate these properties via a comparison with message authentication codes, the symmetric-key analogue of digital signatures.  An instance of a message authentication code is deﬁned by a secret key s shared between a  single  sender and a  single  receiver. The sender can certify a message   1.1 Digital Signature Schemes: A Quick Introduction  5  m by applying a message authentication algorithm to m using the shared key s; this results in a “tag” t. The receiver, given m and t, can verify authenticity of m using a corresponding veriﬁcation procedure along with the same key s. As with digital signatures, the security guarantee provided by a message authentication code is that no malicious third party, who does not know s, can forge a valid-looking tag t cid:48  on any message m cid:48  not explicitly authenticated by the sender.  We refer the reader to [72] for a much more in-depth discussion of message authentication codes.   Thus, both message authentication codes and digital signature schemes can be used to ensure the integrity  or authenticity  of transmitted messages. One clear difference, however, is with respect to the initial key establishment phase. Digital signatures fall under the category of public-key cryptography, where a party  i.e., the signer in this case  need only distribute some key over a public, but authenti- cated, channel. With message authentication codes, on the other hand, the sender must share a key over a secret and authenticated channel. Signature schemes also have a decided advantage when a sender wants to issue the same message to multiple recipients. When using a digital signature scheme, this would be done by distribut- ing a single public key and computing a single signature that can be veriﬁed by any potential recipient; in contrast, with a message authentication code the sender would have to establish a separate secret key with each possible receiver, and would have to compute a separate tag  with respect to the appropriate shared key  for each recipient as well.  A qualitative advantage that digital signatures have as compared to message au- thentication codes is that signatures are publicly veriﬁable. This means that if a receiver veriﬁes the signature on a given message as being legitimate, then it is as- sured that all other parties who receive this signed message will also verify it as legitimate. This feature is not achieved by message authentication codes where a signer shares a separate key with each receiver: in such a setting a malicious sender might compute a correct tag with respect to receiver A’s shared key but an incor- rect tag with respect to a different user B’s shared key. In this case, A knows that he received an authentic message from the sender but has no guarantee that other recipients will agree.  Public veriﬁability implies that signatures are transferable: a signature σ on a message m by a particular signer S can be shown to a third party, who can then verify herself that σ is a legitimate signature on m with respect to S’s public key  here, we assume this third party also knows S’s public key . By making a copy of the signature, this third party can then show the signature to another party and con- vince them that S authenticated m, and so on. Transferability and public veriﬁability are essential for the application of digital signatures to certiﬁcates and public-key infrastructures.  Digital signature schemes also provide the very important property of non- repudiation. That is — assuming a signer S widely publicizes his public key in the ﬁrst place — once S signs a message he cannot later deny having done so. This aspect of digital signatures is crucial for situations where a recipient needs to prove to a third party  say, a judge  that a signer did indeed “certify” a particular message  e.g., a contract : assuming S’s public key is known to the judge, or is otherwise   6  1 Digital Signatures: Background and Deﬁnitions  publicly available, a valid signature on a message is enough to convince the judge that S indeed signed this message. Message authentication codes simply cannot pro- vide this functionality. To see this, say users S and R share a key sSR, and S sends a message m to R along with a  valid  MAC tag t computed using sSR. Since the judge does not know sSR  indeed, this key is kept secret by S and R , there is no way for the judge to determine whether t is a valid tag or not. If R were to reveal the key sSR to the judge, there would still be no way for the judge to know whether this is the “ac- tual” key that S and R shared, or whether it is some “fake” key manufactured, after the fact, by R. Even if were to assume that the judge is given the actual key sSR, and can somehow be convinced of this fact, this still would not provide non-repudiation because there is no way for R to prove that it was S who generated t — the very fact that message authentication codes are symmetric  so that anything S can do, R can also do  implies that R could have generated t on its own, and so there is no way for the judge to distinguish between the actions of the two parties.  Because they are non-repudiable and publicly veriﬁable, digital signatures are used frequently to sign contracts, notarize documents, etc. over the Internet, and have been given legal validity in many countries.  Of course, a drawback of digital signatures as compared to message authentica- tion codes is that the latter are roughly 2–3 orders of magnitude more efﬁcient than the former. For this reason, in situations where public veriﬁability, transferability, and or non-repudiation are not needed, and the sender will communicate primarily with a single recipient  with whom it is able to share a secret key , message au- thentication codes are preferred. We remark that there may also be settings where non-repudiation and transferability are speciﬁcally not desired: say, when a signer S wants a particular recipient to be assured that S certiﬁed a message, but does not want this recipient to be able to prove this fact to other parties.  This is sometimes referred to as the property of deniability.  In such a case, a message authentication code  or some more complicated cryptographic primitive  would have to be used.  1.2 Computational Security  One further difference between message authentication codes and digital signature schemes is that there exist message authentication codes that are unconditionally secure when a bounded number of messages are authenticated. Security of digital signature schemes, on the other hand, is inherently computational  even if we bound the number of messages being signed . Speciﬁcally, no signature scheme can be secure against an all-powerful adversary  an “all-powerful adversary” is one with unlimited computational power or, equivalently, unlimited time . Indeed, consider an adversary that, given a signer’s public key pk and a message m, tries all possible values of σ until it ﬁnds one for which Vrfypk m,σ  = 1.  The adversary knows pk, and can therefore compute Vrfypk ·,·  on inputs of his choice.  Now, at least one σ satisfying Vrfypk m,σ  = 1 exists, since it must be possible for the legitimate   1.2 Computational Security  7  signer to generate a valid signature on m. But then the adversary as described will eventually ﬁnd such a σ and succeed in forging a signature.  A second observation is that no signature scheme can be perfectly secure even against a very “weak” adversary. Illustration of this point is even simpler than before: consider an adversary who simply chooses σ at random. Clearly, there is a non-zero probability that the value thus chosen will satisfy Vrfypk m,σ  = 1  again, using the fact that at least one such σ satisfying this condition exists . This adversary does not even require knowledge of the signer’s public key.  Does the above suggest that secure signature schemes are impossible to con- struct? Not at all. Thankfully, hope is not lost if one is willing to relax the security requirements and consider a computational notion of security rather than a perfect one. That is, instead of requiring  as above  that it be impossible for any adversary to forge a signature, we instead demand that it be impossible except with “small” probability for any efﬁcient  i.e., computationally-bounded  adversary to forge a sig- nature; note in particular that this rules out the two attacks sketched above. In this book, we formalize these notions in the standard way  see [72] for further discus- sion , and for completeness we brieﬂy review the details now.  1.2.1 Computational Notions of Security  In moving to the computational setting, we introduce a security parameter k ∈ N that is used to parameterize both the adversary as well as the signature scheme itself; this security parameter can be viewed as quantifying the level of security obtained by a particular instance of the scheme  though this is not quite formally true . In a bit more detail, we view the signer as selecting a security parameter k when gen- erating keys for the scheme; the security parameter will be passed as input to the key-generation algorithm and the length of the public and private keys will depend on k. Following the standard convention in theoretical cryptography, we equate “ef- ﬁcient adversaries” with algorithms running in probabilistic polynomial time  where the running time is measured as a function of k . Since the adversary will be limited to running in polynomial time it is only fair to require that all algorithms executed by the honest parties  e.g., signing, veriﬁcation  should run in polynomial time as well. We abbreviate “probabilistic, polynomial time” as PPT.  An event occurs with “small probability” if the probability that the event occurs  is negligible in k, where this is deﬁned formally as follows: Deﬁnition 1.1. A function ε : N → [0,1] is negligible if for all c ≥ 0 there exists kc ≥ 0 such that ε k    kc. Rephrased, then, a signature scheme satisfying a computational notion of security will have the property that every probabilistic polynomial-time adversary succeeds in forging a signature  with respect to this scheme  with only negligible probabil- ity. In other words, ﬁx some adversary A running in polynomial time and let εA k  denote the probability that A forges a valid signature with respect to some signature   8  1 Digital Signatures: Background and Deﬁnitions  scheme.  We will specify this experiment more carefully when we introduce formal security deﬁnitions.  Then the scheme is secure if εA k  is negligible in k, implying that as the signer increases the value of k, the “success” probability of the adversary A decreases rapidly. It should be stressed that this says nothing about the “absolute” security of the scheme for particular values of k; all guarantees are given only with respect to the asymptotic performance of the scheme. In some sense, then, a larger value of k results in a “more secure” scheme in practice; formally, though, a scheme is either secure or insecure without reference to any particular value of k.  This is best illustrated with an example.  Example 1.1. Imagine a secure signature scheme where the private key is a uni- formly random string of length k, and consider the naive adversary A who performs a brute-force search for the private key for k5 steps.  We assume the adversary can identify a private key that matches a given public key.  The probability that A ﬁnds the correct private key is k5 2k. For k = 30 the adversary runs for 2.4· 107 steps and ﬁnds the private key with probability ≈ 1 50; this would probably not be consid- ered an acceptable level of security in practice  although the scheme itself — viewed asymptotically — is still “secure” . By “dialing up” the security parameter to k = 60 we already obtain a reasonable security guarantee: even if A runs for 7.7· 108 steps, it ﬁnds the private key only with probability 6.7· 10−10.  The example above illustrates the importance of a concrete security analysis — that is, an analysis that quantiﬁes the maximum success probability of any adver- sary running for a speciﬁc amount of time, and attacking a scheme using a speciﬁc value of the security parameter — in addition to the asymptotic one used in formal deﬁnitions of security. As noted already, a scheme proven secure using an asymp- totic security analysis guarantees only that the probability that any polynomial-time adversary “breaks” the scheme becomes negligibly small as the security parameter is increased; it does not say what value of the security parameter to use in practice to ensure a particular level of security against an adversary running in a particular amount of time. This issue will be revisited in Chapter 7, where the concrete security analysis of some practical schemes will be considered.  1.2.2 Notation  In understanding the security of signature schemes, we will be interested in ana- lyzing probabilistic experiments; we introduce some notation  following [61]  that will provide useful shorthand for doing so. Let A be a probabilistic Turing machine. Then A x;r  denotes the output1 of A when A is run on input x and  sufﬁciently- long  random tape r. In case A takes multiple inputs x1, . . . ,xn  that, of course, can always be encoded as a single input , then A x1, . . . ,xn;r  denotes the output of A when run on these inputs and random tape r.  1 All A considered here will halt on all inputs and random tapes, so the value A x;r  is always well-deﬁned.   1.3 Deﬁning Signature Schemes  9  In writing a multi-stage experiment, the notation y := A x;r  simply means that variable y is assigned the value A x;r . If S is a ﬁnite set, then y ← S denotes as- signing to y an element uniformly chosen from S. The notation y1,y2 ← S is taken to mean that y1 and y2 are assigned elements uniformly and independently chosen from S. Generalizing this notation, y ← A x  refers to the experiment in which a random tape r  of the appropriate length  is selected uniformly at random, and then y is assigned the value A x;r ; thus, if A uses a random tape of length  at most   cid:96  on inputs of length x, the notation “y ← A x ” is shorthand for:  r ← {0,1} cid:96 ;y := A x;r .  When A is deterministic y := A x  is equivalent to y ← A x , though we will use the former notation when we wish to emphasize that A is deterministic.  The probability of a particular event E following execution of some experiment expt is written as Pr[expt : E]. Everything to the left of the colon represents the experiment itself  whose components are executed in order, from left to right , and the event of interest is written to the right of the colon. An event may be expressed as a predicate, where the event is said to occur if the predicate is true. As usual, ∧ is the “logical and” operation, ∨ represents “logical or”, {0,1}k denotes the set of binary strings of length k, and if E is an event then E denotes the complement of E  i.e., the event that E does not occur .  1.3 Deﬁning Signature Schemes  Precise deﬁnitions are crucial if we are to understand the security guaranteed by any particular construction, and are essential before we can even hope to have rig- orous proofs of security for the schemes we will develop. For completeness, we begin with a purely functional deﬁnition describing the basic functionality that any signature scheme should achieve; this is followed by a number of different security deﬁnitions detailing various levels of resilience a signature scheme might provide. In the remainder of the chapter, we focus on techniques for amplifying the security of a given signature scheme; i.e., we show how to take a scheme that achieves a relatively weak notion of security and adapt it so as to obtain a new scheme that realizes a stronger notion of security. Such techniques have proven to be very useful in the design and development of secure signature schemes, and we will see many examples of these techniques in the constructions described in later chapters.  Deﬁnition 1.2. A signature scheme consists of three probabilistic, polynomial- time algorithms  Gen, Sign, Vrfy  along with an associated message space M = {Mk} such that:   The randomized key-generation algorithm Gen takes as input the security pa- rameter k  in unary . It outputs a pair of keys  pk,sk  where pk is called the public key or the veriﬁcation key, and sk is called the private key, the secret   10  1 Digital Signatures: Background and Deﬁnitions  key, or the signing key. We assume the security parameter k is implicit in both pk and sk.   For security parameter k, the  possibly randomized  signing algorithm Sign takes as input a secret key sk and a message m ∈ Mk. It outputs a signature σ. We write this as σ← Signsk m . We assume that if m  cid:54 ∈ Mk, the signature algorithm outputs a distinguished symbol ⊥ .   For security parameter k, the deterministic veriﬁcation algorithm Vrfy takes as input a public key pk, a message m ∈ Mk, and a  purported  signature σ. It out- puts a single bit b, with b = 1 signifying “accept” and b = 0 signifying “reject.” We write this as b := Vrfypk m,σ . We assume that if m  cid:54 ∈ Mk, the veriﬁcation algorithm rejects.  When a given public key is understood from the context, we say a message signature pair  m,σ  is valid if Vrfypk m,σ  = 1. We require that for all k, all  pk,sk  output by Gen 1k , all m ∈ Mk, and all σ output by Signsk m , the message signature pair  m,σ  is valid.  It should be clear that the above deﬁnition exactly formalizes the intuitive notion described earlier. Speciﬁcally, a signature scheme is used in the following way. One party S, who acts as the signer, runs Gen 1n  to obtain keys  pk,sk . When S wants to transmit a message m, it computes the signature σ← Signsk m  and sends  m,σ . Upon receipt of  m,σ , a receiver who knows pk can verify the authenticity of m by checking whether Vrfypk m,σ  ?= 1. This establishes both that S sent m, and also that m was not modiﬁed in transit. It is worth emphasizing, however, that successful veriﬁcation does not prove anything about when m was sent, and thus so-called replay attacks are possible. We return to this point later.  Relaxations of the Deﬁnition  We brieﬂy discuss some relaxations of Deﬁnition 1.2.  The correctness requirement in the deﬁnition can be relaxed to allow for a negli- gible probability of error. We ignore this issue for the most part in our presentation, though we caution the reader that some of the schemes we present do indeed have negligible error probability.  Another variation of the above deﬁnition allows the possibility of randomized veriﬁcation algorithms, allowing a negligible probability of error when a correctly- generated signature is veriﬁed. Few schemes in the literature use randomized veriﬁ- cation, and we will not see any examples in this book.  Instead of requiring that the message space be ﬁxed a priori  for each value of k , it is sometimes convenient to allow the set of legal messages to depend on the pub- lic key generated by Gen. When, on occasion, this will be the case for schemes described in this book, it will be evident from the context and so we will not ex- plicitly mention it. Note that for any practical application the message space should consist of all bit-strings  perhaps of some bounded length .   1.4 Motivating the Deﬁnitions of Security  11  It is possible for the signing algorithm to be stateful  rather than stateless as de- ﬁned above : formally, in this case some state s would be initialized to NULL by Gen, and the signing algorithm would take as input the current state s in addition to the message and the secret key, and would output an updated value s cid:48  for the state in addition to the signature.  We stress that the state is not needed in order to verify the signature. Also, the adversary is assumed unable to view the state of the signer unless otherwise speciﬁed.  For the most part, it is viewed as undesirable in prac- tice for a signature scheme to be stateful; the security of some signature schemes, however, crucially depends on the ability of the signing algorithm to maintain such state.  We will see one such example in Chapter 3.  Unless otherwise speciﬁed, we always assume stateless signature schemes.  1.4 Motivating the Deﬁnitions of Security  The basic security guarantee offered by a signature scheme is, roughly speaking, that no efﬁcient adversary should be able to “forge” a valid message signature pair with respect to a public key pk generated by an honest user, even after the adversary “interacts” with this user and thereby obtains legitimate signatures on multiple mes- sages, generated using the private key sk associated with pk. As outlined previously, we will equate “efﬁcient” with the notion of  probabilistic  polynomial time, and will allow the adversary to possibly succeed in outputting a valid forgery with some negligibly-small probability  recall that both the adversary’s running time and its probability of forging a signature are measured as a function of the security param- eter k . To formally specify the desired notion of security, then, it remains to deﬁne two things more precisely: ﬁrst, what it means to “forge” a valid message signature pair; second, what exactly “interacting” with the legitimate user entails. These two components may be speciﬁed independently, leading to numerous possible deﬁni- tions; we explore some of these possibilities here.  Let us ﬁrst, still somewhat informally, discuss some plausible interpretations of what it means to “forge” a valid message signature pair. One immediate observa- tion is that if the legitimate signer himself generates the signatures σ1, . . . ,σ cid:96  on the messages m1, . . . ,m cid:96 , respectively, then the adversary cannot be prevented from replaying a valid message signature pair  mi,σi . Clearly, then, such “replay” at- tacks should not count as forgeries and we will not try to prevent attacks of this sort in our deﬁnitions.2 Given this, a natural approach is to say that an adversary suc- ceeds in constructing a forgery if it generates a valid message signature pair  m,σ  such that m is not one the messages previously signed by the legitimate signer  i.e., m  cid:54 ∈ {m1, . . . ,m cid:96 } ; we will refer to this a forgery of this type as an existential forgery and call a scheme in which such forgeries are infeasible existentially unforgeable.  2 When using a signature scheme as a component of some larger protocol, however, it is certainly important to recognize that such replay attacks can occur and — if needed — protect against such attacks by ensuring that all messages requiring a signature are distinct  by using timestamps or nonces, for example .   12  1 Digital Signatures: Background and Deﬁnitions  We stress that it is not required that m be “meaningful” in any way; indeed, the no- tion of what is “meaningful” is application-dependent and it therefore does not make much sense to incorporate any semantics  or, equivalently, any notion of “meaning- fulness”  in a deﬁnition of security for signature schemes. This has an added beneﬁt: any signature scheme that is existentially unforgeable can be used in any applica- tion that requires access to the functionality provided by signatures, without having to worry about whether the semantics of the application are compatible with any semantics assumed by the signature scheme itself.  A stronger notion termed strong existential unforgeability has recently been in- troduced, and is required for some applications of digital signature schemes. Here, the adversary is said to produce a forgery even if it outputs a new  valid  signature on a previously signed message  this is in addition to the notion of existential unforge- ability deﬁned above ; formally, a forgery occurs whenever the adversary outputs a valid message signature pair  m,σ   cid:54 ∈ { m1,σ1 , . . . , m cid:96 ,σ cid:96  }  where, as before, σi represents a signature on mi that was obtained from the legitimate signer . Notice that this gives a strict generalization of existential unforgeability.  Having discussed the notion of forgery, we turn next to consideration of the pos- sible ways in which an adversary might interact with the legitimate signer. We fo- cus speciﬁcally on two features of this interaction:  1  how many signatures the legitimate signer generates, and  2  what sort of control the adversary has over the messages that are signed. With regard to the ﬁrst question, we will distinguish only between the case where a single signature is generated and the case in which an unbounded number of signatures might be generated. Signature schemes intended for the setting when only a single signature is produced are called one-time signa- tures. Besides the historical reasons for considering this, relatively weak, deﬁnition  in particular, the ﬁrst provably-secure signature scheme was a one-time signature scheme , one-time signatures also serve as useful building blocks of standard signa- ture schemes  as we will see later . One-time signature schemes are also useful in their own right for certain applications.  The second question  namely, the amount of control the adversary has over the messages that are signed  is more interesting. Here, we describe informally three dif- ferent scenarios we will consider, and provide some justiﬁcation as to why each rep- resents a natural class of adversarial behavior in certain settings. We stress, though, that our ultimate goal is to achieve security in the ﬁnal  strongest  scenario; schemes secure within the context of the other two models, however, will serve as useful “stepping stones” toward this goal  see especially Sections 1.7.1 and 1.7.2 . Random-message attack: The ﬁrst scenario we will consider may be viewed as modeling the case wherein the adversary has no control whatsoever over the mes- sages that are signed. As an example, one can imagine here that the adversary merely observes signatures that are produced on messages provided by other  honest  parties. We formalize this by considering an adversary who is given signatures on a sequence of random messages. Although this may seem a poor approximation to the motivating scenario we have just discussed, a little thought shows that no other reasonable option is available without introducing some  a priori unjustiﬁed  assumption regarding the distribution of messages that are   1.4 Motivating the Deﬁnitions of Security  13  signed. Furthermore, there are scenarios in which the messages that are signed are, indeed, random and this then provides an exact model of an adversary’s at- tack; a good example is when a user is authenticated by computing a signature on a random challenge sent by a veriﬁer.  Known-message attack: The adversary is now assumed to have some limited control over what messages are signed, or there may be some deﬁnite pattern in the types of messages likely to be signed  and so a random-message attack is no longer the most appropriate model . We will formalize this attack scenario by granting the adversary control over the messages that are signed, subject to the restriction that the adversary must specify these messages in advance and, in par- ticular, independently of the signer’s public key as well as any of the subsequent signatures the adversary observes. One can view this as modeling a “worst-case” choice of messages to be signed, as long as these messages are not directly under the adversary’s control  and so cannot be changed once the public key is ﬁxed .   Adaptive  chosen-message attack: This model is the strongest possible, in that it grants the adversary complete control over what messages are signed. Specif- ically, the adversary can not only choose these messages after it sees the public key, but can also select messages based on previous signatures  on previously chosen messages  that the adversary observes; hence the term “adaptive.”  We will often omit this term, however, since we do not consider any non-adaptive variant of chosen-message attacks.  One might object that a realistic adversary would never have complete control over what is signed, since surely the legitimate signer will refuse to sign certain messages  e.g., “I am a crook” . As discussed earlier in the context of forgery, however, it makes little sense to impose any semantics on the message space in a deﬁnition of security. Furthermore, there may well be cases  e.g., a signer acting as a notary  when an adversary might have a signiﬁcant amount of control over what is signed. Finally, a major advantage of such a strong attack model — as in the case of our strong deﬁnition of what constitutes a forgery — is that a scheme proven secure against such a strong attack will certainly be secure for any desired application  without having to consider whether the needs of the application “match” the guarantees provided by the security deﬁnition . With the above in mind, we will introduce a number of formal deﬁnitions in the following section corresponding to various combinations of a notion of forgery and an attack model. Speciﬁcally, we will deﬁne the notions of  1  existential unforge- ability for one-time signature schemes;  2  existential unforgeability under random- message attack;  3  existential unforgeability under known-message attack; and  4   strong  existential unforgeability under adaptive chosen-message attack. We introduce the ﬁrst deﬁnition, as we have mentioned, for its historical signiﬁcance as well as for its usefulness in constructing schemes satisfying stronger deﬁnitions of security, as we will see in a later chapter. Similarly, the second and third deﬁnitions will be used in Sections 1.7.1 and 1.7.2 to construct schemes satisfying the fourth  strongest  notion. The last deﬁnition we consider is the strongest possible  at least   14  1 Digital Signatures: Background and Deﬁnitions  with regard to the possibilities discussed above , and has become the de facto notion of security that any “good” signature scheme should satisfy. One may argue that this deﬁnition is “overkill” with respect to what is needed in practice, although we have argued the contrary above. Even if this were true, however, the deﬁnition is surely sufﬁcient for any application of signature schemes in practice, and thus there is a substantial beneﬁt to constructing schemes satisfying this strong notion of security.  1.5 Formal Deﬁnitions of Security  We state our deﬁnitions in a slightly different order than that discussed in the previ- ous paragraph.  1.5.1 Security against Random-Message Attacks  We begin by deﬁning security against random-message attacks. Here, recall, the ad- versary is given no control over what messages are signed; instead, these messages are chosen randomly from the message space. For completeness, we deﬁne both existential unforgeability and strong existential unforgeability.  Deﬁnition 1.3. Signature scheme  Gen, Sign, Vrfy  is existentially unforgeable un- der a random-message attack if for all polynomials  cid:96  ·  and all probabilistic, polynomial-time adversaries A, the success probability of A in the following ex- periment is negligible  as a function of k : 1. A sequence of  cid:96  =  cid:96  k  messages m1, . . . ,m cid:96  are chosen uniformly at random  from the message space Mk.  2. The key-generation algorithm Gen 1k  is run to obtain a pair of keys  pk,sk . 3. Signatures σ1 ← Signsk m1 , . . . ,σ cid:96  ← Signsk m cid:96   are computed. 4. A is given pk and { mi,σi } cid:96  5. A succeeds if  1  Vrfypk m,σ  = 1 and  2  m  cid:54 ∈ {m1, . . . ,m cid:96 }.  i=1, and outputs  m,σ .  The scheme is strongly unforgeable under a random-message attack if for all polynomials  cid:96  ·  and all probabilistic, polynomial-time adversaries A, the success probability of A is negligible  as a function of k  in an experiment deﬁned as above except for the last condition, now changed to: 5 cid:48 . A succeeds if  1  Vrfypk m,σ  = 1 and  2   m,σ   cid:54 ∈ { m1,σ1 , . . . , m cid:96 ,σ cid:96  }.  As a technical point, if the message space depends on the public key then the order of the above experiments is changed so that the public and secret keys are generated ﬁrst, and then the messages are chosen at random from the message space thus deﬁned.  The remainder of the experiment is unchanged.    1.5 Formal Deﬁnitions of Security  15  Just to get comfortable with the notation, note that we can express the deﬁnition above in the following compact way. Signature scheme  Gen, Sign, Vrfy  is existen- tially unforgeable under a random-message attack if for all polynomials  cid:96  ·  and all probabilistic, polynomial-time adversaries A it is the case that εA k  is negligible, where:   {mi} cid:96   εA k  def= Pr   cid:162  i=1 ← Mk;  pk,sk  ← Gen 1k ; ∀i ∈ [ cid:96 ] : σi ← Signsk mi ;  m,σ  ← A pk,{ mi,σi } cid:96    cid:161   i=1   cid:86  : Vrfypk m,σ  = 1 m  cid:54 ∈ {m1, . . . ,m cid:96 }   .  We will continue to write out experiments in full when we present deﬁnitions, but will switch to the more compact notation when writing proofs of security.  It is sometimes also useful to consider a very weak adversary who is allowed to  obtain a signature on only a single message.  Deﬁnition 1.4. Signature scheme  Gen, Sign, Vrfy  is existentially unforgeable un- der a one-time random-message attack if for all probabilistic, polynomial-time adversaries A, the success probability of A in the following experiment is negligible  as a function of k : 1. A message m1 is chosen uniformly at random from the message space Mk. 2. The key-generation algorithm Gen 1k  is run to obtain a pair of keys  pk,sk . 3. Signature σ1 ← Signsk m1  is computed. 4. A is given pk and  m1,σ1 , and outputs  m,σ . 5. A succeeds if  1  Vrfypk m,σ  = 1 and  2  m  cid:54 = m1.  The scheme is strongly unforgeable under a one-time random-message at- tack if for all probabilistic, polynomial-time adversaries A, the success probability of A is negligible  as a function of k  in an experiment deﬁned as above except for the last condition, now changed to: 5 cid:48 . A succeeds if  1  Vrfypk m,σ  = 1 and  2   m,σ   cid:54 =  m1,σ1 .  One can, by extension, also consider  cid:96 -time attacks for any polynomial  cid:96 . Note, however, the distinction between the resulting notion of security and Deﬁnition 1.3: in the former case,  cid:96  is ﬁxed a priori and the signature scheme is allowed to depend on  cid:96 , whereas in the case of Deﬁnition 1.3 the scheme is ﬁxed and then security is required to hold for any  polynomial   cid:96 .  1.5.2 Security against Known-Message Attacks  We now deﬁne security against known-message attacks. Here, recall, the adversary is able to choose what messages are signed, but it must make this choice in advance of seeing the public key. Again, for completeness, we include a deﬁnition of strong unforgeability also.   16  1 Digital Signatures: Background and Deﬁnitions  Deﬁnition 1.5. Signature scheme  Gen, Sign, Vrfy  is existentially unforgeable un- der a known-message attack if for all polynomials  cid:96  ·  and all probabilistic, polynomial-time adversaries A, the success probability of A in the following ex- periment is negligible  as a function of k : 1. A 1k  outputs a sequence of  cid:96  =  cid:96  k  messages m1, . . . ,m cid:96  ∈ Mk. 2. The key-generation algorithm Gen 1k  is run to obtain a pair of keys  pk,sk . 3. Signatures σ1 ← Signsk m1 , . . . ,σ cid:96  ← Signsk m cid:96   are computed. 4. A is given pk and {σi} cid:96  5. A succeeds if  1  Vrfypk m,σ  = 1 and  2  m  cid:54 ∈ {m1, . . . ,m cid:96 }.  We assume that A is a stateful algorithm, and in particular is allowed to maintain state between steps 1 and 4.  The scheme is strongly unforgeable under a known-message attack if for all polynomials  cid:96  ·  and all probabilistic, polynomial-time adversaries A, the success probability of A is negligible  as a function of k  in an experiment deﬁned as above except for the last condition, now changed to: 5 cid:48 . A succeeds if  1  Vrfypk m,σ  = 1 and  2   m,σ   cid:54 ∈ { m1,σ1 , . . . , m cid:96 ,σ cid:96  }.  i=1, and outputs  m,σ .  A subtle point arises, again, in case the message space depends on the public key; in that case, it becomes difﬁcult  or impossible  to formally deﬁne a notion of security against known-message attacks. In almost any “natural” signature scheme, however — and certainly any scheme used in practice — there is some set M cid:48  k of messages that is always contained in the message space, regardless of the public key.  For example, M cid:48  k might consist of all bit-strings of some given length, such that these strings can be embedded in the message space regardless of the public key.  We can then restrict the adversary to outputting messages in M cid:48  k. Another possibility occurs when the public key can be split naturally into two components, only the ﬁrst of which determines the message space; in this case, the experiment can be modiﬁed so the adversary is given only the ﬁrst component of the public key before being asked to generate the messages to be signed. In the rest of the book, we will implicitly make assumptions of this sort when dealing with security against known- message attacks.  We can, of course, also deﬁne existential unforgeability  and strong unforgeabil- ity  under a one-time known-message attack. Since a deﬁnition is exactly analogous to Deﬁnition 1.4, we do not give such a deﬁnition here.  1.5.3 Security against Adaptive Chosen-Message Attacks  We now deﬁne the strongest attack model, in which the adversary can adaptively choose messages to be signed, depending both on the public key as well as on any previous signatures it has obtained. To capture this formally, we will provide the adversary oracle access to a so-called signing oracle Signsk · . This oracle should   1.5 Formal Deﬁnitions of Security  17  be thought of as a “black box” that computes signatures under the ﬁxed secret key sk: the adversary can submit any input m to this oracle, and will receive in return the signature σ← Signsk m . An important point is that the signing key sk used by the oracle is exactly the one generated along with the public key pk in the experiment; that is, the adversary is obtaining signatures that are valid with respect to public key it is “attacking.” It is to be stressed that the signing oracle is not meant to represent any physical device to which the adversary has access in the real world. Rather, this oracle is simply a convenient means to model the adversary’s interaction with the signer, under the assumption that the adversary can convince the signer to sign any messages of the adversary’s choice  as justiﬁed in Section 1.4 .  Deﬁnition 1.6. Signature scheme  Gen, Sign, Vrfy  is existentially unforgeable un- der a chosen-message attack if for all probabilistic, polynomial-time adversaries A, the success probability of A in the following experiment is negligible  as a func- tion of k : 1. The key-generation algorithm Gen 1k  is run to obtain a pair of keys  pk,sk . 2. A is given pk and allowed to interact with a signing oracle Signsk · , requesting signatures on as many messages as it likes.  We denote this by ASignsk ·  pk .  Let M denote the set of messages queried to the signing oracle by A.  3. Eventually, A outputs  m,σ . 4. A succeeds if  1  Vrfypk m,σ  = 1 and  2  m  cid:54 ∈ M.  The scheme is strongly unforgeable under a chosen-message attack if for all probabilistic, polynomial-time adversaries A, the success probability of A in the following experiment is negligible  as a function of k : 1. The key-generation algorithm Gen 1k  is run to obtain a pair of keys  pk,sk . 2. A is given pk and allowed to interact with a signing oracle Signsk · , requesting signatures on as many messages as it likes. Let Q = { mi,σi } where mi denotes the ith query made by A to the signing oracle, and σi is the ith response.  3. Eventually, A outputs  m,σ . 4. A succeeds if  1  Vrfypk m,σ  = 1 and  2   m,σ   cid:54 ∈ Q.  In both deﬁnitions, we assume that A is a stateful algorithm.   The attack considered in the above deﬁnition is often called an adaptive chosen- message attack in the literature, but since we do not consider any “non-adaptive” variant we often drop the extra qualiﬁer.  Since we will refer to it often, we also deﬁne the corresponding notion of security  for one-time attacks.  Deﬁnition 1.7. Signature scheme  Gen, Sign, Vrfy  is existentially unforgeable un- der a one-time chosen-message attack if for all probabilistic, polynomial-time ad- versaries A, the success probability of A in the following experiment is negligible  as a function of k :   18  1 Digital Signatures: Background and Deﬁnitions  1. The key-generation algorithm Gen 1k  is run to obtain a pair of keys  pk,sk . 2. A is given pk and allowed to request a signature on a single message m1. In return  it is given σ1 ← Signsk m1 .  3. A outputs  m,σ . 4. A succeeds if  1  Vrfypk m,σ  = 1 and  2  m  cid:54 = m1.  The scheme is strongly unforgeable under a one-time chosen-message attack if for all probabilistic, polynomial-time adversaries A, the success probability of A in the following experiment is negligible  as a function of k : 1. The key-generation algorithm Gen 1k  is run to obtain a pair of keys  pk,sk . 2. A is given pk and allowed to request a signature on a single message m1. In return  it is given σ1 ← Signsk m1 .  3. A outputs  m,σ . 4. A succeeds if  1  Vrfypk m,σ  = 1 and  2   m,σ   cid:54 =  m1,σ1 .  As usual, both deﬁnitions assume that A is a stateful algorithm.   1.5.3.1 Terminology  By default, when we talk about “security” of a digital signature scheme we mean ex- istential unforgeability  with respect to the appropriate attack model ; we often also write “unforgeability” in place of “existential unforgeability”. For brevity, we occa- sionally refer to security against random-message attacks, known-message attacks, and chosen-message attacks as RMA-security, KMA-security, and CMA-security, respectively.  By way of terminology, we say that an adversary A “forges a signature on a new message” or “outputs a forgery” whenever A outputs a message signature pair  m,σ  such that Vrfypk m,σ  = 1 and A was not previously given any signature on m. We say that A “outputs a strong forgery” whenever A outputs a message signature pair  m,σ  such that Vrfypk m,σ  = 1 and A was not previously given the signature σ on the message m. Note that whenever A outputs a forgery then it also outputs a strong forgery.  1.6 Relations Between the Notions  The deﬁnitions in the previous section lead to a strict hierarchy of security guaran- tees  assuming that there exist secure signature schemes to begin with . That is:   There exist signature schemes that are existentially unforgeable under a one-time chosen-message attack that are not existentially unforgeable under a chosen- message attack  indeed, it is not hard to see that the scheme we show in Sec-   1.7 Achieving CMA-Security from Weaker Primitives  19  tion 3.1 has exactly this property , and similarly for random-message attacks and known-message attacks.   There exist signature schemes that are existentially unforgeable under a random- message attack but that are not existentially unforgeable under a known-message attack. Similarly, there are signature schemes that are existentially unforgeable under a known-message attack but that are not existentially unforgeable under a chosen-message attack. In both cases, constructing a convoluted scheme proving these assertions is relatively straightforward but we are unaware of any “natural” schemes with these properties.  We stress, however, that a number of natural schemes can be proven secure with respect to a weaker notion of security while no proof is known that they satisfy a stronger notion of security.    There exist signature schemes that are existentially unforgeable under a chosen- message attack, but that are not strongly unforgeable  even if the adversary ob- tains a signature on only a single random message .  The above observations motivate the importance of choosing a scheme satisfying the appropriate deﬁnition of security for the application at hand; one cannot simply “assume” that a scheme satisfying a weak deﬁnition automatically satisﬁes stronger deﬁnitions as well. On the other hand, if a particular application requires a signature scheme only satisfying a weaker notion of security, then one can hope to improve efﬁciency by using a scheme satisfying exactly that notion  and nothing stronger .  1.7 Achieving CMA-Security from Weaker Primitives  As discussed at the end of the previous section, the weaker notions of security we have deﬁned — security against random-message attacks and security against known-message attacks — may provide meaningful guarantees in certain restricted settings. More interesting, perhaps, is their usefulness is constructing schemes satis- fying our strongest deﬁnition: security against chosen-message attacks. In this sec- tion, we explore this possibility and show how schemes secure with respect to a weaker notion can be converted to schemes secure within the strongest attack model. The constructions we show are not only interesting from a theoretical point of view but have practical signiﬁcance as well: numerous schemes rely on the ideas used in the following constructions, and the conversions themselves are relatively efﬁ- cient  decreasing the efﬁciency of the original, weaker scheme by roughly a factor of two .  1.7.1 CMA-Security from RMA-security  We begin by showing how to construct a CMA-secure scheme based on any RMA- secure one. The basic idea is to ‘split’ each message m being signed into two random pieces mL,mR subject to the constraint that mL ⊕ mR = m. Then mL and mR are   20  1 Digital Signatures: Background and Deﬁnitions  signed using two independent instances of the RMA-secure scheme.  To prevent an adversary from mixing-and-matching pieces from two different signed messages, a random nonce is chosen and signed along with each piece.  The details follow.  Construction 1.1: CMA-security from RMA-security   pkR,skR .  We use “L” and “R” to stand for “left” and “right”.   Let Π =  Gen, Sign, Vrfy  be a signature scheme for message of length k + q k . Construct the signature scheme Π∗ =  Gen∗, Sign∗, Vrfy∗  for messages of length q = q k  as follows: Key generation: Algorithm Gen∗ 1k  is deﬁned as follows:   Run two  independent  invocations of Gen 1k  to obtain the keys  pkL,skL ,   The public key is pk∗ =  pkL, pkR  and the secret key is sk∗ =  skL,skR . Signature generation: Algorithm Sign∗   Parse sk∗ as skL,skR.   Choose r ← {0,1}k and mL ← {0,1}q. Set mR := m⊕ mL.   Compute σL ← SignskL r cid:107 mL  and σR ← SignskR r cid:107 mR , where “ cid:107 ” denotes con-   Output the signature σ∗ =  r,mL,mR,σL,σR . Signature veriﬁcation: Algorithm Vrfy∗ pk m,σ∗  is deﬁned as follows: Parse σ∗ as  r,mL,mR,σL,σR  and pk as  pkL, pkR . Then, output 1 iff m ?= mL ⊕ mR and both  sk∗ m  is deﬁned as follows:  catenation.  and  VrfypkL r cid:107 mL, σL  ?= 1  VrfypkR r cid:107 mR, σR  ?= 1.  It is easy to see that the scheme above is correct.  It is not strictly necessary to in- clude mR in the signature output by Sign∗, but it makes the description of the scheme a bit more transparent.  The following theorem shows that the above construction achieves the desired level of security: Theorem 1.1. If Π =  Gen, Sign, Vrfy  is existentially unforgeable  resp., strongly unforgeable  under a random-message attack, then Π∗ =  Gen∗, Sign∗, Vrfy∗  given by Construction 1.1 is existentially unforgeable  resp., strongly unforgeable  under an adaptive chosen-message attack.  Proof. We focus on the case of strong unforgeability, but the claim regarding ex- istential unforgeability follows by examination of the proof. The intuition is sim-   1.7 Achieving CMA-Security from Weaker Primitives 21 ple: in scheme Π∗, the “messages” signed by the underlying signature scheme Π  namely, r cid:107 mL and r cid:107 mR  are always individually uniform, regardless of the adver- sary’s choice of m. Of course, the joint distribution of r cid:107 mL and r cid:107 mR depends on m, but it is their individual distributions we are interested in since r cid:107 mL and r cid:107 mR are each signed using a different secret key. This suggests that security of Π against a random-message attack is sufﬁcient to prove security of Π∗ against a chosen- message attack. The only hitch is that if a nonce value r is ever used twice, then sig- nature forgery becomes trivial. For example, if an adversary obtains the signature  r,mL,mR,σL,σR  on message m and signature  r,m cid:48  R  on message m cid:48 , then this means that σL is a valid signature on r cid:107 mL with respect to pkL, and σ cid:48  R is a valid signature on r cid:107 m cid:48   R with respect to pkR. Thus, the adversary can output  R,σ cid:48   L,m cid:48   L,σ cid:48   R,σL,σ cid:48   r,mL,m cid:48  R , a valid signature on the message mL ⊕ m cid:48  R  and this message is likely not equal to either of m or m cid:48  . Fortunately, it is not hard to show that the probability of using any nonce twice is small. Turning to the formal proof, let A∗ be a PPT adversary attacking Π∗ and denote by  m,σ∗  ← ExptA∗,Π∗ 1k  the experiment   pk∗,sk∗  ← Gen∗ 1k ; m,σ∗  ←  A∗ Sign∗  sk ·  pk∗ .  Let Forge be the event that Vrfy∗ Deﬁnition 1.6. Deﬁne  SuccA∗,Π∗ k  def= Pr  pk∗ m,σ∗  = 1 and  m,σ∗   cid:54 ∈ Q, where Q is as in  cid:104   cid:105   m,σ∗  ← ExptA∗,Π∗ 1k  : Forge  ,  and note that this is exactly the success probability of A∗ as deﬁned in Deﬁnition 1.6. Thus, our goal is to show that SuccA∗,Π∗ k  is negligible. Let  cid:96  =  cid:96  k  denote the maximum number of queries made by A∗ to its sign- ing oracle on security parameter k, and assume without loss of generality that A∗ always makes exactly this many queries; note that  cid:96  must be polynomial since A∗ runs in polynomial time. In a given execution of ExptA∗,Π∗ 1k , let mi denote the ith message submitted by A∗ to its signing oracle, and let σ∗ i =  ri,mL,i,mR,i,σL,i,σR,i  denote the ith signature received. Denote by σ∗ =  r∗,m∗ L,m∗ R  the compo- nents of the signature output by A∗. Now deﬁne the following events:  L ,σ∗  R,σ∗    Let Repeat denote the event that two signatures obtained by A∗ from its signing oracle use the same value for the nonce r, that is, that ri = r j for some i  cid:54 = j.   Let QL = { ri cid:107 mL,i, σL,i } denote the set of “left” message signature pairs. Let ForgeL denote the event that VrfypkL r∗ cid:107 m∗ L   cid:54 ∈ QL. L,σ∗   Similarly, let QR = { ri cid:107 mR,i, σR,i } be the set of “right” message signature pairs, and let ForgeR be the event that VrfypkR r∗ cid:107 m∗ R   cid:54 ∈ QR. R, σ∗ We claim that whenever Forge occurs, at least one of Repeat, ForgeL, or ForgeR occurs. To see this, assume Forge occurs and Repeat does not occur. Since Forge  L, σ∗ R  = 1 and  r∗ cid:107 m∗  L  = 1 and  r∗ cid:107 m∗ R,σ∗   L,σ∗  R,σ∗  1 Digital Signatures: Background and Deﬁnitions L  = 1 and VrfypkR r∗ cid:107 m∗  22 occurs, we know that VrfypkL r∗ cid:107 m∗ R  = 1. Since Repeat does not occur, we know that r∗ = ri for at most one value of i. There are two cases to consider: Case 1: r∗ is not equal to ri for any value of i. In this case, we clearly have r∗ cid:107 m∗ ri cid:107 mL,i for all i and so, in particular,  r∗ cid:107 m∗ occurs.  By a symmetric argument, ForgeR occurs in this case as well.  Case 2: r∗ = ri for some  unique  i. If both  m∗ L  =  mL,i,σL,i  and  m∗ R  =  mR,i,σR,i , then we have m = mi and σ∗ = σ∗ in contradiction to the fact that L   cid:54 =  m,σ∗   cid:54 ∈ Q  since Forge occurred . Thus, it must be the case that either  m∗ R   cid:54 =  mR,i,σR,i   in which case  mL,i,σL,i   in which case ForgeL occurs  or  m∗ ForgeR occurs .  L  cid:54 = L   cid:54 ∈ QL. This means that ForgeL  R,σ∗ L,σ∗  L, σ∗  R,σ∗  L,σ∗  i  We conclude that  Pr[ExptA∗,Π∗ 1k  : Forge] ≤ Pr[ExptA∗,Π∗ 1k  : ForgeL] + Pr[ExptA∗,Π∗ 1k  : ForgeR] + Pr[ExptA∗,Π∗ 1k  : Repeat].   1.1   We show that each of the terms on the right-hand side is negligible, thus completing the proof of the theorem. We deal with the term that is easiest to analyze ﬁrst.  Claim. Pr[ExptA∗,Π∗ 1k  : Repeat] is negligible. Proof. The claim follows easily from a “birthday problem” calculation.  See [72, Appendix A.4] for further information.  Speciﬁcally, We have  cid:96  nonces r1, . . . ,r cid:96  chosen uniformly from the set {0,1}k of size 2k. The probability that two of these values are equal is at most  cid:96 2 2k+1, which is negligible in k.  Claim. Pr[ExptA∗,Π∗ 1k  : ForgeL] is negligible. Proof. To prove this claim, we reduce to the strong unforgeability of Π. Consider the following PPT adversary A, using A∗ as a subroutine and attacking Π in a random-message attack:   cid:96  ∈ {0,1}k+q.  Algorithm A: The algorithm is given a public key pk, generated using Gen 1k , along with  cid:96  signatures σ1, . . . ,σ cid:96  on the random messages m cid:48  1, . . . ,m cid:48    Set pkL := pk.   Run Gen 1k  to obtain keys  pkR,skR .   Set pk∗ :=  pkL, pkR  and run A∗ pk∗ .   When A∗ requests a signature on the ith message mi, do:  1. Let ri be the ﬁrst k bits of m cid:48   i, and let mL,i be the last q  bits of m cid:48  i.  2. Set σL,i := σi.   1.7 Achieving CMA-Security from Weaker Primitives  23  3. Set mR,i := mi ⊕ mL,i. 4. Compute σR,i ← SignskR ri cid:107 mR . 5. Return the signature  ri,mL,i,mR,i,σL,i,σR,i  to A∗.   When A∗ outputs  m, σ∗ =  r∗,m∗ put  r∗ cid:107 m∗  L ,σ∗  R,σ∗  L,m∗  L, σ∗ L .  R  , then out-  Observe ﬁrst that A provides a perfect simulation for A∗; that is, the view of A∗ when run by A  and when pk is generated by Gen 1k   is identically distributed to the view of A∗ in ExptA∗,Π∗ 1k . It is easy to see that the public key pk∗ is identically distributed in both experiments. As for the answers to the signing queries of A∗, note that these, too, are distributed identically in both cases; here, we rely on the fact that the m cid:48   i are chosen uniformly  and independently  at random.  To conclude the proof, we merely observe that A outputs a strong forgery when- ever ForgeL occurs. So, the success probability of A attacking Π in the sense of Deﬁnition 1.3  i.e., with respect to a random-message attack  is exactly equal to Pr[ExptA∗,Π∗ 1k  : ForgeL]. Since Π is assumed to be strongly unforgeable under a random-message attack, this must be negligible.  An exactly analogous argument shows that Pr[ExptA∗,Π∗ 1k  : ForgeR] is negli- gible. Since each term on the right-hand side of Equation  1.1  is negligible, we conclude that the success probability of A∗ in attacking Π∗ under a chosen-message attack is negligible. This completes the proof of the theorem.  1.7.2 CMA-Security from KMA-Security  In this section we show how to construct a signature scheme that is secure against chosen-message attacks from any scheme secure under a known-message attack. Note that since any KMA-secure scheme is also RMA-secure, we could also just as well use the construction from the previous section. Nevertheless, the construction described here offers an alternate approach that is sometimes more efﬁcient when applied to particular schemes. The key idea here is to use a level of indirection. Let Π be a KMA-secure scheme, and let Π cid:48  be a KMA-secure one-time signature scheme. We construct a CMA- secure scheme Π∗ as follows: the public key pk is generated using Π. To sign a message m, the signer generates a fresh public key pk cid:48  using Π cid:48 ; signs pk cid:48  with respect to pk; and signs m with respect to pk cid:48 . Note that this “indirection” removes any dependence between any “message” and the public key with respect to which it is signed: m is independent of pk cid:48 , and pk cid:48  is independent of pk. Details follow. We stress that a fresh key pair  pk cid:48 ,sk cid:48   is generated each time a new message is signed. It is easy to see that the above scheme is correct. We now prove that it realizes the desired level of security.   24  1 Digital Signatures: Background and Deﬁnitions  Construction 1.2: CMA-security from KMA-security Let Π cid:48  =  Gen cid:48 , Sign cid:48 , Vrfy cid:48   be a signature scheme in which the public keys have length q = q k , and let Π =  Gen, Sign, Vrfy  be a signature scheme in which the message space Mk includes all bit-strings of length q k . Construct the signature scheme Π∗ =  Gen∗, Sign∗, Vrfy∗ , whose message space is exactly the message space of Π cid:48 , as follows: Key generation: Gen∗ 1k  simply runs Gen 1k  to generate keys  pk,sk . These are the public and secret keys, respectively. Signature generation: Algorithm Sign∗ 1. Run Gen cid:48  1k  to generate keys  pk cid:48 ,sk cid:48  . 2. Sign pk cid:48  using sk: i.e., compute σ← Signsk pk cid:48  . 3. Sign m using sk cid:48 ; i.e., compute σ cid:48  ← Sign cid:48  sk cid:48  m . 4. Output the signature σ∗ =  pk cid:48 ,σ,σ cid:48  . Signature veriﬁcation: Algorithm Vrfy∗ pk m,σ∗  is deﬁned as follows: Parse σ∗ as  pk cid:48 ,σ,σ cid:48  . Then output 1 if and only if σ is a valid signature on pk cid:48   with respect to pk  and σ cid:48  is a valid signature on m  with respect to pk cid:48  ; i.e., output 1 if and only if both  sk m  is deﬁned as follows:  and  Vrfypk pk cid:48 ,σ  ?= 1  Vrfy cid:48   pk cid:48  m,σ cid:48   ?= 1.  Theorem 1.2. If Π =  Gen, Sign, Vrfy  is existentially unforgeable  resp., strongly unforgeable  under a known-message attack and Π cid:48  =  Gen cid:48 , Sign cid:48 , Vrfy cid:48   is un- forgeable  resp., strongly unforgeable  under a one-time known-message attack, then Π∗ =  Gen∗, Sign∗, Vrfy∗  is existentially unforgeable  resp., strongly unforge- able  under an adaptive chosen-message attack.  1,σ1,σ cid:48   Proof. We prove the theorem for the case of existential unforgeability, but a proof for the case of strong unforgeability can be derived by making suitable modiﬁca- tions. The intuition here is again rather straightforward. Assume the adversary ob- tains a sequence of signatures  pk cid:48  1 , . . . on messages m1, . . . chosen adap- tively by the adversary. A key observation is that if an adversary forges a signature  pk cid:48 ,σ,σ cid:48   on a new message m, then it must be the case that either pk cid:48  = pk cid:48  i for j for all i  cid:54 = j; as we will see, some i, or not.  We assume here for simplicity pk cid:48  this assumption is not needed in the formal proof.  If pk cid:48  = pk cid:48  i, then the adversary has effectively forged a signature σ cid:48  on new message m with respect to scheme Π cid:48  and the public key pk cid:48  i; otherwise, the adversary has effectively forged a signature σ on the new “message” pk cid:48  with respect to scheme Π and public key pk. Further-  i  cid:54 = pk cid:48    1.7 Achieving CMA-Security from Weaker Primitives  25  more, we may note that all “messages” being signed are chosen independently of the corresponding public key: in particular, the keys {pk cid:48  i} that are signed using PK are chosen by the signer  who generates them independently of each other as well as independently of the key PK , and each message mi — although chosen by the adversary — is chosen before the adversary knows the value of the key pk cid:48  i that will be used to sign mi. For this reason, security of Π,Π cid:48  under a known message at- tack is sufﬁcient.3 Moreover, it sufﬁces for Π cid:48  to be unforgeable under a one-time known-message attack since every key pk cid:48  i is used to sign only a single message mi. We now proceed with the formal proof. Given a PPT adversary A∗ attacking the signature scheme Π∗, denote by  m, pk cid:48 ,σ,σ cid:48   ← ExptA∗,Π∗ 1k  the experiment:   pk,sk  ← Gen∗ 1k ; m, pk cid:48 ,σ,σ cid:48   ←  A∗ Sign∗  sk ·  pk .  Let mi denote the ith message submitted by A∗ to its signing oracle, and let { pk cid:48  i  } denote the ith signature received in return. Let Forge be the event i,σi,σ cid:48  that Vrfy∗ pk m, pk cid:48 ,σ,σ cid:48   = 1 and m  cid:54 ∈ {mi}, and deﬁne Succ∗   cid:104   cid:105   m, pk cid:48 ,σ,σ cid:48   ← ExptA∗,Π∗ 1k  : Forge  A∗,Π∗ k  def= Pr  ;  this is exactly the success probability of A∗ in attacking scheme Π∗ in the sense of Deﬁnition 1.6. Our goal is to show that Succ∗ attempted forgery. That is, let Reuse be the event that pk cid:48  = pk cid:48  deﬁne  We will now condition on whether or not A∗ re-uses one of the keys pk cid:48   i in his i for some i, and then  A∗,Π∗ k  is negligible.   cid:105   cid:104   cid:105   cid:104   m, pk cid:48 ,σ,σ cid:48   ← ExptA∗,Π∗ 1k  : Forge∧ Reuse  m, pk cid:48 ,σ,σ cid:48   ← ExptA∗,Π∗ 1k  : Forge∧ Reuse  .  SuccResue  A∗,Π∗ k  def= Pr A∗,Π∗ k  def= Pr  SuccReuse  Of course, we have:  Succ∗  A∗,Π∗ k  = SuccResue  A∗,Π∗ k  + SuccResue  A∗,Π∗ k .  We show that each of the terms on the right-hand side is negligible. We assume without loss of generality in what follows that A∗ always requests signatures on exactly  cid:96  =  cid:96  k  messages for some polynomial  cid:96 .  A∗,Π∗ k  is negligible.  Claim. SuccResue Proof. We construct a PPT adversary A, using A∗ as a subroutine, that attacks Π in a A∗,Π∗ k . Security known-message attack and succeeds with probability exactly SuccResue of Π thus yields the claim. The algorithm A is deﬁned as follows: 3 Observe further that if the public keys {pk cid:48  for Π to be unforgeable under a random message attack.  i} output by Gen cid:48  are random strings, then it is enough   26  1 Digital Signatures: Background and Deﬁnitions  Algorithm A:   Run Gen cid:48  1k  a total of  cid:96  times to obtain keys { pk cid:48    Output pk cid:48  with the signatures {σi} cid:96  ture on pk cid:48   i=1.  cid:96 . Receive in return a public key pk along i=1.  Note: each σi is a valid signa-   Run A∗ pk . When A∗ requests a signature on the ith mes-  1, . . . , pk cid:48  i with respect to pk.   i,sk cid:48   i } cid:96   sage mi, do: 1. Compute σ cid:48  2. Return the signature  pk cid:48   i ← Sign cid:48  sk cid:48  i   mi . i,σi,σ cid:48   i   to A∗.    When A∗ outputs  m, σ∗ =  pk cid:48 ,σ,σ cid:48   , output  pk cid:48 ,σ .  It is immediate that the view of A∗ in the above experiment is identical to its view in ExptA∗,Π∗ 1k ; hence, the event Forge∧Reuse occurs in the above execution A∗,Π∗ k . Since Reuse does not occur, we have of A with probability exactly SuccResue pk cid:48   cid:54 ∈ {pk cid:48  i}; since Forge occurs, it must be the case that σ is a valid signature on pk cid:48   with respect to the public key pk . Hence, we conclude that A outputs a forgery on a new message with probability SuccA∗,Π∗ k . The assumed security of Π under a known-message attack implies that this is negligible.  A∗,Π∗ k  is negligible.  Claim. SuccResue Proof. We now construct a PPT adversary A cid:48  attacking Π cid:48  in a one-time known- A∗,Π∗ k   cid:96 . Since  cid:96  is message attack and having success probability at least SuccResue polynomial and Π cid:48  is, by assumption, existentially unforgeable under a one-time known-message attack, the claim follows.  Algorithm A cid:48 :   Compute  pk,sk  ← Gen 1k  and choose a random index   Run A∗ pk , answering its ith signature query for a message  i∗ ← {1, . . . ,  cid:96 }.  i,sk cid:48  i . i ← Signsk cid:48  i   to A∗.  mi as follows: Case 1: i  cid:54 = i∗. 1. Run Gen cid:48  1k  to generate keys  pk cid:48  2. Compute σi ← Signsk pk cid:48  i  and σ cid:48  3. Return the signature  pk cid:48  i,σi,σ cid:48  Case 2: i = i∗. 1. Output mi∗ and receive a public key pk cid:48  2. Compute σi∗ ← Signsk pk cid:48  i∗ . 3. Return the signature  pk cid:48  i∗ ,σi∗,σ cid:48  output  m,σ cid:48    else output nothing .  i∗  to A∗.  ture σ cid:48  i∗.  i   mi .  i∗ and a signa-    When A∗ outputs  m, σ∗ =  pk cid:48 ,σ,σ cid:48   , if pk cid:48  = pk cid:48   i∗ then   1.8 From Unforgeability to Strong Unforgeability  27  i∗  to A∗.  That is, A cid:48  chooses a random index i∗ and answers all signature queries of A∗ nor- mally except for the i∗th query; A cid:48  can do this since it knows the “master” secret key sk corresponding to pk. For the i∗th query for a signature, on the message mi∗, the adversary A cid:48  outputs mi∗ to its own “oracle” and receives in return a randomly i∗  generated using Gen cid:48  1k   along with a signature σ cid:48  generated public key pk cid:48  i∗ on mi∗. It then computes the signature σi∗ on pk cid:48  i∗ on its own  using sk  and returns iI ,σi∗,σ cid:48   pk cid:48  It is fairly easy to see that the view of A∗ in the above experiment is identical to its view in ExptA∗,Π∗ 1k , and therefore the probability that Forge∧ Reuse occurs in A∗,Π∗ k . When Reuse occurs, there is at least the above experiment is exactly SuccResue one index i for which pk cid:48  = pk cid:48  i; since the distribution of i∗ is uniform given the view of A∗, we have that pk cid:48  = pk cid:48  i∗ with probability at least 1  cid:96 . Given that Forge occurs it must be the case that m  cid:54 = mi∗ and Vrfy cid:48  i∗  m,σ cid:48   = 1, and so A cid:48  outputs a pk cid:48  valid forgery in this case. In summary, A cid:48  outputs a valid forgery with probability at least SuccResue  A∗,Π∗ k   cid:96 . The claim follows.  The preceding two claims complete the proof.  Better efﬁciency using pre-computation. Besides being useful for constructing a CMA-secure scheme from a KMA-secure one, Construction 1.2 can also be used to improve the efﬁciency of signature generation using pre-computation that does not depend on the message being signed.  Signature schemes where pre- computation can be applied to improve efﬁciency are sometimes called “on-line off- line” schemes.  Speciﬁcally, steps 1 and 2 of signature generation are independent of the message being signed; hence they can be carried out in advance and the re- sults cached. When the message m to be signed is known, all that is needed is to compute a signature on m using the underlying one-time signature scheme. As we will see in Section 8.2.3, one-time signature schemes with very efﬁcient signing can be constructed based on a variety of number-theoretic assumptions.  1.8 From Unforgeability to Strong Unforgeability  In the preceding two sections we ampliﬁed the security of a signature scheme in terms of the attack the scheme was able to withstand. Here we amplify the notion of unforgeability, showing how to convert a scheme that is unforgeable  under a chosen-message attack  to one that is strongly unforgeable. We use as a building block a signature scheme that is strongly unforgeable under a one-time chosen- message attack; we will see later on in the book that such schemes are relatively easy to construct.  Theorem 1.3. If Π =  Gen, Sign, Vrfy  is existentially unforgeable under an adap- tive chosen-message attack and Π cid:48  =  Gen cid:48 , Sign cid:48 , Vrfy cid:48   is strongly unforgeable un-   28  1 Digital Signatures: Background and Deﬁnitions  Construction 1.3: Strong unforgeability from unforgeability Let Π =  Gen, Sign, Vrfy  and Π cid:48  =  Gen cid:48 , Sign cid:48 , Vrfy cid:48   be signature schemes; for simplicity, assume they can each be used to sign messages of unbounded length  cf. the construction in the following section . Consider the following construction of signature scheme Π∗ =  Gen∗, Sign∗, Vrfy∗ : Key generation: Gen∗ 1k  simply runs Gen 1k  to generate keys  pk,sk . These are the public and secret keys, respectively. Signature generation: Algorithm Sign∗   Run Gen cid:48  1k  to generate keys  pk cid:48 ,sk cid:48  .   Sign pk cid:48  cid:107 m using sk: i.e., compute σ← Signsk pk cid:48  cid:107 m .   Sign σ using sk cid:48 ; i.e., compute σ cid:48  ← Sign cid:48    Output the signature σ∗ =  pk cid:48 ,σ,σ cid:48  . Signature veriﬁcation: Algorithm Vrfy∗ pk m,σ∗  is deﬁned as follows: Parse σ∗ as  pk cid:48 ,σ,σ cid:48  . Then output 1 if and only if σ is a valid signature on pk cid:48  cid:107 m  with respect to pk  and σ cid:48  is a valid signature on σ  with respect to pk cid:48  ; i.e., output 1 if and only if  sk m  is deﬁned as follows:  sk cid:48  σ .  Vrfypk pk cid:48  cid:107 m,σ  ?= 1 and Vrfy cid:48   pk cid:48  σ,σ cid:48   ?= 1.  der a one-time chosen-message attack, then Π∗ =  Gen∗, Sign∗, Vrfy∗  is strongly unforgeable under an adaptive chosen-message attack.   cid:96 ,σ cid:96 ,σ cid:48   1,σ1,σ cid:48   1 , . . . , pk cid:48   Proof. Intuition for strong unforgeability is straightforward. Consider a sequence of signatures  pk cid:48   cid:96   obtained on messages m1, . . . ,m cid:96 , re- i} are distinct. Let spectively. With overwhelming probability, each of the {pk cid:48   m, pk cid:48 ,σ,σ cid:48    be a strong forgery output by an adversary. We may distinguish several cases: Case 1: pk cid:48   cid:54  in{pk cid:48  Case 2: pk cid:48  = pk cid:48  forgery with respect to Π. There are then two sub-cases:   σ cid:54 = σi. This gives a forgery with respect to scheme Π cid:48   and public key pk cid:48  i .   σ = σi. This implies σ cid:48   cid:54 = σ cid:48  but then this gives a strong forgery with respect to Π cid:48   and public key pk cid:48  i . For a formal proof, let A∗ be a PPT adversary attacking Π∗, and denote by  i}. This clearly results in a forgery with respect to scheme Π. i for some unique i. Note we must have m = mi or else we have a  i  else there is no strong forgery with respect to Π∗ ,   m, pk cid:48 ,σ,σ cid:48   ← ExptA∗,Π∗ 1k  the experiment:   pk,sk  ← Gen∗ 1k ; m, pk cid:48 ,σ,σ cid:48   ←  A∗ Sign∗  sk ·  pk .   1.8 From Unforgeability to Strong Unforgeability 29 Let mi denote the ith message submitted by A∗ to its signing oracle, and let i  } denote the ith signature received in return. Let Forge be the event { pk cid:48  i,σi,σ cid:48  that Vrfy∗ pk m, pk cid:48 ,σ,σ cid:48   = 1 and  m,σ∗ =  pk cid:48 ,σ,σ cid:48     cid:54 ∈ Q, where Q is as in Def- inition 1.6. Deﬁne   cid:104   cid:105   m, pk cid:48 ,σ,σ cid:48   ← ExptA∗,Π∗ 1k  : Forge  A∗,Π∗ k  def= Pr  Succ∗  ;  as usual, this is exactly the success probability of A∗ in attacking scheme Π∗ in the sense of strong unforgeability as deﬁned in Deﬁnition 1.6. Our goal is to show that Succ∗ A∗,Π∗ k  is negligible. As in the proof of Theorem 1.2, we will condition on whether or not A∗ re-uses one of the keys pk cid:48  i in his attempted forgery. Here, however, we deﬁne this event slightly differently: Reuse is now the event that  m, pk cid:48   =  mi, pk cid:48  i  for some i. Deﬁne   cid:105   cid:104   cid:105   cid:104   m, pk cid:48 ,σ,σ cid:48   ← ExptA∗,Π∗ 1k  : Forge∧ Reuse  m, pk cid:48 ,σ,σ cid:48   ← ExptA∗,Π∗ 1k  : Forge∧ Reuse  .  SuccReuse  A∗,Π∗ k  def= Pr A∗,Π∗ k  def= Pr  SuccReuse  Of course,  Succ∗  A∗,Π∗ k  = SuccResue  A∗,Π∗ k  + SuccResue  A∗,Π∗ k .  We show that each of the terms on the right-hand side is negligible, thus proving the theorem.  Claim. SuccReuse  A∗,Π∗ k  is negligible.  The proof of this claim is almost identical to the proof of the ﬁrst claim in the proof of Theorem 1.2, and is therefore omitted.  Claim. SuccReuse  A∗,Π∗ k  is negligible.  Proof. The proof of this claim is very similar to the proof of the second claim in the proof of Theorem 1.2; because we deal with strong unforgeability here, we provide the details. Assume without loss of generality that A∗ always makes exactly  cid:96  =  cid:96  k  sig- nature queries. We construct a PPT adversary A cid:48  attacking Π cid:48  in a one-time chosen- message attack and having success probability  in the sense of strong unforgeability  A∗,Π∗ k   cid:96 . Since  cid:96  is polynomial and Π cid:48  is, by assumption, existen- at least SuccResue tially unforgeable under a one-time known-message attack, the claim follows.  Algorithm A cid:48 : The algorithm is given a public key PK cid:48   generated using Gen cid:48  1k   and is given access to a signing oracle SignSK cid:48  ·  that it will query once.   Compute  pk,sk  ← Gen 1k  and choose a random index  i∗ ← {1, . . . ,  cid:96 }. Set pk cid:48   i∗ := PK cid:48 .   30  1 Digital Signatures: Background and Deﬁnitions    Run A∗ pk , answering its ith signature query for a message  mi as follows: Case 1: i  cid:54 = i∗. 1. Run Gen cid:48  1k  to generate keys  pk cid:48  2. Compute σi ← Signsk pk cid:48  3. Return the signature  pk cid:48  Case 2: i = i∗. 1. Compute σi∗ ← Signsk pk cid:48  2. Query σi∗ to the signing oracle and receive in return a 3. Return the signature  pk cid:48  i∗ ,σi∗,σ cid:48  output  m,σ cid:48    else output nothing .  i,sk cid:48  i . i cid:107 mi  and σ cid:48  i ← Signsk cid:48  i,σi,σ cid:48  i   to A∗. i∗ cid:107 mi∗ .    When A∗ outputs  m, σ∗ =  pk cid:48 ,σ,σ cid:48   , if pk cid:48  = pk cid:48   signature σ cid:48  i∗.  i∗  to A∗.  i∗ then   σi .  i  As in the proof of the previous theorem, the view of A∗ in the above experiment is identical to its view in ExptA∗,Π∗ 1k , and therefore the probability that Forge∧ A∗,Π∗ k . When Reuse occurs, Reuse occurs in the above experiment is exactly SuccResue i ; since the distribution of i∗ there is at least one index i for which  m, pk cid:48   =  mi, pk cid:48  is uniform given the view of A∗, we have that  m, pk cid:48   =  mi∗, pk cid:48  i∗  with probability at least 1  cid:96 . Assume this to be the case in what follows. Since Forge occurs we know that Vrfy cid:48  i∗  σ,σ cid:48   = 1. Furthermore, we must have pk cid:48  i∗ .  Recall that here, Forge means that A∗ output i∗ , this implies that   m, pk cid:48 ,σ,σ cid:48    cid:54 =  mi∗, pk cid:48  a strong forgery.  Since we are assuming  m, pk cid:48   =  mi∗, pk cid:48   σ,σ cid:48    cid:54 =  σi∗ ,σ cid:48   i∗ . But this means that A cid:48  outputs a strong forgery.  In summary, A cid:48  outputs a strong forgery with probability at least SuccResue  i∗,σi∗,σ cid:48   A∗,Π∗ k   cid:96 .  The claim, and thus the theorem, follows.  1.9 Extending the Message Length  We conclude this chapter by demonstrating how a signature scheme for k-bit mes- sages can be extended to give a signature scheme for messages of arbitrary and variable length.  Technically we handle only messages shorter than 2k 4 bits, but since this bound is exponential it is not a serious restriction.  While we will see other means of accomplishing the same goal in the next chapter, the advantage of the present transformation is that it does not require any additional primitives.  Theorem 1.4. If Π is existentially unforgeable  resp., strongly unforgeable  un- der an adaptive chosen-message attack, then Π∗ is existentially unforgeable  resp., strongly unforgeable  under an adaptive chosen-message attack.  Proof. We show that  except with negligible probability  a forgery with respect to Π∗ implies a forgery with respect to Π. Turning this into a formal proof is left as an   1.9 Extending the Message Length  31  Construction 1.4: From “short” messages to arbitrary length messages  sk m  is deﬁned as follows:  Let Π =  Gen, Sign, Vrfy  be a signature scheme for k-bit messages. Construct sig- nature scheme Π∗ =  Gen∗, Sign∗, Vrfy∗  for messages of length less than 2k 4 as follows: Key generation: Gen∗ 1k  simply runs Gen 1k  to generate keys  pk,sk . These are the public and secret keys, respectively. Signature generation: Algorithm Sign∗   Let L < 2k 4 be the length of m, and parse m into  cid:96  blocks m1, . . . ,m cid:96 , each of length k 4.  The ﬁnal block is padded with 0s if necessary, though any such padding is not counted when determining the length L.     Choose a random identiﬁer r ← {0,1}k 4.   For i = 1, . . . ,  cid:96 , compute σi ← Signsk r cid:107 L cid:107 i cid:107 mi , where L and i are uniquely   Output the signature σ :=  cid:104 r,σ1, . . . ,σ cid:96  cid:105 . Signature veriﬁcation: Algorithm Vrfy∗   Let L < 2k 4 be the length of m, and parse m into  cid:96  blocks m1, . . . ,m cid:96 , each of length k 4  padding with 0s if necessary, though again not counting this padding when determining the length .  pk m,σ  is deﬁned as follows:  encoded as strings of length k 4.    Parse σ as  r,σ1, . . . ,σ cid:96  cid:48  .   Output 1 if and only if  cid:96  cid:48  =  cid:96  and Vrfypk r cid:107 L cid:107 i cid:107 mi, σi  = 1 for 1 ≤ i ≤  cid:96 .  exercise. We deal with the case of existential unforgeability, but the case of strong unforgeability is essentially the same.  Let pk be the public key of the signer. Assume a total of q = q k  messages have been signed, and let r i  be the identiﬁer chosen by the signer when signing the ith message. Observe that the {r i }q i=1 are all distinct, except with negligible probability. For the remainder of the proof we assume this to be the case, and show that  under this assumption  a forgery with respect to Π∗ implies a forgery with respect to Π. Consider some forgery  m,σ  with respect to Π∗. Let L < 2k 4 be the length of m, and parse m into  cid:96  blocks m1, . . . ,m cid:96 , each of length k 4  padding with 0s as usual . Parse σ as  r,σ1, . . . ,σ cid:96  . There are two cases: Case 1: r  cid:54 ∈ {r i }q  i=1. Since  m,σ  is a valid forgery, we have in particular  Vrfypk r cid:107 L cid:107 1 cid:107 m1, σ1  = 1,  yet no  k-bit  message with preﬁx r was ever signed  with respect to Π . So  r cid:107 L cid:107 1 cid:107 m1, σ1  is a forgery with respect to Π.   32  1 Digital Signatures: Background and Deﬁnitions  Case 2: r = r i  for some unique i.  Uniqueness follows from out assumption that all the {r i } are distinct.  Let m i  denote the ith message that was signed and let L i  denote its length. If L  cid:54 = L i  then  r cid:107 L cid:107 1 cid:107 m1,σ1  is clearly a forgery with respect to Π, so assume L = L i . Parse m i  as m i   cid:96  , and let j be the ﬁrst index  cid:54 = m j  there must be some such index, since m i   cid:54 = m but their lengths where m i  j are the same . Then  r cid:107 L cid:107  j cid:107 m j,σj  is a forgery with respect to Π.  All other blocks signed using Π differ in either the ﬁrst or third components; the one previously signed block r cid:107 L cid:107  j cid:107 m i   j differs from r cid:107 L cid:107  j cid:107 m j.  This completes the proof.  1 , . . . ,m i   A similar proof applies also to the case of KMA-security:  Theorem 1.5. If Π is existentially unforgeable  resp., strongly unforgeable  under a known-message attack, then Π∗ is existentially unforgeable  resp., strongly un- forgeable  under a known-message attack.  1.10 Further Reading  The idea of rigorously deﬁning a computational notion of security, and of proving security of a construction by reducing its security to a more basic assumption, is due to the pioneering work of Goldwasser and Micali [59] in the context of public-key encryption. For a good overview of the concept of “provable security” as well as a discussion about concrete vs. asymptotic security, see [72].  The basic idea of digital signature schemes was ﬁrst suggested in the highly inﬂuential article by Difﬁe and Hellman [40] that initiated the study of public- key cryptography. In their work, Difﬁe and Hellman proposed both the concept as well as a generic instantiation; although their approach for constructing signa- ture schemes turned out to be insecure  something that was not altogether obvi- ous until deﬁnitions of security for signature schemes were formalized , their ideas served as the impetus for future work. Along with introducing the RSA cryptosys- tem  see Chapter 2 , Rivest, Shamir, and Adleman [99] suggested its use for con- structing a basic signature scheme. Other notable early work on digital signatures includes [97, 80, 110, 78, 44, 79].  One-time signatures were ﬁrst considered by Lamport [76], and known-message attacks were studied by Goldwasser, Micali, and Yao [62]  albeit without completely formal deﬁnitions in either case . These papers also contain secure constructions meeting the proposed deﬁnitions. The deﬁnition of existential unforgeability under an adaptive chosen-message attack, which has become the “default” notion of se- curity for digital signatures, was introduced in the seminal paper of Goldwasser, Micali, and Rivest [61]; their paper also contains a nice discussion about various possible deﬁnitions of security for signature schemes, including some that are not discussed here. Goldwasser, Micali, and Rivest also provide a construction satisfy- ing their strongest deﬁnition.  Interestingly, the authors of [61] seem not to have   1.10 Further Reading  33  recognized at the time that the construction of Section 1.7.2 could have been used to convert the KMA-secure scheme from [62] into a CMA-secure scheme.  The notion of strong unforgeability was popularized by the work of [7]  where an analogous notion was deﬁned in the symmetric-key setting  and that of [2]. Further discussion about notions of security for digital signature schemes  including some additional notions not described here  can be found in the textbook by Goldreich [57].  Even, Goldreich, and Micali [45] proved Theorem 1.2 using essentially the same construction shown here, and the underlying ideas have been implicit in many con- structions of digital signature schemes since then. Even, Goldreich, and Micali were also the ﬁrst to observe that Construction 1.2 improves the efﬁciency of signing us- ing pre-computation, as discussed at the end of Section 1.7.2. Essentially the same construction used to prove Theorem 1.1 was proposed and proven secure by Cramer and Pedersen [35, 32], and later re-investigated by [86] in the context of some spe- ciﬁc signature schemes.  Even, et al. [45] also show a construction of a CMA-secure signature scheme from an RMA-secure scheme, but their construction is less efﬁ- cient than the one given in this chapter.   The construction in Section 1.8 is due to Bellare and Shoup [12]. Other proofs of a similar result appear in [68, 106].   Chapter 2 Cryptographic Hardness Assumptions  As noted in the previous chapter, it is impossible to construct a digital signature scheme that is secure against an all-powerful adversary. Instead, the best we can hope for is to construct schemes that are secure against computationally bounded adversaries  that, for our purposes, means adversaries running in probabilistic poly- nomial time . Even for this “limited” class of adversaries, however, we do not cur- rently have any constructions that can proven, unconditionally, to be secure. In fact, it is not too difﬁcult to see that the existence of a secure signature scheme would imply1 P  cid:54 = NP, a breakthrough in complexity theory.  While there is general belief that P  cid:54 = NP is true, we seem very far away from being able to prove this.  Actually, as we will see below, the existence of a secure signature scheme implies the exis- tence of one-way functions, something not known to follow from P  cid:54 = NP and thus an even stronger result.  Informally, the issue is that P  cid:54 = NP only guarantees the ex- istence of problems that are hard in the worst case. But a secure signature scheme is required to be “hard to break” on the average — in particular, for “average” public keys generated by signers.   Given this state of affairs, all existing constructions of signature schemes are proven secure relative to some assumption regarding the hardness of solving some  cryptographic  problem. We introduce some longstanding and widely used assump- tions in this chapter; other, more recent cryptographic assumptions are introduced as needed throughout the rest of the book.  2.1 “Generic” Cryptographic Assumptions  We begin by discussing “generic” cryptographic assumptions before turning to var- ious concrete, number-theoretic constructions conjectured to satisfy these assump-  1 See any book on complexity theory for deﬁnitions of these classes, which are not essential to the rest of the book.  J. Katz, Digital Signatures, DOI 10.1007 978-0-387-27712-7_2,   Springer Science+Business Media, LLC 2010  35   36  2 Cryptographic Hardness Assumptions  tions. While any scheme used in practice must be based on some concrete “hard” problem, there are several advantages of studying generic assumptions:   A signature scheme based on generic assumptions is not tied to any particu- lar “hard” problem, and therefore offers greater ﬂexibility to the implementor. As but one illustration of this ﬂexibility, note that a signature scheme based on a speciﬁc assumption must be scrapped if the assumption is found to be false, whereas a signature scheme based on generic assumptions  that was instantiated with the particular assumption found to be false  can simply be instantiated using a different concrete problem.   Constructions based on generic assumptions are often simpler to analyze and understand, since abstracting away the “unnecessary” details has the effect of highlighting those details that are important.   Generic constructions are interesting from a theoretical point of view insofar as they indicate what is feasible, and what are the minimal assumptions that are necessary. These are often useful steps toward developing practical schemes.  On the other hand, tailoring a signature scheme to a speciﬁc assumption can often lead to a much more efﬁcient scheme than simply “plugging in” that same assump- tion to a generic template. Indeed, constructions based on speciﬁc assumptions are generally orders of magnitude more efﬁcient than schemes based on generic as- sumptions, regardless of how the latter are instantiated.  2.1.1 One-Way Functions and Permutations  The most basic building block in cryptography — in fact, as we will see, the mini- mal assumption needed for constructing secure signature schemes — is a one-way function. Informally, a one-way function f is a function that is “easy” to compute but “hard” to invert on the average, in a way made precise below. We give two def- initions of a one-way function: the ﬁrst is easier to work with, while the second is easier to instantiate using known number-theoretic primitives  and can also yield more efﬁcient constructions . Fortunately, the two deﬁnitions are equivalent in the sense that one exists if and only if the other does. We also deﬁne two notions of one-way permutations, though equivalence in this case is not known to hold. Deﬁnition 2.1. A function f : {0,1}∗ → {0,1}∗ is a one-way function if: 1.  Easy to compute:  There is a deterministic, polynomial-time algorithm Eval f such that for all k and all x ∈ {0,1}k we have Eval f  x  = f  x .  From now on, we do not explicitly mention Eval f and only refer to f itself, keeping in mind that f can be computed in polynomial time.   2.  Hard to invert:  The following is negligible for all PPT algorithms A:   cid:104    cid:105   x ← {0,1}k;y := f  x ;x cid:48  ← A 1k,y  : f  x cid:48   = y  .  Pr  Note that it is not required that x = x cid:48  in the above.   2.1 “Generic” Cryptographic Assumptions  37  is a one-way permutation if f  A one-way function f preserving  i.e.,  f  x  = x for all x . It is not difﬁcult to show that the existence of a one-way function implies P  cid:54 = NP. On the other hand, we do not currently know whether P  cid:54 = NP necessarily implies the existence of one-way functions.  is bijective and length-  While the above deﬁnition is convenient when one-way functions or permuta- tions are used to construct other objects, it does not provide a natural model for the concrete examples of one-way functions permutations that we currently know. In- stead, it is often simpler to work with families of one-way functions permutations, deﬁned next.  Deﬁnition 2.2. A tuple Π =  Gen, Samp, f   of PPT algorithms is a function family if the following hold: 1. Gen, the parameter-generation algorithm, is a probabilistic algorithm that takes as input a security parameter 1k and outputs parameters I with I ≥ k. Each value of I output by Gen deﬁnes sets DI and RI that constitute the domain and range, respectively, of the function fI deﬁned below.  2. Samp, the sampling algorithm, is a probabilistic algorithm that takes as input parameters I and outputs an element of DI  except possibly with negligible prob- ability . 3. f , the evaluation algorithm, is a deterministic algorithm that takes as input pa- rameters I and an element x ∈ DI, and outputs an element y ∈ RI. We write this as y := fI x .  That is, the function fI is deﬁned by the behavior of f on parame- ters I.   Π is a permutation family if the following additionally hold: 1. For all I output by Gen, the distribution deﬁned by the output of Samp I  is   statistically close to  the uniform distribution on DI.  2. For all I output by Gen it holds that DI = RI and the function fI is a bijection. If Π is a permutation family and there exists a polynomial p such that DI = {0,1}p k  for all I output by Gen 1k , then we say that Π is a permutation family over bit-strings. In this case we will assume the trivial sampling algorithm  that simply outputs its random coins .  Deﬁnition 2.3. A function permutation family Π =  Gen, Samp, Eval  is one-way if for all PPT algorithms A, the following is negligible  in k :  Pr[I ← Gen 1k ;x ← Samp I ;y := fI x ;x cid:48  ← A I,y  : fI x cid:48   = y].  Any one-way permutation family satisfying some mild additional conditions can be transformed into a one-way permutation family over bit-strings, and we now sketch this transformation. Let Π be a one-way permutation family with DI ⊆ {0,1}p k   for some polynomial p  for all I output by Gen 1k . We additionally require that:   38 2 Cryptographic Hardness Assumptions   Given I, the set DI is efﬁciently recognizable.  I.e., there is a polynomial-time algorithm A that takes as input I and a string x ∈ {0,1}p k  and correctly decides whether I ∈ DI.     For all I, the set DI is dense in {0,1}p k . That is, DI 2p k  = 1 poly k . Construct a permutation family Π cid:48  =  Gen cid:48 , Samp cid:48 , f  cid:48   as follows: Gen cid:48  is identical to Gen. The sampling algorithm Samp cid:48  is the trivial one that outputs a random string of length p k   we assume that k can be determined from I . Finally, deﬁne function I : {0,1}p k  → {0,1}p k  as: f  cid:48  f  cid:48  I  x  =   cid:189   fI x  x ∈ DI x  otherwise .  Note that Π cid:48  is not necessarily one-way, since f  cid:48  I is trivial to invert on any point y  cid:54 ∈ DI. Nevertheless, it is hard to invert f  cid:48  I on a noticeable fraction of its range. This hardness can be “ampliﬁed” by running many copes of Π cid:48  in parallel. That is, deﬁne Π cid:48  cid:48  =  Gen cid:48  cid:48 , Samp cid:48  cid:48 , f  cid:48  cid:48   as follows: Gen cid:48  cid:48  is the same as Gen. The sampling algorithm Samp cid:48  outputs a random string of length  cid:96  k  · p k  for an appropriate polynomial  cid:96 . Finally, f  cid:48  cid:48  I  x1 cid:107 ··· cid:107 x cid:96  k   def= f  cid:48   I  x1  cid:107 ··· cid:107  f  cid:48   I  x cid:96  k  .  Intuitively, it is clear that inversion is difﬁcult as long as any of the xi are in DI, and this is true for some xi with all but negligible probability  for  cid:96  chosen appropri- ately . A formal proof that Π cid:48  cid:48  is a one-way permutation family over bit-strings is not much more difﬁcult.  We have deﬁned both one-way functions  cf. Deﬁnition 2.1  and one-way func- tion families  cf. Deﬁnition 2.3 . We now show that these deﬁnitions are equivalent.  Lemma 2.1. A one-way function f  in the sense of Deﬁnition 2.1  exists iff a one- way function family  in the sense of Deﬁnition 2.3  exists.  Proof  sketch . It is immediate that a one-way function f implies the existence of a one-way function family: simply let Gen be the trivial algorithm that on input 1k outputs I = 1k; take Samp to be the algorithm that on input I = 1k outputs a uniformly distributed string x ∈ {0,1}k; and deﬁne fI x  = f  x .  The other direction is also conceptually simple, just more technical. Let Π =  Gen, Samp, f   be a one-way function family such that the running time of Gen is bounded by p1 and the running time of Samp is bounded by p2, and let p def= p1 + p2; note that p is a polynomial and furthermore that the combined length of the random tapes used by Gen and Samp for security parameter k is bounded by p k . Deﬁne f as follows: on input r ∈ {0,1}k ﬁnd the largest integer ¯k such that p ¯k  ≤ k. Parse r as r1r2 with r1 = p1 ¯k  and r2 ≥ p2 ¯k . Set I := Gen 1¯k;r1  and x := Samp I;r2   note that we ﬁx the random tapes of Gen and Samp, so this step is deterministic , and compute y := fI x . The output of f is the pair  I,y . The proof that f is a one-way function is tedious, but straightforward.   2.1 “Generic” Cryptographic Assumptions  39  The above shows that one-way functions are equivalent to one-way function fam- ilies. In contrast, while the existence of one-way permutations is easily seen to imply the existence of one-way permutation families, the converse is not known. Moreover, the speciﬁc number-theoretic assumptions discussed below yield one- way permutation families  indeed, one-way permutation families over bit-strings  much more naturally than they do one-way permutations. We will therefore work exclusively with the notion of one-way permutation families over bit-strings.  This is a good place to record the following observation.  Theorem 2.1. The existence of a signature scheme that is existentially unforgeable under a one-time random-message attack implies the existence of a one-way func- tion.  Proof  sketch . In fact even security against a no-message attack sufﬁces to prove the claim. Let Π =  Gen, Sign, Vrfy  be a signature scheme that is existentially un- forgeable under a no-message attack, where an adversary is given only the public key pk and succeeds if it outputs  m,σ  with Vrfypk m,σ  = 1. Let p k  be a polyno- mial bounding the length of the random tape used by Gen on security parameter 1k. Deﬁne a one-way function f as follows: on input r ∈ {0,1}k, compute the largest integer ¯k such that p ¯k  ≤ k. Then run Gen 1¯k;r  to obtain  pk,sk , and output pk. Observe that any PPT algorithm A inverting f can be used to forge signatures in Π as follows: given pk, run A to obtain a string r. If f  r  = pk, then this means that running Gen 1¯k;r  yields a pair  pk,sk cid:48  . It is then trivial to output a forgery on any message m by computing the signature σ← Signsk cid:48  m .  Note that sk cid:48  need not be equal to the “real” secret key sk used by the signer; i.e., there may be multiple valid secret keys associated with the single public key pk. But correctness of Π implies that this does not matter, since valid signatures with respect to pk can be produced using any secret key associated with pk.   2.1.2 Trapdoor Permutations  A stronger notion than that of one-way functions is obtained by introducing an “asymmetry” of sorts whereby one party can efﬁciently accomplish some task that is infeasible for anyone else. This leads to the idea of trapdoor permutations that may be viewed, informally, as one-way permutations that can be efﬁciently inverted given some additional “trapdoor” information.  One can also consider trapdoor func- tions but these turn out to be much less useful.  A deﬁnition follows. Deﬁnition 2.4. A tuple Π =  Gen, Samp, f , f −1  of PPT algorithms is a trapdoor permutation family if the following hold:   Gen, the parameter-generation algorithm, is a probabilistic algorithm that takes as input a security parameter 1k and outputs parameters I  with I ≥ k  along with an associated trapdoor td.   40  2 Cryptographic Hardness Assumptions  Each value of I output by Gen deﬁnes a set DI that constitutes the domain and range of a permutation fI deﬁned below.   Samp, the sampling algorithm, is a probabilistic algorithm that takes as input parameters I and outputs an element x ∈ DI whose distribution is statistically close to the uniform distribution over DI. We will sometimes leave Samp implicit and just write2 x ← DI.   f , the evaluation algorithm, is a deterministic algorithm that takes as input pa- rameters I and an element x ∈ DI, and outputs an element y ∈ DI. We write this as y := fI x .   f −1, the inversion algorithm, is a deterministic algorithm that takes as input parameters I, a trapdoor td, and an element y ∈ DI. It outputs an element x ∈ DI. We leave I implicit, and write this as x := f −1 and hence f −1 other.  td   fI x   = x, td  ·  and fI ·  are both permutations over DI, and inverses of each  cid:104     For all k, all  I, td  output by Gen 1k , and all x ∈ DI we have f −1    The following is negligible for all PPT algorithms A:  td  y .   cid:105   Pr   I, td  ← Gen 1k ;y ← DI;x ← A I,y  : fI x  = y  .  For brevity, and since it will not cause confusion, we simply refer to a “trapdoor  permutation” rather than a “trapdoor permutation family”.  Because fI is a permutation, choosing x uniformly from DI and then setting y := fI x  results in a value y that is uniformly distributed in DI. We note also that it is possible for fI to be deﬁned over some set that  strictly  contains DI, but the function is only guaranteed to be a bijection when its inputs are taken from DI. The ﬁnal condition of the deﬁnition, however, requires that it be “hard” to ﬁnd any x mapping to y  i.e., even an x  cid:54 ∈ DI . Occasionally, when we do not care about the particular index I or trapdoor td, we will write   f , f −1  ← Gen 1k  and write f  ·  in place of fI ·  and f −1 ·  in place of f −1 td . Of course, it is important to keep in mind that I is required in order to evaluate f , and that f −1 can only be evaluated efﬁciently with knowledge of td.  Trapdoor permutations, in the sense deﬁned above, do not sufﬁce for most of the applications we will see in this book. Instead, we need the following strengthening: Deﬁnition 2.5. A trapdoor permutation family Π =  Gen, Samp, f , f −1  is called doubly enhanced3 if the following conditions hold: 1. The following is negligible for all PPT algorithms A:  Pr   I, td  ← Gen 1k ;r ← {0,1}∗;y := Samp I;r ;x ← A I,y,r  : fI x  = y  .   cid:104    cid:105   2 Technically, x ← DI refers to selecting x uniformly from DI. Since the distribution produced by Samp is statistically close to uniform, the difference is unimportant. 3 We use this terminology to distinguish our deﬁnition from that of enhanced trapdoor permuta- tions, which satisfy only the ﬁrst condition.   2.1 “Generic” Cryptographic Assumptions  41  That is, it should be difﬁcult to ﬁnd a pre-image of y even when given the random coins used to sample y. 2. Let p k  denote the length of the random tape used by Samp on security param- eter 1k. There exists a PPT algorithm Samp cid:48  that takes as input I and outputs a tuple  x,y,r  with x ∈ DI and r ∈ {0,1}p k  and such that:   fI x  = y and y = Samp I;r ;   The distribution on r is statistically close to uniform.  We can also deﬁne a trapdoor permutation over bit-strings in the natural way  cf. Deﬁnition 2.2 . It is not hard to see that any trapdoor permutation over bit-strings is also a doubly enhanced trapdoor permutation: the ﬁrst condition of Deﬁnition 2.5 holds by virtue of the fact that Samp is trivial  since y = Samp I;y  , and the second condition holds by letting Samp cid:48  be the algorithm that chooses x uniformly, sets y := fI x , and sets r := y. All the concrete examples of trapdoor permutations that we will see in this book can be suitably “massaged” to be trapdoor permutations over bit-strings.  2.1.3 Clawfree  Trapdoor  Permutations  A pair of clawfree permutations is, informally, a pair of efﬁciently computable per- mutations f0, f1 deﬁned over the same domain for which it is hard to ﬁnd a claw: namely, a pair x0,x1 with f0 x0  = f1 x1 . A pair of clawfree trapdoor permutations additionally has an associated trapdoor td that allows for efﬁcient inversion of f0 and f1. Observe that given such trapdoor information, it is easy to ﬁnd a claw: sim- ply choose arbitrary y and compute x0 := f −1 1  y ; thus, hardness of ﬁnding a claw holds only for algorithms that do not have access to the trapdoor.  0  y  and x1 := f −1  Deﬁnition 2.6. A tuple Π =  Gen, Samp, f0, f1  of PPT algorithms is a clawfree permutation family if the following hold:   Gen, the parameter-generation algorithm, is a probabilistic algorithm that takes as input a security parameter 1k and outputs parameters I  with I ≥ k  along with an associated trapdoor td. Each value of I output by Gen deﬁnes a set DI that constitutes the domain and range of permutations fI,0, fI,1 deﬁned below.   Samp, the sampling algorithm, is a probabilistic algorithm that takes as input parameters I and outputs an element x ∈ DI whose distribution is statistically close to the uniform distribution over DI. We usually leave Samp implicit, and just write x ← DI.   f0 and f1, the evaluation algorithms, are deterministic algorithms that take as input parameters I and an element x ∈ DI, and output an element y ∈ DI. We write this as y := fI,0 x  or y := fI,1 x .   42   The following is negligible for all PPT algorithms A:  2 Cryptographic Hardness Assumptions  Pr   I, td  ← Gen 1k ; x0,x1  ← A I  : fI,0 x0  = fI,1 x1   .   cid:104   0  and f −1 1  Π =  Gen, Samp, f0, f1, f −1 , f −1 1   is a clawfree trapdoor permutation family if  Gen, Samp, f0, f1  is a clawfree permutation family and the following additionally hold:   f −1 0  , the inversion algorithms, are deterministic algorithms that take as input parameters I, a trapdoor td, and an element y ∈ DI. They output an element x ∈ DI. We leave I implicit, and write this as x := f −1   For all k, all  I, td  output by Gen 1k , all x ∈ DI, and b ∈ {0,1} we have f −1 td,b  fI,b x   = x. Thus, f −1 td,b ·  and fI,b ·  are permutations over DI and inverses of each other.  td,0 y  or x := f −1  td,1 y .  As in the case of trapdoor permutations, we often refer to “clawfree  trapdoor  permutations” rather than “clawfree  trapdoor  permutation families.” We may also , f −1 switch to a less cumbersome notation and write   f0, f1, f −1 1   ← Gen 1k  for the output of Gen, and then use f0 · , f1 ·  in place of fI,0 · , fI,1 ·  and, similarly, use 0  · , f −1 1  ·  in place of f −1 f −1 td,1 · . As before, it is important to keep in mind , f −1 that f −1 1 0  cannot be efﬁciently evaluated without knowledge of td.  We also note, once again, that it is possible for f0, f1 to be deﬁned over some set  strictly  containing the domain D over which these functions are guaranteed to be permutations. The ﬁnal condition of the deﬁnition, however, requires that it be “hard” to ﬁnd any x0,x1 for which f0 x0  = f1 x1   i.e., even x0,x1  cid:54 ∈ D .  td,0 · , f −1  The existence of clawfree trapdoor permutations represents a  possibly  stronger  0  assumption than the existence of trapdoor permutations: , f −1 Lemma 2.2. If Π =  Gen, Samp, f0, f1, f −1 1   is a clawfree trapdoor permuta- 0 tion family, then Π cid:48  =  Gen, Samp, f0, f −1 0   is a trapdoor permutation family. Thus, the existence of clawfree permutations implies the existence of trapdoor permuta- tions.  Proof  sketch . The syntactic requirements are easily seen to match up, and so all we need to prove is hardness of inversion. Fix any PPT algorithm A cid:48  and deﬁne:  δA cid:48  k  def= Pr   I, td  ← Gen 1k ;y ← DI;x ← A cid:48  I,y  : f0 x  = y  .  This is exactly the probability with which A cid:48  inverts Π cid:48 , and so we prove that Π cid:48  is a trapdoor permutation family by showing that δA cid:48  k  is negligible. Consider the following algorithm A for ﬁnding a claw in Π, using A cid:48  as a sub-   cid:104   routine:   cid:105    cid:105   Algorithm A: The algorithm is given parameters I, generated using Gen 1k . Its goal is to ﬁnd a claw.   2.2 Speciﬁc Assumptions  43    Choose x1 ← DI and compute y := f1 x1 .   Run A cid:48  I,y  to obtain x0.   If f0 x0  = y, then output the claw  x0,x1 .  Clearly, A runs in polynomial time. Furthermore, A succeeds in outputting a claw whenever A cid:48  succeeds in inverting y with respect to f0. Since A chooses x1 uniformly at random from DI and f1 is a permutation over this set, the value y given by A to A cid:48  is also uniformly distributed in DI. Thus, the probability that A cid:48  succeeds in inverting y is exactly δA cid:48  k , and this is exactly the probability with which A outputs a claw. The fact that Π is clawfree thus implies that δA cid:48  k  is negligible, as desired.  By analogy with the case of trapdoor permutations, we may also deﬁne a notion  of doubly enhanced clawfree trapdoor permutations: Deﬁnition 2.7. Let Π =  Gen, Samp, f0, f1, f −1 , f −1 1   be a clawfree trapdoor per- mutation family. We say Π is doubly enhanced if both Π0 =  Gen, Samp, f0, f −1 0   and Π1 =  Gen, Samp, f1, f −1 1   are doubly enhanced trapdoor permutation families. That is:   For b ∈ {0,1} and any PPT algorithm A the following is negligible:  0  Pr   I, td  ← Gen 1k ;r ← {0,1}∗;y := Samp I;r ;x ← A I,y,r  : fI,b x  = y  .   If we let p k  denote the length of the random tape used by Samp on security parameter 1k, there exist PPT algorithms Samp0, Samp1 where Sampb takes as input I and outputs a tuple  x,y,r  with x ∈ DI and r ∈ {0,1}p k  and such that: 1. fI,b x  = y and y = Samp I;r ; 2. the distribution on r is statistically close to uniform.   cid:104    cid:105   We may also deﬁne a clawfree trapdoor permutation family over bit-strings in the obvious way, and it is easy see that any such family is also a doubly enhanced clawfree trapdoor permutation family.  2.2 Speciﬁc Assumptions  The discussion thus far has been very general. We now show some concrete ex- amples of number-theoretic problems conjectured to be hard, and demonstrate how these can be used to instantiate the generic assumptions described thus far. We as- sume in this section some familiarity with basic number theory; see the notes at the end of this chapter for pointers to existing references covering this material.  In this chapter we have chosen to focus on the most well known and long- standing cryptographic assumptions; some more recent assumptions are introduced and discussed in Chapters 4 and 5.   44 2.2.1 Hardness of Factoring  2 Cryptographic Hardness Assumptions  The factoring problem is probably the longest-studied “hard” problem in algorith- mic number theory. It is also one of the easiest one-way functions to explain, at least informally, since multiplication is clearly “easy”  i.e., polynomial time  yet ﬁnding the prime factorization of a  large  number is widely believed4 to be “hard”. But does the conjectured “hardness of factoring” trivially imply a one-way function? A natural ﬁrst candidate for a one-way function is the function fmult x,y  = xy. A little thought, however, shows that fmult is decidedly not one-way: with probability 3 4 at least one of x or y will be even, making it trivial to ﬁnd a factor of xy  recall that one-wayness is deﬁned in terms of the inability to ﬁnd any preimage of a randomly generated point . To avoid problems of this sort, we simply need to restrict the in- puts of fmult to  large  primes of equal length. Formally, we construct a function family  Gen, Samp, f   as follows  cf. Deﬁnition 2.3 :   Gen 1k  simply outputs I = 1k. We let DI denote the set of all pairs of k-bit   Samp 1k  is a randomized algorithm that outputs two random  and independently   f  p,q  outputs the product pq. One way to state the factoring conjecture is as the assumption that the family  Gen, Samp, f   deﬁned above is one-way.  chosen  k-bit primes.  primes.  Of course, we have omitted what is perhaps the most important detail in the above: how to generate random primes in polynomial time. An algorithm computing Samp follows fairly readily from the following two facts: 1. Prime numbers are sufﬁciently dense that a random integer is prime with “sufﬁ-  ciently high” probability.  2. There exist  probabilistic  polynomial-time algorithms that can determine  ex-  cept with negligibly small error  whether a given integer is prime.  We refer the reader to the references listed in the notes at the end of this chapter for further information.  For our purposes, it will be convenient to let GenModulus denote an  unspeciﬁed, but polynomial-time  algorithm that, on input 1k, outputs  N, p,q  such that N = pq, and p and q are k-bit primes  with all but negligible probability in k . We can then express the factoring assumption relative to a particular algorithm GenModulus:  Deﬁnition 2.8. We say that factoring is hard relative to GenModulus if for all PPT algorithms A, the following is negligible:  Pr[ N, p,q  ← GenModulus 1k ; p,q  ← A N  : pq = N].  4 It is crucial to keep in mind here that running time is measured in terms of the length s  of the input s  and not their magnitude. It is easy to factor a number N in time linear in N using trial division by all numbers less than N. But a polynomial-time algorithm for factoring N is required to work in time polynomial in N =Θ logN .   2.2 Speciﬁc Assumptions  45  The factoring assumption is that there exists a GenModulus relative to which factor- ing is hard.  We stress that we do not require that GenModulus choose p and q to be random k-bit primes; though that is certainly one possibility  that is also used frequently in practice , we allow for other means of choosing the primes p and q so long as the factoring assumption  relative to GenModulus  is still believed to hold.  Interestingly, the factoring assumption — that, at ﬁrst glance, seems only to guarantee the existence of a one-way function — can be used to construct a much stronger cryptographic primitive: a  doubly enhanced  clawfree trapdoor permuta- tion family. We ﬁrst show how to use the factoring assumption to construct a trap- door permutation family, and then describe the extension to give the result claimed. We begin with a small amount of  standard  number-theoretic background. Given def= {0, . . . ,N−1}. It is a well-known fact that this is a group  any integer N > 1, let ZN under addition modulo N. We also deﬁne  Z∗ N  def= {x ∈ {1, . . . ,N − 1}  gcd x,N  = 1}.  The squaring function modulo N is the function that maps x ∈ Z∗  N is a group under multiplication modulo N; N contains exactly those elements of ZN that have a  It is not too difﬁcult to prove that Z∗ this follows from the fact that Z∗ multiplicative inverse modulo N. N to x2 mod N. Elements of Z∗ N that have a square root are called quadratic residues modulo N, and we denote the set of quadratic residues modulo N by QRN. If N is a product of two distinct, odd primes, then squaring modulo N is a four-to-one function; i.e., each quadratic residue modulo N has exactly four square roots. We use this fact in the proof of the following: Lemma 2.3. Let N = pq with p,q distinct, odd primes. Given x, ˆx such that x2 = y = ˆx2 mod N but x  cid:54 = ± ˆx mod N, it is possible to factor N in polynomial time. Proof. We claim that either gcd N,x + ˆx  or gcd N,x − ˆx  is equal to one of the prime factors of N. Since gcd computations can be carried out in polynomial time, this proves the lemma.  If x2 = ˆx2 mod N then  0 = x2 − ˆx2 =  x− ˆx ·  x + ˆx  mod N,  and so N x− ˆx  x + ˆx . Then p x− ˆx  x + ˆx  and so p divides one of these terms. Say p x+ ˆx   the proof proceeds similarly if p x− ˆx  . If q x+ ˆx  then N x+ ˆx , but this cannot be the case since x  cid:54 = − ˆx mod N. So q cid:54  x + ˆx and gcd N,x + ˆx  = p. The following important result shows  roughly  that if N is hard to factor then squaring modulo N is one-way. Formally, deﬁne a function family Πsquaring =  Gen, Samp, f   as follows:   Gen 1k  computes  N, p,q  ← GenModulus 1k , and outputs parameters N. Let  DN = Z∗  N and RN = QRN.   2 Cryptographic Hardness Assumptions  random elements of ZN until one is found that is relatively prime to N.   46   Samp N  chooses a uniform element of Z∗   fN x  outputs x2 mod N. Theorem 2.2. If factoring is hard relative to GenModulus, then Πsquaring is a one- way function family.  N.  This can be done easily by choosing  Proof. Let A be a probabilistic polynomial-time algorithm, and deﬁne  εA k  def= Pr  N ← Gen 1k ;y ← QRN;x ← A N,y  : x2 = y mod N  .   cid:104    cid:105   Since setting y := x2 mod N for a uniformly random x∈ Z∗ N is equivalent to choosing y uniformly from QRN  because squaring is four-to-one , the above exactly repre- sents A’s success probability in inverting the squaring function modulo N. Showing that εA k  is negligible thus proves the theorem.  Consider the following probabilistic polynomial-time algorithm Afact that at-  tempts to factor moduli output by GenModulus:  Algorithm Afact: The algorithm is given a modulus N as input.   Choose random x ← Z∗   Run A N,y  to obtain output ˆx.   If ˆx2 = y mod N and ˆx  cid:54 = ±x mod N, then factor N using  N and compute y := x2 mod N.  Lemma 2.3.  By Lemma 2.3, we know that Afact succeeds in factoring N exactly when ˆx  cid:54 = ±x mod N and ˆx2 = y mod N. Since the modulus N given as input to Afact is gen- erated by GenModulus 1k , and y is a random quadratic residue modulo N  since x was chosen uniformly at random from Z∗ N , the probability that A outputs ˆx sat- isfying ˆx2 = y mod N is exactly εA k . Moreover, conditioned on the value of the quadratic residue y given to A, the value x used by Afact is equally likely to be any of the four possible square roots of y. This means that, conditioned on A outputting some square root ˆx of y, the probability that ˆx  cid:54 = ±x mod N is exactly 1 2. Putting this together, we have: Pr[ N, p,q  ← GenModulus 1k  : Afact factors N] = Pr   N, p,q  ← GenModulus 1k ;x ← Z∗ N;  : ˆx  cid:54 = ±x mod N  ˆx2 = y mod N   cid:183    cid:184   y := x2 mod N; ˆx ← A N,y    cid:94   cid:184    N, p,q  ← GenModulus 1k ;x ← Z∗ N;  y := x2 mod N; ˆx ← A N,y   : ˆx2 = y mod N   cid:183   =  · Pr  1 2  = εA k  2.  Since factoring is hard relative to GenModulus, we conclude that εA k  must be negligible, completing the proof.   2.2 Speciﬁc Assumptions  47  One approach to making Πsquaring a permutation family is to consider speciﬁc moduli N and restrict the domain of the function. For N = pq a product of two distinct primes p and q, we say that N is a Blum integer if p = q = 3 mod 4. It is a fact that if N is a Blum integer, then any quadratic residue modulo N has exactly one square root that is also a quadratic residue. Thus, the squaring function for a Blum integer N is a permutation over QRN.  It is also known that computing square roots modulo N is “easy”  i.e., can be done in polynomial time  given the factorization of N. Combining this with the previous observation, we obtain a trapdoor permutation family based on factoring:   Gen 1k  computes  N, p,q  ← GenModulus 1k , where GenModulus is such that p = q = 3 mod 4. It then outputs parameters N and trapdoor  p,q . Let DN = QRN.   Samp N  chooses a uniform element of y ∈ QRN.  This can be done easily by choosing a random element r ∈ Z∗   fN x  outputs x2 mod N.   f −1   p,q  y  computes the unique square root of y modulo N that is itself a quadratic residue.  N and setting y := r2 mod N.   Theorem 2.2 implies that the above is a trapdoor permutation family as long as factoring is hard relative to GenModulus. Notice, however, that  as described  it is not a doubly enhanced trapdoor permutation family: given the random coins r used by Samp, which we view5 as an element of Z∗ N, it is trivial to compute a square root of the output value y = r2 mod N. We will see below how this can be addressed.  Extending the above gives a construction of a clawfree trapdoor permutation fam-  ily:   Gen 1k  computes  N, p,q  ← GenModulus 1k , where p = q = 3 mod 4, and chooses random z ← QRN. It then outputs parameters  N,z  and trapdoor  p,q . Let DN = QRN.    Samp N  chooses a uniform element of QRN as above.   Given  N,z , we deﬁne f0 and f1 as follows:  f0 x  = x2 mod N and f1 x  = z· x2 mod N.    Given  N,z  and the trapdoor information  p,q , the inverses of f0 and f1 can 0  y , ﬁnd the unique square root of y 1  y , ﬁnd the unique  be computed as follows: To compute f −1 modulo N that is itself a quadratic residue. To compute f −1 square root of y z mod N that is itself a quadratic residue.  Theorem 2.3. If factoring is hard relative to GenModulus, then the above consti- tutes a clawfree trapdoor permutation family. 5 This is justiﬁed since it is easy to map a sufﬁciently long bit-string to an element of Z∗ a random bit-string yields an element of Z∗ the mapping is invertible in the sense required.  N such that N whose distribution is statistically close to uniform, and   48  2 Cryptographic Hardness Assumptions  Proof. The only condition difﬁcult to verify is that it is computationally infeasible to ﬁnd a claw. We show that any “claw-ﬁnding” algorithm A can be used to compute square roots modulo N. Theorem 2.2 thus implies that ﬁnding a claw is computa- tionally infeasible.  Fix any PPT algorithm A and deﬁne  εA k  def= Pr[ N,z, p,q  ← Gen 1k ; x0,x1  ← A N,z  : x2  0 = z· x2 1].   2.1   Since this is exactly the probability with which A succeeds in ﬁnding a claw, we need to show that εA k  is negligible.  Construct a PPT algorithm A cid:48  computing modular square roots as follows:  Algorithm A cid:48 : The algorithm is given a modulus N and an element z ∈ QRN as input.   Run A N,z  to obtain output  x0,x1 .   If x2  1 mod N, then output x0 x1 mod N.  0 = z· x2  It is easy to see that if the input z given to A cid:48  is chosen uniformly from QRN, then the input  N,z  given to A is distributed identically to the experiment of Equation  2.1 . Thus, the probability that A outputs  x0,x1  with x2 1 mod N is exactly εA k . Furthermore, whenever this occurs A cid:48  outputs a square root of its input z. But if factoring is hard relative to GenModulus, we know from Theorem 2.2 that this can happen with only negligible probability.  0 = z· x2  As in the case of the trapdoor permutation family presented earlier, the construc- tion just given is not doubly enhanced. We will ﬁx this below. To do so, we need N → {−1,+1}.  We to introduce some brief facts about the Jacobi function JN : Z∗ introduce here all the facts that are needed for the construction that follows. For fur- ther information about the Jacobi function, consult the references at the end of the chapter.  An element x ∈ Z∗ N with JN x  = +1 is said to have Jacobi symbol +1, and similarly if JN x  = −1 then we say that x has Jacobi symbol −1. The relevant facts are: 1. Exactly half the elements of Z∗  N have Jacobi symbol +1, and half have Jacobi  symbol −1.  2. Given N,x, it is possible to compute JN x  in polynomial time without knowl-  edge of the factorization of N.  3. For N a Blum integer, we have seen that every quadratic residue z has exactly one square root x that is also a quadratic residue. It is furthermore the case that z has exactly two square roots with Jacobi symbol +1, and these are given by ±x mod N.  N denote the set of elements of Z∗  Let J +1 the construction of a doubly enhanced clawfree trapdoor permutation:  N with Jacobi symbol +1. We now present   2.2 Speciﬁc Assumptions 49   Gen 1k  computes  N, p,q  ← GenModulus 1k , where p = q = 3 mod 4, and chooses random z ← QRN. It then outputs parameters  N,z  and trapdoor  p,q . Let DN = QRN.   Samp N  chooses a uniform element y ∈ QRN by choosing a random r ∈ J +1 and setting y := r2 mod N.  The random r ∈ J +1 is chosen by taking random N bit-strings r1, . . . of the appropriate length, and letting r be the ﬁrst of these that is in Z∗  N and has Jacobi symbol +1.   N    Given  N,z , we deﬁne f0 and f1 as follows:  f0 x  = x4 mod N and f1 x  = z2 · x4 mod N.    Given  N,z  and the trapdoor information  p,q , the inverses of f0 and f1 can 0  y , ﬁnd the unique fourth root of y 1  y , ﬁnd the unique  be computed as follows: To compute f −1 modulo N that is itself a quadratic residue. To compute f −1 fourth root of y z2 mod N that is itself a quadratic residue.  Theorem 2.4. If factoring is hard relative to GenModulus, then the above consti- tutes a doubly enhanced clawfree trapdoor permutation family.  Proof  sketch . We ﬁrst show that ﬁnding a claw implies the ability to compute square roots modulo N; it follows from Theorem 2.2 that ﬁnding a claw is infeasible. Say we are given N and a quadratic residue z ∈ QRN. Given a claw  x0,x1  such that x4 1 2 = z2 mod N. Since the quadratic residue z2 mod N has a unique square root that is also a quadratic residue  namely, z itself , it must be the case that x2 1 = z mod N and so x0 x1 mod N is a square root of z as desired.  1 mod N, we have  x2  0 = z2 · x4  0 x2  0 x2  A similar proof shows that it is hard to ﬁnd a pre-image of y with respect to f1 even when given the randomness used to generate y. Let A be a PPT algorithm inverting f1, and consider the following probabilistic polynomial-time algorithm A cid:48  for computing square roots:  Algorithm A cid:48 : The algorithm is given a modulus N and ˆr ∈ QRN as inputs.   Choose random ˆz ∈ Z∗   Choose random b ∈ {0,1} and set r :=  −1 b ˆr mod N.   Compute y := r2 mod N.   Run A N,z,y,r  to obtain output x.   Output ˆz· x.  N and set z := ˆz2 mod N.  The input to A is distributed correctly, since r is uniformly distributed in J +1 N  this follows because JN ˆr  = +1 since ˆr is a quadratic residue  and z is uniform in QRN. Furthermore, we have  z2x4 = y mod N ⇒ cid:161   ˆz2x2 cid:162 2 = ˆr2 mod N ⇒ ˆz2x2 = ˆr mod N   50  2 Cryptographic Hardness Assumptions   the ﬁnal implication uses the fact that quadratic residues have a unique square root that is also a quadratic residue , and so ˆzx is a square root of ˆr. Lemma 2.3 thus im- plies that A inverts with only negligible probability. A proof for the case of inverting f0 follows analogously. To conclude, we show algorithms Samp0, Samp1 as required6 by Deﬁnition 2.7. Samp0 proceeds as follows: Given  N,z , choose random x ∈ Z∗ N and compute y := x4 mod N. Choose a random bit b and compute r :=  −1 b · x2 mod N. Output  x,y,r . It is clear that  x,y,r  satisfy the functional requirement of Deﬁnition 2.7. Furthermore, y is uniform in QRN and r is a random square root of y having Jacobi symbol +1. From this it follows that r is uniform in J +1 N . Algorithm Samp1 as required by Deﬁnition 2.7 can be deﬁned analogously as follows: Given  N,z , choose random x ∈ Z∗ N and compute y := z2x4 mod N. Choose a random bit b and compute r :=  −1 b · z· x2 mod N; output  x,y,r . Once again,  x,y,r  satisfy the functional requirement of Deﬁnition 2.7. Also, y is uniform in QRN and r is a random square root of y having Jacobi symbol +1. From this it follows that r is uniform in J +1 N .  2.2.2 The RSA Assumption  Another popular assumption related to factoring is the RSA assumption, named after R. Rivest, A. Shamir, and L. Adleman who proposed this assumption in 1978. The RSA assumption implies that factoring is hard, while the converse it not known; thus, the RSA assumption is potentially stronger than the assumption that factor- ing is hard.  In other words, it is possible that an efﬁcient algorithm for the RSA problem might be developed even while the factoring problem remains infeasible.  Nevertheless, the RSA assumption has stood the test of time for over 30 years. We begin with a little background. Let N = pq be a product of two odd primes p and q. Then we have seen that Z∗ N is a group with respect to multiplication mod- ulo N. An easy computation shows that the number of elements in Z∗ N is given by φ N  def=  p− 1 ·  q− 1 ; in other words, φ N  is the order of the group Z∗ N. From this it follows that if e is an integer that is relatively prime to φ N , then the func- tion fN,e : Z∗ N given by fN,e x  = xe mod N is in fact a permutation. In other words, for every y ∈ Z∗ N there exists a unique x ∈ Z∗ N satisfying xe = y mod N. For x,y satisfying this relation, we write x = y1 e mod N.  N → Z∗  The RSA problem, roughly speaking, is to compute the eth root of y modulo N; the RSA assumption is that computing eth roots modulo an integer N of unknown factorization is hard. Formally, let GenRSA be a probabilistic polynomial-time al- gorithm that, on input 1k, outputs a modulus N that is the product of two k-bit primes  except possibly with negligible probability , along with an integer e > 0 6 We concentrate on showing how a uniform r ∈ J +1 can be sampled, since going from this to N the random coins needed to generate r is easy  due to the fact that the Jacobi symbol is efﬁciently computable .   2.2 Speciﬁc Assumptions  51  with gcd e,φ N   = 1 and an integer d > 0 satisfying ed = 1 mod φ N .  We will see below the role played by d. Note that such a d is guaranteed to exist since e is relatively prime to φ N .  Then:  Deﬁnition 2.9. We say that the RSA problem is hard relative to GenRSA if for all PPT algorithms A, the following is negligible:  Pr[ N,e,d  ← GenRSA 1k ;y ← Z∗  N;x ← A N,e,y  : xe = y mod N].  The RSA assumption can be formalized as the assumption that there exists a GenRSA relative to which the RSA problem is hard. For certain applications, how- ever, additional assumptions regarding the output of GenRSA are required. Moreover, for any  N,e,d  output by GenRSA and any y ∈ Z∗  The RSA assumption implies the existence of a one-way permutation family.  N we have   yd e = yde = yde mod φ N  = y1 = y mod N,  and so computing eth roots is equivalent to raising to the dth power. Thus, viewing d as a trapdoor we see that the RSA assumption implies the existence of trapdoor permutations. Moreover, since sampling uniformly from Z∗ N is trivial, we actually obtain a doubly enhanced trapdoor permutation “for free”.  As with GenModulus in the previous section, here too we are agnostic regarding the exact way GenRSA is implemented. One way to implement GenRSA based on any algorithm GenModulus  not necessarily outputting Blum integers  is as follows: 1. On input 1k, compute  N, p,q  ← GenModulus 1k . Then compute  φ N  :=  p− 1  q− 1 .  2. Choose e > 0 such that gcd e,φ N   = 1.  We leave the exact manner in which e is chosen unspeciﬁed, though in practice certain values of e may be preferred.  Compute d := e−1 mod φ N  and output  N,e,d .  Since φ N  can be computed given the factorization of N, and d = e−1 mod φ N  can be computed in polynomial time given φ N , it is clear that hardness of the RSA problem relative to GenRSA as constructed above implies hardness of factoring rel- ative to GenModulus. As mentioned earlier, the converse is not known to be true. On the other hand, the only techniques currently known for attacking the RSA prob- lem rely on ﬁrst factoring N. In addition, it is known that recovering the trapdoor d, given N and e, is as hard as factoring  nevertheless, it is not clear that recovery of d is necessary in order to compute eth roots . With respect to existing technology, then, the RSA and factoring problems may be viewed as “equally hard”.  As in the case of the factoring assumption, the RSA assumption may also be used to construct a  doubly enhanced  clawfree trapdoor permutation family in a very similar fashion:   Gen 1k  computes  N,e,d  ← GenRSA 1k  and chooses random z ← Z∗  N. It then  outputs parameters  N,e,z  and trapdoor d. Let DN = Z∗ N.   52   Samp N  chooses a uniform element of Z∗   Given  N,e,z , deﬁne f0 and f1 as follows:  N in the trivial way.  2 Cryptographic Hardness Assumptions  f0 x  = xe mod N and f1 x  = z· xe mod N.    Given  N,e,z  and the trapdoor information d, the inverses of f0 and f1 can be 0  y , simply compute yd mod N. To com-  computed as follows: To compute f −1 pute f −1  1  y , simply compute  y z d mod N.  The proof that the above is a clawfree trapdoor permutation follows the proof of Theorem 2.3, and is omitted. Observe that this construction is also doubly enhanced  once again, this comes “for free” due to the triviality of sampling from Z∗ N .  In Chapter 4, we will introduce the  more recent  strong RSA assumption that  offers additional ﬂexibility as compared to the RSA assumption described here.  2.2.3 The Discrete Logarithm Assumption  An assumption of a different ﬂavor is obtained by considering the discrete logarithm problem, which may be deﬁned in any ﬁnite cyclic group G. For the most part, we will consider only groups G of prime order q  though this is not required in any sense ; such groups have the feature that every element in G other than the identity is a generator, and have several other advantages as well. Letting g be a generator of the group, and h ∈ G be arbitrary, deﬁne the discrete logarithm of h with respect to g  denoted logg h  as the smallest non-negative integer x such that gx = h.  Note that we always have logg h < q.  The discrete logarithm problem is to compute x given g and a random group element h. We remark that it is easy to sample a random element h ∈ G by choosing a uniform integer y ∈ {0, . . . ,q− 1} and setting h := gy. For certain classes of groups, the discrete logarithm problem is believed to be hard. The problem is certainly not hard in all cyclic groups, and hardness depends to a great extent on the way elements of the group are represented.  This must be so, since all cyclic groups of the same order q are isomorphic yet the discrete logarithm problem is easy in the additive group Zq.   To formally state the discrete logarithm assumption, we must consider an inﬁnite sequence of groups as deﬁned by an appropriate group-generation algorithm. Let G be a polynomial-time algorithm that, on input 1k, outputs a  description of a  cyclic group G, its order q  with q a k-bit integer , and a generator g ∈ G.  Unless stated otherwise, we will also assume that q is prime except with negligible probability.  We also require that membership in G can be tested efﬁciently, and that the group operation in G can be computed efﬁciently  namely, in time polynomial in k . This implies that exponentiation in G can be performed efﬁciently as well. Deﬁnition 2.10. The discrete logarithm problem is hard relative to G if for all PPT algorithms A, the following is negligible:  Pr[ G,q,g  ← G  1k ;h ← G;x ← A 1k,G,q,g,h  : gx = h].   2.3 Hash Functions  53  The discrete logarithm assumption is that there exists a G relative to which the discrete logarithm problem is hard.  We often abuse terminology and say that the discrete logarithm problem is hard for G when G is a group that is output by G .  It is immediate that the discrete logarithm assumption implies the existence of a one-way function family; take fG,q,g x  that outputs gx. The functions in this family are one-to-one if we take the domain of fG,q,g x  to be Zq. For certain groups G  for which the discrete logarithm problem is assumed to be hard , we can in fact obtain a one-way permutation family. One example, commonly used in cryptography, is p for p prime.  The order of this group is q = p− 1, given by groups of the form Z∗ and is not prime. The fact that groups of this form are cyclic is not obvious, but can be proved using basic ﬁeld theory.  In this case, the “natural” mapping fG,q,g : Zp−1 → Z∗ p is the one given above, where fG,q,g x  = gx mod p. But by simply “shifting” the domain we get the function f  cid:48   p given by  p → Z∗  G,q,g : Z∗ f  cid:48  G,q,g x  = gx−1 mod p.  We do not discuss other examples of groups for which the discrete logarithm problem is assumed to be hard. For the purposes of this book, abstracting the choice of group will be more convenient and sufﬁces for our purposes.  The reader may be familiar with other assumptions related to the discrete log- arithm assumption, most prominently the computational and decisional Difﬁe- Hellman assumptions. Interestingly, although these assumptions are extremely use- ful for the construction of efﬁcient public-key encryption schemes, they have thus far had little application to the construction of efﬁcient signature schemes. An ex- ception is in the context of bilinear maps, discussed in Chapter 5, and we defer any discussion to there.  2.3 Hash Functions  Hash functions play a central role in the construction of secure signature schemes. Constructions of hash functions based on various assumptions are known, and we also have extremely efﬁcient constructions  not based on any particular hard cryp- tographic problem  that one can reasonably assume to be secure. We will return to this point after deﬁning the basic types of hash functions we will consider.  2.3.1 Deﬁnitions  A hash function is simply a function that compresses its input. Hash functions are used throughout computer science, but we will be interested in two types of cryp- tographic hash functions. Our hash functions will be keyed: that is, a function H is   54  2 Cryptographic Hardness Assumptions  deﬁned  this is sometimes also called a hash family ; a key s is sampled uniformly at random and published; and we then look at the security of the keyed function Hs. A hash function H is said to be collision-resistant if, roughly speaking, it is hard to ﬁnd distinct x,x cid:48  that “collide”, that is, for which Hs x  = Hs x cid:48  . A hash func- tion is called universal one-way if, informally, it is hard to ﬁnd a collision for a pre-speciﬁed input x, chosen independently of the key s;  Deﬁnition 2.11. A hash function is a pair of probabilistic polynomial-time algo- rithms  Gen,H  such that:   Gen is a probabilistic algorithm that on input 1k outputs a key s.  We assume that 1k is implicit in s.    There exists a polynomial  cid:96  such that H takes as input a key s and x ∈ {0,1}∗, and outputs a string Hs x  ∈ {0,1} cid:96  k .  Note that the running time of H is allowed to depend on x.   If Hs is deﬁned only for inputs x ∈ {0,1} cid:96  cid:48  k , where  cid:96  cid:48  k  >  cid:96  k  for all k, then we say that  Gen,H  is a ﬁxed-length hash function for inputs of length  cid:96  cid:48 .  We now deﬁne the security properties stated informally earlier.  Deﬁnition 2.12. Hash function  Gen,H  is collision-resistant if the following is negligible for all PPT algorithms A:  Pr  s ← Gen 1k ; x,x cid:48   ← A 1k,s  : x  cid:54 = x cid:48  ∧ Hs x  = Hs x cid:48    .  Deﬁnition 2.13.  Gen,H  is universal one-way if the following is negligible for all stateful PPT algorithms A:  Pr  x ← A 1k ;s ← Gen 1k ;x cid:48  ← A 1k,s  : x  cid:54 = x cid:48  ∧ Hs x  = Hs x cid:48    .  This is sometimes also called second pre-image resistance in the literature.  It is easy to see that collision-resistance implies universal one-wayness.   cid:104    cid:104    cid:105    cid:105   2.3.2 The Merkle-Damg˚ard Transform  The Merkle-Damg˚ard  MD  transform can be used to convert a ﬁxed-length hash function  Gen,H cid:48   to a hash function  Gen,H  taking inputs of arbitrary length, while preserving collision-resistance. Besides being useful in its own right, the ex- istence of the MD transform means that we can focus our attention on designing collision-resistant compression functions operating on short, ﬁxed-length inputs, and then automatically convert such compression functions into full-ﬂedged hash functions. The MD transform is also used extensively in practical constructions of hash functions.   2.3 Hash Functions  55  Construction 2.1: The Merkle-Damg˚ard transform Let  Gen,H cid:48   be a ﬁxed-length hash function for inputs of length 2 cid:96  k .  This as- sumption is for simplicity only.  Construct a hash function  Gen,H  as follows:   The key-generation algorithm Gen is unchanged.   Hs is deﬁned for inputs of length at most 2 cid:96  − 1. To compute Hs x  do:  1. Set L := x and B :=   i.e., B is the number of blocks in x . Pad the input x with zeroes until its length is an integer multiple of  cid:96 , and parse the result as the sequence of  cid:96 -bit blocks x1, . . . ,xB. Set xB+1 := L, where L is encoded using exactly  cid:96  bits.   cid:96    cid:168    cid:167  L  2. Set z0 := 0 cid:96 . 3. For i = 1, . . . ,B + 1, compute zi := H cid:48  4. Output zB+1.  s zi−1xi .  Theorem 2.5. If  Gen,H cid:48   is collision-resistant, then so is  Gen,H .  Proof  sketch . The proof follows easily from the observation that any collision in s. Let x and x cid:48  be two different strings, of lengths L and L cid:48  Hs yields a collision in H cid:48  respectively, with Hs x  = Hs x cid:48  . Let x1, . . . ,xB denote the padded version of x, and 1, . . . ,x cid:48  B cid:48 +1 = L cid:48 . let x cid:48  Let zi  resp, z cid:48  1. Case 1: L  cid:54 = L cid:48 . We have  B cid:48  be the result of padding x cid:48 . Recall further that xB+1 = L and x cid:48  i  be as in Construction 2.1. There are two cases to consider:  Hs x  = H cid:48   s z cid:48  s zBL  = H cid:48  B cid:48 L cid:48 , this is a collision in H cid:48  s.  B cid:48 L cid:48   = Hs x cid:48  .  i∗−1 cid:107 x cid:48   i∗. If i∗ = B+1 then zB cid:107 xB+1 and z cid:48   2. Case 2: L = L cid:48 . In this case, note that B = B cid:48  and xB+1 = x cid:48   B+1. Since x  cid:54 = x cid:48 , there i. Let i∗ ≤ B+1 be the largest B+1 are s exactly as in the previous case. If i∗ ≤ B, then maximality of i∗ i∗, in which case zi∗−1 cid:107 xi∗ and z cid:48   Since zBL  cid:54 = z cid:48  must exist an index i with 1 ≤ i ≤ B such that xi  cid:54 = x cid:48  index for which zi∗−1 cid:107 xi∗  cid:54 = z cid:48  a collision in H cid:48  implies zi∗ = z cid:48  The MD transform is only guaranteed to preserve collision-resistance; it is not guaranteed to preserve universal one-wayness.  A variant of the MD transform where an independent key is chosen for each iteration does preserve universal one- wayness, although this approach yields a hash function with a very long key. See further discussion at the end of Section 2.3.4.   B cid:107 x cid:48  i∗ are a collision in H cid:48  s.  i∗−1 cid:107 x cid:48    56 2.3.3 Constructing Collision-Resistant Hash Functions  2 Cryptographic Hardness Assumptions  In this section we describe constructions of  ﬁxed-length  collision-resistant hash functions based on the number-theoretic assumptions introduced earlier in this chap- ter. We conclude with a brief discussion of hash functions used in practice. Collision-resistant hash functions from clawfree permutations. We begin with a construction of collision-resistant hashing from any clawfree permutation fam- ily. Although not very practical, the construction provide a good illustration of how “strong” cryptographic primitives can be constructed from “weaker” building blocks. It also shows that the factoring and RSA assumptions imply the existence of collision-resistant hash functions.  Construction 2.2: Collision resistance from clawfree permutations  Let  Gen, Samp, f0, f1  be a clawfree permutation family, and assume that if I is output by Gen 1k  then elements of DI can be described using  cid:96  bits. Deﬁne the ﬁxed-length hash function  GenH ,H  as follows:   GenH 1k  computes I ← Gen 1k , chooses r ← DI, and outputs the key s =  I,r .   Hs x , where x ∈ {0,1}2 cid:96  k , parses s as  I,r  and parses x = x1···x2 cid:96  where each  In what follows, let  cid:96  =  cid:96  k  and write f0, f1 in place of fI,0, fI,1.   cid:162  fx2 cid:96 −1  ···  fx1  r  ···   .  xi is a single bit. It then outputs fx2 cid:96    cid:161   Theorem 2.6. If  Gen, Samp, f0, f1  is a clawfree permutation family, then hash function  GenH ,H  from Construction 2.2 is collision-resistant.   cid:161   Proof  sketch . The proof follows easily from the observation that any collision in  cid:162  Hs yields a claw. For x ∈ {0,1}2 cid:96  and 1 ≤ i ≤ 2 cid:96  deﬁne fxi−1  ···  fx1  r  ···  ; 1···x cid:48   note that Hs x  = H2 cid:96  with Hs x  = Hs x cid:48  , and let i denote the largest index such that xi  cid:54 = x cid:48  for all j > i . Since f0, f1 are permutations,  2 cid:96  be two different strings i  so x j = x cid:48  j  s  x . Let x = x1···x2 cid:96  and x cid:48  = x cid:48   Hi s = fxi  H2 cid:96  s  x  = H2 cid:96   s  x cid:48   ⇒ Hi  s x  = Hi  s x cid:48   ⇒ fxi Hi−1  s   x   = fx cid:48  i   Hi−1   x cid:48   ;  s  but then Hi−1   x  and Hi−1   x cid:48   are a claw.  s  s  Collision-resistant hash functions from the discrete logarithm assumption. In certain groups G  namely, where there is an efﬁciently computable bijection from G to ZG , the discrete logarithm assumption implies a clawfree permutation family   2.3 Hash Functions  57  and thus a construction of a collision-resistant hash function as discussed above. We give a more direct and more efﬁcient construction here, that additionally has the advantage of not working with arbitrary G. Let G be a group-generation algorithm, and assume that if  G,q,g  ← G  1k  then elements of G can be described using k +O 1  bits.  This assumption is for simplic- ity only, and a generalization of the following construction works if this assumption does not hold.  Deﬁne a ﬁxed-length hash function  Gen,H  as follows:   Gen 1k  computes  G,q,g  ← G  1k  and chooses random h ∈ G. It outputs the   Let s =  G,q,g,h , and deﬁne Hs : Zq × Zq → G as  key s =  G,q,g,h .  Hs x,y  = gxhy.  If we want to view Hs as mapping bit-strings to bit-strings, note that Hs can handle inputs of length 2·  k − 1   since any  k − 1 -bit integer can be viewed naturally as an element of Zq, using the fact that q is a k-bit integer , and the output of Hs can be encoded using k + O 1  bits. Thus, for k large enough we have compression.  Theorem 2.7. If the discrete logarithm problem is hard relative to G , the above construction is collision resistant.  Proof. Let A be a PPT collision-ﬁnding algorithm, and let  εA k  def= Pr   G,q,g,h  ← Gen 1k ;  x,y,x cid:48 ,y cid:48   ← A G,q,g,h  :  x,y   cid:54 =  x cid:48 ,y cid:48  ∧ Hs x,y  = Hs x cid:48 ,y cid:48     where s =  G,q,g,h   denote the probability with which A ﬁnds a collision. Con- struct the following PPT algorithm B solving the discrete logarithm problem relative to G :   cid:184    cid:183   Algorithm B: The algorithm is given  G,q,g,h  as input. Its goal is to compute logg h.   Run A G,q,g,h  to obtain x,y,x cid:48 ,y cid:48  ∈ Zq.   If y  cid:54 = y cid:48 , output  x−x cid:48  · y cid:48 −y −1 mod q.  Any  y cid:48 −y   cid:54 = 0  has an inverse modulo q since q is prime.   First note that A’s input when run as a sub-routine by B is distributed identically to the keys output by Gen  this is true because B’s input has h chosen uniformly from G . Thus, A returns a collision with probability exactly εA k . We complete the proof of the theorem by showing that B outputs the correct answer logg h whenever A ﬁnds a collision. To see this, note that  gxhy = gx cid:48   hy cid:48  ⇒ gx−x cid:48   = hy cid:48 −y ,   58 2 Cryptographic Hardness Assumptions and if the above holds and furthermore  x,y   cid:54 =  x cid:48 ,y cid:48   then it must be the case that y cid:48  − y  cid:54 = 0. So g x−x cid:48    y cid:48 −y  = h, and this is exactly what is output by B. Dedicated collision-resistant hash functions. We have seen that collision-resistant hash functions can be constructed based on a variety of number-theoretic assump- tions. Yet these constructions are rather inefﬁcient. In practice, dedicated construc- tions of  conjectured  collision-resistant hash functions are used that are orders of magnitude faster. These functions are generally unkeyed and have ﬁxed length out- puts. For these reasons, they cannot be said to satisfy asymptotic notions of secu- rity; nevertheless, appropriate concrete notions of security can be deﬁned. Notable examples of hash functions in widespread use as of the time of this writing in- clude SHA-1  which hashes arbitrary-length inputs to 160-bit outputs  and SHA-256  which hashes arbitrary-length inputs to 256-bit outputs .  2.3.4 Constructing Universal One-Way Hash Functions  Collision-resistance is a strong requirement. From a theoretical point of view, we currently know how to construct collision-resistant hash functions only from con- crete, number-theoretic assumptions; constructions based on generic assumptions such as trapdoor permutations are not known.  Moreover, there is evidence that such constructions are impossible.  From a practical point of view, recent years have seen tremendous progress developing methods to attack hash functions. A prime exam- ple is the hash function MD5. For well over a decade MD5 was considered to be collision-resistant for all practical purposes. In 2005, however, Chinese cryptana- lysts discovered a new technique for ﬁnding collisions in MD5. The attacks only got better, to the point where collisions in MD5 can now be found in minutes, and structured collisions in MD5  i.e., colliding inputs x,x cid:48  that each satisfy certain for- matting requirements  can now easily be found as well.  It is thus useful, when possible, to rely on the weaker assumption of universal one-wayness. Doing so potentially allows constructions based on weaker assump- tions, and only makes it harder for an adversary to attack a deployed scheme.  In particular, MD5 is still considered to be universal one-way for the time being.  As an example of the former, we show here a construction of a  ﬁxed-length  universal one-way hash function from any one-way permutation.  The construction can be easily modiﬁed to work with families of one-way permutations over bit-strings as well.  It is known that universal one-way hash functions can be constructed based on the  minimal  assumption of one-way functions; this construction is quite complex, unfortunately, and is beyond the scope of this book.  The construction of a universal one-way hash function from one-way permuta- tions will use a particular pairwise-independent function family we now introduce. Let F2k denote the ﬁeld with 2k elements, and note that there is a natural correspon- dence between elements in F2k and k-bit strings. Deﬁne the function family  def= {ha,b : F2k → {0,1}k−1  b ∈ F2k , a ∈ F2k \{0}},  Hk   2.3 Hash Functions  as  59  ha,b x  = chop ax + b ,  where chop simply removes the ﬁnal bit of its input. We will use the following properties of Hk: Lemma 2.4. For every b ∈ F2k , a ∈ F2k \{0}, the function ha,b is two-to-one. Proof. Fix a,b and any z ∈ {0,1}k−1. Let z0 = z cid:107 0 and z1 = z cid:107 1. The equation ax + b = z0 has the unique solution x = a−1 ·  z0 − b  in F2k  using a  cid:54 = 0 , and similarly for the equation ax + b = z1. Lemma 2.5. Fix arbitrary y ∈ F2k, and consider choosing a,b in the following way: 1. Choose uniform y cid:48  ∈ F2k \{y}, uniform z ∈ {0,1}k−1, and uniform c ∈ {0,1}. Set 2. Solve for a,b in the following system of equations:  z cid:48  = z cid:107 c and ¯z cid:48  = z cid:107  ¯c, and view z cid:48 , ¯z cid:48  as elements of F2k.  ay + b = z cid:48  ay cid:48  + b = ¯z cid:48 .   2.2   2.3   Then the distribution induced on  a,b  is uniform over  F2k \{0} × F2k. Proof. Note ﬁrst that y cid:48 ,z,c determine a,b uniquely, and that a  cid:54 = 0 always. Now ﬁx a ∈ F2k \{0} and b ∈ F2k and let us see how many choices of y cid:48 ,z,c result in this  a,b  being chosen. Since a,y,b are now ﬁxed, there is a unique choice of z,c satis- fying Equation  2.2 . Given this, y cid:48  =  ¯z cid:48 −b ·a−1  cid:54 = y is the unique value satisfying Equation  2.3 . We thus see that each pair  a,b  is selected with probability  1  1  F2k \{0}×{0,1}k−1×{0,1} =  F2k \{0}×F2k ,  and so the distribution of  a,b  is uniform over the indicated sets.  Let f : {0,1}∗ → {0,1}∗ be a length-preserving bijection. Deﬁne  Gen,H  as  follows:   Gen 1k  chooses uniform a ∈ F2k \{0} and b ∈ F2k, and outputs the key  a,b .   Ha,b x  outputs ha,b  f  x  . Note that Ha,b is two-to-one for every a,b; this follows from Lemma 2.4 and the fact that f is one-to-one.  Theorem 2.8. If f is a one-way permutation, then the above hash function is uni- versal one-way.  Proof. Let A be a PPT collision-ﬁnding algorithm in the sense of Deﬁnition 2.13. Deﬁne   60   cid:104   εA k  def= Pr  x ← A 1k ; a,b  ← Gen 1k ;x cid:48  ← A a,b  : x  cid:54 = x cid:48  ∧ Ha,b x  = Ha,b x cid:48    .  2 Cryptographic Hardness Assumptions   cid:105   Construct the following PPT algorithm B inverting f :  Algorithm B: The algorithm is given y cid:48  ∈ {0,1}k as input. Its goal is to compute x cid:48  ∈ {0,1}k with f  x cid:48   = y cid:48 .   Run A 1k  to obtain x; set y = f  x . If y cid:48  = y then output x   Otherwise choose random z,c and then compute a,b as in  and stop. Lemma 2.5. Run A a,b  to obtain x cid:48 . Output x cid:48 .  If y cid:48  = y then B clearly outputs an inverse of y. Conditioned on the event that this does not occur, y cid:48  is uniform in F2k \ {y}.  This follows because B’s input y cid:48  is computed as y cid:48  = f  x cid:48   for uniform x cid:48 , and f is a permutation.  It follows from Lemma 2.5 that a,b are distributed identically to the output of Gen, and so A ﬁnds a collision with probability exactly εA k  in this case.  By construction of B,  Ha,b x  = chop a· f  x  + b  = chop a· y + b  = chop z cid:107 c  = z .  Since Ha,b is two-to-one and  Ha,b  f −1 y cid:48    = chop a· y cid:48  + b  = chop z cid:107  ¯c  = z  collides with x, it follows that f −1 y cid:48   is the only input that collides with x, and so B outputs the correct result f −1 y cid:48   whenever A ﬁnds a collision. The theorem follows.  Improving the compression. The construction above only compresses its input by a single bit. Nevertheless, this sufﬁces for constructing a universal one-way hash function mapping p k -bit inputs to  k − 1 -bit outputs  for any desired polyno- mial p  using a variant of the Merkle-Damg˚ard transform, with the difference being that independent keys must be used in each iteration. This gives a universal one- way hash function where the key size grows linearly in the input length and, in fact, is longer than the input.  This is no problem as far as the deﬁnition of uni- versal one-wayness is concerned, but causes difﬁculty in some applications as will become clear in Chapter 3.  Transformations that improve the compression using smaller keys are also known; these can be used to construct universal one-way hash functions handling inputs of unbounded length. The details are beyond the scope of this book. Furthermore, as noted earlier, universal one-way hash functions can be constructed from one-way functions. For completeness we record the following:  Theorem 2.9. Assuming the existence of one-way functions, there exist universal one-way hash functions  for arbitrary-length inputs .   2.4 Applications of Hash Functions to Signature Schemes 2.4 Applications of Hash Functions to Signature Schemes  61  We wrap up this chapter by showing how to use cryptographic hash functions to improve the parameters of digital signature schemes. We ﬁrst show how to increase the message length of a signature scheme: speciﬁcally, we show how to convert a signature scheme capable of signing k-bit messages into one that can sign messages or arbitrary length.  We have already shown such a construction in Section 1.9, but the one given here is much more efﬁcient.  This technique is used extensively in practice to enable signing large ﬁles. We then show how to decrease the size of pub- lic keys  at the expense of increasing the signature length , constructing in particular a one-time signature scheme that can sign messages twice as long as its own public key. This will form a crucial ingredient in our construction  in the following chapter  of an existentially unforgeable signature scheme from any one-way function.  2.4.1 Increasing the Message Length  Given a signature scheme for “short” messages, a natural way of handling longer messages is to hash all messages before signing them. We show how this can be implemented using both collision-resistant and universal one-way hash functions. Using collision-resistant hash functions. When using collision-resistant hash func- tions, the above idea is simple to implement.  Construction 2.3: Increasing the message length using collision resistance  Let Π =  Gen, Sign, Vrfy  be a signature scheme for k-bit messages, and let  GenH ,H  be a hash function mapping p k -bit inputs to k-bit outputs. Construct signature scheme Π cid:48  =  Gen cid:48 , Sign cid:48 , Vrfy cid:48   for p k -bit messages as follows: Key generation: Gen cid:48  1k  computes  pk,sk  ← Gen 1k  and s ← GenH 1k . The public key is  pk,s  and the secret key is  sk,s . Signature generation: Algorithm Sign cid:48  Signature veriﬁcation: Algorithm Vrfy cid:48   sk,s m  outputs Signsk Hs m  . pk,s m,σ  outputs Vrfypk Hs m ,σ .  Theorem 2.10. If Π is existentially unforgeable  resp., strongly unforgeable  under an adaptive chosen-message attack and  GenH ,H  is collision-resistant, then Π cid:48  is existentially unforgeable  resp., strongly unforgeable  under an adaptive chosen- message attack. Proof  sketch . The proof is quite straightforward, and so we merely provide a sketch for the case of existential unforgeability. Let m1, . . . ,m cid:96  denote the messages   62 2 Cryptographic Hardness Assumptions submitted by an adversary A to the signing oracle Sign cid:48  sk,s · , and let  m,σ  denote a purported forgery output by A. There are two possibilities: either Hs m  = Hs mi  for some i ∈ {1, . . . ,  cid:96 } or not. If so, then A has found a collision in Hs  something that, by assumption on  GenH ,H , occurs with only negligible probability . If not, then Hs m  is a k-bit string different from all k-bit strings {Hs m1 , . . . ,Hs m cid:96  } that were signed using scheme Π. But then A has in fact output a valid forgery for Π  something that, by assumption on Π, occurs with only negligible probability .  Using universal one-way hash functions. In order to use universal one-way hash functions, we have to work a little harder. Note ﬁrst that Theorem 2.10 is no longer guaranteed to hold if  GenH ,H  is only universal one-way: In that case an adversary who observes s — which is included in the public key — might be able to ﬁnd two different messages m,m cid:48  hashing to the same value, and then forge a signature on m cid:48  after requesting a signature on m. However, we can claim the following weaker version of Theorem 2.10:  Theorem 2.11. If Π is existentially unforgeable  resp., strongly unforgeable  un- der a known-message attack and  GenH ,H  is universal one-way, than Π cid:48   as in Construction 2.3  is existentially unforgeable  resp., strongly unforgeable  under a known-message attack.  Proof  sketch . The proof uses exactly the same ideas as in the proof of Theo- rem 2.10, the key difference being that in a known-message attack on Π cid:48  the ad- versary must “commit” to its messages m1, . . . ,m cid:96  before it sees the public key  and so, in particular, before it sees the key s used for the hash function . Thus, if the adversary were able to output a forgery  m,σ  with Hs m  = Hs mi  for some i, this would violate the assumed universal one-wayness of  GenH ,H .  The above already sufﬁces to increase the message length for signature schemes secure against an adaptive chosen-message attack: given an existentially unforge- able signature scheme Π  which is in particular also secure against known-message attacks  for k-bit messages, apply the above theorem to obtain scheme Π cid:48  for arbitrary-length messages that is secure against known message attacks  and hence also against random-message attacks ; then apply either of Theorems 1.1 or 1.2. As we shall see, a direct construction with better efﬁciency is possible.  The problem with Construction 2.3  when a universal one-way hash function is used in place of a collision-resistant hash function  is that the adversary may select messages to be signed in a manner that depends on the hash key s included as part of the public key. We would like to prevent this, and “force” the adversary to choose the messages submitted to the signing oracle independently of the hash key. We can accomplish this by choosing the hash key “on the ﬂy” as part of signature genera- tion. Speciﬁcally, consider the following construction starting with an existentially unforgeable signature scheme Π =  Gen, Sign, Vrfy  and universal one-way hash function  GenH ,H :   Key generation is unchanged; i.e., compute  pk,sk  ← Gen 1k .   2.4 Applications of Hash Functions to Signature Schemes 63   To sign a message m using secret key sk, compute s ← GenH 1k  and output the  signature   s, Signsk sHs m    .  We stress that a fresh key s is computed for every message signed.    To verify the signature  s,σ  on a message m with respect to a public key pk,  output 1 iff Vrfypk sHs m ,σ  ?= 1.  The above construction is existentially unforgeable. To see this, let m1, . . . ,m cid:96  de- note the messages submitted by the adversary A to its signing oracle, and let  s1,σ1 , . . . , s cid:96 ,σ cid:96   be the signatures returned. Say A outputs forgery  m, s,σ   with m  cid:54 ∈ {m1, . . . ,m cid:96 }. Arguing as in the proof of Theorem 2.10, if  s,Hs m    cid:54 =  si,Hsi mi   for all i then A has, in fact, generated a forgery in the original scheme Π  something that is assumed to occur with only negligible probability . On the other hand, if  s,Hs m   =  si,Hsi mi   but m  cid:54 = mi  making the simplifying, but inessen- tial, assumption that the {si} are distinct , then A has violated the assumed universal one-wayness of  GenH ,H .  The key point being that the adversary chose mi before it knew the hash key si.   The main problem with this transformation is that the hash key itself is signed  along with the hashed message  by the underlying scheme, yet many theoretical constructions of universal one-way hash functions use rather long keys. In particular, when the hash key is longer than the input length of the hash function  as was the case for the construction described at the end of Section 2.3.4  the transformation is of no use. Instead, Construction 2.4 — which can be viewed as following the same paradigm used in Construction 1.2 — can be utilized.  Construction 2.4: Increasing the message length using universal one-wayness  Let Π =  Gen, Sign, Vrfy  be a signature scheme for 2k-bit messages,  GenH ,H  be a hash function mapping p k -bit inputs to k-bit outputs and having keys of length h k , and  Gen cid:48  H ,H cid:48   be a hash function mapping h k -bit inputs to k-bit outputs. Construct signature scheme Π cid:48  =  Gen cid:48 , Sign cid:48 , Vrfy cid:48   for p k -bit messages as follows: Key generation: Gen cid:48  1k  computes  pk,sk  ← Gen 1k  and s cid:48  ← Gen cid:48  public key is  pk,s cid:48   and the secret key is  sk,s cid:48  . Signature generation: Sign cid:48   H 1k . The   cid:161  sk,s cid:48  m  computes s ← GenH 1k  and outputs s, Signsk H cid:48    cid:162  s cid:48  s Hs m    .  Once again, we stress that a fresh key s is chosen for each message signed. Signature veriﬁcation: Vrfy cid:48  s cid:48  s Hs m ,σ .  pk,s cid:48  m, s,σ   outputs Vrfypk H cid:48    64  2 Cryptographic Hardness Assumptions  The reader is referred to [11] for a proof of the following:  Theorem 2.12. If Π is existentially unforgeable  resp., strongly unforgeable  under an adaptive chosen-message attack and  GenH ,H  and  Gen cid:48  H ,H cid:48   are both univer- sal one-way, then Π cid:48  is existentially unforgeable  resp., strongly unforgeable  under an adaptive chosen-message attack.  2.4.2 Reducing the Public-Key Length  As our next application of hash functions to signature schemes, we consider ways of shortening the public key. While these techniques are generally useful — in partic- ular, they show that schemes with optimal public-key size are possible — our goal here is to use these techniques to construct a  one-time  signature scheme capable of signing messages twice as long as its own public key; this will be used when we construct existentially unforgeable signature schemes based on general assumptions in the next chapter.  pk,sk m  outputs  pk, Signsk m  .  Hs pk . The public key is  s, pk cid:48   and the secret key is  pk,sk .  The obvious way to decrease the public-key size is to simply hash the orig- inal public key. Formally, let Π =  Gen, Sign, Vrfy  be an existentially unforge- able signature scheme having q k -bit public keys, and let  GenH ,H  be a hash function mapping q k -bit inputs to k-bit outputs. Then the following scheme Π cid:48  =  Gen cid:48 , Sign cid:48 , Vrfy cid:48   has public keys of length k:   Gen cid:48  1k  computes  pk,sk  ← Gen 1k  and s ← GenH 1k , and sets pk cid:48  :=   Sign cid:48    Vrfys,pk cid:48  m, pk,σ   outputs 1 iff  1  Hs pk  ?= pk cid:48  and  2  Vrfypk m,σ  ?= 1. It is not difﬁcult to verify that Π cid:48  is existentially unforgeable if  GenH ,H  is uni- versal one-way.  Note that the hashed input pk is chosen independently of the hash key s.  But public keys in Π cid:48  have length pk cid:48  +s = k +s bits, an improvement only if s < q k  − k. While this bound on the length of the hash key s can be achieved fairly easily if we are willing to assume collision-resistance, the bound is more difﬁcult to ensure based on universal one-wayness alone  cf. the discussion at the end of Section 2.3.4 .  Fortunately, it is possible to guarantee a public key shorter than the message by  running sufﬁciently many copies of the original signature scheme in parallel. Let us ﬁrst verify the claim regarding the lengths of the public key and the mes- sages. Π cid:48  has public keys of size h k  +  cid:96 · k and can sign messages of length 3k·  cid:96 . By our choice of  cid:96  we have  3k cid:96  > 2k cid:96  + k·  2h k  k  = 2k cid:96  + 2h k ,  and so the messages that can be signed have length at least twice that of the public key. As for the security of the construction, we have:   2.4 Applications of Hash Functions to Signature Schemes  65  Construction 2.5: A signature scheme for messages twice as long as public keys  Let Π =  Gen, Sign, Vrfy  be a signature scheme for 3k-bit messages having q k - bit public keys, and let  GenH ,H  be a hash function mapping q k -bit inputs to k-bit outputs and having keys of length h k . Choose  cid:96  k  > 2h k  k, and construct signature scheme Π cid:48  =  Gen cid:48 , Sign cid:48 , Vrfy cid:48   as follows: Key generation: Gen cid:48  1k  does as follows: 1. Compute s ← GenH 1k . 2. For i = 1 to  cid:96 , compute  pki,ski  ← Gen 1k  and set pk cid:48  The public key is  s, pk cid:48  Signature generation: Sign cid:48  pk1, Signsk1 m1 , . . . , pk cid:96 , Signsk cid:96  for all i. It then outputs the signature Signature veriﬁcation: Vrfy cid:48   m, pk1,σ1, . . . , pk cid:96 ,σ cid:96    parses the message m as m1, . . . ,m cid:96  with mi = 3k for all i. It then outputs 1 iff for all i:  1  Hs pki  ?= pk cid:48    m  parses m as m1, . . . ,m cid:96  with mi = 3k   cid:96  , and the secret key is  pk1,sk1, . . . , pk cid:96 ,sk cid:96  .  i, and  2  Vrfypki mi,σi  ?= 1.  i := Hs pki .  1, . . . , pk cid:48   pk1,sk1,...,pk cid:96 ,sk cid:96   1,...,pk cid:48    m cid:96    s,pk cid:48    cid:161    cid:162   .   cid:96   Theorem 2.13. If Π is existentially unforgeable  resp., strongly unforgeable  under a one-time chosen-message attack and  GenH ,H  is universal one-way, then Π cid:48  is existentially unforgeable  resp., strongly unforgeable  under a one-time chosen- message attack.  Proof  sketch . We treat the case of existential unforgeability; strong unforgeabil- ity can be proven similarly. Consider a PPT adversary A attacking Π cid:48  in a one-time chosen-message attack. Let m cid:48  = m cid:48   cid:96  be the message whose signature is re-  quested by A, and say A outputs the forged signature   cid:99 pk1,σ1, . . . , cid:99 pk cid:96 ,σ cid:96   on the message m = m1, . . . ,m cid:96   cid:54 = m cid:48  If cid:99 pki  cid:54 = pki for some i, then A has violated the as-  sumed universal one-wayness of  GenH ,H . Letting j be any index with m j  cid:54 = m cid:48  j, we thus have that σj is a forged signature on the message m j with respect to scheme Π  and public key pk j .  1, . . . ,m cid:48   An alternate, somewhat easier proof of the above theorem relies on the construc- tion of universal one-way hash functions with high compression and short keys. We have given the above proof in order to keep the exposition self-contained.  Construction 2.5 is not existentially unforgeable when an adversary can request signatures on more than one message  even if Π is . However, a variant of the con- struction — in which each block of a signed message is pre-pended with a random, message-speciﬁc identiﬁer — is secure in that sense  when Π is . See Construc- tion 1.4 for the general idea.   66 2.5 Further Reading  2 Cryptographic Hardness Assumptions  Goldreich’s book [56] is a good source for further information regarding generic assumptions, while more details regarding the number-theoretic assumptions dis- cussed here can be found in [72]. The notions of a one-way function and a trapdoor permutation originate in the work of Difﬁe and Hellman [40], though formal deﬁ- nitions appeared only much later. Clawfree trapdoor permutations were introduced by Goldwasser, Micali, and Rivest [61] in the course of constructing the ﬁrst secure digital signature scheme, and that work also contains a construction of clawfree trapdoor permutations based on the hardness of factoring  that is slightly different from the one given here .  Rabin [97] was the ﬁrst to propose a trapdoor function based on the hardness of factoring, and Williams [110] and Blum [16] suggested restricting N to a special form to obtain a trapdoor permutation. As mentioned previously, the RSA assump- tion is due to Rivest, Shamir, and Adleman [99]. A recent survey by Boneh [17] discusses various attacks on RSA and also covers known results on the relationship between the RSA and factoring assumptions. The discrete logarithm assumption  without the restriction to prime order groups  is due to Difﬁe and Hellman [40].  Collision-resistant hash functions were ﬁrst formally deﬁned by Damg˚ard [37], and the construction of collision-resistant hash functions from clawfree permuta- tions is from that work as well. The Merkle-Damg˚ard transformation was introduced independently in [38, 81], and our treatment in Section 2.3.2 is adapted from [72, Section 4.6.4]. Universal one-way hash functions originated in the work of Naor and Yung [88], where the construction of universal one-way hash functions based on one-way permutations was given. Rompel [100]  see also [71]  showed that uni- versal one-way hash functions could be built from any one-way function. See [72] for extensive further discussion about hash functions and their applications.  Techniques for increasing the compression of universal one-way hash functions with reduced key expansion can be found in [11, 105]. Construction 2.4 is due to [11].   Part II Digital Signature Schemes without Random Oracles   Chapter 3 Constructions Based on General Assumptions  Our objective in this chapter is to present a construction of a digital signature scheme based on the minimal assumption  cf. Theorem 2.1  that one-way functions exist. Along the way we will see a relatively simple construction, due to Lamport, of a one-time signature scheme based on the same assumption. We warn the reader at the outset that efﬁciency will not be a consideration here; we aim instead for gen- erality  ﬁrst  and simplicity of exposition  second . Interestingly, although several improved constructions of one-time signatures from one-way functions or permuta- tions are known, the construction of a CMA-secure signature described in this chap- ter is essentially the best known  from any of the general assumptions discussed in the previous chapter ; improving the efﬁciency of this generic construction remains an interesting and important open question.  Determining the weakest possible assumptions on which signatures can be based is, of course, essential for a solid theoretical understanding of signature schemes. Beyond this, one might wonder whether there is any practical value in studying schemes based on general assumptions given that all known examples of, say, one- way functions have some additional algebraic structure. In fact, this is not quite true: it is reasonable to treat, e.g., the hash function SHA-1 as a one-way function1, and so we can use SHA-1 to instantiate the one-way function in schemes based on this assumption. Given the vast efﬁciency advantage of SHA-1 relative to number- theoretic assumptions, this may yield a scheme that is actually more efﬁcient  at least2 in certain respects  than the “efﬁcient” schemes we show in later chapters. This is particularly true with regard to the Lamport one-time signature scheme.  1 Since SHA-1 is deﬁned only for ﬁxed output length, it cannot be a one-way function in the complexity-theoretic sense. Nevertheless we certainly expect SHA-1 to be “hard to invert” for algorithms running in any practical amount of time. 2 All known signature schemes based on general assumptions have very long signatures  regardless of how the underlying assumption is instantiated . On the other hand, the computational efﬁciency of signing or verifying  when using a scheme based on one-way functions that is instantiated with SHA-1  may — depending on the message length and the security desired — be competitive with the efﬁciency of number-theoretic schemes.  J. Katz, Digital Signatures, DOI 10.1007 978-0-387-27712-7_3,   Springer Science+Business Media, LLC 2010  69   70  3 Constructions Based on General Assumptions  Overview of the chapter. We begin by describing Lamport’s construction of a one- time signature scheme based on any one-way function. We then observe, in a series of steps, that we can use a tree-based approach to build a full-ﬂedged signature scheme starting from any one-time signature scheme that can sign messages twice as long as its public key. It is worth remarking that a scheme with this property is trivial to construct if we are willing to assume the existence of collision-resistant hash functions. If we want a construction based only on one-way functions, we have to work a bit harder. The Lamport scheme, in particular, does not have this property  indeed, the public key in the Lamport scheme is much longer than the messages that can be signed . Fortunately, a signature scheme satisfying the stated requirement  and based only on one-way functions  follows fairly easily from our work in the previous chapter.  3.1 Lamport’s One-Time Signature Scheme  The basic idea of Lamport’s signature scheme is simple, and we illustrate it ﬁrst for the case of signing 3-bit messages. Let f be a one-way function. The public key consists of 6 elements y1,0, y1,1, y2,0, y2,1, y3,0, y3,1 in the range of f ; the private key contains the corresponding pre-images x1,0, x1,1, x2,0, x2,1, x3,0, x3,1. These keys can be visualized as two-dimensional arrays:   cid:181    cid:182    cid:181   pk =  y1,0 y2,0 y3,0 y1,1 y2,1 y3,1  sk =  x1,0 x2,0 x3,0 x1,1 x2,1 x3,1   cid:182   .  To sign a message m = m1 cid:107 m2 cid:107 m3, where each mi is a single bit, the signer releases the appropriate pre-image xi,mi for 1 ≤ i ≤ 3; that is, the signature σ simply consists of the three values  x1,m1,x2,m2,x3,m3 . Veriﬁcation is carried out in the natural way: presented with the candidate signature  x1,x2,x3  on the message m = m1 · m2 · m3, the veriﬁer accepts if and only if f  xi  ?= yi,mi for 1 ≤ i ≤ 3. This is shown graphi- cally in Figure 3.1. The Lamport scheme for arbitrary message length  cid:96  is described formally as Construction 3.1.   cid:195    cid:195    cid:33    cid:33  cid:41   Signing m = 011:  sk =  x1,0 x1,1  x2,0 x2,1  x3,0 x3,1  ⇒ σ =  x1,0, x2,1, x3,1   Verifying for m = 011 and σ =  x1,x2,x3 :  pk =  y1,0 y1,1  y2,0 y2,1  y3,0 y3,1  ⇒  f  x1  ?= y1,0 f  x2  ?= y2,1 f  x3  ?= y3,1  Fig. 3.1 The Lamport scheme used to sign the message m = 011.   3.1 Lamport’s One-Time Signature Scheme  71  Construction 3.1: The Lamport one-time signature scheme  Let f be a function, and let  cid:96  =  cid:96  k  denote the desired message length. Key generation: Algorithm Gen 1k  is deﬁned as follows. For i ∈ {1, . . . ,  cid:96 }, do: 1. Choose random xi,0,xi,1 ← {0,1}k. 2. Compute yi,0 := f  xi,0  and yi,1 := f  xi,1 . The public key pk and the private key sk are   cid:182    cid:181    cid:181   pk :=  y1,0 y2,0 ··· y cid:96 ,0 y1,1 y2,1 ··· y cid:96 ,1  sk :=  x1,0 x2,0 ··· x cid:96 ,0 x1,1 x2,1 ··· x cid:96 ,1   cid:182   .  Signature generation: On input a private key sk as above and a message m ∈{0,1} cid:96  with m = m1 cid:107 ··· cid:107 m cid:96 , output the signature  x1,m1, . . . , x cid:96 ,m cid:96  . Signature veriﬁcation: On input a public key pk as above, a message m ∈ {0,1} cid:96  with m = m1 cid:107 ··· cid:107 m cid:96 , and a signature σ =  x1, . . . ,x cid:96  , output 1 if and only if it is the case that f  xi  = yi,mi for 1 ≤ i ≤  cid:96 .   cid:181    cid:182   Theorem 3.1. Let  cid:96  be any polynomial. If f is a one-way function, then Construc- tion 3.1 is existentially unforgeable under a one-time chosen-message attack.  y1,0 y2,0 ··· y cid:96 ,0 y1,1 y2,1 ··· y cid:96 ,1  Proof. We let  cid:96  =  cid:96  k  for the rest of the proof. As intuition for the security of the scheme, note that for an adversary given public key pk = , ﬁnding an x such that f  x  = yi∗,b∗ for any  i∗,b∗  amounts to inverting f . So it will certainly be hard to compute a signature on any message m given only the public key. What about computing a signature on some message m after being given a signature on a different message m cid:48 ? If m cid:48   cid:54 = m then there must be at least one position i∗ on which these messages differ. Say mi∗ = b∗  cid:54 = m cid:48  i∗. Then forging a signature on m requires, in particular, ﬁnding an x such that f  x  = yi∗,b∗. But ﬁnding such an x does not become any easier even when given {xi,b} for all  i,b   cid:54 =  i∗,b∗   since the values {xi,b} i,b  cid:54 = i∗,b∗  are all chosen independently of xi∗,b∗ .  We now turn this intuition into a formal proof. Let Π =  Gen, Sign, Vrfy  denote the Lamport signature scheme. Let A be a probabilistic polynomial-time adversary, and denote by  m,σ  ← ExptA,Π 1k  the experiment   pk,sk  ← Gen 1k ; m,σ  ← ASignsk ·  pk ,  where A is allowed only a single query to its signing oracle. Letting m cid:48  denote the message that A queries to its signing oracle in a particular execution of ExptA,Π 1k   we assume without loss of generality that there is always some such message , we then let Forge be the event that Vrfypk m,σ  = 1 and m  cid:54 = m cid:48 .   72  Deﬁne  3 Constructions Based on General Assumptions   cid:105   cid:104   m,σ  ← ExptA,Π 1k  : Forge  SuccA,Π k  def= Pr  and note that this is exactly the success probability of A as deﬁned in Deﬁnition 1.7. To prove the theorem we must show that SuccA,Π k  is negligible. In a particular execution of ExptA,Π 1k  where Forge occurs, we say that A output a forgery at  i,b  if b = mi  cid:54 = m cid:48  i. In other words, this means that A has succeeded in forging a valid signature on a message m after being given a signature on some message m cid:48   cid:54 = m, and moreover mi = b while m cid:48  i = 1−b. It is immediately clear that whenever Forge occurs, A outputs a forgery at some  i,b . We now construct the following PPT algorithm I attempting to invert the one-  way function f :  Algorithm I : The algorithm is given y and 1k as input. It goal is to output x with f  x  = y. 1. Choose a random index i∗ ←{1, . . . ,  cid:96 } and a random bit b∗ ← {0,1}. 2. For all i ∈ {1, . . . ,  cid:96 } and b ∈ {0,1} with  i,b   cid:54 =  i∗,b∗ :  Set yi∗,b∗ := y.   Choose xi,b ← {0,1}k and set yi,b := f  xi,b .   cid:181    cid:182   y1,0 y2,0 ··· y cid:96 ,0 y1,1 y2,1 ··· y cid:96 ,1  .  3. Run A on input pk := 4. When A requests a signature on the message m cid:48 :  i∗ = b∗, stop.    If m cid:48    Otherwise, return the correct signature σ=  x1,m cid:48    If A output a forgery at  i∗,b∗ , then output xi∗.  5. When A outputs  m,σ  with σ =  x1, . . . ,xp :  1  , . . . ,x cid:96 ,m cid:48    .   cid:96   Whenever A outputs a forgery at  i∗,b∗ , algorithm I succeeds in inverting its given input y. We are interested in the probability that this occurs when the input to I is generated by choosing a random x ← {0,1}k and then setting y := f  x   cf. Deﬁnition 2.1 . To analyze this probability it is useful to imagine a “mental exper- iment” in which I is given x at the outset, sets xi∗,b∗ := x, and then always returns a signature to A in step 4  i.e., even if m cid:48  i∗ = b∗ . It is not hard to see that the view of A being run as a subroutine by I in this mental experiment is distributed iden- tically to the view of A in ExptA,Π 1k . Therefore, the probability that A outputs a forgery in step 5 is exactly SuccA,Π k . Because  i∗,b∗  was chosen at random at the beginning of the experiment, and the view of A is independent of this choice, the probability that A outputs a forgery at  i∗,b∗  — conditioned on the fact that A outputs a forgery — is at least 1 2 cid:96 .  This is because a signature forgery implies a forgery for at least one point  i,b . Since there are 2 cid:96  points, the probability of the forgery being at  i∗,b∗  is at least 1 2 cid:96 .  We conclude that, in this mental experi- ment, the probability that A outputs a forgery at  i∗,b∗  is at least SuccA,Π k  2 cid:96 . Returning to the real experiment involving I as initially described, the key ob- servation is that the probability that A outputs a forgery at  i∗,b∗  is unchanged.   3.1 Lamport’s One-Time Signature Scheme  73  This is because the mental experiment and the real experiment coincide if A outputs a forgery at  i∗,b∗ . That is, the experiments only differ if A requests a signature on a message m cid:48  with m cid:48  i∗ = b∗; but if this happens then it is impossible  by deﬁnition  for A to subsequently output a forgery at  i∗,b∗ . So, in the real experiment, the probability that A outputs a forgery at  i∗,b∗  is still at least SuccA,Π k  2 cid:96 . That is:  Pr[x ← {0,1}k;y := f  x ;x cid:48  ← I  1k,y  : f  x cid:48   = y] ≥ SuccA,Π k  2 cid:96 .  Because f is a one-way function, we must have SuccA,Π k  2 cid:96  ≤ negk k ; since  cid:96  is polynomial, we conclude that SuccA,Π k  is negligible.  It is worth noting that the Lamport scheme is completely insecure if it is used to sign more than one message: an adversary who obtains signatures on both 0 cid:96  and 1 cid:96   with respect to the same public key  learns the entire secret key! Achieving strong unforgeability. An easy observation if that if the function f in Lamport’s scheme is a one-way permutation  or generated from a family of one-way permutations in the natural way , then the scheme is strongly unforgeable under a one-time chosen-message attack. A variant of Lamport’s scheme achieves strong unforgeability under the  minimal  assumption that one-way functions exist. The basic idea here is to instantiate the one-way function f in Construction 3.1 with a universal one-way hash function  that, in turn, can be constructed from any one-way function; see Section 2.3.4 . In more detail, let  GenH ,H  be a universal one-way hash function mapping 2k-bit inputs to k-bit outputs. Key generation now works by choosing a random seed s ← GenH 1k  and then proceeding as in Construction 3.1. I.e., for i ∈ {1, . . . ,  cid:96 }, do: 1. Choose random xi,0,xi,1 ← {0,1}2k. 2. Compute yi,0 := Hs xi,0  and yi,1 := Hs xi,1 . The public key pk is   cid:181    cid:181   pk :=  s,  y1,0 y2,0 ··· y cid:96 ,0 y1,1 y2,1 ··· y cid:96 ,1   cid:182  cid:182    note the inclusion of s , and the secret key is as before. Veriﬁcation is done in the natural way. We have:  Theorem 3.2. Let  cid:96  be any polynomial. If  GenH ,H  is universal one-way, then the above construction is strongly unforgeable under a one-time chosen-message attack.  Proof  sketch . The reduction is, in fact, easier than that used in the preceding proof. Construct an algorithm I as follows:  Algorithm I: 1. For all i ∈ {1, . . . ,  cid:96 } and b ∈ {0,1}, choose xi,b ← {0,1}2k. 2. Choose random i∗ ← {1, . . . ,  cid:96 } and b∗ ← {0,1}. Output  xi∗,b∗ and receive in return a key s.   74  3 Constructions Based on General Assumptions   cid:181    cid:181    cid:182  cid:182   3. For all i ∈ {1, . . . ,  cid:96 } and b ∈ {0,1}, set yi,b := Hs xi,b . 4. Run A on input pk := 5. When A requests a signature on the message m cid:48 , return the  y1,0 y2,0 ··· y cid:96 ,0 y1,1 y2,1 ··· y cid:96 ,1  s,  .  6. When A outputs  m,σ  with σ =  x1, . . . ,xp :  correct signature σ =  x1,m cid:48    If A output a forgery at  i∗,b∗ , then output xi∗.  , . . . ,x cid:96 ,m cid:48    .  1   cid:96   Since I never need abort, it is not immediately clear that A outputs a forgery at  i∗,b∗  with probability at least SuccA,Π k  2 cid:96   with SuccA,Π k  deﬁned in the nat- ural way . Now, however, an additional argument is needed in order to claim that I succeeds  cf. Deﬁnition 2.13  with overwhelming probability whenever A outputs a forgery at  i∗,b∗ .  Indeed, it could be the case that xi∗ = xi∗,b∗ in which case I does not succeed.  This follows from the facts that, with overwhelming probability, the number of pre-images of yi∗,b∗ with respect to Hs is exponential, and A has no information regarding which pre-image of yi∗,b∗ algorithm I chose.  3.2 Signatures from One-Time Signatures  Lamport’s one-time signature scheme can be useful in its own right: although the public key  and signatures  are long, signing and veriﬁcation can be very efﬁcient when the one-way function is instantiated using, e.g., a cryptographic hash function. Lamport’s scheme will also be a key component in our eventual construction of a CMA-secure signature scheme. Building to that result, we show here how to build a full-ﬂedged signature scheme from any one-time signature scheme that can sign messages twice as long as its public key. Had Lamport’s scheme satisﬁed this crite- rion, we would be done; alas, in Lamport’s scheme the public key is much longer than the messages being signed.  E.g., if we take f to be length-preserving then a public key of length 2k cid:96  is needed to sign messages of length  cid:96 .  Nevertheless, the results of the preceding chapter already show how to construct a one-time signature scheme with the desired property, as we will later observe.  We build up to our ﬁnal construction of this section in stages. In Section 3.2.1 we deﬁne the notion of a stateful signature scheme, where the signer updates its private key after each signature, and show how to construct a CMA-secure stateful signature scheme. In Section 3.2.2 we discuss a more efﬁcient variant of this scheme that is still stateful. We then describe how this construction can be made stateless, as required by our original deﬁnition of a signature scheme.   3.2 Signatures from One-Time Signatures 3.2.1 “Chain-Based” Signatures  75  We ﬁrst deﬁne the notion of a stateful signature scheme, where the signer may main- tain some state that is updated after every signature is produced.  Deﬁnition 3.1. A stateful signature scheme consists of three efﬁcient algorithms  Gen∗, Sign∗, Vrfy∗  such that:   The randomized key-generation algorithm Gen∗ takes as input the security pa- rameter 1k, and outputs  pk,sk,s0  where pk is the public key, and sk is the private key, and s0 is the initial state.   The signing algorithm Sign∗ takes as input a secret key sk, the current state si−1, and a message m. It outputs a signature σ and an updated value si for the state.   The deterministic veriﬁcation algorithm Vrfy takes as input a public key pk, a message m, and a  purported  signature σ. It outputs a single bit b, with b = 1 signifying “accept” and b = 0 signifying “reject.”  We impose the natural correctness condition: for every k, every  pk,sk,s0  output by Gen∗ 1k , and any sequence of messages m1, . . . ,m cid:96 , if we compute  σi,si  ← Sign∗  sk,si−1 mi  for i ∈ {1, . . . ,  cid:96 }, then for every i ∈ {1, . . . ,  cid:96 } we have  Vrfy∗  pk mi,σi  = 1.  We emphasize that the state is not needed in order to verify a signature. Signature schemes that do not maintain state  as per the standard deﬁnition  are called stateless to distinguish them from stateful schemes. Clearly, stateless schemes are preferable though stateful schemes can still potentially be useful depending on the context. In any case, as discussed earlier, our aim in introducing stateful signatures is simply to use them as a stepping stone to a full stateless construction.  Existential unforgeability under an adaptive chosen-message attack for the case of stateful signatures schemes is deﬁned in a manner exactly analogous to Deﬁ- nition 1.6, with the only subtleties being that the signing oracle only returns the signature  and not the state , and that the signing oracle updates and maintains the state appropriately each time it is invoked.  We can easily construct a stateful “ cid:96 -time” signature scheme that can sign  cid:96  =  cid:96  k  messages for any polynomial  cid:96 .  The notion of security here would be analogous to the deﬁnition of one-time signatures given earlier; we do not give a formal deﬁnition since our discussion here is only informal.  Such a construction works by simply letting the public key consist of  cid:96  independently generated public keys for some one-time signature scheme Π, with the private key similarly con- structed; i.e., set pk :=  pk1, . . . , pk cid:96   and sk :=  sk1, . . . ,sk cid:96   where each  pki,ski  is an independently-generated key-pair for some one-time signature scheme. The state is just a counter initially set to 1. To sign a message m using the private key sk and current state i ≤  cid:96 , simply compute σi ← Signski m   that is, generate a one-time signature on m using the ith private key ski , output the signature  i,σi , and update the state to i + 1. In other words, the ith message is signed using ski. Veriﬁcation   76  3 Constructions Based on General Assumptions  of a signature  i,σi  on a message m can be done by checking whether σi is a valid signature on m with respect to pki.  Intuitively, this scheme is secure if used to sign  cid:96  messages because each private key is used to sign only a single message.  In fact, if Π is strongly unforgeable under a one-time chosen-message attack then the construction is strongly unforgeable un- der an  cid:96 -time chosen-message attack.  Since  cid:96  may be an arbitrary polynomial, why doesn’t this give us the solution we are looking for? The main drawback is that the scheme requires the upper bound  cid:96  on the number of messages that can be signed to be ﬁxed in advance, at the time of key generation.  In particular, the scheme does not satisfy Deﬁnition 1.2.  This is a potentially severe limitation since once the up- per bound is reached a new public key would have to be generated and distributed. We would like instead to have a single, ﬁxed scheme that can support signing an unbounded number of messages. Another drawback of the scheme is the fact that it is not very efﬁcient, since the public and private keys have length that is linear in the total number of messages that can be signed.  We remark that more efﬁcient constructions of  cid:96 -time signatures are possible, by direct modiﬁcation of Lamport’s scheme. Such scheme still have public and private keys whose length is linear in the number of messages to be signed and, in any case, the ﬁrst drawback remains.   Let Π =  Gen, Sign, Vrfy  be a one-time signature scheme. In the scheme we have just described, the signer runs  cid:96  invocations of Gen to obtain public keys pk1, . . . , pk cid:96 , and includes each of these in its actual public key pk. The signer is then restricted to signing at most  cid:96  messages. We can do better by using a “chain- based scheme” in which the signer generates and certiﬁes additional public keys on-the-ﬂy as needed.  Let us now assume that Π can sign messages twice as long as its public keys. For concreteness and without loss of generality, we assume that public keys have length k, and that messages of length 2k can be signed.  In the chain-based scheme, the public key consists of just a single public key pk1 generated using Gen, and the private key contains the associated private key sk1; the initial state is empty. To sign the ﬁrst message m1 ∈ {0,1}k, the signer ﬁrst generates a new key-pair  pk2,sk2  using Gen, and then signs both m1 and pk2 using sk1 to obtain σ1 ← Signsk1 m1 cid:107 pk2 . The signature that is output includes both pk2 and σ1, and the signer adds  m1, pk2,sk2,σ1  to its state. In the general case, when it comes time to sign the ith message the signer will have stored { m j, pk j+1,sk j+1,σj }i−1 j=1 as its state. To sign the ith message mi ∈ {0,1}k, the signer generates a new key-pair  pki+1,ski+1  using Gen, and then signs mi and pki+1 using ski to obtain a signature σi ← Signski mi cid:107 pki+1 . The actual signature that is output includes pki+1, σi, and also the values {m j, pk j+1,σj}i−1 j=1. The signer then adds  mi, pki+1,ski+1,σi  to its state.  To verify a signature  pki+1,σi,{m j, pk j+1,σj}i−1  j=1  on a message m = mi with respect to public key pk1, the receiver veriﬁes each link between the public key pk j and the next public key pk j+1 in the chain, as well as the link between the last public key pki+1 and m. That is, the veriﬁcation procedure outputs 1 if and only if   3.2 Signatures from One-Time Signatures 77 Vrfypk j m j cid:107 pk j+1,σj  ?= 1 for all j ∈ {1, . . . ,i}. Observe that this veriﬁcation begins from the public key pk1 that was initially distributed. It is not hard to be convinced — at least on an intuitive level — that the signa- ture scheme thus constructed is existentially unforgeable under an adaptive chosen- message attack, regardless of how many messages are signed.  In fact, if Π is strongly unforgeable then so is the chain-based scheme constructed from Π.  In- formally, this is once again due to the fact that each key-pair  pki,ski  is used to sign only a single “message”  where in this case the “message” is actually the con- catenation mi cid:107 pki+1 of a message and a public key . Since we are going to prove the security of a more efﬁcient scheme in the next section, we do not give a formal proof of security for the chain-based scheme here.  The chain-based signature scheme is a stateful signature scheme that is exis- tentially unforgeable under an adaptive chosen-message attack. It has a number of disadvantages, though. For one, there is no immediate way to eliminate the state  recall that our ultimate goal is a stateless scheme satisfying Deﬁnition 1.2 . It is also not very efﬁcient, in that the signature length, size of the state, and veriﬁcation time are all linear in the number of messages that have been signed. Finally, each signature reveals all previous messages that have been signed. While this does not technically violate any security requirement for signatures, it is easy to imagine that this may be undesirable in some contexts. We will eliminate all these advantages in the next section.  3.2.2 “Tree-Based” Signatures  The signer in the chain-based scheme of the previous section can be viewed as maintaining a tree, rooted at the public key pk1, whose degree is 1 and whose depth is equal to the number of messages signed thus far. A natural way to improve the efﬁciency of this approach is to use a binary tree in which each node has degree 2. As before, a signature will correspond to a “certiﬁed” path in the tree from a leaf to the root; notice that as long as the tree has polynomial depth  even if it has exponential size! , veriﬁcation can still be done in polynomial time.  Concretely, to sign messages of length k we will work with a binary tree of depth k having 2k leaves. As before, the signer will add nodes to the tree “on-the- ﬂy,” as needed  and in particular this ensures that only polynomially many leaves are explicitly deﬁned, while the rest remain implicit . In contrast to the chain-based scheme, though, only leaves  and not internal nodes  will be used to certify mes- sages. Each leaf of the tree will correspond to one of the possible messages of length k.  In more detail, we imagine a binary tree of depth k where the root is labeled by ε  i.e., the empty string , and a node that is labeled with the binary string w of length less than k has left-child labeled w0 and right-child labeled w1. For every node w, we associate a pair of keys pkw,skw from our one-time signature scheme Π.  We continue to assume that Π can sign messages up to twice as long as its public key.    78  3 Constructions Based on General Assumptions  The public key of the root, pkε, is the actual public key of the signer. To sign a message m ∈ {0,1}k, the signer carries out the following steps: 1. It ﬁrst generates keys  as needed  for all nodes on the path from the root to the leaf labeled m.  Some of these public keys may have been generated in the process of signing previous messages; in this case the previous value — stored as part of the state — is used.  2. Next, the signer “certiﬁes” the path from the root to the leaf labeled m by com- puting a signature on pkw0 cid:107 pkw1, using private key skw, for each string w that is a proper preﬁx of m.  3. Finally, the signer “certiﬁes” m itself by computing a signature on m using the  private key skm.  The ﬁnal signature on m consists of the signature on m with respect to pkm, as well as all the information needed to verify the path from the leaf labeled m to the root. The signer also updates its state by storing all the key pairs generated as part of the signing process. A formal description of this scheme is given as Construction 3.2.  Notice that each of the underlying keys in this scheme is used to sign only a single “message”: each key associated with an internal node signs a pair of public keys, and keys at the leaves are used to sign a single message.  Before proving security of this tree-based approach, let us note that it improves on the chain-based scheme in a number of respects. It still allows for signing an unbounded number of messages. In terms of efﬁciency, the signature length and veriﬁcation time are now proportional to the message length k but are independent of the number of messages signed.  If some bound  cid:96  on the total number of messages to be signed were known, a modiﬁcation of the scheme would have signature length and veriﬁcation time O log  cid:96  .  The scheme is stateful, but we will see that this can be rectiﬁed after we prove the following result.  Theorem 3.3. Let Π be a signature scheme that is existentially unforgeable  resp., strongly unforgeable  under a one-time chosen-message attack. Then Construc- tion 3.2 is existentially unforgeable  resp., strongly unforgeable  under an adaptive chosen-message attack.  Proof. We prove existential unforgeability, but the proof of strong unforgeability  assuming Π is strongly unforgeable  is essentially the same. Let Π∗ denote Con- struction 3.2. Let A∗ be a probabilistic polynomial time adversary, let  cid:96 ∗ =  cid:96 ∗ k  be a  polynomial  upper bound on the number of signing queries made by A∗, and set  cid:96  =  cid:96  k  def= 2k cid:96 ∗ k +1. Note that  cid:96  upper-bounds the number of public keys from Π that are needed to generate  cid:96 ∗ signatures using Π∗. This is because each signature in π∗ requires at most 2k new keys from Π  in the worst case , and there is one additional key from Π that is used as the actual public key pkε. Let ExptA∗,Π∗ 1k  denote the experiment in which A∗ interacts with Π∗ exactly as in Deﬁnition 1.6  with the only difference being that now the signing oracle main- tains state . Let δ k  denote the probability with which A∗ outputs a valid forgery in ExptA∗,Π∗ 1k . Consider the following PPT adversary A attacking the one-time signature scheme Π:   3.2 Signatures from One-Time Signatures  79  Construction 3.2: A “tree-based” signature scheme  def= ε, the empty string .  Let Π =  Gen, Sign, Vrfy  be a signature scheme signing messages twice as long as its public key. For a binary string m, let mi def= m1···mi denote the i-bit preﬁx of m  with m0 Key generation: Algorithm Gen∗ 1k  is deﬁned as follows. On input 1k, compute  pkε,skε  ← Gen 1k  and output the public key pkε. The private key and initial state are skε. Signature generation: To sign a message m ∈ {0,1}k using the current state, algo- rithm Sign∗ does the following: 1. For i = 0 to k− 1:    If pkmi0, pkmi1, and σmi are not in the current state, compute them:   pkmi0,skmi0  ← Gen 1k   pkmi1,skmi1  ← Gen 1k   σmi ← Signskmi   pkmi0 cid:107  pkmi1 ,   cid:179  cid:169    cid:170 k−1   cid:180   and then store all these computed values as part of the state.  2. If σm is not yet included in the state, compute σm ← Signskm m  and store it as  part of the state.  3. Output the signature   cid:179  cid:169   σmi , pkmi0, pkmi1  i=0 , σm  .   cid:170 k−1   cid:180   Signature veriﬁcation: On input a public key pkε, a message m ∈ {0,1}k, and signature  , output 1 if and only if:  σmi , pkmi0, pkmi1  pkmi0 cid:107  pkmi1,σmi  ?= 1 for all i ∈ {0, . . . ,k− 1}.  i=0 , σm  1. Vrfypkmi 2. Vrfypkm m,σm  ?= 1.  Adversary A: A is given as input a public key pk  the security parameter k is implicit .   Choose a random index i∗ ← {1, . . . ,  cid:96 }. Construct a list  pk1, . . . , pk cid:96  of keys as follows: – Set pki∗ – For i  cid:54 = i∗, compute  pki,ski  ← Gen 1n .  := pk.    Run A∗ on input the public key pkε = pk1. When A∗ requests  a signature on a message m do:   80  3 Constructions Based on General Assumptions  1. For i = 0 to k− 1:  –  If the values pkmi0, pkmi1, and σmi have not yet been deﬁned, then set pkmi0 and pkmi1 equal to the next two unused public keys pk j and pk j+1, and com- pute a signature σmi on pkmi0 cid:107  pkmi1 with respect to pkmi.3  2. If σm is not yet deﬁned, compute a signature σm on m  3. Give   cid:179  cid:169    cid:170 k−1  with respect to pkm  see footnote 3 . i=0 , σm   cid:180   cid:170 k−1   Say A∗ outputs a message m and a signature i=0 , σ cid:48   σmi , pkmi0, pkmi1  σ cid:48  mi, pk cid:48   mi0, pk cid:48    cid:179  cid:169   mi1  m  to A∗.   cid:180   .  If this is a valid signature on m, then: Case 1: Say there exists a j ∈ {0, . . . ,k − 1} for which m j1  cid:54 = pkm j1; this includes the case m j0  cid:54 = pkm j0 or pk cid:48  pk cid:48  when pkm j0 or pkm j1 were never deﬁned by A. Take the minimal such j, and let j∗ be such that pk j∗ = pkm j = pk cid:48  m j  such a j∗ exists by the minimality of j . If j∗ = i∗, output m j0 cid:107 pk cid:48   pk cid:48  Case 2: If case 1 does not hold, then pk cid:48  such that pk j∗  = pkm. If j∗ = i∗, output  m,σ cid:48   m = pkm. Let j∗ be  m j1, σ cid:48  m j   .  m .  = pk  the public key A was given initially .  The ﬁnal step of A may seem more complicated than it is due to the burdensome notation, but what is going on is rather simple: If A∗ forges a signature  with respect to Π∗  on a message m, then this implies that A∗ has effectively forged a signature  with respect to Π  somewhere along the path from the root to the leaf associated with m. The last step of A is simply to ﬁnd the ﬁrst such place where this occurs, and to identify the public key pk j∗ from its list of public keys {pk1, . . . , pk cid:96 } where the forgery occurs. A succeeds in forging a signature  with respect to Π  if it happens to be the case that pk j∗ = pki∗ The view of A∗ when run as a subroutine by A, when A is given pk generated by Gen 1k , is distributed identically to the view of A∗ in ExptA∗,Π∗ 1k . Thus, the probability that A∗ outputs a forgery when it is run as a subroutine by A is ex- actly δ k . Assuming that A∗ outputs a forgery, consider each of the two possible cases described above: Case 1: Since i∗ was chosen uniformly at random and is independent of the view of A∗, the probability that j∗ = i∗ is exactly 1  cid:96 . If j∗ = i∗, then A requested a single signature on the message pkm j0 cid:107 pkm j1 with respect to the public key pk = pki∗ = 3 If i  cid:54 = i∗ then A can compute a signature with respect to pki by itself. For i = i∗, the algorithm A can obtain a  single  signature with respect to pki∗ by making the appropriate query to its signing oracle. This is what is meant here.   3.2 Signatures from One-Time Signatures  pkm j that it was given. Moreover,  81  m j0 cid:107 pk cid:48  pk cid:48  is a valid signature on pk cid:48   m j1  cid:54 = pkm j0 cid:107 pkm j1 m j0 cid:107 pk cid:48   m j1 with respect to pk. Thus, A outputs  and yet σ cid:48  m j a valid forgery in this case. Case 2: Again, since i∗ was chosen uniformly at random and is independent of the view of A∗, the probability that j∗ = i∗ is exactly 1  cid:96 . Assuming j∗ = i∗, then A did not request any signatures with respect to the public key pk = pk j∗ = pkm and yet σ cid:48  m is a valid signature on m with respect to pk. We see again that A outputs a valid forgery in this case.  That is, conditioned on A∗ outputting a forgery  and regardless of which of the above cases occurs  A outputs a forgery with probability exactly 1  cid:96 . This means that A succeeds in outputting a valid forgery with probability exactly δ k   cid:96 . By the assumed security if Π and the fact that  cid:96  is polynomial, we conclude that δ k  must be negligible.  Another approach. For completeness, we remark that a variant of the tree-based approach can be applied directly to any one-time signature scheme Π  i.e., even if Π cannot sign messages twice as long as its own public key . We describe this variant informally. The public key of Π∗ contains pkε as in Construction 3.2 but now also include a key s for a universal one-way hash function. The same binary tree structure as in Construction 3.2 is used, except that now a node labeled w  associated with the key pair  pkw,skw   authenticates its two children  associated with the key pairs  pkw0,skw0  and  pkw1,skw1 , respectively  by computing σw ← Signskw  Hs  pkw0 cid:107  pkw1   .   Messages are signed by leaves exactly as before, without any hashing.  The obser- vation is that universal one-way hashing sufﬁces here because all the public keys associated with internal nodes are outside the control of the attacker  i.e., they are chosen by the signer independent of the hash key s . Reducing the tree depth. To sign messages of length  cid:96 , Construction 3.2 utilizes a tree of depth  cid:96  and associates each possible message m ∈ {0,1} cid:96  with the leaf la- beled by m.  Of course, the underlying one-time signature scheme Π must be able to sign messages of length  cid:96 .  Since the signature time, veriﬁcation time, and signature length all depend linearly on the tree depth, the efﬁciency of the scheme can be im- proved by decreasing the depth of the tree. A tree of depth ω logk  can be used  to sign messages of arbitrary length  in the following way: when signing a message, choose a random leaf; sign the message using the key associated with that leaf; and then authenticate the path from that leaf to the root exactly as in Construction 3.2.  It does not matter if different leaves end up being used to sign the same message. In particular, the signer need not store the leaves that are used to sign the different mes- sages as part of its state [although it will continue to store the keys associated with   82  3 Constructions Based on General Assumptions  each node in the tree, including the leaves].  If the same leaf ever gets used to sign two different messages, an adversary can forge a signature  using that same leaf ; however, this occurs with only negligible probability since the number of leaves is super-polynomial. Besides taking this complication into account, the security proof is otherwise unchanged.  3.2.3 A Stateless Solution  In Construction 3.2, as described, the signer’s state depends on the messages that have been signed. One could imagine, however, having the signer generate all nec- essary information  for all the nodes in the entire tree  in advance, at the time of key generation.  That is, at the time of key generation the signer could generate keys { pkw,skw } and signatures {σw} for all binary strings w of length at most k.  If key generation were done in this way, the signer would not have to update its state at all; these values would instead all be stored as part of a  large  private key, and we would obtain a stateless scheme. The problem with this approach, of course, is that generating all these values at the time of key generation requires exponential time. An alternative is to store some randomness that can be used to generate the values { pkw,skw } and {σw}, as needed, rather than storing the values themselves. That is, the signer could store a random string rw for each w, and whenever the values pkw,skw were needed the signer could compute  pkw,skw  := Gen 1k;rw .  Simi- larly, if the signing procedure were probabilistic, the signer could store r cid:48  w and then set σw := Signskw pkw0 cid:107 pkw1;r cid:48  w .  Generating and storing sufﬁciently many ran- dom strings at the time of key generation, however, would still require exponential time and space. A simple modiﬁcation of this alternative gives a polynomial-time solution. In- stead of storing random rw and r cid:48  w as suggested above, the signer can store two keys k,k cid:48  for a pseudorandom function F. Roughly, a keyed function F is pseudo- random if the function Fk ·   for random key k  is indistinguishable from a truly random function with the same domain and range.  The reader is referred to [72] for a formal deﬁnition of pseudorandom functions. This is the only place in the book where they are used.  When needed, the values pkw,skw can now be generated by the following two-step process: 1. Compute rw := Fk w .4 2. Compute  pkw,skw  := Gen 1n;rw   as before . In addition, the key k cid:48  is used to generate the value r cid:48  w that is used to compute the signature σw. This gives a stateless signature scheme in which key generation  as well as signing and verifying  can be carried out in polynomial time. Intuitively, this works because storing a random function is equivalent to storing all the rw and r cid:48  w values that are needed, and storing a pseudorandom function is “just as good”.  4 We assume F handles variable-length inputs, and has output length that is sufﬁciently long.   3.3 Signatures from One-Way Functions  83  We leave it as an exercise to prove that this modiﬁed scheme remains existentially unforgeable under an adaptive chosen-message attack.  3.3 Signatures from One-Way Functions  We now have all the pieces in place to construct a CMA-secure signature scheme from any one-way function.  3.3.1 Putting the Pieces Together  The results of the previous section can be summarized as follows:  Theorem 3.4. Assuming the existence of a signature scheme that is strongly un- forgeable under a one-time chosen-message attack and can sign messages twice as long as its own public key, there exists a signature scheme that is strongly unforge- able under an adaptive chosen-message attack.  Proof. A signature scheme as assumed in the theorem implies the existence of one- way functions  Theorem 2.1 ; these, in turn, are known to imply the existence of pseudorandom functions  see [64] . The discussion in the preceding section then gives the stated result.  Theorem 3.5. Assuming the existence of one-way functions, there exists a signature scheme that is strongly unforgeable under an adaptive chosen-message attack.  Proof. By the preceding theorem, it sufﬁces to show how to construct a signature scheme Π that is strongly unforgeable under a one-time chosen-message attack and can sign messages twice as long as its own public key. Recall that the existence of one-way functions implies the existence of universal one-way hash functions  The- orem 2.9 , and hence the existence of a signature scheme Π cid:48  that is strongly un- forgeable under a one-time chosen-message attack  Theorem 3.2 . Applying Con- struction 2.5 to Π cid:48  gives a signature scheme Π with the required properties.  3.3.2 Thoughts on the Construction  It is worth reﬂecting just how inefﬁcient and complicated the resulting construction of a CMA-secure signature scheme is  when based directly on one-way functions, assuming no other primitives . Given a one-time signature scheme Π that can sign messages twice as long as its own public key, the stateful tree-based construction of a CMA-secure signature scheme Π∗ described in Section 3.2.2 is conceptually   84  3 Constructions Based on General Assumptions  simple but not very efﬁcient, with the signing time, veriﬁcation time, and signature length all depending linearly on the tree depth.  The tree depth is O k  as described in Section 3.2.2, but can be improved to ω logk  as discussed at the end of that section.  Making Π∗ stateless requires a pseudorandom function: although block ciphers such as DES or AES  see [72]  provide efﬁcient practical instantiations of pseudorandom functions, building a pseudorandom function from a one-way func- tion is incredibly complex and inefﬁcient.  Moreover, the underlying  one-time  scheme Π relies in an essential way on the construction of universal one-way hash functions from one-way functions — itself a complicated and inefﬁcient process. Given such a hash function, building Π is not too complex  and, as noted following Theorem 3.5, can be further simpliﬁed  but is not very efﬁcient, either.  The alternate approach discussed at the end of Sec- tion 3.2.2 still requires a universal one-way hash function.   Some sort of tree-based approach seems essential to constructing signatures from one-way functions, although no proof of this is known.  One way to formalize the question would be to ask whether signature schemes built from one-way functions inherently have long signatures. In fact, a tree-based approach seems inherent even if we are willing to rely on stronger assumptions such as [clawfree] trapdoor per- mutations or collision-resistant hash functions.  More surprising, perhaps, is that all known constructions of  stateless  signature schemes from one-way functions rely on pseudorandom functions and universal one-way hash functions, even though there appears to be no inherent reason why this should be the case.  The above should only motivate the reader to either improve on the known con-  structions, or to show that further improvements are impossible!  3.4 Further Reading  We survey here the historical development of constructions of signature schemes based on progressively weaker assumptions, even though we have not covered all these early constructions in the text.  Lamport’s one-time signature scheme was published in 1979 [76], though it was already described in [40]. Other, more efﬁcient, constructions  that do not rely on speciﬁc number-theoretic assumptions but in some cases assume more than one-way functions  include those given in [79, 80, 45, 20, 15, 98, 85].  The ﬁrst construction of a CMA-secure signature scheme was given by Gold- wasser, Micali, and Rivest [61] based on the existence of clawfree trapdoor per- mutations. The Goldwasser-Micali-Rivest scheme was stateful, and Goldreich [55]  based on an idea credited to Levin  showed how to make it stateless using pseudo- random functions. Their scheme relies on a tree-based construction  similar, though not identical, to what is outlined in this chapter  whose genesis can be traced back to Merkle [80, 78, 79]. The idea for reducing the tree depth to ω logk  is also due to Goldreich [55].   3.4 Further Reading  85  Given the beneﬁt of hindsight, it is interesting to observe that alternate — and, in some cases, simpler — constructions of stateful CMA-secure signature schemes could have been obtained at around the same time as the journal publication of [61].  Note that the conference version of [61] appeared in 1984.  Goldwasser, Micali, and Yao [62] gave a KMA-secure scheme that could have been converted to a CMA- secure scheme using the techniques from Section 1.7.2. Their scheme is based on speciﬁc assumptions like RSA and factoring, but could have also been viewed as relying on clawfree trapdoor permutations. The tree-based approach described in Section 3.2.2 is based on ideas by Merkle [80] that go back to the late ’70s; coupled with Lamport’s scheme, this could have been used to construct signature schemes from collision-resistant hash functions via Construction 3.2.  Collision-resistant hash functions, in turn, can be constructed from clawfree permutations [37].  None of this is meant to take away anything from the incredible achievement of [61], which provides the ﬁrst rigorous proof of security for any signature scheme con- struction.  Following the work of [61], the race was on to ﬁnd the minimal assumptions under which signature schemes could be based. Bellare and Micali [5, 6] showed that trapdoor permutations sufﬁce. Naor and Yung [88] introduced the concept of universal one-way hash functions; showed that these sufﬁce for constructing sig- nature schemes; and gave constructions of universal one-way hash functions from one-way permutations, this establishing that this assumption implies the existence of signature schemes. Subsequently, de Santis and Yung [39] showed that one-to- one one-way functions imply the existence of universal one-way hash functions. The question was ﬁnally settled by Rompel [100]  see also [71] , who showed that one-way functions sufﬁce.  Apropos the discussion in Section 3.3.2, lower bounds on the  black-box  ef- ﬁciency of one-time signature schemes based on general assumptions have been shown [52, 3].   Chapter 4 Signature Schemes Based on the  Strong  RSA Assumption  4.1 Introduction  The signature schemes described in the previous chapter have the advantage of be- ing based on very weak cryptographic assumptions, but have the drawback of being incredibly inefﬁcient.  Even the Lamport scheme, which could conceivably be used, has very large public keys and signatures.  It is natural to wonder whether relying on stronger, more speciﬁc assumptions might yield more efﬁcient schemes. Un- fortunately, progress in this direction has been limited: only a handful of schemes are known that are more efﬁcient than the “generic” constructions of the previous chapter and, of these, even fewer are efﬁcient enough to compete with the signature schemes currently used in practice.1 In fact, and somewhat disappointingly, the only schemes we currently have that come close to the efﬁciency of signature schemes currently in use are based on relatively “new” cryptographic assumptions discussed in this and the following chapter.  Admittedly, this point is debatable and depends to some extent on what one takes as his measure of efﬁciency.   In this chapter we present signature schemes based on the RSA assumption or a recent variant  discussed later  called the “strong” RSA assumption. In the following chapter we will introduce schemes that rely on bilinear maps.  4.1.1 Technical Preliminaries  We begin with some technical lemmas that will prove useful in the analysis of the schemes discussed in this chapter. The RSA assumption  informally  is that given a modulus N  that is a product of two primes , a random element y ∈ Z∗ N, and an exponent e that is relatively prime to φ N , it is “hard” to compute the eth root of y  modulo N . Might it be easier to  1 We stress that here we are referring to schemes that can be proven secure without resorting to the random oracle model. Part III of this book discusses schemes of the latter type.  J. Katz, Digital Signatures, DOI 10.1007 978-0-387-27712-7_4,   Springer Science+Business Media, LLC 2010  87   4 Signature Schemes Based on the  Strong  RSA Assumption  88 compute the eth root of some power of y; i.e., to compute the eth root of ye cid:48  mod N for some e cid:48  of our choice? The following lemma shows that this is not the case as long as e and e cid:48  are relatively prime.2 Speciﬁcally, the lemma states that if e,e cid:48  are relatively prime then an eth root of ye cid:48  mod N can be used to compute an eth root of y itself.  Note that the lemma does not require e or e cid:48  to be relatively prime to φ N .  Lemma 4.1. Given N, elements x,y ∈ Z∗ N, and integers e,e cid:48  for which it holds that gcd e,e cid:48   = 1 and xe = ye cid:48  mod N, an eth root of y  modulo N  can be computed in polynomial time. Proof. Assume without loss of generality that e,e cid:48  are positive  if not, we can al- ways re-write the equation by taking inverses . Applying the extended Euclidean algorithm to e,e cid:48  we can efﬁciently compute integers A,B satisfying  Ae + Be cid:48  = gcd e,e cid:48   = 1.  We claim that yAxB mod N  which can be computed easily given what is known  is an eth root of y. Indeed, we have   cid:161  yAxB cid:162 e mod N = yAe  xe B mod N  = yAe ye cid:48  = yAe+Be cid:48    B mod N  = y1 = y mod N,  concluding the proof.  A nice consequence of the above is the observation, due to Shamir [102], that it does not become any easier to compute y1 e mod N even given {y1 ei mod N} for some set of primes {ei} not containing e. More formally: Lemma 4.2. Say the RSA problem is hard relative to GenRSA, and let {ei} cid:96  i=1 be a set of primes that does not contain the exponent e output by GenRSA and such that gcd φ N ,ei  = 1 for all N output by GenRSA and all i. Then the following is negligible for all PPT algorithms A:  Pr   N,e,d  ← GenRSA 1k ;y ← Z∗ N; x ← A 1k,N,e,y,{ei,y1 ei} cid:96  i=1   : xe = y mod N  .   4.1   Proof. Given a PPT algorithm A, construct the following algorithm A cid:48  which at- tempts to solve the  standard  RSA problem:   cid:183    cid:184   Algorithm A cid:48 : The algorithm is given  N,e,y  as input. Its goal is to compute y1 e mod N.   Set ˆe := ∏ cid:96   i=1 ei.  2 Note that it may be trivial to compute the eth root of ye cid:48  for an integer k then yk is the eth root of ye cid:48   .  if gcd e,e cid:48    cid:54 = 1. For example, if e cid:48  = k·e   4.1 Introduction  89    Set ˆei := ˆe ei for 1 ≤ i ≤  cid:96 .  Note ˆei is an integer for all i.    Set Y := y ˆe mod N and Yi := y ˆei mod N for 1 ≤ i ≤  cid:96 .   Run A 1k,N,e,Y,{ei,Yi} cid:96    If X e ?= Y = y ˆe mod N, then compute x = y1 e mod N using  i=1  and obtain output X.  Lemma 4.1.  The key to the above algorithm is that the ˆei are all integers, and so A cid:48  can efﬁciently compute the values  Yi = y ˆei = y ˆe ei = Y 1 ei mod N.  Thus, A cid:48  is a PPT algorithm. Furthermore, Lemma 4.1 does indeed apply since gcd e, ˆe  = 1  this follows easily since the {ei} are prime and e  cid:54 ∈ {ei} . We con- clude that A cid:48  successfully outputs the eth root of its given input value y whenever A successfully outputs the eth root of its input value Y . The theorem follows by noting that the distribution on the inputs given to A in the above algorithm is identical to the distribution on the inputs given to A in Equation  4.1 : since gcd φ N ,∏i ei  = 1, the value Y = y ˆe is uniformly distributed in Z∗ N when y is uniformly distributed in Z∗ N, and it is easy to see from what we have already said that the remainder of A’s inputs have the correct distribution. We conclude that A cid:48  computes the eth root of y with probability exactly that given by Equation  4.1 . If the RSA problem is hard relative to GenRSA, then, Equa- tion  4.1  must be negligible for any PPT algorithm A as claimed.  We do not directly use Lemma 4.2 in what follows, though we will often implic- itly rely on the techniques used in its proof. To get a feeling for why the above lemma might be useful in our context, note that it suggests the following very simple signa- ture scheme  which only supports a polynomial-size message space as described : the public key contains  N,y,{ei} cid:96  i=1   where the {ei} satisfy the conditions of the lemma above ; a signature on the message i  for 1 ≤ i ≤  cid:96   is given by y1 ei mod N. Lemma 4.2 implies that it is hard to compute the signature on a message j even when given the signatures on all other messages {i}i cid:54 = j.  This can be turned into a formal proof.  We will see in Section 4.3.5 that an extension of this idea yields a relatively efﬁcient scheme  which is, however, proved secure based on a stronger assumption than standard RSA . Lemma 4.2 requires a set of  distinct  primes {ei} each of which is relatively prime to φ N . In the applications that follow, it will be convenient to ﬁx this set of primes independently of N  and, in particular, before N is even known . An easy way to achieve this is to choose the primes such that ei > max{p,q}, where p,q are the factors of N. This is easy to ensure  without knowledge of the factorization of N  by choosing ei as a  k + 1 -bit prime  recall that p and q, the factors of N, are k-bit integers when GenRSA is run on security parameter 1k .   90 4.1.2 Outline of the Chapter  4 Signature Schemes Based on the  Strong  RSA Assumption  We present here a number of signature schemes based on the RSA and strong RSA assumptions. We begin by describing a signature scheme proposed by Dwork and Naor, as well as an improvement of this scheme due to Cramer and Damg˚ard. Both of these schemes rely on a tree-based approach similar to that used in the previous chapter, with the efﬁciency improvements being due to the fact that, by relying on the RSA assumption, trees of larger degree  and hence lower depth  can be used. We then show a recent scheme by Hohenberger and Waters that can also be viewed as using a tree-based approach, but has the advantage of yielding shorter signatures. All these schemes are proven secure based on a variant of the standard RSA assumption  see the next section for details .  The RSA assumption states that, given N, e, and y, it is infeasible to compute y1 e mod N. The strong RSA assumption  described formally in Section 4.3  is that, given N and y, it is infeasible to compute  e,x1 e  for any e ≥ 2, even if we allow the freedom to choose e. Cramer and Shoup have shown how the strong RSA assump- tion can be used to dramatically simplify and improve the efﬁciency of the Cramer- Damg˚ard scheme; we discuss the resulting Cramer-Shoup signature scheme, as well as further improvements of this scheme due to Fischlin, in Sections 4.3.3 and 4.3.4. A different approach, but also relying on the strong RSA assumption, is taken in the Gennaro-Halevi-Rabin scheme shown in Section 4.3.5.  4.2 Signature Schemes Based on the RSA Assumption  In this section we will show three schemes based on the RSA assumption. Each of these schemes, as described, actually requires a variant of the RSA assumption that we formalize now.  Throughout this section, let GenModulus be a probabilistic polynomial-time al- gorithm that, on input 1k, outputs a modulus N along with two  distinct  k-bit primes p,q with N = pq. Let GenPrime be a probabilistic polynomial-time algorithm that, on input 1k, outputs a prime e of length at least k. We require that GenPrime gener- ates primes “at random” in the sense that if we run GenPrime twice, the outputs of these two executions are equal with only negligible probability.  This immediately implies that even if we run GenPrime polynomially many times, the probability of getting a repeated output is negligible.  We highlight that GenPrime does not take N or the factors of N as input, but if e is a prime of length at least k  and N is a product of k-bit primes  then we are guaranteed that gcd e,φ N   = 1.  We use the following variant of the RSA assumption in Sections 4.2.1 and 4.2.2: Deﬁnition 4.1. The RSA problem is hard relative to GenModulus and GenPrime if for all polynomials p  with p k  ≥ k for all k  and all PPT algorithms A, the following is negligible:    cid:183    cid:184   4.2 Signature Schemes Based on the RSA Assumption  91  Pr   N, p,q  ← GenModulus 1k ;y ← Z∗ N; e ← GenPrime 1p k  ;x ← A N,e,y   : xe = y mod N  .  In other words, this deﬁnition requires that the RSA problem is hard relative to a “random” large public exponent e.  In Section 4.2.3 we use a slightly stronger version of the above:  Deﬁnition 4.2. The RSA problem is hard relative to GenModulus and GenPrime, even with public coins if for all PPT algorithms A, the following is negligible:  Pr   N, p,q  ← GenModulus 1k ;y ← Z∗ N;  ω← {0,1}k;e ← GenPrime 1k;ω ;x ← A N,e,y,ω   : xe = y mod N  .   cid:183    cid:184   In other words, this deﬁnition requires that the RSA problem is hard relative to a “random” large public exponent e, even if the random coins used to generate e are known.  4.2.1 The Dwork-Naor Scheme  Dwork and Naor [42] showed that by relying on speciﬁc properties of the RSA prob- lem it is possible to construct signature schemes that are more efﬁcient than what would be obtained by using the generic construction of the previous chapter. As in Construction 3.2, the signer in the Dwork-Naor scheme maintains a tree of vertices. Each vertex is here associated with a label that, for now, can be viewed as roughly analogous to the public key that is associated with each vertex in Construction 3.2. Continuing the analogy to Construction 3.2, here too the label of the root vertex is included as part of the public key; vertices authenticate their children; and messages are signed by associating them with leaves of the tree  although the exact way this is done is now slightly different . The main novelty of the Dwork-Naor scheme — and the key feature that makes it more efﬁcient than a naive instantiation of Con- struction 3.2 — is that in the Dwork-Naor scheme a vertex can authenticate each of its children independently instead of having to authenticate its children all at once. Speciﬁcally, in the Dwork-Naor scheme a veriﬁer can check that a particular node v  with some known label  is authenticated by its parent without having to know the labels of any of v’s siblings.  In contrast, the veriﬁer in Construction 3.2 needed to know the labels of all of v’s siblings in order to verify authenticity of v.  As a con- sequence, the Dwork-Naor scheme can more readily use a tree of larger degree, and hence smaller depth, resulting in a more efﬁcient construction.3 We now describe in more detail exactly how this is accomplished. Fix some integer  cid:96  ≥ 2 representing the degree of the tree that will be constructed as part of the scheme. The public key in the Dwork-Naor scheme includes a modulus  3 Of course, Construction 3.2 could also have used a tree of larger degree  given a signature scheme capable of signing sufﬁciently long messages , but the reader can check that this will reduce the efﬁciency in that case.   L· ∏  j :[L cid:48 ] j=1  1 ei  92 4 Signature Schemes Based on the  Strong  RSA Assumption N  a product of two k-bit primes  as well as a list Y = {y1, . . . ,y2k} of elements N and a set of distinct primes E = {e1, . . . ,e cid:96 } that are all relatively prime from Z∗ to φ N . In the tree that will be constructed vertices will be labeled with strings of length 2k; observe that elements of Z∗ N can be represented as strings of this length. The basic authentication step, which we now describe, enables a vertex with label L to authenticate its ith child  1 ≤ i ≤  cid:96   having label L cid:48 , and is deﬁned as follows:  auth L i→ L cid:48   def=  y j  mod N   4.2    in the above, [L cid:48 ] j refers to the jth bit of L cid:48  . This authentication information can be computed if the factorization of N is known. Note also that given a  presum- ably authenticated  parent vertex with label L, its candidate ith child with label L cid:48 , and authentication information auth, it is easy to verify the authenticity of L cid:48  with respect to a known public key by checking whether  authei ?= L· ∏ j :[L cid:48 ] j=1  y j mod N.   4.3   With the above basic authentication step in place, designing a full-ﬂedged signa- ture scheme is relatively straightforward given the results of the previous chapter. The signer will maintain a tree of degree  cid:96  and depth d, where the root of the tree is assigned a label that is included as part of the public key. Messages will be as- sociated with the leaves of this tree, meaning that the scheme can be used to sign at most4 B =  cid:96 d messages.  For a ﬁxed value of B, larger values of  cid:96  translate to a larger public key but shorter signatures.  To sign a message m ∈ {0,1}2k, the signer assigns the label m to the next unused leaf, and then authenticates the path from the root to this leaf. The veriﬁer validates the claimed sequence of authenticators in the obvious way. Note that the scheme, as described, is stateful since the signer must keep track of both which leaves have been used as well as the labels assigned to internal nodes in the tree.5  The scheme is formally described as Construction 4.1. Efﬁciency of the scheme can be improved by using a collision-resistant hash N to shorter strings. In this case, a basic authenti-  function H to map elements of Z∗ cation step would take the form  L· ∏  j :[H L cid:48  ] j=1  1 ei  y j  mod N .  auth L i→ L cid:48   def=  4 It is not difﬁcult to extend the scheme so that an unbounded number of messages can be signed; for simplicity, however, the scheme is described with a ﬁxed upper bound on the number of signa- tures to be issued. 5 Although it is possible to avoid maintaining state using essentially the same techniques described in Section 3.2.3, doing so would reduce the efﬁciency of the scheme.   4.2 Signature Schemes Based on the RSA Assumption  93  Construction 4.1: The Dwork-Naor scheme  Lv0 ← Z∗  N. Set Y := {y1, . . . ,y2k}.  Let GenModulus, GenPrime be as described in the text. Key generation: On input security parameter 1k, proceed as follows:   Run  N, p,q  ← GenModulus 1k .   For i ∈ {1, . . . ,  cid:96 }, compute ei ← GenPrime 1k . Set E := {e1, . . . ,e cid:96 }.   For i ∈ {1, . . . ,2k}, let yi be a uniformly distributed element in Z∗   The public key is  N,Lv0 ,Y,E  and the secret key is p,q. Signature generation: The signer implicitly holds a tree of depth d and out-degree  cid:96  whose root v0 has label Lv0. To generate a signature on a message m ∈ {0,1}2k, let vd be the left-most leaf in the tree that has not yet been used. Assign label Lvd := m to this leaf. Let  i1, . . . ,id  denote the sequence of edges on the path from the root to this leaf  where each i1, . . . ,id lies in the range {1, . . . ,  cid:96 } , and let  v1, . . . ,vd  be the nodes on this path  not including the root . Let  Lv1, . . . ,Lvd   denote the labels of these nodes  if any of these nodes have not yet been assigned a label, they are now assigned a label chosen uniformly at random from Z∗ N . The signature on m is then:  N. Also choose   i1, . . . ,id , Lv1 , . . . ,Lvd−1 , auth Lv0  i1→ Lv1 , . . . , auth Lvd−1  id→ Lvd  ,  where the auth L i→ L cid:48   are computed as in Equation  4.2 . Signature veriﬁcation: A signature   i1, . . . ,id , Lv1, . . . ,Lvd−1 , auth1, . . . , authd  on a message m is veriﬁed in the natural way, by setting Lvd := m, and then verifying auth1, . . . , authd as in Equation  4.3 .  It would then sufﬁce for the set Y to include, say, only 160 elements of Z∗ than 2048 elements of Z∗ N. Theorem 4.1. If the RSA problem is hard relative to GenModulus and GenPrime, the Dwork-Naor scheme is existentially unforgeable under an adaptive chosen- message attack.  N rather  Proof. Given a PPT adversary A attacking the scheme, we construct a PPT algorithm A cid:48  which attempts to solve the RSA problem. Before giving an informal overview of A cid:48 , we ﬁrst introduce some terminology. Say a label Lv associated with a particular node v in the tree is legitimate if Lv is the label assigned to v by the legitimate signer, and say the label is illegitimate otherwise.  We assume without loss of generality that A requests  cid:96 d signatures before it outputs its forgery, and so the signer does indeed assign a label to every node in the tree.  If A outputs a valid signature forgery   94  4 Signature Schemes Based on the  Strong  RSA Assumption   i1, . . . ,id , ˜Lv1, . . . , ˜Lvd−1 , auth1, . . . , authd  on some new message m then, letting ˜Lvd := m and ˜Lv0 := Lv0, there must be some minimum r ∈ {1, . . . ,d} for which label ˜Lvr−1 is legitimate  for node vr−1  but label ˜Lvr is illegitimate  for node vr . We will refer to vr−1 as the critical node and call ir  indicating the position of vr among the children of vr−1  the critical index. If we let Lvr denote the legitimate label of vr, then there must be a minimum position j ∈ {1, . . . ,2k} for which the jth bit of ˜Lvr and the jth bit of Lvr differ; call such j the critical position. We are now ready to give an overview of A cid:48 . Algorithm A cid:48  is given an instance  N,y,e  of the RSA problem, and will use A as a subroutine in an attempt to solve the given instance. At the beginning of its execution, A cid:48  guesses values i∗ ∈ {1, . . . ,  cid:96 } and j∗ ∈ {1, . . . ,2k} for the critical index and critical position, respectively; it then generates a public key and simulates the actions of a legitimate signer for A. If A outputs a forgery and the guesses i∗, j∗ made by A cid:48  are correct, then A cid:48  will be able to solve its given instance of the RSA problem; since this happens with inverse polynomial probability, we see that that the success probability of A is polynomially related to the success probability of A cid:48 . We remark that A cid:48  does not need to guess the critical node. We now describe A cid:48  in more detail. A cid:48  is given N,y, and a prime e, and is supposed to compute y1 e mod N. To do this, it ﬁrst generates a public key and node labels in the following way:   Choose random i∗ ∈ {1, . . . ,  cid:96 } and j∗ ∈ {1, . . . ,2k}.  As described above, i∗ rep- resents a guess as to the critical index of the forgery output by A, and j∗ represents a guess as to the critical position.    Set ei∗ := e. For i  cid:54 = i∗, compute ei ← GenPrime 1k ; set E := {e1, . . . ,e cid:96 }. Let ˆe def= ∏i ei.  We assume throughout the following that the {ei} are distinct, since this occurs with all but negligible probability.  Y := {y1, . . . ,y2k}.    Set y j∗ := y ˆe ei∗ mod N. For j  cid:54 = j∗, choose s j ← Z∗ j mod N. Let   For each non-leaf node v in the tree, A cid:48  now generates a label Lv. It does so in a way that ensures it can compute appropriate authentication values for all nodes  except possibly the leaves , as we will discuss. For each non-leaf node v, we will let bv denote the j∗th bit of Lv A cid:48  begins by choosing a random bit bv for every leaf node v. Starting from the nodes at level d − 1 and working backwards to the root  at level 0 , A cid:48  assigns label Lv to node v as follows: – Let v cid:48  be the i∗th child of v, with associated bit bv cid:48 . – Choose random rv ∈ Z∗  N and set y j := s ˆe  N and compute  Lv := r ˆe  v ybv cid:48   j∗ mod N.  The bit bv associated with node v is deﬁned to be the j∗th bit of Lv.   4.2 Signature Schemes Based on the RSA Assumption 95   The public key is  N,Lv0,Y,E , where Lv0 is the value assigned to the root v0 in  the above procedure. We claim that both the public key and the labels generated in the above process are distributed exactly the same as they would be in a real execution of the signature scheme. It is immediate that N and the {ei} have the correct distribution.  Here, we use the fact that the prime e given as input to A cid:48  is generated using GenPrime.  Furthermore, since the initial input y as well as the {s j} are all uniformly distributed N, and the {ei} are all relatively prime to φ N , it follows that the {y j} are in Z∗ uniformly distributed as required. One can also easily check that the label of every non-leaf node is a uniform element of Z∗ N. We may also observe that, due to the way the {yi} are computed, A cid:48  can compute j mod N for all   j,i   cid:54 =   j∗,i∗ . In particular, then, A cid:48  is able to compute the y1 ei necessary authentication value for any internal node v cid:48   with label Lv cid:48   having parent v  with label Lv : Indeed, if v cid:48  is the i∗th child of v then  auth Lv  i∗→ Lv cid:48   def=  y j  mod N  j :[Lv cid:48  ] j=1  Lv · ∏ r ˆe  v · ∏ j cid:54 = j∗  j :[Lv cid:48  ] j=1  1 ei∗   1 ei∗  =  y j  mod N,  using the fact that [Lv cid:48 ] j∗ def= bv cid:48 . Since, by construction, A cid:48  knows the ei∗th root of y j when j  cid:54 = j∗, the desired authentication value can be computed. Similarly, if v cid:48  is the ith child of v for some i  cid:54 = i∗, then   r ˆe  1 ei  auth Lv  i→ Lv cid:48   =  v yb  j∗ · ∏  y j  j :[Lv cid:48  ] j=1  mod N  for some bit b; since A cid:48  knows the eith root of every y j  including y j∗ , the necessary authentication value can again be computed. Furthermore, we show how A cid:48  can compute the desired answer y1 e if its guesses for i∗ and j∗ are correct. Say A outputs a forged signature which contains an ille- gitimate label ˜Lv cid:48  associated with a node v cid:48 , where v cid:48  is the i∗th child of its parent v having legitimate label ˜Lv = Lv. Let Lv cid:48  denote the legitimate label of node v cid:48 , and assume further that ˜Lv cid:48  and Lv cid:48  differ on their j∗th bit. As part of its forgery, A must have output a value auth = auth Lv  i∗→ ˜Lv cid:48   satisfying: y j mod N  authei∗ = Lv · ∏  j :[˜Lv cid:48  ] j=1   96  4 Signature Schemes Based on the  Strong  RSA Assumption  =  r ˆe  = r ˆe  v ybv cid:48  v · y1−2bv cid:48   j∗  · ∏ j :[˜Lv cid:48  ] j=1 · ∏ j :[˜Lv cid:48  ] j=1 j cid:54 = j∗  j∗  y j mod N  y j mod N,  relying here on the fact that [˜Lv cid:48 ] j∗ = 1−bv cid:48   since [Lv cid:48 ] j∗ = bv cid:48 , and Lv cid:48  and ˜Lv cid:48  differ on their j∗th bit . Let S def= { j : [˜Lv cid:48 ] j = 1∧ j  cid:54 = j∗} and b def= bv cid:48 . Re-arranging, using the fact that e = ei∗, and substituting the chosen values for the {y j}, we obtain:    e  auth  r ˆe e v ∏ j∈S s ˆe e j  = y 1−2b ·  ˆe e  mod N.  Since  1− 2b  ∈ {−1,1} and ˆe e is relatively prime to e, Lemma 4.1 shows that A cid:48  can efﬁciently compute the eth root of y, as desired. One piece is missing in our informal description of A cid:48 . We showed earlier that A cid:48  can compute the necessary authentication values for any internal node; however, this does not extend to the case of computing the necessary authentication values for the leaves. The problem is that the labels for the leaves are outside the control of A cid:48 , since A chooses “labels” for the leaves by selecting messages to be signed. We remark that it would be easy to show that the Dwork-Naor scheme is existen- tially unforgeable under a known message attack  and then apply Construction 1.2 to obtain security under a chosen-message attack ; as we will see, however, the Dwork-Naor scheme can be proven secure as-is under a chosen-message attack. To be precise about where the difﬁculty lies, note that for any leaf v that is not an i∗th child, A cid:48  can compute the desired authentication value regardless of the message m chosen by A to be assigned to this leaf. On the other hand, when a leaf v is an i∗th child then A cid:48  can compute the desired authentication value only when bv is equal to the j∗th bit of the message m chosen by A to be assigned to this leaf. Since the view of A is independent of bv, it will be possible for A cid:48  to generate a valid signature with probability 1 2. Unfortunately, this is not enough to provide a “good” simulation since there are polynomially many leaves of the tree that are i∗th children  and A cid:48  would have to answer correctly for all such leaves . Instead, we will have A cid:48  rewind A  using a new guess for bv each time  in order to enable a good simulation. Say a leaf v is “hard” if it is an i∗th child of its parent, and call it “easy” otherwise. For messages associated with “easy” leaves, A cid:48  will provide a signature as discussed earlier. For a message m associated with a “hard” leaf v cid:48  whose parent is v, do: 1. If m j∗ = bv cid:48 , provide a signature using the approach described earlier. 2. Otherwise, rewind A to the point where node v is ﬁrst used. Choose a new, ran- dom bit bv cid:48  for the leaf and generate a new label Lv for the parent node v as follows:   4.2 Signature Schemes Based on the RSA Assumption  97  Repeat the following until the j∗th bit of Lv is equal to bv: choose random rv ∈ Z∗ compute  N and  Lv := r ˆe  v ybv cid:48   j∗ mod N.  3. Resume execution of A from the point where v is ﬁrst used, and return to Step 1  when signing a message associated with the leaf v cid:48 .  Note that the value of bv is not changed, so no other labels are affected by the above and A cid:48  can continue to provide valid signatures until possibly reaching leaf v cid:48  again. Assuming that A cid:48  can complete the simulation described above, the view of A at the end of the simulation is identically distributed to the view of A in an execution with a real signer. Moreover, this simulation is independent of i∗ and j∗; thus, the guesses of i∗, j∗ are correct with probability 1 2 cid:96 k. A consequence is that if A out- puts a forgery with some probability ε, then A cid:48  outputs the desired RSA inverse with probability ε cid:48  = ε  cid:96 k. We thus conclude that ε is negligible. It remains only to argue that A cid:48  can complete its simulation in  expected  polyno- mial time. View the simulation provided by A cid:48  as occurring in a sequence of phases, where a phase is identiﬁed with a node in level d − 1 that is being used to issue sig- natures.  Thus, a given phase associated with a node v at level d − 1 encompasses  cid:96  signatures associated with each of the  cid:96  children of v.  In the phase corresponding to node v  at level d − 1 , A cid:48  can issue all signatures until  possibly  the point when it reaches the i∗th child of v; at that point, A cid:48  can compute a valid signature with prob- ability 1 2 and must otherwise rewind A to the beginning of that phase. It is thus clear that A cid:48  can complete the simulation of any given phase in expected polynomial time. Furthermore, once A cid:48  successfully completes the simulation of some phase it proceeds to the next phase  and never rewinds to a point prior to the current phase . Since there are a polynomial number of phases, it follows that A cid:48  can complete its entire simulation in expected polynomial time.6 This completes the proof.  4.2.2 The Cramer-Damg˚ard Scheme  A drawback of the Dwork-Naor scheme is that the public key is relatively large, as it contains both a set E of  cid:96  prime numbers as well as a set Y of 2k elements of Z∗ N. Cramer and Damg˚ard [34] introduced a modiﬁcation of the Dwork-Naor scheme which improves the length of the public key by avoiding the need for the set Y .  Note that  cid:96  is likely to be an order of magnitude smaller than k, and so this does indeed yield a signiﬁcant improvement in practice.  In addition, the Cramer- Damg˚ard scheme has some conceptual advantages as compared to the Dwork-Naor 6 We can convert A cid:48  to a strict polynomial-time algorithm using standard techniques. Let kc be an upper bound on the expected running time of A cid:48 , and say A cid:48  succeeds with probability at least 1 kc cid:48  for inﬁnitely many values of k. Using Markov’s inequality, A cid:48  runs more than 2kc cid:48  kc steps with ; truncating A cid:48 ’s execution at 2kc cid:48 +c steps gives a strict polynomial-time probability less than 1 2kc cid:48  algorithm with success probability at least 1 kc cid:48  − 1 2kc cid:48  for inﬁnitely many values of k.  = 1 2kc cid:48    98  4 Signature Schemes Based on the  Strong  RSA Assumption  scheme:  1  it avoids the need for rewinding in the proof of security, thus simplifying the proof; also,  2  the Cramer-Damg˚ard scheme serves as a sort of “template” for the Cramer-Shoup signature scheme that we will see later.  The Cramer-Damg˚ard scheme has the same underlying structure as the Dwork- Naor scheme in that it also relies on a “short” tree of “high” degree  cid:96  in which a node v cid:48  can be authenticated by its parent v independently of the other children of v. The scheme also relies on a set E := {e1, . . . ,e cid:96 } of  cid:96  distinct primes to perform this authentication.  Each such prime will now be of length 2k + 1, but this technical detail can be ignored for now.  The primary difference between the schemes — and what leads to the efﬁciency improvement — is the use of a different authentication technique which now requires only a single element h ∈ Z∗ N to be included in the public key  rather than a set Y of 2k such elements . This basic authentication step, which enables a vertex with label L to authenticate its ith child  1 ≤ i ≤  cid:96   having label L cid:48 , is deﬁned as follows:   cid:179   L· hL cid:48  cid:180 1 ei mod N,  auth L i→ L cid:48   def=  where L cid:48  is a 2k-bit string viewed as an integer in the range {0, . . . ,22k − 1}  in fact, all internal labels will be elements of Z∗ N . As usual, this authentication information can be computed if the factorization of N is known. Furthermore, given a  presum- ably authenticated  parent vertex with label L, the candidate label L cid:48  of its ith child, and authentication information auth, anyone can verify the authenticity of L cid:48  by checking whether   4.4    4.5   authei ?= L· hL cid:48   mod N.  Plugging the basic authentication step of Equation  4.4  into the Dwork-Naor construction yields a signature scheme which can be shown7 to be existentially un- forgeable under a known message attack; applying Construction 1.2  using an arbi- trary one-time signature scheme secure under a known-message attack  would then give a scheme that is existentially unforgeable under an adaptive chosen-message attack. Better efﬁciency can be obtained, however, by relying on the paradigm of Construction 1.2 but using a speciﬁc one-time signature scheme at the bottom level, in particular, by using at the bottom level the same basic authentication step as above  with the same values of h,N  but with a different prime e cid:96 +1  cid:54 ∈ {e1, . . . ,e cid:96 }. As in the Dwork-Naor scheme, then, the signer implicitly works with a tree of depth d having out-degree  cid:96  and whose root v0 is labeled with a value Lv0 included in the public key. Here, however, a leaf of the tree is not directly labeled with a message to be signed, but is instead assigned a randomly generated label that is then used to authenticate the message itself. One can picture this as a tree in which there is a des- ignated “message node” hanging off each “leaf”.  For consistency with the previous  7 We remark that the rewinding technique used in the proof of Theorem 4.1 would not apply in this case since one would have the guess the entire message whose signature is requested by the adversary, rather than just a single bit of this message.   4.2 Signature Schemes Based on the RSA Assumption  99  notation, when a leaf with label L is used to authenticate a message m, the resulting authentication information will be denoted by auth L  cid:96 +1→ m .   4.2.2.1 A One-Time Signature Scheme  Before giving a complete description and proof of security for the full Cramer- Damg˚ard scheme, it will be instructive to analyze the basic authentication step as a one-time signature scheme.  See Construction 4.2.  We do not directly rely on this result in what follows, but the techniques used here will be helpful in understanding the proof of the full Cramer-Damg˚ard scheme.  Construction 4.2: An RSA-based one-time signature scheme  Let GenModulus, GenPrime be as described in the text. Key generation: On security parameter 1k, proceed as follows:   Compute  N, p,q  ← GenModulus 1k  and e ← GenPrime 12k+1 .   Choose random Lv0,h ∈ Z∗ N.   The public key is  N,Lv0 ,h,e  and the secret key is d. Signature generation: To sign message m ∈ {0,1}2k, viewed as an integer in the range {0, . . . ,22k − 1}, the signer computes   cid:161  Lv0 · hm cid:162 1 e  .  auth :=  The signature is auth. Signature veriﬁcation: To verify signature auth on message m, simply verify whether authe ?= Lv0 · hm mod N.  Theorem 4.2. If the RSA problem is hard relative to GenModulus and GenPrime, then Construction 4.2 is strongly unforgeable under a one-time, known-message attack.  Proof. Since for a given public key there is only one valid signature on any given message, it sufﬁces to prove  regular  unforgeability. Given a PPT adversary A which forges a valid signature on a new message with non-negligible probability, we con- struct a PPT algorithm A cid:48  that solves the RSA problem with the same probability. A cid:48 , given an RSA modulus N, an element y ∈ Z∗ N, and a  2k + 1 -bit prime e, uses A as a subroutine in the following way: First, run A 1k  to obtain a message m to be signed. Set h := y, choose random s ∈ Z∗ N, and compute Lv0 := seh−m mod N. Give to A the public key  N,Lv0,h,e  along with the signature s. One can verify that the   100  4 Signature Schemes Based on the  Strong  RSA Assumption  public key given to A is distributed identically to a real public key  in particular, Lv0 is uniformly distributed in Z∗ N , and s is a valid signature on m with respect to the given public key. mod N  i.e., A forges a valid signature s cid:48  on a new message m cid:48  , then A cid:48  can compute y1 e mod N. To see this, assume without loss of generality that m cid:48  > m and observe that  We claim that if A outputs  m cid:48 ,s cid:48   such that m cid:48   cid:54 = m and  s cid:48  e = Lv0hm cid:48    s cid:48  eh−m cid:48   = Lv0 = seh−m mod N  and so  s cid:48  s e = hm cid:48 −m = ym cid:48 −m mod N. Since m,m cid:48  ∈ {0, . . . ,22k − 1}, their differ- ence m cid:48  − m is less then e  here, we use the fact that e is a  2k + 1 -bit integer . Since e is prime, it follows that gcd e,m cid:48  − m  = 1 and so Lemma 4.1 applies. But this means A cid:48  can efﬁciently compute the eth root of y modulo N.  4.2.2.2 The Cramer-Damg˚ard Scheme  The Cramer-Damg˚ard scheme is given as Construction 4.3. As in the case of the Dwork-Naor scheme, the scheme as described is stateful  but see footnote 5 .  Theorem 4.3. If the RSA problem is hard relative to GenModulus and GenPrime, then the Cramer-Damg˚ard scheme is existentially unforgeable under an adaptive chosen-message attack. Proof. We ﬁrst establish some notation. The nodes at the ﬁrst d−1 levels of the tree will be referred to as internal nodes, while the nodes at depth d will be called leaves. The union of these will be called the tree nodes. The children of the leaves will be referred to as message nodes. As in the proof of Theorem 4.1, a label Lv associated with particular node v is called legitimate if Lv is the label assigned to this node by the signer; the label is illegitimate otherwise.  As before, we assume without loss of generality that the adversary requests  cid:96 d signatures before it outputs its forgery, and so the signer does indeed assign a label to every tree node.   Let A be a PPT adversary attacking the Cramer-Damg˚ard signature scheme and  having success probability ε k . If A outputs a valid forgery   i1, . . . ,id , ˜Lv1, . . . , ˜Lvd  , auth1, . . . , authd+1   4.6  on some message m then, letting ˜Lvd+1 := m and ˜Lv0 := Lv0, there must be some minimum r ∈ {1, . . . ,d + 1} for which label ˜Lvr−1 is legitimate  for node vr−1  but ˜Lvr is illegitimate  for node vr . We will refer to such vr−1 as the critical node. Let ε1 k  denote the probability that A outputs a signature forgery whose critical node is an internal node, and let ε2 k  be the probability that A outputs a signature forgery whose critical node is a leaf. We will give PPT algorithms A cid:48  2 that run A as a subroutine and solve the RSA problem with probability polynomially related to ε1,ε2, respectively. Because the RSA problem is hard for GenRSA, both ε1 and ε2 must therefore be negligible. Since ε k  = ε1 k  +ε2 k , this yields the theorem.  1,A cid:48    4.2 Signature Schemes Based on the RSA Assumption  101  Construction 4.3: The Cramer-Damg˚ard scheme  Let GenModulus, GenPrime be as described in the text. Key generation: On security parameter 1k, proceed as follows:   Run  N, p,q  ← GenModulus 1k .   For i = 1 to  cid:96  + 1, compute ei ← GenPrime 12k+1 . Set E := {e1, . . . ,e cid:96 +1}.   Choose random Lv0,h ∈ Z∗ N.   The public key is  N,Lv0 ,h,E  and the secret key is p,q. Signature generation: The signer implicitly maintains a tree of depth d and out- degree  cid:96  whose root v0 is labeled with Lv0. The  cid:96 d “leaves” of this tree each have a single child at depth d + 1  and thus, technically speaking, they are not leaves although we will continue to refer to them as such . Each leaf will be used to sign a single message. To generate a signature on a message m ∈ {0,1}2k, let vd be the left-most leaf in the tree which has not yet been used, and let vd+1 be its child. Assign a random label Lvd ∈ Z∗ N to vd, and set Lvd+1 := m. Let  i1, . . . ,id  denote the sequence of edges on the path from the root to the leaf  where each i1, . . . ,id lies in the range {1, . . . ,  cid:96 } , and let  v1, . . . ,vd  be the nodes on this path  not including the root . Let  Lv1 , . . . ,Lvd   denote the labels of these nodes; if any of these nodes have not yet been assigned a label, they are now assigned a label chosen uniformly at random from Z∗  N. The signature is then:   i1, . . . ,id , Lv1, . . . ,Lvd  ,  auth Lv0  i1→ Lv1 , . . . , auth Lvd−1  id→ Lvd  , auth Lvd where the auth L i→ L cid:48   are computed as in Equation  4.4 . Signature veriﬁcation: A signature   cid:96 +1→ Lvd+1   ,   i1, . . . ,id , Lv1 , . . . ,Lvd  , auth1, . . . , authd, authd+1  on a message m is veriﬁed in the natural way, by using the root value Lv0 contained in the public key, setting Lvd+1 := m, and then verifying the values auth1, . . . , authd+1 as in Equation  4.5 .  Algorithm A cid:48   1 is constructed using essentially the same idea used to construct algorithm A cid:48  in the proof of the Dwork-Naor scheme; actually, the proof is a bit simpler here since all legitimate labels of the tree nodes are chosen uniformly at random by the signer  and, in particular, are outside the control of A ; thus, no rewinding of A is necessary. Algorithm A cid:48  2 is devised in a manner similar to the A cid:48  used in the proof of the one-time signature scheme of the previous section  cf. Theorem 4.2  using the observation that, in the present scheme, the signer does not   102  4 Signature Schemes Based on the  Strong  RSA Assumption  “commit” to the label Lv of any leaf v until after the adversary decides what message should be authenticated by this leaf.  This is in contrast to the Dwork-Naor scheme where the label of a node v at level d−1 is chosen and revealed by the signer before all the messages that will be authenticated by the children of v are determined. Note the similarity with Construction 1.2.   We proceed with a description and analysis of the two algorithms. In each case we use the adversary A as a subroutine of an algorithm that will attempt to compute y1 e mod N for given input values N,y, and e. Algorithm A cid:48  1. Say A outputs a forgery as in Equation  4.6 . If the critical node vr−1 is an internal node then we call ir the critical index. As in the proof of Theorem 4.1, 1 guess in advance the value i∗ ∈ {1, . . . ,  cid:96 } of the critical index. A cid:48  we will have A cid:48  1 will then generate a public key  N,Lv0,h,E  along with labels for all the tree nodes such that  1  these values are distributed identically to the public key and tree-node labels in a real execution of the signature scheme;  2  A cid:48  1 will be able to answer all signing queries of A  without having to rewind A ; yet  3  if A outputs a forgery whose critical node is an internal node, and A cid:48  1’s guess of the critical index is correct, then A cid:48  1 will be able to compute the desired answer y1 e mod N. Since the guess of the critical index is correct with probability 1  cid:96 , we conclude that A cid:48  1 succeeds in solving its given RSA instance with probability ε1 k   cid:96 .  1 is given N,y, and a  2k + 1 -bit prime e, and its goal is to compute y1 e mod N. It prepares a public key and labels for the tree nodes as follows:   Choose random i∗ ← {1, . . . ,  cid:96 }. Set ei∗ := e, and compute ei ← GenPrime 12k+1  for i  cid:54 = i∗. Deﬁne E = {e1, . . . ,e cid:96 ,e cid:96 +1}, and let ˆe := ∏ cid:96 +1 i=1 ei.  We assume in what follows that all the primes {ei} are distinct, since this occurs with all but negligible probability.    Set h := y ˆe ei∗ mod N.   Generate labels for all tree nodes in the following bottom-up fashion:  1 in more detail. A cid:48   We now describe A cid:48   – For a node v at level d  i.e., v is a leaf node , choose the label Lv as follows: – For a node v at level r < d, choose the label Lv as follows: let w be the i∗th  pick random sv ← Z∗ child of v having label Lw. Choose sv ← Z∗  N and let Lv := se cid:96 +1  v · h−Lw mod N.  N and set Lv := s ˆe  v mod N.  In this way, A cid:48     The public key is  N,Lv0 ,h,E .  1 eventually obtains a label Lv0 for the root of the tree.  We ﬁrst claim that both the public key and the labels generated in the above process are distributed identically to their distribution in a “real” execution of the signature scheme. This is immediate for the case of N and the {ei}. Since y is a uni- form element of Z∗ N and ˆe ei∗ is relatively prime to φ N , we see that h is uniformly distributed as well. A similar argument applies for the labels of all the tree nodes since the {sv} are chosen independently and uniformly at random from Z∗ N. such a way that A cid:48  adversary  without rewinding ; this follows from the observations that:  More interestingly, the public key and the labels of the tree nodes are set up in 1 can compute a valid signature on any message given to it by the   4.2 Signature Schemes Based on the RSA Assumption   Say i  cid:54 = i∗, and let w be the ith child of some internal node v. Then A cid:48   1 can compute i→ Lw , where Lv,Lw are the labels computed in the above process. To  auth Lv see this, let w∗ be the i∗th child of v and note that  103  auth Lv   cid:161   cid:161    cid:162 1 ei mod N v · hLw−Lw∗ cid:162 1 ei mod N  cid:180 Lw−Lw∗  cid:179   y ˆe eiei∗  i→ Lw  def= Lv · hLw s ˆe = = s ˆe ei  ·  v  mod N.  Since both ˆe ei and ˆe eiei∗ are integers, A cid:48  it does not know the factorization of N.  1 can compute the above even though    Let w∗ be the i∗th child of some internal node v. We show that A cid:48   1 can compute i∗→ Lw∗ , where Lv,Lw∗ are the labels computed in the above process. To  auth Lv see this, note that:  auth Lv  Lv · hLw∗ cid:162 1 ei∗ mod N  cid:161   cid:162 1 ei∗ mod N  cid:161   mod N.  i∗→ Lw∗  def= s ˆe = v = s ˆe ei∗  v  Again, since ˆe ei∗ is an integer, A cid:48  the factorization of N.  1 can compute the above without knowledge of   For any leaf v and any message m chosen by the adversary to be authenticated by  this leaf, A cid:48   1 can compute auth Lv   cid:96 +1→ m . To see this, note that  auth Lv   cid:96 +1→ m  =  Lv · hm 1 e cid:96 +1 mod N   cid:179    cid:179   se cid:96 +1 v   cid:179   = = sv ·  · y ˆe ei∗ y ˆe e cid:96 +1ei∗   cid:180 m cid:180 1 e cid:96 +1 mod N  cid:180 m  mod N.  1 can easily compute the above.  Once again, since ˆe e cid:96 +1ei∗ is an integer, A cid:48  Finally, we show that if A outputs a valid forgery where the critical node is an internal node, and the guess i∗ for the critical index is correct, then A cid:48  1 can compute the desired solution y1 e = y1 ei∗ mod N. Indeed, assume A outputs a valid forgery as in Equation  4.6  with critical node vr−1  for r ≤ d  and such that ir = i∗. Using the fact that the forgery is valid we have  recall that Lvr is the legitimate label of node vr :  auth   cid:180  r = Lvr−1 · h˜Lvr mod N ei∗   cid:179  vr−1 · h−Lvr s ˆe vr−1 · h˜Lvr−Lvr mod N  = s ˆe  =  · h˜Lvr mod N   104  4 Signature Schemes Based on the  Strong  RSA Assumption  = s ˆe  vr−1 · y  ˆe ei∗  · ˜Lvr−Lvr   mod N,  and so A cid:48   1 can compute the value γ := authr s ˆe ei∗  v  mod N such that  γei∗ = y  ˆe ei∗  · ˜Lvr−Lvr   mod N.  1 can compute y1 ei∗ using Lemma 4.1.  2. We now construct an algorithm A cid:48   Now, since ei∗ is relatively prime to both ˆe ei∗ and ˜Lvr − Lvr  using, in the latter case, the fact that ˜Lvr − Lvr < ei∗ since ei∗ is a  2k + 1 -bit prime while ˜Lvr and Lvr are 2k-bit values , A cid:48  It is easy to see that A’s view is independent of the initial guess i∗ made by A cid:48  1. Thus, the probability that this guess is correct, even conditioned on the fact that A outputs a forgery whose critical node is an internal node, is exactly 1  cid:96 . This means that A cid:48  1 solves its given RSA instance with probability ε1 k   cid:96 . Since this must be negligible by assumption, we conclude that ε1 is negligible. Algorithm A cid:48  2 that succeeds in solving its given RSA instance whenever A outputs a valid forgery whose critical node is a leaf. Now, A cid:48  2 will construct a public key along with a set of node labels for all internal nodes  but not the leaves  in such a way that A cid:48  2 can authenticate any leaf node regardless of the label this leaf nodes is assigned; to authenticate a message chosen by A, we will then have A cid:48  2 choose the label of the corresponding leaf in such a way that it can issue a legitimate signature. It is thus essential that in the Cramer-Damg˚ard scheme the label of the leaf used to authenticate some message is not determined until after the message to be signed is chosen by A. This is in contrast to the Dwork-Naor scheme  where the adversary gets to see the label of a node before having to decide on some message that should be authenticated by that node , and is essential to the current proof.  We now give a more complete description of A cid:48   2 is given N, y, e and is to compute y1 e mod N. It prepares a public key and labels for the internal nodes of the tree as follows:   Set e cid:96 +1 := e and compute ei ← GenPrime 12k+1  for i  cid:54 = i∗. Deﬁne E := {e1, . . . ,e cid:96 ,e cid:96 +1}, and let ˆe := ∏ cid:96  i=1 ei  note that ˆe is deﬁned differently than be- fore . We assume in what follows that all the primes {ei} are distinct, as this occurs with all but negligible probability.    Set h := y ˆe mod N.   Generate a label Lv for every internal node v as follows: pick random sv ← Z∗   The public key is  N,Lv0 ,h,E , where v0 is the root of the tree.  2. Recall that A cid:48   Using similar arguments as in the previous analysis of A cid:48   1, one can verify that the public key and all node labels generated in the above procedure are distributed exactly as in a real execution of the signature scheme. We thus turn to showing that A cid:48  2 can indeed authenticate any leaf regardless of the label that leaf is assigned. Indeed, let v be an internal node and let w be the ith child of v for some i ∈ {1, . . . ,  cid:96 }  note that w may be a leaf . Then regardless of the label Lw assigned to w, the simulator can compute auth Lv  i→ Lw  since:  and let Lv := s ˆe  v mod N.  N   4.2 Signature Schemes Based on the RSA Assumption Lv · hLw i→ Lw  def= s ˆe = = s ˆe ei  auth Lv  v   cid:162 1 ei mod N v · y ˆe cid:162 1 ei mod N  · y ˆe ei mod N,   cid:161   cid:161   105  and ˆe ei is an integer.  v  2 chooses sv ← Z∗  Given the above, it is straightforward to show that A cid:48   2 can respond correctly to any signing query of A. This will be done as in the proof of Theorem 4.2: when A requests  by making a signing query  that a message m be authenticated by leaf v, algorithm A cid:48   N and sets the label of v to · h−m mod N. Lv := se cid:96 +1 Note that Lv is distributed uniformly at random in Z∗ N, as in a real execution of the signature scheme. Now, by what we have said earlier, A cid:48  2 can provide correct authentication values for each of the nodes on the path from the root to v; it only remains to show that A cid:48  2 can authenticate m using the newly created label Lv. This  cid:96 +1→ m  := sv  it is easily veriﬁed that this is the correct is done by setting auth Lv authentication value . Say A outputs a forgery in which the critical node is a leaf v. To complete the description of A cid:48  2 to compute the desired solution y1 e mod N. Let m be the message that A cid:48  2 authenticated using v, let m cid:48  be the mes- sage included by A in its forgery, and let Lv denote the legitimate label of v  con- structed as described above . As in the proof of Theorem 4.2, A cid:48  2 can recover from A’s forgery the value  2, we show how this allows A cid:48    cid:96 +1→ m cid:48    s def= auth Lv =  Lv · hm cid:48  cid:180 1 e cid:96 +1 mod N   cid:179   cid:179  = = sv · y m cid:48 −m · ˆe e cid:96 +1 mod N,  · y m cid:48 −m · ˆe   cid:180 1 e cid:96 +1 mod N  se cid:96 +1 v  and so s sv is the e cid:96 +1th root of y m cid:48 −m · ˆe  recall that A cid:48  2 knows sv . Because m cid:48 ,m ∈ {0, . . . ,22k − 1}, we have m − m cid:48  < e cid:96 +1; since e cid:96 +1 is prime, it follows that gcd e cid:96 +1,m − m cid:48   = 1. We know also that e cid:96 +1 and ˆe are relatively prime. Using Lemma 4.1, it follows that A cid:48   2 can compute the desired e cid:96 +1th root of y.  To conclude, we have shown that A cid:48   2 computes the desired solution with proba- bility exactly ε2 k , which must be negligible by assumption. It must therefore be the case that ε2 is negligible, as desired.  As we have shown that both ε1 and ε2 are negligible, this completes the proof of  the theorem.   106 4.2.3 The Hohenberger-Waters Scheme  4 Signature Schemes Based on the  Strong  RSA Assumption  Hohenberger and Waters [67] recently introduced a signature scheme based on the RSA assumption that has several advantages relative to the two schemes described previously. The primary advantage is that signatures in the Hohenberger-Waters scheme are short, even though a tree of large depth is still  implicitly  used.  Even though the Hohenberger-Waters scheme is only proved security under a known- message attack, one can apply Construction 1.2 to get a scheme secure against chosen-message attacks whose signatures are still shorter than in the Dwork-Naor or Cramer-Damg˚ard schemes.  Because the signature length is independent of the tree depth, and the tree is maintained only implicitly, the Hohenberger-Waters scheme can afford to use a binary tree of depth k  and exponential size  and can therefore more easily be made stateless.  Speciﬁcally, a leaf can be assigned to each possible message m ∈ {0,1}k to be signed, as in Construction 3.2.   In the Dwork-Naor and Cramer-Damg˚ard schemes, the signer uses a tree of de- gree  cid:96  and a prime ei is associated with each of the  cid:96  outgoing “directions”. Thus, for example, the same prime e1 is assigned to the left-most outgoing edge of every node in the tree. In the Hohenberger-Waters scheme a different prime is associated with every edge in the tree. Since  as noted earlier  the scheme uses a tree of expo- nential size, it is impossible to explicitly list all these primes as part of the public key; instead, a  compact, keyed  function f mapping edges to primes is included in the public key.  The same idea could be used to reduce the size of the public key in the Dwork-Naor and Cramer-Damg˚ard schemes.  As we will see in the proof of security, this function can be “programmed” by a simulator so as to map a speciﬁc edge to a given prime e  that is given to the simulator as part of the RSA challenge . We now describe the keyed function f that we use.8 Let F be a pseudorandom function that, for simplicity, we assume maps arbitrary-length inputs to k-bit out- puts. Given a string m ∈ {0,1}≤k, deﬁne fK,c m  = GenPrime 1k;FK m ⊕ c . The Hohenberger-Waters scheme is given as Construction 4.4.  Theorem 4.4. If the RSA problem is hard relative to GenModulus and GenPrime, even for public coins, then the Hohenberger-Waters scheme is strongly unforgeable under a known-message attack.  Proof. Observe that for a given public key, each message m has a unique valid signature.  This relies on the fact that GenPrime always outputs an e relatively prime to φ N .  We prove existential unforgeability, and strong unforgeability follows.  Fixing K,c, deﬁne E m  = { fK,c mi }k  i=1; this is just the set of primes that are used to sign m. We also deﬁne e m  = ∏e∈E m  e  this matches the deﬁnition of e m  in the description of the scheme . If we imagine that the signer implicitly maintains a binary tree of depth k, we can associate any message m ∈ {0,1}k, in the natural way, with a path P m  in this tree from the root to a leaf. We can similarly associate any preﬁx mi with a path from the root to a node at depth i; it is then natural to view the prime e = fK,c mi  as being associated with the last edge on this path. 8 Hohenberger-Waters suggest a different function, but our choice of f yields a simpler proof.   4.2 Signature Schemes Based on the RSA Assumption  107  Construction 4.4: The Hohenberger-Waters scheme  def= m1···mi denote the i-bit preﬁx of m.  Let GenModulus, GenPrime, and f be as described in the text. Given a binary string m, let mi Key generation: On security parameter 1k, proceed as follows:   Compute  N, p,q  ← GenModulus 1k .   Choose random h ∈ Z∗   The public key is  N,h,K,c  and the secret key is p,q. Signature generation: To sign message m ∈ {0,1}k, do:   For i = 1 to k, let ei := fK,c mi . Deﬁne e m  = ∏k   Output the signature σ = h1 e m  mod N.  N, and K,c ∈ {0,1}k.  i=1 ei.  Signature veriﬁcation: To verify signature σ on message m, do:   For i = 1 to k, let ei := fK,c mi . Deﬁne e m  = ∏k   Output 1 iff σe m  ?= h mod N.  i=1 ei.  i=1Pi.  Given a PPT algorithm A attacking the scheme in a known-message attack, we construct a PPT algorithm A cid:48  attempting to solve the RSA problem: A cid:48  is given as input N,e,y,ω with GenPrime 1k;ω  = e. It proceeds as follows:   Run A 1k  to get messages m1, . . . ,m cid:96 .   Imagining a depth-k binary tree as discussed above, let Pi = P mi  be the path associated with mi and set P := ∪ cid:96    Choose a node v∗ at random9 from among those nodes adjacent to P  i.e., nodes connected to P but not in P , and set m∗ equal to the message preﬁx associated with the path from the root to node v∗. Let j∗ denote the depth of v∗  or, equiva- lently, the length of m∗ .   Choose random K ∈ {0,1}k, and set c := FK m∗ ⊕ ω.  Note that this ensures fK,c m∗  = e.    Let ˆE = ∪ cid:96  i=1E mi , and set ˆe := ∏ei∈ ˆE ei. Security of the pseudorandom function can be shown to imply that, with all but negligible probability, e  cid:54 ∈ ˆE  and so gcd e, ˆe  = 1 ; we assume this to be the case from now on.   Set h := y ˆe mod N and give to A the public key  N,h,K,c  and the signatures {σi = y ˆe e mi  mod N} cid:96    If A outputs a forgery  m,σ , let vm denote the ﬁrst node on the path P m  that is not in P.  The path from the root to vm corresponds to the shortest preﬁx of m  i=1.  9 Even though the  implicit  tree has exponential size, it is not hard to see that this step can be performed efﬁciently.   108  4 Signature Schemes Based on the  Strong  RSA Assumption that is not a preﬁx of any of the {mi}. Since m  cid:54 ∈ {mi}, some such preﬁx must exist.  If vm = v∗, then A cid:48  computes the desired solution as described next.   Assuming vm = v∗ and recalling that v∗ is at depth j∗, we thus have m j∗ = m∗  and so  e m  =   cid:96 ∏  i=1  fK,c mi  = fK,c m∗ · ∏ i cid:54 = j∗  fK,c mi   fK,c mi .  = e· ∏ i cid:54 = j∗  cid:180 e  σ∏i cid:54 = j∗ fK,c mi   = y ˆe mod N.   cid:179   Because σ is a valid signature on m, we have σe m  = h mod N and so  Using that fact that gcd e, ˆe  = 1, it follows from Lemma 4.1 that A cid:48  can efﬁ- ciently compute the desired solution y1 e mod N. It is not hard to verify that the view of A when run by A cid:48  is identically distributed to the view of A in a real execution of the signature scheme. Moreover, since there are only polynomially many nodes adjacent to P, the guess of m∗ by A cid:48  is correct with inverse polynomial probability. We conclude that A cid:48  correctly solves its given RSA instance with probability that is polynomially related to the success probability of A in its attack. This completes the proof of the theorem.  4.3 Schemes Based on the Strong RSA Assumption  The constructions we have seen so far in this chapter are more efﬁcient than the generic schemes of the previous chapter, but are still not considered efﬁcient enough to be used in practice  and they are certainly not competitive with the RSA-based solutions that will be discussed in Chapter 7 . For this reason, researchers have explored a variant of the RSA assumption  termed the strong RSA assumption , and have used it to construct more efﬁcient signature schemes. We will describe two such approaches here. The ﬁrst approach, initiated by Cramer and Shoup with subsequent efﬁciency improvements by Fischlin, may be viewed as a modiﬁcation of the Cramer-Damg˚ard scheme in which the tree has depth 1 and the edges leaving the root are associated with primes e1, . . . chosen “on-the-ﬂy”  and, in particular, no longer included as part of the public key . The second approach, due to Gennaro, Halevi, and Rabin, uses the strong RSA assumption to construct a secure scheme “directly”, in a manner inspired by Lemma 4.2. The Gennaro-Halevi-Rabin scheme has the advantage of being quite straightforward to analyze  at least for the variant presented here ; the Cramer-Shoup Fischlin schemes, however, appear to be more practical.   4.3 Schemes Based on the Strong RSA Assumption 4.3.1 The Strong RSA Assumption  109  The RSA assumption states, informally, that given  y,e,N  it is “hard” to compute y1 e mod N. The strong RSA assumption asserts that this problem remains “hard” even given the freedom to choose e: that is, given  N,y  it is “hard” to output a valid solution  e,y1 e mod N  for any chosen e ≥ 2  we sometimes refer to this as ﬁnding a non-trivial root of y . More formally, let GenModulus be as in the previous section. Then: Deﬁnition 4.3. The strong RSA problem is hard relative to GenModulus if the following is negligible for all PPT algorithms A:  N, p,q  ← GenModulus 1k ;y ← Z∗ N;   cid:94    cid:184    cid:183   xe = y mod N  .  : e ≥ 2  Pr   x,e  ← A N,y   We stress that e need not be prime, nor do we require gcd e,φ N   = 1.  Although the strong RSA assumption can be formulated with respect to arbitrary moduli N, for technical reasons we will assume throughout this section that the factors p,q of moduli N output by GenModulus are such that  p− 1  2 and  q− 1  2 are also prime  p,q of this type are known as strong primes . This ensures that φ N  =  p− 1  q− 1  = 4p cid:48 q cid:48  for p cid:48 ,q cid:48  prime. Note also that any odd e of length less than k− 1 is relatively prime to φ N  in this case.  We continue to let GenPrime denote an algorithm that, on input 1 cid:96 , outputs an  cid:96 -bit prime. We assume primes output by GenPrime are “random” in the sense dis- cussed at the beginning of Section 4.2.  4.3.2 Security Against Known-Message Attacks  As an instructive prelude to the full Cramer-Shoup scheme, we ﬁrst present a scheme that is secure against known-message attacks. The scheme is essentially a variant of the one-time signature scheme shown in Section 4.2.2.1, where here a fresh prime is used each time a signature is generated.  There are some other, more minor dif- ferences as well .  Theorem 4.5. If the strong RSA problem is hard relative to GenModulus, then Con- struction 4.5 is strongly unforgeable under a known-message attack.  Proof. Let A be a PPT adversary attacking the scheme and having success probabil- ity ε k . A attacks the scheme in a known-message attack by requesting signatures on t = t k  messages {mi}t i=1 chosen by A before it is given the public key. Let the public key be  N,Lv0,h  and denote the signature on message mi by  ei, authi . We will assume throughout the rest of the proof that the {ei} are distinct  since this fails to hold with only negligible probability ; therefore, if the adversary outputs a valid forgery  e, auth  on some message m, there are two cases:  1  e = e j for some   110  4 Signature Schemes Based on the  Strong  RSA Assumption  Construction 4.5: A scheme secure against known-message attacks Let GenModulus, GenPrime be as described in the text, and set  cid:96  =  cid:98 k 2 cid:99 . Key generation: On security parameter 1k, proceed as follows:   Run  N, p,q  ← GenModulus 1k , where p and q are strong primes.   Choose random Lv0,h ∈ QRN.   The public key is  N,Lv0 ,h  and the secret key is p,q. Signature generation: To sign message m ∈ {0,1} cid:96 , viewed as an integer in the range {0, . . . ,2 cid:96  − 1}, the signer sets e ← GenPrime 1 cid:96 +1  and computes  Lv0 · hm cid:162 1 e mod N  cid:161   auth :=  using the factorization of N. The signature is  e, auth . Signature veriﬁcation: To verify signature  e, auth  on message m, check that e is an odd,   cid:96  + 1 -bit number and then verify whether  authe ?= Lv0 · hm mod N.   unique  j, or  2  e  cid:54 ∈ {ei}. Let ε1 k  denote the probability of the ﬁrst event, and ε2 k  be the probability of the second. We claim that both ε1,ε2 are negligible. Since ε = ε1 +ε2  except for a negligible term relating to the probability that ei = e j for some i  cid:54 = j , this concludes the proof of the theorem. The proof that ε1 is negligible follows almost immediately from the analysis of algorithm A cid:48  1 in the proof of Theorem 4.3  and relies on the “standard” RSA assumption as used there ; we therefore focus on bounding ε2.  Interestingly, here we can bound ε2 even for an adaptive chosen-message attack.  In doing so, we will rely on the strong RSA assumption. Thus, we will present a PPT algorithm A cid:48   using A as a subroutine  that is given  N,y  as input and outputs  e,y1 e   with e ≥ 2  with probability polynomially related to ε2. Under the strong RSA assumption, it follows that ε2 is negligible as claimed. Algorithm A cid:48 , on input  N,y , proceeds as follows:   For i = 1 to t, compute ei ← GenPrime 1 cid:96 +1 , and set ˆe := ∏t   Set h := y2 ˆe mod N. Choose random a ← {1, . . . ,N2} and set Lv0 := ha mod N.   Give to A the public key  N,Lv0,h . When A requests a signature on the ith mes-  Let t be a polynomial upper-bound on the number of signatures requested by A.  i=1 ei.  sage mi, compute  authi := y2a ˆe eiy2mi ˆe ei mod N   4.3 Schemes Based on the Strong RSA Assumption  111   cid:161   =  Lv0hmi   cid:162 1 ei mod N,    for some e cid:48  ≥ 2 as discussed below.    If A outputs valid signature forgery  e, auth  on a message m, with e  cid:54 ∈ {e1, . . .et},  and give to A the signature  ei, authi . then A cid:48  will attempt to compute  e cid:48 ,y1 e cid:48  We will show in a moment how A cid:48  attempts to compute  e cid:48 ,y1 e cid:48     in the case when A outputs a valid signature forgery with e  cid:54 ∈ {e1, . . . ,et}. Let us ﬁrst argue, however, that the probability that A outputs such a forgery is negligibly close to ε2. This fol- lows from the fact that A’s view in the above interaction with A cid:48  is statistically close to A’s view in an interaction with a real signer: N is clearly distributed identically in both cases, and since y is uniformly distributed in Z∗ N and gcd  ˆe,φ N   = 1, we have that h is uniformly distributed in QRN. Furthermore, the signatures given to A are all valid and correctly distributed signatures with respect to the given public key. It only remains to argue that the distribution of Lv0 in the above experiment is sta- tistically close to the distribution that results from the true key-generation process. The real key-generation algorithm chooses Lv0 uniformly from QRN. Turning to the above experiment, we ﬁrst note that QRN is a cyclic subgroup of Z∗ N with order p cid:48 q cid:48  for some primes p cid:48 ,q cid:48   this is due to the fact that N is a product of strong primes . Since h is a random quadratic residue, h is a generator of QRN with all but negligible probability; assume this to be the case in what follows. Let c def= a mod p cid:48 q cid:48 , viewed as an integer between 0 and p cid:48 q cid:48  − 1  inclusive . For  any γ∈ {0, . . . , p cid:48 q cid:48  − 1}, the probability  over choice of a  that c = γ is at least  p cid:48 q cid:48  cid:99   cid:98  N2 N2 ≥  p cid:48 q cid:48  − 1 N2 N2 ≥ 1 1 p cid:48 q cid:48  + 1  p cid:48 q cid:48  − 1 and  using similar reasoning  at most N2 . It follows that the distribution of c is statistically close to uniform over {0, . . . , p cid:48 q cid:48  − 1}. Since Lv0 depends only on c, we conclude that the distribution of Lv0 is statistically close to uniform over QRN. We now show that when A outputs a forgery  e, auth  on a message m with e  cid:54 ∈ {e1, . . . ,et}, then A cid:48  can compute a correct solution with noticeable probability. Since authe = Lv0hm mod N, we have  N2  authe = ha+m = y2· a+m · ˆe mod N.  Let K := 2·  a + m · ˆe. If gcd e,K  = 1, then A cid:48  can apply Lemma 4.1 and output  e,y1 e  as a solution. In fact, as long as e does not divide K it is possible to compute a non-trivial root: say d = gcd e,K  cid:54 = e, and notice that — since d < e < min{p cid:48 ,q cid:48 } and e  and hence d  is odd — we have gcd d,2p cid:48 q cid:48   = 1. Thus,  authe d = yK d mod N.  Now, since gcd e d,K d  = 1 and e d > 2, algorithm A cid:48  can still apply Lemma 4.1 to compute a  non-trivial   e d th root of y.   112  4 Signature Schemes Based on the  Strong  RSA Assumption  It thus only remains to show that, with noticeable probability, e does not di- vide K. Let r be any prime dividing10 e, and note that gcd r,2 ˆe  = 1. We show that, with noticeable probability, r does not divide  a + m ; equivalently, we show that, with noticeable probability,  a + m   cid:54 = 0 mod r. Write a as a = bp cid:48 q cid:48  + c  so c = a mod p cid:48 q cid:48  as before . Although Lv0 reveals c  in an information-theoretic sense , the conditional distribution on b given Lv0 is statistically close to uniform on {0, . . . , cid:98 N2 p cid:48 q cid:48  cid:99 }. Since r  cid:98 N2 p cid:48 q cid:48  cid:99  is negligible, it follows that b mod r is statistically close to uniform on {0, . . . ,r− 1}  even conditioned on the adversary’s view . Using the fact that p cid:48 q cid:48   cid:54 = 0 mod r, we see that  Prb[a + m = 0 mod r] = Prb[ bp cid:48 q cid:48  +  c + m   = 0 mod r]  = Prb[bp cid:48 q cid:48  = − c + m  mod r] = Prb[b = − c + m  p cid:48 q cid:48  mod r],  and this ﬁnal probability is negligibly close to 1 r ≤ 1 3. We conclude that, with noticeable probability, r does not divide  a+m ; hence, with noticeable probability, e does not divide K. This completes the proof.  4.3.3 The Cramer-Shoup Scheme  We now have all the building blocks in place to present the Cramer-Shoup signature scheme [36].  See Construction 4.6. Our description is intended to highlight the cor- respondence with the Cramer-Damg˚ard scheme.  The scheme assumes a collision- resistant hash function H mapping inputs to strings of length  cid:96  =  cid:98 k 2 cid:99 . We also continue to assume that the signature scheme is deﬁned for messages of length  cid:96 . Theorem 4.6. If the strong RSA problem is hard relative to GenModulus, then the Cramer-Shoup signature scheme is existentially unforgeable under an adaptive chosen-message attack.  Proof. All the necessary components of the proof are contained in the proofs of The- orems 4.3 and 4.5, and so we will be relatively brief here. Let A be a PPT adversary attacking the Cramer-Shoup signature scheme that outputs a forgery with probabil- ity ε k . Say A obtains t = t k  signatures {ei,Li, auth1,i, auth2,i }t i=1 on messages {mi}t i=1, and outputs a forgery  e,L, auth1, auth2  on a message m. Let ε1 k  denote the probability that A outputs a forgery such that e = ei for some i, and let ε2 k  be the probability that A’s forgery satisﬁes e  cid:54 ∈ {ei}. Since ε k  = ε1 k  + ε2 k , showing that both ε1 and ε2 are negligible will complete the proof.  We can bound ε1 by exactly following the proof of Theorem 4.3. In fact, we can bound ε1 by direct reduction to the Cramer-Damg˚ard scheme using depth d = 1.11 10 Recall that signature veriﬁcation does not check whether e is prime. 11 Hardness of the strong RSA problem relative to GenModulus implies hardness of the RSA problem relative to GenModulus and an arbitrary GenPrime. This, in turn, implies security of the Cramer-Damg˚ard scheme by theorem 4.3.   4.3 Schemes Based on the Strong RSA Assumption  113  Construction 4.6: The Cramer-Shoup scheme Let GenModulus, GenPrime be as described in the text, and set  cid:96  =  cid:98 k 2 cid:99 . Key generation: On security parameter 1k, proceed as follows:   Run  N, p,q  ← GenModulus 1k , where p and q are strong primes.   Choose random Lv0,h ∈ QRN and compute e cid:48  ← GenPrime 1 cid:96 +1 .   The public key is  N,Lv0 ,h,e cid:48   and the secret key is p,q. Signature generation: To sign message m ∈ {0,1} cid:96 , viewed as an integer in the range {0, . . . ,2 cid:96  − 1}, choose random quadratic residue L ∈ QRN and set e ← GenPrime 1 cid:96 +1 . Then compute   cid:179    cid:180 1 e  auth1 :=  Lv0 · hH L   mod N  auth2 :=  L· hm 1 e cid:48   mod N.  authe 1  ?= Lv0 · hH L  mod N  authe cid:48   2  ?= L· hm mod N.  and  and  The signature is  e,L, auth1, auth2 . Signature veriﬁcation: To verify signature  e,L, auth1, auth2  on message m, ﬁrst verify that e is an odd,   cid:96 +1 -bit integer different from e cid:48   note that it is not required to verify primality of e . Then check that  In detail, we construct an adversary A cid:48  for the Cramer-Damg˚ard scheme as follows: Given public key  N,Lv0 ,h,E = {e1, . . . ,et,et+1}  for an instance of the Cramer- Damg˚ard scheme, A cid:48  runs A on public key  N,Lv0,h,et+1 . The t signing queries of A are answered in the natural way, and a forgery by A in which e ∈ {e1, . . . ,et} immediately yields a forgery for A cid:48  as well. We therefore turn our attention to bound- ing ε2. The bound on ε2 is derived in a manner essentially the same as that used in the proof of Theorem 4.5. In particular, we can construct an algorithm A cid:48   using A as a subroutine  that solves an instance  N,y  of the strong RSA problem with probabil- ity polynomially related to ε2 k . The public key is constructed by A cid:48  exactly as in the proof of Theorem 4.5, with the only difference being the additional selection of a prime e cid:48  ← GenPrime 1 cid:96 +1  and its inclusion in the public key. As described in the proof of that theorem, A cid:48  will be able to compute auth1,i   cid:180 1 ei for  Lv0 · hH Li    cid:179   def=   114  4 Signature Schemes Based on the  Strong  RSA Assumption   cid:179  Lv0 · hH Li   i · h−mi mod N and auth2,i := si.   cid:180 1 ei as in the proof of Theorem 4.5.  arbitrary Li. To respond to the ith signature request of A on some message mi, we thus have A cid:48  proceed as follows:   Choose random si ← Z∗ N.   Set Li := se cid:48    Compute auth1,i   Output the signature  ei,Li, auth1,i, auth2,i . Arguing as in the proof of Theorem 4.5, we have that A will output a forgery such that e  cid:54 ∈ {ei} with probability negligibly close to ε2 k . Furthermore, as in that proof, when this occurs A cid:48  can compute a non-trivial root of y with noticeable probability. It follows that ε2 is negligible. This completes the proof.  def=  4.3.4 The Fischlin Scheme  An improvement to the Cramer-Shoup scheme was subsequently proposed by Fis- chlin [48] and is presented as Construction 4.7. This variant offers the advantages of faster signing and veriﬁcation, as well as shorter signatures. It is fair to say that this scheme is currently the most efﬁcient known scheme which can be proven secure based on standard assumptions.  Theorem 4.7. If the strong RSA problem is hard relative to GenModulus, then Con- struction 4.7 Fischlin is existentially unforgeable under an adaptive chosen-message attack.  i=1 on adaptively chosen-messages {mi}t  Proof. The proof relies on many of the same ideas as the proof of Theorem 4.6, and also has some similarities with Construction 1.1. As usual, let A be a PPT adversary attacking the scheme that outputs a forgery with probability ε k . Say A obtains t = t k  signatures { ei,αi, authi }t i=1 and outputs forgery  e,α, auth  on a message m. Let ε1 k  denote the probability that A’s forgery satisﬁes e = ei for some  unique12  i, and let ε2 k  be the probability that e  cid:54 ∈ {ei}. As in the previous proofs, we are done once we show that ε1 and ε2 are negligible. If A’s forgery  e,α, auth  satisﬁes e = ei then either α  cid:54 = αi or α⊕ m  cid:54 = αi ⊕ 1  k   denote the probability that the ﬁrst 1  k . We will prove that ε1 1  mi  or possibly both . Let ε1  resp., second  case occurs. Note that ε1 k  ≤ ε1 is negligible; the proof that ε2 We show an algorithm A cid:48   1 is negligible is completely analogous. 1 that solves an instance  N,y,e  of the  regular  RSA problem with probability polynomially related to ε1 1 begins by making a ran- dom guess j ← {1, . . . ,t}  recall, t is the number of signatures requested by A . Next, A cid:48  12 We assume the {ei} are distinct, since a collision occurs with negligible probability.  1 prepares a public key as follows:  1  k   resp., ε2  1  k . A cid:48   1  k  +ε2   4.3 Schemes Based on the Strong RSA Assumption  115  Construction 4.7: The Fischlin scheme Let GenModulus, GenPrime be as described in the text, and set  cid:96  =  cid:98 k 2 cid:99 . Key generation: On security parameter 1k, proceed as follows:   Run  N, p,q  ← GenModulus 1k , where p and q are strong primes.   Choose random L,h1,h2 ∈ QRN.   The public key is  N,L,h1,h2  and the secret key is p,q. Signature generation: To sign message m ∈ {0,1} cid:96 , compute e ← GenPrime 1 cid:96 +1  and choose a random  cid:96 -bit string α. Then compute   cid:161   auth :=  L· hα  1 · hα⊕m  2   cid:162 1 e mod N   using the known factorization of N , viewing both m and α⊕ m as integers in the range {0, . . . ,2 cid:96  − 1}. The signature is  e,α, auth . Signature veriﬁcation: To verify signature  e,α, auth  on message m, ﬁrst check that e is an odd,   cid:96  + 1 -bit integer  again, we stress that verifying the primality of e is not necessary . Then check whether  authe ?= L· hα  1 · hα⊕m  2  mod N.  −αj 1 w ˆe mod N.  ˆe := ∏i ei. Choose αj ← {0,1} cid:96  and set L := h    Set e j := e and compute e j ← GenPrime 1 cid:96 +1  for j ∈ {1, . . . ,t}\{i}. Then set   Choose random v,w ← QRN and set h1 := y2 ˆe e j mod N and h2 := v ˆe mod N.   The public key is  N,L,h1,h2 . The resulting public key is distributed identically to the public keys output by the true key generation algorithm.  Here, we rely on the fact that v,w are generators of QRN except with negligible probability, something that is true because N is a prod- uct of strong primes.  Furthermore, it is fairly immediate that for i  cid:54 = j it is possible for A cid:48  1 to generate a correctly distributed signature  using ei  on any message mi chosen by A: in particular, A cid:48   1 need only choose a random αi and then compute  authi := y2 αi−αj  ˆe eie j · w ˆe ei · v α⊕m  ˆe ei mod N   cid:161  = h αi−αj  ei =  1 L· hαi  · w ˆe ei · h α⊕m  ei   cid:162 1 ei mod N.  2  1 · hα⊕m  2  mod N  Finally, A cid:48  here, A cid:48   1 can also compute a signature using e j on any message m j chosen by A;  1 uses the αj it had chosen in advance and sets   116  4 Signature Schemes Based on the  Strong  RSA Assumption   cid:179   cid:179   auth j := w ˆe e j · v αj⊕m  ˆe e j mod N 1 · hαj⊕m −αj · hαj w ˆe · h 1 1 · hαj⊕m L· hαj   cid:180 1 e j mod N.  =  =  2  2   cid:180 1 e j mod N  Since αj was chosen uniformly, and is independent of the public key, this signature too has the correct distribution.  Continuing the description of A cid:48   1: it runs A using the generated public key and answers the signing queries of A as outlined above. Assume A outputs a valid forgery  e,α, auth  on a message m with e = e j and α cid:54 = αj. Since A cid:48  1 perfectly simulates a real execution of the scheme and the guess j of A cid:48  1 is correct with probability 1 t, 1  k  t. Moreover, when this occurs we have authe j = this occurs with probability ε1 L· hα  mod N and so  1 · hα⊕m  2  −αj 1  h  · w ˆe = L = authe j · h−α 1  · h− α⊕m   2  mod N  or, re-writing,  Due to the way h1,h2 were computed, this implies:  hα−αj  1  y2· α−αj · ˆe e j = authe j · cid:161   2  · w− ˆe mod N.  = authe j · h− α⊕m   cid:179   v ˆe cid:162 − α⊕m  · w− ˆe mod N  auth·  v ˆe e j − α⊕m  · w− ˆe e j  =   cid:180 e j mod N.  1 can compute γ def= auth· v ˆe e j − α⊕m ·w− ˆe e j mod N. So, A cid:48   Note that A cid:48  1 can com- pute y1 e j by application of Lemma 4.1  the {ei}i cid:54 = j are all relatively prime to e j, and α−αj < e j so that difference is relatively prime to e j as well . We conclude that A cid:48  1 correctly solves its given RSA instance with probability polynomially related to ε1 1 , and so this must be negligible.  As we have previously stated, a similar argument applies to ε2 1 . Hence, this concludes the proof that ε1 is negligible.  We next turn to bounding ε2. Here we construct an algorithm A cid:48   2 that solves an instance  N,y  of the strong RSA problem with probability polynomially related to ε2 k . Since the analysis here largely follows that of the proofs for Theorems 4.5 and 4.6, we merely provide a sketch. A cid:48    Compute ei ← GenPrime 1 cid:96 +1  for i = 1, . . . ,t. Then set ˆe := ∏i ei   Set h1 := y2 ˆe mod N. Choose a,a cid:48  ← {1, . . . ,N2}, and set h2 := ha   The public key is  N,L,h1,h2 . As argued in the proof of Theorem 4.5, the distribution on the public key  N,L,h1,h2  generated in this way is statistically close to the distribution on public keys output by the real key generation procedure. Furthermore, since A cid:48  roots of L,h1, and h2 for all i, it is not hard to see that A cid:48  2 can provide any signatures requested  2 constructs a public key as follows:  2 knows the eth i  1 mod N and  1 mod N.  L := ha cid:48    4.3 Schemes Based on the Strong RSA Assumption  117  by A  and these signatures will have the correct distribution . Finally, if A outputs a valid forgery  e,α, auth  on some message m, and it is the case that e  cid:54 ∈ {ei}, then  authe = L· hα  1 · hα⊕m  2  mod N  = y2 ˆe· a cid:48 +α+a· α⊕m   mod N  from which A cid:48  the proof of Theorem 4.5 . This concludes the proof.  2 can compute a non-trivial root of y with noticeable probability  as in  4.3.5 The Gennaro-Halevi-Rabin Scheme  The scheme presented here as Construction 4.8, due to Gennari, Halevi, and Ra- bin [53], is markedly different from the Cramer-Shoup-Fischlin scheme, and can be said to more directly follow the ideas of Lemma 4.2. As presented here, the Gennaro-Halevi-Rabin scheme has the advantage of being very easy to analyze al- though it is less efﬁcient than the previous two schemes we have seen. The original paper discusses a more efﬁcient variant of the scheme that is more difﬁcult to ana- lyze, and relies on a somewhat non-standard assumption.  For the purposes of the presentation, we assume there exists an efﬁcient, de- terministic function f mapping messages to odd primes of length at least k.  This assumption on f can be relaxed [53] at the expense of a more complicated analy- sis. Again, our intention here is not to present the most optimized instantiation of the scheme, but only to convey the main ideas.  Furthermore, f is required to be collision resistant. We refer the reader to the bibliographic notes at the end of this chapter for references to various constructions of such an f .  Construction 4.8: The Gennaro-Halevi-Rabin scheme  Let GenModulus and f be as described in the text. Key generation: On security parameter 1k, proceed as follows:   Run  N, p,q  ← GenModulus 1k  with p,q strong primes.   Choose random z ← Z∗ N.   The public key is  N,z  and the secret key is p,q.  Signature generation: The signature on message m is z1  f  m  mod N, computed using the factorization of N. Signature veriﬁcation: To verify signature σ on message m, simply output 1 iff σf  m  ?= z mod N.   118  4 Signature Schemes Based on the  Strong  RSA Assumption  Note the strong parallel with what is claimed in Lemma 4.2. A key difference is that here the set of roots {z1  f  mi  mod N} that are available to an adversary may be chosen adaptively since the primes { f  mi } depend on message {mi} that are potentially under the control of an adversary. Indeed, it is not known whether the scheme as presented in Construction 4.8 can be proven secure against adaptive chosen-message attacks based on the strong RSA assumption.  Although we re- mark that security against adaptive chosen-message attacks can be proved based on a somewhat non-standard assumption [53].  Nevertheless, we can prove the scheme secure against known message attacks. Theorem 4.8. If the strong RSA problem is hard relative to GenModulus, the Gennaro-Halevi-Rabin scheme is strongly unforgeable under a known-message at- tack. Proof. Every message has a unique valid signature, so existential unforgeability and strong unforgeability and it sufﬁces to prove the former. Given a PPT adversary A succeeding in a known-message attack with probability ε k , we construct an algorithm A cid:48  that solves a given instance  N,y  of the strong RSA problem with the same probability. It follows by assumption that ε k  must be negligible. The attack begins when A 1k  outputs a set of t = t k  messages {mi}t i=1. Next, A cid:48  prepares a public key and signatures as follows: it computes ˆe := ∏i f  mi  and sets z := y ˆe mod N. The public key is  N,z . Furthermore, the signature on each message mi is computed as  σi := y ˆe  f  mi  = z1  f  mi  mod N   note that A cid:48  can compute this value since ˆe  f  mi  is an integer . It is easy to see that the public key and all signatures are distributed exactly as in an execution of the real signature scheme.  Now, if A outputs a valid forgery  m,σ  with m  cid:54 ∈ {mi} then we have  σf  m  = z = y ˆe mod N.  Since f  m  is prime and f is collision resistant, we have gcd  f  m , ˆe  = 1  except with negligible probability  and A cid:48  can compute a non-trivial f  m th root of y using Lemma 4.1. This concludes the proof.  4.4 Further Reading  It is interesting to observe that all known schemes based on the RSA assump- tion with even moderate efﬁciency require the RSA problem  i.e., computing y1 e mod N  to be hard for several primes e  e.g., a random large prime as in the constructions described here, or several ﬁxed small primes . It remains open to con- struct an efﬁcient scheme based on the assumption, say, that the RSA problem with ﬁxed exponent e = 3 is hard.   4.4 Further Reading  119  Extending the ideas used in the Dwork-Naor [42] and Cramer-Damg˚ard [34] signature schemes, Catalano and Gennaro [26] show a tree-based signature scheme based on a variant of the factoring assumption.  The strong RSA assumption was introduced in [50, 4]. Although seemingly much stronger than the standard RSA assumption, the best known attacks on the RSA and strong RSA problems currently have the same complexity.  Construction 4.8 is based on the original Gennaro-Halevi-Rabin signature scheme introduced in [53], and was also implicitly considered by Naccache, et al. [86]. In the original paper presenting the scheme [53], existential unforgeability is shown directly  i.e., without resorting to Theorem 1.1  by introducing slight modiﬁca- tions to the scheme and imposing additional assumptions on the function f  but see [31] for further discussion regarding the validity of those assumptions . Functions f which unconditionally satisfy the properties as required for Theorem 4.8 are given in [23, 83, 31, 86]; none of these constructions, however, is particularly efﬁcient.  Besides the schemes discussed in this chapter, other notable signature schemes based on the strong RSA assumption includes [24, 75, 27, 65]; see [70] for a recent survey of those and other works.  As we have mentioned, the signature schemes of Cramer-Shoup and Fischlin are currently the most efﬁcient provably secure schemes known. In our description of these schemes, however, we have been concerned more with clarity than efﬁciency. We refer the reader to [36, 48] for various efﬁciency improvements as well as dis- cussions on efﬁcient implementation of these schemes.  A second paper by Hohenberger-Waters [66] shows an approach by which certain signature schemes based on the strong RSA assumption can be converted to stateful schemes based on the standard RSA assumption.   Chapter 5 Constructions Based on Bilinear Maps  5.1 Introduction  In the past 10 years cryptographic constructions based on bilinear maps have become extremely popular, most prominently following their use in constructing identity-based encryption schemes. Bilinear maps have also led to several efﬁcient signature schemes, and we explore two such constructions here.  5.1.1 Technical Preliminaries  For the purposes of this chapter, we treat bilinear maps in a completely abstract fashion without discussing any speciﬁc instantiation. A detailed understanding of bilinear maps as used in cryptography requires a more in-depth familiarity with elliptic curves than we are willing to assume on behalf of the reader. The references at the end of this chapter serve as a good starting point for further reading on this topic.  Let G be an efﬁcient algorithm that, on input 1k, outputs  G,GT ,q,g, ˆe  where:   G, GT are  descriptions of  two groups of prime order q, where group operations   g is a random1 generator of G.   ˆe is a  description of an  efﬁciently computable function2 ˆe : G×G → GT whose  in G,GT can be performed efﬁciently.  properties are summarized below.  1 The assumption that g is random can be relaxed, but assuming g is random simpliﬁes things. 2 Often ˆe is deﬁned as a mapping ˆe : G1 × G2 → GT where G1,G2 are isomorphic but do not necessarily share the same representation.  This is sometimes referred to as the asymmetric case, in contrast to the symmetric case presented in this text.  We have opted to focus on the symmetric case because doing so allows us to simplify the notation; all the results covered in this chapter, however, carry over to the asymmetric setting.  J. Katz, Digital Signatures, DOI 10.1007 978-0-387-27712-7_5,   Springer Science+Business Media, LLC 2010  121   122 5 Constructions Based on Bilinear Maps The function ˆe is required to be bilinear, meaning that for every g,h ∈ G and every a,b ∈ Zq  ˆe ga,hb  = ˆe g,h ab.  We also assume that ˆe is non-degenerate, namely that ˆe g,g   cid:54 = 1.  Later, we will formally state the speciﬁc computational assumptions that will be used to prove security of the signature schemes that will be presented. To gain some familiarity with bilinear maps, though, we include some preliminary discus- sion here.  We always assume that the discrete logarithm problem is hard in G. Formally,  we assume the following is negligible for all PPT algorithms A:  Pr[ G,GT ,q,g, ˆe  ← G  1k ;h ← G;x ← A 1k,G,GT ,q,g,h, ˆe  : gx = h].  This implies hardness of the discrete logarithm problem in GT : if not, then A could efﬁciently compute the discrete logarithm of h ∈ G as follows:   Compute gT = ˆe g,g . By non-degeneracy of ˆe and the fact that the orders of G   Compute hT = ˆe g,h .   Compute loggT hT = x  using the fact that the discrete logarithm problem in GT  and GT are prime, we have that gT is a generator of GT .  is easy .  This succeeds because of bilinearity; namely, because if h = gx then  hT = ˆe g,h  = ˆe g,gx  = ˆe g,g x = gx T .  5.1.2 Outline of the Chapter  In this chapter we focus on two signature schemes built using bilinear maps. The ﬁrst scheme we present is due to Boneh and Boyen and relies on an assumption similar in some respects to the strong RSA assumption. We then show a scheme due to Waters that can be based on the more standard computational Difﬁe-Hellman assumption  though in a group where an efﬁciently computable bilinear map is deﬁned . This scheme is interesting in that it is derived from an identity-based encryption scheme; the reader is referred to Waters’s original paper [109] for further details.  Our intention here is to highlight the techniques used in designing these schemes and proving them secure, not to discuss their relative performance beneﬁts. Such a discussion would require a more extensive digression into the speciﬁcs of bilinear maps as used in cryptography.   5.2 The Boneh-Boyen Scheme 5.2 The Boneh-Boyen Scheme  123  Let G , as before, be an algorithm that generates parameters  G,GT ,q,g, ˆe  deﬁning a bilinear map. For compactness, we abbreviate the output of G by params. The strong Difﬁe-Hellman  SDH  assumption states that the following problem is hard:   cid:179    cid:180   Given params and gx,gx2 c,g1  x+c   output  , . . . ,gxq ∈ G  for random x , for an arbitrary c ∈ Zq.   The solution with c = −x is disallowed.  We will in fact require this problem to be hard for any  polynomial  q. Observe that a candidate solution  c,h  ∈ Zq × G can be veriﬁed  with respect to the given instance g,gx, . . . ,gxq  by checking whether ˆe gx gc,h  ?= ˆe g,g . Letting h = g1  x+c cid:48   for some c cid:48  ∈ Zq  note that if h = 1 then ˆe gx gc,h  = 1  cid:54 = ˆe g,g ; in any other case, c cid:48  is well-deﬁned , this works because  ˆe gxgc,h  = ˆe gx+c,g1  x+c cid:48    = ˆe g,g  x+c   x+c cid:48  ,  and the ﬁnal expression is equal to e g,g  if and only if c = c cid:48 .  Formally:   cid:183   Deﬁnition 5.1. The SDH problem is hard relative to G if for all PPT algorithms A and all polynomials q = q k  the following is negligible:  Pr  params ← G  1k ;x ← Zq;   c,h  ← A params,gx,gx2  , . . . ,gxq   : ˆe gx gc,h  = ˆe g,g   .   cid:184   The SDH assumption, as stated, is vaguely similar to the strong RSA assumption insofar as A is given the freedom to choose c. A stronger correspondence is given by the following lemma, which can be viewed as an analogue of Lemma 4.2.   cid:34   Lemma 5.1. Say the SDH problem is hard relative to G . Then for all PPT algo- rithms A, all polynomials q, and any set of integers {ci}q i=1, the following is negligi- ble:   cid:180  : ˆe gx gc,h  = ˆe g,g    cid:94   c  cid:54 ∈ {ci}  .   cid:35   params ← G  1k ;x ← Zq;  Pr   c,h  ← A  params,gx,{ci,g1  x+ci }q  i=1   cid:179   Stated differently, even given several SDH solutions {ci,g1  x+ci }q  i=1 it remains difﬁcult for A to ﬁnd a new SDH solution  c,g1  x+c  . This immediately yields a sig- nature scheme secure under a known-message attack, as we will see subsequently. We ﬁrst prove the lemma. Proof. Given a PPT algorithm A, a polynomial q, and a set of integers {ci}q i=1 as in the lemma, we construct a PPT algorithm B solving the SDH problem. Algorithm B is given params =  G,GT ,q,g, ˆe  and {gxi}q+1 i=1 . A key observation is that given any polynomial f  X  ∈ Zq[X] of degree at most q + 1, it is possible for B to compute   124  5 Constructions Based on Bilinear Maps  g f  x   where x here is the same as in the instance B is given . This is done by writing f  X  = ∑q+1  i=0 fiX i and then computing   cid:179  gxi cid:180  fi = g∑q+1  i=0 fixi  .  q+1  ∏  i=0  then computes the following values, exactly as described above:  We use this extensively in what follows. B deﬁnes the polynomial f  X  = ∏q   cid:179   cid:179    cid:180 r  cid:180 r  .  g f  x  gx f  x   1. ¯g := 2. ¯g cid:48  := 3. For i ∈ {1, . . . ,q}, hi :=   cid:179   i=1 X + ci  and chooses a random r ← Zq. It  cid:180 r  .  Note that, by construction of f , we in-  .  Note that the polynomial X f  X  has degree q + 1.   deed have that f  X   X + ci  ∈ Zq[X] for all i.   g f  x   x+ci   i=1. Observe that  B then runs A on input params cid:48  =  G,GT ,q, ¯g, ˆe , ¯g cid:48 , and {ci,hi}q   ¯g is a random element of G;   ¯g cid:48  = ¯gx for a random x ∈ Zq  unknown to B ;   hi = ¯g1  x+ci  for all i. We assume f  x   cid:54 = 0 since this event occurs with negligible probability  and would anyway allow B to compute x . Thus, the inputs given to A have the correct distribu- tion and so the probability with which A outputs  c, ¯h  with ¯h = ¯g1  x+c  and c  cid:54 ∈ {ci} remains unchanged. Assuming A does indeed output  c, ¯h  with ¯h = ¯g1  x+c  and c  cid:54 ∈ {ci}, we show that it is possible for B to compute a valid solution to its SDH instance. Using long division, B computes a polynomial f  cid:48  ∈ Zq[X] and a non-zero scalar c cid:48  ∈ Zq such that f  X  = f  cid:48  X ·  X + c  + c cid:48 .  We have c cid:48   cid:54 = 0 by deﬁnition of f and the fact that c  cid:54 ∈ {ci}.  Then B outputs the solution   cid:181    cid:179   ¯h1 r g f  cid:48  x   c,   cid:180 1 c cid:48  cid:182   ,  where the value g f  cid:48  x  is computed as described earlier. This is a valid solution to B’s given SDH instance since   cid:195    cid:33 1 c cid:48   ¯h1 r g f  cid:48  x   ¯g1  r x+c    g f  cid:48  x    cid:195   cid:195   g f  cid:48  x + c cid:48   g f  cid:48  x   x+c  g f  cid:48  x    cid:33 1 c cid:48   cid:33 1 c cid:48  1 c cid:48   =  gr f  x   r x+c    =  =  =   cid:182 1 c cid:48    cid:181  g c cid:48   x+c  = g1  x+c .   5.2 The Boneh-Boyen Scheme  125  The previous lemma suggests the following signature scheme. The public key contains  G,GT ,q,g, ˆe  along with a value X = gx; the secret key is x. The signature on the message m ∈ Zq is just σ = g1  x+m .  We require m  cid:54 = −x.  To verify a signature σ on a message m, it is simply required to check whether  ˆe X gm,σ  ?= ˆe g,g ;  this succeeds because for a correct signature σ we have  ˆe X gm,σ  = ˆe gxgm,g1  x+m   = ˆe g,g  x+m   x+m  = ˆe g,g .  Lemma 5.1 immediately implies that the scheme just described is existentially unforgeable under a known-message attack. We could of course then apply Con- struction 1.2 to obtain a scheme secure under an adaptive chosen-message attack. The Boneh-Boyen scheme, given as Construction 5.1, applies essentially the same idea but more efﬁciently.  Construction 5.1: The Boneh-Boyen scheme  def=  G,GT ,q,g, ˆe  ← G  1k  and choose random  Let G be as described in the text. Key generation: Compute params x,y ∈ Zq. The public key is  params,gx,gy  and the secret key is x,y. Signature generation: Given a message m ∈ Zq, the signer choose a random r ∈ Zq .  Note that x + m + yr  cid:54 = 0 mod q except and outputs the signature with negligible probability over choice of r.  Signature veriﬁcation: To verify a signature  r,σ  on a message m with respect to a public key  params,X,Y  , check whether ˆe XgmY r,σ  ?= ˆe g,g .  r,g1  x+m+yr    cid:179    cid:180   Theorem 5.1. If the SDH problem is hard relative to G , then the Boneh-Boyen scheme is strongly unforgeable under an adaptive chosen-message attack.  Proof. Fix some PPT algorithm A attacking the signature scheme, and let q be a  polynomial  upper-bound on the number of signature queries made by A. For a given public key  params,X,Y    with associated secret key x,y , say A obtains sig- natures { ri,σi } on messages {mi} and outputs a strong forgery m, r,σ .  We allow m ∈ {mi} as long as  m,r,σ   cid:54 ∈ { mi,ri,σi }.  We assume A never requests a signa- ture on the message m = −x; this is without loss of generality since, given m = −x, it is trivial to construct a forgery. Let ε1 k  denote the probability with which A outputs a valid forgery and m + ry = mi + riy for some i, and let ε2 k  denote the probability with which A outputs a forgery and m+ry  cid:54 = mi +riy for all i.  Note that one can efﬁciency determine which is the case, even given only the public key, by   126  5 Constructions Based on Bilinear Maps  checking if gmY r = gmiY ri for some i.  We show that ε1 and ε2 are negligible; since the overall success probability of A is ε k  = ε1 k +ε2 k , this completes the proof. We begin by bounding ε2 since this is the easier case. Consider the following algorithm B2 given input as in Lemma 5.1 for random {ci}q  i=1:  i=1, and is then given  Algorithm B2: The algorithm chooses3 random {ci}q params,gx,{ci,σi = g1  x+ci }q   Choose y ← Zq \ {0}, and then give to A the public key   When A requests a signature on the ith message mi, set ri :=   If A outputs a strong forgery m, r,σ  with m+ry  cid:54 = mi +riy   params,gx,gy .  ci − mi  y mod q and return the signature  ri,σi .  i=1.  for all i, then output the solution  m + ry,σ .  Since the {ci} are chosen at random, independent of the public key given to A, the distribution over A’s view in the above experiment is statistically close to the distribution over A’s view in a real attack on the signature scheme.  In particular, the {ri} are random and signatures constructed by B2 are correctly distributed.  Thus, with probability exactly ε2 in the above experiment, A outputs a strong forgery m, r,σ  where m+ry  cid:54 = mi +riy for all i. In this case, σ= g1  x+ m+ry  . Further, by construction of B2 we have ci = mi + riy for all i. Thus, m + ry  cid:54 ∈ {ci} and therefore B2 outputs a new  and correct  SDH solution with probability ε2. By the assumed hardness of the SDH problem and Lemma 5.1, it follows that ε2 is negligible.  We now bound ε1. The main idea is similar to that used above, but the algebra is  slightly more complicated. Consider the following algorithm B1  Algorithm B1: The algorithm chooses random non-zero {ci}q given params,gy,{ci,σi = g1  y+ci }q   Choose x ← Zq, and give the public key  params,gx,gy    When A requests a signature on the ith message mi, set ri :=  i=1, and is then  to A.  i=1.   x + mi  ci mod q and return the signature  Note that ri  cid:54 = 0 by our assumption that mi  cid:54 = −x.     If A outputs a strong forgery  r,σ  on a message m, with  g1  y+ci    cid:180 1 ri.   cid:179   gm gy r = gmi gy ri for some i, then compute y :=  m− mi   ri − r  mod q.   We show below that r  cid:54 = ri.  At this point it is trivial to output a new SDH solution.  3 Although Lemma 5.1 was only stated for the case of ﬁxed {ci}, it is not difﬁcult to see that the lemma extends to this setting as well.   5.3 The Waters Scheme  127  It is straightforward to see that the public key given to A has the same distribution as in a real attack, and the {ri} are all random. It takes a little more work to see that the signatures constructed by B1 have the correct form; this is so because   cid:179    cid:180 1 ri = g1  riy+rici  = g1  riy+x+mi ,  g1  y+ci   by choice of ri. Finally, say A outputs a strong forgery m, r,σ  with gm gy r = gmi gy ri for some i. For a given public key and m,r, there is a unique σ such that  r,σ  is a valid signature on m. Since  r,σ  is a valid signature on m but  m,r,σ   cid:54 =  mi,ri,σi , we must in fact have  m,r   cid:54 =  mi,ri . But if gm gy r = gmi gy ri then m + ry = mi + riy and so actually m  cid:54 = mi and r  cid:54 = ri. It follows that B1 can correctly solve for y as described, and so B1 outputs a new  and correct  SDH solution with probability ε1. By the assumed hardness of the SDH problem and Lemma 5.1, it follows that ε1 is negligible. This concludes the proof.  5.3 The Waters Scheme  We conclude this chapter by presenting the Waters signature scheme. This construc- tion is of signiﬁcant interest for several other applications it has beyond merely serving as a standard signature scheme, most prominently to identity-based encryp- tion  the context in which it was ﬁrst proposed ; unfortunately, we will not be able to survey these diverse applications in this book. For our purposes, the scheme serves as an example of an efﬁcient scheme based on  what is for the most part  a standard assumption. The proof technique used to prove it secure is quite clever too.  We can deﬁne the computational Difﬁe-Hellman  CDH  assumption in any  cyclic  group G, and this assumption had been used well before bilinear maps were introduced to cryptography. Roughly, the CDH assumption is that the following problem is hard for any generator g ∈ G:  Given ga,gb ∈ G  for random exponents a,b , output gab ∈ G.  Interestingly, in the general case a valid solution to the CDH problem cannot neces- sarily be veriﬁed; that is, there is not necessarily any efﬁcient mechanism to deter- mine whether a candidate solution h to a CDH instance  g,ga,gb  is correct or not. Moreover, in certain groups G it is even reasonable to assume that it is  essentially  never possible to verify a solution; this is, roughly speaking, what the decisional Difﬁe-Hellman assumption entails.  When an efﬁciently computable bilinear map is deﬁned over G, however, it is possible to efﬁciently verify correct solutions to the CDH problem  and so, in par- ticular, the decisional Difﬁe-Hellman assumption cannot hold . Indeed, given four   128  5 Constructions Based on Bilinear Maps  elements g,gx,gy,gz, where g has order q, checking whether z ?= xy mod q is equiva- lent to checking whether ˆe g,gz  ?= ˆe gx,gy . Assuming the CDH assumption holds, this asymmetry between the difﬁculty of computing a correct solution and the ease of verifying it proves very useful; we will see this both here, as well as later in Section 7.1.1.  The CDH assumption is formally stated as follows:  Deﬁnition 5.2. The CDH problem is hard relative to G if for all PPT algorithms A the following is negligible:  Pr  params ← G  1k ;a,b ← Zq : A params,ga,gb  = gab  .   cid:104    cid:105   We jump right in with a description of the Waters scheme.  Construction 5.2: The Waters scheme  Let G be as described in the text. def=  G,GT ,q,g, ˆe  ← G  1k . Choose a ← Zq Key generation: Compute params and set g1 := ga. Choose also random g2,u0, . . . ,uk ← G. The public key is  params,g1,g2,u0, . . . ,uk  and the secret key is ga 2. Fixing a public key, we set H m  def= u0 · ∏k i where m = m1···mk ∈ {0,1}k. i=1 umi Signature generation: Given a message m ∈ {0,1}k, the signer choose a random r ∈ Zq and outputs the signature  ga Signature veriﬁcation: To verify a signature  σ1,σ2  on a message m, check whether ˆe g,σ1  ?= ˆe σ2,H m  · ˆe g1,g2 .  2 · H m r, gr .  Let us ﬁrst verify correctness. Given an honestly generated signature  σ1,σ2  on a message m, we have  2 · H m r  ˆe g,σ1  = ˆe g, ga 2 · ˆe g, H m r  = ˆe g, ga = ˆe ga,g2 · ˆe gr,H m   = ˆe g1,g2 · ˆe σ2,H m  ,  as desired. Theorem 5.2. If the CDH problem is hard relative to G , then the Waters scheme is unforgeable under an adaptive chosen-message attack.  We remark that the Waters scheme is not strongly unforgeable, as there is an easy way to “re-randomize” a valid signature on any message. This can actually be a useful feature for certain applications.   5.3 The Waters Scheme  129  Proof. Given an adversary A attacking the signature scheme, making at most qs signing queries, and having success probability ε, we construct an adversary B solv- ing the CDH problem with probability polynomially related to ε. Informally, B will generate a public key  having the appropriate distribution  for which B can compute valid signatures on a  random  subset S ⊂ {0,1}k of messages, and such that any forgery produced by A on a message outside of S allows B to solve its given CDH instance. We expect B to be successful with probability roughly   cid:182 qs ·   cid:181 S  2k   cid:181  1− S 2k   cid:182   ;  ε·   cid:179    cid:180   setting S 2k ≈ is a bit more subtle, and is given next.  1− 1 qs  then gives B success probability O ε . The formal analysis  Algorithm B: The algorithm is given params =  G,GT ,q,g, ˆe  and g1,g2.   Set  cid:96  = 2qs. We assume k cid:96  < q, which holds for k large   Choose x0 ← {−k cid:96 , . . . ,0} and x1, . . . ,xk ← {0, . . . ,  cid:96 }. Also  enough. choose y0, . . . ,yk ← Zq.    For i = 0, . . . ,k, set ui := gxi  2 gyi. Deﬁne the functions F m  def=   Run A on the public key  params,g1,g2,u0, . . . ,uk . When  i=1 mixi and G m  def= y0 + ∑k  i=1 miyi.  x0 + ∑k  A requests a signature on a message m, do: 1. If F def= F m  = 0 mod q then abort. 2. Otherwise, set w := F−1 mod q and G def= G m . Choose .  2 gGr g−Gw gFr    If A outputs a valid forgery  m, σ1,σ2  , do:  r ← Zq and return the signature 1. If F m   cid:54 = 0 mod q then abort. 2. Otherwise, output σ1 σG m  .  , gr g−w 1   cid:161    cid:162   1  2  It is easy to see that the public key given to A has the correct distribution. Let us next argue that as long as B does not abort  1  the signatures given to A are distributed correctly, and  2  B outputs a correct solution to its given CDH instance. Let a = logg g1 and b = logg g2. Recall that a real signature on the message m would for a random ¯r. Setting F = F m , G = G m , w = be computed as F−1 mod q  using the fact that B only returns a signature if F  cid:54 = 0 mod q , and ¯r = r− aw, and observing that H m  = gF m   2H m ¯r, g¯r cid:162   gG m , we have   cid:161   ga  2H m ¯r = ga ga  2  2 · cid:161   2 gG cid:162 r−aw  gGr−Gaw  2H m r−aw = ga = ga = gFr  gF 2gFr−a 2 gGrg−Gw  2  1   130  and  5 Constructions Based on Bilinear Maps  g¯r = gr−aw = grg−aw = grg−w 1  ,  exactly as returned by B. Since B chooses r at random, ¯r = r− aw is uniformly dis- tributed and we conclude that signatures returned by B have the correct distribution. Say A outputs a valid signature  σ1,σ2  on a message m for which F m  = 0 mod q. By deﬁnition of the veriﬁcation algorithm, this means ˆe g,σ1    ˆe σ2,H m   = ˆe g1,g2  = ˆe g,gab , and so  ˆe g,g ab =  ˆe g,σ1   ˆe σ2,H m   ˆe g,σ1   ˆe g,g0  2gG m    ,  =  from which we conclude that σ1 gG m  = gab. It remains only to analyze the probability with which B does not abort, and suc- cessfully completes the simulation. Since the {xi} chosen by B are independent of the public key given to A, we can analyze this probability by imagining a “men- tal experiment” in which A interacts with the real signature scheme, requesting signatures on messages m1, . . . ,mqs and then outputting a forgery on a message m  cid:54 ∈ {m1, . . . ,mqs} with  overall  probability ε. After this point, {xi} are chosen from the same distribution used by B, and we ask whether  F m1   cid:54 = 0 mod q ∧ ··· ∧ F mqs   cid:54 = 0 mod q ∧ F m  = 0 mod q.   5.1   We stress that the probability that the above event holds is not independent of m and the {mi}, and this dependence creates problems some application of the Waters scheme  most notably in the context of proving that it gives a secure identity-based encryption scheme . In our context, however, it sufﬁces to give a lower bound for the probability of the above event that holds for any m and {mi}. Fix arbitrary m and {mi}, and let E be the event in Equation  5.1 . We are in- terested in the probability of this event over choice of x and the {xi}. We can sim- plify things by noting that F m  < q for all m, and therefore F m  = 0 mod q iff F m  = 0. We then have  Pr[E] ≤ Pr[F m   cid:54 = 0] +  Pr  F m  = 0  F mi  = 0  .   cid:104   qs∑  i=1   cid:94    cid:105   For any x1, . . . ,xk, there is exactly one choice of x0 for which F m  = 0; thus, Pr[F m   cid:54 = 0] = k cid:96   k cid:96  + 1 . Next consider any i ∈ {1, . . . ,qs}, and let M = mi. Since m  cid:54 = M, there must be some index j where they differ. Without loss of gen- erality, say the jth bit of m is 1 and the jth bit of M is 0. Fixing some choice of x1, . . . ,x j−1,x j+1, . . . ,xk, we see that F m  = 0 and F M  = 0 only if  x0 + x j = −∑ i cid:54 = j  mixi  and x0 = −∑ i cid:54 = j  Mixi,   131  5.4 Further Reading  and therefore   cid:94   Pr[F m  = 0  F mi  = 0] ≤ 1 k cid:96  + 1  · 1  cid:96  + 1 .  Putting everything together, we have Pr[E] ≤ k cid:96  k cid:96  + 1  and so   k cid:96  + 1 ·   cid:96  + 1  ,  qs   cid:182   +   cid:181  1− qs  cid:96  + 1  ·  ≥  1  4kqs + 2 .  Pr[E] ≥ 1  k cid:96  + 1  From this we conclude that B succeeds with probability at least ε  4kqs + 2 , and so ε must be negligible if the CDH problem is hard relative to G .  5.4 Further Reading  A good introduction to elliptic-curve cryptography, including a discussion of bi- linear maps, can be found in the textbook by Washington [108]. Galbraith et al. [51] give a more up-to-date treatment of the bilinear maps used in cryptographic schemes, along with a detailed discussion of their efﬁciency.  Our proof of security for the Boneh-Boyen scheme was adapted directly from their paper [18]. For the Waters scheme [109], the proof given here more closely follows an alternate approach suggested by Bellare and Ristenpart [8] although we stress that the same basic ideas were used already by Waters. We remark that is both these aforementioned works [109, 8], the proofs are signiﬁcantly complicated because they provide a security analysis for identity-based encryption. In contrast, here we faced the easier task of proving security as a signature scheme only.   Part III Digital Signature Schemes in the Random Oracle Model   Chapter 6 The Random Oracle Model  The signature schemes described in the previous chapters, whether based on the RSA strong RSA assumptions or bilinear maps, represent essentially the extent of what is currently known regarding efﬁcient yet provably secure signature schemes. These schemes have some clear disadvantages:   They are based on a relatively small set of assumptions. Notably, we are lacking efﬁcient constructions based on the hardness of factoring or the discrete loga- rithm problem, or even the computational Difﬁe-Hellman assumption in groups without an associated bilinear map.   Though efﬁcient, the existing schemes are currently viewed as not being efﬁcient enough for most practical applications. This is especially true given the avail- ability of various “heuristically secure” schemes  i.e., schemes whose security has not been broken thus far  that are much more efﬁcient than the provably secure schemes we know. Given what appears to be the status quo — that the only schemes having a chance of being widely used are those whose efﬁciency is truly comparable with currently deployed schemes — we are left with somewhat of a dilemma. On the one hand we would surely prefer to use schemes having some concrete evidence for their security; on the other hand the schemes that we can  currently  prove secure are not  yet  efﬁcient enough.  One approach to addressing this dilemma is to introduce new number-theoretic assumptions; these may, in turn, enable constructions of more efﬁcient schemes based on those assumptions, or might allow for proofs of security for existing schemes.  To some extent, this has already happened with the introduction of the strong RSA assumption and — even more so — with the variety of assumptions that have been proposed in the context of groups over which a bilinear map is deﬁned.  This is certainly a reasonable approach. Of course, that there is always the danger that a new problem turns out to be not quite as hard as it appeared on ﬁrst glance! There is also a more subtle problem that arises when introducing a new assumption expressly to prove an existing scheme secure: at what point does introducing a new assumption become “equivalent” to simply assuming the security of the signature  J. Katz, Digital Signatures, DOI 10.1007 978-0-387-27712-7_6,   Springer Science+Business Media, LLC 2010  135   136  6 The Random Oracle Model  scheme itself? This is not a question that can be answered readily  see [87] for one possible approach , but the point remains that it is preferable to base schemes on well-studied, widely accepted assumptions rather than newer ones.  Another approach to resolving the dilemma has become popular, though the the- oretical soundness of the approach has yet to be rigorously justiﬁed. This method- ology advocates the use of a new model, called the random oracle model, in which to prove security of cryptographic schemes.1 As suggested by the name, the random oracle model is an idealized model that assumes the existence of a public, random function H such that all parties can obtain H x   for any desired input value x  only by interacting with an oracle computing H; parties cannot compute H  for any in- put  on their own. The oracle  equivalently, H  is assumed to implement a truly random function, something that can be visualized in the following way: the oracle maintains a table of pairs { xi,yi } which is initially empty. When the oracle re- ceives a query x it ﬁrst checks whether x = xi for some i; if so, the corresponding yi is returned. Otherwise, a random string y of the appropriate length is chosen, the answer y is returned, and the oracle stores  x,y  in its table so that the same output value can be returned if the same input is queried again. Queries to the oracle are assumed to be private so that, for example, if an honest party queries the oracle on input x then an adversary does not learn x.  The random oracle model is used to design cryptographic primitives via the fol-  lowing two-step approach: 1. A scheme is designed and proven secure assuming the existence of this random oracle  and possibly also using other number-theoretic or cryptographic assump- tions ; that is, the scheme is designed in this idealized “random oracle model.” We will describe the model in more detail below.  2. In the real world, of course, no random oracle is available. In practice, then, the random oracle is instantiated with a cryptographic hash function  such as SHA-1, modiﬁed appropriately  that is hoped to be “sufﬁciently good” at simulating a random oracle.  As we shall see, it is not clear exactly what is meant for a hash function to be “sufﬁciently good” at simulating a random oracle, nor is it clear that this is a goal that can possibly be achieved in general. Thus, proofs of security for a given scheme in the random oracle model should not be viewed as proofs that apply to any “real- world” instantiation of the scheme. Before discussing in more detail the theoretical drawbacks of the random oracle model, as well as the practical justiﬁcations for using it, we will describe by way of example why the random oracle model is so useful in proving security of cryptographic schemes.  1 Indeed, use of the random oracle model is not limited to the case of signature schemes.   6.1 Security Proofs in the Random Oracle Model 6.1 Security Proofs in the Random Oracle Model  137  At a high level, the random oracle model is used in the following way: given an adversary A breaking some scheme violating some cryptographic assumption in the random oracle model, A is transformed to an algorithm A cid:48  which violates some cryptographic assumption in the standard model by having A cid:48  simulate the random oracle for A. Our algorithm A cid:48  gains two advantages here:  1  A cid:48  gets to see the queries that A makes to the random oracle; and  2  A cid:48  gets to answer these queries “any way it likes”  although to provide a good simulation these queries should be answered in a “random-looking” way . There is also a third, perhaps more obvious advantage  already implicit in the random oracle model itself : the value of H x  for any point x not explicitly queried by A is completely random, at least from the perspective of A.  We give two quick examples of proofs where the above techniques are used in an essential way. We make no attempt to be rigorous here; rather, our goal is to provide the reader with enough intuition so that the later proofs in the random oracle model  given in the chapters that follow  will be easier to digest. First example. For the ﬁrst example we consider the following game: a “challenger” generates an RSA key  N,e , chooses random m ∈ {0,1} cid:96  and r ∈ Z∗ N, and sends  N,e,re mod N,H r ⊕ m  to A, where H : Z∗ N → {0,1} cid:96  is taken to be a random oracle. We claim that, under the RSA assumption, no PPT adversary A can learn any information about m  beyond what it could determine by random guessing  except with negligible probability. To see this, we argue as follows: The only way A can learn anything about m is by explicitly querying the random oracle at the point r; this is a consequence of the fact that H r  is completely random  from the point of view of A  unless A speciﬁcally queries H at this point. Letting ε denote the probability that A does indeed query H r , we have that A learns no information about m except with probability ε. We now show that εmust be negligible by constructing a PPT algorithm A cid:48  which  solves the RSA problem with probability exactly ε:  Algorithm A cid:48  The algorithm is given  N,e,y , and its goal is to compute y1 e mod N.   Choose random r cid:48  ← {0,1} cid:96 .   Run A on input  N,e,y,r cid:48  . Perfectly simulate the random oracle queries of A by returning random answers to each  fresh  query.   When A is done, let x1, . . . ,xn denote the queries that A made   If there exists an i for which xe i mod N ?= y, then output xi.  to the random oracle.  The input given to A is distributed identically to the above experiment, and it is trivial for A cid:48  to simulate the random oracle for A  since A makes only polynomial-   138 6 The Random Oracle Model lymany queries, A cid:48  need only store a polynomial-size table of input output pairs . Since A cid:48  can see the queries made by A to the random oracle, it follows that A cid:48  in- verts its given input y with probability exactly ε. We conclude that, under the RSA assumption, ε is negligible as claimed. Second example. We now consider a game in which the challenger generates  N,e  as before, and sends these and a random value y ∈ Z∗ N to an adversary A. The goal is for A to compute y1 e mod N. The “twist” is that A can query the random or- acle H : Z∗ N  we assume with- out loss of generality that these are distinct , receiving in return the output values y1 = H x1 , . . . ,y cid:96  = H x cid:96  ; the challenger then gives to A the values y1 e i mod N for all i  assume the challenger knows the factorization of N and so can compute these values . We claim that A still cannot compute y1 e mod N except with negli- gible probability. To see this, construct the following adversary A cid:48  which computes y1 e mod N with the same probability at A, but without any additional “help” from the challenger:  N at any sequence of points x1, . . . ,x cid:96  ∈ Z∗  N → Z∗  Algorithm A cid:48  The algorithm is given  N,e,y  as input, and its goal is to com- pute y1 e mod N.   Run A on input  N,e,y .   For each random oracle query H xi  of A:  – Choose ri ← Z∗ N. – Answer the query using yi := re  i mod N.    Give r1, . . . ,r cid:96  to A. Output whatever value is output by A.  The key point to notice in the above is that A cid:48  perfectly simulates the random oracle queries of A  indeed, each answer yi is uniformly distributed in Z∗ N , but in such a way that A cid:48  knows the corresponding inverses ri = y1 e i mod N. Thus, the view of A above is identically distributed to its view in the real experiment, and so A cid:48  outputs the correct inverse of y with exactly the same probability with which A outputs the correct inverse in the original game.  6.2 Is the Random Oracle Methodology Sound?  The proofs we have given in the previous two examples are rather simple and clean. It is worth noting, however, that the proofs rely heavily on the random oracle model, and cannot be translated to the “real world” when the random oracle H is instantiated with any concrete hash function.2 In the ﬁrst example, the proof relies on the fact that H r  is completely random unless r is explicitly queried to the oracle, and on  2 This is not to say that there might not be some other way to prove the same results as in the two examples; the point is only that the proofs given earlier do not work.   6.2 Is the Random Oracle Methodology Sound? 139 the ability of A cid:48  to see the queries being made by A. Neither of these assumptions hold for any concrete function H which can be evaluated by A on its own. First of all, it is not even clear in this case what it means for A to “explicitly query H r ,” since A may be able to evaluate H r  other than by explicitly making a query to a subroutine that computes H. Given this, it is doubly unclear what it might mean for H r  to be “completely random” from the point of view of A — note in particular that once A is given a program to compute H, the value H r  is decidedly no longer random. Finally, once A no longer needs to make explicit queries to compute H r  there is no way for A cid:48  to “intercept” these queries and check for an inverse of y. The proof of the second example, above, relies on the ability of A cid:48  to answer the random oracle queries of A in any manner of its choosing. Once the function H is ﬁxed  in particular, once A is given the code to compute H , however, this is of course no longer possible.  The objections raised above are representative of a more general problem with the random oracle model. Recall the two-step approach to designing schemes in this model: ﬁrst, a scheme is developed and proven secure in the random oracle model; next, the scheme is instantiated in the real world using a hash function which is assumed to provide a “sufﬁciently good” simulation of a random oracle. Unfortu- nately, we do not in general know how to prove that any concrete hash function is “sufﬁciently good” at simulating a random oracle; thus, a proof of security in the random oracle model does not actually constitute a proof of security  for the in- stantiated scheme  in the real world. Worse, we cannot in general even deﬁne  in a meaningful way  what “simulating a random oracle” means. Because of this, using the random oracle model to “prove” security of a scheme is qualitatively differ- ent from, e.g., introducing a new cryptographic assumption in order to prove some scheme secure, and a proof of security in the random oracle model is generally re- garded as less desirable than a proof of security in the so-called3 standard model which does not allow for random oracles.  The division of the chapters in this book is meant to emphasize this preference for proofs that avoid random oracles.   It is worth stressing at this point that a random oracle is fundamentally different from a pseudorandom function, and in particular a pseudorandom function cannot be used generically to instantiate a random oracle. A pseudorandom function is a keyed function which can only be evaluated  in the real world  when the key is known, and is only “random-looking” when the key is unknown. In contrast, a ran- dom oracle is unkeyed and, when instantiated by a hash function in the real world, can be evaluated by anyone; yet it is supposed to remain “random-looking” in some ill-deﬁned sense. Finally, pseudorandom functions can be  meaningfully  deﬁned and realized; in contrast, it is clear that no real-world function will have the proper- ties of a random oracle that were relies upon in the proofs above.  As in footnote 2, this is not to say that there does not exist any real-world function for which the pre- vious claims of security hold; only that there is no real-world function for which the previous proofs will work.   3 In the use of “standard model” to designate the non-random oracle model, one can already sense the unease with which the random oracle model is regarded.   140  6 The Random Oracle Model  In light of the above, a major current research question is what, exactly, a proof of security in the random oracle model does guarantee vis-a-vis the security of the scheme in the real world. It is fair to say that we are a long way from a good under- standing of the answer to this question.  6.2.1 Negative Results  In fact, a number of negative results concerning the use of the random oracle model are known. These negative results generally show a  contrived  scheme which is provably-secure in the random oracle model but demonstrably insecure for any con- crete instantiation of the random oracle.  In at least one case [89] a stronger result is demonstrated whereby a security goal is shown to be achievable in the random oracle model, but not achievable — by any scheme — in the standard model.  We will give the general ﬂavor of these results, again without being completely formal. As a warm-up, we ﬁrst show a weaker result: that for any real-world hash func- tion H∗ there exists a signature scheme which is secure in the random oracle model but insecure when instantiated using H. The idea is quite simple: let H∗ 0  = v0, where the output-length of H∗ is assumed to be linear in the security parameter. Now take any secure signature scheme and modify it so that, when signing a mes- sage, the signer ﬁrst checks whether H 0  ?= v0  where H is the random oracle ; if so, the signer outputs its secret key  if not, then the signature is computed normally . In the random oracle model, this modiﬁed scheme is still secure: the probability that H 0  = v0 for any value v0 is negligible, and assuming this is not the case then the signature scheme is unchanged. On the other hand, the scheme is clearly insecure when H is instantiated using H∗.  Along the same general lines, but using a more technically difﬁcult proof, one can show the following, stronger result: there exists a signature scheme which is secure in the random oracle model, but which is insecure when instantiated using any real-world hash function H∗. Take any secure signature scheme and modify it in the following way: when signing a message m the signer ﬁrst interprets m as the code for a function fm  if m cannot be interpreted as a program, the signer can take fm as, say, the identity function . The signer then chooses random values r1, . . . ,r cid:96  for some sufﬁciently-large  but polynomial  value  cid:96 , and checks whether fm r1  ?= H r1 , . . . , fm r cid:96   ?= H r cid:96  . If so, then the signer outputs its secret key; otherwise, the signature is computed normally. It is easy to see that the scheme is insecure for any concrete choice of H∗, as an adversary can simply request that the signer sign the code for the program com- puting H∗. On the other hand, intuitively the scheme is secure in the random oracle model since there is unlikely to exist any “short” program m for which fm agrees with the random oracle on a large fraction of their inputs.  We have glossed over many technical details; the interested reader is referred to [25, 14].  Note that this “disconnect” relies exactly on the fact that a truly random function  as realized by a   6.3 The Random Oracle Model in Practice  141  random oracle  is an exponential-size object, while any concrete function instantiat- ing a random oracle must have polynomial size  that is, there must be a polynomial- size program computing this function .  6.3 The Random Oracle Model in Practice  Given the theoretical problems with the random oracle model, as well as the negative results discussed above, are schemes with proofs of security in the random oracle model any better than schemes having no proof of security at all? Although there are those who would disagree, we believe that they are, and offer the following reasons in support of this conviction:   A proof of security for a given scheme in the random oracle model indicates that the design of the scheme is “sound,” in the sense that the only possible weakness in  the real-world instantiation of  the scheme can arise due to a weakness in the hash function used to instantiate the random oracle. Alternately, the only way to “break” the scheme is to “break” the hash function itself  in some way ; thus, if the hash function is “good enough” we have some conﬁdence in the security of the scheme itself. Furthermore, if a given instantiation of the scheme is success- fully cryptanalyzed, we can replace the hash function being used with a “better” one.   Finally, there have been no real-world attacks on any “natural” scheme proven secure in the random oracle model  this is meant to rule out the attacks on the “contrived” schemes such as those discussed in Section 6.2.1 . This gives ev- idence to the usefulness of the random oracle model in designing schemes in practice.   In light of the above, a proof of security in the random oracle model is preferable to no proof at all. Of course, this assumes that these are the only options; i.e., that schemes with proofs of security in the standard model will not be used due to their inefﬁciency.  We do not argue that choosing efﬁciency at the expense of security is the right decision to make, only that it seems to be the decision made most frequently in practice. This also assumes that the schemes proven secure in the random oracle model are indeed signiﬁcantly more efﬁcient than known schemes with proofs in the standard model.   Nevertheless, the above ultimately represent only intuitive speculation as to the use- fulness of the random oracle model rather than rigorous proof, and we emphasize our opinion that proofs of security in the standard model are preferable to proofs in the random oracle model. Understanding exactly what such proofs guarantee in the real world remains, in our mind, one of the most important research questions facing cryptographers today.   142 6.4 Further Reading  6 The Random Oracle Model  See [72, Chapter 13] for extensive additional discussion of the pros and cons of the random oracle model, examples of its application to security proofs, and some comments regarding implementation of random oracles in the real world.  The use of random oracle model to facilitate proofs was ﬁrst suggested by Fiat and Shamir [47]. The model was formalized, advocated, and popularized by the seminal work of Bellare and Rogaway [9], after which the use of the random oracle model to prove security of cryptographic constructions truly began to take off.  For negative results concerning the random oracle model, see [25, 14].   Chapter 7 Full-Domain Hash  and Related  Signature Schemes  An important class of signature schemes proven secure in the random oracle model is given by the full-domain hash  FDH  signature scheme and its variants. In ad- dition to being simple and natural, as well as quite efﬁcient, constructions in this family are also the basis for standardizes signature schemes that are widely used.  We begin by describing the basic FDH signature scheme, which can be instanti- ated with any doubly enhanced1 trapdoor permutation.  The same ideas can also be instantiated using groups over which a bilinear map is deﬁned.  We then focus on techniques for improving the tightness of the security reduction, i.e., the “gap” be- tween the probability with which an adversary forges a signature and that with which the security reduction solves the underlying hard problem on which the scheme is based.  This will be explained more concretely after our treatment of FDH.  Inter- estingly, these techniques all rely on the stronger assumption of  doubly enhanced  clawfree trapdoor permutations  though they are all described here using RSA as a special case .  We ﬁrst show that a tighter analysis of FDH is possible. Even this reduction has some slack, however, and so we turn to other schemes that offer optimally right reductions. The ﬁrst of these is a randomized variant of FDH where a random “salt” is chosen  and included with the signature  each time a message is signed. We then show how the salt can be avoided while maintaining the tight reduction.  7.1 The Full-Domain Hash  FDH  Signature Scheme  Full-domain hash  FDH  gives what is perhaps the most intuitively appealing ap- proach to constructing digital signatures, and can be viewed as a secure realization of the original ideas of Difﬁe and Hellman. At a high level, the public key in FDH consists of  a description of  a trapdoor permutation f ; the secret key is  the de-  1 In the literature, FDH is usually described as being based on trapdoor permutations. As we will see in the proof of Theorem 7.1, however, doubly enhanced trapdoor permutations are needed.  J. Katz, Digital Signatures, DOI 10.1007 978-0-387-27712-7_7,   Springer Science+Business Media, LLC 2010  143   144 7 Full-Domain Hash  and Related  Signature Schemes scription of  the inverse f −1. Letting H be a hash function  that will be modeled as a random oracle  mapping messages to the domain of f , the signature on a message m is simple f −1 H m  . Veriﬁcation of a candidate signature σ can be done by sim- ply checking whether f  σ  ?= H m . This is formalized as Construction 7.1, where the main difference is that we are more precise regarding our use of H..  Construction 7.1: The FDH signature scheme  Let Π=  Gen, Samp, f , f −1  be a trapdoor permutation family, and let H :{0,1}k → {0,1}k be a hash function. Key generation: Compute  I, td  ← Gen 1k . The public key is I and the secret key is td. Signature generation: To compute the signature on a message m, compute r := H m  followed by y := Samp I;r . Then output the signature f −1 Signature veriﬁcation: To verify a signature σ on a message m, compute r := H m  followed by y := Samp I;r . Then output 1 iff f  σ  ?= y.  td  y .  Theorem 7.1. If Π is a doubly enhanced trapdoor permutation, and H is modeled as a random oracle, then Construction 7.1 is strongly unforgeable under an adaptive chosen-message attack. Proof. Messages in FDH have unique signatures, so unforgeability implies strong unforgeability. Given a PPT adversary A attacking the FDH signature scheme, mak- ing qH hash queries  i.e., queries to the random oracle computing H  and forging a signature with probability ε, we construct a PPT algorithm A cid:48  inverting Π  in the sense described in Deﬁnition 2.5  with probability at least ε qH. Since qH must be polynomial, we conclude that ε must be negligible. Because Π is doubly enhanced, there exists  cf. Deﬁnition 2.5  an algorithm Samp cid:48  that takes as input I and outputs a tuple  x,y,r  such that  1  fI x  = y and y = Samp I;r , and  2  the distribution on r is statistically close to uniform. For simplicity we will assume that the distribution on r is uniform. We also make three assumptions, without loss of generality, regarding the behavior of A: 1. A never repeats a query to the random oracle. 2. Before making a signature query on a message m, adversary A ﬁrst makes the  hash query H m .  3. Before outputting a forgery  m,σ , adversary A ﬁrst makes the hash query H m . Our algorithm A cid:48  proceeds as follows:  Algorithm A cid:48 : The algorithm is given  I,y,r  as input, with y = Samp I;r . Its goal is to output x such that fI x  = y.   7.1 The Full-Domain Hash  FDH  Signature Scheme  145    Choose j ← {1, . . . ,qH}.   Run A on the public key I. Store triples  ·,·,·  in a table, initially empty. An entry  mi,xi,ri  indicates that A cid:48  has set H mi  = ri, and fI xi  = Samp I;ri   in particular, xi is a valid signature on mi .   When A makes its ith random oracle query H mi , answer it  as follows: – If i = j, return r. – Otherwise, compute  xi,yi,ri  ← Samp cid:48  I , return ri as the answer to the query, and store  mi,xi,ri  in the table. When A requests a signature on a message m, let i be such that m = mi and answer this query as follows: – If i  cid:54 = j, then there is an entry  mi,xi,ri  in the table. Re-  turn xi.  – If i = j then abort.    If A outputs a forgery  m,σ  with m = m j, return σ.  We may easily observe that as long as A cid:48  does not abort, the simulation it provides  for A is perfect. Speciﬁcally: 1. The public key has the correct distribution. 2. A’s jth query to the random oracle is answered with the random string r. By def- inition of Samp cid:48 , all of A’s other queries to the random oracle are also answered with a random string. 3. Signing queries  assuming A cid:48  does not abort  are also answered correctly; this, again, follows from the properties of Samp cid:48 .  Moreover, if A outputs a forgery  m,σ  with m = m j then  fI σ  = Samp I;H m j   = Samp I,r  = y,  and so A cid:48  correctly solves its given instance. The theorem follows from the fact that the guess j made by A cid:48   representing a guess of the hash-query index for which A will produce its forgery  is correct with probability 1 qH.  7.1.1 An Instantiation Using Bilinear Maps  For completeness, we show here how the FDH approach can be instantiated using bilinear maps  even though these do not quite give a trapdoor permutation family . The scheme described here was introduced by Boneh, Lynn, and Shacham and is re- ferred to as the BLS signature scheme. For simplicity in the description that follows, we assume a random oracle mapping directly to the appropriate group; in practice, one has to be careful to instantiate this random oracle properly.   146  7 Full-Domain Hash  and Related  Signature Schemes  Construction 7.2: The BLS signature scheme  Let G be as in Chapter 5. Key generation: Compute params =  G,GT ,q,g, ˆe  ← G  1k . Choose x ← Zq and set y := gx. The public key is  params,y  and the secret key is x. Let H : {0,1}k → G be a hash function. Signature generation: To compute the signature on a message m, compute h := H m  and output the signature hx. Signature veriﬁcation: To verify a signature σ on a message m, check whether ˆe σ,g  ?= ˆe H m ,y .  Theorem 7.2. If the CDH problem is hard relative to G , and H is modeled as a random oracle, then Construction 7.2 is strongly unforgeable under an adaptive chosen-message attack.  Proof. The proof here is substantially identical to the proof of Theorem 7.1, and so we only sketch the analysis. Given a PPT adversary A attacking the BLS signature scheme, making qH hash queries  i.e., queries to the random oracle computing H  and forging a signature with probability ε, we construct a PPT algorithm A cid:48  solving the CDH problem with probability at least ε qH. We make the same assumptions on the behavior of A as in the proof of Theorem 7.1.  Our algorithm A cid:48  proceeds as follows:  Algorithm A cid:48 : The algorithm is given  G,GT ,q,g, ˆe,y,h  as input, and its goal is to output σ∈ G with ˆe σ,g  = ˆe h,y .   Choose j ← {1, . . . ,qH}.   Run A on the public key  params,y . Store triples  ·,·,·  in a table, initially empty. An entry  mi,xi,hi  indicates that A cid:48  has set H mi  = hi, and hi = gxi.   When A makes its ith random oracle query H mi , answer it  as follows: – If i = j, return h. – Otherwise, choose xi ← Zq, set hi := gxi, return hi as the  answer to the query, and store  mi,xi,hi  in the table.  When A requests a signature on a message m, let i be such that m = mi and answer this query as follows: – If i  cid:54 = j, then there is an entry  mi,xi,hi  in the table.  Return yxi.  – If i = j then abort.    If A outputs a forgery  m,σ  with m = m j, return σ.   7.2 An Improved Security Reduction for FDH  147  It is not difﬁcult to verify that, unless A cid:48  aborts, the simulation provided for A is perfect and A cid:48  correctly solves its given CDH instance if A forges a signatures. The theorem follows.  7.2 An Improved Security Reduction for FDH  The proofs of security we have given for the FDH and BLS signature schemes pro- vide the following guarantee: if there exists a PPT adversary A making qH hash queries who can “break” the signature scheme with probability ε, then there exists a PPT algorithm A cid:48  that can solve the underlying hard problem with probability ε qH.  In general, the running time of the reduction A cid:48  as a function of the running time of A is also an important concern. In the proofs we have given, however, the run- ning time of A cid:48  was within a relatively small multiple of the running time of A.  Turning this around, this means that if we believe that some relevant computational problem is hard to solve in time t with probability better than ε cid:48   for some concrete setting of the security parameter k , then using this computational problem in one of these constructions gives a signature scheme that cannot be broken with probability better than qHε cid:48 . Since qH, in practice, corresponds to the number of hash function evaluations made by A, this can lead to a signiﬁcant loss in security! For example, one may set parameters so that ε cid:48  ≈ 2−100. But then if qH ≈ 280  a large, but not unachievable, value , the signature scheme only has security ε≈ 2−20  a not-very- conservative choice . In theory, the schemes are still “secure” since we may take the security parameter as high as we like  and are assured that, asymptotically, the advantage of any adversary will decay quickly ; in practice, however, we see that the tightness of a security reduction is of extreme importance.  Interestingly, the security reduction for the FDH signature scheme can be im- proved when a clawfree trapdoor permutation family is used.  A similar idea can be applied directly to the BLS signature scheme, using the observation — recorded in Section 2.3.3 — that groups in which the discrete logarithm problem is hard imply clawfree permutations.  It can be shown that if there exists a PPT adversary A mak- ing qS signing queries who can “break” the signature scheme with probability ε, then there exists a PPT algorithm A cid:48  that can solve the underlying hard problem with probability O ε qS . Since qS  cid:191  qH, this represents a signiﬁcant improvement.  We illustrate the idea here using the speciﬁc example of RSA as a  doubly en- hanced  clawfree trapdoor permutation  cf. Section 2.2.2 . Here, the public key is  N,e  and the signature on a message m is H m 1 e mod N. Examining the reduc- tion A cid:48  presented in the proof of Theorem 7.1, and assuming for simplicity that the hash function H maps directly onto Z∗ N, we see that A cid:48  will guess the index i of the hash query that results in a forgery; A cid:48  then sets the output of the ith hash query H mi  to be y  the value to be inverted . The output of all other hash queries H m j  N . In this way, A cid:48  can answer all signing queries is set to xe  j mod N for random x j ∈ Z∗   148  7 Full-Domain Hash  and Related  Signature Schemes  except those for message mi; furthermore, if adversary A outputs a forged signature on mi, then A cid:48  obtains the desired inverse. The loss of security arises from having to guess the index i from among all qH hash queries of A. We can improve the reduction by having A cid:48  be a bit more clever in how it re- sponds to hash queries of A. Speciﬁcally, each hash query will now be answered in one of two ways. With probability γ, a hash query is answered as before  i.e., H m  = xe mod N for a random x ; let us refer to any message whose hash is com- puted the way as a type-0 message. With probability 1−γ, however, a hash query is answered by choosing random x ∈ Z∗ N and setting the answer to be yxe mod N; we refer to any message whose hash is computed this way as a type-1 message. Note that A cid:48  can compute a valid signature, exactly as before, on any type-0 message; a forged signature on a type-0 message, though, is useless to A cid:48 . In exactly the op- posite way, A cid:48  is unable to compute a valid signature on any type-1 message, but a forgery on any such message allows A cid:48  to compute the desired inverse as we now describe. Say A forges a valid signature σ on a type-1 message m whose hash was computed as H m  = yxe mod N. Then   σ x e = σe xe = H m  xe = y mod N,  and so σ x mod N is the correct answer. For completeness, we give the reduction here:  Algorithm A cid:48 : The algorithm is given  N,e,y  as input, and its goal is to out- put x such that xe = y mod N.   Run A on the public key  N,e . Store triples  ·,·,·  in a ta- ble, initially empty. An entry  bi,mi,xi  indicates that mi is a type-bi message, answered using randomness xi  see be- low .   When A makes its ith random oracle query H mi , choose random xi ← Z∗ – With probability γ, return xe – With probability 1− γ, set bi := 2, return yxe  i mod N as the answer to the query, and store  1,mi,xi  in the table. When A requests a signature on a message m, let i be such that m = mi and let  bi,mi,xi  be the corresponding entry in the table. Answer this query as follows: – If bi = 0, then return xi. If bi = 1, then abort.  query, and store  0,mi,xi  in the table.  N and answer the query as follows:  i mod N as the answer to the    If A outputs a forgery  m,σ , let i be such that m = mi and let  bi,mi,xi  be the corresponding entry in the table. If bi = 0 abort. Otherwise output σ xi mod N.  A cid:48  aborts if A ever asks for a signature on any type-1 message, or if A cid:48  outputs a forgery on a type-0 message. The probability with which A cid:48  does not abort is thus   7.3 Probabilistic FDH  149  p def= γqS ·  1−γ ,  which is maximized at p = O 1 qS  by setting γ = qS  qS + 1 . Putting everything together, if A outputs a valid forgery with probability ε then A cid:48  solves its given RSA instance with probability O ε qS  as claimed.  For the generalization of the above to the case of arbitrary clawfree trapdoor  permutations, see the references at the end of this chapter.  7.3 Probabilistic FDH  The result described in the previous section still leaves a gap. Here, we show a probabilistic variant of FDH  called PFDH  that achieves a tight security reduction; namely, this scheme has a proof of security showing that an adversary breaking the scheme with probability εyields an algorithm solving the underlying computational problem with probability ε cid:48  ≈ ε. Here, too, the stronger assumption of clawfree trap- door permutations is needed; Construction 7.3 gives an instantiation of the approach using RSA.  We discuss how to set κ as part of the security proof below.   Construction 7.3: The PFDH-RSA signature scheme  Let GenRSA be as in Chapter 4. Key generation: Compute  N,e,d  ← GenRSA 1k . The public key is  N,e  and the secret key is d. Let H : {0,1}k → Z∗ Signature generation: To compute the signature on a message m, choose random r ← {0,1}κ, compute y := H r cid:107 m , and output the signature  r,yd mod N . Signature veriﬁcation: To verify a signature  r,σ  on a message m, check whether σe ?= H r cid:107 m .  N be a hash function.  The key novelty here is that messages now have multiple valid signatures, and the reduction A cid:48  can use this to its advantage. Let  N,e,y  be the RSA instance given to A cid:48 . In the reduction that follows, A cid:48  gives the public key  N,e  to A and  essen- tially  computes in advance a list of qS signatures for each possible message m.  To avoid exponential running time, A cid:48  determines the list of signatures for a message m only after m is used in a hash query of A.  That is, for each message m the re- duction A cid:48  chooses random r1, . . . ,rqS, sets H m cid:107 ri  = xe i mod N for all i  with the {xi} chosen randomly and independently, except that xi = xi if ri = r j , and ﬁxes the ith signature on m to be  ri,xi . The r1, . . . ,rqS are stored in a list Lm. Using the terminology from the previous section, any hash query H m cid:107 r  with r ∈ Lm is thus   150 7 Full-Domain Hash  and Related  Signature Schemes answered as a type-0 query. A hash query H m cid:107 r  with r  cid:54 ∈ Lm is answered as a type-1 query; that is, A cid:48  sets the answer to be yxe mod N for random x ∈ Z∗ N. We see that A cid:48  can answer all signing queries of A without any possibility of abort. More- over, if A outputs a forgery  r,σ  on a message m, then A cid:48  can output the desired solution to its RSA instance iff r  cid:54 ∈ Lm; we then only need to argue that this happens with sufﬁciently high probability.  We now describe the reduction formally:  Algorithm A cid:48 : The algorithm is given  N,e,y  as input, and its goal is to out- put x such that xe = y mod N.   Run A on the public key  N,e . Store triples  ·,·,·  in a table   When A makes oracle query H m cid:107 r  do:  that is initially empty. 1. If there is an entry  m cid:107 r,x,z  in the table, return z. 2. If list Lm already exists, go to the next step. Otherwise, choose qS values rm,1, . . . ,rm,qS ← {0,1}κ and store them in a list Lm. 3. If r ∈ Lm then let i be such that r = rm,i. Choose random xm,i ∈ Z∗ m,i mod N. Store  m cid:107 r,xm,i,z  in the table. z = yxe mod N. Store  m cid:107 r,x,z  in the table.  4. If r  cid:54 ∈ Lm, choose random x ∈ Z∗  N and return the answer z = xe  N and return the answer  When A requests some message m to be signed for the ith time, let rm,i be the ith value in Lm and compute z = H m cid:107 rm,i  as above if the hash query H m cid:107 rm,i  has not yet been asked. Let  m cid:107 rm,i,xm,i,z  be the corresponding entry in the table. Output the signature  rm,i,xm,i .   If A outputs a forgery  m, r,σ   and r ∈ Lm then abort. Oth- erwise, let  m cid:107 r,x,z  be the corresponding entry of the table, and output σ x mod N.  As noted above, A cid:48  provides a perfect simulation for A, and so if A outputs a forgery with probability ε in a real attack on the signature scheme then it outputs a forgery with the same probability in the above experiment. Conditioned on A’s out- putting a valid forgery  r,σ  on a message m, the reduction A cid:48  succeeds iff r  cid:54 ∈ Lm. Since each element in Lm is chosen uniformly, this occurs with probability exactly p =  1− 2−κ qS. Setting kappa = logqS  and assuming qS ≥ 2 , we have p ≥ 1 4. Overall, then, A cid:48  outputs the correct solution to its given RSA instance with proba- bility at least ε 4, and the reduction is therefore tight.  We remark that the same argument, applied to the same reduction, shows that  PFDH-RSA is in fact strongly unforgeable.   7.4 A Simpler Variant with a Tight Reduction 7.4 A Simpler Variant with a Tight Reduction  151  The PFDH scheme in the previous section uses a random salt, included as part of the signature, each time a message is signed. Here we show a simple technique that maintains the tight reduction while avoiding the salt altogether. As in the previous two sections, the basic idea here can be instantiated using any clawfree trapdoor permutation but we illustrate the idea using the speciﬁc example of RSA.  Construction 7.4: A  deterministic  variant of FDH  N be a hash function.  N. The public key is  N,e,y  and the secret key is d.  Let GenRSA be as in Chapter 4. Key generation: Compute  N,e,d  ← GenRSA 1k  and then choose a random ele- ment y ∈ Z∗ Let H : {0,1}k → Z∗ Signature generation: To compute the signature on a message m, compute z := H m  and choose a random bit b ∈ {0,1}. Then:   If b = 0 output zd mod N.   If b = 1 output  yz d mod N. If a given message is ever signed more than once, the same signature is released each time  see text . Signature veriﬁcation: A signature σ on a message m is accepted as valid if either  σe ?= H m  mod N or σe ?= y· H m  mod N.  In order to obtain a tight security proof, it is essential that only one signature is released for any given message.  Interestingly, however, the scheme remains se- cure [with a non-tight reduction] even if both possible signatures are released.  In practice this could be done, without maintaining state, by including a key K for a pseudorandom function as part of the secret key and then determining the bit b for a given message m as b := FK m .  The reduction here is actually quite simple. Let us call a signature σ on a message m a type-0 signature if σe = H m  mod N, and a type-1 signature if σe = yH m  mod N. For each message m, the reduction A cid:48  chooses a random bit b in advance and then sets H m  in such a way that it can compute a type-b signa- ture for m. If the adversary outputs a forgery, then with probability 1 2 the forged signature will have the opposite type than the signature that is known by A cid:48 . In that case, A cid:48  easily computes a eth root of the value y included as part of the public key.   152  7 Full-Domain Hash  and Related  Signature Schemes   In fact, the scheme is even strongly unforgeable.  We present the reduction here in its entirety:  Algorithm A cid:48 : The algorithm is given  N,e,y  as input, and its goal is to out- put x such that xe = y mod N.   Run A on the public key  N,e,y . Store tuples  ·,·,·,·  in a   When A makes oracle query H m , choose a random bit b ∈  table that is initially empty. {0,1} and a random x ∈ Z∗ 1. If b = 0, return z = xe mod N as the answer to the query. 2. If b = 1, return z = xe y mod N as the answer to the  N and then do:  query.  Store  b,m,x,z  in the table. When A requests the signature on some message m, ﬁnd the entry  b,m,x,z  in the table and output x.   If A outputs a forgery  m,σ , ﬁnd the entry  b,m,x,z  in the  table and then: 1. If b = 0 and σe = yz, then output σ x mod N. 2. If b = 1 and σe = z, then output x σ mod N.  If A forges a signature with probability ε, then A cid:48  solves its given RSA instance with probability ε 2.  7.5 Further Reading  The FDH signature scheme, inspired by existing signature standards, was presented and analyzed by Bellare and Rogaway [9]. The reduction in Section 7.1 is based on their work. The improved analysis in Section 7.2 is due to Coron [28], who later gave evidence [29] that this reduction is the best possible  for FDH . The idea of using randomized hashing to obtain a tight security reduction is due to Bellare and Rogaway [10], who introduced a scheme called PSS; the PFDH scheme shown here was introduced by Coron [29] as a simpliﬁed abstraction of PSS. In the same work, Coron showed how to improve the reduction given in [10] so that a shorter random salt could be used; we have used Coron’s tighter analysis  as applied to PFDH  in Section 7.3. PSS-RSA has since been standardized [95]. The FDH variant presented in Section 7.4 adapts ideas of Katz and Wang [73].  Coron’s analysis in each of the works just cited was speciﬁc to an RSA-based instantiation, and Dodis and Reyzin [41] subsequently showed that the analysis in each case could be extended to any trapdoor clawfree permutation.  The BLS signature scheme appears in [19]. Techniques for hashing onto the ap- propriate group are discussed in that paper as well as more recent work of Coron and Icart [30].   7.5 Further Reading  153  Factoring-based instantiations of FDH-like schemes, resulting in what are among  the most efﬁcient signatures known, are analyzed thoroughly by Bernstein [13].   Chapter 8 Signature Schemes from Identiﬁcation Schemes  There are currently two main techniques for constructing signature schemes in the random oracle model. The ﬁrst technique uses the “full-domain hash” approach, and several schemes designed using this approach were introduced in the previous chapter. Here we cover the second central method, in which signature schemes are derived from so-called identiﬁcation schemes. We note up front that there is a rich literature studying identiﬁcation schemes in their own right; however, we limit our- selves to a discussion of only those aspects that are most directly relevant to the construction of signature schemes.  The chapter is organized as follows. We ﬁrst deﬁne identiﬁcation schemes as well as the notion of passive security for such schemes; although this deﬁnition of security is relatively weak as far as identiﬁcation schemes are concerned, the deﬁnition sufﬁces for our purposes. We then describe and prove secure the Fiat- Shamir transform, which provides a general method for converting  a certain class of  passively secure identiﬁcation schemes to signature schemes in the random ora- cle model. We also discuss a simple transformation of certain identiﬁcation schemes to KMA-secure signature schemes without relying on the random oracle model. Armed with these result, we then devote several sections to identiﬁcation schemes per se: speciﬁcally, we show several identiﬁcation schemes, based on a variety of number-theoretic assumptions, to which the Fiat-Shamir transform can be applied. We remark that many of the ideas explored in this chapter have proven extremely useful in other areas of cryptography, most notably in the context of zero-knowledge proofs. Although we do not describe any of these additional applications, we hope to whet the reader’s appetite and thereby motivate the reader to explore these appli- cations; we also expect that the material covered here will provide a ﬁrm foundation with which to better understand these more advanced topics.  J. Katz, Digital Signatures, DOI 10.1007 978-0-387-27712-7_8,   Springer Science+Business Media, LLC 2010  155   156 8.1 Identiﬁcation Schemes  8 Signature Schemes from Identiﬁcation Schemes  Consider a scenario in which a party P  or prover  wants to convince another party V  or veriﬁer  that P is indeed who he claims to be. One can imagine this arising in many ways: for example, perhaps P and V have never met before, or perhaps P and V are communicating over a network  and not face-to-face  and V wants to ensure that he is not communicating with P rather than an imposter. For the problem to be meaningful there must clearly be some information distinguish- ing P from everyone else; otherwise, anyone could easily impersonate P. In a set- ting in which P wants to be able to convince multiple potential veriﬁers  rather than just a single, ﬁxed veriﬁer , the natural approach is to assume that P establishes a public key pk which is known to any potential veriﬁer; then, using an associated secret key sk generated along with this public key, P can run an instance of an identiﬁcation scheme to convince V that he is the party identiﬁed with pk.  Before deﬁning any notion of security for this setting, let us ﬁrst give a purely syntactic deﬁnition of an identiﬁcation scheme in order to ﬁx some notation. For two interactive protocols A and B, we let b ←  cid:104 A x ,B y  cid:105  denote an execution of A  holding input x  with B  holding input y , with b denoted the ﬁnal output of B at the conclusion of the protocol. Deﬁnition 8.1. An identiﬁcation scheme consists of three probabilistic, polynomial- time algorithms  Gen, P, V   such that:   The randomized key generation algorithm Gen takes as input the security pa- rameter k  in unary . It outputs a pair of keys  pk,sk , where pk is called the public key and sk is called the secret key. We assume the security parameter k is implicit in both pk and sk.   P and V are interactive protocols. The prover algorithm P takes as input a secret key sk and the veriﬁcation algorithm V takes as input a public key pk. At the conclusion of the protocol, V outputs a bit b with b = 1 signifying “accept” and b = 0 signifying “reject.”  We require that for all k and all  pk,sk  output by Gen 1k  we have:  Pr[ cid:104 P sk , V  pk  cid:105  = 1] = 1.  Let us explore next what kind of security an identiﬁcation scheme should achieve. For an identiﬁcation scheme to be useful, a minimal level of security requires that an adversary A who knows the public key pk of some honest prover P should be unable to falsely impersonate P to a veriﬁer. A bit more formally, this would mean that for any efﬁcient adversary A the following should be negligible:   pk,sk  ← Gen 1k  :  cid:104 A pk , V  pk  cid:105  = 1  .  Pr   8.1    cid:104    cid:105   This notion of security is easy to achieve: simply generate the public and secret keys by choosing a random x and setting sk = x and pk = f  x , where f is a one- way function. During an execution of the identiﬁcation protocol, the prover simply   8.1 Identiﬁcation Schemes  157  P x   V  pk   x  cid:45   verify: f  x  ?= pk  Fig. 8.1 A simple identiﬁcation protocol.  sends x and the veriﬁer checks whether pk ?= f  x   see Figure 8.1 . It is easy to see that this both satisﬁes the functional deﬁnition stated earlier as well as the notion of security expressed in Equation  8.1 .  What is wrong with this simple protocol? Well, it clearly does not protect against an eavesdropping adversary who monitors even a single execution of the protocol between P and V . In particular, P sends its entire secret key in the clear; hence, any adversary who eavesdrops on one execution of the protocol obtains the secret key and can impersonate P from that point on.  An identiﬁcation scheme is secure against passive attacks if, informally, it re- mains difﬁcult for an adversary to impersonate P even after eavesdropping on arbitrarily many executions of the protocol between P and an honest veriﬁer V . To give a formal deﬁnition, we introduce an oracle Transsk,pk ·  which, on empty input, returns a transcript  i.e., all messages sent and received  of an honest execu- tion  cid:104 P sk , V  pk  cid:105  of the identiﬁcation scheme. We can thus model each eaves- dropping attempt of an adversary by a query to this oracle. Note that if P, V are randomized, then Trans is randomized as well and so returns a  possibly  different transcript every time it is invoked. We point out also that Trans only returns those messages that would be available to an eavesdropper; in particular, the internal states of the parties  and speciﬁcally their random coins  are not included in the informa- tion returned by Trans. Finally, we stress that this oracle is modeling eavesdropping attacks on honest executions of the protocol  i.e., executions of P with an honest veriﬁer V  ; see further discussion below.  With this in place, we now give the formal deﬁnition.  Deﬁnition 8.2. An identiﬁcation scheme  Gen, P, V   is secure against a passive attack, or passively secure, if the following is negligible for all PPT adversaries A =  A1,A2 :   cid:35    cid:34   Pr   pk,sk  ← Gen 1k  s ← ATranssk,pk ·   pk   1  :  cid:104 A2 s , V  pk  cid:105  = 1  .  In the above deﬁnition we imagine the adversary carrying out an attack in two “stages”: ﬁrst the adversary eavesdrops on the protocol multiple times  this is re- ﬂected by giving A1 access to the Trans oracle , and it eventually outputs some state information s; the adversary, using s, then tries to impersonate P. This deﬁnition is equivalent to the seemingly stronger deﬁnition in which we allow A2 to query the Trans oracle even while it is actively trying to impersonate P  so, for example, if   158  8 Signature Schemes from Identiﬁcation Schemes  P sk   generate I   probabilistically   compute response r  V  pk   I  cid:45   c ← Ω   cid:190  c  r  cid:45  verify using pk,I,c,r  Fig. 8.2 A canonical identiﬁcation scheme  see text .  1,A cid:48   the identiﬁcation scheme is a three-round protocol then A2 might decide to query the Trans oracle between the second and third rounds . To see that security in this case is implied by Deﬁnition 8.2, let A be an adversary strategy  there is clearly no longer any point in separating the adversary into two stages  which makes queries to Trans both before and during its interaction with V , and consider the following strategy A cid:48  =  A cid:48  2  which achieves identical success probability but does not query the Trans oracle during its second stage. Let q = q k  be a  polynomial  upper bound on the number of times A queries the Trans oracle. Then A cid:48  1 makes q queries to Trans to obtain a sequence of transcripts t1, . . . ,tq. The output of A cid:48  1 is s = t1, . . . ,tq. In the second stage, A cid:48  2 s  simply runs A  forwarding messages to from V in the ob- vious way ; whenever A makes its ith query to Trans, this is answered by A cid:48  2 using 2 makes no queries to Trans, yet A cid:48  the transcript ti it has already obtained. Clearly A cid:48  succeeds in impersonating P with exactly the same probability as A does. We will freely use either formulation of Deﬁnition 8.2 in what follows. Before moving on to discuss the connection between identiﬁcation schemes and signature schemes in the following section, we do want to remark that passive se- curity is indeed a rather weak notion of security: for one, it does not protect against adversaries who pose as veriﬁers  and thus interact with P in executions of the identiﬁcation scheme  and can behave dishonestly as they do so, and then subse- quently try to impersonate P to some other  honest  veriﬁer. Security against such attacks, termed active security, as well as security in other, stronger attack models, has received a lot of attention in the literature  see the end of this chapter for some pointers  and such considerations lead to a number of fascinating research direc- tions. Since these stronger deﬁnitions of security are irrelevant for our purposes, though, we do not provide any further details here.  Throughout this chapter, we assume identiﬁcation schemes for which the follow-  ing hold  see Figure 8.2 :   The identiﬁcation protocol itself takes three rounds: i.e., an execution of the pro- tocol consists of an initial message I sent by P, a “challenge” c sent by V , and a ﬁnal response r sent by P.   We assume the challenge c is chosen uniformly from some set Ω.  Technically, Ω = {Ωk} depends on the security parameter k. In general, it may also depend on the public key pk.  This implies that anyone given the transcript of an exe-   8.2 From Identiﬁcation Schemes to Signatures  159  cution of the protocol  along with P’s public key pk , can efﬁciently determine whether V would have accepted following that execution. By way of terminol- ogy, we say that  pk,I,c,r  is an accepting transcript if V would accept an ex- ecution of the protocol resulting in this transcript.  When pk is understood from the context, we simply refer to  I,c,r  as an accepting transcript.    We assume the ﬁst message of the protocol is “non-degenerate” in the following sense: for any secret key sk and any ﬁxed message ˆI, the probability that P sk  outputs I = ˆI as the ﬁrst message is negligible.  This implies, in particular, that the probability that some ﬁrst message I repeats in polynomially many executions of the protocol is negligible.  Note that this can easily be achieved for any 3-round identiﬁcation scheme by simply having P send an additional k-bit random string  which is ignored by V   as part of its ﬁrst message.  We refer to identiﬁcation schemes satisfying the above as canonical.  8.2 From Identiﬁcation Schemes to Signatures  We begin by describing the Fiat-Shamir transform, an extremely general tech- nique for converting passively-secure  canonical  identiﬁcation schemes to signa- ture schemes in the random oracle model. We then isolate two criteria that are sufﬁ- cient  though not necessary  to assure passive security of an identiﬁcation scheme.  Although these criteria are not required to apply the Fiat-Shamir transform, rely- ing on these criteria simpliﬁes matters.  We conclude this section by showing how identiﬁcation schemes satisfying slightly stronger criteria  satisﬁed by all the iden- tiﬁcation schemes that will be presented in the following section  can be converted to KMA-secure signature schemes without invoking the random oracle model.  8.2.1 The Fiat-Shamir Transform  The basic idea behind the Fiat-Shamir transform is to have the prover run an instance of the identiﬁcation protocol by itself, generating the challenge c by applying a hash function H to the ﬁrst message I and then computing an appropriate response r.  Compare Figure 8.3 to Figure 8.2.  If H is modeled as a random oracle, then the challenge c generated by H is “truly random” and so it will be just as difﬁcult for an adversary  who does not know sk  to ﬁnd an accepting transcript  I,H I ,r  as is would be to impersonate the prover in an honest execution of the protocol.  This intuition is formalized in the proof of the theorem that follows.  By including a message m in the input to H, an accepting transcript  I,H I,m ,r  thus constitutes a signature on m. Since H I,m  is redundant  as it can be computed from I and m , the actual signature is just  I,r .  The Fiat-Shamir transform is formalized as Construction 8.1.   160  8 Signature Schemes from Identiﬁcation Schemes  Construction 8.1: The Fiat-Shamir transform  Let Π=  Gen, P, V   be a canonical identiﬁcation scheme where the veriﬁer’s chal- lenges are chosen uniformly from Ω. Let H : {0,1}∗ → Ω be a hash function. Key generation: Run Gen 1k  to generate keys  pk,sk . These are the public and secret keys, respectively. Signature generation: To sign message m using secret key sk, do:   Run the prover algorithm P sk  to generate an initial message I.   Compute c := H I,m .   Compute the appropriate response r to the “challenge” c using P sk . The signature is  I,r . Signature veriﬁcation: To verify the signature  I,r  on message m with respect to public key pk, proceed as follows:   Compute c := H I,m .   Accept the signature iff  pk,I,c,r  is an accepting transcript.  Theorem 8.1. Let Π =  Gen, P, V   be a canonical identiﬁcation scheme that is secure against a passive attack. Then if H is modeled as a random oracle, the sig- nature scheme Π cid:48  resulting from the Fiat-Shamir transform applied to Π is existen- tially unforgeable under an adaptive chosen-message attack.  Proof. The intuition behind the proof is relatively straightforward, although there are some technical details to take care of. We will use an adversary A cid:48  attacking the signature scheme to construct an adversary A attacking the identiﬁcation scheme. Adversary A is given a public key pk as well as access to the oracle Transsk,pk, and interacts with an honest veriﬁer V  recall by the discussion following Deﬁnition 8.2 that we can allow A to access the Trans oracle even during its interaction with V  . To get a feel for the main idea, assume for simplicity that A cid:48  acts in the following  P sk   generate I   probabilistically   I   cid:45   compute response r   cid:190  c := H I,m   the signature is  I,r   Fig. 8.3 “Collapsing” an identiﬁcation scheme using the Fiat-Shamir transform.   8.2 From Identiﬁcation Schemes to Signatures  161  way: it ﬁrst requests signatures on  distinct  messages m1, . . . ,m cid:96 ; next, it makes a single hash query c := H I,m cid:48    where m cid:48   cid:54 ∈ {m1, . . . ,m cid:96 } ; ﬁnally, it outputs the signature forgery  I,r  on the message m cid:48 . To construct A, we must show two things: how it can simulate the signing queries made by A cid:48 , and how it can use the forgery produced by A cid:48  to attack the identiﬁcation scheme Π. For the “toy” example just mentioned these are both quite simple: In response to a request by A cid:48  for a signature on the message mi, we have A proceed as follows: 1. Query Transsk,pk to obtain a transcript  Ii,ci,ri  of an execution of Π. 2. Return the signature  Ii,ri  to A cid:48 .  By doing so, A implicitly sets H Ii,mi  = ci.  For each message mi, the signature  Ii,ri  returned by A is distributed identically to a signature that would be generated using signature scheme Π cid:48 . To see this, compare how the values  Ii,ci,ri  are generated in each case:  An execution of Π 1. Choose random coins ωi. 2. P sk;ωi  generates Ii. 3. V chooses random ci ← Ω. 4. P sk,ci;ωi  outputs ri.  An execution of Π cid:48  1. Choose random coins ωi. 2. P sk;ωi  generates Ii. 3. ci := H Ii,mi . 4. P sk,ci;ωi  outputs ri.  The only difference is in step 3; however, since H is a random oracle, the ci’s are dis- tributed identically in the two experiments.  Though there is no randomness explicit in step 3 of the execution of Π cid:48 , the randomness is implicit in the initial, random selection of H from the set of all functions.  We conclude that, for this particular A cid:48 , our adversary A is able to perfectly simulate all signing queries of A cid:48 . We next describe how A can use the forgery of A cid:48  to successfully impersonate P. When A cid:48  makes its hash query H I,m cid:48  , then A simply sends the initial message I to the veriﬁer V . When V responds with a challenge c, then A responds to the hash query of A cid:48  with exactly this value. Finally, when A cid:48  outputs the signature forgery  I,r  on message m cid:48 , the response r is forwarded by A to V ; see Figure 8.4. Note that  A cid:48  pk   A pk   V  pk   query H I,m cid:48    cid:45   c   cid:190  output forgery  I,r  on m cid:48   cid:45   I  cid:45    cid:190  c  r  cid:45   Fig. 8.4 A uses A cid:48  to impersonate the honest prover P.   162  8 Signature Schemes from Identiﬁcation Schemes   1  c is uniformly distributed in Ω, exactly as the output of a random oracle should be; and  2  if Vrfypk m cid:48 , I,r   = 1 then  I,H I,m cid:48  ,r  is an accepting transcript and so  cid:104 A, V  pk  cid:105  = 1; that is, A succeeds in impersonating P exactly when A cid:48  outputs a valid forgery. We now generalize these ideas to construct an adversary A from any forger A cid:48 . Among the difﬁculties we must now deal with are that A does not know which hash query of A cid:48  will be used by A cid:48  to construct its forgery; also, A cid:48  may interleave its hash and signing queries in an arbitrary fashion. So, let A cid:48  be a PPT adversary attacking Π cid:48 . We make a few simplifying assump- tions without any loss of generality. First, we assume that A cid:48  makes any given hash query only once. For convenience, when a signature  I,r  on a message m is given to A cid:48  we also include the value H I,m ; we may therefore assume that A cid:48  never queries H I,m  after receiving such a signature. We also require that if A cid:48  outputs the forgery  I,r  on a message m, then A cid:48  had previously asked the hash query H I,m . We will call this unique such query the special hash query. Let qH be a polynomial upper bound on the number of hash queries made by A cid:48 .  We now describe out PPT adversary A attacking Π. Adversary A is given as input a public key pk, has access to the oracle Transsk,pk, and interacts with a veriﬁer V . The ﬁrst thing A does is guess at random an index i ← {1, . . . ,qH}; this represents a guess as to the index of the special hash query  if any  that will be made by A cid:48 . Adversary A then runs A cid:48  pk , answering the oracle queries of A cid:48  as follows Hash query H I,m : There are two cases:   If this is the ith query to H, then A is  implicitly  guessing that this query will be the special hash query. A sends I to the honest veriﬁer V with which it is interacting, and receives in return a challenge c. Then A returns c as the answer to this hash query. We will refer to this hash query as the guessed query.    If this is not the ith hash query, then A simply chooses a random value c ← Ω  and returns c as the answer to this query.  In either case, the value returned to A cid:48  is uniformly distributed in Ω as required. Signing query Signsk m : A queries its oracle Transsk,pk and obtains in return a transcript  I,c,r . If the hash value H I,m  was previously deﬁned, then A aborts. If not, then A returns the signature  I,r  to A cid:48   along with the hash value H I,m  = c . If A cid:48  outputs a valid forgery   ˆI, ˆr  on a message ˆm, then A checks whether the guessed query H I,m  is equal to the special query H  ˆI, ˆm . If not, then A aborts. Otherwise, A sends ˆr to its veriﬁer V . Observe that as long as A does not abort during its execution, and its guess for the special query is correct, A succeeds in impersonating the honest prover. This is so because   When the guessed query is equal to the special query, this means that A has sent     ˆI, ˆr  is a valid signature on ˆm exactly if   ˆI,c, ˆr  is an accepting transcript.  ˆI to its veriﬁer, and received in return the challenge c = H  ˆI, ˆm .   8.2 From Identiﬁcation Schemes to Signatures  163  A aborts if, in the process of answering a signing query for the message m, it happens that A obtains a transcript  I,c,r  for which the hash query H I,m  was already made by A cid:48 . Since the identiﬁcation protocol Π is assumed to be canonical  and so the ﬁrst message of the protocol is non-degenerate , this event occurs with only negligible probability. Assuming A did not abort during its execution, it provides a perfect simulation for A cid:48 . Moreover, A’s guess for the special query is correct with probability 1 qH  and this event is independent of the event that A cid:48  outputs a valid forgery . We con- clude that if A cid:48  succeeds in outputting a valid forgery with probability ε cid:48 , then A succeeds in its impersonation attempt with probability exactly ε=  ε cid:48 −µ k   q k  for some negligible function µ. Since identiﬁcation scheme Π is secure by assump- tion, this completes the proof.  It is easy to see that, in general, the signature scheme Π cid:48  need not be strongly unforgeable. For example, say Π is a canonical identiﬁcation scheme having the property that  pk,I,c,r0  is an accepting transcript iff  pk,I,c,r1  is; i.e., the last bit of P’s response is ignored by V . Then in the derived scheme Π cid:48 , a valid signature  I,rb  on a message m can be changed to the different valid signature  I,r¯b  on the same message. On the other hand, it can be shown  via a modiﬁcation of the above proof  that this sort of attack is the only possibility. Thus, if Π has the property that for any pk,I,c there is  at most  a single r so that  pk,I,c,r  is an accepting transcript, then the derived scheme Π cid:48  is strongly unforgeable under an adaptive chosen-message attack.  A second observation, which proves quite useful in practice, is that for some spe- ciﬁc identiﬁcation schemes a more efﬁcient variant of the Fiat-Shamir transform is possible. Speciﬁcally, say a canonical identiﬁcation scheme Π has the property that given any public key pk, any challenge c, and any response r, it is possible to deter- ministically compute  in polynomial time  an initial message I such that  pk,I,c,r  is an accepting transcript. Then we can modify the signature scheme Π cid:48  so that the signature is  c,r  rather than  I,r .  Veriﬁcation is done in the natural way; see Construction 8.2.  Since signatures computed according to this variant approach can be converted to signatures computed using the approach of Construction 8.1, and vice versa, existential unforgeability of this variant follows.  Note, however, that for strong unforgeability of this variant an additional assumption on the identi- ﬁcation protocol is needed beyond the assumption required for strong unforgeability for Construction 8.1.   8.2.2 Two Useful Criteria  In this section we will explore two useful criteria for identiﬁcation schemes that, if satisﬁed, imply passive security.  We continue to assume canonical identiﬁcation schemes, although most of what we say can be appropriately generalized if this is not the case.  The criteria given here are sufﬁcient for passive security, but not nec- essary. Nevertheless, introducing these criteria has a three-fold beneﬁt:  1  many   164  8 Signature Schemes from Identiﬁcation Schemes  Construction 8.2: The Fiat-Shamir transform  variant   Key generation: As before. Signature generation: To sign message m using secret key sk, do:   Run the prover algorithm P sk  to generate an initial message I.   Compute c := H I,m .   Compute the appropriate response r to the “challenge” c using P sk . The signature is  c,r . Signature veriﬁcation: To verify the signature  c,r  on message m with respect to public key pk, do:   Deterministically compute I such that  pk,I,c,r  is an accepting transcript. If no  such A exists, reject.    Accept the signature c ?= H I,m .   Accept the signature iff  pk,I,c,r  is an accepting transcript.  identiﬁcation schemes satisfy these criteria, and as such it is often convenient to be aware of this fact when considering other applications of those schemes;  2  intro- ducing these criteria helps simplify and unify proofs of security for the identiﬁcation schemes we will see later in the chapter  as well as many others that have been pro- posed in the literature ;  3  as noted earlier in this chapter, the criteria deﬁned here are extremely useful in other areas of cryptography  outside the realm of identiﬁca- tion schemes , and so there is an independent beneﬁt to studying them.  Informally, the two criteria are as follows:  Honest-veriﬁer zero knowledge  HVZK  There is an efﬁcient probabilistic al- gorithm Sim that takes a public key pk and outputs transcripts that are indis- tinguishable from transcripts of honest executions of the identiﬁcation protocol. While computational indistinguishability sufﬁces, we remark that all the identi- ﬁcation schemes considered in this chapter satisfy perfect HVZK whereby the transcripts output by Sim are identically distributed to the transcripts of real exe- cutions  cid:104 P SK , V  pk  cid:105 .  Special soundness Given public key pk  but not the associated secret key sk , it is computationally infeasible to output two accepting transcripts  I,c1,r1 ,  I,c2,r2  with the same ﬁrst message but c1  cid:54 = c2. Roughly speaking  we will see a more precise formulation of this below , this implies that for any PPT ad- versary trying to impersonate P the following holds: for any initial message I of the adversary’s choosing, the adversary will only be able to respond correctly to at most one challenge  and so the adversary’s probability of successful imper- sonation is at most Ω−1 .  We now make these ideas more formal.   8.2 From Identiﬁcation Schemes to Signatures  165  Deﬁnition 8.3. An identiﬁcation protocol Π is honest-veriﬁer zero knowledge  HVZK  if there exists a PPT algorithm Sim such that the following distributions are computationally indistinguishable:   pk,sk  ← Gen 1k  :  sk, pk, Sim pk   and   pk,sk  ← Gen 1k  :  sk, pk, Transsk,pk  .  If the above distributions are identical, we say Π is perfect honest-veriﬁer zero knowledge.  By a standard hybrid argument,1 if Π is honest-veriﬁer zero knowledge  resp., perfect honest-veriﬁer zero knowledge  then the following is negligible  resp., zero  for any PPT adversary A:   cid:179   cid:161    cid:180  cid:111   cid:162  cid:111    cid:105    cid:110   cid:110    cid:104    cid:175  cid:175  cid:175 Pr   cid:104    pk,sk  ← Gen 1k  : ATranssk,pk ·  pk  = 1 − Pr   pk,sk  ← Gen 1k  : ASim pk  pk  = 1   cid:105  cid:175  cid:175  cid:175    where Sim is the algorithm guaranteed by Deﬁnition 8.3 . Of course, one could simply deﬁne honest-veriﬁer zero knowledge via the above equation  which is, in general, weaker than Deﬁnition 8.3 ; however, it will be much easier to prove honest-veriﬁer zero knowledge using Deﬁnition 8.3.  Deﬁnition 8.4. An identiﬁcation protocol Π satisﬁes special soundness if the fol- lowing is negligible for all PPT algorithms A:    pk,sk  ← Gen 1k    I,c1,r1,c2,r2  ← A pk  :  Pr   .  c1  cid:54 = c2 and   pk,I,c1,r1 ,  pk,I,c2,r2  are both accepting transcripts  The following result is quite natural, although the proof is a bit technical.  Theorem 8.2. Assume canonical identiﬁcation protocol Π is honest-veriﬁer zero knowledge and satisﬁes special soundness. Then for any PPT adversary A =  A1,A2  we have:   cid:35    cid:34   Pr   pk,sk  ← Gen 1k  s ← ATranssk,pk ·   pk   1  :  cid:104 A2 s , V  pk  cid:105  = 1  −Ωk−1 ≤ µ k   for some negligible function µ · . In particular, if Ωk = ω poly k   then Π is secure against a passive attack.  1 The proof relies on the fact that, in Deﬁnition 8.3, indistinguishability holds even given the real secret key sk. This is one reason we formulated the deﬁnition as we did, even though in the literature the deﬁnition is often formulated as requiring indistinguishability of the transcripts only.   166  8 Signature Schemes from Identiﬁcation Schemes  The theorem can be modiﬁed appropriately for the case when the space of chal-  lenges Ω depends on the public key.  Proof. Given a PPT adversary A attacking Π in an impersonation attack, we con- struct an algorithm B that violates special soundness.  B, as described, runs in ex- pected polynomial time; using standard techniques, it can be modiﬁed to run in strict polynomial time.  The intuition is simple: B, given a public key pk, runs A1 pk . The Trans queries of A1 are simulated by B using the procedure Sim for simulating exe- cutions of protocol Π  such a Sim exists since Π is honest-veriﬁer zero knowledge . When A1 is done, it passes some state s to A2 that, informally, enables A2 to imper- sonate P with “high” probability. Now, B runs A2 with B playing the role of the veriﬁer. The intuition here is that since A2 succeeds with “high” probability  over random choice of challenge c ∈ Ωk , then with high probability B will be able to ﬁnd two distinct challenges c1,c2 for which A2 answers correctly on the same ﬁrst message I  note A2’s initial message I is ﬁxed before the challenge is sent by B . This exactly violates special soundness. See Figure 8.5 for a high-level depiction of the main idea.  A2 s   B  I  cid:45   c1 ← Ωk   cid:190  c1  r1  cid:45    cid:190  c2  r2  cid:45   if  I,c1,r1  is an accepting transcript: rewind A2 c2 ← Ωk  if  I,c2,r2  is an accepting transcript and c1  cid:54 = c2: output  I,c1,r1,c2,r2   Fig. 8.5 Intuition as to how B violates special soundness using A2.  For technical reasons, however, the proof is a bit more complicated. We formally deﬁne B in two stages. The ﬁrst stage of B exactly follows the intuition outlined above, resulting in A1 outputting state s that is then passed to A2:  Algorithm B: The algorithm is given a public key pk.   Run A1 pk .   To respond to a query Transsk,pk ·  made by A1, run Sim pk   and give the result to A1.   8.2 From Identiﬁcation Schemes to Signatures  167    When A1 is done, it outputs state s. Run procedure Extract  below  using A2 s .   If Extract outputs “success”, then output  I,c1,r1,c2,r2  with c1  cid:54 = c2 and  I,c1,r1 ,  I,c2,r2  both accepting tran- scripts.  The second stage of B, which we have called Extract above, uses A2 s  in an at- tempt to compute two accepting transcripts  I,c1,r1  and  I,c2,r2  with c1  cid:54 = c2. In our description of the Extract algorithm, we implicitly assume that A2 is determin- istic; this is without loss of generality, as any random coins for A2 could just as well be included in the state s. Thus, we may view A2 s  as follows: ﬁrst, A2 s  outputs some initial message I; next, for any challenge c ∈ Ωk, running A2 s,c  results in some response r.  Algorithm Extract: This algorithm interacts with A2 s .   Run A2 s , which outputs some initial message I.   Choose c1 ← Ωk, and compute r1 := A2 s;c1 .   If  I,c1,r1  is not an accepting transcript, then output “fail” and abort   Otherwise, for c cid:48  ∈ Ωk \{c1} do: – Choose c2 ← Ωk \{c1} and compute r2 := A2 s;c2 . – Also compute r cid:48  := A2 s;c cid:48  . – If either  I,c2,r2  or  I,c cid:48 ,r cid:48   are accepting, output “suc-  cess” and stop.    Output “fail” and abort.  We analyze the behavior of B in the following claims.  Claim. B runs in expected polynomial time.  Proof. It is clear that the main routine of B runs in strict polynomial time  assuming A1 does . What remains is to analyze the running time of Extract. Fix the algorithm A2 s  that Extract interacts with; we show that, regardless of the behavior of A2 s  the number of times Extract runs A2 is polynomial in expectation.  Thus, since A2 runs in strict polynomial time the overall running time of Extract is polynomial in expectation.  It sufﬁces to show that the expected number of iterations of the inner for loop is polynomial. Fix any s, and let p be the number of challenges c ∈ Ωk for which A2 s  responds correctly  i.e., for which  A2 s ,c,A2 s,c   is an accepting transcript . Then the probability that A2 s  succeeds in impersonating the prover is exactly p Ωk, and so Extract enters the for loop with exactly this probability. Assuming Extract enters the for loop, there are two possibilities: Case 1: p = 1. In this case, Extract will never output “success” but will instead run the maximum Ωk−1 iterations of the for loop. But since it enters the for loop with probability only 1 Ωk, the expected number of iterations of the for loop is only:   168  8 Signature Schemes from Identiﬁcation Schemes  Case 2: p > 1. Then there are p− 1 > 0 challenges c2 ∈ Ωk \{c1} for which A2 s  responds correctly. The probability of selecting such a challenge, in any given it- eration of the for loop, is  p − 1   Ωk − 1  >  p − 1  Ωk. It follows that the expected number of iterations of the for loop is at most Ωk  p− 1 . Since Extract only enters the for loop with probability p Ωk, the expected number of iterations of the for loop, overall, is at most:  1  Ωk ·  Ωk− 1  < 1.  p  Ωk · Ωk p− 1  ≤ 2.  This completes the proof of the claim.  The next claim shows that if A2 s  succeeds with high probability  over random choice of challenge c ∈ Ωk , then Extract outputs “success” with similarly high probability.  Claim. Fix A2 and s and let  Pr[ cid:104 A2 s , V  cid:105  = 1] = ρ   the above probability is over V ’s choice of challenge only . Then ExtractA2 s  out- puts “success” with probability at least ρ−Ωk−1. Proof. When ρ≤ Ω−1 the claim is trivially true. For the case of ρ > Ωk−1 we show something stronger: that Extract outputs “success” with probability exactly ρ. To see this, note that Extract enters the for loop with probability exactly ρ. But when ρ> Ωk−1, there are at least two challenges  and hence at least one challenge c2 ∈ Ωk \ {c1}  for which A2 s  responds correctly. Since Extract does not exit the for loop until all challenges in Ωk \{c1} have been tried  to see whether A2 s  responds correctly , it is clear that Extract outputs “success” in this case whenever it enters the for loop. It follows that if ρ > Ωk−1, then Extract outputs “success” with probability exactly ρ.   cid:34   To complete the proof, we show that if  pk,sk  ← Gen 1k  s ← ATranssk,pk ·   pk   Adv k  def= Pr  1   cid:35   :  cid:104 A2 s , V  pk  cid:105  = 1  −Ωk−1  is not negligible, then the probability that B outputs “success”  and hence violates special soundness  is non-negligible as well. Special soundness of Π then implies that Adv must be negligible, as desired.2  2 Technically speaking, we are not quite done since B runs in expected polynomial time rather than strict polynomial time. But the same ideas as in footnote 6 of Chapter 4 apply here as well.    cid:34    cid:34   8.2 From Identiﬁcation Schemes to Signatures  So, assume Adv is not negligible, and deﬁne  Adv cid:48  k  def= Pr   pk,sk  ← Gen 1k  s ← ASim pk   pk   1  :  cid:104 A2 s , V  pk  cid:105  = 1   the difference is that we have replaced A1’s access to Trans with access to Sim . Since Π is honest-veriﬁer zero knowledge, it must be that negligible  see also the remark following Deﬁnition 8.3  and hence Adv cid:48  is not neg- ligible. Next, note that we may write  Adv cid:48  k  = Exp   pk,sk  ← Gen 1k  s ← ASim pk   pk   1  : Pr   cid:104 A2 s , V  cid:105  = 1  −Ωk−1,   cid:104   where the outer expectation is taken over an experiment that is identical to the ﬁrst phase of B, and the inner probability is taken over random choice of the veriﬁer’s challenge. Using Claim 8.2.2 we thus have:  169  −Ωk−1   cid:35   cid:175  cid:175 Adv k − Adv cid:48  k   cid:175  cid:175  is  cid:105  cid:35    cid:34   cid:34   cid:34   = Exp  ≥ Exp  = Exp = Adv cid:48  k .  Pr[B outputs “success”]  1   pk,sk  ← Gen 1k  s ← ASim pk   pk   pk,sk  ← Gen 1k  s ← ASim pk   pk   pk,sk  ← Gen 1k  s ← ASim pk   pk   1  1   cid:104   cid:104   : Pr[Extract outputs “success”]  : Pr   cid:104 A2 s , V  cid:105  = 1  −Ωk−1  : Pr   cid:104 A2 s , V  cid:105  = 1  −Ωk−1   cid:105   cid:105  cid:35    cid:35   cid:35   We thus see that if Adv cid:48  is not negligible, then B violates special soundness with non-negligible probability. This completes the proof of the theorem.  An identiﬁcation protocol satisfying the criteria of Theorem 8.2 is said to achieve  soundness 1 Ωk.  8.2.3 One-Time Signature Schemes without Random Oracles  In the following section we will demonstrate several identiﬁcation protocols that are honest-veriﬁer zero knowledge and also satisfy special soundness. By Theorem 8.2, this implies passive security for each of those protocols and so the Fiat-Shamir trans- form can be applied to each of them to obtain a construction of a CMA-secure signa- ture scheme in the random oracle model. Here, we identify here a slight strengthen- ing of the HVZK condition and then show how this  along with special soundness    170  8 Signature Schemes from Identiﬁcation Schemes  gives a simple construction of a one-time KMA-secure signature scheme without relying on random oracles.  We ﬁrst describe the construction. The public key of the signature scheme is sim- ply a public key for the underlying identiﬁcation scheme, along with an initial ﬁrst message I. The message m ∈ Ω to be signed is interpreted as a “challenge”; to sign this message, the signer simply computes the appropriate response r.  Veriﬁcation is done in the natural way.  See Construction 8.3 for a formal speciﬁcation.  Construction 8.3: One-time signatures from canonical identiﬁcation schemes  Let Π =  Gen, P, V   be a canonical identiﬁcation scheme with challenge space Ω = {Ωk}.  If Ω depends on the public key, the following scheme can be modiﬁed appropriately.  Key generation: Run Gen 1k  to generate keys  pk,sk . Then run the prover algo- rithm P sk  to generate an initial message I. The public key is  pk,I  and the secret key includes sk as well as the random coins used to generate I. Signature generation: To sign message m ∈ Ω, interpret m ∈ Ω as a challenge and compute the appropriate response r using the prover algorithm, secret key sk, and random coins used to generate I  which are part of the signer’s secret key . The signature is r. Signature veriﬁcation: To verify signature r on message m with respect to public key  pk,I , simply check whether  pk,I,m,r  is an accepting transcript.  To analyze the security of this construction, we introduce a slightly stronger vari- ant of HVZK called special HVZK. Recall that HVZK requires the existence of a simulator Sim that, on input a public key pk, outputs transcripts indistinguishable from transcripts of real executions of the identiﬁcation protocol between P and V . Special HVZK, roughly speaking, requires this simulator to work in a speciﬁc way: namely, Sim additionally takes as input a challenge c ∈ Ω and outputs a transcript in which c is the challenge. We deﬁne this notion formally only for the case in which the resulting transcript is perfectly indistinguishable from real transcripts.  Deﬁnition 8.5. Identiﬁcation protocol Πis special honest-veriﬁer zero knowledge if there exists a PPT algorithm Sim such that the following distributions are identical:   cid:189   cid:189    cid:179    cid:180  cid:190   cid:190    pk,sk  ← Gen 1k ;c ← Ω;   I,r  ← Sim pk,c   :  sk, pk,I,c,r   pk,sk  ← Gen 1k ;c ← Ω;  I,s  ← P sk ; r ← P s,c  :  sk, pk,I,c,r   .  and   In the above, s represents the prover’s state.    8.3 Some Secure Identiﬁcation Schemes  171  Note that if Π is special HVZK then it is also HVZK; given a special-HVZK sim- ulator Sim we can construct an HVZK simulator Sim cid:48  by simply choosing random c ∈ Ω and then running Sim pk,c . We remark also that, for our application here, it would sufﬁce in Deﬁnition 8.5 for indistinguishability to hold without being given sk  but in that case the deﬁnition would be incomparable to HVZK .  Theorem 8.3. If Π is special honest-veriﬁer zero knowledge and satisﬁes special soundness, then Construction 8.3 yields a one-time signature scheme that is existen- tially unforgeable under a known-message attack.  Proof. The proof is straightforward, and so we only sketch it here. Given a PPT ad- versary A attacking the signature scheme, we construct a PPT adversary A cid:48  violating special soundness. Adversary A cid:48 , given as input a public key pk, works as follows: ﬁrst, it runs A to obtain message m  recall that in a known-message attack A must decide on its message before obtaining the public key . Then, it runs Sim pk,c  to obtain  I,r . Finally, it returns to A the public key  pk,I  and the signature r on the message m. Note that both the public key and the signature are distributed exactly as in a real experiment involving A and the signer. If A outputs a valid signature forgery r cid:48  on a message m cid:48   cid:54 = m, then A cid:48  exactly  violates special soundness of Π. The theorem follows.  Although the level of security obtained using Construction 8.3 is relatively weak, schemes designed using this methodology can be very efﬁcient and thus highly use- ful, e.g., for application in Construction 1.2.  We conclude this section with two remarks on the proof:    As in the case for signature schemes resulting from the Fiat-Shamir transform, signatures built using Construction 8.3 need not be strongly unforgeable. How- ever, if Π has the property that for any pk,I,c there is  at most  a single r so that  pk,I,c,r  is an accepting transcript, then applying Construction 8.3 does yield a strongly unforgeable scheme.   It sufﬁces for the identiﬁcation protocol to be HVZK  rather than special HVZK  in order to prove security of signatures resulting from Construction 8.3 under a random message attack.  8.3 Some Secure Identiﬁcation Schemes  In order to apply the Fiat-Shamir transform and obtain concrete signature schemes, it remains only to show examples of canonical identiﬁcation protocols that are both honest-veriﬁer zero knowledge and satisfy special soundness  and also have expo- nentially large challenge spaces Ω . In fact, all the identiﬁcation schemes we show will satisfy special HVZK and so Construction 8.3 can also be applied. On parallel repetition. Before presenting any concrete examples of protocols, a brief remark is in order regarding the parallel composition of identiﬁcation schemes.   172  8 Signature Schemes from Identiﬁcation Schemes  To be precise, let Π =  Gen, P, V   be an identiﬁcation protocol, let t = t k  be polynomial, and consider the protocol Πt =  Gen, Pt, V t  in which P cid:48  and V  cid:48  are obtained via t-fold  parallel  repetition of P and V , respectively.  Note that Gen is unchanged, and so Pt and V t execute parallel repetitions with respect to a single public key output by Gen.  It is not hard to see that if Π is  special  honest-veriﬁer zero knowledge and satisﬁes special soundness, then Πt does as well. If the chal- lenge space for Π is Ωk, then the challenge space for Πt is Ωt k  . We conclude  via application of Theorem 8.2  that if Π achieves soundness ε k  then Πt achieves soundness ε k t k . Parallel repetition therefore provides an exponential improve- ment to the soundness. A corollary is that, at least from a theoretical perspective, it sufﬁces to design protocols achieving constant soundness  say, soundness 1 2 .  The above arguments extend to the case when the same protocol is repeated in parallel using different public keys, and also to the more general case when different protocols are executed in parallel.  k  In the sections that follow, we show a number of identiﬁcation protocols satis- fying the criteria required by Theorem 8.2. Many examples of such protocols have been proposed in the literature, and it is not our intention to provide an exhaustive survey here. Instead, we will focus on a few well-known, representative examples. We remark also that various efﬁciency improvements for the schemes we present are possible; our aim is to present the schemes in as straightforward and as simple a manner as possible.  8.3.1 The Fiat-Shamir Scheme  The ﬁrst scheme we describe is also one of the ﬁrst to have been proposed and proven secure. We start by presenting a “basic” version, due to Goldwasser, Micali, and Rackoff, and then discuss in detail a more efﬁcient variation given by Fiat and Shamir. Both protocols rely for their security on the hardness of computing square roots modulo N  where N is a product of two primes ; by Theorem 2.2, this is equivalent to basing security on the hardness of factoring.  The basic scheme is given as Construction 8.4. One can easily check that the ver- iﬁer always accepts an honest execution of the protocol. We will prove next that, as- suming the hardness of factoring, the protocol is honest-veriﬁer zero knowledge and achieves special soundness; we conclude that the identiﬁcation scheme has sound- ness 1 2. Repeating the protocol sufﬁciently-many times in parallel  see the earlier discussion  allows us to achieve any desired level of security.  Theorem 8.4. The Goldwasser-Micali-Rackoff identiﬁcation scheme is  perfect  special honest-veriﬁer zero knowledge. Furthermore, if factoring is hard relative to GenModulus then it also satisﬁes special soundness.  Proof. We ﬁrst prove that the Goldwasser-Micali-Rackoff  GMR  scheme is  per- fect  special honest-veriﬁer zero knowledge. Consider the following algorithm Sim:   8.3 Some Secure Identiﬁcation Schemes  173  Construction 8.4: The Goldwasser-Micali-Rackoff identiﬁcation scheme  Let GenModulus be a PPT algorithm that, on input 1k, outputs a modulus N along with two  distinct  k-bit primes p,q with N = pq. Key generation: Run  N, p,q  ← GenModulus 1k . Choose a random x ∈ Z∗ then set y := x2 mod N. The public key is  N,y  and the secret key is x. Prover’s initial message: Choose s ← Z∗ Veriﬁer’s challenge: Choose and send challenge c ← {0,1}. Prover’s response: Send r := xc·s mod N.  Here, x is taken from the secret key and s is the randomness used to generate the ﬁrst-round message.  Acceptance criterion: Accept transcript  I,c,r  with respect to the public key  N,y  if either  1  c = 0 and r2 = I mod N, or  2  c = 1 and r2 = y· I mod N.  It is important also to verify that I,r ∈ Z∗  N and send I := s2 mod N.  N and, in particular, I  cid:54 = 0.   N and  Algorithm Sim: The algorithm is given a public key  N,y  in addition to a chal- lenge c ∈ {0,1}.   Choose r ← Z∗ N.   Output the transcript  r2 yc mod N,c,r .  To see that this perfectly simulates a real execution of the protocol for any given public key  N,y , any3 secret key x, and any given challenge c we look — in each case — at the distribution of r  conditioned on the given values , and then at the distribution of I conditioned on r  and the given values . In a real execution of the protocol, r is uniformly distributed in Z∗ N regardless of the choice of c.  When c = 0 then r = s and so this is clear; when c = 1 then r = sx mod N, but since s is uniform sx is uniform for any x.  Then I is the unique value satisfying I = r2 yc mod N. In a simulated transcript, r and I are chosen from identical distributions by construction. Special soundness follows easily from the following observation: given two ac- cepting transcripts  I,0,r0  and  I,1,r1  with respect to some public key  N,y , it is possible to efﬁciently compute a square root of y modulo N.  This implies spe- cial soundness, since then any PPT algorithm violating special soundness with non- negligible probability can be used to compute square roots of random elements of Z∗ N with non-negligible probability for N output by GenModulus. By Theorem 2.2, this contradicts the assumed hardness of factoring relative to GenModulus.  To see this, note simply that by deﬁnition of the acceptance criterion we have  3 Recall that each public key has four possible associated secret keys.  0 = I = r2 r2  1 y mod N   8 Signature Schemes from Identiﬁcation Schemes  174 with r0,r1 ∈ Z∗  N, and so r1 r0 mod N is a square root of y modulo N.  As we have already noted, by running the GMR protocol in parallel k times we can amplify the soundness from 1 2 to 2−k. Better communication complexity  at the expense of a longer public key  can be achieved using an approach due to Fiat and Shamir; see Construction 8.5  and also Figure 8.6 .  Construction 8.5: The Fiat-Shamir identiﬁcation scheme  Let GenModulus be a PPT algorithm that, on input 1k, outputs a modulus N along with two  distinct  k-bit primes p,q with N = pq. Key generation: Compute  N, p,q  ← GenModulus 1k . Then choose x1, . . . ,xk ← Z∗ N and set yi := x2 i mod N for all i. The public key is  N,y1, . . . ,yk  and the secret key is  x1, . . . ,xk . Prover’s initial message: Choose s ← Z∗ Veriﬁer’s challenge: Choose and send challenge c ← {0,1}k. Prover’s response: Parse the challenge c as a sequence of bits c1, . . . ,ck. Send  N and send I := s2 mod N.  r := s· k∏  i=1  i mod N = s· ∏ xci ici=1  xi mod N,  where the xi are from the secret key and s is the randomness used in the ﬁrst round. Acceptance criterion: Accept transcript  I,c,r   where c = c1···ck  with respect to the public key  N,y1, . . . ,yk  iff  r2 ?= I · ∏ ici=1  It is important also to verify that I,r ∈ Z∗  yi mod N.  N and, in particular, I  cid:54 = 0.   It is not difﬁcult to verify that the honest prover is always accepted since, in an  honest execution:   cid:33 2   cid:195  s· ∏ ici=1  xi  r2 =  = s2 · ∏ ici=1  i = I · ∏ x2 ici=1  yi mod N.  Theorem 8.5. The Fiat-Shamir identiﬁcation scheme is  perfect  special honest- veriﬁer zero knowledge. Furthermore, if factoring is hard relative to GenModulus then it also satisﬁes special soundness. Proof. We ﬁrst prove that the scheme is perfect special honest-veriﬁer zero knowl- edge. Consider the following algorithm Sim:   8.3 Some Secure Identiﬁcation Schemes  175  P N,x1, . . . ,xk   s ← Z∗ N I := s2 mod N  parse c as c1···ck r := s· ∏ici=1 xi mod N  V  N,y1, . . . ,yk   I  cid:45   c ← {0,1}k   cid:190  c  r  cid:45  check whether  r2 ?= I · ∏ici=1 yi mod N  Fig. 8.6 An execution of the Fiat-Shamir identiﬁcation scheme.  Algorithm Sim: The algorithm is given a public key  N,y1, . . . ,yk  and a chal- lenge c = c1···ck ∈ {0,1}k.   Choose r ← Z∗ N. ∏ici=1 yi    Set I := r2 · cid:161    cid:162 −1 mod N.    Output the transcript  I,c,r .  To see that this perfectly simulates a real execution of the protocol for any public key  N,y1, . . . ,yk , any secret key  x1, . . . ,xk , and any challenge c we look — in each case — at the distribution of r conditioned on the given values, and then at the distribution of I conditioned on the given values and r. In an honest execution of the protocol, r = s· ∏ici=1 xi mod N for a uniformly distributed value s ∈ Z∗ N and so r is uniform regardless of c and  x1, . . . ,xk . Then I is the unique value satisfying   cid:162 −1 mod N. In simulated transcripts r and I are distributed in the  I = r2 · cid:161   ∏ici=1 yi  same manner, by construction.  Special soundness is a bit more involved.4 We will show how to use any PPT algo- rithm which violates special soundness to factor moduli N output by GenModulus. Assume a PPT algorithm A for which N ← GenModulus 1k ; x1, . . . ,xk ← Z∗ N; ∀i : yi := x2 i mod N; pk =  N,y1, . . . ,yk ;  I,c1,r1,c2,r2  ← A pk    pk,I,c1,r1 ,  pk,I,c2,r2  are both accepting transcripts  c1  cid:54 = c2 and      Pr  :  is not negligible. Consider the following PPT algorithm F which takes as input a modulus N output by GenModulus: algorithm F ﬁrst chooses random values x1, . . . ,xk ← Z∗ i mod N for all i. Next, F runs A on input 4 In contrast to the GMR scheme, a violation of special soundness here does not directly enable computation of the prover’s secret key; for this reason, the proof of special soundness is somewhat more involved.  N, and then sets yi := x2   176  8 Signature Schemes from Identiﬁcation Schemes   N,y1, . . . ,yk . Note that the input provided to A by F is distributed identically to a real public key in the Fiat-Shamir scheme, and so A violates special soundness with the same probability. Assuming A outputs  I,c1,r1,c2,r2  with c1  cid:54 = c2 and where  I,c1,r1 ,  A,c2,r2  are both accepting transcripts, F proceeds as follows. By deﬁnition of the acceptance criterion,  where c1,i  resp., c2,i  refers to the ith bit of c1  resp., c2 . We also have r1,r2 ∈ Z∗ N. Let ∆ci  def= c1,i − c2,i. It follows that  1 · k∏ r2  −c1,i y i  i=1  = I = r2  2 · k∏  i=1  −c2,i y i  mod N,   cid:33 2   cid:195  k∏  i=1  x∆ci i  mod N,   r1 r2 2 =  k∏  i=1  y∆ci i =  i=1 x∆ci i  and so F knows two square roots R def=  r1 r2  and X def= ∏k of the same value Y def= X 2 = R2 mod N. Note, however, that from the point of view of A the value X is a random square root of Y .  This is so since the xi are chosen uniformly at N, the ∆ci lie in {−1,0,1}, and at least one ∆ci is non-zero.  As in random from Z∗ Theorem 2.2, then, R  cid:54 = ±X mod N with probability 1 2; furthermore, when this occurs F can compute the factorization of N. We conclude that if A indeed violates special soundness with non-negligible probability, then F factors moduli N output by GenModulus with non-negligible probability — but this contradicts the assumed hardness of factoring relative to GenModulus.  8.3.2 The Guillou-Quisquater Scheme  We now show an identiﬁcation scheme introduced by Guillou and Quisquater whose security against passive attacks is based on the RSA assumption. See Construc- tion 8.6  and also Figure 8.7 .  V  N,e,y   P N,e,x   s ← Z∗ N A := se mod N  r := xc · s mod N   cid:190  c  I  cid:45   c ← Ze  r  cid:45  check whether re · y−c ?= I mod N  Fig. 8.7 An execution of the Guillou-Quisquater identiﬁcation scheme.   8.3 Some Secure Identiﬁcation Schemes  177  Construction 8.6: The Guillou-Quisquater  GQ  Identiﬁcation Scheme  N and set y := xe mod N. The public key is  N,e,y  and the secret key is x.  Let GenRSA be as in Chapter 4. Key generation: Compute  N,e,d  ← GenRSA 1k , where e is prime. Then choose x ← Z∗ Prover’s initial message: Choose s ← Z∗ Veriﬁer’s challenge: Choose and send challenge c ← Ze. Prover’s response: Send the response r := xc · s mod N, where x is taken from the secret key and s is the randomness used in the ﬁrst round. Acceptance criterion: Accept transcript  I,c,r  with respect to the public key  N,e,y  iff  N and send I := se mod N.   It is important also to verify that I,r ∈ Z∗  N and, in particular, I  cid:54 = 0.   re · y−c ?= I mod N.  In an honest execution of the Guillou-Quisquater protocol, the veriﬁer always ac- cepts since  re · y−c =  xc · s e · y−c = yc · se · y−c = se = I mod N.  Theorem 8.6. The Guillou-Quisquater identiﬁcation scheme is  perfect  special honest-veriﬁer zero knowledge. Furthermore, if the RSA problem is hard relative to GenRSA then is also satisﬁes special soundness.  Proof. We ﬁrst prove that the GQ scheme achieves perfect special HVZK. Consider the following algorithm Sim:  Algorithm Sim: The algorithm is given a public key  N,e,y  in addition to a challenge c ∈ Ze.   Choose r ← Z∗ N.   Set I := re · y−c mod N.   Output the transcript  I,c,r .  To see that this perfectly simulates a real execution of the protocol for any given public key  N,e,y   note that this ﬁxes the secret key  and challenge c, we look — in each case — at the distribution of r conditioned on the given values, and then at the distribution of I conditioned on the given values and r. In a real execution of the N  regardless of c  since r = xc · s mod N protocol, r is uniformly distributed in Z∗ for a uniformly distributed value s ∈ Z∗ N. Then I is the unique value satisfying I = re · y−c mod N. In simulated transcripts, both r and I are chosen from these same distributions by construction.   178  8 Signature Schemes from Identiﬁcation Schemes  Special soundness follows easily from the following observation: given two ac- cepting transcripts  I,c1,r1  and  I,c2,r2   with c1  cid:54 = c2 and c1,c2 ∈ Ze  with respect to an arbitrary public key  N,e,y , it is possible to efﬁciently compute y1 e mod N.  This implies special soundness, as any PPT algorithm violating special soundness with non-negligible probability can thus be used to solve the RSA problem with respect to GenRSA.  To see that this is true, note that by deﬁnition of the acceptance criterion we have  1 · y−c1 = I = re re  2 · y−c2 mod N  with r1,r2 ∈ Z∗ lute value of their difference is less than e; since e is prime,  N, and so  r1 r2 e = yc1−c2 mod N. Now, since c1,c2 ∈ Ze the abso-  gcd e,c1 − c2  = 1  and we may apply Lemma 4.1 to compute y1 e mod N.  The GQ protocol achieves soundness 1 e. To achieve passive security, then, we need to choose e large enough so that 1 e is negligible.  Alternately, we may use a smaller e and parallel repetition.   8.3.3 The Micali Ong-Schnorr Scheme  The next scheme we consider is secure under the assumption that factoring Blum integers is hard  cf. Section 2.2.1 . The scheme is more efﬁcient than the Fiat-Shamir scheme  whose security is based on essentially the same assumption , but we have deferred its presentation to now because of its similarities to the Guillou-Quisquater scheme.  P N,t,x   s ← Z∗ N I := s2t mod N  V  N,t,y   I  cid:45   c ← Z2t  r := xc · s mod N   cid:190  c  r  cid:45  check whether  r2t · y−c ?= I mod N  Fig. 8.8 An execution of the Micali Ong-Schnorr identiﬁcation scheme.  As usual, it is easy to check that correctness always holds:  r2t · y−c =  xc · s 2t · y−c = yc · s2t · y−c = I mod N.   8.3 Some Secure Identiﬁcation Schemes  179  Construction 8.7: The Micali Ong-Schnorr Identiﬁcation Scheme  Let GenModulus be a PPT algorithm that, on input 1k, outputs a modulus N along with two  distinct  k-bit primes p,q with N = pq and p = q = 3 mod 4. Fix some parameter t = ω logk . Key generation: Compute  N, p,q  ← GenModulus 1k . Choose x ← Z∗ pute y := x2t mod N. The public key is  N,y  and the secret key is x. Prover’s initial message: Choose s ← Z∗ N and send I := s2t mod N. Veriﬁer’s challenge: Choose and send challenge c ← Z2t . Prover’s response: Send the response r := xc · s mod N, where x is taken from the secret key and s is the randomness used in the ﬁrst round. Acceptance criterion: Accept transcript  I,c,r  with respect to the public key  N,y  iff  N and com-   It is important also to verify that I,r ∈ Z∗  N and, in particular, I  cid:54 = 0.   r2t · y−c ?= I mod N.  The similarity to the GQ scheme is clear. On the other hand, the analysis is more complex. The issue is this: from two accepting transcripts  I,c1,r1 ,  I,c2,r2   with c1  cid:54 = c2 , one can compute  as in the proof of special soundness for the Guillou- Quisquater scheme :   r1 r2 2t = yc1−c2 mod N.   8.2  But now gcd 2t ,c1 − c2  is not necessarily equal to 1, and so we cannot necessarily compute y1 2t mod N. Instead, using the fact that N is a Blum integer, we show that Equation  8.2  enables computation of a square root of y. As in Theorem 2.2, this contradicts the assumed hardness of factoring N.5 We now proceed with the details.  Theorem 8.7. The Micali Ong-Schnorr scheme is  perfect  special honest-veriﬁer zero knowledge. Furthermore, if factoring is hard for GenModulus then it also sat- isﬁes special soundness.  Proof. A proof that the scheme is honest-veriﬁer zero knowledge follows along similar lines to the proof for the case of the Guillou-Quisquater scheme, and so we omit it. Before proving special soundness, we recall a key property of Blum integers  cf. Section 2.2.1: if N is a Blum integer, then squaring modulo N is a permutation on the set QRN of quadratic residues modulo N. Thus, if x,y ∈ QRN and x2 = y2 mod N 5 As in the case of the Fiat-Shamir scheme, then, a violation of special soundness does not enable computation of the prover’s secret key  but can still be shown to be infeasible .   180  8 Signature Schemes from Identiﬁcation Schemes  we can conclude that x = y mod N; more generally, if x2 cid:96  = y2 cid:96  mod N then x = y mod N. We stress that this implication is valid only when x,y ∈ QRN. With the above in mind, we ﬁrst show that given two accepting transcripts  I,c1,r1  and  I,c2,r2   with c1  cid:54 = c2 and c1,c2 ∈ Z2t   it is possible to compute a square root of y modulo N. As in the Guillou-Quisquater scheme, we may derive Equation  8.2 ; assume without loss of generality that c1 > c2 and let ∆ = c1 − c2. Compute integers  cid:96 ,m  with m ≥ 1 odd  such that ∆ = 2 cid:96  · m; note that this can be done easily, and does not require the full factorization of ∆. Note further that since c1,c2 ∈ Z2t we have ∆ < 2t and so  cid:96  < t. Re-writing Equation  8.2 , we have:    r1 r2 2t− cid:96  2 cid:96  =  ym 2 cid:96  mod N.  The key observation is that ym ∈ QRN  since y ∈ QRN  and furthermore it is also the case that  r1 r2 2t− cid:96  ∈ QRN  since t −  cid:96  ≥ 1 . By what we have said above, we conclude that    r1 r2 2t− cid:96 −1 2 = ym mod N   using the fact that N is a Blum integer . Since gcd 2,m  = 1, we may apply Lemma 4.1 to compute a square root of y.  8.3.4 The Schnorr Scheme  The ﬁnal identiﬁcation scheme we present in this section is due to Schnorr, and is based on the hardness of the discrete logarithm problem. For concreteness and sim- plicity, we describe the protocol based on some ﬁxed group G of  publicly known  prime order q; in general, of course, the size of the group will have to grow with the security parameter k and so we need an inﬁnite family of such groups along with an efﬁcient algorithm generating  descriptions of  groups of the required form. A description of the scheme follows  see also Construction 8.8 :  Public: group G, group order q, generator g  V  y = gx   P x   s ← Zq I := gs  r := cx + s mod q  I  cid:45   c ← Zq   cid:190  c  r  cid:45  check whether gr · y−c ?= I  Fig. 8.9 An execution of the Schnorr identiﬁcation scheme.   8.3 Some Secure Identiﬁcation Schemes  181  Construction 8.8: The Schnorr identiﬁcation scheme Assume a group G of prime order q and a generator g ∈ G are publicly known  otherwise, they can also be generated during key generation and included with the public key . Key generation: Choose random x ← Zq and set y := gx. The public key is y ∈ G and the secret key is x ∈ Zq. Prover’s initial message: Choose s ← Zq and send I := gs. Veriﬁer’s challenge: Choose and send challenge c ← Zq. Prover’s response: Send the response r := cx + s mod q, where x is the secret key and s is the randomness used in the ﬁrst round. Acceptance criterion: Accept transcript  A,c,r  with respect to the public key y iff   In general, one must also verify that I ∈ G and c ∈ Zq.   gr · y−c ?= I.  Correctness is easily veriﬁed.  Theorem 8.8. The Schnorr identiﬁcation scheme is  perfect  special honest-veriﬁer zero knowledge. Furthermore, if the discrete logarithm problem is hard in G then it also satisﬁes special soundness.  Proof. We ﬁrst prove that the Schnorr scheme achieves perfect special HVZK. Con- sider the following algorithm Sim:  Algorithm Sim: The algorithm is given a public key y and a challenge c ∈ Zq.   Choose r ← Zq.   Set I := gr · y−c.   Output the transcript  I,c,r .  To see that this perfectly simulates a real execution of the protocol for any given public key y  which ﬁxed the secret key x  and challenge c, we look — in each case — at the distribution of r conditioned on the given values, and then at the distribution of I conditioned on the values of the given values and r. In a real execution of the protocol, r is uniformly distributed in Zq  regardless of c  because r = cx + s mod q for a uniformly distributed value s ∈ Zq. Then I is the unique value satisfying I = gr ·y−c. In simulated transcripts, r and I have the same distributions by construction. Special soundness follows easily from the following observation: given two ac- cepting transcripts  I,c1,r1  and  I,c2,r2   with c1  cid:54 = c2 and c1,c2 ∈ Zq  with re- spect to a public key y, it is possible to efﬁciently compute logg y.  To see that this   182  8 Signature Schemes from Identiﬁcation Schemes  implies special soundness, note that any PPT algorithm violating special soundness with non-negligible probability can thus be used to compute discrete logarithms of a random group element y ∈ G with non-negligible probability.  To see this, note that by deﬁnition of the acceptance criterion we have gr1y−c1 = I = gr2y−c2  and so gr1−r2 = yc1−c2 and  g r1−r2   c1−c2  = y.  We conclude that logg y =  r1 − r2  ·  c1 − c2 −1 mod q, which can be computed efﬁciently  note that c1 − c2  cid:54 = 0 mod q and so the desired inverse modulo q exists .  8.4 Further Reading  Identiﬁcation schemes have a long history, and we have only covered here what is necessary for our treatment of signature schemes. The reader interested in identiﬁ- cation schemes per se is referred to the references cited here, as well as other works  e.g., [93] , for a full discussion of stronger deﬁnitions of security and how they can be achieved.  Canonical identiﬁcation schemes as we have described them here are also known as sigma protocols  Σ-protocols . This abstract notion, as well as the deﬁnitions of  special  HVZK and special soundness, were ﬁrst proposed in [32]; see there for further discussion and applications.  The Fiat-Shamir transform was ﬁrst presented in [47]. Our proof here follows that of Abdalla et al. [1], though earlier proofs of slightly weaker results were also known [96, 92]. The proof relies heavily on the random oracle model, and it remains an active area of research to give a proof of the Fiat-Shamir transform  or a suitable variant  in the standard model, or to show the insecurity of practical schemes derived using the Fiat-Shamir transform. For some negative results indicating limitations on what can be proved regarding the Fiat-Shamir transform in general, see [43, 58].  The weaker transformation from identiﬁcation protocols to KMA-secure one- time signature schemes  Construction 8.3  is implicit in work of Cramer and Damg˚ard [33], where it was then used to construct an existentially unforgeable sig- nature scheme. The idea has also been formalized as chameleon signatures [74], which have several applications. See the work of [103] for some particularly efﬁ- cient instantiations.  Construction 8.4 is implicit in the work of Goldwasser, Micali, and Rack- off [60], though it was presented in a somewhat different context there. Fiat and Shamir [47] gave the improved Construction 8.5 and analyzed it as an identiﬁca- tion scheme. A slight generalization of the Fiat-Shamir scheme was studied in later work by Feige, Fiat, and Shamir [46]. Construction 8.6 was presented by Guillou and Quisquater [63].   8.4 Further Reading  183  Micali introduced a signature scheme derived from an identiﬁcation scheme much like Construction 8.7 in an unpublished manuscript [82]; the scheme was ﬁrst published by Ong and Schnorr [94]. Several variants and extensions of this con- struction have been given in the literature [91, 69, 104, 49]. Construction 8.8 is due to Schnorr [101].  In contrast to Chapter 7, here we have not focused much on the concrete security bounds of our proofs of security. In fact, the reader may notice that the concrete se- curity bound guaranteed by our proof of Theorem 8.1 is quite bad; it is open whether this can be improved for speciﬁc schemes. An alternative to the Fiat-Shamir trans- form was suggested by Micali and Reyzin [84]; their transform yields a tighter con- crete security analysis, but only applies to restricted types of identiﬁcation schemes. Work of Goh et al. [54] introduces signature schemes that can be viewed as being derived from some speciﬁc identiﬁcation schemes; their schemes have tight reduc- tions to the computational or decisional Difﬁe-Hellman assumptions.  A notable omission from this book is the Digital Signature Algorithm Digital Signature Standard  DSA DSS , a US government standard [90]. Despite its im- portance, we have made a conscious decision to leave a discussion of DSS out of this book because existing proofs of security for DSS  or variants thereof  require proof techniques beyond the scope of this book. The interested reader is referred to [21, 107, 77, 22] or the analyses of DSA ECDSA posted on the CRYPTREC website.6  6 http:  www.cryptrec.go.jp english estimation.html   References  1. M. Abdalla, J. H. An, M. Bellare, and C. Namprempre. From identiﬁcation to signatures via the Fiat-Shamir transform: Necessary and sufﬁcient conditions for security and forward- security. IEEE Transactions on Information Theory, 54 8 :3631–3646, 2008.  2. J.H. An, Y. Dodis, and T. Rabin. On the security of joint signature and encryption.  In Advances in Cryptology — Eurocrypt 2002, volume 2332 of LNCS, pages 83–107. Springer, 2002.  3. B. Barak and M. Mahmoody-Ghidary. Lower bounds on signatures from symmetric primi- tives. In 48th Annual Symposium on Foundations of Computer Science  FOCS , pages 680– 688. IEEE, 2007.  4. N. Bari and B. Pﬁtzmann. Collision-free accumulators and fail-stop signature schemes with- out trees. In Advances in Cryptology — Eurocrypt ’97, volume 1233 of LNCS, pages 480– 494. Springer, 1997.  5. M. Bellare and S. Micali. How to sign given any trapdoor function. In Advances in Cryptol-  ogy — Crypto ’88, volume 403 of LNCS, pages 200–215. Springer, 1990.  6. M. Bellare and S. Micali. How to sign given any trapdoor function. Journal of the ACM,  39 1 :214–233, 1992.  7. M. Bellare and C. Namprempre. Authenticated encryption: Relations among notions and analysis of the generic composition paradigm. In Advances in Cryptology — Asiacrypt 2000, volume 1976 of LNCS, pages 531–545. Springer, 2000.  8. M. Bellare and T. Ristenpart. Simulation without the artiﬁcial abort: Simpliﬁed proof and improved concrete security for Waters’ IBE scheme. In Advances in Cryptology — Euro- crypt 2009, volume 5479 of LNCS, pages 407–424. Springer, 2009.  9. M. Bellare and P. Rogaway. Random oracles are practical: A paradigm for designing efﬁcient protocols. In 1st ACM Conference on Computer and Communications Security, pages 62–73. ACM Press, 1993.  10. M. Bellare and P. Rogaway. The exact security of digital signatures: How to sign with RSA and Rabin. In Advances in Cryptology — Eurocrypt ’96, volume 1070 of LNCS, pages 399– 416. Springer, 1996.  11. M. Bellare and P. Rogaway. Collision-resistant hashing: Towards making UOWHFs prac- In Advances in Cryptology — Crypto ’97, volume 1294 of LNCS, pages 470–484.  tical. Springer, 1997.  12. M. Bellare and S. Shoup. Two-tier signatures from the Fiat-Shamir transform, with appli- IET Proc. Information Security,  cations to strongly unforgeable and one-time signatures. 2 2 :47–63, 2008.  13. D. J. Bernstein. Proving tight security for Rabin-Williams signatures. In Advances in Cryp-  tology — Eurocrypt 2008, volume 4965 of LNCS, pages 70–87. Springer, 2008.  185   186  References  14. J. Black. The ideal-cipher model, revisited: An uninstantiable blockcipher-based hash func- In Fast Software Encryption – FSE 2006, volume 4047 of LNCS, pages 328–340.  tion. Springer, 2006.  15. D. Bleichenbacher and U. M. Maurer. On the efﬁciency of one-time digital signatures. In Advances in Cryptology — Asiacrypt’96, volume 1163 of LNCS, pages 145–158. Springer, 1996.  16. M. Blum. Coin ﬂipping by telephone. In Proc. IEEE Spring COMPCOM, pages 133–137,  1982.  17. D. Boneh. Twenty years of attacks on the RSA cryptosystem. Notices of the American  Mathematical Society, 46 2 :203–213, 1999.  18. D. Boneh and X. Boyen. Short signatures without random oracles and the SDH assumption  in bilinear groups. Journal of Cryptology, 21 2 :149–177, 2008.  19. D. Boneh, B. Lynn, and H. Shacham. Short signatures from the Weil pairing. Journal of  Cryptology, 17 4 :297–319, September 2004.  20. J. N. Bos and D. Chaum. Provably unforgeable signatures. In Advances in Cryptology —  Crypto ’92, volume 740 of LNCS, pages 1–14. Springer, 1993.  21. E. F. Brickell, D. Pointcheval, S. Vaudenay, and M. Yung. Design validations for discrete logarithm based signature schemes. In 3rd Intl. Workshop on Theory and Practice in Public Key Cryptography PKC 2000 , volume 1751 of LNCS, pages 276–292. Springer, 2000.  22. D. R. L. Brown. Generic groups, collision resistance, and ECDSA. Designs, Codes, and  Cryptography, 35 1 :119–152, 2005.  23. C. Cachin, S. Micali, and M. Stadler. Computationally private information retrieval with polylogarithmic communication. In Advances in Cryptology — Eurocrypt ’99, volume 1592 of LNCS, pages 402–414. Springer, 1999.  24. J. Camenisch and A. Lysyanskaya. A signature scheme with efﬁcient protocols.  In 3rd Intl. Conf. on Security in Communication Networks  SCN , volume 2576 of LNCS, pages 268–289. Springer, 2002.  25. R. Canetti, O. Goldreich, and S. Halevi. The random oracle methodology, revisited. Journal  of the ACM, 51 4 :557–594, 2004.  26. D. Catalano and R. Gennaro. Cramer-Damg˚ard signatures revisited: Efﬁcient ﬂat-tree sig- In 8th Intl. Workshop on Theory and Practice in Public Key  natures based on factoring. Cryptography PKC 2005 , volume 3386 of LNCS, pages 313–327. Springer, 2005.  27. B. Chevallier-Mames and M. Joye. A practical and tightly secure signature scheme without hash function. In Cryptographers’ Track — RSA 2007, volume 4377 of LNCS, pages 339– 356. Springer, 2007.  28. J.-S. Coron. On the exact security of full domain hash.  In Advances in Cryptology —  Crypto 2000, volume 1880 of LNCS, pages 229–235. Springer, 2000.  29. J.-S. Coron. Optimal security proofs for PSS and other signature schemes. In Advances in  Cryptology — Eurocrypt 2002, volume 2332 of LNCS, pages 272–287. Springer, 2002.  30. J.-S. Coron and T. Icart. An indifferentiable hash function into elliptic curves. Available at  http:  eprint.iacr.org 2009 340.  31. J.-S. Coron and D. Naccache. Security analysis of the Gennaro-Halevi-Rabin signature scheme. In Advances in Cryptology — Eurocrypt 2000, volume 1807 of LNCS, pages 91– 101. Springer, 2000.  32. R. Cramer. Modular Design of Secure yet Practical Cryptographic Protocols. PhD thesis,  University of Amsterdam, 1996.  33. R. Cramer and I. Damg˚ard. Secure signature schemes based on interactive protocols.  In Advances in Cryptology — Crypto ’95, volume 963 of LNCS, pages 297–310. Springer, 1995. 34. R. Cramer and I. Damg˚ard. New generation of secure and practical RSA-based signatures. In Advances in Cryptology — Crypto ’96, volume 1109 of LNCS, pages 173–185. Springer, 1996.  35. R. Cramer and T. Pedersen. Efﬁcient and provable security ampliﬁcations. Technical Report  CS-R9529, CWI, 1995.  36. R. Cramer and V. Shoup. Signature schemes based on the strong RSA assumption. ACM  Transactions on Information and System Security, 3 3 :161–185, 2000.   References  187  37. I. Damg˚ard. Collision free hash functions and public key signature schemes. In Advances in  Cryptology — Eurocrypt ’87, volume 304 of LNCS, pages 203–216. Springer, 1988.  38. I. Damg˚ard. A design principle for hash functions. In Advances in Cryptology — Crypto ’89,  volume 435 of LNCS, pages 416–427. Springer, 1990.  39. A. De Santis and M. Yung. On the design of provably secure cryptographic hash functions. In Advances in Cryptology — Eurocrypt ’90, volume 473 of LNCS, pages 412–431. Springer, 1990.  40. W. Difﬁe and M. E. Hellman. New directions in cryptography. IEEE Transactions on Infor-  mation Theory, 22 6 :644–654, 1976.  41. Y. Dodis and L. Reyzin. On the power of claw-free permutations.  In 3rd Intl. Conf. on Security in Communication Networks  SCN , volume 2576 of LNCS, pages 55–73. Springer, 2002.  42. C. Dwork and M. Naor. An efﬁcient existentially unforgeable signature scheme and its  applications. Journal of Cryptology, 11 3 :187–208, 1998.  43. C. Dwork, M. Naor, O. Reingold, and L. Stockmeyer. Magic functions. Journal of the ACM,  50 6 :852–921, 2003.  44. T. El Gamal. A public key cryptosystem and a signature scheme based on discrete logarithms.  IEEE Transactions on Information Theory, 31:469–472, 1985.  45. S. Even, O. Goldreich, and S. Micali. On-line off-line digital signatures. Journal of Cryptol-  46. U. Feige, A. Fiat, and A. Shamir. Zero-knowledge proofs of identity. Journal of Cryptology,  47. A. Fiat and A. Shamir. How to prove yourself: Practical solutions to identiﬁcation and sig- In Advances in Cryptology — Crypto ’86, volume 263 of LNCS, pages  ogy, 9 1 :35–67, 1996.  1 2 :77–94, 1988.  nature problems. 186–194. Springer, 1987.  48. M. Fischlin. The Cramer-Shoup strong-RSA signature scheme revisited. In 6th Intl. Work- shop on Theory and Practice in Public Key Cryptography PKC 2003 , volume 2567 of LNCS, pages 116–129. Springer, 2003.  49. M. Fischlin and R. Fischlin. The representation problem based on factoring. In Cryptogra-  phers’ Track — RSA 2002, volume 2271 of LNCS, pages 96–113. Springer, 2002.  50. E. Fujisaki and T. Okamoto. Statistical zero knowledge protocols to prove modular poly- nomial relations. In Advances in Cryptology — Crypto ’97, volume 1294 of LNCS, pages 16–30. Springer, 1997.  51. S. D. Galbraith, K. G. Paterson, and N. P. Smart. Pairings for cryptographers. Discrete  Applied Mathematics, 156 16 :3113–3121, 2008.  52. R. Gennaro, Y. Gertner, J. Katz, and L. Trevisan. Bounds on the efﬁciency of generic cryp-  tographic constructions. SIAM Journal on Computing, 35 1 :217–246, 2005.  53. R. Gennaro, S. Halevi, and T. Rabin. Secure hash-and-sign signatures without the random oracle. In Advances in Cryptology — Eurocrypt ’99, volume 1592 of LNCS, pages 123–139. Springer, 1999.  54. E.-J. Goh, S. Jarecki, J. Katz, and N. Wang. Efﬁcient signature schemes with tight reductions  to the Difﬁe-Hellman problems. Journal of Cryptology, 20 4 :493–514, 2007.  55. O. Goldreich. Two remarks concerning the Goldwasser-Micali-Rivest signature scheme. In Advances in Cryptology — Crypto ’86, volume 263 of LNCS, pages 104–110. Springer, 1987. 56. O. Goldreich. Foundations of Cryptography, vol. 1: Basic Tools. Cambridge University  57. O. Goldreich. Foundations of Cryptography, vol. 2: Basic Applications. Cambridge Univer-  Press, Cambridge, UK, 2001.  sity Press, Cambridge, UK, 2004.  58. S. Goldwasser and Y. Tauman Kalai. On the  in security of the Fiat-Shamir paradigm. In 44th Annual Symposium on Foundations of Computer Science  FOCS , pages 102–115. IEEE, 2003.  59. S. Goldwasser and S. Micali. Probabilistic encryption. Journal of Computer and System  Sciences, 28 2 :270–299, 1984.  60. S. Goldwasser, S. Micali, and C. Rackoff. The knowledge complexity of interactive proof  systems. SIAM Journal on Computing, 18 1 :186–208, 1989.   188  References  61. S. Goldwasser, S. Micali, and R. L. Rivest. A digital signature scheme secure against adaptive  chosen-message attacks. SIAM Journal on Computing, 17 2 :281–308, 1988.  62. S. Goldwasser, S. Micali, and A. C.-C. Yao. Strong signature schemes. In 15th Annual ACM  Symposium on Theory of Computing  STOC , pages 431–439. ACM Press, 1983.  63. L. C. Guillou and J.-J. Quisquater. A “paradoxical” indentity-based signature scheme result- ing from zero-knowledge. In Advances in Cryptology — Crypto ’88, volume 403 of LNCS, pages 216–231. Springer, 1990.  64. J. H˚astad, R. Impagliazzo, L. A. Levin, and M. Luby. A pseudorandom generator from any  one-way function. SIAM Journal on Computing, 28 4 :1364–1396, 1999.  65. D. Hofheinz and E. Kiltz. Programmable hash functions and their applications. In Advances  in Cryptology — Crypto 2008, volume 5157 of LNCS, pages 21–38. Springer, 2008.  66. S. Hohenberger and B. Waters. Realizing hash-and-sign signatures under standard assump- tions. In Advances in Cryptology — Eurocrypt 2009, volume 5479 of LNCS, pages 333–350. Springer, 2009.  67. S. Hohenberger and B. Waters. Short and stateless signatures from the RSA assumption. In Advances in Cryptology — Crypto 2009, volume 5677 of LNCS, pages 654–670. Springer, 2009.  68. Q. Huang, D. S. Wong, and Y. Zhao. Generic transformation to strongly unforgeable sig- natures. In ACNS 07: 5th International Conference on Applied Cryptography and Network Security  ACNS , volume 4521 of LNCS, pages 1–17. Springer, 2007.  69. M. Jakobsson. Reducing costs in identiﬁcation protocols. Presented at the rump session of  Crypto 1992. Available at http:  www.informatics.indiana.edu markus papers.asp.  70. M. Joye. How  not  to design strong-RSA signatures. Designs, Codes, and Cryptography.  71. J. Katz and C.-Y. Koo. On constructing universal one-way hash functions from arbitrary  one-way functions. Available at http:  eprint.iacr.org 2005 328.  72. J. Katz and Y. Lindell. Introduction to Modern Cryptography. Chapman & Hall CRC Press,  To appear.  2007.  73. J. Katz and N. Wang. Efﬁciency improvements for signature schemes with tight security In ACM CCS ’03: 10th ACM Conference on Computer and Communications  reductions. Security, pages 155–164. ACM Press, 2003.  74. H. Krawczyk and T. Rabin. Chameleon signatures.  In Network and Distributed System  Security Symposium – NDSS 2000. The Internet Society, 2000.  75. K. Kurosawa and K. Schmidt-Samoa. New online ofﬂine signature schemes without ran- In 9th Intl. Conference on Theory and Practice of Public Key Cryptogra-  dom oracles. phy PKC 2006 , volume 3958 of LNCS, pages 330–346. Springer, 2006.  76. L. Lamport. Constructing digital signatures from a one-way function. Technical Report  SRI-CSL-98, SRI Intl. Computer Science Laboratory, October 1979.  77. J. Malone-Lee and N. P. Smart. Modiﬁcations of ECDSA. In SAC 2002: 9th Annual Inter- national Workshop on Selected Areas in Cryptography  SAC , volume 2595 of LNCS, pages 1–12. Springer, 2003.  78. R. C. Merkle. Protocols for public key cryptosystems. In IEEE Symposium on Security &  Privacy, pages 122–134. IEEE, 1980.  79. R. C. Merkle. A digital signature based on a conventional encryption function. In Advances  in Cryptology — Crypto ’87, volume 293 of LNCS, pages 369–378. Springer, 1988.  80. R. C. Merkle. A certiﬁed digital signature  that antique paper from 1979 . In Advances in  Cryptology — Crypto ’89, volume 435 of LNCS, pages 218–238. Springer, 1990.  81. R. C. Merkle. One way hash functions and DES. In Advances in Cryptology — Crypto ’89,  volume 435 of LNCS, pages 428–446. Springer, 1990.  82. S. Micali. A secure and efﬁcient digital signature algorithm. Technical Report MIT LCS TM- 501b, Massachusetts Institute of Technology, Laboratory for Computer Science, April 1994. In 40th Annual  83. S. Micali, M. O. Rabin, and S. P. Vadhan. Veriﬁable random functions.  Symposium on Foundations of Computer Science  FOCS , pages 120–130. IEEE, 1999.  84. S. Micali and L. Reyzin. Improving the exact security of digital signature schemes. Journal  of Cryptology, 15 1 :1–18, 2002.   References  189  85. M. Mitzenmacher and A. Perrig. Bounds and improvements for BiBa signature schemes.  Technical Report TR-02-02, Harvard University, 2002.  86. D. Naccache, D. Pointcheval, and J. Stern. Twin signatures: An alternative to the hash-and- sign paradigm. In ACM CCS ’01: 8th ACM Conference on Computer and Communications Security, pages 20–27. ACM Press, 2001.  87. M. Naor. On cryptographic assumptions and challenges  invited talk . In Advances in Cryp-  tology — Crypto 2003, volume 2729 of LNCS, pages 96–109. Springer, 2003.  88. M. Naor and M. Yung. Universal one-way hash functions and their cryptographic applica- tions. In 21st Annual ACM Symposium on Theory of Computing  STOC , pages 33–43. ACM Press, 1989.  89. J. B. Nielsen. Separating random oracle proofs from complexity theoretic proofs: The non- committing encryption case. In Advances in Cryptology — Crypto 2002, volume 2442 of LNCS, pages 111–126. Springer, 2002.  90. National Institute of Standards and Technology. Digital signature standard  DSS . Fed- eral Information Processing Standards  FIPS  Publication 186-3, 2009. Available at http:  www.itl.nist.gov fipspubs by-num.htm.  91. K. Ohta and T. Okamoto. A modiﬁcation of the Fiat-Shamir scheme. In Advances in Cryp-  tology — Crypto ’88, volume 403 of LNCS, pages 232–243. Springer, 1990.  92. K. Ohta and T. Okamoto. On concrete security treatment of signatures derived from identi- ﬁcation. In Advances in Cryptology — Crypto ’98, volume 1462 of LNCS, pages 354–369. Springer, 1998.  93. T. Okamoto. Provably secure and practical identiﬁcation schemes and corresponding signa- ture schemes. In Advances in Cryptology — Crypto ’92, volume 740 of LNCS, pages 31–53. Springer, 1993.  94. H. Ong and C.-P. Schnorr. Fast signature generation with a Fiat-Shamir-like scheme.  In Advances in Cryptology — Eurocrypt ’90, volume 473 of LNCS, pages 432–440. Springer, 1990.  95. PKCS 1 version 2.1: RSA cryptography standard. RSA Data Security, Inc., 1998. Available  96. D. Pointcheval and J. Stern. Security arguments for digital signatures and blind signatures.  at http:  www.rsa.com rsalabs.  Journal of Cryptology, 13 3 :361–396, 2000.  97. M. O. Rabin. Digitalized signatures and public-key functions as intractable as factorization. Technical Report MIT LCS TR-212, Laboratory for Computer Science, MIT, January 1979. 98. L. Reyzin and N. Reyzin. Better than BiBa: Short one-time signatures with fast signing and verifying. In 7th Australian Conference on Information Security and Privacy, ACISP 2002, volume 2384 of LNCS, pages 144–153. Springer, 2002.  99. R. L. Rivest, A. Shamir, and L. M. Adleman. A method for obtaining digital signatures and  public-key cryptosystems. Communications of the ACM, 21 2 :120–126, 1978.  100. J. Rompel. One-way functions are necessary and sufﬁcient for secure signatures. In 22nd Annual ACM Symposium on Theory of Computing  STOC , pages 387–394. ACM Press, 1990.  101. C.-P. Schnorr. Efﬁcient signature generation by smart cards.  Journal of Cryptology,  4 3 :161–174, 1991.  102. A. Shamir. On the generation of cryptographically strong pseudorandom sequences. ACM  Trans. on Computer Systems, 1 1 :38–44, 1983.  103. A. Shamir and Y. Tauman.  Improved online ofﬂine signature schemes.  In Advances in  Cryptology — Crypto 2001, volume 2139 of LNCS, pages 355–367. Springer, 2001.  104. V. Shoup. On the security of a practical identiﬁcation scheme. Journal of Cryptology,  12 4 :247–260, 1999.  105. V. Shoup. A composition theorem for universal one-way hash functions. In Advances in  Cryptology — Eurocrypt 2000, volume 1807 of LNCS, pages 445–452. Springer, 2000.  106. R. Steinfeld, J. Pieprzyk, and H. Wang. How to strengthen any weakly unforgeable signature into a strongly unforgeable signature. In Cryptographers’ Track — RSA 2007, volume 4377 of LNCS, pages 357–371. Springer, 2007.   190  References  107. S. Vaudenay. The security of DSA and ECDSA.  In 6th Intl. Workshop on Theory and Practice in Public Key Cryptography PKC 2003 , volume 2567 of LNCS, pages 309–323. Springer, 2003.  108. L. Washington. Elliptic Curves: Number Theory and Cryptography. CRC Press, 2008. 109. B. R. Waters. Efﬁcient identity-based encryption without random oracles. In Advances in  Cryptology — Eurocrypt 2005, volume 3494 of LNCS, pages 114–127. Springer, 2005.  110. H. C. Williams. A modiﬁcation of the RSA public-key encryption procedure. IEEE Trans-  actions on Information Theory, 26 6 :726–729, 1980.   Index  attacks   adaptive  chosen-message, 13, 16–27 known-message, 13, 15–16, 23, 27, 109 random-message, 12, 14–15, 19–23 replay, 10, 11  bilinear maps, 121  signature schemes based on, 121–131  Blum integer, 47, 48, 178 Boneh-Boyen scheme, 125 Boneh-Lynn-Shacham scheme, 145  canonical identiﬁcation schemes, see identiﬁcation schemes, canonical  clawfree permutation  construction of hash function from, 56–57 clawfree trapdoor permutation, 41–43, 143,  147, 149  doubly enhanced, 43, 48, 51, 143 from the factoring assumption, 47–48 from the RSA assumption, 51  collision-resistant hash function, see hash  function, collision-resistant  constructions of signature schemes  based on bilinear maps, 121–131, 145–147 based on the RSA assumption, 87–108,  based on the strong RSA assumption,  147–152  108–118  98  strong unforgeability from unforgeability,  27–30  the Boneh-Boyen scheme, 122–127 the Boneh-Lynn-Shacham scheme, 145 the Cramer-Damg˚ard scheme, 97–105 the Cramer-Shoup scheme, 98 the Dwork-Naor scheme, 91–97 the Fischlin scheme, 114–117 the Gennaro-Halevi-Rabin scheme, 117–118 the Hohenberger-Waters scheme, 105–108 the Lamport scheme, 70–71 the Waters scheme, 127–131 tree-based signatures, 77  Cramer-Damg˚ard scheme, 100 Cramer-Shoup scheme, 112  deﬁnitions of security  identiﬁcation schemes, 157 relations between, 18 signature schemes, 14–19  Difﬁe-Hellman assumptions, 53, 127, 128, 183 Digital Signature Standard  DSS , 183 discrete logarithm assumption, 52–53, 122,  180  construction of hash functions from, 56–58  doubly enhanced, see clawfree trapdoor permutation, doubly enhanced, see trapdoor permutation, doubly enhanced  Dwork-Naor scheme, 92  chain-based signatures, 75 CMA-security from KMA-security, 23–27,  existential unforgeability, 11, 14–18  CMA-security from RMA-security, 19–23 from any one-way function, 83 from identiﬁcation schemes, 155–182 full-domain hash, 143–145 Lamport scheme, 74  factoring assumption, 43–50, 56, 172, 174 clawfree trapdoor permutation from, 47 trapdoor permutations from, 47  Fiat-Shamir identiﬁcation scheme, 172–176 Fiat-Shamir transform, 159–163  191   192  Index  collision-resistant, 54–55, 58, 61–62  pseudorandom function  Fischlin scheme, 114 full-domain hash  FDH , 143–145  probabilistic, 149–150 tigher security reduction for, 147–149 variant of, 150–152  Gennaro-Halevi-Rabin scheme, 117 Goldwasser-Micali-Rackoff identiﬁcation  scheme, 172–174  Guillou-Quisquater identiﬁcation scheme,  176–178  hash function, 53  constructions of, 55–58  Merkle-Damg˚ard transform, 54–55 universal one-way, 54, 62–64, 73, 81  constructions of, 58–60  Hohenberger-Waters scheme, 106 honest-veriﬁer zero knowledge, see identi- ﬁcation schemes, honest-veriﬁer zero knowledge  special, 170  identiﬁcation schemes  canonical, 159 deﬁnition of security for, 157 Fiat-Shamir transform, 159–163 functional deﬁnition of, 156 honest-veriﬁer zero knowledge, 164, 165,  170  parallel repetition of, 171 special soundness, 164, 165, 170 the Fiat-Shamir scheme, 172–176 the Goldwasser-Micali-Rackoff scheme,  172–174  the Guillou-Quisquater scheme, 176–178 the Ong-Schnorr scheme, 178–180 the Schnorr scheme, 180–182  Merkle-Damg˚ard transform, 54–55 message authentication codes  comparison with signature schemes, 4–6  message space, 9  ﬁxed vs. key-dependent, 10 increasing the size of, 30–32, 61–64  negligible  deﬁnition , 7  one-time signature scheme, 23, 27, 64, 70–74,  99, 171  constructing signatures from, 75  one-way function, 36–39  necessary for signatures, 39 SHA-1 as, 69 sufﬁcient for one-time signatures, 70 sufﬁcient for signatures, 83  one-way permutation, 36–39, 73  construction of universal one-way hash  function from, 59  Ong-Schnorr identiﬁcation scheme, 178–180  use in constructing signatures, 82  RSA assumption, 50–52, 56, 143, 147, 176 clawfree trapdoor permutation from, 51 signature schemes based on, 87–108,  147–152  Schnorr identiﬁcation scheme, 180–182 security  computational, 7–9 unconditional, 6–7  sigma protocols  Σ-protocols , 182 signature schemes  deﬁnitions of security for, 11–19 functional deﬁnition of, 9 one-time, 12, 17 properties of, 4 stateful vs. stateless, 11  special soundness, see identiﬁcation schemes,  special soundness  stateful signature scheme, 11, 75–82, 92, 100,  119  deﬁnition of, 75  strong Difﬁe-Hellman assumption, 123 strong RSA assumption, 90  signature schemes based on, 108–118  from unforgeability, 27  trapdoor permutation, 39–41, 85, 143  doubly enhanced, 40, 51, 143 from the factoring assumption, 47 from the RSA assumption, 51  universal one-way hash function, see hash  function, universal one-way  Lamport one-time signature scheme, 70–74  strong unforgeability, 12, 14–18, 27–30, 33, 73  on-line off-line signature schemes, 27  Waters scheme, 128

@highlight

Digital Signatures is the first comprehensive account of the theoretical principles and techniques used in the design of provably secure signature schemes. In addition to providing the reader with a better understanding of the security guarantees provided by digital signatures, the book also contains full descriptions and detailed proofs for essentially all known secure signature schemes in the cryptographic literature. A valuable reference for students, professors, and researchers, Digital Signatures can be used for self-study, as a supplement to a course on theoretical cryptography, or as a textbook in a graduate-level seminar.