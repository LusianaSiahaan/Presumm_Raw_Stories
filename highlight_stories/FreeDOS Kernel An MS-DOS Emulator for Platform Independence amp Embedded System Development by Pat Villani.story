The FreeDOS  Kernel   Pat Villani    M£\  CRC  Press   \ \   J *'   J  Taylo r & Francis  Group   Boca Raton  London  New York   CRC Press is an imprint  of  the  Taylor  &  Francis Group, an informa  business    CRC Press Taylor & Francis Group 6000 Broken Sound Parkway NW, Suite 300 Boca Raton, FL 33487-2742 First issued in hardback 2017    1996 by Miller Freeman CRC Press is an imprint of Taylor & Francis Group, an Informa business No claim to original U.S. Government works  ISBN 13: 978-1-138-41230-9  hbk    ISBN 13: 978-0-87930-436-2  pbk   This book contains information obtained from authentic and highly regarded sources. Reason- able efforts have been made to publish reliable data and information, but the author and publisher  cannot assume responsibility for the validity of all materials or the consequences of their use. The  authors and publishers have attempted to trace the copyright holders of all material reproduced in  this publication and apologize to copyright holders if permission to publish in this form has not  been obtained. If any copyright material has not been acknowledged please write and let us know so  we may rectify in any future reprint. Except as permitted under U.S. Copyright Law, no part of this book may be reprinted, reproduced,  transmitted, or utilized in any form by any electronic, mechanical, or other means, now known or  hereafter invented, including photocopying, microfilming, and recording, or in any information  storage or retrieval system, without written permission from the publishers. Trademark Notice: Product or corporate names may be trademarks or registered trademarks, and  are used only for identification and explanation without intent to infringe. Visit the Taylor & Francis Web site at http:  www.taylorandfrancis.com and the CRC Press Web site at http:  www.crcpress.com   To Billy who tried to get me to write a book for  15 years.   To Kiddle, Mike, and Mom, for  nodding  and  smiling.   And  especially to Donna,  whose love and confidence  in me   made this book possible.    Table of Contents   Chapter 1   Introduction     A Brief History of Desktop Operating Systems. . ..  2  3  MS-DOS  DOS-C  6  Why Roll Your Own  7  8  9  9  10  10  11  11  12  12  13  13  14   Educational Tool  Embedded Systems  Non-Intel Applications  DOS Clone  Extending DOS   Compiler  Assembler  Linker  Locator  Debugger   Development Environment   Getting Started   iv    Chapter 2  DOS Basics  Where to Start  Basic MS-DOS Architecture  What Do Physical Disks Look Like?   Generic Disk Organization  Floppy Disk Drives  Logical Versus Physical   MS-DOS API  MS-DOS File System   Boot Area  FAT Area  Directory Area and Directories   MS-DOS Memory Management  MS-DOS Task Management  MS-DOS Device Drivers  What I Am Not Covering   Chapter 3   Bird's-Eye  View ofDOS-C  Basic DOS-C Architecture  Booting DOS-C  DOS-C Kernel Architecture  DOS-C API  DOS-C File System  DOS-C Memory Management  DOS-C Task Management  DOS-C High-Level I O and Device Drivers  Final Notes   15  15  17  21  22  24  24  26  30  33  39  44  48  50  52  54   55  56  58  62  63  64  65  66  67  69   v    Chapter 5  DOS-C Kernel: Memory  Manager   Chapter 4  DOS-C Kernel:   File System Manager  Device Driver Interface  Character Device Interface  Block Device Interface  FAT File System Functions   FAT Management  Directory Management  File Management   and  Task Manager  Arena Management   Allocation Strategy Management  Arena Support Functions   Task Manager   Assembly Language Support  Process Environment  Program Loaders  Returning From a Process   Chapter 6  DOS-C Kernel: API   System Call Support  DOS-C Personality Layer  Simple I O Support  DOS Function Support  FCB Function Support   vi   71  72  75  84  94  94  104  122   143  145  147  160  166  166  169  182  199   201  203  216  277  279  230    Chapter 7  Command  Line Interpreter   Starting the Command Line Interpreter  command. com   Architecture  DOSLIB  Internal Commands  External Commands  Batch Commands   Other Options for  Command Interpreters   Chapter 8  DOS-C Kernel-  Putting  It All  Together  Organizing the Project  Building the DOS-C Kernel  Testing the Kernel   or Did I Really Want to Do This?   Where Do You Go From Here?  Appendix  A  A Note about Portability  Appendix  B  The FreeDOS Project:   239  240  242  243  253  256  259  267  274   275  276  278   285  287  289   Official FAQ File  Revision History  General Information   299  299  300  300  What Is the Goal of the FreeDOS Project?  300  What Is the Reason for  FreeDOS?  300  What Will FreeDOS Not Be?  Who Owns FreeDOS?  301  How Is FreeDOS Project Development Organized? . .  301  301  What Exactly Is Included in FreeDOS?  301  Will FreeDOS Run on Some Particular Machine ?.  . . .  303  Will FreeDOS Run Some Particular Program?  303  Will FreeDOS Be Compatible with  Some Particular Version of MS-DOS?   Technical Information   303   VII    Specific  Answers  to  Common  Questions   Why Not Use DJGPP?  Why Not Add 32-bit Multitasking or  Other Advanced Features?  Why Use MICRO-C?  It Doesn't  Support  floats  or typedefs!  But Wait! Why Is the DOS-C Kernel  Written in Borland C?  I Can't Get Some Program to Work  Is FreeDOS Junk or What?  What Happened to FreeDOS?  It Seemed Dead for  a Long Time  What Happened to James Hall,  the Originator of FreeDOS?   How  to  Obtain  More  Information   305  305  305  Where Is the Official FreeDOS Web Page?  306  Where Is the Official FreeDOS FTP Site?  306  Is There a Mailing List for  FreeDOS?  Is There a Usenet Newsgroup for  FreeDOS?  307  307  Who Are the Contact People for  FreeDOS?  What Other Documents Exist?  308  How Can I Participate in FreeDOS Development?  . . . 308   303  303   304   304   304   305   305   311  312  312  313  313  314  314  315   317   Appendix  C  DOS-C Distribution  Disk   Before  You Start  Building  DOS-C  from  the Diskette  Directory  Structure  Organization  in a Nutshell  Building  a Bootable  Floppy  DOS-C  and  FreeDOS  Please  Help  Us   Index   Vili    Chapter 1   Introduction   Ask anyone to define an operating system. I will bet that for every ques  tion you ask, you will receive a different  answer. You may ask, "Is the  definition of an operating system so vague?" I'm happy to answer — no.  However, operating systems do mean different  things to different people.  To many computer users, it is the full  collection  of utilities  and the  kernel  that  drives their  computer  to run their  favorite  applications. To  engineers  working  with  small  microprocessor  systems,  it  may  be  the  kernel and drivers together that makes a complex control system work.  No  matter  what  the  definition,  an  operating  system  of  one  form  or  another is an integral part of software engineers' and users' lives.   Also, operating  systems are the subject  of heated debates and argu  ment. The debates range from  the OS 2 versus Windows battles to the  Berkeley versus System V UNIX debates. Lately, with the introduction  of WindowsNT,  the WindowsNT  versus  UNIX  debate  dominates  dis  cussions  in  many  a  workplace.  These  discussions  typically  result  in  heated  debates  that  approach  religious  fervor  over  the  choice  of  an  operating system.   1    2 — The FreeDOS Kernel   A Brief History of Desktop  Operating  Systems  Historically  in the minicomputer  and mainframe  world, there were  as  many operating  systems as there were computer vendors. Each vendor  would  design  a  unique  operating  system  that  took  advantage  of  its  unique hardware. Sometimes, the operating system changed drastically  from  one revision to another as the hardware changed, requiring  major  rewrites  of application  code. Fortunately, this was not the case for  the  desktop computing environment.   With the introduction  of microprocessors, many individuals  saw an  opportunity  to create  small desktop  computers. An 8-bit microproces  sor, such as the Intel 8080 or Motorola 6800, was the central processing  unit for the early desktop computers. Memory limitations were on the  order of  a few  kilobytes, and  some rather  amazing  applications  ran in  this  small  space. As the popularity  of these  computers  grew,  so did  a  small cottage industry serving hobbyists and small businesses.   Early  users  of  these  computers  recognized  advantages  in  sharing  technology,  and  some  early  computer  conferences  attempted  to  stan  dardize  media  formats  and  storage  methods  so  programs  be  could  exchanged. The storage medium for early desktop computers was audio  cassette, with recording formats  such as Tarbell and Kansas City Stan  dard. Later,  8-inch and  51 4-inch floppy disks became  affordable,  and  small operating systems such as CP M and Flex further  promoted stan  dardization while still allowing room for experimentation.   The market  for  the desktop computer  grew rapidly  as did the com  plexity  of microprocessors.  Processors  such  as the Intel  8086  and the  Motorola  68000  began  promoting  16-bit  and  32-bit  capabilities,  and  companies such as Apple and IBM took advantage of these new proces  sors.  Operating  systems  developed  for  these  new  systems  spawned  a  new generation  of  applications. These companies  also  spent  consider  ably more time and money in planning markets than the earlier cottage  industry that sprung up around desktop computers. Of particular  inter  est to us is a case study of the joint IBM and Microsoft  approach with  MS-DOS. Its evolution will help shed some light on features  and func  tions within MS-DOS.    Introduction — 3   MS-DOS  IBM's entry into the desktop market was with the IBM-PC. This desk  top computer was the product of a skunk-works team within IBM that  featured  an Intel  8088 microprocessor  as its CPU  and 64Kb of RAM.  Originally  introduced  with  only  cassette  tape  as  standard  storage, the  IBM-PC  also offered  a 51 4-inch floppy disk  as an option. To manage  the  diskette,  IBM  licensed  the  MS-DOS  operating  system  from  Microsoft.   The original design of MS-DOS  evolved  from  an operating  system  developed  by  a Seattle company  for  its  S-100-based  desktop  comput  ers.  Microsoft  purchased  all  rights  to  it,  because  operating  systems  were new to them and IBM had approached them for software to run on  its new PC. This system became the source code base for MS-DOS.   The MS-DOS  precursor  was  similar to the CP M operating  system  for the Intel 8080 and required little RAM, a distinct advantage because  the 80x86 family is similar in design to the 8080. By design, the operat  ing  system  provided  a  similar  API   Application  Programming  Inter  face  to CP M. As a result, MS-DOS  1.0 held very closely to the CP M  model. When  combined  with a familiar  architecture, many  developers  were  able to  adapt  their  CP M-based  applications  to MS-DOS. Favor  quickly  shifted  toward Microsoft  to the detriment of Digital  Research,  whose CP M-86 operating system was the primary competition.   As the market matured, so did both MS-DOS and the PC. Demands  for  MS-DOS  began to grow  from  outside IBM, with IBM leading  the  pack  in  technology.  The  next  generation  of  desktop  computers  from  IBM  was  the  XT. This  computer  was  similar  to  the  PC  but  featured  more memory and a 10Mb internal disk drive. Its motherboard also was  capable of much more memory: 256Kb instead of 64Kb. IBM's  target  for  this  more  powerful  system  was  the  business  market.  Previously,  only  large businesses  could  afford  any kind  of computing  power. The  XT addressed the needs of smaller businesses.    4 — The FreeDOS Kernel   In  order  to  address  this  new  market,  Microsoft  developed  a  new  strategy  for  their  products  as  well.  They  adopted  a  dual  approach  to  desktop  computing  environments.  To  manage  the  new  internal  disk  drive, Microsoft adapted its XENIX operating system  an AT&T UNIX v7  derivative  for the XT. They also enhanced the MS-DOS operating system  to support larger storage devices and added a XENIX-like hierarchical file  system.  Microsoft  developers  enhanced  the  MS-DOS  API  with  many  XENIX-like  calls, which  enabled  easy  migration  of  applications  devel  oped  for  a personal  computer  market  based  on MS-DOS  to  a business  market  based  on XENIX. Microsoft  also  enhanced  the MS-DOS  com  mand  line  interpreter,  command.com,  with  I O  redirection  and  pipes  similar to XENIX. This redesigned MS-DOS now became the basis for  all new MS-DOS versions.   The lock-step product announcements continued with both IBM and  Microsoft  again  adding  new  products  in  unison.  IBM  introduced  the  AT, based on an Intel 80286, and Microsoft  released another version of  MS-DOS to support it. At this time, Microsoft began to abandon its earlier  XENIX product in favor  of LAN connectivity  and GUI interfaces.  IBM  also started a joint development with Microsoft for OS 2. This new operat  ing  system  would  take  advantage  of  memory  management  and  other  advanced  features  that  the  new  processor  offered.  The  need  for  a new  operating  system was clear — MS-DOS lacked protection  mechanisms,  and it was very easy for a program crash to destroy the operating system.  The  Ctrl-Alt-Delete  key  sequence became  very  familiar  to users, and a  huge market for fixed-disk reconstruction programs was born.   For migration  of MS-DOS  applications to OS 2, IBM and  Microsoft  developed  a strategy  similar  to their market  entry  strategy. They  would  provide all the functions that were previously available so that developers  could  quickly  adapt  existing  applications  to  the  new  operating  system.  Virtual devices and API entries similar in functionality to BIOS calls elim  inated the need for  i nt xx-style real-mode device control, while retaining  the functionality  familiar to developers. With API calls defined in C, OS 2  encouraged  greater  developer productivity  through the use of high-level  languages and broke the traditional register call model that both CP M and  MS-DOS sported. Unfortunately,  a design limitation of the 80286 forced  some serious incompatibilities between OS 2 and MS-DOS.    Introduction — 5   The Intel 80286 featured two modes of operation, a real mode and a  protected  mode.  The  80286  protected  mode  sported  a  new  memory  management scheme that modified the processor behavior so that mem  ory access is very different  from real mode. Any access to memory uses  the contents  of descriptors, in place of  segment registers, to look up a  new base  address  and add it to the offset  address. The descriptor  plus  offset  scheme expanded memory capacity from  1Mb in the  8086 8088  to  16Mb in the 80286. An unfortunate  side effect  of this scheme is that  real-mode programs using segment plus offset  addressing will not port  easily to protected mode.   Additionally, a significant  design oversight on Intel's part existed in  the  80286.  The  processor  could  switch  from  real  mode  to  protected  mode in order to take advantage of features  offered  by the new operat  ing  system, but it could not switch back.  Once in protected  mode, the  only way back was a hardware reset to the 80286. IBM designed new  features into both the BIOS and hardware of the AT to make the switch  back  to  real  mode, but  the  context  switch  time  was  very  high. Thus,  new  multitasking  OS 2  applications  worked  in  protected  mode  only,  and MS-DOS real-mode applications were limited to a single task.   The OS 2 protected-mode environment was similar to environments  found on larger computers but was incompatible with existing MS-DOS  applications. This limited its popularity  — users  did not want to drop  all their  old  applications  and  spend  much  more  for  special  protected- mode applications — and generated bad press about OS 2. When com  bined  with  rumors  of  discord  between  the  successful  IBM Microsoft  team,  users  stayed  with  MS-DOS. Microsoft  decided  at  this  point  to  create  a migration  path that would  always  include MS-DOS  compati  bility for all its new operating systems.   New  directions  from  Microsoft  included  a  new  GUI  environment,  Windows, that layered MS-DOS. For all subsequent  releases  after  3.3,  MS-DOS and Windows became more tightly coupled so that both could  cooperatively take advantage of 80386+ processors. These new proces  sors featured  improved  memory  management,  linear  addressing,  and a  V86  mode.  The  V86  mode  allowed  real-mode  programs  to  function  while taking advantage of operating system services for process protec  tion and multitasking. Through it all, MS-DOS remained the foundation    6 — The FreeDOS Kernel   for  80x86 desktop computing. This may change in the future,  now that  early  machines  are  being  retired  from  service,  and  Microsoft,  feeling  relief  from  supporting  the  older  real-mode  only  computers,  has  many  new, advanced operating systems in the wings.   DOS-C  DOS-C  started  as an experiment  in writing  device drivers using C  for  MS-DOS  v3.1. Many articles and books that discussed the  foundation  of a DOS device driver had appeared on the scene; however, it seemed  that each article described code written in assembly language only. In a  discussion  with  some  colleagues,  I  argued  that  this  was  unnecessary,  citing UNIX as an example. As a result of these discussions, I began to  write  DOS  device  drivers  in  C. I developed  both  block  and  character  device drivers, along with special  C data structures to match the DOS  request packet. This effort  proved to be very successful,  and I decided  to continue with personal research to expand on these techniques. The  goal:  to  create  a  full  operating  system  by  using  the  same  techniques  used to create the device drivers.   I began  the  design  of  a new  architecture  that  would  use  assembly  language only at the call interface and for process management, such as  stack manipulation  and context  switching. The implementation  of this  operating system would take advantage of the C language features  and  require  fewer  resources  to  develop  than  the  traditional  assembly  lan  guage designs. Although UNIX proved this concept for large multi-user  operating systems, there were no documented instances for a traditional  PC operating system.   Building  on this  knowledge,  I developed  a minimal  operating  sys  tem  using  the  device  drivers  written  earlier,  along  with  a  new  8086  interrupt API. Known as XDOS, it proved to be a functional  operating  system. This new operating system became the vehicle to explore boot  ing techniques,  and I developed  a C library  SDK   Software  Develop  ment Kit  for it.   I  later  began  to  enhance  XDOS  and  chose  DOS  as  the  new API.  These  enhancements  included  a more  advanced  architecture  that  uses    Introduction — 7   an IPL  Intermediate Program Loader  to set up the operating environ  ment before loading the operating system itself. Additionally, reentrant  system calls for real-time applications became part of the design. Using  the  name NSS-DOS   bearing  the initials  of  the  consulting firm I was  part of in place of Microsoft's  MS , I demonstrated this version to a few  friends and business acquaintances. As a result of these demonstrations,  a major  defense contractor approached my consulting firm for a source  license for this operating system. The only new requirement — it had to  run on 680x0 processors.   This  presented  a  new  challenge.  Because  of  the  MS-DOS  model  used for the API, NSS-DOS relied heavily on a segmented architecture.  To meet this challenge, I began a major  redesign of NSS-DOS. Devel  opment of new portability techniques allowed compilation  of the same  source code base on a variety of hosts and with a wide range of compil  ers and target processors. The new version, DOS NT, resulted from this  work. The redesigned kernel used microkernel techniques with logical  separation  of  the  file  system,  memory,  and  task  managers.  The  new  design  included  a portable  DOS API  along  with  a new  DOS  SDK to  guarantee portability. By removing all processor-unique code from  the  core functions,  a highly portable operating system resulted.   The version described in this book, DOS-C, is derived from DOS NT  and is closer in design to MS-DOS: the kernel is one large program as  opposed to many small programs. It is a nonmultitasking operating sys  tem that provides  a large number  of  system calls  similar to MS-DOS.  This  simplified  design  provides  an  operating  system  that  readers  can  study without getting lost in the complexity that a microkernel entails.  It also provides an excellent source code base to experiment on or with.   Why Roll Your Own  Although I discussed the reasons for the development of DOS-C, there  are probably many readers who are wondering why bother at all. After  all,  a  professional  software  company  with  a  great  deal  of  resources  behind it wrote and maintains MS-DOS. Why would anyone develop a  simple clone of a successful  operating system?    8 — The FreeDOS Kernel   Educational  Tool  The first application for such an operating system is as an educational tool.  Without a collection of reverse engineering tools, it is impossible to exam  ine MS-DOS in any great detail. Anyone who has ever looked at mainte  nance of a software  system will tell you that trying to get into the original  programmer's head to figure out the reasons for a particular design, without  proper documentation, is a monumental task — especially at the disassem  bled assembly code level. My compliments to all the folks who are pouring  out  reams  of  "undocumented  documentation."  Reverse  engineering  MS-DOS may also break any existing licensing agreements between you  and Microsoft, so check your license before applying a disassembler to it.  My guess is that MS-DOS  source code is almost entirely in assem  bly  language,  and  the  kernel  itself  is  guaranteed  to  be  assembly  lan  guage.  Even  if  you  did  see  the  source,  it  would  be  more  difficult  to  follow  than if coded in a high-level  language. My goal of  minimizing  assembly language yields two benefits:  the code is portable and easier  to understand. Although a high-level language in itself does not neces  sarily  guarantee  portability,  it  is  easier  to  port  C  source  code  than  assembly  source  code. Also,  conditional  code  and  looping  constructs  are easier to understand in C than assembly language.   As an educational tool, you can replace any section of the tested oper  ating  system. This allows you to experiment with different  algorithms.  You may  want  to change  the LRU   Least  Recently  Used   buffer  algo  rithm for a different  one and compare performance. You may also want to  learn about the different  algorithms in order to apply a similar technique  to a different  application. For example, loadable  device drivers may be  useful  in a stand-alone application where the host uses different  devices  in different  configurations, or the buffered  keyboard input code may pro  vide enough insight for an interactive display system.   Finally, you can test the code on a host MS-DOS or UNIX machine  using  a  source-level  debugger  because  the  majority  of  DOS-C  is  C  code. For example, performing  DOS NT  code tests  on  a  680x0-based  UNIX  machine  proved  invaluable.  Many  of  the  "big-endian"  versus  "little-endian"  issues  surfaced  quickly  during  the unit  testing  of  indi  vidual components of the operating system.    Introduction — 9   Embedded  Systems  Possibly one of the most useful  applications is as an embedded operat  ing system. Many times, an application requires the functionality  of an  operating system, such as file storage, embedded databases, or sophisti  cated  device  control. A  general-purpose  operating  system  used  in  an  embedded system may not do the trick. Additionally, it may not be pos  sible to develop the application  on the host because of a lack of hard  ware or support tools.   You can simplify  the design of a typical embedded  system by using  a DOS PC for  application  development  and later linking to your DOS  to  create  an  application  ROM. You  can  debug  the  application  on  the  host PC and define all the DOS entry points used. Later, you can either  replace  the  DOS  functionality  or  use  an  embedded  operating  system  with  custom  device  drivers  for  your unique  hardware. The  embedded  operating system approach eliminates work and becomes a tool for the  developer.  Additionally,  the  embedded  operating  system  becomes  an  abstraction  layer  between  the  application  and  the  embedded  system  hardware.   Non-Intel  Applications  When the operating  system design is portable, new opportunities  open  up  for  both  traditional  and  embedded  applications.  One possibility  in  the area of embedded  systems is to design your  system and develop it  as you would for a normal PC embedded system, then use cross-devel  opment  tools  to  recompile  the  application.  When  combined  with  the  cross-compiled  operating  system,  software  verification  reduces  to  the  level of regression testing on the new hardware.   Another reason for developing your own operating system is simply  to adapt it to a new platform.  There are many non-Intel processor  sin  gle-board  computers.  To  approach  a  company  such  as  Microsoft  to  adapt MS-DOS  to this custom  hardware  would be both time  and cost  prohibitive.  However,  with  an  operating  system  designed  to be  porta  ble, moving the operating system to a new target is a question of cross- development tools.    10 — The FreeDOS Kernel   DOS  Clone  Another  way to view  DOS-C  is  as  a declaration  of  independence. As  the desktop computer market matures, Microsoft  is moving away  from  MS-DOS  as the  foundation  of  its  GUI products. Another  example  of  the trend away from DOS is the decreasing size of the DOS clone mar  ket. Products such as DR-DOS are rapidly disappearing from the scene,  which leaves older applications  in an orphan  state. Creating  your own  version of DOS solves this problem.   Extending  DOS  Have you, as a developer, ever looked at the DOS API and felt that if it  had just one additional feature, your professional  life would be easier?  Taking the challenge head-on and creating your own version of DOS is  an excellent way of extending DOS.   A typical way to extend DOS is with the Novell approach. When they cre  ated their network product, it was as an extension to the existing MS-DOS  i n t  21 h call. They captured the call and searched their own system calls. If  it matched one, the network product would service it. Otherwise, the proces  sor was restored to its original state and the call was passed through to DOS.  Microsoft  also adopted this interrupt chaining with its standard  i nt  2f h  multiplex interrupt chain in v3 and above.   With your own DOS, you can extend system calls to cover your own  special call by simply  adding it to the function  call handler. You write  an  extension,  test  it,  and  integrate  it  into  your  DOS.  The  simplicity  behind  this type of  customization  gives you, the  developer,  enormous  power over your applications environment.    Introduction —11   Development  Environment  I  expect  to  hear  you  now  say:  "Gee,  this  all  sounds  great,  but  what  expensive tools do I need to do this?" As it turns out, you do not neces  sarily  need  any. By using  a native  80x86 platform  to develop  for  and  test  on,  popular  PC  compilers  from  companies  such  as  Borland  and  Microsoft  are  suitable  as long  as you  follow  special  guidelines. Also,  there is no need for  special linkers if you design your architecture cor  rectly. As I will describe in later chapters, the use of an IPL  simplifies  the files on disk, and you can use common  . com and  . exe file formats.  Testing  also becomes  simpler through the use of  some low-cost tools.  With all this in mind, choose your tools.   Compiler  First, choose a C compiler. The version of DOS presented in this book  compiles with Borland C  Borland International, Scotts Valley, Calif. ,  Microsoft  C   Microsoft  Corp.,  Redmond,  Wash.   and  other  C  cross- compilers. Special  attention to the use of portable techniques pays  off  when using simple development tools. As it turns out, the only area that  ties  a given  C compiler  to its  host  operating  system  is the  C runtime  library. Avoid its use to ensure that your code will run stand-alone with  the low-cost compilers.   Beware of floating point code used by the C compiler. Some compil  ers  generate  non-reentrant  floating  point  code  or  code  that  uses  non- reentrant library calls. Many times, a compiler's start-up code will take  over a number of interrupt vectors. These vectors capture floating point  exceptions  generated when  a call to a nonexistent  coprocessor  occurs.  This  is  a common  technique  for  automatic  switching  between  copro  cessor floating point calculations and software  emulation of the copro  cessor. For all these reasons, and more, avoidance of floating point code  helps. DOS-C  avoids  all floating point code by  avoiding  the use  of C  library calls such as pri ntf    , further  simplifying  the choice.    12 — The FreeDOS Kernel   Assembler  Besides the C compiler, you will need an assembler. The need for this is  twofold. First, the standard start-up code delivered with a native C com  piler assumes a host machine and operating  system. You will be work  ing  with  a  "naked"  machine  that  does  not  have  an  operating  system  available  remember, you are creating it . As a result, you need to sub  stitute your own start-up code that will take care of memory  initializa  tion,  stack  and  register  initializations,  etc.,  and  finally  call  mainO.  Second, you will use the de facto  DOS  standard. This means that you  use  the  same  registers  for  system  calls,  switch  stacks  during  system  calls, etc.   The support code must be written in assembly language, allowing us  full  control of the target machine. The  asm shortcut provided by many  C compilers simply does not suffice  because we must move away  from  the C model for this support. You cannot afford  stack register and frame  pointer manipulations, and many times you will not generate code that  resembles a C function.   Linker  Look  at the linker provided  with the  C compiler  you  choose. For  our  80x86  version,  you  can  use  the  standard  DOS  linkers.  However,  for  many platforms  they may not be suitable. You may need some form of  "strip"  utility  as  typically  supplied  on  many  UNIX  platforms  so  that  you can adequately create an IPL. As you will see later, our architecture  specifies  that the kernel  is an executable file for  a known  format.  Our  choice of the  .exe file type simplified  our decision, but you will need  to be careful  when examining other platforms  and targets.    Introduction —13   Locator  If you have decided to place the operating  system into ROM, or if you  have  a  special  target  machine  architecture  that  requires  you  to fix the  operating  system in memory, you may also need a locator. This type of  utility comes in various  shapes and  sizes and may be split between the  linker and various other utilities, but it always serves the same purpose: to  fix all memory references to absolute addresses and possibly to generate  a special file format acceptable to various device programmers. There are  two examples of this type of utility set. The first example is as a stand  alone locator. Multiple vendors in the 80x86 community have such utili  ties to convert DOS  .exe files into "hex" files. UNIX users may find that  their linker,  1 d, accepts special specification files and that other utilities  will convert the resulting file into a hex file. Check your manuals because  this is a function  of the vendor whose UNIX you are running.   Debugger  With all your development tools in place, you will need to begin think  ing about debugging tools. This choice is dictated by a number of fac  tors. The most significant  is your target architecture. If you plan to use  your  operating  system  in ROM, then  a tool  such  as  a ROM  emulator  that will accept a download from your development platform  and emu  late your target ROM s  may be a good choice. This device will permit  you to download your code directly, but you will need some other tool  in combination with the ROM emulator to assist you in debugging.   If your budget permits, you may want to look into an in-circuit emu  lator.  This  tool  replaces  the  processor  on  your  target  hardware  and  allows you to electronically  look into your target. They typically pro  vide  all the  favorite  debugging  methods  available  on  host  debuggers,  such  as  single-step  and  break  point.  Additionally,  they  usually  allow  you to stop a processor that has stopped responding — a highly  desir  able feature for anyone who has experienced such a lock-up while run  ning DOS-based native debuggers. Also, many other hardware features,  such as trace buffers,  are usually available for in-circuit emulators. This  type of buffer  allows  you to look into the history  of your program  so    14 — The FreeDOS Kernel   that if you wonder how you got to a certain point in your program, the  trace  buffer  will  point  it  out.  Finally,  if  source-level  debugging  is  an  option, you should buy it. It will simplify  your job by orders of magni  tude. Just make certain that it supports your development tools.   If you are on a limited budget or you are using DOS-C as a learning  tool,  you  will  want  to  look  into  remote  debuggers.  Many  of  you  are  probably already familiar with the remote debugging features of debug  gers  such  as  Turbo  Debugger   Borland  International   or  CodeView   Microsoft  Corp. . These run on a remote DOS machine, but the type of  remote debugger you will want to use is one that runs stand-alone. They  sometimes  require  some work to  adapt  to the target  hardware but  are  well worth the effort.  Some will also work in combination  with ROM  emulators, making the combined tools almost as powerful  as an in-cir- cuit emulator.   Getting Started  Now  that  I  have briefly  touched  on  why  and  how  to  write  your  own  operating  system,  I  will  begin  to  build  DOS-C.  I  will  approach  its  development  in  a logical  fashion  by first developing  a  set  of  require  ments. I will examine MS-DOS from the outside in order to assist in the  development of a set of general specifications. I will develop a general- purpose method of examining error recovery  and apply it to round out  our requirements. When completed, I will proceed to develop the oper  ating system itself.   The full  source code for  this book  is now  available  on the pub  lisher's  ftp  site  at  ftp.mfi.com pub rdbooks FreeDOS.zip;  login  as "anonymous"  and  download  the file. Any references  to  the "companion code diskette" in the book now refer to the code  available  on  the  ftp  site.  See  Appendix  C  for  more  details  or  check  the  FreeDOS  home  page  at  http:  sunsite.unc.edu   pub micro pc-stuff freedos  or  my  personal  web  page  at  http: www. monmouth.com user_pages pa tv  for updates.    Chapter 2   DOS Basics   Where to Start  Many  programmers  have  come  to take  MS-DOS  for  granted.  Its API  has  become  a  standard  in  the  industry  and  is  known  by  developers  world-wide. Many books, published by Microsoft  and others, describe  the  interface.  Many  other  books  contain  information  about  writing  applications for DOS, and others talk about how to extend it. Still oth  ers  describe  how  to write  extenders,  device  drivers, etc. Additionally,  periodicals  dedicate  space  to  and  books  are  published  about  the  "undocumented" system calls and data structures.   15    16 — The Free DOS Kernel   Although  Microsoft  produced  a great  deal  of  programmer  and  user  documentation  for MS-DOS, there is plenty of undocumented  informa  tion  about  MS-DOS  internals.  Proof  of  this  is  the  sheer  volume  of  "undocumented" books and articles published about MS-DOS. However,  even with the undocumented  sources, the target audience for this docu  mentation  is  application  programmers  who  want  to  emulate  some  of  Microsoft's  private programming tricks, not for programmers who want  to  design  their  own  version  of  DOS. Very  little  documentation  exists  about MS-DOS internals. You may need to provide the same interface as  MS-DOS and in some cases emulate MS-DOS internals in your design in  order to achieve any level of binary compatibility.   Whenever possible, I followed reference articles and texts during the  design.  These  references  are  very  good  and  cover  a  good  portion  of  what you need to know. However, as pointed out earlier, questions will  come up where you will need to perform  little experiments to find out  how DOS behaves. One reason is that many times, a programmer's ref  erences  cover  a  subset  of  error  responses;  however,  you  will  need  to  cover  other  undocumented  instances. Another  reason  is  that  you  can  gain insight into the DOS design by running  a test program that exer  cises a system call.   Exercising  system  calls  through  varying  conditions  is  one  of  the  best ways to study DOS. Many times, you don't know what  algorithm  the MS-DOS designers used. Quite often,  it may be possible for many  algorithms to perform certain functions.  Unlike an open system where  all functions  of the operating system adhere to a well-known  standard,  Microsoft  created  the  system  functions  and  modified  them  as  they  went along. In some cases, the changes occurred as bug fixes or as the  result  of  developer  learning  curves. In  other  cases, Microsoft  created  new  system calls to take advantage of new features  introduced  with a  release.  As  a  result,  many  applications  have  become  dependent  on  these features  and any little quirks that they may exhibit. You need to  emulate  these  features  closely  so  that  your  version  of  DOS  doesn't    DOS Basics  —17   break  existing  applications.  Although  more  than  one  algorithm  may  achieve a given function, you must choose the algorithms for your DOS  that closely emulate the original MS-DOS version.   This  chapter  contains  a  sample  experiment  whose  purpose  is  to  examine  the  minimum  set  of  files  and  other  objects  that  MS-DOS  requires to run. The goal is to demonstrate a methodology that you can  use whenever  a design  question  arises. From there, the chapter  covers  the basic DOS boot procedure, physical disk organization, API, file sys  tem, memory management, and device driver.   Basic MS-DOS  Architecture  The way I like to study any new subject  is by starting with the overall  picture. I like to peel  away the different  layers, uncovering  new  infor  mation with each new layer. I find this approach helps me comprehend  a new subject better because I will not get lost in the details too early in  the  game.  I  will  take  this  approach  and  begin  by  looking  at  the  four  basic MS-DOS files: boot,  i o. sys, msdos . sys, and command. com. You  may ask, "How do I know that these are the basic MS-DOS files?" Per  form a simple experiment to find out.   You will  format  a bootable floppy disk  as the basis  of  this  experi  ment. Take a blank disk, place it into drive A, and type format  a :  Is  at  the  DOS  prompt.  MS-DOS  chugs  along  and  gives  you  a  bootable  disk. You know it's bootable because you can now hit  Ctrl-Alt-Delete  and up comes MS-DOS. You can copy files, delete files, execute other  programs, etc. In short, every essential MS-DOS function  is available at  the new prompt.    18 — The FreeDOS Kernel   Now take a closer look at this bootable disk and see what MS-DOS has  done to it, aside from laying out track and sector structure to make it boot  able. When you examine the directory, you find one file, command. com, on  it. This file is the MS-DOS command line interpreter or shell. If you do a  dir  a :   a  : h, you find two  hidden  files,  i o . sys  and  msdos . sys   or  i bmbi o. sys  and  i bmdos . sys  in certain versions of MS-DOS  and  PC-DOS . It seems that Microsoft considers these three files to be the min  imum components needed for MS-DOS to operate.   This is interesting, but you know from  the references  that one other  component  will not  appear  in  any directory  listing because  it is not a  true file: the boot sector. The boot sector is the first sector placed onto  the disk by the  format  command after  the disk physical format  opera  tion. The PC architecture defines  its function,  and it is a de facto  stan  dard. All PC-style computers load and execute the boot sector in order  to boot any operating system; it is the final component to the minimum  set of programs for MS-DOS.   Each of the four components has a specific role in starting MS-DOS.  As you can see, your little experiment proves that only four components  are necessary  for  a minimal  DOS  operating  system.  If  you  limit  your  design  to  only  these  components   or  their  equivalent  functions ,  your  design becomes easier to handle by eliminating the development of tran  sient commands such as a t t r i b,  format,  etc.   Having  established  the  minimum  set  of  programs  necessary  for  MS-DOS to operate, you can examine the dynamics of these four pro  grams.  If  your  computer  is  a  standard  PC-class  computer  like  mine,  the  BIOS  performs  a power-on  self  test   POST   the  instant  you  turn  your  computer  on. The basic  tests  your  computer  may perform  are a  memory  test,  followed  by  a  keyboard  test,  disk  test,  and  hard  drive  test. You may  also  see  coprocessor  tests  and  other  varied  tests  inter  spersed among the basic tests. At the end of these tests, you will hear a  beep. The question now is, "What happens after the beep?"    DOS Basics  —19   The answer is simple: Your computer's BIOS now attempts to boot  the operating system from either the floppy disk or the hard disk. If it's  booting from a floppy, it brings the boot sector into memory at location  0: 7c00h. This is an important  address, because all BIOS guarantee to  load the boot at this location for compatibility reasons. If the boot sec  tor is not at 0: 7c00h, MS-DOS will not boot properly because a closer  examination of the boot program reveals that its address modes require  this  start  address   unlike  a  .com  or  .exe  file  that  can  load  anywhere  within the x86 real mode memory . If it's booting from a hard drive, the  BIOS  loads  a master boot  sector to determine the active partition  and  then loads the boot record into the same address. However, for  educa  tional purposes, you will continue to examine a floppy disk boot.   After  loading the boot, the BIOS performs  a f ar jump to  0: 7c00h.  MS-DOS  places  a boot  sector  onto  a disk  or  hard  disk  regardless  of  whether it is bootable or not. This protects the user from  inadvertently  attempting to boot from a nonbootable disk  unfortunately  only for x86  processors . By  design, the boot  checks  for  a bootable  hard  or floppy  disk by looking  at the root  directory  for  the presence  of two  required  MS-DOS  files,  i o. sys  and  msdos . sys. If boot  does not find them, it  issues the well-known  "non-system  diskette" message  and waits for  a  new disk to retry. The hard drive boot does not wait but halts, since a  boot  failure  means  that  something  is  seriously  wrong  with  the  active  partition, whereas  a floppy boot error may result from  a user inserting  the wrong floppy disk into the boot drive.   The boot next searches the root directory for  i o. sys and msdos.sys   or i bmbi o. sys  and i bmdos . sys . It reads each entry in the root direc  tory in order to determine the filenames. If these files are present, boot  proceeds to load  i o. sys. It does this by getting the starting disk sector  from the matching  i o. sy s entry, copying each sector into a fixed loca  tion in memory, and transfering  execution control to it. One  significant  boot  limitation  is that  it can  only  load  sequential  records. Boot's  size  limitation  is significantly  less than one sector, and the developers  who  created boot were very creative when it came to trading off  functional  ity versus size.    20 — The FreeDOS Kernel   Once the transfer  of control takes place,  i o . sy s proceeds to initial  ize its device drivers. These drivers are the fundamental  device drivers  that every DOS system has: floppy disk, hard drive, console, printer, and  auxiliary  serial  port.  Up  until  this  point,  boot  communicated  strictly  through the BIOS functions  in order to save space and achieve portabil  ity, but  i o . sys  now uses its device drivers for control,  i o . sys  contin  ues to initialize its device drivers by loading msdos.sys  and instructing  it to initialize itself. It then uses  msdos.sys  to read  config.sys,  if  present,  i o . sys  parses each line ofconfig.sys  and sets up the envi  ronment  space,  loads  and  initializes  the  device  drivers,  and  performs  other  functions  necessary  for  a  successful  boot.  When  i o. sys  com  pletes all this, it loads command . com and finally transfers control to it.  Notice  that  I  have  not  mentioned  the  familiar  DOS  startup  file,  autoexec. bat. That is because it is really not part of the actual boot  process  but  a convenience  placed  into  command.com.  The  designers  of MS-DOS  knew that many people modified  CP M in order to exe  cute  a program  on  startup  and that  other  operating  systems,  such  as  UNIX, had special files or directories of files that executed on startup   i.e.,   etc re .  These files are extremely  useful  in turnkey  applica  tions  and  tailoring  environments.  You  can  perform  a  short  experi  ment to verify  that  autoexec. bat  is a function  of  command. com. You  can  take  the  sample  disk  formatted  earlier  and  add  a  simple  autoexec. bat file to it. Next reboot your computer to verify  that the  new file executes. Then  change  command.com to  a simpler  or  differ  ent  command  line  interpreter.  What  you  will  see  is  the  same  as  before,  except without the execution  of  autoexec. bat.  By  verifying  that  autoexec.bat  did  not  execute  when  the  command  line  inter  preter changed, you verified that its association is with command. com.    DOS Basics — 21   You now have enough data from  this little experiment to generalize   the MS-DOS boot procedure.  1. Four  mandatory  components  of  a  basic  MS-DOS  system  are:  boot,  io.sys,  msdos.sys,  and  command.com.  Two  optional  files  are:  config.sys  and  autoexec.bat.   2.  To initiate a boot sequence, load the boot sector at 0: 7c00h and exe   cute it.   to it.   3.  Boot  must  examine  the  disk.  If  bootable,  it  loads  the  first  stage,   i o. sys   or  i bmbi o. sys , and executes it.   4.  Upon transfer  of control,  i o. sys  loads msdos . sys   or  i bmbi o. sys  loads  ibmdos.sys   and  allows  it  to  initialize,  io.sys  then  uses  msdos . sys to parse and execute confi g. sys if present.   5.  When completed,  command. com is loaded and control is  transferred   6.  command.com  executes  autoexec.bat  if  present  and  displays  the   familiar DOS prompt, awaiting user input for commands.  You will use this information  later when you design  your  architec   ture for DOS-C.   What Do Physical Disks Look  Like?  One area of mystery to many developers is the physical location of sec  tors  stored  on  a  disk.  Unless  you've  developed  disk  drivers  before,  you've  probably  never  seen  this.  Even  if  you  did  write  a  disk  driver,  odds are that you've never looked at the physical file system organiza  tion. I'll show you the physical and logical organization of the MS-DOS  file system so that the mystery will finally be solved.    22 — The FreeDOS Kernel   Generic Disk  Organization  Disk  drives  are  ubiquitous.  Nearly  every  desktop  computer,  worksta  tion, server, and mainframe  has at least one. They are the preferred sec  ondary  storage  for  computers.  Typically,  their  size  is  many  times  the  primary RAM and ROM storage contained within the computer itself.  They're  also  taken  for  granted.  Why?  Because  storing  data  onto  the  disk is  done without  regard  to either  physical  or logical  organization.  Just pause for one moment and ask yourself when was the last time you  thought about which sectors the file you just created occupies?   Before I get into such details, you need to understand the terms used  to describe  how the disk  stores data and how the disk actually  works.  Figure 2.1 is a view of a generic disk. This disk has one or more physi  cal platters  that hold the data. Each platter  allows data to be read  and  written  from  either  one  or  both  surfaces  due  to  a coating  capable  of  being  magnetized.  This coating  is  similar  to that used  on mylar  tapes    DOS Basics — 23   that store data or audio. The data is stored by magnetizing  a portion of  this  surface  as the  surface  moves beneath  a read write  head.  Unlike a  tape, where the tape is spooled from  one reel to another, a disk rotates  so that the same physical location is available once per revolution  and  data can be written and repeatedly accessed by waiting for the next rev  olution. This stripe of recorded data is called a track.   This track contains  all the data. You need to  access this data much  the  same way  you  access  internal  memory  —  you  need  to be  able to  modify it at random intervals. In order to facilitate this, the track is bro  ken  down into sectors that have prerecorded  markers   laid  down by a  formatting  program  that identifies  where a sector is physically located  on the track. By prior agreement, this sector is defined  as a fixed num  ber of bytes designed to fit within the physical space between the prere  corded  markers. With  a fixed number  of  bytes  contained  within  each  sector, you can store the number of bytes equal to the size of the sector  times the number of sectors recorded on each track.   There  is more than  one track  per  disk.  In  fact  there  are two direc  tions in which you can distribute the tracks: on different  surfaces of the  platter and across the surface. Typically, a disk has more than one sur  face.  It  usually  has  two  surfaces  and  multiple  platters.  By  placing  a  read write head in close proximity of each surface, you can access this  data by electrically switching heads and reading or writing data on this  surface. This organization is known as a cylinder because you can visu  alize the track  as physically  extending  through  each platter  forming  a  three  dimensional  cylinder  of  data. You can  now  store the  number  of  bytes  in  each  track  times  the  number  of  tracks  in  each  cylinder.  By  moving the heads, you can take advantage of the surface  area by  form  ing concentric rings or tracks on each surface  and concentric  cylinders  across the platters. With this additional  dimension  of  storage, you can  store the number  of bytes in each cylinder times the number  of cylin  ders on each disk drive.    24 — The FreeDOS Kernel   Floppy Disk Drives  To better understand how the logical MS-DOS file system organization  relates  to  the  physical  disk,  we  need  to  select  a  specific  disk  type  to  study. Hard drives vary in architecture from vendor to vendor. Just look  at the number of drive types in your computer's BIOS. Floppy disks are  much more standard and easier to study. I'll discuss a 360Kb floppy disk.  Like the generic disk, the data organization  on a floppy disk is bro  ken  into  sectors, tracks, and cylinders. The platter  on  a floppy disk is  made from mylar as opposed to aluminum or some other alloy. Because  the mylar is very flexible when compared to the metal platter, the term  "floppy" was applied to it. There is only a single platter with one or two  surfaces, so a maximum of two tracks compose a cylinder. The number  of cylinders vary, but most common is 40 or 80.   For  a 360Kb floppy, the organization  is nine  sectors per track, two  tracks per cylinder and forty cylinders per disk. Other architectures are  possible, such as 720Kb and  1.44Mb floppy disks. These disks are also  different  physical  sizes, typically  5  1 4-inch and  3  1 2-inch, but  other  sizes such as 8-inch and 3-inch existed in the past. With MS-DOS, the  sector size is typically 512 bytes, but other sector sizes were also used  in the past.   Logical Versus Physical  Both  MS-DOS  and  DOS-C  internally  reference  the  disk  drive  as  an  array  of fixed-size blocks  of  data.  Each  block  of  data  in this  array  is  sequentially numbered from zero to one less than the maximum size of  the disk  in sectors . DOS-C and MS-DOS impose a structure upon this  array  of  sectors in order to easily  access  data and  organize files. This  logical  file  system  organization  is  shown  in  Figure  2.2.  DOS-C  and  MS-DOS place a boot sector at the first sector on the disk because this  is the best defined  sector on the disk. This  sector contains the code to  load the operating system and a data structure that contains all the perti  nent variables that define  the disk geometry. For a 360Kb floppy disk,  the next sector is a reserved sector and it's followed by two FAT areas,    DOS Basics — 25   each two  sectors long. The last  area reserved by the file system is the  root directory and it's 7 sectors long. The remainder of the disk is dedi  cated to data and subdirectories.   Mapping  this logical  structure into the physical  disk requires  some  thought. In order to map the disk, you need to standardize how the log  ical sector numbers map into physical  sector, cylinder, and track num  bering. For MS-DOS and compatible operating systems, the first block  is  mapped  into  sector  1  of  cylinder  0,  track  1.  The  track  number  increases  for  every  nine  sectors  on  a  360Kb  floppy,  followed  by   Figure 2.2  Diagram  of logical file system organization  for   MS-DOS  and  DOS-C.   719  Ä  13   12   ^  6   5   4   3   2   ^   Data Area and  Subdirectories    x   Root Directory   FAT 2   FAT1   Reserved   Boot Sector    26 — The FreeDOS Kernel   increasing  cylinder  number. This mapping  is illustrated  in Figure 2.3.  The file system structure does not take up a full  cylinder and is spread  out over two tracks.   Although not immediately apparent, this organization allows for the  most rapid access when reading files sequentially. Each sequential sec  tor  can  be  accessed  immediately  upon  reading  the  previous  sector.  When the last sector on the track  sector 9 for a 360Kb disk  is read, the  first sector on the next track can be immediately accessed on the start of  the  next  rotation.  Once  all  sectors  for  every  track  in  the  cylinder  are  read  two tracks for  a 360Kb disk , the next cylinder is read by physi  cally moving the heads. This is important because there is a time pen  alty for stepping the disk heads on the order of several milliseconds. It's  also important that the sectors follow each other so that you don't incur  a penalty  of  a rotation  of the disk before  reading the next  sector. This  delay is also on the order of several milliseconds. Although the sectors  are  sequential  on  a floppy disk,  some hardware  is not fast  enough,  so  the sectors are interlaced so that the sequential disk reads are completed  in a minimum number of rotations. This is known as sector interleave  and is necessary on some smaller XT-type systems.   MS-DOS API  As I discussed earlier, Microsoft based the early MS-DOS API on the CP M  model. This model enters  all call parameters  into one or more registers  and makes a system call, possibly to a fixed address. MS-DOS offers two  such system calls. One address is es : 05h. This system call is very nearly  a duplicate of the CP M system call. CP M used the same address, and all  of the initial MS-DOS vl.O system calls  sometimes called the FCB sys  tem call, because of the reliance on File Control Blocks for disk I O  are  nearly  identical to their CP M counterparts. This model is primarily  for  the  . corn-type programs  coded  as small or tiny model programs. These  program  images  also  are  similar  to  the  CP M-style  executable  image.  Although the primary reason for this entry point is to accomodate  . com  programs, it is available to tiny- and small-model  . exe programs as well.    DOS Basics  —27   Figure 2.3  Diagram  of logical file system  organizaiton   mapped into a physical  disk.   F*T2   47  1   X  £» !  Sector 8  S  '   \\   Bottom View  through disk  — Side 0   Top View — Side 1    28 — The FreeDOS Kernel   Another MS-DOS API entry  similar to the CP M style  cs : 05h is a  call to 0:90h. As with the  cs : 05h call, this system call entry is for use  by  .exe-style  programs  that  use  medium  and  large  models  in  their  code. This entry point received little use, if any, and was actually incor  rect in some earlier versions of MS-DOS.   By far the most used and widely accepted MS-DOS API is the i n t  2xh  system calls. Unlike  CP M, the MS-DOS  designers  had  software  inter  rupts, such as i n t  21 h, to work with. Using software interrupts causes the  processor to push  i p and cs register flags on its stack. It then looks up a  new vector by translating xxh  by multiplying it by four  and placing the  long-word vector found at the previously computed memory location into  cs : i p. This is a very fast call and is highly flexible. Microsoft reserved the  range of  20h through  3f h for use by MS-DOS  and derivative operating  systems. Other interrupts are similarly used by services outside MS-DOS,  such as the system BIOS and application programs.   At the highest level, the Microsoft-reserved  vectors of  20h  through  31 h allow  a  maximum  of  18  software  interrupts.  However,  by  using  values in registers to further  subdivide each call, the technique  allows  for  13 API entry points with  almost unlimited  function  calls for  each.  Table 2.1 presents a summary of these calls.   Through its development, MS-DOS was the recipient of three variet  ies of API call methods that use the  software  interrupt  call technique.  Each technique is simple to use and well documented. They do require,  however,  that  the  programmer  become  familiar  with  each  and  follow  conventions. Otherwise, MS-DOS can break very easily.   The first type  of API  call  is  the  simple  software  interrupt.  System  calls i nt  20h and i nt  24h-29h are examples of this type of call, which  has only one defined function for each system call. Examples of the sim  plest calls are the terminate calls  Terminate Program and Terminate and  Stay Resident . Through these system calls, programs return only simple  status  information  to  MS-DOS.  Examples  of  slightly  more  complex  calls are the Absolute Disk Read and Absolute Disk Write calls. As with  the  simpler  calls, there  is no modification  to  function  behavior  by  the  call,  and  the  call  performs  only  one  function.  These  calls  are  only  slightly more complex in that the system call returns to the caller  after  performing its function,  allowing the application program to continue.    DOS Basics  —29   The second type of API call is characterized by multiple functions avail  able through a single  i nt  xxh entry. The primary DOS API  i nt  21 h is  an excellent example. To select a function,  load register ax with a func  tion number that corresponds to a unique  system call. The  application  program loads other registers with variables applicable to the particular  system call or pointers to an area of memory for system calls. MS-DOS  then performs  the operation and returns its results in registers or mem  ory pointed to by registers.   Table 2.1  DOS  i n t System Calls.   int  Number  20h  21h  22h  23h  24h  25h  26h  27h  28h  29h  2ah  2bh  2ch  2dh  2eh  2fh  30h  31h   Function   Terminate program  System calls  Termination address  Break address  Critical error  Absolute disk read  Absolute disk write  Terminate and stay resident  Idle handler  Fast console I O  Network handler  Not defined for DOS kernel  Not defined for DOS kernel  Not defined for DOS kernel  comma nd.com reload  Multiplex interrupt  fa r jump DOS entry  Part of 31 h    30 — The FreeDOS Kernel   The  MS-DOS  int  21 h system  call  is  also  the  best  documented  example  of  this  type  of  system  call.  Close  examination  of  this  API  reveals that many functions  contain not only a major  function  number  but a minor function  number as well. This allows greater expansion of  system  calls  and  also  allows  for  logical  grouping  of  related  system  calls. The IOCTL system call is the best example of this.   The third type of API call is the chained  system call. Chained sys  tem calls used by MS-DOS extensions, such as installable file systems  and network system calls, are similar to the techniques used to extend  MS-DOS by third-party vendors. The multiplex interrupt,  int  2 f h, is  an example of this call. When an application  or MS-DOS uses a func  tion installed into the multiplex chain, it loads a major  and minor  func  tion number into the  a x register. Each extension  saves the call context  and examines the  ax register. If it matches, it performs  the service and  returns to the application or MS-DOS through an i ret  instruction. If it  is not a function  defined within the extension, MS-DOS restores the call  context and passes control to the next extension's entry point stored dur  ing  installation  of  the  extension.  Should  no  extension  handle  the call,  MS-DOS performs a default action and returns to the application.   You need to study these API calls because a clear understanding of  system  call  techniques  will  be  very  important  later  when  you  design  your  DOS-C  API.  Because  the  goal  is  to  create  a  DOS-compatible  operating system, you will need to respond to the same type of system  calls  in  order  to  guarantee  a level  of  compatibility.  The exact  mecha  nisms will be discussed in later chapters.   MS-DOS  File  System  The MS-DOS  kernel  supplies  applications  with  a number  of  services.  These services provide process management, memory management, file  management, and miscellaneous services. Probably the greatest number  of MS-DOS system calls relate or pertain to file management. This sec  tion explores the MS-DOS primary file system, the File Allocation Table   FAT  file system, and examines key details and data structures.    DOS Basics — 31   As I discussed earlier, the original MS-DOS purpose was to manage  small, 160Kb floppy disks. Fixed disks with gigabyte storage capacities  on  a desktop  computer  and  multimegabyte  memory  were unheard  of.  Instead, MS-DOS designers faced space restrictions both on disk and in  memory. They  also faced  high rotational  and head positioning  latency  times inherent to the 51 4-inch floppy disk drives. This forced MS-DOS  designers to be creative in both disk layout and system call  functional  ity. This creativity will be apparent as you closely examine the FAT file  system.   Begin the examination of the FAT file system by examining a simple  DOS floppy disk that contains only a root file system and is representa  tive of a freshly formatted floppy disk. Its structure is flexible enough to  be  compatible  with  almost  any  removable  media,  regardless  of  size.  Figure 2.4 illustrates a conceptual model of disk storage in an operating  system  compatible  with  MS-DOS.  In  MS-DOS,  a  logical  disk  is  a  sequential  set  of  512-byte  sectors. The  disk  consists  of  a boot  block,   Figure 2.4  Floppy disk storage  model.   Boot Block   Reserved   FAT  Area   Root   Directory    32 — The FreeDOS Kernel   followed  by  zero  or  more  reserved  sectors,  and  the  file  system.  The  boot  and reserved  sectors  are  for  disk booting  and  disk  maintenance,  although the boot sector also carries file system  information.   Following the boot-related area is one or more FAT areas. Each FAT  consists of one or more sequential sectors in which each entry consists  of a forward  pointer in a linked list of pointers. Values of zero indicate  free  space,  and  other  values  indicate  bad  sectors,  disk  size,  and  disk  type. The need  for  more than  one FAT stems from  the greatest  weak  ness  of  the  MS-DOS  file  system,  the  FAT itself.  If  a  program  crash  destroys  a FAT, no other information  anywhere  within  the file system  allows you to recover your files. Because disks are probably the compo  nent in a computer with the lowest reliability, redundant FATs improve  the file system reliability compared to a single FAT.   Immediately  following  the  FAT s   is  the  root  directory.  In  early  MS-DOS days, the root directory was the only disk directory, similar to  its CP M cousin. All data relating to filename, location, creation  date,  file size, and file protection  are contained within  an entry in the direc  tory. Starting  with MS-DOS  v2.0, the file system became  hierarchical  with  other  directories  that  extend  from  the  root  directory.  However,  there  are  differences  between  a root  directory  and  other  disk  directo  ries. The first significant  difference  is that the root  directory  does not  contain  an  entry  for  "."   itself   and  ".."   its  parent   directories.  This  choice  allowed  for  backward  compatibility  with  systems running pre- 2.0 versions. Another  significant  difference  is that the root directory is  fixed in length, although a subdirectory can be expanded. Again, com  patibility with pre-2.0 versions forced this limitation.   Hard  drives  are  very  similar  to the  diskette  in  design.  The  biggest  difference  is that hard drives can  support multiple  disk images, which  in turn can support more than one operating  system. This concept bor  rows the idea of multiple volumes from other operating system designs.  It improves on the concept by placing the multiple-volume concept out  side the operating system and in control of the boot code. Each volume  is called a partition and shares a single master boot record.    DOS Basics — 33   As  with floppy disks, when  an x86  system boots, it loads  the first  sector into memory. The difference  between the floppy and hard disk is  in the functionality  of the boot code contained in this sector. The master  boot record contains code that examines a partition table also contained  in this sector. It determines the active partition and proceeds to load the  first sector of this partition into memory. The remainder of the boot pro  cess is then exactly the same as for a floppy disk. By using this design,  the file system remains identical for both floppy disks and hard disks.   However, certain on-disk changes to the data structure are necessary  when certain physical sizes exceed certain structure member sizes. This  occurs  on  drives  when  the  physical  size  begins  to  exceed  a  12-bit  encoding  limit  in  the  FAT  and  a  16-bit  limit  on  the  device  drivers.  These limits challenged MS-DOS but its designers were smart enough  to extend to 16-bit FAT entries and 32-bit block addressing to overcome  these hurdles.   What  you  have  seen  so  far  is  the  principal  MS-DOS  file  system  architecture. Other file systems are supported by MS-DOS, such as the  CD-ROM  file  system,  but  I  will  not  cover  them  due  to  space  limita  tions. However, I will further  examine each of the file system compo  nents in detail so that you can design your DOS clone.   Boot Area  The first area of the disk, as seen earlier, is the boot area. This area con  sists of the boot sector plus zero or more reserved sectors. You already  know that this sector executes first in order to start MS-DOS, and you  know that every  disk has one whether  it is bootable  or not. What  you  don't yet know is what the structure of this sector is and how MS-DOS  knows how to access a given sector on different  disk geometries.    34 — The FreeDOS Kernel   Figure  2.5  shows  a  diagram  of  the  boot  sector.T  Three  areas  are  shown   although this varies for  Master Boot  sectors . Every  disk boot  must contain  these three  areas. The first area, called boot  sector,  con  tains  an important  disk  structure  with  all information  about the archi  tecture of the disk. The second area is the body of the executable boot   f  File  system  structures  are  presented  as  diagrams  in  this  book  to  avoid  confusion.  The  MS-DOS  design  is  for  80x86  processors  and  ignores  portability  issues. As  a result,  all  data structures contained on disk reflect  80x86 byte and word order. Additionally, all infor  mation published by Microsoft reflects the assembly language roots of MS-DOS through its  presentation as assembly language data structures. Later chapters address portability issues  and techniques. All data read from and written to a storage medium respects MS-DOS con  ventions, but all in-memory data structures are native C structures for  efficiency.   Figure 2.5  Floppy disk boot sector diagram.   0   03eh   Boot Sector   62 Bytes   Boot Code   448 Bytes   Olfeh   Signature   2 Bytes    DOS Basics — 35   code. The final area is a signature word,  0x55aa, used to identify  this  sector as a valid boot sector.   The earlier discussion centered on how MS-DOS boots. In it, I dis  cussed  loading  the boot  sector  into location  0:7c00h  and  transferring  control to this  address. I also  spoke about various  disk  geometries.   Figure  2.6  The boot sector data  structure.   bsJump  bsOemName  bsBytesPerSec  bsSecPerClust  bsResSectors  bsFATs  bsRootDirEnts  bsSectors  bsMedia  bsFATsecs  bsSecPerTrack  bsHeads  bsHiddenSecs  bsHugeSectors  bsDriveNumber  bsReservedl  bsBootSicmature  bsVolumelD  bsVolumeLabel  bsFi1eSysType    36 — The FreeDOS Kernel   I will use the boot sector data structure, shown in Figure 2.6, to explain  how this is possible.   The  first  entry  in  this  table  is  an  area  called  bsJump,  which  is  a  reserved entry that contains an Intel 3-byte jump: either e9 xx xx abso  lute jump  or  e b xx  90 relative jump.  Fortunately,  the  ugliness  of  the  Microsoft  design for Intel processors rears its head only with this entry.  The sequences are actually Intel opcode for an absolute jump or a rela  tive jump  followed  by  a  no-op  instruction.  It  does,  however,  explain  how the disk information   in the boot sector area  placed  ahead of the  boot  code does not interfere  with the booting  process  since this  entry  points to the actual boot code entry address.   The remainder of the data structure is much of what you expect from  the  boot  area.  The  next  entry,  bsOemName, is  8 bytes  allocated  to  an  OEM name and version. This entry identifies  who formatted  the disk,  not  which  operating  system  is currently  running.  It  is  on the  disk  for  information  only and serves no other purpose.   Starting with the next entry, the boot sector duplicates the MS-DOS  BIOS Parameter Block  BPB . The first BPB entry, bsBytesPerSec, is  a 16-bit entry that specifies how many bytes are in a sector. This is typ  ically 512, but can be  different.   The next area, bsSecPerClust,  indicates how many sectors are in a  cluster. Although I have not discussed the cluster yet, this is where you  first encounter it. A cluster is a group of sectors used as a  fundamental  unit  of  storage  allocation  and  serves  two  purposes.  First,  it  places  a  level of indirection between the operating system and the physical disk  media format.  This allows changes in disk and operating  system tech  nologies to be mutually exclusive. Second, it allows disk sizes to grow  much  larger  than  would  be  possible  with  just  a  sector  allocation  scheme. An  example  is  a typical  hard  disk  allocation  scheme.  These  disks typically use 4096-byte clusters, allocating  8 sectors per  cluster.  If the addressing limit is 16 bits, the limit is 33Mb of storage using sec  tor  allocation  but increases  to 268Mb using  an  8Kb cluster  allocation  scheme. With  32 bits,  sector  allocation  yields  approximately  2200Gb  and 17,600Gb respectively.    DOS Basics — 37   The entry  bsResSector  specifies how many reserved sectors are on  the drive or disk, including the boot sector. This entry is useful  for both  the operating  system  and the boot program. As you  will  see later, the  operating  system uses this entry in computing the location of key disk  data  structures.  Boot  can  use  this  entry  to  compute  how  many  addi  tional sectors to load into memory for more complex booting schemes.  An example of such a scheme may be booting multiple operating sys  tems.  It  is possible  for  boot  to  load  a  secondary,  more  complex  boot  program  that  would  then  proceed  to  present  a  menu  and  load  the  selected  operating  system.  Other  schemes  are  also  possible,  limited  only by the developer's imagination.   Jumping  ahead,  bsMedia  is the media descriptor. This  scheme was  an  early  attempt  at  automated  identification  of  the  media  type  that  is  present  in  a drive. MS-DOS  passes  this  byte, by  specification,  to  the  device driver. Originally, this entry  switched  a drive from  low to high  density.  It  is,  however,  an  incomplete  scheme  where  the  same  byte  appears  to  specify  more  than  one  type  of  media  to  the  same  device  driver. Although Microsoft  may use it, I will only pass it to the device  driver for compatibility purposes.   The entries  bsFATs, bsRootDi rEnts,  bsFATsecs,  bsSecPerTrack,  and bs Heads, when combined with bs Res Sector,  are used to translate  a logical  sector  number  to  a physical  sector  location.  For  example,  to  get  to  the  primary  FAT  disk  logical  sector,  start  at  logical  sector  bsResSector   logical  sectors  start  at 0 . To get to the  secondary FAT  logical  sector, start at  bsResSector  +  bsFATsecs. An interesting  note  is  that  more  than  two  FATs  are  permitted  on  any  disk,  implied  by  bs FATs. So, if you want to get to the nth FAT, start at   bsResSector +  n*bsFATsecs    resulting in the generalized FAT algorithm.    38 — The FreeDOS Kernel   From Figure 2.4, you  saw that the root directory  followed  the FAT  areas. You can compute the start of the root directory with the algorithm   bsResSector  +  bsFATs*bsFATsecs .   Finally, any data sector you need to find starts at the logical sector   log sectors  bsResSector  +   bsFATs*bsFATsecs    +  32*bsRootDi  rEnts bsBytesPerSec .   Because I have been talking about logical sectors, you will later see  that this is the method MS-DOS uses to convey a desired  sector to the  device driver. The de facto  DOS convention  for physical translation  is  the  sequential  cylinder  model,  where  each  cylinder  is  composed  of  a  number of tracks, and cylinders increase with logical sector numbering.  To translate  a  logical  sector  to  a  physical  cylinder,  track,  and  sector  model, the cylinder number is computed as the integral computation   log  secfor  bsSecPerTrack*bsHeads .   The track number is computed by   log sector mod   bsSecPerTrack*bsHeads  bsSecPerTrack.   Finally, the physical sector number is     log sector mod   bsSecPerTrack*bsHeads     *mod bsSecPerTrack    + 1.    Physical sector numbering starts at  1.    There are only two other key entries, bsSectors  and bsHugeSectors.  These entries are used for error checking by the device driver. If a logical  sector number is greater than or equal to bsSectors  or  bsHugeSectors,  then  an  error  condition  exists. The  reason  for  two  separate  entries  is  historical. Originally, bsSectors  was the only entry governing disk size.    DOS Basics — 39   It is limited to 16 bits, which is insufficient  for larger hard disk drives. Dur  ing its evolution, MS-DOS  gained  a second entry to handle these larger  drives, bsHugeSectors. The method used to decide which entry to use is a  simple algorithm: look at  bsSectors,  if it is zero, use  bsHugeSectors,  else use bsSectors.   The   remaining  entries,  bsBootSignature,   bsVolumeLabel,  bsReservedl,  bsVolumelD,  bsDri veNumber,  and  bsFil eSysType,  deal with disk volume identification  or are internal data structure mem  bers. The remaining  sector,  bsBootSignature,  is used  in  other  calls,  and all of the remaining data structure members are informational  only.  bsHiddenSecs  is an additional  entry that  allows MS-DOS  to hide,  or  reserve,  additional  sections  that  are  hidden  from  the  file  system.  However, bsHiddenSecsis rarely used.   FAT Area  Interestingly enough, the FAT is probably the best-documented  area in  all of MS-DOS. Frankly, I don't know why, but I will review it here in  order to present a complete MS-DOS file system discussion. For those  of you who find this boring, skip ahead.   All files contained  on  the  basic  DOS  file  system  are  composed  of  three distinct parts: a directory entry, a linked list in a FAT, and a collec  tion of disk sectors that contain the information  in the file. I will discuss  the directory entry later, but for the purposes in this section, the directory  entry contains the means by which MS-DOS identifies  the file by name  and by a number used as an index into the FAT array. For example, when  MS-DOS  opens  a file for  read  access, it finds the file by matching  the  filename and retrieves the starting FAT index. In essence, this is the only  action necessary to open a file, although MS-DOS maintains other inter  nal data structures that are also updated.   The FAT and the data area have a one-to-one relationship. This rela  tionship allows MS-DOS to keep track of the data clusters in an  efficient  manner.  By  definition,  each  FAT  entry  corresponds  to  its  equivalent    40 — The FreeDOS Kernel   sequential cluster. For example, any reference  to cluster number 3 also  refers to FAT entry number 3. The FAT functions  as a linked list. If you  want to find the cluster that  follows  cluster  number  3, you look  at the  FAT entry number 3 and get its content. This number now gives the next  data cluster number. Figure 2.7 illustrates how this works.   In the example, you  see two files. The first file, autoexec.bat,  is  probably  very  close  to  one  you  may  have  on  your  boot  disk.  When  MS-DOS  opens the file, it first goes to the directory  and begins a lin  ear  search  for  the  filename  autoexec.bat  by  looking  for  a  string  match. When MS-DOS finds a string match, it performs  some internal  updates  to  the  file  table  and  picks  up  the  entry  for  the  starting  disk  cluster, in this case 2. An interesting note about this entry, all clusters  on a disk begin with cluster number 2, with 0 reserved  as a free  clus  ter indicator and  1  reserved for MS-DOS. This is important when you  begin your design.   If  you now  instruct  MS-DOS  to read  the file sequentially,  you  will  read  all  sectors in cluster  number  2 first. MS-DOS  does this in one of  three ways, depending on the number of bytes requested and the current   Figure 2.7  MS-DOS FAT read example.   AUTOEXEC  BAT   DATAFILE  TXT   2   6   FAT  OfOh  fffh  003h  004h  fffh  OOOh  007h  009h  ff7h  OOah  fffh   0  1  2  3  4  5  6  7  8  9  10   Cluster  MD  RSVR  1  2  EOF  FREE  1  2  BAD  3  EOF   0  1  2  3  4  5  6  7  8  9  10    DOS Basics — 41   position of the MS-DOS internal file pointer. In the first case, when you  read less than a whole sector and the file pointer is at an arbitrary posi  tion within the file, MS-DOS reads a sector from the cluster into a buffer  and transfers  the requested  number  of bytes to memory. In the  second  case, where the file pointer is at the start of a sector boundary  and the  requested number of bytes is a multiple of a sector, MS-DOS  transfers  the data directly into memory. In the third case, the internal pointer is at  an arbitrary position and the requested data transfer is greater than a sec  tor. In this case, MS-DOS performs  a combination of actions of the first  two cases and continues until a new cluster is needed.   When  MS-DOS  begins to read the next cluster,  it needs to find its  physical location on disk. It does this by looking at the FAT in the entry  corresponding to the current cluster number. The number it reads corre  sponds to the next entry to be read. In this fashion, each FAT entry cor  responding  to  a  physical  cluster  forms  a  forward  link  for  the  corresponding  file  data  area.  This  process  continues  until  MS-DOS  encounters an end-of-file  marker. The example in Figure 2.7 shows this  for the third cluster of a utoexec. bat. The sequence of clusters is 2, 3,  and 4. FAT entry 4 contains an  f f f h, which signals MS-DOS that this  is  the  last  cluster  of  the  file   by  definition,  any  entry  in  the  range  of  f f 8h through f f f h indicates the end-of-file . Table 2.2 lists all possible  values contained  in a FAT entry  and their meanings. One note — this   Table 2.2  FAT entry values and  meanings.   Value    0 000h    0 001h    0 002h- f fefh    f ff0h- f ff6h   f ff7h    f ff8h- f fffh   Meaning   Free cluster   Not used   Data cluster indices   Reserved   Last cluster   Bad Cluster, used for bad sector mapping    42 — The FreeDOS Kernel   Figure 2.8  MS-DOS FAT  write example.   Before create operation   Directory   AUTOEXEC  BAT   ♦  SMALL   TXT   AUTOEXEC  BAT   EXAMPLE  SMALL   TXT  TXT   2   6   2   5  6   ♦  = 00hor0E5hin  first filename byte.   After create, write, and close   Directory   FAT  OfOh  fffh  003h  004h  fffh  OOOh  fffh  OOOh  OOOh   ►  ►   Cluster   MD  RSVR  1  2  EOF  FREE  1  FREE  FREE   0  1  2  3  4  5  6  7  8  9  10   FAT  OfOh  fffh  003h  004h  fffh  007h  fffh  008h  fffh   Cluster  MD  RSVR  1  2  EOF  1  EOF  2  EOF   0  1  2  3  4  5  6  7  8  9  10   0  1  2  3  4  5  6  7  8    DOS Basics — 43   discussion uses  12-bit values, which correspond to the type of FAT typ  ically found  on floppy disks and small hard disks. You quickly run out  of range on larger hard disks, so a 16-bit FAT is used for these. This dis  cussion holds true for  16-bit FATs, just sign extend the numbers.   For a write, the operation is somewhat more complex because file posi  tion plays a big part in how write works. However, you can examine some  fundamental  MS-DOS FAT principals for write with a simple sequential  file  create and write example. Figure 2.8 illustrates this example.   In the example, you start by creating exampl e. txt, the example file.  First,  MS-DOS  searches  for  a free  directory  entry  to begin  its  alloca  tion. It does this by searching for either a 00h or 0e5h for the first char  acter  of  the  entry   I  will  discuss  their  meaning  in  the  next  section .  When it's found, internal file data structures are updated and the opera  tion  is  complete. You  can  now  begin  the  write  operation,  and  this  is  when the FAT fun starts. As soon as you do a write, the very first cluster  allocation occurs. In the example, cluster 5 is the first available cluster  and is allocated to our example file. When you have written exactly one  cluster size plus one byte, the next cluster is allocated. In the example,  cluster 6 is occupied by a cluster belonging to sma 11 . txt,  so the search  returns cluster 7. The FAT forward link entry for cluster 5 now contains 7  and the writing continues until you finally close the file. In the example,  this  occurs  somewhere  in  the  third  cluster.  MS-DOS  updates  its  data  structures  and places  an EOF indicator  in the FAT forward  link entry,  relative cluster 3 or physical cluster 8.   I have been very careful  in discussing the write operation by avoid  ing  all  references  to  time  in  my  discussion. As  MS-DOS  matured,  it  seems that the timing of the actual physical write to disk changed. Also,  I wanted to keep the discussion very generic because in the later design  you will want to add some robustness to DOS-C, and you will see that  the method used to update the physical disk dictates exactly how much  of a file is recoverable in the event of a hardware or power failure  dur  ing the write operation.    44 — The FreeDOS Kernel   Directory Area  and Directories  The last part of the FAT file system discussion  is the directory  area.  I have already covered both the data area cluster mapping and the FAT  forward  link  and  shown  how  an  MS-DOS  file  is  composed  of  three  components.  The  directory  is  the  glue  that  holds  the file together.  In  MS-DOS, there are two types of directories, the root directory and sub  directories. I draw this distinction because there are some subtle  differ  ences between them.   The first distinction is that every disk must have a root directory. The  root directory is the starting point for all directories and files. Whenever  a  search  down  any  path  is  started,  starting  from  the  root  directory  is  guaranteed to get you to the exact file or directory.   Another  difference  is  in  the  contents  of  the  root  directory.  A  root  directory contains entries not only for files and subdirectories but also for  the volume label that appears  at the top of a d i r  command  output. It  is also why the volume label has a limit of  11 characters: It must fit into  the  space  normally  reserved  for  filename   8 bytes   and  extension   3  bytes . Additionally, it also does not contain an entry for "."  self  and ".."   parent , whereas all subdirectories must always contain these entries.   The final distinctions between the root directory  and  subdirectories  are location  and size. The root directory consists of a sequential  set of  sectors starting at a fixed location on the disk, whereas a subdirectory is  actually a special MS-DOS file that can only be accessed by MS-DOS  itself for both read and write. The size of the root directory is fixed by  an entry in the boot area, and subdirectories can grow in much the same  way a file can. As you will see later, these differences  are critical in the  design of directory handlers within DOS-C.   Having noted these critical differences,  I can now state what is com  mon in all types of directories. Any MS-DOS FAT file system directory  is  stored  as  a linear  array  of  directory  entries. The  rules  for  use  of  a  directory  entry  are  common  for  all file types. Figure  2.9  illustrates  a  directory entry structure.    DOS Basics — 45   There are not very many directory entry fields, reflecting  the simple  function  that a directory entry performs within MS-DOS. The directory  entry performs four functions: name the file, specify  access rights, hold  time stamps, and specify the file location and size.   When it comes to filenames, MS-DOS borrows from its CP M heri  tage  by  borrowing  the  filename  and  file  extension  method.  MS-DOS  limits  the  filename  to  an  8-byte  entry  and  the  extension  to  a  3-byte  entry. Each entry is left justified  and space filled. Hence the file "abc" is  stored as " A B C ^ ^ ^ ",  the file "B.C" is " B ^ _ _ _ C _ ",  and the  file "FileName.Txt" is "FILENAMETXT". There are no typographical  errors  in the  previous  example;  all filenames and  extensions  are  con  verted  to upper  case by MS-DOS, further  simplifying  filename  match  algorithms. One final note, an unused field is denoted by  a  00h  and a  deleted file by a 0e5h in the first location of deName. This distinction is  important, because MS-DOS stops its linear search in a directory when  it encounters  00h. It is an interesting way of making files disappear on  an MS-DOS disk.   Figure 2.9  Directory entry  structure.   deName  deExtension  d e A t t r i b u te  deReserved  deTime  deDate  d e S t a r t C l u s t er  d e F i l e S i ze    46 — The FreeDOS Kernel   The  deAttribute  entry  restricts file access. In  this field, a set bit  indicates that an attribute is active. Table 2.3 lists these attributes. One  interesting  note — the  ATTR_ARCHIVE bit  is  actually  a "modified"  bit  set, whenever MS-DOS  does a write operation to the file. In this way,  MS-DOS knows that a file with this bit set needs to be archived.   For  people  who  are  familiar  with  UNIX  and  other  operating  sys  tems, these attribute bits and file restrictions seem primitive. In essence,  they are sufficient  for  a small, personal  system. I will revisit these bits  and their meanings later in the design of DOS-C.   Time  stamping  is another  function  of the directory  entry  for  which  MS-DOS uses the last file access that modified  the file to generate the  date and time fields. The choice of encoding method was the preference  of the operating system architect. Unlike UNIX where the time stamp is  seconds from  an epoch, the MS-DOS time stamp consists of both date  and time. Like UNIX, the MS-DOS time stamp is 32 bits wide, broken  into a  16-bit date field and a  16-bit time field. These two fields are  fur  ther broken down into bit fields composed of the logical parts of the ele  ment, such as hours : minutes : seconds and year: month: day,  as shown in  Figure  2.10.  Time  stamps  will  become  a  critical  data  item  to  update  when I visit functions  such as create, write, and close later in our design.   Table 2.3  Attribute bits of the de A tt  ribut  e entry.   Mnemonic   Value   Meaning   ATTR_READONLY   ATTFLHIDDEN   ATTFLSYSTEM   ATTR_VOLUME   ATTR_DIRECTORY   ATTR_ARCHIVE   Olh   02h   04h   08h   10h   20h   A read-only file   Hidden or directory  can't delete    System or directory  can't delete    Volume label, not a file   A directory   Modified file    DOS Basics — 47   The final ties, and probably the most important, are the file location  links. These fields link the FAT and data clusters to the directory entry.  The field deSta rtCl uster  is the FAT link to the first FAT entry. This is  in essence the anchor for the file. The entry de Fi 1 eSi ze completes the  file description  by  specifying  the  size  of  the  file  in  bytes. With  this  entry, the file becomes independent of file system architecture or cluster  size. It does, however, limit physical file sizes to 4.3Gb.   The design  of the directory  is pivotal in  any program that  manipu  lates  a FAT disk,  and  it  is  no  exception  in  DOS-C.  Design  tradeoffs  concerning  the  timing  of  directory  updates  will  affect  file  system  robustness.  There  are  also  design  issues  regarding  when  to  switch  between  16-bit and 32-bit FAT tables, etc. I will examine these in later  chapters and use the information presented here during the design.   Figure 2.10  Date and time format  used in the directory entry.   15   10   9   6  5   0   Year    from  1980    Month   Day   15   11  10   5  4   0   Hours   Minutes   Seconds   NOTE: Logical word format  shown.    48 — The FreeDOS Kernel   MS-DOS  Memory  Management  In  all except  the simplest  operating  systems,  there  exists  one form  or  another of memory  management.  The reason is simple: memory  is yet  another  computer  resource  given  to the operating  system  to  maintain.  How  an operating  system performs  this  management  varies  drastically  among  systems. For example,  large  operating  systems,  such  as UNIX,  provide memory management in multiple forms. One is for program use  as part of a heap management scheme. Another is for the program itself,  either maintaining it for program loading or dispensing it in a fashion that  gives the program the illusion of much more memory than is physically  available. MS-DOS manages memory using a much simpler scheme but  still manages program heap requirements and program loading space.   I must admit that the developers of MS-DOS did the best they could  with a poor architecture. In many computers other than those based on  the original PC and XT architecture, there is some form of a hardware  memory  management  unit,  which  provides  two functions:  protection  and relocation. On these machines, protection is achieved by disallow  ing writes to occur based on some table, either in memory or within the  memory management unit itself. Typically, the write protection can be  specified  over  portions  of memory.  This  capability  helps  make  these  other  machines  more resilient  to occurrences  of wild pointers, patho  logical  programs,  etc., protecting  other  programs  and  the  operating  system  in the process.  It  is  much  harder  for  application  programs  to  crash these machines. Relocation  allows the operating  system to move  physical  memory  around  and make  it look  as though  it is  contiguous  logical  memory.  Memory  becomes  available  to a program  in either  a  straightforward  manner for allocation or on demand for virtual memory.  At  the time  of  the  development  of  the PC, the  desktop  computer  market was based on simple systems running with simple microproces  sors. When IBM decided to enter the market, it decided to emulate the  simpler computers rather than introduce proven technology that it had  used on its mainframes  and minis. This unfortunate  choice has always  been a weak spot for MS-DOS, because it suffered  attacks from  critics  for being vulnerable to crashes.    DOS Basics  —49   The developers of MS-DOS did, however, introduce  some forms of  memory  management  through  the  use  of  a memory  block  linked  list  that consists of a control header, known as a memory control block or  arenaheader, and the allocated  or free  memory.  By now, it should be  obvious that the linked list is the data structure of choice for MS-DOS.   To their credit, they did the best with what they had, and the MS-DOS  memory management scheme does provide a fair degree of control.   Figure 2.11  illustrates  the MS-DOS  arenaheader.  Throughout  the  history of MS-DOS, the a rena header  has been referred to as the MCB  or Memory Control Block  they are the same data structure . This data  structure is in front of each allocated and free memory block. In the first  640Kb, these control blocks contain an "M" in a rena Si gnat u re for all  headers  except  the  last  one,  which  contains  a  "Z".  The  next  field,  arenaOwner, contains the segment value of the PSP  Program Segment  Prefix   when  it belongs  to  a user  or contains  a  0008h  if  it belongs  to  MS-DOS. This  value  identifies  the block's  owner  and  is used  to dis  pose of memory when a program terminates. The next entry, arenaSize,  is  used  to  indicate  the  size  in  paragraphs  of  the  memory  block.  arena Re served  is  currently  unused  within  MS-DOS  and  is  reserved  for potential future  use. The final area,  a rena Name, contains either the  name  of  the  program  that  it  belongs  to,  or  a  special  name  such  as  "UMB" to indicate  a special  arena. When  MS-DOS  divides  a  special  arena  into  subarenas,  it  applies  the  same  arenaheader  and  manage  ment techniques to these areas.   Figure 2.11 f  The arenaheader  data structure.   arenaSignature   arenaOwner  arenaSize  arenaReserved  arenaName    50 — The FreeDOS Kernel   MS-DOS also provides a number of API calls to manage the arenas.  The basic  management  provided  is  simple  allocate  and dispose.  Calls  are also used to set allocation strategy, such as first fit, last fit, and best  fit. Additionally,  there  are  calls  that  detect  and  manipulate  the  upper  memory blocks.   MS-DOS uses special arena calls to further  subdivide an arena when  used for  special MS-DOS  applications. One special  arena usage is  for  special  storage  allocations  specified  in  config.sys,  such  as  new  stacks, File Control Blocks  FCBs , and device drivers. Another special  arena  usage  is  to  identify  and  subdivide  the  upper  memory  blocks,  which  MS-DOS  uses  to  load  device  drivers  and  the  kernel  itself  into  memory above the conventional 640Kb limit.   MS-DOS  Task  Management  Task  management  in  MS-DOS  is  very  simple.  There  are  only  three  methods  of loading  a program: load  and execute, load, and load  over  lay. Readers who are familiar with other operating systems may find the  limited selection a surprise, but they represent the minimum set neces  sary for  a small operating  system. When combined with the Terminate  Program and Keep Program system calls, the load methods offer  a pow  erful  set of system calls.   I  want  to  point  out  to  the  reader  that  although  MS-DOS  offers  a  small selection of system calls that handle program execution, there is a  great deal of work that MS-DOS must perform for these calls. Examine  the  Load  and  Execute  Program  system  call  as  an  example.  The first  thing  that  MS-DOS  does  is  look  for  the  executable  file  and  identify  what type of executable file it is:  . com or  . exe. It does this by examin  ing the first two bytes. If it sees the correct  . exe signature, it proceeds  to load the file and do the correct relocation by correcting  all segment  references  contained  within  the  file.  Otherwise,  it  assumes  that  it's  a  . com file and just loads the file directly into memory. It then creates the  PSP and populates it with all inherited file handles, updates the termi  nation  address,  Ctrl-C  handler,  and  critical  error  handler.  Next,  the  starting  address  is  determined,  a  program  stack  is  allocated,  and    DOS Basics — 51   machine registers are loaded. At this point, control is transferred  to the  loaded  program.  Much  of  the  same  effort  goes  into  the  Load  system  call. The only difference between the two is that transfer of control does  not take place for Load. Another method is Load Overlay, but this only  loads a program without changing the PSP or special handlers.   When program execution completes, two system calls are available:  Terminate  Program  and  Keep  Program.  There  is  considerable  differ  ence between these two calls. Both system calls store a program return  value available to the parent program, but they soon differ  in  function.  The  Terminate  system  call  proceeds  to  undo  everything  done  by  the  Load  system calls. It must begin by replacing the termination  address,  Ctrl-C handler, and critical error handlers with those of the parent and  go through the PSP and operate on the child's file handles. After all this  is complete, it returns the program's memory back to the memory pool,  effectively  destroying  the  program  image.  Control  is  then  transferred  back to the parent program and execution continues within the parent.  In  contrast,  the  Keep  Program  system  call  must  omit  destroying  the  image, closing files, etc. The reason  for  this is  simple: Whereas  other  operating  systems have the concept of daemons built into them —  for  example, UNIX uses daemons for  all of its networking,  cron  program  scheduling,  line printer  functions,  and  other tasks — the  only  way  to  accomplish a similar task in MS-DOS is to terminate the program and  keep its image in memory. The technique  is known  as TSR  or Termi  nate  and  Stay  Resident.  It  is  for  this  reason  that  Keep  Program  must  keep the image and associated  data structures, such as the PSP, intact,  since the program may be triggered by an external event. With this in  mind,  the  differences  become  clear.  Keep  Program  only  stores  the  return code and returns control to the parent program. This  guarantees  that the program image remains intact.    52 — The FreeDOS Kernel   MS-DOS  Device Drivers  The MS-DOS device drivers are simple in design but difficult  to imple  ment in C, not because the code is complex, but because the data struc  ture  used  to  communicate  with  the  device  driver  is  actually  designed  for  assembly  language  and results in a very complex  union  to imple  ment. The major  contributing  factor  is that the structure implements  a  common  beginning  for  control  information,  but  the  following  data  areas vary for each call. I will examine the mechanism used to control  driver entry points and a portion of the common data structure.   The design of MS-DOS device drivers is very much tied to the x86  architecture. If you examine Figure 2.12, you will see two sets of point  ers that are different  in size. The first pointer, dh Li n k, links together all  the device drivers used by MS-DOS, both internal and loaded  through  config.sys.  The other two pointers,  dhStrategy  and  dhlnterrupt,  are offsets  into the two driver entry points. For these calls, the  device  driver segment is assumed to be the segment for the call, restricting the  device driver size to one segment.   The two names of the entry points, dhStrategy  and  dhlnterrupt,  suggest  device  drivers  similar  to those used  in multitasking  operating  systems. Unfortunately, when you examine the way the typical MS-DOS  device driver is written, those names are very misleading. In other oper  ating  systems,  the  dhStrategy  entry  would  queue  up  a  request  and   Figure 2.12  The deviceheader  data structure.   dhLink  dhAttributes  dhStrategy  dhlnterrupt  dhNameOrUnits    DOS Basics — 53   possibly  start  the  transfer,  and  dhlnterrupt  would  be  the  interrupt  handler  that  might  terminate  the  data  transfer.  MS-DOS  designers  never did get to complete this. In MS-DOS, dhStrategy  is called first.  When  it  is  called,  the  device  driver  usually  just  stores  the  request  pointer.  The  driver  entry,  dhlnterrupt,  is  then  called  immediately  afterwards  where the actual driver call is implemented.   The  requestheader  is the common  data  structure that prefixes  all  device driver requests  Figure 2.13 . When the device driver is called, a  far  pointer to the request  is passed to the device driver. Appended  to  the request area is a variable data structure that is unique for each sys  tem call. Because of this variability,  rh Length  indicates the length, in  bytes, of the combined  requestheader  and unique data  structure. To  allow the device driver to handle more than one device,  rhUnit  speci  fies  the  device  number  that  the  driver  is  to  operate  on.  The  entry  rhFunction  specifies  the function,  such as read or write, requested of  the  driver. Finally,  when  the  operation  is complete,  rhStatus  returns  the completion status. The entry  rh Re served  is unused at this time and  is reserved for future use.   Of the remaining devi ceheader entries  Figure 2.12 , the dhAttri butes  and  dhNameOrUnits  entries  are  used  for  informational  purposes.  d h A11 r i b u t e s is used to convey information to MS-DOS about the device  driver. It is a bit field that indicates whether the device driver is for a block or  character  device,  whether  it  is  stdin  or  stdout,  etc.  The final field,  dhNameOrUnits, contains either the name of the device if it is a character  device or the number of units handled by this device for a block device.   Figure 2.13  The requestheader  data structure.   rhLength  r h U n i  t  rhFunction  rhStatus  rhReserved    54 — The FreeDOS Kernel   Unfortunately,  you need to learn many more details before  attempt  ing to write a device driver. This task is beyond the scope of this book,  but the topic is well  documented  by Microsoft  and other publishers. I  highly recommend  that you refer  to these  sources before  writing  your  own device drivers. I will go into the details of each device driver later  in this book and cover what calls are handled and how.   What I Am  Not Covering  As  you  can  see by  now,  even  a  small  desktop  operating  system  like  MS-DOS  can  be  complex. You  have  seen  that  the  API  has  different  variations,  a  file  has  two  parts  hidden  by  the  operating  system,  etc.  However, there are parts of MS-DOS that I am not covering because I  am not implementing them in DOS-C. I am not covering installable file  systems  because  of  DOS-C  design  limitations. Also,  I  will  be  taking  liberty with internal data structures and error handling. With this  infor  mation in hand, I will start the DOS-C design and implementation.    Chapter 3   Bird's-Eye View  ofDOS-C   Previous chapters examined the architecture of MS-DOS and looked at some  details of the operating system. They also created a model of MS-DOS and  defined the minimum set of programs that form MS-DOS. This chapter will  take a look at the overall architecture and the major components of DOS-C  and will show its relationship to the MS-DOS model. This chapter will also  examine the dynamics of booting DOS-C and explain the design behind the  techniques used.   One  major  difference  that  you  will  see throughout  this  chapter  is that the DOS-C design does not worry about smaller systems. This is  really a reflection  of the times. DOS-C expects to work in systems with  at  least  256Kb  of  memory,  whereas  MS-DOS  expected  only  64Kb   although the current kernel is much larger than the minimum memory  requirements  of  MS-DOS  vl.O . Also,  you  no  longer  need  to  worry   55    56 — The FreeDOS Kernel   about  saving disk space for  small floppy disks because you can expect  systems  that  have  over  seven times  more  storage than  the original  PC  disks. Finally, I want to use a high-level language in the implementation  so I won't  waste time trying  various  assembly  language  techniques  to  minimize size or maximize speed. As you will see in the final kernel, the  penalty  you pay  for  the convenience  of rapid  coding  in  a higher  level  language is far less than some programmers  would like you to believe.  So with this in mind, start examining the architecture of DOS-C.   Basic DOS-C  Architecture  Chapter 2 outlined an experiment to determine the minimum set of pro  grams necessary to run MS-DOS to limit the scope of the project,  since  individual programmers have to learn by example without the resources  of a megacorporation with 200 programmers available to tackle the job.  The result: MS-DOS needs, as a minimum, boot,  i o. sys, msdos . sys,  and command. com to operate. These four components are the necessary  set  for  MS-DOS,  but  this  chapter  will  re-examine  each  component's  functionality  and broaden the definition to improve upon the design.   The  boot  sector  is  the  first  sector  placed  onto  the  diskette.  You  already  know  that  all  PC-style  computers  load  and  execute  the  boot  sector in order to boot any operating system. As a result, you don't have  much latitude in the design for boot. Also, with less than 512 bytes to  use for the boot code, you won't be performing  many miracles. We do  have a fair amount of freedom in the next stage.   As you may recall, boot loads i o. sys, which proceeds to initialize its  internal device drivers,  io.sys  continues to initialize its device drivers  by loading msdos.sys  and instructing it to initialize itself,  i o. sys  then  uses  msdos.sys  to read  config.sys,  if  present. When  io.sys  com  pletes the processing of confi g. sys, it loads  command. com and finally  transfers  control to it, allowing  autoexec.bat  to  execute  and  ending  up  at  the  command  line  prompt.  This  is  a good  description  of  what  MS-DOS  uses, but  you  need  to  broaden  the  definition  somewhat  so  that you can get a better picture of exactly what is happening.    Bird's-Eye View ofDOS-C  — 57   If you step back and re-examine the operations, you can make some  generalizations  that  will  help  define  what  you  will  do. You  saw  that  boot loads a program that loads the full kernel. This loaded program is  aware of a limited  set of file system functions  and knows how to read  executable files into memory. If you take this generalization  and look  back  into  some  computer  science  texts,  you  will  find  this  to  be  the  description of an Intermediate Program Loader or IPL. You will use this  description of stage two of the booting process. You can now state that  for  DOS-C, the  second  stage  is  an IPL  whose  function  is to load  the  final kernel.   You  also  see from  the previous  description  that  when  stage two is  complete, the complete kernel has been loaded into memory and it has  initialized  its  internal  data  structures.  Again,  if  you  generalize  this  description, you can say that the IPL loads the kernel and transfers con  trol to it. This is now stage three of the boot process.   The last part of the previous example then shows that  command. com  is loaded and control is transferred  to it. Once again you will step back  and generalize this stage. What you can say is that the kernel, after ini  tialization, loads a user-level program that eventually brings you to the  user interface.   These four  stages of booting also give nice logical breaks for  defin  ing the four fundamental  components. As stated earlier, the first compo  nent  is  boot,  since  its  behavior  is  largely  dictated  by  the  computer  architecture and not the operating system itself. The second component  is an IPL that is aware of the file system and the structure of the kernel  and loads the kernel  into memory. The third component  is the kernel,  responsible  for  all  the  system  calls  and  resource  management  of  the  operating system. The final component is the command line interpreter.  Now take these four components and make some decisions about the  nature of each. You know that the boot must be in the first sector of the  disk and that it must contain certain data structures. It is a binary image  and will utilize the BIOS for communications. It will look for the IPL  and load it into memory.   The IPL will be aware of the file system and be capable of loading  an executable  image  into memory. If  you  look  at this  simple  descrip  tion, you see that you can say that the IPL is a specialized version of the    58 — The FreeDOS Kernel   operating  system. This is an excellent  way to design  it, since you can  concentrate  your  efforts  on the kernel  itself  and use the  C  compiler's  preprocessor to conditionally  exclude unnecessary  portions of the ker  nel. Because you know that boot is limited in capability, you will make  the IPL a binary image easily loaded into memory and call it  i pi  . sys.  You can also take advantage of its derivation from the kernel and give it  the capability to load  .exe files, yielding tremendous flexibility in the  requirements  for the kernel. You can load one or more files into mem  ory, relocate them dynamically during the load process, and save devel  opment time since you will need to copy only one or more  . exe files to  the boot diskette in order to change the kernel.   For DOS-C, you will limit the kernel to a single  file,  kernel  .exe,  so that you will not need to get fancy with the development process. It  will be a single executable, with full relocation capability, and you can  generate it using standard DOS compilers  and linkers. It will initialize  itself and load the user-level programs to start the user interface.   Because  you  are modeling  MS-DOS, the final component  will bor  row  from  MS-DOS  and will be  command. com. You do not  necessarily  need to do this, as you could have loaded an  . exe version of command or  an i n i t  similar to UNIX that brings the operating system to a multi-user  state. However,  so many programs  have been written  with the concept  that  the  command  line  interpreter  is  loaded  next  and  that  it  is  called  command.com  that  changing  this  step may  only  complicate  things. So  you will follow closely MS-DOS and end with command. com executing  autoexec. bat to give the user interface.   Booting DOS-C  You have generalized the MS-DOS boot stages and the basic partition  ing  of  the  necessary  operating  system  functions  into  DOS-C  files.  Examine  the dynamics  of booting  DOS-C. Figure  3.1  shows the boot  stages for DOS-C. Four distinct  stages are involved in the boot, corre  sponding to the four minimum components necessary for DOS-C. This  approach  simplifies  the  design  through  modularization.  By  confining  each  stage  to  its  own  unique  module,  interaction  is  confined  to  the    Bird's-Eye View ofDOS-C  — 59   interface  layers. A bug that may exist in  kernel  . exe  does not require  changes  in  i pi  . sys  nor will  any change in  size of either  i pi  . sys  or  kernel  .exe affect  each other.   The  computer's  ROM  BIOS  initiates  the  first  stage.  This  stage  is  identical to the way almost any PC-compatible  operating  system starts  out.  The  BIOS  fixes  the  location  of  boot  in  memory  and  the  initial  cs : i p. For MS-DOS, IBM placed the location of boot at  0000: 7c00h   Figure 3.1  The four  stages ofDOS-C  boot.   f 0 0 0 : f f f fh   f 0 0 0 : f f f fh   0000:7e00h   0000:7c00h   0000:0400h   boot   BIOS RAM   Stage 1   ipl   . s y s   1000:0000h   0000:0400h   BIOS RAM   Stage 2   f 0 0 0 : f f f fh   f 0 0 0 : f f f fh   0000:0400h   0000:0400h   k e r n e l . e xe   Scratch RAM   BIOS RAM   Stage 3   command.com   k e r n e l . e xe   Scratch RAM   BIOS RAM   Stage 4    60 — The FreeDOS Kernel   to  allow  30Kb  for  loading  io.sys  and  msdos.sys.  DOS-C  does  not  need boot to load in this location because all of the following  stages are  either position independent or relocatable, and you can judiciously jug  gle the following  stages for any size kernel.   As  a neutral  choice, load the next  stage,  ipl  . sys,  into memory  at  1000:0000h.  There is no magic to this  address: it can be almost  any  where.  You  can  dynamically  locate  ipl  .sys  anywhere  in  memory  because  you  have built  it  from  the  kernel  source  code  using  the  x86  small  model.  This  limits  the  total  size  of  ipl  .sys  to  only  64Kb. By  limiting  the  scope  of  the  IPL,  you  can  easily fit its  functionality  into  this memory size.   ipl  .sys  loads  kernel  .exe  and is aware of MS-DOS file systems.  However, its lifetime is short and its purpose is simple: load the kernel.  In order to reduce development time, it is logical to derive the IPL from  the kernel  source by reducing  the kernel  functionality  to only what is  needed  to  load  the  kernel. You will  see  how  I  have  derived  ipl  .sys  from the kernel source code when you examine the source code, but for  now I will outline what you don't need. For one thing, you won't need  any sort of API since you won't have any other program using the inter  nal functions. You can also reduce the size of  i pi  . sys  by  eliminating  functions  you  don't  need.  For  example, because  it is  strictly  a loader  there is no need for functions  that write or delete. You only need  func  tions that  open, read,  and close. You can  further  simplify  i pi  . sys  by  restricting  it to only one loader. You can always  switch to the other or  include both  if you  decide to do  so in the future.  Realistically,  if you  choose the  .exe loader you are not restricted to a programming model,  and therefore  this is the choice for the design. Also, you don't need all  of the  device drivers. It does not make  sense to have a line printer  or  serial port driver if the primary function  is booting.   You also should recognize the potential behind an IPL boot process.  You can design a debugger or menu  system into the IPL to choose the  program you intend to load. Either feature enhances the debugging pro  cess, since you can stop after loading the kernel and start debugging, or  you  can  decide  to  change  the  name  of  the  experimental  kernel  and  select it at runtime.    Bird's-Eye View of  DOS-C—61   Stage three starts once the kernel is loaded into memory. The kernel  starts at mai n    , just as any C program will, and begins by initializing  itself. This includes locating all of memory, building  arenas, and load  ing the proper  addresses into the interrupt  vectors. After  initialization,  processing  confi g. sys  can occur, but you won't  do that  for  this ver  sion. Finally, the kernel searches for and loads command. com into mem  ory  and  makes  this  the  granddaddy  of  all  programs.  If  command.com  returns, the kernel will shut down and you will need to reboot. This is  no  different  than  the  case  where  MS-DOS  cannot  find  command.com  and  issues  the  error  message  "Bad  or  missing  command  interpreter,"  except that the approach is cleaner.   When  command.com is successfully  loaded,  stage four  commences.  command.com  does  its  own  initialization  including  creating  the  initial  environment  and  executing  autoexec.bat.  Once  this  has  occurred,  command. com issues a prompt and goes into a loop awaiting user input.  DOS-C is now loaded and ready to run.   I feel that it is always a good idea to include visual indicators in the  code  so that you can monitor the progress  of  an operation. When  you  boot DOS-C, the first indicator you will see is from boot. Because boot  is small, it doesn't do very much except announce itself by placing the  message  "boot"  on  the  screen.  Although  it  doesn't  seem  like  much,  many times when I didn't  see this little message, I immediately  knew  that I had an error to find.   i pi  . sys announces that it is booting DOS-C, and the modified  . exe  loader  outputs  "."  at  regular  intervals  during  the  loading  process.  i pi  .sys  is  bigger  than  boot  and  can  afford  to  be  somewhat  more  verbose. The  reason  for  two  visual  indicators  is twofold.  First,  you  need an indicator that  i pi  . sys  has been successfully  loaded, the same  as boot. Second, other things can go wrong with  i pi  . sys, so a visual  indicator of  the  load  process  helps  identify  errors  and the  choice  of  putting a "." to the screen at strategic locations is very helpful.  Finally,  kernel  . exe and command. com both announce themselves when loaded  but do not contain progress indicators because the debugging technique  used  on  them  is  different  and  gives  better  information  than  a  visual  indicator does.    62 — The FreeDOS Kernel   Now  that  you  have conceptually  loaded  DOS-C  into  memory  suc  cessfully  and have it operational, you can look a little closer at its orga  nization. Next examine the design  of the DOS-C kernel,  and  see how  you can  organize the code into logical  modules, each implementing  a  logical system  function.   DOS-C Kernel  Architecture  The DOS-C architecture takes a layered approach. This approach is not  very  different  from  other  operating  systems.  The  only  deviation  you  will find is that there is a decoupling between the upper and lower lay  ers of the operating system.   Figure 3.2 shows the architecture of DOS-C. Because of the need for  compatibility with the de facto DOS standards, full  compliance is nec  essary in two interface  areas. The first interface  area is obvious — the  DOS API entry points. These are the entry points that you expect  from  a  DOS-compatible  operating  system.  These  include  the  traditional  int  20h, 21 h, 22h, 23h, 24h, 27h, 28h, and  2fh.   Another  less  obvious  interface  is  the  device  driver  interface.  This  interface  is also well documented and supported by many hardware and  software  vendors.  It  is  important  that  DOS-C  is  compatible  with  this  interface so that you can assure proper support of loadable device drivers.  The kernel consists  of C code wherever possible. However,  certain  functions  are written  in  assembly  language. These  functions  typically  perform  direct  machine  control,  such  as  manipulating  the  stack  and  flipping interrupt bits. You will find this code in a number of  assembly  files along with C-to-assembly interface  functions.   Following  a system call through the kernel is an easy way to take a  tour through  the kernel. Taking  this journey  and noting  where  certain  features exist will help when you examine them more closely.    Bird's-Eye View of DOS-C—  63   DOS-CAPI  A  DOS API entry  point  handler  intercepts  any  system  call to  DOS-C  and translates it into a C call. Do this as close to the entry point as pos  sible in order to use C as early as possible. The C call then does some  context switching and performs a call to the appropriate internal service  function.  It is up to the service routine to route the system call through  the kernel to the appropriate handler.   Figure 3.2  DOS-C kernel architecture.   DOS-Compatible System Calls   i   DOS API Entry Points   fcbfns   dosfns   fs   task   memmgr   c h a r i o   b 1 o c k i o   Task and Process Support Code   execrh   i  r   Device Drivers   Machine Level Support Code    64 — The FreeDOS Kernel   The  path  through  the  kernel  varies  depending  on  which  DOS API  entry point you examine. In order to continue the search deeper into the  kernel, focus  on the  int  21 h service  function,  int21_service.  This  handler is a dispatcher that examines the call number found in the regis  ter  storage  area.  It  uses  this  number  to  execute  some  local  machine- dependent  code  that  converts  register  variables  to  C  parameters  for  function  calls, calls an internal function  that performs the call, and con  verts the return  values back  into register  values before  returning.  The  dispatcher  returns  to  the  handler  for  another  context  switch  and  the  entry point handler returns to the user.   As  mentioned  earlier,  the  dispatcher  performs  the  appropriate  C  function  call to perform  the DOS-C operation. DOS-C directs this call  into the kernel  and can  only proceed  "down" in the  architecture.  One  architecture design rule is that functions  are only aware of functions  at  the same or lower layer. This is a DOS-C design choice that allows the  easy addition of functionality  at the higher levels without affecting  the  operational layers.   The DOS API layer directs a larger number of calls into the dosf ns,  or DOS Functions, layer. This layer works with the lower layers to add  the DOS appearance to the system calls. It does this by combining calls  into the various managers in the next lower layers with code to add fea  tures to the manager calls that are unique to a DOS interface. For exam  ple, this layer contains functions that encompass all rules for handling file  I O that deals with PSP, handles, or character and block I O  functionality.   DOS-C File  System  The DOS-C design  allows for  a file manager that is independent  from  the  design  of  the  rest  of  the  operating  system.  The  f s  module  is  the  DOS-C file manager. Whenever an application requests an operation on  a file that  is resident  on  a block  device,  f s performs  the operation.  It  does this by working  with an internal table, called the  fjnode   or file  node  table.    Bird's-Eye View ofDOS-C—  65   The  f_node  table  is  the  foundation  for  the  design  of  the  FAT file  system  manager.  The  f_node  data  structure  controls  all  internal  file  operations and virtualizes the file. When f s performs an operation such  as create or open, it allocates an entry from the fjnode  table and popu  lates the  f_node fields. The call returns a number that is the index into  the f_node  table. From here on out, any function that performs an oper  ation on the file receives this number. The  f_node  table entry that cor  responds to this index controls all file parameters. It is the anchor that  ties together the three components of a file discussed in Chapter 2.   If you are familiar with DOS internals from the undocumented inter  nals literature, you will recognize the need to map an internal  fjnode  to the  SFT   System  File Table   structure  used by  DOS. The need  for  this mapping is a result of the many programs that expect an SFT entry  for a file. This is one of the many unfortunate results of having an oper  ating  system that  is  open  to probing  from  user  programs  —  you  lose  control of internal data structures. Changing any internal data structure  may  break  a working  application.  It  also  complicates  DOS-C  design  because  these  considerations  will  occur  repeatedly  and  must  be  addressed in a manner that guarantees DOS compatibility.   For  file-related  issues,  you  handle  this  through  the  dosfns  layer  function.  The module  dosfns  handles  this type  of mapping,  which  is  part of its "DOS personality" responsibility. At the  f s level, it does its  work in  an  "OS-neutral"  mode  in  order  to localize  unique  features  to  the personality  module. This  design  lends itself  to portability  but will  complicate  some DOS personality  issues. Fortunately,  the benefits  far  outweigh the complications.   DOS-C Memory  Management  Memory  management  in DOS-C is an area that requires  close  emula  tion of the MS-DOS techniques. Because DOS-C is a real-mode operat  ing  system,  the  memory  management  techniques  presented  here  are  much  simpler than those you will find if you examine more  advanced  operating systems.    66 — The FreeDOS Kernel   In a manner  similar to the MS-DOS  memory management  scheme,  DOS-C  manages  memory  through  the  use  of  a memory  block  linked  list that uses the same arena header as the one described in Chapter 2.   The arena header in DOS-C is known as the MCB  Memory Control  Block . As with MS-DOS, this  data  structure  is in front  of  each allo  cated and free memory block. DOS-C uses the same "M" and "Z" sig  natures to identify the block type. Also, the segment value of the PSP of  the program it belongs to, or a 0008h if it belongs to DOS-C, identifies  the owner of the block in the same way. DOS-C uses all other entries in  an identical manner. Again, many programs make use of this  informa  tion, and DOS-C provides this  same information  for  the  sake of com  patibility.  Unlike  fs  where  DOS  personality  splits  between  it  and  dosf ns, memmgr contains all DOS personality.   DOS-C provides the same API calls as MS-DOS to manage the are  nas.  It  provides  an  allocation  function  and  a  dispose  function  along  with  a  call  used  to  set  allocation  strategy. Additionally,  a  number  of  calls  are  used  internally  within  DOS-C  for  initialization  of  the  arena  and  validation  of  the  integrity  of  the  arena  whenever  memory  blocks  return to the free memory pool.   DOS-C  Task  Management  Because  the  DOS-C  design  adheres  to  the  de  facto  DOS  standard,  it  should not be surprising  that the operating  system is not multitasking.  This  is  not  entirely  true  as  you  will  see  in  later  chapters.  There  are  really  three  tasks  in  DOS-C,  the  user  task,  the  kernel  task,  and  the  driver task, but the user only sees a single task. The task manager,  task,  manages this single user task.   The primary  function  of the task manager is to act as a task loader,  unlike other operating systems where task loading is incidental to man  aging the task. Also, there are only two relatively simple executable file  types,  . com and  . exe. We have seen descriptions of both in Chapter 2,  but we will examine the dynamics of loading the two types of tasks.    Bird's-Eye View  ofDOS-C—67   Both executable file types  start from  a single load entry. It is up to  DOS-C to identify  which file type it is. It does this by examining  the  first two bytes  of the file. If it is an "MZ", then it is an  . exe file and  task  invokes the  .exe  loader, otherwise  task  assumes it to be a  .com  binary image and invokes the  . com loader.   Both loaders initially follow  similar code. They both allocate mem  ory  from  memmgr  to  place  the  environment  strings.  The  differences  begin when the actual file loading occurs. The  . com loader merely allo  cates memory and begins loading the file into memory for a maximum  of  64Kb.  The  .exe  loader,  on  the  other  hand,  computes  the  size  required and then allocates memory. It then proceeds to load the image.  When  task  completes loading the image, it does a seek to the reloca  tion  offset  and  does  a  segment  fixup   necessary  for  the  segmented  architecture of the 80x86 family .   From this point, both  loaders  proceed  to  create  the PSP  and  clone  the file table.  They  both  end  by  allocating  and  initializing  the  tasks'  registers and executing the task if so requested. The only minor  differ  ence  here  is that  the  initial  ss : sp  and  cs : i p are  default  values  for  a  .com, whereas  task  computes them from  the  .exe file header  for  the  . exe file.   The user program termination  handler  is the final task  code to be  examined.  In  our  task  module,  program  termination  is  handled  in  a  straightforward  manner by closing all open files, restoring the parent's  information,  and, if it is not a TSR, releasing the program's memory.   DOS-C High-Level  I O and Device Drivers  So far, you have followed  the system call through the DOS-C API and  examined  the  various  managers  that  provide  the  requested  service. If  the request is an I O request, the system call now proceeds deeper into  the kernel to perform raw I O. The manager does this by placing a call  into the next layer — the raw I O handlers.    68 — The FreeDOS Kernel   There  are two handlers  in the raw I O layer,  chario  and  bl ockio.  Although  each  handler  uses  different  methods,  both  handlers  are  the  primary  interface  between the device drivers  and the remainder  of the  kernel. Both handlers perform  all the necessary buffer  management  for  both types of I O, including line buffer  management.   The I O handlers are loosely based on the UNIX I O model. As with  UNIX, two types of I O are defined.  The first type is the character  I O  type. This type of I O  appears  as a stream of bytes to the kernel. The  kernel either sequentially reads a byte into the kernel or writes from the  kernel. There are also functions  to read a buffer  into memory and han  dle the familiar DOS line editing  functions.   The block I O interface provides functions  to read and write a block  of data to a block device — usually a disk. Each block corresponds to a  sector and is actually a data structure in a block cache. When the kernel  reads  data  from  a  disk,  bl ockio  reads  the  sector  into  a  buffer  and  places  it  into  a  Least  Recently  Used   LRU   chain.  When  bl ockio  needs  a new buffer,  it writes the tail of the list to disk, if needed,  and  returns that buffer.  The buffer  then becomes  available for  data  transfer  into the buffer.  When  bl ockio  completes  the data transfer,  the  buffer  goes  to  the  head  of  the  LRU  chain,  indicating  that  it  is  the  newest  buffer.  Management  functions  handle these operations  for  dirty  buffer  write back, as well as buffer fill. Buffer  management functions  also per  form operations such as LRU management and flush.   As with the API, the device driver interface is well documented. It is  important  that  DOS-C  closely  follow  this  convention.  Because  the  interface  is  designed  for  an  assembly  language  system,  a  special  assembly language function  interfaces all device drivers. This  function,  execrh    , accepts a request packet from the I O handlers that contains  a function  number requested by the device driver. It handles the correct  sequence of calls for the device driver to the strategy and interrupt entry  points and returns the packet to the I O handler. The function  execrh      is a C call, allowing an easy assembly language interface.    Bird's-Eye View  ofDOS-C—69   The DOS-C  device  drivers  are the bottom  layer  of the kernel. Like  the remainder of the kernel, C is used in these device drivers also. The  device drivers perform the necessary device interface between the kernel  and the device itself. DOS-C has the  same device drivers  as MS-DOS  and they perform the same functions  as their MS-DOS counterparts.   Final  Notes  The discussion of the DOS-C architecture covers about 90% of the ker  nel. MS-DOS defines  a few functions  that don't neatly fit the architec  ture.  These  functions,  such  as  time  management,  National  Language  Support,  etc.,  are  handled  individually  in  the  layer  that  best  supports  them. Unfortunately,  the design trade-offs  forced  special  handling. As  you will see in later chapters, the benefits  of the layered design far out  weigh the inconvenience of special  functions.    70 — The FreeDOS Kernel    Chapter 4   DOS-C Kernel- File System Manager   Up  to  now,  I  have  covered  generic  DOS  and  DOS-C  basics.  I  have  looked  at  the  architecture  of  DOS-C  and  discussed  its  layered  approach, design rules, and calling conventions. The method I used was  a  hypothetical  trip  through  the  kernel,  and  I  examined  the  flow  of  a  generic system call through the kernel and the interface layers.   This chapter examines the code in the kernel from  the device inter  face  layer up and starts by examining the device driver interface.  This  interface  is an important piece of DOS-C, since all device driver calls  use this interface.  I will then  look  at the lower half  of the file system  managers, namely the block device and the character device interfaces.  I  will  examine  the  data  structures  used  in  both  and  detail  the  design  methodology behind each. Finally, I will tie these together by present  ing the FAT file system code.   71    72 — The FreeDOS  Kernel   Device Driver  Interface  The design of the code that performs  the device driver interface  is one of  the critical areas in the kernel. In order to use standard DOS device driv  ers,  the  kernel  must  call  the  device  driver  in  a manner  similar  to  other  DOS-compatible operating systems. This is necessary to guarantee com  patibility  with  third-party  device  drivers   i.e., your  mouse  driver,  some   Figure  4.1  Device  driver functionality   layer.   DOS-Compatible System Calls   DOS API Entry Points   fcbfns  fs  c h a r i o   dosfns   memmgr  bl ocki o   Task and Process Support Code   task   execrh   Device Drivers   Machine Level Support Code    DOS-C Kernel: File System Manager — 73   SCSI  disk  drivers, etc. . It must  also be easy  to use by the kernel's  C  code  modules. I achieve  ease  of use through  a simple  C function  that  receives a pointer to a standard DOS request packet and another pointer  to  a data  structure, known  as the  dhdr,  used  to  manage  devices. This  forms the device driver [execrh    ] interface layer  Figure 4.1 .   The  realization  of  this  design  is  an  assembly  code  module  that  translates  a C call  into  the  appropriate  device  driver  call.  The  file  execrh.asm  contains  the  actual  assembly  code;  however,  look  at  the  pseudo code in Figure 4.2 in order to gain a better understanding of the  process.  The  call  takes  two  parameters,  a  far  pointer,  rhp,  to  the  request packet data structure and another  far  pointer,  dhp, to the  dhdr  data structure.   Figure   4.2  Psuedo code for  exec   rh        interface   function.   void  execrh   i   VOI   d   * TempFuncH ;   request  far   *rhp,  struct  dhc   ir  1   far  *dhp    perform  c  sp  =  bp;  ;  =  sp  -=  4  '  save  old  sp  =  si ;  sp  =  ds;   :  entry  *    *  Actually   a  push   in   s t r u c t i o n *      *  and  make  space   for   TempFunc*    contents  of   *  Actually  a  push   *  d i t to   temporary  in   registers*   s t r u c t i o n *    *    Set  pass   up  fc  ed  ir    r  standard  DOS  device  th   Ì  far  pointers   into   driver  call  Bir  respective   by  assigning   registers   si  =  bx  =   dhp  rhp    *  ds:es   points   *  es:bx  points   to  to   th   th    B  device  hea  B  request  pa   jer  *   :ket  *     *  *- - bp  sp    *  *- - *- -   k    *  *  *   ds:  es:    74 — The FreeDOS Kernel   The first parameter,  rhp, is a pointer to the request packet data struc  ture  as  described  in  various  DOS  references.  The  request  packet  is  a  variable data structure used by DOS to command  a device to  perform  control,  input,  or  output  functions.  The  information  contained  within  the request packet is all that is required by the device driver to perform  the  requested  function.  This  request  packet  is  the  standard  request  packet expected by DOS-compatible device drivers.   Figure 4.2  Psuedo code for  execrh      interface  function   continued.   I*   k  After translating C parameters to DOS standard  * device driver parameters, begin executing  driver  * strategy and interrupt code by indirect  calls  * found in the device driver header.  Method  used is  * assigning the function pointer to a temporary  * variable and using it for the function  call.  *  * NOTE: device drivers use "tiny" model, so  * register adjustments are made along the way.  *    * Call  strategy  first *   TempFunc = dhp -> dhStrategy;  TempFuncO ;   * Call  Interrupt next *   TempFunc = dhp -> dhlnterrupt;  TempFunc  ;   * and exit perform a c exit *   ds = *sp++;  * Actually a pop instruction*   si = *sp++   * ditto  sp = bp;   *     DOS-C Kernel: File System Manager — 75   In order to properly identify  the device that performs the I O request,  execrh     requires a second parameter, dhp, the device header, which is  loosely based on a similar data structure discussed in popular  "undocu  mented" literature. It contains a pointer to the device driver variable and  other useful information  such as current directory for block devices.   Like  other  DOS-compatible  operating  systems,  DOS-C  creates  a  device I O request in kernel  space. Unlike some DOS-compatible  sys  tems, DOS-C creates this space as an automatic variable in the  function  that  is  performing  I O.  DOS-C  fills  the  packet  then  proceeds  to  call  execrh     to execute the call.   Upon  entry  into  the  function,  execrh    performs  a  sequence  of  instructions that emulate a normal C function  entry, including reserving  space for  the local  variable  Temp Fune. It next prepares  for  a standard  DOS device driver call by assigning fa r pointers passed into execrh      to their respective registers —  ds : es  for the device header and  es : bx  for the request packet.   After  translating  the  C  parameters  to  DOS  standard  device  driver  parameters, execrh     continues by executing driver strategy and inter  rupt  code with  indirect  calls  found  in the header  of the  device  driver.  The method used to perform the call is to load the function  pointer into  a  temporary  variable  and  use  it  for  an  indirect  subroutine  call. Note:  Device drivers use the "tiny" model, so the actual assembly code makes  register adjustments  along the way.   Character Device  Interface  The  character  device  interface  is  one  of  the  two  lower-half  functions  used throughout the operating system  as diagrammed in Figure 4.3a, b .  This  interface  handles  both  single-character  I O  and  buffered  I O,  including command-line canonical processing. The file chario.c  con  tains  all  functions  related  to  this  interface.  With  the  understanding  of  how execrh     works, examine a simple function that uses it.    76 — The FreeDOS Kernel   Let's examine the low-level character output function  _sto      List  ing 4.1 . This  function  is responsible  for  all output to the  system con  sole. The first thing it does is look for  a break  Ctrl-C or Ctrl-Break . I  will  discuss  the  exact  mechanism  later,  but  for  now just  assume  the  existence of a function  that returns TRUE if a user has hit a Break key. If  a break condition exists, _s to     handles it and exits immediately; if not,  it  proceeds  to  read  the  character.  As  mentioned  before,  the  request  packet  is  actually  an  automatic  variable  allocated  on the kernel  stack;  _sto     is a perfect example. The function fills the fields of the request,  including  the  command  requested.  Each  I O  function  has  different  fields,  but the concept is universal to all the low-level drivers.   Figure  4.3a  Character  device functionality   layer.   DOS-Compatible System Calls   i   DOS API Entry Points   fcbfns   fs   c h a r i o   task   memmgr   dosfns   blockio   Task and Process Support Code   execrh   i  r   Device Drivers   Machine Level Support Code    DOS-C Kernel: File System Manager — 77   Figure 4.3b  Low-level character output functions.   sti   sto   _sti   _sto   execrh   Listing  4.1  Source code for _   _sto       function.   s t a t ic  BOOL  _sto C0UNT  c   i   request  rq;  BYTE  buf  =  c;   if con_break     i   handle_break  ;  return  FALSE;   rq.r_length  =  sizeof request  ;  rq.r_command  =  CJDUTPUT;  rq.r_count  =  1;  rq.r_trans  =   BYTE  FAR  *  &buf   rq.r_status  =  0;  execrh  request  FAR  * &rq,  i f   r q . r _ s t a t us  & S_ERR0R   return  char_error &rq,   ;   return  TRUE;   con_ .name  ;   }    struct  dhdr   FAR  * &con_dev ;    78 — The FreeDOS Kernel   After _sto     initializes the request packet, it invokes the execrh      function.  As you  saw earlier, this is where the device  driver is  called.  When  execrh     returns, _sto     examines the request packet status. If  an error occurred, the kernel character  error handler is invoked;  other  wise, the function  successfully  returns. Again, this handling  is typical  for all the low-level device driver interface  functions.   A  function  similar  to  _sto      is  the  sto      function   Listing  4.2 .  The  function  _sto    provides  only  primitive  functionality.  Users  of  modern  operating  systems,  have  become  accustomed  to  seeing  tab  expansion,  screen  hold   Ctrl-S  and  Ctrl-Q  handling ,  etc. The  sto     function  provides this  functionality.   Listing 4.2  Source code for  sto     function.   VOID  sto C0UNT c   {   *     * Test for hold char  con_hold  ;   *  Display  a  printable  character*   i f  c   !=  HT   _sto c ;  i f  c  ==  CR    scr_pos  =  0;  else  i f  c   ==  BS   {   if scr_pos  >  0   --scr_pos;   }  else  i f   c  ==  HT   {   do   _sto '   '  ;   while ++scr_pos  &  7  ;   }  else  i f  c    ++scr_pos;   !=  LF  &&  c  !=  BS     DOS-C Kernel: File System Manager — 79   The first order of business for sto     is to check for the reception of a  hold  character   Ctrl-S .  This  is  done  through  the  special  function  con_hol d    , which pauses until a Ctrl-Q is received. As with other parts  of  DOS-C,  sto    also  builds  on  lower  level  functions,  in  this  case  _sto    , to  achieve  its  functionality.  sto     tests  for  special  characters  such as a horizontal tab  HT , enter, or carriage return  CR . Tab charac  ters  are expanded  to multiples  of eight  spaces, whereas carriage return  and backspace characters are intercepted by  sto    , which modifies  the  global variable scr_pos, which tracks the current column position of the  cursor. scr_pos  is also used later in the command line editing functions.  Similar to _sto     is _sti       Listing 4.3 . Like _sto    , _sti      is a  lower level function  that performs input. Two levels of character I O are  needed because DOS-compatible operating systems can supply both raw   no  tab  expansions,  backspace  characters  that  do  not  delete  previous  characters, etc.  and processed or "cooked"  tab expansions, backspace   Listing  4.3  Source code for  _   _St1      function.   rq.r_length  =  sizeof request  ;  rq.r_command  =  C_INPUT;  rq.r_count  =  1;  rq.r_trans  =   BYTE  FAR  * &cb;  rq.r_status  =  0;  execrh  request  FAR  * &rq,  i f   r q . r _ s t a t us  &  S_ERR0R    return  char_error &rq,  con_name ;    struct  dhdr   FAR  * &con_dev ;   COUNT  _ s t i   V O I D   r  l   BYTE  cb;  request  rq;   i f   cb  ==   CTL_C   r  l   handle_break  ;  return  CTL_C;   else   return  cb ;   }    80 — The FreeDOS Kernel   characters that delete previous characters, etc.  I O. Because both input  and output require the two levels of support, a similar design is used in  both_sto     and_st i     .   The function  sti     supplies the next layer of functionality  Listing 4.4 .  Here, the symmetry breaks down because the DOS compatibility rule dic  tates that the next level fills a special keyboard buffer  and performs  the  expected line editing. As a result, s t i     is much longer that s t o    .   sti      begins by checking the line buffer  that is passed in to see if it  is large enough to hold the requested number of bytes and for a carriage  return  terminating  the buffer  if  it is not  empty. The  higher  layer  read  functions  use this particular  feature.   The preprocessor  switch NOSPCL  is discussed later .   sti       then  falls  into  a  loop  that  terminates  only  when  _ s t i     returns a carriage return. At the beginning of the loop, sti      then tests  a character with the use of a switch. The  switch  defaults  to a simple  entry of the character into the keyboard buffer  with the use of a helper  function,  kbfillO.  The  switch  captures  other  characters,  such  as  backspace  and escape, and diverts them to special handling  code. It is  this mechanism that produces the familiar repeated line response to the  F3 function  key and the erased character  with both the backspace key  and the back-arrow key.   One interesting  note here is the use of  a static character  array  as a  buffer  for the last line. As with all DOS operating systems, DOS-C pro  vides the ability to recall the last line entered a character at a time with  the use of the right-arrow key. When DOS-C receives a carriage return,  it  transfers  the  line  into  the  static  buffer  local_buffer  in  order  to  properly  perform  line  editing.  DOS-C  replaces  the received  character  by  the  character  contained  in  local_buffer  at  the  correct  position  within  the  line  as  recorded  by  structure  member,  kp  ->  kb_count.  This buffer  is  also used to repeat  the entire  last  line whenever  the F3  function  key is received. I must warn you that this particular  design is  not  meant  for  multiprogramming  environments  because  the  use  of  a  static variable defeats the reentrant requirement that all functions  must  follow  in  a  true  multiprogramming  kernel.  However,  DOS-C  is  not  multiprogramming, so you can allow some liberty and use simpler code  in the  function.    DOS-C Kernel: File System Manager — 81   Listing  4.4  Source  code for  sti         function.   VOID  sti keyboard  FAR  *kp   1  i   REG  UWORD  c,  cu_pos  =  scr_pos;  WORD  init_count  =  kp  ->  kb_count;   s t a t ic  BYTE  local_buffer[LINESIZE];   ifndef  NOSPCL   endif   i f   kp  - >  kb_size     kb_count   kp  ->  kb_buf[kp  ->   i f   kp  ->  kb_size  ==  0    return;   kb_count]   !=  CR   kp  ->  kb_count  =  0;   FOREVER  r  l   switch c  =  _ s t i       J  case  CTL_F:   continue;   ifndef  NOSPCL   case  SPCL:   switch c  =  _ s t i       i  case  LEFT:   goto  backspace;   case  F3:  r  i   REG  COUNT  i;   i++    f o r  i  =  kp  ->  kb_count;  1   ocal_buffer[i]   !=  ' \ 0 ';   c  =  i f  c   ==  ' \ r'   local_buffer[kp  c  ==   break;   k b f i l K k p,  c ,  FALSE    ->  kb  .count];     ' \ n'   i   j  break;    82 — The FreeDOS Kernel   Listing 4.4  Source code for  sti      function  — continued.   case  RIGHT:   ' \ r '  break;   c  =  l o c a l _ b u f f e r [ kp  i f  c  ==     c  ==  kbfilKkp, c, FALSE ;  break;   ->  kb_count];   ' \ n '    endif   break;   case CTL_BS:  case BS:  backspace:   if kp -> kb_count > 0   {   destr_bs  ;   if kp -> kb_buf[kp -> kb_count - 1] >= ' '   {  }  else if  kp -> kb_buf[kp -> kb_count -1] < ' '   {   &&  kp -> kb_buf[kp -> kb_count - 1]!= HT     destr_bs  ;  destr_bs  ;   }  else  {   do  {   }  --kp  ->  kb_count;   i f   kp   ->  kb_buf[kp  ->  kb_count  -1]  ==  HT    destr_bs  ;   }  while  scr_pos  >  cu_pos   &&    scr_pos  &  7    ;   }  break;   case  CR:   k b f i l K k p,  CR,  TRUE ;  k b f i l K k p,  LF,  TRUE ;    i f n d ef  NOSPCL   fbcopyUBYTE  FAR  * kp  ->  kb_buf,   BYTE  FAR  * local_buffer,   l o c a l _ b u f f e r [ kp    COUNT kp  ->  kb_count ;  ->  kb_count]  =   ' \ 0 ';   endif    DOS-C Kernel: File System Manager — 83   The  file  chario.c  also  contains  a number  of  helper  functions  that  functions  in  chario.c  and  other  files  use.  These  functions  perform  tasks,  such  as  converting  displayed  control  characters  into  a  printable  form by placing a "A" in front  of the corresponding  printable  character  [mod_sto   ]. Other  helper  functions  fill  the keyboard  buffer  and pre  vent buffer  overrun  conditions  while warning the user with  an  audible  alert [kbf i 11    ]. I suggest that you study these functions  in order to get  a  better  understanding  of  the  interrelationships  between  the  main  I O  functions  and the helper  functions.   One  final  note  about  s t i    .  The  DOS-C  design  allows  for  non- IBM-compatible  I O,  such  as  a  serial  interface,  where  these  function  keys  F3, right arrow, and left  arrow  may not exist. In order to work in  this  environment,  you  must  define  N OS PCL during  the  compilation  of  chario.c.  This  removes  the  local_buffer  functionality  from  the  function  sti     .   Listing  4.4  Source code for  sti      function   -  continued.  -  return;   case  LF:   sto CR ;  sto LF ;  break;   case  ESC:   s t o   ' W '  ;  sto CR ;  sto LF ;  for c  =  0;  c  <  cu_pos;  c++    stoC   '  ;   kp  ->  kb_count  =  init_count;  break;   default:   k b f i l K k p ,  c,  FALSE ;  break;   }   }   }    84 — The FreeDOS Kernel   Block Device  Interface  The  block  device  interface  is  similar  to  the  character  device  design.  Like  its  character  counterpart,  the block  device  interface  has  a lower  layer that acts as the device driver interface  and an upper layer that per  forms  higher  level  functions  such  as buffering   Figure  4.4a,b .  How  ever, they both differ  due to the nature of the I O.   At the API level, any file or device can have a read or write request  of an arbitrary number of bytes. For the character device interface, this   Figure 4.4a  Block device functionality  layer.   DOS-Compatible System Calls   i   DOS API Entry Points   fcbfns   fs   chario   task   memmgr   dosfns   bl  o c k io   Task and Process Support Code   execrh   i  r   Device Drivers   Machine Level Support Code    DOS-C Kernel: File System Manager — 85   is usually not a problem because character devices are capable of trans  ferring  a single byte  at a time. Block I O  devices must transfer  data a  fixed number of bytes at a time, 512 bytes for a DOS-compatible  oper  ating system. Also, block devices are random access, meaning that any  block  can be  accessed  in  any  order,  with finite rotational  latency  and  cylinder  stepping  times  incurred  with  each  read  from  a  disk  block.  Therefore,  our lower layer for the design of the block device  interface  buffers  these  blocks  in  a way  that  reduces  disk  access  times.  DOS-C  uses a linked list of block buffer  structures that contains flags, pointers,  and  a  data  buffer.  A  last-recently-used  list  updated  with  every  buffer  access  organizes  the  buffer  structures.  DOS-C  reads  the  buffers  into  memory only when it needs a buffer  not in the cache and writes a buffer  to disk when it needs a new buffer that is not in the cache and the buffer  removed  from  the end of the list was modified.  DOS-C  also writes to  disk when it specifically flushes the disk buffers.   Similar to the character  I O  functions,  the block I O  functions  also  have a device driver interface that converts the assembly language call  ing  conventions  to  C.  For  our  block  I O  functions,  the  call  is  dskxferO   Listing 4.5 .   Figure 4.4b  Upper-layer block I O functions  and lower-layer   device driver interface.   flushl   f i ll   flush_buffers   getblock   dskxfer   execrh    86 — The FreeDOS Kernel   On first examination  of  dskxfer    , the  system call does not  seem  very  different  from  its  character  counterpart  except  that  the  set-up of  the request packet is inside an infinite loop. I will address the reason for  this shortly, but it will be an important item to note.   When  you look  closer  at the  set-up in  dskxfer    , you  see that the  block unit passes a subunit. The use of a subunit allows a device driver to  handle multiple drives  i.e., the floppy driver needs to handle both A and  B drives while the hard disk driver handles C and D drives . You also see  that the command  can be any one of three:  C_0UTVFY, C_0UTPUT, and   Listing  4.5  Source code for  dskxferO   function.    COUNT  d s k,  LONG  b l k n o,  VOID  FAR  * b u f,   COUNT  mode    REG  req   struct  dpb  *dpbp  =  &blk_devices[dsk];  uest  rq;   BOOL  dskxfer  r  i    ;;    for  i   rq.r_length  =  sizeof request ;  rq.r_unit  =  dpbp  ->  dpb_subunit;  rq.r_command  =  mode  ==  DSKWRITE  ?    verify_ena  ?  C_0UTVFY  :  C_0UTPUT   :  C_INPUT;   rq.r_status  =  0 ;  rq.r_meddesc  =  dpbp  ->  dpb_mdb;  rq.r_trans  =   BYTE  FAR  * buf;  rq.r_count  =  1 ;  if blkno  >  MAXSHORT   {   rq.r_start  =  HUGECOUNT;  rq.r  huge  =  blkno  -  1;   }  else   break;   rq.r_start  =  blkno  -  1;   execrh  request  FAR  * &rq,  dpbp  ->  dpb.  i f   !   r q . r _ s t a t us  &  S_ERR0R   &&   rq.r_status  & S_   _device ;   .DONE      DOS-C Kernel: File System Manager — 87   C_INPUT. As you can see, dskxfer     addresses both input and output.  Additionally,  there  are  two  output  modes,  a  simple  write  mode   C_0UTPUT  and a write then verify  mode  C_0UTVFY . At one time, disk  hardware and media were not as reliable as they are today, so it was fool  ish to operate without this mode. Today's hardware is much more reli  able,  so you  don't  really  need  to  operate  in this  mode. The C_0UTVFY  mode is also time consuming, requiring that the write operation complete  and the disk spin one full revolution to perform the verify  operation.   The  next  area  in  which  you  will  notice  a  difference  is  where  ds kxf er     passes the block number, bl kno, into the request packet. You  will  notice  that  when  the  block  number  is  greater  than  MAX SHORT,  dskxfer     sets the r_start field to HUGECOUNT and the r_huge field to  blkno  -  1 ; otherwise, ds kxf er     sets the r_s t a rt field to bl kno  -  1.   Listing  4.5  Source code for  dskxferO   function  —  continued.   switch block_error &rq,  dpbp  ->  dpb_unit     else    i  loop:   case  ABORT:  case  FAIL:   return  FALSE;   case  RETRY:   continue;   case  CONTINUE:   break;   default:   goto  loop;   }   \  j   }  return   TRUE;   }    88 — The FreeDOS Kernel   The two cases are handled similarly because both require that bl kno be  decremented, although the internal representation of a block device starts  with one, whereas the device driver starts with zero. Two data structure  members are needed. Because DOS now allows more than 65,536 blocks  to a device. When the requested block exceeds 65,535, a 32-bit field is  used  instead  of  the  traditional  16-bit field. The  need  for  32-bit  block  addresses resulted from the availability of drives with greater than 32Mb   65,535*512 bytes . The use of a split handler allows for backward com  patibility with older disk drivers.   After  dskxfer     fills the  request  packet,  it  makes  a device  driver  call through the same execrh     function  that the character device uses.  It is after  this call that the function  differs  from  its character  counter  part.  Where  the  corresponding  character  device  handler  simply  exits  through  the  character  error  handler,  dskxfer      has  a loop. The  loop  starts out by invoking the block error handler, the function  that outputs  the familiar  "Abort, retry, fail" error message. Depending  on what the  error  handler  returns   presumably,  the user responded  with one of the  three  choices ,  the  loop  is  responsible  for  the  resulting  action.  For  a  retry response, the loop forces the whole operation to be retried through  a simple C  continue  statement. For a fail  or abort response, the loop  forces  an error return. For a continue response, the loop allows DOS-C  to ignore the error altogether:  a C break  statement allows the  function  to exit through the normal function  return so that a success is returned  regardless of what the driver reported. Note that the error handler must  return a valid condition; otherwise, dskxfer     repeats the loop until it  receives  a known  return  code. The  use  of  the  infinite  loop  forces  the  process to repeat until the user returns a valid response.   The  next  step  up  from  the  disk  driver  interface  dskxferO   is  fl  ushl      Listing 4.6 . This function  moves up one level by working  with the block structure, unlike  dskxfer     which works with the data  itself.  This  allows  flushlO  to  work  more  efficiently  through  key  block structure members and also gives it full control over when to do a  physical write.    DOS-C Kernel: File System Manager — 89   The first order of business for  f 1 ushl     is to examine the members  b_f 1 ag, which indicates that the data in the buffer  is valid if TRUE, and  b_update,  which  indicates  that  the  data in the buffer  has been  modi  fied. If  both  these  members  are  true,  fl  ushl      transfers  the  data  to  disk.  When  flushlO  completes  the  operation,  it  clears  b_update,  indicating the data has been saved to disk, and clears b_f 1 a g if an error  occurred during the write process.   Like its companion  f 1 ushl    ,  f i 11     also is in the next layer  up  from the device driver interface  Listing 4.7 . Where f 1 ushl     handles  the write operation, f i 11     handles the read operation,  fi  11     is simi  lar to  f 1 ushl     with one major  exception: it must save the buffer,  if it  was modified to disk. In order to do this, the entry code is  different.   Upon entry,  f i 11     examines the member  b_f 1 ag, which indicates  whether  or  not  it  contains  valid  data.  It  also  examines  the  member  b_update,  which records whether the data has been  modified.  If both  conditions  are true,  f i 11     calls  f 1 ushl     to clear  the buffer  before  proceeding any further.  Next, it performs  a precautionary test to ensure   Listing 4.6  Source code for  flushlO  BOOL  flushl   struct buffer FAR *lpBlock   {   function.   REG WORD ok;  if    IpBloc k  ->  b_flag  &&  IpBlock  ->  b_update    ok  =  dskxferdpBlock  ->  b_unit,   IpBlock  ->  b_blkno,    VOID  FAR  * lpBlock  ->  b  . b u f f e r,  DSKWRITE ;   else   ok  =  TRUE;   IpBlock  ->  b_update  =  FALSE;   IpBlock  ->  b_flag  &=  ok;   return ok ;   }   *    *  even  if  error,   *  mark  not  d i r ty  *    *  otherwise  system  has  *    *  trouble   continuing.  *     90 — The FreeDOS Kernel   that  if the buffer  did require  a write  operation,  it completed  properly.  f i 11      accomplishes this through the local variable ok, which contains  the  return  code  if  a  write  operation  was  performed.  If  the  operation  does not require a write,  f i 11      sets  ok to TRUE in order to guarantee  the read operation takes place.   Once the ds kxf er     operation completes, f i 11      assigns the return  code to the member b_f 1 ag. This invalidates the buffer if the read oper  ation  failed.  Finally,  fil  1      clears  the member  b_update,  indicating  that the buffer  is clean, and updates the members  b_bl kno and b_uni t  to identify  the disk block associated with this  buffer.   With  the  single  buffer  operations  in  place,  the  next  step  up  is  the  buffer  chain operations. These operations are the ones that maintain the  chain  and  implement  the LRU  functionality.  There  is  really  only  one  active chain entry point,  getbl ock   , but there are a number of chain   Listing  4.7   Source code for   fi   7 7      function.    REG   s t r u ct  b u f f er  FAR  * l pB   l o c k,  LONG  b l k n o,   COUNT   dsk    - >  b _ f l ag  &&  IpBl   ock  ->  b_update    f l u s h l   l p B l o c k  ;   BOOL  f i ll  r  i   REG WORD Ok;   i f d p B l o ck  ok  =   else   ok  =   TRUE;   i f   o k    DSKREAD ;   IpBlock  IpBlock  IpBlock  IpBlock  r e t u r n  o   ->  b_flag  =  ok;  ->  b_update  =  FALSE;  ->  b_blkno  =  blkno;  ->  b_unit  =  dsk;  k ;   }   ok  =   dskxfer dsk,  blkno,    VOID  FAR  *   l p Bl   ock   ->   b_buffer,    DOS-C Kernel: File System Manager — 91   maintenance functions.  The function  fl  ush_buf f ers     is an example  of a chain maintenance function   Listing 4.8 .   Sometimes DOS-C needs to ensure that all the disk buffers  are writ  ten to disk. This condition may occur when all files on a disk are closed  and  files  were  written  to.  This  is  an  example  of  when  DOS-C  calls  fl  ush_buffers    .   The  function   is  simple.  It  begins  by  initializing  the  variable   1 pBl ock. It uses a whi 1 e loop to walk the chain, examining each buffer  on the chain for  a match to the requested disk. If the buffer  belongs to  the requested  disk,  fl  ush_buffers     invokes  fl  ushl     to write  the  buffer  out.  It  then  picks  up  the  next  buffer  address  from  the  bjnext  member  and  continues  the loop. Note  that  the  loop terminates  with  a  null pointer that terminates the chain.   Other simple functions perform operations similar to f 1 u s h_b u f f e r s    ,   such as  init_buffers    , which initializes the chain;  fl  ush   , which  flushes all buffers  to disk; and  seti nvl d   , which invalidates a number   Listing  4.8  Source code for  fl  ush_   _bu ffers      function.   BOOL  flush_buffers  r    REG  COUNT  dsk    REG  struct  buffer  FAR  *lpBlock;  REG  BOOL  ok  =  TRUE;   f i r s t b u f;    IpBlock    IpBlock  =  while  t   i f d p B l o ck   ->  b_unit  ==  dsk    i f   i f l u s h l d p B l o c k      ok  =  FALSE;   IpBlock  =  IpBlock  ->  b_next;   j  return  ok;   }    92 — The FreeDOS Kernel   of  buffers  on  the  chain.  These  are  chain  maintenance  functions  whose  need  arises from  various DOS-C conditions, but a single entry, as men  tioned earlier, performs the LRU maintenance. This results from the fun  damental  design  rule  for  block  I O.  DOS-C  reads  and  writes  all  disk  blocks through the buffer  chain. This simplifies  stream I O at the higher  levels. All higher level functions  request a block and modify  it. When it  becomes  necessary  to  update  a  block,  DOS-C  performs  all  updates  through the buffer  chain maintenance functions. As a result, there are no  explicit read or write block calls.   Listing 4.9  Source code for  getbl  ock     function.  struct buffer FAR *  getblock   LONG blkno, COUNT dsk   {   REG  struct  buffer  FAR  *lpBlock;  REG  struct  buffer  FAR  ^IpLastBlock;  REG  struct  buffer  FAR  *lpMiddleBlock;  REG WORD  imsave;    *  Search  through  buffers  is   already  in  a  buffer   *   to  see  if   the  required  block   IpBlock  =  f i r s t b u f ;  IpLastBlock  =  NULL;  IpMiddleBlock  =  NULL;  whiledpBlock  !=  NULL   {   if     IpBlock  ->  b_flag   &&   IpBlock  ->  b_unit  ==  dsk    &&   IpBlock  ->  b_blkno  ==  blkno       {    *  found   it  ifdpLastBlock  {   --  rearrange  LRU  links   !=   NULL    IpLastBlock  ->  b_next  =  IpBlock  ->  b_next;  IpBlock  ->  b_next  =  f i r s t b uf  =  IpBlock;   f i r s t b u f;   }  return lpBlock ;   *   *    *     DOS-C Kernel: File System Manager — 93   The function  getblock    is responsible for returning a block to any  function  that needs  it   Listing  4.9 . In order to do this  and  follow  the  basic  design  rules, the design  for  getbl ock    is in two parts. First it  searches  the  chain,  and  next  it removes  a block.  How  it removes  the  block is what determines the read or write operation.   The  function  starts  off  by  initializing  three  pointers:  IpBlock,   IpLastBlock,  and  1 pMiddl eBl ock. The pointer  1 pBl ock points to the  current block and is the variable used to terminate the whi 1 e loop fol  lowing  the  initialization.  Three  conditions  determine  if  a  block  is  found:   1  the block  is  valid   b_f 1 ag ,   2  it  is  from  the  correct  disk   b_uni t , and  3  it is the block we want  b_bl kno . If these conditions  are met, getbl ock    removes the buffer  from the chain and places it at  the front  of the chain before  returning the buffer  address; otherwise, it   Listing  4.9  Source code for  getbl  ock     function   -  continued.  -  else  r  i   }    *  move  along  to  next  buffer*   IpMiddleBlock  =  IpLastBlock;  IpLastBlock  =  IpBlock;  IpBlock  =  IpBlock  ->  b_next;   }   *  The  block  we  need  is  not  in  a  buffer,  we  must  r   *  buffer  available,  and  f i ll   it  with  the  desired   nake  a  block    *  detach  1ru  buffer  *   ifdpMiddleBlock   !=   NULL    IpMiddleBlock  ->  b_next  =  NULL;   IpLastBlock  ->  b_next  =  f i r s t b uf  =  IpLastBlock;  i f   f l u s h l d p L a s t B l o c k   &&  f i ll   IpLastBlock,   *  success   *    f i r s t b u f;   IpMiddleBlock  =  IpLastBlock;   IpMiddleBlock  =  NULL;    *   f a i l u re   return    IpMiddleBlock ;   else   }   bl kno   ,  dsk     *   *    *     94 — The FreeDOS Kernel   reassigns the pointers and moves the current buffer  pointer to the next  buffer  in the chain. If the whi 1 e loop terminates, then the buffer  is not  on the chain  and  getbl ock    removes the last buffer  from  the chain.  flushl      writes  out  the  block's  contents,  if  necessary,  and  fil  1       reads the desired block's  contents,  getbl ock    then returns the block  address to the caller, conditioned by error handling.   FAT File System  Functions  Three  files  make  up  the  fs  module:  fattab.c,  fatdir.c,  and  f atf s . c. I chose to partition the functions  that make up f s in this way  so that each of these three files corresponds to the three distinct  objects  that make up the FAT file system disk discussed in Chapter 2. The file  fattab.c  deals  with  FAT handling  on  a  device.  It  works  with  both  12-bit and  16-bit FAT devices, and it treats both in a uniform  fashion.  The file f atdi r. c handles all directory management and is responsible  for directory searches  i.e., Find First and Find Next . The file f atf s . c  handles all the remaining data functions  and maps these functions  into  a support subset for the dosf ns and f cbf ns personality layers.   FAT  Management  As you have seen before, a symmetry similar to the read and write sym  metry  seen in both the character  and block device interfaces  exists  for  both operations of linking a FAT block number into a chain and retriev  ing  a  FAT block  number  from  the  FAT  chain   Figure  4.5 .  The  file  fattab.cis  made up of a FAT block retrieval portion  read  and a FAT  block  is  next_cl  uster    .  This  function  returns  the  next  cluster  in  a  chain  given  the  current  cluster.  Similarly,  the  linking  portion  entry  is  1 ink_fat    . This  function  takes  two  FAT cluster  numbers  and  links  the second cluster into the first cluster.   retrieval  portion  entry   linking  portion    write .  The    DOS-C Kernel: File System Manager — 95   Retrieving a FAT Cluster Number  The best way to look at these functions is to start with next_cl  lister      and  then  examine  link_fat  .  Because  next_cl  uster      does  not  modify  any data structures, I will use it to study the fundamental  algo  rithms. I will proceed by looking at the  16-bit handlers, then the  12-bit  handlers.  The  16-bit  handlers  are  easier  to  understand  because  they  don't  have to  deal  with packing  issues resulting  from  the mapping  of  12-bit  values  into  byte-oriented  data  structures.  Using  this  approach,  you get an opportunity to look at the FAT closely before dealing with the  complications of the linking  functions.   Figure 4.5  FAT file system functionality  layer.   DOS-Compatible System Calls   DOS API Entry Points   fcbfns  fs  chario   dosfns   memmgr   blockio   Task and Process Support Code   task   execrh   Device Drivers   Machine Level Support Code    96 — The FreeDOS Kernel   The design of the upper layer of the FAT file system requires that the  FAT handlers  treat  all  disks  in  a uniform  manner. As  discussed  earlier,  there are two different  FAT sizes:  12-bit and  16-bit. Because the higher  level functions don't concern themselves with the type of FAT,  only a sin  gle entry point is provided: next_cl  lister      Listing 4.10 . The require  ments of this function  are relatively  simple: it must decide what type of  FAT  the  disk  uses  and  then  dispatch  the  correct  handler.  The  macro  IS FATI2  Figure 4.6  is used to decide which function to call by first test  ing the disk parameter block  dpb_si ze  member to determine what size  FAT the current device contains. This test looks to see if the size of the  disk is less than or equal to  FAT_MAGIC  4086  blocks. If it is, then the  FAT is a 12-bit type and next_cl  uster     invokes next_cl  12   ; other  wise it invokes next_c 116     .   The two FAT handlers are both similar in design, but I will examine  next_cl  16    first  Listing 4.11 . This provides an opportunity to look  cleanly at the algorithm that walks a linked list in the FAT.  In each case,  the algorithm begins by getting the physical block that corresponds  to  the  given  FAT number.  It  determines  the  blocks  location  on  disk  by  computing  the  number  of  FAT entries  within  a  single  disk  block  and  scaling the block number by the number of FAT  entries within a block.  For both  the  12-bit  and  16-bit  cases, the  algorithm  then  computes  an  index into the block it fetched  earlier. It then retrieves the next cluster  number  from  the  block  by  using  a  byte-order-neutral  function  and  returns the next cluster number to the caller.   Listing  4.10  Source  code for  next_cl  uster   UWORD  next_cluster   struct dpb *dpbp, REG UCOUNT  CIusterNum   {      function.   if ISFAT12 dpbp    else  if ISFAT16 dpbp    else   return next_cl12 dpbp, CIusterNum ;  return next_cl16 dpbp, CIusterNum ;  return  LONG_LAST_CLUSTER;   }    DOS-C Kernel: File System Manager — 97   Figure  4.6   I SFATI 2 macro for  use I   with   next_   _cluster     .   define  ISFAT12 dpbp       dpbp -  >dpb_   .sizeX   =FAT_   MAGIC    UCOUNT   CIusterNum    REG    struct  dpb  *dpbp   WORD  next_cluster  r  I  if ISFAT12 dpbp    return  next_cl12 dpbp,  CIusterNum   else  return  next_cl16 dpbp ,  CIusterNum   else  return  LONG  LAST  CLUSTER;   if ISFAT16 dpbp     ;  ;   }   Listing  4.11  Source  code for  next_cl  16     function.   UWORD  next_cll6   struct dpb *dpbp, REG UCOUNT CIusterNum   {   UCOUNT idx;  struct buffer FAR *bp;  UWORD RetCluster;   * Get the block that this cluster is in *   bp = getblock  LONG    LONG ClusterNum  * SIZE0F_CLST16     dpbp -> dpb_secsize + dpbp ->  dpb_fatstrt + l,dpbp -> dpb_unit ;   if bp == NULL    return DE_BLKINVLD;    * form an index so that we can read the block as a   * byte array  idx =    LONG ClusterNum  * SIZE0F_CLST16  %   dpbp -> dpb_secsize;    * Get the cluster number, *   fgetword  VOID FAR * & bp -> b_buffer[idx] ,    WORD FAR * &RetCluster ;    * and return successful. *   return  RetCl uster;   }   *   *     98 — The FreeDOS Kernel   The differences  between the  12-bit and  16-bit cases become  appar  ent when you compare next_cl  12     to next_cl  16    . next_cl  12     is  shown  in  Listing  4.12.  The  most  obvious  difference  is  in  size.  next_cl  12     is larger  than  its  16-bit  counterpart,  which  results  from  the special unpacking that it must perform.  The  12-bit FAT packs two  FAT numbers  into  3 bytes,  saving  1 byte  for  every  two  entries  when  compared to the  16-bit FAT. However, the complexity of this operation  forces  next_cl  12     to work harder.   Like  its  16-bit  counterpart,  next_cll2    begins  by  getting  the  block that corresponds  to the given FAT cluster  number. It also  deter  mines the block by computing the number of FAT cluster entries within   Listing  4.12   Source  code for  next_cl  12      function.   UWORD  next_cll2  struct dpb *dpbp, REG UCOUNT CI usterNum   {   REG UBYTE FAR *fbpO, FAR *fbpl;  UCOUNT idx;  struct buffer FAR *bp, FAR *bpl;   * Get the block that this cluster is in *   bp = getblock  LONG     ClusterNum «  1  + CIusterNum  »  1     dpbp -> dpb_secsize + dpbp ->  dpb_fatstrt + 1 , dpbp -> dpb_unit ;   if bp == NULL    return BAD;    * form an index so that we can read the block as a   * byte array  idx =    CIusterNum «  1  + CIusterNum  »  1  % dpbp -> dpb_secsize;   * Test to see if the cluster straddles the block. If it   * does, get the next block and use both to form the   * FAT word. Otherwise, just point to the next block.  if idx >= dpbp -> dpb_secsize - 1   {   bpl = getblock  LONG  dpbp -> dpb_fatstrt +   *    *    *   *   *        ClusterNum «  1  + ClusterNum  »  1     dpbp -> dpb_secsize   + 2, dpbp -> dpb_unit ;   if bpl ==  struct buffer * 0   fbpl =  UBYTE FAR * & bpl -> b_buffer[0] ;   return BAD;   }    DOS-C Kernel: File System Manager — 99   a  single  disk  block  and  scaling  it. At  this  point,  the  12-bit  algorithm  diverges from  the  16-bit algorithm. The  12-bit FAT table entry  always  straddles  2 bytes  and the algorithm computes  an index into the block.  However, because  of the 3-to-2  ratio of bytes-to-entries, certain  block  sizes  may  cause  the  last  entry  in  the  block  to  straddle  into  the  next  block. For example, in a 512-byte block, 341 entries occupy 511 bytes,  leaving a single byte in each 512-byte block. This results in the unique  situation that if the index points to the last byte in the block, the entry  straddles the next block.   At  this  point,  next_cl  12      determines  if  the  FAT cluster  number  straddles the block with the use of two pointers to build the FAT cluster  number. If the entry  starts on the last byte of the block,  next_cl  12      reads the next block and sets the second pointer to the first byte, other  wise it simply sets the second pointer to the next byte in the block.   At  this  point,  next_cl  12      fetches  the  2  bytes  that  compose  the  next cluster number from the block or blocks by using a special method  that  differentiates  odd-numbered  from  even-numbered  FAT  entries,  which  are  packed  differently.  next_cl  12      performs  a  test  for  odd- numbered  FAT entries  and  executes  the  correct  unpacking  procedure   Listing 4.12  Source code for  next_cl  12     function  —   continued.   fbpl =  UBYTE FAR * & bp -> b_buffer[idx + 1] ;   else  fbpO  =  UBYTE FAR * & bp -> b_buffer[idx] ;   * Now to unpack the contents of the FAT entry. Odd and   * even bytes are packed differently.  if  ClusterNum & 0x01   ClusterNum =   *fbp0 & OxfO  »  4   *fbpl « 4;  else  ClusterNum = *fbp0    *fbpl & OxOf  « 8 ;  if   ClusterNum & MASK  == MASK   ClusterNum = LAST_CLUSTER;  else if   ClusterNum & BAD  == BAD   ClusterNum = BAD;  return  ClusterNum;   *   *     100 — The FreeDOS Kernel   based  on  the  outcome.  The  function  returns  this  number  unless  it  encounters  a last cluster  or bad  cluster  value, in which  case it returns  the  16-bit  equivalent  instead,  satisfying  the  FAT  size  independence  requirement of the upper layers.  Writing a FAT Cluster Number  As with the next_cl  us ter     function, the higher level functions  don't  concern themselves with the type of FAT, so only a single entry point is  provided:  1 ink_fat       Listing  4.13 . The  requirements  of  this  func  tion  are  the  same  as  those  of  next_cl  uster    :  it  must  decide  what  type of FAT the disk uses and then dispatch the correct handler. It per  forms these tasks in exactly the same way as next_cl  uster     and dis  patches  either  1 ink_fatl2      or  1 ink_fatl6      for  12-bit  and  16-bit  FATs respectively.   Again  the  two FAT handlers  are both  similar  in  design,  and  I will  examine the  16-bit handler,  1 ink_f atl6    , first  Listing 4.14 . As you  already  know,  the  16-bit  version  is  simpler  than  the  12-bit  version  because  it  doesn't  concern  itself  with  packing  and  unpacking  cluster  numbers.   As with the next_cl  uster     functions, the 1 i n k_f at     algorithms  begin by getting the block that corresponds  to the given FAT number.  They both determine the block by computing and scaling the number of  FAT entries within  a single disk block.  For both the  12-bit  and  16-bit  cases, the algorithm then computes  an index into the block and places   Listing  4.13  Source code for   Tin   k_fat       function.   UCOUNT  l i n k _ f at  r  l   else   else   }     s t r u c t  dpb  *dpbp,  UCOUNT   Cluste   r l,  REG   UCOUNT   Cl uster "2    if ISFAT12 dpbp     return  1ink_fatl2 dpbp ,  if ISFAT16 dpbp    return  1ink_fatl6 dpbp,   Cl   u s t e r l ,   C l u s t e r 2   ;   Cl   u s t e r l,   C l u s t e r 2  ;   return  DE_BLKINVLD;    DOS-C Kernel: File System Manager — 707   the next cluster number into the block using a byte-order-neutral  func  tion. Unlike the next_cl  16     function,  1 i n k_f at 16     must now mark  the  block  as  modified  in  order  to  guarantee  that  the  FAT is  properly  updated.  It  also  updates  the  dpb,  which  is  an  internal  data  structure   Listing 4.14  Source code for  1 ink_fatl6   UCOUNT  link_fatl6   struct dpb *dpbp, UCOUNT Clusterl, UCOUNT Cluster2   {     function.   UCOUNT idx;  struct buffer FAR *bp;  UWORD C12 = Cluster2;   * Get the block that this cluster is in *   bp = getblock  LONG    LONG Clusterl  * SIZE0F_CLST16      dpbp -> dpb_secsize + dpbp -> dpb_fatstrt + 1,  dpbp -> dpb_unit ;   b_buffer[idx]  ;   if bp == NULL    * Finally, put the word into the buffer and mark the   * buffer as dirty.  fputword  WORD FAR * &C12,  VOID FAR * & bp ->  bp -> b_update = TRUE;   * Return successful .   * update the free space count  if Cluster2 == FREE   {    * update the free space count for returned cluster  if dpbp -> dpb_nfreeclst != UNKNCLUSTER    ++dpbp -> dpb_nfreeclst;   *   *    *   *    *     * update the free space count for removed  cluster  if dpbp -> dpb_nfreeclst != UNKNCLUSTER    --dpbp -> dpb_nfreeclst;   else   return SUCCESS;    702 — The FreeDOS Kernel   associated with the disk. It increases the dpbjnf reecl st  member if the  linked cluster is actually a free cluster entry and decreases it otherwise.  This  way,  the  structure  is  updated  as  we  remove  clusters  from  and  return clusters to the free pool.   Listing 4.15  Source code for  1 i nk_fatl2   UCOUNT  link_fatl2  struct dpb *dpbp, UCOUNT Clusterl, UCOUNT Cluster2   {     function.   REG UBYTE FAR *fbpO, FAR *fbpl;  UCOUNT idx;  struct buffer FAR *bp, FAR *bpl;   * Get the block that this cluster is in  bp = getblock  LONG     Clusterl «  1  + Clusterl  »  1      *   dpbp -> dpb_secsize + dpbp -> dpb_fatstrt  +  1 , dpbp -> dpb_unit ;   if bp == NULL    return DE_BLKINVLD;    * form an index so that we can read the block as a   * byte array  idx =    Clusterl «  1  + Clusterl  »  1  % dpbp ->   *   *    dpb_secsize;    * Test to see if the cluster straddles the block. If it  *    * does, get the next block and use both to form the  *    * FAT word. Otherwise, just point to the next block.  *   if idx >= dpbp -> dpb_secsize - 1   {   bpl = getblock  LONG  dpbp -> dpb_fatstrt +     Clusterl  «  + Clusterl  >> 1    dpbp -> dpb_secsize    + 2, dpbp -> dpb_unit ;   1    if bpl ==  struct buffer * 0   return DE_BLKINVLD;  bpl -> b_update = TRUE;  fbpl =  UBYTE FAR * & bpl -> b_buffer[0] ;   }  else  fbpO  =  UBYTE FAR * & bp -> b_buffer[idx] ;  bp -> b_update = TRUE;   fbpl =  UBYTE FAR * & bp -> b_buffer[idx + 1] ;    DOS-C Kernel: File System Manager — 103   Like its  16-bit counterpart,  the  1 ink_fatl2       Listing  4.15   func  tion begins by getting the block that corresponds to the given FAT num  ber.  It  also  determines  the block  and  fetches  it. Next,  it  computes  an  index into the block, but unlike 1 i n k_f a 116    , it must pack the desired  cluster into the block. To do this, 1 i n k_f at 12     uses an algorithm sim  ilar to that used by next_cl  12    . Once it packs the cluster number into  the block, it must mark the block and update the dpb in the same way as  link_fatl6  .   Listing 4.15  Source code for  11 nk_fatl2      function  —   continued.    *  Now  pack  the  value  in  *   if    Clusterl  &  0x01    *fbp0  =   *fbp0  &  OxOf   *fbpl  =   Cluster2  »  4   &  Oxff;       Cluster2  &  OxOf   «  4 ;   *fbp0 = Cluster2 & Oxff;  *fbpl =  *fbpl & OxfO   Cluster2 »  8  & OxOf;    * update the free space count *   if Cluster2 == FREE     * update the free space count for returned cluster  ifCdpbp -> dpb_nfreeclst != UNKNCLUSTER    *    ++dpbp -> dpb_nfreeclst;    * update the free space count for removed cluster  ifCdpbp -> dpb_nfreeclst != UNKNCLUSTER    --dpbp -> dpb_nfreeclst;   *    }  return SUCCESS;   }   else   else    104 — The FreeDOS Kernel   Directory  Management  Now that I have examined the functions that manage the disk FAT,  I will  move on to the directory management functions. This really puts you in  an excellent position because you have seen the interaction of  functions  at this level with the  getbl ock    support  function.  Many  of the other  functions  at this level will operate in a similar fashion. You will also get  a first look at a DOS service function.  These functions  typically have a  DOS-like functionality  associated with them but may deal with an inter  nal data structure or may only supply a portion of the DOS  function.   The  di rent  Structure  Two important structures are used in directory management: di rent  and  f_node   Listings 4.16 and 4.17 . The di rent  structure is the first struc  ture I will  examine,  and it is  also  a key  data  structure. The  structure's  design  mirrors  the FAT directory  entry  so that  you  can  easily  transfer  directory data into and out of memory. It contains filename and extension  in fields di r_name and di r_ext  identical to the directory record on the  disk.  DOS-C  maintains  attributes,  date,  and  time  stamp  in  fields  di r_attri  b,  di r_date,  and di r_time  that are in memory identical to   Listing  4.16  Source code for  a   *irent  structure.   struct  di   rent  r  l   UBYTE   UBYTE   UBYTE   BYTE  time  date  UWORD   dir_name[FNAME_SIZE];   dir_ext[FEXT_SIZE];   di  r _ a t t r i b;  dir_reserved[10];  di  r_time;  dir_date;  di  r_start;   1*   Filename    *   Filename  extension   1*   File  Attribute    *   *   *  1*  1*  1*   reserved  Time  f i le   created updated  Date  f i le  created updated  Starting  cluster  1st  available  =  2  File  size  in  bytes   *    *    *    *   *   *   *   *   *    ULONG   di  r_size;   };    DOS-C Kernel: File System Manager — 705   their respective directory record entries. However DOS-C translates file  size and starting cluster in d i r_s i ze  and d i r_s t a r t  to the machine's  native memory representation. For 80x86 machines, the memory  format  matches the disk format, but the code uses portable techniques for other  architectures. As you will  see, DOS-C uses this  structure  for  every file  access and maintenance routine.   Listing  4.17  Source code for  f_node  structure.   f_node   struct  r  i   UWORD  f_count;  COUNT  f_mode;  struct  r  l    *   *    *    *    *    *   *    *   *   *   *   *   *    *   *   *   *   *   *   *   *   number  of  uses  of  this  f i le  read,  w r i t e,  read-write,  etc   directory  has  been  modified   directory   is   the  root   f_node  is  new  and  needs   f i ll   f_node  is  assigned  to  d ir   directory   is   f u ll   f i le  this   flags  f i l e 's  dir  entry  image   offset  of  the  d ir  entry  the  startin g  cluster  of  dir  when  dir  is  not  root  the  block  device  for   f i le   f i le  size    for  directories   for  next  op  byte  offset  the  largest  offset  ever  the  cluster  we  were  at  the  cluster  we  are  at  the  relative  cluster  the  sector  the  byte  in  the  cluster   in  the  cluster   *   *    *    *    *    *   *    *   *   *   *   *   *    *   *   *   *   *   *   *   *    BOOL   BOOL   BOOL   BOOL   BOOL   f_dmod:  1 ;   f _ d r o o t : l;   f _ d n e w : l;   f _ d d i r : l;   f _ d f u l l : l;   f_flags;  }  struct  di  rent   f_dir;   ULONG  f _ d i r o f f;  UWORD  f _ d i r s t a r t;   struct  dpb  *   f_dpb;   ULONG  f_dsize;  ULONG  f . o f f s e t;  ULONG  f_highwater;  UWORD  f_back;  UWORD  f_cluster;  UWORD  f_relcluster;  UWORD  f_sector;  UWORD  f_boff;   };    106 — The FreeDOS Kernel   The  f_node  Structure  The  f_node  structure  is  the  central  data  structure  that  every  file  and  directory operation in f s uses. Within f s, there is a one-to-one relation  ship between the  fjnode   file node  structure and any file or directory.  Understanding this structure is key to understanding  f s itself.   The first member  in the  structure  is  f_count.  This  member  main  tains  a count  of the number  of references   open, create, etc.   made to  this file. When this member is zero, the fjnode  is free. The next mem  ber  is  fjnode.  This member  contains  a flag that  indicates  what  mode   read, write, read-write, etc.  the file is in.   Many  operations  within  f s  go  through  states.  For  example,  a file  must be opened before  it can be read. The state that it is in when open  must  be  carried  through  from  one  operation  to  another.  Additionally,  other  more  subtle  states need  storage. The member  f_f  1 ags  contains  these bits. The first bit  of  importance  is  f_dmod,  which  indicates  that  the  directory  has  been  modified.  This  bit  is  examined  when  DOS-C  closes a file and the directory entry is updated if it is set. The next bit is  f_droot,  which indicates that the directory associated with this  fjnode  is the root directory and requires special handling. When an  fjnode  is  first allocated, a bit is necessary to indicate that the fjnode  is new and  needs to be filled. Bit  f_dnew  indicates this state. Also, an  fjnode  can  be  assigned  either  to  a file or  a  directory.  If  bit  f_ddi  r  is  TRUE, the  f_node  is  assigned  to  a  directory.  Finally,  on  occasion,  a  directory  search may encounter an "end of directory" condition, a state especially  important when trying to obtain a free directory slot. Bit f_df  ul 1  indi  cates that the directory is full when TRUE.   The  next  member  in  the  structure  is  the  di rent   f_di  r  structure.  This  is the  file's  directory  entry  image. Every file operation,  whether  directory management or data manipulation, uses this entry. Associated  with the directory image are two members that position the entry within  its  directory:  f_diroff  and  f_dirstart.  The  member  f_diroff  records  the byte  offset  of  the  directory  entry.  It  is  used  primarily  for  locating the correct block and offset  for directory read and write opera  tions. Member  f  di rstart  records the starting cluster of the directory  when it is not the disk's root directory. As discussed in Chapter  2, the    DOS-C Kernel: File System Manager — 707   root  directory  is  a sequential  set of  disk blocks fixed in both  position  and  length,  whereas  subdirectories  are  special  files  that  obey  all file  rules. As a result, functions  that read and write the contents of a direc  tory must be aware of the distinction. The member  f  di rstart  is an  optimization entry that allows DOS-C to do the disk search to find the  start only once. As you will see later, this search can be costly for files  that are many directories deep.   The next entry is a pointer toadpb  struct. This is the disk parame  ter block  for  the block  device corresponding  to this file, dpb is  a data  structure  that  contains  all  disk-related  information  such  as  disk  size,  geometry, etc. It is this pointer that DOS-C uses to identify  the disk. In  fact, this is the structure built up by the Media Check Device Driver call.  The next member, f_dsi ze, is a measure of the size in byes of direc  tories. DOS-C  uses this  member  to maintain  the  size  of  the  directory  during directory searches. It sets this member when opening a directory  and  checks  it  when  reading  a  directory.  DOS-C  also  maintains  this  f_node  member  in Find First  and Find Next  functions,  because  these  functions  use the Directory Read function  in their search.   The next two members in the  f_node  data structure maintain the file  position information. The first member, f_of  f set, records the byte offset  in the file for the next read or write operation. At the beginning  of each  data transfer  operation, DOS-C translates  f_of  f set  into information  on  the physical position of the block and computes the index into the block.  In  addition,  with  each  write  operation,  DOS-C  compares  f_offset  to  f_highwater  and transfers  f_offset  to  f_highwater  if  f_offset  is  greater than  f_highwater.  In this way  f_highwater  is the write high- water mark, recording  the largest  offset  ever encountered  in  f_of  f set.  You need to record this information  in the event that an application per  forms a seek operation prior to a file write operation. If DOS-C writes data  to the file in a way that extends the file length, and a seek operation fol  lows that  moves  f_offset  to  a position  within  the  file,  f_highwater  contains the true file size. DOS-C later uses  f_hi  ghwater  to update the  directory entry when the application closes the  file.    108 — The FreeDOS Kernel   The member  f_back  contains the last cluster number of a sequential  file access. It is used to link the FAT when new blocks are added to the  file.  Associated with this member is f_cl  uster. This member contains  the current cluster number and is used to map the current position of the  next read or write operation performed  on the file.   In order to map the file offset  into the physical  sector  and the byte  offset  into  the  sector,  structure  members  f_sector  and  f_boff  are  used to map the sector into the cluster and the byte offset  into the clus  ter,  respectively.  These  members  are  necessary  because  they  must  be  maintained  between  read  and  write  operations  in  order  to  lessen  the  overhead for each operation.  Opening a Directory  Now that I have examined the fundamental  f_node  data structure, I can  begin to look at the file system functions.  These functions  are the first  of the file system  functions  I will  cover that  make use  of the  f_node  structure. They are also similar to the FAT functions  in that they man  age the second part of a FAT file.   DOS-C treats directories in a fashion  similar to files. A directory is  referenced  identically  to  a  file.  For  example,  a  directory  has  a  path  name  that  references  the  directory.  It  also  has  a  directory  entry  in  a  directory with one notable exception — the root directory. Its content is  a sequential  set of records that  are randomly  accessed  and updated  as  needed. In short, a directory resembles  a file in many respects. For all  these reasons, DOS-C manages directories in a fashion  similar to files.  Opening a file entails allocating an f_node  kernel data structure and  initializing it through a call to di r_open      Listing 4.18 . di r_open      does  this  by  first  allocating  an  fjnode  structure  and  presetting  it  to  read-write  mode.  Any  fjnode  that  represents  a  directory  must  be  placed  into  read-write  mode  so  that  DOS-C  properly  records  any  update made to the file by subsequent operations.   Next you determine what drive you are using  so that you can index  the block device table. You need this information because this data struc  ture contains the entire state of the block device which may be modified  by the user  e.g., change the current directory, write to a file, etc. .    DOS-C Kernel: File System Manager — 709   Listing  4.18  Source  code for  di r_open     function.   struct f_node *  dir_open   BYTE FAR *dirname   {   if  n o t . *    struct f_node *fnp;  WORD drive;  REG struct dpb *dpbp;  struct f_node *get_f_node  ;  BYTE path[64], *s ;   *  Allocate  an  f_node  if  possible  -  error  return   0   if  fnp = get_f_node    ==  struct f_node * 0   {  }   return   struct f_node * NULL;    *  Force  the  f_node  into  read-write  mode  fnp  ->  f_mode  =  RDWR;    *  Determine   what  drive  we  are  using...   If   issued.    the  second  character  of   then  a  drive  specifcation  was    *  for  FAT-style  f i le  systems,  if   *  of   the  path  ==  ' : ',  it  was,  update  the  path  to  point  past  the   *   *  f i le   specification  and  assign  drive  to  the  requested   *  drive,  otherwise  if * dirname  +  1   ==  {   ' : '    . ..   drive  =  *di rname  -  i f   d r i ve  >  26     'A';   drive  -=    ' a'   -   ' A '  ;   dirname  +=  2;  dpbp  =  &blk_devices[drive];   }  else  {   *  Selec t  the  default  to  help  non-drive  specified  path   *  searches...   dpbp  =  &blk_devices[drive  =  default_drive];   }  fnp  ->  f_dpb  =  dpbp;   * Generate full  path name  if *di rname == ' '  *di rname == ' W   fscopy dirname,   BYTE  FAR* path ;   *    *    *   *   *   *   *    *   *    *     770 —  The FreeDOS Kernel   You then generate the full path name so that you can properly locate  the directory that contains its entry. Remember that a user can  specify  an absolute filename  i.e., c : \dos\f ormat. exe  or a relative filename   i.e.,  . .\my_dir\my_file.txt .  You  parse  the  filename  prepending  the current directory  for that drive if necessary, then clean up the path  by eliminating  redundant  path  separators  and relative directory  names  such as "." and "..".   Listing 4.18  Source code for  di r_open     function  —   continued.   else  {    *  s t a r t  with  the  logged  in  directory  scopy dpbp  ->  dpb_path,  path ;   * and append passed  relative directory  for s = path; *s != '\0'; ++s ;  *s++ = '\V ;  fscopy dirname,   BYTE  FAR* s ;   }   *  then  clean  up  the  path  trim_path path ;   *  Determin e  if  we  are  starting  from  the  r o o t . ..   ' \ V     *  For  FAT-style  f i le  systems,  the  root  is  a  consective   *  number  of  blocks  given  by  the  bpb.  All  sub-directories   *  ar e  f i l es  and  need  to  be  treated  as  such.  fnp  ->  f_flags.f_droot  =   *path  ==  '  '   &&   * path  +  1   ==     *path  ==  ' \ 0 '  ;   * Perform all directory  common  handling after all   * special  handling has been performed.  ++dpbp -> dpb_count;  if media_check dpbp  < 0   {  --dpbp -> dpb_count;  release_f_node fnp ;  return   struct f_node * 0;   *   *    *    *    *   *   *    *   *     DOS-C Kernel: File System Manager — 777   Now the fun begins. You need to determine if you are starting  from  the  root  because  for  FAT-style  file  systems,  the  root  is  a  consecutive  number of blocks given by the dpb. However, all subdirectories are files  and  dir_open    handles  them  as  such.  Because  of  the  differences   Listing  4.18  Source code for  di  r_open     function  —   continued.   fnp  ->  f _ d i r o ff  =  01  ;  fnp  ->  f_flags.f_dmod  =  FALSE;  fnp  ->  f_flags.f_dnew  =  TRUE;  fnp  ->  f_dsize  =  DIRENT_SIZE  *  dpbp  ->  dpb_dirents;  i f   ! f np  - >  i   f_flags.f_droot     *  a  brand  new  f_node   tree  to  find  the  starting  eli   BYTE  dbuff[FNAME_SIZE+FEXT_SIZE],  *p;  WORD  i;   *  Walk  the  directory   *   *  Set  the  root  flags  since  we  always  s t a rt   *  fro m  the  root  fnp  ->  f_flags.f_droot  =  TRUE;  for p  =  path;  *p  !=  ' \ 0 ';     1    *  skip   all  path  seperators  while *p  ==  7'     *p  ==   ' \ \ '     *  don' t  continue  if  we're  at  the  end  i f   *p  ==   ' \ 0 '    ++P;   break;   ister  *   *   *   *    *    *    *    *   *   *     *  Conver t  the  name  into  an  absolute   *   name  for  comparison...   *  f i r st  f o r  i  =  0 ;  i  <  FNAME_SIZE;  i++   r  i   the  f i le  name  with  t r a i l i ng  spaces...   i f   *p   !=  ' \ 0'  && *p  !=  ' .'  && *p  !=  7'  && *p   d b u f f [ i]  =  *p++ ;   !=  ' \ \ '    else   break;   }    112 — The FreeDOS Kernel   between  a FAT root directory  and subdirectory, the initial task of find  ing the starting point of the directory differs,  and di r_open     handles  each case individually.   Listing 4.18  Source code for  di r_open     function  —   continued.   *   *    *   *    for  ; i < FNAME_SIZE; i++    dbuff[i] = ' ';    * and the extension  don't forget to   * add trailing spaces ...  if *p == '.'   for i = 0; i < FEXT_SIZE; i++   {   ++p;   if *p != '\0' && *p != V  && *p != 7' && *p != '\\'   else   dbuff[i+FNAME_SIZE] = *p++;  break;   }  for  ; i < FEXT_SIZE; i++    dbuff[i+FNAME_SIZE] = ' ';    * Now search through the directory to   * find the entry...  i = FALSE;  touc  BYTE FAR * dbuff, FNAME_SIZE+FEXT_SIZE ;  while dir_read fnp  == DIRENT_SIZE   {   i f   f np  ->  f_dir.dir_name[0]   !=  ' \ 0'  &&  fnp  ->   f_dir.dir_name[0]   !=  DELETED    if fcmp  BYTE  FAR  * dbuff,    BYTE  FAR  * fnp  ->  f_dir.dir_name,  FNAME_SIZE+FEXT_SIZE     {   }   {   }   }   i  =  TRUE;  break;    DOS-C Kernel: File System Manager — 113   After  dir_open    completes  all  special  handling  it  performs  all  common  directory  handling. It increments  the reference  count  for  the  dpb in order to keep track of the number of files using this block device.  It also performs a media check to make sure the user did not change the  media in the drive, and it corrects internal data structures if they are dif  ferent. This is one important difference  between MS-DOS-style operat  ing  systems  and  UNIX-style  operating  systems.  MS-DOS-style  operating  systems  allow  you  to  change  the  disk  on  the  fly,  whereas   Listing  4.18  Source code for  di  r_open     function  —   continued.       ! fnp  ->  f _ d i r . d i r _ a t t r ib  &  D_DIR     --dpbp  ->  dpb_count;  release_f_node fnp ;  return   struct   f_node  *   0;   i f   !i  {   }  else  i   f i le   root    *  make  certain  we've  moved  off  fnp  ->  f_flags.f_droot  =  FALSE;  fnp  ->  f_flags.f_ddir  =  TRUE;   *  se t  up  for  read write  fnp  ->  f . o f f s et  =  01  ;  fnp  ->  fjiighwater  =  01;  fnp  ->  f_cluster  =  fnp  ->  fnp  ->  f _ d i r s t a rt  =  fnp  ->   *  rese t  the  directory  fnp  ->  f _ d i r o ff  =  01  ;  fnp  ->  f_flags.f_dmod  =  FALSE;  fnp  ->  f_flags.f_dnew  =  TRUE;  fnp  ->  f_dsize  =  DIRENT_SIZE  *  dpbp  ->  dpb_di   f _ d i r . d i r _ s t a r t;  f _ d i r . d i r _ s t a r t;   flags   *    *    *    rents;   }   \   }  return   fnp;   }    114 — The FreeDOS Kernel   UNIX-style operating systems require that the disk be mounted prior to  use. Any file system open or create will always do a media check as a  pseudo-mount  operation.   If the media check is successful,  di r_open     initializes the  fjnode  data  structures  to  point  to  the beginning  of  the  directory,  ready  for  a  read operation. Part of this initialization is walking the directory tree to  find the  starting  cluster.  Remember  that  the  search  may  need  to  go  through several directories, verifying  the path, in order to find the start  ing cluster. This search first sets the root flags because the trimmed path  is  an  absolute  path  that  always  starts  from  the  root  directory.  di r_open     adjusts each component of the path to match an MS-DOS  directory  name  entry  by  adding  trailing  spaces  and  concatenating  the  extension.  It  then  performs  a comparison  between  the  adjusted  name  and  the  name  currently  in  the  f_node.  When  a  match  is  found,  di r_open     records the starting cluster into the  f_node.  di r_open     repeats this process until the path is exhausted and the fjnode  contains  the starting cluster of the full path.   Listing  4.19  Source code for  di  r_read      and  di   r_wri   te     functions.   COUNT  dir_read   REG  struct  f_node  *fnp   r  i   REG  i,  j;  struct  buffer   FAR  *bp;   *  Directories  need  to  point  to  their  current  offset,   *  not   for  next  op.  Therefore,  is  anything  other   *  than   the  f i r st  directory  entry,  we  w i ll  update  the   *  offset  on  entry  rather  than  wait  until  e x i t.  it   *  was  new,  clear  the  special  new  f l a g.  i f   f np  ->   f_flags.f_dnew    If   if   it   fnp  ->  f_flags.f_dnew  =  FALSE;   else   fnp  ->  f _ d i r o ff  +=  DIRENT_SIZE;   *   *   *   *   *     DOS-C Kernel: File System Manager — 775   When di r_open     successfully  completes, it returns a pointer to the  initialized  f_node  data  structure. This  is  an important  feature  to  note  because this pointer is the internal representation of a file. All file oper  ations work on this internal data structure and DOS-C converts all user  handles to an  f_node  pointer through the interface  functions  for  inter  nal file operations.  Reading Writing a Directory Entry  Once  a  directory  is  opened,  it  can  either  be  read  from  or  written  to.  DOS-C  provides  two  functions  for  this  purpose:  dir_read    and  di r_wri te       Listing  4.19 . DOS-C  only uses these  functions  in file   Listing 4.19  Source code for  di r_read     and  di r_wr   IteO   functions  — continued.   the  end  of  the  directory.    *  Determine  if  we  h it   *  have,   bump  the  offset  back  to  the  end  and  e x i t.   *  not,    *  f_dmod  b it  and  leave,  but  only  for  root  directories  i f   I   f np  ->   the  di rent  portion  of  the  f_node,  clear  the   f_flags.f_droot    If  we   f i ll   If   &&  fnp  ->  f _ d i r o ff  >=  fnp  ->   f_dsize    *   *   *   *    {   }  else  {   fnp  ->  f _ d i r o ff  return  0 ;   -=  DIRENT_SIZE;   i f   f np  - >  {   f_flags.f_droot    i f     f np  ->  f _ d i r o ff      fnp  ->  f_dpb  ->  dpb_secsize   +  fnp  ->  f_dpb  ->  dpb_dirstrt   >=  fnp  ->  f_dpb  ->  dpb_data    {   fnp  ->  f_flags.f_dfull  =  TRUE;  return  0 ;   }  bp  =  getblock  LONG  fnp  ->  f _ d i r o ff      fnp  ->  f_dpb  ->   dpb_secsize  +  fnp  ->  f_dpb  ->   fnp  ->  f_dpb  ->  dpb_unit ;   dpb_dirstrt ,   }    116 — The FreeDOS Kernel   Listing 4.19  Source code for  di r_read     and  di r_wr   IteO   functions  — continued.   else  {   }   REG UWORD secsize = fnp -> f_dpb -> dpb_secsize;   * Do a "seek" to the directory position  fnp -> f_offset = fnp -> f_diroff;   * Search through the FAT to find the block   * that this entry is in.  if map_cluster fnp, XFR_READ  != SUCCESS   {   fnp  ->  f_flags.f_dfull  =  TRUE;  return  0 ;   }   * If the returned cluster is FREE, return zero   * bytes read.  if fnp -> f_cluster == FREE   return 0;    * If the returned cluster is LAST_CLUSTER or   * LONG_LAST_CLUSTER, return zero bytes read   * and set the directory as full.  if last_link fnp    {   fnp -> f_diroff -= DIRENT_SIZE;  fnp -> f_flags.f_dfull  = TRUE;  return 0;   }   * Compute the block within the cluster and the   * offset within the block.  fnp -> f_sector =   fnp -> f_offset   secsize   & fnp -> f_dpb -> dpb_clsmask;  fnp -> f_boff = fnp -> f_offset  % secsize;   * Get the block we need from cache  bp = getblock     L0NG clus2phys fnp -> f_cluster,  fnp -> f_dpb -> dpb_clssize,  fnp -> f_dpb -> dpb_data   + fnp -> f_sector,   fnp -> f_dpb -> dpb_unit ;   *   *   *    *   *    *   *   *    *   *    *     DOS-C Kernel: File System Manager — 777   open, create, and close operations  and they cannot be accessed by the  user.  They  are  only  called  in  an  indirect  fashion.  As  you  have  done  before, start with the read function  and then note the symmetry and dif  ferences between the read and write  functions.   Before  I  dive  into  the  operation,  you  should  note  one  difference  between directory operations and normal file operations. Data read from  or written to a directory  is contained  within  the  f_node  data  structure  contained  in kernel  memory,  not  in user  memory. As  a result,  DOS-C  directories  need  to  point  to  their  current  offset  because  of  the  record  nature of the directory entry. This means that if it is anything other than  the first directory  entry, you update the offset  on entry  then  wait  until  exit as you would do for normal file data operations.   Listing  4.19  Source code for  di  r_read      and  d i r_   _wri   te     functions  —  continued.    *  Now  that  we  have  the  block   *  the   directory  entry.  i f   bp   !=   NULL    getdirent  BYTE  FAR  * &bp  ->   fo   n  our  en   t r y,   get   f _ d i r o ff  % fnp  ->   struct  d i rent  FAR   b_buffe  f_dpb  -   * &fnp   r[fnp  dpb_  ->  f_   ->  .secsize],  d i r    ;   else  r  l   }   fnp  ->  f_flags.f_dfull  =  TRUE;  return  0 ;    *  Update   the  f_node's  directory  fnp  ->  f_flags.f_dfull  =  FALSE;  fnp  ->  f_flags.f_dmod  =  FALSE;   info    *  and  for  efficiency,  stop  when   *  unused   entry.  i f   f np  ->  f_dir.dir_name[0]  ==   ,N   \0'    we  h it   the   f  i r st   return  0;   else   return  DIRENT  SIZE;   *   *    *    *   *    }   }    118 — The FreeDOS Kernel   Following  this  rule,  di r_read      starts  exactly  this  way. The  algo  rithm also must determine if you hit the end of the directory. If you have,  you need to make certain that you do not proceed past the last record;  otherwise, you fill the di rent  portion of the f_node  for root directories  or do a "seek" to the directory position  and read the cluster number. If  the returned cluster is FREE or it is  LAST_CLUSTER, you return zero bytes  read;  otherwise,  you  compute  the  block  within  the  cluster  and  offset  within the block. You then read the directory entry into the di rent  por  tion of the f_node  and return DI RENT_SI ZE bytes read.   Function  dir_write    functions  slightly  differently.  It  begins  by  determining if the f_node  was modified by a write or create operation.  If  so,  the  function  updates  the  disk  block  containing  the  entry  and  marks the buffer  so that the buffer  cache functions  will write the block  to  disk  when  needed.  This  is  simple  for  root  directories  because  they  are sequential disk blocks and a seek is a simple computation. All other  directories require different  handling.   Listing  4.19  Source code for  di  r_read      and  di  r_wr   ite     functions  —  continued.   COUNT  dir_write  r  i   ;REG  struct  f_node  *fnp    buffer  FAR  *bp;   ite  the  entry  if  ->   f_flags.f_dmod    struct     *  Updc  i f   f np  1   it  was  modified  by  a   write   or  create.. .   *    is  simple.    *  Root   is  a  consecutive  set  of  blocks   *  i f   f np  ->  i   f_flags.f_droot    bp  =  getblock    LONG  fnp  ->  f _ d i r o ff     fnp  ->  +  fnp  ->  f_dpb  ->  dpb_dirstrt ,  fnp  ->  f_dpb  ->  dpb_unit ;   }   ,  so  h   andling   *   *    f_dpb   ->  dpb_secsize    DOS-C Kernel: File System Manager —  779   Listing  4.19  Source  code for  di r_read     and  di r_wr   IteO   functions  —  continued.    *  All  other  directories  are  j u st   *  special   handling  is  resetting  the  offset  so  that   *  we  can  continually  update  the  same  directory  entry.  else  {   f i l e s.  The  only   REG  UWORD  secsize  =  fnp  ->  f_dpb  ->  dpb_secsize;   *   *   *    *   *    *   *    *   *    *   *    *    f_node.    *  Do  a  "seek"  to  the  directory  position   *  and  convert  the  f_node  to  a  directory  fnp  ->  f_offset  =  fnp  ->  f _ d i r o f f;  fnp  ->  f_back  =  LONG_LAST_CLUSTER;  fnp  ->  f_cluster  =  fnp  ->   *  Searc h  through  the  FAT  to  find  the  block   *  that   this  entry  if map_cluster fnp,  XFR_READ   !=  SUCCESS   {   f _ d i r s t a r t;   i n.   is   fnp  ->  f_flags.f_dfull  =  TRUE;  release_f_node fnp ;  return  0;   }   * If the returned cluster is FREE, return zero   * bytes read.  if fnp -> f_cluster == FREE   {   release_f_node fnp ;  return 0;   }   * Compute the block within the cluster and the   * offset within the block.  fnp -> f_sector =   fnp -> f_offset   secsize   & fnp -> f_dpb -> dpb_clsmask;  fnp -> f_boff = fnp -> f_offset  1 secsize;   * Get the block we need from cache  bp = getblock     L0NG clus2phys fnp -> f_cluster,  fnp -> f_dpb -> dpb_clssize,  fnp -> f_dpb -> dpb_data   + fnp -> f_sector,   fnp -> f_dpb -> dpb_unit ;   }    720 —  The FreeDOS Kernel   Note that all directories  other than root are just files. However, you  do need to remember  that  directory  operations  are record-style  opera  tions. This means that the only special handling is resetting the offset  so  that you can continually update the same directory entry, di r_wri te     handles  the  seek  to  the  correct  record  in  a  similar  fashion  to  the  di r_read     algorithm,  and the disk block is updated. When you suc  cessfully  complete, you return  DI RENT_SIZE bytes written.  Closing a Directory  di r_cl ose    is the function  responsible  for  closing  a directory   List  ing 4.20 . Because of the fjnode  design, it is surprisingly simple. First,  dir_close    tests  for  invalid  f_nodes  to  guarantee  code  integrity,  although the  fjnode  should be valid  at this point.  If the  fjnode  con  tains garbage or is an invalid pointer, a kernel crash or corruption of the  file system could be the result, so di r_cl ose    guards against invalid  fjiodes.   Listing  4.19  Source  code for  di r_read     and  di r_wr ite       functions  —  continued.    *  Now  that  we  have  a  block,   *  entry   into  the  block.  i f   bp  ==  NULL   {   release_f_node fnp ;  return  0;   transfer   the  diectory   *   *    }  putdirent  struct di rent FAR * &fnp -> f_dir,   VOID FAR * &bp -> b_buffer[fnp ->  f_diroff  % fnp -> f_dpb -> dpb_secsize] ;   bp -> b_update = TRUE;   }  return DIRENT_SIZE;   }    DOS-C Kernel: File System Manager — 727   dir_close     Next,  dir_close     then  proceeds  to  write  the  entry  through  a  call  to  d i r_w r i t e    . This is a conditional write because the d i r_w r i t e     func  tion examines the  f_node  to see if a prior call modified  it and only per  forms  the  write  if  necessary.  This  optimization  helps  performance  by  reducing unnecessary disk access. Remember, disks are electromechanical  devices and their speed is very slow when compared to processor speeds.  cache  by  calling  fl  ush_buf f ers    ,  causing  all  modified  disk  buffers,  which  include  both  file  and  directory  data,  to  disk.  Again,  fl  us h_buffers      only  conditionally  updates  modified  buffers  for  optimization purposes. Once dirty buffers  in the buffer  cache are safely  on disk, di r_cl ose    decrements the reference  count and releases the  instance of the f_node.  Note that in order to correctly share files when  users  spawn  child  processes,  rei ease_f_node      only  returns  the  f_node  to the f_node  pool when the reference count is zero.   to  be  written   the  buffer   updates   Listing  4.20  Source code for  di  r_   _c 1 ose      function.   VOID  dir_close   REG  struct  f_node  *fnp   i   REG  COUNT  disk  =  fnp  ->  f_dpb  -:   *  Test  for  i f   f np  ==  NULL    invalid  f  nodes   return;   > dpb_   unit;   ifndef   I PL    *  Write  out  the  entry  dir_write fnp ;   endif    *  Clear  buffers  after  flush_buffers disk ;  setinvld disk ;   release    *   and  release  this  -- fnp  ->  f_dpb   release  f  node fnp ;   instance  of  ->  dpb_count;   the   f  jnode   }   *    *    *    *     722 — The FreeDOS Kernel   File  Management  Find First Next  I now look at the first DOS support functions.  Unlike UNIX-like oper  ating  systems,  a  user  cannot  directly  access  an  MS-DOS  directory.  However,  the  need  for  reading  the  directory  contents  is  important. A  user may want to look for a specific file, get the date or access rights of a  file,  or simply list the contents of the  directory. The designers of MS-DOS  designed  the  dos_findfi  rst      and  dos_f indnext      functions  to  handle these situations  Listing 4.21 .   Listing 4.21  Source code for  dos_findfirst     and   dos_findnext       functions.   COUNT  dos_findfirst  {    UCOUNT  a t t r,  BYTE  FAR  *name    REG struct f_node *fnp;  REG dmatch FAR *dmp =  dmatch FAR * dta;  struct dosnames DosName;  REG COUNT i;  BYTE *p;  *    * The findfirst findnext  calls are probably the worst  *    * of the DOS calls. They must work somewhat on the fly   *  i.e. - open but never close . Since we don't want to  *    * lose f_nodes every time a directory is searched, we will *   *    * initialize the DOS dirmatch  structure and then for   * every find, we will  open the current directory, do a  *    * seek and read, then close the f_node.  *    * Start out by initializing the dirmatch  structure.  *   dmp -> dm_drive = default_drive;  dmp -> dm_entry = 0;  dmp -> dm_cluster = 0;  dmp -> dm_attr_srch = attr;  if DosNames name,   struct dosnames FAR * &DosName  != SUCCESS    return  DE_FILENOTFND;    DOS-C Kernel: File System Manager — 123   These  function  calls  must  work  somewhat  on the fly. If  you  do not   properly design the algorithm, d os_f i n d f i r s t     and d os_f i n d n ext      could end up opening a directory and reading it but never closing it. This  would cause you to loose an f_node  for every directory search. To open  a directory and never close it, you must properly implement the support  functions,  dir_open    , di r_read    , and dir_write    .   Listing 4.21  Source code for  dos_findfirst     and   dos_findnext      functions  — continued.   dmp  ->  dm_drive  =  DosName.dn_drive;    *  Build   the  match  pattern  out  of  the  passed  string  for p  =  DosName.dn_name,  i  =  0;  i  <  FNAME_SIZE;  i++   {    *  tes t  for  a  valid  f i le  name  terminator  i f   *p  {   !=  ' \ 0'  &&  *p   ' . '    !=    * If not a wildcard   '*' , just transfer  if *p != '*    else  {   dmp -> dm_name_pat[i] = *p++;    * swallow the wildcard  ++p;   * fill with character wildcard  ?   for  ; i < FNAME_SIZE; i++    * and skip to seperator  while *p != '\0' && *p != '.' && *p   dmp -> dm_name_pat[i] = '?';   != V  && *p != '\\'    ++p;   break;   else   break;    124 — The FreeDOS Kernel   Because you  don't  want to lose  fjnodes  every time  an  application  searches  a  directory,  you  initialize  the  MS-DOS  di rmatch  structure  and then  for  every find, you  open the current  directory, do a seek and  read, then close the fjnode.  You also store all necessary information  in  the  di rmatch  structure  that  is in user  space. This  way, the user  indi  rectly handles  f_node  resource management.   Look  a  little  closer  at  dos_findf  i rst    .  The  function  begins  by  initializing the di rmatch  structure. Next, it parses the pattern in order  to create  an expanded  pattern  in the  di rmatch  structure  to use  in  the   Listing 4.21  Source code for  dos_findfirst     and   dos_findnext      functions  — continued.   for  ; i < FNAME_SIZE; i++    dmp -> dm_name_pat[i] = ' ';   i = 0;   * and the extension  don't forget to add trailing spaces ... *   if *p == '.'   {   ++p;  for  ; i < FEXT_SIZE; i++   {   if *p != '\0' && *p != '.' && *p != V  && *p != '\\'   {   if *p != '*    else   dmp -> dm_name_pat[i+FNAME_SIZE] = *p++;  for  ; i < FEXT_SIZE; i++   break;   dmp -> dm_name_pat[i+FNAME_SIZE]    ? '   else   break;    DOS-C Kernel: File System Manager — 725   directory reads. Note that the expanded pattern removes all "*" charac  ters and fills the pattern with the character wildcard "?". The algorithm  later used in dos_f i nd     next automatically matches the character wild  card in the source pattern. This is how DOS-C implements wildcards.   Listing  4.21  Source code for  dos_findfirst     and   dos_findnext      functions  —  continued.   for   "    ;  i  <  FEXT_SIZE;  i++   dmp  ->  dm_name_pat[i+FNAME_SIZE]  =  '   ';   Now  search  through  the  directory    *  touc  BYTE  FAR  * dmp  ->  dm_name_pat,  FNAME_SIZE+FEXT_SIZE  ;   to  find  the  e n t r y . ..   Special  handling  -  the  volume  id  is  only  in  the  root  directory  and  only  searched  for  once.  So  we  need  to  open  the  root  and  return  only  the  f i r st  entry  contains  the  volume  id  b it  set.   that    *   *   *   *  i f   a t tr  &  D_V0LID   r  i    *  Now  open  this  directory  so  that  we  can  read  the   *  f_node  entry  and  do  a  match  on  i f     f np  =  dir_open  BYT E  FAR  *   " \ \ "     ==  NULL    i t.   return  DE_PATHNOTFND;    *  Now  do  the  search  while dir_read fnp   ==  DIRENT_SIZE   i    *  Test  the  a t t r i b u te  and  return  f i r st  i f   f np  ->   f  d i r . d ir  a t t r ib  &  D VOLID   {   found   pop_dmp dmp,  dir_close fnp ;  return  SUCCESS;   fnp ;   }   i      *  Now  that  we've  done  our  f a i l ed  search,  close  it  and   *  return   an  error.  dir_close fnp ;  return  DE_FILENOTFND;   }   *    *   *   *   *    *   *    *    *    *   *     126 — The FreeDOS Kernel   With the initialization complete, now search through the directory to  find the entry. Use  dos_f i ndnext     to return the first match, but first  you must perform  some special handling. The volume ID is only in the  root  directory  and  only  searched  for  once.  Whenever  the  attributes  passed in from  the user require a volume ID search, you need to open  the root  directory  and return  only the first entry where the volume ID  bit is set. Open the root directory and search by using a whi 1 e loop that  reads the directory entry and terminates when you reach the end of the  directory. Within the loop, test the attribute  of the directory  entry just  read and return the first directory entry found   if any . If you do find a  match,  dos_f indfi  rst      populates  the  users  di rent  structure  by   Listing   4.21  Source code for  dos_f  indfi   rst      and   dos_findnext       functions  —  continued.   Otherwise  j u st   do  a  normal  find  next   1*  else  i   BYTE  LocalPath[67];    *  Build  the  f u ll  path  so  that  we  can  open  sprintf Local  Path,   "%c:%s",  *DosName.dn_path  ==  ' \ 0'  ?  " ."   'A'  +  dmp  ->  dm_drive,  :  DosName.dn_path ;   it    *  Now  open  this  directory  so  that  we  can  read  the   *  f_node  entry  and  do  a  match  on  i f     f np  =  dir_open  BYT E  FAR  * LocalPath    ==  NULL    i t.   return  DE_PATHNOTFND;   dmp  ->  dm_cluster  =  fnp  ->   f _ d i r s t a r t;   pop_dmp dmp,  dmp  ->  dm_entry  =  0;  i f   ! f np  ->    fnp ;   f_flags.f_droot    else   dmp  ->  dm_cluster  =  0;   dir_close fnp ;  return  dos_findnext   ;   }   }   *    *    *   *     DOS-C Kernel: File System Manager — 727   using the pop_dmp    function,  closes the file, and returns  successfully.  If  dos_f i ndf i rst     did not find the entry, it closes the root directory  and returns an error.   If  the  volume  ID  attribute  bit  is  not  set,  dos_f i ndf i rst      uses  dos_findnext      to find the first match.  dos_findf  i rst      prepares  for the call by first building the full  path so that it can open the direc  tory using  di r_open    . It opens this directory so that it can determine  the  starting  cluster  of  the  directory  and  save  the  cluster  in  the  users  di rent  structure. Finally, it closes the directory, which in turn returns  all resources, and exits through dos_f i ndnext    .   Although  d o s_f i n d f i r s t      did  a  search   ID,  dos_f i ndnext     performs  the bulk  of  the  work.  This  partitioning  of  functionality  guarantees  identical  searches  for  both  functions.  This  is  why dos_findfi  rst     exits through dos_fi ndnext    .   for  volume   To start,  dos_f i ndnext      assigns  a pointer  to  the  match  parame  ters. This pointer is actually  a pointer to the disk transfer  area because  MS-DOS specifies that the di r mat eh structure be contained within the   Listing  4.21  Source code for  dos_fi  ndfi  rst      and  continued.     functions  —   dos_findnext    COUNT  d o s _ f i n d n e xt  r  i     v o i d     REG  dmatch  FAR  *dmp  =   dmatch  FAR  *   d t a;  REG  struct  BOOL  found  =  FALSE;  BYTE  FAR  *p,  * q;   f_node  *fnp;    *  assign  our  match  parameters  pointer.  dmp  =   dmatch  FAR  *   d t a;    *  Allocate   an  f_node  if  possible  -  error  i f     f np  =  get_f_node     ==   struct  f_node  i   r e t u rn  DE  FILENOTFND;   }   *    return   0    * 0    if  n o t . *     128 — The FreeDOS Kernel   dta   a remnant of the CP M compatibility rules . Next dos_f i ndnext      allocates an fjnode  if possible and returns a "File not found" error if it  cannot.  dos_f i ndnext     next  selects the drive parameter block  entry  that  corresponds  to  the  drive  specified  in  the  dirmatch  structure.  dos_f i ndnext      then  performs  a media  check  to  guarantee  that  the  user  did not change the disk between  the calls  and returns  an error if  this did happen.   Listing 4.21  Source code for  dos_findfirst     and   dos_findnext      functions  — continued.    *  Force  the  f_node  into  read-write  mode  fnp  ->  f_mode  =  RDWR;   *  Selec t  the  default  to  help  non-drive  specified  path   *  searches...  fnp -> f_dpb = &blk_devices[dmp -> dm_drive];  ++ fnp -> f_dpb  -> dpb_count;  if media_check fnp -> f_dpb  < 0   {   -- fnp -> f_dpb  -> dpb_count;  release_f_node fnp ;  return  DE_FILENOTFND;   fnp  ->  f_dsize  =  DIRENT_SIZE  *   fnp  ->  f_dpb    ->  dpb_dirents;    *  Searc h  through  the  directory   *  a  see k  f i r s t.  if dmp  ->  dm_entry  >  0    to  find  the  entry,  but  do   fnp  ->  f _ d i r o ff  =   dmp  ->  dm_entry  -  1   *  DIRENT_SIZE;   fnp  ->  f_offset  =  fnp  ->  f_highwater  =  fnp  ->   f _ d i r o f f;   fnp  ->  f_cluster  =  dmp  ->  dm_cluster;  fnp  ->  f _ d i r s t a rt  =  dmp  ->  dm_cluster;   *    *   *    *   *     DOS-C Kernel: File System Manager — 729   Listing 4.21  Source code for  dos_findfirst     and   dos_findnext      functions  — continued.    *  Loop  through  the  directory  while dir_read fnp   ==  DIRENT_SIZE   {   ++dmp  ->  dm_entry;  i f   f np  ->   f_dir.dir_name[0]   f_dir.dir_name[0]   !=  DELETED    !=  ' \ 0'  &&  fnp  ->   *   {   {   if fcmp_wild  BYTE  FAR  *  dmp  ->  dm_name_pat ,    BYTE  FAR  * fnp  ->  FNAME_SIZE+FEXT_SIZE     f_dir.dir_name,    *  Tes t  the  a t t r i b u te  as  the  final  step*   i f   f np  ->   f _ d i r . d i r _ a t t r ib  &  D_V0LID    continue;   i f    else    ~ dmp  ->  dm_attr_srch  &  fnp  ->  &   D_DIR    D_SYSTEM    D_HIDDEN    ==  0    f _ d i r . d i r _ a t t r i b      D_ARCHIVE    D_RD0NLY    {   }  else   found  =  TRUE;  break;   continue;    * If found, transfer it to the dmatch  structure  if found    pop_dmp dmp,  fnp ;    * return the result  -- fnp -> f_dpb  -> dpb_count;  release_f_node fnp ;  return found ? SUCCESS : DE_FILENOTFND;    130 — The FreeDOS Kernel   With  all these  preliminaries  out  of the way,  dos_f indnext      gets  down to business  and starts to search through the directory to find the  entry. First it recovers information  saved in the  di rmatch  structure by  dos_f indf i rst     and does  a seek to the directory  record  that corre  sponds  to  the  next  record  to  be  read.  dos_f indnext      falls  into  a  whi 1 e loop whose exit criterion is an end-of-file  on the directory. As it  loops through the directory, it performs  a wildcard match on the name  field of the entry if it is not a deleted entry. If a match occurs, it tests the  attribute as the final step because a match condition requires both name  and attribute matches. If an entry meets both criteria, dos_f i ndnext      transfers  the entry into the  dmatch  structure and returns the resources.  Finally, it returns a success or file-not-found error based on the result of  the search. This satisfies MS-DOS requirements and completes the first  look at DOS support  functions.   Listing  4.22  Source  code for  dos_open      function.  COUNT  dos_open   BYTE FAR *path, COUNT flag   {   REG struct f_node *fnp;  COUNT i;  BYTE FAR *fnamep;  BYTE dname[NAMEMAX];  BYTE fname[FNAME_SIZE],  fext[FEXT_SIZE];   * First test the flag to see if the user has passed a   * valid file mode...  if flag   2   return DE_INVLDACC;   *   *     * first split the passed dir into comopnents   i.e. - path  *    * to new directory and name of new directory.  *   if  fnp = spiit_path path, dname, fname, fext   == NULL   {   dir_close fnp ;  return DE_PATHNOTFND;   }    DOS-C Kernel: File System Manager — 131   Opening a File  If you have followed  the directory  functions  so far,  most  of what you  will see in the file handlers will look very familiar. The DOS-C design  reuses  code  and  algorithms  wherever  possible,  facilitated  through  the  use  of  the  fjnode  data  structure  common  to  all the file system  func  tions.  I  will  examine  dos_open    to  study  how  a  file  access  works   Listing  4.22 .  The  reader  can  look  at  other  functions  such  as  dos_create     because of the similarity in design.   Listing  4.22  Source code for  dos_open     function  —   continued.   If  we  can't  find  i t,   just  return  a   the  f i l e.    *  Look  for   *  not   found  error.  if !find_fname fnp,  i   dir_close fnp ;  return  DE  FILENOTFND;   fname,   f e x t      }   *  Set   the  f_node  to  the  desired  mode  fnp  ->  f_mode  =  f l a g;   I n i t i a l i ze     *  fnp  ->  f . o f f s et  =  01  ;  fnp  ->  fjiighwater  =  fnp  ->   the  rest  of  the  f_node.   f _ d i r . d i r _ s i z e;   fnp  ->  f_back  =  LONG_LAST_CLUSTER;  fnp  ->  f_cluster  =  fnp  ->   f _ d i r . d i r _ s t a r t;   fnp  ->  f_flags.f_dmod  =  FALSE;  fnp  ->  f_flags.f_dnew  =  FALSE;  fnp  ->  f_flags.f_ddir  =  FALSE;   return  x l t _ f n p   f n p   ;   }   *   *    *    *     132 — The FreeDOS Kernel   The algorithm for dos_open     is similar to that of di r_open    . The  only changes are that a file also has a mode associated with it and that it  must  return  a  number  that  will  be  later  used  to  derive  the  handle  returned to the user.   dos_open      begins  by  first  testing  the  flag  to  see  if  the  user  has  passed a valid file mode. This type of testing is necessary for all of the  DOS support functions. An application can easily pass erroneous  infor  mation and DOS-C must handle this in a sane way. Crashing because of  bad parameters passed to a call is definitely not an option.   Once parameter testing is complete, the path passed in the call needs  to be validated.  dos_open     splits the path into components   i.e., path  to directory, filename, and file extension  and tests for a valid path. This  information  is  needed  to  locate  the  file.  If  the  file  can't  be  found,  dos_open    returns  a  file-not-found  error.  If  the  file  is  found,  dos_open     proceeds to set the fjnode  to the desired mode and initial  izes the rest of the fjnode.  It finally returns through xl t_f np   , which  translates an f_node  pointer to a numeric index for later use.   With  fjnode  initialized,  any  file  operation  can  take  place,  and  f_node  retains the state of the file. It is this data structure that contains  the directory image, current size, pointer to the next byte to be read, etc.   Reading Writing  a File  Reading  and  writing  a file is  a large part  of the  DOS-C  file  system  code. This  code  is used  for  loading  programs  as well  as file access  to  user  applications.  DOS-C  provides  two  functions,  dos_read    and  dos_write    for  DOS  support  functions,  but  a  single  function,  rdwrbl ock   , does all the work  Listing 4.23 . Both  dos_read     and  dos_write    call  rdwrblockO  with  XFR_READ  to  read  a  file  and  XFR_WRITEtowriteafile.   rdwrbl ock    is common to both functions because of the similarity  between file read and write operations. In both cases, data is transferred  with only data direction differences.  The block cache mechanism  sim  plifies  matters  by  providing  automatic  mechanisms  for  writing  dirty  buffers.  Hence,  data  is transferred  either  from  memory  to  a buffer  or  vice versa. I will note other small differences  along the way.    DOS-C Kernel: File System Manager — 133   As you have seen before,  rdwrbl ock    starts off by translating the  internal handle into an  f_node  pointer because  all internal file system  operations  use  fjnodes  to  maintain  the  state  of  the  file.  Part  of  the  translation  requires  testing  the  validity  of  the  file.  For  example,  the  application may erroneously close the file and attempt to read from it or   Listing  4.23  Source  code for  rdwrb  1 ock     function.  UCOUNT  rdwrblock   COUNT fd, VOID FAR *buffer, UCOUNT count, COUNT mode,   COUNT   *err    {   REG struct f_node  *fnp;  REG struct buffer FAR *bp;  UCOUNT xfr_cnt = 0, ret_cnt = 0;  LONG idx;  WORD secsize;  UCOUNT to_xfer = count;   ifdef DEBUG   if bDumpRdWrParms   {   mode == XFR_WRITE ? "WRITE" : "READ" ;   printf "rdwrblock: mode = %s\n",  printfC fd  buffer  printf " %02d  %04x:%04x   count\n --   C0UNT FP_0FF buffer , count ;   \n" ;  %d\n", fd,  COUNT FP_SEG buffer ,   }  endif   * Translate the fd into an f_node  pointer, since all   * internal  operations are achieved  through  f_nodes.  fnp = xlt_fd fd ;   * If the fd was invalid because it was out of range or the *    * requested  file was not open, tell the caller and exit  *    * note: an invalid fd is indicated by a 0 return  *   if fnp ==  struct f_node * 0  fnp -> f_count <= 0   {   *   *    *err  = DE_I NVLDHNDL;  return 0;    134 — The FreeDOS Kernel   write to it. If the internal handle is invalid because it is out of range or  the requested file is  not  open,  rdwrbl ock     notifies  the  calling  DOS  support  function  of  the  error  and  exits. Next,  rdwrbl ock    tests  that  the requested number of bytes for data transfer  is not zero. If the count  is zero  and the mode  is  XFR_READ, rdwrbl ock    just  exits because  a  read with a count of zero is a valid call but does not require any  further  processing. Additionally,  a write with a count of zero is a special case  that sets the file length to the current length. Another test is to check for  a  seek past end-of-file  on an  XFR_READ operation. This is also a valid  read operation that must return 0 bytes transferred. Again, it is easy to  test this up front  and avoid further  processing.   Listing 4.23  Source code for  rdwrb 1 ock    function  —   continued.    *  Test that we are really about to do a data transfer. If   * the count is zero and the mode is XFR_READ, just exit.   *  Any read with a count of zero is a nop .   *   * A write   mode is XFR_WRITE  is a special  case, it sets   * the file length to the current length   truncates it .   *   * NOTE: doing this up front saves a lot of headaches later  if count == 0   r l   *   *   *   *   *   *   *   *    if mode == XFR_WRITE    fnp -> fjiighwater = fnp -> f_offset;  *err  = SUCCESS;  return 0;   }   i     * Another test is to check for a seek past EOF on an   * XFR READ operation.  if mode == XFR_READ  && ifnp -> f_flags.f_ddir  &&  fnp -> f_offset >= fnp -> f_dir.dir_size     *   *    i   }   *err  = SUCCESS;  return 0;    DOS-C Kernel: File System Manager — 135   With  the  special  cases  out  of  the  way,  you  begin  testing  that  the  operation is valid. First,  rdwrbl ock    tests that the user call passed a  valid  mode  for  this  f_node.  This  consists  of  testing  combinations  of  read-only  and read-write in the case of read operations  and write-only  and read-write  for  write  operations. If these two combinations  do not  exist, then an invalid access error is returned.   Next, rdwrbl oc k     adjusts the fa r pointer from user space to supervi  sor space with a call to the memory management ad j us t_f a r     function.   Listing 4.23  Source code for  rdwrb  1 ock    function  —   continued.    *  test   that  we  have  a  valid  mode  for  this  switch mode   {  case  XFR_READ:   f_node   *    !=  RDONLY  &&  fnp  ->  f_mode   !=  RDWR    i f   f np  ->  f_mode  {   *err  =  DE_INVLDACC;  return 0;   }  break;   ifndef  I PL   case XFR_WRITE:   }  break;   endif   default:   *err  =  DE_INVLDACC;  return 0;   if fnp -> f_mode  != WRONLY && fnp -> f_mode  != RDWR   {   *err  =  DE_INVLDACC;  return 0;   }   * The variable secsize will be used later.  secsize = fnp -> f_dpb -> dpb_secsize;   * Adjust the far pointer from user space tp supervisor space*   buffer = adjust_far  VOID FAR * buffer ;   *     136 — The Free DOS Kernel   Although DOS-C is real mode only, the call is still necessary because of the  segment  architecture. Adjust  the  segment  and  offset  so that  you  have a  usable range for the transfer. Once the pointer has been adjusted,  proceed  to transfer  the data.  rdwrblock    uses  a block transfer  method  so that  later versions of DOS-C can use memory management.   Listing  4.23  Source code for  rdwrb  1 ock    function  —   continued.   ,  we  can  u t i l i ze  memory  management  in  more  complex  C  versions.    *  Do  the  data  transfer.  Use  block  transfer  methods  so   *  tha t   *  DOS- while ret_cnt  <  count   i   to  the  f_node's  pointer  position.   Position  the  f i le  This  is  done  by  updating  the  f_node's  cluster,  block   sector   and  byte  offset  so  that  read  or  write  becomes  a  simple  data  move  into  or  out  of  the  block  data  buffer.    *   *   *   *   *  i f   f np  ->   f . o f f s et  ==  01   r  i  I PL   ifndef    *  For  the  write  case,  a  newly  created   *  w i ll   have  a  s t a rt  cluster  of  FREE.  If  we're   *  doing  a  write  and  this   *  through,   allocate  a  new  cluster  if  mode  ==  XFR_WRITE   &&   fnp  ->  f _ d i r . d i r _ s t a rt  ==  FREE     time  to  the   is  the  f i r st   f i le   f i l e.   i f   ! f i r s t _ f a t   f n p     {   dir_close fnp ;  *err  =  DE_HNDLDSKFULL;  return   ret_cnt;   endif   1   to  the  starting  cluster  and   i n i t i a l i z i ng    *  complete   the  common  operations  of   *   *  setting   all  offsets  fnp  ->  f_cluster  =  fnp  ->  fnp  ->  f_back  =  LONG_LAST_CLUSTER;  fnp  ->  f_sector  =  0;  fnp  ->  f_boff  =  0;   to  zero.   f _ d i r . d i r _ s t a r t;   }   *   *   *    *   *   *   *   *    *   *   *   *    *   *   *     DOS-C Kernel: File System Manager — 137   rdwrblockO  uses  a  while  loop  that  exits  when  the  bytes  trans  ferred  equal  the  requested  amount.  This  guarantees  that  the  correct  number  of bytes is transferred.  Next, the loop positions  the file to the  pointer  position  of  the  fjnode.  This  is  done  by  updating  the  cluster,  block   sector ,  and  byte  offset  of  the  fjnode  so  that  read  or  write  becomes a simple data move into or out of the block data buffer.  There   Listing  4.23  Source code for  rdwrb  1 ock    function  —   continued.    *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *  e"L   f_node's   into  a  it   sector    information,  we  need  to  translate   The  more  d i f f i c u lt  scenario  is  the   more  common   f i le  offset  case.  Here,  we  need  to  take  the  offset  pointer   f_offset   and  translate  relative  cluster  position,  cluster  block  offset   f_sector   and  byte  offset    f _ b o f f  .  Once  we  have  this  relative  cluster   position  into  an  absolute  cluster  position   f_cluster  .  This  is  unfortunate  because  it  requires  a  linear  search  through  the  f i l e 's  FAT  entries.  designed  as  a  simple  floppy  disk  operating  system  where  the  FAT  was  contained  in  core,  but  now  requires  a  search  through  the  FAT  blocks.   It   made  sense  when  DOS was  o r i g i n a l ly   the   The  algorithm  in  this  the  blockio  block  buffering  scheme  to  simplify  task.  Be   function  takes  advantage  of  the   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *    switch map_cluster fnp,  mode    {  case  DE_SEEK:   dir_close fnp ;  return  ret_cnt;   default:   dir_close fnp ;  *err  =  DE_HNDLDSKFULL;  return   ret_cnt;   case  SUCCESS:   break;   }    138 — The FreeDOS Kernel   is a special case that must be examined. For write operations, a newly  created file will have  a start cluster  of  FREE. Check  for  this  condition  because if this is the case, you must  allocate  a new cluster to the file.  Then  rdwrbl ock    completes the common operations of initializing to  the starting cluster and setting all offsets  to zero.   Listing   4.23  Source code for  rdwrb  1 ock    function  —   continued.   ifndef   IPL   *   XFR_WRITE  case  only  -  if  we're  at  the  end,  the  next   *  FAT  is  an  EOF  marker,  so  j u st  extend  the  f i le  if mode  ==  XFR_WRITE  &&  l a s t j i n k   f n p      *   length  *    if lextend fnp    1  i   dir_close fnp ;  *err  =  DE_HNDLDSKFULL;  return   ret_cnt;   endif   1    *  Compute  the  block  within  the  cluster  and  the  offset   *  withi n  the  block.  fnp  ->  f_sector  =   fnp  ->  f_offset  fnp  ->  f_boff  =  fnp  ->  f_offset  % secsize;      secsize   &  fnp  ->  f_dpb  ->  dpb_clsmask;   *   *    ifdef  DSK_DEBUG   printf "%d  l i n k s;  d ir  offset  %ld,  starting  at  cluster  %d\n",   fnp  ->  fnp  ->  fnp  ->   f_count,  f _ d i r o f f,  f_cluster ;   endif    *  Do  an  EOF  test  and  return  whatever  was  transferred   *  but   only  for  regular  if  mode  ==  XFR_READ   &&  ! fnp  ->   in  XFR_READ  mode   f_flags.f_ddir    f i l es   &&   fnp  ->  f_offset  >=  fnp  ->   f _ d i r . d i r _ s i z e      *   *    i   }   *err  =  SUCCESS;  ret_cnt;  return    DOS-C Kernel: File System Manager — 139   Listing 4.23  Source code for  rdwrb  1 ock      function  —   continued.    *  Get  the  block  we  need  from  cache*   bp  =  getblock  L0NG clus2phys fnp  ->   f_cluster,   fnp  ->  f_dpb  ->  dpb_clssize,  fnp  ->  f_dpb  ->  dpb_data   +  fnp  ->  fnp  ->  f_dpb  ->  dpb_unit ;   f_sector,   if bp ==  struct buffer * 0   {   *err  = DE_BLKINVLD;  return ret_cnt;   }   * transfer a block  *    * Transfer size as either a full  block size, or the  *   *    * requested transfer size, whichever is smaller.   * Then compare to what is left, since we can transfer  *    * a maximum of what is left.  *   switch mode   {  case XFR_READ:   if fnp -> f_flags.f_ddir   else   xfr_cnt = min to_xfer, secsize - fnp -> f_boff ;  xfr_cnt = min min to_xfer, secsize - fnp -> f_boff ,   fnp -> f_dir.dir_size  - fnp ->  f_offset ;  fbcopy  BYTE FAR * &bp -> b_buffer[fnp -> f_boff],  break;   buffer, xfr_cnt ;   ifndef I PL   case XFR_WRITE:   xfr_cnt = min to_xfer, secsize - fnp -> f_boff ;  fbcopy buffer, BYTE FAR * &bp -> b_buffer[fnp -> f_boff],  bp -> b_update = TRUE;  break;   xfr_cnt ;   endif   default:   *err  =  DE_INVLDACC;  return ret_cnt;   }    140 — The FreeDOS Kernel   The more common scenario is the common file offset case. Here, you  need to take the offset pointer of the fjnode   f_of f set   and translate it  into a relative cluster position, cluster block  sector , offset   f_sector ,  and byte offset   f_bof  f .  Once you have this information,  you need to  translate  the  relative  cluster  position  into  an  absolute  cluster  position   f_cl  uster .  This  is  unfortunate  because  it  requires  a  linear  search   Listing 4.23  Source code for  rdwrb  1 ock     function  —   continued.    *  update  pointers  and  counters  ret_cnt  +=  xfr_cnt;  to_xfer  -=  xfr_cnt;  fnp  ->  f_offset  +=  xfr_cnt;  buffer  =  add_far  VOI D  FAR  * buffer,  if mode  ==  XFR_WRITE  &&    fnp  ->  f_offset  >  fnp  ->  fnp  ->  fjiighwater  =  fnp  ->   fjiighwater    f_offset;    ULONG xfr_cnt ;   *    }  *err  = SUCCESS;  return ret_cnt;   }  COUNT  dos_read   COUNT fd, VOID FAR ^buffer, UCOUNT count   {   COUNT  err, xfr;  xfr = rdwrblock fd, buffer, count, XFR_READ,  &,err ;  return  err  != SUCCESS ? err  : xfr;   }   ifndef  I PL  COUNT  dos_write   COUNT fd, VOID FAR ^buffer, UCOUNT count   {   COUNT  err, xfr;  xfr = rdwrblock fd, buffer, count, XFR_WRITE,  return  err  != SUCCESS ? err  : xfr;   ^err ;   }  endif    DOS-C Kernel: File System Manager — 141   through the file's FAT entries. This scenario made sense when DOS was  originally designed as a simple floppy disk operating  system where the  FAT  was  contained  in  core,  but  a  search  through  the  FAT  blocks  is  required.  The  algorithm  used by  rdwrblockO  takes  advantage  of  the  bl ocki o block buffering  scheme to simplify  the task. Because the FAT  is contained  within  a block, the block  may remain  within  the cache if  there are enough buffers.  This minimizes  seek and rotational latencies.  After  rdwrblockO  determines  the  physical  addresses,  it  performs  another test for a special case. In the write case only, rdwrbl ock    must  check for end-of-file  before the data transfer can take place. You need to  extend the file by allocating another cluster before you can transfer  data  to it. For this reason, the test must occur before the transfer. If the file is  at  the  end,  the  next  FAT  is  an  EOF  marker  and  rdwrbl ock    just  extends the file's cluster chain.   For read operations,  rdwrbl ock    does an EOF test for every loop  iteration. You need to test for  end-of-file  because it is a valid termina  tion  condition.  If  you  encounter  this  situation,  you  return  a  count  of  whatever was transferred  for regular files in read mode.   If it was not an end-of-file,  rdwrbl ock    proceeds to get the block  you  need  from  cache  and transfer  data to  or from  the block.  Transfer  size is either a full block size, or the requested transfer  size, whichever  is smaller. When this transfer  is complete,  rdwrbl ock    compares  its  count to what is left,  since you must transfer what is left,  rdwrbl ock     updates pointers and counters and repeats the loop. It returns the num  ber of bytes transferred  when the loop terminates.   Closing a File  Much  of  the  dos_close    algorithm   Listing  4.24   will  seem  very  familiar  if you have studied the  di r_cl ose    function   Listing 4.20 .  Like  the  other  file  system  functions,  dos_cl ose    first translates  the  internal  handle  into  a  useful  pointer.  If  the  corresponding  fjnode  is  invalid because the internal handle is out of range or the requested file  is not open,  dos_cl ose    simply returns  an error. It then looks  at the  file mode.  If  the  file  is  not  read-only,  a write  may  have  taken  place.    142 — The FreeDOS Kernel   dos_cl ose    updates the directory  size and sets a flag that will cause  the directory record to be written. It then calls di r_cl ose    to update  the directory, if necessary, and exits.   More Functions  By  now, you  have  looked  at file system  operations  that  perform  data  transfer  in one form  or another. The file system functions  also contain  other utilitarian functions that return file sizes, file creation or modifica  tion  dates, times, etc. The functions  are all built  from  building  blocks  similar  to  the  data  transfer  functions  and  can  be  easily  understood  if  you  have  understood  the  explanations  of  the  data  transfer  functions.  MS-DOS is feature-rich with utility functions; it will be useful to study  the code in these files.   Listing 4.24  Source code for  dos_cl  ose      function.  COUNT  dos_close   COUNT fd   {   struct f_node *fnp;   * Translate the fd into a useful  pointer  fnp = xlt_fd fd ;   * If the fd was invalid because it was out of range or the *    * requested  file was not open, tell the caller and exit  *    * note: an invalid fd is indicated by a 0 return  *   if fnp ==  struct f_node * 0  fnp -> f_count <= 0   if fnp -> f_mode != RDONLY   {   return  DE_INVLDHNDL;   *    fnp -> f_dir.dir_size = fnp -> fjiighwater;  fnp -> f_flags.f_dmod = TRUE;   }  fnp -> f_flags.f_ddir = TRUE;  di r_close fnp ;  return SUCCESS;   }    Chapter 5   DOS-C Kernel- Memory Manager  and Task Manager   In  this  chapter,  I  will  examine  two  resource  managers:  the  memory  manager and the task manager. Both of these managers serve an impor  tant role in the operations  of DOS-C   Figure  5.1 . Each  manager pro  vides  system  call  services  that  are part  of  the MS-DOS  collection  of  system  services. They  also provide  key  internal  services  necessary  to  the other DOS-C services. One note: although the code is written to be  portable, portions of these managers, especially the task manager, con  tain 80x86-specific code.   143    144 — The FreeDOS Kernel   In DOS-C, the memory manager provides and maintains the memory  allocation of DOS-C. Unlike other operating systems, the memory man  ager does not provide protection  to the memory  it manages. It cannot,  because DOS-C is designed to work in real mode so that it runs on XT  systems, which  are powered  with the  8088 processor. Memory  protec  tion mechanisms  are not  available in the low-end  8088 and in the real   Figure 5.1  Memory and task resource managers functionality layer.   DOS-Compatible System Calls   DOS API Entry Points   fcbfns  fs  chario   dosfns   memmgr   blockio   Task and Process Support Code   task   execrh   Device Drivers   Machine Level Support Code    DOS-C Kernel: Memory Manager and Task Manager — 145   mode of 80286 and newer processors. However, the algorithms used can  easily  be adapted   and have been  in related  operating  systems   to pro  vide the underlying allocation mechanism for protected-mode versions.  The task manager is also simplified  when compared to task manag  ers of other operating  systems. MS-DOS  is a simple operating  system  that  can  only  perform  a single task  at  a time. Because  DOS-C  is pat  terned after  it, DOS-C also provides support for  a single task at a time.  Its primary  responsibility  is to act as a task loader  and perform  a task  switch from  kernel mode to user mode and vice versa. Again, the code  presented  here  is  derived  from  more  sophisticated  multitasking  code,  and the elements necessary for multitasking  are contained in this code.  However,  what  is sorely  missing  is  a scheduler,  but  one can  be easily  introduced if you are inclined to do so.   Arena  Management  In MS-DOS, the memory area is known as the arena. The arena is a col  lection  of  one  or  more  areas  of  memory  that  contain  a data  structure  followed  by available memory. DOS-C uses the same data structures as  MS-DOS  to  maintain  the  memory  arena.  This  is  necessary,  because  many  programs  examine  the memory  header  when  they  want  to walk  the memory chain to find other programs that may reside in memory. In  fact,  much  of  the  "undocumented"  literature  is  devoted  to  explaining  the memory header and presents special programs to dump the header.  Because  the  goal  of  DOS-C  is  to  be  compatible  with  MS-DOS,  the  memory header is identical.   Like MS-DOS, DOS-C arranges the memory arena as a collection of  variable-length blocks. Each block has a Memory Control Block  MCB   defined  by the mcb data structure  Listing 5.1 . This header starts with a  single byte that is ASCII "M" except in the last block which starts with  an  ASCII  "Z". All  memory  blocks  must  have  an  owner,  and  DOS-C  identifies  the owner by  assigning  the segment  of  the program  segment  prefix of the owner. This entry is the m_ps p member. Note that the use of  the segment is a direct 80x86 architecture derivative.    146 — The FreeDOS Kernel   Another  80x86-dependent  entry  is  the  size  member,  m_size.  This  member contains the size of the memory block in 16-byte paragraphs that  match the 80x86 paragraph size. The user gets the memory block starting  at the next byte after  the MCB header,  which falls, coincidentally,  on a  paragraph  boundary. This field is also instrumental  in tracing  the MCB  chain. If you want to determine where the next MCB header will be, take  the address of the block and add m_s i ze to it. The next MCB block starts  at this  address. Of course you  must perform  all computations  in  80x86  segment:offset  fashion. Unfortunately, this is not very portable, but porta  bility must be sacrificed for compatibility purposes. However, the code is  written in a portable manner and the use of any other granularity such as  memory pages can be substituted. For example, an 80386 or 68040 ver  sion can use 4Kb pages that correspond to MMU pages.   The  last  MCB  member  is  m_name.  In  a  departure  from  standard  MS-DOS, DOS-C places the filename of the owner  in this field. This  allows easy owner identification  of the block when programs that walk  the  MCB  chain  dump  the header  contents. DOS-C, unlike  MS-DOS,  also clears this field when the MCB becomes available.   Another  member  is  m_f i l l.  This  odd  little  unused  portion  of  the  MCB  header  is  a fix that  brings  the  size  of  the  header  to  fit  exactly  within  one paragraph. Again, because  of  MS-DOS'  strong  root  in  the  80x86 world, assembly language arithmetic is smaller and faster  if you  can ignore the offset  and work with the segment only. Microsoft  chose  to  do this  and  sacrificed  3 bytes  to  simplify  the  math.  This  is  a good  software  engineering tradeoff  that results in cleaner code.   Listing  5.1  The mcb data  structure.   typedef  struct  i   i   BYTE  m_type;  UW0RD  m_psp;  UW0RD  m_size;  BYTE  m_fil1[3];  BYTE  m_name[8];   }  mcb;    *  mcb  ype  -  chain  or  end    *  owner  id  via  psp  segment   *  size  of  segment  in  paragraphs    *  owner  name  limited  to  8  bytes   *   *   *   *     DOS-C Kernel: Memory Manager and Task Manager — 147   Allocation  Strategy  Management  DOS-C  provides  five  functions  to  manage  memory.  These  functions  provide allocation, deallocation, size modification,  and validation  func  tions. However, not all functions  are available to the user. MS-DOS and  DOS-C provide system calls to allocate, change size, and return mem  ory to DOS-C. The other functions  provide DOS-C  with  the ability  to  find a block  of  memory  large enough  to load  a program  and to  verify  that the arena is intact. Unfortunately,  DOS-C  needs this  functionality  because  any program could destroy the arena or DOS-C itself  because  it lacks memory protection schemes.  Memory Allocation  For memory  allocation, DOS-C provides the function  DosMemAl 1 oc      Listing 5.2 , which can allocate memory using three different  criteria:  first fit, best fit, and last fit. It can also return the largest memory block  available  for  program  loading   Figure  5.2 .  The  algorithm  used  is  straightforward  —  search  each  memory  block  until  it  encounters  the  last one or meets  an exit criteria. If  a block matches the criteria of the  search,  DosMemAl 1 oc     sets  a local  variable  TRUE and  terminates  the  loop, unless it determines that it encountered an end block after the test,  in which case it returns an error.   Listing  5.2  The DosMemA 11 oc      function.     i n t  s i z e,  COUNT  mode,  seg  FAR  * p a r a,   UWORD  FAR  *asize    COUNT  DosMemAlloc  1   REG mcb  FAR  *p;  mcb  FAR  * q;  COUNT  i;  BOOL  found;   I n i t i a l i ze     *  p  =   mcb  FAR  *  MK_FP first_mcb,  0    ;   *7    148 — The FreeDOS Kernel   For each iteration,  DosMemAl 1 oc    checks for  a corrupted  memory  block.  The  test  it  performs  simply  looks  at  the  m__type  member  to  determine whether the block is valid. If it is, neither an ASCII "M" nor   Figure 52  Memory  allocation  criteria.   [llH   tised   iised   allocated  memory   used   -mséé''   used   allocated  memory   command   command   command   kernel   lilliSiil   kernel   Find First   Find Best   Find Largest    DOS-C Kernel: Memory Manager and Task Manager — 149   Listing   5.2  The  DosMemA 11 oc     function  —  continued.   Search  through  memory  blocks   q  =   mcb  FAR  *   0f   i  =  0,  found  =  FALSE;   ! f oi   nd;       *  for  i    *  check   for  corruption  i f  p  ->  m_type   return  DE_MCBDESTRY;   !=  MCB_N0RMAL  &&  p  ->  m_type   !=  MCB_LAST   *    *    *    *    *    *    *    *    *    free  based  on  mode  rules    *  Test   if  switch mode   r  1  case  LAST_FIT:  default:    *  Check  for  a  last  i f  p  ->  m_size  >=  size  &&  p  ->  m_psp  =   f it  candidate   FREE.   .PSP     *  keep  the  last  know  q  =  p;   f it    *  not   free  -  bump  the  pointer  i f  p  ->   m type   !=  MCB  LAST    p  =  MK  FP far2para  V0ID  FAR  * p   +   P  ">   1,  0 ;    *  was  there  no  room   q  =  0 ?  else  i f  p  ->  m_type  =  MCB_LAST  &&  q  =    mcb   return  DE_N0MEM;    *  something   was  found  -  continue  else   m_size  +   *   FAR  * 0    found  =  TRUE;   break;   case  FIRST_FIT:   q  =  p;  found  =  TRUE;  break;    *  Check  for  a  f i r st  i f  p  - >  m size  >=  size  &&  p  ->  m psp  =  {   f it  candidate   FREE.   _PSP    p  =  MK  FP far2para  V0ID  FAR  * p   +   P  ">   m_size   +    *  not  free  -  bump  the  pointer  i f  p  - >  m type   !=  MCB_LAST    1,  0 ;    *  nothing   found  t i ll  end  -  no  room  else   return  DE_N0MEM;   break;    750 — The FreeDOS Kernel   an ASCII "Z", DosMemAl 1 oc     terminates and returns an error. If it is a  valid memory block,  DosMemAl 1 oc    tests to see if it is free,  and if so,  proceeds to test it based on mode rules. The algorithm then diverges at  this point when it tests the block. A switch  statement splits the execu  tion path based on the requested mode.   DosMemAl 1 oc    tests  for  last fit by  searching  through  each  mem  ory  control  block.  If  the  size  of  the block  is  greater  than  or equal  to  the requested  size,  DosMemAl 1 oc    notes the address  of the block. If  DosMemAl 1 oc     examined the block marked with the end of the mem  ory arena, it terminates  and returns  an error; otherwise, it proceeds to  common completion code.   Listing  5.2  The  DosMemAl1  oc     function  —   -  continued.   case  BEST_FIT:   1*  Check  for  a  best  f it  candidate  i f  p  ->   m_size.>=  size  &&  p  ->  m_psp  =  1   i f  i  =  0     p  ->  m size  <  i   {   FREE_PSP    i  =  p  ->  m_size;  q  =  p;   }   }   *  not   free  -  bump  the  pointer  i f  p  ->   m_type  !=  MCB_LAST    p  =  MK_FP far2para  V0ID  FAR  *    p   +   p  ->  m_size  +   1.  0 ;    *  was  there  no  room   q  =  0 ?  else  i f  p   ->  m_type  =  MCB_LAST  &&   q  =   *    mcb  FAR  * 0       return  DE_N0MEM;    *  something   was  found  -  continue  else   found  =  TRUE;   break;   *    *    *     DOS-C Kernel: Memory Manager and Task Manager — 757   Listing 5.2  The DosMemA 11 oc    function  — continued.   case  LARGEST:     *  Check  for  a  f i r st  if  Up   ->  m_psp  =  FREE_PSP   &&   i  =  0     p  ->  m_size  >  i     {   f it  candidate   *    size  =  *asiz e  == 1  =  p  ->  m_size;  q  =  p;   1, 0 ;   }   * not free - bump the pointer  if p -> m_type != MCB_LAST    *   p = MK_FP far2para  V0ID FAR * p  + p -> m_size +   * was there no room  q =  0 ?  *   else if p -> m_type =  MCB_LAST && q =   mcb FAR * 0    * something was found - continue  *   else  break;   return DE_N0MEM;   found = TRUE;   }   }  p  =  q;   *  Larger   f it  case  i f  p  ->  m_size  >  size   {   if mode  {   !=  LAST_FIT    *    *    q  =  MK_FP far2para  V0ID  FAR  * p   +  size  +  1,  0 ;   *  Always   flow  m_type  up  on  alloc  q  ->  m_type  =  p  ->  m_type;  p -> m_type = MCB_N0RMAL;  p -> m_psp = cu_psp;  q -> m_psp = FREE_PSP;  q  ->  m_size  =  p  ->  m_size  -  size  -  1;  p  ->  m_size  =  size;  f o rd  =  0 ;  i  <  8;   p -> m_name[i] = q -> m_name[i] = '\0';   i++     152 — The FreeDOS Kernel   DosMemAl 1 oc     tests for first fit in a way similar to the last fit case.  It also  searches through  each  memory  control  block. If the size of the  block  is greater than or equal  to the requested  size, the address  of the  block is noted. However, unlike last fit, it exits the loop and proceeds to  common  completion  code.  If  DosMemAl loc      reaches  the  end  of  the  memory arena, it also terminates and returns an error.   Listing 5.2  The Dos Mem A 11 oc     function  — continued.   else  {   q  =  MK_FP far2para  V0ID  FAR  * p   +    p  ->  m_size  -  size ,  0 ;    *  Always   flow  m_type  up  on  alloc  q  ->  m_type  =  p  ->  m_type;  p  ->  m_type  =  MCB_N0RMAL;  q  ->  m_psp  =  cu_psp;  p  ->  m_psp  =  FREE_PSP;  p  ->  m_size  =  p  ->  m_size  -  size  -  1;  q  ->  m_size  =  size;  f o r  i  =  0 ;   i  <  8;   i++    p  ->  m_name[i]  =  q  ->  m_name[i]  =  ' \ 0 ';   }   *  Found  -  return  good  *para  =  far2para  VOID  FAR  *  mode  =  LAST_FIT  ?  :   VOID  FAR  *   p    ;    VOID  FAR  * q   return  SUCCESS;   }   *  Exact   f it  case  else  i f  p  ->  m_size  =  size   {   i  <  8;   p -> m_name[i] = '\0';   p  ->  m_psp  =  cu_psp;  f o r  i  =  0 ;  i++    * Found - return good  *para = far2para  VOID  FAR *  BYTE FAR * p ;  return SUCCESS;   }  else   return  DEJCBDESTRY;    DOS-C Kernel: Memory Manager and Task Manager — 153   The best fit test uses a local variable to maintain the size of the block  closest  to  the  requested  size.  In  a manner  similar  to  the  last fit case,  DosMemAl 1 oc     compares the requested size to the block size. If the size  of the block is greater than or equal to the requested size, DosMemAllocO  then proceeds to test the block  size. If it is smaller than  the last block  that  was  greater  than  the  requested  size,  DosMemAl 1 oc     notes  the  address of the block. In this way, it determines  the smallest block that  will satisfy  the request. If  DosMemAl 1 oc     reaches the end of the mem  ory  arena,  it terminates  -md returns  an error;  otherwise,  it proceeds  to  common completion code.   The test for the largest memory block is the simplest case. DosMemAl 1 oc       simply  determines  which  memory  block  is  the  largest  and  notes  the  address  of  this  block.  In  this  way,  DosMemAl!oc    determines  the  smallest block that will satisfy  the request. If it does not find a block, it  terminates and returns an error; otherwise, it proceeds to common com  pletion code.   DosMemAl 1 oc    completes the search by modifying  the block that it  found. If the block is larger than requested,  DosMemAl 1 oc     proceeds to  carve out the size of block requested from  the block found. If,  however,  the block  found  is identical  in  size to that  requested,  DosMemAl 1 oc     simply reassigns the block. With all arena maintenance out of the way,  DosMemAl 1 oc    exits by returning the segment of paragraph  following  the MCB. This segment forms  the address of the first byte of  allocated  memory that the user may utilize.  Memory Deallocation  DOS-C  provides  a complement  to  DosMemAllocO  with  DosMemFreeO   Listing 5.3 . DosMemFree     takes the segment acquired from DosMemAl 1 oc      and returns it to the free pool. In comparison, DosMemFree     is much sim  pler because there is only one way to return  a memory block,  whereas  there are four  ways to allocate one. Its job is a simple one: check that  the block is valid and combine it with adjacent blocks if possible.    154 — The FreeDOS Kernel   Listing 5.3  The DosMemFree     function.  COUNT  DosMemFree   int para   {   REG mcb FAR *p, FAR *q;  COUNT i;   * Initialize  D -  mcb FAR *  MK  FP para, 0  ;   * check for corruption  if p -> m_type i= MCB_N0RMAL && p -> m_type != MCB_LAST   return DE_INVLDMCB;    * Mark the mcb as free so that we can later   * merge with other surrounding  free mcb's  p -> m_psp = FREE_PSP;  ford' = 0; i < 8;  i++    p -> m_name[i] = '\0';    *  Now  merge  free  blocks  for p  =   mcb  FAR  *  MK_FP first_mcb,  0    ;  p  ->  m_type   *    !=  MCB_LAST;  p  =  q    {   *    * make q a pointer to the next block  q = MK_FP far2para  V0ID FAR * p  + p -> m_size + 1,  0 ;   * and test for corruption  *   if q -> m_type != MCB_N0RMAL && q -> m_type i= MCB_LAST   if p -> m_psp ! =  FREE_PSP    return DE_MCBDESTRY;  continue;    * test if next is free - if so merge  if q -> m_psp =  FREE_PSP   {    * Always flow type down on free  p -> m_type = q -> m_type;  p -> m_size += q -> m_size + 1;   * and make pointers the same since the next   * free is now this block  q = p;   return SUCCESS;   *    *    *   *    *    *    *   *     DOS-C Kernel: Memory Manager and Task Manager — 755   DosMemFreeO  first  checks  for  corruption  in  the  same  way  that  DosMemAl 1 oc    does.  DosMemFree    then marks the MCB  as free  so  that  you  can  later  merge  it  with  other  surrounding  free  MCBs.  Once  marked,  DosMemAl 1 oc    proceeds to merge adjacent  free blocks.   In order to free  an MCB, DosMemFree    has to go through each one  to  determine  if  the  previous  block  and  the  following  block  are  avail  able. It tries to merge all blocks that become available in a belt and sus  penders  fashion.  The  algorithm  uses  a  pointer  to  the  next  block.  DosMemFreef    updates this pointer on each iteration based on the con  tent of the last block and tests for corruption. Again, because of lack of  memory  protection  hardware  in  low-end  80x86  processors,  any  task  can corrupt an MCB.   If the MCB passes the corruption  test,  DosMemFree    tests the next  MCB to see if it is free. If it is, it merges the two blocks by first setting  the  m_psp  structure  member  to  FREE_PSP. It  then  takes  the  type  from  what had been the adjacent  free block and copies it into the current  free  block. The algorithm counts on the fact that only the last block is marked  free; if you merge with the last block, then the current block becomes the  last block. It then adjusts the size of the current block and exits.   The next function,  DosMemLargest     Listing 5.4 , is never seen by  the user. Its purpose in DOS-C is to assist the task manager in locating  the  largest  available  free  block.  Task  manager  needs  this  information  because it follows the model of MS-DOS in its operation. Under certain  conditions  in the process  of loading  a program, the task manager  must  load the program in the largest available memory.  DosMemLargest     is  called to return this information.   Listing5.4   The DosMemLargest     function.   seg  DosMemLargest   seg  FAR  *size   i   REG  mcb  FAR  * p;  mcb  FAR  * q;  COUNT  found;   I n i t i a l i ze     *  p  =   mcb  FAR  *  MK_FP first_mcb,  0    ;   *7    156 — The FreeDOS Kernel   In a simple fashion,  DosMemLargest    searches through each mem  ory block to find the largest one. As you have seen before, first it checks  for and exits if it finds arena corruption. It then tests for the largest block  available by noting the segment of the current MCB. If  it is larger than  any you have encountered to this point, DosMemLa rgest     exits success  fully; otherwise, it returns an error indicating that you are out of memory.  A user-accessible memory manager function is DosMemChange     List  ing 5.5 , which changes the size of a given memory block, if possible. It  can be used to either  increase or decrease the size of the block. It can  also be called without changing the size of the memory block, but that  is a special case.   Listing   5.4  The DosMemLa rgest     function  —  continued.    *  for  i   Search  through  memory  blocks   q  =   mcb  FAR  *   0,  *size  =  0,  found  =  FALSE;  Ifound;      *     *  chec k  for  corruption  *   i f  p  ->  m_type  !=  MCB_N0RMAL  &&  p  ->  m_type  !=  MCB_LAST    return  DE_MCBDESTRY;    *  Test  for  i f    p  ->  m_psp  =  FREE_PSP   &&   p  ->  m_size  >  *size     largest  f i t   a v a i l a b le   *    *size  =  p  ->  m_size;  q  =  p;    *  not   free  -  bump  the  pointer  i f  p  ->   m_type  !=  MCB_LAST    *    p  =  MK_FP far2para  V0ID  FAR * p   +  p  ->  m_size  +  1,  0 ;  *     *  was  there  no  room   q  =  0 ?  else  i f  p  ->  m_type  =  MCB_LAST  &&  q  =    mcb  FAR  * 0    return  DE_N0MEM;     *  something  was  found  -  continue*   else   found  =  TRUE;   \  ì  i f   else   q  !=  0   return  SUCCESS;   return  DE_N0MEM;   !   }    DOS-C Kernel: Memory Manager and Task Manager — 757   Listing5.5   The DosMemChangeO  function.   COUNT  DosMemChange  i     i n t  p a r a,   i nt  s i z e    REG  REG   mcb  FAR  *p,  FAR  * q;  COUNT  i;    *  P  =   I n i t i a l i z e   mcb  FAR  *  MK__IT --paraf  0    ;     *  i f    7*  i f    {   return  DEJODESTRY;   check  for  wrong  allocation  size  >  p  ->  m_size    REG  COUNT  delta;   check  for  corruption  p  ->  m_type  1=  MCB_N0RMAL  &&  p  ->  m_type  i=  MCB_LAST     *  make  q  a  pointer  q  =  MK_FP far2para  V0ID  FAR  * p   +  p  ->  m_size  +  1,   to  the  next  block   0 ;   if   next  mcb  is  not  free,  error  no  memory    *  i f  q  - >  m_psp  !=  FREE_PSP    return  DE_N0MEM;    *  reduce   the  size  of  q  and  add  difference   *  but   check  that  q  is  big  enough  delta  =  siz e  -  p  ->  m_size;  i f  q  ->  m_size  <  delta    f i r st   to  p   return  DE_N0MEM;  q  ->  m_size  -=  delta;  p  ->  m_size  +=  delta;    *  Now  go  back  and  adjust  q,  we'll  make  p  new  q  p  =  MK_FP far2para  V0ID  FAR  * q   +  delta,  0 ;  p  ->  m_type  =  q  ->  m_type;  p  ->  m_psp  =  q  ->  m_psp;  p  ->  m_size  =  q  ->  m_size;  f o rd  =  0 ;  i  <  8;   i++    p  ->  m_jiame[i]  =  q  ->  m_name[i] ;    *  and  finished  return  SUCCESS;   }   *    *    *    *    *    *   *    *    *l    755 — The FreeDOS Kernel   Like the other memory manager functions,  DosMemChange    starts out  by verifying that the memory block passed to it is valid. If it is not valid, it  returns an error. If it is valid, it proceeds to check the three possible cases.  If  the  new  size  is  larger  than  the  current  size,  DosMemChange     checks  the  next  MCB  to  see  if  the  block  is  free.  The  next  memory  block  must be free  in  order  for  DosMemChange    to allocate  memory.  Unlike other operating systems, DOS-C does not have access to memory  management hardware to allocate physical memory to logical memory.  It must take it from the nexr memory block. If the next block is not free,  it returns an error.   Listing  5.5  The DosMemChange   function  —  continued.   else,  shrink  se  i f   s i ze     m  size    it  down    *  el  i    *  make  q  a  pointer  q  =  MK_FP far2para  V0ID  FAR  * p   +  size  +  1,  0 ;   to  the  new  next  block    *  reduce   the  size  of  p  and  add  difference  q  ->  m_type  =  p  ->  m_type;  q  ->  m_size  =  p  ->  m_size  -  size  -  1;  p  ->  m_size  =  size;   to  q    *  Make  certian  the  old  psp  is  not  last    if  P  ->  m_type  =  MCB_N0RMAL;   it  was     *  Mark  the  mcb  as  free  so  that  we  can  later   *  merge  with  other  surrounding  free  mcb's  q  ->  m_psp  =  FREE_PSP;  i++   f o rd  =   0;   i  <  8;   q  ->  m_name[i]  =  * \ 0 ';    *  now  free  it  so  that  we  have  a  complete  block  return  DosMemFree far2para  VOID  FAR  *   q    ;   }   !  }    *  el   otherwise,  se   i ts  a  no-op   return  SUCCESS;   *    *    *    *    *   *    *    *     DOS-C Kernel: Memory Manager and Task Manager — 159   If  the  next  block  is  free,  DosMemChange     verifies  that  it  is  large  enough  to accommodate  the memory  change. If  so,  DosMemChange     proceeds to reduce the size of the next block  and add the difference  to  the  current  block.  Once  DosMemChange    has  reduced  the  size  of  the  next block,  it must move the MCB  to the new  location. With the new  MCB in place, DosMemChange    successfully  returns.   If  DosMemChange     is  to  reduce  the  size  of  the  memory  block,  it  reduces the size of the current block and adds the difference  to the next  block  It creates  a n^v;  MCB  for  the  left-over  memory  and  then  exits  through  DosMemFreeU, which will merge the freed  block, if possible,  completing the reallocation process.   The final possible  scenario  is when  the  new  size is identical  to the  old size. In this case, DosMemChange    simply  exits. Although there is  no physical change,  DosMemChange    does perform  a validation of the  memory block, This is a good way to check the validity of the block.   DosMemCheck     Listing 5.6  is the final memory manager function I  will examine. Like DosMemLargest    , it is not accessible to the user. It  is a DOS-C function  that supports the memory manager. Because of the  critical  nature  of  the  MCB  headers  and  the  arena  itself,  DOS-C  must   Listing5.6   The DosMemCheck     function.   COUNT  DosMemCheck  r  i     v o i d    REG mcb  FAR  *p;   I n i t i a l i ze    *  p  =   mcb  FAR  *  MK_FP first_mcb,  0    ;    *  Search   through  memory  blocks  for   i   ;  ;       *  check   for  corruption  i f  p  ->  m_type  !=  MCB_N0RMAL  &&  p  ->  m_type  !   =  MCB_LAST    return  DE_MCBDESTRY;   * 7   *    *7    160 —  The FreeDOS Kernel   check the validity of the arena at key times, such as when a program ter  minates.  It  is  the  responsibility  of  DosMemCheck     to  guarantee  that  DOS-C does not operate with a corrupted memory arena.   The  DosMemCheck    algorithm is simple. It begins at the beginning  of the memory  arena and examines the MCB header. It checks for cor  ruption  using the now familiar ASCII "M" or ASCII "Z" check. If the  header is good, it computes  the location  of the next block  and  repeats  the check.  DosMemCheck    continues checking MCB headers until the  final memory block has been checked.   Arena  Support  Functions   Aside from the arena management functions, the memory manager also  supplies arena support functions. These functions  are needed to support  what may seem to be simple functions  but are key to a portable design.  For example, funtions  are needed that extend the addition of scalar val  ues to segmented  pointers  so that data references  may extend  past  the  64Kb  80x86 boundaries. They  are also important  to assist in compiler  independance  for  80x86  processors.  For  example,  integer  arithmetic  may  wrap  in  one  compiler  or  memory  model  and  be  adjusted  in  another.   Listing5.6  The DosMemCheckC  function  — continued.   I*  not corrupted - if last we're OKI  if p -> m_type =  MCB_LAST    return SUCCESS;   *     * not corrupted - but not end, bump the pointer  else if p -> m_type != MCB_LAST    *   p = MK_FP far2para  V0ID  FAR * p  + p -> m_size + 1, 0 ;  *     * totally  lost - bad exit  else   return  DE_MCBDESTRY;   }   }    DOS-C Kernel: Memory Manager and Task Manager — 161   mcb_init     is a rather  simple  function   Listing  5.7  that  initializes  the memory  arena.  For real mode, this is rather simple. All you need to  do is create a single memory block that is also the last block. From here  on out, all the memory management functions  maintain the MCB chains.  DOS-C also provides two support functions  that perform a logical to  physical translation — loosely  speaking. Again, you only  support real  mode, and as a result, there really is not much in the way of logical to  physical  support. However, these functions  are of considerable  help in  converting  segmented  architecture,  pointers  to  linear  representations.  You will see both these functions  used throughout the task and memory  managers.   The function  fa r2pa ra      Listing 5.8  takes afar  pointer and con  verts it to a segment  address, which is different  than  simply taking the  segment portion of the pointer. It computes a linear representation and  then converts it back  Figure 5.3a . What you are left with is the largest  segment possible for this address.   Why do you need this? The segmented architecture of the Intel fam  ily  allows a pointer  0000:fffOh.  This  address is not convenient for a  pointer  because  with  most  C compilers  targeted  for Intel  processors,  you can only increment this by Of h before the pointer wraps around to  0000:0000h. Using  far2para     for the same pointer, you build  anew  pointer  of Of f f : 0000h. Now you get a useful  range  of ffffh  before   Listing  5   7  :   The  mcb_init        function.   VOID  mcb__init  i   COUNT   i  ;    mcb   FAR  *mcbp,  i nt   size    mcbp  mcbp  mcbp  f o rd   -> m_  -> m_  -> m_  =  0  cbp  IT   =  MCB_LAST;  -type  = FREE_PSP  _psp  =  =  size;  _size  8;  i++   i  <  -> m_r  named ]  =  ;_mode  =  FIRST_   ' \ 0 ';  rI T;   mem  access   }    162 — The FreeDOS Kernel   the  pointer  wraps  around.  Practically,  you  can  guarantee  a  range  of  f f f Oh or 65,520 bytes before the pointer wraps around.   Function  1 ong2para     is much simpler but equally necessary   List  ing  5.8 .  In  many  instances  during  program  loading,  a  linear  logical  address  is  computed  and  long2para    converts  this  address  to  the   Listing5.8  The  far2para      and  7ongZpara      functions.   seg  far2para   VOID FAR *p   {  seg ul = FP_SEG p ;  offset u2 = FP_0FF p ;  ULONG phy_addr;  phy_addr =    long ul  «  4  + u2;  return   phy_addr>>4 ;   seg  long2para   LONG size   {   return    size + OxOf  »4  ;   Figure  5.3a   fa r to paragraph   operation.   2   1  0  0   segment «  4   +   1  0  0  4   +  offset   =  linear address   2  2  .  .   0  0  1   I   4   <  >  f  0  0   2  C  V J    »4   =  adjusted  paragraph    DOS-C Kernel: Memory Manager and Task Manager — 163   nearest segment  Figure 5.3b . Again, this function  is a bridge between  linear architecture and the segmented architecture of the Intel family.   Support  functions  with  more  complexity  are  add_far    and  adjust_far     Listing  5.9 .  Again,  these  functions  are  bridges  between linear and segmented architectures. They also assist DOS-C in  overcoming segmented pointer limitations.   As  I  discussed  previously,  many  C  compilers  for  Intel  processors  limit  their  pointer  arithmetic  to that  which  can  be  addressed  within  a  segment. Unfortunately, DOS-C needs to address the entire 1Mb of real  memory  range.  add_far     addresses this limitation. Both the file sys  tem  manager  and  the  memory  manager  need  to  add  a l o n g t o a f ar  pointer, with the result of a new  far  pointer.  add_far     accomplishes   Figure 5.3b   1 on g to paragraph  operation.   2  2  0  0  4   linear address  size    +   I o  o  o  o  f   add to round up   2  2   0   1  3   J   »4   I   r   \  2  2   f   0  1   =  segment   Listing 5.9   The add_ far       and   adjust_   .fa  r    functions.   VOID  FAR  *  add_far  1    VOID   FAR  * f p,  ULONG   off    UWORD  seg  UWORD  o ff   _val  ;  _val  ;    *  Break  seg_val  =  off_val  =   f ar  pointer  FP_SEG fp   FP_0FF fp    intc   3  components   -  K      164 — The FreeDOS Kernel   this by breaking a far  pointer into components and adding the offset  to  the  far  pointer's  offset  part   Figure  5.4a . It then  masks the offset  so  that it fits into a paragraph word and adds the top part into the segment.  This  top portion  is effectively  the carry  into the  segment.  add_far      finally converts the individual components to a far  pointer and returns  it  Listing 5.9 .   Listing5.9   The  add_fari   continued.   and  adjust_far     functions  —    *  add  the  offset  off  4=  off_val;   to  the  fp's  offset  part    *  make  off_val  equal  off  vai  =  off  &  Oxffff;   to  lower  part  of  new  value    *  and  add  top  part  seg_val  +=      o ff  &  OxOOOf00001      0x10 ;   into  seg    *  and  send  back  the  new  pointer  return   VOID  FAR  * MK_FP seg_val,  off_val ;   VOID  FAR  *  adjust_far  r  1    VOID  FAR  *fp    UL0NG  linear;  UW0RD  seg_val;  UW0RD  off_val;    *  F i r s t,  convert  the  segmented  pointer  linear  =     UL0NG FP_SEG fp    «  4   +  FP_0FF fp ;   to  a  linear  address   into  segments.    *  Break  it  seg_val  =   UW0RD  1inear  »  4 ;  off_val  =   UW0RD  1inear  &  Oxf ;    *  and  return  an  adddress  adjusted  to  the  nearest  paragraph   *  boundary.  return  MK  FP seg  v a i,  off  v a i  ;   *7  *    *7   *    *    *    *    *    }   }    DOS-C Kernel: Memory Manager and Task Manager — 165   The function  adjust_far     is also needed by the file system man  ager. It  adjusts  a  far  pointer  so that  you  can  get  the  maximum  range  out  of  C  pointer  arithmetic   Figure  5.4b ,  similar  to  far2para    .  It  does  this  by  converting  the  segmented  pointer  to  a  linear  address,  breaking  it  into  segments  by  masking,  and  returning  an  address  adjusted to the nearest paragraph  Listing 5.9 .   1 tigure  5.4a   add_ fari    operation.   2  3  0 2   10   0   7   f a r t o f p   +     f    f  0   0   +  off_val   0   7     1  0   f  L  L  ...  X   f   =  off   >  f  &0xff  ff   split   &0xf0000   +   1   0 0   0     3  3 j 0  2   Of   0   7   Figure 5.4b   Normalized  adjusted    fa   =   final  sum   r pointer  operation.   3  0  2  1   2   +   f   f    f    f     GL  i   DL   3   0    1   f   1  1   r   f   3   0  1   segment   +  offset   = linear address   *  0  0   0   f     split adjusted  pointer    166 — The FreeDOS Kernel   Task Manager  The DOS-C task manager is responsible only for starting tasks, switch  ing between user space and kernel space, and terminating tasks. In con  trast  to other operating  systems, it is a simple task manager;  however,  its simplicity  will  assist you in understanding  machine  support issues,  such as initial register values and the switching of stack space.   Assembly  Language  Support  I will first examine fundamental  assembly  language  support  functions  necessary for task management in DOS-C. These functions  include the  separation of user and kernel space, process start up, and process termi  nation. The DOS-C design calls for  a minimum of assembly language,  so  our  assembly  language  functions  are  straightforward  and  not  very  complicated.   The first assembly language function  I will examine is exec_user       Listing 5.10 . This function  saves the current state on the kernel stack.  It then takes the pointer passed to it and recovers the new process con  text from  it. It uses the Intel  i ret  instruction to recover the  cs : i p and  flags  from  the  stack.  This  is  the  simplest  way  of jumping  to  a  new  address that remains compatible with normal interrupts.   You will notice that the processor  context  is saved  on the stack  for  both  user  and  kernel  processes.  This  technique  is  used  throughout  DOS-C. There are other ways to save a context, such as placing all the  registers within a table, but that requires much more code than using the  stack. It does, however, place the constraint that the stack must be large  enough  for  the user  functions  plus  the context.  Fortunately,  MS-DOS  addresses  this  in the programming  manuals,  and  all programs  written  for MS-DOS will have a stack large enough to use this technique.    DOS-C Kernel: Memory Manager and Task Manager — 767   The same technique is used by the  handl e_break     function   List  ing 5.10 . DOS-C calls this function  whenever a break has been detected.  By  MS-DOS  standards,  whenever  a  break  is  detected,  an  int  23h   Listing  5.10  The exec_user    and handle_break     functions.   Special  cal l   for  switching  processes   void  interrupt  i regs  far  * i r p;   far  exec_user irp      +    +   +    rland  C++  specific  -+  26  -+  24  -+  22  - +  20  -+  18  -+  16  -+  14  -+  12  -+  10  -+   i  rp  hi  irp 1ow  flags  cs  ip  ax  bx  ex  dx  es  ds  si  di  bp   6  -+  4  -+  2  -+  0  -+   +- - -  +    168 — The FreeDOS Kernel   instruction  is executed. This places  the  necessary  cs : i p and flags for  returning  to  the  system  on  the  user  stack.  When  the  user  handler  returns,  it  checks  for  an  i ret  or  retf  return  and  handles  each  case  appropriately.   Listing  5.10  The exec_user    and   handle_break     functions — continued.   _exec_user   pub1"!  proc   r  far   p y o..~     c; <^ r      ax,WORD  PTR  [bp+24]  dx,W0RD  PTR  [bp+26]  sp,ax  ss,dx   ;  i rp    user  ss:sp    ;  set-up  user  stack   ax  bx  ex  dx  es  ds  si  di  ax,DGR0UP  ds,ax  bp  bp,sp   push  push  push  push  push  push  push  push  mov  mov  push  mov  eld  e li   mov  mov  mov  mov  s ti      pop  bp  pop  pop  pop  pop  POP  pop  pop  pop  i  ret   di  si  ds  es  dx  ex  bx  ax   _exec_user   endp    DOS-C Kernel: Memory Manager and Task Manager — 169   Process  Environment  The  assembly  language  support  functions  you  have just  seen  lay  the  foundation  for  the  remainder  of  the  task  manager.  These  functions,  along  with  memory  manager  support  functions,  are  used  extensively   Listing 5.10  The exec_user     and  functions — continued.   hand!e_break     Special  call for switching processes during break handling  void interrupt far handle_break     flags  cs  IP   +    +  I  +   ex      dx  bx  sp  bp  si  di  ds  es   +  I  +    +    +   24  +  22  +  20  +  18  +  16  14  12  10   _i_   _,  I  4  +    2  +    0   +   bp & sp after mov bp,sp    170 — The FreeDOS Kernel   within  the  loaders. However,  before  diving  into the  loaders, I want  to  look at a process environment.   A program,  when  loaded  into  memory,  is  a process.  Each  process  within DOS-C has a data structure associated with it known as the PSP  or  Program  Segment  Prefix.  It  is  important  that  you  become  familiar  with this data structure because DOS-C uses it to tie together file sys  tem as well as task-related  functions.   Listing  5.10  The  exec_user     and  functions  —  continued.   hand!e_break     public   _handle_break   _handle_break   proc   far   push  ax  push  bx  push  ex  push  dx  push  es  push  ds  push  si  push  di  mov  mov  push  bp  mov  assume  DS:  DGROUP  eld   ax,DGR0UP  ds,ax   bp,sp   ;  handler  body  -  start  out  by  restoring  stack  pushf  cl  i   ;  save  background  stack  mov  word  ptr  DGROUP:_api_ss,ss  mov  word  ptr  DGROUP:_api_sp,sp   ;  restore  foreground  stack  here  mov  ss,word  ptr  DGROUP:_usr_ss  sp.word  ptr  DGROUP:_usr_sp  mov    DOS-C Kernel: Memory Manager and Task Manager — 777   DOS-C  also  has  two  executable  file  types  typically  referred  to  as  EXE and COM files. A COM file is a memory image of an executable  program. DOS-C  simply  loads  this  type  of program  into memory. An  EXE file, however,  is  a more  complex file consisting  of  a header  fol  lowed  by  the program  and  possibly  a relocation  table.  It  is  important   Listing  5.10  The exec_user    and  functions  — continued.   handle_break     the  user  registers  back   ;  get  pop  pop  pop  pop  pop  pop  pop  pop  pop   all  bp  di  si  ds  es  dx  ex  bx  ax   ;  do  int   the  i n t  23  handler  and  see  if  23h   it   returns   re  back,  must  have  been  users  handler  ax  bx  ex  dx  es  ds  si  di  bp  bp,sp  ax,DGROUP  ds,ax   ;  we'  push  push  push  push  push  push  push  push  push  mov  mov  mov  assume  DS:  DGROUP   1   far  return  or   i r et   ;  test  cmp  J'z   for  sp,_usr_sp  hbrkl   ;  it  was  far   ret    172 — The FreeDOS Kernel   that you understand  this data structure  as well because  it governs how  the loader loads the program into memory.   As  you  have  seen  before,  the  psp  data  structure   Listing  5.11   is  another  80x86 processor-dependent  data structure. It is designed  to fit  within the first 16 paragraphs. This results in a few unused fill regions   Listing5.10   The exec_user    and  functions  — continued.   handle_break     hbrkl:   i n t  21  from  the  top   t a rt  bp  di­ si  ds  es  dx  ex  bx  ax  _int21_entry   ;  res  pop  pop  pop  pop  pop  pop  pop  pop  pop  call  i r et   hbrkl  bp  di  si  ds  es  dx  ex  bx  ax  ax,4c00h   popf  jnc  pop  pop  pop  pop  pop  pop  pop  pop  pop  mov   mov  call  i r et   hbrk2:   ;  clear  the  flag  from  the  stack  ;  user  wants  to   restart   1   byte  ptr   _break_flg,Offh  _int21_entry   ;  exit  ;  set  break  detected   flag   _handle_break   edp    DOS-C Kernel: Memory Manager and Task Manager — 173   Listing  5.11  The psp data  structure.   typedef  s t r u ct  i   UWORD  ps_exit;  UWORD  ps_size;  p s _ f i l l l;  BYTE    *  CP M-like  entry  point  BYTE  VOID  VOID   p s _ f a r c a l l;   .UAK  ^ c _ r p ^l   i n t e r r u pt  ! AR  V ^ _'    i n t e r r u pt  FAR  *ps_    i n t e r r u pt  FAR  *ps_   i T^M   ,   i V ^ M  ,  _isv23   ,  J s v 2 4      ;   CP M-1ike  e x it  point  memory  size  s i n g le  char    in  paragraphs  f i ll   f ar  c a ll  opcode  r e - e n t ry  point  terminate  address  break  address  c r i t i c al  error  address  parent  psp  segment  f i le  environment  paragraph  user  stack  pointer  maximum  open  f i l es  open  f i le  previous  psp  pointer  process  dta  address   t a b le  -  Oxff   table  pointer   is  unused   -  i nt  21   u n i x - s t y le  c a ll   -  Oxcd  0x21  0    *   *   *    *   *   *   *   *   *   *   *   *   *   *   *   *   *    *    *   *7  *   *7  *7  *   *   *   *7  *7  *   *7  *7  *7  *   *   *7  *   KCb   *    *    *7   _ p s _ f c b l ;   f i r st  command  l i ne  argument   second  command  l i ne  argument   f i l l 5 [ 3 6 ];   BYTE  s t r u c t  i   _count;  BYTE  _ps_cmd  BYTE  _ps_cmd[127];    *   command   t a il   UWORD  ps_parent;  UBYTE  p s _ f i l e s [ 2 0 ];  UWORD  ps_environ;  BYTE  FAR  *ps_stack;  WORD  ps_maxfiles;  UBYTE  FAR  * p s _ f i l e t a b;  BYTE  FAR  *ps_prevpsp;  BYTE  FAR  *ps_dta;  BYTE  BYTE   p s _ f i ! 1 2 [ 1 6 ];  ps_unix[3];   p s _ f i l l 3 [ 9 ];   *    BYTE  union  1   s t r u ct  f  {   fcb   }  _ u l;  s t r u ct  i   }  _u2;  struct      BYTE   fcb   f i ! 1 4 [ 1 6 ];   _ps_fcb2;   }  _ U 4;   }  _u3;   }  _ u;   }  psp;    174 — The FreeDOS Kernel   that are placed in the data structure to guarantee alignment and compat  ibility with MS-DOS. A few  areas also serve multiple purposes. These  areas result in  uni ons becoming members of the structure. Although it  may  seem complex  at first glance, studying  each member  will help in  understanding the psp.   Historically, the psp has its roots in CP M. The member ps_exi t  is a  remnant  of  this  CP M  heritage.  It  provides  a CP M-like  exit  point. A  COM program can terminate by simply performing a jump to address 0.  Another  CP M-like  entry  n«;int  is  ps_farcall  and  ps_reentry    .  These members are a call to the DOS-C system call dispatcher. A COM  file may perform  a system call  with the  cai 1  5h mechanism  that was  used for CP M. These two psp entries are now seldom used, but DOS-C  maintains the structure members for compatibility with older programs.  Three  members,  ps_isv22  ,  ps_isv23  ,  and  ps_isv24  ,  rep  resent the initial process  terminate  address, break address, and critical  error address vectors. Before DOS-C starts a process, the interrupt vec  tors for  22h, 23h, and 24h are copied into these psp structure members.  Upon process  termination,  these vectors are copied back,  and the  22h  vector  is  executed.  Quite  often,  these  vectors  are  used  as  hooks  into  special termination processing.   DOS-C also uses the psp for process-related information. For exam  ple, there are system calls to set and get a quantity known as a DTA or  Disk Transfer Area. Because this is a process-unique entity, it is stored  within the  psp in structure member  ps_dta. Another per-process entity  is ps_stack. This entry is the user stack pointer on entry into the i nt  21h  handler.  Other process-related  members  are  ps_size,  which  holds the  process memory size in paragraphs, and ps_pa rent, which contains the  parent  process  psp  segment. You  should  note  that  throughout  DOS-C  the psp segment is used as the process ID. It is this quantity that identi  fies the owner of a memory block and is stored in the MCB header.    DOS-C Kernel: Memory Manager and Task Manager — 7 75   I have previously noted that UNIX influenced MS-DOS in the area of  file handles and redirection,  psp data structure members  psjnaxf i 1 es,  ps_files,  and  ps_fi  1 etab  assist  in  the  implementation.  Member  psjnaxfiles  is  a  per-process  variable  that  specifies  the  maximum  number  of  open files permissible  for  this process. DOS-C uses  a table  for mapping user handles into system handles called ps_f i 1 es. DOS-C  also allows a user to change the number of files on a per-process basis.  Member  ps_f i l e t a b i s a f ar  pointer to the open file table.   Two 3theT entries echo other UNIX influences on MS-DOS. In MS-DOS  and DOS-C, each program has an environment that it inherits from  its  parent  process. The  implementation  is  a segment  of  memory  aligned  on a paragraph boundary. The segment for the environment is stored in  ps_envi ron. Finally, a UNIX-style system call entry, ps_unix,  allows  a COM program to perform  a cai 1  50h to dispatch a system call.   The remainder  of the  psp is dedicated to two FCBs, _ps_f cbl  and  _ps_f cb2, which are parsed prior to the start of the program. These are  compatibility  entries  that  were  used  for  command  line  variables  as a  shortcut to processing the command  tail. Of course, the command  line  used  to  invoke  the  process  less  the  verb  is  _u4.  These  febs  and  the  command tail are held within the  union  _u. This  union  is designed to  specifically  match the  psp entries. Aliases for the  union struct  com  binations  are _ps_fcbl  and  _ps_fcb2  for  the  two  system  FCBs  and  _ps_cmd  and _ps_cmd_count  for the command tail.   Before  becoming  a process,  a program  may  be  stored  on  disk  two  ways. The first way is as a COM file, which is an exact binary image of  the program  as it initially  appears in memory. The image must reserve  the first 100h bytes for the psp and must use the tiny or small program  ming model. The second  way  is as an EXE file that is composed  of a  header,  image,  and  an  optional  relocation  table   Listing  5.12 .  The  exe_header  data  structure  is  the  mechanism  used  to tie  the  program  together.    176 — The FreeDOS Kernel   The first entry  in  exe_header  is  exSignature,  which  identifies  an  EXE file. This entry is either the ASCII characters "MZ" or "ZM". The  next two members indicate the file size in 512-byte pages. The first of  these two, exExtraBytes, indicates the number of bytes in the last par  tial  page. The  second  of  these  two,  ex Pages,  contains  the  number  of  whole and partial pages in the file.   Member  exRelocItems  is  a  count  of  the  number  of  relocation  entries in the relocation table. Each entry is 4 bytes long and is stored in  80x86  segment:offset  fashion.  Th-  final  member  that  determines  the  EXE file size isexHeaderSize, which is the size of the  header in 16-byte  paragraphs. DOS-C uses this member to compute the size of the image  that it loads into memory.   Before  loading  the program  into memory, DOS-C  attempts  to allo  cate memory for the program. It does this by computing the image size  and  calculating  minimum  and  maximum  memory  requirements  using  members  exMinAlloc  and  exMaxAlloc.  With  memory  allocated,  the  image  is loaded,  and the  relocation  table  is used  to fix segment  refer  ences  in the program. These  segment  references  are pointed  to by  the   Listing  5.12  The exe_h e a der  data  structure.   typedef  struct    i   UWORD  UWORD  UWORD  UWORD  UWORD  UWORD  UWORD  UWORD  UWORD  UWORD  UWORD  UWORD  UWORD  UWORD   exSignature;  exExtraBytes;  exPages;  exRelocItems;  exHeaderSize;  exMinAlloc;  exMaxAlloc;  exInitSS;  exInitSP;  exCheckSum;  exInitIP;  exInitCS;  exRelocTable;  exOverlay;   }  exe_header;    DOS-C Kernel: Memory Manager and Task Manager — 7 77   entries in the relocation  table. DOS-C uses member  ex Rei ocTabl e to  seek to the start of the relocation  table within the file and then  adjusts  each segment reference for  exRel oc I terns iterations.   With  the program  loaded  into memory  and  far  addresses  adjusted  for  its  new  location,  DOS-C  uses  exInitSS  and  exInitSP  to  set  the  initial stack pointer. It initializes each register and begins program exe  cution at cs: ip specified by ex I nit IP  and  exInitCS.   Two final file maintenance  entries remain  in  exe_header.  The first  is  exOverlay,  whir-  k  used fin- overlays  and  specifies  the  overlay  number  that  a  file  represents.  The  other  is  exCheckSum,  which  is  designed  to contain  a checksum  that  guarantees  file  integrity.  Neither  MS-DOS nor DOS-C uses this entry.   Now that I have covered the basic data structures, I can start looking  at functions  that fill these data structures. The DOS-C loaders use these  functions  to simplify  the loading of executable programs.   The first function  I will examine is Chi 1 dEnv     Listing 5.13 . This  function  creates  a new environment  for  a process  if  one exists for  the  parent process. The first thing  Chi 1 dEnv    does is compute the length  of the environment by creating  a far  pointer  and stepping through the  strings until it finds the terminating null string. Chi 1 dEnv    attempts to  protect  the kernel  against  corrupted  environments  by  testing  the envi  ronment  size previously  computed to see if it is greater than the maxi  mum  permissible  environment  size.  If  it  is,  the  environment  may  be  corrupted  or  missing  the  terminating  null  string,  and  ChildEnvO  aborts without creating a new environment area.   Listing  5.   13  The  Ch 7   Id En   v      function.    exec_blk  FAR   * e x p,   UWORD  * p C h i l dE  nvSeg    COUNT  Chi  1dEnv  i   BYTE  BYTE  UWORD  COUNT  UWORD   FAR  *pSrc;  FAR  *pDest;  nEr  vSize;  RetCode;  Ma> vEnvSize;    178 — The FreeDOS Kernel   Listing 5.13  The Ch i 1 dEn v     function  — continued.   I*  create a new environment for the process  if exp -> exec.env_seg  != 0   {   for nEnvSize = 0, pSrc = MK_FP exp -> exec.env_seg,0 ;   {   *pSrc != '\0';    while *pSrc  != '\0'    -H-nEnvSize,   }   * account for terminating  null  ++nEnvSize;  ++pSrc;   else  {    **   nEnvSize = 0; *   pChildEnvSeg = 0;  return SUCCESS;    * Test env size and abort if greater than max  if nEnvSize >= MAXENV    return  DE_INVLDENV;    * allocate enough space for env + path  if  RetCode = DosMemAl loc long2para nEnvSize + 65 , FIRST_FIT,    seg FAR * pChiIdEnvSeg,   UWORD FAR * MaxEnvSize    < 0    else   return RetCode;  pDest = MK_FP *pChildEnvSeg + 1,  0 ;    * fill the new env and inform the process of its   * location  throught the psp  for pSrc = MK_FP exp -> exec.env_seg,0 ; *pSrc != '\0';    {   *    *    *   *    fstrncpy pDest, pSrc, BUFFERSIZE ;  while *pSrc  1= '\0'   while *pDest  !=  '\0'   ++pSrc;  ++pDest;   ++pSrc;  ++pDest;   }  *pDest =  '\0' ;  return SUCCESS;    DOS-C Kernel: Memory Manager and Task Manager —  779   Now that you have the environment  size and some assurance that it  is  intact,  Chi 1 dEnv    calls  DosMemAl loc     to  allocate  enough  space  for  the new  environment  plus  the path. If  the memory  is  successfully  allocated, Chi 1 dEnv     proceeds to fill the new environment and inform  the new process of its location through the pointer  pChi 1 dEnvSeg.   Just as the Chi 1 dEnv    function  deals specifically  with the creation  of a process environment, DOS-C has the function  new_psp     Listing  5.14  that deals specifically  with the creation of a process  psp. Similar  to its environment  Hbii«,^ new_psp    is used by the loaders to  simplify  the loading of  an executable  program  into memory. This design  is not  unusual. You have seen this type of design throughout DOS-C.   Listing 5.14  The n e w_psp     function.  VOID  new_psp   psp FAR *p, int psize   {   REG COUNT i ;  BYTE  FAR  *1pPspBuffer;    *  Clear  out  new  psp  f i r st  fordpPspBuffer  =  p,   *lpPspBuffer  =  0;   i  =  0;  i  <  sizeof psp    ;  ++i     ifndef  I PL  endif   i n i t i a l i ze  all  entries  and  exits    *   *  CP M-like   exit  point  p -> ps_exit = 0x20cb;   * CP M-like entry  point - jump to special  entry  p -> ps_farcall= Oxea;  p -> ps_reentry = int21_entry;   * unix style call  - Oxcd 0x21 Oxcb   int 21, retf   p -> ps_unix[0] = Oxcd;  p -> ps_unix[l] = 0x21  p -> ps_unix[2] = Oxcb   * Now for parent-child  relationships   * parent psp segment  p -> ps_parent = D0S_PSP;   * previous psp pointer  p -> ps_prevpsp =  BYTE FAR * -l;   *    *   *   *    *    *   *   *     180 — The FreeDOS Kernel   Listing  5.14  The n e w_psp     function  —   continued.   ifndef   I PL   j   l-  W u-.  1  1  U  J  ,    *  Environment  and  memory  useage  parameters   *  memory  size  in  paragraphs  p  ->  ps_size  =  psize;   *  environment   paragraph  p  ->  ps_environ  =  0;   *  process   dta  D  >  ps_dt*  -   BYTE  FAR *  &p  >  ps_cma   *  terminate   address  p  ->  ps_isv22  =  int22_handler;   *  break  address  p  ->  ps_isv23  =  int23_handler;   *  c r i t i c al   error  address  p  ->  ps_isv24  =  int24_handler;   endif    *  Fil e  System  parameters   *  user  stack  pointer  -  i nt  21  p  ->  ps_stack  -   BYTE  FAR  *   - l;   *  f i le   f o r  i  =  0 ;  i  <  20;  i++    table  -  Oxff  is  unused   p  ->  p s _ f i l e s [ i]  =  Oxff;   i n i t i a l i ze   stdin,  stdout,  etc    *  p  ->  ps_files[STDIN]  =  0;  p  ->  ps_files[STDOUT]  =  1  p  ->  ps_files[STDERR]  = 2  p  ->  ps_files[STDAUX]  = 3  p  ->  ps_files[STDPRN]  = 4   *  maximum  open  f i l es  p  ->  psjnaxfiles  = 20;   *  open  f i le  p  ->  ps_filetab  =  p  ->  ps_files;   *  p  ->  ps_fcbl.fcb_drive  =  1;   *  second   command  line  argument  p  ->  ps_fcb2.fcb_drive  =  2;   f i r st   command  line  argument   table  pointer    *  stdin   *  stdout    *  stderr   *  stdaux    *  stdprn    *  local   command  line  p  ->  ps_cmd_count  = 0;  P  ->  ps_cmd[0]  = 0;    *  command   *  command   t a il  t a il   }   *   *    *    *    *   *    *    *   *   *    *   *   *   *   *   *7  *   *    *    *    *   *   *     DOS-C Kernel: Memory Manager and Task Manager — 181   The function  new_psp    begins by clearing the memory region that  will become the new  psp. This action ensures a known state for  mem  bers that are not currently used and also for variable-length fields such  as the command tail.   The algorithm behind  new_psp     is simple: it initializes  all entries  and exits. It does not fill in psp structure members that are process spe  cific. In essence, it creates  a skeletal  psp that is necessary  for both the  COM loader and the EXE loader.   The first structure member  :t initializes  is the CP M-like exit point.  It enters 2 bytes that are an  i nt  20h instruction. This is the direct Ter  minate Program entry and guarantees termination whether the program  performs  a call  or  a jump  to this  location.  It initializes  the  CP M-like  entry point next with a jump to special entry  i nt21_ent ry. Then it ini  tializes the UNIX-style call that is an  i nt  21 h instruction followed  by  a far  return. This completes the psp system call linkages.   new_psp    next  initializes  the parent-child  relationships.  It fills in  the parent  psp segment with the DOS-C segment,  D0S_PSP. This loca  tion  will  be  overwritten  later,  but  this  initialization  guarantees  an  owner. It then initializes the previous psp pointer to  -1. This signifies to  DOS-C that it is the  start  of  the process  chain. Again,  it will be  over  written by DOS-C when applicable.   With process relationship structure members initialized,  new_psp     proceeds  to  environment  and  memory  usage  structure  members.  It  begins by  initializing  the process  memory  size  in paragraphs  with  the  parameter  psi ze. Then, it initializes the environment with 0, indicating  that no environment  is assigned  at this time. The program loaders will  fill this in later. Next,  new_psp    assigns the process  dta  to the com  mand tail area, finishing initialization  of the process memory  structure  member.   Next,  new_psp    initializes  the  interrupt  vector  members.  It  first  assigns  the  address  of  the  int22_handl er  function  to  the  terminate  member. Then it initializes the break address member with the address of  the  i nt23_hand1 er  function.  Finally, the critical error address structure  member  receives  the  address  of  the  int24_handl er  function,  and  the  user stack pointer member for  i nt  21 h system calls is initialized to - 1.  This last one is not a real vector but is grouped this way for simplicity.    182 — The FreeDOS Kernel   new_psp    now proceeds to initialize the file system parameters. It  first initializes  the file table. Each  entry  is assigned  Oxff,  which  indi  cates that the corresponding handle is unused or closed. It then initial  izes  the  first  five  handle  entries  for  stdin,  stdout,  etc.,  with  the  corresponding  table  handles  of  the fixed system  file.  new_psp    then  initializes  the maximum  open files structure  member  to the default  of  20 and completes  the file assignments  by  assigning  the open file table  pointer to the psp file table.   new_psp    complete-  ?K  work  Ky initializing  the FCBs  of the first  and second command line arguments and the command tail, then exits.  This  completes  the  new_psp    function.  Again,  some  of  these  entries  will be overwritten, but this technique guarantees that the entire  psp is  initialized  in  one  way  or  another  and  assists  in  the  maintenance  of  DOS-C so that if any change accidentally  omits a psp update, an error  condition results that may be caught later.   Program  Loaders  I now will take a look at the program loaders. This is the primary area of  responsibility for the task loader of any DOS-compatible operating sys  tem. The basic methodology is simple. Look at the start of the file, if you  see  a magic  number,  assume  that  it  is  an  EXE  file;  otherwise,  it  is a  COM file. Based on this response, dispatch the correct loader.   The basic entry  point for  task loading  is  Dos Exec      Listing  5.15 .  Dos Exec     begins by checking the validity of the file. First it looks for  the  file  by  simply  trying  to  open  the  file  with  dos_open  .  If  Dos Exec     cannot find the file because dos_open     returns an error, it  assumes that the file does not exist and returns an error. Next it attempts  to read the header. If the file header  cannot  be read,  Dos Exec     again  assumes  a  nonexistent  file  and  returns  an  error.  If  it  was  successful,  Dos Exec     calls dos_close rc   to close the file. Now for the acid test:  if the header structure member exSigna tu re is not MAGIC  "MZ" , then  it assumes the file is a COM file and executes the COM loader; other  wise it assumes it's an EXE file and executes the EXE loader.    DOS-C Kernel: Memory Manager and Task Manager — 183   Listing 5.15  The Dos Exec      function.  COUNT  DosExec   COUNT mode, exec_blk FAR *ep, BYTE FAR *lp   {   ifdef IPL  endif   COUNT re, nNumRead;   * If file not found - free ram and return error  printfC."  ;  if  rc = dos_open lp, 0   < 0   1f  nNumRead = dos_read rc,  VOID FAR * &header,  != sizeof exe_header    {   return DE_FILENOTFND;   sizeof exe_header      ifdef IPL   endif   return DE_INVLDDATA;   printf "Internal  IPL error - Read failure  read %d != %d ",   nNumRead, sizeof exe_header    ;   *    dos_close rc ;   ifdef   IPL   p r i n t f   " . "  ;   endif   if header.exSignature   !=  MAGIC    IPL  return  DosComLoaderdp,  ep,  mode ;   ifndef   else  {   }  endif   else   char  szFileName[32];   fmemcpy  BYTE  FAR  * szFileName,  p r i n t f   " \ n F i l e:  %s   MAGIC  =  %04x ",  szFileName,   l p  ;   header.exSignature ;   fatalC'IPL  can't   load   .com  f i l e s ! "  ;   return  DosExeLoaderdp,  ep,  mode ;    184 — The FreeDOS Kernel   The COM loader that  Dos Exec     calls is DosComLoader     Listing  5.16 . DosComLoader    is a good function  to examine first. By examin  ing it, you can concentrate on the steps required to load a file into mem  ory  without  the complexity  of the EXE file relocation,  placement in  memory rules, etc.   Listing5.16   The  DosComLoa   der        function.    BYTE  FAR  *namep,   exec.   _blk  FAR ^exp,  COUNT  mode    s t a t ic  COUNT  DosComLoader  I   COUNT  r e,  env_size,  nread;  UWORD  mem;  UWORD  env,  a s i z e;  BYTE  FAR * s p,  FAR * d p;  psp  FAR * p;  mcb  FAR  *mp;  i r e gs  FAR  * i r p;  LONG  com_size;   if mode  i   !=  OVERLAY    return  re;   i  else   i   }   i  else  i   if env   i=  0    DosMemFree env ;   return  re;   mp  =  MK_FP mem,  0  ;  ++mem;   i f     re  =  ChildEnv exp ,   &env        !=   SUCCESS    mem  =  exp  ->  load.load_   _seg;     *  A l l o c a t e  our  memory  and  pass  i f     re  =  DosMemAlloc 0 ,  LARGEST   UWORD FAR   back  any  e r r o rs  ,   seg  FAR * &mem,  *   & a s i z e     <  0     *     DOS-C Kernel: Memory Manager and Task Manager — 185   Listing5.16   The   DosComLoaderi function   —  continued.   is  fatal  because  we  lost   f i le   not  found  -  error   Now  load  the  executable  If  NOTE  -  this  from  DosExec!    *  1*   *   *  i f     r c  =  dos_open namep,  0    <  0   fatal " DosComLoader   com  f i le  do  it  =  MK..!T mem,  sizeof psp  ;    *  sp  for com_size  =  655361,  nread  =  0;  com_size  i   in  32K  chunks   lost   in   it   nread  =  dos_read rc,  sp,  CHUNK ;  sp  +=  nread;  com_size  -=  nread;  if nread  <  CHUNK    in   t r a n s it   t r a n s i t"    ;   >  0;      break;   i    d05   ;_close rc ;   if mode  =  OVERLAY   return  SUCCESS;   point  to  the  PSP  so  we  can  build  = MK_FP mem,  0 ;   7*  P  =  new_psp p,  mem +  asize ;   it   table   7*  clone  the  f i le  ifdnDOS  >  0   1   psp  FAR  * q;  REG COUNT  i;   q  =  MK_FP cu_psp,  0 ;  f o rd  =  0 ;  i  <  20;  {   i++    REG  COUNT  r e t;   i f  q  ->  p s _ f i l e s [ i]  &&      r et  =  CloneHandle q  ->  ps_fi"   !=  Oxff   p  ->  p s _ f i l e s [ i]  =  r e t;   else   p  ->  ps  f i l e s [ i]  =  Oxff;   e s [ i ]     >=  0     }   }   *7  *f  *   *    *    *    *     186 — The FreeDOS Kernel   As described earlier, a COM file is a simple memory image of the pro  gram. It is an exact image of the program at the instant prior to the start of  execution. The rules are simple: reserve the first 256 bytes for a psp, and  DOS-C guarantees to give you a stack, guarantees initial register values,  and  starts executing  at  100h  offset  from  the beginning  of the file. This  model  is  virtually  identical  to  the  CP M  model  and  made  a good first  choice for programs migrating from 8-bit to 16-bit environments.   Although the concept is simple, the algorithm is somewhat more com  plex. Some issues must be dealt with when starting a program. It needs to  systematically  allocate  resources,  make  assignments  to  psp  structure   Listing  5.16  The DosComLoader     function  —  continued.   p  ->  ps_environ  =  env  =  0  ?  0  :  env  +  l;    *  complete   the  psp  by  adding  the  command  line  p  ->  ps_cmd_count  =  exp  ->  exec.cmd_line  ->  ctCount;  fbcopy exp  ->  exec.cmd_line  ->  ctBuffer,  p  ->  ps_cmd,   p  ->  ps_cmd_count  >  127  ?  127  :  p  ->  ps_cmd_count  ;    *  stick   a  new  line  on  the  end  for  safe  measure  p  ->  ps_cmd[p  ->  ps_cmd_count]  =   ' \ r ';   identify    functions'   the  mcb  as  this    *   *  use  the  f i le  name  less  extension  -  l e ft  adjusted  and   *  space   mp  ->  m_psp  =  mem +  1;  for asize  =  0 ;  asize  <  8;  asize++   i   f i l l ed   if namep[asize]   !=   ' . '    mp  ->  m_name[asize]  =  namep[asize];   else   break;   ì  f o r  ;   asize  <  8;  asize++    mp  ->  m_name[asize]  =  '   ' ;    *  build   the  user  area  on  the  stack  irp  =  MK_FP mem,   Oxfffe  -  s i z e o f   i r e g s      ;   *7   *7   *   *   *    *     DOS-C Kernel: Memory Manager and Task Manager — 187   members,  and  trap  potential  errors.  Although  these  issues  somewhat  complicate the task of loading a COM file, the code is straightforward.   DosComLoader     begins by trying to allocate a user environment. It does   this by calling Chi 1 dEnv    if it is not loading an overlay. DosComLoader      checks for  errors  and returns  should  Chi 1 dEnv    be unable to create the   Listing5.16   The DosComLoader    function  —  continued.   !    *  start  al locò-  iny  REGs  i rp  ->  ES =  irp  ->  DS =  mem;  i rp  ->  CS =  mem;  i rp  ->  IP  =  0x100;  i rp  ->  AX  =  Oxffff;  i rp  ->  BX  =  i rp  ->  CX  =  i rp  ->  DX =  irp  ->  SI  =  i rp  ->  DI  =  i rp  ->  BP  =  0;  i rp  ->  FLAGS  =  0;    *   for  now,  until   fcb  code  is   in   to  the  executable    *  Transfer   control  p  ->  ps_parent  =  cu_psp;  p  ->  ps_prevpsp  =   BYTE  FAR  * MK_FP cu_psp,  0 ;  p  ->  ps_stack  =   BYTE  FAR  * user_r;  switch mode   r  1  case  L0ADNG0:   cu_psp  =  mem;  dta  =  p  ->  ps_dta;  exec_user irp ;   *  We  should  never  be  here  fatal "KERNEL  RETURNED]II" ;  break;   case  LOAD:   exp  ->  exec.stack  =   BYTE  FAR  *   i r p;  exp  ->  exec.start_addr  =  MK_FP irp  ->  CS,  i rp  ->  IP ;  return  SUCCESS;   !     }   }   *    *7   *7   *     188 — The FreeDOS Kernel   environment. Given that the first memory allocation succeeds, it next tries to  allocate memory for the process and exits if an error occurs. Note that by  specification, the memory allocation is for the largest memory block avail  able. Also, if DosComLoader     detects an error condition, it must deallocate  the memory previously set aside for the environment. This pattern of deallo  cating previously set-aside resources continues through  DosComLoaderO  because as more of the new process environment is built up, more system  resources  are used. An  exit  from  an  error  condition  must  systematically  return the system resource«  ornerwi«?.e; DOS-C would slowly become use  less after repeated errors.   At  this  point,  DosComLoader     has  allocated  all  the  memory  it  needs to load the executable. It again  starts  out by attempting  to open  the file that contains the program image.  If it cannot find the file, it per  forms error processing. Note that this time the error is fatal. The reason  may  not be clear until  you  examine  how DOS-C  arrived  at this  point.  Previously,  the file had  to  exist  in  order  to  test  for  the  presence  of  a  header. If an error occurs only  a single function  call later, a more seri  ous error, such as the corruption of the user data or a wild function  call,  caused  DOS-C  to  execute  this  code  erroneously.  The  odds  are  very  good that DOS-C cannot recover, so it must terminate.   Once  DosComLoader     opens the file, it proceeds to load the image  into  memory  in  32Kb  chunks.  It  does  this  by  repeatedly  calling  dos_read     and updating  pointers  so that  the next  iteration  loads  the  next chunk in the proper location. There are only two ways to exit the  loop: the first way is to try to read more than 64Kb, and the second way  is to read less than  32Kb, indicating  an end-of-file  condition.  Regard  less of the terminating condition,  DosComLoader     then closes the file  by calling dos_cl ose   . This is also the exit point for an overlay, since  all other resources are part of the root program.   For program loading, however, DosComLoaderO  now must proceed to  make this image into an executable process. It computes the location of the  psp  so  that  DosComLoader     can  populate  it.  DosComLoader     calls  new_psp     to  initialize,  then  proceeds  to  clone  the parent  process' file  table.  DosComLoader    places the true environment  segment  value into  the psp and then completes it by moving the command line into the com  mand tail of the psp.    DOS-C Kernel: Memory Manager and Task Manager — 189   Next,  DosComLoader     has  to  do  some  housekeeping.  It  needs  to  identify  the mcb to signify  that it belongs to this process. It does this in  two  ways.  First,  DosComLoader     uses  the  file  name  less  extension  after  left  adjusting  it with trailing space. Second, it places the segment  value  of  the  psp  address  into  the  m_psp  structure  member.  It  is  this  structure member that DOS-C uses to identify  free memory blocks.   Finally, DosComLoader     must pay attention to the needs to the pro  cessor itself. It first computes the location of the machine stack and pro  ceeds ?o bwlu t^  -. "*<  -:, : : on the stack. It builds this aren by allocating  register variables in a manner that complies with the exec_user     sup  port  function.  This  is  how  DosComLoader     guarantees  the  register  contents. With the machine context initialized,  DosComLoader    trans  fers control to the loaded executable image through  exec_user    . One  final note, if the function  is invoked  with  a load  and go condition,  the  exec_user    call  should  never  return.  If  it  does,  you  have  another  unrecoverable error and DosComLoader     invokes a fatal error.   You now have a better understanding, after examining DosComLoader    ,  of the  basic steps in loading a program into memory and starting the process.  I will now move ontoDosExeLoaderO   Listing 5.17  to examine the more  complete EXE file-loading process.   function.   FAR *exp, COUNT mode    Listing  5.17  The  Dos  Exe Loa  der      static COUNT  DosExeLoader   BYTE EAR *namep, exec_blk  COUNT re, env_size, i, nBytesRead;  UWORD mem, env, asize, start_seg;  ULONG image_size;  ULONG image offset;  BYTE FAR *sp, FAR * dp;  psp FAR *p;  mcb FAR *mp;  iregs FAR *irp;  UWORD  reloc[2];  seg FAR *spot;  LONG exe size;  BYTE szNameBuffer[64];   ifdef  I PL  endif    190 — The FreeDOS Kernel   As with  DosComLoadeK  ,  DosExeLoadeK    first attempts to clone  the environment and create a memory arena for the new process. Unlike  DosComLoader   ,  it  next  computes  an  image  offset  from  the  header  because  the  image  shares  its  size  information  within  the  file  with  the  header and optional relocation and debugger information. With this infor  mation in hand,  DosExeLoader    can now compute image size by add  ing the number of pages scaled to bytes to the size of the  psp in bytes.   j Listing5.17  The üostxeLoader    ifndef I PL   function  — continued.    * Clone the environement and create a memory arena  if mode != OVERLAY   {   if  rc = ChildEnv exp, &env   != SUCCESS    return re;   *    }  else   endif   mem = exp -> load.load_seg;   ifdef I PL   endif   *     * compute image offset from the header  fscopy namep,  BYTE FAR * szNameBuffer ;  printf "\nEXE loader loading: %s", szNameBuffer ;  image_offset =  ULONG header.exHeaderSize * 161;   * compute image size by removing the offset from the number *    * pages scaled to bytes  plus the remainder and the psp *    *  First scale the size  *   image_size =  ULONGMheader.exPages  * 5121;   * remove the offset  image_size -= image_offset;   * add in the remainder bytes  if header.exExtraBytes i= 0    *   *    image_size -=  ULONG  512 - header.exExtraBytes ;   if 0    * and finally add in the psp size  if mode  1= OVERLAY    image_size +=  UL0NG long2para  LONG sizeof psp  ;   *      endif    DOS-C Kernel: Memory Manager and Task Manager — 191   This is now the minimum size of the memory block necessary to load the  file. It  will  be  used  later  to  determine  the  actual  memory  block  size.  Next,  DosExel_oader     attempts  to find out how  many  paragraphs  are available. It computes  the minimum  size of the EXE file by using  the  exMinAl 1 oc header  structure member. It then follows  the rules  for  EXE  file  loading  by  attempting  to  allocate  the  maximum  memory  requested for the process — the exact amount available if less than the  maximum  requested  but  no  less  than  the  minimum  requested.  Once  DosExeLoader      has  determined  the  amount  of  memory  to  request  from  the memory  manager,  it allocates the memory  and returns  if any  errors occur.   With a memory block available, DosExeLoader     next computes the  far  pointer to the space where the image will be loaded and proceeds to  load the executable. In a manner similar to DosComLoader   , it attempts   Listing5.17  The DosExeLoader     function  — continued.   ifndef  I PL   if mode  != OVERLAY   {    * Now find out how many paragraphs are available  if  rc = DosMemLargest  seg  FAR * &asize   != SUCCESS   else  {   return re;   exe_size  =   L0NG long2para image_size   +   *    header.exMinAlloc  +  long2para  L0NG sizeof psp  ;   if exe_size  >  asize   return  DE_N0MEM;   else  if   L0NG long2para image_size    +   header.exMaxAlloc  +  long2para  L0NG sizeof psp     <  asize    exe_size  =   L0NG long2para image_size   +   header.exMaxAlloc  +  long2para  L0NG sizeof psp  ;   else   exe_size  = asize;   }    192 — The FreeDOS Kernel   Listing 5.17  The Dos ExeLoader     function  — continued.   I*  Allocate  our  memory  and  pass  back  any  errors   *  We can  s t i ll  get  an  error  on  f i r st   *  returned   size  was  a  bet  f it  case  i f     rc  =  DosMemAlloc  seg exe_size ,  FIRST_FIT,   f it   if   the  above   *    *   *     seg  FAR  * &mem,   UWORD  FAR  * &asize    <  0    {   i f   re  =  DE_N0MFM'  {   if  rc = DosMemAlloc 0, LARGEST,  seg FAR * &mem,    UWORD FAR * &asize   < 0    {   if env  != 0   return re;   DosMemFree env ;   }   * This should never happen, but ...  if asize < exe_size   {   DosMemFree env ;   if env  != 0   DosMemFree mem ;  return re;   }  }  else  {   if env  != 0   return re;   DosMemFree env ;   *    }  }  else   * with no error, we got exactly what we asked for   asize = exe_size;   *    }  else  mem = KERNSEG;  endif    DOS-C Kernel: Memory Manager and Task Manager — 193   to open the file and exits with a fatal error if it cannot. The same logic  that applied to DosComLoader    applies to DosExeLoader  ; however,  there is a major divergence at this point. Where  DosComLoader    sim­ ply started loading from the beginning of the file,  Dos  Exe  Loader     per­ forms  a seek operation from the offset  computed earlier to the start of  the image.   As in DosComLoader   , DosExeLoader    uses a loop to read in the  image in 32Kb chunks. However, unlike DosComLoader   , its loop exit  criteria are either reading all bytes in the computed EXE file size or a   Listing 5.17  The Dos Exe Loa der      function  — continued.  ifndef I PL   if mode != OVERLAY   {  endif    * memory found large enough - continue processing  mp = MK_FP mem, 0 ;  -H-mem;   ifndef  I PL   }  else   endif  ifdef I PL  endif   mem = exp -> load.load_seg;   printf "." ;   * create the start seg for later computations  if mode =  OVERLAY   else   start_seg = mem;  start_seg = mem + long2para  LONG sizeof psp  ;    * Now load the executable   * If file not found - error   * NOTE - this is fatal  because we lost it in transit   * from DosExec!  if  rc = dos_open namep, 0   < 0    fatal " DosExeLoader  exe file lost in transit" ;    194 — The FreeDOS Kernel   Listing  5.17   The Dos Exe Loader       function   —  continued.   offset  to   start  of  image   dos_   Jseek rc,   image_offset,   0    =  image.   .offset    *7   IPL  n t f  "   . "  ;   ifdef  pri  endif   *  if  i   ifndef   " IPL   endif   }   ifdef   IPL  p r i n t fC   endif   . "  ;   IrfmnHp  J-  0^FRLAV:  1   DosMemFree --mem ;  if env   !=  0    DosMemFree env ;   i    return  DE_INVLDDATA;   else   sp  whi  {   _size  =  image_size;  „FP start_seg,  0x0 ;   exe_  = MK_  le exe_size  > 0    IPL  pri r   i t f   " . "  ;   ifdef   endif  }   7*  read  if mode  exe_   in  the  image  in  32K  chunks  !=  OVERLAY   .size  =  image_size  -   long2para  LONG sizeof psp  ;   *    nByt   .esRead  =  dos_read  C0UNT rc   COUNT  exe_size  <   ,   VOID  CHUNK ?   FAR * sp,  exe_size  :  CHUNK  ;   sp =  exe_  if    r   = add_far  V0ID  FAR * sp,   ULONG CHUNK ;  _size  -=  nBytesRead;  iBytesRead  =  0    exe_size  break;    =  0        DOS-C Kernel: Memory Manager and Task Manager — 195   read error. Also, DosExeLoader    calls add_far     to update the pointer  to the next chunk. This  call  is  necessary  in  order to avoid  the  pointer  addition  problems  discussed  earlier  in  the  chapter.  DosExeLoader   ,  unlike DosComLoader   , is not finished with the file when it completes  the image load. It must next proceed to relocate the image for  the new  segment into which it was loaded. It does this by seeking to the  offset  given  in the header  structure  member  exRelocTable  and  looping  the  header  structure  member  exRel ocltems  iterations. For each  iteration,  it calls  rlos_r<^rn  } UJ  read  the  relocation  segment:offset  file  pointer,   Listing 5.17  The DosExeLoaderC   function  — continued.    if  0   endif    *   Error  if  we  did  not  read  the  entire  if exe_size   !=   0    image   fatal "Broken  exe  loader   exe_size   !=  0   "  ;    * relocate the image for new segment  dos_lseek rc,  L0NG header.exRelocTable, 0 ;  for  i=0; i < header.exRelocItems; i++   {   != sizeof reloc    return DE_INVLDDATA;   if  dos_read rc,  VOID FAR * &reloc[0], sizeof reloc    {  }  if mode =  OVERLAY   {   spot = MK_FP reloc[l] + mem, reloc[0] ;  *spot = *spot + exp -> load.reloc;   }  else  {   *  spot = MK_FP reloc[l] + mem + 0x10, reloc[0] ;  spot = MK_FP reloc[l] + start_seg, reloc[0] ;  *spot = *spot + start_seg;    function  — continued.   196 — The FreeDOS Kernel   Listing 5.17  The DosExeLoader    ifdef  I PL  endif   printf "." ;   * and finally  close the file  dos_close rc ;   * exit here for overlay  if mode —  OVERLAY   return SUCCESS;    * point to the PSP so we can build it  p = MK_FP mem, 0 ;  new_psp p, mem + asize ;   ifndef  I PL   table    *  clone   the  f i le  ifdnDOS  >  0   {   psp  FAR  * q;   q  =  MK_FP cu_psp,  0 ;  f o r  i  =  0 ;  i  <  20;  {   i++    REG  COUNT  r e t;   i f  q  ->  p s _ f i l e s [ i]  &&      r et  =  CloneHandle q  ->  p s _ f i l e s [ i ]     >=  0     !=  Oxff   else   p  ->  p s _ f i l e s [ i]  =  ret;   p  ->  p s _ f i l e s [ i]  =  Oxff;   p  ->  ps_environ  =  env  =  0  ?  0  :  env  +  1;   else   endif   p  ->  ps_envi ron  =  0;    DOS-C Kernel: Memory Manager and Task Manager — 797   computes  the  corresponding  memory  location,  and  adds  the  segment  value to the original segment value in memory.   When Dos Exe Loader     completes the file load and relocation process,  it closes the file by calling dos_close    . As with DosComLoader   , this  is also the exit point for an overlay.   In  a  manner  similar  to  DosComLoader   ,  DosExeLoaderC    pro  ceeds to make this image into an executable process by computing the  location of and building the PSP.   Listing5.17  The DosExeLoaderC   function  — continued.   I*  complete  the  psp  by  adding  the  command  line  p  ->  ps_cmd_count  =  exp  ->  exec.cmd_line  ->  ctCount;  fbcopy exp  ->  exec.cmd_line  ->  ctBuffer,  p  ->  ps_cmd,   p  ->  ps_cmd_count  >  127  ?  127  :  p  ->  ps_cmd_count ;    *  stick   a  new  line  on  the  end  for  safe  measure  p  ->  ps_cmd[p  ->  ps_cmd_count]  =   ' \ r ';   identify    functions'   the  mcb  as  this    *   *  use  the  f i le  name  less  extension  -  l e ft  adjusted  and   *  space   f i l l ed  mp  ->  m_psp  =  mem +  1;  f o r  i  =  0 ;  i  <  8;  i++   {   *    *    *   *   *    !=   ' . '    if namep[i]  else   mp -> m_name[i] = namep[i];  break;   }  for ; i < 8; i++    mp -> m_name[i] = ' ';    * build the user area on the stack  irp = MK_FP header.exInitSS + start_seg,     header.exInitSP  - sizeof iregs   & Oxffff  ;   *    ifdef  I PL  endif   printf ".\n" ;    198 — The FreeDOS Kernel   Listing5.17   The DosExeLoaderC   function—   continued.    *  start   allocating  REGs   *  Note:  must  match  es  & ds  memory  segment  i rp  ->  ES =  i rp  ->  DS =  mem;  irp  ->  CS =  header.exInitCS  +  start_seg;  i rp  ->  IP  =  header.exInitIP;  i rp  ->  AX =  Oxffff;    *  for  now,  until   fcb  code  is  in   ifdef   I PL   irp  ->  BX =  BoolDrive;  i rp  ->  CX =  Numhloppi es;   else   endif   i rp  ->  BX =  irp  ->  CX =   i rp  ->  DX =  irp  ->  SI  =  i rp  ->  DI  =  irp  ->  BP =  0;  i rp  ->  FLAGS  =  0;    *  Transfer  control  p  ->  ps_parent  =  cu_psp;  p  ->  ps_prevpsp  =   BYTE  FAR * MK_FP cu_psp,  0 ;  p  ->  ps  stack  =   BYTE  FAR * user   to  the  executable   r;   p r i n t f   " S t a r t i ng  kernel    . . . \ n "  ;   cu_psp  = mem;  dta  =  p  ->  ps_dta;  exec_user irp ;   *  We should  never  be  here  fatal "KERNEL  RETURNED]J J" ;  break;   ifdef   I PL   endif   switch mode      case  LOADNGO:   ifndef   I PL   case  LOAD:   endif  }   }   exp  ->  exec.stack  =   BYTE  FAR  *   i r p;  exp  ->  exec.start_addr  =  MK_FP irp  ->  CS,  i rp  ->  IP ;  return  SUCCESS;   *   *7   *7   *    *     DOS-C Kernel: Memory Manager and Task Manager — 199   DosExeLoaderO  also computes the location of the machine stack and  proceeds to build the user area on the stack. Unlike  DosComLoader   , it  uses information  in the header to do this, whereas DosComLoader     sim  ply  determined  the  stack  from  the process  environment  it  built.  It  also  places the machine context on the stack and transfers control to the loaded  executable image through exec_user     using the same logic as that used  in  DosComLoader   . As you will see next, this common logic is neces  sary for an orderly return.   Returning  From a Process  When  a process completes, it must return to the calling process. How  ever, it does not return directly but exits through DOS-C. For this rea  son,  DOS-C  provides  a  single  function,  return_user    ,  to  handle  process  termination. After  you  examine  this  function,  you  will  better  understand  why  the  process  context  for  starting  a process  requires  a  special stack format. You will also later see how this affects  the system  call interface.   The  return_user     function   Listing 5.18  has two basic purposes.  First,  it  must  systematically  tear  down  the  process  environment  that  DosComLoader     or DosExeLoaderC   built up. Second, it must recover  the  old  process  context  and  restore  it.  In  doing  this,  DOS-C  acts  on  behalf  of  the  terminating  process  and  control  simply  passes  through  DOS-C.   The  first  task  return_user      undertakes  is  to  close  all  files  by  looping  through  the file table  and closing  each file individually.  Next,  return_user     proceeds to return the parent process context. It starts  this  by  restoring  the parent  process  interrupt  vectors  that  were  previ  ously saved in the psp. Next,  return_user     begins to free all process  memory  if  not  a Terminate  and  Stay  Resident   TSR   return.  DOS-C  sets a flag when  a process  returns  through  the TSR  entry  points. This  flag  is  checked  here  to  determine  if  memory  resources  and  the  psp  itself  should  be  discarded.  If  it  is  a  TSR  return,  return_user     bypasses  the  return  of  memory;  otherwise,  it returns  the  environment  first, then the memory block for the process itself.    200 —  The FreeDOS Kernel   Finally,  return_user     reestablishes the parent process as the cur  rent process by restoring the process  segment value as the current pro  cess and restoring the dta  to the parent process' dta. With all this out  of the way, return_user     finally reenters the parent at the point prior  to the system call that started the process by calling  exec__user   .   The  return_user     function.   Listing5.18  VOID  return_user   void   {  psp FAR *p, FAR *q;  REG COUNT i ;    *   Close  all  f o rd  =  0;   f i l es  i  <  20;   DosClosed   ;   i++     * restore parent  p = MK_FP cu_psp, 0 ;   * When process  returns - restore the isv  setvec 0x22, p -> ps_isv22 ;  setvec 0x23, p -> ps_isv23 ;  setvec 0x24, p -> ps_isv24 ;   * And free all process memory if not a TSR return  ifdtsr   {   i f  p  ->  ps_environ   !=   UWORD O    DosMemFree --p  ->  ps_environ ;   DosMemFree --cu_psp ;  }  cu_psp = p -> ps_parent;  q = MK_FP cu_psp,0 ;  dta = q -> ps_dta;  exec_user p -> ps_stack ;    Chapter 6   DOS-C Kernel: API   If you are reading this book sequentially, you started looking at DOS-C  from the bottom up. You studied the lowest levels of the I O portions of  the system by looking at the assembly language interface  to the device  drivers. You explored the buffer  cache and the character canonical pro  cessing. You then discovered the relationships of the lower levels to the  upper managers: the file system manager, the memory manager, and the  task manager.   I  am  going  to  break  that flow now  and  approach  the  system  calls  from  the top down. Why the change you may ask? Up until this point,  the internals were unfamiliar to you and there was no foundation to dis  cuss the higher levels. Now you have a solid foundation  in place, and  you can begin building the structure on top by following  the  specifica  tions  Figure 6.1 .   207    202 — The FreeDOS Kernel   I am now going to discuss the DOS APIs. Although there are a few,  I am going to focus on two: i nt  20h and i nt  21h. These two represent  the two methods used by programs to communicate with DOS and are  the most interesting of the system calls.   Using this approach, the developer who is familiar with the API can eas  ily relate the system call to what is going on under the hood. This approach  also allows the developer who is not familiar with the API an opportunity   Figure 6.1  DOS API functionality  layer.   DOS-Compatible System Calls   DOS API Entry Points   fcbfns   fs   chario   task   memmgr   dosfns   blockio   Task and Process Support Code   execrh   i  r   Device Drivers   Machine Level Support Code    DOS-C Kernel: API — 203   to be  guided  through  it  and  relate  it  to  the  internals. For  developers  in  between  those  levels  of  familiarity,  the  following  discussions  will  serve  both as a refresher and guided tour of the interrelationships.   System  Call Support  Warning:  The code you are about to look at is highly 80x86 depen  dent. The reason is quite simple. Any code that deals with an operating  system call is dependent on the underlying machine architecture. How  ever, the methods used are portable to other processors if you general  ize the technique.   Any  processor  must  have  some  mechanism  to  make  a  call.  For  example,  a  Motorola  680x0  typically  uses  software  exceptions.  The  Intel  80x86 uses two methods. The first method, the call gate, is valid  only  in protected  mode. A particular  memory  location  in the  form  of  cs : i p is dedicated to the system call by placing an entry into a mem  ory-resident table known as the translation lookaside buffer.  The built- in  memory  management  unit  wakes  up  when  a  call  is  made  to  this  address and causes the processor to dispatch the handler for it.   The second method, the software  interrupt, is available in both real  and protected modes. This method relies on a special instruction known  as an  i nt  instruction. It functions  in a way similar to a hardware inter  rupt or exception in that it causes a break in the normal flow of the code  and forces  the processor  to begin  a special piece of code to handle it.  This  instruction  is  usually  followed  by  a  number  that  indicates  what  vector address is to be used. To use it, you place the address of the han  dler into the table location that corresponds to the vector number used.  You use it as a system call by making  assignments  to registers, or an  area of memory, that are specially reserved for the system call, such as  the stack. You then execute the  int  instruction,  and when it returns, a  register or memory location contains the results of the system call.   DOS-C and MS-DOS both use the software interrupt method of sys  tem calls  of which there  are two types. The first type is  simply  a call  that takes no parameters. The Terminate call  int  2Oh  and the Share  Processor call  i nt  28h  are representative of this. The second type is    204 — The FreeDOS Kernel   the more interesting of the two. This type of call takes both register and  memory locations as variables and acts on them. In fact, the most inter  esting example is the  i nt  21 h call, where one register is used to multi  plex between a number of system calls. It is this system call that gives  DOS-compatible operating systems the bulk of their personalities.   Again, I warn the reader that the code you are about to study is very  processor dependent. In fact, DOS-C uses the built-in interrupt  function  declarations that are common to 80x86 C compilers in order to  simplify  the design. However, you can use the same technique — by supplying an  assembly language handler that acts as an interface to the C code — by  saving the context onto the stack, setting the C call frame, performing the  call, and then recovering the context before doing an interrupt return.   DOS-C has two simple system calls to handle program termination.  One is the Terminate call where the program loses all its resources and  returns to the parent program. The other is the Terminate and Stay Res  ident call where the program  again returns to the parent program, but  all memory resources remain intact. This type of program is the equiva  lent of  a daemon  process that is used  in other  operating  systems. The  differences  between the two are minimal.   The function  int20_handl er     Listing 6.1   is a very  simple  func  tion terminate function. First, it sets the flag ts r to  FALSE in order to dif  ferentiate  between  a normal exit and a TSR exit. This is the same flag  you saw in the task manager in Chapter 5. It then calls DosMemCheck      Listing 6.1  The  int20_handler     funtion.   VOID  INRPT  far  int20_handler    i nt   es,  i nt  ds,  i nt  d i,   i nt  s i,   i nt  dx,   i nt  ex,  i nt  ax,  i nt   i nt  bp,  i nt  sp,  i nt  es,   i p,   i nt  bx,   i nt   flags    {   }   tsr  =  FALSE;  DosMemCheck  ;  return_user  ;    DOS-C Kernel: API — 205   from  the memory  manager to guarantee that the memory  arena is still  intact since DOS-C cannot function reliably if the memory arena is cor  rupted. It finally calls  return_user     from  the task manager in order  to terminate the task.   In the case  of  this  system  call, the  only  function  an  assembly  lan  guage interface needs to perform is setting up the C call frame. As you  can see from the function, none of the machine registers are used. How  ever, this is not the case in the function  i nt21_handl er   .   In DOS-C, the  int  21 h handler is divided into two functions   Fig  ure 6.2 . The first is  int21_handl er      Listing 6.2 . This is the  func  tion  whose  address  is  placed  into  the  int  21 h vector.  It  starts  by  incrementing  the  In DOS  flag.  This  flag  indicates  to  DOS-C  that  it   Figure 6.2  System call flow.  User code   Kernel code   mov  dl, 'A'  mov  ah, 2  int 21h  mov  dl ,  'B'   Converts system  call to C call   C function  to dispatch    206 — The FreeDOS Kernel   received an interrupt from within the kernel. It causes some functions to  execute  differently  in  order  to  guarantee  a certain  degree  of  reentrant  functionality.  It  next  creates  a  pointer  from  the  system  call  frame,  user_r.  This  pointer  is  an  important  structure,  iregs,  that  describes  the interrupt stack frame  and becomes the primary means of communi  cation between the kernel and the user functions. All register references  into and out of the kernel are contained on this stack. It is a fa r pointer  because the context is contained  within the executing program's  stack  space, again contributing to a reentrant design. With the machine con  text  in  place,  int21_handl er      switches  from  the  user  stack  to  the  kernel stack by calling  s e t_s t a c k    . At this point,  int21_handler    has created the kernel  environment.  It calls  int21_service     to dis  patch the function  call and passes  user_r,  the pointer to the  interrupt  context, to allow the functions  that were dispatched to access and mod  ify  the user's registers. When the system call has been completely  ser  viced, int21_handler     calls  restore_stack     to switch back to the  user stack, decrements  InDOS, and returns.   One note about this function.  Most, if not all, of the 80x86 C com  pilers  support  the  special  function  type  interrupt.  When  a function  is  declared  as  a  type  interrupt,  the  compiler  automatically  places  extra  code to save all the machine registers. It does this in a particular order.  To simplify  the  switching  of tasks, DOS-C  uses this register  order  to   Listing  6.2  The  int21_handler     function.   VOID  INRPT  far  int21_handler     i nt   es,  i nt  ds,  i nt  d i,   i nt  s i,   i nt  dx,   i nt  ex,  i nt  ax,  i nt   i nt  bp,  i p,   i nt  sp,  i nt  es,   i nt  bx,   i nt   flags    i   }   ++InD0S;  user_r  =   iregs  far  * &es;  set_stack  ;  int21_service user_r ;  restore_stack  ;  --InDOS;    DOS-C Kernel: API — 207   save both  user  and  kernel  context,  as  well  as  the  register  context  for  starting a program  Figure 6.2 . This allows a single structure  definition  for  all  process-related  functions,  including  system  calls.  It  also  adds  additional  instructions  to  establish  the  data  section  for  the  function.  With all this out of the way, it finally creates the stack frame  for the C  call and begins its work.   Listing  6.3  A sample C interrupt  function  handler  and assembly   language  equivalent.   int21   Jiandler     i nt   es,  i nt  ds,  i nt  d i,  i nt  bx,   i nt  dx,  i nt   flags    i nt  ex,  i nt  ax,  i nt   i nt  s i,   i nt  bp,  i nt  sp,  i nt  es,   i p,   cs:_TEXT  far  proc   assume   _int21_ha  push  push  push  push  push  push  push  push  push  mov  mov  mov   ndler  ax  bx  ex  dx  es  ds  si  di  bp  bp,DGR0UP  ds,bp  bp,sp   {   ++InD0S;   ine   word  ptr  DGR0UP:_InD0S   user_r  =   iregs  far  * &es;   lea  mov  mov   [bp]   ax,word  ptr   word  ptr  DGR0UP:_user_r+2,ss  word  ptr  DGROUP:_user_r,ax    208 — The FreeDOS Kernel   You will  notice  when  examining  the translated  statements   Listing  6.3  that in the assignment of the user context  far  pointer,  user_r,  the  compiler is aware that the registers are passed on the stack and uses  ss   Listing  6.3  A sample C interrupt  function  handler  and assembly   language equivalent —  continued.   set_stack  ;   call   near  ptr  _set_stack   int21_service user_r   ;   push  push  call  pop  pop   word  ptr  DGROUP:  user  r+2  word  ptr  DGROUP:_user_r  near  ptr  _int21_service  ex  ex   restore_stack  ;   call   near  ptr  _restore_stack   --InDOS;   dec   word  ptr  DGR0UP:_InD0S   bp  di­ si  ds  es  dx  ex  bx  ax   pop  pop  pop  pop  pop  pop  pop  pop  pop  i  ret  _int21_ha   ndler   endp    DOS-C Kernel: API — 209   for  the  segment  portion  of  the  pointer.  This  assignment  allows  the  stack to be switched in the very next statement with no adverse  effects  on the code.   The final aspect of  i nt21_handl er     to note is the exit. Upon ter  minating  the  function,  the  C  compiler  generates  code  to  recover  the  context  from  the  stack.  This  is  the  reason  you  needed  to  recover  the  user  stack  before  returning.  Also,  the  compiler  generates  an  i ret  instead of the normal  ret  instruction to return from  the interrupt. This  makes the function  a full interrupt handler in its own right, without ever  having to resort to assembly language. These features may not be avail  able for your C compiler or platform, but the code presented in Listing  6.2 should be used as a guide to your own specialized  interrupt system  call handler.   Once safely  within kernel  space,  int21_service     is the  function  that  actually  handles  the  system  call   Listing  6.4 .  It is  arranged  as a  switch  statement based  on the contents  of the  ah register. It  accesses  the  ah register through the  i regs  far  pointer  ras  r  ->  AH. This is  important to note because all registers are accessed in this fashion  and  are part of the user context as explained earlier.   Listing  6.4  An  abbreviated  int21_service     function.   VOID  int21_service iregs  r  l   far  * r    COUNT  re,  r c l;  ULONG  I r e;    *  The  dispatch  handler   ifdef  DEBUG   if bDumpRegs   i   fbcopy  VOID  FAR  *   r,  s i z e o f   i r e g s    ;   printf "System  call  dump_regs  =  TRUE;  dumpO;    VOID  FAR  * &error_regs,    21h :  %02x\n",  r  ->  AX ;   }   *     Listing  6.4  An abbreviated  intZl_service     function  —   210 — The FreeDOS Kernel   continued.   endif   switch r  -> AH   i   *  p r i nt  unused  and  f a ll  default:  ifdef  DEBUG   into  terminate   debug  only    *    fbcopy  VOID  FAR *   r,   VOID  FAR  * &error_regs,   s i z e o f   i r e g s    ;   printfC'Inval  id  system  call  dump_regs  = TRUE;  dumpO;    21 h \n"  ;     i f d ef  KDB   break;     endif  else   endif   r  ->  AX =  - r e;  r  ->  FLAGS  =  FLG_CARRY;  break;    *   Terminate  Program  case  0x00:   tsr  =  FALSE;  returnjnode  =  break_fl g  ?  1  :  0;  return_code  =  r  -> AL;  DosMemCheck  ;  return_user  ;  break;    *  Read  Keyboard  with  Echo  case 0x01:   r  ->  AL =  DosCharInputEcho  ;  break;    *  Displa y  Character  case  0x02:   DosDisplay0utput r  ->  DL ;  break;   *    *    *     DOS-C Kernel:  API—211   The switch has a default handler up front. By specification, the carry  flag is  set  on  an  invalid  system  call  and the  default  case  handles  this  condition.  It  also  has  a bit  of  debugging  logic  worked  in  to  assist  in  determining  DOS  compatibility.  It  is  switched  in  by  defining  DEBUG  during compilation.   The rest of the switch is simple, although the cases are numerous. In  each case, much of the manipulation of registers is done within the case   Listing  6.4  An  abbreviated   int21_   service      function  —   continued.   case  OxOf:   if FcbOpen MK_FP r  ->   DS,  r  -  >  DX      r  ->  AL  =  0;   r  ->  AL  =  Oxff;   else   break;   r  ->  AL  =  0;   r  ->  AL  =  Oxff;   else   break;   case  0x10:   if FcbClose MK_FP r  -  >  DS,  r   ->  DX      case  0x14:   r   COUNT  nErrorCode;   if FcbRead MK_FP   r  ->  AL  =  0;   else   break;   }   r  ->  AL  =  nErrorCode   r  ->  DS   r  ->  DX    ,  &nErrorCode      272 — The FreeDOS Kernel   itself. The case sets up either to complete the entire call itself,  such as  in the CP M compatibility functions  0x18, Oxld, Oxle, and 0x20, or to  make  a function  call  to  a handler  for  that  system  call.  Sometimes  it  requires  setting  up local  variables,  at which  time  the case  is  a com  pound statement. In almost all cases, the case exits through a brea k but  not  until  it  performs  some  error  processing.  Unfortunately,  the  error  processing  must be done within the case because MS-DOS has  differ  ent error returns for groups of system calls.   Listing  6.4  An abbreviated  int21_service     function  —   continued.    *  CP M  compatibility   functions   case  0x18:  case  Oxld:  case  Oxle:  case  0x20:   r  ->  AL  =  0;  break;    *  Pars e  File  Name  case  0x29:   {   BYTE  FAR  *lpFileName;   ->  AL  =  FcbParseFnameO  ->  AL,   IpFileName  =  MK_FP r  ->  DS,  r  ->  S I  ;  r  &lpFileName,  MK_FP r  ->  ES,  r  ->  D I    ;  r  r   ->  DS  =  FP_SEG lpFileName ;  ->  SI  =  FP_0FF lpFileName ;   }  break;    DOS-C Kernel: API — 213   Examine  a  few  of  the  system  calls.  Perhaps  the  simplest  function  call that dispatches into the kernel is Read Keyboard with Echo,  func  tion  0x01.  In  this  function  call,  the  al  register  returns  a  character  entered at the keyboard after echoing it to the display. DOS-C provides  the  function  DosCharlnputEchoO  to perform  this  function.  The  ser  vice code for the system call is a simple call to  DosCharInputEcho     and  an  assignment  of  the  return  to  r  ->  AL. Because  no  error  is  returned by this system call, it just terminates with a brea k to end sys  tem call processing.   Another  example  with  more  functionality  is  the  Display  Character  call,  function  0x02. For this  function,  the character  to be  displayed  is  passed in the dl  register. To provide this functionality,  DOS-C provides  the function  call  DosDisplayOutputO,  which takes  a single parame  ter: the character to be displayed. The call is invoked with the argument  r  - >  D L in order to retrieve the character from the user's d 1  register.   Listing  6.4  An  abbreviated   int21_   _service     function  —   continued.    *  Dos   Open   case  0x3d:   *    i f     rc  =  DosOpen MK_FP r  i   r  r   ->  AX  =  - r e;  ->  FLAGS   =  FLG_CARRY;   ->   DS,   r   ->  DX ,  r   ->  A D   <   0    else  i      break;   r  r   ->  AX  =  r e;  ->  FLAGS  &=  ~FLG_CARRY  '    214 — The FreeDOS Kernel   Listing  6.4  An abbreviated  intZl_service     function  —   *    *    continued.    *  Dos   Close  case  0x3e:   i f     r c  =  DosClose r  ->  BX    <  0   i   r  ->  AX  =  - r e;  r  ->  FLAGS  =  FLG_CARRY;   r  ->  FLAGS  &=  ~FLG_CARRY;   else   break;    *   Dos  Read   case  0x3f:    COUNT  FAR  *   & r c l  ;   !=  SUCCESS    r  ->  FLAGS  =  FLG_CARRY;  r  ->  AX  =  - r c l;   r  ->  FLAGS  &=  -FLG_CARRY;  r  ->  AX  =  r e;   i f   r cl  i   j  else  r i   i     break;   re  =  DosRead r  ->  BX,  r  ->  CX,  MK_FP r  ->  DS,  r  ->  DX ,    i f d ef   DEBUG   if bDumpRegs   i   i    endif  }   p r i n t f   " E x i t i ng  system  call  fbcopy  V0ID  FAR  *   r,  s i z e o f   i r e g s    ;    21h \n" ;    VOID  FAR  ^ &error_regs,   dump_regs  =  TRUE;  dump  ;  p r i n t f   " - - - \ n "  ;    DOS-C Kernel: API — 215   A somewhat more complicated system call is Parse File Name, func  tion  0x29. In this  function,  the filename to be parsed  is  at the  address  given by  ds : si  in the user registers, and the parsing is controlled by a  flag in the a 1  register. The function returns the next byte in the user's ds  and s i registers, after the parse terminates, and a result flag in the a 1  reg  ister. In this example, you have local storage in the form of 1 p Fi 1 e Name  and  data  transfers  between  internal  functions  and  user  registers.  This  type of function  is much more common throughout DOS-C.   Our final example requires looking at two function  calls, Dos Open,  function  0x3d,  and  FCB  Open,  function  0x0f.  These  functions  illus  trate the logic behind two of the error returns in DOS-C. Both  functions  retrieve their  arguments  from  user registers  in  a manner  already  seen.  However,  both  functions  have  error  returns.  For  FcbOpenO,  a  false  return indicates an error. However, the system call returns an error con  dition  in  al.  In  order  to  accommodate,  the  case  examines  the  return  from  the  function  call  and  assigns  the  correct  value  using  an  if.  . .els e  construct.  However,  the  function  Dos Open     returns  not  only  an error  condition  by returning  a negative  number,  but returns  a  handle, which is a positive integer for successful  completion. The spec  ifications for this function  call require that ax contains either the handle  or  an error  number. The carry flag is checked  to detect  an error. This  technique is much more common for the later system calls. Again, the  case  makes  a call to  DosOpen     and uses  an  if..  .el se  construct  to  build the correct return. However, there are several differences  between  FcbOpen    and DosOpen   .The  DosOpen    test within the if statement  is  for  negative  numbers. Also, the  returned  value  is  always  in  the  ax  register  and accessed through  r  ->  AX, although the sign of the error  must  be  changed.  Additionally,  the  carry  flag  is  definitively  set  or  cleared.   Although these are the highlights of  i nt21_servi ce   , the system  calls  examined  provide  insight  into the  steps required  to convert  an  int  21 h call  into  a C function  and vice versa   Figure  6.2 .  Unfortu  nately, each system call must be handled in a unique manner because of  the way MS-DOS  handles each call. But the overhead  is minimal  and  the resulting  compatibility  far  outweighs the headaches. Other  system  calls are a variation of the two examined here and you are encouraged  to study them and expand on them for your own applications.    216 — The FreeDOS Kernel   DOS-C Personality  Layer  If you have been  following  the  system calls, you will notice that they  call  functions  that  you  have  not  yet  encountered.  The  reason  is  that  there  are  functionality  layers  between  the  core  DOS-C  functions  and  the system calls   Figure 6.3 . These functionality  layers fall  into three  categories: simple I O, FCB calls, and DOS calls. I will examine each  of these three and study the relationships between the system calls and  the core DOS-C  functions.   Figure 6.3  FCB and DOS call functionality  layers.   DOS-Compatib le System Calls   DOS API Entry Points   fcbfns   fs   chario   task   memmgr   dosfns   blockio   Task and Process Support Code   execrh   i  f   Device Drivers   Machine Level Support Code    DOS-C Kernel:  API—217   Simple I O  Support  Start by looking at the simple I O functions. A number of them support  the  console,  an  auxiliary  device,  and  a printer.  These  are  direct  calls  down to either the device drivers or a DOS support function. They may  not need translation and are sometimes simply links from the  i nt  21 h  system call to the device driver.   The function  DosCharInputEcho      Listing 6.5  is an example of sim  ple I O functions. It builds a request in the local variable rq, calls execrh   ,  and  handles  errors  through  char_error    should  any  occur.  It  then  exits but not before calling DosCharOutputOto echo the character.   The  function  DosDispl ayOutput       Listing  6.6   is  another  exam  ple,  although somewhat more complex. This function  does some output  formatting. It checks for a return, delete, backspace, and horizontal tab.  In each case except tab, it updates internal screen parameters then calls  DosCharOutputOto  output the character to the screen. Tab repeatedly  calls DosCharOutputO  to output a space until the screen position vari  able scr_pos  is a multiple of eight. This algorithm is how DOS-C per  forms tab expansion.   function.   Listing  6.5  The DosCharInputEcho    int DosCharlnputEcho VOID   {   BYTE cb;  request rq;  rq.r_length = sizeof request ;  rq.r_command = C_INPUT;  rq.r_count = 1;  rq.r_trans =  VOID FAR * &cb;  rq.r_status = 0;  execrh  request FAR * &rq, syscon ;  if rq.r_status & S_ERR0R   DosCharOutput cb ;  return cb;   return char_error &rq, con_name ;   }    218 — The FreeDOS Kernel   There are other simple I O functions, but by now you should under  stand  how  these  functions  work.  I  urge  you  to  look  at  the  file  i nthndl  r. c to further  study these  functions.   Listing 6.6  The DosDispiayOutputC   VOID DosDisplayOutputCCOUNT c   {   * Non-portable  construct  if c < ' '  c == 0x7f    function.   0;   switch c   {  case '\r':  scr_pos =  break;  case 0x7f:  ++scr_pos;  break;  case '\b':   if scr_pos  --scr_  break;  case '\t':   do  DosCha  while scr_  return;   > 0   .pos;   r0utput '  7 ;  .pos &   break;   default:  }  DosCharOutput    O;   DosCharOutput    O;   } el  se  {    DOS-C Kernel: API — 219   DOS Function  Support  The next logical  area to examine is the DOS Function  Support,  which  includes functions  that give DOS system calls, such as Make Directory,  Open, etc., their functionality.  These system calls typically work with a  structure known  as a system file table   SFT . Each entry is defined  as  the data structure sft  in DOS-C.   The  sft  data  structure   Listing  6.7   is  key  to  both  DOS  and  File  Control Block  FCB  support functions. Although DOS-C does not use   Listing  6   . 7  The s ft  data  structure.   t r u ct  S   dpb  FAR   _sft_dcb;   s t r u ct  dhdr   FAR  *   *  1*   typedef  s1  i   :ruct   sft_count;  sft_mode;  s f t _ a t t r i b;  s f t _ f l a g s ;   WORD  WORD  BYTE  WORD  union  r  l   _sft_dev;  _dcb_or_dev;  s f t _ s t cl   ust;  s f t _ t i m e;  s f t _ d a t e;  s f t _ s i z e;  s f t _ p o s i t;  s f t _ r e l cl   ust;  sft_cucl  ust;  s f t _ d i r dl  ust;  s f t _ di  r i d x;  s f t _ n a m e [ l l ];  FAR  *  s f t j o s h a r e ;  sft_mach;  sft_psp;  s f t _ s h r o f f;  s f t _ s t a t u s;   }  s ft  WORD  time  date  LONG  LONG  WORD  WORD  WORD  BYTE  BYTE  BYTE   WORD  WORD  WORD  WORD   }  s f t;    *   *   *   *   reference  count  open  mode  -  see  below  f i le  a t t r i b u te   flags   -  see  below   -  d ir  s t y le   The  device  control  block   device  d r i v er    f or  char  dev   S t a r t i ng  c l u s t er  F i l e  time  F i le  date  F i l e  size  Current  f i le  p o s i t i on  F i le  r e l a t i ve   c l u s t er  F i le  current  c l u s t er  Sector  containing  c l u s t er  d i r e c t o ry  d ir  s t y le   index  f i le  name   backward  l i nk  of  f i le  sharing  s ft  machine  number  -  network  apps  owner  psp  Sharing  o f f s et  t h is  s ft   status    *   1*   *   *  1*   *   *   *  1*  1*  1*   1*  1*  1*  1*  1*   *   *   *   *    *    *    *   *   *   *   *   *   *   *   *   *    *   *   *   *   *     220 — The FreeDOS Kernel   sf t  for file operations, it maintains it for compatibility with MS-DOS.  Although  sft  is well known and used by many DOS applications, it is  one of the  "undocumented"  data  structures. It is useful  to explain  the  SFT to better understand the DOS and FCB support  functions.   There is one entry for each open file in the system. This is the same  as  MS-DOS. Where  DOS-C  differs  from  MS-DOS  is  that  it  links  an  f_node  to each SFT entry. This allows us to use the file system man  ager in place of DOS-specific file system code.   Review  the  sft  so you  better  understand  how  to  use  it  within  the  interface level. Each structure starts with the member sf t_count,  a ref  erence count. This entry represents the number of file handles that refer  to the file. In DOS-C, you maintain this entry and declare the SFT entry  free  when  sft_count  contains  0. This is the only real  structure mem  ber  that  is  used  for  SFT  maintenance.  The  rest  of  the  structure  is  devoted to the file.   The first of the file-related members, sf tjnode, contains the mode the  file  was opened in  e.g., read, write, etc. . It is identical to the mode word  passed as an argument to the Dos Open     system call  i nt  21h function  3dh . The attribute of the file, as stored in the directory, is stored in the  structure member sf t_attri  b. In DOS-C this entry is updated for appli  cation  purposes  only  because  the real file attribute  is  derived  from  the  f_node.  Also  associated  with  file  functionality  is  sft_flags,  which  holds a set of flags that determine the attributes of the open file. If the file  is a character device, this member determines whether it is a console or  null device, or whether the file should return an EOF condition. If it is a  block device, it contains information such as the block device number and  network file or drive information.   Following  sft_flags   is  sft_dcb_or_dev.  This  union  holds  the  far  pointer  _sft_dcb,  which  points  to the  device  control  block,  and  the f a r pointer _sf t_dev, which points to the device driver for a char  acter device. DOS-C uses this member whenever the file is a character  device.  For  block  devices,  it  maintains  the field but  uses  the  f_node  information  instead. Again,  although  DOS-C  does not  actively use an  entry, it is important that the entry is maintained for compatibility.    DOS-C Kernel: API — 221   The same is true for a number of file-related entries in the sf t. These  members, which I will briefly  discuss next, are not used by DOS-C but  are  maintained  for  compatibility.  They  are  sft_stclust,  sft_time,  sft_date,  sft_relcl  ust,  sft_cucl  ust,  sft_di  rdl ust,  sft_di  ridx, and sftjname.  These members all have a  corresponding entry within the  f_node.   sft_posit,   sft_size,   The  remaining  members  are  used  for  remote  and  shared  applica  tions.  Both  members  sft_shroff  and  sft_bshare  are  used  by  share.exe  for  file-sharing  purposes.  sft_bshare  contains  the  back  ward  link  of  the  file-sharing  SFT, and  sft_shroff  holds  the  sharing  offset.  The  remaining  entries, with  the  exception  of  sft_status  and  sft_psp,  deal  with  network  files.  The  member  sftjnach  is  used  to  hold the machine number for network applications.   In order to identify  the owner of the file, sf t_psp  contains the Pro  gram Segment Prefix   PSP  of the owner. This field is actively used by  DOS-C for the same purposes. Finally, sf t_status  contains the status  of this SFT. In the case of DOS-C, it is actually the index of the corre  sponding  f_node  in the  f_node  table  and is the link between the  sft  and the  f_node.   With the knowledge of the underlying  sft  data structure, now look  at the DOS personality functions.  The first function  you will look at is  DosOpenO.Itis representative of the personality functions that allocate  an SFT. The method you will use is the same as you have used before:  follow  a  typical  sequence  of  open,  read,  and  close  and  look  at  the  details along the way.   DosOpen     Listing 6.8   starts by checking for valid arguments. As  you have seen before, this is a necessary step to prevent the propagation  of an error that may crash the system. For this function,  the only test is  a check to see if the mode argument is within range.    222 — The FreeDOS Kernel   Next,  Dos Open     proceeds  to open the file. First  it must  get  a  free  handle. It checks the return to make certain that the handle was actually  allocated. If not, it returns an error. Once it gets a handle, it has to get  an SFT entry, again checking for an error.   Once  resources  have been  allocated,  DosOpen      must  check  for  a  device. The  way  DOS-C  handles  the file is  dependent  on  whether  or  not the name specifies  a disk file or a device. If it is a device, the sf t  is   Listing  6.8  The DosOpen     function.   COUNT  DosOpen  r  i    BYTE  FAR  * f n a m e,  COUNT  mode    psp  FAR *p  =  MK_FP cu_psp,0 ;  WORD hndl ,  sft_idx;  sft  FAR  * s f t p;  struct  dhdr  FAR  *dhp;  BYTE  FAR  * f r o o t;  BYTE  buff[FNAME_SIZE+FEXT_SIZE];  WORD  i;    *  test   if  mode  is  in  range  if  mode  &  SFT_0MASK   1=  0    return  DE_INVLDACC;    *  get  a  free  handle  if  hndl  =  get_free_hndl      ==  Oxff    return  DE_T00MANY;   return  DE_T00MANY;    *  check  for  a  device  froot  =  get_root fname ;  f o r  i  =  0;  i  <  FNAME_SIZE;  i++   r  1   i f d f r o ot  1=  ' \ 0'  &&  *froot  1=  ' . '   else   b u f f [ i]  =  *froot++ ;   break;   }     *  now  get  a  free  system  f i le  i f     s f tp  =  get_free_sft  WOR D  FAR * &sft_idx    =   table  entry   *   =   sft  FAR  *   - l    *    *    *     DOS-C Kernel: API — 223   Listing  6.8  The  DosOpenO  function  —  continued.   for   ; i < FNAME_SIZE; i++    buff[i] = ' ' ;    * if we have an extension, can't be a device  if *froot  1=  ' . '  ;  {   for dhp =  struct dhdr FAR * &nul_dev; dhp 1=  {    struct dhdr FAR * -l; dhp = dhp -> dh_next   if fnmatch  BYTE FAR * buff,  BYTE FAR * dhp ->   *    {   dh_name, FNAME_SIZE, FALSE    sftp -> sft_count += 1;  sftp -> sft_mode = mode;  sftp -> sft_attrib = 0;  sftp -> sft_flags =    dhp -> dh_attr & ~SFT_MASK   SFT_FDEVICE   SFT_FE0F;   sftp -> sft_psp = cu_psp;  fbcopy  BYTE FAR * buff, sftp -> sft_name,  sftp -> sft_dev = dhp;  p -> ps_filetab[hndl] = sft_idx;  return  hndl ;   FNAME_SIZE+FEXT_SIZE ;   }   }   }  sftp -> sft_status = dos_open fname, mode ;  if sftp -> sft_status >= 0   {   p -> ps_filetab[hndl] = sft_idx;  sftp -> sft_count += 1;  sftp -> sft_mode = mode;  sftp -> sft_attrib = 0;  sftp -> sft_flags = 0;  sftp -> sft_psp = cu_psp;  fbcopy  BYTE FAR * buff, sftp -> sft_name,  return  hndl ;   FNAME_SIZE+FEXT_SIZE ;   }  else   }   return sftp -> sft_status;    224 — The FreeDOS Kernel   initialized  and the member  sf t_f 1 ags  is set to indicate this. Also, the  member  sft_dev  is initialized  to point to the character  device  driver.  This  is  the  switch  between  character  and file types.  Device  indepen  dence is also achieved by this, since the entry  and  all following  func  tions deal with the driver in an identical  fashion.   If  the  name  did  not  specify  a device,  DosOpen      proceeds  to  call  dos_open     to open the disk file. The return from this call is stored in  sf t_status  and tested for an error. If no  error occurred, this entry is now  the link between the s ft  and the f_node.  For a successful  disk file open,  the s ft  is initialized, and the function returns the handle for this open.   Once a file is opened you can proceed to read from it. The DOS per  sonality  function  that  supports  the  system  call  is  Dos Read       Listing  6.9 . This function  handles both device and file access exactly the same  way.  For  every  call,  Dos Read     tries  to  read  the  number  of  bytes  requested. It will continue to read bytes for every subsequent call until  an EOF condition occurs, at which time it returns 0 bytes read.   Listing 6.9  The Dos Read     function.  UCOUNT  DosRead   COUNT hndl , UCOUNT n, BYTE FAR *bp, COUNT FAR  {   *err    sft FAR *s;  WORD sys_idx;  sfttbl  FAR *sp;  UCOUNT ReadCount;   * Test that the handle is valid  if hndl < 0   {   *err  = DE_I NVLDHNDL;  return 0;   }   * Get the SFT block that contains the SFT  if  s = get_sft hndl   ==  sft FAR * -l   {   *err  = DE_I NVLDHNDL;  return 0;   }   *    *     DOS-C Kernel: API — 225   The algorithm for  Dos Read     starts in a way similar to other DOS-C  system calls. It begins by validating the arguments passed to it. In this  case,  it  verifies  that  the  handle  passed  by  the  user  is  valid  or  at  least  within range. Next, it gets the SFT block that corresponds to the handle  and checks if it is valid. If not, it returns  an error indicating  an invalid  handle. The final check is for permissions. If the file is not open or does  not have write permission,  Dos Read     exits  and returns  an error  code  indicating that this was an invalid file access.   Next it checks structure member  sf t_f 1 ags  to see if the  sf t  refers  to a device. If the  sf t  does refer to a file, Dos Read     proceeds to do a  device read.  Dos Read     first tests for end-of-file  and exits immediately  if it is. This prevents  Dos Read     from going any further  if the device is  no  longer  open  or  cannot  produce  more  data.  Next  it  handles  raw   binary  and cooked  command line edit  modes. It examines the struc  ture member  sft_f  1 ags  to see if  SFT_FBINARY is set. This flag differ  entiates between the two modes. If it is set, Dos Read     performs a direct   Listing  6.9   The Dos Read      function-  —  continued.    *   If   n<   Dt  open  or  write  permission  -  exit   ->   sft_count  =  0      s  ->  sft_   .mode  &  SFT_MWRITE     *err  =  DE_INVLDACC;  return  0;   device  read  if  device  sft_flags  &  SFT_FDEVICE    uest  rq;   i f  s  r  i   }   *  Do a  i f  s  ->  1  i   req   *  i f   r i   }   First  test  for  eof  and  exit  . s  ->  sft_flags  & SFT_FE0F    'mmediately   s  ->  sft_flags   if   is   it  & SFT_      *    _FNUL     s  ->  sft_flags  &=  ~SFT_FE0F  *err  =  SUCCESS;  return  0;   *    *     226 — The FreeDOS Kernel   driver call that attempts to read the number of requested bytes. On return  from  the  device  driver  call,  Dos Read      examines  the  request  packet  for  errors  and  invokes  the  error  handler  if  an  error  occurred.  If  no  error occurred, it returns the number of bytes the driver actually read.  DosReadO  gets  this  from  the  request  header  structure  member  r_count.  In this way, the device driver controls the transfer.  This is an  excellent way to perform direct reads and writes to a device.   Listing  6.9  The  Dos Read    function  —  continued.    *  Now  handle  raw  and  cooked  modes   *    ->  sft_flags  &  SFT_FBINARY    i f  s  {   rq.r_length  =  sizeof request  ;  rq.r_command  =  C_I NPUT;  rq.r_count  =  n;  rq.r_trans =  BYTE FAR * bp;  rq.r_status = 0;  execrh  request FAR * &rq, s -> sft_dev ;  if rq.r_status & S_ERR0R   {   REG i;  BYTE buff[FNAME_SIZE+l];  fbcopy s -> sft_name,  BYTE FAR * buff,  buff[FNAME_SIZE+l] = 0;  for i = FNAME_SIZE; i > 0; i--   if buff[i] == ' '   else   FNAME_SIZE ;   buff[i] = 0;  break;   char_error &rq, buff ;   }  else  {   }   }   *err  = SUCCESS;  return rq.r_count;    DOS-C Kernel: API  —227   If  SFT_FBINARY  is  not  set,  Dos Read     proceeds  to  read  from  the  device in a "cooked" mode, i.e., the characters  are processed  for  break  detection, flow control is enabled, etc. There are two possible ways to get  the data in this  mode. The first is  an  attempt  to read  directly  from  the  standard  input  device.  Dos Read     examines  the  sft  structure  member  sf t_f 1 ags to see if SFT_FSTDI N is set. If it is, it calls sti      to complete   Listing  6.9  The  Dos Read    function  —  continued.   else  i f  s   {   ->  sft_flags  &  SFT_FSTDIN    if !check_break     {   kb_buf.kb_size = LINESIZE - 1;  kb_buf.kb_count = 0;  sti  keyboard FAR * &kb_buf ;  fbcopy  BYTE FAR * kb_buf.kb_buf, bp,  kb_buf.kb_count ;  *err  = SUCCESS;  return kb_buf.kb_count;   }  else  {   }   }  else  {   *err  =  SUCCESS;  return  0;   if !check_break     {   *bp  =  _ s t i    ;  *err  =  SUCCESS;  return  1;   else   *err  = SUCCESS;  return 0;    228 — The FreeDOS Kernel   the read and returns the number of bytes read. If not, it calls the device  driver support function  and exits with the number of bytes read. The sec  ond way to get the data in a "cooked" mode is as an attempt to read from  a device driver and _sti      is called instead.   When it is not a device driver,  DosOpen     relies on  rdwrbl ock    to  perform  the file read,  returning  the  count  or  an  error  condition  if  an  error occurs. In this context,  DosOpen    is simply a pass through to the  f s support function  call that was covered in detail in Chapter 4.   When  you  are  through  with  the  file,  you  must  close  it  and  return  resources back to DOS-C. Dos CI ose     is the DOS personality  function  that implements the Close system call. It performs  in a fashion  similar  to other calls you have seen.   Listing 6.9  The Dos Read    function  — continued.   else  {   if !check_break     {    * a block read   COUNT re;  ReadCount = rdwrblock s -> sft_status, bp,  n,  if rc != SUCCESS   {   XFR_READ, &rc ;   *err =  pc;  return 0;   else   *err = SUCCESS;  return ReadCount;   else   *err = SUCCESS;  return 0;   *err = SUCCESS;  return 0;    DOS-C Kernel: API — 229   As  you  have  seen  before,  DosCloseO   Listing  6.10   first  verifies  that the handle is valid or within range. Next, it gets the SFT block that  corresponds  to the handle. If it is not a valid handle, it returns  a DOS  error indicating that the handle is invalid. In order to close the file, the   Listing  6.10  The DosClose     function.   COUNT  DosClose  i    COUNT  hndl    psp  FAR  *p  =  MK_FP cu_psp,0 ;  s ft  FAR  * s;    *  Test   t h at  if hndl  <  0    the  handle   is  v a l id   return  DE_INVLDHNDL;    *  Get  the  SFT  block  that  contains  the  SFT  i f    s  =  get_sft hndl    ==    s ft  FAR  *   - l    return  DE_INVLDHNDL;   is  not  opened  another  error*    If     *  i f  s   this  ->  sft_count  ==  0   return  DE_ACCESS;    *  now  just  drop  the  count  if  a  device,  else   *  call  i f  s  r  l   ->  sft_flags  &  SFT_FDEVICE    f i le  system  handler   p  ->  ps_filetab[hndl]  =  Oxff;  s  ->  sft_count  -=  1;  return  SUCCESS;   p  ->  ps_filetab[hndl]  =  Oxff;  s  ->  sft_count  -=  1;  i f  s   - >  sft_count  >  0   return  SUCCESS;   else   return  dos  close s  ->  s ft  status ;   j  else  r  l   }   }   *    *    *   *     230 — The FreeDOS Kernel   final test  verifies  that  the file is  open,  so  that  you  do  not  incorrectly  return  resources  that  were  not  allocated,  potentially  crashing  DOS-C.  So, if the file is not open, you return an invalid access error.   Now examine whether or not the file is a device. If it is, Dos CI ose      just  decrements  the  SFT count. This  allows  devices to be opened  and  shared by duplicating the handle using the Duplicate  system call. Oth  erwise, it calls the file system handler to close the disk file.   This function  completes the tour of the DOS personality  functions.  This gives you a good idea of how to give a system call a particular fla  vor. I will now look at the other DOS-C personality function  set.   FCB  Function  Support  I  will  now  examine  the  File  Control  Block  or  FCB  function  calls.  These calls provide the old CP M-style FCB function  call personality.  Their design is similar to the DOS function  calls. Both are layers that  perform the direct function  of the matching system call. Also, both cre  ate a translation  service into the three managers: file system, task, and  memory.   The FCB function  calls also rely heavily on a kernel data structure.  The difference  is that this structure does not exist solely within the ker  nel, but  is resident  in user  space. This places  some  additional  restric  tions on DOS-C. All designs of FCB support functions  must allow  for  users to modify the FCB or complete an operation without a logical ter  mination, i.e., open a file but never close it.   The FCB is a well-known MS-DOS data structure. It is inherited  from  its CP M ancestor  and retains many fields that are similar to its CP M  counterpart.  It  also  forms  the basis  for  the  DOS-C  f cb  data  structure   Listing  6.11 .  It  is  important  that  this  data  structure  closely  matches  the MS-DOS  version  because  it is the  only  means  of  communicating  file-related information  for the FCB system calls.   Structure member  f cb_dri ve contains the drive number for the file.  By convention, the drives are mapped as 0 = default,  1 = A, etc. The file  name  is contained  in two  members:  fcb_fname  and  f cb_f ext.  These  are  left-aligned,  space-filled  representations  of  the  traditional  DOS    DOS-C Kernel: API — 231   f i l e,  ext  filename. The next structure member, f cb_cubl ock, contains  the current file position represented as a block number where the block is  defined  as 128 records. It is mainly used for sequential read write opera  tions. In order to further refine the current file position, the next structure  member, f cb_recs i z, specifies the logical record size in bytes.   Starting with the next member, the f cb starts to record file and direc  tory information. The member f cb_f s i ze contains the file size in bytes  that is initialized when a file is opened or created. DOS-C updates this  member  with each write operation. File date and time  are recorded  in  structure members f cb_date  and f cb_time.   By convention, DOS-C reserves an area of the FCB in order to meet  the requirement that users may modify  the FCB or complete an opera  tion without a logical termination. The next group of structure members  are  reserved  for  DOS-C.  The  first  member  in  the  reserved  group  is  fcb_sftno.  This member  is used to map the FCB to  an internal  SFT  structure. By starting at fcb_sftno,  DOS-C can follow the links down  into the fjnode  structure used by the file system manager. For a device,  the next two members,  fcb_attrib_hi  and  fcb_attrib_l  o form  an  attribute mode for files and devices.   Listing  6.11  The  fcb  data  structure.    *  File  Control  Block   FCB   typedef  struct   fcb  drive;  fcb  fname[FNAME .SIZE];  fcb_fext[FEXT_SIZE];  fcb_cublock;   BYTE  BYTE  BYTE  UWORD   UWORD  ULONG  date  time   BYTE  BYTE  BYTE  UWORD  UWORD  UBYTE  UBYTE  ULONG   }  fcb;   fcb_recsiz;  fcb_fsize;  fcb_date;  fcb_time;   fcb_sftno;  f c b _ a t t r i b _ h i;  fcb_attrib_lo;  f c b _ s t r t c l s t;  f c b _ d i r c l s t;  fcb_di  r o f f;  fcb_curec;  fcb_rndm;    *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   for  seq.  r w   Drive  number  0=default,  1=A,  etc  File  name  File  name  Extension  Current  block  number  of  128  records block,  Logical  record  size  in  bytes,  default  =  File  size  in  bytes  Date  f i le  created  Time  of  last  write  the  following   are  reserved  by  system  Device  ID  share  i n f o,   dev  a t t r ib  word  hi  dev  a t t r ib  word  l o,  open  mode  f i le  starting  cluster  cluster  of  the  d ir  entry  offset  of  the  d ir  entry  end  reserved  Current  block  number  of  Current  relative  record  number   *    *   *   *   *   *   = 128  *   *   *   *   *   *   *   *   *   *   *   *   *     232 — The FreeDOS Kernel   When the device is a file, f cb_strtcl  st  records the  file's  starting  cluster  and  fcb_dirclst  specifies  the  cluster  that  contains  the  file's  directory  entry.  In  order  to  easily  locate  the  directory  entry,  structure  member  f cb_di rof f  contains  the  offset  of  the  directory  entry  itself.  When combined with f cb_di rei st, a directory entry is fully  qualified.  By MS-DOS  design, the remaining  structure entries are user mem  bers that are used in random read, write, and seek operations. The first  of these members is f cb_curec, which contains the current block num  ber. Again  to  fully  specify  a record,  the  structure  member  f cb_rndm  contains the current relative record number of the random operation.   As I have done before, I will study the FCB personality functions by  studying the steps needed to open, read, and close a file. The first func  tion  I  will  look  at  is  FcbOpenO.  This  function  takes  a  single  far  pointer that points to the FCB in the users memory  area as does virtu  ally all of the FCB  functions.   FcbOpen      Listing  6.12   begins  by  attempting  to  get  a  free  SFT  entry.  In  DOS-C,  all  calls  use  an  SFT  entry  to  map  the  FCB  in  user  space into a kernel data structure. Should  FcbOpen    be unable to get   Listing  6.12  The  FebOpen     function.   BOOL  FcbOpen lpXfcb   xfeb  FAR  *lpXfcb;  1   WORD  sft_idx;  s ft  FAR  * s f t p;  struct  dhdr  FAR  *dhp;  BYTE  buff[FNAME_SIZE+FEXT_SIZE  +  3 ];  feb  FAR  *lpFcb;  COUNT  FcbDrive;     *  get  a  free  system  f i le  i f     s f tp  =  FcbGetFreeSft  WOR D  FAR * &sft_idx    =   table  entry   *    sft  FAR  *   - l    return  DE_T00MANY;    *  Build   a  traditional  DOS  f i le  name  IpFcb  =  CommonFcblnitdpXfcb,  buff,  &FcbDrive ;   *     DOS-C Kernel: API — 233   an SFT entry, it returns  a DOS error indicating that too many files are  open.  Next,  FcbOpen     converts  the  XFCB  entry   an  extended  FCB   into an FCB and extracts the filename from the FCB into a local array.  It builds a traditional DOS filename in the form of  a : fi 1 e. ext  that is  understood by the support  functions.   Listing  6.12   The  FebOpen    function  —  continued.   for  a  device  have  an  extension,  can't  be  a  device   *   *     *  check    *  if  we  i f d s D e v i c e   b u f f     i   for dhp  =   struct  dhdr  FAR  * &nul_dev;  dhp  !=    struct  dhdr   FAR  *   - l;  dhp  =  dhp  ->  dh_next    if FcbFnameMatch  BYTE  FAR  *   b u f f,    BYTE  FAR  * dhp  ->   dh_name,  FNAME_SIZE,  FALSE     r  i   r  l   sftp  ->  sft_count  +=  1;  sftp  ->  sft_mode  =  0_RDWR;  sftp  ->  s f t _ a t t r ib  =  0;  sftp  ->  sft_flags  =    dhp  ->  dh_attr  & ~SFT_MASK   SFT_FE0F;   sftp  ->  sft_psp  =  cu_psp;  fbcopydpFcb  ->  fcb_fname,  sftp  ->  sft_name,     SFT_FDEVICE     FNAME_SIZE+FEXT_SIZE ;   sftp  ->  sft_dev  =  dhp;  IpFcb  ->  fcb_sftno  =  sft_idx;  IpFcb  ->  fcb_curec  =  0;  IpFcb  ->  fcb_recsiz  =  0;  IpFcb  ->  fcb_fsize  =  0;  IpFcb  ->  fcb_date  =  dos_getdate  ;  IpFcb  ->  fcb_time  =  dos_gettime  ;  IpFcb  ->  fcb_rndm  =  0;  return  TRUE;   }   }   }    234 — The FreeDOS Kernel   In a fashion  similar to  DosOpen   ,  FcbOpen    checks  for  a device  because it must initialize the SFT differently  for  devices than for  disk  files. If it is not a device, it calls dos_open     to open the disk file. Once  this is done, FcbOpen     proceeds to populate the FCB with information  necessary  to  both  the  user  and  DOS-C.  In  essence,  FcbOpen     per  forms  many  of  the  same  functions  as  DosOpenO,  but  functions  in  a  slightly different  manner because of the method used to call it.   File  reads  are  handled  by  FcbReadO   Listing  6.13 .  As  with  FcbOpen    , FcbRead     accepts a f a r pointer into user space that points  to the user's FCB. The first step that  FcbRead     takes in servicing the   Listing  6.12  The  FebOpen    function  —  continued.   sftp  ->  sft_status  =  dos_open buff,  0_RDWR ;  i f   i   sftp  ->  sft_status  >=  0    IpFcb  ->  fcb_drive  =  FcbDrive;  IpFcb  ->  fcb_sftno  =  sft_idx;  IpFcb  ->  fcb_curec  =  0;  IpFcb  ->  fcb_recsiz  =  128;  IpFcb  ->  fcb_fsize  =  dos_getfsize sftp  ->  sft_status ;  dos_getftime sftp  ->  sft_status,   date  FAR  * &lpFcb  ->  fcb_date,   time  FAR  * &lpFcb  ->  fcb_time ;  IpFcb  ->  fcb_rndm  =  0;  sftp  ->  sft_count  +=  1;  sftp  ->  sft_mode  =  0_RDWR;  sftp  ->  s f t _ a t t r ib  =  0;  sftp  ->  sft_flags  =  0;  sftp  ->  sft_psp  =  cu_psp;  fbcopy  BYTE  FAR  * &lpFcb  ->  fcb_fname,    BYTE  FAR * &sftp  ->  sft_name,  FNAME_SIZE+FEXT_SIZE ;   return  TRUE;   return  FALSE;   \  j  else   }    DOS-C Kernel: API — 235   system call is to convert the extended  FCB to  an FCB  if necessary.  It  then retrieves the SFT block that contains the sft  by using the member  fcb_sftno.  If  it  cannot  retrieve  the  block,  the  file  was  probably  not  opened and  FcbRead     returns an error. If the FCB correctly links to an   Listing  6.13  The  Feb Rea d      function.   BOOL  FcbReaddpXfcb,  nErrorCode   xfeb  FAR  dpXfcb;  COUNT  ^nErrorCode;  r  I   s ft  FAR  * s;  fcb  FAR  dpFcb;  LONG  1 Posit;  COUNT  nRead;  psp  FAR  *p  -  MK_FP cu_psp,0 ;    *  Convert  to  fcb  if  necessary  IpFcb  =  ExtFcbToFcb lpXfcb ;   *    *    *   *        *  Get  the  SFT  block  that  contains  the  SFT  i f    s  =  FcbGetSftdpFcb  ->  fcb_sftno    ==     s ft  FAR   *   - l    return  FALSE;   is  not  opened  another  error*    If     *  i f  s   this  ->  sft_count  ==  0   return  FALSE;   t o.    *  Now  update  the  fcb  and  compute  where  we   *  position  1 Posit  =    IpFcb  ->  fcb_cublock  *  128   +  1  *  IpFcb  ->  fcb_recsiz;  if dos_lseek s  r  l   ->  sft_status,  1 Posit,  0   <   0    need  to   DFcb  ->   fcb_curec   *nErrorCode  =  FCB_ERR_E0F;  return  FALSE;   }    *  Do  the  read  nRead =  dos_read s  ->  sft_status,  p  ->  ps_dta,   IpFcb  -  >  fcb_recsiz ;   *     236 — The FreeDOS Kernel   open file, FcbReacK   must now update the FCB  and compute the cor  rect file position. With this position computed,  FcbReacK   updates the  file with a call to dos_l seek   , returning an error if it cannot properly  perform the seek.   Listing  6.13  The  Feb Rea d     function  —  continued.   return  and  do   i t.   *     *  Now  find  out  how  we  w i ll  if nRead  ==  IpFcb  ->  fcb_recsiz   r i   *nErrorCode  =  FCB_SUCCESS;  FcbNextRecord lpFcb ;  return  TRUE;   se  if nRead  <  0    *nErrorCode  =  FCB_ERR_E0F;  return  TRUE;   se  if nRead  ==  0    ^nErrorCode  =  FCB_ERR_N0DATA;  return  FALSE;   1    el  r i   1    el  r i   se   j  el  r  l   COUNT  nldx,  nCount;  BYTE  FAR  *1pDta;   nCount  =  IpFcb  ->  fcb_recsiz  -  nRead;  IpDta  =   BYTE  FAR  * & p  ->  ps_dta[nRead] ;  for nIdx  =  0 ;  nldx  <  nCount;  nldx++    ^lpDta++  =  0;   *nErrorCode  =  FCB_ERR_E0F;  FcbNextRecord lpFcb ;  return  FALSE;   }   }    DOS-C Kernel: API — 237   Once the file pointer is updated,  FcbReacK   performs the read oper  ation through a call to dos_read     using the link to the  fjnode  in the  sf t  structure member  sf t_status, transferring  the data to the DTA as  indicated in the ps_dta  member. The number of bytes to be transferred  is the number of bytes in a record for this FCB as stored in  f cb struc  ture member  f cb_recsi z.   Based on the return,  Feb Rea d    will return in any of three ways. If  the number of bytes read matches the record  size, the FCB is updated  by a call to  FcbNext Record     and returns normally. If it returns  fewer  bytes  read  than  a record  size,  FcbRead     returns  with  an  EOF  error  code.  If  the  number  read  is  exactly  zero,  Feb Rea d    returns  an  error  indicating that no data was read.   Finally, the function  FcbCl ose     Listing 6.14  is called to close the  file. Again,  a pointer to the user's  FCB in user  space is passed  in and  operated  on. As  you  saw  with  FcbRead   ,  FcbClose     converts  the  user's extended FCB to an FCB if necessary. It also gets the SFT block  that contains the sf t  and returns an error if it was not opened.   Next,  FcbCl ose    checks to see if the file opened was a device. If it  was, it decrements the sf t_count  member of the sft  and returns. Oth  erwise, it sets the file's time, date, and size by calling dos_setf time     and  dos_setfsize    .  With  this  information  updated,  FcbCl ose    calls dos_cl ose    and exits.    238 — The FreeDOS Kernel   Listing  6.14  The  Feb CI ose      function.   BOOL  FcbClose lpXfcb   xfeb  FAR  * l p X f c b;  r  i   s ft  FAR  * s;  feb  FAR  *lpFcb;    *  Convert   to  feb  if  necessary  IpFcb  =  ExtFcbToFcb lpXfcb ;   *    *    *    *   *    *     *  Get  the  SFT  block  that  contains  the  SFT  i f    s  =  FcbGetSftdpFcb  ->  fcb_sftno    ==    s ft   FAR  *   - l    return  FALSE;   is  not  opened  another  error   If     *  i f  s   this  ->  sft_count  ==  0   return  FALSE;   f i le  system  handler    *  now  just  drop  the  count  if  a  device,  else   *  call  i f  s  r  i   ->  sft_flags  &  SFT_FDEVICE    s  ->  sft_count  -=  1;  return  TRUE;   j  else  r  i   s  ->  sft_count  -=  1;  i f  s   ->  sft_count  >  0   return  SUCCESS;   else  i    *  chang e  time  and  set  f i le  size  dos_setftime s   ->  sft_status,    date  FAR  ^ &lpFcb  ->  feb.   time  FAR  * &lpFcb  ->  feb.  IpFcb  ->   _date,  _time  ;  fcb_fsize   ;   dos_setfsize s  return  dos_close s  ->  sft_status   ==  SUCCESS;   ->  sft_status,   }   }   }    Chapter 7   Command Line  Interpreter   Until  now,  I  have  been  concerned  primarily  with  the  details  of  the  DOS-C kernel. I have looked  at the  system call mechanisms, file sys  tem  functions,  and  memory  management  and  task  management  func  tions. I have also dug into the device driver interface  and  investigated  the C-to-assembly  language interface  for  calling  standard DOS  device  drivers. With all these details exposed, it's time to look at other compo  nents of the operating system, beginning with the user-level commands.  A good place to start is with DOS-C's version of command. com.   You may start by asking "How does command. com fit in?" In DOS-C,  it  is  the  first  program  started  by  the  kernel  and  the  parent  of  every  other  program  started  through  either  a command  entered  at  the  key  board  or  sets of commands  in a batch file. It is the component  of the  operating  system  responsible  for  maintaining  the  master  environment   239    240 — The FreeDOS Kernel   and running the system initialization program, autoexec, bat. In many  ways, it is similar to the  i ni t  program that runs on many UNIX sys  tems, but it combines the features  of command line parsing and initial  ization. Unlike  i n i t,  command. com does not keep a list of programs to  monitor  or  maintain  multiple  levels  that  allow  single-user  and  multi  user operation.   Starting the Command  Line  Interpreter  In Chapter  3, I examined  the four  stages  of  a DOS-C boot. In the final  stage, the DOS-C kernel loads command. com, or any other program speci  fied  in the confi g. sys file, and is the first program to run with the DOS-C  kernel. It establishes the environment for all subsequent programs executed  under DOS-C. What you don't know is the method used to start this pro  gram. Take a closer look at how DOS-C starts command. com.   Loading  command.com  is  a four-step  process  and is fairly  straight  forward.  The  reason  is  simple:  if  you  allow  DOS-C  users  to  replace  command.com  with  another  command  line  interpreter  of  their  choice,  you need to get that information  from the user. There are many ways to  do this. You may have a special  in it  program that reads  a  configura  tion  file  and  starts  the  command  line  interpreter.  This  is  the  UNIX  model where  i n i t  spawns a special set of programs to listen to a serial  line  or the  console. These  programs  specifically  look  for  a login  and  then look up the command line interpreter to run from a field contained  in the   etc passwd  file.  You may  also build the command  line  inter  preter into the kernel. An operating  system that implements this model  is CP M. However, DOS-C is based on the MS-DOS model that speci  fies the  default  command  line  interpreter  command.com  and  loads  it  unless it is directed otherwise by an entry in the file conf i g. sys. The  DOS-C kernel uses a process broken into three phases to facilitate  the  config.sys  switch  Figure 7.1 .   The DOS-C kernel uses a data structure, confi g, to hold  information  regarding the number of buffers, the number of files, and the name of the  command  line  interpreter.  This  data  structure  is  initialized  with  default  values when the kernel is compiled. The reason you initialize this structure    Command Line Interpreter — 241   with default values is simple: you need to read a file in order to determine  the user kernel configuration. You need to allocate space for file structures  and buffers  before  you can  access the file system to read  conf i g. sys.  The kernel uses this initial set to initialize some file system portions of the  kernel  in  preparation  of  processing  config.sys  in  the  function  i n i t_ke r n e 1     . It calls the function  PreConfigOto  perform this initial  allocation of file system data structures.   With preliminary file system data structures in place, the kernel then  processes  conf i g. sys, replacing the initialized portions of the  conf i g   Figure 7.1  A three-phase process  to load an executable file from   config.sys.   command.com   ^ r   i  r   ^ r   parse  config.sys   1  pre-config   parse  config.sys   1  load  shel 1   P-0   Phase 1  Initialize file  system   Phase 2  Load first  program   Phase 3  Start initial program  frnmmanrl.  romi    242 — The FreeDOS Kernel   data structure with those values parsed from the contents  ofconfig.sys.  One of those structure members is cfglni t. This member contains either  the  string  "command.com"  as  initialized  at  compile  time  or  the  string  parsed from the  commanch line in  confi g. sys. Also, the remainder of  any line parsed from  the  commanch line in  confi g. sys  is stored in the  structure member  cfglni  tTai 1. This allows special parameters such as  stack size or environment buffer size to be passed to the start-up command.  When the kernel  is ready to execute its first process, it invokes the  function  p_0    . This function  looks up the program it will execute by  referring  to the command name stored in  confi g. cfglnit  and passes  the  command  tail  conf i g. cf gIni tTai 1. Function  p_0     packs  this  into a standard DOS exec_bl  k data structure and calls  Dos Exec    , the  internal version of i nt  21 h  Fn  O0h,to start the program. By using this  technique,  any  standard  DOS executable  program  may be used  as the  start up command.  By  convention,  you  start  command.com  identically  to the way MS-DOS  starts its command  line interpreter.  Once  started,  the kernel  suspends  its  execution  and  control  passes  to the  command  line  interpreter.  From  this  point  on,  the  kernel  remains  in  the  back  ground,  only  to execute  system  calls  as needed  by  command.com  and  other application programs.   command, com  In DOS-C, the command line interpreter is command. com. As mentioned  earlier, this is by convention  and can be almost any other program. For  example, during debugging of the DOS-C command. com, the line   commanchcommand.exe   p   is inserted into conf i g. sys  so that the version executed is the one that  contains  all  debugging  information  normally  stripped  from  the  .com  file. This  allows  the  use  of  a  standard  DOS  source-level  debugger  to  simplify  the debugging of the interpreter.   The  DOS-C  version  of  command.com  is  written  in  C.  No  special  coding  tricks  or foolery  are  associated  with  it. It is  a simple  program  designed  to  accept,  parse,  and  execute  user  input.  It has  a number  of    Command Line Interpreter — 243   built-in  commands  identical  to  the  MS-DOS  version  and  allows  the  grouping  of  commands  into  a  single file known  as  a batch  file.  Like  MS-DOS, DOS-C command. com batch processing allows for some sim  ple program control instructions that test various parameters and mod  ify flow of control based on the results of these tests. It also maintains  the global environment block so that programs have access to the glo  bal environment variables.   Architecture  The architecture for  command. com is simple. It is organized as a table- driven  executive  with  a  collection  of  stand-alone  functions  used  to  implement  the  internal  commands.  This  executive  performs  a  linear  search through the table in order to find the function that corresponds to  the  command.  If  there  is  a  match,  the  executive  executes  the  corre  sponding  function;  otherwise, it defaults  to the terminating entry. This  process  continues  forever,  repeating  the  prompt-command  cycle  for  every user command.   Take a closer look at how  command. com works. What you see  from  the initial examination is that it is very much a standard C program. Like  all conventional C programs, execution starts at ma i n      Listing 7.1 .   Listing  7.1  The  command, com   main      function.   VOID  mainO  i   COUNT  nread;  BOOL  bool_FLAG  =  FALSE;  BOOL  c f l a g;  BYTE  FAR  *cmd_tail;  BYTE  *p_ptr;  extern  UWORD _psp;  psp  FAR  *p;  COUNT  driveno  = - 1;  BYTE  pattern[MAX_CMDLINE]  =  '  BYTE  path[MAX_CMDLINE]  =  " ",   "    esize[MAX_ _CMDLINE]  =  " ";    244 — The FreeDOS Kernel   Listing 7.1  The command, com  main    function   — continued.   *    I n i t i a l i ze  the  interpreter    *  p  =  MK_FP _psp,  0 ;  switchchar  =  '   ' ;  batch_FLAG  =  FALSE;  argv[0]  =  args[0];  a r g v [ l]  =   BYTE  *   0;  args[0][0]  =  ' \ 0 ';  nail  = ' \ 0 ';  env  =   BYTE  FAR * MK_FP p  ->  ps_environ,  0 ;  cmd_tail  =  MK_FP _psp,  0x81 ;  fstrncpy  BYTE  F A R *   t a i l,  cmd_tail,  0x7f ;   pflag  =  cflag  =  FALSE;  dosopt "$d$p*[e:pc]+",    BYTE  FAR  *   t a i l,   &driveno,  path,  pattern,  esize,  &pflag,   &cflag ;    *  Get  the  passed-in  Environment  size  and make   *  allocate  enough  space  EnvSize  =  EnvSizellpO ;  if EnvSize  <  ENV_DEFAULT    EnvSize  =  ENV_DEFAULT;   certain  we   *   *    i f   * e s i ze  i   !=  ' \ 0 '    COUNT  size  =  atoi esize ;  bool_FLAG  =  EnvAlloc size ;  EnvSize  =  size;   bool_FLAG  =  EnvAlloc EnvSize ;   if !bool_FLAG    error_message OUT_ENV_SPACE ;   j  else   else    *   Check  what  PROMPT  is  set  in  env  to  over  ride  p_ptr  =  EnvLookupC PROMPT" ;  i f   p _ p tr   !=    BYTE  * 0    scopy p_ptr,  prompt_string ;   default   *    scopy dflt_pr_string,  prompt_string  ;    Command Line Interpreter — 245   command. com starts by initializing a number of internal variables. It  then  examines  the  command  tail,  searching  for  options  passed  when  DOS-C invoked  command. com. These options modify  the execution of  the interpreter. For example, the   p  option tells  command. com that this  instance  is the root  interpreter   since  other instances  of  command.com  may be invoked  and must not exit, thereby fixing this copy as the root  process  for  DOS-C.  command.com  may  also  be  invoked  to  execute  a  single command with the    c option, so it must modify  its internal code   Listing   7.1  The command.com  main       function  — continued.   ^heck  what  PATH  is  set  in  env  to   over  ride  default    *     p  ptr  =  EnvLookupC'PATH" ;  i f    3_ptr   !=   BYTE  * 0   scopy p_ptr,  path ;   scopy dflt_path_string,  path ;  .cflag    else   i f   i   i f   p f l a g   i   i n i t i al   *   Special  MS-DOS  compatabi   *  all  command  shells  terminate  onto  th  at  the  root   *  but   we  always   *  11  change  it  DEBUG   terminate  If  anyone  complains,  we'   l i ty   i z a t i o n,  emselves,  s h e l l.   p  ->  ps_parent  =  _psp;   ifndef   endif   *    *   *   *   *    *     *  Tr y  to  exec  autoexec.bat  bootup  =  TRUE;  n a il  =  ' \ 0 ';  if    ibatch C  .Wautoexec.bat"  {   ,   t a i l      n a il  =  ' \ 0 ';  cmd_date l,  argv ;  cmd_time l,  argv ;  bootup  =  FALSE;   }   }    246 — The FreeDOS Kernel   Listing 7.1  The command, com  main    function  —continued.    *  Announc e  our  version  printf ANNOUNCE,  copyright ;   *    p r i n t f   " * * * *  Shareware  version  ****\nPlease   register   your  copy.\n" ;   p r i n t f   " \ n \ n "    ;   else  {   ifdef  SHWR   else   endif   FOREVER   default_drive  =  DosGetDrive  ;  put_prompt prompt_string ;  if  nread  =  DosRead STDIN,   BYTE  FAR  * cmd_line,   MAX_CMDLINE    <  0   continue;   do_command nread ;   else  {   BYTE  FAR  *p;   default_drive  =  DosGetDrive    ;  for p  =  cmd_tail;  *p  !=  ' \ r ';  p++   {   i f   *p  ==  7'  &&   * p  +  1   ==  'c'     * p  +  1   ==   'C'     break;   }  p  +=  2;  fstrncpy  BYTE FAR * cmd_line, p, 0x7f ;  for nread = 0; ^p != '\r'; nread++,  p++ ;  ++nread;  do_command nread ;    Command Line Interpreter — 247   path  to  comply  with  the  user's  single-command  execution.  Other  options modify  command. com buffer  space for environment and stacks.  For these reasons, the parsing  of  command  line variables  occurs  very  early on in main   .   With  command  line  options  parsed,  main     continues  to  initialize  areas that  command.com variables  affected,  such as  prompt  and  path.  Once  completed,  it  examines  whether  or  not  it  is  in  the  single-com  mand  mode  or the  iterative-command  interpreter  mode. If  it is  in  the  single-command  mode, the  remainder  of  the  command  line  is  copied  into  a local  buffer  and  main    invokes  do_command    to  execute  the  single command. If it is not executing a single command, command. com  assumes it is in the interpreter mode.   The code interpreter mode examines the flags set earlier in main   .  If  command.com  encountered  the   p  option,  it  knows  that  it  was  invoked  as the root interpreter  by the kernel. Within  DOS-C, only the  root  interpreter  receives  the   p  option,  so  command.com  attempts  to  execute  autoexec. bat. Executing this command on start-up is a DOS  de facto  standard to which all DOS users are well accustomed.  Should  autoexec. bat not be on the boot disk, command. com gives the user the  chance  to update  the  operating  system's  date  and time. This  is  also a  DOS standard and dates back to IBM PC and XT days when there was  no system clock,  and the start-up of DOS was the only opportunity  to  set the system time. If  command. com did not receive the   p option, the  interpreter  merely announces its invocation in an attempt to  differenti  ate itself from the root interpreter.   Once command. com completes all this preliminary set-up, it falls into  the  command  loop,  an  infinite  loop  that  outputs  the  prompt  and  then  reads from  standard input. Once the user enters a command, the  buffer  that received the keyboard input is passed to do_command    , which exe  cutes the command. Because this loop never exits, the sequence repeats  for as long as the interpreter is active. However,  command. com can exit,  but I will examine this mechanism later.    248 — The FreeDOS Kernel   Both code paths, the single-command path and iterative-command loop,  share the function  do_command      Listing 7.2 . This is the function  that  actually carries out the execution of individual commands. do_comnia nd      is responsible for input and output redirection. It also parses the command  tail into an argument list for use by internal commands.   Listing 7.2  The do_command      function.   VOID do_command nread   COUNT nread;  {   REG struct table *p;  REG BYTE *lp;  COUNT index = 0;  BYTE Input[MAX_CMDLINE], Output[MAX_CMDLINE];  BOOL AppendMode;  COUNT OldStdin = -1, OldStdout = -1, ErrorCode;  BOOL IORedirected = FALSE;  if nread <= 0   cmd_line[nread] = '\0';   * Pre-scan the command line and look for any re-directs  *Input = ^Output = '\0';  AppendMode = FALSE;  Redirect cmd_line, Input, Output, &AppendMode ;  IORedirected =  *Input != '\0'  ^Output != '\0' ;  if *Input != '\0'   {   return;   COUNT Handle;  if !DosDupHandle STDIN,   COUNT FAR * &01dStdin,  {    COUNT FAR * &ErrorCode     RestoreI0 01dStdin,  error_message INTERNAL_ERR ;  return;   -1 ;   *     Command Line Interpreter — 249   Both  the  single-command  mode  and  the  iterative-command  inter  preter  share  a  single  algorithm.  This  algorithm  is  encompassed  by  do_command   .  When  initially  invoked,  do_command     prescans  the  command  line  for  redirection.  This  is  done  through  the  invocation  of  Redi rect    , which scans the command line looking for all entries that   Listing 7.2  The do_command     function  — continued.   Handle = DosOpen  BYTE FAR * Input, 0_RDWR ;  if  Handle < 0     !DosForceDupHandle Handle,  STDIN  {    COUNT FAR * &ErrorCode      RestoreI0 01dStdin, -1 ;  error_message INTERNAL_ERR ;  return;   }  DosClose Handle ;   if ^Output  != '\0'   {   COUNT Handle;  if !DosDupHandle STDOUT,   COUNT FAR * &01dStdout,    COUNT FAR * &ErrorCode     {   RestoreIOC-1, OldStdout ;  error_message INTERNAL_ERR ;  return;   }  if AppendMode   {   ifUHandle  =  DosOpen  BYTE  FAR  * 0utput,  0_RDWR   {   RestoreIOC-1,  OldStdout ;  error_message INTERNAL_ERR ;  r e t u r n;   }  DosSeek Handle,  2,  01  ;   }  else   Handle  =  DosCreat  BYTE  FAR  *   0 u t p u t,   D_N0RMAL   I  D_ARCHIVE ;    250 — The FreeDOS Kernel   are preceded by " ", which are conventionally used for I O redi  rection. Once this scan is complete, do_command    proceeds to change  the  standard  input  and  output  file  descriptors  with  the  DOSAPI  calls  DosDupHandle   ,  DosOpenO,  and  DosForceDupHandl e   .  This  has  the net effect  of saving the original file descriptor, so you can recover it  later, and redirecting the input or output  stream. This is done once  for  the input stream and again for the output stream.   With  I O  redirection  out  of  the  way,  do_command     moves  on  to  parsing the command line for possible use by internal commands. The  internal  commands  use  an  internal  representation  of  arge  and  argv  similar to that in any conventional C program. Once the argument list is  built, do_command     moves on to execute the command. It does this by  first looking for the special case of a simple drive change. This is a two- character  string pointed to by  argv[0], where the  second character  is   Listing   7.2  The do_command     function   —  continued.   i f U H a n d le  <  0        !DosForceDupHandl   e Handle,   COUNT  FAR  * &ErrorCode    STDOUT,      r  l   ,  OldStdout ;   RestoreI0 -l  error_message INTERNAL_ERR ;  r e t u r n;   }  DosClose Handle     arge  =  0;  arge  <  16;  argc++    argv[argc]  =   BYTE  *   0;  a r g s [ a r g c ] [ 0]  =   \ 0 ';   =  scanspl cmd_line   ,  a r g s [ 0 ] ,   '   '  ;   a r g s [ 0 ] [ 0]  ==   '@'    at_FLAG  =  TRUE;  index++;   at_FLAG  =  FALSE;   }   f or  i     IP =   i f    {   j  else    Command Line Interpreter — 257   Listing 7.2  The do_command     function  — continued.   If  preceeded  by  a  @,  swallow  i t,    *   *  elsewhere.   Also,  change  case  so  that  our  command  verb   *  is  case  sensitive.  while args[0][index]  {   it  was  taken  care  of   ' \ 0 '    !=   *   *   *    args[0][index-l] = tolower args[0][index] ;  args[0][index] = tolower args[0][index] ;   if at_FLAG   else  index++;  }  if at_FLAG    args[0][index-l] = '\0';   argv[0] = args[0];   *  this  kludge  is  for  an  MS-DOS  wart  emulation  t a il  =  skipwh lp ;   *    for argc  =  1;  arge  <  NPARAMS;  argc++   {   Ip  =  scandp,  args[argc] ;  if *args[argc]  ==   ' \ 0 '    break;   else   argv[argc]  =  args[argc];   }  if *argv[0] != '\0'   {   BYTE c = argv[0][0];  if c >= 'a' && c <= 'z'   if c >= 'A' && c <= 'Z'   ' A '   ;   c = c - 'a' + 'A';   DosSetDrive c  -   }    * Look for just a drive change command, and execute   * it if found.  if argv[0][l] == ':' && argv[0][2] == NULL   {   *   *     252 — The FreeDOS Kernel   ":".  Should  this  be  the  case,  the  current  drive  is  changed  through  a  DOSAPIcallto  DosSetDrive    , and do_command    exits. If it is not a  drive change,  do_command    checks  for  a special  request  to the Help  subsystem.  If  do_command     identifies  it  as  being  such  a  request,  it  builds a Help command line, invokes  help, exe and exits.   Finally,  if the command  is neither  a drive change  nor  a call to the  Help subsystem, do_comniand    attempts to invoke either an internal or  external command to satisfy  the user request. It does this through a call  to 1 ookup     Listing 7.3 , which performs the actual command lookup.  The  internal  command's  corresponding  function  is  then  executed  by  invoking  the returned  pointer  to the  internal  function.  Once the  com  mand  completes,  do_command     restores  the  I O  to  its  original  state  and exits.   Listing 7.2  The do_command     function  — continued.   It  may  be  a  help  command  request.    *  else  i f     a r g v [ l ] [ 0]   ==  switchchar   &&    a r g v [ l ] [ l]  {   *    strcpy tail, "  "   ;  strcat tail, argv[0] ;  strcat tail,  "\r\n" ;  arge = 2;  a r g v [ l]  =  argv[0] ;  argv[0]  =  "help";  argv[2]  =  0;  ExecCmcKargc,  argv ;  if IORedirected    RestoreI0 01dStdin,  OldStdout ;   }   *  do  a  normal  command  execution  else  {   p  =  lookup commands,  argv[0] ;   * p  ->  func   argc,  argv ;  if IORedirected    RestoreI0 01dStdin,  OldStdout  ;   }   }   }    Command Line Interpreter — 253   When the default  entry is invoked, it attempts to take the command  parsed from the command line and locate an external program to  fulfill  the  user's  request.  It  follows  a  predetermined  sequence  of  searches  based  on  filename  extensions.  This  is  conventionally  *.com,  *.exe,  and *. bat, in that order. It spawns the external program, if found,  and  the  external  command  returns  to  this  point  when  it  terminates.   DOSLIB  Before I proceed much further, I need to explain what the DOSAPI that  I mentioned previously is all about. What you have seen is a sequence  of calls such as  DosOpen   ,  DosSetDri ve   , etc. MS-DOS  shows the  influences  of early operating  system designs in the assembly  language  system call, wherein MS-DOS, and in turn DOS-C, implements system  calls  as  software  interrupts,  and  system  call  parameters  are passed  in  the processor  register  set. The choice  of registers  seems  arbitrary  and  does  not  follow  any  high-level  language  conventions.  Consequently,  special arrangements must be made for high-level languages such as C,  in effect  hiding the assembly language details from the C program.   Listing  7.3  The  1 ookup      function.   struct  table   *lookup p,  struct  table  *p;  BYTE  *token;  r   token    while * p  ->  entry   r  i   !=   ' \ 0 '    if strcmp p  ->  entry,   token   ==   0    break;   else   ++P;   1  return  p;   }    254 — The FreeDOS Kernel   There are many ways to hide the system call details from the C code.  It is possible to embed the system calls directly in a C function  through  the use of parameterized C macros. This technique is used by operating  systems such as Linux. It is also possible to implement a message-pass  ing scheme where the system call parameters are placed into a message  packet and sent to the kernel. This is the Minix technique. What I have  done  in  DOS-C  is  define  a  logical  set  of  C  functions  that  act  as  the  DOSAPI. These functions  are then specially constructed to accept nor  mal  C  parameters  and  convert  them  to  the  int  21 h  system  calls  accepted by DOS-C. In doing this, I have defined the DOS-C DOSAPI.  Examine the  DosOpen    API call  Listing 7.4  to study the anatomy  of  an API call. The call  starts out as a normal  C function  defining  two  parameters,  Fi 1 eName, normally passed as a fa r pointer in  ds : dx, and  Fi 1 eAccess, normally in  ah. The function  returns  a  16-bit integer that  represents either the handle of the opened file or an error code if negative.  On starting the function  DosOpen    , the parameter  Fi 1 eName is bro  ken into segment and offset  components  suitable for the  i nt  21 h call.  Although  you  could  have deferred  this until  later,  after  you  make  the  transition  to  assembly  language, the  FP_SEG    and  FP_0FF    macros  are  used  instead.  This  way,  you  don't  need  to  second  guess  how  the  compiler encodes  far  pointers.  DosOpen    then shifts  gears and drops  into  assembly  language  using  the  C  directive  asm.  Once  in  assembly  language,  the  parameters  are  recovered  from  the  function  invocation  and moved into the correct registers. DosOpen     then loads the  function  number  into  the  al  register  and  proceeds  to  make  an  int  21 h call.  When the  i n t  21 h call returns, the return values are checked for errors  and the return value is set accordingly.   At this point you may be wondering why the API calls are coded in  this  fashion.  After  all,  you  could  code  the  API  function  entirely  in  assembly  language  or  use  the  more  common  i n121      or  intdosO  functions.  Any  of  these  choices  would  work,  but  the  tradeoffs  are  apparent.  If  you  code  the API  in  assembly  language,  you  must  have  intimate knowledge of how the compiler passes parameters in  function  calls,  and the use  of  i n 121      and related  calls  runs  the risk  of  using    Command Line Interpreter — 255   self-modifying  code or code built on the stack. Although you don't nec  essarily want to put this code in read-only memory, the code should not  preclude  this  option. The  hybrid  approach  chosen  here represents  the  best compromise between the two and is an approach typically seen in  many operating system APIs.   Listing  7.4  The DOSAPI function  Dos Open    .   COUNT  DosOpen FileName,  F i l e A c c e s s   COUNT  F i l e A c c e s s;  BYTE  FAR  *F  r  i   ileName;   UWORD  UWORD  COUNT   FileName_seg  =  FP_SEG FileName ;  FileName_off  =  FP_OFF FileName ;  Handle;   ds  ex  ex, FileName_seg  dx,  FileName_off  al,byte  ptr  FileAccess  ds,cx   asm  {  push  push  mov  mov  mov  mov   mov  i nt   pop  pop   mov   jnc  neg  mov   ah,0x3d  0x21   ex  ds   Handle,ax   out  ax  Handle,ax   }  return   Handle;   out:  }    256 — The FreeDOS Kernel   Internal  Commands  I  will  now  look  at  two  internal  commands,  cd  and  exit.  These  two  functions  are representative of internal commands in  command. com. In  the case of  cd, the design is virtually identical to all the other internal  commands,  exit,  however,  is  a  special  case  that  is  used  to  quit  the  interpreter. Because of this, exit  needs to do some special housekeep  ing before exiting. Start by examining  cd.   The  function  cd     Listing  7.5   starts  out by  initializing  the  auto  matic variable  01 dDri ve. You do this to store the drive that is logged  in  when  the flow of  execution  entered  the  cd  command,  so  you  can  return to the original logged-in drive in the event that you encounter an  error anywhere within the function.  Next, you do a command line san  ity check as a simple method of checking the syntax. This sanity check   Listing  7.5  The  cd      function.   BOOL  cd arge,  argv   WORD  arge;  BYTE  * a r g v [ ];  i   COUNT  OldDrive,  NewDrive  = - 1;  BYTE  CurDir[MAX_CMDLINE]  =  "";    *  I n i t i a l i ze  where  we  are  OldDrive  =  DosGetDrive  ;    *  Do  command  line  sanity  checks  if argc  >  2    1   error_message INV_NUM_PARAMS ;  return  FALSE;   }    *  get   command  line  options  and  switch  dosopt "$d*\   BYTE  F A R *   t a i l,  &NewD  if NewDrive  <  0    NewDrive  =  default_drive;   DosSetDrive NewDrive ;   *    *    to  the  requested  drive  rive,  CurDir ;   *     Command Line Interpreter — 257   is to make certain that the user only enters commands  of the form  cd  or cd  d :   or other drive designation . Should a syntax error occur, an  error is returned to the main command loop.   With the syntax check out of the way, it's time to parse the command  line  for  options.  In  the  case  of  cd  , you  are  looking  for  an  optional  directory parameter, which may contain an optional drive  specification  that you need to separate, cd     uses dosopt     to search for an optional  drive, and if it encounters  one, it calls  DosSetDrive    to temporarily  switch to that drive. If no directory is present in the second  argument,  cd  simply  echoes  the  current  parameter.  If  one  is  present,  cd    pro  ceeds  to  change  the  directory,  and  then  switches  back  to  the  original  drive, completing the cd    operation.   Listing  7.5  The  cd    function  —  continued.    *  Do  pwd  function  for  no  parameter  case  if *CurDir  ==  r  l   ' \ 0 '    DosPwcKNewDrive  +  1,  CurDir ;  printf "%c:\\%s\n\n",  DosSetDrive 01dDrive ;  return  TRUE;   'A'  +  NewDrive,  CurDir ;   }    *  Otherwise,   change  the  directory,  and  then  switch  back   *  t o  the  old  directory.  if  DosCd  BYTE  FAR  * CurDir    i   !=  SUCCESS    *    *   *    error_message INV_DIR ;  DosSetDrive 01dDrive ;  return  FALSE;   DosSetDrive 01dDrive ;  return  TRUE;   else  i   }   }    258 — The FreeDOS Kernel   cd illustrates the general design of every internal command. First, it  performs  a syntax check. Next, it proceeds to extract the information  it  needs by parsing the arguments that were passed on invocation. Finally,  the  command  is  implemented  using  DOSAPI  calls.  Error  checks  are  performed  at each  step and a means of recovery  is designed  into each  step. When the command exits because of an error or another reason, it  returns  an  exit  code  that  indicates  either  success   TRUE   or  failure   FALSE . In the event of a failure, the function  calls an error routine to  deliver  an  error  message. All  commands  within  command.com  follow  this design.   cmd_exit      Listing 7.6   handles the built-in  exit  command.  The  design  of this  function  deviates  significantly  from  other built-in  com  mands because of its special nature. Within DOS, the exi t  command is  reserved to terminate any invocation of the command interpreter except  for  the  initial  one  started  when  DOS  starts  up.  DOS-C  follows  this  same convention  and supplies an  exit  command  similar to that  found  in any other DOS, including MS-DOS. The one deviation that DOS-C  makes  is  that  the  kernel  invokes  the  initial  command.com  with  a   p  switch to indicate that it is the permanent shell.   When you examine cmd_exi t    , you find that it begins with code that  examines  whether  or not it is contained  within  a permanent  shell. This  early check  aborts  cmd_exi t     before  proceeding  into the body  of the  function, guaranteeing that this invocation of command. com doesn't exit.  Another feature of command. com is that it can return values that con  vey information,  such as error codes back to the program that invoked  the command. This feature is typically seen in batch files, allowing the  batch file to return  a code  indicating  either  an error  condition  caused  the termination of the batch program or successful  completion. A return  code of zero means, by convention, success, command. com also returns  success unless  otherwise  instructed  by  an  argument  to the  exit  com  mand.  cmd_exi t     does this by a simple examination of a rgc. If there  is only a single argument, it exits with a success code; otherwise, it con  verts the first argument to a numeric value and returns that number as  the return code.    Command Line Interpreter — 259   External  Commands  ExecCmcK    is  the  central  point  where  command.com  invokes  external  commands.  This  is  an  important  function  since  the  vast  majority  of  DOS  commands  and  applications  are  invoked  through  this  interface.   *    *    *    Listing  7.6  The  cmd_exi   t      function.   BOOL  cmd_exit argc,  argv   COUNT  arge;  BYTE  FAR  * a r g v [ ];  r  i  ifndef  DEBUG    *  Don't  exit  from  a  pe  i f   p f l a g    return  TRUE;   endif   I f  no  values  passed,    *  if arge  ==  1    DosExit O ;   rmanent  shel1   return  errorvalue  =  0    *  otherwise  return  what  the  user  asked  for  else  i   =  "0123456789";   COUNT  ret_val;  s t a t ic  BYTE  nums[]  BYTE  FAR  *p;   for ret_val  =  0,  p  i   COUNT j;  f o r  j  =  0;  j  <  if nums[j]  break;   ret_val  +=  j;      DosExit ret_val   ;   j++    10;  ==  *p    = a r g v [ l ];   i s d i g i t   * p  ;   p++    ì  return  TRUE;   }    260 — The FreeDOS Kernel   Listing 7.7 illustrates the function  ExecCmcK  , which  seems  excessive  at first glance. You shouldn't jump to conclusions too early in the game,  however, because starting a program and accurately keeping track of its  environment can consume significant resources.   Start  by  looking  at  the  overall  design.  All  commands  are  entered  through  the command  line interface  you examined  earlier.  ExecCmcK    parses the command line and breaks it into an internal a rgc a rgv struc  ture similar to the C calling convention for ma i n    . It then takes the first  argument  and  attempts  to  match  it  against  the  internal  dispatch  table.   Listing  7.7  The  ExecCmd     function.   BOOL ExecCmd arge,  argv   COUNT arge;  BYTE *argv[];  {   exec_blk exb;  COUNT  err;  BYTE tmppath[64];  COUNT idx;  BOOL ext = FALSE;  BYTE *extp;  COUNT len;  BYTE *lp;  CommandTail  CmdTail;  feb fcbl, fcb2;  static  BYTE *extns[2] =  {   ".com",  ".exe"   };  s t a t ic  BYTE  * b a t f i le  =  " . b a t ";  BYTE  PathString[MAX_CMDLINE];  BYTE  Path[MAX_CMDLINE],  *pPath;   includes   " . \"  so  that  the  current  directory    *  Build  the  path  string  and  create  the  f u ll  string  that   *   *  f i r s t.  Note  that  Path  is  strcpy Path,  strcpy PathString,  EnvLookup "PATH"  ;  pPath  =  PathString;   is  searched  i n i t i a l i z ed  outside  the  loop.   " . \ \ "  ;   *   *   *     Command Line Interpreter — 261   Listing  7.7  The  ExecCmd    function  —  continued.   do  {    * Build a path to the command.  if *pPath == ';'   strcpy tmppath, Path ;  if *tmppath  != '\0' && !  tmppath[strlen tmppath    ++pPath;     W  == 0     strcat tmppath, "\\"  ;   strcat tmppath, argv[0] ;   * batch processing   * search for an extension in the specification  for idx = len = strlen argv[0]  ; idx > 0 &&   idx >  len - FEXT_SIZE - 2 ; --idx    - 1] ! =   *    *   *    {   if argv[0][idx] == '.'   {   ext = TRUE;  extp = &argv[0][idx];  break;   }   }   * If no extension was found, the   * specified and we do not append  if iext   {   strcat tmppath, battile ;  extp = battile;   entire path was  an extension.   *   *    }   * if it ends with a '.bat'  either user supplied or   * previously added , try to run as a batch.  if  strcmp extp, battile  == 0  && batch tmppath, tail    {   *   *    if pflag && bootup   bootup = FALSE;  return TRUE;   }    262 — The FreeDOS Kernel   The algorithm used for the match  stops when  a terminating  null  string  entry  is  encountered.  The  accompanying  entry  points  to  ExecCmdO  make  it  the  default  function  to  be  invoked  when  looking  for  internal  commands.  In  this  fashion,  an  external  command  is  treated  no  differ  ently  than  an  internal  command.  By  making  it  the  default  entry,  you  have  guaranteed  that  command.com  searches  the  internal  commands  before loading an external command.   Listing   7.7  The  ExecCmdO  function   —  continued.   th  t r a i l i ng  newline.  and  put  it   into  CmdTail   to  a   format   t a il  comes  in  as   a  string  wi  return  only    *   *  Convert   it   *  CmdTail.ctCount  =     strcpy CmdTail.ctBu  strcpy &CmdTail.ctE  CmdTail.ctBuffer[CmdTail.ctCour  <  LINESIZE   if CmdTail.ctCount  r[CmdTail.ctCount]  =  ' \ 0 ';  CmdTail.ctBuffe   arge  >  1   ?  f f e r,  "  "  ;  u f f e r [ l ],    arge  >  1   ?  t a il   s t r l e n   t a i l    i t]  =  ' \ 0 ' ;   :  1 ;   :  " "  ;   *   *   *    rtn_errlvl  =  0;  exb.execenv_seg  =  exb.execcmd_l  ine  =   FP_SEG env   =  CommandTai   1  FAR  * &CmdTail  ;    if   PARSEFN   if argc  >  1   i   DosParseFilename  BYTE  FAR   feb  FAR  *   *   a r g v [ l ],   &fcbl,  0  ;   exb.execfcb_l   =   feb  FAR  *   & f c b l;   exb.execfcb_l   =   feb  FAR  *   0;   exb.execfcb_2  DosParseFilename  BYTE  FAR   feb  FAR   =   feb  FAR  * &fcb2;   *   a r g v [ 2 ],  * &fcb2,  0 ;   else   if argc  >  2   1   }  else   exb.execfcb_2   =   feb  FAR  *   0;    Command Line Interpreter — 263   Listing  7.7  The  ExecCmd    function  —  continued.   else   endif   exb.exec.fcb_l  =   fcb  FAR  *   0;  exb.exec.fcb_2  =   fcb  FAR  *   0;   for idx  =  0;  {   idx  <  2;   idx++    strcpy tmppath,  Path ;  !=  ' \ 0'  &&  if *tmppath   !  tmppath[strlen tmppath   strcat tmppath,  " \ \ "    ;   strcat tmppath,  argv[0] ;  i f   i e x t   {   -  1]   !=  ' \ V   ==  0     strcat tmppath,  e x t n s [ i d x ]  ;  extp  =  extns[idx];   }  if ! strcmp extp,  extns[idx]   ==  0     continue;   i f     r t n _ e r r l vl  =   err  =  DosExec  BYTE  FAR  * tmppath,    exec_blk  FAR  * &exb    !=  SUCCESS    {   switch err   {  case  DE_FILEN0TFND:   continue;   case  DE_INVLDFUNC:   rtn_errlvl  =  INV_FUNCTION_PARAM;  goto  errmsg;   case  DE_PATHN0TFND:   rtn_errlvl  =  PATH_N0T_F0UND;  goto  errmsg;   case  DE_T00MANY:   rtn_errlvl  =  T00_FILES_0PEN;  goto  errmsg;    264 — The FreeDOS Kernel   Listing  7.7  The  ExecCmd    function  —  continued.   case DE_ACCESS:  rtn_errlvl = ACCESS_DENIED;  goto errmsg;   case  DE_N0MEM:   r t n _ e r r l vl  =  INSUFF_MEM;  goto  errmsg;   d e f a u l t:   errmsg:   r t n _ e r r l vl  =  EXEC_ERR ;   e r r o r _ m e s s a g e   r t n _ e r r l v l  ;  r e t u rn  FALSE;   }   }  else  {   r t n _ e r r l vl  =  DosRtnValue    &  O x f f;  r e t u rn  TRUE;   }   }  i f   e rr  <  0  {      i dx  ==  2    i f   !   e rr  ==   DE_FILENOTFND  {   error_message EXEC  FAIL ;  r e t u r n  FALSE;      i dx  ==  2     }  c o n t i n u e;   }   }  w h i l e   * P a th  =  !=   *Path   ' \ 0 '  ;   error_message BAD_CMD_FILE_NAME ;  r e t u rn  FALSE ;   }   ' \ 0\  pPath  =  s c a n s p K p P a t h,  Path,   ' ; '  ,    Command Line Interpreter — 265   Once  ExecCmcK    is  invoked,  it  initializes  and  searches  for  a com  mand  in  a fixed manner  that  includes  searching  for  .bat,  .com,  and  . exe forms of the  command. This search is performed  along fixed direc  tories  as  specified  in the  path  environment  variable. Once  ExecCmcK    finds the command,  it creates the proper environment before  executing  the external command. When the external command returns, ExecCmd      checks  for  errors  before  exiting  to  the  interpreter's  main  loop,  which  adds to the robustness of the design.   Take a closer look at the algorithm behind  ExecCmcK  .  ExecCmcK    starts by  initializing  the internal  execution  path  variable. It builds  the  path  string  and creates  a path that begins  with  "A" so that the  current  directory  is  searched first. Next,  ExecCmcK   uses  a C  do  . ..  whi 1 e  construct to repeat the search along each directory contained within the  string constructed  earlier. For each iteration,  ExecCmd    builds a  .bat  form  of  the  command  and  searches  for  it  by  invoking  the  function  batch       Listing  7.8 .  If  it  is  a batch  file,  ExecCmd    returns;  other  wise, it tries to load a binary executable.   To execute  a binary   .com  or  .exe   file,  ExecCmd     uses  an  exec  block data structure for use in an i n t  21 h  f n  4 b h. It starts by creating a  command tail for use in the system call. It also initializes the exec block  with  the  master  environment  segment.  Next,  it  initializes  the  two  f cb  entries by parsing the command line using the Parse Filename system call   int  21 h  fn  29h . Finally, it attempts to execute a  . c om version then an  . exe version of the command through the Dos Exec     API call. The order  of  . com then  . exe is controlled by order of entry in the extns table.   Listing 7.8  The batch     function.   BOOL  batch file   BYTE  * f i l e;  {   COUNT idx;  COUNT file_parse  ;  BOOL parse  ;    266 — The FreeDOS Kernel   Listing 7.8  The batch     function  — continued.   if   so  clean  up    *  check  to  see  if  currently  processing  a  batch  f i le   *  if batch_FLAG   {   COUNT  f p;   *    *    i f     fp  =  DosOpen  BYTE  FAR  *   f i l e,  0_RD0NLY    <  0    return  FALSE;   else   DosClose fp ;   batch_FLAG  =  FALSE;  f o r   i dx  = 0;   idx  <  NPARAMS;  idx++    posparam[idx][0]  =  ' \ 0 ';   for label_cnt  =  0 ;  label_cnt  <  MAX_LABELS;  {   labels[label_cnt].lb_name[0]  =  ' \ 0 ';  labels[label_cnt].lb_posit  =  ' \ 0 ' ;   }  DosClose fileptr ;   label_cnt++     *  open  batch  f i le  i f     f i l e p tr  =  DosOpen  BYTE  FAR  *   f i l e,  0_RD0NLY    <  0   {   for  reading   *    batch_FLAG = FALSE;  return  FALSE;   }   * Ok, now set mode to batch and initialize positional   * parameter array.  echo_FLAG = TRUE;  batch_FLAG = TRUE;  shift_offset = 0;  for idx = 0; idx < NPARAMS; idx++    strcpy posparam[idx], args[idx] ;   *   *    *     * deal  with command  line  file_parse fileptr ;  return TRUE;    Command Line Interpreter — 267   On return  from  the  Dos Exec     API  call,  ExecCmcK   examines  the  return  code  for  error  conditions. It  does  this  for  two reasons. First,  it  needs to see if it found the command.  Dos Exec     uses this return infor  mation to proceed to the next entry, if necessary. It does this with a sim  ple  C  continue  statement,  bypassing  all  other  error  tests.  Second,  it  needs to translate the error codes into useful  user feedback  in the  form  of  error  messages.  These  messages  are  an  absolute  necessity  for  the  user. Without them, command. com would be nearly useless.   Batch  Commands  Batch commands execute in a fashion similar to external commands but  with  significant  differences.  Unlike  a  binary  file,  command.com  exe  cutes these commands by sequentially reading a text file that contains a  sequence of commands. It reads the file one line at a time, interpreting  each line.   Command line interpreters in many operating systems, such as UNIX  and  its  derivatives,  possess  similar  features.  Unfortunately,  the  DOS  batch  command  language  it  is  not  nearly  as  well-structured  as  these  other  interpreters. The batch  language that DOS uses tends to be very  simple with  not  much  support  for flow control  or  structured  program  ming. In fact, some language features  such as the cai 1  batch command  did  not  occur  until  late  in  the  development  of  MS-DOS. Without  the  call  batch command, you cannot nest batch commands simply, and the  lack of this command was a problem. Many users found batch program  ming without the ca 11 command extremely restrictive, and it took quite  a bit of demand from the user community before Microsoft  responded.  The restrictive DOS batch language is somewhat unfortunate  for the  DOS-C design.  One of our design  goals is that DOS-C be  functionally  equivalent  to  MS-DOS.  Maintaining  compatibility  with  the  standard  DOS batch  language  is necessary  to prevent breaking  applications  that  rely on it. There is quite a bit of risk associated with deviating from the  standard  because  many  batch  files  in  the  DOS  software  pool  may  be  affected by the changes. For example, these batch files are used in various  applications as control programs coordinating multiple subcommands, in  installation  procedures  as  installation  scripts,  and  by  many  users  for    268 — The FreeDOS Kernel   local customization. The command. com batch language is also the script  language  used  by  the  system  start-up  command  autoexec.bat.  As  a  result, the implementation of the command. com batch scripting language  should  match  the MS-DOS  version.  This  makes  the  design  somewhat  cumbersome  in  spots. In  fact,  in  the  process  of  matching  the  original  MS-DOS  design,  you  quickly  understand  how  unstructured  assembly  language coding led to the unstructured batch language design.   Look at the DOS-C method used to execute a batch command. Batch  commands  are initiated in  command. com through the invocation  of the  Dos Exec     function.  ExecCmd    attempts to execute batch  commands  before  binary  commands  and  uses  a  call  to  the  function  batch      to  execute the batch command. If the command is not a batch  command,  batch     returns a FALSE, allowing  ExecCmd    to continue. However, if  it  is  a batch  command,  batch     executes  the batch file by  reading  it  line by line and executing each line.   indicated  by   The  function  batch     takes  only  a single  argument,  a pointer  to a  string representing the batch command to be executed. Armed with the  filename, batch     attempts to open the batch file, but only if it is not  currently  processing  one,  as  the  global  variable  ba t c h_F LAG. If it is in the middle of a batch file, ba t c h     first checks to  see if the file can be opened. If it is not opened, it returns, thereby allow  ing for error processing. If the file is good, it's opened and internal vari  ables  are reset. At this point  you may  wonder  why you  need  all these  steps before ever getting to the meat of batch processing. The answer is  simple, if not obscure: the code is here to properly handle the chaining  of batch files, a command. com feature heavily relied on. It is the first of  many special code snippets necessary for correct MS-DOS emulation.  In any event, with the possible exception of a bad batch file specifi  cation,  batch     proceeds  to  open  the  new  batch file for  input,  again  keeping track of failures to allow for error processing. It then initializes  a number of internal variables and begins parsing the file for commands  through  a  call  to  file_parse     Listing  7.9 ,  returning  TRUE as  an  indicator for success on completion.    Command Line Interpreter — 269   Listing  7.9  The  fi  1 e_parse     function.   COUNT  f i l e _ p a r s e   f i l e p t r   WORD  f i l e p t r;  i   WORD rc_FLAG;  COUNT  nread;  COUNT  pass;  BYTE  1ine[MAX_CMDLINE];  BYTE  *p;   for pass  =  1;  pass  <=  NUM_PASSES;  pass++   1   default_drive  =  DosGetDrive  ;  do  i   BOOL  eof  =  FALSE,  eoi  =  FALSE;   f o r   * l i ne  =  0 ,  p  =  l i n e,  nread  =  0;   ieol  &&  ieof  &&   nread  <  MAX_CMDLINE ;        BYTE  FAR  *   p,  1    !=  1    r  i   if DosRead fileptr,  i   eof  =  TRUE;  break;      switch ^p   1  case  CTL_Z:  case   ' \ r ':   ^P  =  ' \ 0 ';  eoi  =  TRUE;  break;   case  ' \ n ':   ^P  =  ' \ 0 ';  continue;   default:   ++nread;  ++p;  break;   }   }    270—  The FreeDOS Kernel   Listing  7.9  The fi  1 e_parse    function  — continued.   *    expand cmd_line,   l i n e  ;   default_drive  =  DosGetDrive  ;  p  =  skipwh cmd_line ;    *  dummy  nread  to  get  by  a  blank  if pass  >  1  && *p  ==  ' \ 0 '   I i   line   nread  =  1;  if echo_FLAG   r i   i f   e o f    X Ì  i f   i e o f    else   continue;   break;   p r i n t f   " \ n "  ;   put_prompt prompt_string ;  p r i n t f   " \ n "  ;   }   r  l   }   i   X Ì   if echo_FLAG  && pass  >  1  && *p  !=  '@'  && *p  !=   ' :' &&   nread  > 0    p r i n t f   " \ n "  ;  put_prompt prompt_string ;  printf "%s\n",  cmd  l i n e  ;   i f     rc  FLAG  =  parse cmd  l i n e,  strlen cmd   l i n e  ,   pass     !=  TRUE    printf "ERROR  parsing  batch  fi  1e\n" ;  return   rc_FLAG ;   }  while   nread  > 0 ;  DosSeek fileptr,  0,   OL ;   }   }   DosClose fileptr ;  batch_FLAG  =  FALSE;  return  TRUE;    Command Line Interpreter — 277   The fi  1 e_parse     function  is heart of batch processing. This func  tion  implements  the  basic  structure  of  the  batch  command  language.  file_parse      builds  a  symbol  table  to  keep  track  of  labels  and  is  responsible  for  expanding  batch  variables. Take  a closer  look  at  how  this is done.   The  basic  control  structure  of  file_parse     is  a  for  loop  that  loops  through  the  body  of  the  file_parse    code.  file_parse    loops through  the batch file twice. The first time, it goes through  and  builds a label table that contains an entry for each label plus the file off  set  for  that  label.  This  allows  the  flow  of  control  functions,  such  as  goto, to quickly position to the correct offset  in the file. In each pass,  file_parse     first builds  a  line  from  the  file,  terminating  on  either  end-of-file,  carriage return, or line feed. Once the line is read, substitu  tions are made for  each  command. com variable, such as %0 through %9  and  other  shell  variables.  It  does  this  by  a  call  to  the  function  expand    . Once the line is expanded, it echoes the line if needed, then  executes the command by a call to parse      Listing 7.10 .   The function  parse     is the final link in batch processing.  parse     modifies its behavior based on the pass variable. If pass is equal to 1, a  label, signified as a string preceded with a ":", is entered into the symbol   Listing  7.10   The parse     function.   ine,  nread,  pass    BOOL  parsed  BYTE  1 i n e [ ];  COUNT  nread;  COUNT  pass;  i   cursor  =   skipwh line    >   ==  1    if pass  i   i f  *   else   }   return  TRUE;   cursor  ==  return   ' :'  label,      _bat ++cursor  ;    272 — The FreeDOS Kernel   table by a call to  1 abel_bat    . All other commands are bypassed. For  all other  pass  values, the label lines  are bypassed, but command  lines  are executed by calling do_comniand   , which is the same function  that  parses each individual command line while in the interactive mode.   As you can see, a batch file is handled nearly identically to individual  commands  typed  in  by  the  user.  The  only  exception  is  that  you  keep  track of labels. What you don't see is how flow of control is executed. If  you look at the dispatch table, you see that you have built-in commands  for  i f and goto. In the DOS-C version of command. com, each statement  that controls flow is  a built-in  command  similar  to the  d i r  command.  Look at the goto command to understand how these commands work.   All  flow  of  control  statements  are  similar   in  design.  Like  goto_bat      Listing 7.11 , they initially examine the batch_FLAG and  return immediately if command. com is not in batch mode. This flag dis  ables these commands during interactive operation and is set only when   Listing  7.10  The parse     function  —  continued.   switch *cursor    {   case  '@' :   at_FLAG  =  TRUE;  cursor  =  skipwh ++cursor ;  do_command nread ;  at_FLAG  =  FALSE;  break;  ' : ' :  labels  processed  in  pass  1   case    *  break;   default:   do_command nread ;  break;   ì   return  TRUE;  }   *     Command Line Interpreter — 273   command.com  is  in  batch  mode. You  need  to  disable  flow  of  control  statements during interactive operation  since you cannot reposition the  input file  the keyboard in this case .   When  a flow of  control  statement  needs  to  transfer  the  command  flow to a new location denoted by a label, it searches the symbol table  for  the label. When  it finds the label, the function  retrieves  the corre  sponding  file  offset  and  uses  it  to  reposition  the  file,  effectively  per  forming  a jump  to  the  statement  following  the  label.  For  conditional  commands,  the  evaluation  of  the  condition  prior  to  performing  the  lookup modifies the batch file execution, but the code is virtually iden  tical. Although not complicated, the method is very  effective.   Listing  7.11  The  go t o_ba t      function.   BOOL goto_bat    {   COUNT label_cnt = 0;  BYTE *lp;  if !batch_FLAG    return FALSE;   Ip  =  skipwh tai1 ;   while labels[label_cnt].lb_name  {   !=    ' \ 0 '    if strcmp labels[label_cnt].lb_name,  {   Ip   ==  0     LONG 1abels[label_cnt].lb_posit ;   DosSeek fileptr,  0,   return  TRUE;   }  label_cnt++;   }  error_message LABEL_N0T_F0UND ;  return  FALSE;    274 — The FreeDOS Kernel   Other Options for  Command  Interpreters  Other command  line interpreters  are available  for  MS-DOS, and each  has  its  advantages  and  disadvantages.  However,  this  chapter  demon  strates the  fundamentals  of  operating  system  command  line  interpret  ers.  In  general,  these  techniques  are  similar  to  those  used  in  other  command line interpreters  found  in other operating  systems. Although  the system calls may be different,  the general principles are the same.   The  DOS-C  version  of  command.com  is  not  a full  implementation  for MS-DOS. Two features  are noticeably missing. First, the MS-DOS  command.com  makes  a special  int  28h  call that  is used to  multiplex  pri nt. com while idle. MS-DOS needs this because of its single thread  of  execution.  It  must  cooperatively  share  its  thread  of  control  with  print.com.  Also  missing  are pipes. MS-DOS  does  not  support  inter  process  communications,  again  because  of  its  single thread  of  execu  tion.  Pipes  are  implemented  as  temporary  files  in  MS-DOS  that  are  deleted  after  being  read.  This  is  a  simple  but  effective  technique  that  simulates pipes well.   These are features  that can be easily  added to our  command. com, if  so desired. As with  all of DOS-C, the  source is yours to enhance  and  change as you please.    Chapter 8   DOS-C Kernel- Putting It All Together   If you have read the book to this chapter, you now have an understand  ing  of  the  design  behind  DOS-C. You  have  gone  over  the  high-level  design and taken different  tours through the kernel to examine various  aspects of the kernel. You have studied some of the fundamental  kernel  data structures  and discovered  how these data structures relate to both  DOS-C and MS-DOS. But you haven't built DOS-C yet.   This chapter covers the actual building of the kernel and debugging  techniques. The concept  of building  a program  and debugging  it with  the use of remote debuggers may be new to many readers, so I will go  through a step-by-step build and test session of the kernel.   275    276 — The FreeDOS Kernel   Organizing the Project  Any  software  project  usually  has some  structure  associated  with it. In  the smallest of projects, all the necessary files are usually kept in a sin  gle directory. In larger projects, individual components are kept in sep  arate  directories  and  built  in  one  common  area.  DOS-C  follows  the  latter model.   At  the  highest  level,  the  project  is  organized  into  five  directories:  lib,  doc,  hdr,  dist,  and  src   Figure  8.1 .  Each  of  these  directories  holds  a  major  component  of  DOS-C.  The  src  directory  is  further  divided into subdirectories:  ipl,  boot,  command, drivers,  fs,  kernel,  mi sc,  uti 1 s,  and  tmp. This organization  adds  structure to the  project.  Is every project organized this way? No, not necessarily, and this direc  tory  structure  may  not  make  sense  for  another  project.  You  may  not  even  organize  your  own  operating  system  project  this  way,  but  the  object  is to organize your files in a way that makes the overall  project  easy to maintain.   At the top level, the  dist  directory  is an abbreviation  for  distribu  tion  and holds  all files necessary  for  a binary  distribution.  It is essen  tially an image of a bootable floppy that you would give to someone to   Figure   8.1  DOS-C   directory   structure.   +-- +-- +-- +-- +--  - l ib  -doc  -hdr  -dist  -src  +-- +-- +-- +-- +-- +-- +-- +-- +--  -ipl  -boot  -command  -drivers  -fs  -kernel  -mise  - u t i Is  -tmp    DOS-C Kernel: Putting It All Together — 277   try  DOS-C.  In  this  directory  are  boot.bin,  ipl  .sys,  kernel  .exe,  command.com,  other  executable  files,  and  documentation,  including  release  notes. Had  this been  a larger  project,  this  directory  may  have  been  further  subdivided.  For  example,  it  may  have been  divided  into  one directory for each disk of a distribution. Another possible organiza  tion is to use a single directory but have other areas for distribution on  different  media. Whatever makes the most sense for your project should  guide  your  implementation.  For  DOS-C,  the  binaries  are  distributed  two ways: a compressed  archive and a snuggle floppy. For this reason,  it makes sense that all the files are collected into a single directory, and  distribution is built from that directory.   The  doc  directory  is  where  all  project  documentation  goes.  This  directory includes informational files, release notes, to-do lists, and any  other  project-related  documentation.  Had  DOS-C  been  bigger,  the  directory  may  have  been  further  divided  into  separate  directories.  DOS-C is an active project, and as it grows, so will the documentation.  This directory  structure may change later, but for  now, a single direc  tory with one file per documentation item is all that is necessary.   The next three directories  are dedicated  to building the executables.  They  are  lib,  hdr,  and  src,  abbreviations  for  libraries,  headers,  and  source,  respectively.  The  first  of  these  directories,  1 i b,  is  a  common  directory that holds libraries built in the project. The next directory, hdr,  holds  all  header  files  used  in  the  project.  The  final  directory,  src,  is  divided into subdirectories, each dedicated to a component of the project.  Again  you  may  wonder  about  the  structure.  Simply,  you  need  to  make certain that all key components, such as headers and libraries, are  kept in areas that are easily accessible from the lower source levels. The  general rule for DOS-C is that any project-specific  header or library is  always two directories up from  the one you are in when you build the  file. This simple organization  simplifies the developer's task and elimi  nates duplication of files and just plain losing files. Again, this structure  may not be ideal for every project, but any project that is large enough  should  have  a file structure. This  way,  all members  of  a project  team  know where all the files are located.    278 — The FreeDOS Kernel   When you organize your project, examine the project. Try to organize  the directory structure in a way that makes sense. In the case of DOS-C,  the directories  are organized  by  functionality,  but  for  your project  you  may want to divide files into one directory per executable. It all depends  on  what  makes  sense  for  your  particular  development  environment.  You  will  also  need  to  consider  your  build  tools.  Some  make  pro  grams include concepts such as view pathing. This is a technique where  multiple  directories  specified  in  a  makefile  variable  are  searched  for  dependencies, much the same way that command. com searches multiple  directories  in its  path  variable. In this case, you may want to create a  phantom directory structure for work in progress and use the view path  to pick up files from the source tree that are needed for the build but use  local files that may be under development.   Building  the DOS-C  Kernel  The build organization of DOS-C is a separate makefile for each major  component.  Each makefile  is named, with  a  .mak extension,  after  the  component  it  builds.  For  example,  the  makefile  for  kernel  .exe  is  kernel  .mak  Listing 8.1  and for  ipl  .sys  is  ipl  .mak. This allows for  rapid identification  and association of the component and the makefile.  There  is no  overall  makefile.  To build  the  entire  package,  invoke  the  batch file bui 1 d. bat that resides in the top directory.   Listing 8.1  Kernel makefile kernel   .mak.     Makefile  for  Borland  C++  3.1  for  kernel.exe     SHeader:   D: dos-c src kernel kernel.mav   1.0   02  Jul  1995  8:30:22   patv  $     $Log:   D: dos-c src kernel kernel.mav   $   Rev  1.0      I n i t i al   revision.   02  Jul  1995  8:30:22   patv   RELEASE  =  1.00   .AUT0DEPEND    DOS-C Kernel: Putting It All Together — 279   Each  makefile  has,  at  a  minimum,  four  targets.  These  targets  are  used  by  the  top  build  file  and  also  standardize  the  operations  across  each DOS-C component. These targets,  al 1,  production,  populate,  cl obber,  and  cl ean, define common makefile  operations that you can  perform  for  each  DOS-C  component.  The  target  all  builds  every   Listing  8.1  Kernel  makefile  kernel   .mak —   -  continued.   =  -v  -X  - I.  -D  STDC  =0  -DDEBUG  -DKERNEL  -DI86  =   Mx Zi DSTANDAL0NE=1  =..\..\LIB\DEVICE.LIB   ..\..\LIB\LIBM.LIB   -DPR0T0  -DSHWR  -DASMSUPT       Compiler  and  Options  for  Borland  C++    CC =  bcc  +kernel  .cfg  ASM =  TASM  LIB  =  TLIB  LINK  =  TLINK  LIBPATH  =  .  INCLUDEPATH  =  ..\HDR  CFLAGS  AFLAGS  LIBS     where  to  copy  source  from  FSSRC  =  \   . . \ f s \ f a t f s . c  . . \ f s \ f a t d i r .c  . . \ f s \ f a t t a b .c  . .\fs\dosfns.c  . . \ f s \ f c b f n s .c  . . \ f s \ e r r o r .c   \  \  \  \  \   SUPTSRC  =  \   \   . . \ f s \ p r f .c  ..\fs\misc.c  ..\fs\dosnames.c  ..\fs\syspack.c   \   \   IOSRC  =  \   . . \ f s \ b l o c k i o .c  . . \ f s \ c h a r i o .c   \   f a t f s . c  f a t d i r .c  fattab.c  dosfns.c  fcbfns.c   \  \  \  \   COPIEDSRCB  =  \   \   \   error.c  prf.c  \  mi s ec  dosnames.c  syspack.c  \  blockio.c  \  chario.c   \     what  to  delete  when  cleaning  COPIEDSRCA  =  \    280 — The FreeDOS Kernel   executable  for  that  component.  It  may  consist  of  one  or  more  .bin,  . com or  . exe files. The target  popul ate  copies all source files into the  directory. DOS-C uses this target to copy files from  f s, the file system  manager  directory,  into  ipl  and  kernel  before  building  the file. This   Listing  8.1  Kernel  makefile   kernel   . ma k —  continued.   ^ I m p l i c it  Rules*   * L i st  Macros*   \     . c . o b j:   $ CC   -c  {$<  }   .cpp.obj:   $ CC   -c  {$<  }      \  \   \  \   \  \  \   \  \  \  \   EXE_dependencies  =  kernel  .obj  blockio.obj  chario.obj  dosfns.obj  dsk.obj  \  error.obj  f a t d i r . o bj  f a t f s . o bj  fattab.obj  fcbfns.obj  initoem.obj  inthndlr.obj  \  i o c tl  .obj  ma in.obj  \  memmgr.obj  mi sc.obj  \  dosnames.obj  prf.obj  strings.obj  sysclk.obj  syscon.obj  syspack.obj  systime.obj  task.obj  \  apisupt.obj  asmsupt.obj  execrh.obj  \  procsupt.obj  stacks.obj   \  \  \  \  \   \  \   \   \   \   \     all  :   ^ E x p l i c it  Rules*  productio n   production:  populate   kernel.exe   t d s t r ip  kernel.exe  copy  kernel.exe  del  *.obj  del  kernel.exe   . . \ . . \ d i st    DOS-C Kernel: Putting It All Together — 281   Listing  8.1  Kernel  makefile  kernel   .mak —   continued.   populate:   $ FSSRC   $ SUPTSRC   $ I0SRC   release  $ RELEASE   . . \ u t i l s \ p op  $ FSSRC   . . \ u t i l s \ p op  $ SUPTSRC   . . \ u t i l s \ p op  $ I0SRC    clobber:   clean  del  kernel.exe   clean:   . . \ u t i l s \ r m f i l es  $ C0PIEDSRCA   . . \ u t i l s \ r m f i l es  $ COPIEDSRCB   del  *.obj  del  *.bak  del  * . c rf  del  * . x rf  del  *.map  del  * . l st  del  * . l as   kernel.exe:  kernel.cfg  $ EXE  dependencies    $ LINK     m v c P- L$ LIBPATH   @&&   kernel.obj+  blockio.obj+  chario.obj+  dosfns.obj+  dsk.obj+  error.obj+  f a t d i r . o b j+  f a t f s . o b j+  fattab.obj+  fcbfns.obj+  initoem.obj+  inthndlr.obj+  i o c t l . o b j+  ma in.obj+  memmgr.obj+  misc.obj+  dosnames.obj+  prf.obj+  strings.obj+  sysclk.obj+  syscon.obj+  syspack.obj+  systime.obj+  task.obj+  apisupt.obj+  asmsupt.obj+  execrh.obj+  procsupt.obj+  stacks.obj  kernel  kernel  $ LIBS   1     exe  f i le    map  f i le    282 — The FreeDOS Kernel   way, only one copy of each source file exists, and software  maintenance  is  simplified.  Both  targets  clean  and  clobber  clean  the  directory  of  files that  are left  over after  a build  occurs. The only  difference  is that  cl ean leaves the product files, whereas cl obber leaves only the source  files that  belong  in  the  directory.  The  target  production  creates  the  actual version that appears in the di st  directory. This version is stripped  of all debugging information  and built without debugging options.   Listing  8.1  Kernel  makefile  kernel   .mak —   continued.     kernel.obj:  kernel.cfg   kernel.asm   ^Individual  File  Dependencies*   $ ASM   $ AFLAGS   KERNEL.ASM,KERNEL.OBJ   blockio.obj:  kernel.cfg  blockio.c   chario.obj:  kernel.cfg  chario.c   dosfns.obj:  kernel.cfg  dosfns.c   dsk.obj:  kernel.cfg   dsk.c   e r r o r . o b j:  kernel.cfg  error.c   f a t d i r . o b j:  kernel.cf g   f a t d i r .c   f a t f s . o b j:  kernel.cfg   f a t f s .c   f a t t a b . o b j:  kernel.cfg    fattab.c   fcbfns.obj:  kernel.cfg   fcbfns.c   initoem.obj:  kernel.cfg   initoem.c   i n t h n d l r . o b j:  kernel.cfg   inthndlr.c   i o c t l . o b j:  kernel.cfg   i o c t l .c   main.obj:  kernel.cfg  main.c   memmgr.obj:  kernel.cfg  memmgr.c   mi sc. obj:  kernel  .cfg  mi s ec   dosnames.obj:  kernel.cfg   dosnames.c   p r f . o b j:  kernel.cfg  prf.c   s t r i n g s . o b j:  kernel.cfg  strings.c   sysclk.obj:  kernel.cfg  sysclk.c    DOS-C Kernel: Putting It All Together — 283   Now build DOS-C. First, change directory to the DOS-C root direc  tory. Next, enter the command build  and the process begins. The batch  file changes directory to each component  directory  and executes  ma ke  with the target product i on specified. This usually takes a few minutes.  When it completes, the di st  directory contains all the executable com  ponents of DOS-C. This is a simple procedure to build an entire operat  ing system.   Listing 8.1  Kernel makefile  kernel   .mak — continued.   syscon.obj: kernel.cfg syscon.c  syspack.obj: kernel.cfg syspack.c  systime.obj: kernel .cfg systime.c  task.obj: kernel.cfg task.c  apisupt.obj: kernel.cfg apisupt.asm   $ ASM  $ AFLAGS  APISUPT.ASM,APISUPT.OBJ   asmsupt.obj: kernel.cfg asmsupt.asm   $ ASM  $ AFLAGS  ASMSUPT.ASM,ASMSUPT.OBJ   execrh.obj: kernel.cfg execrh.asm   $ ASM  $ AFLAGS  EXECRH.ASM,EXECRH.OBJ   procsupt.obj: kernel.cfg procsupt.asm   $ ASM  $ AFLAGS  PROCSUPT.ASM,PROCSUPT.OBJ   stacks.obj: kernel.cfg stacks.asm   $ ASM  $ AFLAGS  STACKS.ASM,STACKS.OBJ   proto.h:  $ CSRC  $ LIBCSRC1  $ LIBCSRC2  $ LIBCSRC3  $ LIBCSRC4    echo  * proto.h generated by make *  > proto.h  echo undef _P »  proto.h  ..\utils\proto $ CSRC   ..\utils\proto $ LIBCSRC1   ..\utils\proto $ LIBCSRC2   ..\utils\proto $ LIBCSRC3   ..\utils\proto $ LIBCSRC4   echo Don't forget to edit proto.h for version control  ^Compiler Configuration File*     kernel.cfg: kernel.mak  copy &&  $ CFLAGS    kernel.cfg    284 — The FreeDOS Kernel   Now, look at another potential activity. Add a feature to the DOS-C  kernel. Add function  80h, which outputs a message when invoked. You  will need to modify the file i nthndl  r. c to add the new system call and  a test program, test80. c  Listing 8.2 , to test the new feature.   The new function call is simple. Use the built-in pri ntf     function to  output the test message and the contents of the  a 1  register. Then negate the  a 1  register and return. It easily could have been a more complex call, sim  ilar to some of the  other DOS-C system calls, but this serves the purpose.  Edit  i nthndl  r. c  Listing 6.4  and add the code from Listing 8.3 to  the  int21_service      switch.  Build  the  new  kernel  in  the  kernel  directory with the command  ma ke  - f  kernel  kernel  . exe to build a  debug version  of the kernel. The  ma ke builds the kernel  and when  it's  complete, you proceed to make a test disk.   Listing  8.2  Test program   test  80. c.   include     include      define  TESTFN  0x80   void  main void   r  i   union  REGS  regs;  p r i n t f   " S t a rt  test  regs.h.ah  =  TESTFN;  regs.h.al  =  0x12;  int86 0x21,  &regs,  &regs ;  printf "Done.\n  Function  returned  0x%02x\n",  regs.h.al ;    *  our  new  system  call   - - \ n "  ;   *    }   Listing  8.3  New system call  80h.   case  0x80:   printf "System  Call  received 0x%02x\n", r -> AL ;  r -> AL = - r -> AL ;  break;    DOS-C Kernel: Putting It All Together — 285   First, switch to the di st  directory and use the sys command to cre  ate a bootable floppy disk. Next,  switch back to the  kernel  directory  and copy  kernel  .exe  onto the  disk,  overwriting  the  distribution  ker  nel. Finally, copy  test80. exe to the disk. It is that  simple to create a  test disk. In fact, once you have a bootable floppy disk, all you need to  do is copy  kernel  . exe to it because the loader,  i pi  . sys, has the capa  bility to load EXE files. Reboot the system and run  test80.  It returns  the message "System Call received Oxee".   Testing the Kernel   or Did I Really Want to Do  This?   Now comes the fun part — testing your new kernel. Many times, you will  make a change and the kernel will simply not work. The question is: what  do you do then? Take a look at debugging techniques that may be used to  debug any stand-alone operating system or embedded application   You have a number  of debugging  options. The first is to place spe  cial messages throughout code. This technique proves quite useful  and  is quick, low cost, and effective  when the program that you are debug  ging is running, just incorrectly.   With DOS-C, this option is built into the kernel at a few key places.  Also, if you look at  i nt  21h function  33h subfunction  Ofdh  and Of f h,  you will see two debug toggles used for read and write system calls and  system calls in general. These prove quite helpful in determining what a  user program is doing.   However,  this  type  of  debugging  generally  cannot  handle  tougher  problems.  For  example,  wild  pointers  and  uninitialized  variables  require  guess  work to  specifically  dump the  affected  area.  Often,  this  type of problem doesn't manifest  itself until a particular application or  sequence  of events  occur. That  is when  guess  work  and iterative  tests  become time consuming.    286 — The FreeDOS Kernel   However,  there  are  other  software  alternatives. The first is  simula  tion. Using this technique, you build  a special version  of the program  and run it under a well-behaved operating system. DOS-C has a special  version called  kdb.  kdb is a small command line interpreter that  simu  lates system calls into the kernel and allows the user to set and examine  variables.  It  is  particularly  useful  during  the  initial  debugging  stages  when algorithms are being tested and if a good source-level debugger is  available for the particular C compiler you are using.   Another especially useful  technique is remote debugging. With this  technique, you first load a small debugger onto the target system or in  ROM. Then, using the host, load the program to be debugged onto the  target system. The host system then allows you to examine levels, sin  gle  step,  set  break  points,  and  perform  other  general  source-level  debugging. Much of DOS-C application testing was done using a com  mercially available remote debugger. The package used during DOS-C  development  required  building  a  special  target  program  that  included  some  special  startup code. To handle this, a special makefile  was cre  ated  that  built  the  special  debug  target.  However,  these  systems  cost  many hundreds of dollars.   The disadvantage  of this technique is that when your target  system  crashes, you may have no way of performing  a post mortem, especially  if the code you are testing is in RAM. A wild pointer or an infinite loop  can quickly overwrite the program or the data area with usually no way  of stopping or breaking the program.   The optimum technique  is to use  an in-circuit  emulator,  which  has  all the  advantages  of remote  debugging, but with  additional  hardware  support. With an in-circuit emulator, you remove the processor from the  target  under  test  and replace  it with  an umbilical  to  special  hardware  connected to the host. This hardware simulates the processor  and adds  special  hardware  break  points  not  normally  available  to  remote  soft  ware  debuggers.  For  example,  if  you  have  a  particular  variable  that  mysteriously  changes during debugging, you can set a hardware break  point on a write to that one location or range of locations. When a write  occurs, the  in-circuit  emulator  will  stop  and  show  you  exactly  which  instruction in your code is doing the errant write.    DOS-C Kernel: Putting It All Together — 287   In-circuit  emulators  also  have  other  features,  such  as  trace  stacks,  which  store  some  past  sequence  of  instructions. You  can  turn  on  the  trace buffer  and stop, then look at all the history within the buffer.  This  is  especially  useful  when  examining  loop  terminations  and  hardware  interrupt  timing.  Some  models  even  have built-in  profiling  logic  that  will do a profile of your code nonintrusively.   So,  what's  the  catch?  Cost.  In-circuit  emulators  typically  cost  thou  sands  of  dollars  and  some  are literally  full-blown  workstations  that run  into the tens of thousands. The price for debugging ease may be expensive.  It is all a matter  of your  application  and budget. If you  are writing  the  operating  system  for  a  multimillion  dollar  realtime  application,  multiple in-circuit emulators are probably appropriate. If you are doing  a midnight  engineering job  on  a budget,  remote  debugging  or  simple  printf       statements  will  do  fine.  It  is  up  to  you  to  determine  your  debugging technique.   Where Do You Go From  Here?  It is all up to you. I have presented you with a look into an operating sys  tem that performs like a popular well-known operating system, MS-DOS.  What you do with it is your choice.   You can use it to customize your environment and build special fea  tures into it to support your application. You can also make some minor  changes  and  embed  it  into  an  application  as the  embedded  operating  system,  or you  can  simply  change  main     and  fall  directly  into  your  application.  Or you  can use  it  as  an example  to better  understand  the  principles of an operating system.   The choice is yours. You now have a good understanding of DOS-C  and the source code is for you to use within the DOS-C license terms.  Use it as a tool and good luck.    288 — The FreeDOS Kernel    Appendix A   A Note about  Portability   Portability is an issue from  which hardly anyone can escape. Develop  ers encounter  pressures  daily, from  management  and customers  alike,  to develop portable code. In a typical project, it may be desirable to use  the same source code for different  platforms  in order to create a wider  market for the end product. Also, with technology rapidly changing, the  code developed today will probably be reused on the next generation of  hardware, necessitating portable design techniques. Additionally,  shar  ing  the  code  base  among  different  processors  greatly  eases  software  maintenance problems.   289    290 — The FreeDOS Kernel   The C programming language is a major contributor to portability. It  is ubiquitous and standard. By using C, today's developer accomplishes  a significant  degree of portability but is also lulled into a false  sense of  security  by  the  language's  features.  C  library  functions  may  behave  differently  with  different  operating  systems. There  are  also  semantic  problems with the language itself. For example, integer size is variable,  depending on the target machine. With segmented architecture proces  sors,  another  variable  is  pointer  size  and  memory  organization  when  the pointer is in memory. Yet another difference  is the order of bits in  bit  fields.  These,  and  other  factors,  present  quite  a  challenge  to  the  developer.   When I originally began the design of the predecessor to DOS-C, I  had already tackled portability problems in my designs of real-time and  embedded  systems  using  both  8-bit  and  16-bit  processors.  I had  also  standardized  on  C in  the  early  1980s  to  help bring  these  products  to  market faster. This experience proved invaluable when a potential cus  tomer  approached  me  to  make  it  available  on  a  non-Intel  platform.  Encouraged by this customer, I undertook the task of writing a portable  operating system.   One important  part of the design  was to ensure processor  indepen  dence in the code. The first step in achieving this goal was to minimize  the amount of assembly code. The second step was to guarantee porta  ble C code with stringent design rules to guarantee word size and byte  order independence.   I  guaranteed  meeting  these  design  rules  with  the  architecture  described  in Chapter  3 and by designing  a portable  set of types that I  could  change to match the capability  of the target  processor  with  the  use  of  the  C preprocessor  ifdef.  These  portable  types  allow  me  to  guarantee  that  the  physical  disk  structures  are processor  neutral.  The  need for portable types becomes evident by studying the DOS file sys  tem.  A  quick  examination  of  the  MS-DOS  FAT  file  system  reveals  three simple types: 8-bit, 16-bit, and 32-bit. I achieved part of the goal  by  simply  casting  the  8-bit type to  char  and the  32-bit type to  1 ong.  However,  an  int  is not  a good  choice  for  the  16-bit type because  its  length may be either  16-bit or 32-bit depending on the target processor.    A Note about Portability — 297   Casting the  16-bit type to a short  guarantees the  16-bit length. Addi  tionally, I needed to guarantee the representation  of these variables as  both  signed  and  unsigned  values,  so creating  another  unsigned  set  guaranteed  non-negative values for ANSI-C compilers.  Unfortunately,  one of the target machines  only had K&R C available, which compli  cated the issue because K&R C doesn't have some unsi gned types.   I did not want to depend on familiarity with C types in order to recog  nize the size of the variable, so I decided to create aliases so they stand  out in even the most cursory browsing of the  code. I chose the following:  BYTE;  typedef char  WORD;  typedef short  DWORD;  typedef long  typedef unsigned  char  UBYTE;  typedef unsigned  short  UWORD;  typedef unsigned  long  ULONG;  typedef short  SHORT;  ifdef  STRICT  typedef signed  long  LONG;  else  define  LONG  long  endif   Pointer  size and organization  are another  area of concern  for  com  patibility. As you know, the 80x86 family  has a real mode designed to  be  compatible  throughout  the  entire  family.  This  guarantees  upward  compatibility  from  the  8088.  DOS  is  a  real  mode  operating  system  originally designed for the 8088. Many of the DOS system calls require  far  pointers  in  the  form  of  segment:offset.  To take  advantage  of  the  32-bit  linear  protected  mode,  a  layered  product,  such  as  a  DOS  extender or the Windows GUI, supplies protected mode enhancements.    292 — The FreeDOS Kernel   This means that DOS clone designers must make use of C  constructs  such as  far  and memory models  such as small. Because DOS-C itself  is  small  enough  to  fit  into  the  small  model   separate  code  and  data  areas,  each  less than  64Kb , I decided  to take  advantage  of the  small  model  so that  I would  have tighter  and  faster  code  than  if  I used  the  large model   separate code and data areas, each with as much as  1Mb  of  memory . However,  the tradeoff  for  this  decision  is that  any  refer  ence  to  memory  outside  of  DOS-C  must  be  a  far  reference,  and  the  segment:offset  pair must be adjusted.  Unfortunately,  compilers for lin  ear machines may not support the far  and near keywords. The method  I chose to simplify  this requirement is:   ifdef      define FAR far   define NEAR near  endif  ifdef     define FAR   define NEAR  endif   With this approach you compile all files with a command line option  to switch between the architectures  i.e.,  - DI86 for 80x86,  - DMC68K for  680x0,  etc. . When  the  preprocessor  completes  its  pass,  architecture- dependent  features  such as the  far  are expanded to either  "far"  or " "  depending on the architecture.   Finally, the issue of byte order differences  between in-memory  and  disk  images  of  file  system  variables  is  addressed  whenever  data  is  transferred  between a disk data structure member and a memory struc  ture member. The in-memory  version  is  always the native  representa  tion by default.  I did not want to waste time by manipulating  it every  time  the  program  needed  to  access  an  in-memory  variable.  However,  when I transfer the variable to or from a disk buffer,  I invoke the appro  priate conversion function. This function  is either a preprocessor macro  or  a  C  function,  depending  on  whether  or  not  the  target  is  a  native  80x86  processor.  When  I  compile  a  native  version,  a  preprocessor    A Note about Portability — 293    LONG  *     v p      WORD  *     v p     *     v p      BYTE   *     l p   *     w p   *     b p   FAR  FAR  FAR  FAR  FAR  FAR   * L0NG  * W0RD  * BYTE   * L0NG   * W0RD   * BYTE   * L0NG   * W0RD   * BYTE   switch bypasses the conversion function  for the sake of efficiency.  This  was handled by the following code:  ifdef NATIVE  lp       define  getlong vp,   define  getword vp,  wp      define  bp     getbyte vp,   define  lp   fgetlong vp,   define  wp   fgetworcKvp,   define  fgetbyte vp,  bp    define  vp   fputlongClp,   define  vp   fputworcKwp,  vp    define  fputbyteCbp,  else  VOID getword VOID *, WORD  VOID getbyte VOID *, BYTE  VOID fgetlong VOID FAR  VOID fgetword VOID FAR  VOID fgetbyte VOID FAR  VOID fputlong LONG FAR  VOID fputword WORD FAR  VOID fputbyte BYTE FAR  endif   *     l p   = *   L O NG  FA R  *     w p   = *   W O RD  FAR  *     b p   = *   B Y TE  FAR  *     v p   = *   L O NG  FAR  *     v p   = *   W O RD  FAR  *     v p   = *   B Y TE  FAR   0;  0;  LONG  FAR  WORD  FAR  BYTE  FAR  VOID  FAR  VOID  FAR  VOID  FAR   *     v p     *     v p     *     v p     *     l p     *  wp    *  bp     The  conversion  functions  themselves  are  in  the  file  syspack.c    Listing A.  1 .    294 — The FreeDOS Kernel   Listing  A.l   syspack.c   is  part  of  DOS-C.    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   *    *   *   SYSPACK.C  *    *  *    *  System  Disk  Byte  Order  Packing  Functions  *    *  *    *  Copyright   c   1995  *    *  Pasquale  J.  V i l l a ni  *    *  All  Rights  Reserved  *    *  *    *  This  f i le  *    *  *    *  DOS-C  is  free  software;  you  can  redistribute  *    *  modify  it  under  the  terms  of  the  GNU  General  Public  License  *    *  as  published  by  the  Free  Software  Foundation;  either  version  *    *  2,   or   at  your  option   any  later  version.  *    *  *    *  DOS-C  is  distributed  in  the  hope  that  it  w i ll  be  useful,  but  *    *  WITHOUT  ANY  WARRANTY;  without  even  the  implied  warranty  of  *    *  MERCHANTABILITY  or  FITNESS  FOR A  PARTICULAR  PURPOSE.  See  *    *  the  GNU  General  Public  License  for  more  d e t a i l s.  *    *  *    *   You  should  have  received  a  copy  of  the  GNU  General  Public  *    *  License  along  with  DOS-C;  see  the  f i le  COPYING.  *    *  write  to  the  Free  Software  Foundation,  675  Mass  Ave,  *    *  Cambridge,   MA  02139,  USA.  *    *  *   ji<i<i<i<i<i<i<i<i<i<i<i<i<i<i<i<i<i<i<i<i<i<i<i<i<i<i<i<i<i<i<i<i<i<i<i<i<^   it  and or   If  not,   include  " . .   . .   h d r   p o r t a b . h"  include  "globals.h"    *  $Logfile:  ifndef  I PL  s t a t ic  BYTE  *syspackRcsId  =  "$Header:   D: dos-c src fs syspack.c_v   $  *    May  1996  21:15:12  endif   patv   $";   D: dos-c src fs syspack.c_v   1.3   29    A Note about Portability — 295   Listing  A.l   syspack.  c —  continued   1*  *  $Log:    k   D: dos-c src fs syspack.c_v   $   29  May  1996  21:15:12   patv   Rev  1.2   Rev  1.3   for  v0.91a   *  *  bug  fixes  -k  *  *  First  GPL  release.  -k  *  *  Eliminated  version  strings  -k  *  *  *    revision.   Rev  1.1   Rev  1.0   I n i t i al   01  Sep  1995  17:48:42   patv   30  Jul  1995  20:50:26   patv   in   ipl   02  Jul  1995  8:05:34   patv   ifdef  NONNATIVE  VOID  getlong   REG  VOID  *vp,  LONG  *lp   i  * lp  =     BYTE  * vp [0]  &  Oxff   +       BYTE  *   v p   [ l]  &  Oxff   «  8   +      BYTE  * vp [2]  &  Oxff   «  16   +      BYTE  * vp [3]  &  Oxff   «  24 ;   }   VOID  getword   REG  VOID  *vp,  WORD ^wp   i   VOID  getbyte   VOID  *vp,  BYTE  ^bp   t  ^bp  =  ^  BYTE  *   v p  ;  }   ^wp  =     BYTE  * vp [0]  &  Oxff   +      BYTE  *   v p   [ l]  &  Oxff   }   «  8 ;    296 — The FreeDOS Kernel   Listing A.l   syspack.  c — continued   VOID  fgetword  REG VOID FAR *vp, WORD FAR *wp   {  *wp =    BYTE FAR * vp [0] & Oxff  +      BYTE FAR * vp [l] & Oxff  « 8 ;  }  VOID  fgetlong  REG VOID FAR *vp, LONG FAR *lp   {  *lp =    BYTE * vp [0] & Oxff  +      BYTE * vp [l] & Oxff  «  8  +      BYTE * vp [2] & Oxff  «  16  +      BYTE * vp [3] & Oxff  « 24 ;   }  VOID  fgetbyte  VOID FAR *vp, BYTE FAR *bp   {  *bp = *  BYTE FAR * vp ;  }  VOID  fputlong  LONG FAR *lp, VOID FAR *vp   {  REG BYTE FAR *bp =  BYTE FAR * vp;  bp[0] = *lp & Oxff;  bp[l] =  *lp  »  8  & Oxff;  bp[2] =  *lp  »  16  & Oxff;  bp[3] =  *lp  »  24  & Oxff;  }  VOID  fputword  WORD FAR *wp, VOID FAR *vp   {  REG BYTE FAR *bp =  BYTE FAR * vp;  bp[0] = ^wp & Oxff;  bp[l] =  ^wp  »  8  & Oxff;  }    A Note about Portability — 297   \  Listing  A. 1   syspack.c  —  continued   VOID  fputbyte   BYTE  FAR  *bp,  VOID  FAR  *vp   1  * BYTE  FAR  * vp  =  *bp;   Ì  endif   VOID  getdirent   BYTE  FAR  *vp,  .  1  fbcopy &vp[DIR_NAME],  dp  fbcopy &vp[DIR_EXT],  dp  fgetbyte &vp[DIR_ATTRIB]  fgetword &vp[DIR_TIME],  fgetword &vp[DIR_DATE],  fgetword &vp[DIR  START],  fgetlong &vp[DIR_SIZE],   struct  di rent  FAR  *dp    ->  dir_name,  FNAME_SIZE ;  ->  dir_ext,  FEXT_SIZE ;  ,   BYTE  FAR  * &dp  ->  d i r _ a t t r i b  ;  ;W0RD  FAR  * &dp  ->  dir_time ;  ;W0RD  FAR  * &dp  ->  dir_date ;   WORD  FAR  * &dp  ->  d i r _ s t a r t  ;  ;L0NG  FAR  * &dp  ->  dir_size ;   VOID  putdirent   struct  di  rent  i  REG  COUNT  i ;  REG  BYTE  FAR  *p;   rAR  *dp,  BYTE  FAR  *vp    fbcopy dp  ->  dir_name,  &vp[DIR_NAME],  FNAME_SIZE ;  fbcopy dp  ->  dir_ext,  &vp[DIR_EXT],  FEXT_SIZE ;  fputbyte  BYTE  FAR  * &dp  fputword  WORD  FAR  * &dp  fputword  WORD  FAR  * &dp  fputword  WORD  FAR  * &dp  fputlong  LONG  FAR  * &dp  f o r  i  =  0,  p  =   BYTE  FAR  *p++  =  NULL;   ->  di  ->  di  ->  di  ->  di  ->  dir_size,  &vp[DIR_SIZE] ;  * &vp[DIR_RESERVED];  i  <  10;   r _ a t t r i b,  &vp[DIR_ATTRIB] ;  r_time,  &vp[DIR_TIME] ;  r_date,  &vp[DIR_DATE] ;  r_start,  &vp[DIR_START] ;   i++    }   }    298 — The FreeDOS Kernel    Appendix B   The FreeDOS Project:  Official FAQ File   This  document  is  intended  to  answer  frequently  asked  questions  that  arise regarding the FreeDOS Project  and its goals. Please take the time  to read this document to determine if your questions are answered here  before contacting project coordinators.   Revision  History  3 August  1996, M. "Hannibal" Toal, First  Draft   299    300 — The FreeDOS Kernel   General  Information   What Is the Goal of the FreeDOS  Project?  The goal of the FreeDOS Project is to create a completely free MS-DOS- compatible operating system. FreeDOS will run on all DOS-capable plat  forms, from XTs to Pentium Pros.   What Is the Reason for  FreeDOS?  There are many users who either do not have access to hardware that is  capable of running today's 32-bit operating systems  such as Windows 95,  OS 2, and UNIX  or who do not require the complexity of those systems.  FreeDOS  will  be  beneficial  for  businesses,  schools,  and  organiza  tions because there are no royalty payments. FreeDOS will be an option  for hobbyists, hackers, and anyone who would enjoy a chance to exam  ine or customize the source code and inner workings of a real operating  system for educational, practical, or recreational purposes.   What Will FreeDOS Not  Be?  FreeDOS will not be multitasking. It will not be object oriented. It will  not include a Graphical User Interface, a flat memory model, or operate  in 32-bit protected mode.   It's not that we do not desire any of these things. It is fun  and inter  esting to speculate about the capabilities of an advanced, 32-bit version  of FreeDOS. However, it is the goal of FreeDOS to complete  a  16-bit  MS-DOS-compatible  operating  system first, before  proceeding  in dif  ferent directions.    The FreeDOS Project: Official FAQ File — 301   Who Owns  FreeDOS?  Everybody and nobody. FreeDOS and its associated programs and doc  umentation  are protected  under the terms  of the GNU  General  Public  License  GPL . This means that FreeDOS can be freely copied, so long  as  there  is  no  attempt  to  restrict  further  copying.  All  copyrights  are  retained  by  the  original  authors.  All  source  code  will  be  publically  available.  See  the  full  text  of  the  GPL,  included  with  FreeDOS,  for  more  information.   How Is FreeDOS Project Development  Organized?  The  FreeDOS  Project  Committee,  a  group  of  the  senior  contributors  and participants involved with FreeDOS, is a group of individuals that  exists to make decisions and set standards for the FreeDOS  Project.   The  FreeDOS  project  consists  of  a number  of  specific  groups  and  each  of  these  groups  has  a  coordinator.  These  groups  are  the  utility,  shell, kernel, testing, and documentation groups.   Technical  Information   What Exactly  Is Included  in  FreeDOS?  FreeDOS will be a complete, independent operating system. It includes  a  kernel,  a  shell,  and  a full  complement  of  utilities. FreeDOS  uses  a  freeware  C compiler for all development work. Each is described sepa  rately in the following text.    302 — The FreeDOS Kernel   What Is the DOS-C  Kernel?  The kernel is the heart of  an operating  system. It is a special  program  that contains low-level functions  and routines to bridge the gap between  hardware and software. Pat Villani's DOS-C is the kernel that forms the  basis for the FreeDOS operating  system. DOS-C, as the name implies,  is  written  entirely  in  C  and  will  eventually  be  100 percent  MS-DOS  compatible.   What Is the FreeDOS  Shell?  A shell is an interactive program that is used to load and run other pro  grams and usually also provides a basic set of tools and functions  nec  essary to make a computer actually useful. Users familiar with MS-DOS  will know this program as command. com.   The FreeDOS  command. com  written by Tim Norman in cooperation  with  several  other  developers   provides  piping,  redirection,  command  line history and editing, several built-in functions, and batch file capabil  ity. Future versions will add enhancements such as command aliasing.   What Are the FreeDOS  Utilities?  The  utilities  that  accompany  an  operating  system  are  designed  to  enable a user to perform productive tasks and to control and customize  the computing environment.   The FreeDOS utilities include the traditional assortment of programs  that MS-DOS users will find familiar,  from  at t ri  b to  vol.  Some will  be slightly different,  some will be enhanced, and some will be new pro  grams that should have been included with MS-DOS long ago.   What Is the DDS MICRO-C  Compiler?  The MICRO-C compiler is a free C compiler writtten by Dave Dunfield  of Dunfield  Development Systems. MICRO-C is not officially  a part of  FreeDOS, as it is not published  under  the terms  of the GNU  General  Public License. MICRO-C is a capable and well-designed free  product  that was chosen as the standard compiler for FreeDOS programs until a  free compiler capable of producing 8086-compatible code is available.    The FreeDOS Project: Official FAQ File — 303   Will FreeDOS Run  on Some Particular  Machine?  Probably. The DOS-C kernel will run on virtually  all hardware that is  truly  IBM-PC  compatible. Very  old  hardware,  or  in  some  cases  very  new  or  unusual  hardware,  may  have  problems  running  DOS-C.  For  example, the DOS-C kernel does not currently deal properly with sec  ond hard drives.   Will FreeDOS Run  Some Particular  Program?  Maybe. Most of the problems that people have when running FreeDOS  are due to either bugs or unfinished parts of the DOS-C kernel. The lat  est version  v0.91a  of the DOS-C kernel is able to run WordPerfect  5.1  and DOOM. Microsoft Windows does not currently run under DOS-C.   Will FreeDOS Be Compatible with  Some Particular Version of  MS-DOS?  FreeDOS will be compatible with MS-DOS v3.30. The reason I chose  version 3.30 as a target is that there are very few fundamental  changes  between MS-DOS v3.30 and subsequent versions.   Specific Answers  to Common  Questions   Why Not  Use DJGPP?  DJGPP is a fine product, but it generates code for only 386+ machines.  Because the goal of FreeDOS is to run on all PC-compatible machines,  DJGPP is not suitable for FreeDOS development.    304 — The FreeDOS Kernel   Why Not Add 32-bit Multitasking  or  Other Advanced  Features?  Because we need to ship a  16-bit single-tasking product first. No such  free operating system exists. If we keep adding more and more features  to what we already have, this will indefinitely  prolong and delay com  pletion of FreeDOS.   The  goals  of the FreeDOS  Project  are clearly  defined.  If  you  have  need  for  a free  32-bit  multitasking  operating  system,  we  recommend  Linux or FreeBSD. Don't worry, you won't hurt our feelings.   Why  Use MICRO-C?  ItDoesnJt  Support  floats  or  This is absolutely true. Despite MICRO-C's few, specific limitations, it  is an excellent and free product. It is well suited to the task of construct  ing small command-line-oriented utilities.   typedefs!   Seriously — do you need to pay hundreds of dollars for an advanced  commercial  C C++  compiler  to  develop  a  program  like  xcopy?  By  choosing a free compiler to produce a free operating system, not only is  the FreeDOS project philosophically consistent with its own goals, but  it is easier for new people to participate in development because there is  no specific compiler to purchase.   But  Wait! Why Is the DOS-C Kernel Written in Borland  C?  Development  of the DOS-C kernel predates the birth  of the  FreeDOS  Project. Because of the DOS-C kernel's unique position as the  founda  tion  of  the  FreeDOS  operating  system  and  because  of  the  time  and  effort that would be required to port it to MICRO-C or some other com  piler, DOS-C development will continue under Borland C.    The FreeDOS Project: Official FAQ File — 305   I Can't  Get Some Program to Work.  Is FreeDOS Junk  or What?  You could  throw  up  your  hands  and  delete  FreeDOS  from  your  hard  disk if you run into problems while using it. Or you could be part of the  solution by sending us a detailed report of the nature of your particular  problem. If we are not aware of problems, we cannot correct them.   What Happened  to  FreeDOS?  It Seemed Dead for  a Long  Time.  FreeDOS  suffered  an extended period of inactivity due to the personal  obligations  of  project  coordinator  M.  "Hannibal" Toal. Now  that  this  period has passed, activity has resumed anew.   What Happened  to James  Hall,  the Originator of  FreeDOS?  James Hall graduated from college in 1995, and due to his personal and  career obligations, was no longer able to continue involvement with the  FreeDOS  Project.   How to Obtain More  Information   Where Is the Official FreeDOS Web Page?  The address of the FreeDOS web page is:   http:  sunsite.unc.edu pub micro pc-stuff freedos freedos.html    306 — The FreeDOS Kernel   Where Is the Official FreeDOS FTP  Site?  The address of the FreeDOS FTP site is:  % ftp sunsite.unc.edu  ftp> cd pub micro pc-stuff freedos   Is  There a Mailing  List for  FreeDOS?  The FreeDOS mailing list is maintained by the listserver on vpro. nl.   To subscribe to the mailing list:   free-dos-request@vpro.nl   mail  Subject:  subscribe  your@email.address   Any body text in the message is unnecessary and will not be read.   To cancel a subscription to the mailing list:   free-dos-request@vpro.nl   mail  Subject:  unsubscribe  your@email.address   You should use the same address that you used when subscribing.   To post a message to the mailing list:   mail   free-dos@vpro.nl   Note that only mail to be posted to the mailing list should be sent to the  address  free-dos@vpro.nl.  All  new  subscription  and  subscription  cancellation requests should be sent tofree-dos-reques  t@ v pro.nl.    The FreeDOS Project: Official FAQ File — 307   Is  There a Usenet Newsgroup for  FreeDOS?  FreeDOS  does  not  have  an  official  newsgroup.  However,  official  announcements  will occur  from  time to time  on the following  Usenet  newsgroups: comp.os.msdos.programmer  and  alt.msdos.programmer.   Who Are the Contact People for  FreeDOS?   Project Coordinator  M. "Hannibal" Toal   mtoal@arctic.nsbsd.kl2.ak.us   Kernel Development  Pat Villani   Shell Development   patv@iop.com   Tim Norman  normat@rpi.edu   Utility Development:  Bryon Quackenbush   odo@cris.com   Documentation   BearHeart  Bill Weinman   bearheart@bearnet.com   Testing   This could be you!  your@name.here    308 — The FreeDOS Kernel   What Other Documents  Exist?   Compatibility File  List of programs known to run under FreeDOS.*   FreeDOS Manifesto  A philosophical statement of Project goals.   Status File  Lists the status of all parts of the Project.   Development Standards  Guidelines  for  FreeDOS  Project  develop  ment.*      Denotes documents yet to be written.   FreeDOS is an ongoing project  and documentation  will be continu   ally updated. Check the FreeDOS home page at:  URL  http:  sunsite.unc.edu pub micro pc-stuff freedos   for the current status of all documentation.   How Can I Participate in FreeDOS  Development?  First,  congratulations  on  making  it  this  far! You  should  now  have  an  idea  about  what  FreeDOS  is, what  it  is  not,  and  where  the  project  is  heading. If you would like to become more involved:     Subscribe to the FreeDOS mailing list. Introduce yourself.     Download the latest FreeDOS release and try it out.     Obtain the Compatibility File and test some new unlisted programs.     Send us your results and opinions!    The FreeDOS Project: Official FAQ File — 309   If you are a crack programmer, or even an aspiring crack programmer:      Obtain and review the Status File and Development Standards.     Download MICRO-C and try it out a little bit.     Identify  a task and contact the appropriate development leader.     Hack some quality code and send it in!   Actually, there is not that much new code to be written. A lot of what  needs  to  be  done  is  porting  existing  code  to  MICRO-C,  along  with  extensive testing  and error reporting  to  assist  Pat Villani  with  DOS-C  development. FreeDOS is 90 percent completed, but the last  10 percent  always seems to take 90 percent of the time.    310 — The FreeDOS Kernel    Appendix C   DOS-C  Source Code   The full  source code for this book is now available on the pub­ lisher's  ftp  site  at  ftp.mfi.com pub rdbooks FreeDOS.zip;  login as "anonymous" and download the file. Any references to  the "companion code diskette" in the book now refer to the code  available on the ftp site. For more information, see the FreeDOS  home page at   http:  sunsite.unc.edu pub micro pc-stuff freedos   or my personal web page at   http:  www.monmouth.com user_pages patv   for updates.   311    312 — The FreeDOS Kernel   Before  You Start  I have made every effort to ensure that the code for this book builds and  boots on an IBM-compatible PC. You could simply copy the subdirec  tory dos - c to your hard drive and build a copy of DOS-C on your com  puter. However, I'd recommend that you do all your initial testing either  on  a separate test computer  or restrict  all operations  to floppy disk as  you verify  its operation. Make multiple copies of the distribution  code  on disks from which you can work. If you are working with a copy and  should accidentally destroy it, you can simply make another copy of the  code disk and continue working.   Building  DOS-C from  the Diskette  Copy the dos - c directory using xcopy, or a similar command, to a disk  drive containing  a minimum  of 5Mb of free  space. The distribution  is  not that large itself, but it requires that amount of space to compile. To  build the operating  system, a batch file  bui 1 d. bat   is included in the  dos - c directory. On invocation,  bui 1 d. bat  proceeds to each subdirec  tory  and builds the boot,  kernel, ipl, and utilities. When  it completes,  the newly created files are in dos - c\di st. In addition, there is a corre  sponding batch file  clean.bat   to clean up the source directories by  removing leftover files, such as *. ob j,  *. ba k, etc.    DOS-C Source Code — 313   Directory  Structure  d o s - c  root directory  +  +  +  +  +  +  +  +  +  +  +  +  +  +   di st  doc  h d r  1 ib  s r c  +  +  +  +  +  +  +  mise  +  tmp  uti  1 s  +   boot  command  dri vers  f s  i p]  kernel   holds image of distribution disk  documentation  directory  common *. h  files  1 i bm . l ib  and devi ce. 1 ib  source directories  for:   boot. bi n  command. com and hel p. exe  devi ce. 1 i b  common kernel and ipl f s manager files  i p] . SyS  kernel  .exe  miscellaneous files for  kernel  and  ipi   sys . exe   Organization  in a  Nutshell  Each component  or group of utilities  is  segregated  into its own direc  tory. Whenever common files are needed, they are removed and placed  in  a separate  directory.  To build  that  component  or utility,  a  makefile  exists in the directory that bears the component's or utility's basename.  Each  makefile  has  at  least  two  targets:  production  and  clean.  production  builds  the  expected  component  or  utility  and  clean  cleans up the directory for distribution. The makefile may have at least  one additional target that builds the component. I recommend that you  examine the component's  makefile  to better understand how the com  ponent is built.    314 — The FreeDOS Kernel   Building  a Bootable  Floppy  To create a bootable floppy:  1. Format a new floppy. Do not enter a label for the disk; otherwise, the   sys utility will report an error and abort.   2.  Make certain you are in the directory where the DOS-C distribution   files are stored. This is normally dos -c\di  st.   3.  Enter the command:   sys  a:   or   sys  b:   to transfer the system files to the diskette.   4.  Write protect this disk and boot from it.  Check the distribution disk for additional instructions that are unique to  this release.   DOS-C and FreeDOS  Jim  Hall  began  the  FreeDOS  project  when  Microsoft  began  making  public statements that it might not support MS-DOS in the future. This  statement  of  Microsoft's  marketing  plans  almost  immediately  makes  every IBM PC, XT, AT, and clones of these machines obsolete. If your  machine  is  not  at  least  an  80386   or  80486DX2-66,  as  it  turns  out ,  MS-DOS v6.22 is the last new release available to you. Combine this  with  the  software  market  following  Microsoft,  and  new  releases  of  popular applications are not likely, either. This move condemns you to  work  with  existing  applications  with  the  feature functionality  gap  growing every day. Jim decided that he would drum up support for an  independent MS-DOS operating system that would eventually pick up  where Microsoft  left  off.    DOS-C Source Code — 315   At  about  the  same  time,  I  was  working  with  1 inux  and  stumbled  across the dos emu project. I tried to run my DOS NT real-time operat  ing system and found  that I could boot it under  dos emu. I donated my  shareware  version  to the project  in the hopes that  it would  help  them  while  they  continued  to build  DOS  features  into the  emulator.  I even  considered  taking  the  responsibility  of  building  DOS  emulation  into  dos emu since  I  was  familiar  with  the  interface.  Jim  Hall  was  on  the  dosemu mailing list and became excited when he heard the news.   DOS-C  came  into being  when  I was  approached  by  Jim  Hall. Jim  told  me  about  his  effort  and  I  decided  not  to  build  the  interface  into  dosemu, but instead to build a stand-alone kernel that could also  func  tion  as  the  dosemu  kernel.  I  rewrote  the  original  DOS-C  kernel  to  remove copyrighted  material that I did not own because the FreeDOS  group wanted to be able to distribute source code under the GNU Pub  lic License. The result is what I have described in this book.   However, neither DOS-C nor FreeDOS are static. There are new fea  tures  and  functions  being  added  daily. There  are  new  commands  and  kernel enhancements, as well as bug fixes. Compatibility problems that  may be uncovered  during  kernel  testing  are fixed as they  arise, intro  ducing  yet  another  reason  for  continuous  updating.  Finally,  there  are  plans to move DOS-C and FreeDOS forward with features not found in  MS-DOS, so that future versions will have a broader appeal.   With this in mind, I urge you to check the FreeDOS  home page at  http:  sunsite.unc.edu pub micro pc-stuff freedos  or my per  sonal  web  page  at  http: www.monmouth .com user_pages patv  for  updates.   Please Help Us  The FreeDOS project is free  software.  It relies on the kindness of peo  ple  like  you  to  pitch  in  and  help  create  new  utilities,  document  the  project,  or simply test new software. That's where you come in. If you  can, please contact me at patv@i op. com or any of the individuals listed  in the FAQ  See Appendix  B . The  success  of the project  depends  on  your support.    316 — The FreeDOS Kernel    A  abort error message  88  absolute disk read  29  absolute disk write  29  accessing memory  5  address   and Intel 80286  5  break  29, 174  critical error  174  linear, with Windows and MS-DOS   v3.3+  5   and locator  13  terminate  174  termination  29   adjust_far    135  algorithm   in DOS-C design  131  emulating MS-DOS versions  16-17   API  201-238   assembly language handler  204  assembly language interface  205  C interrupt function handler and assembly   language equivalent  207-208   call anatomy  254-255  DOS functionality  layer, diagram  202  DOS-C  6-7,  63-64   arena management  66  int  21 h handler  64  personality layer  65  system call  63, 64   int  20h  203  int  21h  204  int  28h  203  i nt instruction  203  int_21service    206  int20_handler    204  int21_handler    205-209  int21_service    209-215  inthndlr.c  218  MS-DOS  4, 26-30   arena management calls  50  call methods  28-30  andCP M  3   Index   API, MS-DOS — continued   extending  10  int  20h-int  31 h system calls  28  int  2xh system calls  28  and OS 2  4  system calls list  29  personality layer  216  system call support  203-215   architecture dependency  203   architecture   command.com  243-253  and development  11-14  DOS-C  6-7,  56-58   design rule  64  kernel  62-63  floppy disk  24  hard disk  22-23   logical versus physical  24-26   MS-DOS  3-6,  17-21   logical file system organization  25, 27   archive binaries  277  arena management   see also memory manager, arena management  allocation strategy  147-160   allocation  147-153  deallocation  153-160   API calls  50  arena support functions  160-165   add_far   163-165  adjust_far   163-165  far2para   161-162  long2para    162-163   DOS-C  66, 145-165  MCB  145-146, 153, 155-156,  158-161   chain  146, 161   mcb  145-146  mcb_init    161  MS-DOS  49-50   arenaheader  data structure and members  49  asm  12,254  assembler, for development environment  12   317    318 — The FreeDOS Kernel   assembly   code for block and character device drivers  85  code for device drivers  75  code module for device driver call  73  in command. com batch language  268  data structure in MS-DOS  34, 52  andDOSLIB  253-254  in kernel  62  in MS-DOS source code  8  in operating system architecture  6  in support code  12  and task manager  68   attribute maintenance with d i r_a 11 r i b  104  autoexec.bat  40-41   and command. com with   p option  247  in DOS-C  56, 58, 61  in MS-DOS boot  20-21   B  b_blkno  90,93  b_flag  89-90,93  b_next  91  b_unit  90,93  b_update  89-90  backspace   characters with sto   , sti     ,_sto    ,and   _sti    79-80   and DosDisplayOutputO  217   batch   commands  267-273  file and command. com  242-243  language  267-268  processing  268-273   batch    265-268  batch_FLAG  268,272  bDumpRdWrParms  133  binary   commands and batch commands  268  compatibility  16  vs. cooked  225  distribution  276  executable  265   BIOS   and 80286  5  booting the OS  19  BPB  36-39  and DOS-C  57, 59  MS-DOS and OS 2  4  POST  18   bit field   in dhAttributes  53  in directory entry  46   blkno  87-88  block   data in disk drive array  24, 25  device  64, 220   and directory management  106-120  and FAT management  94-103  functionality  layer, diagram  84   device driver  6   and file management  128-141  interface diagram  85  device interface  84-94  I O functions,  structure diagram  85  I O interface  68  identifying  type and owner  66   blockio  68, 141  boot   area  33-39  block  31  DOS-C   architecture  56-58  booting stages  58-62  techniques  6   from floppy disk  17-21  from hard disk  32-33  MS-DOS  17   procedure  19-21   sector  24, 34-39   data structure and members  35  DOS-C  56   BPB  36-39  buffer   algorithm  8  and cache  121, 85  cache functions  118  chain operations  90-94  getblockO  93  keyboard  80, 83  line  80  LRU list to organize structures  85  management in DOS-C  68  trace  13,287  translation lookaside  203   build.bat  278  byte order  290, 292    c   C interrupt function  handler and assembly   language equivalent  207-208   C_INPUT  87  C_0UTPUT  86-87  C_0UTVFY  86-87  cache   block  132, 141  and buffers  85,121  functions  for buffers  118   Carriage Return  CR   79  carry  flag  211,215  cd  256-258  cd    256-257  cfglnit  242  cfglnitTail  242  chain   FAT  94  file cluster  141  int  2fh  multiplex interrupt  10  Least Recently Used, see LRU  multiplex  30  operations for buffer  90-94   chained system call  30  char_error    217  character device  6, 220, 224  chario  68  chario.c  75, 83  checksum  177  child   file handles and Terminate  51  parent-child relationship and   new_psp    181   processes and file sharing  121   ChildEnvO  177-179,187  clone   DOS  10  environment and DosExeLoader     190  file table in task management  67  parent process in DosComLoader     188   close   directory  120-121  file  141-142   pop_dmp    127  Close system call  228   Index — 319   cluster   bad  41  definition  36  anddir_open    114, 127  and dir_read      118  dir_start  105  f_back  108  f_boff  108  f_cluster  108, 140  f_node f_offset   140  f_sector  108  and FAT relationship  39  FREE  138  free  41  last  41  linking number  94  mapping  44  andrdwrblockO  137,138,141  recording  106  retrieving FAT cluster number  95-100  return next  94  translating  105  writing FAT cluster number  100-103   COM  file  171, 175, 182, 186, 187   andcs:05h  26   COM loader  181,182,184  command line interpreter  4  command.com  239-274  architecture  243-253  batch  file  242-243  batch processing functions  268-273  in booting stages  61  building into kernel  240-242  DOSLIB  253-255  external commands  259-267  internal commands  256-258  loading  240-242  in MS-DOS architecture  17, 18, 20-21  parsing a command line  241-242, 247-253   for options  257-267   reload  29   con_hold    79  config  240-242  config.sys  240-242  in booting stages  61  anddhLink  52  load process diagram  241  in MS-DOS boot  20-21  special arena calls  50    320 — The FreeDOS Kernel   console   device  220  I O support  217  and_sto    76  CPU in IBM-PC  3  crash   bad parameters passed to call  132  and f _n ode error  120  and FAT  32  and memory management  48  and remote debugging  286   create   device I O request in kernel space  75  and dir_read     and di r_write    117  and dir_write      118  anddos_findfirst    124  and media check  114  and  rdwrblock    138   cron  51  cursor and scr_pos  79  cylinder, disk  22-23   D  daemon  51, 204  data   structures  6   computing location  37  presented in this book  34  used in block and character device   interfaces  71-142   transfer  68,215   by block I O devices  85   data cluster indices  41  date  122   directory entry format in MS-DOS  47  field  46  maintenance with di r_date  104  updating with co mm and. com  247   day, see date  deAttri but e entry and attribute bits  46  DEBUG 211  debug target  286  debug version of kernel  284  debugger   inDOS-Cboot  60  factors in choosing  13-14   debugging   application  9  command.com 242  and in-circuit emulator  287  and in-circuit emulator  13  remote  14,286  and ROM emulator  13  a running program  285  simulation technique  286  source-level  14  and target architecture  13  technique for  kernel  . exe and   command.com  61   techniques for stand-alone operating system   or embedded application  285-287   deFileSize  47  delete and DosDi spi ayOutput      217  deleted file, hex notation  45  deName  45  density and media byte  37  descriptor   media  37  and memory management scheme  5   desktop computing, history of  2-6  deStartCluster  47  device   attribute mode  231  block  220   functionality  layer, diagram  84   character  220, 224   functionality  layer, diagram  76   console  220  control and embedded systems  9  determining FAT size  96  FAT handling  94  interface   block  84-94  character  75-83   null  220  virtual in MS-DOS and OS 2  4   device driver   data structure for communication  52  in DOS-C  6, 67-69  entries for error checking  38  functionality  layer  72  fundamental  in DOS  20  initializing  20  interface  85  interface in DOS-C  62, 72-75   see also  execrhO    device driver — continued   media type identification  37  in MS-DOS  52-54  and physical disk size limitations  33   device independence  224  devi ceheader  data structure and   members  52-53   dhdr  73  dhp  73,75  dir  18,44,272  dir_close    120-121  dir_open    108-115,123,127  dir_read    115,118,120,123  dir_write    114-121, 123  directory   see also FAT, directory  contents list  122   directory management, see FAT, directory   management   directory structure for DOS-C  276  di rent  data structure and members  104-  106, 118, 126-127   DIRENT_SIZE  118,120  dirmatch  124,127-130  disassembler and licensing agreement  8  disk   floppy   architecture  24  building a bootable  floppy  17  with IBM-PC  3  media storage history  2  storage model diagram  31   hard   architecture  22-23   logical versus physical  24-26   for IBM-XT  3  withanlPL  11  MS-DOS adjustments  for XT  4  and the XT  3-4   physical file organization  21-23   Disk Transfer Area, see DTA  diskette, see disk,  floppy  dmatch  130  DOS architecture   logical file system organization  25-27   DOS clone  10   embedded systems and device control  9   dos_close    141-142,182,188,237  dos_create    131   Index — 321   dos_find    125  dos_findfirst    122-130  dos_findnext    122-130  dos_lseek    236  dos_open    130-132,182,234  D0S_PSP  181  dos_read    132,188,195  dos_setfsize    237  dos_setftime    237  dos_write    132  DOSAPI examples  250-254  DOS-C   building a bootable  floppy  313  building from the distribution disk  312  directory structure  276-278,312  distribution disk  311-315  and FreeDOS history  314-315  history of  6-7  makefile  278-285  organization  313  project organization  276-285  DosCharlnputEchoO  213,217  DosCharOutputO  217  DosCloseO  228-230  DosComLoaderO  184-199  DosDisplayOutputO  213,217-218  DosDupHandleO  250  Dos Exec    182-184, 242, 265-268  DosExeLoaderO  189-199  dosfns  64,65,94  DosForceDupHandleO  250  DosMemAllocO  147-155, 179  DosMemChangeO  156-159  DosMemCheckO  159-160,204  DosMemFreeO  153-155, 159  DosMemLargestO  155-156,159  DosOpen      215,220-224,228,234,250,253-254  dosoptO  257  Dos Read 0  224-228  DosSetDriveO  252-253,257  dpb  101,103,107,111,113  dpb  struct  107  dpb_nfreeclst  102  dpb_size  96  drive  24  driver, initializing in DOS-C  56, 60  dskxferO  85-88,90  DTA  174,237  dta  128,181,200    322 — The FreeDOS Kernel   E  End Of File, see EOF  environment   applications, customizing  10  creating in DOS-C boot  61  customizing  287  development  11,278  modifying  co mm and. com buffer  space  247  process  169-182  setting up  20  tailoring  20   EOF  41,141,220,224,237   placing  43   error   checking by device driver  38  critical  29  handler and Terminate  51  handler, updating  50   exCheckSum  177  EXE file  171, 175-176, 182, 184, 189, 191, 193  and0:90h  28  and choice of compiler   linker  12  locator  13   andcs:05h  26  and Load and Execute Program  50  loader  60,61,67,181,182  loading from  i pi . sys  58  and MZ signature  67, 176, 182  ZM as EXE signature  176   exe_header  182, 191, 195  exe_header  data structure and   members  175-177   exec  265  exec_blk  242  exec_user    166-172,189,199-200  ExecCmdO  259-267,268  execrhO  68,72-75,78,88,217  execrh.asm  73  extension   and di r_open     114  for DOS  10  filename  44,45  maintenance with di r_ext  104  for MS-DOS  30   external commands for command. com  259-267  extns  265   F  f_dful1  106  f_node  structure and members  64-65, 105-  108, 140, 220-221, 224, 231, 237  allocation  65   far jump DOS entry  29  fast console I O  29  FAT  30   algorithm  37  area  39-43  and crash  32  and data area  39  directory management  104-121   close directory  120-121  di rent  104-105  f_node  106-108  open directory  108-115  read write directory entry  115-120   directory structure  44-47  disk storage model  31  entry values and meanings  41  fatdir.c  94  fatfs.c  94  fattab.c  94  file management  122-142   close  file  141-142  find  first next  122-130  more functions  142  open  file  131-132  read write  file  132-141   file system  30-47   functionality  layer diagram  95  functions  94-142  manager and f_node table  65   logical map  25  management  94-103   retrieving cluster number  95-100  writing cluster number  100-103   and physical disk drive limitations  33  physical map  27  read example  40  write example  42   FAT_MAGIC  96  fatdir.c  94  fatfs.c  94  fattab.c  94    Index — 323   FCB  50,215-220   function  support  230-238  functionality  layer, diagram  216  system call  26   f cb data structure and members  230-232,   235, 237   FcbCloseO  237-238  fcbfns  94  FcbNextRecordO  237  FcbOpenO  215,232-234  FebRead    234-237  file   see also FAT,  file  access  131  access rights  122  date  122  directory entry image  106  format generated by locator  13  internal representation of  115  locating  132  mode  132  position  107  size  105  starting cluster  105   File Allocation Table, see FAT  File Control Blocks, see FCBs  file management, see FAT, file management  file node, see  f_node  file system   inDOS-C  7  manager  64-65, 71-142   block I O handler  84-94  character I O handler  75-83  directory close  120-121  directory open  108-115  directory read write  114-120  dirmatch  124,127-130  dskxferO  85-88,90  execrhO  73-75,78,88  f_node  65, 106-108  and pointer arithmetic  163-165  FAT, see FAT  file close  141-142  file open  131-132  file read write  132-141  find first and find next functions  122-130   in MS-DOS for IBM-XT  4  andPSP  170  and psp  182   file table, system, see SFT  Fi 1 eAccess  254  FileName  254  filename   location of data relating to  32  maintenance with di r_name  104  name and extension method  45   file-not-found error  132  floppy,  see disk,  floppy  flushO  91  flush_buffers    91,121  f l u s h lO  88-89,91,94  FP_0FF    254  FP_SEG    254  FREE_PSP  155  FreeDOS  299-309  compatibility  303  contact information  305-307,315  DDS MICRO-C compiler  302, 304  documentation  308  and DOS-C history  314-315  FTP site  306  kernel  302, 304  mailing list  306  participation  308-309,315  project development organization  301  shell  302  Usenet newsgroup  307  utilities  302  web page  305   f s  64-65, 94, 106, 228  function   design rule  64  f_node  65  for file I O  64  in  ipl.sy s  60  in kernel  62  numbers in MS-DOS API  30   G  getblockO  90,92-94,  104  global environment block  243   H  handle  50, 51, 64, 132-134, 141, 182   duplicating  230  file  220   handle_break    167-172    324 — The FreeDOS Kernel   handler   error  226  idle  29  int  21h  174  int22_handler  181  int23_handler  181  int24_handler  181  interrupt system call  209  network  29  hard drive, see disk,  hard  HUGECOUNT 87      I O  67-68   redirection  250-252  in dosfns  64   ibmbio.sys  18-21  ibmdos.sys  18-21  ID   process  174  volume  126-127   in-circuit emulator and debugging  13  InDOS  205-206  init_buffers    91  init_kernel0  241  int  20h  203  int  21 h  10,204,254  int  21 h handler  174  int  28h  203  int  2fh  multiplex interrupt chain  10  i nt instruction  203  i nt  system calls  29  i nt xx-style real-mode device control  4  int20_handler    204  int21_handler    205-209  int21_service    206,209-215  intdosO  254  Intermediate Program Loader, see IPL  internal commands for command. com  256-258  interpreter   command line  4, 18, 20, 239-274   in DOS-C architecture  57   root  245, 247   interrupt   chaining  10  MS-DOS API design  28-30  multiplex  29  software  203-204  type  206   interrupt — continued   vectors  11   andnew_psp    181  and psp  174  and return_user    199   interrupt function declarations, built-in  204  interrupt system call handler  209  inthndlr.c  218,284  io.sys  17-21  IPL  7,11   in architecture  57-58  in booting stages  59-61  and development environment  11  and linker  12  in DOS-C history  7   ipl.sys  5 8   in booting stages  60-61   iregs  206,209  i ret  30, 166, 168, 209  ISFATI2  96-97   K  kb_count  80  kbfillO  80,83  kdb  286  kernel   adding feature  284  building  278-285  building command line interpreter   in  240-242   debug version  284  debugging  285-287  DOS NT  7  DOS-C  7, 12   architecture  62-63  in booting stages  57-62   MS-DOS  8   services  30   testing  285, 287  kernel.exe  58-59   in booting stages  60-61   keyboard   buffer  80, 83  input code  8  read with echo  213    L  label and file parsing  271-273  label_bat    272  LAST_CLUSTER  118  Least Recently Used, see LRU  link_fat    94-95,100  link_fatl2    100-103  link_fatl6    100-101, 103  linker   and development environment  12  and locator  13   load   command.com  240-242  process diagram  241   Load and Execute Program system call  50  Load Overlay system call  51  load program, methods  50-51  Load system call  51  loader   choosing type  60  COM  67, 181, 182, 184  dispatching EXE or COM  182  EXE  61,67,181,182  intermediate program, see IPL  andnew_psp    179, 181  program  182-199  and psp  172  taskinDOS-C  66  local_buffer  80,83  locate   . exe files in DOS-C  58  ipl.sys  60   locator   logical   and development environment  13  for device programmers  13   disk  31  file system organization  25, 27  sector  37-39  vs. physical file organization  24-26   lookaside buffer  203  IpBlock  91,93  IpFileName  215  IpLastBlock  93  IpMiddleBlock  93  LRU  8, 68, 90, 92  functionality  90  maintenance  92   Index — 325   M  MAGIC  182  MAXSHORT  87  MCB  49, 66, 145-146, 153, 155-156, 158-  161, 174  chain  146, 161  see also  arenaheader   mcb data structure and members  145, 146,   155,189   mcb_init    161  memmgr  66, 67  memory   allocated by loaders in task manager  67  deallocation by task manager  67  fixing operating system in  13  and I O handlers  68  initialization in assembler  12  Memory Control Block, see MCB  memory manager  143-144,145-165   adjust_far    135  allocation strategy  50  arena management  49-50   see also arena management   DOS-C  65-66   allocation strategy  66  arena management  66  MCB  66   MS-DOS  48-50   microkernel  7  migration path in MS-DOS history  5  MMU  146  mod  38  mod_sto    83  MS-DOS   API  26-30   arena management calls  50  int  2xh system calls  28   architecture  3-6,  17-21  assembly data structure  34, 52   msdos.sys  17-21  multiple function  MS-DOS API call  29  multiprogramming  80   local_buffer  80   multitasking  7   and the 80286  5  and the 80386+  5  and DOS-C task manager  145   MZ as EXE signature  67, 176, 182    326 — The FreeDOS Kernel   N  new_psp    179-182, 188  next_cll2    96,98-99  next_cll6    96-98  next_cluster    94-96   ISFATI2 macro source code  97   NOSPCL  80,83  Novell, extending DOS  10  NSS-DOS  7  null device  220   OEM  36  OldDrive  256  OS-neutral, see portability   o   p  parse   batch file for commands  268-272  command line  241-242, 247-253   for options  257-258   path  247,265,278  PC,  history of  3-6  pChildEnvSeg  179  platters, definition  22  pool   f_node  121  free memory  66  memory  51  pop_dmp    127  portability  289-297   and arena support functions  160  BIOS functions  and boot  20  byte order  290, 292  C vs. assembly source code  8  in DOS-C development  7  dosfns  65  in MS-DOS design  34  segmentation  290-292  and system call support  203  vs.  compatibility  146  word size  290   POST  18  PreConfigO  241  program loader  182-199  Program Segment Prefix, see PSP  prompt  247   psize  181  PSP  49, 170, 197, 221   creation  50   task manager  67   and Load Overlay  51  management  49-51  arena header  66  dosfns  64   and Terminate  51  and Terminate and Stay Resident  51   psp data structure and members  172-175,   179-182, 186, 188-190, 199, 237   R  r_count 226  r_huge 87  r_start 87  RAM and remote debugging  286  rdwrblockO  132-141,228  reentrant design  206  release_f_node    121  relocation  184, 190, 195, 197  capability in  kernel  .exe  58  memory management  48  and task manager  50, 67   relocation table  171,175-177  remote debugging  14, 286  requestheader  structure and members  53  ret  209  retf  168  rhp  73-74  ROM   and boot  59  and embedded system design  9  emulator  13-14  emulator and debugging  13  placing operating system into  13  using operating system in  13   root directory  32, 44   andf_node  106-107  and open  file directory  108   root interpreter  245, 247    Index — 327   s   scheduler  145  scr_pos  79,217  script   installation  267  language  268   SDK   C library for DOS-C  6  DOS for portability  7   sector interleave, definition  26  sector, definition  23  seek  67  segment  146   assigning  145  and device driver  52  reference  67, 176   correcting  50   registers in real vs. protected mode  5  value  49,66,188   segmentation  290-292  self test, see POST  setinvldO  91  SFT  219-222, 225, 229-235, 237   mapping  65   sft  data structure and members  219-222,   224-225, 227, 235, 237   share.exe  221  shell   permanent  258  see also interpreter  variables  271   short  291  software interrupt  203-204  software interrupt MS-DOS API call  28  spawn child processes  121  stack  186, 189, 199, 203-209   kernel  166  modifying  command. com buffer  space  247  pointer  177  user  168, 174, 181   stack space, switching  166  _sti    79-80,228  sti    80-83,227  _sto    76-80  sto    78-80  subcommand, coordinating with batch file 267  subdirectory  44   and dir_open    111-112  and f_node  107   subunit  86  sys  285  syspack.c  293-297  system call  29   flow diagram  205  support  203-215   System File Table, see SFT   T  tab, horizontal  HT   79  task manager  143-145,166-200   assembly language support  166-168   exec_user    166-172  handle_break    167-172   COM  file  50, 171, 174, 175, 182, 186,   187   COM loader  181,182,184  DOS-C  66-67   COM  files  66-67  EXE  files  66-67  PSP  67   DosExecO  182-184  and DosMemLargest    155  EXE  file  171, 175-176, 182, 184, 189,   191,193   EXE loader  181,182  exec_user    166-172,189,199-200  MS-DOS  50-51  new_psp    179-182, 188  process environment  169-182  PSP  50-51,  170, 197  psp  172-175, 179-182, 186, 188-190,   199   TempFunc  75  Terminate  29  Terminate and Stay Resident, see TSR  time   field  46  management, MS-DOS vs. DOS-C  69  MS-DOS directory entry format  47  stamping  46   maintenance with d i r_t i me      104   updating with co mm and. com  247   trace buffer  13,287  track, definition  23  TSR  29,51,199,204   and task manager  67   tsr  204    328 — The FreeDOS Kernel  u   UMB  49   V  virtual device in MS-DOS and OS 2  4   w   wildcard  125,130  word size  290   X  XFCB  233  XFR_READ  132,134  XFR_WRITE  132  xlt_fnp    132   Y  year in MS-DOS time stamping  46   z   ZM as EXE signature  176

@highlight

Ask anyone to define an operating system. I will bet that for every question you ask, you will receive a different answer. You may ask, "Is the definition of an operating system so vague?" I'm happy to answer — no. However, operating systems do mean different things to different people. To many computer users, it is the full collection of utilities and the kernel that drives their computer to run their favorite applications. To engineers working with small microprocessor systems, it may be the kernel and drivers together that makes a complex control system work. No matter what the definition, an operating system of one form or another is an integral part of software engineers' and users' lives. Also, operating systems are the subject of heated debates and argument. The debates range from the OS/2 versus Windows battles to the Berkeley versus System V UNIX debates. Lately, with the introduction of WindowsNT, the WindowsNT versus UNIX debate dominates discussions in many a workplace. These discussions typically result in heated debates that approach religious fervor over the choice of an operating system.