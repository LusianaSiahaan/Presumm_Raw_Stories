Java®  A L L - I N - O N E  5th Edition  by Doug Lowe   Java® All-in-One For Dummies®, 5th Edition Published by: John Wiley & Sons, Inc., 111 River Street, Hoboken, NJ 07030-5774, www.wiley.com  Copyright   2017 by John Wiley & Sons, Inc., Hoboken, New Jersey  Published simultaneously in Canada  No part of this publication may be reproduced, stored in a retrieval system or transmitted in any form or by  any means, electronic, mechanical, photocopying, recording, scanning or otherwise, except as permitted under  Sections 107 or 108 of the 1976 United States Copyright Act, without the prior written permission of the Publisher.  Requests to the Publisher for permission should be addressed to the Permissions Department, John Wiley & Sons,  Inc., 111 River Street, Hoboken, NJ 07030,  201  748-6011, fax  201  748-6008, or online at http:  www.wiley.com  go permissions.  Trademarks: Wiley, For Dummies, the Dummies Man logo, Dummies.com, Making Everything Easier, and related  trade dress are trademarks or registered trademarks of John Wiley & Sons, Inc. and may not be used without  written permission. All other trademarks are the property of their respective owners. John Wiley & Sons, Inc. is not  associated with any product or vendor mentioned in this book.  LIMIT  OF  LIABILITY DISCLAIMER  OF  WARRANTY:  THE  PUBLISHER  AND  THE  AUTHOR  MAKE  NO  REPRESENTATIONS OR WARRANTIES WITH RESPECT TO THE ACCURACY OR COMPLETENESS OF THE CONTENTS  OF THIS WORK AND SPECIFICALLY DISCLAIM ALL WARRANTIES, INCLUDING WITHOUT LIMITATION WARRANTIES  OF  FITNESS  FOR  A  PARTICULAR  PURPOSE.  NO  WARRANTY  MAY  BE  CREATED  OR  EXTENDED  BY  SALES  OR  PROMOTIONAL MATERIALS. THE ADVICE AND STRATEGIES CONTAINED HEREIN MAY NOT BE SUITABLE FOR  EVERY SITUATION. THIS WORK IS SOLD WITH THE UNDERSTANDING THAT THE PUBLISHER IS NOT ENGAGED  IN  RENDERING  LEGAL,  ACCOUNTING,  OR  OTHER  PROFESSIONAL  SERVICES.  IF  PROFESSIONAL  ASSISTANCE  IS REQUIRED, THE SERVICES OF A COMPETENT PROFESSIONAL PERSON SHOULD BE SOUGHT. NEITHER THE  PUBLISHER  NOR  THE  AUTHOR  SHALL  BE  LIABLE  FOR  DAMAGES  ARISING  HEREFROM.  THE  FACT  THAT  AN  ORGANIZATION OR WEBSITE IS REFERRED TO IN THIS WORK AS A CITATION AND OR A POTENTIAL SOURCE OF  FURTHER INFORMATION DOES NOT MEAN THAT THE AUTHOR OR THE PUBLISHER ENDORSES THE INFORMATION  THE ORGANIZATION OR WEBSITE MAY PROVIDE OR RECOMMENDATIONS IT MAY MAKE. FURTHER, READERS  SHOULD BE AWARE THAT INTERNET WEBSITES LISTED IN THIS WORK MAY HAVE CHANGED OR DISAPPEARED  BETWEEN WHEN THIS WORK WAS WRITTEN AND WHEN IT IS READ.  For general information on our other products and services, please contact our Customer Care Department within  the U.S. at 877-762-2974, outside the U.S. at 317-572-3993, or fax 317-572-4002. For technical support, please visit  https:  hub.wiley.com community support dummies.  Wiley publishes in a variety of print and electronic formats and by print-on-demand. Some material included with  standard print versions of this book may not be included in e-books or in print-on-demand. If this book refers to  media such as a CD or DVD that is not included in the version you purchased, you may download this material at  http:  booksupport.wiley.com. For more information about Wiley products, visit www.wiley.com.  Library of Congress Control Number: 2017934999  ISBN: 978-1-119-24779-1  pbk ; ISBN 978-1-119-24780-7  ebk ; ISBN 978-1-119-24781-4  ebk   Manufactured in the United States of America  10   9   8   7   6   5   4   3   2   1   Contents at a Glance  Introduction  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 1 Book 1: Java Basics   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 5 CHAPTER 1:  Welcome to Java  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 7 CHAPTER 2:	 Installing	and	Using	Java Tools  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 21 CHAPTER 3:	 Working	with	TextPad  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 35  Book 2: Programming Basics   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 43 CHAPTER 1:	 Java	Programming	Basics  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 45 CHAPTER 2:	 Working	with	Variables	and	Data	Types  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 65 CHAPTER 3:	 Working	with	Numbers	and	Expressions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 99 CHAPTER 4:  Making Choices  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 129 CHAPTER 5:	 Going	Around	in	Circles	 Or,	Using	Loops   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 151 CHAPTER 6:	 Pulling	a	Switcheroo  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 179 CHAPTER 7:	 Adding	Some	Methods	to	Your	Madness  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 193 CHAPTER 8:	 Handling	Exceptions   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 213  Book 3: Object-Oriented Programming  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 233 CHAPTER 1:	 Understanding	Object-Oriented	Programming   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 235 CHAPTER 2:	 Making	Your	Own	Classes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 249 CHAPTER 3:	 Working	with	Statics  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 267 CHAPTER 4:	 Using	Subclasses	and	Inheritance  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 277 CHAPTER 5:  Using Abstract Classes and Interfaces  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 299 CHAPTER 6:  Using the Object and Class Classes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 315 CHAPTER 7:	 Using	Inner	Classes,	Anonymous	Classes,	   and	Lambda	Expressions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 341 CHAPTER 8:	 Working	with	Packages	and	the	New	Java	Module	System  .  .  .  .  .  .  .  .  . . 353  Book 4: Strings, Arrays, and Collections  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 373 CHAPTER 1:	 Working	with	Strings  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 375 CHAPTER 2:	 Using	Arrays   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 393 CHAPTER 3:	 Using	the	ArrayList	Class  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 423 CHAPTER 4:  Using the LinkedList Class  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 437 CHAPTER 5:  Creating Generic Collection Classes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 449 CHAPTER 6:	 Using	Bulk	Data	Operations	with	Collections  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 463   Book 5: Programming Techniques  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 473 CHAPTER 1:	 Programming	Threads  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 475 CHAPTER 2:	 Using	Regular	Expressions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 505 CHAPTER 3:  Using Recursion  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 523 CHAPTER 4:	 Working	with	Dates	and Times  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 539  Book 6: JavaFX  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 561 CHAPTER 1:  Hello, JavaFX!  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 563 CHAPTER 2:  Handling Events  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 583 CHAPTER 3:	 Setting	the	Stage	and	Scene	Layout  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 603 CHAPTER 4:	 Using	Layout	Panes	to	Arrange	Your	Scenes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 625 CHAPTER 5:	 Getting	Input	from	the	User  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 659 CHAPTER 6:  Choosing from a List   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 681  Book 7: Web Programming  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 707 CHAPTER 1:	 Using	Java	Web	Start  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 709 CHAPTER 2:	 Creating	Servlets  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 721 CHAPTER 3:	 Using	JavaServer	Pages  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 741 CHAPTER 4:	 Using	JavaBeans  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 757  Book 8: Files and Databases  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 775 CHAPTER 1:  Working with Files   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 777 CHAPTER 2:	 Working	with	File	Streams   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 799 CHAPTER 3:	 Database	for	$100,	Please   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 827 CHAPTER 4:	 Using	JDBC	to	Connect	to	a	Database  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 845 CHAPTER 5:  Working with XML  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 861  Index  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 881   Table of Contents  INTRODUCTION   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 1 About	This	Book  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 2 Foolish	Assumptions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 2 Icons	Used	in	This	Book  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 3 Beyond	the	Book  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 4 Where to Go from Here  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 4  BOOK 1: JAVA BASICS  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 5 CHAPTER 1:  Welcome to Java  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 7 What	Is	Java,	and	Why	Is	It	So	Great?  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 8 Platform	independence  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 8 Object orientation  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 9 The	Java	API   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 10 The	Internet  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 11 Java versus Other Languages .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .12 Important	Features	of	the	Java	Language  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 13 Type	checking  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 13 Automatic	memory	management  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 15 Exception	handling  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 16 On the Downside: Java’s Weaknesses   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 16 Java	Version	Insanity  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 17 What’s	in	a	Name?  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 19 CHAPTER 2:	 Installing	and	Using	Java Tools  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 21 Downloading	and	Installing	the	Java	Development	Kit  .  .  .  .  .  .  .  .  .  .  .  . . 22 Downloading	the	JDK   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 22 Installing	the	JDK  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 23 Perusing	the	JDK	folders  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 23 Setting	the	path  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 24 Using	Java’s	Command-Line	Tools   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 26 Compiling	a	program   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 26 Compiling	more	than	one	file  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 27 Using	Java	compiler	options  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 28 Running	a	Java	program  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 29 Using	the	javap	command  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 31 Using Java Documentation  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 32 Java	SE	API	Docs  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 32 Java	Language	Specification  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 33  Table of Contents      v   CHAPTER 3:  Working with TextPad  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 35 Downloading	and	Installing	TextPad   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 35 Editing	Source	Files  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 36 Compiling	a	Program   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 39 Running	a	Java	Program  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 40  BOOK 2: PROGRAMMING BASICS  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 43 CHAPTER 1:  Java Programming Basics  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 45 Looking	at	the	Infamous	Hello,	World! Program   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 46 Dealing	with	Keywords  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 49 Working	with	Statements  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 51 Types	of	statements  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 51 White	space   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 52 Working	with	Blocks  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 53 Creating	Identifiers  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 55 Crafting Comments  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 55 End-of-line comments  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 56 Traditional	comments  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 56 JavaDoc comments  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 57 Introducing	Object-Oriented	Programming   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 57 Understanding classes and objects   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 57 Understanding static methods  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 58 Creating an object from a class  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 59 Viewing	a	program	that	uses	an	object  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 60 So	what’s	the	difference?  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 62 Importing	Java	API	Classes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 63 CHAPTER 2:  Working with Variables and Data Types  .  .  .  .  .  .  .  .  .  .  .  .  . 65 Declaring Variables  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 66 Declaring two or more variables in one statement  .  .  .  .  .  .  .  .  .  .  .  . . 67 Declaring class variables   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 67 Declaring instance variables   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 68 Declaring local variables  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 69 Initializing Variables   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 70 Initializing variables with assignment  statements  .  .  .  .  .  .  .  .  .  .  .  .  . . 71 Initializing variables with initializers  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 72 Using	Final	Variables	 Constants   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 72 Working	with	Primitive	Data	Types  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 73 Integer	types   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 75 Floating-point	types .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .76 The	char	type  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 78 The	Boolean	type  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 79 Wrapper	classes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 79 Using	Reference	Types  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 80  vi      Java All-in-One For Dummies   Working	with	Strings  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 82 Declaring and initializing strings  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 82 Combining strings  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 83 Converting	primitives	to	strings   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 83 Converting	strings	to	primitives   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 84 Converting and Casting Numeric Data  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 85 Automatic conversions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 85 Type	casting  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 86 Thinking	Inside	the	Box   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 87 Understanding	Scope  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 87 Shadowing	Variables  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 89 Printing	Data	with	System.out  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 90 Using	standard	input	and	output	streams   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 90 Using	System.out	and	System.err  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 92 Getting	Input	with	the	Scanner	Class  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 92 Importing	the	Scanner	class   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 93 Declaring	and	creating	a	Scanner	object  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 94 Getting	input   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 94 Getting	Input	with	the	JOptionPane	Class  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 96 Using	enum	to	Create	Your	Own	Data	Types  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 97 CHAPTER 3:  Working with Numbers and Expressions .  .  .  .  .  .  .  .  .  .  .  . 99 Working	with	Arithmetic	Operators  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 99 Dividing Integers  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 102 Combining	Operators  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 104 Using	the	Unary	Plus	and	Minus	Operators  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 105 Using	Increment	and	Decrement	Operators  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 106 Using	the	Assignment	Operator  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 108 Using	Compound	Assignment	Operators  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 110 Using the Math Class   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 111 Using constants of the Math class   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 112 Working with mathematical functions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 113 Creating random numbers .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .116 Rounding functions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 119 Formatting Numbers   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 121 Recognizing	Weird	Things	about	Java	Math .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .124 Integer	overflow  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 125 Floating-point	weirdness   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 125 Division	by	zero  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 126 CHAPTER 4:  Making Choices  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 129 Using	Simple	Boolean	Expressions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 130 Using	if	Statements  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 132 Simple	if	statements  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 132 if-else statements   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 134  Table of Contents      vii   Nested if statements  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 135 else-if statements   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 139 Using	Mr.	Spock’s	Favorite	Operators	 Logical	Ones,	of	Course   .  .  . . 141 Using	the	!	operator   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 142 Using	the	&	and	&&	operators   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 143 Using	the		and		operators   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 144 Using	the	^	operator  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 145 Combining	logical	operators  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 146 Using	the	Conditional	Operator   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 148 Comparing	Strings  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 149 CHAPTER 5:  Going Around in Circles  Or, Using Loops   .  .  .  .  .  .  .  .  . . 151 Using	Your	Basic	while	Loop  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 152 The	while	statement  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 152 A	counting	loop  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 152 Breaking	Out	of	a	Loop  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 154 Looping	Forever  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 154 Letting the user decide when to quit  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 156 Letting	the	user	decide	in	another	way  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 157 Using	the	continue	Statement  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 157 Running	do-while	Loops  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 159 Validating	Input	from	the	User  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 161 Using	the	Famous	for	Loop  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 163 Understanding	the	formal	format	of	the	for	loop   .  .  .  .  .  .  .  .  .  .  .  . . 164 Scoping	out	the	counter	variable   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 166 Counting even numbers  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 167 Counting backward  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 168 Using	for	loops	without	bodies  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 169 Ganging	up	your	expressions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 170 Omitting	expressions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 171 Breaking	and	continuing	your	for	loops .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .172 Nesting	Your	Loops  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 173 A	simple	nested	for	loop   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 173 A guessing game  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 174 CHAPTER 6:  Pulling a Switcheroo   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 179 Battling	else-if	Monstrosities  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 179 Viewing	an	example	else-if	program   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 180 Creating	a	better	version	of	the	example	program  .  .  .  .  .  .  .  .  .  .  . . 181 Using	the	switch	Statement  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 183 Viewing	a	boring	switch	example,	complete	with	flowchart  .  .  .  . . 184 Putting	if	statements	inside	switch	statements   .  .  .  .  .  .  .  .  .  .  .  .  .  . . 185 Creating Character Cases  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 186 Intentionally	Leaving	Out	a	Break	Statement  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 188 Switching	with	Strings  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 191  viii      Java All-in-One For Dummies   CHAPTER 7:  Adding Some Methods to Your Madness  .  .  .  .  .  .  .  .  .  . . 193 The	Joy	of	Methods  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 194 The	Basics	of	Making	Methods  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 195 An	example  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 196 Another	example  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 197 Methods	That	Return	Values  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 199 Declaring	the	method’s	return	type  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 199 Using the return statement to return the value  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 200 Using	a	method	that	returns	a	type  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 201 You	gotta	have	a	proper	return	statement  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 201 Trying	another	version	of	the	guessing-game	program   .  .  .  .  .  .  . . 203 Methods	That	Take	Parameters   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 206 Declaring	parameters  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 207 Scoping	out	parameters  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 208 Understanding	pass-by-value  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 209 Trying	yet	another	version	of	the	guessing-game	program  .  .  .  . . 210 CHAPTER 8:  Handling Exceptions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 213 Understanding	Exceptions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 214 Witnessing	an	exception  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 215 Finding	the	culprit  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 215 Catching	Exceptions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 216 A	simple	example   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 217 Another	example  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 218 Handling	Exceptions	with	a	Preemptive	Strike  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 220 Catching	All	Exceptions	at	Once  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 221 Displaying	the	Exception	Message  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 223 Using	a	finally	Block   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 223 Handling	Checked	Exceptions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 226 Viewing	the	catch-or-throw	compiler	error  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 226 Catching	FileNotFoundException   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 227 Throwing	the	FileNotFoundException   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 228 Throwing	an	exception	from	main  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 229 Swallowing	exceptions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 229 Throwing	Your	Own	Exceptions   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 231 Catching	Multiple	Exceptions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 232 BOOK 3: OBJECT-ORIENTED PROGRAMMING  .  .  .  .  .  .  .  .  .  .  .  .  . . 233 CHAPTER 1:  Understanding Object-Oriented    Programming  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 235 What	Is	Object-Oriented	Programming?  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 235 Understanding Objects  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 237 Objects	have	identity   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 237 Objects	have	type   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 238  Table of Contents      ix   Objects have state  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 239 Objects have behavior   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 240 Understanding	the	Life	Cycle	of	an	Object   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 240 Working with Related Classes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 241 Inheritance  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 242 Interfaces  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 242 Designing	a	Program	with	Objects  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 243 Diagramming Classes with UML  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 244 Drawing classes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 245 Drawing arrows  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 246 CHAPTER 2:  Making Your Own Classes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 249 Declaring a Class  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 249 Picking	class	names  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 250 Knowing	what	goes	in	the	class	body  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 250 Seeing	where	classes	go  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 251 Working with Members   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 253 Understanding	fields  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 253 Understanding methods   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 254 Understanding	visibility   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 254 Using	Getters	and	Setters   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 255 Overloading Methods  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 257 Creating Constructors  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 259 Creating basic constructors  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 259 Creating default constructors  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 260 Calling other constructors  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 262 Finding	More	Uses	for	the	this	Keyword  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 263 Using Initializers  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 265 CHAPTER 3:  Working with Statics  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 267 Understanding	Static	Fields	and	Methods  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 267 Working	with	Static	Fields   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 269 Using	Static	Methods   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 269 Counting Instances  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 270 Preventing	Instances  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 273 Using	Static	Initializers  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 274 CHAPTER 4:  Using Subclasses and Inheritance  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 277 Introducing Inheritance  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 277 Motorcycles,	trains,	and	automobiles   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 279 Game	play  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 279 A	businesslike	example   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 280 Inheritance hierarchies  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 280 Creating	Subclasses   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 281 Overriding Methods   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 283  x      Java All-in-One For Dummies   Protecting	Your	Members   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 284 Using	this	and	super	in	Your	Subclasses  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 284 Understanding	Inheritance	and Constructors   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 286 Using	final  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 287 Final methods   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 287 Final classes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 288 Casting	Up	and	Down  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 289 Determining	an	Object’s	Type  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 290 Poly	What?   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 292 Creating	Custom	Exceptions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 294 Tracing	the	Throwable	hierarchy   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 294 Creating	an	exception	class  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 296 Throwing	a	custom	exception  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 296 CHAPTER 5:  Using Abstract Classes and Interfaces  .  .  .  .  .  .  .  .  .  .  .  .  . . 299 Using Abstract Classes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 299 Using Interfaces  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 302 Creating a basic interface  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 303 Implementing	an	interface  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 304 Using	an	interface	as	a	type  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 305 More	Things	You	Can	Do	with	Interfaces  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 306 Adding	fields	to	an	interface  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 306 Extending	interfaces  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 306 Using interfaces for callbacks   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 307 Using Default Methods  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 311 CHAPTER 6:  Using the Object and Class Classes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 315 The	Mother	of	All	Classes:	Object  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 316 Every	object	is	an	Object   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 316 Object	as	a	type  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 316 Methods of the Object class .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .317 Primitives	aren’t	objects  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 319 The	toString	Method  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 319 Using	toString  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 320 Overriding	toString  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 321 The	equals	Method  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 322 Using equals  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 323 Overriding the equals method   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 324 The	clone	Method  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 328 Implementing	the	clone	method  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 329 Using	clone	to	create	a	shallow	copy  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 332 Creating	deep	copies   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 333 The	Class	Class  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 338  Table of Contents      xi   CHAPTER 7:  Using Inner Classes, Anonymous    Classes, and Lambda Expressions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 341 Declaring Inner Classes   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 342 Understanding inner classes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 342 Viewing	an	example   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 343 Using	Static	Inner	Classes   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 345 Using	Anonymous	Inner	Classes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 347 Creating	an	anonymous	class  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 347 Creating	a	program	with	an	anonymous	class  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 349 Using	Lambda	Expressions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 351  CHAPTER 8:  Working with Packages and the New Java    Module System  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 353 Working	with	Packages  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 354 Importing	classes	and	packages  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 354 Creating	your	own	packages  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 355 An	example  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 357 Putting	Your	Classes	in	a	JAR	File   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 358 jar	command-line	options   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 359 Archiving	a	package  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 360 Adding	a	jar	to	your	classpath  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 361 Running	a	program	directly	from	an	archive   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 362 Using	JavaDoc	to	Document	Your	Classes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 363 Adding JavaDoc comments   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 363 Using the javadoc command  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 366 Viewing	JavaDoc	pages  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 367 Using	the	Java	Module	System   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 368 Understanding modules  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 369 The	module-info.java	file  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 369 Setting	up	folders	for	a	module   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 371 Compiling	a	module   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 371 Creating	a	modular	JAR	file   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 372 BOOK 4: STRINGS, ARRAYS, AND COLLECTIONS  .  .  .  .  .  .  .  .  . . 373 CHAPTER 1:  Working with Strings  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 375 Reviewing	Strings .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .376 Using	the	String	Class  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 378 Finding the length of a string  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 380 Making	simple	string	modifications  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 380 Extracting	characters	from	a	string  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 381 Extracting	substrings	from	a	string  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 382 Splitting	a	string  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 384 Replacing	parts	of	a	string  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 386  xii      Java All-in-One For Dummies   Using	the	StringBuilder	and	StringBuffer	Classes   .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 387 Creating	a	StringBuilder	object  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 388 Using	StringBuilder	methods  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 388 Viewing	a	StringBuilder	example .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .390 Using	the	CharSequence	Interface  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 391 CHAPTER 2:  Using Arrays  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 393 Understanding	Arrays  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 393 Creating	Arrays   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 394 Initializing	an	Array  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 395 Using	for	Loops	with	Arrays  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 396 Solving	Homework	Problems	with	Arrays  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 397 Using	the	Enhanced	for	Loop   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 400 Using	Arrays	with	Methods  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 401 Using	Two-Dimensional	Arrays  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 401 Creating	a	two-dimensional	array  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 402 Accessing	two-dimensional	array	elements   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 403 Initializing	a	two-dimensional	array  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 405 Using	jagged	arrays  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 405 Going	beyond	two	dimensions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 407 Working	with	a	Fun	but	Complicated	Example:	A	Chessboard  .  .  .  .  . . 408 Using	the	Arrays	Class   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 416 Filling	an	array  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 417 Copying	an	array  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 417 Sorting	an	array  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 419 Searching	an	array .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .419 Comparing	arrays  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 420 Converting	arrays	to	strings  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 420 CHAPTER 3:  Using the ArrayList Class  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 423 Understanding	the	ArrayList	Class  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 424 Creating	an	ArrayList	Object  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 427 Adding Elements  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 428 Accessing Elements  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 429 Printing	an	ArrayList  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 430 Using an Iterator  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 430 Updating	Elements  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 432 Deleting Elements  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 434 CHAPTER 4:  Using the LinkedList Class  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 437 Understanding the LinkedList Class  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 438 Creating a LinkedList  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 442 Adding Items to a LinkedList  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 443 Retrieving Items from a LinkedList  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 445 Updating	LinkedList	Items  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 446 Removing LinkedList Items   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 447  Table of Contents      xiii   CHAPTER 5:  Creating Generic Collection Classes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 449 Why	Generics?  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 450 Creating a Generic Class  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 451 A	Generic	Stack	Class  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 453 Using	Wildcard-Type	Parameters  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 457 A Generic Queue Class  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 458 Using	the	Diamond	Operator   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 462 CHAPTER 6:  Using Bulk Data Operations with Collections  .  .  .  . . 463 Looking	At	a	Basic	Bulk	Data	Operation   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 464 Looking	Closer	at	the	Stream	Interface  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 467 Using	Parallel	Streams  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 470 BOOK 5: PROGRAMMING TECHNIQUES   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 473 CHAPTER 1:  Programming Threads  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 475 Understanding	Threads  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 476 Creating	a	Thread  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 477 Understanding	the	Thread	class  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 477 Extending	the	Thread	class   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 478 Creating and starting a thread   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 480 Implementing	the	Runnable	Interface  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 480 Using the Runnable interface   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 481 Creating	a	class	that	implements	Runnable  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 481 Using	the	CountDownApp	class   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 483 Creating	Threads	That	Work	Together  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 485 Using	an	Executor  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 489 Synchronizing	Methods   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 491 Creating a Lock   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 496 Coping	with	Threadus	Interruptus  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 497 Finding	out	whether	you’ve	been	interrupted   .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 498 Aborting the countdown   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 499 CHAPTER 2:  Using Regular Expressions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 505 Creating	a	Program	for	Experimenting	with	Regular	Expressions  .  . . 506 Performing	Basic	Character	Matching  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 509 Matching single characters   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 509 Using	predefined	character	classes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 509 Using custom character classes   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 512 Using ranges  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 513 Using negation  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 514 Matching	multiple	characters   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 514 Using	escapes .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .516 Using	parentheses	to	group	characters  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 516 Using	the	pipe	symbol   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 518  xiv      Java All-in-One For Dummies   Using	Regular	Expressions	in	Java	Programs   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 519 Understanding	the	String	problem  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 519 Using	regular	expressions	with	the	String	class  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 520 Using	the	Pattern	and	Matcher	classes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 521 CHAPTER 3:  Using Recursion  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 523 Calculating	the	Classic	Factorial	Example   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 523 The	nonrecursive	solution  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 524 The	recursive	solution .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .524 Displaying	Directories  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 526 Writing	Your	Own	Sorting	Routine  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 530 Understanding how Quicksort works  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 530 Using the sort method  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 531 Using	the	partition	method  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 532 Putting	it	all	together   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 534 CHAPTER 4:	 Working	with	Dates	and Times  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 539 Pondering	How	Time	is	Represented  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 540 Picking	the	Right	Date	and	Time	Class	for Your	Application  .  .  .  .  .  .  . . 541 Using	the	now	Method	to	Create	a	Date-Time	Object  .  .  .  .  .  .  .  .  .  .  .  . . 542 Using	the	parse	Method	to	Create	a	Date-Time	Object  .  .  .  .  .  .  .  .  .  .  . . 544 Using	the	of	Method	to	Create	a	Date-Time	Object  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 545 Using the Month enumeration   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 545 Using the ZoneId class  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 547 Using	the	ZoneOffset	class  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 548 Looking Closer at the LocalDate Class  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 548 Extracting	Information	About	a	Date  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 550 Comparing	Dates  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 551 Calculating with Dates   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 552 Formatting Dates  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 554 Looking	at	a	Fun	Birthday	Calculator  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 556  BOOK 6: JAVAFX   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 561 CHAPTER 1:  Hello, JavaFX!  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 563 Perusing	the	Possibilities	of	JavaFX  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 564 Looking	at	a	Simple	JavaFX	Program   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 566 Importing	JavaFX	Packages   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 567 Extending	the	Application	Class   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 568 Launching	the	Application  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 569 Overriding the start Method  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 570 Creating	a	Button   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 572 Handling an Action Event  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 573  Table of Contents      xv   Creating	a	Layout	Pane  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 574 Making	a	Scene  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 576 Setting	the	Stage  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 576 Examining	the	Click	Counter	Program  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 577 CHAPTER 2:  Handling Events  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 583 Examining	Events   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 584 Handling Events  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 585 Implementing	the	EventHandler	Interface   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 587 Handling Events with Inner Classes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 591 Handling	Events	with	Anonymous	Inner Classes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 593 Using	Lambda	Expressions	to	Handle	Events  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 596 CHAPTER 3:  Setting the Stage and Scene Layout  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 603 Examining	the	Stage	Class  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 604 Examining	the	Scene	Class  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 607 Switching	Scenes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 609 Creating	an	Alert	Box   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 613 Exit,	Stage	Right  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 618 Creating a Close button  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 619 Handling the CloseRequest event  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 621 Putting	it	all	together   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 622 CHAPTER 4:  Using Layout Panes to Arrange Your Scenes  .  .  .  .  . . 625 Working	with	Layout	Panes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 626 Introducing	five	JavaFX	layout	panes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 626 Creating	layout	panes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 626 Combining	layout	panes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 628 Using	the	HBox	Layout  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 628 Spacing	Things	Out  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 630 Adding	Space	with	Margins  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 632 Adding	Space	by	Growing	Nodes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 633 Using	the	VBox	Layout  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 635 Aligning	Nodes	in	a	Layout	Pane  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 637 Making	Nodes	the	Same	Width  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 638 Using	the	Flow	Layout  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 639 Using	the	Border	Layout   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 643 Using	the	GridPane	Layout   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 645 Sketching	out	a	plan  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 646 Creating	a	grid	pane  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 647 Working	with	grid	pane	constraints  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 650 Examining	a	grid	pane	example   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 652  xvi      Java All-in-One For Dummies   CHAPTER 5:  Getting Input from the User  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 659 Using	Text	Fields  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 660 Validating Numeric Data .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .667 Using	Check	Boxes   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 668 Using	Radio	Buttons  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 671 Looking	at	a	Pizza	Order	Application  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 673 CHAPTER 6:  Choosing from a List  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 681 Using	Choice	Boxes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 681 Creating	a	choice	box  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 683 Setting	a	default	value   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 684 Getting the selected item  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 685 Working with Observable Lists   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 685 Listening	for	Selection	Changes   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 688 Using	Combo	Boxes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 690 Creating	combo	boxes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 691 Getting the selected item  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 692 Handling	combo	box	events   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 693 Using List Views  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 694 Creating a list view  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 695 Getting the selected items  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 696 Using	Tree	Views  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 696 Building	a	tree  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 698 Creating	a	TreeView	control  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 701 Getting the selected node   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 702 Looking	at	a	complete	program	that	uses	a	tree	view  .  .  .  .  .  .  .  .  . . 704 BOOK 7: WEB PROGRAMMING   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 707 CHAPTER 1:  Using Java Web Start  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 709 Looking	at	a	Simple	JavaFX	Program   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 709 Understanding	Java	Web	Start  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 712 Creating	a	JNLP	File  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 713 Creating	an	HTML	File	to	Launch	a	Java	Application   .  .  .  .  .  .  .  .  .  .  .  .  . . 715 Uploading	the	Java	Web	Start	Files	to	Your	Web	Server  .  .  .  .  .  .  .  .  .  . . 716 Launching	the	ClickMe	Application	Using	Java	Web	Start  .  .  .  .  .  .  .  .  . . 717 Creating	an	Exception	to	Allow	Java	Web	  Start	Applications	to	Run  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 718 CHAPTER 2:  Creating Servlets  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 721 Understanding	Servlets   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 721 Using	Tomcat  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 723 Installing	and	configuring	Tomcat  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 723 Starting	and	stopping	Tomcat  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 724 Testing	Tomcat  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 725  Table of Contents      xvii   Creating	a	Simple	Servlet  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 726 Importing	the	servlet	packages  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 726 Extending	the	HttpServlet	class  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 726 Printing	to	a	web	page  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 727 Responding	with	HTML  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 727 Running	a	Servlet  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 730 Improving	the	HelloWorld	Servlet  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 730 Getting	Input	from	the	User   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 732 Working with forms  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 732 Using	the	InputServlet	servlet  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 734 Using	Classes	in	a	Servlet  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 735 CHAPTER 3:  Using JavaServer Pages  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 741 Understanding	JavaServer	Pages   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 742 Using	Page	Directives  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 743 Using	Expressions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 744 Using	Scriptlets   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 746 Using Declarations   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 749 Using Classes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 751 CHAPTER 4:  Using JavaBeans  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 757 Getting	to	Know	JavaBeans  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 757 Looking	Over	a	Sample	Bean  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 759 Using	Beans	with	JSP	Pages  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 761 Creating bean instances  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 761 Getting	property	values  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 763 Setting	property	values  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 764 Viewing	a	JSP	page	that	uses	a	bean  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 765 Scoping	Your	Beans   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 767 A	shopping	cart	application  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 767 The	shopping	cart	page   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 768 The	BookCart	JavaBean   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 770 BOOK 8: FILES AND DATABASES  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 775 CHAPTER 1:  Working with Files  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 777 Using the File Class  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 777 Knowing	the	class	constructors	and	methods   .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 778 Creating a File object  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 780 Creating	a	file  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 780 Getting	information	about	a	file  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 781 Getting	the	contents	of	a	directory  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 781 Renaming	files  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 782 Deleting	a	file  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 783 Using	Command-Line	Parameters  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 784  xviii      Java All-in-One For Dummies   Choosing	Files	in	a	Swing	Application .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .785 Creating	an	Open	dialog	box  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 788 Getting	the	selected	file  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 789 Using	file	filters   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 789 Using	Path	Objects   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 792 Creating	files	with	the	Paths	class  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 793 Getting	the	contents	of	a	directory  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 794 Using	a	File	Visitor	to	Walk	a	File	Tree  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 795 CHAPTER 2:  Working with File Streams  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 799 Understanding	Streams  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 800 Reading	Character	Streams  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 801 Creating	a	BufferedReader   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 802 Reading from a character stream  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 803 Reading	the	movies.txt	file  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 804 Writing	Character	Streams  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 807 Connecting	a	PrintWriter	to	a	text	file   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 808 Writing to a character stream  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 810 Writing	the	movies.txt	file   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 810 Reading	Binary	Streams  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 813 Creating	a	DataInputStream   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 815 Reading	from	a	data	input	stream  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 815 Reading	the	movies.dat	file  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 817 Writing	Binary	Streams  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 820 Creating	a	DataOutputStream  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 822 Writing	to	a	binary	stream  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 822 Writing	the	movies.dat	file  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 823 CHAPTER 3:  Database for $100, Please  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 827 Defining	a	Relational	Database  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 828 Understanding	 and	Pronouncing 	SQL  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 828 Introducing	SQL	Statements  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 829 Creating	a	SQL	Database  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 829 Querying	a	Database   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 832 Using a basic select statement   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 832 Narrowing	the	query  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 834 Excluding	rows  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 834 Using singleton selects  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 835 Finding what something sounds like   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 835 Using column functions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 835 Selecting	data	from	more	than	one	table  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 837 Eliminating	duplicates  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 838  Table of Contents      xix   Updating	and	Deleting	Rows  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 839 Using the delete statement  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 840 Using	the	update	statement   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 841 CHAPTER 4:  Using JDBC to Connect to a Database  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 845 Setting	Up	a	Driver   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 845 Connecting to a Database   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 846 Querying	a	Database   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 848 Executing	a	select	statement  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 849 Navigating through the result set  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 849 Getting data from a result set  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 850 Putting	it	all	together:	A	program	that	reads	  from a database  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 851 Updating	SQL	Data  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 855 Using	an	Updatable	RowSet	Object  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 856 Deleting a row  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 858 Updating	the	value	of	a	row	column   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 858 Inserting a row  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 859 CHAPTER 5:  Working with XML  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 861 Defining	XML   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 861 Tags  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 862 Attributes   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 863 The	XML	declaration  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 864 The	movies.xml	file  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 864 Using	a	DTD  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 865 Processing	XML	in	Two	Ways:	DOM	and	SAX   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 868 Reading a DOM Document   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 869 Creating	a	DocumentBuilderFactory   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 870 Configuring	the	DocumentBuilderFactory  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 870 Creating a document builder and the document  .  .  .  .  .  .  .  .  .  .  .  .  . . 871 Using the getDocument method  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 872 Reading DOM Nodes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 872 Processing	elements  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 874 Getting attribute values  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 875 Getting child element values  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 876 Putting	It	All	Together:	A	Program	That	Lists	Movies  .  .  .  .  .  .  .  .  .  .  .  .  . . 877 INDEX  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . 881  xx      Java All-in-One For Dummies   Introduction  Welcome to Java All-in-One For Dummies, 5th Edition — the one Java book   that’s designed to replace an entire shelf full of the dull, tedious titles  you’d otherwise have to buy. This book contains all the basic informa- tion you need to know to get going with Java programming, starting with writing  statements and using variables and ending with techniques for writing programs  that use animation and play games. Along the way, you find plenty of not-so-  basic information about programming user interfaces, working with classes and  objects, creating web applications, and dealing with files and databases.  You can  and probably should, eventually  buy separate books on each of these  topics. It won’t take long before your bookshelf is bulging with 10,000 or more  pages of detailed information about every imaginable nuance of Java program- ming. But before you’re ready to tackle each of those topics in depth, you need to  get a bird’s-eye picture. That’s what this book is about.  And  if  you  already  own  10,000  pages  or  more  of  Java  information,  you  may  be  overwhelmed  by  the  amount  of  detail  and  wonder,  “Do  I  really  need  to  read  1,200  pages  about  JSP  just  to  create  a  simple  web  page?  And  do  I  really  need  a  six-pound book on JavaFX?” Truth is, most 1,200-page programming books have  about  200  pages  of  really  useful  information  —  the  kind  you  use  every  day  —  and about 1,000 pages of excruciating details that apply mostly if you’re writing  guidance-control  programs  for  nuclear  missiles  or  trading  systems  for  the  New York Stock Exchange.  The  basic  idea  here  is  that  I’ve  tried  to  wring  out  the  100-or-so  most  use- ful pages of information on these different Java programming topics: setup and  configuration, basic programming, object-oriented programming, programming  techniques, JavaFX, file and database programming, web programming, and ani- mation and game programming. Thus you get a nice, trim book.  So whether you’re just getting started with Java programming or you’re a  seasoned  pro, you’ve found the right book.  Introduction      1   About This Book  Java All-in-One For Dummies, 5th Edition, is a reference for all the great things  and  maybe a few not-so-great things  that you may need to know when you’re writ- ing Java programs. You can, of course, buy a huge 1,200-page book on each of the  programming topics covered in this book. But then, who would carry them home  from the bookstore for you? And where would you find the shelf space to store  them? And when will you find the time to read them?  In this book, all the information you need is conveniently packaged for you in- between one set of covers. And all of the information is current for the newest  release of Java, known as JDK 9. This book doesn’t pretend to be a comprehensive  reference  for  every  detail  on  every  possible  topic  related  to  Java  programming.  Instead, it shows you how to get up and running fast so that you have more time  to  do  the  things  you  really  want  to  do.  Designed  using  the  easy-to-follow  For  Dummies format, this book helps you get the information you need without labor- ing to find it.  Java All-in-One For Dummies, 5th Edition, is a big book made up of nine smaller  books  —  minibooks,  if  you  will.  Each  of  these  minibooks  covers  the  basics  of  one  key  element  of  programming,  such  as  installing  Java  and  compiling  and  running programs, or using basic Java statements, or using JavaFX to write GUI  applications.  Whenever one big thing is made up of several smaller things, confusion is always  a possibility. That’s why this book has multiple access points. At the beginning  is a detailed table of contents that covers the entire book. Then each minibook  begins with a minitable of contents that shows you at a miniglance what chapters  are included in that minibook. Useful running heads appear at the top of each page  to point out the topic discussed on that page. And handy thumbtabs run down the  side of the pages to help you find each minibook quickly. Finally, a comprehensive  index lets you find information anywhere in the entire book.  Foolish Assumptions  You  and  I  have  never  met,  so  it  is  difficult  for  me  to  make  any  assumptions  about why you are interested in this book. However, let’s start with a few basic  assumptions:   » You own or have access to a relatively modern computer. The examples  were created on a Windows computer, but you can learn to program in Java  just as easily on a Mac or Linux computer.  2      Java All-in-One For Dummies    » You’re an experienced computer user. In other words, I assume that you   know the basics of using your computer, such as starting programs and  working with the file system.   » You’re interested in learning how to write programs in the Java  language. Since that’s what this book teaches, it’s a fair assumption.  I do not make any assumptions about any previous programming experience in  Java or in any other programming language. Nor do I make any assumptions about  why you want to learn about Java programming. There are all sorts of valid rea- sons for learning Java. Some want to learn Java for professional reasons; maybe  you want to become a professional Java programmer, or maybe you are a C or C++  programmer who occasionally needs to work in Java. On the other hand, maybe  you think programming in Java would make an interesting hobby.  Regardless of your motivation, I do assume that you are a reasonably intelligent  person. You don’t have to have a degree in advanced physics, or a degree in any- thing at all for that matter, to master Java programming. All you have to be is  someone who wants to learn and isn’t afraid to try.  Icons Used in This Book  Like any For Dummies book, this book is chock-full of helpful icons that draw your  attention to items of particular importance. You find the following icons through- out this book:  Danger, Will Robinson! This icon highlights information that may help you avert  disaster.  Something new is aloft! I point it out with this icon.  Did I tell you about the memory course I took?  Pay special attention to this icon; it lets you know that some particularly useful  tidbit is at hand.  Introduction      3   Hold it — overly technical stuff is just around the corner. Obviously, because this  is a programming book, almost every paragraph of the next 900 or so pages could  get this icon. So I reserve it for those paragraphs that go into greater depth, down  into explaining how something works under the covers — probably deeper than  you really need to know to use a feature, but often enlightening.  Beyond the Book  In  addition  to  the  material  in  the  print  or  e-book  you’re  reading  right  now,  this product also comes with some access-anywhere goodies on the web. Check  out the free Cheat Sheet for more on Java. To get this Cheat Sheet, simply go to   www.dummies.com  and  type  Java  All-in-One  For  Dummies  Cheat  Sheet  in  the  Search box.  You  can  also  download  the  code  used  in  the  book  at  www.dummies.com go  javaaiofd5e.  Where to Go from Here  This isn’t the kind of book you pick up and read from start to finish, as if it were  a cheap novel. If I ever see you reading it at the beach, I’ll kick sand in your face.  Beaches are for reading romance novels or murder mysteries, not programming  books. Although you could read straight through from start to finish, this book  is a reference book, the kind you can pick up, open to just about any page, and  start reading. You don’t have to memorize anything in this book. It’s a “need-to-  know” book: You pick it up when you need to know something. Need a reminder  on the constructors for the ArrayList class? Pick up the book. Can’t remember  the goofy syntax for anonymous inner classes? Pick up the book. After you find  what you need, put the book down and get on with your life.  4      Java All-in-One For Dummies   Java Basics  1   Contents at a Glance  CHAPTER 1:  Welcome to Java  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 7 CHAPTER 2:	 Installing	and	Using	Java Tools  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 21 CHAPTER 3:  Working with TextPad  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 35   IN THIS CHAPTER  » Finding out about programming   » Scoping out Java   » Comparing Java with other   programming languages   » Understanding Java’s   incomprehensible version numbers  Chapter 1 Welcome to Java  This chapter is a gentle introduction  to the world of Java. In the next few   pages, you find out what Java is, where it came from, and where it’s going.  You also discover some of the unique strengths of Java, as well as some of  its weaknesses. Also, you see how Java compares with other popular programming  languages, including C, C++, C, and Visual Basic.  By the way, I assume in this chapter that you have at least enough background to  know what computer programming is all about. That doesn’t mean that I assume  you’re an expert or professional programmer. It just means that I don’t take the  time  to  explain  such  basics  as  what  a  computer  program  is,  what  a  program- ming language is, and so on. If you have absolutely no programming experience,  I s uggest that you pick up a copy of Java For Dummies, 5th Edition, or Beginning  Programming with Java For Dummies, 3rd Edition, both by Barry Burd  Wiley .  Throughout this chapter, you find little snippets of Java program code, plus a few  snippets of code written in other languages, including C, C++, and Basic. If you  don’t have a clue what this code means or does, don’t panic. I just want to give you  a feel for what Java programming looks like and how it compares with program- ming in other languages.  All the code listings used in this book are available for download at www.dummies. com go javaaiofd5e.  CHAPTER 1  Welcome to Java      7   What Is Java, and Why Is It So Great?  Java is a programming language in the tradition of C and C++. As a result, if you  have any experience with C or C++, you’ll often find yourself in familiar territory  as you discover the various features of Java.  For more information about the sim- ilarities and differences between Java and C or C++, see the section “Java versus  Other Languages,” later in this chapter.   Java differs from other programming languages in a couple of significant ways,  however. I point out the most important differences in the following sections.  Platform independence  One  of  the  main  reasons  Java  is  so  popular  is  its  platform  independence,  which  simply means that Java programs can be run on many types of computers. A Java  program runs on any computer with a Java Runtime Environment, also known as a  JRE, installed. A JRE is available for almost every type of computer you can think  of: PCs running any version of Windows, Macintosh computers, Unix and Linux  computers, huge mainframe computers, and even cellphones.  Before Java, other programming languages promised platform independence by  providing compatible compilers for different platforms.  A compiler is the program  that  translates  programs  written  in  a  programming  language  into  a  form  that  can actually run on a computer.  The idea was that you could compile different  versions of the programs for each platform. Unfortunately, this idea never really  worked. The compilers were never identical on each platform; each had its own  little nuances. As a result, you had to maintain a different version of your program  for each platform you wanted to support.  Java’s platform independence isn’t based on providing compatible compilers for  different platforms. Instead, Java is based on the concept of a virtual machine. You  can think of the Java Virtual Machine  sometimes called the JVM  as being a hypo- thetical computer platform — a design for a computer that doesn’t exist as actual  hardware.  Instead,  the  JRE  is  an  emulator  —  a  program  that  sets  aside  part  of  your hard drive to act like a computer  namely, the JVM  that can execute Java  programs.  The Java compiler doesn’t translate Java into the machine language of the com- puter that the program is running on. Instead, the compiler translates Java into  the machine language of the JVM, which is called bytecode. Then the JRE runs the  bytecode in the JVM. Because of the JVM, you can execute a Java program on any  computer that has a JRE installed without recompiling the program.  8      BOOK 1  Java Basics   That’s how Java provides platform independence — and believe it or not, it works  pretty well. The programs you write run just as well on a PC running any version  of Windows, a Macintosh, a Unix or Linux machine, or any other computer with a  JRE installed — including smartphones or tablet computers.  While you lie awake tonight pondering the significance of Java’s platform inde- pendence, here are a few additional thoughts to ponder:  a v a J   o t   e m o c l e W   » The JRE is separate from the Java compiler. As a result, you don’t have to install   a Java compiler to run compiled Java programs. All you need is the JRE.   » When someone asks whether your computer “has Java,” he or she usually   means to ask, “Have you installed the Java Runtime Environment?”  You need  the JRE so that you can run Java programs.    » Platform independence goes only so far. If you have some obscure type of  computer system — such as an antique Olivetti Programma 101 — and a JRE  isn’t available for it, you can’t run Java programs on it.  I didn’t make up the Olivetti Programma 101. It was a desktop computer made  in the early 1960s, and it happened to be my introduction to computer pro- gramming.  My junior high school math teacher had one in the back of his  classroom, and he let me play with it during lunch.  Do a Google search for  Olivetti Programma 101 and you can find several interesting websites about it.   » Java’s platform independence isn’t perfect. Although the bytecode runs   identically on every computer that has a JRE, some parts of Java use services  provided by the underlying operating system. As a result, minor variations  sometimes crop up, especially in applications that use graphical interfaces.   » Because a runtime system that emulates a JVM executes Java bytecode, some  people mistakenly compare Java with interpreted languages such as Basic or  Perl. Those languages aren’t compiled at all, however. Instead, the interpreter  reads and interprets each statement as it is executed. Java is a true compiled  language; it’s just compiled to the machine language of JVM rather than to the  machine language of an actual computer platform.   » If you’re interested, the JVM is completely stack-oriented; it has no registers for   storing local data.  I’m not going to explain what that term means, so if it  doesn’t make sense to you, skip it. It’s not important. It’s just interesting to  nerds who know about stacks, registers, and things of that ilk.   Object orientation  Java is inherently object-oriented, which means that Java programs are made up  from programming elements called objects. Simply put  don’t you love it when   CHAPTER 1  Welcome to Java      9   you read that in a computer book? , an object is a programming entity that repre- sents either some real-world object or an abstract concept.  All objects have two basic characteristics:   » Objects have data, also known as state. An object that represents a book, for   example, has data such as the book’s title, author, and publisher.   » Objects also have behavior, which means that they can perform certain tasks.  In Java, these tasks are called methods. An object that represents a car might  have methods such as start, stop, drive, and crash. Some methods simply  allow you to access the object’s data. A book object might have a getTitle  method that tells you the book’s title.  Classes are closely related to objects. A class is the program code you write to cre- ate objects. The class describes the data and methods that define the object’s state  and behavior. When the program executes, classes are used to create objects.  Suppose you’re writing a payroll program. This program probably needs objects  to represent the company’s employees. So the program includes a class  probably  named  Employee  that defines the data and methods  for  each  Employee object.  When your program runs, it uses this class to create an object for each of your  company’s employees.  The Java API  The Java language itself is very simple, but Java comes with a library of classes  that provide commonly used utility functions that most Java programs can’t do  without. This class library, called the Java API  short for application programming  interface , is as much a part of Java as the language itself. In fact, the real chal- lenge of finding out how to use Java isn’t mastering the language; it’s master- ing the API. The Java language has only about 50 keywords, but the Java API has  several thousand classes, with tens of thousands of methods that you can use in  your programs.  The  Java  API  has  classes  that  let  you  do  trigonometry,  write  data  to  files,  cre- ate  windows  onscreen,  and  retrieve  information  from  a  database,  among  other  things. Many of the classes in the API are general purpose and commonly used.  A  whole  series  of  classes  stores  collections  of  data,  for  example.  But  many  are  obscure, used only in special situations.  10      BOOK 1  Java Basics   Fortunately, you don’t have to learn anywhere near all of the Java API. Most pro- grammers are fluent with only a small portion of it: the portion that applies most  directly to the types of programs they write. If you find a need to use some class  from the API that you aren’t yet familiar with, you can look up what the class does  in the Java API documentation at http:  download.java.net jdk9 docs api.  The Internet  Java  is  often  associated  with  the  Internet,  and  rightfully  so,  because  Al  Gore  invented Java just a few days after he invented the Internet. Okay, Java wasn’t  really invented by Al Gore. It was developed right at the time the World Wide Web  was becoming a phenomenon, and Java was specifically designed to take advan- tage of the web. In particular, the whole concept behind the JVM is to enable any  computer connected to the Internet to run Java programs, regardless of the type  of computer or the operating system it runs.  a v a J   o t   e m o c l e W  You can find three distinct types of Java programs on the Internet:   » Servlets: Servlets are web-based Java programs that run on an Internet server  computer rather than in an Internet user’s web browser. Servlets are the real  way that many, if not most, commercial websites work. A servlet generates a  page of HTML that is sent to a user’s computer to be displayed in the user’s  web browser. If you request information about a product from an online  store, the store’s web server runs a servlet to generate the HTML page  containing the product information you requested.   » Applets: Applets are Java programs that run directly within a web browser. To   run an applet, the browser starts a JVM, and that virtual machine is given a  portion of the web page to work with. Then the virtual machine runs the  applet’s bytecode.   » Web Start applications: A Web Start is a Java application that is designed to  be launched from a web page but run directly on a user’s computer rather  than within a web browser.  Applets have recently fallen out of favor because they often experience compat- ibility problems with different browser versions. As a result, Web Start applica- tions have largely replaced Applets. You’ll find out how to create servlets and Web  Start applications in Book 7.  CHAPTER 1  Welcome to Java      11   Java versus Other Languages  Superficially, Java looks a lot like many of the programming languages that pre- ceded it, most notably C and C++. For example, here’s the classic Hello, World!  program, written in the C programming language:  main   {     printf "Hello, World!" ; }  This program simply displays the text "Hello, World!" on the computer’s con- sole. Here’s the classic Hello, World! program written in Java:  public class HelloApp {     public static void main String[] args      {         System.out.println "Hello, World!" ;     } }  Although the Java version is a bit more verbose, the two have several similarities:   » Both require each executable statement to end with a semicolon  ; .  » Both use braces  {}  to mark blocks of code.  » Both use a routine called main as the main entry point for the program.  Many other similarities aren’t evident in these simple examples, but the examples  bring the major difference between C and Java front and center: Object-oriented  programming rears its ugly head even in simple examples. Consider the following  points:   » In Java, even the simplest program is a class, so you have to provide a line that  declares the name of the class. In this example, the class is named HelloApp.  HelloApp has a method named main, which the JVM automatically calls when  a program is run.   » In the C example, printf is a library function you call to print information to  the console. In Java, you use the PrintStream class to write information to  the console.  12      BOOK 1  Java Basics   PrintStream? There’s no PrintStream in this program! Wait a minute — yes,  there is. Every Java program has available to it a PrintStream object that  writes information to the console. You can get this PrintStream object by  calling the out method of another class, named System. Thus System.out  gets the PrintStream object that writes to the console. The PrintStream  class in turn has a method named println that writes a line to the console.  So System.out.println really does two things, in the following order:  1.  It uses the out field of the System class to get a PrintStream object.  2.  It calls the println method of that object to write a line to the console.  a v a J   o t   e m o c l e W  Confusing? You bet. Everything will make sense, however, when you read  about object-oriented programming in Book 3, Chapter 1.   » void looks familiar. Although it isn’t shown in the C example, you could have   coded void on the main function declaration to indicate that the main  function doesn’t return a value. void has the same meaning in Java. But  static? What does that mean? That, too, is evidence of Java’s object orienta- tion. It’s a bit early to explain what it means in this chapter, but you can find  out in Book 2, Chapter 7.  Important Features of the Java Language  If you believe the marketing hype put out by Oracle and others, you think that Java  is the best thing to happen to computers since the invention of memory. Java may  not be that revolutionary, but it does have many built-in features that set it apart  from other languages. The following sections describe just three of the many fea- tures that make Java so popular.  Type checking  All programming languages must deal in one way or the other with type  checking —   the  way  that  a  language  handles  variables  that  store  different  types  of  data.   Numbers, strings, and dates, for example, are commonly used data types available  in most programming languages. Most programming languages also have several  types of numbers, such as integers and real numbers.  All languages must check data types, so make sure that you don’t try to do things  that don’t make sense  such as multiplying the gross national product by your last  name . The question is, does the language require you to declare every variable’s  type so you can do type checking when it compiles your programs, or does the  language do type checking only after it runs your program?  CHAPTER 1  Welcome to Java      13   Some languages, such as Pearl, are not as rigid about type checking as Java. For  example, Pearl does not require that you indicate whether a variable will contain  an integer, a floating point number, or a string. Thus, all the following statements  are allowed for a single variable named $a:  $a = 5 $a = "Strategery" $a = 3.14159  Here  three  different  types  of  data  —  integer,  string,  and  double  —  have  been  assigned to the same variable.  Java, on the other hand, does complete type checking at runtime. As a result, you  must declare all variables as a particular type so that the compiler can make sure  you use the variables correctly. The following bit of Java code, for example, won’t  compile:  int a = 5; String b = "Strategery"; String c = a * b;  If you try to compile these lines, you get an error message saying that Java can’t  multiply an integer and a string.  In Java, every class you define creates a new type of data for the language to work  with.  Thus,  the  data  types  you  have  available  to  you  in  Java  aren’t  just  simple  predefined types, such as numbers and strings. You can create your own types.  If you’re writing a payroll system, you might create an Employee type. Then you  can declare variables of type Employee that can hold only Employee objects. This  capability prevents a lot of programming errors. Consider this code snippet:  Employee newHire; newHire = 21;  This code creates a variable  newHire  that can hold only Employee objects. Then  it tries to assign the number 21 to it. The Java compiler won’t let you run this  program because 21 is a number, not an employee.  An important object-oriented programming feature of Java called inheritance adds  an interesting — and incredibly useful — twist to type checking. Inheritance is  way too complicated to dive into just yet, so I’ll be brief here: In Java, you can  create your own data types that are derived from other data types. Employees are  people, for example, and customers are people too, so you might create a Person   14      BOOK 1  Java Basics   class and then create Employee and Customer classes that both inherit the Person  class. Then you can write code like this:  Person p; Employee e; Customer c; p = e;      this is allowed because an Employee is also a    c = e;      this isn't allowed because an Employee is not a        Person.      Customer.  a v a J   o t   e m o c l e W  Confused yet? If so, that’s my fault. Inheritance is a pretty heady topic for Chap- ter 1 of a Java book. Don’t panic if it makes no sense just yet. It will all be clear by  the time you finish reading Book 3, Chapter 4, which covers all the subtle nuances  of using inheritance.  Automatic memory management  Memory management is another detail that all programming languages have to  deal with. All programming languages let you create variables. When you create  a variable, the language assigns a portion of the computer’s memory to store the  data referred to by the variable. Exactly how this memory is allocated is a detail  that you usually can safely ignore, no matter which language you’re working with.  But a detail that many languages do not let you safely ignore is what happens to  that memory when you no longer need the data that was stored in it.  In  C++  and  similar  languages,  you  must  write  code  that  explicitly  releases  that  memory so that other programs can access it. If you don’t do this, or if you do it  wrong, your program might develop a memory leak. In a memory leak, your pro- gram slowly but surely sucks memory away from other programs until the oper- ating system runs out of memory and the computer grinds to a halt.  In Java, you don’t have to explicitly release memory when you’re done with it;  instead,  memory  is  freed  automatically  when  it’s  no  longer  needed.  The  JVM  includes a special process called the garbage collector that snoops around the vir- tual machine’s memory; determines when data is no longer being used; and auto- matically deletes that data, freeing the memory that it occupied.  A feature related to garbage collection is bounds checking, which guarantees that  programs can’t access memory that doesn’t belong to them. Languages such as C  and C++ don’t have this type of safety net. As a result, programming errors in C or  C++ can cause one program to trample over memory that’s being used by another  program, which in turn can cause your computer to crash.  CHAPTER 1  Welcome to Java      15   On the Downside: Java’s Weaknesses  Exception handling  As Robert Burns said, “The best-laid schemes o’ mice an’ men gang oft agley,  an’ lea’e us nought but grief an’ pain, for promis’d joy!” When you tinker with  computer programming, you’ll quickly discover what he meant. No matter how  carefully you plan and test your programs, errors happen, and when they do, they  threaten to bring your whole program to a crashing halt.  Java has a unique approach to error handling that’s superior to that of any other  language  except C, which just copies Java’s approach, as I mention earlier in the  chapter . In Java, the JRE intercepts and folds errors of all types into a special type  of object called an exception object. After all, Java is object-oriented through and  through, so why shouldn’t its exception-handling features be object-oriented?  Java requires any statements that can potentially cause an exception to be brack- eted by code that can catch and handle the exception. In other words, you, as the  programmer, must anticipate errors that can happen while your program is run- ning and make sure that those errors are dealt with properly. Although this neces- sity can be annoying, it makes the resulting programs more reliable.  So far, I’ve been tooting Java’s horn pretty loudly. Lest you think that figuring  out how to use it is a walk in the park, the following paragraphs point out some  of Java’s shortcomings  many of which have to do with the API rather than the  language itself :   » The API is way too big. It includes so many classes and methods that you’ll  likely never use even half of them. Also, the sheer size of the Java API doesn’t  allow you to wander through it on your own, hoping to discover the one class  that’s perfect for the problem you’re working on.   » The API is overdesigned. In some cases, it seems as though the Java design- ers go out of their way to complicate things that should be simple to use. The  API class that defines a multiline text-input area doesn’t have a scroll bar, for  example. Instead, a separate class defines a panel that has a scroll bar. To  create a multiline text area with a scroll bar, you have to use both classes.  That’s fine if you ever want to create a text area that doesn’t have a scroll bar,  but you never will. Java’s designers complicated the design of the text area  and scroll panel classes to provide for a case that no one ever uses or would  want to use.  16      BOOK 1  Java Basics    » Some corners of the API are haphazardly designed. Most of the problems  can be traced back to the initial version of Java, which was rushed to market  so that it could ride the crest of the World Wide Web wave in the late 1990s.  Since then, many parts of the API have been retooled more thoughtfully, but  the API is still riddled with remnants of Java’s early days.   » In my opinion, the biggest weakness of Java is that it doesn’t directly  support true decimal data. This issue is a little too complicated to get into  right now, but the implication is this: Without special coding  which few Java  books explain and few Java programmers realize , Java doesn’t know how to  add. Consider this bit of code:  a v a J   o t   e m o c l e W  double x = 5.02; double y = 0.01; double z = x + y; System.out.println z ;  This  little  program  should  print  5.03,  right?  It  doesn’t.  Instead,  it  prints  5.029999999999999. This little error may not seem like much, but it can add up.  If you ever make a purchase from an online store and notice that the sales tax is a  penny off, this is why. The explanation for why these errors happen — and how to  prevent them — is pretty technical, but it’s something that every Java program- mer needs to understand.  Java Version Insanity  Like most products, Java gets periodic upgrades and enhancements. Since its ini- tial release in 1996, Java has undergone the following version updates:   » Java 1.0: This version was the original version of Java, released in 1996. Most  of the language is still pretty much the same as it was in version 1.0, but the  API has changed a lot since this release.   » Java 1.1: This version was the first upgrade to Java, released in 1997. This   release is important because most Internet browsers include built-in support  for applets based on Java 1.1. To run applets based on later versions of Java, in  most cases you must download and install a current JRE.   » Java 1.2: This version, released in late 1998, was a huge improvement over   the previous version — so much so, in fact, that Sun called it Java 2. It included  an entirely new API called Swing for creating graphical user interfaces, as well  as other major features.  CHAPTER 1  Welcome to Java      17    » Java 1.3: This version, released in 2000, was mostly about improving perfor- mance by changing the way the runtime system works. Oddly, though this  version is technically Java 1.3, it’s also called Java 2 version 1.3. Go figure.   » Java 1.4: Released in 2001, this version offered a slew of improvements. As   you might guess, it’s called Java 2 version 1.4. Keep figuring . . . .   » Java 1.5: Released in 2004, this version included more changes and improve- ments than any other version. To add to Sun’s apparent unpredictability in its  version numbering, this version officially has two version numbers. Sun’s  official Java website explains it like this:  Both version numbers “1.5.0” and “5.0” are used to identify this release of  the Java 2 Platform Standard Edition. Version “5.0” is the product version,  while “1.5.0” is the developer version.  That clears everything right up, doesn’t it?   » Java 1.6: Released in December 2006  just in time for the holidays! , this   version of Java offered minor improvements and better efficiency.  For Java 1.6, the product version is 6  not 6.0 . Remember the extra 2 that  appeared magically in 1998? Well, the 2 is gone in Java 1.6. So unlike the  versions between 1998 and 2006, Java 1.6 is officially named the Java Platform   not the Java 2 Platform . Personally, I think someone at Sun has been talking  to George Lucas. I fully expect the next version of Java to be a prequel called  Java 0 Episode 1.   » Java 1.7: Released in mid-2011, this was a relatively minor upgrade that added   a few enhancements to the API and a few tweaks to the language itself.  » Java 1.8: Released in February of 2014, Java 8  as it is known  adds some   significant and long-anticipated new features to Java. One of the most  important is lambda expressions, a language feature that simplifies certain  aspects of object-oriented programming. Other new features include a  completely revamped API for working with dates and times, and a new  framework for working with large collections of data in a way that can easily  take advantage of multicore processors.   » Java 1.9: Released in 2017, Java 9 adds a significant and long-awaited feature   called the Java Module System, which provides a new and improved way of  managing the collections of Java code that make up a complete Java applica- tion. You learn about this new feature in Book 3, Chapter 8.  You may need to be aware of version differences if you’re writing applications that  you want to be able to run on earlier versions of Java. Bear in mind, however, that  one of the chief benefits of Java is that the runtime system is free and can be easily  downloaded and installed by end users. As a result, you shouldn’t hesitate to use  the features of Java 9 when you need them.  18      BOOK 1  Java Basics   What’s in a Name?  The final topic that I want to cover in this chapter is the names of the various  pieces  that  make  up  Java’s  technology  —  specifically,  the  acronyms  you  con- stantly come across whenever you read or talk about Java, such as JVM, JRE, JDK,  and J2EE. Here they are, in no particular order of importance:  a v a J   o t   e m o c l e W   » JDK: Java Development Kit — that is, the toolkit for developers that includes the  Java compiler and the runtime environment. To write Java programs, you need  the JDK. This term was used with the original versions of Java  1.0 and 1.1  and  abandoned with version 1.2 in favor of SDK. But with versions 5.0, 6, and 7,  the term JDK is officially back in vogue.   » SDK: Software Development Kit — what Sun called the JDK for versions 1.2, 1.3,   and 1.4.   » JRE: Java Runtime Environment — the program that emulates the JVM so that  users can run Java programs. To run Java programs, you need only download  and install the JRE.   » JVM: Java Virtual Machine — the platform-independent machine that’s   emulated by the JRE. All Java programs run in a JVM.   » Java SE: Java Standard Edition — a term that describes the Java language and  the basic set of API libraries that are used to create Java programs that can  run on Windows, Linux, and other platforms, such as Macintosh. Java SE can  also create programs, called applets, that run in a browser window. Most of  this book focuses on Java SE.   » J2SE: Java 2 Standard Edition — an older term for the Java language and basic   libraries  for Java versions 1.2 through 1.5 .   » Java EE: Java Enterprise Edition, also known as J2EE  Java 2 Enterprise Edition  —   an expanded set of API libraries that provide special functions such as  servlets.  CHAPTER 1  Welcome to Java      19    IN THIS CHAPTER  » Downloading Java from the Oracle   website   » Installing Java   » Using Java tools   » Getting help  Chapter 2 Installing and Using  Java Tools  Java development environments have two basic approaches. On the one hand,   you can use a sophisticated integrated development environment  IDE  such  as JavaBeans or Eclipse. These tools combine a full-featured source editor that  lets you edit your Java program files with integrated development tools, including  visual development tools that let you create applications by dragging and drop- ping visual components onto a design surface.  At  the  other  extreme,  you  can  use  just  the  basic  command-line  tools  that  are  available free from Oracle’s Java website  http:  java.oracle.com . Then you  can use any text editor you want to create the text files that contain your Java  programs  called source files , and compile and run your programs by typing com- mands at a command prompt.  As a compromise, you may want to use a simple development environment, such  as TextPad. TextPad is an inexpensive text editor that provides some nice fea- tures for editing Java programs  such as automatic indentation  and shortcuts for  compiling and running programs. It doesn’t generate any code for you or provide  any type of visual design aids, however. TextPad is the tool I used to develop all  the examples shown in this book. For information about downloading and using  TextPad, see Book 1, Chapter 3.  CHAPTER 2  Installing and Using Java Tools      21   Downloading and Installing   the Java Development Kit  Before you can start writing Java programs, you have to download and install the  correct version of the Java Development Kit  JDK  for the computer system you’re  using. Oracle’s Java website provides versions for Windows, Solaris, and Unix. The  following sections show you how to download and install the JDK.  Downloading the JDK  To get to the download page, point your browser to http:  java.oracle.com  technetwork java. Then follow the appropriate links to download the JDK 9 for  your operating system.  When you get to the Java download page, you find links to download the JDK or  the JRE. Follow the JDK link; the JRE link gets you only the Java Runtime Environ- ment, not the complete Java Development Kit.  The JDK download comes in two versions: an online version that requires an active  Internet connection to install the JDK and an offline version that lets you down- load the JDK installation file to your computer and install it later.  I recommend that you use the offline version. It installs faster, and you can rein- stall the JDK later if you need to without having to download it again.  LEGAL MUMBO JUMBO  Before you can download the JDK, you have to approve of the Java license agreement —  all 1,919 words of it, including all the thereupons, whereases, and hithertos so finely  crafted by Oracle’s legal department. I’m not a lawyer  and I don’t play one on TV , but  I’ll try to summarize the license agreement for you:     The party of the first part  that’s Oracle  grants you the right to use Java as is and   doesn’t promise that Java will do anything at all.     The party of the second part  that’s you  in turn promises to use Java only to write   programs. You’re not allowed to try to figure out how Java works and sell your  secrets to Microsoft.     You can’t use Java to make a nuclear bomb or a missile delivery system.  I’m not   making that up. It’s actually in the license agreement.   22      BOOK 1  Java Basics   The exact size of the offline version depends on the platform, but most versions  are between 50MB and 60MB. As a result, the download takes a few hours if you  don’t have a high-speed Internet connection. With a cable, DSL, or T1 connection,  the download takes less than five minutes.  Installing the JDK  After  you  download  the  JDK  file,  you  can  install  it  by  running  the  executable  file  you  downloaded.  The  procedure  varies  slightly  depending  on  your  operat- ing  system, but basically, you just run the JDK installation program file after you  download it, as follows:   » On a Windows system, open the folder in which you saved the installation   program and double-click the installation program’s icon.   » On a Linux or Solaris system, use console commands to change to the  directory to which you downloaded the file and then run the program.  After you start the installation program, it prompts you for any information that  it needs to install the JDK properly, such as which features you want to install  and what folder you want to install the JDK in. You can safely choose the default  answer for each option.  Perusing the JDK folders  When  the  JDK  installs  itself,  it  creates  several  folders  on  your  hard  drive.  The  locations of these folders vary depending on your system, but in all 32-bit ver- sions of Windows, the JDK root folder is in the path Program Files\Java on your  boot drive. On 64-bit versions of Windows, the root folder will be either Program  Files\Java or Program Files  x86 \Java. The name of the JDK root folder also  varies, depending on the Java version you’ve installed. For version 1.9, the root  folder is named jdk-9.  Table 2-1 lists the subfolders created in the JDK root folder. As you work with Java,  you’ll refer to these folders frequently.  In addition to these folders, the JDK installs several files in the JDK root folder.  I list these files in Table 2-2.  CHAPTER 2  Installing and Using Java Tools      23   TABLE 2-1	  Folder  bin  conf  include  jmods  jre  lib  Subfolders of the JDK Root Folder Description  The compiler and other Java development tools  Configuration files  This library contains files needed to integrate Java with programs written in other   languages  Modules for the Java Module System  new with Java 1.9   The Java runtime environment  Library files, including the Java API class library  TABLE 2-2	  File  Files in the JDK Root Folder Description  README.html  The Java read-me file in HTML format.  README.txt  The read-me file again, this time in text format.  LICENSE  COPYRIGHT  Src.zip  The Java license that you agreed to when you downloaded the JDK, on the outside  chance that you enjoyed it so much the first time, you want to read it again.  If you work  for Microsoft, you probably should read it again, at least twice.   The copyright notice. Most companies would be happy to just place   Oracle  Microsystems, Inc., at the bottom of the read-me or license file. Not Oracle. It puts the  copyright notice in a separate text file, along with information about all the copyright and  export laws that apply.  The source code for the Java API classes. This folder is created only if you unpack the  src.zip file  which may be named src.jar . After you get your feet wet with Java,  looking at these source files can be a great way to find out more about how the API  classes work.  Setting the path  After you install the JDK, you need to configure your operating system so that it  can find the JDK command-line tools. To do that, you must set the Path environ- ment variable — a list of folders that the operating system uses to locate execut- able programs. To do this on a Windows 7 or earlier system, follow these steps.  You must be logged in as an administrator to make the changes described in this  procedure. On Windows 8, Java installs as a desktop application that works like  the Windows 7 configuration.  24      BOOK 1  Java Basics   1.  Click the Start menu, then right-click Computer.  This brings up the System Properties page. 2.  Click the Advanced System Settings link. 3.  Click the Environment Variables button.  The Environment Variables dialog box appears, as shown in Figure 2-1.  FIGURE 2-1:   The  Environment  Variables   dialog box.  4.  In the System Variables list, scroll to the Path variable, select it, and then   click the Edit button.  A little dialog box pops up to let you edit the value of the Path variable.  5.  Add the JDK bin folder to the beginning of the Path value.  Use a semicolon to separate the bin folder from the rest of the information  that may already be in the path.  Note: The name of the bin folder may vary on your system, as in this example:  c:\Program Files\Java\jdk-9\bin;other directories...  6.  Click OK three times to exit.  The first OK gets you back to the Environment Variables dialog box; the second  OK gets you back to the System Properties dialog box; and the third OK closes  the System Properties dialog box.  For Linux or Solaris, the procedure depends on which shell you’re using. For more  information, consult the documentation for the shell you’re using.  CHAPTER 2  Installing and Using Java Tools      25   Using Java’s Command-Line Tools  Java  comes  with  several  command-line  tools  that  you  can  run  directly  from  a  command prompt. The two most important are javac, the Java compiler used to  compile a program, and java, the runtime command used to run a Java  program.  These  tools  work  essentially  the  same  way  no  matter  what  operating  system  you’re using.  Compiling a program  You can compile a program from a command prompt by using the javac  command.  Before you can do that, however, you need a program to compile. Follow these  steps: 1.  Using any text editor, type the following text in a file, and save it as   HelloApp.java:  public class HelloApp {     public static void main String[] args      {         System.out.println "Hello, World!" ;     } }  Pay special attention to capitalization. If you type Public instead of public, for  example, the program won’t work.  If you don’t want to bother with typing, you  can download the sample programs from this book’s website at www.dummies. com go javaaiofd5e.   2.  Save the file in any directory you want. 3.  Open a command prompt, use a cd command to change to the directory   you saved the program file in, and then enter the command javac  HelloApp.java.  This command compiles the program  javac  and creates a class file named  HelloApp.class.  Assuming that you typed the program exactly right, the javac command doesn’t  display  any  messages  at  all.  If  the  program  contains  any  errors,  however,  you  get one or more error messages onscreen. If you typed Public instead of public  despite  my  warning  earlier  in  this  section,  the  compiler  displays  the  following  error message:  26      BOOK 1  Java Basics   C:\java\samples>javac HelloApp.java HelloApp.java:1: error: class, interface, or enum expected Public class HelloApp ^ 1 error  C:\java\samples>  The compiler error message indicates that an error is in line 1 of the HelloApp. java file. If the compiler reports an error message like this one, your program  contains a coding mistake. You need to find the mistake, correct it, and compile  the program again.  Compiling more than one file  Normally, the javac command compiles only the file that you specify on the com- mand line, but you can coax javac into compiling more than one file at a time by  using any of the techniques I describe in the following paragraphs:   » If the Java file you specify on the command line contains a reference to   another Java class that’s defined by a java file in the same folder, the Java  compiler automatically compiles that class too.  Suppose you have a java program named TestProgram, which refers to a  class called TestClass, and the TestClass.java file is located in the same  folder as the TestProgram.java file. When you use the javac command to  compile the TestProgram.java file, the compiler automatically compiles the  TestClass.java file too.   » You can list more than one filename in the javac command. The following   command compiles three files:  javac TestProgram1.java TestProgram2.java TestProgram3.java   » You can use a wildcard to compile all the files in a folder, like this:  javac *.java   » If you need to compile a lot of files at the same time but don’t want to use a  wildcard  perhaps you want to compile a large number of files but not all the  files in a folder , you can create an argument file, which lists the files to  compile. In the argument file, you can type as many filenames as you want,  using spaces or line breaks to separate them. Here’s an argument file named  TestPrograms that lists three files to compile:  TestProgram1.java TestProgram2.java TestProgram3.java  CHAPTER 2  Installing and Using Java Tools      27   You can compile all the programs in this file by using an @ character followed  by the name of the argument file on the javac command line, like this:  javac @TestPrograms  Using Java compiler options  The javac command has a gaggle of options that you can use to influence the way  it compiles your programs. For your reference, I list these options in Table 2-3.  Java Compiler Options Description  Generates all debugging info.  Generates no debugging info.  -g:{lines,vars,source}  Generates only some debugging info.  TABLE 2-3	  Option  -g  -g:none  -nowarn  -verbose  -deprecation  -classpath    -cp    Generates no warnings.  Outputs messages about what the compiler is doing.  Outputs source locations where deprecated APIs are used.  Specifies where to find user class files.  Specifies where to find user class files.  -sourcepath    Specifies where to find input source files.  -bootclasspath    Overrides locations of bootstrap class files.  -extdirs    Overrides locations of installed extensions.  -endorseddirs    Overrides location of endorsed standards path.  -d    Specifies where to place generated class files.  -encoding    Specifies character encoding used by source files.  -source    -target    Provides source compatibility with specified release.  Generates class files for specific virtual-machine version.  -version  -help  -X  -J   28      BOOK 1  Java Basics  Provides version information.  Prints a synopsis of standard options.  Prints a synopsis of nonstandard options.  Passes   directly to the runtime system.   To use one or more of these options, type the option before or after the source file- name. Either of the following commands, for example, compiles the HelloApp.  java file with the -verbose and -deprecation options enabled:  javac HelloWorld.java -verbose -deprecation javac -verbose -deprecation HelloWorld.java  Don’t get all discombobulated if you don’t understand what all these options do.  Most  of  them  are  useful  only  in  unusual  situations.  The  options  you’ll  use  the  most are   » -classpath or -cp: Use this option if your program makes use of class files   that you’ve stored in a separate folder.   » -deprecation: Use this option if you want the compiler to warn you when- ever you use API methods that have been deprecated.  Deprecated methods  are older methods that once were part of the Java standard API but are on the  road to obsolescence. They still work but may not function in future versions  of Java.    » -source: Use this option to limit the compiler to previous versions of Java.  Note, however, that this option applies only to features of the Java language  itself, not to the API class libraries. If you specify -source 1.4, for example,  the compiler won’t allow you to use new Java language features that were  introduced in a version later than 1.4, such as generics, enhanced for loops,  or Lambda expressions. But you can still use the new API features that were  added with version 1.5, such as the Scanner class.   » -help: Use this option to list the options that are available for the javac   command.  Running a Java program  When you successfully compile a Java program, you can run the program by typ- ing the java command followed by the name of the class that contains the pro- gram’s main method. The JRE loads, along with the class you specify, and then  runs the main method in that class. To run the HelloApp program, for example,  type this command:  C:\java\samples>java HelloApp  The program responds by displaying the message "Hello, World!".  CHAPTER 2  Installing and Using Java Tools      29   The class must be contained in a file with the same name as the class, and its  filename must have the extension .class. You usually don’t have to worry about  the name of the class file because it’s created automatically when you compile the  program with the javac command. Thus, if you compile a program in a file named  HelloApp.java, the compiler creates a class named HelloApp and saves it in a file  named HelloApp.class.  Understanding error messages If Java can’t find a filename that corresponds to the class, you get a simple error  message indicating that the class can’t be found. Here’s what you get if you type  JelloApp instead of HelloApp:  C:\java\samples>java JelloApp Exception in thread "main"     java.lang.NoClassDefFoundError: JelloApp  This error message simply means that Java couldn’t find a class named JelloApp.  Specifying options Like the Java compiler, the Java runtime command lets you specify options that  can influence its behavior. Table 2-4 lists the most commonly used options.  Common Java Command Options  Description  Runs the client virtual machine.  Runs the server virtual, which is optimized for server systems.  Lists the directories or JAR or Zip archive files used to search  for class files.  Does the same thing as -classpath.  Sets a system property.  Enables verbose output.  Displays the JRE version number and then stops.  Displays the JRE version number and then continues.  Lists standard options.  -classpath directories and archives  TABLE 2-4	  Option  -client  -server  -cp    -D name=value  -verbose  -version  -showversion  -? or -help  30      BOOK 1  Java Basics   Option  -X  Description  Lists nonstandard options.  -ea or -enableassertions  Enables the assert command.  -ea classes or packages  Enables assertions for the specified classes or packages.  -esa or -enablesystemassertions  Enables system assertions.  -dsa or -disablesystemassertions  Disables system assertions.  Using the javap command  The  javap  command  is  called  the  Java  disassembler  because  it  takes  class  files  apart and tells you what’s inside them. You won’t use this command often, but  using it to find out how a particular Java statement works is fun sometimes. You  can also use it to find out what methods are available for a class if you don’t have  the source code that was used to create the class.  Here’s the information you get when you run the javap HelloApp command:  C:\java\samples>javap HelloApp Compiled from "HelloApp.java" public class HelloApp{     public HelloApp  ;     public static void main java.lang.String[] ; }  As you can see, the javap command indicates that the HelloApp class was  compiled  from the HelloApp.java file and that it consists of a HelloApp public class and a  main public method.  You  may  want  to  use  two  options  with  the  javap  command.  If  you  use  the  -c  option,  the  javap  command  displays  the  actual  Java  bytecodes  created  by  the  compiler for the class. And if you use the -verbose option, the bytecodes  plus a  ton of other fascinating information about the innards of the class  are displayed.  If you become a big-time Java guru, you can use this type of information to find  out exactly how certain Java features work. Until then, you probably should leave  the  javap  command  alone  except  for  those  rare  occasions  when  you  want  to  impress your friends with your in-depth knowledge of Java.  Just hope that when  you do, they don’t ask you what the aload or invokevirtual instruction does.   CHAPTER 2  Installing and Using Java Tools      31   Using Java Documentation  USING OTHER COMMAND-LINE TOOLS  Java has many other command-line tools that come in handy from time to time. You can  find a complete list of command-line tools at the following website:  http:  download.java.net jdk9 docs technotes tools index.htmlbasic  I describe three of these additional tools elsewhere in this book:     applet viewer: Runs a web applet application. For more information, see Book 7,   Chapter 1.     javadoc: Automatically creates HTML documentation for your Java classes. For   more information, see Book 3, Chapter 7.     jar: Creates Java archive  JAR  files, which store classes in a compressed file that’s   similar to a Zip file. I cover this command in Book 3, Chapter 7.  Before you get too far into figuring out Java, don’t be surprised if you find yourself  wondering whether some class has some other method that I don’t describe in  this book — or whether some other class may be more appropriate for an appli- cation you’re working on. When that time comes, you’ll need to consult the Java  help pages.  Complete documentation for Java is available on the Oracle Java website at http:   download.java.net jdk98 docs.  Although  this  page  contains  many  links  to   documentation pages, the two you’ll use the most are the Java SE API documen- tation pages and the Developer’s Guides pages. The following sections describe  these two links.  Java SE API Docs  The  API  and  documentation  links  at  http:  download.java.net java jdk98  docs api index.html take you to the complete documentation for all currently  supported  versions  of  the  Java  API,  in  English  as  well  as  Japanese.  Figure  2-2  shows the English Java SE 8 API documentation page.  32      BOOK 1  Java Basics   FIGURE 2-2:   The   documentation  page for Java SE  API 9  English  version .  You can use this page to find complete information for any class in the API. By  default, all the Java classes are listed in the frame that appears in the bottom-left  corner of the page. You can limit this display to the classes in a particular package  by choosing the package from the menu in the top-left corner of the page.  Click the class you’re looking for in the class list to call up its documentation page.  Figure 2-3 shows the documentation page for the String class. If you scroll down  this page, you find complete information about everything you can do with this  class, including an in-depth discussion of what the class does, a list of the vari- ous methods it provides, and a detailed description of what each method does. In  addition, you find links to similar classes.  Java Language Specification  If you’re interested in learning details about some element of the Java language  itself   rather  than  the  information  about  a  class  in  the  API  class  library ,  visit  the  Java  Programming  Language  reference  page  at  http:  docs.oracle.com  javase specs index.html. That link takes you to a set of pages that describes —  in sometimes excruciating and obscure detail — exactly how each element of the  Java language works.  CHAPTER 2  Installing and Using Java Tools      33   FIGURE 2-3:   The   documentation  page for the  String class.  Frankly,  this  documentation  isn’t  that  much  help  for  beginning  programmers.  It  was  written  by  computer  scientists  for  computer  scientists.  You  can  tell  just  by looking at the table of contents that it isn’t for novices. The first chapter is  called “Introduction”  that’s not so bad , but Chapters 2 and 3 are titled “Gram- mars”  and  “Lexical  Structure,”  respectively,  and  matters  just  get  more  arcane  from there.  That’s why you’re reading this book, after all. You won’t even find a single sen- tence more about lexical structure in this book  other than this one, of course .  Even so, at some time in your Java journeys, you may want to get to the bottom  of the rules that govern such strange Java features as anonymous inner classes.  When that day arrives, grab a six-pack of Jolt Cola, roll up your sleeves, and open  the Java Language Specification pages.  34      BOOK 1  Java Basics   IN THIS CHAPTER  » Acquiring TextPad   » Using TextPad to edit source files   » Compiling Java programs   » Running Java programs  Chapter 3 Working with TextPad  TextPad is an inexpensive  $27  text editor that you can integrate with the   Java Development Kit  JDK  to simplify the task of coding, compiling, and  running Java programs. It isn’t a true integrated development environment   IDE ,  as  it  lacks  features  such  as  integrated  debugging,  code  generators,  and  drag-and-drop tools for creating graphical user interfaces.  TextPad is a popular tool for developing Java programs because of its simplicity  and speed. It’s ideal for learning Java because it doesn’t generate any code for you.  Writing every line of code yourself may seem like a bother, but the exercise pays  off in the long run because you have a better understanding of how Java works.  Downloading and Installing TextPad  You can download a free evaluation version of TextPad from Helios Software Sys- tems at www.textpad.com. You can use the evaluation version free of charge, but  if you decide to keep the program, you must pay for it.  Helios accepts credit card  payment online.   If the Java JDK is already installed on your computer when you install TextPad,  TextPad automatically configures itself to compile and run Java programs. If you   CHAPTER 3  Working with TextPad      35   install the JDK after you install TextPad, you need to configure TextPad for Java  by following these steps: 1.  Choose Configure ➪ Preferences to open the Preferences dialog box. 2.  Click Tools in the tree that appears on the left side of the dialog box. 3.  Click the Add button to reveal a drop-down list of options and then click   Java SDK Commands.  Figure 3-1 shows how the Preferences dialog box appears when the Java tools  are installed. As you can see, the Tools item in the tree on the left side of the  dialog box includes three Java tools: Compile Java, Run Java Application, and  Run Java Applet.  FIGURE 3-1:   Configuring tools  in TextPad.  4.  Click OK.  Editing Source Files  The commands you need to compile and run Java programs are added to  TextPad’s Tools menu.  Figure 3-2 shows a Java source file being edited in TextPad. If you’ve worked with  a Windows text editor before, you’ll have no trouble mastering the basics of Text- Pad. I won’t go over such basic procedures as opening and saving files because  they’re  standard;  instead,  I  describe  some  TextPad  features  that  are  useful  for  editing Java program files.  36      BOOK 1  Java Basics   When you first create a file  by clicking the New button on the toolbar or by choos- ing File ➪ New , TextPad treats the file as a normal text file, not as a Java program  file. After you save the file  by clicking the Save button or choosing File ➪ Save   and assign .java as the file extension, TextPad’s Java-editing features kick in.  FIGURE 3-2:   Editing a Java file  in TextPad.     d a P t x e T h t i w g n k r o W  i     The following paragraphs describe some of TextPad’s most noteworthy features  for working with Java files:   » You can’t really tell from Figure 3-2, but TextPad uses different colors to   indicate the function of each word or symbol in the program. Brackets are red  so that you can spot them quickly and make sure that they’re paired correctly.  Keywords are blue. Comments and string literals are green. Other text, such  as variable and method names, is black.   » TextPad automatically indents whenever you type an opening bracket and  then reverts to the previous indent when you type a closing bracket. This  feature makes keeping your code lined up easy.   » Line numbers display down the left edge of the editing window. You can turn   these line numbers on or off by choosing View ➪ Line Numbers.  CHAPTER 3  Working with TextPad      37    » To go to a particular line, press Ctrl+G to bring up the Go To dialog box. Make  sure that Line is selected in the Go to What box, enter the line number in the  text box, and click OK.   » If you have more than one file open, you can switch between the files by using   the Document Selector — the pane on the left side of the TextPad window   refer to Figure 3-2 . If the Document Selector isn’t visible, choose  View ➪ Document Selector to summon it.   » Another way to switch between two  or more  files is to choose   View ➪ Document Tabs. Tabs appear at the bottom of the document window,  and you can click these tabs to switch documents.   » A handy Match Bracket feature lets you pair brackets, braces, and parentheses.  To use this feature, move the insertion point to a bracket, brace, or parenthesis  and then press Ctrl+M. TextPad finds the matching element.   » To search for text, press F5. In the Find dialog box, enter the text you’re   looking for, and click OK. To repeat the search, press Ctrl+F.   » To replace text, press F8.  USING WORKSPACES  In TextPad, a workspace is a collection of files that you work on together. Workspaces  are useful for projects that involve more than just one file. When you open a workspace,  TextPad opens all the files in the workspace.  To create a workspace, first open all the files that you want to include in the workspace.  Then choose File ➪ Workspace ➪ Save As and, in the Save As dialog box, give the work- space a name.  The files that make up the workspace are saved in a single file with   the .tws extension.   To open a workspace, choose File ➪ Workspace ➪ Open to display the Open dialog box,  select the workspace file that you previously saved, and click Open. Alternatively, you  can choose the workspace from the list of recently used workspaces at the bottom of  the File ➪ Workspace submenu.  To configure TextPad to open the most recently used workspace automatically when- ever you start TextPad, choose Configure ➪ Preferences to open the Preferences dialog  box, click General in the tree on the left side of the dialog box, select the Reload Last  Workspace at Startup check box, and click OK to close the dialog box.  38      BOOK 1  Java Basics   Compiling a Program  To  compile  a  Java  program  in  TextPad,  choose  Tools ➪ Compile  Java  or  use  the  keyboard shortcut Ctrl + 1. The javac command compiles the program, and the  compiler output is displayed in the Tool Results pane of the TextPad window. If  the program compiles successfully, the message Tool completed successfully  appears in the Tool Results pane. If the compiler finds something wrong with your  program, one or more error messages are displayed, as shown in Figure 3-3.     d a P t x e T h t i w g n k r o W  i     FIGURE 3-3:   Error messages  displayed by the  Java compiler.  In this example, eight compiler error messages are displayed:  javac 1.8.0-ea C:\Users\Doug\Documents\Java 4E\Manuscript\Apps\Book 1\Chapter 3\HelloApp.    java:5: error: unclosed string literal          printHello "World! ;                    ^ C:\Users\Doug\Documents\Java 4E\Manuscript\Apps\Book 1\Chapter 3\HelloApp.    java:5: error: ';' expected           printHello "World! ;                              ^  CHAPTER 3  Working with TextPad      39   C:\Users\Doug\Documents\Java 4E\Manuscript\Apps\Book 1\Chapter 3\HelloApp.    java:8: error: illegal start of expression      public static void printHello String greetee      ^ C:\Users\Doug\Documents\Java 4E\Manuscript\Apps\Book 1\Chapter 3\HelloApp.    java:8: error: ';' expected      public static void printHello String greetee            ^ C:\Users\Doug\Documents\Java 4E\Manuscript\Apps\Book 1\Chapter 3\HelloApp.    java:8: error: illegal start of expression      public static void printHello String greetee                    ^ C:\Users\Doug\Documents\Java 4E\Manuscript\Apps\Book 1\Chapter 3\HelloApp.    java:8: error: ';' expected      public static void printHello String greetee                                   ^ C:\Users\Doug\Documents\Java 4E\Manuscript\Apps\Book 1\Chapter 3\HelloApp.    java:8: error: ';' expected      public static void printHello String greetee                                                  ^ C:\Users\Doug\Documents\Java 4E\Manuscript\Apps\Book 1\Chapter 3\HelloApp.    java:12: error: reached end of file while parsing  }  ^ 8 errors Tool completed with exit code 1  If you double-click the first line of each error message, TextPad takes you to the  spot  where  the  error  occurred.  If  you  double-click  the  line  with  the  unclosed  string literal message, for example, you’re taken to line 5, and the insertion  point is positioned at the spot where the compiler found the error. Then you can  correct the error and recompile the program.  Often, a single error can cause more than one error message to display, as is the  case in Figure 3-3. The error is that I left off a closing quotation mark after the  word Hello in line 5. That one error caused all eight error messages!  Running a Java Program  After  you  compile  a  Java  program  with  no  errors,  you  can  run  it  by  choosing  Tools ➪ Run  Java  Application  or  pressing  Ctrl+2.  A  command  window  opens,  in   40      BOOK 1  Java Basics   which the program runs. Figure 3-4 shows the HelloApp program running in a  separate window atop the TextPad window.  FIGURE 3-4:   Running a   program.     d a P t x e T h t i w g n k r o W  i     When the program finishes, the message Press any key to continue appears  in the command window. When you press a key, the window closes, and TextPad  comes back to life.  In case you’re wondering, TextPad actually runs your program by creating and  running a batch file — a short text file that contains the commands necessary to  run your program. This batch file is given a cryptic name, such as tp02a11c.BAT.  Here’s the batch file generated for the HelloApp program:  @ECHO OFF C: CD "\Users\Doug\Documents\Java 5E\Applications\Book 1\Chapter 3" "C:\Program Files\Java\jdk-9\bin\java.exe" HelloApp PAUSE  CHAPTER 3  Working with TextPad      41   Here’s a closer look at these commands:   » The first command tells MS-DOS not to display the commands in the com-  mand window as the batch file executes.   » The next two commands switch to the drive and directory that contain the   java program.   » Next, the java.exe program is called to run the HelloApp class.  » Finally, a PAUSE command executes. That command is what displays the   Press any key to continue message when the program finishes.  42      BOOK 1  Java Basics   Programming  Basics  2   Contents at a Glance  CHAPTER 1:  Java Programming Basics   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 45 CHAPTER 2:  Working with Variables and Data Types   .  .  .  .  .  .  .  .  . 65 CHAPTER 3:  Working with Numbers and Expressions   .  .  .  .  .  .  .  . 99 CHAPTER 4:  Making Choices  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 129 CHAPTER 5:  Going Around in Circles  Or, Using Loops   .  .  .  .  .  .  . 151 CHAPTER 6:  Pulling a Switcheroo  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 179 CHAPTER 7:  Adding Some Methods to Your Madness  .  .  .  .  .  .  .  . 193 CHAPTER 8:  Handling Exceptions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 213   IN THIS CHAPTER  » Introducing the famous Hello,   World! program   » Identifying basic elements of Java   programs such as keywords,  statements, and blocks   » Finding different ways to add  comments to your programs   » Getting basic information about   object-oriented programming   » Identifying ways to import classes  Chapter 1 Java Programming Basics In this chapter, you find the basics of writing simple Java programs. The pro-  grams you see in this chapter are very simple: they just display simple informa- tion on a console  in Windows, that’s a command-prompt window . You need  to cover a few more chapters before you start writing programs that do anything  worthwhile.  But  the  simple  programs  you  see  in  this  chapter  are  sufficient  to  illustrate the basic structure of Java programs.  Be warned that in this chapter, I introduce you to several Java programming fea- tures that are explained in greater detail in later chapters. You see, for example,  some variable declarations, a method, and even an if statement and a for loop.  The  goal  of  this  chapter  isn’t  to  march  you  into  instant  proficiency  with  these  programming elements, but just to introduce you to them.  You  can  find  all  the  code  listings  used  in  this  book  at  www.dummies.com go  javaaiofd5e.  CHAPTER 1  Java Programming Basics      45   Looking at the Infamous Hello,  World! Program  Many programming books begin with a simple example program that displays the  text "Hello, World!" on the console. In Book 1, Chapter 1, I show you a Java pro- gram that does that to compare it with a similar program written in C. Now take a  closer look at each element of this program, shown in Listing 1-1.  LISTING 1-1:   The HelloApp Program  public class HelloApp  {      public static void main String[] args       {          System.out.println "Hello, World!" ;      }  }   →1 →2 →3 →4 →5 →6 →7  Later in this chapter, you discover in detail all the elements that make up this  program. But first, I want to walk you through it word by word.  Lines 1 and 2 mark the declaration of a public class named HelloApp: →1      public: A keyword of the Java language that indicates that the element   that follows should be made available to other Java elements. In this case,  what follows is a class named HelloApp. As a result, this keyword  indicates that the HelloApp class is a public class, which means other  classes can use it.  In Book 3, Chapter 2, I cover the most common  alternative to public: private. There are also other alternatives, but  they’re covered in later chapters.                class: Another Java keyword that indicates that the element being   defined here is a class. All Java programs are made up of one or more  classes. A class definition contains code that defines the behavior of the  objects created and used by the program. Although most real-world  programs consist of more than one class, the simple programs you see in  this minibook have just one class.               HelloApp: An identifier that provides the name for the class being defined   here. Whereas keywords, such as public and class, are words that are  defined by the Java programming language, identifiers are words that you  create to provide names for various elements you use in your program. In  this case, the identifier HelloApp provides a name for the public class   46      BOOK 2  Programming Basics   being defined here.  Although identifier is the technically correct term,  sometimes identifiers are called symbols or names.   →2      {: The opening brace on line 2 marks the beginning of the body of the   class. The end of the body is marked by the closing brace on line 7.  Everything that appears within these braces belongs to the class. As you  work with Java, you’ll find that it uses these braces a lot. Pretty soon the  third and fourth fingers on your right hand will know exactly where they  are on the keyboard.               Lines 3 through 6 define a method of the HelloApp class named main: →3      public: The public keyword is used again, this time to indicate that a  method being declared here should have public access. That means  classes other than the HelloApp class can use it. All Java programs must  have a class that declares a public method named main. The main method  contains the statements that are executed when you run the program.               static: You find all about the static keyword in Book 3, Chapter 3. For  now, just take my word that the Java language requires that you specify  static when you declare the main method.               void: In Java, a method is a unit of code that can calculate and return a   value. For example, you could create a method that calculates a sales total.  Then the sales total would be the return value of the method. If a method  doesn’t need to return a value, you must use the void keyword to indicate  that no value is returned. Because Java requires that the main method not  return a value, you must specify void when you declare the main method.               main: Finally, here’s the identifier that provides the name for this method.  As I’ve already mentioned, Java requires that this method be named main.  Besides the main method, you can create additional methods with  whatever names you want to use. You discover how to create additional  methods in Book 2, Chapter 7. Until then, the programs consist of just one  method named main.                String[] args : Oh, boy. This Java element is too advanced to thor-  oughly explain just yet. It’s called a parameter list, and it’s used to pass data  to a method. Java requires that the main method must receive a single  parameter that’s an array of String objects. By convention, this param- eter is named args. If you don’t know what a parameter, a String, or an  array is, don’t worry about it. You can find out what a String is in the next  chapter, and parameters are in Book 2, Chapter 7; arrays are in Book 4. In  the meantime, realize that you have to code  String[] args  on the  declaration for the main methods in all your programs.  →4      Another{: Another set of braces begins at line 4 and ends at line 6. These  braces mark the body of the main method. Notice that the closing brace in  line 6 is paired with the opening brace in line 4, whereas the closing brace  in line 7 is paired with the one in line 2. This type of pairing is commonplace   CHAPTER 1  Java Programming Basics      47     i  s c i s a B g n m m a r g o r P a v a J      in Java. In short, whenever you come to a closing brace, it’s paired with the  most recent opening brace that hasn’t already been closed — that is, that  hasn’t already been paired with a closing brace.  →5      System.out.println "Hello, World!" ;: This is the only statement in  the entire program. It calls a method named println that belongs to the  System.out object. The println method displays a line of text on the  console. The text to be displayed is passed to the println method as a  parameter in parentheses following the word println. In this case, the text  is the string literal Hello, World! enclosed in a set of quotation marks. As  a result, this statement displays the text Hello, World! on the console.               Note that in Java, most  but not all  statements must end with a semicolon.  Because this statement is the only one in the program, this line is the only  one that requires a semicolon.  →6      }: Line 6 contains the closing brace that marks the end of the main   method body that was begun by the brace on line 4.  →7      Another }: Line 7 contains the closing brace that marks the end of the  HelloApp class body that was begun by the brace on line 2. Because this  program consists of just one class, this line also marks the end of the program.  To run this program, you must first use a text editor such as Notepad or TextPad  to enter it — exactly as it appears in Listing 1-1 — in a text file named HelloApp. java. Then you can compile it by running the following command at a command  prompt:  javac HelloApp.java  This command creates a class file named HelloApp.class that contains the Java  bytecodes compiled for the HelloApp class.  You can run the program by entering this command:  java HelloApp  Now that you’ve seen what a Java program actually looks like, you’re in a better  position to understand exactly what this command does. First, it loads the Java  Virtual Machine  JVM  into memory. Then it locates the  HelloApp class, which  must  be  contained  in  a  file  named  HelloApp.class.  Finally,  it  runs  the  main  method of the HelloApp class. The main method, in turn, displays the message  "Hello, World!" on the console.  The rest of this chapter describes some of the basic elements of the Java program- ming language in greater detail.  48      BOOK 2  Programming Basics   Dealing with Keywords  A keyword is a word that has a special meaning defined by the Java programming  language. The program shown earlier in Listing 1-1 uses four keywords: public,  class, static, and void. In all, Java has 53 keywords. They’re listed in alphabeti- cal order in Table 1-1.  double  implements  protected  TABLE 1-1	  abstract  assert  boolean  break  byte  case  catch  char  class  const  continue  Java’s Keywords goto default  do  if  extends  int  else  enum  false  final  finally  float  for  import  instanceof  interface  long  native  new  null  package  private  public  return  short  static  strictfp  super  switch  synchronized  this  throw  throws  transient  true  try  void  volatile  while  Strangely enough, three keywords listed in Table 1-1 — true, false, and null —   aren’t technically considered to be keywords. Instead, they’re called literals. Still,  they’re reserved for use by the Java language in much the same way that keywords  are, so I lumped them in with the keywords.  Stranger still, two keywords — const and goto — are reserved by Java but don’t  do anything. Both are carryovers from the C++ programming language. The const  keyword defines a constant, which is handled in Java by the final keyword. As  for goto, it’s a C++ statement that is considered anathema to object-oriented pro- gramming purists, so it isn’t used in Java. Java reserves it as a keyword solely for  the purpose of scolding you if you attempt to use it.     i  s c i s a B g n m m a r g o r P a v a J     Like  everything  else  in  Java,  keywords  are  case-sensitive.  Thus,  if  you  type  If  instead  of  if  or  For  instead  of  for,  the  compiler  complains  about  your  error.  Because Visual Basic keywords begin with capital letters, you’ll make this mistake  frequently if you’ve programmed in Visual Basic.  CHAPTER 1  Java Programming Basics      49   Considering  the  Java  community’s  disdain  for  Visual  Basic,  it’s  surprising  that  the error messages generated when you capitalize keywords aren’t more insult- ing. Accidentally capitalizing a keyword in Visual Basic style can really throw the  Java compiler for a loop. Consider this program, which contains the single error of  capitalizing the word For:  When you try to compile this program, the compiler generates a total of four error  messages for this one mistake:  public class CaseApp {     public static void main String[] args      {         For  int i = 0; i<5; i++              System.out.println "Hi" ;     } }  C:\Java AIO\CaseApp.java:5: '.class' expected         For  int i = 0; i<5; i++                   ^ C:\Java AIO\CaseApp.java:5: illegal start of type         For  int i = 0; i<5; i++                            ^ C:\Java AIO\CaseApp.java:5: not a statement         For  int i = 0; i<5; i++                           ^ C:\Java AIO\CaseApp.java:5: ';' expected         For  int i = 0; i<5; i++                                  ^ 4 errors      For  int i = 0; i<5; i++   Even though this single mistake generates four error messages, not one of the  messages actually points to the problem. The little arrow beneath the source line  indicates what part of the line is in error, and none of these error messages has  the arrow pointing anywhere near the word For! The compiler isn’t smart enough  to realize that you meant for instead of For. So it treats For as a legitimate identi- fier and then complains about everything else on the line that follows it. It would  be much more helpful if the compiler generated an error message like this:  C:\Java AIO\CaseApp.java:5: 'For' is not a keyword         For  int i = 0; i<5; i++   50      BOOK 2  Programming Basics   Better yet, for those of us old enough to remember Get Smart on TV:  C:\Java AIO\CaseApp.java:5: Thees ees Java! Vee do not capitalize keyverds     here!          For  int i = 0; i<5; i++   The moral of the story is that keywords are case-sensitive, and if your program  won’t compile and the error messages don’t make any sense, check for keywords  that you’ve mistakenly capitalized.  Working with Statements  Like  most  programming  languages,  Java  uses  statements  to  build  programs.  Unlike most programming languages, Java doesn’t use statements as its funda- mental unit of code. Instead, it gives that honor to the class. However, every class  must have a body, and the body of a class is made up of one or more statements.  In other words, you can’t have a meaningful Java program without at least one  statement. The following sections describe the ins and outs of working with Java  statements.  Types of statements  Java has many types of statements. Some statements simply create variables that  you can use to store data. These types of statements are often called declaration  statements and tend to look like this:  Another  common  type  of  statement  is  an  expression  statement,  which  performs  calculations. Here are some examples of expression statements:  int i; String s = "This is a string"; Customer c = new Customer  ;  i = a + b; salesTax = invoiceTotal * taxRate; System.out.println "Hello, World!" ;  Notice that the last statement in this group is the same as line 5 in Listing 1-1.  Thus the single statement in the HelloApp program is an expression statement.     i  s c i s a B g n m m a r g o r P a v a J     CHAPTER 1  Java Programming Basics      51   There are many kinds of statements besides these two. if-then statements, for  example, execute other statements only if a particular condition has been met,  and statements such as for, while, and do execute whole groups of statements  one or more times.  It’s often said that every Java statement must end with a semicolon. Actually, this  isn’t quite true. Some types of Java statements must end with semicolons — but  others don’t have to. The basic rule is that declaration and expression statements  must end with a semicolon, but most other statement types do not. Where this  rule gets tricky, however, is that most other types of statements include one or  more declarations or expression statements that do use semicolons. Here’s a typi- cal if statement:  if  total > 100      discountPercent = 10;  Here, the variable named discountPercent is given a value of 10 if the value of  the total variable is greater than 100. The expression statement ends with a semi- colon, but the if statement itself doesn’t.  The Java compiler lets you know if you  use a semicolon when you shouldn’t.   White space  In Java, the term white space refers to one or more consecutive space characters,  tab characters, or line breaks. All white space is considered the same.  In other words, a single space is treated the same as a tab or line break or any  combination of spaces, tabs, and line breaks.  If you’ve programmed in Visual Basic, white space is different from what you’re  used  to.  In  Visual  Basic,  line  breaks  mark  the  end  of  statements  unless  special  continuation characters are used. In Java, you don’t have to do anything special to  continue a statement onto a second line. Thus the statement  x =  y + 5    z;  is identical to this statement:  x =  y + 5    z;  52      BOOK 2  Programming Basics   In fact, you could write the preceding statement like this if you wanted:  x =   y + 5     z ;  I wouldn’t advise it, but the statement does compile and execute properly.  Be advised, however, that you can’t put white space in the middle of a keyword or  identifier. The following example won’t work:  p u b l i c  static  v o i d  main String[] args   Here the extra spaces between the letters in the words public and void will confuse  the compiler.  Using  white  space  liberally  in  your  programs  is  a  good  idea.  In  particular,  you  should routinely use white space like this:   » Line breaks: Place each statement on a separate line.  » Tabs: Line up elements that belong together.  The compiler ignores the extra white space, so it doesn’t affect the bytecode that’s  created for your program. As a result, using extra white space in your program  doesn’t affect your program’s performance in any way, but it does make the pro- gram’s source code easier to read.  Working with Blocks  A block is a group of one or more statements that’s enclosed in braces. A block  begins with an opening brace   {   and ends with a closing brace   }  . Between the      i  s c i s a B g n m m a r g o r P a v a J     CHAPTER 1  Java Programming Basics      53   opening and closing braces, you can code one or more statements. Here’s a block  that consists of three statements:  {     int i, j;     i = 100;     j = 200; }  A block is itself a type of statement. As a result, any time the Java language requires  a statement, you can substitute a block to execute more than one statement. In  Book 2, Chapter 4, you discover that the basic syntax of an if statement is this:  if   expression   statement  Here statement can be a single statement or a block. If you find this idea confus- ing, don’t worry; it will make more sense when you turn to Book 2, Chapter 4.  You can code the braces that mark a block in two popular ways. One is to place  both braces on separate lines and then indent the statements that make up the  block. For example:  if   i > 0  {     String s = "The value of i is " + i;     System.out.print s ; }  if   i > 0  {     String s = "The value of i is " + i;     System.out.print s ; }  The other style is to place the opening brace for the block on the same line as the  statement the block is associated with, like this:  Which style you use is a matter of personal preference. I prefer the first style, and  that’s the style I use throughout this book. But either style works — and many  programmers prefer the second style because it’s more concise.  Note that even though a block can be treated as a single statement, you should  not end a block with a semicolon. The statements within the block may require  semicolons, but the block itself does not.  54      BOOK 2  Programming Basics   Creating Identifiers  An identifier is a word that you make up to refer to a Java programming element by  name. Although you can assign identifiers to many types of Java elements, they’re  most commonly used for the following elements:   » Classes, such as the HelloApp class in Listing 1-1  » Methods, such as the main method in Listing 1-1  » Variables and fields, which hold data used by your program  » Parameters, which pass data values to methods  Identifiers are also sometimes called names. Strictly speaking, a name isn’t quite  the same thing as an identifier; a name is often made up of two or more identifiers  connected with periods  called dots . In line 5 of Listing 1-1, for example, System  and  out  are  both  identifiers,  but  System.out  is  a  name.  In  practice,  the  terms  name and identifier are used interchangeably.  You must follow a few simple rules when you create identifiers:   » Identifiers are case-sensitive. As a result, SalesTax and salesTax are distinct   identifiers.   » Identifiers can be made up of upper- or lowercase letters, numerals, under-  score characters    , and dollar signs   $  . Thus, identifier names such as  Port1, SalesTax$, and Total_Sales.   » All identifiers must begin with a letter. Thus, a15 is a valid identifier, but   13Unlucky isn’t  because it begins with a numeral .   » An identifier can’t be the same as any of the Java keywords listed in Table 1-1.   Thus, you can’t create a variable named for or a class named public.   » The Java language specification recommends that you avoid using dollar signs   in names you create, because code generators use dollar signs to create  identifiers. Thus, avoiding dollar signs helps you avoid creating names that  conflict with generated names.     i  s c i s a B g n m m a r g o r P a v a J     Crafting Comments  A comment is a bit of text that provides explanations of your code. The compiler  ignores comments, so you can place any text you want in a comment. Using plenty   CHAPTER 1  Java Programming Basics      55   of comments in your program is a good way to explain what your program does  and how it works.  Java  has  three  basic  types  of  comments:  end-of-line  comments,  traditional  com- ments, and JavaDoc comments. More about that is coming right up.  End-of-line comments  An end-of-line comment begins with the sequence     a pair of consecutive slashes   and  ends  at  the  end  of  the  line.  You  can  place  an  end-of-line  comment  at  the  end of any line. Everything you type after the    is ignored by the compiler. For  example:  total = total * discountPercent;    calculate the discounted total  If you want, you can also place end-of-line comments on separate lines, like this:     calculate the discounted total total = total * discountPercent;  You can place end-of-line comments in the middle of statements that span two  or more lines. For example:  total =  total * discountPercent      apply the discount first       + salesTax;                     then add the sales tax  Traditional comments  A traditional comment begins with the sequence  * , ends with the sequence * , and  can span multiple lines. Here’s an example:   * HelloApp sample program.    This program demonstrates the basic structure    that all Java programs must follow. *   A traditional comment can begin and end anywhere on a line. If you want, you can  even sandwich a comment between other Java programming elements, like this:  x =  y +  * a strange place for a comment *  5    z;  Usually, traditional comments appear on separate lines. One common use for tra- ditional comments is to place a block of comment lines at the beginning of a class  to indicate information about the class — such as what the class does, who wrote   56      BOOK 2  Programming Basics   it, and so on. That type of comment, however, is usually better coded as a JavaDoc  comment, as described in the next section.  You may be tempted to temporarily comment out a range of lines by placing  *  in front of the first line in the range and *  after the last line in the range. That  practice can get you in trouble, however, if the range of lines you try to comment  out includes a traditional comment, because traditional comments can’t be nested.  The following code won’t compile, for example:   * int x, y, z; y = 10; z = 5; x =  y +  * a strange place for a comment *  5    z; *   Here, I tried to comment out a range of lines that already included a traditional  comment. Unfortunately, the *  sequence near the end of the fifth line is inter- preted as the end of the traditional comment that begins in the first line, so when  the compiler encounters the *  sequence in line 6, it generates an error message.  JavaDoc comments  JavaDoc  comments  are  actually  special  types  of  traditional  comments  that  you  can use to create web-based documentation for your programs — automatically.  Because you’ll have a better appreciation of JavaDoc comments when you know  more about object-oriented programming, I devote a section in Book 3, Chapter 8,  to creating and using JavaDoc comments.  Introducing Object-Oriented Programming  Having  presented  some  of  the  most  basic  elements  of  the  Java  programming  language, most Java books would next turn to the important topics of variables and  data types. Because Java is an inherently object-oriented programming language,  however,  and  because  classes  are  the  heart  of  object-oriented  programming,  I look next at classes to explore the important role they play in creating objects.  I get to variables and data types first thing in the next chapter.  Understanding classes and objects  As I’ve already mentioned, a class is code that defines the behavior of a Java pro- gramming element called an object. An object is an entity that has both state and   CHAPTER 1  Java Programming Basics      57     i  s c i s a B g n m m a r g o r P a v a J      behavior. The state of an object consists of any data that the object might be keep- ing track of, and the behavior consists of actions that the object can perform. The  behaviors are represented in the class by one or more methods that can be called  on to perform actions.  The difference between a class and an object is similar to the difference between a  blueprint and a house. A blueprint is a plan for a house. A house is an implementa- tion of a blueprint. One set of blueprints can be used to build many houses. Like- wise, a class is a plan for an object, and an object is — in Java terms — an instance  of a class. You can use a single class to create more than one object.  When an object is created, Java sets aside an area of computer memory that’s suf- ficient to hold all the data that’s stored by the object. As a result, each instance of  a class has its own data, independent of the data used by other instances of the  same class.  Understanding static methods  You  don’t  necessarily  have  to  create  an  instance  of  a  class  to  use  the  methods  of the class. If you declare a method with the static keyword, you can call the  method without first creating an instance of the class, because static methods  are called from classes, not from objects.  The main method of a Java application must be declared with the static keyword  because when you start a Java program by using the java command from a com- mand prompt, Java doesn’t create an instance of the application class. Instead, it  simply calls the program’s static main method.  The difference between static and nonstatic methods will become more apparent  when you look at object-oriented programming in more depth in Book 3. But for  now, consider this analogy. The blueprints for a house include the details about  systems  that  actually  perform  work  in  a  finished  house,  such  as  electrical  and  plumbing systems. To use those systems, you have to actually build a house. In  other words, you can’t turn on the hot water by using the blueprint alone; you  have to have an actual house with an actual device to heat the water.  The blueprints do include detailed measurements of the dimensions of the house,  however. As a result, you can use the blueprints to determine the square footage  of the living room.  Now imagine that the blueprints actually have a built-in calculator that displays  the size of the living room if you push the Living Room button. That button would  be like a static method in a class: You don’t actually have to build a house to use  the button; you can activate it from the blueprints alone.  58      BOOK 2  Programming Basics   Many Java programs — in fact, many of the programs in the rest of Book 2 — are  entirely made up of static methods. Most realistic programs, however, require  that  you  create  one  or  more  objects  that  the  program  uses  as  it  executes.  As  a  result, knowing how to create simple classes and how to create objects from those  classes are basic skills in Java programming.  Creating an object from a class  In Java, you can create an object from a class in several ways. The most straight- forward way is to create a variable that provides a name you can use to refer to the  object, use the new keyword to create an instance of the class, and then assign the  resulting object to the variable. The general form of a statement that does that bit  of magic looks like this:  ClassName variableName = new ClassName  ;  To create an object instance of a class named Class1 and assign it to a variable  named myClass1Object, you would write a statement like this:  Class1 myClass1Object = new Class1  ;  Why do you have to list the class name twice? The first time, you’re providing a  type for the variable. In other words, you’re saying that the variable you’re creat- ing here can be used to hold objects created from the Class1 class. The second  time you list the class name, you’re creating an object from the class. The  new  keyword tells Java to create an object, and the class name provides the name of the  class to use to create the object.  The equal sign  =  is an assignment operator. It simply says to take the object cre- ated by the new keyword and assign it to the variable. Thus, this statement actu- ally does three things:   » It creates a variable named myClass1Object that can be used to hold objects   created from the Class1 class. At this point, no object has been created —  just a variable that can be used to store objects.   » It creates a new object in memory from the Class1 class.  » It assigns this newly created object to the myClass1Object variable. That way,  you can use the myClassObject variable to refer to the object that was created.     i  s c i s a B g n m m a r g o r P a v a J     CHAPTER 1  Java Programming Basics      59   Viewing a program that uses an object  To give you an early look at what object-oriented programming really looks like,  Listing 1-2 and Listing 1-3 show another version of the HelloApp application —  this time using two classes, one of which is actually made into an object when  the program is run. The first class, named HelloApp2, is shown in Listing 1-2.  This class is similar to the HelloApp class shown in Listing 1-1 but uses an object  created from the second class, named Greeter, to actually display the "Hello,  World!" message on the console. The  Greeter class is shown in Listing 1-3. It  defines a method named sayHello that displays the message.  Both the HelloApp and the Greeter classes are public classes. Java requires that  each public class be stored in a separate file with the same name as the class; the  filename ends with the extension .java. As a result, the HelloApp2 class is stored  in a file named HelloApp2.java, and the Greeter class is stored in a file named  Greeter.java.  The HelloApp2 class The HelloApp2 class is shown in Listing 1-2.  LISTING 1-2:   The HelloApp2 Class     This application displays a hello message on     the console by creating an instance of the    Greeter class and then calling the Greeter    object's sayHello method.  public class HelloApp2  {     public static void main String[] args       {         Greeter myGreeterObject = new Greeter  ;          myGreeterObject.sayHello  ;      } }  →1  →6  →8  →10 →11  The following paragraphs describe the key points: →1       This class begins with a series of comment lines identifying the function   of the program. For these comments, I used simple end-of-line com- ments rather than traditional comments.  For more on commenting, see  the “Crafting Comments” section, earlier in this chapter.   60      BOOK 2  Programming Basics   →6        The HelloApp2 class begins on line 6 with the public class declaration.   Because the public keyword is used, a file named HelloApp2.java  must contain this class.  →8         The main method is declared, using the same form as the main method  in the first version of this program  Listing 1-1 . Get used to this form,  because all Java applications must include a main method that’s declared  in this way.  →10      The first line in the body of the main method creates a variable named  myGreeterObject that can hold objects created from the Greeter class.  Then it creates a new object using the Greeter class and assigns this  object to the myGreeterObject variable.  →11      The second line in the body of the main method calls the myGreeterOb- ject object’s sayHello method. As you’ll see in a moment, this method  simply displays the message "Hello, World!" on the console.  The Greeter class The Greeter class is shown in Listing 1-3.  LISTING 1-3:   The Greeter Class     This class creates a Greeter object     that displays a hello message on    the console.  public class Greeter  {     public void sayHello        {         System.out.println "Hello, World!" ;      } }  The following paragraphs describe the key points: →1      This class also begins with a series of comment lines that identify the   function of the program.  →5      The class declaration begins on this line. The class is declared as public so  other classes can use it. This declaration is required so that the HelloApp2  class can access the Greeter class.  CHAPTER 1  Java Programming Basics      61  →1  →5  →7  →9     i  s c i s a B g n m m a r g o r P a v a J      →7      The sayHello method is declared using the public keyword so that it’s  available to other classes that use the Greeter class. The void keyword  indicates that this method doesn’t provide any data back to the class that  calls it, and sayHello simply provides the name of the method.  →9      The body of this method consists of just one line of code that displays the   "Hello, World!" message on the console.  So what’s the difference?  You  may  notice  that  the  only  line  that  actually  does  any  real  work  in  the   HelloApp2 program is line 9 in the Greeter class  Listing 1-3 , and this line hap- pens to be identical to line 5 in the original HelloApp class  Listing 1-1 . Other  than the fact that the second version requires roughly twice as much code as the  first version, what really is the difference between these two applications?  Simply put, the first version is procedural, and the second is object-oriented. In  the first version of the program, the main method of the application class does all  the work of the application by itself: It just says hello. The second version defines  a class that knows how to say hello to the world and then creates an object from  that class and asks that object to say hello. The application itself doesn’t know   or even care  exactly how the Greeter object says hello. It doesn’t know exactly  what the greeting will be, what language the greeting will be in, or even how the  greeting will be displayed.  To illustrate this point, consider what would happen if you used the Greeter class  shown in Listing 1-4 rather than the one shown in Listing 1-3. This version of the  Greeter class uses a Java library class called JOptionPane to display a message in  a dialog box rather than in a console window.  I won’t bother explaining in a list  how this code works, but you can find out more about it in the next chapter.  If  you were to run the HelloApp2 application using this version of the Greeter class,  you’d get the dialog box shown in Figure 1-1.  LISTING 1-4:  Another Version of the Greeter Class     This class creates a Greeter object    that displays a hello message    in a dialog box.  import javax.swing.JOptionPane;   →5  public class Greeter {  62      BOOK 2  Programming Basics       public void sayHello       {         JOptionPane.showMessageDialog null,              "Hello, World!", "Greeter",             JOptionPane.INFORMATION_MESSAGE ;     } }  →11  FIGURE 1-1:   The class in   Listing 1-4   displays this  dialog box.  The important point to realize here is that the HelloApp2 class doesn’t have to be  changed to use this new version of the Greeter class. Instead, all you have to do is  replace the old Greeter class with the new one, recompile the Greeter class, and  the HelloApp2 class won’t know the difference. That’s one of the main benefits of  object-oriented programming.  Importing Java API Classes  You may have noticed that the Greeter class in Listing 1-4 includes this statement:  import javax.swing.JOptionPane;  The purpose of the import statement is to let the compiler know that the program  is using a class that’s defined by the Java API called JOptionPane.  Because the Java API contains literally thousands of classes, some form of orga- nization is needed to make the classes easier to access. Java does this by group- ing classes into manageable groups called packages. In the previous example, the  package that contains the JOptionPane class is named javax.swing.  Strictly  speaking,  import  statements  are  never  required.  But  if  you  don’t  use  import statements to import the API classes your program uses, you must fully  qualify the names of the classes when you use them by listing the package name      i  s c i s a B g n m m a r g o r P a v a J     CHAPTER 1  Java Programming Basics      63   in front of the class name. So if the class in Listing 1-4 didn’t include the import  statement in line 5, you’d have to code line 11 like this:  javax.swing.JOptionPane.showMessageDialog null,     "Hello, World!", "Greeter",     javax.swing.JOptionPane.INFORMATION_MESSAGE ;  In other words, you’d have to specify javax.swing.JOptionPane instead of just  JOptionPane whenever you referred to this class.  Here are some additional rules for working with import statements:   » import statements must appear at the beginning of the class file, before any   class declarations.   » You can include as many import statements as are necessary to import all the   classes used by your program.   » You can import all the classes in a particular package by listing the package   name followed by an asterisk wildcard, like this:  import javax.swing.*;   » Because many programs use the classes that are contained in the java.lang   package, you don’t have to import that package. Instead, those classes are  automatically available to all programs. The System class is defined in the  java.lang package. As a result, you don’t have to provide an import  statement to use this class.   » The latest version of Java, called JDK 9, introduces a new feature for managing   packages called the Java Platform Module System. I cover this new feature in  Book 3, Chapter 8.  64      BOOK 2  Programming Basics   IN THIS CHAPTER  » Creating proper variable declarations   » Discovering the difference between   primitive and reference types   » Looking at Java’s built-in data types   » Introducing strings   » Getting input from the console   » Getting input if you’re using an older   version of Java  Chapter 2 Working with Variables  and Data Types  In  this  chapter,  you  find  out  the  basics  of  working  with  variables  in  Java.   Variables  are  the  key  to  making  Java  programs  general  purpose.  The  Hello,  World!  programs in the previous chapter, for example, are pretty specific: The  only thing they say is “Hello, World!” But with a variable, you can make this type  of program more general. You could vary the greeting so that sometimes it would  say “Hello, World!” and at other times it would say “Greetings, Foolish Mortals.”  Or  you  could  personalize  the  greeting,  so  that  it  said  “Hello,  Bob!”  or  “Hello,  Amanda!”  Variables  are  also  the  key  to  creating  programs  that  can  perform  calculations.  Suppose  that  you  want  to  create  a  program  that  calculates  the  area  of  a  circle,  given the circle’s radius. Such a program uses two variables: one to represent the  radius of the circle and the other to represent the circle’s area. The program asks  the user to enter a value for the first variable. Then it calculates the value of the  second variable.  CHAPTER 2  Working with Variables and Data Types      65   Declaring Variables  In Java, you must explicitly declare all variables before using them. This rule is in  contrast to some languages — most notably Basic and earlier versions of Visual  Basic, which let you use variables that haven’t been automatically declared.  Allowing you to use variables that you haven’t explicitly declared might seem a  pretty good idea at first glance, but it’s a common source of bugs that result from  misspelled variable names. Java requires that you explicitly declare variables so  that if you misspell a variable name, the compiler can detect your mistake and  display a compiler error.  The basic form of a variable declaration is this:  type name;  Here are some examples:  int x; String lastName; double radius;  In these examples, variables named  x,  lastName, and  radius are declared. The  x variable holds integer values, the lastName variable holds String values, and  the radius variable holds double values. For more information about what these  types  mean,  see  the  section  “Working  with  Primitive  Data  Types”  later  in  this  chapter. Until then, just realize that int variables can hold whole numbers  such  as  5,  1,340,  or  -34 ,  double  variables  can  hold  numbers  with  fractional  parts   such as 0.5, 99.97, or 3.1415 , and String variables can hold text values  such  as "Hello, World!" or "Jason P. Finch" .  Notice that variable declarations end with semicolons. That’s because a variable  declaration is itself a type of statement.  Variable  names  follow  the  same  rules  as  other  Java identifiers,  as  I  describe  in  Book 2, Chapter 1, so see that chapter for details. In short, a variable name can be  any combination of letters, numerals, or underscores and dollar signs – but must  start with a letter. Most programmers prefer to start variable names with low- ercase letters and capitalize the first letter of individual words within the name.  firstName and salesTaxRate, for example, are typical variable names.  66      BOOK 2  Programming Basics   Declaring two or more variables   in one statement  You can declare two or more variables of the same type in a single statement by  separating the variable names with commas. For example:  int x, y, z;  Here three variables of type int are declared, using the names x, y, and z.  As a rule, I suggest that you avoid declaring multiple variables in a single state- ment. Your code is easier to read and maintain if you give each variable a separate  declaration.  Declaring class variables  A class variable is a variable that any method in a class can access, including static  methods such as main. When declaring a class variable, you have two basic rules  to follow:   » You must place the declaration within the body of the class but not within any   of the class methods.   » You must include the word static in the declaration. The word static   comes before the variable type.  The following program shows the proper way to declare a class variable named  helloMessage:  public class HelloApp {     static String helloMessage;     public static void main String[] args      {         helloMessage = "Hello, World!";         System.out.println helloMessage ;     } }  As you can see, the declaration includes the word static and is placed within the  HelloApp class body but not within the body of the main method.  CHAPTER 2  Working with Variables and Data Types      67   You  don’t  have  to  place  class  variable  declarations  at  the  beginning  of  a  class.  Some programmers prefer to place them at the end of the class, as in this example:  public class HelloApp {     public static void main String[] args      {         helloMessage = "Hello, World!";         System.out.println helloMessage ;     }     static String helloMessage; }  Here the helloMessage variable is declared after the main method.  I think classes are easier to read if the variables are declared first, so that’s where  you see them in this book.  Declaring instance variables  An  instance  variable  is  similar  to  a  class  variable  but  doesn’t  specify  the  word  static  in  its  declaration.  As  the  name  suggests,  instance  variables  are  associ- ated with instances of classes. As a result, you can use them only when you create  an instance of a class. Because static methods aren’t associated with an instance  of  the  class,  you  can’t  use  an  instance  variable  in  a  static  method  —  and  that  includes the main method.  The following example program won’t compile:  public class HelloApp {     String helloMessage;        error -- should use static keyword     public static void main String[] args      {         helloMessage = "Hello, World!";         System.out.println helloMessage ;      will not compile     } }  If you attempt to compile this program, you get the following error messages:  C:\J ava\HelloApp.java:7: error: non-static variable helloMessage cannot be   referenced from a static context                  helloMessage = "Hello, World!";                 ^  68      BOOK 2  Programming Basics   C:\J ava\HelloApp.java:8: non-static variable helloMessage cannot be   referenced from a static context                  System.out.println helloMessage ;                                    ^  Both of these errors occur because the main method is static, so it can’t access  instance variables.  Instance variables are useful whenever you create your own classes, but because  I don’t cover that topic until Book 3, you won’t see many examples of instance  methods in the remainder of the chapters in Book 2.  Declaring local variables  A local variable is a variable that’s declared within the body of a method. Then you  can use the variable only within that method. Other methods in the class aren’t  even aware that the variable exists.  Here’s  a  version  of  the  HelloApp  class  in  which  the  helloMessage  variable  is  declared as a local variable:  public class HelloApp {     public static void main String[] args      {         String helloMessage;         helloMessage = "Hello, World!";         System.out.println helloMessage ;     } }  Note that you don’t specify static on a declaration for a local variable. If you do,  the compiler generates an error message and refuses to compile your program.  Local variables always exist in the context of a method, and they exist only while  that method is executing. As a result, whether or not an instance of the class has  been created is irrelevant.  Unlike class and instance variables, a local variable is fussy about where you posi- tion the declaration for it. In particular, you must place the declaration before the  first statement that actually uses the variable. Thus the following program won’t  compile:  public class HelloApp {     public static void main String[] args      {  CHAPTER 2  Working with Variables and Data Types      69           helloMessage = "Hello, World!";      error -- helloMessage         System.out.println helloMessage ;    is not yet declared         String helloMessage;     } }  When  it  gets  to  the  first  line  of  the  main  method,  the  compiler  generates  two  error messages complaining that it can’t find the symbol "helloMessage". That’s  because the symbol hasn’t been declared.  Although  most  local  variables  are  declared  near  the  beginning  of  a  method’s  body, you can also declare local variables within smaller blocks of code marked by  braces. This will make more sense to you when you read about statements that use  blocks, such as if and for statements. But here’s an example:  if  taxRate > 0  {     double taxAmount;     taxAmount = subTotal * taxRate;     total = subTotal + total; }  Here the variable taxAmount exists only within the set of braces that belongs to  the if statement.  The variables taxRate, subtotal, and total are defined out- side of the code block defined by the braces.   Initializing Variables  In Java, local variables are not given initial default values. The compiler checks to  make sure that you have assigned a value before you use a local variable. The fol- lowing example program won’t compile:  public class testApp {     public static void main String[] args      {         int i;         System.out.println "The value of i is " + i ;     } }  70      BOOK 2  Programming Basics   If you try to compile this program, you get the following error message:  C:\Java\testApp.java:6: error: variable i might not have been initialized         System.out.println "The value of i is " + i ;                                                   ^  To  avoid  this  error  message,  you  must  initialize  local  variables  before  you  use  them. You can do that by using an assignment statement or an initializer, as I  describe in the following sections.  Unlike local variables, class variables and instance variables are given default val- ues. Numeric types are automatically initialized to zero, and String variables are  initialized to empty strings. As a result, you don’t have to initialize a class variable  or an instance variable, although you can if you want them to have an initial value  other than the default.  Initializing variables with   assignment  statements  One way to initialize a variable is to code an assignment statement following the  variable declaration. Assignment statements have this general form:  variable = expression;  Here, the expression can be any Java expression that yields a value of the same  type as the variable. Here’s a version of the main method from the previous exam- ple that correctly initializes the i variable before using it:      public static void main String[] args      {         int i;         i = 0;         System.out.println "i is " + i ;     }  In this example, the variable is initialized to a value of zero before the println  method is called to print the variable’s value.  You find out a lot more about expressions in Book 2, Chapter 3. For now, you can  just use simple literal values, such as 0 in this example.  CHAPTER 2  Working with Variables and Data Types      71   Initializing variables with initializers  Java also allows you to initialize a variable on the same statement that declares the  variable. To do that, you use an initializer, which has the following general form:  In effect, the initializer lets you combine a declaration and an assignment state- ment into one concise statement. Here are some examples:  type name = expression;  int x = 0; String lastName = "Lowe"; double radius = 15.4;  In each case, the variable is both declared and initialized in a single statement.  When you declare more than one variable in a single statement, each variable can  have its own initializer. The following code declares variables named x and y, and  initializes x to 5 and y to 10:  When you declare two class or instance variables in a single statement but use  only one initializer, you can mistakenly think that the initializer applies to both  variables. Consider this statement:  int x = 5, y = 10;  static int x, y = 5;  Here you might think that both x and y would initialize to 5. But the initializer  applies only to y, so x is initialized to its default value, 0.  If you make this mistake  with a local variable, the compiler displays an error message for the first state- ment that uses the x variable because it isn’t properly initialized.   Using Final Variables  Constants   A final variable, also called a constant, is a variable whose value you can’t change  after it’s been initialized. To declare a final variable, you add the final keyword  to the variable declaration, like this:  final int WEEKDAYS = 5;  72      BOOK 2  Programming Basics   Although  you  can  create  final  local  variables,  most  final  variables  are  class  or  instance variables. To create a final class variable  sometimes called a class con- stant , add static final  not final static  to the declaration, as follows:  static final WEEKDAYS = 5;  Although  it  isn’t  required,  using  all  capital  letters  for  final  variable  names  is  common. When you do so, you can easily spot the use of final variables in your  programs.  Constants are useful for values that are used in several places throughout a pro- gram and that don’t change during the course of the program. Suppose that you’re  writing  a  game  that  features  bouncing  balls,  and  you  want  the  balls  always  to  have a radius of 6 pixels. This program probably needs to use the ball diameter in  several places — to draw the ball onscreen, to determine whether the ball has hit  a wall, to determine whether the ball has hit another ball, and so on. Rather than  just specify 6 whenever you need the ball’s radius, you can set up a class constant  named BALL_RADIUS, like this:  static final BALL_RADIUS = 6;  Using a class constant has two advantages:   » If you decide later that the radius of the balls should be 7, you make the   change in just one place: the initializer for the BALL_RADIUS constant.  » The constant helps document the inner workings of your program. The   operation of a complicated calculation that uses the ball’s radius is easier to  understand if it specifies BALL_RADIUS rather than 6, for example.  Working with Primitive Data Types  The term data type refers to the type of data that can be stored in a variable. Java  is sometimes called a strongly typed language because when you declare a variable,  you must specify the variable’s type. Then the compiler ensures that you don’t  try to assign data of the wrong type to the variable. The following example code  generates a compiler error:  int x; x = 3.1415;  Because x is declared as a variable of type int  which holds whole numbers , you  can’t assign the value 3.1415 to it.  CHAPTER 2  Working with Variables and Data Types      73   Java makes an important distinction between primitive types and reference types.   » Primitive types are the data types defined by the language itself.  » Reference types are types defined by classes in the Java application program- ming interface  API  or by classes you create rather than by the language itself.  A key difference between a primitive type and a reference type is that the memory  location associated with a primitive-type variable contains the actual value of the  variable.  As  a  result,  primitive  types  are  sometimes  called  value types.  By  con- trast, the memory location associated with a reference-type variable contains an  address  called a pointer  that indicates the memory location of the actual object.  I explain reference types more fully in the section “Using Reference Types,” later  in this chapter, so don’t worry if this explanation doesn’t make sense just yet.  It isn’t quite true that reference types are defined by the Java API and not by the  Java language specification. A few reference types, such as Object and String, are  defined by classes in the API, but those classes are specified in the Java Language  API. Also, a special type of variable called an array, which can hold multiple occur- rences of primitive- or reference-type variables, is considered to be a reference type.  Java defines a total of eight primitive types, listed in Table 2-1. Of the eight primi- tive  types,  six  are  for  numbers,  one  is  for  characters,  and  one  is  for  true false  values.  TABLE 2-1	  Java’s Primitive Types Type  Explanation  int  short  long  byte  float  double  char  boolean  A 32-bit  4-byte  integer value  A 16-bit  2-byte  integer value  A 64-bit  8-byte  integer value  An 8-bit  1-byte  integer value  A 32-bit  4-byte  floating-point value  A 64-bit  8-byte  floating-point value  A 16-bit character using the Unicode encoding scheme  A true or false value  74      BOOK 2  Programming Basics   Integer types  An integer is a whole number — that is, a number with no fractional or decimal  portion. Java has four integer types, which you can use to store numbers of vary- ing sizes. The most commonly used integer type is int. This type uses 4 bytes  to store an integer value that can range from about negative 2 billion to positive  2 billion.  If you’re writing the application that counts how many hamburgers McDonald’s  has sold, an int variable may not be big enough. In that case, you can use a long  integer  instead.  long  is  a  64-bit  integer  that  can  hold  numbers  ranging  from  about negative 9,000 trillion to positive 9,000 trillion.  That’s a big number, even  by federal deficit standards.   In some cases, you may not need integers as large as the standard int type pro- vides. For those cases, Java provides two smaller integer types. The short type  represents a two-digit integer, which can hold numbers from –32,768 to +32,767,  and the byte type defines an 8-bit integer that can range from –128 to +127.  Although the short and byte types require less memory than the int and long  types,  there’s  usually  little  reason  to  use  them  for  desktop  applications,  where  memory is usually plentiful. A few bytes here or there won’t make any difference  in the performance of most programs — so you should stick to int and long most  of the time. Also, use long only when you know that you’re dealing with numbers  too large for int.  In Java, the size of integer data types is specified by the language and is the same  regardless of what computer a program runs on. This is a huge improvement over  the C and C++ languages, which let compilers for different platforms determine  the optimum size for integer data types. As a result, a C or C++ program writ- ten and tested on one type of computer may not execute identically on another  computer.  Java allows you to promote an integer type to a larger integer type. Java allows the  following, for example:  int xInt; long yLong; xInt = 32; yLong = xInt;  int xInt; long yLong;  Here you can assign the value of the xInt variable to the yLong variable because  yLong is larger than xInt. Java does not allow the converse, however:  CHAPTER 2  Working with Variables and Data Types      75   yLong = 32; xInt = yLong;  The value of the yLong variable cannot be assigned to the xInt because xInt is  smaller than  yLong. Because this assignment may result in a loss of data, Java  doesn’t allow it.  If you need to assign a long to an int variable, you must use  explicit casting, as described in the “Type casting” section, later in this chapter.   A  feature  that  was  new  in  Java  7  allows  you  to  include  underscores  to  make   longer numbers easier to read. Thus, the following statements both assign the  same value to the variables xLong1 and xLong2:  long xLong1 = 58473882; long xLong2 = 58_473_882;  Floating-point types  Floating-point numbers are numbers that have fractional parts  usually expressed  with a decimal point . You should use a floating-point type whenever you need a  number with a decimal, such as 19.95 or 3.1415.  Java  has  two  primitive  types  for  floating-point  numbers:  float,  which  uses  4 bytes, and double, which uses 8 bytes. In almost all cases, you should use the  double type whenever you need numbers with fractional values.  The precision of a floating-point value indicates how many significant digits the  value can have following its decimal point. The precision of a float type is only  about six or seven decimal digits, which isn’t sufficient for most types of calcula- tions. If you use Java to write a payroll system, for example, you might get away  with  using  float  variables  to  store  salaries  for  employees  such  as  teachers  or  firefighters, but not for professional baseball players or corporate executives.  By contrast, double variables have a precision of about 15 digits, which is enough  for most purposes.  Floating-point  numbers  actually  use  exponential  notation   also  called  scientific  notation  to store their values. That means that a floating-point number actually  records  two  numbers:  a  base  value   also  called  the  mantissa   and  an  exponent.  The  actual  value  of  the  floating-point  number  is  calculated  by  multiplying  the  mantissa  by  2  raised  to  the  power  indicated  by  the  exponent.  For  float  types,  the exponent can range from –127 to +128. For double types, the exponent can  range from –1,023 to +1,024. Thus both float and double variables are capable of   representing very large and very small numbers.  76      BOOK 2  Programming Basics   You  can  find  more  information  about  some  of  the  nuances  of  working  with   floating-point values in Book 2, Chapter 3.  When you use a floating-point literal, you should always include a decimal point,  like this:  double period = 99.0;  If you omit the decimal point, the Java compiler treats the literal as an integer.  Then, when it sees that you’re trying to assign the integer literal to a double vari- able, the compiler converts the integer to a double value. This avoidable conver- sion step uses some precious processing time.  To save that time, you can add an F or D suffix to a floating-point literal to indicate  whether the literal itself is of type float or double. For example:  float value1 = 199.33F; double value2 = 200495.995D;  GETTING SCIENTIFIC WITH  FLOATS AND DOUBLES  If you have a scientific mind, you may want to use scientific notation when you write  floating-point literals. The equation  double e = 5.10e+6;  is equivalent to  double e = 5100000D;  double e = 5.10e6;  double impulse = 23e-7;  is equivalent to  double impulse = 0.0000023;  The sign is optional if the exponent is positive, so you can also write  Note that the exponent can be negative to indicate values smaller than 1. The equation  CHAPTER 2  Working with Variables and Data Types      77   If you omit the suffix, D is assumed. As a result, you can usually omit the D suffix  for double literals.  Interestingly, floating-point numbers have two distinct zero values: a negative  zero and a positive zero. You don’t have to worry about these much, because Java  treats them as equal. Still, they would make for a good question on Jeopardy!  “I’ll  take Weird Numbers for $200, Alex.”   The char type  The char type represents a single character from the Unicode character set. It’s  important to keep in mind that a character is not the same as a string; you find  out about strings later in this chapter, in the section “Working with Strings.” For  now, just realize that a char variable can store just one character, not a sequence  of characters, as a string can.  To assign a value to a char variable, you use a character literal, which is always  enclosed in apostrophes rather than quotes. Here’s an example:  char code = 'X';  Here the character X is assigned to the variable named code.  The following statement won’t compile:  char code = "X";      error -- should use apostrophes, not quotes  That’s because quotation marks are used to mark strings, not character constants.  Unicode is a 2-byte character code that can represent the characters used in most  languages  throughout  the  world.  Currently,  about  35,000  codes  in  the  Unicode  character  set  are  defined,  which  leaves another  29,000  codes  unused.  The  first  256 characters in the Unicode character set are the same as the characters of the  ASCII character set, which is the most commonly used character set for computers  with Western languages.  For  more  information  about  the  Unicode  character  set,  see  the  official  Unicode  website at www.unicode.org.  Character literals can also use special escape sequences to represent special char- acters. Table 2-2 lists the allowable escape sequences. These escape sequences let  you create literals for characters that can’t otherwise be typed within a character  constant.  78      BOOK 2  Programming Basics   TABLE 2-2	  Escape Sequences for Character Constants Escape Sequence  Explanation  \b  \t  \n  \f  \r  \"  \'  \\  Backspace  Horizontal tab  Line feed  Form feed  Carriage return  Double quote  Single quote  Backslash  The Boolean type  A Boolean type can have one of two values: true or false. Booleans are used to  perform logical operations, most commonly to determine whether some condition  is true. For example:  boolean enrolled = true; boolean credited = false;  Here a variable named enrolled of type boolean is declared and initialized to a  value of true, and another boolean named credited is declared and initialized  to false.  In some languages, such as C or C++, integer values can be treated as Booleans,  with 0 equal to false and any other value equal to true. Not so in Java. In Java,  you can’t convert between an integer type and a boolean type.  Wrapper classes  Every  primitive  type  has  a  corresponding  class  defined  in  the  Java  API  class  library. This class is sometimes called a wrapper class because it wraps a primitive  value with the object-oriented equivalent of pretty wrapping paper and a bow to  make the primitive type look and behave like an object. Table 2-3 lists the wrapper  classes for each of the eight primitive types.  As you find out later in this chapter, you can use these wrapper classes to convert  primitive values to strings, and vice versa.  CHAPTER 2  Working with Variables and Data Types      79   TABLE 2-3	  Wrapper Classes for the Primitive Types Primitive Type  Wrapper Class  int  short  long  byte  float  double  char  boolean  Integer  Short  Long  Byte  Float  Double  Character  Boolean  Using Reference Types  In Book 3, Chapter 1, you’re introduced to some of the basic concepts of object- oriented programming. In particular, you see how all Java programs are made up  of one or more classes, and how to use classes to create objects. In this section,  I show how you can create variables that work with objects created from classes.  To start, a reference type is a type that’s based on a class rather than on one of the  primitive types that are built into the Java language. A reference type can be based  on a class that’s provided as part of the Java API class library or on a class that you  write yourself. Either way, when you create an object from a class, Java allocates  however much memory the object requires to store the object. Then, if you assign  the object to a variable, the variable is actually assigned a reference to the object,  not the object itself. This reference is the address of the memory location where  the object is stored.  Suppose that you’re writing a game program that involves balls, and you create a  class named Ball that defines the behavior of a ball. To declare a variable that can  refer to a Ball object, you use a statement like this:  Ball b;  Here, the variable b is a variable of type Ball.  80      BOOK 2  Programming Basics   To create a new instance of an object from a class, you use the new keyword along  with the class name. This second reference to the class name is actually a call to  a special routine of the class called a constructor. The constructor is responsible  for initializing the new object. Here’s a statement that declares a variable of type  Ball, calls the Ball class constructor to create a new Ball object, and assigns a  reference to the Ball object to the variable:  Ball b = new Ball  ;  One of the key concepts in working with reference types is the fact that a variable  of a particular type doesn’t actually contain an object of that type. Instead, it con- tains a reference to an object of the correct type. An important side effect is that  two variables can refer to the same object.  Consider these statements:  Ball b1 = new Ball  ; Ball b2 = b1;  Here I’ve declared two Ball variables, named b1 and b2, but I’ve created only one  Ball object. In the first statement, the Ball object is created, and b1 is assigned a  reference to it. Then, in the second statement, the variable b2 is assigned a refer- ence to the same object that’s referenced by b1. As a result, both b1 and b2 refer  to the same Ball object.  If you use one of these variables to change some aspect of the ball, the change is  visible to the ball no matter which variable you use. Suppose that the Ball class  has a method called setSpeed that lets you set the speed of the ball to any int  value and a getSpeed method that returns an integer value that reflects the ball’s  current speed. Now consider these statements:  b1.setSpeed 50 ; b2.setSpeed 100 ; int speed = b1.getSpeed  ;  When these statements complete, is the value of the speed variable 50 or 100? The  correct answer is 100. Because b1 and b2 refer to the same Ball object, changing  the speed by using b2 affects b1 as well.  This is one of the most confusing aspects of programming with an object-oriented  language such as Java, so don’t feel bad if you get tripped up from time to time.  CHAPTER 2  Working with Variables and Data Types      81   Working with Strings  A string is a sequence of text characters, such as the message "Hello,  World!"  displayed  by  the  HelloApp  program  illustrated  in  this  chapter  and  the  preced- ing chapter. In Java, strings are an interesting breed. Java doesn’t define strings  as a primitive type. Instead, strings are a reference type defined by the Java API  String  class.  The  Java  language  does  have  some  built-in  features  for  working  with strings. In some cases, these features make strings appear to be primitive  types rather than reference types.  Java’s string-handling features are advanced enough to merit an entire chapter,  so for the full scoop on strings, I refer you to Book 4, Chapter 1. The following  sections present just the bare essentials of working with strings so that you can  incorporate simple strings into your programs.  Declaring and initializing strings  Strings  are  declared  and  initialized  much  like  primitive  types.  In  fact,  the  only  difference you may notice at first is that the word String is capitalized, unlike the  keywords for the primitive types, such as int and double. That’s because String  isn’t a keyword. Instead, it’s the name of the Java API class that provides for string  objects.  The following statements define and initialize a string variable:  String s; s = "Hello, World!";  Here a variable named s of type String is declared and initialized with the string  literal  "Hello,  World!".  Notice  that  string  literals  are  enclosed  in  quotation  marks,  not  apostrophes.  Apostrophes  are  used  for  character  literals,  which  are  different from string literals.  Like any variable declaration, a string declaration can include an initializer. Thus  you can declare and initialize a string variable in one statement, like this:  String s = "Hello, World!";  Class  variables  and  instance  variables  are  automatically  initialized  to  empty  strings, but local variables aren’t. To initialize a local string variable to an empty  string, use a statement like this:  String s = "";  82      BOOK 2  Programming Basics   Combining strings Combine  two  strings  by  using  the  plus  sign   +   as  a  concatenation operator.   In  Java-speak, combining strings is called concatenation.  The following statement  combines the value of two string variables to create a third string:  String hello = "Hello, "; String world = "World!"; String greeting = hello + world;  The final value of the greeting variable is "Hello, World!"  When Java concatenates strings, it doesn’t insert any blank spaces between the  strings. Thus, if you want to combine two strings and have a space appear between  them, make sure that the first string ends with a space or the second string begins  with a space.  In the preceding example, the first string ends with a space.   Alternatively, you can concatenate a string literal along with the string variables.  For example:  String hello = "Hello"; String world = "World!"; String greeting = hello + ", " + world;  Here the comma and the space that appear between the words Hello and World  are inserted as a string literal.  Concatenation is one of the most commonly used string-handling techniques, so  you see plenty of examples in this book. In fact, I’ve already used concatenation once  in this chapter. Earlier, I showed you a program that included the following line:  System.out.println "The value of i is " + i ;  Here the println method of the System.out object prints the string that’s created  when the literal "The value of i is " is concatenated with the value of the i  variable.  Converting primitives to strings  Because  string  concatenation  lets  you  combine  two  or  more  string  values,  and  because primitive types such as int and double are not string types, you may be  wondering  how  the  last  example  in  the  preceding  section  can  work.  In  other   CHAPTER 2  Working with Variables and Data Types      83   words, how can Java concatenate the string literal "The value of i is " with  the integer value of i in this statement?:  System.out.println "The value of i is " + i ;  The answer is that Java automatically converts primitive values to string values  whenever you use a primitive value in a concatenation.  You  can  explicitly  convert  a  primitive  value  to  a  string  by  using  the  toString  method of the primitive type’s wrapper class. To convert the int variable x to a  string, for example, you use this statement:  String s = Integer.toString x ;  In  the  next  chapter,  you  discover  how  to  use  a  special  class  called  the  Number  Format class to convert primitive types to strings while applying various types of  formatting to the value, such as adding commas, dollar signs, or percentage marks.  Converting strings to primitives  Converting  a  primitive  value  to  a  string  value  is  pretty  easy.  Going  the  other  way — converting a string value to a primitive — is a little more complex, because  it doesn’t always work. If a string contains the value 10, for example, you can eas- ily convert it to an integer. But if the string contains thirty-two, you can’t.  To convert a string to a primitive type, you use a parse method of the appropriate  wrapper class, as listed in Table 2-4. To convert a string value to an integer, you  use statements like this:  String s = "10"; int x = Integer.parseInt s ;  TABLE 2-4	  Wrapper  Integer  Short  Long  Byte  Float  Methods That Convert Strings to Numeric Primitive Types parse Method  Example  parseInt String   int x = Integer.parseInt "100" ;  parseShort String   short x = Short.parseShort "100" ;  parseLong String   long x = Long.parseLong "100" ;  parseByte String   byte x = Byte.parseByte "100" ;  parseByte String   float x = Float.parseFloat "19.95" ;  84      BOOK 2  Programming Basics   parse Method  Example  parseByte String   double x = Double.parseDouble "19.95" ;  Boolean  parseBoolean  boolean x = Boolean.parseBoolean  Wrapper  Double  Character   none    String    "true" ;  You have no real reason to do this, of course, but as you see later in this chapter,  you can use the  parse methods to convert string values entered by the user to  primitive types. That way, you can write programs that let the user enter numeric  data via the console window.  Note that you don’t need a parse method to convert a String to a Character. If  you need to do that, you can find out how in Book 4, Chapter 1.  Converting and Casting Numeric Data  From time to time, you need to convert numeric data of one type to another. You  may  need  to  convert  a  double  value  to  an  integer,  or  vice  versa.  Some  conver- sions can be done automatically; others are done using a technique called casting.  I describe automatic type conversions and casting in the following sections.  Automatic conversions  Java can automatically convert some primitive types to others and do so whenever  necessary. Figure 2-1 shows which conversions Java allows. Note that the con- versions shown with dotted arrows in the figure may cause some of the value’s  precision to be lost. An int can be converted to a float, for example, but large int  values won’t be converted exactly because int values can have more digits than  can be represented by the float type.  Whenever you perform a mathematical operation on two values that aren’t of the  same type, Java automatically converts one of them to the type of the other. Here  are the rules Java follows when doing this conversion:   » If one of the values is a double, the other value is converted to a double.  » If neither is a double but one is a float, the other is converted to a float.  CHAPTER 2  Working with Variables and Data Types      85    » If neither is a double nor a float but one is a long, the other is converted to   a long.   » If all else fails, both values are converted to int.  FIGURE 2-1:   Numeric type  conversions  that are done   automatically.  Type casting  Casting is similar to conversion but isn’t done automatically. You use casting to  perform a conversion that is not shown in Figure 2-1. If you want to convert a  double to an int, for example, you must use casting.  When you use casting, you run the risk of losing information. A double can hold  larger numbers than an int, for example. In addition, an int can’t hold the frac- tional part of a double. As a result, if you cast a double to an int, you run the risk  of losing data or accuracy, so 3.1415 becomes 3, for example.  To cast a primitive value from one type to another, you use a cast operator, which  is simply the name of a primitive type in parentheses placed before the value you  want to cast. For example:  Note that the fractional part of a double is simply discarded when cast to an inte- ger; it isn’t rounded. For example:  double pi = 3.1314; int iPi; iPi =  int  pi;  double price = 9.99; int iPrice =  int  price;  86      BOOK 2  Programming Basics   Here iPrice is assigned the value 9. If you want to round the double value when  you convert it, use the round method of the Math class, as I show you in the next  chapter.  Thinking Inside the Box  Beginning  with  version  1.5,  the  Java  language  supports  boxing  and  unboxing.  Boxing occurs when Java converts a primitive value to its corresponding wrapped  object,  and  unboxing  occurs  when  Java  goes  the  other  way   converts  from  a  wrapped object to the corresponding primitive value . Here’s an example:  Integer wrap = 10; System.out.println wrap ; int prim = wrap; System.out.println prim ;  The output of this code is 10 followed by another 10. In the first line, you assign a  primitive value 10 to the wrapper object named wrap. Believe it or not, Java does  a lot of work to put the little number 10 into a handsome Integer wrapper. In the  third line of code, Java turns the big wrapped wrap object back into a primitive 10   because the variable prim is of type int . Again, Java does some work behind the  scenes.  Think of boxing and unboxing as nicknames for wrapping and unwrapping. The bot- tom line is, Java can wrap and unwrap values automatically. That’s very handy.  The scope of a variable refers to which parts of a class the variable exists in. In the  simplest terms, every variable exists only within the block in which the variable  is declared, as well as any blocks that are contained within that block. That’s why  class and instance variables, which are declared in the class body, can be accessed  by any methods defined by the class, but local variables defined within a method  can be accessed only by the method in which they are defined.  In Java, a block is marked by a matching pair of braces. Java has many kinds of  blocks, including class bodies, method bodies, and block statements that belong  to statements such as if or for statements. But in each case, a block marks the  scope boundaries for the variables declared within it.  The program in Listing 2-1 can help clarify the scope of class and local variables.  CHAPTER 2  Working with Variables and Data Types      87  Understanding Scope   LISTING	2-1:	 A Program That Demonstrates Scope for Class and Local Variables  public class ScopeApp {        static int x;     public static void main String[] args      {         x = 5;         System.out.println "main: x = " + x ;         myMethod  ;     }     public static void myMethod       {         int y;         y = 10;          if  y == x + 5           {             int z;             z = 15;              System.out.println "myMethod: z = " + z ;         }          System.out.println "myMethod: x = " + x ;         System.out.println "myMethod: y = " + y ;     }  }   →2  →16 →17  →20  →22  →25 →27  The following paragraphs explain the scope of each of the variables used in this  class: →2        The variable x is a class variable. Its scope begins in line 2 and ends in  line 27. As a result, both the main method and the myMethod method can  access it.  →16      The variable y is a local variable that’s initialized in line 16. As a result, its  scope begins in line 16 and ends in line 25, which marks the end of the  body of the myMethod method.  →17      The variable z is a local variable that’s declared and initialized in the   statement block that belongs to the if statement in line 17.  →22      The scope of variable z begins when the variable is initialized in line 20 and   ends when the statement block ends in line 22.  When you run this program, you’ll get the following output:  main: x = 5 myMethod: z = 15  88      BOOK 2  Programming Basics   myMethod: x = 5 myMethod: y = 10  Strictly speaking, the scope of a local variable begins when the variable is initial- ized  and  ends  when  the  block  that  contains  the  variable’s  declaration  ends.  By  contrast,  the  scope  for  a  class  or  instance  variable  is  the  entire  class  in  which  the variable is declared. That means you can use a class or instance variable in a  method that physically appears before the variable is declared, but you can’t use a  local variable before it’s declared.  Shadowing Variables  A shadowed variable is a variable that would otherwise be accessible but is tempo- rarily made unavailable because a variable with the same name has been declared  in a more immediate scope. That’s a mouthful, but the example in Listing 2-2  makes the concept clear. Here a class variable named x is declared. Then, in the  main method, a local variable with the same name is declared.  LISTING	2-2:	 A Class That Demonstrates Shadowing  public class ShadowApp {        static int x;      public static void main String[] args      {         x = 5;          System.out.println "x = " + x ;          int x;          x = 10;          System.out.println "x = " + x ;          System.out.println "ShadowApp.x = " +             ShadowApp.x ;      }  }     →2 →4  →8 →9 →10 →11 →12  →14 →15 →17  The following paragraphs explain the scoping issues in this program: →2–4      The class variable x is declared in line 4. Its scope is the entire class   body, from line 2 to line 17.  →8–9      The class variable x is assigned a value of 5 in line 8. Then this value is   printed to the console in line 9.  CHAPTER 2  Working with Variables and Data Types      89   →10       In line 10, a local variable named x is declared. The local variable shadows  the class variable x, so any reference to x through the end of this method  in line 15 refers to the local variable rather than the class variable.  →11       The local variable x is initialized in line 11. At that point, the local variable x   comes into scope and remains in scope until the end of the method in line 15.  →12       The System.out.println statement in line 12 prints the value of the  local variable x. Note that this statement is identical to the statement in  line 9, which printed the class variable x because the class variable had  not yet been shadowed.  →14       While a class variable is shadowed, you can access it by specifying the class   name as shown in line 14. Here ShadowApp.x refers to the class variable. →15       When the main method ends in line 15, the class variable x is no longer   shadowed.  Here is the output you will get from this program:  x = 5 x = 10 ShadowApp.x = 5  The scope of a local variable that shadows a class variable doesn’t necessarily begin  at the same point that the local variable’s scope begins. The shadowing begins  when the local variable is declared, but the local variable’s scope doesn’t begin until   the variable is initialized. If you attempt to access the variable between the decla- ration and the initialization, the Java compiler displays an error message.  Because shadowing is a common source of errors, I suggest that you avoid it as  much as possible.  Printing Data with System.out  You’ve  already  seen  several  programs  that  use  System.out.println  to  display  output on the console. In the following sections, I officially show you how this  method works, along with a related method called just print.  Using standard input and output streams  Java applications are designed to work in a terminal input output  I O  environ- ment. Every Java application has at its disposal three I O streams that are designed  for  terminal-based  input  and  output,  which  simply  sends  or  receives  data  one  character at a time. The three streams are  90      BOOK 2  Programming Basics    » Standard input: A stream designed to receive input data. This stream is   usually connected to the keyboard at the computer where the program is run.  That way, the user can type characters directly into the standard input stream.  In the section “Getting Input with the Scanner Class,” later in this chapter, you  connect this input stream to a class called Scanner, which makes it easy to  read primitive data types from the standard input stream.   » Standard output: A stream designed to display text output onscreen. When  you run a Java program under Windows, a special console window opens, and  the standard output stream is connected to it. Then any text you send to  standard output is displayed in that window.   » Standard error: Another stream designed for output. This stream is also  connected to the console window. As a result, text written to the standard  output stream is often intermixed with text written to the error stream.  Windows  and  other  operating  systems  allow  you  to  redirect  standard  output  to  some other destination — typically a file. When you do that, only the standard  output data is redirected. Text written to standard error is still displayed in the  console window.  To redirect standard output, you use a greater-than  >  sign on the command that  runs the Java class, followed by the name of the file you want to save the standard  output text to. Here’s an example:  C:\Java>java TestApp >output.txt  Here the standard output created by the class TestApp is saved in a file named  output.txt. Any text sent to the standard error stream still appears in the console  window, however. As a result, the standard error stream is useful for programs  that use output redirection to display status messages, error messages, or other  information.  When you use a single > sign for redirection, Windows overwrites the redirected  file if it already exists. If you prefer to add to the end of an existing file, use two  greater-than signs, like this:  C:\Java>java TestApp >>output.txt  Then, if the output.txt file already exists, anything written to standard output by  the TestApp class will be added to the end of the existing output.txt file.  All three standard streams are available to every Java program via the fields of the  System class, described in Table 2-5.  CHAPTER 2  Working with Variables and Data Types      91   TABLE 2-5	  Static Fields of the System Object Field  Description  System.in  System.out  System.err  Standard input  Standard output  Standard error  Using System.out and System.err  Both  System.out  and  System.err  represent  instances  of  a  class  called  Print  Writer, which defines the print and println methods used to write data to the  console. You can use both methods with either a String argument or an argument  of any primitive data type.  The  only  difference  between  the  print  and  the  println  methods  is  that  the  println method adds a line-feed character to the end of the output, so the output  from the next call to print or println begins on a new line.  Because it doesn’t start a new line, the print method is useful when you want to  print two or more items on the same line. Here’s an example:  int i = 64; int j = 23; System.out.print i ; System.out.print " and " ; System.out.println j ;  The console output produced by these lines is  64 and 23  Note that you could do the same thing with a single call to println by using string  concatenation, like this:  int i = 64; int j = 23; System.out.println i + " and " + j ;  Getting Input with the Scanner Class  Until Java 1.5, getting text input from the user in a console-based Java program  wasn’t easy. But with Java 1.5, a new class — called Scanner — was introduced to   92      BOOK 2  Programming Basics   simplify the task of getting input from the user. In the following sections, you use  the Scanner class to get simple input values from the user. The techniques that  I present here are used in many of the programs shown in the rest of this book.  If you’re using an older version of Java, you should still read this section, because  many of the programs in this book use the Scanner class. However, you should also  read the next section, “Getting Input with the JOptionPane Class,” because that sec- tion describes a way of getting user input that works with earlier versions of Java.  Throughout the following sections, I refer to the program shown in Listing 2-3. This  simple program uses the Scanner class to read an integer value from the user and  then displays the value back to the console to verify that the program received the  value entered by the user. Here’s a sample of the console window for this program:  Enter an integer: 5 You entered 5.  The program begins by displaying the message Enter  an  integer: on the first  line. Then it waits for you to enter a number. When you type a number  such as 5   and press the Enter key, it displays the confirmation message  You entered 5.   on the second line.  LISTING	2-3:	 A Program That Uses the Scanner Class  import java.util.Scanner;  public class ScannerApp {     static Scanner sc = new Scanner System.in ;      public static void main String[] args      {         System.out.print "Enter an integer: " ;          int x = sc.nextInt  ;          System.out.println "You entered " + x + "." ;      } }  →1  →6  →10 →11 →12  Importing the Scanner class  Before you can use the Scanner class in a program, you must import it. To do that,  you code an import statement at the beginning of the program, before the class  declaration, as shown in line 1 of Listing 2-3:  import java.util.Scanner;  Note that java and util aren’t capitalized, but Scanner is.  CHAPTER 2  Working with Variables and Data Types      93   If you’re using other classes in the java.util package, you can import the entire  package by coding the import statement like this:  import java.util.*;  Declaring and creating a Scanner object  Before you can use the Scanner class to read input from the console, you must  declare  a  Scanner  variable  and  create  an  instance  of  the  Scanner  class.  I  rec- ommend that you create the Scanner variable as a class variable and create the   Scanner object in the class variable initializer, as shown in line 6 of Listing 2-3:  static Scanner sc = new Scanner System.in ;  That way, you can use the sc variable in any method in the class.  To  create  a  Scanner  object,  you  use  the  new  keyword  followed  by  a  call  to  the  Scanner class constructor. Note that the Scanner class requires a parameter that  indicates the input stream that the input comes from. You can use System.in here  to specify standard keyboard console input.  Getting input  To  read  an  input  value  from  the  user,  you  can  use  one  of  the  methods  of  the   Scanner class that are listed in Table 2-6. As you can see, the primitive data type  has a separate method.  TABLE 2-6	  Scanner Class Methods That Get Input Values Method  Explanation  boolean nextBoolean    Reads a boolean value from the user.  byte nextByte    Reads a byte value from the user.  double nextDouble    Reads a double value from the user.  float nextFloat    Reads a float value from the user.  int nextInt    Reads an int value from the user.  String nextLine    Reads a String value from the user.  long nextLong    Reads a long value from the user.  short nextShort    Reads a short value from the user.  94      BOOK 2  Programming Basics   Notice in the first column of the table that each method listing begins with the  type of the value that’s returned by the method. The nextInt method, for exam- ple,  returns  an  int  value.  Also,  notice  that  each  of  the  methods  ends  with  an  empty set of parentheses. That means that these methods don’t require param- eters. If a method does require parameters, the parameters are listed within these  parentheses.  Because  these  methods  read  a  value  from  the  user  and  return  the  value,  you  most often use them in statements that assign the value to a variable. Line 11 in   Listing 2-3, for example, reads an int and assigns it to a variable named x.  When the nextInt method is executed, the program waits for the user to enter a  value in the console window. To let the user know what kind of input the program  expects, usually you should call the System.out.print method before you call a  Scanner method to get input. Line 10 in Listing 2-3 calls System.out.print to  display the message Enter an integer: on the console. That way, the user knows  that the program is waiting for input.  If  the  user  enters  a  value  that  can’t  be  converted  to  the  correct  type,  the  pro- gram crashes, which means that it terminates abruptly. As the program crashes,  it displays a cryptic error message that indicates what caused the failure. If you  enter three instead of an actual number, for example, the console window looks  something like this:  Ente r an integer: three Exception in thread "main" java.util.  InputMismatchException          at java.util.Scanner.throwFor Scanner.java:819          at java.util.Scanner.next Scanner.java:1431          at java.util.Scanner.nextInt Scanner.java:2040          at java.util.Scanner.nextInt Scanner.java:2000   at ScannerApp.main ScannerApp.java:11   This  message  indicates  that  an  exception  called  InputMismatchException  has  occurred, which means that the program was expecting to see an integer but got  something  else  instead.  In  Book  2,  Chapter  8,  you  find  out  how  to  provide  for  exceptions like these so that the program can display a friendlier message and  give  the  user  another  shot  at  entering  a  correct  value.  Until  then,  you  have  to  put up with the fact that if the user enters incorrect data, your program crashes  ungracefully.  You can prevent the nextInt and similar methods from crashing with incorrect  input data by first using one of the methods listed in Table 2-7 to test the next  input to make sure it’s valid. I haven’t yet covered the Java statements you need to  perform this test, but don’t worry; in Book 2, Chapter 8, I show you the solution.  CHAPTER 2  Working with Variables and Data Types      95   TABLE 2-7	  Method  Explanation  Scanner Class Methods That Check for Valid Input Values  boolean hasNextBoolean    Returns true if the next value entered by the user is a valid boolean   value.  boolean hasNextByte    Returns true if the next value entered by the user is a valid byte value.  boolean hasNextDouble    Returns true if the next value entered by the user is a valid double value.  boolean hasNextFloat    Returns true if the next value entered by the user is a valid float value.  boolean hasNextInt    Returns true if the next value entered by the user is a valid int value.  boolean hasNextLong    Returns true if the next value entered by the user is a valid long value.  boolean hasNextShort    Returns true if the next value entered by the user is a valid short value.  Getting Input with the JOptionPane Class  If you’re using a version of Java before Java 1.5, you don’t have the luxury of using  the Scanner class to read input directly from the user via a console window. You  can use the JOptionPane class, however, to display simple dialog boxes such as  the one shown in Figure 2-2 to get text input from the user. Then you can use the  parse methods of the primitive-type wrapper classes to convert the text entered  by the user to the appropriate primitive type.  FIGURE 2-2:   A dialog box  displayed by the  JOptionPane  class.  Although  the  JOptionPane  class  has  many  methods,  the  only  one  you  need  to  use to get simple text input is the showInputDialog method. This method uses  a single parameter that specifies the prompting message that’s displayed in the  dialog box. It returns a string value that you can then parse to the proper type.  The JOptionPane class is a part of the javax.swing package, so you need to add  an  import  javax.swing.JOptionPane  statement  to  the  beginning  of  any  pro- gram that uses this class.  Listing 2-4 shows a simple program that uses the JOPtionPane class to get an  integer value and display it on the console.  96      BOOK 2  Programming Basics   LISTING	2-4:	 A Program That Uses the JOptionPane Class to Get User Input  import javax.swing.JOptionPane;  public class DialogApp {     public static void main String[] args      {         String s;         s = JOptionPane.showInputDialog                   "Enter an integer:" ;          int x = Integer.parseInt s ;          System.out.println "You entered " + x + "." ;      } }  →1  →7 →8 →9 →10  The following paragraphs describe the important lines in this program: →1         This line imports the JOptionPane class. →7–8      This statement displays an input dialog box with the prompt Enter an   integer: and assigns the string entered by the user to the variable named s.  →9         This statement uses the parseInt method of the Integer class to   convert the string entered by the user to an integer.  →10        This statement displays the integer value to confirm that the data   entered by the user was converted properly to an integer.  This program terminates abruptly if the user enters anything other than an inte- ger in the input dialog box. If the user enters ten, for example, the program ter- minates,  and  a  cryptic  message  indicating  that  a  NumberFormatException  has  occurred  is  displayed.  In  Book  2,  Chapter  8,  you  learn  how  to  provide  a  more  understandable message in this situation. Until then, just be careful to enter cor- rect numbers when you use the JOptionPane class.  Using enum to Create Your   Own Data Types  You will often find yourself using a String or int variable that you want to con- strain to just a few different values. For example, suppose you’re writing a pro- gram that plays a card game and you want a way to represent the suite of each  card.  You  could  do  that  with  a  String  variable  whose  value  should  be  Hearts,  Spades,  Clubs,  or  Diamonds.  Or  you  might  use  an  int  and  use  the  value  1  to   CHAPTER 2  Working with Variables and Data Types      97   represent Hearts, 2 for Spades, 3 for Clubs, or 4 for Diamonds. But such a scheme  is error prone. What if you assign a value of 5 to the int variable?  A better way is to create an enum, which is basically a custom variable type which  has a limited set of possible values. To define an enum, you use the enum key- word  usually modified by public  followed by a list of possible values enclosed  in brackets:  public enum CardSuit {HEARTS, SPADES, CLUBS, DIAMONDS}  You can declare variables using the enum’s name as the data type:  Then, you can assign a value by using the enum name followed by a period and  any of the enum values, as in this example:  CardSuit suit;  suit = CardSuit.HEARTS;  Here’s a complete program that defines an enum, creates a variable of the enum’s  type, assigns a value, and prints the result:  public class EnumTest {     public enum CardSuit {HEARTS, SPADES, CLUBS, DIAMONDS}      public static void main String[] args      {         CardSuit suit;         suit = CardSuit.HEARTS;         System.out.println "The suit is " + suit ;     } }  This program displays the following line on the console:  The suit is HEARTS  98      BOOK 2  Programming Basics   IN THIS CHAPTER  » Dealing with operators, such as +, –,   *, and     » Creating finely crafted expressions   » Incrementing and decrementing   » Accepting an assignment   » Using the Math class   » Formatting your numbers   » Seeing strange things that can   happen with numbers  Chapter 3 Working with Numbers  and Expressions  In Book 2, Chapter 2, you discover the various primitive numeric types that are   supported by Java. In this chapter, you build on that knowledge by doing basic  operations with numbers. Much of this chapter focuses on the complex topic of  expressions, which combine numbers with operators to perform calculations. This  chapter  also  covers  performing  advanced  calculations  using  the  Math  class  and  techniques for formatting numbers when you display them. In addition, you find  out why Java’s math operations sometimes produce results you may not expect.  Working with Arithmetic Operators  An operator is a special symbol or keyword that’s used to designate a mathematical  operation or some other type of operation that can be performed on one or more  values, called operands. In all, Java has about 40 operators. This chapter focuses  on the operators that do arithmetic. These arithmetic operators — seven of them   CHAPTER 3  Working with Numbers and Expressions      99   in all, summarized in Table 3-1 — perform basic arithmetic operations, such as  addition, subtraction, multiplication, and division.  TABLE 3-1	  Java’s Arithmetic Operators Operator  Description  +  -  *     %  ++  --  Addition  Subtraction  Multiplication  Division  Increment  Decrement  Remainder  Modulus   The following section of code can help clarify how these operators work for int  types:  int a = 32, b = 5; int c = a + b;        c is 37 int d = a - b;        d is 27 int e = a * b;        e is 160 int f = a   b;        f is 5  32   5 is 6 remainder 2  int g = a % b;        g is 2   32   5 is 6 remainder 2  a++;                  a is now 33 b--;                  b is now 4  Notice that for division, the result is truncated. Thus 32   5 returns 6, not 6.4.  For more information about integer division, see the section “Dividing Integers,”  later in this chapter.  Here’s how the operators work for double values:  double x = 5.5, y = 2.0; double m = x + y;           m is 7.5 double n = x - y;           n is 3.5 double o = x * y;           o is 11.0 double p = x   y;           p is 2.75 double q = x % y;           q is 1.5 x++;                        x is now 6.5 y--;                        y is now 1.0  100      BOOK 2  Programming Basics   CATEGORIZING OPERATORS BY THE  NUMBER OF OPERANDS  A common way to categorize Java’s operators is to use the number of operands the  operator works on. When the operators are categorized this way, you find three types:     Unary operators: Operators that work on just one operand. Examples of unary  operators are negation  -x, which returns the negative of x  and increment  x++,  which adds 1 to x .  A unary operator can be a prefix operator or a postfix operator. A prefix operator is  written before the operand, like this:  A postfix operator is written after the operand, like this:  operator operand  operand operator     Binary operators: Operators that work on two operands. Examples of binary oper- ators are addition  x + y , multiplication  invoiceTotal * taxRate , and com- parison operators  x < leftEdge . In Java, all binary operators are infix operators,  which means they appear between the operands, like this:  operand1 operator operand2     Ternary operators: Operators that work on three operands. Java has only one  ternary operator, called the conditional operator  ?: . The conditional operator is  also infix:  operand1 ? operand2 : operand3  When you divide two int values, the result is an integer value, even if you assign  it to a double variable. For example:  int a = 21, b = 6; double answer = a   b;      answer = 3.0  If that’s not what you want, you can cast one of the operands to a double before  performing the division.  Casting an operand means converting its value from one  data type to another.  Here’s how:  int a = 21, b = 6; double answer =  double a   b;      answer = 3.5  The moral of the story is that if you want to divide int values and get an accurate  double result, you must cast at least one of the int values to a double.  CHAPTER 3  Working with Numbers and Expressions      101   Here are a few additional things to think about tonight as you lie awake pondering  the wonder of Java’s arithmetic operators:   » In algebra, you can write a number right next to a variable to imply multiplica-  tion. In this case, 4x means “four times x.” Not so in Java. The following  statement doesn’t compile:  int x; y = 4x;       error, this line won't compile   » The remainder operator  %  is also called a modulus operator. It returns the  remainder when the first operand is divided by the second operand. The  remainder operator is often used to determine whether one number is evenly  divisible by another, in which case the result is zero. For more information,  see the next section, “Dividing Integers.”   » All operators, including the arithmetic variety, are treated as separators in   Java. As a result, any use of white space in an expression is optional. Thus the  following two statements are equivalent:  a =    x + 4  * 7      y * x ; a=  x+4 *7   y*x ;  Just remember that a little bit of white space never hurt anyone, and some- times it helps make Java a little more readable.  When you divide one integer into another, the result is always another integer.  Any remainder is simply discarded, and the answer is not rounded up. 5   4 gives  the result 1, for example, and 3   4 gives the result 0. If you want to know that   5     4 is actually 1.25 or that 3     4 is actually 0.75, you need to use floats or  doubles instead of integers.  If  you  need  to  know  what  the  remainder  is  when  you  divide  two  integers,  use  the remainder operator  % . Suppose that you have a certain number of marbles  to give away and a certain number of children to give them to. The program in   Listing  3-1  lets  you  enter  the  number  of  marbles  and  the  number  of  children.  Then it calculates the number of marbles to give to each child and the number of  marbles you have left over.  The remainder operator is also called the modulus operator.  Dividing Integers  102      BOOK 2  Programming Basics   Here’s  a  sample  of  the  console  output  for  this  program,  where  the  number  of  marbles entered is 93 and the number of children is 5:  Welcome to the marble divvy-upper. Number of marbles: 93 Number of children: 5 Give each child 18 marbles. You will have 3 marbles left over.  LISTING	3-1:	 A Program That Divvies Up Marbles  import java.util.Scanner;  public class MarblesApp {     static Scanner sc = new Scanner System.in ;      public static void main String[] args      {            declarations          int numberOfMarbles;         int numberOfChildren;         int marblesPerChild;         int marblesLeftOver;             get the input data          System.out.println "Welcome to the marble divvy-upper." ;         System.out.print "Number of marbles: " ;         numberOfMarbles = sc.nextInt  ;         System.out.print "Number of children: " ;         numberOfChildren = sc.nextInt  ;             calculate the results         marblesPerChild = numberOfMarbles   numberOfChildren;          marblesLeftOver = numberOfMarbles % numberOfChildren;              print the results          System.out.println "Give each child " +             marblesPerChild + " marbles." ;         System.out.println "You will have " +             marblesLeftOver + " marbles left over." ;     }  }  →1  →5  →9  →15  →23 →24  →26  CHAPTER 3  Working with Numbers and Expressions      103   The following paragraphs describe the key lines in this program: →1          Imports the java.util.Scanner class so that the program can use it   to get input from the user.  →5          Creates the Scanner object and assigns it to a class variable so that it   can be used in any method in the class.  →9–13       Declare the local variables used by the program. →15-20      Get the input from the user. →23         Calculates the number of marbles to give to each child by using   integer division, which discards the remainder.  →24        Calculates the number of marbles left over. →26–31      Print the results.  It’s probably obvious if you think about it, but you should realize that if you use  integer division to divide a by b, the result times b plus the remainder equals a.  In other words:  int a = 29;              any value will do int b = 3;               any value will do int c = a   b; int d = a % b; int e =  c * b  + d;     e will always equal a  Combining Operators  You can combine operators to form complicated expressions. When you do, the  order in which the operations are carried out is determined by the precedence of  each operator in the expression. The order of precedence for the arithmetic opera- tors is   » Increment  ++  and decrement  --  operators are evaluated first.  » Next, sign operators  + or -  are applied.  » Then multiplication  * , division    , and remainder  %  operators are   evaluated.   » Finally, addition  +  and subtraction  -  operators are applied.  104      BOOK 2  Programming Basics   In the expression a + b * c, for example, multiplication has a higher precedence  than addition. Thus b is multiplied by c first. Then the result of that multiplica- tion is added to a.  If an expression includes two or more operators at the same order of precedence,  the operators are evaluated left to right. Thus, in the expression a * b   c, a is  multiplied by b and then the result is divided by c.  If you want, you can use parentheses to change the order in which operations are  performed.  Operations  within  parentheses  are  always  performed  before  opera- tions that aren’t in parentheses. Thus, in the expression  a + b  * c, a is added  to b first. Then the result is multiplied by c.  If an expression has two or more sets of parentheses, the operations in the inner- most set are performed first. In the expression  a *  b + c     d, b is added to  c. Then the result is multiplied by a. Finally, that result is divided by d.  Apart from the increment and decrement operators, these precedence rules and  the use of parentheses are the same as they are for basic algebra. So if you were  paying attention in the eighth grade, precedence should make sense.  With double or float values, changing the left to right order for operators with  the same precedence doesn’t affect the result. With integer types, however, it can  make a huge difference if division is involved. Consider these statements:  int a = 5, b = 6, c = 7; int d1 = a * b   c;       d1 is 4 int d2 = a *  b   c ;     d2 is 0  This difference occurs because integer division always returns an integer result,  which  is  a  truncated  version  of  the  actual  result.  Thus,  in  the  first  expression,  a is first multiplied by b, giving a result of 30. Then this result is divided by c.  Truncating the answer gives a result of 4. But in the second expression, b is first  divided by c, which gives a truncated result of 0. Then this result is multiplied by  a, giving a final answer of 0.  Using the Unary Plus and Minus Operators  The unary plus and minus operators let you change the sign of an operand. Note  that the actual operator used for these operations is the same as the binary addi- tion and subtraction operators. The compiler figures out whether you mean to use  the binary or the unary version of these operators by examining the expression.  CHAPTER 3  Working with Numbers and Expressions      105   The unary minus operator doesn’t necessarily make an operand have a negative  value. Instead, it changes whatever sign the operand has to start with. Thus, if  the operand starts with a positive value, the unary minus operator changes it to  negative. But if the operand starts with a negative value, the unary minus operator  makes it positive. The following examples illustrate this point:  Interestingly enough, the unary plus operator doesn’t actually do anything. For  example:  int a = 5;        a is 5 int b = -a;       b is -5 int c = -b;       c is +5  int a = -5;       a is -5 int b = +a;       b is -5 a = 5;            a is now 5 int c = +a;       c is 5  Notice that if a starts out positive, +a is also positive. But if a starts out negative,  +a is still negative. Thus the unary plus operator has no effect. I guess Java pro- vides the unary plus operator out of a need for balance.  You can also use these operators with more complex expressions, like this:  int a = 3, b = 4, c = 5; int d = a * - b + c ;       d is -27  Here, b is added to c, giving a result of 9. Then the unary minus operator is applied,  giving a result of -9. Finally, -9 is multiplied by a, giving a result of -27.  Using Increment and Decrement  Operators  One of the most common operations in computer programming is adding or sub- tracting 1 from a variable. Adding 1 to a variable is called incrementing the variable.  Subtracting 1 is called decrementing. The traditional way to increment a variable  is this:  a = a + 1;  Here the expression a + 1 is calculated, and the result is assigned to the variable a.  106      BOOK 2  Programming Basics   Java provides an easier way to do this type of calculation: the increment  ++  and  decrement  --  operators. These unary operators apply to a single variable. Thus,  to increment the variable a, you can code just this:  a++;  Note that an expression that uses an increment or decrement operator is a state- ment by itself. That’s because the increment or decrement operator is also a type  of assignment operator, as it changes the value of the variable it applies to.  You can use the increment and decrement operators only on variables — not on  numeric  literals  or  other  expressions.  Java  doesn’t  allow  the  following  expres- sions, for example:  a = b * 5++;       can't increment the number 5 a =  b * 5 ++;     can't increment the expression  b * 5   Note  that  you  can  use  an  increment  or  decrement  operator  in  an  assignment  statement. Here’s an example:  int a = 5; int b = a--;       both a and b are set to 4  When the second statement is executed, the expression a-- is evaluated first, so a  is set to 4. Then the new value of a is assigned to b. Thus both a and b are set to 4.  The  increment  and  decrement  operators  are  unusual  because  they  are  unary   operators that can be placed either before  prefix  or after  postfix the variable they  apply  to.  Whether  you  place  the  operator  before  or  after  the  variable  can  have  a major effect on how an expression is evaluated. If you place an increment or   decrement operator before its variable, the operator is applied before the rest of  the expression is evaluated. As a result, the incremented value of the variable is  used in the expression. By contrast, if you place the operator after the variable, the  operator is applied after the expression is evaluated. Thus the original value of the  variable is used in the expression.  Confused yet? A simple example can clear things up. First, consider these state- ments with an expression that uses a postfix increment:  int a = 5; int b = 3; int c = a * b++;      c is set to 15  When the expression in the third statement is evaluated, the original value of b —   3 — is used in the multiplication. Thus c is set to 15. Then b is incremented to 4.  CHAPTER 3  Working with Numbers and Expressions      107   Now consider this version, with a prefix increment:  int a = 5; int b = 3; int c = a * ++b;      c is set to 20  This time, b is incremented before the multiplication is performed, so c is set to  20. Either way, b ends up set to 4.  Similarly, consider this example:  int a = 5; int b = --a;      b is set to 5, a is set to 4.  This example is similar to an earlier example, but this time the prefix increment  operator is used. When the second statement is executed, the value of a is assigned  to b. Then a is decremented. As a result, b is set to 5, and a is set to 4.  Because the increment and decrement operators can be confusing when used with  other operators in an expression, I suggest that you use them alone. Whenever  you’re tempted to incorporate an increment or decrement operator into a larger  expression, pull the increment or decrement out of the expression, and make it  a separate statement either before or after the expression. In other words, code  b++; c = a * b;  instead of  c = a * ++b;  In the first version, it’s crystal-clear that b is incremented before the multiplica- tion is done.  Using the Assignment Operator  The standard assignment operator  =  is used to assign the result of an expression  to a variable. In its simplest form, you code it like this:  variable = expression;  108      BOOK 2  Programming Basics   Here’s an example:  int a =  b * c    4;  int a; a + 3 =  b * c ;  You’ve already seen plenty of examples of assignment statements like this one,  so I won’t belabor this point any further. I do want to point out — just for the  record — that you cannot code an arithmetic expression on the left side of an equal  sign. Thus the following statement doesn’t compile:  In the rest of this section, I point out some unusual ways in which you can use  the assignment operator. I don’t recommend that you actually use any of these  techniques, as they’re rarely necessary and almost always confusing, but knowing  about them can shed light on how Java expressions work and sometimes can help  you find sneaky problems in your code.  The key to understanding the rest of this section is realizing that in Java, assign- ments are expressions, not statements. In other words, a  =  5 is an assignment  expression, not an assignment statement. It becomes an assignment statement  only when you add a semicolon to the end.  The result of an assignment expression is the value that’s assigned to the variable.  The result of the expression a = 5, for example, is 5. Likewise, the result of the  expression a =  b + c  * d is the result of the expression  b + c  * d.  The implication is that you can use assignment expressions in the middle of other  expressions. The following example is legal:  int a; int b; a =  b = 3  * 2;      a is 6, b is 3  As in any expression, the part of the expression inside the parentheses is evalu- ated first. Thus, b is assigned the value 3. Then the multiplication is performed,  and the result  6  is assigned to the variable a.  Now consider a more complicated case:  int a; int b = 2; a =  b = 3  * b;      a is 9, b is 3  What’s happening here is that the expression in the parentheses is evaluated first,  which means that b is set to 3 before the multiplication is performed.  CHAPTER 3  Working with Numbers and Expressions      109   The parentheses are important in the previous example because without paren- theses, the assignment operator is the last operator to be evaluated in Java’s order  of precedence. Consider one more example:  int a; int b = 2; a = b = 3 * b;      a is 6, b is 6  This time, the multiplication 3 * b is performed first, giving a result of 6. Then  this result is assigned to b. Finally, the result of that assignment expression  6   is assigned to a.  Incidentally, the following expression is also legal:  a = b = c = 3;  This expression assigns the value 3 to all three variables. Although this code seems  pretty harmless, you’re better off just writing three assignment statements.  You  might guess that clumping the assignments together is more efficient than writ- ing them on three lines, but you’d be wrong. These three assignments require the  same number of bytecode instructions either way.   Using Compound Assignment Operators  A compound assignment operator is an operator that performs a calculation and an  assignment at the same time. All of Java’s binary arithmetic operators  that is, the  ones that work on two operands  have equivalent compound assignment opera- tors, which Table 3-2 lists.  TABLE 3-2	  Compound Arithmetic Operators Operator  Description  +=  -=  *=   =  %=  Addition and assignment  Subtraction and assignment  Multiplication and assignment  Division and assignment  Remainder and assignment  110      BOOK 2  Programming Basics   The statement  a += 10;  is equivalent to  a = a + 10;  Also, the statement  z *=2;  is equivalent to  z = z * 2;  int a = 2; int b = 3; a *= b + 1;  Is a set to 7 or 8?  To prevent confusion, use compound assignment expressions by themselves, not  in combination with other expressions. Consider these statements:  In other words, is the third statement equivalent to  a = a * b + 1;        This would give 7 as the result  or  a = a *  b + 1 ;      This would give 8 as the result  At first glance, you might expect the answer to be 7, because multiplication has a  higher precedence than addition. But assignment has the lowest precedence of all,  and the multiplication here is performed as part of the assignment. As a result, the  addition is performed before the multiplication — and the answer is 8.  Gotcha!   Using the Math Class  Java’s built-in operators are useful, but they don’t come anywhere near provid- ing all the mathematical needs of most Java programmers. That’s where the Math   CHAPTER 3  Working with Numbers and Expressions      111   class comes in. It includes a bevy of built-in methods that perform a wide variety  of mathematical calculations, from basic functions such as calculating an absolute  value or a square root to trigonometry functions such as sin and cos  sine and  cosine , to practical functions such as rounding numbers or generating random  numbers.  I was going to make a joke here about how you’d have to take a math class to fully  appreciate the Math class; or how you’d better stay away from the Math class if you  didn’t do so well in math class; or how if you’re on the football team, maybe you  can get someone to do the Math class for you. But these jokes seemed too easy, so  I decided not to make them.  All the methods of the Math class are declared as static methods, which means you  can use them by specifying the class name Math followed by a period and a method  name. Here’s a statement that calculates the square root of a number stored in a  variable named y:  double x = Math.sqrt y ;  The  Math  class  is  contained  in  the  java.lang  package,  which  is  automatically  available to all Java programs. As a result, you don’t have to provide an import  statement to use the Math class.  The following sections describe the most useful methods of the Math class.  Using constants of the Math class  The Math class defines two constants that are useful for many mathematical cal- culations. Table 3-3 lists these constants.  TABLE 3-3	  Constant  Constants of the Math Class What It Is  Value  PI  E  The constant pi  π , the ratio of a circle’s radius and diameter  3.141592653589793  The base of natural logarithms  2.718281828459045  Note that these constants are only approximate values, because both π and e are  irrational numbers.  112      BOOK 2  Programming Basics   The  program  shown  in  Listing  3-2  illustrates  a  typical  use  of  the  constant  PI.  Here, the user is asked to enter the radius of a circle. Then the program calculates  the  area  of  the  circle  in  line  13.   The  parentheses  aren’t  really  required  in  the  expression in this statement, but they help clarify that the expression is the Java  equivalent to the formula for the area of a circle, πr2.   Here’s the console output for a typical execution of this program, in which the  user entered 5 as the radius of the circle:  Welcome to the circle area calculator. Enter the radius of your circle: 5 The area is 78.53981633974483  LISTING	3-2:	  The Circle Area Calculator  import java.util.Scanner; public class CircleAreaApp {     static Scanner sc = new Scanner System.in ;     public static void main String[] args      {         System.out.println              "Welcome to the circle area calculator." ;         System.out.print "Enter the radius of your circle: " ;         double r = sc.nextDouble  ;         double area = Math.PI *  r * r ;          System.out.println "The area is " + area ;     } }  →13  Working with mathematical functions  Table 3-4 lists the basic mathematical functions that are provided by the  Math  class. As you can see, you can use these functions to calculate such things as the  absolute value of a number, the minimum and maximum of two values, square  roots, powers, and logarithms.  CHAPTER 3  Working with Numbers and Expressions      113   TABLE 3-4	  Method  Explanation  Mathematical Functions Provided by the Math Class  abs argument   Returns the absolute value of the argument. The argument can be an int, long,  float, or double. The return value is the same type as the argument.  cbrt argument   Returns the cube root of the argument. The argument and return value are   doubles.  exp argument   Returns e raised to the power of the argument. The argument and the return value  are doubles.  hypot arg1, arg2   Returns the hypotenuse of a right triangle calculated according to the Pythagorean  theorem — √ x2 + y2. The argument and the return values are doubles.  log argument   Returns the natural logarithm  base e  of the argument. The argument and the  return value are doubles.  log10 argument   Returns the base 10 logarithm of the argument. The argument and the return value  are doubles.  max arg1, arg2   Returns the larger of the two arguments. The arguments can be int, long, float,  or double, but both must be of the same type. The return type is the same type as  the arguments.  min arg1, arg2   Returns the smaller of the two arguments. The arguments can be int, long,  float, or double, but both must be of the same type. The return type is the same  type as the arguments.  pow arg1, arg2   Returns the value of the first argument raised to the power of the second argument.  Both arguments and the return value are doubles.  random    Returns a random number that’s greater than or equal to 0.0 but less than 1.0. This  method doesn’t accept an argument, but the return value is a double.  signum argument   Returns a number that represents the sign of the argument: –1.0 if the argument  is negative, 0.0 if the argument is zero, and 1.0 if the argument is positive. The  argument can be a double or a float. The return value is the same type as  the argument.  sqrt argument   Returns the square root of the argument. The argument and return value  are doubles.  The program shown in Listing 3-3 demonstrates each of these methods except  random. When run, it produces output similar to this:  abs b     = 50 cbrt x    = 2.924017738212866 exp y     = 54.598150033144236 hypot y,z = 5.0 log y     = 1.0986122886681096 log10 y   = 0.47712125471966244  114      BOOK 2  Programming Basics   max a, b  = 100 min a, b  = -50 pow a, c  = 1000000.0 random    = 0.8536014557793756 signum b  = -1.0 sqrt x    = 1.7320508075688772  You can use this output to get an idea of the values returned by these Math class  methods. You can see, for example, that the expression Math.sqrt y  returns a  value of 5.0 when y is 25.0.  The  following  paragraphs  point  out  a  few  interesting  tidbits  concerning  these  methods:   » You can use the abs and signnum methods to force the sign of one variable to   match the sign of another, like this:  int a = 27; int b = -32; a = Math.abs a  * Math.signum b ;      a is now -27;   » You can use the pow method to square a number, like this:  double x = 4.0; double y = Math.pow x, 2 ;      a is now 16;  Simply multiplying the number by itself, however, is often just as easy and just  as readable:  double x = 4.0; double y = x * x;      a is now 16;   » In the classic movie The Wizard of Oz, when the Wizard finally grants the   Scarecrow his brains, the Scarecrow suddenly becomes intelligent and quotes  the Pythagorean theorem, which is  coincidentally  used by the hypot method  of the Math class. Unfortunately, he quotes it wrong. What the Scarecrow  actually says in the movie is this: “The sum of the square root of any two sides  of an isosceles triangle is equal to the square root of the remaining side.” Silly  Scarecrow. What he should have said, of course, is “The square of the  hypotenuse of any right triangle is equal to the sum of the squares of the  other two sides.”   » Every time you run the program in Listing 3-3, you get a different result for the  random method call. The random method is interesting enough that I describe  it separately in the next section, “Creating random numbers.”  CHAPTER 3  Working with Numbers and Expressions      115   LISTING	3-3:	 A Program That Uses the Mathematical Methods of the Math Class  public class MathFunctionsApp {     public static void main String[] args      {         int a = 100;         int b = -50;         int c = 3;         double x = 25.0;         double y = 3.0;         double z = 4.0;          System.out.println "abs b     = " + Math.abs b  ;         System.out.println "cbrt x    = " + Math.cbrt x  ;         System.out.println "exp y     = " + Math.exp z  ;         System.out.println "hypot y,z = " + Math.hypot y,z  ;         System.out.println "log y     = " + Math.log y  ;         System.out.println "log10 y   = " + Math.log10 y  ;         System.out.println "max a, b  = " + Math.max a, b  ;         System.out.println "min a, b  = " + Math.min a, b  ;         System.out.println "pow a, c  = " + Math.pow a, c  ;         System.out.println "random    = " + Math.random   ;         System.out.println "signum b  = " + Math.signum b  ;         System.out.println "sqrt x    = " + Math.sqrt y  ;     } }  Creating random numbers  Sooner or later, you’re going to want to write programs that play simple games.  Almost all games have some element of chance built into them, so you need a way  to create computer programs that don’t work exactly the same every time you run  them. The easiest way to do that is to use the random method of the Math class,  which Table 3-4 lists later in this section, along with the other basic mathematical  functions of the Math class.  The random method returns a double whose value is greater than or equal to 0.0  but less than 1.0. Within this range, the value returned by the random method is  different every time you call it and is essentially random.  Strictly speaking, computers are not capable of generating truly random numbers,  but over the years, clever computer scientists have developed ways to generate  numbers  that  are  random  for  all  practical  purposes.  These  numbers  are  called  pseudorandom numbers because although they aren’t completely random, they look  random to most human beings.  116      BOOK 2  Programming Basics   Java has many methods and classes for generating random numbers. The java. util.Random  class,  for  example,  provides  about  ten  specialized  methods  that  generate random values. To generate a double with a value between 0.0 and 1.0,  you can execute new  Random  .nextDouble  . In addition, the java.security. SecureRandom class provides random values for encrypting sensitive documents.  And if size matters to you, the java.math.BigInteger class allows you to gener- ate arbitrarily large random numbers  numbers with 1,000 digits, if that’s what  you need .  The  random  method  generates  a  random  double  value  between  0.0   inclusive,  meaning that it could be 0.0  and 1.0  exclusive, meaning that it can’t be 1.0 . Most  computer applications that need random values, however, need random integers  between some arbitrary low value  usually 1, but not always  and some arbitrary  high value. A program that plays dice needs random numbers between 1 and 6,  whereas a program that deals cards needs random numbers between 1 and 52  53  if a joker is used .  As a result, you need a Java expression that converts the double value returned  by the random function to an int value within the range your program calls for.  The following code shows how to do this, with the values set to 1 and 6 for a dice- playing game:  int low = 1;         the lowest value in the range int high = 6;        the highest value in the range int rnd =  int  Math.random   *  high - low + 1   + low;  This expression is a little complicated, so I show you how it’s evaluated step by step: 1.  The Math.Random method is called to get a random double value. This value is   greater than 0.0 but less than 5.0.  2.  The random value is multiplied by the high end of the range minus the low   end, plus 1. In this example, the high end is 6 and the low end is 1, so you now  have a random number that’s greater than or equal to 0.0 but less than 6.0.   It could be 5.99999999999999, but it never is 6.0.   3.  This value is converted to an integer by the  int  cast. Now you have an   integer that’s 0, 1, 2, 3, 4, or 5.  Remember that when you cast a double to an  int, any fractional part of the value is simply discarded. Because the number is  less than 6.0, it never truncates to 6.0 when it is cast to an int.   4.  The low value in the range is added to the random number. Assuming that low  is 1, the random number is now 1, 2, 3, 4, 5, or 6. That’s just what you want: a  random number between 1 and 6.  CHAPTER 3  Working with Numbers and Expressions      117   LISTING	3-4:	  Rolling the Dice  To give you an idea of how this random-number calculation works, Listing 3-4   shows a program that places this calculation in a method called randomInt and  then calls it to simulate 100 dice rolls. The randomInt method accepts two param- eters representing the low and high ends of the range, and it returns a random  integer  within  the  range.  In  the  main  method  of  this  program,  the  randomInt  method  is  called  100  times,  and  each  random  number  is  printed  by  a  call  to  System.out.print.  The console output for this program looks something like this:  Here are 100 random rolls of the dice: 4 1 1 6 1 2 6 6 6 6 5 5 5 4 5 4 4 1 3 6 1 3 1 4 4 3 3 3 5 6 5 6 6 3 5 2 2 6   4 1 2 2 4 2 2 4 1 4 3 6 5 5 4 4 2 4 1 3 5 2 1 3 3 5 4 1 6 3 1 6 5 2 6 6 3 5   3 3  4 5  2 5 4 5 3 1 4 2 5 2 1 4 4 4 6 6 4 6 3 3  Every time you run this program, however, you see a different sequence of 100  numbers.  The program in Listing 3-4 uses several Java features that you haven’t seen yet.  public class DiceApp {     public static void main String[] args      {         int roll;         String msg = "Here are 100 random rolls of the dice:";         System.out.println msg ;         for  int i=0; i<100; i++           {             roll = randomInt 1, 6 ;              System.out.print roll + " " ;          }         System.out.println  ;     }     public static int randomInt int low, int high       {         int result =  int  Math.random                *  high - low + 1   + low;         return result;      }  }  →8  →10 →11  →16  →18  →20  118      BOOK 2  Programming Basics   The following paragraphs explain how the program works, but don’t worry if you  don’t get all the elements in this program. The main thing to see is the expression  that converts the random double value returned by the Math.double method to  an integer.  →8      The for statement causes the statements in its body  lines 10 and 11  to be  executed 100 times. Don’t worry about how this statement works for now;  you find out about it in Book 2, Chapter 5.  →10    This statement calls the randomInt method, specifying 1 and 6 as the   range for the random integer to generate. The resulting random number is  assigned to the roll variable.  →11    The System.out.print method is used to print the random number   followed by a space. Because this statement calls the print method rather  than the println method, the random numbers are printed on the same  line rather than on separate lines.  →16    The declaration for the randomInt method indicates that the method   returns an int value and accepts two int arguments: one named low and  the other named high.  →18    This expression converts the random double value to an integer between   low and high.  →20    The return statement sends the random number back to the statement   that called the randomInt method.  Rounding functions  The Math class has four methods that round or truncate float or double values.  Table  3-5  lists  these  methods.  As  you  can  see,  each  of  these  methods  uses  a  different technique to calculate an integer value that’s near the double or float  value passed as an argument. Note that even though all four of these methods  round a floating-point value to an integer value, only the round method actually  returns an integer type  int or long, depending on whether the argument is a  float or a double . The other methods return doubles that happen to be integer  values.  CHAPTER 3  Working with Numbers and Expressions      119   TABLE 3-5	  Method  Explanation  Rounding Functions Provided by the Math Class  ceil argument   Returns the smallest double value that is an integer and is greater than or equal to  the value of the argument.  floor argument   Returns the largest double value that is an integer and is less than or equal to the  value of the argument.  rint argument   Returns the double value that is an integer and is closest to the value of the  argument. If two integer values are equally close, it returns the one that is even. If the  argument is already an integer, it returns the argument value.  round argument   Returns the integer that is closest to the argument. If the argument is a double, it  returns a long. If the argument is a float, it returns an int.  Listing 3-5 shows a program that uses each of the four methods to round three  double values: 29.4, 93.5, and -19.3. Here’s the output from this program:  round x  = 29 round y  = 94 round z  = -19  ceil x  = 30.0 ceil y  = 94.0 ceil z  = -19.0  floor x  = 29.0 floor y  = 93.0 floor z  = -20.0  rint x  = 29.0 rint y  = 94.0 rint z  = -19.0  Note that each of the four methods produces a different result for at least one of  the values:   » All the methods except ceil return 29.0  or 29  for the value 29.4. ceil   returns 30.0, which is the smallest integer that’s greater than 29.4.   » All the methods except floor return 94.0  or 94  for the value 93.5. floor  returns 93.0 because that’s the largest integer that’s less than 93.99. rint  returns 94.0 because it’s an even number, and 93.5 is midway between 93.0  and 94.0.   » All the methods except floor return -19.0  or -19  for -19.3. floor  returns -20 because –20 is the largest integer that’s less than –19.3.  120      BOOK 2  Programming Basics   LISTING	3-5:	  Program That Uses the Rounding Methods of the Math Class  public class RoundingApp {     public static void main String[] args      {         double x = 29.4;         double y = 93.5;         double z = -19.3;          System.out.println "round x  = " + Math.round x  ;         System.out.println "round y  = " + Math.round y  ;         System.out.println "round z  = " + Math.round z  ;         System.out.println  ;         System.out.println "ceil x  = " + Math.ceil x  ;         System.out.println "ceil y  = " + Math.ceil y  ;         System.out.println "ceil z  = " + Math.ceil z  ;         System.out.println  ;         System.out.println "floor x  = " + Math.floor x  ;         System.out.println "floor y  = " + Math.floor y  ;         System.out.println "floor z  = " + Math.floor z  ;         System.out.println  ;         System.out.println "rint x  = " + Math.rint x  ;         System.out.println "rint y  = " + Math.rint y  ;         System.out.println "rint z  = " + Math.rint z  ;     } }  Formatting Numbers  Most of the programs you’ve seen so far have used the System.out.println or  System.out.print method to print the values of variables that contain numbers.  When you pass a numeric variable to one of these methods, the variable’s value  is converted to a string before it’s printed. The exact format used to represent the  value isn’t very pretty: Large values are printed without any commas, and all the  decimal digits for double or float values are printed whether you want them to  be or not.  In many cases, you want to format your numbers before you print them — to add  commas to large values and limit the number of decimal places printed, for exam- ple. Or, if a number represents a monetary amount, you may want to add a dollar  sign  or whatever currency symbol is appropriate for your locale . To do that, you  can use the NumberFormat class. Table 3-6 lists the NumberFormat class methods.  CHAPTER 3  Working with Numbers and Expressions      121   TABLE 3-6	  Method  Methods of the NumberFormat Class  Explanation  getCurrencyInstance    A static method that returns a NumberFormat object that formats  currency values  getPercentInstance    getNumberInstance    A static method that returns a NumberFormat object that formats  percentages  A static method that returns a NumberFormat object that formats  basic numbers  format number   Returns a string that contains the formatted number  setMinimumFractionDigits int   Sets the minimum number of digits to display to the right of the  decimal point  setMaximumFractionDigits int   Sets the maximum number of digits to display to the right of the  decimal point  Like many aspects of Java, the procedure for using the NumberFormat class is a  little awkward. It’s designed to be efficient for applications that need to format a  lot of numbers, but it’s overkill for most applications.  The procedure for using the NumberFormat class to format numbers takes a little  getting used to. First, you must call one of the static getXxxInstance methods to  create a NumberFormat object that can format numbers in a particular way. Then,  if  you  want,  you  can  call  the  setMinimumFractionDigits  or  setMaximumFrac- tionDigits method to set the number of decimal digits to be displayed. Finally,  you call that object’s format method to actually format a number.  Note  that  the  NumberFormat  class  is  in  the  java.text  package,  so  you  must  include the following import statement at the beginning of any class that uses  NumberFormat:  import java.text.NumberFormat;  Here’s an example that uses the NumberFormat class to format a double value as  currency:  double salesTax = 2.425; NumberFormat cf = NumberFormat.getCurrencyInstance  ; System.out.println cf.format salesTax  ;  When you run this code, the following line is printed to the console:  $2.43  122      BOOK 2  Programming Basics   Note that the currency format rounds the value from 2.425 to 2.43.  Here’s an example that formats a number by using the general number format,  with exactly three decimal places:  double x = 19923.3288; NumberFormat nf = NumberFormat.getNumberInstance  ; nf.setMinimumFractionDigits 3 ; nf.setMaximumFractionDigits 3 ; System.out.println nf.format x  ;  When you run this code, the following line is printed:  19,923.329  Here’s an example that uses the percentage format:  double grade = .92; NumberFormat pf = NumberFormat.getPercentInstance  ; System.out.println pf.format grade  ;  When you run this code, the following line is printed:  92%  Here the number is formatted with a comma and the value is rounded to three  places.  If  your  program  formats  several  numbers,  consider  creating  the  NumberFormat  object as a class variable. That way, the NumberFormat object is created when the  program starts. Then you can use the NumberFormat object from any method in  the program’s class. Listing 3-6 is a simple example that shows how this process  works. When this program is run, the following output is produced:  My allowance: $5.00 Cost of Paint Ball Gun: $69.95  Here the cf variable is created as a class variable. Then both the print MyAllowance  and printCostOfPaintBallGun methods can use it in lines 19 and 27.  CHAPTER 3  Working with Numbers and Expressions      123   LISTING	3-6:	 A Program That Uses a NumberFormat Class Variable  import java.text.NumberFormat;  public class NumberFormatClassApp {      static NumberFormat cf =          NumberFormat.getCurrencyInstance  ;      public static void main String[] args      {         printMyAllowance  ;         printCostOfPaintBallGun  ;     }      public static void printMyAllowance       {         double myAllowance = 5.00;         cf = NumberFormat.getCurrencyInstance  ;         System.out.println "My allowance: "              + cf.format myAllowance  ;     }      public static void printCostOfPaintBallGun       {         double costOfPaintBallGun = 69.95;         cf = NumberFormat.getCurrencyInstance  ;         System.out.println "Cost of Paint Ball Gun: "              + cf.format costOfPaintBallGun  ;     } }  →6  →19  →27  Recognizing Weird Things about   Java Math  Believe it or not, computers — even the most powerful ones — have certain lim- itations  when  it  comes  to  performing  math  calculations.  These  limitations  are  usually insignificant, but sometimes they sneak up and bite you. The following  sections describe the things you need to watch out for when doing math in Java.  124      BOOK 2  Programming Basics   Integer overflow  The basic problem with integer types is that they have a fixed size. As a result, there  is a limit to the size of the numbers that can be stored in variables of type short,  int, or long. Although long variables can hold numbers that are huge, sooner or  later you come across a number that’s too big to fit in even a long variable.  Okay, consider this  admittedly contrived  example:  int a = 1000000000; System.out.println a ; a += 1000000000; System.out.println a ; a += 1000000000; System.out.println a ; a += 1000000000; System.out.println a ;  1000000000 2000000000 -1294967296 -294967296  Here you expect the value of a to get bigger after each addition. But here’s the  output that’s displayed:  The first addition seems to work, but after that, the number becomes negative!  That’s because the value has reached the size limit of the int data type. Unfor- tunately, Java doesn’t tell you that this error has happened. It simply crams the  int variable as full of bits as it can, discards whatever bits don’t fit, and hopes  that you don’t notice. Because of the way int stores negative values, large positive  values suddenly become large negative values.  The moral of the story is that if you’re working with large integers, you should use  long rather than int, because long can store much larger numbers than int. If  your programs deal with numbers large enough to be a problem for long, consider  using floating-point types instead. As you see in the next section, floating-point  types can handle even larger values than long, and they let you know when you  exceed their capacity.  Floating-point weirdness  Floating-point numbers have problems of their own. For starters, floating-point  numbers are stored using the binary number system  base 2 , but humans work  with numbers in the decimal number system  base 10 . Unfortunately, accurately  converting numbers between these two systems is sometimes impossible. That’s   CHAPTER 3  Working with Numbers and Expressions      125   because in any number base, certain fractions can’t be represented exactly. One  example: Base 10 has no way to exactly represent the fraction 1 3. You can approx- imate it as 0.3333333, but eventually you reach the limit of how many digits you  can store, so you have to stop. In base 2, it happens that one of the fractions you  can’t accurately represent is the decimal value 1 10. In other words, a float or  double variable can’t accurately represent 0.1.  Don’t believe me? Try running this code:  float x = 0.1f; NumberFormat nf = NumberFormat.getNumberInstance  ; nf.setMinimumFractionDigits 10 ; System.out.println nf.format x  ;  The resulting output is this:  0.1000000015  Although 0.1000000015 is close to 0.1, it isn’t exact.  In most cases, Java’s floating-point math is close enough not to matter. The mar- gin of error is extremely small. If you’re using Java to measure the size of your  house, you’d need an electron microscope to notice the error. If you’re writing  applications that deal with financial transactions, however, normal rounding can  sometimes magnify the errors to make them significant. You may charge a penny  too much or too little sales tax. And in extreme cases, your invoices may actually  have obvious addition errors.  Integer  types  are  stored  in  binary  too,  of  course.  But  integers  aren’t  subject  to  the same errors that floating-point types are — because integers don’t represent  fractions at all — so you don’t have to worry about this type of error for integer  types.  Division by zero  According to the basic rules of mathematics, you can’t divide a number by zero.  The reason is simple: Division is the inverse of multiplication — which means  that if a * b = c, it is also true that a = c   b. If you were to allow b to be zero,  division would be meaningless, because any number times zero is zero. Therefore,   126      BOOK 2  Programming Basics   both  a  and  c  would  also  have  to  be  zero.  In  short,  mathematicians  solved  this  dilemma centuries ago by saying that division by zero is simply not allowed.  So what happens if you do attempt to divide a number by zero in a Java program?  The answer depends on whether you’re dividing integers or floating-point num- bers. If you’re dividing integers, the statement that attempts the division by zero  chokes up what is called an exception, which is an impolite way of crashing the  program. In Book 2, Chapter 8, you find out how to intercept this exception to  allow your program to continue. In the meantime, any program you write that  attempts an integer division by zero crashes.  If you try to divide a floating-point type by zero, the results are not so abrupt.  Instead, Java assigns to the floating-point result one of the special values listed  in  Table  3-7.  The  following  paragraphs  explain  how  these  special  values  are  determined:   » If you divide a number by zero, and the sign of both numbers is the same, the   result is positive infinity. 0.0 divided by 0.0 is positive infinity, as is -34.0  divided by -0.0.   » If you divide a number by zero, and the signs of the numbers are different, the  result is negative infinity. -40.0 divided by 0.0 is negative infinity, as is 34.0  divided by 0.0.   » If you divide zero by zero, the result is not a number  NaN , regardless of the   signs.  Floating-point zeros can be positive or negative. Java considers positive and neg- ative zeros to be equal numerically.  If you attempt to print a floating-point value that has one of these special values,  Java converts the value to an appropriate string. Suppose that you execute the fol- lowing statements:  double i = 50.0; double j = 0.0; double k = i   j; System.out.println k ;  The resulting console output is  Infinity  If  i  were  -50.0,  the  console  would  display  -Infinity,  and  if  i  were  zero,  the  console would display NaN.  CHAPTER 3  Working with Numbers and Expressions      127   TABLE 3-7	  Special Constants of the float and double Classes Constant  Meaning  POSITIVE_INFINITY  NEGATIVE_INFINITY  NaN  Positive infinity  Negative infinity  Not a number  The following paragraphs describe some final bits of weirdness I want to sneak in  before closing this chapter:   » NaN is not equal to itself, which can have some strange consequences.   For example:  double x = Math.sqrt -50 ;       Not a number double y = x; if  x == y      System.out.println "x equals y" ;  Okay, I know that I jumped the gun here on the if statement, because I don’t  cover if statements until Book 2, Chapter 4. So just assume, for the sake of  argument, that the if statement tests whether the variable x is equal to the  variable y. Because this test immediately follows an assignment statement  that assigns the value of x to y, you can safely assume that x equals y, right?  Wrong. Because x is NaN, y also is NaN. NaN is never considered to be equal to  any other value, including another NaN. Thus, the comparison in the if  statement fails.   » Another strange consequence: You can’t assume that a number minus itself is   always zero. Consider this statement:  double z = x - x;       not necessarily zero  Shouldn’t this statement always set z to zero? Not if x is NaN. In that case, not  a number minus not a number is still not a number.   » One more weirdness and then I’ll stop: Any mathematical operation involving  infinity results in either another infinity or NaN. Infinity + 5, for example, still  equals infinity, so Buzz Lightyear’s call “To infinity and beyond!” just isn’t going  to happen. But infinity minus infinity gives you . . . NaN.  128      BOOK 2  Programming Basics   IN THIS CHAPTER  » Boring into Boolean expressions    for fun and profit   » Focusing on your basic, run-of-the-   mill if statement   » Looking at else clauses and else-if   statements   » Understanding nested if statements   » Considering logical operators   » Looking at the weird ?: operator   » Knowing the proper way to do string   comparisons  Chapter 4 Making Choices  So  far  in  this  book,  all  the  programs  have  run  straight  through  from  start   to  finish  without  making  any  decisions  along  the  way.  In  this  chapter,  you discover two Java statements that let you create some variety in your   programs. The if statement lets you execute a statement or a block of statements  only if some conditional test turns out to be true. And the switch statement lets  you  execute  one  of  several  blocks  of  statements  depending  on  the  value  of  an  integer variable.  The  if statement  relies  heavily  on the  use  of  Boolean expressions, which  are,  in  general, expressions that yield a simple true or false result. Because you can’t do  even the simplest if statement without a Boolean expression, this chapter begins  by showing you how to code simple Java boolean expressions that test the value  of a variable. Later, after looking at the details of how the if statement works,   I revisit boolean expressions to show how to combine them to make complicated  logical decisions. Then I get to the switch statement.  You’re going to have to put your thinking cap on for much of this chapter, as most  of it plays with logic puzzles. Find yourself a comfortable chair in a quiet part of  the house, turn off the TV, and pour yourself a cup of coffee.  CHAPTER 4  Making Choices      129   Using Simple Boolean Expressions  All if statements, as well as several of the other control statements that I describe  in  Book  2,  Chapter  5   while,  do,  and  for ,  use  boolean  expressions  to  deter- mine whether to execute or skip a statement  or a block of statements . A boolean  expression is a Java expression that, when evaluated, returns a Boolean value: true  or false.  As you discover later in this chapter,  boolean expressions can be very compli- cated. Most of the time, however, you use simple expressions that compare the  value of a variable with the value of some other variable, a literal, or perhaps a  simple arithmetic expression. This comparison uses one of the relational operators  listed in Table 4-1. All these operators are binary operators, which means that they  work on two operands.  TABLE 4-1	  Relational Operators Operator Description  ==  !=  <  <=  >  >=  Returns true if the expression on the left evaluates to the same value as  the expression on the right.  Returns true if the expression on the left does not evaluate to the same  value as the expression on the right.  Returns true if the expression on the left evaluates to a value that is less  than the value of the expression on the right.  Returns true if the expression on the left evaluates to a value that is less  than or equal to the expression on the right.  Returns true if the expression on the left evaluates to a value that is  greater than the value of the expression on the right.  Returns true if the expression on the left evaluates to a value that is  greater than or equal to the expression on the right.  A basic Java boolean expression has this form:  expression relational-operator expression  Java evaluates a boolean expression by first evaluating the expression on the left,  then evaluating the expression on the right, and finally applying the relational  operator to determine whether the entire expression evaluates to true or false.  Here are some simple examples of relational expressions. For each example, assume  that the following statements were used to declare and initialize the variables:  130      BOOK 2  Programming Basics   int i = 5; int j = 10; int k = 15; double x = 5.0; double y = 7.5; double z = 12.3;  Here  are  the  sample  expressions,  along  with  their  results   based  on  the  values  supplied :  Expression  Value  Explanation  i == 5  true  The value of i is 5.  i == 10  false  The value of i is not 10.  i == j  false  i is 5, and j is 10, so they are not equal.  i == j - 5  true  i is 5, and j – 5 is 5.  i > 1  true  i is 5, which is greater than 1.  j == i * 2  true  j is 10, and i is 5, so i * 2 is also 10.  s e c i o h C g n k a M  i     x = i  k < z  true  Casting allows the comparison, and 5.0 is equal to 5.  false  Casting allows the comparison, and 15 is greater than 12.3.  i * 2 < y  false  i * 2 is 10, which is not less than 7.5.  Note that the relational operator that tests for equality is two equal signs in a row   == . A single equal sign is the assignment operator. When you’re first learning  Java, you may find yourself typing the assignment operator when you mean the  equals operator, like this:  if  i = 5   Oops. But Java won’t let you get away with this, so you have to correct your mis- take and recompile the program. At first, doing so seems like a nuisance. The more  you work with Java, the more you realize that it really is a nuisance, but one you  can get used to.  Another  important  warning:  Do  not  test  strings  by  using  any  of  the  relational  operators listed in Table 4-1, including the equals operator. You’re probably going  to feel tempted to test strings like this:  inputString == "Yes"  CHAPTER 4  Making Choices      131   Note, however, that this is not the correct way to compare strings in Java. You  find out the correct way in the section “Comparing Strings,” later in this chapter.  Using if Statements  The if statement is one of the most important statements in any programming  language, and Java is no exception. The following sections describe the ins and  outs of using the various forms of Java’s powerful if statement.  Simple if statements  In its most basic form, an if statement lets you execute a single statement or a  block of statements only if a boolean expression evaluates to true. The basic form  of the if statement looks like this:  if  boolean-expression  statement  Note that the boolean expression must be enclosed in parentheses. Also, if you  use only a single statement, it must end with a semicolon. But the statement can  also be a statement block enclosed by braces. In that case, each statement within  the block needs a semicolon, but the block itself doesn’t.  Here’s an example of a typical if statement:  double commissionRate = 0.0; if  salesTotal > 10000.0      commissionRate = 0.05;  In this example, a variable named commissionRate is initialized to 0.0 and then  set to 0.05 if salesTotal is greater than 10000.0.  Some programmers find it helpful to visualize the operation of an if statement as  a flowchart, as shown in Figure 4-1. In this flowchart, the diamond symbol rep- resents the condition test: If the sales total is greater than $10,000, the statement  in the rectangle is executed. If not, that statement is bypassed.  Indenting the statement under the if statement is customary because it makes the  structure of your code more obvious. It isn’t necessary, but it’s always a good idea.  132      BOOK 2  Programming Basics   FIGURE 4-1:   The flowchart for  an if statement.  Here’s an example that uses a block rather than a single statement:  double commissionRate = 0.0; if  salesTotal > 10000.0  {     commissionRate = 0.05;     commission = salesTotal * commissionRate; }  In this example, the two statements within the braces are executed if sales Total  is greater than $10,000. Otherwise neither statement is executed.  Here are a few additional points about simple if statements:   » Some programmers prefer to code the opening brace for the statement block   on the same line as the if statement itself, like this:  s e c i o h C g n k a M  i     if  salesTotal > 10000.0  {     commissionRate = 0.05;     commission = salesTotal * commissionRate; }  This method is simply a matter of style, so either technique is acceptable.   » Indentation by itself doesn’t create a block. Consider this code:  if  salesTotal > 10000.0      commissionRate = 0.05;     commission = salesTotal * commissionRate;  Here I don’t use the braces to mark a block but indent the last statement as  though it were part of the if statement. Don’t be fooled; the last statement is   CHAPTER 4  Making Choices      133   executed regardless of whether the expression in the if statement evaluates  to true.  Some programmers like to code a statement block even for if statements  that conditionally execute just one statement. Here’s an example:  if  salesTotal > 10000.0  {     commissionRate = 0.05; }  That’s not a bad idea, because it makes the structure of your code a little more  obvious by adding extra white space around the statement. Also, if you decide  later that you need to add a few statements to the block, the braces are  already there.  It’s all too easy to later add extra lines to a conditional and  forget to include the braces, which leads to a bug that can be hard to trace.    » If only one statement needs to be conditionally executed, some programmers   put it on the same line as the if statement, like this:  if  salesTotal > 10000.0  commissionRate = 0.05;  This method works, but I’d avoid it. Your classes are easier to follow if you use  line breaks and indentation to highlight their structure.  if-else statements  An if-else statement adds an additional element to a basic if statement: a state- ment  or  block  that’s  executed  if  the  boolean  expression  is  not  true.  Its  basic  format is  if  boolean-expression  statement else statement  Here’s an example:  double commissionRate; if  salesTotal <= 10000.0      commissionRate = 0.02; else     commissionRate = 0.05;  In this example, the commission rate is set to 2 percent if the sales total is less  than or equal to $10,000. If the sales total is greater than $10,000, the commission  rate is set to 5 percent. Figure 4-2 shows a flowchart for this if-else statement.  134      BOOK 2  Programming Basics   FIGURE 4-2:   The flowchart  for an if-else  statement.  In  some  cases,  you  can  avoid  using  the  else  part  of  an  if-else  statement  by  cleverly  rearranging  your  code.  This  code  has  the  same  effect  as  the  preceding  if-else statement:  You can use blocks for either or both of the statements in an if-else statement.  Here’s an if-else statement in which both statements are blocks:  double commissionRate = 0.05; if  salesTotal <= 10000.0      commissionRate = 0.02;  double commissionRate; if  salesTotal <= 10000.0  {     commissionRate = 0.02;     level1Count++; } else {     commissionRate = 0.05;     level2Count++; }  s e c i o h C g n k a M  i     Nested if statements  The statement that goes in the if or else part of an if-else statement can be any  kind of Java statement, including another if or if-else statement. This arrange- ment is called nesting, and an if or if-else statement that includes another if or  if-else statement is called a nested if statement.  CHAPTER 4  Making Choices      135   The general form of a nested if statement is this:  if  expression-1      if  expression-2  statement-1     else statement-2 else     if  expression-3  statement-3     else statement-4  In  this  example,  expression-1  is  first  to  be  evaluated.  If  it  evaluates  to  true,  expression-2 is evaluated. If that expression is true, statement-1 is executed;  otherwise statement-2 is executed. But if expression-1 is false, expression-3   is  evaluated.  If  expression-3  is  true,  statement-3  is  executed;  otherwise   statement-4 is executed.  An if statement that’s contained within another if statement is called an inner  if  statement,  and  an  if  statement  that  contains  another  if  statement  is  called  an  outer  if  statement.  Thus,  in  the  preceding  example,  the  if  statement  that  tests  expression-1  is  an  outer  if  statement,  and  the  if  statements  that  test   expression-2 and expression-3 are inner if statements.  Nesting can be as complex as you want, but try to keep it as simple as possible.  Also, be sure to use indentation to indicate the structure of the nested statements.  Suppose that your company has two classes of sales representatives  Class 1 and  Class 2  and that these reps get different commissions for sales below $10,000 and  sales above $10,000, according to this table:  You could implement this commission structure with a nested if statement:  Sales  $0 to $9,999  $10,000 and over  Class 1  Class 2  2%  4%  2.5%  5%  if  salesClass == 1      if  salesTotal < 10000.0          commissionRate = 0.02;     else         commissionRate = 0.04; else  136      BOOK 2  Programming Basics   This example assumes that if the salesClass variable isn’t 1, it must be 2. If that’s  not the case, you have to use an additional if statement for Class 2 sales reps:      if  salesTotal < 10000.0          commissionRate = 0.025;     else         commissionRate = 0.05;  if  salesClass == 1      if  salesTotal < 10000.0          commissionRate = 0.02;     else         commissionRate = 0.04; else if  salesClass == 2      if  salesTotal < 10000.0          commissionRate = 0.025;     else         commissionRate = 0.05;  if  salesClass == 1      if  salesTotal < 10000.0          commissionRate = 0.02;     else         commissionRate = 0.04; if  salesClass == 2      if  salesTotal < 10000.0          commissionRate = 0.025;     else         commissionRate = 0.05;  Notice that I place this extra if statement on the same line as the else keyword.  That’s a common practice for a special form of nested if statements called else- if statements. You find more about this type of nesting in the next section.  You could just use a pair of separate if statements, of course, like this:  s e c i o h C g n k a M  i     The result is the same. This particular technique, however, works only if the if  statement itself doesn’t change the variable being tested. If the first if statement  does change the value of the salesClass variable, this statement doesn’t work.  Note that you could also have implemented the commission structure by testing  the sales level in the outer if statement and the sales representative’s class in the  inner statements:  if  salesTotal < 10000      if  salesClass == 1          commissionRate = 0.02;  CHAPTER 4  Making Choices      137   Be careful when you use nested if and else statements, as it is all too easy to end  up with statements that don’t work the way you expect them to. The key is know- ing how Java pairs else keywords with if statements. The rule is actually very  simple: Each else keyword is matched with the most previous if statement that  hasn’t already been paired with an else keyword.  Sorry — you can’t coax Java into pairing the if and else keywords differently by  using indentation. Suppose that Class 2 sales reps don’t get any commission, so  the inner  if statements in the preceding example don’t need  else statements.  You may be tempted to calculate the commission rate by using this code:  Sorry — that won’t work. The indentation creates the impression that the else  keyword is paired with the first if statement, but in reality, it’s paired with the  second  if  statement.  As  a  result,  no  sales  commission  rate  is  set  for  sales  of  $10,000 or more.  This problem has two solutions. The first, and preferred, solution is to use braces  to clarify the structure:      else         commissionRate = 0.04; else     if  salesClass == 1          commissionRate = 0.025;     else         commissionRate = 0.05;  if  salesTotal < 10000      if  salesClass == 1          commissionRate = 0.02; else     if  salesClass == 1          commissionRate = 0.025;  if  salesTotal < 10000  {     if  salesClass == 1          commissionRate = 0.02; } else {     if  salesClass == 1          commissionRate = 0.025; }  138      BOOK 2  Programming Basics   The other solution is to add an else statement that specifies an empty statement  a  semicolon by itself  to the first inner if statement:  if  salesTotal < 10000      if  salesClass == 1          commissionRate = 0.02;     else ; else     if  salesClass == 1          commissionRate = 0.025;  The empty else statement is paired with the inner if statement, so the second  else keyword is properly paired with the outer if statement.  else-if statements  A common pattern for nested if statements is to have a series of if-else state- ments with another if-else statement in each else part:  if  expression-1      statement-1 else if  expression-2      statement-2 else if  expression-3      statement-3  These statements are sometimes called else-if statements, although that term is  unofficial. Officially, all that’s going on is that the statement in the else part hap- pens to be another if statement — so this statement is just a type of a nested if  statement. It’s an especially useful form of nesting, however.  Suppose that you want to assign four commission rates based on the sales total,  according to this table:  s e c i o h C g n k a M  i     Sales  Commission  Over $10,000  $5,000 to $9,999  $1,000 to $4,999  Under $1,000  5%  3.5%  2%  0%  CHAPTER 4  Making Choices      139   You can easily implement a series of else-if statements:  if  salesTotal >= 10000.0      commissionRate = 0.05; else if  salesTotal >= 5000.0      commissionRate = 0.035; else if  salesTotal >= 1000.0      commissionRate = 0.02; else     commissionRate = 0.0;  Figure 4-3 shows a flowchart for this sequence of else-if statements.  FIGURE 4-3:   The flowchart  for a sequence  of else-if   statements.  140      BOOK 2  Programming Basics   You have to think through carefully how you set up these  else-if statements.  At first glance, for example, this sequence looks as though it might work:  if  salesTotal > 0.0      commissionRate = 0.0; else if  salesTotal >= 1000.0      commissionRate = 0.02; else if  salesTotal >= 5000.0      commissionRate = 0.035; else if  salesTotal >= 10000.0      commissionRate = 0.05;  Nice try, but this scenario won’t work. These if statements always set the com- mission rate to 0 percent because the boolean expression in the first if statement  always tests true  assuming that the salesTotal isn’t zero or negative — and if  it is, none of the other if statements matter . As a result, none of the other if  statements are ever evaluated.  Using Mr. Spock’s Favorite Operators   Logical Ones, of Course   A logical operator  sometimes called a Boolean operator  is an operator that returns a  Boolean result that’s based on the Boolean result of one or two other expressions.  Expressions that use logical operators are sometimes called compound expressions  because the effect of the logical operators is to let you combine two or more condi- tion tests into a single expression. Table 4-2 lists the logical operators.  s e c i o h C g n k a M  i     TABLE 4-2	  Logical Operators  Operator  Name  Description  !  &    Not  And  Or  Type  Unary  Binary  Binary  Returns true if the operand to the right evaluates to false.  Returns false if the operand to the right is true.  Returns true if both of the operands evaluate to true. Both  operands are evaluated before the And operator is applied.  Returns true if at least one of the operands evaluates to  true. Both operands are evaluated before the Or operator  is applied.   continued   CHAPTER 4  Making Choices      141   TABLE	4-2	 continued   Operator  Name  Xor  Description  Type  Binary  ^  &&    Conditional And  Binary  Conditional Or  Binary  Returns true if one — and only one — of the operands  evaluates to true. Returns false if both operands evaluate  to true or if both operands evaluate to false.  Same as &, but if the operand on the left returns false,  returns false without evaluating the operand on the right.  Same as , but if the operand on the left returns true,  returns true without evaluating the operand on the right.  The following sections describe these operators in excruciating detail.  Using the ! operator  The  simplest  of  the  logical  operators  is  Not   ! .  Technically,  it’s  a  unary  prefix  operator, which means that you use it with one operand, and you code it immedi- ately in front of that operand.  Technically, this operator is called the complement  operator, not the Not operator. But in real life, most people call it Not. And many  programmers call it bang.   The Not operator reverses the value of a boolean expression. Thus, if the expres- sion is true, Not changes it to false. If the expression is false, Not changes it  to true.  Here’s an example:  ! i = 4   This expression evaluates to true if i is any value other than 4. If i is 4, it evalu- ates to false. It works by first evaluating the expression  i = 4 . Then it reverses  the result of that evaluation.  Don’t confuse the Not logical operator  !  with the Not Equals relational opera- tor  != . Although these operators are sometimes used in similar ways, the Not  operator is more general. I could have written the preceding example like this:  i != 4  The result is the same. The Not operator can be applied to any expression that  returns a true-false result, however, not just to an equality test.  142      BOOK 2  Programming Basics   You must almost always enclose the expression that the ! operator is applied to in  parentheses. Consider this expression:  Assuming that i is an integer variable, the compiler doesn’t allow this expression  because it looks like you’re trying to apply the ! operator to the variable, not to the  result of the comparison. A quick set of parentheses solves the problem:  ! i == 4  ! i == 4   Using the & and && operators  The & and && operators combine two boolean expressions and return true only  if  both  expressions  are  true.  This  type  of  operation  is  called  an  And operation,  because the first expression and the second expression must be true for the And  operator to return true.  Suppose that the sales commission rate should be 2.5% if the sales class is 1 and  the sales total is $10,000 or more. You could perform this test with two separate  if statements  as I did earlier in this chapter , or you could combine the tests into  one if statement:  if   salesClass == 1  &  salesTotal >= 10000.0       commissionRate = 0.025;  Here the expressions   salesClass  ==  1  and   salesTotal  >=  10000.0  are  evaluated separately. Then the  & operator compares the results. If they’re both  true, the & operator returns true. If one is false or both are false, the & opera- tor returns false.  Notice that I use parentheses liberally to clarify where one expression ends and  another begins. Using parentheses isn’t always necessary, but when you use logi- cal operators,  I suggest  that  you  always  use  parentheses  to  clearly  identify  the  expressions being compared.  The && operator is similar to the & operator, but it leverages your knowledge of  logic a bit more. Because both expressions compared by the & operator must be  true for the entire expression to be true, there’s no reason to evaluate the second  expression if the first one returns false. The & operator isn’t aware of this fact,  so  it  blindly  evaluates  both  expressions  before  determining  the  results.  The  &&  operator is smart enough to stop when it knows what the outcome is.  s e c i o h C g n k a M  i     CHAPTER 4  Making Choices      143   As a result, almost always use && instead of &. Here’s the preceding example, and  this time it’s coded smartly with &&:  if   salesClass == 1  &&  salesTotal >= 10000.0       commissionRate = 0.025;  Why do I say you should almost always use &&? Because sometimes the expressions  themselves  have  side  effects  that  are  important.  The  second  expression  might  involve  a  method  call  that  updates  a  database,  for  example,  and  you  want  the  database to be updated whether the first expression evaluates to true or to false.  In that case, you want to use & instead of && to ensure that both expressions get  evaluated.  Relying  on  the  side  effects  of  expressions  can  be  risky  —  and  you  can  almost  always  find  a  better  way  to  write  your  code  to  avert  the  side  effects.  In  other  words, placing an important call to a database-update method inside a compound  expression that’s buried in an if statement probably isn’t a good idea.  Using the  and  operators  The  and  operators are called Or operators because they return true if the first  expression is true or if the second expression is true. They also return true if  both expressions are true.  You find the  symbol on your keyboard just above the  Enter key.   Suppose that sales representatives get no commission if total sales are less than  $1,000 or if the sales class is 3. You could do that with two separate if statements:  if  salesTotal < 1000.0      commissionRate = 0.0; if  salesClass == 3      commissionRate = 0.0;  With  an  Or  operator,  however,  you  can  do  the  same  thing  with  a  compound  condition:  if   salesTotal < 1000.0    salesClass == 3       commissionRate = 0.0;  To evaluate the expression for this if statement, Java first evaluates the expres- sions on either side of the  operator. Then, if at least one of these expressions is  true, the whole expression is true. Otherwise the expression is false.  144      BOOK 2  Programming Basics   In  most  cases,  you  should  use  the  Conditional  Or  operator      instead  of  the  regular Or operator   , like this:  if   salesTotal < 1000.0    salesClass == 3       commissionRate = 0.0;  Like the Conditional And operator  && , the Conditional Or operator stops evaluat- ing as soon as it knows what the outcome is. Suppose that the sales total is $500.  Then there’s no need to evaluate the second expression. Because the first expres- sion  evaluates  to  true  and  only  one  of  the  expressions  needs  to  be  true,  Java  can skip the second expression. If the sales total is $5,000, of course, the second  expression must be evaluated.  As with the And operators, you should use the regular Or operator only if your  program depends on some side effect of the second expression, such as work done  by a method call.  Using the ^ operator  The ^ operator performs what in the world of logic is known as an Exclusive Or,  commonly abbreviated as Xor. It returns true if one — and only one — of the two  subexpressions is true. If both expressions are true, or if both expressions are  false, the ^ operator returns false.  Most programmers don’t bother with the ^ operator because it’s pretty confusing.  My feelings won’t be hurt if you skip this section.  Put another way, the ^ operator returns true if the two subexpressions have dif- ferent results. If they have the same result, it returns false.  Suppose that you’re writing software that controls your model railroad set, and  you want to find out whether two switches are set in a dangerous position that  might allow a collision. If the switches are represented by simple integer vari- ables named switch1 and switch2, and 1 means the track is switched to the left  and 2 means the track is switched to the right, you could easily test them like this:  s e c i o h C g n k a M  i     if   switch1 == switch2       System.out.println "Trouble! The switches are the same" ; else     System.out.println "OK, the switches are different." ;  Now, suppose that  for some reason  one of the switches is represented by an int  variable where 1 means the switch goes to the left and any other value means the  switch goes to the right — but the other switch is represented by an int variable   CHAPTER 4  Making Choices      145   where –1 means the switch goes to the left and any other value means the switch  goes  to  the  right.   Who  knows  —  maybe  the  switches  were  made  by  different  manufacturers.  You could use a compound condition like this:  if    switch1==1 && switch2==-1           switch1!=1 && switch2!=-1        System.out.println "Trouble! The switches are the same" ; else     System.out.println "OK, the switches are different." ;  But an XOR operator could do the job with a simpler expression:  if   switch1==1 ^ switch2==-1       System.out.println "OK, the switches are different." ; else     System.out.println "Trouble! The switches are the same" ;  Frankly, the ^ operator is probably one you consider avoiding. In fact, most of the  Java books on my bookshelf  and believe me, I have a lot of them  don’t even men- tion this operator except in its other, more useful application as a bitwise opera- tor. That’s probably because many applications don’t use it as a logical operator,  and  the  applications  for  which  it  is  suitable  can  also  be  solved  with  the  more  traditional And and Or operators.  Combining logical operators  You can combine simple boolean expressions to create more complicated expres- sions. For example:  if   salesTotal<1000.0   salesTotal<5000.0 &&       salesClass==1    salestotal < 10000.0 &&       salesClass == 2        CommissionRate = 0.0;  Can you tell what the expression in this if statement does? It sets the commission  to zero if any one of the following three conditions is true:   » The sales total is less than $1,000.  » The sales total is less than $5,000, and the sales class is 1.  » The sales total is less than $10,000, and the sales class is 2.  146      BOOK 2  Programming Basics   In  many  cases,  you  can  clarify  how  an  expression  works  just  by  indenting  its  pieces differently and spacing out its subexpressions. This version of the preced- ing if statement is a little easier to follow:  if   salesTotal < 1000.0           salesTotal < 5000.0  &&  salesClass == 1            salestotal < 10000.0  &&  salesClass == 2            commissionRate = 0.0;  Figuring out exactly what this if statement does, however, is still tough. In many  cases, the better thing to do is skip the complicated expression and code separate  if statements:  if  salesTotal < 1000.0      commissionRate = 0.0; if   salesTotal < 5000.0  &&  salesClass == 1       commissionRate = 0.0; if   salestotal < 10000.0  &&  salesClass == 2       commissionRate = 0.0;  s e c i o h C g n k a M  i     In Java, boolean expressions can get a little complicated when you use more than  one  logical  operator,  especially  if  you  mix  And  and  Or  operators.  Consider  this  expression:  if   a==1 && b==2  c==3       System.out.println "It's true!" ; else     System.out.println "No it isn't!" ;  What do you suppose this if statement does if a is 5, b is 7, and c = 3? The answer  is  that  the  expression  evaluates  to  true,  and  "It's  true!"  is  printed.  That’s  because Java applies the operators from left to right. So the && operator is applied  to a==1  which is false  and b==2  which is also false . Thus, the && operator  returns false. Then the  operator is applied to that false result and the result  of c==3, which is true. Thus the entire expression returns true.  Wouldn’t this expression have been clearer if you had used a set of parentheses to  clarify what the expression does? Consider this example:  if   a==1 && b==2   c==3       System.out.println "It's true!" ; else     System.out.println "No it isn't!" ;  Here you can clearly see that the && operator is evaluated first.  CHAPTER 4  Making Choices      147   Using the Conditional Operator  Java has a special operator called the conditional operator that’s designed to elimi- nate the need for if statements in certain situations. It’s a ternary operator, which  means that it works with three operands. The general form for using the condi- tional operator is this:  boolean-expression ? expression-1 : expression-2  The boolean expression is evaluated first. If it evaluates to true, expression-1  is  evaluated,  and  the  result  of  this  expression  becomes  the  result  of  the  whole  expression. If the expression is false, expression-2 is evaluated, and its results  are used instead.  Suppose  that  you  want  to  assign  a  value  of  0  to  an  integer  variable  named   salesTier  if  total  sales  are  less  than  $10,000  and  a  value  of  1  if  the  sales  are  $10,000 or more. You could do that with this statement:  int tier = salesTotal > 10000.0 ? 1 : 0;  Although not required, a set of parentheses helps make this statement easier to  follow:  int tier =  salesTotal > 10000.0  ? 1 : 0;  One common use for the conditional operator is when you’re using concatenation  to build a text string, and you have a word that may need to be plural based on  the value of an integer variable. Suppose that you want to create a string that says  "You have x apples", with the value of a variable named appleCount substituted  for x. But if apples is 1, the string should be "You have 1 apple", not "You have  1 apples".  The following statement does the trick:  String msg = "You have " + appleCount + " apple"     +   appleCount>1  ? "s." : "." ;  When Java encounters the ? operator, it evaluates the expression  appleCount>1 .  If true, it uses the first string  s. . If false, it uses the second string  "." .  148      BOOK 2  Programming Basics   Comparing Strings  Comparing strings in Java takes a little extra care, because the == operator really  doesn’t work the way it should. Suppose that you want to know whether a string  variable named answer contains the value "Yes". You may be tempted to code an  if statement like this:  if  answer == "Yes"      System.out.println "The answer is Yes." ;  Unfortunately, that’s not correct. The problem is that in Java, strings are reference  types, not primitive types; when you use the == operator with reference types, Java  compares the references to the objects, not the objects themselves. As a result, the  expression answer == "Yes" doesn’t test whether the value of the string refer- enced by the answer variable is "Yes". Instead, it tests whether the answer string  and the literal string "Yes" point to the same string object in memory. In many  cases, they do — but sometimes they don’t, and the results are difficult to predict.  The correct way to test a string for a given value is to use the equals method of  the String class:  if  answer.equals "Yes"       System.out.println "The answer is Yes." ;  This method actually compares the value of the string object referenced by the  variable with the string you pass as a parameter and returns a Boolean result to  indicate whether the strings have the same value.  The String class has another method, equalsIgnoreCase, that’s also useful for  comparing strings. It compares strings but ignores case, which is especially useful  when you’re testing string values entered by users. Suppose that you’re writing  a program that ends only when the user enters the word End. You could use the  equals method to test the string:  s e c i o h C g n k a M  i     In this case, however, the user would have to enter end exactly. If the user enters  End or END, the program won’t end. It’s better to code the if statement like this:  if  input.equals "end"        end the program  if  input.equalsIgnoreCase "end"        end the program  CHAPTER 4  Making Choices      149   Then the user could end the program by entering the word end spelled with any  variation of upper- and lowercase letters, including end, End, END, or even eNd.  You can find much more about working with strings in Book 4, Chapter 1. For now,  just remember that to test for string equality in an if statement  or in one of the  other control statements presented in the next chapter , you must use the equals  or equalsIgnoreCase method instead of the == operator.  150      BOOK 2  Programming Basics   IN THIS CHAPTER  » The thrill of while loops   » The rapture of infinite loops   » The splendor of do loops   » The joy of validating input   » The wonder of for loops   » The ecstasy of nested loops  Chapter 5 Going Around in Circles   Or, Using Loops   So far, all the programs in this book have started, run quickly through their   main method, and then ended. If Dorothy from The Wizard of Oz were using  these programs, she’d probably say, “My, programs come and go quickly   around here!”  In this chapter, you find out how to write programs that don’t come and go so  quickly. They hang around by using loops, which let them execute the same state- ments more than once.  Loops are the key to writing one of the most common types of programs: pro- grams that get input from the user, do something with it, get more input from  the user and do something with that, and keep going this way until the user has  had enough.  Put another way, loops are like the instructions on your shampoo: Lather. Rinse.  Repeat.  Like  if statements, loops rely on conditional expressions to tell them when to  stop  looping.  Without  conditional  expressions,  loops  would  go  on  forever,  and  your users would grow old watching them run. So if you haven’t yet read Book 2,  Chapter 4, I suggest that you do so before continuing much further.  CHAPTER 5  Going Around in Circles  Or, Using Loops       151   Using Your Basic while Loop  The most basic of all looping statements in Java is while. The while statement  creates a type of loop that’s called a while loop, which is simply a loop that exe- cutes  continuously  as  long  as  some  conditional  expression  evaluates  to  true.  while loops are useful in all sorts of programming situations, so you use while  loops a lot.  I tell you about other kinds of loops later in this chapter.   The while statement  The basic format of the while statement is this:  while  expression  statement  The  while  statement  begins  by  evaluating  the  expression.  If  the  expression  is  true,  statement  is  executed.  Then  the  expression  is  evaluated  again,  and  the  whole process repeats. If the expression is false, statement is not executed, and  the while loop ends.  Note that the statement part of the while loop can either be a single statement  or a block of statements contained in a pair of braces. Loops that have just one  statement aren’t very useful, so nearly all the while loops you code use a block  of statements.  Well, okay, sometimes loops with a single statement are useful.  It isn’t unheard of — just not all that common.   A counting loop  Here’s a simple program that uses a while loop to print the even numbers from  2 through 20 on the console:  public class EvenCounter {     public static void main String[] args      {         int number = 2;         while  number <= 20          {             System.out.print number + " " ;             number += 2;         }         System.out.println  ;     } }  152      BOOK 2  Programming Basics   If you run this program, the following output is displayed in the console window:  2 4 6 8 10 12 14 16 18 20  The conditional expression in this program’s while statement is number <= 20.  That means the loop repeats as long as the value of number is less than or equal to  20. The body of the loop consists of two statements. The first prints the value of  number followed by a space to separate this number from the next one. Then the  second statement adds 2 to number.  Figure 5-1 shows a flowchart for this program. This flowchart can help you visu- alize the basic decision-making process of a loop.  FIGURE 5-1:   The flowchart for  a while loop.  CHAPTER 5  Going Around in Circles  Or, Using Loops       153   Breaking Out of a Loop  In many programs, you need to set up a loop that has some kind of escape clause.  Java’s escape clause is the break statement. When a break statement is executed  in a while loop, the loop ends immediately. Any remaining statements in the loop  are ignored, and the next statement executed is the statement that follows the  loop.  Suppose that you’re afraid of the number 12.  I’m not a doctor, and I don’t play  one on TV, but I think the scientific name for this condition would be dodecapho- bia.  You could modify the counting program shown in the preceding section so  that when it gets to the number 12, it panics and aborts the loop:  public class Dodecaphobia {     public static void main String[] args      {         int number = 2;         while  number <= 20          {             if  number == 12                  break;             System.out.print number + " " ;             number += 2;         }         System.out.println  ;     } }  When you run this program, the following line is displayed on the console:  2 4 6 8 10  Whew! That was close. Almost got to 12 there.  Looping Forever  One common form of loop is called an infinite loop. That’s a loop that goes on for- ever. You can create infinite loops many ways in Java  not all of them intentional ,  but the easiest is to just specify true for the while expression.  154      BOOK 2  Programming Basics   Here’s an example:  public class CountForever {     public static void main String[] args      {         int number = 2;         while  true          {             System.out.print number + " " ;             number += 2;         }     } }  If you run this program, your console window quickly fills up with numbers and  just keeps going. That’s great if you really like even numbers, but eventually you’ll  tire of this loop and want it to stop. You can stop an infinite loop in any of three  ways:   » Turn off your computer.  » Hit your computer with an ax or other heavy object.  » Close the console window.  The last one is probably the one you want to go with.  Obviously, infinite loops are something you want to avoid in your programs. So  whenever you use a while expression that’s always true, be sure to throw in a  break statement to give your loop some way to terminate. You could use an infi- nite loop with a break statement in the Dodecaphobia program:  public class Dodecaphobia2 {     public static void main String[] args      {         int number = 2;         while  true          {             if  number == 12                  break;             System.out.print number + " " ;             number += 2;         }         System.out.println  ;     } }  CHAPTER 5  Going Around in Circles  Or, Using Loops       155   Here the loop looks as though it might go on forever, but the break statement  panics out of the loop when it hits 12.  Letting the user decide when to quit  It turns out that infinite loops are also useful when you want to let the user be in  charge of when to stop the loop. Suppose that you don’t know what numbers a  user is afraid of, so you want to count numbers until the user says to stop. Here’s  a program that does that:  import java.util.Scanner;  public class NumberPhobia {     static Scanner sc = new Scanner System.in ;      public static void main String[] args      {         int number = 2;         String input;         while  true          {             System.out.println number + " " ;             System.out.print                  "Do you want to keep counting?"                 + "  Y or N " ;             input = sc.next  ;             if  input.equalsIgnoreCase "N"                   break;             number += 2;         }         System.out.println "\nWhew! That was close.\n" ;     } }  Here’s  some  typical  console  output  from  this  program,  for  a  user  who  has  octophobia:  2 Do you want to keep counting?  Y or N y 4 Do you want to keep counting?  Y or N y 6 Do you want to keep counting?  Y or N n Whew! That was close.  156      BOOK 2  Programming Basics   Letting the user decide in another way  Another way to write a loop that a user can opt out of is to test the input string in the  while condition. The only trick here is that you must first initialize the input string  to the value that continues the loop. Otherwise, the loop doesn’t execute at all!  Here’s a variation of the NumberPhobia program named NumberPhobia2 that uses  this technique:  import java.util.Scanner;  public class NumberPhobia2 {     static Scanner sc = new Scanner System.in ;      public static void main String[] args      {         int number = 2;         String input = "Y";         while  input.equalsIgnoreCase "Y"           {             System.out.println number + " " ;             System.out.print                  "Do you want to keep counting?"                 + "  Y or N " ;             input = sc.next  ;             number += 2;         }         System.out.println "\nWhew! That was close." ;     } }  This program works almost the same way as the preceding version, but with a  subtle difference. In the first version, if the user says N after the program displays  6, the value of the number variable after the loop is 6 because the break statement  bails out of the loop before adding 2 to number. But in this version, the value of  number is 8.  Using the continue Statement  The break statement is rather harsh: It completely bails out of the loop. Some- times that’s what you need — but just as often, you don’t really need to quit the  loop; you just need to skip a particular iteration of the loop. The Dodecaphobia  program presented earlier in this chapter stops the loop when it gets to 12. What if  you just want to skip the number 12, so you go straight from 10 to 14?  CHAPTER 5  Going Around in Circles  Or, Using Loops       157   To  do  that,  you  can  use  the  break  statement’s  kinder,  gentler  relative,  the   continue statement. The continue statement sends control right back to the top  of the loop, where the expression is immediately evaluated again. If the expres- sion is still true, the loop’s statement or block is executed again.  Here’s a version of the Dodecaphobia program that uses a continue statement to  skip the number 12 rather than stop counting altogether when it reaches 12:  public class Dodecaphobia3 {     public static void main String[] args      {         int number = 0;         while  number < 20          {             number += 2;             if  number == 12                  continue;             System.out.print number + " " ;         }         System.out.println  ;     } }  Run this program, and you get the following output in the console window:  2 4 6 8 10 14 16 18 20  Notice that I had to make several changes in this program to get it to work with a  continue statement instead of a break statement. If I had just replaced the word  break with continue, the program wouldn’t have worked, because the statement  that added 2 to the number came after the break statement in the original version.  As a result, if you just replace the break statement with a continue statement,  you end up with an infinite loop when you reach 12, because the statement that  adds 2 to number never gets executed.  To make this program work with a continue statement, I rearranged the state- ments in the loop body so that the statement that adds 2 to number comes before  the continue statement. That way, the only statement skipped by the continue  statement is the one that prints number to the console.  Unfortunately, this change affected other statements in the program. Because 2  is added to number before number is printed, I had to change the initial value of  number from 2 to 0, and I had to change the while expression from number <= 20  to number < 20.  158      BOOK 2  Programming Basics   Running do-while Loops  A do-while loop  sometimes just called a do loop  is similar to a while loop, but  with a critical difference: In a do-while loop, the condition that stops the loop  isn’t tested until after the statements in the loop have executed. The basic form of  a do-while loop is this:  do     statement while  expression ;  Note that the while keyword and the expression aren’t coded until after the body  of the loop. As with a while loop, the body for a do-while loop can be a single  statement or a block of statements enclosed in braces.  Also, notice that the expression is followed by a semicolon. do-while is the only  looping statement that ends with a semicolon.  Here’s a version of the EvenCounter program that uses a do-while loop instead  of a while loop:  public class EvenCounter2 {     public static void main String[] args      {         int number = 2;         do         {             System.out.print number + " " ;             number += 2;         } while  number <= 20 ;          System.out.println  ;     } }  Here’s the most important thing to remember about do-while loops: The state- ment or statements in the body of a do-while loop always get executed at least  once. By contrast, the statement or statements in the body of a while loop aren’t  executed at all if the while expression is false the first time it’s evaluated.  Look at the flowchart in Figure 5-2 to see what I mean. You can see that execution  starts at the top of the loop and flows through to the decision test after the loop’s  body has been executed once. Then, if the decision test is true, control flies back  up to the top of the loop. Otherwise, it spills out the bottom of the flowchart.  CHAPTER 5  Going Around in Circles  Or, Using Loops       159   FIGURE 5-2:   The flowchart for  a do-while loop.  Here are a few other things to be aware of concerning do-while loops:   » You often can skip initializing the variables that appear in the expression   before the loop, because the expression isn’t evaluated until the statements in  the loop body have been executed at least once.   » You can use break and continue statements in a do-while loop, just as you   can in a while loop.   » Some programmers like to place the brace that begins the loop body on the   same line as the do statement and the while statement that ends the  do-while loop on the same line as the brace that marks the end of the loop  body. Whatever makes you happy is fine with me. Just remember that the  compiler is agnostic when it comes to matters of indentation and spacing.  160      BOOK 2  Programming Basics   Validating Input from the User  do-while  loops  are  especially  useful  for  validating  input  by  the  user.  Suppose  you’re  writing  a  program  that  plays  a  betting  game,  and  you  want  to  get  the  amount of the user’s bet from the console. The user can bet any dollar amount he  wants  whole dollars only, though  but can’t bet more than he has in the bank,  and he can’t bet a negative amount or zero. Here’s a program that uses a do-while  loop to get this input from the user:  import java.util.Scanner;  public class GetABet {     static Scanner sc = new Scanner System.in ;     public static void main String[] args     {       int bank = 1000;      assume the user has $1,000       int bet;              the bet entered by the user        System.out.println "You can bet between 1 and " +           bank ;       do       {           System.out.print "Enter your bet: " ;           bet = sc.nextInt  ;       } while    bet   bank   ;       System.out.println "Your money's good here." ;    } }  Here the expression used by the do-while loop validates the data entered by the  user, which means that it checks the data against some set of criteria to make sure  the data is acceptable.  The  operator performs an Or test. It returns true if at least one of the expres- sions on either side of the operator is true. So if the bet is less than or equal to zero   bet   bank , this  expression returns true.  This type of validation testing checks only whether the user entered a valid num- ber in an acceptable range. If the user entered something that isn’t a valid num- ber, such as the word Buttercup or Humperdinck, the program chokes badly and  spews forth a bunch of vile exception messages upon the console. You find out  how to clean up that mess in Book 2, Chapter 8.  CHAPTER 5  Going Around in Circles  Or, Using Loops       161    Actually, you can avoid this problem by using either a do loop or a while loop  and the hasNextDouble method of the Scanner class, which I describe in Book 2,  Chapter 2.   If you want to display an error message when the user enters incorrect input, you  have to use an if statement inside the loop, and this if statement must duplicate  the expression that validates the input data. Thus the expression that does the  validation has to appear twice. For example:  import java.util.Scanner;  public class GetABet2 {     static Scanner sc = new Scanner System.in ;    public static void main String[] args     {       int bank = 1000;      assume the user has $1,000       int bet;              the bet entered by the user        System.out.println            "You can bet between 1 and " + bank ;       do       {           System.out.print "Enter your bet: " ;           bet = sc.nextInt  ;           if    bet   bank                  System.out.println                    "What, are you crazy?" ;       } while    bet   bank   ;       System.out.println "Your money's good here." ;    } }  Here, the if statement displays the message "What, are you crazy?" if the user  tries to enter an inappropriate bet.  You can avoid duplicating the expression that does the data validation by adding a  boolean variable that’s set in the body of the do-while loop if the data is invalid,  as in this example:  import java.util.Scanner; public class GetABet3  162      BOOK 2  Programming Basics   {    static Scanner sc = new Scanner System.in ;    public static void main String[] args     {       int bank = 1000;      assume the user has $1,000       int bet;              the bet entered by the user       boolean validBet;     indicates if bet is valid       System.out.println            "You can bet between 1 and " + bank ;       do       {           System.out.print "Enter your bet: " ;           bet = sc.nextInt  ;           validBet = true;           if    bet   bank              {               validBet = false;               System.out.println                    "What, are you crazy?" ;           }       } while  !validBet ;       System.out.println "Your money's good here." ;    } }  In this example, I use a boolean variable named validBet to indicate whether the  user has entered a valid bet. After the user enters a bet, this variable is set to true  before  the  if  statement  tests  the  validation  criteria.  Then,  if  the  if  statement  finds that the bet is not valid, validBet is set to false.  Using the Famous for Loop  In addition to while and do-while loops, Java offers the for loop. You may have  noticed that many of the loops presented so far in this minibook involve counting.  It turns out that counting loops are quite common in computer programs, so the  people  who  design  computer  programming  languages   they’re  called  computer  programming language designers  long ago concocted a special kind of looping  mechanism that’s designed just for counting.  The basic principle behind a for loop is that the loop itself maintains a counter  variable — that is, a variable whose value increases each time the body of the loop  is executed. If you want a loop that counts from 1 to 10, you’d use a counter vari- able that starts with a value of 1 and is increased by 1 each time through the loop.  Then you’d use a test to end the loop when the counter variable reaches 10. The  for loop lets you set all this up in one convenient statement.  CHAPTER 5  Going Around in Circles  Or, Using Loops       163   People who majored in computer science call the counter variable an iterator. They  do so because they think that we don’t know what it means. But we know perfectly  well that the iterator is where you put your beer to keep it cold.  Understanding the formal   format of the for loop  I would now like to inform you of the formal format of the for loop, so that you’ll  know how to form it from now on. The for loop follows this basic format:  for  initialization-expression; test-expression; count-expression      statement;  The three expressions in the parentheses following the keyword for control how  the for loop works. The following paragraphs explain what these three expres- sions do:   » The initialization expression is executed before the loop begins. Usually, you  use this expression to initialize the counter variable. If you haven’t declared  the counter variable before the for statement, you can declare it here too.  » The test expression is evaluated each time the loop is executed to determine   whether the loop should keep looping. Usually, this expression tests the  counter variable to make sure that it is still less than or equal to the value you  want to count to. The loop keeps executing as long as this expression  evaluates to true. When the test expression evaluates to false, the loop  ends.   » The count expression is evaluated each time the loop executes. Its job is usually   to increment the counter variable.  Figure 5-3 shows a flowchart to help you visualize how a for loop works.  Here’s a simple for loop that displays the numbers 1 to 10 on the console:  public class CountToTen {     public static void main String[] args      {         for  int i = 1; i <= 10; i++              System.out.println i ;     } }  164      BOOK 2  Programming Basics   Run this program, and here’s what you see on the console:  FIGURE 5-3:   The flowchart for  a for loop.  1 2 3 4 5 6 7 8 9 10  This for loop has the following pieces:   » The initialization expression is int i = 1. This expression declares a variable   named i of type int and assigns it an initial value of 1.  CHAPTER 5  Going Around in Circles  Or, Using Loops       165    » The test expression is i <= 10. As a result, the loop continues to execute as   long as i is less than or equal to 10.   » The count expression is i++. As a result, each time the loop executes, the   variable i is incremented.   » The body of the loop is the single statement System.out.println i . As a  result, each time the loop executes, the value of the i variable is printed to the  console.  I made up the terms I use to describe the three expressions in a for loop. Offi- cially, Java calls them the ForInit expression, the expression, and the ForUpdate  expression. Don’t you think my terms are more descriptive?  Scoping out the counter variable  If  you  declare  the  counter  variable  in  the  initialization  statement,  the  scope  of  the counter variable is limited to the for statement itself. Thus, you can use the  variable in the other expressions that appear within the parentheses and in the  body of the loop, but you can’t use it outside the loop. This example code causes  a compiler error:  public class CountToTenError {    public static void main String[] args     {       for  int i = 1; i <=10; i++            System.out.println i ;       System.out.println "The final value of i is " +                           i ;    } }  That’s  because  the  last  statement  in  the  main  method  refers  to  the  variable  i,  which has gone out of scope because it was declared within the for loop.  You don’t have to declare the counter variable in the for statement itself, how- ever. The following program works:  public class CountToTenErrorFixed {    public static void main String[] args     {        int i;        for  i = 1; i <=10; i++             System.out.println i ;  166      BOOK 2  Programming Basics          System.out.println "The final value of i is " +                            i ;    } }  Note  that  because  the  i  variable  is  declared  before  the  for  statement,  the  ini- tialization expression doesn’t name the variable’s data type. When you run this  program, the following appears in the console window:  1 2 3 4 5 6 7 8 9 10 The final value of i is 11  Counting even numbers  Earlier in this chapter, you saw a program that counts even numbers up to 20. You  can do that with a for loop too. All you have to do is adjust the count expression.  Here’s a version of the CountEven program that uses a for loop:  public class ForEvenCounter {    public static void main String[] args     {        for  int number = 2; number <= 20; number += 2             System.out.print number + " " ;        System.out.println  ;    } }  Run this program, and sure enough, the console window displays the following:  2 4 6 8 10 12 14 16 18 20  CHAPTER 5  Going Around in Circles  Or, Using Loops       167   Counting backward  No rule says for loops can only count forward. To count backward, you simply  have to adjust the three for loop expressions. As usual, the initialization expres- sion specifies the starting value for the counter variable. The test expression uses  a greater-than test instead of a less-than test, and the count expression subtracts  from the counter variable rather than adding to it.  For example:  public class CountDown {    public static void main String[] args     {        for  int count = 10; count >= 1; count--         {                System.out.println count ;        }    } }  Run this program, and you see this result in the console window:  10 9 8 7 6 5 4 3 2 1  If you grew up in the 1960s watching NASA launches religiously, as I did, you’ll  appreciate this variation of the countdown program:  public class LaunchControl {    public static void main String[] args     {       System.out.print           "We are go for launch in T minus " ;       for  int count = 10; count >= 0; count--        {          if  count == 8              System.out.println  168      BOOK 2  Programming Basics                    "Ignition sequence start!" ;          else             System.out.println count + "..." ;       }       System.out.println "All engines running!" ;       System.out.println "Liftoff! We have a liftoff!" ;    } }  When you run it, here’s the output that’s displayed:  We are go for launch in T minus 10... 9... Ignition sequence start! 7... 6... 5... 4... 3... 2... 1... 0... All engines running! Liftoff! We have a liftoff!  Can’t you just hear the voice of Paul Haney, the famous “Voice of Mission Control”  for NASA in the 1960s? If you can’t, you’re not nearly as nerdy  or as old  as I am.  Using for loops without bodies  Some programmers get a kick out of writing code that is as terse as possible. I  think Seinfeld did an episode about that. Jerry had a girlfriend who was a “terse- coder,” and he had to dump her because he couldn’t understand her code.  Anyway, terse-coders sometimes like to play with for statements in an effort to  do away with the body of a for loop altogether. To do that, they take advantage of  the fact that you can code any expression you want in the count expression part of  a for statement, including method calls. Here’s a program that prints the num- bers 1 to 10 on the console, using a for statement that has no body:  public class TerseCoder {    public static void main String[] args     {       for  int i = 1; i <=10; System.out.println i++  ;    } }  CHAPTER 5  Going Around in Circles  Or, Using Loops       169   Here  the  count  expression  is  a  call  to  System.out.println.  The  parameter  to  the println method cleverly uses the increment operator, so the variable is both  printed and incremented in the same expression.  Stay away from terse-coders! Seinfeld was right to dump her.  Ganging up your expressions  An obscure aspect of for loops is the fact that the initialization and count expres- sions can actually be a list of expressions separated by commas. This can be use- ful if you need to keep track of two counter variables at the same time. Here’s a  program that counts from 1 to 10 and 10 to 1 at the same time, using two counter  variables:  public class CountBothWays {     public static void main String[] args      {         int a, b;         for  a = 1, b = 10; a <= 10; a++, b--              System.out.println a + " " + b ;     } }  If you run this program, here’s what you see in the console window:  1 10 2 9 3 8 4 7 5 6 6 5 7 4 8 3 9 2 10 1  Keep in mind these rules when you use more than one expression for the initial- ization and counter expressions:   » In the initialization expression, you can’t declare variables if you use more  than one expression. That’s why I declared the a and b variables before the  for statement in the CountBothWays example.  170      BOOK 2  Programming Basics    » The expressions in an expression list can be assignment statements, incre-  ment or decrement statements  such as a++ , method calls, or object creation  statements that use the new keyword to create an object from a class. Other  types of statements, such as if statements or loops, are not allowed.   » You can’t list more than one expression in the test expression. You can use   compound conditions created with boolean operators, however, so you don’t  need to use an expression list.  Here, just to prove that I can do it, is a version of the LaunchController program  that uses a bodiless for loop:  public class ExpressionGanging {    public static void main String[] args     {       System.out.print            "We are go for launch in T minus " ;       for  int count = 10; count >= 0;          System.out.println  count == 8  ?              "Ignition sequence start!" :              count + "..." ,          count--     ;       System.out.println "All engines running!" ;       System.out.println            "Liftoff! We have a liftoff!" ;    } }  This program actually looks more complicated than it is. The count expression  is a list of two expressions. First is a call to System.out.println that uses the  ternary ?: operator to determine what to print. The ?: operator first evaluates the  count variable to see if it equals 8. If so, the string "Ignition sequence start!"  is sent to the  println method. Otherwise,  count  +  "..." is sent. The second  expression simply increments the count variable.  I think you’ll agree that coding the for statement like this example is way out  of  line.  It’s  better  to  keep  the  expressions  simple  and  do  the  real  work  in  the  loop’s body.  Omitting expressions  Yet another oddity about for loops is that all three of the expressions are optional.  If you omit one or more of the expressions, you just code the semicolon as a place- holder so that the compiler knows what’s going on.  CHAPTER 5  Going Around in Circles  Or, Using Loops       171   Omitting the test expression or the iteration expression is not common, but omit- ting the initialization expression is common. The variable you’re incrementing in  the for loop may already be declared and initialized before you get to the loop, for  example. In that case, you can omit the initialization expression, like this:  Scanner sc = new Scanner System.in ; System.out.print "Where should I start? " ; int a = sc.nextInt  ; for   ; a >= 0; a--      System.out.println a ;  This for loop simply counts down from whatever number the user enters to zero.  If you omit the test expression, you’d better throw a break statement in the loop  somewhere  as described earlier in the chapter in the “Breaking Out of a Loop”  section . Otherwise you’ll find yourself in an infinite loop.  You can omit all three of the expressions if you want to, as in this example:  for ;;      System.out.println "Oops" ;  This program also results in an infinite loop. There’s little reason to do this, how- ever, because while true  has the same effect and is more obvious.  Breaking and continuing your for loops  You can use a break in a for loop just as you can in a while or do-while loop. Here  I revisit the Dodecaphobia program from earlier in the chapter, this time with a  for loop:  public class ForDodecaphobia {     public static void main String[] args      {         for  int number = 2; number <=20; number += 2          {             if  number == 12                  break;             System.out.print number + " " ;         }         System.out.println  ;     } }  172      BOOK 2  Programming Basics   As before, this version counts by 2 until it gets to 20. When it hits 12, however, it  panics and aborts the loop, so it never actually gets to 14, 16, 18, or 20. The console  output looks like this:  2 4 6 8 10  And here’s a version that uses a continue statement to skip 12 rather than abort  the loop:  public class ForDodecaphobia2 {     public static void main String[] args      {         for  int number = 2; number <=20; number += 2          {             if  number == 12                  continue;             System.out.print number + " " ;         }         System.out.println  ;     } }  The console output from this version looks like this:  2 4 6 8 10 14 16 18 20  Loops can contain loops. The technical term for this is loop-de-loop. Just kidding.  Actually, the technical term is nested loop, which is simply a loop that is completely  contained inside another loop. The loop that’s inside is called the inner loop, and  the loop that’s outside is called the outer loop.  A simple nested for loop  To demonstrate the basics of nesting, here’s a simple little program that uses a  pair of nested for loops:  public class NestedLoop {     public static void main String[] args   CHAPTER 5  Going Around in Circles  Or, Using Loops       173  Nesting Your Loops       {         for int x = 1; x < 10; x++          {             for  int y = 1; y < 10; y++                  System.out.print x + "-" + y + "  " ;             System.out.println  ;         }     } }  This program consists of two for loops. The outer loop uses x as its counter vari- able, and the inner loop uses y. For each execution of the outer loop, the inner  loop executes 10 times and prints a line that shows the value of x and y for each  pass through the inner loop. When the inner loop finishes, a call to System.out. println with no parameters forces a line break, thus starting a new line. Then the  outer loop cycles so that the next line is printed.  When you run this program, the console displays this text:  1-1  1-2  1-3  1-4  1-5  1-6  1-7  1-8  1-9 2-1  2-2  2-3  2-4  2-5  2-6  2-7  2-8  2-9 3-1  3-2  3-3  3-4  3-5  3-6  3-7  3-8  3-9 4-1  4-2  4-3  4-4  4-5  4-6  4-7  4-8  4-9 5-1  5-2  5-3  5-4  5-5  5-6  5-7  5-8  5-9 6-1  6-2  6-3  6-4  6-5  6-6  6-7  6-8  6-9 7-1  7-2  7-3  7-4  7-5  7-6  7-7  7-8  7-9 8-1  8-2  8-3  8-4  8-5  8-6  8-7  8-8  8-9 9-1  9-2  9-3  9-4  9-5  9-6  9-7  9-8  9-9  A guessing game  Listing 5-1 shows a more complicated but realistic example of nesting. This pro- gram implements a simple guessing game in which the computer picks a number  between 1 and 10, and you have to guess the number. After you guess, the com- puter tells you whether you’re right or wrong and then asks whether you want to  play again. If you enter Y or y, the game starts over.  The nesting comes into play because the entire game is written in a while loop  that repeats as long as you say you want to play another game. Then — within  that loop — each time the game asks for input from the user, it uses a do-while  loop to validate the user’s entry. Thus, when the game asks the user to guess a  number between 1 and 10, it keeps looping until the number entered by the user is  in that range. And when the game asks the user whether he or she wants to play  again, it loops until the user enters Y, y, N, or n.  174      BOOK 2  Programming Basics   Here’s a sample of the console output displayed by this program:  Let's play a guessing game!  I'm thinking of a number between 1 and 10. What do you think it is? 5 You're wrong! The number was 8  Play again?  Y or N y  I'm thinking of a number between 1 and 10. What do you think it is? 32 I said, between 1 and 10. Try again: 5 You're wrong! The number was 6  Play again?  Y or N maybe  Play again?  Y or N ok  Play again?  Y or N y  I'm thinking of a number between 1 and 10. What do you think it is? 5 You're right!  Play again?  Y or N n  Thank you for playing.  LISTING 5-1:   The Guessing Game  import java.util.Scanner; public class GuessingGame {     static Scanner sc = new Scanner System.in ;     public static void main String[] args      {         boolean keepPlaying = true;          System.out.println "Let's play a guessing game!" ;         while  keepPlaying           {             boolean validInput;              int number, guess;             String answer;                Pick a random number  →10  →13  →15   continued   CHAPTER 5  Going Around in Circles  Or, Using Loops       175   LISTING 5-1:    continued               number =  int  Math.random   * 10  + 1;                 Get the guess             System.out.println "\nI'm thinking of a number "                 + "between 1 and 10." ;             System.out.print "What do you think it is? " ;             do              {                 guess = sc.nextInt  ;                 validInput = true;                 if    guess   10                    {                     System.out.print                          "I said, between 1 and 10. "                         + "Try again: " ;                     validInput = false;                 }             } while  !validInput ;                 Check the guess             if  guess == number                   System.out.println "You're right!" ;             else                 System.out.println "You're wrong! " +                     "The number was " + number ;                Play again?             do              {                 System.out.print "\nPlay again?  Y or N " ;                 answer = sc.next  ;                 validInput = true;                 if  answer.equalsIgnoreCase "Y"  ;                 else if  answer.equalsIgnoreCase "N"                       keepPlaying = false;                 else                     validInput = false;             } while  !validInput ;          }          System.out.println "\nThank you for playing!" ;      } }  →20  →26  →36  →39  →46  →57 →58 →59  The following paragraphs describe some of the key lines in this program: →10       Defines a boolean variable named keepPlaying that’s initialized to  true and changed to false when the user indicates that he or she  has had enough of this silly game.  176      BOOK 2  Programming Basics   →13-58     Begins the main while loop for the game. The loop continues as long   as keepPlaying is true. This loop ends on line 58.  →15       Defines a boolean variable named validInput that’s used to   indicate whether the user’s input is valid. The same variable is used  for both the entry of the user’s guess and the Y or N string at the end  of each round.  →20       Picks a random number between 1 and 10. For more information on   random numbers, refer to Book 2, Chapter 3.  →26-36       Begins the do-while loop that gets a valid guess from the user. This  loop ends on line 36. The statements in this loop read the user’s guess  from the console and then test to make sure it is between 1 and 10. If  so, validInput is set to true. Otherwise, validInput is set to false,  an error message is displayed, and the loop repeats so that the user is  forced to guess again. The loop continues as long as validInput is  false.  →39      The if statement compares the user’s guess with the computer’s   number. A message is displayed to indicate whether the user guessed  right or wrong.  →46-57      Begins the do-while loop that asks whether the user wants to play  again. This loop ends on line 57. The statements in this loop read a  string from the user. If the user enters Y or y, validInput is set to  true.  keepPlaying is already true, so it is left alone.  If the user  enters N or n, validInput is set to true, and keepPlaying is set to  false. And if the user enters anything else, validInput is set to  false. The loop continues as long as validInput is false.  →59       This statement is executed after the program’s main while loop   finishes; it thanks the user for playing the game.  CHAPTER 5  Going Around in Circles  Or, Using Loops       177    IN THIS CHAPTER  » Avoiding the trouble with big else-if   statements   » Using the switch statement   » Creating case groups   » Using characters with case  Chapter 6 Pulling a Switcheroo  In  Book  2,  Chapter  4,  you  find  out  about  the  workhorses  of  Java  decision-   making:  boolean  expressions  and  the  mighty  if  statement.  In  this  chapter,  you discover another Java tool for decision-making: the switch statement. The  switch statement is a pretty limited beast, but it excels at making one particular  type of decision: choosing one of several actions based on a value stored in an  integer variable. As it turns out, the need to do just that comes up a lot. You want  to keep the switch statement handy for use when such a need arises.  Battling else-if Monstrosities  Many applications call for a simple logical selection of things to be done depend- ing on some value that controls everything. As I describe in Book 2, Chapter 4,  such things are usually handled with big chains of else-if statements all strung  together.  Unfortunately, these things can quickly get out of hand. else-if chains can end  up  looking  like  DNA  double-helix  structures  or  those  things  that  dribble  down  from the tops of the computer screens in The Matrix, with hundreds of lines of code  that string else-if after else-if. The switch statement provides a much more  concise alternative.  CHAPTER 6  Pulling a Switcheroo      179   Viewing an example else-if program  Listing 6-1 shows a bit of a program that might be used to decode error codes in a  Florida or Ohio voting machine.  LISTING 6-1:   The else-if Version of a Voting Machine Error Decoder  import java.util.Scanner; public class VoterApp {   static Scanner sc = new Scanner System.in ;   public static void main String[] args    {     System.out.println        "Welcome to the voting machine "       + "error code decoder.\n\n"       + "If your voting machine generates "       + "an error code,\n"       + "you can use this program to determine "       + "the exact\ncause of the error.\n" ;     System.out.print "Enter the error code: " ;      int err = sc.nextInt  ;      String msg;     if  err==1        msg = "Voter marked more than one candidate.\n"         + "Ballot rejected.";     else if  err==2        msg = "Box checked and write-in candidate "         + "entered.\nBallot rejected.";     else if  err==3        msg = "Entire ballot was blank.\n"         + "Ballot filled in according to "         + "secret plan.";     else if  err==4        msg = "Nothing unusual about the ballot.\n"         + "Voter randomly selected for tax audit.";     else if  err==5        msg = "Voter filled in every box.\n"         + "Ballot counted twice.";     else if  err==6        msg = "Voter drooled in voting machine.\n"         + "Beginning spin cycle.";     else if  err==7   180      BOOK 2  Programming Basics         msg = "Voter lied to pollster after voting.\n"         + "Voter's ballot changed "         + "to match polling data.";     else       msg = "Voter filled out ballot correctly.\n"         + "Ballot discarded anyway.";     System.out.println msg ;   } }  o o r e h c t i w S a g n        i l l  u P  Wow! And this program has to decipher just 7 error codes. What if the machine  had 500 codes?  Creating a better version   of the example program  Fortunately, Java has a special statement that’s designed just for the kind of task  represented by the voting machine error decoder program: the switch statement.  Specifically, the switch statement is useful when you need to select one of several  alternatives based on the value of an integer or character type variable.  Listing 6-2 shows a version of the voting machine error decoder program that  uses a switch statement instead of a big else-if structure. I think you’ll agree  that this version of the program is a bit easier to follow. The switch statement  makes it clear that all the messages are selected based on the value of the  err  variable.  LISTING 6-2:   The switch Version of the Voting Machine Error Decoder  import java.util.Scanner; public class VoterApp2 {   static Scanner sc = new Scanner System.in ;    public static void main String[] args    {     System.out.println        "Welcome to the voting machine "       + "error code decoder.\n\n"       + "If your voting machine generates "       + "an error code,\n"       + "you can use this program to determine "       + "the exact\ncause of the error.\n" ;     System.out.print "Enter the error code: " ;   continued   CHAPTER 6  Pulling a Switcheroo      181   LISTING 6-2:    continued       int err = sc.nextInt  ;      String msg;      switch  err      {       case 1:         msg = "Voter marked more than one "           + "candidate.\nBallot rejected.";         break;       case 2:         msg = "Box checked and write-in candidate "         + "entered.\nBallot rejected.";         break;       case 3:         msg = "Entire ballot was blank.\n"           + "Ballot filled in according to "           + "secret plan.";         break;       case 4:         msg = "Nothing unusual about the ballot.\n"           + "Voter randomly selected for tax audit.";         break;       case 5:         msg = "Voter filled in every box.\n"           + "Ballot counted twice.";         break;       case 6:         msg = "Voter drooled in voting machine.\n"           + "Beginning spin cycle.";         break;       case 7:         msg = "Voter lied to pollster after voting.\n"           + "Voter's ballot changed "           + "to match polling data.";         break;       default:         msg = "Voter filled out ballot correctly.\n"           + "Ballot discarded anyway.";         break;     }     System.out.println msg ;   } }  182      BOOK 2  Programming Basics   Using the switch Statement  The basic form of the switch statement is this:  switch  expression  {   case constant: statements;         break;   [ case constant-2: statements;         break;  ]...   [ default: statements;         break;  ]... }  o o r e h c t i w S a g n        i l l  u P  The expression must evaluate to an int, short, byte, or char. It can’t be a long  or a floating-point type.  You can code as many case groups as you want or need. Each group begins with  the word case, followed by a constant  usually, a simple numeric literal  and a  colon. Then you code one or more statements that you want executed if the value  of the switch expression equals the constant. The last line of each case group is a  break statement, which causes the entire switch statement to end.  The  default group, which is optional, is like a catch-all case group. Its state- ments are executed only if none of the previous case constants match the switch  expression.  Note that the case groups are not true blocks marked with braces. Instead, each  case group begins with the case keyword and ends with the case keyword that  starts the next case group. All the case groups together, however, are defined as a  block marked with a set of braces.  The last statement in each case group usually is a break statement. A break state- ment causes control to skip to the end of the switch statement. If you omit the  break statement, control falls through to the next case group. Accidentally leav- ing out break statements is the most common cause of trouble with the switch  statement.  CHAPTER 6  Pulling a Switcheroo      183   Viewing a boring switch example,   complete with flowchart  Okay, the voting machine error decoder was kind of fun. Here’s a more down-to-  earth example. Suppose that you need to set a commission rate based on a sales  class represented by an integer  1, 2, or 3  according to this table:  Class  Commission Rate  1  2  3  Any other value  2%  3.5%  5%  0%  You could do this with the following switch statement:  double commissionRate; switch  salesClass  {     case 1:         commissionRate = 0.02;         break;     case 2:         commissionRate = 0.035;         break;     case 3:         commissionRate = 0.05;         break;     default:         commissionRate = 0.0;         break; }  Figure  6-1  shows  a  flowchart  that  describes  the  operation  of  this  switch  statement. As you can see, this flowchart is similar to the flowchart in Figure 4-3   Book 2, Chapter 4 , because the operation of the switch statement is similar to  the operation of a series of else-if statements.  Flowcharts  remind  me  of  the  good  old  days,  when  many  COBOL  programming  shops  required  their  programmers  to  draw  flowcharts  for  every  program  they  wrote  before  they  were  allowed  to  write  any  code.  The  flowcharts  didn’t  really  help programmers write better programs, but they were fun to draw.  184      BOOK 2  Programming Basics   o o r e h c t i w S a g n        i l l  u P  FIGURE 6-1:   The flowchart  for a switch   statement.  Putting if statements inside   switch statements  You’re free to include any type of statements you want in the case groups, includ- ing if statements. Suppose that your commission structure depends on total sales  as well as sales class, as in this table:  Class  Sales < $10,000  Sales $10,000 and Above  1  2  3  Any other value  1%  2.5%  4%  0%  2%  3.5%  5%  0%  CHAPTER 6  Pulling a Switcheroo      185   You can use the following switch statement:  double commissionRate; switch  salesClass  {     case 1:         if  salesTotal < 10000.0              commissionRate = 0.01;         else             commissionRate = 0.02;         break;     case 2:         if  salesTotal < 10000.0              commissionRate = 0.025;         else             commissionRate = 0.035;         break;     case 3:         if  salesTotal < 10000.0              commissionRate = 0.04;         else             commissionRate = 0.05;         break;     default:         commissionRate = 0.0;         break; }  Here each case group includes an if statement. If necessary, these if statements  could be complex nested if statements.  Other than the if statements within the case groups, there’s nothing here to see,  folks. Move along.  Creating Character Cases  Aside from having a nice alliterative title, this section shows how you can use a  char variable rather than an integer in a switch statement. When you use a char  type, providing two consecutive case constants for each case group is common,  to allow for both lowercase and uppercase letters. Suppose that you need to set  the commission rates for the sales class based on character codes rather than on  integer values, according to this table:  186      BOOK 2  Programming Basics   o o r e h c t i w S a g n        i l l  u P  Commission Rate  Class  A or a  B or b  C or c  Any other value  2%  3.5%  5%  0%  Here’s a switch statement that can do the trick:  double commissionRate; switch  salesClass  {     case 'A':     case 'a':         commissionRate = 0.02;         break;     case 'B':     case 'b':         commissionRate = 0.035;         break;     case 'C':     case 'c':         commissionRate = 0.05;         break;     default:         commissionRate = 0.0;         break; }  The key to understanding this example is realizing that you don’t have to code  any statements at all for a case group — and that if you omit the break statement  from a case group, control falls through to the next case group. Thus the case 'A'  group doesn’t contain any statements, but control falls through to the case 'a'  group.  You use apostrophes, not quotation marks, to create character literals.  CHAPTER 6  Pulling a Switcheroo      187   Intentionally Leaving Out   a Break Statement  Although the most common cause of problems with the switch statement is acci- dentally leaving out a break statement at the end of a case group, sometimes you  need to do it on purpose. Many applications have features that are progressively  added based on a control variable. Your local car wash, for example, may sell sev- eral packages with different services, as in this table:  Package  Services  A  B  C  D  E  Wash, vacuum, and hand-dry  Package A + wax  Package B + leather vinyl treatment  Package C + tire treatment  Package D + new-car scent  Listing 6-3 shows an application that displays all the products you get when you  order a specific package. It works by testing the package codes in a switch state- ment  in  reverse  order   starting  with  package  E   and  adding  the  products  that  come with each package to the details variable. None of the case groups except  the last includes a break statement. As a result, control falls through each case  group to the next group. Thus, once a case group has tested true, the rest of the  case groups in the switch statement are executed.  LISTING 6-3:   The Car Wash Application  import java.util.Scanner;  public class CarWashApp {   static Scanner sc = new Scanner System.in ;    public static void main String[] args    {     System.out.println        "The car wash application!\n\n" ;     System.out.print "Enter the package code: " ;     String s = sc.next  ;     char p = s.charAt 0 ;      String details = "";  188      BOOK 2  Programming Basics   o o r e h c t i w S a g n        i l l  u P      switch  p      {       case 'E':       case 'e':         details += "\tNew Car Scent, plus ... \n";       case 'D':       case 'd':         details += "\tTire Treatment, plus ... \n";       case 'C':       case 'c':       details +=         "\tLeather Vinyl Treatment, plus ... \n";       case 'B':       case 'b':         details += "\tWax, plus ... \n";       case 'A':       case 'a':         details += "\tWash, vacuum, and hand dry.\n";         break;       default:         details = "That's not one of the codes.";         break;     }     System.out.println "\nThat package includes:\n" ;     System.out.println details ;   } }  Just between you and me, writing programs that depend on switch statements  falling through the cracks  as in this example  isn’t really a good idea. Instead,  consider placing the statements for each case group in separate methods and then  calling all the methods you need for each case group. Then you can use a break  statement at the end of each group to prevent falling through. Listing 6-4 shows  a  version  of  the  car  wash  application  that  uses  this  technique  to  prevent  fall- throughs in the switch statement.  Using simple fall-throughs to treat uppercase  and lowercase characters the same way isn’t as confusing, so this program still  uses that technique.   LISTING 6-4:  A Version of the Car Wash Program That Prevents Nasty Falls  import java.util.Scanner;  public class CarWashApp2 {   static Scanner sc = new Scanner System.in ;   public static void main String[] args    continued   CHAPTER 6  Pulling a Switcheroo      189   LISTING 6-4:    continued     {     System.out.println        "The car wash application!\n\n" ;     System.out.print "Enter the package code: " ;     String s = sc.next  ;     char p = s.charAt 0 ;      String details = "";     switch  p      {       case 'E':       case 'e':         details = packageE   + packageD   + packageC             + packageB   + packageA  ;         break;       case 'D':       case 'd':         details = packageD   + packageC             + packageB   + packageA  ;         break;       case 'C':       case 'c':         details = packageC   + packageB             + packageA  ;         break;       case 'B':       case 'b':         details = packageB   + packageA  ;         break;       case 'A':       case 'a':         details = packageA  ;         break;       default:         details = "That's not one of the codes.";         break;     }     System.out.println "\nThat package includes:\n" ;     System.out.println details ;   }    public static String packageA     {     return "\tWash, vacuum, and hand dry.\n";   }    public static String packageB    190      BOOK 2  Programming Basics     {     return "\tWax, plus ... \n";   }    public static String packageC     {     return "\tLeather Vinyl Treatment, plus ... \n";   }    public static String packageD     {     return "\tTire Treatment, plus ... \n";   }    public static String packageE     {     return "\tNew Car Scent, plus ... \n";   } }  o o r e h c t i w S a g n        i l l  u P  Switching with Strings  Beginning with Java 1.7, the expression in the switch statement can evaluate to a  String value. Listing 6-5 shows a version of the car wash program that uses the  string codes PRESIDENTIAL, ELITE, DELUXE, SUPER, and STANDARD as the car wash  types, instead of the letters A through E. Notice that to allow for variations in how  a  user  might  capitalize  these  codes,  the  user’s  input  is  converted  to  all  capital  letters before it is tested against the string constants in the switch statement.  LISTING 6-5:  A Version of the Car Wash Program That Uses a String  import java.util.Scanner;  public class CarWashStringApp {     static Scanner sc = new Scanner System.in ;      public static void main String[] args      {         System.out.println "The car wash application\n\n" ;         System.out.print "Enter the package code: " ;         String s = sc.next  ;          String details = "";  CHAPTER 6  Pulling a Switcheroo      191   continued    LISTING 6-5:    continued           switch  s.toUpperCase            {             case "PRESIDENTIAL":                 details += "\tNew Car Scent, plus ... \n";             case "ELITE":                 details += "\tTire Treatment, plus ... \n";             case "DELUXE":                 details += "\tLeather Vinyl Treatment, plus ... \n";             case "SUPER":                 details += "\tWax, plus ... \n";             case "STANDARD":                 details += "\tWash, vacuum, and hand dry.\n";                 break;             default:                 details = "That's not one of the codes.";                 break;         }         System.out.println "\nThat package includes:\n" ;         System.out.println details ;     } }  192      BOOK 2  Programming Basics   IN THIS CHAPTER  » Introducing static methods   » Seeing some good reasons to use   methods in your programs   » Creating methods that return values   » Creating methods that accept   parameters  Chapter 7 Adding Some Methods  to Your Madness  In Java, a method is a block of statements that has a name and can be executed by   calling  also called invoking  it from some other place in your program. You may  not realize it, but you’re already very experienced in using methods. To print  text to the console, for example, you use the println or print method. To get an  integer from the user, you use the  nextInt method. To compare string values,  you use the equals or equalsIgnore Case method. Finally, the granddaddy of all  methods — main — contains the statements that are executed when you run your  program.  All the methods you’ve used so far  with the exception of main  have been defined  by the Java API and belong to a particular Java class. The nextInt method belongs  to the Scanner class, for example, and the equalsIgnoreCase method belongs to  the String class. By contrast, the main method belongs to the class defined by  your application.  In this chapter, you find out how to create additional methods that are part of your  application’s class. Then you can call these methods from your main method. As  you’ll see, this technique turns out to be very useful for all but the shortest Java  programs.  CHAPTER 7  Adding Some Methods to Your Madness      193   The Joy of Methods  The use of methods can dramatically improve the quality of your programming  life. Suppose that the problem your program is supposed to solve is complicated,  and you need at least 1,000 Java statements to get ’er done. You could put all those  1,000 statements in the main method, but it would go on for pages and pages. It’s  better to break your program into a few well-defined sections of code and place  each of those sections in a separate method. Then your main method can simply  call the other methods in the right sequence.  Or suppose that your program needs to perform some calculation, such as how  long to let the main rockets burn to make a midcourse correction on a moon flight,  and  the  program  needs  to  perform  this  calculation  in  several  places.   Without  methods,  you’d  have  to  duplicate  the  statements  that  do  this  calculation.  That  approach is not only error-prone, but also makes your programs more difficult to  test and debug. But if you put the calculation in a method, you can simply call the  method whenever you need to perform the calculation. Thus methods help you cut  down on repetitive code.  Another good use for methods is to simplify the structure of your code that uses  long loops. Suppose you have a while loop that has 500 statements in its body.  That structure makes it pretty hard to track down the brace that marks the end of  the body. By the time you find it, you probably will have forgotten what the while  loop does. You can simplify this while loop by placing the code from its body in a  separate method. Then all the while loop has to do is call the new method.  At this point, the object-oriented programming zealots in the audience are start- ing to boo and hiss. A few of them have already left the auditorium. They’re upset  because  I’m  describing  methods  in  traditional  procedural-programming  terms  instead of modern object-oriented programming terms.  Well,  phooey.  They’re  right,  but  so  what?  I  get  to  the  object-oriented  uses  for  methods in Book 3. There, you find out that methods have a far greater purpose  than simply breaking a long main method into smaller pieces. Even so, some of the  most object-oriented programs I know use methods just to prevent repetitive code  or to slice a large method into a couple of smaller ones. So there.  194      BOOK 2  Programming Basics   The Basics of Making Methods  All methods — including the main method — must begin with a method  declaration.  Here’s the basic form of a method declaration, at least for the types of methods I  talk about in this chapter:  public static return-type method-name  parameter-list  {     statements... }  The following paragraphs describe the method declaration piece by piece:   » public: This keyword indicates that the method’s existence should be   publicized to the world and that any Java program that knows about your  program  or, more accurately, the class defined for your Java program  should  be able to use your method. That’s not very meaningful for the types of  programs you’re dealing with at this point in the book, but it becomes more  meaningful in Book 3: There you find out more about what public means  and see some alternatives to public that are useful in various and sundry  situations.   » static: This keyword declares that the method is a static method, which means   that you can call it without first creating an instance of the class in which it’s  defined. The main method must always be static, and any other methods in  the class that contains the main method usually should be static as well.   » return-type: After the word static comes the return type, which indicates  whether the method returns a value when it is called and, if so, what type the  value is. If the method doesn’t return a value, specify void.  I talk more about  methods that return values later in this chapter, in the section “Methods That  Return Values.”    » method-name: Now comes the name of your method. The rules for making  up method names are the same as the rules for creating variable names: You  can use any combination of letters and numbers, but the name has to start  with a letter. Also, it can include the dollar sign  $  and underscore character   _ . No other special characters are allowed.  When picking a name for your method, try to pick a name that’s relatively  short but descriptive. A method name such as calculateTheTotalAmount  OfTheInvoice is a little long, but just calc is pretty ambiguous. Something  along the lines of calculateInvoiceTotal seems more reasonable to me.  CHAPTER 7  Adding Some Methods to Your Madness      195    » parameter list: You can pass one or more values to a method by listing the  values in parentheses following the method name. The parameter list in the  method declaration lets Java know what types of parameters a method should  expect to receive and provides names so that the statements in the method’s  body can access the parameters as local variables. You discover more about  parameters in the section “Methods That Take Parameters,” later in this  chapter.  If the method doesn’t accept parameters, you must still code the parentheses  that surround the parameter list. You just leave the parentheses empty.   » Method body: The method body consists of one or more Java statements   enclosed in a set of braces. Unlike Java statements such as if, while, and for,  the method body requires you to use the braces even if the body consists of  only one statement.  An example  Okay, all that was a little abstract. Now, for a concrete example, I offer a version  of the Hello, World! program in which the message is displayed not by the main  method, but by a method named sayHello that’s called by the main method:  public class HelloWorldMethod {     public static void main String[] args      {         sayHello  ;     }     public static void sayHello       {         System.out.println "Hello, World!" ;     } }  This  program  is  admittedly  trivial,  but  it  illustrates  the  basics  of  creating  and  using methods in Java. Here, the statement in the main method calls the sayHello  method, which in turn displays a message on the console.  The order in which methods appear in your Java source file doesn’t matter. The  only rule is that all the methods must be declared within the body of the class —  that is, between the first left brace and the last right brace. Here’s a version of the  HelloWorldMethod program in which I reverse the order of the methods:  196      BOOK 2  Programming Basics   public class HelloWorldMethod {     public static void sayHello       {         System.out.println "Hello, World!" ;     }     public static void main String[] args      {         sayHello  ;     } }  This version of the program works exactly like the preceding version.  Another example  Okay, the last example was kind of dumb. No one in his  or her  right mind would  create a method that has just one line of code and then call it from another method  that also has just one line of code. The Hello,  World! program is too trivial to  illustrate anything remotely realistic.  A program in Book 2, Chapter 5, plays a guessing game. Most of this program’s  main method is a large while loop that repeats the game as long as the user wants  to keep playing. This loop has 41 statements in its body. That’s not so bad, but  what if the game were 100 times more complicated, so that the while loop needed  4,100 statements to play a single cycle of the game? Do you really want a while  loop that has 4,100 statements in its body? I should think not.  Listing 7-1 shows how you can simplify this game a bit just by placing the body  of the main while loop in a separate method. I called this method playARound,  because its job is to play one round of the guessing game. Now, instead of actually  playing a round of the game, the main method of this program delegates that task  to the playARound method.  LISTING 7-1:  A Version of the Guessing-Game Program    That Uses a playARound Method  import java.util.Scanner;  public class GuessingGameMethod {    static Scanner sc = new Scanner System.in ;    static boolean keepPlaying = true;     public static void main String[] args     {  →7   continued   CHAPTER 7  Adding Some Methods to Your Madness      197   LISTING 7-1:    continued         System.out.println "Let's play a guessing game!" ;  →12  →14  →19        while  keepPlaying         {           playARound  ;        }       System.out.println "\nThank you for playing!" ;    }    public static void playARound       {       boolean validInput;       int number, guess;       String answer;           Pick a random number       number =  int  Math.random   * 10  + 1;       System.out.println "\nI'm thinking of a number "           + "between 1 and 10." ;           Get the guess       System.out.print "What do you think it is? " ;       do       {           guess = sc.nextInt  ;           validInput = true;           if   guess   10             {               System.out.print "I said, between 1 "                   + "and 10. Try again: " ;               validInput = false;           }       } while  !validInput ;           Check the guess       if  guess == number            System.out.println "You're right!" ;       else           System.out.println "You're wrong!"               + " The number was " + number ;          Play again?       do       {           System.out.print "\nPlay again?  Y or N " ;           answer = sc.next  ;           validInput = true;           if  answer.equalsIgnoreCase "Y"  ;           else if  answer.equalsIgnoreCase "N"    198      BOOK 2  Programming Basics                 keepPlaying = false;            else               validInput = false;       } while  !validInput ;    } }  →60  Here are a few important details to notice about this method:  →7    Because both the main method  in line 12  and the playARound method    in line 60  must access the keepPlaying variable, I declare it as a class  variable rather than as a local variable in the main method.            Class variables must be static if you intend to access them from static   methods.   →14    The body of the while loop in the main method is just one line: a call to  the playARound method. Thus, each time the loop repeats, the program  plays one round of the game with the user.   →19    The declaration for the playARound method marks the method as   static so that the static main method can call it.  The body of the playARound method is identical to the body of the while loop used  in the single-method version of this program shown in Book 2, Chapter 5. If you  want a refresher on how this code works, I politely refer you to Listing 5-1, near  the end of that chapter.  Methods that just do work without returning any data are useful only in limited  situations. The real utility of methods comes when they can perform some mun- dane task such as a calculation and then return the value of that calculation to the  calling method so that the calling method can do something with the value. You  find out how to do that in the following sections.  Declaring the method’s return type  To create a method that returns a value, you simply indicate the type of the value  returned by the method on the method declaration in place of the void keyword.  Here’s a method declaration that creates a method that returns an int value:  public static int getRandomNumber    CHAPTER 7  Adding Some Methods to Your Madness      199  Methods That Return Values   Here the getRandomNumber method calculates a random number and then returns  the number to the caller.  The return type of a method can be any of Java’s primitive return types  described  in Book 2, Chapter 2 :  int long float char short byte double boolean  Alternatively, the return type can be a reference type, including a class defined by  the API such as String or a class you create yourself.  Using the return statement   to return the value  When you specify a return type other than void in a method declaration, the body  of  the  method  must  include  a  return  statement  that  specifies  the  value  to  be  returned. The return statement has this form:  return expression;  The expression must evaluate to a value that’s the same type as the type listed in  the method declaration. In other words, if the method returns an int, the expres- sion in the return statement must evaluate to an int.  Here’s a program that uses a method that determines a random number between  1 and 10:  public class RandomNumber {     public static void main String[] args      {         int number = getRandomNumber  ;         System.out.println "The number is " + number ;     }     public static int getRandomNumber       {         int num =  int  Math.random   * 10  + 1;  200      BOOK 2  Programming Basics           return num;     } }  In this program, the getRandomNumber method uses the Math.random method to  calculate a random number from 1 to 10.  For more information about the Math. random method, see Book 2, Chapter 3.  The return statement returns the random  number that was calculated.  Because the return statement can specify an expression as well as a simple vari- able, I could just as easily have written the getRandomNumber method like this:  public static int getRandomNumber   {     return  int  Math.random   * 10  + 1; }  Here  the  return  statement  includes  the  expression  that  calculates  the  random  number.  Using a method that returns a type  You can use a method that returns a value in an assignment statement, like this:  int number = getRandomNumber  ;  Here the getRandomNumber method is called, and the value it returns is assigned  to the variable number.  You can also use methods that return values in expressions — such as  number = getRandomNumber   * 10;  Here the value returned by the getRandomNumber method is multiplied by 10, and  the result is assigned to number.  You gotta have a proper return statement  If a method declares a return type other than void, it must use a return state- ment to return a value. The compiler doesn’t let you get away with a method that  doesn’t have a correct return statement.  CHAPTER 7  Adding Some Methods to Your Madness      201   Things can get complicated if your return statements are inside if statements.  Sometimes,  the  compiler  gets  fooled  and  refuses  to  compile  your  program.  To  explain this situation, I offer the following tale of multiple attempts to solve what  should be a simple programming problem.  Suppose that you want to create a random-number method that returns random  numbers between 1 and 20 but never returns 12  because you have the condition  known as dodecaphobia, which — as Lucy from Peanuts would tell you — is the  fear of the number 12 . Your first thought is to just ignore the 12s, like this:  public static int getRandomNumber   {     int num =  int  Math.random   * 20  + 1;     if  num != 12          return num; }  The  compiler  isn’t  fooled  by  your  trickery  here,  however.  It  knows  that  if  the  number is 12, the return statement won’t get executed, so it issues the message  missing return statement and refuses to compile your program.  Your next thought is to simply substitute 11 whenever 12 comes up:  public static int getRandomNumber    {     int num =  int  Math.random   * 20  + 1;     if  num != 12          return num;     else         return 11; }  Later that day, you realize that this solution isn’t a good one because the number  isn’t really random anymore. One of the requirements of a good random-number  generator is that any number should be as likely as any other number to come up  next. But because you’re changing all 12s to 11s, you’ve made 11 twice as likely to  come up as any other number.  To fix this error, you decide to put the random-number generator in a loop that  ends only when the random number is not 12:  public static int getRandomNumber   {     int num;  202      BOOK 2  Programming Basics       do     {         num =  int  Math.random   * 20  + 1;         if  num != 12              return num;     } while  num == 12 ; }  But the compiler refuses to compile the method again. It turns out that the com- piler is smart, but not very smart. It doesn’t catch the fact that the condition in the  do-while loop is the opposite of the condition in the if statement, meaning that  the only way out of this loop is through the return statement in the if statement.  So the compiler whines missing return statement again.  After thinking about it for a while, you come up with this solution:  public static int getRandomNumber   {     int num;     while  true      {         num =  int  Math.random   * 20  + 1;         if  num != 12              return num;     } }  Now  everyone’s  happy.  The  compiler  knows  that  the  only  way  out  of  the  loop  is through the return statement, your dodecaphobic user doesn’t have to worry  about seeing the number 12, and you know that the random number isn’t twice  as likely to be 11 as any other number. Life is good, and you can move on to the  next topic.  Trying another version of the   guessing-game program  To illustrate the benefits of using methods that return values, Listing 7-2 pres- ents another version of the guessing-game program that uses four methods in  addition to main:   » playARound: This method plays one round of the guessing game. It doesn’t    » getRandomNumber: This method returns a random number between    return a value.  1 and 10.  CHAPTER 7  Adding Some Methods to Your Madness      203    » getGuess: This method gets the user’s guess, makes sure that it is between   1 and 10, and returns the guess if it’s within the acceptable range.   » askForAnotherRound: This method asks the user to play another round   and returns a boolean value to indicate whether the user wants to continue  playing.  LISTING 7-2:  Another Version of the Guessing-Game Program  import java.util.Scanner;  public class GuessingGameMethod2 {    static Scanner sc = new Scanner System.in ;     public static void main String[] args     {       System.out.println "Let's play a guessing game!" ;       do        {          playARound  ;        } while  askForAnotherRound   ;        System.out.println "\nThank you for playing!" ;    }     public static void playARound       {       boolean validInput;       int number, guess;       String answer;           Pick a random number       number = getRandomNumber  ;            Get the guess       System.out.println "\nI'm thinking of a number "          + "between 1 and 10." ;       System.out.print "What do you think it is? " ;       guess = getGuess  ;      Check the guess       if  guess == number           System.out.println "You're right!" ;       else          System.out.println "You're wrong!"             + " The number was " + number ;    }  →11  →13 →14  →18  →25  →31  204      BOOK 2  Programming Basics      public static int getRandomNumber       {       return  int  Math.random   * 10  + 1;     }    public static int getGuess       {       while  true         {          int guess = sc.nextInt  ;          if   guess   10            {             System.out.print "I said, between 1 and 10. "                 + "Try again: " ;          }          else             return guess;        }    }     public static boolean askForAnotherRound       {       while  true         {          String answer;          System.out.print "\nPlay again?  Y or N  " ;          answer = sc.next  ;          if  answer.equalsIgnoreCase "Y"                return true;           else if  answer.equalsIgnoreCase "N"               return false;        }    } }  →41  →43  →46  →48  →57  →61  →63  →69  →71  The following paragraphs point out the key lines of this program:  →11    The start of the do loop in the main method. Each cycle of this do loop   plays one round of the game. The do loop continues until the user  indicates that he or she wants to stop playing.   →13   Calls the playARound method to play one round of the game.  →14    Calls the askForAnotherRound method to determine whether the user  wants to play another round. The boolean return value from this method  is used as the expression for the do loop. Thus, the do loop repeats if the  askForAnotherRound method returns true.  CHAPTER 7  Adding Some Methods to Your Madness      205    →18   The start of the playARound method.  →25    Calls the getRandomNumber method to get a random number between   1 and 10. The value returned by this method is stored in the number  variable.   →31    Calls the getGuess method to get the user’s guess. This method returns a   number between 1 and 10, which is stored in the guess variable.   →41    The start of the getRandomNumber method, which indicates that this   method returns an int value.   →43    The return statement for the getRandomNumber method. The random  number is calculated using the Math.random method, and the result of  this calculation is returned as the value of the getRandomNumber method.   →46    The start of the getGuess method, which indicates that this method   returns an int value.   →48    The getGuess method uses a while loop, which exits only when the user   enters a number between 1 and 10.   →57    The return statement for the getGuess method. Note that this return   statement is in the else part of an if statement that checks whether  the number is less than 1 or greater than 10. If the number is outside the  acceptable range, the return statement isn’t executed. Instead, the  program displays an error message, and the while loop repeats.   →61    The start of the askForAnotherRound method, which returns a boolean    →63    The askForAnotherRound method, which uses a while loop that exits   only when the user enters a valid Y or N response.   →69    The askForAnotherRound method, which returns true if the user enters    value.  Y or y.   →71    The askForAnotherRound method, which returns false if the user   enters N or n.  Methods That Take Parameters  A parameter is a value that you can pass to a method. Then the method can use the  parameter as though it were a local variable initialized with the value of the vari- able passed to it by the calling method.  The  guessing-game  application  shown  in  Listing  7-2  has  a  method  named  getRandomNumber that returns a random number between 1 and 10:  206      BOOK 2  Programming Basics   public static int getRandomNumber   {     return  int  Math.random   * 10  + 1; }  This method is useful, but it would be even more useful if you could tell it the  range of numbers you want the random number to fall in. It would be nice to call  the method like this to get a random number between 1 and 10:  int number = getRandomNumber 1, 10 ;  Then, if your program needs to roll dice, you could call the same method:  int number = getRandomNumber 1, 6 ;  Or, to pick a random card from a deck of 52 cards, you could call it like this:  int number = getRandomNumber 1, 52 ;  You wouldn’t have to start with 1, either. To get a random number between 50 and  100, you’d call the method like this:  int number = getRandomNumber 50, 100 ;  In the following sections, you write methods that accept parameters.  Declaring parameters  A method that accepts parameters must list the parameters in the method dec- laration.  The  parameters  are  placed  in  a  parameter  list  inside  the  parentheses  that follow the method name. For each parameter used by the method, you list  the parameter type followed by the parameter name. If you need more than one  parameter, you separate the parameters with commas.  Here’s a version of the getRandomNumber method that accepts parameters:  public static int getRandomNumber int min, int max  {     return  int  Math.random           *  max - min + 1   + min; }  CHAPTER 7  Adding Some Methods to Your Madness      207   Here  the  method  uses  two  parameters,  both  of  type  int,  named  min  and  max.  Then, within the body of the method, these parameters can be used as though they  were local variables.  The names you use for parameters can be the same as the names you use for the  variables you pass to the method when you call it, but they don’t have to be. You  could call the getRandomNumber method like this:  int min = 1; int max = 10; int number = getRandomNumber min, max ;  Or you could call it like this:  int low = 1; int high = 10; int number = getRandomNumber low, high ;  Or you could dispense with the variables altogether and just pass literal values to  the method:  int number = getRandomNumber 1, 10 ;  You can also specify expressions as the parameter values:  int min = 1; int max = 10; int number = getRandomNumber min * 10, max * 10 ;  Here number is assigned a value between 10 and 100.  Scoping out parameters  The scope of a parameter is the method for which the parameter is declared. As a  result, a parameter can have the same name as local variables used in other meth- ods without causing any conflict. Consider this program:  public class ParameterScope {     public static void main String[] args      {         int min = 1;         int max = 10;         int number = getRandomNumber min, max ;  208      BOOK 2  Programming Basics           System.out.println number ;     }  public static int getRandomNumber int min, int max      {         return  int  Math.random               *  max - min + 1   + min;     } }  Here the main method declares variables named min and max, and the getRandom  Number method uses min and max for its parameter names. This doesn’t cause any  conflict, because in each case the scope is limited to a single method.  Understanding pass-by-value  When Java passes a variable to a method via a parameter, the method itself receives  a copy of the variable’s value, not the variable itself. This copy is called a pass-  by-value, and it has an important consequence: If a method changes the value it  receives as a parameter, that change is not reflected in the original variable that  was passed to the method. The following program can help clear this up:  public class ChangeParameters {     public static void main String[] args      {         int number = 1;         tryToChangeNumber number ;         System.out.println number ;     }      public static void tryToChangeNumber int i      {         i = 2;     } }  Here a variable named number is set to 1 and then passed to the method named  tryToChangeNumber. This method receives the variable as a parameter named i  and then sets the value of i to 2. Meanwhile, back in the main method, println is  used to print the value of number after the tryToChangeNumber method returns.  Because tryToChangeNumber gets only a copy of number, not the number variable  itself, this program displays the following on the console  drum roll, please . . . : 1.  CHAPTER 7  Adding Some Methods to Your Madness      209   The key point is this: Even though the tryToChangeNumber method changes the  value of its parameter, that change has no effect on the original variable that was  passed to the method.  Trying yet another version of the   guessing-game program  To show off the benefits of methods that accept parameters, Listing 7-3 shows  one more version of the guessing-game program. This version uses the following  methods in addition to main:   » playARound: This method plays one round of the guessing game. It doesn’t  return a value, but it accepts two arguments, min and max, that indicate the  minimum and maximum values for the number to be guessed.   » getRandomNumber: This method returns a random number between min and   max values passed as parameters.   » getGuess: This method also accepts two parameters, min and max, to limit the   range within which the user must guess.   » askForAnotherRound: This method asks the user to play another round and   returns a boolean value to indicate whether the user wants to continue  playing. It accepts a String value as a parameter; this string is displayed on  the console to prompt the user for a reply.  LISTING 7-3:   Yet Another Version of the Guessing-Game Program  import java.util.Scanner;  public class GuessingGameMethod3 {     static Scanner sc = new Scanner System.in ;    public static void main String[] args     {       System.out.println "Let's play a guessing game!" ;       do       {           playARound 1, getRandomNumber 7, 12  ;        } while  askForAnotherRound "Try again?"  ;       System.out.println "\nThank you for playing!" ;    }    public static void playARound int min, int max     {  →13  210      BOOK 2  Programming Basics         boolean validInput;       int number, guess;       String answer;           Pick a random number       number = getRandomNumber min, max ;           Get the guess       System.out.println "\nI'm thinking of a number "           + "between " + min + " and " + max + "." ;        System.out.print "What do you think it is? " ;       guess = getGuess min, max ;            Check the guess       if  guess == number            System.out.println "You're right!" ;       else           System.out.println "You're wrong!"               + " The number was " + number ;    }    public static int getRandomNumber int min, int max      {       return  int  Math.random              *  max - min + 1   + min;    }    public static int getGuess int min, int max      {       while  true        {           int guess = sc.nextInt  ;           if    guess   max               {               System.out.print "I said, between "                   + min + " and " + max                   + ". Try again: " ;           }           else               return guess;        }    }    public static boolean askForAnotherRound String prompt      {       while  true        {           String answer;           System.out.print "\n" + prompt + "  Y or N  " ;           answer = sc.next  ;           if  answer.equalsIgnoreCase "Y"                 return true;  →25  →29  →31  →41  →43  →47  →52  →59  →63  CHAPTER 7  Adding Some Methods to Your Madness      211   continued    LISTING 7-3:    continued             else if  answer.equalsIgnoreCase "N"                 return false;       }    } }  The following paragraphs point out the key lines of this program:  →13    This line calls the playARound method to play one round of the game.   The values for min and max are passed as literals. To add a small amount  of variety to the game, the getRandomNumber method is called here to set  the value for the max to a random number from 7 to 12.   →25    The call to the getRandomNumber method passes the values of min and   max as parameters to set the range for the random numbers.   →29    The message that announces to the user that the computer has chosen a  random number uses the min and max parameters to indicate the range.   →31    The call to the getGuess method now passes the range of acceptable   guesses to the getGuess method.   →41    The declaration for the getRandomNumber method specifies the min and    →43    The calculation for the random number is complicated a bit by the fact    →47    The declaration for the getGuess method accepts the min and max   max parameters.  that min may not be 1.  parameters.   →52    The if statement in the getGuess method uses the min and max values   to validate the user’s input.   →59    This line is the return statement for the getGuess method. Note that this   return statement is in the else part of an if statement that checks  whether the number is less than 1 or greater than 10. If the number is  outside the acceptable range, the return statement isn’t executed.  Instead, the program displays an error message, and the while loop  repeats.   →63    The askForAnotherRound method accepts a string variable to use as a   prompt.  212      BOOK 2  Programming Basics   IN THIS CHAPTER  » Seeing what to do when bad things   happen to good programs   » Finding out all about exceptions   » Using try, catch, and finally   » Preventing exceptions from  happening in the first place  Chapter 8 Handling Exceptions  This chapter is about what happens when Java encounters an error situation   that it can’t deal with. Over the years, computer programming languages  have  devised  many  ways  to  deal  with  these  types  of  errors.  The  earliest  programming languages dealt with them rudely, by abruptly terminating the pro- gram and printing out the entire contents of the computer’s memory in hexadeci- mal. This output was called a dump.  Later programming languages tried various ways to keep the program running  when  serious  errors  occurred.  In  some  languages,  the  statements  that  could  potentially cause an error had elements added to them that would provide feed- back about errors. A statement that read data from a disk file, for example, might  return an error code if an I O error occurred. Still other languages let you create a  special error processing section of the program to which control would be trans- ferred if an error occurred.  Being  an  object-oriented  programming  language,  Java  handles  errors  by  using  special exception objects that are created when an error occurs. In addition, Java  has a special statement called the try statement that you must use to deal with  exception objects. In this chapter, you find all the gory details of working with  exception objects and try statements.  CHAPTER 8  Handling Exceptions      213   Understanding Exceptions  An exception is an object that’s created when an error occurs in a Java program  and Java can’t automatically fix the error. The exception object contains informa- tion about the type of error that occurred. The most important information — the  cause of the error — is indicated by the name of the exception class used to cre- ate the exception. You usually don’t have to do anything with an exception object  other than figure out which one you have.  Each type of exception that can occur is represented by a different exception class.  Here are some typical exceptions:   » IllegalArgumentException: You passed an incorrect argument to a method.  » InputMismatchException: The console input doesn’t match the data type   expected by a method of the Scanner class.   » ArithmeticException: You tried an illegal type of arithmetic operation, such   as dividing an integer by zero.   » IOException: A method that performs I O encountered an unrecoverable   I O error.   » ClassNotFoundException: A necessary class couldn’t be found.  There are many other types of exceptions, and you find out about many of them  in later chapters of this book.  You need to know a few other things about exceptions:   » When an error occurs and an exception object is created, Java is said to have  thrown an exception. Java has a pretty good throwing arm, so the exception is  always thrown right back to the statement that caused it to be created.   » The statement that caused the exception can catch the exception if it wants it,   but it doesn’t have to catch the exception if it doesn’t want it. Instead, it can  duck and let someone else catch the exception. That someone else is the  statement that called the method that’s currently executing.   » If everyone ducks and the exception is never caught by the program, the   program ends abruptly and displays a nasty-looking exception message on  the console  more on that in the next section .   » Two basic types of exceptions in Java are checked exceptions and unchecked   exceptions:    A checked exception is an exception that the compiler requires you to provide   for it one way or another. If you don’t, your program doesn’t compile.  214      BOOK 2  Programming Basics      An unchecked exception is an exception that you can provide for, but you   don’t have to.   » So far in this book, I’ve avoided using any Java API methods that throw  checked exceptions, but I have used methods that can throw unchecked  exceptions. The nextInt method of the Scanner class, for example, throws  an unchecked exception if the user enters something other than a valid  integer value. For more information, read on.  Witnessing an exception  Submitted for your approval is a tale of a hastily written Java program, quickly put  together to illustrate certain Java programming details while ignoring others. Out of  sight, out of mind, as they say. Said program played a guessing game with the user,  accepting numeric input via a class called Scanner. Yet this same program ignored the  very real possibility that the user may enter strange and unexpected data — data that  could hardly be considered numeric, at least not in the conventional sense. The time:  Now. The place: Here. This program is about to cross over into . . . the Exception Zone.  The program I’m talking about here is, of course, the guessing-game program  that’s appeared in several forms in recent chapters.  You can find the most recent  version at the end of Book 2, Chapter 7.  This program includes a validation rou- tine that prevents the user from making a guess that’s not between 1 and 10. That  validation routine, however, assumes that the user entered a valid integer num- ber. If the user enters something other than an integer value, the nextInt method  of the Scanner class fails badly.  Figure 8-1 shows an example of what the console looks like if the user enters text  such  as five  instead of a number. The first line after the user enters the incorrect data  says the program has encountered an exception named InputMismatchException.  In short, this exception means that the data entered by the user couldn’t be matched  with the type of data that the Scanner class expected. The nextInt method expected  to find an integer, and instead, it found the word five.  s n o i t p e c x E g n     i l  d n a H  Finding the culprit  You can find the exact statement in your program that caused the exception to  occur by examining the lines that are displayed right after the line that indicates  which exception was encountered. These lines, called the stack trace, list the meth- ods that the exception passed through before your program was aborted. Usually,  the first method listed is deep in the bowels of the Java API, and the last method  listed is your application’s main method. Somewhere in the middle, you find the  switch from methods in the Java API to a method in your program. That’s usually  where you find the statement in your program that caused the error.  CHAPTER 8  Handling Exceptions      215   FIGURE 8-1:   This program has  slipped into the  Exception Zone.  In Figure 8-1, the stack trace lines look something like this:  at java.util.Scanner.throwFor Scanner.java:909  at java.util.Scanner.next Scanner.java:1530  at java.util.Scanner.nextInt Scanner.java:2160  at java.util.Scanner.nextInt Scanner.java:2119  at GuessingGameMethod3.getGuess GuessingGameMethod3.java:51  at GuessingGameMethod3.playARound GuessingGameMethod3.java:31  at GuessingGameMethod3.main GuessingGameMethod3.java:13   Each line lists not only a class and method name, but also the name of the source  file  that  contains  the  class  and  the  line  number  where  the  exception  occurred.  Thus, the first line in this stack trace indicates that the exception is handled in the  throwFor method of the Scanner class at line 909 of the Scanner.java file. The  next three lines also indicate methods in the Scanner class. The first line to men- tion  the  GuessingGame  class   GuessingGameMethod3   is  the  fifth  line.  It  shows  that  the  exception  happened  at  line  51  in  the  GuessingGameMethod3.java  file.  Sure enough, that’s the line that calls the nextInt method of the Scanner class to  get input from the user.  Catching Exceptions  Whenever you use a statement that might throw an exception, you should write  special code to anticipate and catch the exception. That way, your program won’t  crash as shown in Figure 8-1 if the exception occurs.  216      BOOK 2  Programming Basics   You catch an exception by using a try statement, which has this general form:  try {     statements that can throw exceptions } catch  exception-type identifier  {     statements executed when exception is thrown }  Here, you place the statements that might throw an exception within a try block.  Then you catch the exception with a catch block.  Here are a few things to note about try statements:   » You can code more than one catch block. That way, if the statements in the  try block might throw more than one type of exception, you can catch each  type of exception in a separate catch block.   » For scoping purposes, the try block is its own self-contained block, separate  from the catch block. As a result, any variables you declare in the try block  are not visible to the catch block. If you want them to be, declare them  immediately before the try statement.   » You can also code a special block  called a finally block  after all the catch  blocks. For more information about coding finally blocks, see the section  “Using a finally Block,” later in this chapter.   » The various exception classes in the Java API are defined in different packages.   If you use an exception class that isn’t defined in the standard java.lang  package that’s always available, you need to provide an import statement for  the package that defines the exception class.  s n o i t p e c x E g n     i l  d n a H  A simple example  To illustrate how to provide for an exception, here’s a program that divides two  numbers  and  uses  a  try catch  statement  to  catch  an  exception  if  the  second  number turns out to be zero:  public class DivideByZero {    public static void main String[] args     {       int a = 5;       int b = 0;               you know this won't work       try  CHAPTER 8  Handling Exceptions      217         {          int c = a   b;       but you try it anyway       }       catch  ArithmeticException e        {          System.out.println "Oops, you can't "              + "divide by zero." ;       }    } }  Here,  the  division  occurs  within  a  try  block,  and  a  catch  block  handles  ArithmeticException.  ArithmethicException  is  defined  by  java.lang,  so  an  import statement for it isn’t necessary.  When you run this program, the following is displayed on the console:  Oops, you can't divide by zero.  There’s  nothing  else  to  see  here.  The  next  section  shows  a  more  complicated  example, though.  Another example  Listing 8-1 shows a simple example of a program that uses a method to get a valid  integer from the user. If the user enters a value that isn’t a valid integer, the catch  block catches the error and forces the loop to repeat.  LISTING 8-1:  Getting a Valid Integer  import java.util.*; public class GetInteger {     static Scanner sc = new Scanner System.in ;     public static void main String[] args      {         System.out.print "Enter an integer: " ;         int i = GetAnInteger  ;         System.out.println "You entered " + i ;     }     public static int GetAnInteger       {         while  true          {             try             {  218      BOOK 2  Programming Basics                   return sc.nextInt  ;             }             catch  InputMismatchException e              {                 sc.next  ;                 System.out.print "That's not "                     + "an integer. Try again: " ;             }         }     } }  Here the statement that gets the input from the user and returns it to the methods  called is coded within the try block. If the user enters a valid integer, this state- ment is the only one in this method that gets executed.  If the user enters data that can’t be converted to an integer, however, the nextInt  method throws an InputMismatchException. Then this exception is intercepted  by the catch block — which disposes of the user’s incorrect input by calling the  next  method,  as  well  as  by  displaying  an  error  message.  Then  the  while  loop  repeats.  Here’s what the console might look like for a typical execution of this program:  Enter an integer: three That's not an integer. Try again: 3.001 That's not an integer. Try again: 3 You entered 3  Here are a couple other things to note about this program:   » The import statement specifies java.util.* to import all the classes from   the java.util package. That way, the InputMismatchException class  is imported.   » The next method must be called in the catch block to dispose of the user’s   invalid input because the nextInt method leaves the input value in the  Scanner’s input stream if an InputMismatchException is thrown. If you omit  the statement that calls next, the while loop keeps reading it, throws an  exception, and displays an error message in an infinite loop. If you don’t  believe me, look at Figure 8-2. I found this error out the hard way.  The only  way to make it stop is to close the console window.   s n o i t p e c x E g n     i l  d n a H  CHAPTER 8  Handling Exceptions      219   FIGURE 8-2:   Why you have  to call next to   discard the  invalid input.  Handling Exceptions with   a Preemptive Strike  The try statement is a useful and necessary tool in any Java programmer’s  arsenal.  The best way to handle exceptions, however, is to prevent them from happening  in the first place. That’s not possible all the time, but in many cases it is. The key  is to test your data before performing the operation that can lead to an exception  and then skipping or bypassing the operation of the data that is problematic.  One  thing I really hate is problematic data.   You can usually avoid the ArithmethicException that results from dividing inte- ger data by zero by checking the data before performing the division:  if  b != 0      c = a   b;  This eliminates the need to enclose the division in a try block, because you know  that the division by zero won’t happen.  You can apply this same technique to input validation by using the hasNextInt  method of the Scanner class. This method checks the next input value to make  sure it’s a valid integer.  The Scanner class calls the next input value a token, but  that won’t be on the test.  You can do this technique in several ways, and I’ve been  encouraging you to ponder the problem since Book 2, Chapter 2. Now behold the  long-awaited answer: Listing 8-2 shows a version of the GetInteger method that  uses a while loop to avoid the exception.  220      BOOK 2  Programming Basics   LISTING 8-2:  Another Version of the GetInteger Method  import java.util.*; public class GetInteger2 {     static Scanner sc = new Scanner System.in ;     public static void main String[] args      {         System.out.print "Enter an integer: " ;         int i = GetAnInteger  ;         System.out.println "You entered " + i ;     }     public static int GetAnInteger       {         while  !sc.hasNextInt            {             sc.nextLine  ;             System.out.print "That's not "                 + "an integer. Try again: " ;         }         return sc.nextInt  ;     } }  This is a clever little bit of programming, don’t you think? The conditional expres- sion in the while statement calls the hasNextInt method of the Scanner to see  whether the next value is an integer. The while loop repeats as long as this call  returns false, indicating that the next value is not a valid integer. The body of the  loop calls nextLine to discard the bad data and then displays an error message.  The loop ends only when you know that you have good data in the input stream,  so the return statement calls nextInt to parse the data to an integer and return  the resulting value.  s n o i t p e c x E g n     i l  d n a H  Catching All Exceptions at Once  Java provides a catch-all exception class called Exception that all other types of  exceptions are based on.  Don’t worry about the details of what I mean by that.  When you read Book 3, Chapter 4, it makes more sense.   CHAPTER 8  Handling Exceptions      221   If you don’t want to be too specific in a catch block, you can specify Exception  instead of a more specific exception class. For example:  try {     int c = a   b; } catch  Exception e  {     System.out.println "Oops, you can't "         + "divide by zero." ; }  In  this  example,  the  catch  block  specifies  Exception  rather  than  Arithmetic  Exception.  If you have some code that might throw several types of exceptions, and you want  to provide specific processing for some types but general processing for all the  others, code the try statement this way:  try {        statements that might throw several types of    exceptions } catch  InputMismatchException e  {        statements that process InputMismatchException } catch  IOException e  {        statements that process IOException } catch  Exception e  {        statements that process all other exception types }  In  this  example,  imagine  that  the  code  in  the  try  block  could  throw  an  InputMismatchException,  an  IOException,  and  perhaps  some  other  type  of  unanticipated  exception.  Here  the  three  catch  blocks  provide  for  each  of  these  possibilities.  When you code more than one catch block on a try statement, always list the  more specific exceptions first. If you include a catch block to catch Exception,  list it last.  222      BOOK 2  Programming Basics   Displaying the Exception Message  In most cases, the catch block of a try statement won’t do anything at all with  the exception object passed to it. You may want to display an error message occa- sionally, however; exception objects have a few interesting methods that can come  in handy from time to time. These methods are listed in Table 8-1.  TABLE 8-1   Methods of the Exception Class Method  Description  String getMessage    Describes the error in a text message.  Prints the stack trace to the standard error stream.  void  printStackTrace    String toString    Returns a description of the exception. This description  includes the name of the exception class followed by a  colon and the getMessage message.  The following example shows how you could print the message for an exception  in a catch block:  try {     int c = a   b; } catch  Exception e  {     System.out.println e.getMessage   ; }  s n o i t p e c x E g n     i l  d n a H  This code displays the text   by zero on the console if b has a value of 0. You can  get even more interesting output by using this line in the catch clause:      e.printStackTrace System.out ;  Using a finally Block  A finally block is a block that appears after all the catch blocks for a statement.  It’s executed whether or not any exceptions are thrown by the try block or caught  by any catch blocks. Its purpose is to let you clean up any mess that might be left  behind by the exception, such as open files or database connections.  CHAPTER 8  Handling Exceptions      223   The basic framework for a try statement with a finally block is this:  try {     statements that can throw exceptions } catch  exception-type identifier  {     statements executed when exception is thrown } finally {     statements that are executed whether or not     exceptions occur }  Listing 8-3 shows a contrived but helpful example that demonstrates how to use  the finally clause. In this example, a method called divideTheseNumbers tries  to divide the numbers twice. If the division fails the first time  due to a divide-  by-zero exception , it tries the division again. Completely irrational, I know. But  persistent, like a teenager.  LISTING 8-3:  A Program That Uses a finally Clause  public class CrazyWithZeros {     public static void main String[] args      {         try         {             int answer = divideTheseNumbers 5, 0 ;          }         catch  Exception e           {             System.out.println "Tried twice, "                + "still didn't work!" ;         }     }     public static int divideTheseNumbers int a, int b           throws Exception     {         int c;         try         {             c = a   b;              System.out.println "It worked!" ;          }  →7  →9  →16  →22 →23  224      BOOK 2  Programming Basics           catch  Exception e          {             System.out.println "Didn't work the first time." ;              c = a   b;              System.out.println "It worked the second time!" ;          }         finally         {             System.out.println "Better clean up my mess." ;          }         System.out.println "It worked after all." ;          return c;      } }  →27 →28 →29  →33  →35 →36  Here’s the console output for the program:  Didn't work the first time. Better clean up my mess. Tried twice, still didn't work!  s n o i t p e c x E g n     i l  d n a H  The following paragraphs explain what’s going on, step by step: →7      The main method calls the divideTheseNumbers method, passing 5   and 0 as the parameters. You already know that this method isn’t going  to work.  →9     The catch clause catches any exceptions thrown by line 7. →16    The divideTheseNumbers method declares that it throws Exception. →22    This line is the first attempt to divide the numbers. →23    If the first attempt succeeds, this line is executed, and the message "It  worked!" is printed. Alas, the division throws an exception, so this line  never gets executed.  →27    Instead, the catch clause catches the exception, and the message   "Didn't work the first time." is displayed. That’s the first line in  the console output.  →28    The divideTheseNumbers method stubbornly tries to divide the same two   numbers again. This time, no try statement is there to catch the error. →29    Because another exception is thrown for the second division, however,  this line is never executed. Thus you don’t see the message "It worked  the second time!" on the console.  If you do, you’re in an episode of  The Twilight Zone.   CHAPTER 8  Handling Exceptions      225   →33    This statement in the finally clause is always executed, no matter what  happens. That’s where the second line in the console output came from.  After the finally clause executes, the ArithmeticException is thrown  back up to the calling method, where it is caught by line 9. That’s where  the last line of the console output came from.  →35    If the division did work, this line would be executed after the try block  ends, and you’d see the message "It worked after all." on the  console.  →36    Then the return statement would return the result of the division.  Handling Checked Exceptions  Checked exceptions are exceptions that the designers of Java feel that your pro- grams  absolutely  must  provide  for,  one  way  or  another.  Whenever  you  code  a  statement that could throw a checked exception, your program must do one of  two things:   » Catch the exception by placing the statement within a try statement that has   a catch block for the exception.   » Specify a throws clause on the method that contains the statement to  indicate that your method doesn’t want to handle the exception, so it’s  passing the exception up the line.  This is known as the catch-or-throw rule. In short, any method that includes a  statement that might throw a checked exception must acknowledge that it knows  the exception might be thrown. The method does this by handling it directly or by  passing the exception up to its caller.  To illustrate the use of checked exceptions, I have to use some classes with meth- ods  that  throw  them.  Up  to  now,  I’ve  avoided  introducing  classes  that  throw  checked exceptions, so the following illustrations use some classes you aren’t yet  familiar  with.  Don’t  worry  about  what  those  classes  do  or  how  they  work.  The  point is to see how to handle the checked exceptions they throw.  Viewing the catch-or-throw compiler error  Here’s a program that uses a class called FileInputStream. To create an object  from  this  class,  you  must  pass  the  constructor  a  string  that  contains  the  path   226      BOOK 2  Programming Basics   and name of a file that exists on your computer. If the file can’t be found, the  FileInputStream throws a FileNotFoundException that you must either catch  or throw. This class is in the java.io package, so any program that uses it must  include an import java.io statement.  Consider the following program:  import java.io.*; public class FileException1 {     public static void main String[] args      {         openFile "C:\test.txt" ;     }     public static void openFile String name      {         FileInputStream f = new FileInputStream name ;     } }  This program won’t compile. The compiler issues the following error message:  unreported exception java.io.FileNotFoundException; must be caught or    declared to be thrown  This message simply means that you have to deal with the FileNotFoundException.  Catching FileNotFoundException  One way to deal with the FileNotFoundException is to catch it by using an ordi- nary try statement:  s n o i t p e c x E g n     i l  d n a H  import java.io.*; public class FileException2 {     public static void main String[] args      {         openFile "C:\test.txt" ;     }     public static void openFile String name      {         try         {             FileInputStream f =                 new FileInputStream name ;         }  CHAPTER 8  Handling Exceptions      227           catch  FileNotFoundException e          {             System.out.println "File not found." ;         }     } }  In this example, the message "File not found." is displayed if the C:\test.txt  file doesn’t exist.  Throwing the FileNotFoundException  Suppose  that  you  don’t  want  to  deal  with  this  error  condition  in  the  openFile  method, but would rather just pass the exception up to the method that calls the  openFile method.  To do that, you omit the try statement. Instead, you add a throws clause to the  openFile method’s declaration. That clause indicates that the openFile method  knows it contains a statement that might throw a FileNotFoundException but  doesn’t want to deal with that exception here. Instead, the exception is passed up  to the caller.  Here’s the openFile method with the throws clause added:  public static void openFile String name      throws FileNotFoundException {     FileInputStream f = new FileInputStream name ; }  As you can see, the throws clause simply lists the exception or exceptions that  the method might throw. If more than one exception is in the list, separate the  exceptions with commas:  public static void readFile String name      throws FileNotFoundException, IOException  Adding  a  throws  clause  to  the  openFile  method  means  that  when  the  File  NotFoundException occurs, it is simply passed up to the method that called the  openFile method. That means the calling method  in this illustration, main  must  catch or throw the exception. To catch the exception, the main method would have  to be coded like this:  228      BOOK 2  Programming Basics   public static void main String[] args  {     try     {         openFile "C:\test.txt" ;     }     catch  FileNotFoundException e      {         System.out.println "File not found." ;     } }  Then, if the file doesn’t exist, the catch block catches the exception, and the error  message is displayed.  Throwing an exception from main  If you don’t want the program to handle the FileNotFound exception at all, you  can add a throws clause to the main method, like this:  public static void main String[] args      throws FileNotFoundException {     openFile "C:\test.txt" ; }  Then the program abruptly terminates with an exception message and stack trace  if the exception occurs.  Swallowing exceptions  What  if  you  don’t  want  to  do  anything  if  a  checked  exception  occurs?  In  other  words, you want to simply ignore the exception. You can do that by catching the  exception in the catch block of a try statement but leaving the body of the catch  block empty. Here’s an example:  public static void openFile String name  {     try     {         FileInputStream f = new FileInputStream name ;     }  s n o i t p e c x E g n     i l  d n a H  CHAPTER 8  Handling Exceptions      229       catch  FileNotFoundException e      {     } }  Here the FileNotFoundException is caught and ignored. This technique is called  swallowing the exception.  Swallowing  an  exception  is  considered  to  be  bad  programming  practice.  Sim- ply swallowing exceptions that you know you should handle when working on a  complicated program is tempting. Because you plan to get back to that exception  handler after you iron out the basic functions of the program, a little exception- swallowing doesn’t seem like that bad an idea. The problem is that inevitably, you  never get back to the exception handler, so your program gets rushed into produc- tion with swallowed exceptions.  If you must swallow exceptions, at least write a message to the console indicat- ing that the exception occurred. That way, you have a constant reminder that the  program has some unfinished details you must attend to.  Note  that  not  all  exception  swallowing  is  bad. Suppose  you  want  the  openFile  method to return a boolean value to indicate whether the file exists, rather than  throw an exception. Then you could code the method something like this:  public static boolean openFile String name  {     boolean fileOpened = false;     try     {         FileInputStream f = new FileInputStream name ;         fileOpened = true;     }     catch  FileNotFoundException e      {     }     return fileOpened; }  Here the exception isn’t really swallowed. Instead, its meaning is converted to a  boolean result that’s returned from the method. As a result, the error condition  indicated by the FileNotFoundException isn’t lost.  230      BOOK 2  Programming Basics   Throwing Your Own Exceptions  Although  such  methods  are  uncommon,  you  may  want  to  write  methods  that  throw exceptions all on their own. To do that, you use a  throw statement. The  throw statement has the following basic format:  throw new exception-class   ;  The exception-class can be  Exception or a class that’s derived from  Exception.  You find out how to create your own classes — including exception classes — in  Book 3. For now, I just focus on writing a method that throws a general Exception.  Here’s a program that demonstrates the basic structure of a method that throws  an exception:  public class MyException {     public static void main String[] args      {         try         {             doSomething true ;         }         catch  Exception e          {             System.out.println "Exception!" ;         }     }     public static void doSomething boolean t          throws Exception     {         if  t              throw new Exception  ;     } }  s n o i t p e c x E g n     i l  d n a H  Here  the  doSomething  method  accepts  a  boolean  value  as  a  parameter.  If  this  value is true, it throws an exception; otherwise it doesn’t do anything.  Here are the essential points to glean from this admittedly trivial example:   » You throw an exception by executing a throw statement. The throw state-  ment specifies the exception object to be thrown.   » If a method contains a throw statement, it must include a throws clause in its   declaration.  CHAPTER 8  Handling Exceptions      231    » A method that calls a method that throws an exception must either catch or   throw the exception.   » Yup, this example is pretty trivial. But it illustrates the essential points.  Catching Multiple Exceptions  A feature that was new in Java 7 lets you catch two or more exception types with a  single catch statement. Suppose you have a bit of code that might throw two dif- ferent exceptions — say, FileNotFoundException and IOException — and you  want to handle both identically. One way to do that is to write two catch state- ments  one to catch each section , and then write the same code for both catch  blocks, like this:  try {        statements that might throw FileNotFoundException    or IOException } catch  FileNotFoundException e  {     System.out.println e.getMessage   ; } catch  IOException e  {     System.out.println e.getMessage   ; }  This method works, but it’s clumsy. Java lets you specify two or more exception  types in the catch statement. You separate the exception types with a vertical bar,  like this:  {        statements that might throw FileNotFoundException    or IOException } catch  FileNotFoundException  IOException e  {     System.out.println e.getMessage   ; }  This way, you can handle both exception types with just one block of code.  232      BOOK 2  Programming Basics   Object-Oriented  Programming  3   Contents at a Glance  CHAPTER 1:  Understanding Object-Oriented    Programming  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 235 CHAPTER 2:  Making Your Own Classes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 249 CHAPTER 3:  Working with Statics  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 267 CHAPTER 4:  Using Subclasses and Inheritance  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 277 CHAPTER 5:  Using Abstract Classes and Interfaces  .  .  .  .  .  .  .  .  .  .  . 299 CHAPTER 6:  Using the Object and Class Classes   .  .  .  .  .  .  .  .  .  .  .  .  .  . 315 CHAPTER 7:  Using Inner Classes, Anonymous Classes,    and Lambda Expressions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 341  CHAPTER 8:  Working with Packages and the New Java   Module System   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 353   IN THIS CHAPTER  » Looking at what object-oriented   programming is   » Understanding objects and classes   » Investigating inheritance and   interfaces   » Designing programs with objects   » Diagramming with UML  Chapter 1 Understanding Object- Oriented Programming  This  chapter  is  a  basic  introduction  to  object-oriented  programming.  It   introduces some of the basic concepts and terms you need to know as you  get a handle on the specific details of how object-oriented programming   works in Java.  If  you’re  more  of  a  hands-on  type,  you  may  want  to  skip  this  chapter  and  go  straight to Book 3, Chapter 2, where you find out how to create your own classes in  Java. You can always return to this chapter later to review the basic concepts that  drive object-oriented programming. Either way is okay by me. I get paid the same  whether you read this chapter now or skip it and come back to it later.  What Is Object-Oriented Programming?  The  term  object-oriented  programming  means  many  different  things.  But  at  its  heart,  object-oriented  programming  is  a type  of  computer  programming  based   CHAPTER 1  Understanding Object-Oriented Programming      235   on the premise that all programs are essentially computer-based simulations of  real-world objects or abstract concepts. For example:   » Flight-simulator programs attempt to mimic the behavior of real airplanes.   Some do an amazingly good job; military and commercial pilots train on them.  In the 1960s, the Apollo astronauts used a computer-controlled simulator to  practice for their moon landings.   » Many computer games are simulations of actual games that humans play,   such as baseball, NASCAR racing, and chess. But even abstract games such as  Pac-Man and Final Fantasy IV attempt to model the behavior of creatures and  objects that could exist somewhere. Those programs simulate a conceptual  game — one that can’t actually be played anywhere in the real world but can  be simulated by a computer.   » Business programs can be thought of as simulations of business processes —   such as order taking, customer service, shipping, and billing. An invoice, for  example, isn’t just a piece of paper; it’s a paper that represents a transaction  that has occurred between a company and one of its customers. Thus, a  computer-based invoice is really just a simulation of that transaction.  The notion of a programming language having a premise of this sort isn’t new.  Traditional  programming  languages  such  as  C   and  its  predecessors,  including  even COBOL  are based on the premise that computer programs are computer- ized implementations of actual procedures — the electronic equivalent of “Step 1:  Insert Tab A into Slot B.” The LISP programming language is based on the idea  that all programming problems can be looked at as different ways of manipulating  lists. And the ever-popular database-manipulation language SQL views program- ming problems as ways to manipulate mathematical sets.  Here are some additional thoughts about the notion of computer programs being  simulations of real-world objects or abstract concepts:   » Sometimes the simulation is better than the real thing. Word-processing  programs started out as simulations of typewriters, but a modern word-  processing program is far superior to any typewriter.   » The idea that all computer programs are simulations of one type or another   isn’t a new one. In fact, the first object-oriented programming language   Simula  was developed in the 1960s. By 1967, this language had many of the  features we now consider fundamental to object-oriented programming —  including classes, objects, inheritance, and virtual methods.   » Come to think of it, manual business recordkeeping systems are simulations  too. A file cabinet full of printed invoices doesn’t hold actual orders; it holds  written representations of those orders. A computer is a better simulation  device than a file cabinet, but both are simulations.  236      BOOK 3  Object-Oriented Programming   Understanding Objects  All this talk of simulations is getting a little existential for me, so now I’m turning  to the nature of the objects that make up object-oriented programming. Objects —   both in the real world and in the world of programming — are entities that have  certain  basic  characteristics.  The  following  sections  describe  some  of  the  most  important of these characteristics: identity, type, state, and behavior.  Objects have identity  Every object in an object-oriented program has an identity. In other words, every  occurrence of a particular type of object — called an instance — can be distin- guished from every other occurrence of the same type of object, as well as from  objects of other types.  In the real world, object identity is a pretty intuitive and obvious concept. Pick  up two apples, and you know that although both of them are apples  that’s the  object type, described in the next section , you know that they aren’t the same  apple. Each has a distinct identity. Both are roughly the same color but not exactly.  They’re both roundish but have minor variations in shape. Either one  or both   could have a worm inside.  Open a file cabinet that’s full of invoices, and you find page after page of papers  that look almost identical, but each one has an invoice number printed somewhere  near  the  top  of  the  page.  This  number  isn’t  what  actually  gives  each  of  these  invoices a unique identity, but it gives you an easy way to identify each individual  invoice, just as your name gives other people an easy way to identify you.  In  object-oriented  programming,  each  object  has  its  own  location  in  the  com- puter’s memory. Thus, two objects, even though they may be of the same type,  have their own distinct memory locations. The address of the starting location for  an object provides a way of distinguishing one object from another, because no  two objects can occupy the same location in memory.  Here are a few other important thoughts about object identity in Java:   » Java keeps each object’s identity pretty much to itself. In other words, there’s   no easy way to get the memory address of an object; Java figures that it’s  none of your business, and rightfully so. If Java made that information readily  available to you, you’d be tempted to tinker with it, which could cause all sorts  of problems, as any C or C++ programmer can tell you.  CHAPTER 1  Understanding Object-Oriented Programming      237    » Java objects have something called a hash code, which is an int value   that’s automatically generated for every object and almost represents the  object’s identity. In most cases, the hash code for an object is based on  the object’s memory address, but not always. Java doesn’t guarantee that  two distinct objects won’t have the same hash code.   » When used with objects, the equality operator  ==  actually tests the object   identity of two variables or expressions. If they refer to the same object  instance, the two variables or expressions are considered equal.  Objects have type  I remember studying “Naming of Parts,” a fine poem written by Henry Reed in  1942, back when I was an English major in college:  To-day we have naming of parts. Yesterday,  We had daily cleaning. And to-morrow morning,  We shall have what to do after firing. But to-day,  To-day we have naming of parts. Japonica  Glistens  like coral in all of the neighboring gardens,   And today we have naming of parts.  Sure, it’s a fine antiwar poem and all that, but it’s also a little instructive about  object-oriented programming. After the first stanza, the poem goes on to name  the parts of a rifle:  This is the lower sling swivel. And this  Is the upper sling swivel, whose use you will see,  When you are given your slings. And this is the piling swivel,  Which in your case you have not got.  Imagine  a  whole  room  of  new  soldiers  taking  apart  their  rifles,  while  the  drill  sergeant tells them, “This is the lower sling swivel. And this is the upper sling  swivel.…” Each soldier’s rifle has one of these parts — in object-oriented terms,  an object of a particular type. The lower sling swivels in the soldiers’ rifles are  different objects, but all are of the type LowerSlingSwivel.  Like the drill sergeant in this poem, object-oriented programming lets you assign  names to the different kinds of objects in a program. In Java, types are defined by  classes. So when you create an object from a type, you’re saying that the object  is of the type specified by the class. The following example statement creates an  object of type Invoice:  Invoice i = new Invoice  ;  238      BOOK 3  Object-Oriented Programming   In this case, the identity of this object  that is, its address in memory  is assigned  to the variable i, which the compiler knows can hold references to objects of type  Invoice.  Objects have state  Now switch gears to another literary genius:  One fish, two fish,  Red fish, blue fish  In object-oriented terms, Dr. Seuss here is enumerating a pair of objects of type  Fish. The Fish type apparently has two attributes; call them Number and Color.  These two objects have differing values for these attributes:  Attribute  Object 1  Object 2  Number  Color  One  Red  Two  Blue  The type of an object determines what attributes the object has. Thus all objects  of  a  particular  type  have  the  same  attributes.  They  don’t  necessarily  have  the  same values for those attributes, however. In this example, all Fish have attri- butes named Number and Color, but the two Fish objects have different values for  these attributes.  The combination of the values for all the attributes of an object is called the object’s  state. Unlike its identity, an object’s state can — and usually does — change over its  lifetime. Some fish can change colors, for example. The total sales for a particular  customer changes each time the customer buys another product. The grade-point  average for a student changes each time a new class grade is recorded. The address  and phone number of an employee change if the employee moves.  Here are a few more interesting details about object state:   » Some of the attributes of an object are publicly known, but others can be  private. The private attributes may be vital to the internal operation of the  object, but no one outside the object knows that they exist. They’re like your  private thoughts: They affect what you say and do, but nobody knows  them but you.   » In Java, the state of an object is represented by class variables, which are   called fields. A public field is a field that’s declared with the public keyword so  that the variable can be visible to the outside world.  CHAPTER 1  Understanding Object-Oriented Programming      239   Objects have behavior  Another characteristic of objects is that they have behavior, which means that they  can do things. Like state, the specific behavior of an object depends on its type. But  unlike state, behavior isn’t different for each instance of a type. Suppose that all  the students in a classroom have calculators of the same type. Ask them all to pull  out the calculators and add two numbers — any two numbers of their choosing.  All the calculators display a different number, but they all add in the same way —  that is, they all have a different state but the same behavior.  Another  way  to  say  that  objects  have  behavior  is  to  say  that  they  provide  ser- vices that can be used by other objects. You’ve already seen plenty of examples  of objects that provide services to other objects. Objects created from the Number  Format class, for example, provide formatting services that turn numeric values  into nicely formatted strings such as $32.95.  In  Java,  the  behavior  of  an  object  is  provided  by  its  methods.  Thus  the  format  method of the NumberFormat class is what provides the formatting behavior for  NumberFormat objects.  Here are a few other notable points about object behavior:   » The interface of a class is the set of methods and fields that the class makes   public so that other objects can access them.   » Exactly how an object does what it does can and should be hidden within the  object. Someone who uses the object needs to know what the object does but  doesn’t need to know how it works. If you later find a better way for the object  to do its job, you can swap in the new improved version without anyone  knowing the difference.  Understanding the Life Cycle of an Object  As you work with objects in Java, understanding how objects are born, live their  lives, and die is important. This topic is called the life cycle of an object, and it goes  something like this: 1.  Before an object can be created from a class, the class must be loaded. To do  that, the Java runtime locates the class on disk  in a .class file  and reads it  into memory. Then Java looks for any static initializers that initialize static  fields — fields that don’t belong to any particular instance of the class, but  belong to the class itself and are shared by all objects created from the class.  240      BOOK 3  Object-Oriented Programming   Working with Related Classes  A class is loaded the first time you create an object from the class or the first  time you access a static field or method of the class. When you run the main  method of a class, for example, the class is initialized because the main  method is static.  2.  An object is created from a class when you use the new keyword. To initialize the  class, Java allocates memory for the object and sets up a reference to the object  so that the Java runtime can keep track of it. Then Java calls the class constructor,  which is like a method but is called only once: when the object is created. The  constructor is responsible for doing any processing required to initialize the  object — initializing variables, opening files or databases, and so on.  3.  The object lives its life, providing access to its public methods and fields to   whoever wants and needs them.  4.  When it’s time for the object to die, the object is removed from memory, and   Java drops its internal reference to it. You don’t have to destroy objects  yourself. A special part of the Java runtime called the garbage collector takes  care of destroying all objects when they are no longer in use.  So  far,  most  of  the  classes  you’ve  seen  in  this  book  have  created  objects  that  stand on their own, each being a little island unto itself. The real power of object-  oriented programming, however, lies in its ability to create classes that describe  closely related objects.  Baseballs, for example, are similar to softballs. Both are specific types of balls.  Each type has a diameter and a weight; both types can be thrown, caught, or hit.  Baseballs and softballs, however, have different characteristics that cause them to  behave differently when they’re thrown, caught, or hit.  If you’re creating a program that simulates the way baseballs and softballs work,  you need a way to represent these two types of balls. One option is to create sepa- rate classes to represent each type of ball. These classes are similar, so you can  just copy most of the code from one class to the other.  Another option is to use a single class to represent both types of balls. Then you  pass a parameter to the constructor to indicate whether an instance of the class  behaves like a baseball or like a softball.  Java has two object-oriented programming features that are designed specifically  to handle classes that are related this way: inheritance and interfaces. I briefly  describe these features in the following sections.  CHAPTER 1  Understanding Object-Oriented Programming      241   Inheritance  Inheritance  is  an  object-oriented  programming  technique  that  lets  you  use  one  class as the basis for another. The existing class is called the base class, superclass,  or parent class; the new class that’s derived from it is called the derived class, sub- class, or child class.  When you create a subclass, the subclass is automatically given all the methods  and fields defined by its superclass. You can use these methods and fields as is, or  you can override them to alter their behavior. In addition, you can add methods  and fields that define data and behavior that’s unique to the subclass.  You  could  use  inheritance  to  solve  the  baseball softball  problem  from  the  pre- ceding section by creating a class named Ball that provides the basic features of  all types of balls and then using it as the base class for separate classes named  BaseBall and SoftBall. Then these classes could override the methods that need  to behave differently for each type of ball.  One way to think of inheritance is as a way to implement is-a-type-of relationships.  A softball is a type of ball, as is a baseball. Thus inheritance is an appropriate way  to implement these related classes.  For more information about inheritance, see  Book 3, Chapter 4.   Interfaces  An interface is a set of methods and fields that a class must provide to implement  the interface. The interface itself is simply a set of public method and field dec- larations that are given a name. Note that the interface itself doesn’t provide any  code that implements those methods. Instead, it just provides the declarations.  Then a class that implements the interface provides code for each of the methods  the interface defines.  You could use an interface to solve the baseball softball problem by creating an  interface named Ball that specifies all the methods and fields that a ball should  have. Then you could create the SoftBall and BaseBall classes so that they both  implement the Ball interface.  Interfaces are closely related to inheritance but have two key differences:   » The interface itself doesn’t provide code that implements any of its methods.  An interface is just a set of method and field signatures. By contrast, a base  class can provide the implementation for some or all of its methods.  242      BOOK 3  Object-Oriented Programming    » A class can have only one base class, but a class can implement as many   interfaces as necessary.  You find out more about interfaces in Book 3, Chapter 5.  Designing a Program with Objects  An object-oriented program usually isn’t just a single object. Instead, it’s a group  of objects that work together to get a job done. The most important part of devel- oping an object-oriented program is designing the classes that are used to cre- ate the program’s objects. The basic idea is to break a large problem into a set of  classes, each of which is manageable in size and complexity. Then you write the  Java code that implements those classes.  So  the  task  of  designing  an  object-oriented  application  boils  down  to  deciding  what classes the application requires — and what the public interface to each of  those classes should be. If you plan your classes well, implementing the applica- tion is easy. If you plan your classes poorly, you’ll have a hard time getting your  application to work.  One common way to design object-oriented applications is to divide the applica- tion  into  several  distinct  layers  or  tiers  that  provide  distinct  types  of  functions.  Most  common  is  a  three-layered  approach,  as  shown  in  Figure  1-1.  Here  the  objects of an application are split into three basic layers:   » Presentation: The objects in this layer handle all the direct interaction with  users. The HTML pages in a web application go in this layer, as do the Swing  page and frame classes in a GUI-based application.  I cover Swing in Book 6.   » Logic: The objects in this layer represent the core objects of the application.   For a typical business-type application, this layer includes objects that  represent business entities such as customer, products, orders, suppliers,  and the like. This layer is sometimes called the business rules layer because  the objects in this layer are responsible for carrying out the rules that govern  the application.   » Database: The objects in this layer handle all the details of interacting with  whatever form of data storage is used by the application. If the data is stored  in a SQL database, for example, the objects in this layer handle all the SQL.  CHAPTER 1  Understanding Object-Oriented Programming      243   FIGURE 1-1:   Three-layered  design.  Diagramming Classes with UML  Since the very beginning of computer programming, programmers have loved to  create diagrams of their programs. Originally, they drew flowcharts that graphi- cally represented a program’s procedural logic.  Flowcharts were good at diagramming procedures, but they were way too detailed.  When  the  structured  programming  craze  hit  in  the  1970s,  and  programmers  started thinking about the overall structure of their programs, they switched from  flowcharts  to  structure  charts,  which  illustrated  the  organizational  relationships  among the modules of a program or system.  Now  that  object-oriented  programming  is  the  thing,  programmers  draw  class   diagrams to illustrate the relationships among the classes that make up an appli- cation. Figure 1-2 shows a class diagram of a simple system that has four classes.  The  rectangles  represent  the  classes  themselves,  and  the  arrows  represent  the  relationships among the classes.  You  can  draw  class  diagrams  in  many  ways.  To  add  some  consistency  to  their  diagrams, most programmers use a standard called UML, which stands for Unified  Modeling Language. The class diagram in Figure 1-2 is an example of a simple UML  diagram, but UML diagrams can get much more complicated.  The following sections describe the details of creating UML class diagrams. Note  that these sections don’t even come close to explaining all the features of UML.  I  include  just  the  basics  of  creating  UML  class  diagrams  so  that  you  can  make  some sense of UML diagrams when you see them and so that you know how to  draw simple class diagrams to design the class structure for your applications.  244      BOOK 3  Object-Oriented Programming   FIGURE 1-2:   A simple class  diagram.  FIGURE 1-3:   A class.  Drawing classes  The basic element in a class diagram is a class. In UML, each class is drawn as a  rectangle. At minimum, the rectangle must include the class name. You can sub- divide the rectangle into two or three compartments that can contain additional  information about the class, as shown in Figure 1-3.  The middle compartment of a class lists the class variables, whereas the bottom  compartment lists the class methods. The name of each variable or method can be  preceded by a visibility indicator, which can be one of the symbols listed in Table 1-1.    In actual practice, it’s common to omit the visibility indicator and list only those  fields or methods that have public visibility.   CHAPTER 1  Understanding Object-Oriented Programming      245   TABLE 1-1	  Visibility Indicators for Class Variables and Methods Indicator  Description  +  –    Public  Private  Protected  If you want, you can include type information for variables as well as for methods  and parameters. The type of a variable is indicated by following the variable name  with a colon and the type:  connectionString: String  A method’s return type is indicated in the same way:  getCustomer  : Customer  Parameters  are  listed  within  the  parentheses,  and  both  the  name  and  type  are  listed. For example:  getCustomer custno: int : Customer  Note:  Omitting  the  type  and  parameter  information  from  UML  diagrams  is  common.  Interfaces are drawn pretty much the same way as classes, but the class name is  preceded by the word interface:   >  ProductDB  Note: The word interface is enclosed within a set of double-left and double-right  arrows. These arrows aren’t just two less-than or greater-than symbols typed in  a row; they’re a special combination of symbols. Fortunately, the double-arrow  symbol is a standard part of the ASCII character set. You can access it in Microsoft  Word via the Insert Symbol command.  Drawing arrows  Besides using rectangles to represent classes, class diagrams include arrows to  represent  relationships  among  classes.  UML  uses  a  variety  of  types  of  arrows,   as I describe in the following paragraphs.  246      BOOK 3  Object-Oriented Programming   A solid line with a hollow closed arrow at one end represents inheritance:  The arrow points to the base class. A dashed line with a hollow closed arrow at one  end indicates that a class implements an interface:  The arrow points to the interface. A solid line with an open arrow indicates an  association:  An association simply indicates that two classes work together. It may be that one  of the classes creates objects of the other class or that one class requires an object  of the other class to perform its work. Or perhaps instances of one class contain  instances of the other class.  You can add a name to an association arrow to indicate its purpose. If an associa- tion arrow indicates that instances of one class create objects of another class, you  can place the word Creates next to the arrow.  CHAPTER 1  Understanding Object-Oriented Programming      247    IN THIS CHAPTER  » Creating your own class   » Looking at the pieces of a class   declaration   » Finding out about class fields   » Constructing constructors   » Adding methods to your classes   » Using the this keyword  Chapter 2 Making Your Own  Classes O     kay, class, it’s time to learn how to create your own classes.  In this chapter, you discover the basics of creating classes in Java. All Java pro- grams are classes, so you’ve already seen many examples of classes. You’ve seen  class headers such as public  class  GuessingGame and static methods such as  public static void main. Now, in this chapter, I show you how to create pro- grams that have more than one class.  Declaring a Class  All classes must be defined by a class declaration — lines of code that provide the  name for the class and the body of the class. Here’s the most basic form of a class  declaration:  [public] class ClassName {class-body}  CHAPTER 2  Making Your Own Classes      249   The public keyword indicates that this class is available for use by other classes.  Although it’s optional, you usually include it in your class declarations. After all,  the main reason you write class declarations is so other classes can create objects  from the class you’re defining.  Find out more about using the public keyword in  the section “Seeing where classes go,” later in this chapter.   In later chapters of this book, you find out about some additional elements that  can  go  in  a  class  declaration.  The  format  I’m  describing  here  is  just  the  basic   format used to create basic classes.  Picking class names  The ClassName is an identifier that provides a name for your class. You can use  any identifier you want to name a class, but the following three guidelines can  simplify your life:   » Begin the class name with a capital letter. If the class name consists of more  than one word, capitalize each word: for example, Ball, RetailCustomer, and  GuessingGame.   » Whenever possible, use nouns for your class names. Classes create   objects, and nouns are the words you use to identify objects. Thus most class  names should be nouns.   » Avoid using the name of a Java API class. No rule says that you absolutely  have to, but if you create a class that has the same name as a Java API class,  you have to use fully qualified names  such as java.util.Scanner  to tell  your class apart from the API class with the same name.  There are thousands of Java API classes, so avoiding them all is pretty hard.  But at the least, you should avoid commonly used Java class names, as well as  any API classes that your application is likely to use. Creating a class named  String or Math, for example, is just asking for trouble.  Knowing what goes in the class body  The class body of a class is everything that goes within the braces at the end of the  class declaration. The public class ClassName part of a class declaration takes  just one line, but the body of the class declaration may take hundreds of lines  or  thousands, if you get carried away .  The class body can contain the following elements:  250      BOOK 3  Object-Oriented Programming    » Fields: Variable declarations define the public or private fields of a class.  » Methods: Method declarations define the methods of a class.  » Constructors: A constructor is a block of code that’s similar to a method but  is run to initialize an object when an instance is created. A constructor must  have the same name as the class itself, and although it resembles a method,  it doesn’t have a return type.   » Initializers: These stand-alone blocks of code are run only once, when the  class is initialized. There are actually two types, called static initializers and  instance initializers. Although you won’t use them often, I talk about instance  initializers later in this chapter, in the section “Using Initializers.”  For informa- tion about static initializers, refer to Book 3, Chapter 3.    » Other classes and interfaces: A class can include another class, which is then  called an inner class or a nested class. Classes can also contain interfaces.  For  more information about inner classes, see Book 3, Chapter 7. And for  information about interfaces, refer to Book 3, Chapter 5.   Unlike some programming languages, Java doesn’t care about the order in which  items appear in the class body. Still, being consistent about the order in which you  place things in your classes is a good idea. That way you know where to find them.  I usually code all the fields together at the start of the class, followed by construc- tors  and  then  methods.  If  the  class  includes  initializers,  I  place  them  near  the  fields they initialize. And if the class includes inner classes, I usually place them  after the methods that use them.  Some programmers like to place the fields at the end of the class rather than at the  beginning. Whatever brings you happiness is fine with me.  The fields, methods, classes, and interfaces contained within a class are called the  members of the class. Constructors and initializers aren’t considered to be mem- bers, for reasons that are too technical to explain at this point.  You can find the  explanation in Book 3, Chapter 3.   Seeing where classes go  A public class must be written in a source file that has the same name as the class,  with  the  extension  java.  A  public  class  named  Greeter,  for  example,  must  be  placed in a file named Greeter.java.  CHAPTER 2  Making Your Own Classes      251   As  a  result,  you  can’t  place  two  public  classes  in  the  same  file.  The  following  source file  named DiceGame.java  won’t compile:  The compiler coughs up a message indicating that Dice is a public class and must  be declared in a file named Dice.java.  This problem has two solutions. The first is to remove the public keyword from  the Dice class:  public class DiceGame {     public static void main String[] args      {         Dice d = new Dice  ;         d.roll  ;     } } public class Dice {     public void roll       {            code that rolls the dice goes here     } }  public class DiceGame {     public static void main String[] args      {         Dice d = new Dice  ;         d.roll  ;     } } class Dice {     public void roll       {            code that rolls the dice goes here     } }  The compiler gladly accepts this program.  An inner class is a class that’s defined within the body of another class and is avail- able only from within that class.  For more information about inner classes, see  Book 3, Chapter 7.   252      BOOK 3  Object-Oriented Programming   Working with Members  When you code more than one class in a single source file, Java still creates a sepa- rate class file for each class. Thus, when you compile the DiceGame.java file, the  Java compiler creates two class files: DiceGame.class and Dice.class.  Removing the public keyword from a class is acceptable for relatively small pro- grams,  but  its  limitation  is  that  the  Dice  class  is  available  only  to  the  classes  defined  within  the  DiceGame.java  file.  If  you  want  the  Dice  class  to  be  more  widely available, opt for the second solution: Place it, with the public keyword, in  a separate file named Dice.java.  If you’re going to create an application that has several public classes, create a  separate folder for the application. Then save all the class files for the application  to this folder. If you keep your class files together in the same folder, the Java  compiler can find them. If you place them in separate folders, you may need to  adjust your ClassPath environment variable to help the compiler find the classes.  The  members  of  a  class  are  the  fields  and  methods  defined  in  the  class  body.    Technically,  classes  and  interfaces  defined  within  a  class  are  members  too.  I don’t discuss them in this chapter, though, so you can ignore them for now.   The following sections describe the basics of working with fields and methods in  your classes.  Understanding fields  A field is a variable that’s defined in the body of a class, outside any of the class’s  methods. Fields, which are also called class variables, are available to all the meth- ods of a class. In addition, if the field specifies the public keyword, the field is  visible outside the class. If you don’t want the field to be visible outside the class,  use the private keyword instead.  A field is defined the same as any other Java variable, but it can have a modifier  that specifies whether the field is public or private. Here are some examples of  public field declarations:  public int trajectory = 0; public String name; public Player player;  CHAPTER 2  Making Your Own Classes      253   To create a private field, specify private instead of public:  private int x_position = 0; private int y_position = 0; private String error-message = "";  Fields can also be declared as final:  public final int MAX_SCORE = 1000;  The  value  of  a  final  field  can’t  be  changed  after  it  has  been  initialized.  Note:  Spelling final field names with all capital letters is customary  but not required .  Understanding methods  You define methods for a class by using the same techniques that I describe in  Book 2, Chapter 7. To declare a method that’s available to users of your class, add  the public keyword to the method declaration:  public boolean isActive   {     return this.isActive; }  To create a private method that can be used within the class but isn’t visible out- side the class, use the private keyword:  private void calculateLunarTrajectory   {        code to get the calculated lunar trajectory }  Understanding visibility  In the preceding sections, I mention that both fields and methods can use the pub- lic or private keyword to indicate whether the field or method can be accessed  from outside the class. This is called the visibility of the field or method.  The combination of all the members that have public access is sometimes called  the public interface of your class. These members are the only means that other  objects  have  to  communicate  with  objects  created  from  your  class.  As  a  result,  carefully consider which public fields and methods your class declares.  254      BOOK 3  Object-Oriented Programming   Using Getters and Setters  The term expose is sometimes used to refer to the creation of public fields and  methods. If a class has a public method named isActive, for example, you could  say that the class exposes the isActive method. That simply means the method  is available to other classes.  You  can  use  private  fields  and  methods  within  a  class  —  but  not  from  other  classes. Private fields and methods provide implementation details that may be  crucial to the operation of your class but that shouldn’t be exposed to the outside  world. Private fields and methods are sometimes called internal members because  they’re available only from within the class.  One of the basic goals of object-oriented programming is to hide the implemen- tation details of a class inside the class while carefully controlling what aspects  of the class are exposed to the outside world. As a general rule, you should avoid  creating public fields. Instead, you can make all your fields private. Then you can  selectively grant access to the data those fields contain by adding to the class spe- cial methods called accessors.  There are two types of accessors. A get accessor  also called a getter  is a method  that retrieves a field value, whereas a set accessor  setter  is a method that sets a  field value. These methods are usually named getFieldName and setFieldName,  respectively. If the field is named count, for example, the getter and setter meth- ods are named getCount and setCount.  Here’s a class that uses a private field named Health to indicate the health of a  player in a game program:  public class Player {     private int health;      public int getHealth       {         return health;     }      public void setHealth int h      {         health = h;     } }  CHAPTER 2  Making Your Own Classes      255   Here the health field itself is declared as private, so it can’t be accessed directly.  Instead, it can be accessed only through the methods getHealth and setHealth.  Creating  classes  with  accessors  rather  than  simple  public  fields  offers  several  benefits:   » You can create a read-only property by providing a get accessor but not a set   accessor. Then other classes can retrieve the property value — but can’t  change it.   » Instead of storing the property value in a private field, you can calculate it   each time the get accessor method is called. Suppose you have a class named  Order that includes fields named unitPrice and quantityOrdered. This  class might also contain a getOrderTotal method that looks like this:      public double getOrderTotal       {         return unitPrice * quantityOrdered;     }  Here, instead of returning the value of a class field, the get accessor calculates  the value to be returned.   » You can protect the class from bad data by validating data in a property set  accessor and either ignoring invalid data or throwing an exception if invalid  data is passed to the method. Suppose that you have a set accessor for an  int property named Health whose value can range from 0 to 100. Here’s  a set accessor that prevents the Health property from being set to an  incorrect value:      public void setHealth int h      {         if  h < 0              health = 0;         else if  h > 100              health = 100;         else             health = h;     }  Here, if the setHealth method is called with a value less than 0, health is set  to 0. Likewise, if the value is greater than 100, health is set to 100.  For  a  little  added  insight  on  the  use  of  accessors,  see  the  nearby  sidebar  “The  Accessor pattern.”  256      BOOK 3  Object-Oriented Programming   THE ACCESSOR PATTERN  The use of accessors  as described in the section “Using Getters and Setters” in this  chapter  is an example of a design pattern that’s commonly used by Java programmers.  The Accessor pattern is designed to provide a consistent way to set or retrieve the value  of class fields without having to expose the fields themselves to the outside world.  Most Java programmers quickly learn that one of the basic guidelines of object-oriented  programming is to avoid public fields. Unfortunately, they often respond to this guide- line by making all fields private and then providing get and set accessors for every field,  whether they need them or not. So they write classes that look like this:  public class MyClass {     private int fieldX;     private int fieldY;     public int getX   { return x; }     public void setX int xValue  { this.x = xValue; }     public int getY   { return y; }     public void setY int yValue  { this.y = yValue; } }  Why not just make fieldX and fieldY public fields and skip the accessors?  If all your accessors do is set and return the values, without doing any data validation  or other processing, you may as well skip them. The point of making your fields private  is to carefully control access to them. If you’re going to use accessors for all your fields,  you might as well make the fields public.  Instead, carefully consider which fields really should be accessible to the outside  world — and provide accessors only for those fields that really need them.  Overloading Methods  A Java class can contain two or more methods with the same name, provided that  those methods accept different parameters. This technique, called overloading, is  one of the keys to building flexibility into your classes. With overloading, you can  anticipate different ways that someone might want to invoke an object’s functions  and then provide overloaded methods for each alternative.  CHAPTER 2  Making Your Own Classes      257   The  term  overloading  is  accurate  but  a  little  unfortunate.  Normally,  when  you  say  that  something  is  overloaded,  there’s  a  problem.  I  once  saw  a  picture  of  a  Volkswagen Jetta loaded down with 3,000 pounds of lumber.  You can find the   picture  courtesy  of  Snopes.com,  the  Urban  Legend  Reference  Page  website,  at  www.snopes.com photos automobiles lumber.asp.  That’s a classic example of  overloading in the ordinary sense. Fortunately, you don’t have to worry about Java  collapsing under the weight of overloaded methods.  You’re already familiar with several classes that have overloaded methods, though  you may not realize it. The PrintWriter class, for example  which you access via  System.out , defines 10 versions of the println method that allow you to print  different types of data. The following lines show the method declaration for each  of these overloads:  void println   void println boolean x  void println char x  void println char[] x  void println double x  void println float x  void println int x  void println long x  void println Object x  void println String x   The basic rule in creating overloaded methods is that every method must have  a unique signature. A method’s signature is the combination of its name and the  number and types of parameters it accepts. Thus, each of the println methods  has a different signature, because although all the methods have the same name,  each method accepts a different parameter type.  Two things that are not a part of a method’s signature are   » The method’s return type: You can’t code two methods with the same name   and parameters but with different return types.   » The names of the parameters: All that matters to the method signature are   the types of the parameters and the order in which they appear. Thus the  following two methods have the same signature:  double someMethodOfMine double x, boolean y  double someMethodOfMine double param1, boolean param2   258      BOOK 3  Object-Oriented Programming   Creating Constructors  A  constructor  is  a  block  of  code  that’s  called  when  an  instance  of  an  object  is   created. In many ways, a constructor is similar to a method, but a few differ- ences exist:   » A constructor doesn’t have a return type.  » The name of the constructor must be the same as the name of the class.  » Unlike methods, constructors are not considered to be members of a class.    That’s important only when it comes to inheritance, which is covered in  Book 3, Chapter 4.    » A constructor is called when a new instance of an object is created. In fact, it’s  the new keyword that calls the constructor. After creating the object, you can’t  call the constructor again.  Here’s the basic format for coding a constructor:  public ClassName  parameter-list  [throws exception...] {     statements... }  The public keyword indicates that other classes can access the constructor. That’s  usually what you want, although in the next chapter, you see why you might want  to create a private constructor. ClassName must be the same as the name of the  class that contains the constructor. You code the parameter list the same way that  you code it for a method.  Notice also that a constructor can throw exceptions if it encounters situations that  it can’t recover from.  For more information about throwing exceptions, refer to  Book 2, Chapter 8.   Creating basic constructors  Probably the most common reason for coding a constructor is to provide initial  values for class fields when you create the object. Suppose that you have a class   CHAPTER 2  Making Your Own Classes      259   named Actor that has fields named firstName and lastName. You can create a  constructor for the Actor class:  public Actor String first, String last  {     firstName = first;     lastName = last; }  Then you create an instance of the Actor class by calling this constructor:  Actor a = new Actor "Arnold", "Schwarzenegger" ;  A new Actor object for Arnold Schwarzenegger is created.  Like methods, constructors can be overloaded. In other words, you can provide  more than one constructor for a class, provided that each constructor has a unique  signature. Here’s another constructor for the Actor class:  public Actor String first, String last, boolean good  {     firstName = first;     lastName = last;     goodActor = good; }  This  constructor  lets  you  create  an  Actor  object  with  information  besides  the  actor’s name:  Actor a = new Actor "Arnold", "Schwarzenegger", false ;  Creating default constructors  I grew up watching Dragnet. I can still hear Joe Friday reading some thug his rights:  “You have the right to an attorney during questioning. If you desire an attorney  and cannot afford one, an attorney will be appointed to you free of charge.”  Java  constructors  are  like  that.  Every  class  has  a  right  to  a  constructor.  If  you  don’t provide a constructor, Java appoints one for you, free of charge. This free  constructor is called the default constructor. It doesn’t accept any parameters and  doesn’t do anything, but it does allow your class to be instantiated.  Thus, the following two classes are identical:  260      BOOK 3  Object-Oriented Programming   public Class1 {     public Class1   { } }  public Class1 { }  In the first example, the class explicitly declares a constructor that doesn’t accept any  parameters and has no statements in its body. In the second example, Java creates a  default constructor that works just like the constructor shown in the first example.  The default constructor is not created if you declare any constructors for the class.  As a result, if you declare a constructor that accepts parameters and still want to  have an empty constructor  with no parameters and no body , you must explicitly  declare an empty constructor for the class.  An example might clear this point up. The following code does not compile:  public class BadActorApp {     public static void main String[] args      {         Actor a = new Actor  ;       error: won't compile     } }  class Actor {     private String lastName;     private String firstName;     private boolean goodActor;      public Actor String last, String first      {         lastName = last;         firstName = first;     }      public Actor String last, String first, boolean good      {         lastName = last;         firstName = first;         goodActor = good;     } }  CHAPTER 2  Making Your Own Classes      261   This program won’t compile because it doesn’t explicitly provide a default con- structor for the Actor class; because it does provide other constructors, the default  constructor isn’t generated automatically.  Calling other constructors  A constructor can call another constructor of the same class by using the special  keyword this as a method call. This technique is commonly used when you have  several constructors that build on one another.  Consider this class:  public class Actor {     private String lastName;     private String firstName;     private boolean goodActor;      public Actor String last, String first      {         lastName = last;         firstName = first;     }      public Actor String last, String first, boolean good      {         this last, first ;         goodActor = good;     } }  Here the second constructor calls the first constructor to set the  lastName and  firstName fields. Then it sets the goodActor field.  You have a few restrictions in using the this keyword as a constructor call:   » You can call another constructor only in the very first statement of a constructor.   Thus, the following code won’t compile:      public Actor String last, String first, boolean good      {         goodActor = good;         this last, first ;    error: won't compile     }  262      BOOK 3  Object-Oriented Programming   If you try to compile a class with this constructor, you get a message saying  call to this must be first statement in constructor.   » Each constructor can call only one other constructor, but you can chain   constructors. If a class has three constructors, the first constructor can call the  second one, which in turn calls the third one.   » You can’t create loops in which constructors call one another. Here’s a class   that won’t compile:  class CrazyClass {     private String firstString;     private String secondString;      public CrazyClass String first, String second      {           this first ;           secondString = second;     }      public CrazyClass String first      {           this first, "DEFAULT" ;     error: won't                                       compile     } }  The first constructor starts by calling the second constructor, which calls the  first constructor. The compiler complains that this error is a recursive  constructor invocation and politely refuses to compile the class.  If  you  don’t  explicitly  call  a  constructor  in  the  first  line  of  a  constructor,  Java  inserts code that automatically calls the default constructor of the base class —  that  is,  the  class  that  this  class  inherits.   This  little  detail  doesn’t  become  too  important until you get into inheritance, which is covered in Book 3, Chapter 4, so  you can conveniently ignore it for now.   Finding More Uses for the this Keyword  As I describe in the preceding section, you can use the this keyword in a con- structor to call another constructor for the current class. You can also use this  in the body of a class constructor or method to refer to the current object — that  is, the class instance for which the constructor or method has been called.  CHAPTER 2  Making Your Own Classes      263   The this keyword is usually used to qualify references to instance variables of the  current object. For example:  public Actor String last, String first  {     this.lastName = last;     this.firstName = first; }  Here this isn’t really necessary because the compiler can tell that lastName and  firstName refer to class variables. Suppose, however, that you use lastName and  firstName as the parameter names for the constructor:  public Actor String lastName, String firstName  {     this.lastName = lastName;     this.firstName = firstName; }  Here the this keywords are required to distinguish among the parameters named  lastName and firstName and the instance variables with the same names.  You can also use this in a method body. For example:  public String getFullName   {     return this.firstName + " " + this.lastName; }  Because  this  example  has  no  ambiguity,  this  isn’t  really  required.  Many  pro- grammers  like  to  use  this  even  when  it  isn’t  necessary,  however,  because  it   clarifies that they’re referring to an instance variable.  Sometimes you use the this keyword all by itself to pass a reference to the current  object as a method parameter. You can print the current object to the console by  using the following statement:  System.out.println this ;  The println method calls the object’s toString method to get a string represen- tation of the object and then prints it to the console. By default, toString prints  the name of the class that the object was created from and the object’s hash code.  If you want the println method to print something more meaningful, provide a  toString method of your own for the class.  264      BOOK 3  Object-Oriented Programming   Using Initializers  An initializer  sometimes called an initializer block  is a lonely block of code that’s  placed  outside  any  method,  constructor,  or  other  block  of  code.  Initializers  are  executed whenever an instance of a class is created, regardless of which construc- tor is used to create the instance.  Initializer blocks are similar to variable initializers used to initialize variables. The  difference is that with an initializer block, you can code more than one statement.  Here’s a class that gets the value for a class field from the user when the class is  initialized:  You can almost always achieve the same effect by using other coding techniques,  which usually are more direct. You could prompt the user for the value in the con- structor, for example, or you could call a method in the field initializer, like this:  class PrimeClass {     private Scanner sc = new Scanner System.in ;      public int x;      {         System.out.print              "Enter the starting value for x: " ;         x = sc.nextInt  ;     }  }  class PrimeClass {    private Scanner sc = new Scanner System.in ;     public int x = getX  ;     private int getX      {       System.out.print "Enter the starting value "         + "for x: " ;       return sc.nextInt  ;    } }  CHAPTER 2  Making Your Own Classes      265   Either way, the effect is the same.  Here are a few other tidbits of information concerning initializers:   » If a class contains more than one initializer, the initializers are executed in the   order in which they appear in the program.   » Initializers are executed before any class constructors.  » A special kind of initializer block called a static initializer lets you initialize static   fields.  For more information, see the next chapter.    » Initializers are sometimes used with anonymous classes, as I describe in   Book 3, Chapter 6.  266      BOOK 3  Object-Oriented Programming   IN THIS CHAPTER  » Adding static fields to a class   » Creating static methods   » Creating classes that can be   instantiated   » Working with static initializers  Chapter 3 Working with Statics  Astatic method is a method that isn’t associated with an instance of a class.    Unless  you  jumped  straight  to  this  chapter,  you  already  knew  that.   Instead, the method belongs to the class itself. As a result, you can call  the method without first creating a class instance. In this chapter, you find out  everything you need to know about creating and using static fields and methods.  Understanding Static Fields and Methods  According to my handy Webster’s dictionary, the word static has several meanings,  most of which relate to the idea of being stationary or unchanging. A static display  is a display that doesn’t move. Static electricity is an electrical charge that doesn’t  flow. A static design is a design that doesn’t change.  As used by Java, however, the term static doesn’t mean unchanging. You can cre- ate a static field, for example, and then assign values to it as a program executes.  Thus, the value of the static field can change.  To confuse things further, the word static can also mean interference, as in radio  static that prevents you from hearing music clearly on the radio. But in Java, the  term static doesn’t have anything to do with interference or bad reception.  CHAPTER 3  Working with Statics      267   So what does the term static mean in Java? It’s used to describe a special type of  field or method that isn’t associated with a particular instance of a class. Instead,  static fields and methods are associated with the class itself, which means that  you don’t have to create an instance of the class to access a static field or methods.  Instead, you access a static field or method by specifying the class name, not a  variable that references an object.  The value of a static field is the same across all instances of the class. In other  words, if a class has a static field named CompanyName, all objects created from the  class will have the same value for CompanyName.  Static fields and methods have many common uses. Here are but a few:   » To provide constants or other values that aren’t related to class   instances: A Billing class might have a constant named SALES_TAX_RATE  that provides the state sales tax rate.   » To keep count of how many instances of a class have been created: A  Ball class used in a game might have a static field that counts how many  balls currently exist. This count doesn’t belong to any one instance of the Ball  class.   » In a business application, to keep track of a reference or serial number   that’s assigned to each new object instance: An Invoice class might  maintain a static field that holds the invoice number that is assigned to the  next Invoice object created from the class.   » To provide an alternative way to create instances of the class: An   excellent example is the NumberFormat class, which has static methods such  as getCurrencyInstance and getNumberInstance that return object  instances to format numbers in specific ways. One reason you might want to  use this technique is to create classes that can have only one object instance.  This type of class, called a singleton class, is described in the sidebar “The  Singleton pattern,” later in this chapter.   » To provide utility functions that aren’t associated with an object at all: A  good example in the Java API library is the Math class, which provides a bunch  of static methods to do math calculations. Examples that you might code  yourself are a DataValidation class with static methods that validate input  data and a database class with static methods that perform database  operations.  268      BOOK 3  Object-Oriented Programming   Working with Static Fields  A static field is a field that’s declared with the static keyword, like this:  private static int ballCount;  Note that the position of the static keyword is interchangeable with the posi- tions of the visibility keywords  private and public, as well as protected, which  I describe in the next chapter . As a result, the following statement works as well:  static private int ballCount;  As a convention, most programmers tend to put the visibility keyword first.  Note that you can’t use the static keyword within a class method. Thus the fol- lowing code won’t compile:     s c i t a t S h t i w g n k r o W  i     private void someMethod   {     static int x; }  In other words, fields can be static, but local variables can’t.  You can provide an initial value for a static field. Here’s an example:  private static String district = "Northwest";  Static fields are created and initialized when the class is first loaded. That happens  when a static member of the class is referred to or when an instance of the class  is created, whichever comes first.  Another way to initialize a static field is to use a static initializer, which I cover later  in this chapter, in the section “Using Static Initializers.”  Using Static Methods  A static method is a method declared with the static keyword. Like static fields,  static methods are associated with the class itself, not with any particular object  created from the class. As a result, you don’t have to create an object from a class  before you can use static methods defined by the class.  CHAPTER 3  Working with Statics      269   The best-known static method is main, which is called by the Java runtime to start  an application. The main method must be static — which means that applications  are run in a static context by default.  One of the basic rules of working with static methods is that you can’t access a  nonstatic method or field from a static method, because the static method doesn’t  have an instance of the class to use to reference instance methods or fields. The  following code won’t compile:  public class TestClass {     private int x = 5;         an instance field      public static void main String[] args      {         int y = x;             error: won't compile     } }  Here the main method is static, so it can’t access the instance variable x.  Note: You can access static methods and fields from an instance method, however.  The following code works fine:  public class Invoice {     private static double taxRate = 0.75;      private double salesTotal;      public double getTax       {         return salesTotal * taxRate;     } }  Here the instance method named salesTotal has no trouble accessing the static  field taxRate.  Counting Instances  One common use for static variables is to keep track of how many instances of a  class have been created. To illustrate how you can do this, consider the program   270      BOOK 3  Object-Oriented Programming   in Listing 3-1. This program includes two classes. The CountTest class is a simple  class that keeps track of how many times its constructor has been called. Then the  CountTestApp class uses a for loop to create 10 instances of the class, displaying  the number of instances that have been created after it creates each instance.  Note  that  the  instance  count  in  this  application  is  reset  to  zero  each  time  the  application is run. As a result, it doesn’t keep track of how many instances of the  CountTest class have ever been created — only of how many have been created  during a particular execution of the program.  LISTING 3-1:   The CountTest Application  public class CountTestApp  {     public static void main String[] args      {         printCount  ;         for  int i = 0; i < 10; i++          {             CountTest c1 = new CountTest  ;              printCount  ;          }     }      private static void printCount       {         System.out.println "There are now "              + CountTest.getInstanceCount               + " instances of the CountTest class." ;     } } class CountTest  {     private static int instanceCount = 0;       public CountTest        {         instanceCount++;     }      public static int getInstanceCount        {         return instanceCount;     } }     s c i t a t S h t i w g n k r o W  i     →1  →8 →9  →15  →21  →23  →25  →29  CHAPTER 3  Working with Statics      271   The following paragraphs describe some of the highlights of this program:  →1    This line is the start of the CountTestApp class, which tests the  CountTest class.   →8    →9    →15    →21   →23   →25    →29    This line creates an instance of the CountTest class. Because this code is  contained in a for loop, 10 instances are created.   This line calls the printCount method, which prints the number of  CountTest objects that have been created so far.   This line prints a message indicating how many CountTest objects have  been created so far. It calls the static getInstanceCount method of the  CountTest class to get the instance count.   This line is the start of the CountTest class.  The static instanceCount variable stores the instance count.   This line is the constructor for the CountTest class. Notice that the  instanceCount variable is incremented within the constructor. That  way, each time a new instance of the class is created, the instance count  is incremented.   The static getInstanceCount method simply returns the value of the  static instanceCount field.  THE SINGLETON PATTERN  A singleton is a class that you can use to create only one instance. When you try to create  an instance, the class first checks to see whether an instance already exists. If so, the  existing instance is used; if not, a new instance is created.  You can’t achieve this effect by using Java constructors, because a class instance has  already been created by the time the constructor is executed.  That’s why you can use  the this keyword from within a constructor.  As a result, the normal way to implement  a singleton class is to declare all the constructors for the class as private. That way, the  constructors aren’t available to other classes. Then you provide a static method that  returns an instance. This method either creates a new instance or returns an existing  instance.  Here’s a bare-bones example of a singleton class:  class SingletonClass {    private static SingletonClass instance;  272      BOOK 3  Object-Oriented Programming      private SingletonClass      {    }     public static SingletonClass getInstance      {       if  instance == null            instance = new SingletonClass  ;       return instance;     } }  Here the SingletonClass contains a private instance variable that maintains a ref- erence to an instance of the class. Then a default constructor is declared with private  visibility to prevent the constructor from being used outside the class. Finally, the static  getInstance method calls the constructor to create an instance if the instance vari- able is null. Then it returns the instance to the caller.  Here’s a bit of code that calls the getInstance method twice and then compares the  resulting objects:     s c i t a t S h t i w g n k r o W  i     SingletonClass s1 = SingletonClass.getInstance  ; SingletonClass s2 = SingletonClass.getInstance  ; if  s1 == s2     System.out.println "The objects are the same" ; else    System.out.println "The objects are not the same" ;  When this code is run, the first call to getInstance creates a new instance of the  SingletonClass class. The second call to getInstance simply returns a reference to  the instance that was created in the first call. As a result, the comparison in the if state- ment is true, and the first message is printed to the console.  Preventing Instances  Sometimes you want to create a class that can’t be instantiated at all. Such a class  consists entirely of static fields and methods. A good example in the Java API is the  Math class. Its methods provide utility-type functions that aren’t really associated  with a particular object. You may need to create similar classes yourself occasion- ally. You might create a class with static methods for validating input data, for  example, or a database access class that has static methods to retrieve data from a  database. You don’t need to create instances of either of these classes.  CHAPTER 3  Working with Statics      273   You can use a simple trick to prevent anyone from instantiating a class. To create  a class instance, you have to have at least one public constructor. If you don’t pro- vide a constructor in your class, Java automatically inserts a default constructor,  which happens to be public.  All you have to do to prevent a class instance from being created, then, is provide  a single private constructor, like this:  public class Validation {     private Validation   {}          prevents instances         static methods and fields go here }  Now, because the constructor is private, the class can’t be instantiated.  Incidentally,  the  Math  class  uses  this  technique  to  prevent  you  from  creating  instances from it. Here’s an actual snippet of code from the Math class:  public final class Math {      **      * Don't let anyone instantiate this class.      *      private Math   {}  I figure that if this trick is good enough for the folks who wrote the Math class, it’s  good enough for me.  Using Static Initializers  In the preceding chapter, you discover initializer blocks that you can use to initial- ize instance variables. Initializer blocks aren’t executed until an instance of a class  is created, so you can’t count on them to initialize static fields. After all, you might  access a static field before you create an instance of a class.  Java provides a feature called a static initializer that’s designed specifically to let  you initialize static fields. The general form of a static initializer looks like this:  static { statements... }  274      BOOK 3  Object-Oriented Programming   As you can see, a static initializer is similar to an initializer block but begins with  the word static. As with an initializer block, you code static initializers in the  class body but outside any other block, such as the body of a method or constructor.  The first time you access a static member such as a static field or a static method,  any  static  initializers  in  the  class  are  executed  —  provided  that  you  haven’t  already created an instance of the class. That’s because the static initializers are  also executed the first time you create an instance. In that case, the static initial- izers are executed before the constructor is executed.  If a class has more than one static initializer, the initializers are executed in the  order in which they appear in the program.  Here’s an example of a class that contains a static initializer:  class StaticInit {     public static int x;     static     {         x = 32;     }    other class members such as constructors and    methods go here... }  This  example  is  pretty  trivial.  In  fact,  you  can  achieve  the  same  effect  just  by  assigning the value 32 to the variable when it is declared. If, however, you had  to perform a complicated calculation to determine the value of x — or if its value  comes from a database — a static initializer could be very useful.     s c i t a t S h t i w g n k r o W  i     CHAPTER 3  Working with Statics      275    IN THIS CHAPTER  » Explaining inheritance   » Creating subclasses   » Using protected access   » Creating final classes   » Demystifying polymorphism   » Creating custom exception classes  Chapter 4 Using Subclasses  and Inheritance  As you find out in Book 3, Chapter 1, a Java class can be based on another   class. Then the class becomes like a child to the parent class: It inherits  all the characteristics of the parent class, good and bad. All the fields and  methods of the parent class are passed on to the child class. The child class can  use these fields or methods as they are, or it can override them to provide its own  versions. In addition, the child class can add fields or methods of its own.  In this chapter, you discover how this magic works, along with the basics of creat- ing and using Java classes that inherit other classes. You also find out a few fancy  tricks that help you get the most out of inheritance.  Introducing Inheritance  The word inheritance conjures up several noncomputer meanings:   » Children inherit certain characteristics from the parents. Two of my three  children have red hair, for example.  Ideally, they won’t be half bald by the  time they’re 30.   CHAPTER 4  Using Subclasses and Inheritance      277    » Children can also inherit behavior from their parents. As they say, the apple   doesn’t fall far from the tree.   » When someone dies, his heirs get his stuff. Some of it is good stuff, but some  of it may not be. My kids are going to have a great time rummaging through  my garage, deciding who gets what.   » You can inherit rights as well as possessions. You may be a citizen of a country   by virtue of being born to parents who are citizens of that country.  In Java, inheritance refers to a feature of object-oriented programming that lets  you  create  classes  that  are  derived  from  other  classes.  A  class  that’s  based  on  another class is said to inherit the other class. The class that is inherited is called  the parent class, the base class, or the superclass. The class that does the inheriting is  called the child class, the derived class, or the subclass.  The terms subclass and superclass seem to be the preferred terms among Java gurus.  So if you want to look like you know what you’re talking about, use these terms.  Also, be aware that the term subclass can be used as a verb. When you create a  subclass that inherits a base class, for example, you are subclassing the base class.  You need to know a few important things about inheritance:   » A derived class automatically takes on all the behavior and attributes of its  base class. Thus, if you need to create several classes to describe types that  aren’t identical but have many features in common, you can create a base  class that defines all the common features. Then you can create several  derived classes that inherit the common features.   » A derived class can add features to the base class it inherits by defining its  own methods and fields. This is one way that a derived class distinguishes  itself from its base class.   » A derived class can also change the behavior provided by the base class. A   base class may provide that all classes derived from it have a method named  play, for example, but each class is free to provide its own implementation of  the play method. In this case, all classes that extend the base class provide  their own implementation of the play method.   » Inheritance is best used to implement is-a-type-of relationships. Here are a few  examples: Solitaire is a type of game; a truck is a type of vehicle; an invoice is a  type of transaction. In each case, a particular kind of object is a specific type of  a more general category of objects.  The following sections provide more examples that help illustrate these points.  278      BOOK 3  Object-Oriented Programming   Motorcycles, trains, and automobiles  Inheritance  is  often  explained  in  terms  of  real-world  objects  such  as  cars  and  motorcycles  or  birds  and  reptiles.  Consider  various  types  of  vehicles.  Cars  and  motorcycles are two distinct types of vehicles. If you’re writing software that rep- resents  vehicles,  you  could  start  by  creating  a  class  called  Vehicle  that  would  describe the features that are common to all types of vehicles, such as wheels; a  driver; the ability to carry passengers; and the ability to perform actions such as  driving, stopping, turning, and crashing.  A motorcycle is a type of vehicle that further refines the Vehicle class. The Motor  cycle class would inherit the Vehicle class, so it would have wheels; a driver;  possibly passengers; and the ability to drive, stop, turn, and crash. In addition, it  would have features that differentiate it from other types of vehicles, such as two  wheels and handlebars used for steering control.  A car is also a type of vehicle. The Car class would inherit the Vehicle class, so  it too would have wheels; a driver; possibly some passengers; and the ability to  drive, stop, turn, and crash. Also, it would have some features of its own, such as  four wheels, a steering wheel, seat belts and air bags, and an optional automatic  transmission.  Game play  Because you’re unlikely ever to write a program that simulates cars, motorcycles,  and other vehicles, take a look at a more common example: games. Suppose that  you want to develop a series of board games such as Life, Sorry!, and Monopoly.  Most board games have certain features in common:   » They have a playing board with locations that players can occupy.  » They have players that are represented by objects.  » The game is played by each player taking a turn, one after the other. When  the game starts, it keeps going until someone wins.  If you don’t believe me,  ask the kids who tried to stop a game of Jumanji before someone won.   Each specific type of game has these basic characteristics but adds features of its  own.  The  game  Life  adds  features  such  as  money,  insurance  policies,  spouses,  children, and a fancy spinner in the middle of the board. Sorry! has cards that you  draw to determine each move and safety zones within which other players can’t  attack you. Monopoly has Chance and Community Chest cards, properties, houses,  hotels, and money.  CHAPTER 4  Using Subclasses and Inheritance      279   If you were designing classes for these games, you might create a generic Board  Game class that defines the basic features common to all board games and then  use it as the base class for classes that represent specific board games, such as  LifeGame, SorryGame, and MonopolyGame.  A businesslike example  If vehicles or games don’t make the point clear enough, here’s an example from  the world of business. Suppose that you’re designing a payroll system, and you’re  working on the classes that represent the employees. You realize that the pay- roll includes two types of employees: salaried employees and hourly  employees.  So  you  decide  to  create  two  classes,  sensibly  named  SalariedEmployee  and  HourlyEmployee.  You quickly discover that most of the work done by these two classes is identical.  Both types of employees have names, addresses, Social Security numbers, totals  for how much they’ve been paid for the year, how much tax has been withheld,  and so on.  The employee types also have important differences. The most obvious one is that  the salaried employees have an annual salary, and the hourly employees have an  hourly  pay  rate.  Also,  hourly  employees  have  a  schedule  that  changes  week  to  week, and salaried employees may have a benefit plan that isn’t offered to hourly  employees.  Thus you decide to create three classes instead of just two. A class named Employee  handles all the features that are common to both types of employees; then this  class is the base class for the SalariedEmployee and Hourly  Employee classes.  These classes provide the additional features that distinguish salaried employees  from hourly employees.  Inheritance hierarchies  One of the most important aspects of inheritance is that a class derived from a  base class can in turn be used as the base class for another derived class. Thus you  can use inheritance to form a hierarchy of classes.  You’ve already seen how an Employee class can be used as a base class to create  two  types  of  subclasses:  a  SalariedEmployee  class  for  salaried  employees  and  an HourlyEmployee class for hourly employees. Suppose that salaried employees  fall into two categories: management and sales. Then you could use the Salaried  Employee class as the base class for two more classes: Manager and SalesPerson.  280      BOOK 3  Object-Oriented Programming   Creating Subclasses  Thus, a Manager is a type of SalariedEmployee. Because a SalariedEmployee is a  type of Employee, a Manager is also a type of Employee.  All  classes  ultimately  derive  from  a  Java  class  named  Object.  Any  class  that  doesn’t specifically state what class it is derived from is assumed to derive from  the  Object  class.  This  class  provides  some  of  the  basic  features  that  are  com- mon to all Java classes, such as the toString method. For more information, see  Book 3, Chapter 6.  The basic procedure for creating a subclass is simple: You just use the extends  keyword on the declaration for the subclass. The basic format of a class declara- tion for a class that inherits a base class is this:  public class ClassName extends BaseClass {        class body goes here }  Suppose that you have a class named Ball that defines a basic ball, and you want  to create a subclass named BouncingBall that adds the ability to bounce:  public class BouncingBall extends Ball {        methods and fields that add the ability to bounce        to a basic Ball object:     public void bounce       {            the bounce method     } }  }  Here  I’m  creating  a  class  named  BouncingBall  that  extends  the  Ball  class.   Extends is Java’s word for inherits.   The subclass automatically has all the methods and fields of the class it extends.  Thus, if the Ball class has fields named size and weight, the BouncingBall class  has those fields too. Likewise, if the Ball class has a method named throw, the  BouncingBall class gets that method too.  CHAPTER 4  Using Subclasses and Inheritance      281   THE DELEGATION PATTERN  Inheritance is one of the great features of object-oriented programming languages  such as Java, but it isn’t the answer to every programming problem. Also, quite frankly,  many Java programmers use it too much. In many cases, simply including an instance of  one class in another class is easier than using inheritance. This technique is sometimes  called the Delegation pattern.  Suppose that you need to create a class named EmployeeCollection that repre- sents a group of employees. One way to create this class would be to extend one of  the collection classes supplied by the Java API, such as the ArrayList class. Then your  EmployeeCollection class would be a specialized version of the ArrayList class and  would have all the methods that are available to the ArrayList class.  A simpler alternative, however, would be to declare a class field of type ArrayList  within your EmployeeCollection class. Then you could provide methods that use this  ArrayList object to add or retrieve employees from the collection.  Why is this technique called the delegation? Rather than write code that implements  the functions of the collection, you delegate that task to an ArrayList object, because  ArrayList objects already know how to perform these functions.  For more informa- tion about the ArrayList class, see Book 4, Chapter 3.   You need to know some important details to use inheritance properly:   » A subclass inherits all the members from its base class. Constructors are not  considered to be members, however. As a result, a subclass does not inherit  constructors from its base class.   » The visibility  public or private  of any members inherited from the base  class is the same in the subclass. That means that you can’t access from the  subclass methods or fields that are declared in the base class as private.   » You can override a method by declaring a new member with the same  signature in the subclass. For more information, see the next section.   » A special type of visibility called protected hides fields and methods from  other classes but makes them available to subclasses. For more information,  see the section “Protecting Your Members,” later in this chapter.   » You can add more methods or fields, private or protected, to a subclass.  The BouncingBall class shown earlier in this section, for example, adds a  public method named bounce.  282      BOOK 3  Object-Oriented Programming   Overriding Methods  If a subclass declares a method that has the same signature as a public method of  the base class, the subclass version of the method overrides the base class version  of the method. This technique lets you modify the behavior of a base class to suit  the needs of the subclass.  Suppose you have a base class named Game that has a method named play. The  base class, which doesn’t represent any particular game, implements this method:  public class Game {     public void play       {     } }  Then you declare a class named Chess that extends the Game class but also pro- vides an implementation for the play method:  public class Chess extends Game {     public void play       {         System.out.println "I give up. You win." ;     } }  Here, when you call the play method of a Chess object, the game announces that  it gives up.  I was going to provide a complete implementation of an actual chess  game program for this example, but it would have made this chapter about 600  pages long. So I opted for the simpler version here.   Note that to override a method, three conditions have to be met:   » The class must extend the class that defines the method you want to override.  » The method must be declared in the base class with public access. You can’t   override a private method.   » The method in the subclass must have the same signature as the method in  the base class. In other words, the name of the method and the parameter  types must be the same.  CHAPTER 4  Using Subclasses and Inheritance      283   Protecting Your Members  You’re already familiar with the public and private keywords, which are used  to indicate whether class members are visible outside the class or not. When you  inherit a class, all the public members of the superclass are available to the sub- class, but the private members aren’t. They do become part of the derived class,  but you can’t access them directly in the derived class.  Java provides a third visibility option that’s useful when you create subclasses:  protected. A member with protected visibility is available to subclasses but not  to other classes. Consider this example:  public class Ball {     private double weight;     protected double getWeight       {         return this.weight;     }     protected void setWeight double weight      {         this.weight = weight;     } } public class BaseBall extends Ball {     public BaseBall       {         setWeight 5.125 ;     } }  Here, the getWeight and setWeight methods are declared with protected access,  which means that they’re visible in the subclass BaseBall. These methods aren’t  visible to classes that don’t extend Ball, however.  Using this and super in Your Subclasses  You already know about the this keyword: It provides a way to refer to the cur- rent object instance. It’s often used to distinguish between a local variable or a  parameter and a class field with the same name. For example:  284      BOOK 3  Object-Oriented Programming   public class Ball {     private int velocity;     public void setVelocity int velocity      {         this.velocity = velocity;     } }  Here  the  this  keyword  indicates  that  the  velocity  variable  referred  to  on  the  left side of the assignment statement is the class field named velocity, not the  parameter with the same name.  But what if you need to refer to a field or method that belongs to a base class? To  do that, you use the super keyword. It works similarly to this but refers to the  instance of the base class rather than the instance of the current class.  Consider these two classes:  public class Ball {     public void hit       {         System.out.println "You hit it a mile!" ;     } } class BaseBall extends Ball {     public void hit       {         System.out.println "You tore the cover off!" ;         super.hit  ;     } }  Here the hit method in the BaseBall class calls the hit method of its base class  object. Thus, if you call the hit method of a BaseBall object, the following two  lines are displayed on the console:  You tore the cover off! You hit it a mile!  You can also use the super keyword in the constructor of a subclass to explicitly  call a constructor of the superclass. For more information, see the next section.  CHAPTER 4  Using Subclasses and Inheritance      285   Understanding Inheritance  and Constructors  When  you  create  an  instance  of  a  subclass,  Java  automatically  calls  the  default  constructor of the base class before it executes the subclass constructor. Consider  the following classes:  public class Ball {     public Ball       {         System.out.println              "Hello from the Ball constructor" ;     } } public class BaseBall extends Ball {     public BaseBall       {         System.out.println              "Hello from the BaseBall constructor" ;     } }  If you create an instance of the BaseBall class, the following two lines are dis- played on the console:  Hello from the Ball constructor Hello from the BaseBall constructor  If you want, you can explicitly call a base class constructor  from a subclass by  using the super keyword. Because Java automatically calls the default construc- tor for you, the only reason to do this is to call a constructor of the base class that  uses a parameter. Here’s a version of the Ball and BaseBall classes in which the  BaseBall constructor calls a Ball constructor that uses a parameter:  public class Ball {     private double weight;     public Ball double weight      {         this.weight = weight;     } }  286      BOOK 3  Object-Oriented Programming   public class BaseBall extends Ball {     public BaseBall       {         super 5.125 ;     } }  Here  the  BaseBall  constructor  calls  the  Ball  constructor  to  supply  a  default  weight for the ball.  You  need  to  obey  a  few  rules  and  regulations  when  working  with  superclass  constructors:   » If you use super to call the superclass constructor, you must do so in the very   first statement in the constructor.   » If you don’t explicitly call super, the compiler inserts a call to the default   constructor of the base class. In that case, the base class must have a default  constructor. If the base class doesn’t have a default constructor, the compiler  refuses to compile the program.   » If the superclass is itself a subclass, the constructor for its superclass is called  in the same way. This continues all the way up the inheritance hierarchy until  you get to the Object class, which has no superclass.  Java has a final keyword that serves three purposes. When you use final with a  variable, it creates a constant whose value can’t be changed after it has been ini- tialized. Constants are covered in Book 2, Chapter 2, so I won’t describe this use  of the final keyword more here. The other two uses of the final keyword are to  create final methods and final classes. I describe these two uses of final in the  following sections.  A final method is a method that can’t be overridden by a subclass. To create a final  method, you simply add the keyword final to the method declaration. For example:  Final methods  public class SpaceShip {  CHAPTER 4  Using Subclasses and Inheritance      287  Using final       public final int getVelocity       {         return this.velocity;     } }  Here the method getVelocity is declared as final. Thus, any class that uses the  SpaceShip class as a base class can’t override the getVelocity method. If it tries,  the compiler issues the error message  "Overridden method final" .  Here are some additional details about final methods:   » You might think that a subclass wouldn’t need to override a method, but   there’s no reason to be sure of that. Predicting how other people might use  your class is difficult. As a result, usually you should avoid using final methods  unless you have a compelling reason to do so.   » Final methods execute more efficiently than nonfinal methods because the  compiler knows at compile time that a call to a final method won’t be overrid- den by some other method. The performance gain isn’t huge, but for applica- tions in which performance is crucial, it can be noticeable.   » Private methods are automatically considered to be final because you can’t   override a method you can’t see.  Final classes  A final class is a class that can’t be used as a base class. To declare a class as final,  just add the final keyword to the class declaration:  public final class BaseBall {       members for the BaseBall class go here }  Then no one can use the BaseBall class as the base class for another class.  When you declare a class to be final, all of its methods are considered to be final  as well. That makes sense when you think about it. Because you can’t use a final  class as the base class for another class, no class can possibly be in a position to  override any of the methods in the final class. Thus all the methods of a final class  are final methods.  288      BOOK 3  Object-Oriented Programming   Casting Up and Down  An object of a derived type can be treated as though it were an object of its base  type. If the BaseBall class extends the Ball class, for example, a BaseBall object  can be treated as though it were a Ball object. This arrangement is called upcast- ing, and Java does it automatically, so you don’t have to code a casting operator.  Thus the following code is legal:  Ball b = new BaseBall  ;  Here  an  object  of  type  BaseBall  is  created.  Then  a  reference  to  this  object  is  assigned to the variable b, whose type is Ball, not BaseBall.  Now suppose that you have a method in a ball-game application named hit that’s  declared like this:  public void hit Ball b   In other words, this method accepts a Ball type as a parameter. When you call  this method, you can pass it either a Ball object or a BaseBall object, because  BaseBall is a subclass of Ball. So the following code works:  Automatic  casting  doesn’t  work  the  other  way,  however.  Thus  you  can’t  use  a  Ball object where a BaseBall object is called for. Suppose your program has a  method declared like this:  BaseBall b1 = new BaseBall  ; hit b1 ; Ball b2 = b1; hit b2 ;  public void toss BaseBall b   Then the following code does not compile:  Ball b = new BaseBall  ; toss b ;       error: won't compile  Ball b = new BaseBall  ; toss  BaseBall  b ;  You can explicitly cast the b variable to a BaseBall object, however, like this:  CHAPTER 4  Using Subclasses and Inheritance      289   Note that the second statement throws an exception of type ClassCastException  if the object referenced by the b variable isn’t a BaseBall object. So the following  code won’t work:  Ball b = new SoftBall  ; toss  BaseBall  b ;          error: b isn't a Softball  What  if  you  want  to  call  a  method  that’s  defined  by  a  subclass  from  an  object  that’s referenced by a variable of the superclass? Suppose that the SoftBall class  has a method named riseBall that isn’t defined by the Ball class. How can you  call it from a Ball variable? One way to do that is to create a variable of the sub- class and then use an assignment statement to cast the object:  Ball b = new SoftBall  ; SoftBall s =  SoftBall b;      cast the Ball to a                                SoftBall s.riseBall  ;  But there’s a better way: Java lets you cast the Ball object to a SoftBall and call  the riseBall method in the same statement. All you need is an extra set of paren- theses, like this:  Ball b = new SoftBall  ;   SoftBall  b .riseBall  ;  Here the expression   SoftBall  b  returns the object referenced by the b vari- able, cast as a SoftBall. Then you can call any method of the SoftBall class by  using the dot operator.  This operator throws a ClassCastException if b is not a  SoftBall object.   As a general rule, you should declare method parameters with types as far up in  the  class  hierarchy  as  possible.  Rather  than  create  separate  toss  methods  that  accept BaseBall and SoftBall objects, for example, you can create a single toss  method  that  accepts  a  Ball  object.  If  necessary,  the  toss  method  can  deter- mine which type of ball it’s throwing by using the instanceof operator, which is  described in the next section.  Determining an Object’s Type  As described in the preceding section, a variable of one type can possibly hold a  reference to an object of another type. If SalariedEmployee is a subclass of the  Employee class, the following statement is perfectly legal:  290      BOOK 3  Object-Oriented Programming   Employee emp = new SalariedEmployee  ;  Here  the  type  of  the  emp  variable  is  Employee,  but  the  object  it  refers  to  is  a  SalariedEmployee.  Suppose you have a method named getEmployee whose return type is Employee  but that actually returns either a SalariedEmployee or an HourlyEmployee object:  Employee emp = getEmployee  ;  In  many  cases,  you  don’t  need  to  worry  about  which  type  of  employee  this  method returns, but sometimes you do. Suppose that the SalariedEmployee class  extends  the  Employee  class  by  adding  a  method  named  getFormattedSalary,  which returns the employee’s salary formatted as currency. Similarly, the Hourly  Employee class extends the Employee class with a getFormattedRate method that  returns the employee’s hourly pay rate formatted as currency. Then you’d need to  know which type of employee a particular object is, to know whether you should  call the getFormattedSalary method or the getFormattedRate method to get the  employee’s pay.  To tell what type of object has been assigned to the emp variable, you can use the  instanceof operator, which is designed specifically for this purpose. Here’s the  preceding code rewritten with the instanceof operator:  Employee emp = getEmployee  ; String msg; if  emp instanceof SalariedEmployee  {     msg = "The employee's salary is ";     msg +=   SalariedEmployee  emp .getFormattedSalary  ; } else {     msg = "The employee's hourly rate is ";     msg +=   HourlyEmployee  emp .getFormattedRate  ; } System.out.println msg ;  Here the instanceof operator is used in an if statement to determine the type of  the object returned by the getEmployee method. Then the emp can be cast without  fear of CastClassException.  CHAPTER 4  Using Subclasses and Inheritance      291   Poly What?  The term polymorphism refers to the ability of Java to use base class variables to  refer to subclass objects; to keep track of which subclass an object belongs to; and  to use overridden methods of the subclass, even though the subclass isn’t known  when the program is compiled.  This  sounds  like  a  mouthful,  but  it’s  not  hard  to  understand  when  you  see  an  example. Suppose that you’re developing an application that can play the venera- ble game Tic-Tac-Toe. You start by creating a class named Player that represents  one of the players. This class has a public method named move that returns an int  to indicate which square of the board the player wants to mark:  class Player {     public int move       {         for  int i = 0; i < 9; i++          {             System.out.println                  "\nThe basic player says:" ;             System.out.println                  "I'll take the first open square!" ;             return firstOpenSquare  ;         }         return -1;     }     private int firstOpenSquare       {         int square = 0;            code to find the first open square goes here         return square;     } }  This basic version of the Player class uses a simple strategy to determine what its  next move should be: It chooses the first open square on the board. This strategy  stokes your ego by letting you think you can beat the computer every time.  To  keep the illustration simple, I omit the code that actually chooses the move.   Now you need to create a subclass of the Player class that uses a more intelligent  method to choose its next move:  class BetterPlayer extends Player {  292      BOOK 3  Object-Oriented Programming       public int move       {         System.out.println "\nThe better player says:" ;         System.out.println              "I'm looking for a good move..." ;         return findBestMove  ;     }     private int findBestMove       {         int square = 0;    code to find the best move goes here         return square;     } }  As you can see, this version of the Player class overrides the move method and  uses a better algorithm to pick its move.  Again, to keep the illustration simple, I  don’t show the code that actually chooses the move.   The next thing to do is write a short class that uses these two Player classes to  play a game. This class contains a method named playTheGame that accepts two  Player objects. It calls the move method of the first player and then calls the move  method of the second player:  public class TicTacToeApp {     public static void main String[] args      {         Player p1 = new Player  ;         Player p2 = new BetterPlayer  ;         playTheGame p1, p2 ;     }     public static void playTheGame Player p1, Player p2      {         p1.move  ;         p2.move  ;     } }  Notice that the playTheGame method doesn’t know which of the two players is the  basic player and which is the better player. It simply calls the move method for  each Player object.  CHAPTER 4  Using Subclasses and Inheritance      293   Creating Custom Exceptions  When you run this program, the following output is displayed on the console:  Basic player says: I'll take the first open square!  Better player says: I'm looking for a good move...  When the move method for p1 is called, the move method of the Player class is  executed.  But  when  the  move  method  for  p2  is  called,  the  move  method  of  the   BetterPlayer class is called.  Java knows to call the move method of the BetterPlayer subclass because it uses  a technique called late binding. Late binding simply means that when the compiler  can’t tell for sure what type of object a variable references, it doesn’t hard-wire  the method calls when the program is compiled. Instead, it waits until the pro- gram is executing to determine exactly which method to call.  The last topic I want to cover in this chapter is how to use inheritance to create  your own custom exceptions. I cover most of the details of working with excep- tions in Book 2, Chapter 8, but I hadn’t explored inheritance, so I couldn’t discuss  custom exception classes in that chapter. I promised that I’d get to it in this mini- book. The following sections deliver on that long-awaited promise.  Tracing the Throwable hierarchy  As you know, you use the try catch statement to catch exceptions and the throw  statement  to  throw  exceptions.  Each  type  of  exception  that  can  be  caught  or  thrown  is  represented  by  a  different  exception  class.  What  you  may  not  have  realized is that those exception classes use a fairly complex inheritance chain, as  shown in Figure 4-1.  The following paragraphs describe the classes in this hierarchy:   » Throwable: The root of the exception hierarchy is the Throwable class. This  class represents any object that can be thrown with a throw statement and  caught with a catch clause.  294      BOOK 3  Object-Oriented Programming   FIGURE 4-1:    The hierarchy of  exception classes.   » Error: This subclass of Throwable represents serious error conditions that  reasonable programs can’t recover from. The subclasses of this class repre- sent the specific types of errors that can occur. If the Java Virtual Machine runs  out of memory, for example, a VirtualMachineError is thrown. You don’t  have to worry about catching these errors in your programs.   » Exception: This subclass of Throwable represents an error condition that   most programs should try to recover from. Thus, Exception is effectively the  top of the hierarchy for the types of exceptions you catch with try catch  statements.  With the exception  sorry  of RuntimeException, the subclasses of  Exception represent specific types of checked exceptions that must be  caught or thrown. Note that some of these subclasses have subclasses of their  own. The exception class named IOException, for example, has more than  25 subclasses representing different kinds of I O exceptions that can occur.   » RuntimeException: This subclass of Exception represents unchecked   exceptions. You don’t have to catch or throw unchecked exceptions, but you  can if you want to. Subclasses of RuntimeException include  NullPointerException and ArithmeticException.  If your application needs to throw a custom exception, you can create an exception  class that inherits any of the classes in this hierarchy. Usually, however, you start  with the Exception class to create a custom checked exception. The next section  explains how to do that.  CHAPTER 4  Using Subclasses and Inheritance      295   Creating an exception class  To create a custom exception class, you just define a class that extends one of the  classes in the Java exception hierarchy. Usually you extend Exception to create a  custom checked exception.  Suppose  that  you’re  developing  a  class  that  retrieves  product  data  from  a  file  or  database,  and  you  want  methods  that  encounter  I O  errors  to  throw  a  cus- tom exception rather than the generic  IOException that’s provided in the Java  API. You can do that by creating a class that extends the Exception class:  public class ProductDataException extends Exception { }  Unfortunately, constructors aren’t considered to be class members, so they aren’t  inherited when you extend a class. As a result, the  ProductDataException has  only a default constructor. The Exception class itself and most other exception  classes have a constructor that lets you pass a string message that’s stored with  the exception and can be retrieved via the getMessage method. Thus you want to  add this constructor to your class, which means that you want to add an explicit  default constructor too. So now the ProductDataException class looks like this:  public class ProductDataException extends Exception {     public ProductDataException     {     }     public ProductDataException String message      {         super message ;     } }  Although it’s possible to do so, adding fields or methods to a custom exception  class is unusual.  Throwing a custom exception  As for any exception, you use a throw statement to throw a custom exception. You  usually code this throw statement in the midst of a catch clause that catches some  other, more generic exception. Here’s a method that retrieves product data from a  file and throws a ProductDataException if an IOException occurs:  296      BOOK 3  Object-Oriented Programming   public class ProductDDB {     public static Product getProduct String code          throws ProductDataException     {         try         {             Product p;                code that gets the product from a file                and might throw an IOException             p = new Product  ;             return p;          }          catch  IOException e           {             throw new ProductDataException                  "An IO error occurred." ;          }     } }  try {     Product p = ProductDB.getProduct productCode ; } catch  ProductDataException e  {     System.out.println e.getMessage   ; }  Here’s some code that calls the getProduct method and catches the exception:  Here the message is simply displayed on the console if a ProductDataException  is thrown. In an actual program, you want to log the error, inform the user, and  figure out how to continue the program gracefully even though this data excep- tion has occurred.  CHAPTER 4  Using Subclasses and Inheritance      297    IN THIS CHAPTER  » Understanding abstract methods and   classes   » Using basic interfaces   » Using interfaces as types   » Adding constants to an interface   » Inheriting interfaces   » Working with callbacks   » Using default methods  Chapter 5 Using Abstract Classes  and Interfaces  In  this  chapter,  you  find  out  how  to  use  two  similar  but  subtly  distinct  fea-  tures:  abstract  classes  and  interfaces.  Both  let  you  declare  the  signatures  of  the methods and fields that a class implements separately from the class itself.  Abstract classes accomplish this by way of inheritance. Interfaces do it without  using  inheritance,  but  the  effect  is  similar.  This  chapter  also  covers  a  feature  called default methods, which are designed to make interfaces easier to work with.  Using Abstract Classes  Java lets you declare that a method or an entire class is abstract, which means that  the method has no body. An abstract method is just a prototype for a method: a  return type, a name, a list of parameters, and  optionally  a throws clause.  CHAPTER 5  Using Abstract Classes and Interfaces      299   To create an abstract method, you specify the modifier abstract and replace the  method body with a semicolon:  public abstract int hit int batSpeed ;  Here the method named hit is declared as an abstract method that returns an int  value and accepts an int parameter.  A class that contains at least one abstract method is called an abstract class and must  be declared with the abstract modifier on the class declaration. For example:  public abstract class Ball {     public abstract int hit int batSpeed ; }  If  you  omit  the  abstract  modifier  from  the  class  declaration,  the  Java  com- piler coughs up an error message to remind you that the class must be declared  abstract.  An abstract class can’t be instantiated. Thus, given the preceding declaration, the  following line doesn’t compile:  Ball b = new Ball  ;      error: Ball is abstract  The problem here isn’t with declaring the variable b as a Ball; it’s using the new  keyword with the Ball class in an attempt to create a Ball object. Because Ball is  an abstract class, you can use it to create an object instance.  You can create a subclass from an abstract class like this:  public class BaseBall extends Ball {     public int hit int batSpeed      {            code that implements the hit method goes here     } }  When you subclass an abstract class, the subclass must provide an implementa- tion for each abstract method in the abstract class. In other words, it must over- ride each abstract method with a nonabstract method.  If it doesn’t, the subclass  is also abstract, so it can’t be instantiated either.   300      BOOK 3  Object-Oriented Programming   THE ABSTRACT FACTORY PATTERN  One common use for abstract classes is to provide a way to obtain an instance of one  of several subclasses when you don’t know which subclass you need in advance. To do  this, you can create an Abstract Factory class that has one or more methods that return  subclasses of the abstract class.  Suppose that you want to create a Ball object, but you want to let the user choose  whether to create a SoftBall or a BaseBall. To use the Abstract Factory pattern, you  create a class  I call it BallFactory  that has a method named getBallInstance. This  method accepts a String parameter that’s set to "BaseBall" if you want a BaseBall  object or "SoftBall" if you want a SoftBall object.  Here’s the factory class:  class BallFactoryInstance {    public static Ball getBall String t     {       if  s.equalsIgnoreCase "BaseBall"             return new BaseBall  ;       if  s.equalsIgnoreCase "SoftBall"             return new SoftBall  ;       return null;    } }  Then, assuming that the String variable userChoice has been set according to the  user’s choice, you can create the selected type of Ball object like this:  Ball b = BallFactory.getBallInstance userChoice ;  In an actual application, using an enum variable is better than using a String variable to  indicate the type of object to be returned.  Abstract classes are useful when you want to create a generic type that is used as  the superclass for two or more subclasses, but the superclass itself doesn’t repre- sent an actual object. If all employees are either salaried or hourly, for example, it  makes sense to create an abstract Employee class and then use it as the base class  for the SalariedEmployee and HourlyEmployee subclasses.  CHAPTER 5  Using Abstract Classes and Interfaces      301   Here are a few additional points to ponder concerning abstract classes:   » Not all the methods in an abstract class have to be abstract. A class can   provide an implementation for some of its methods but not others. In fact,  even if a class doesn’t have any abstract methods, you can still declare it as  abstract.  In that case, the class can’t be instantiated.   A private method can’t be abstract. That makes sense, because a subclass  can’t override a private method, and abstract methods must be overridden.  » Although you can’t create an instance of an abstract class, you can declare a  variable by using an abstract class as its type. Then use the variable to refer to  an instance of any of the subclasses of the abstract class.   » A class can’t specify both abstract and final. That would cause one of those  logical paradoxes that result in the annihilation of the universe. Well, ideally,  the effect would be localized. But the point is that because an abstract class  can be used only if you subclass it, and because a final class can’t be  subclassed, letting you specify both abstract and final for the same class  doesn’t make sense.  Abstract classes are used extensively in the Java API. Many of the abstract  classes have names that begin with Abstract — such as AbstractBorder,  AbstractCollection, and AbstractMap — but most of the abstract classes  don’t. The InputStream class  used by System.in  is abstract, for example.  Using Interfaces  An  interface  is  similar  to  an  abstract  class,  but  an  interface  can  include  only  abstract methods and final fields  constants , and an interface can’t be used as  a base class. A class implements an interface by providing code for each method  declared by the interface.  Interfaces have two advantages over inheritance:   » Interfaces are easier to work with than an abstract class, because you don’t  have to worry about providing any implementation details in the interface.   » A class can extend only one other class, but it can implement as many   interfaces as you need.  The following sections describe the details of creating and using interfaces.  302      BOOK 3  Object-Oriented Programming   Creating a basic interface  Here’s  a  basic  interface  that  defines  a  single  method,  named  Playable,  that  includes a single method named play:  public interface Playable {     void play  ; }  This interface declares that any class that implements the Playable interface must  provide an implementation for a method named play that accepts no parameters  and doesn’t return a value.  This interface has a few interesting details:   » The interface itself is declared as public so that it can be used by other   classes. Like a public class, a public interface must be declared in a file with  the same name. Thus this interface must be in a file named Playable.java.   » The name of the interface  Playable  is an adjective. Most interfaces are  named with adjectives rather than nouns because they describe some  additional capability or quality of the classes that implement the interface.  Thus classes that implement the Playable interface represent objects that  can be played.  In case you haven’t been to English class in a while, an adjective is a word that  modifies a noun. You can convert many verbs to adjectives by adding -able to  the end of the word — playable, readable, drivable, and stoppable, for example.  This type of adjective is commonly used for interface names.   » Another common way to name interfaces is to combine an adjective with a   noun to indicate that the interface adds some capability to a particular type of  object. You could call an interface that provides methods unique to card  games CardGame, and this interface might have methods such as deal,  shuffle, and getHand.   » All the methods in an interface are assumed to be public and abstract. If you  want, you can code the public and abstract keywords on interface meth- ods. That kind of coding is considered to be bad form, however, because it  might indicate that you think the default is private and not abstract.  CHAPTER 5  Using Abstract Classes and Interfaces      303   Implementing an interface  To implement an interface, a class must do two things:   » It must specify an implements clause on its class declaration.  » It must provide an implementation for every method declared by the   interface.  Here’s a class that implements the Playable interface:  public class TicTacToe implements Playable {        additional fields and methods go here      public void play       {           code that plays the game goes here     }        additional fields and methods go here }  Here  the  declaration  for  the  TicTacToe  class  specifies  implements  Playable.  Then the body of the class includes an implementation of the play method.  A class can implement more than one interface:  public class Hearts implements Playable, CardGame {        must implement methods of the Playable        and CardGame interfaces }  Here, the Hearts class implements two interfaces: Playable and CardGame.  A class can possibly inherit a superclass and implement one or more interfaces.  Here’s an example:  public class Poker extends Game     implements Playable, CardGame {        inherits all members of the Game class        must implement methods of the Playable        and CardGame interfaces }  304      BOOK 3  Object-Oriented Programming   Using an interface as a type  In Java, an interface is a kind of type, just like a class. As a result, you can use an  interface as the type for a variable, parameter, or method return value.  Consider this snippet of code:  Playable game = getGame  ; game.play  ;  Here I assume that the getGame method returns an object that implements the  Playable interface. This object is assigned to a variable of type Playable in the  first statement. Then the second statement calls the object’s play method.  For another  slightly more complex  example, suppose that you have an interface  named Dealable defining a method named deal that accepts the number of cards  to deal as a parameter:  public interface Dealable {     void deal int cards ; }  Now suppose that you have a method called startGame that accepts two param- eters:  a  Dealable  object  and  a  String  that  indicates  what  game  to  play.  This  method might look something like this:  private void startGame Dealable deck, String game  {     if  game.equals "Poker"           deck.deal 5 ;     else if  game.equals "Hearts"           deck.deal 13 ;     else if  game.equals "Gin"           deck.deal 10 ; }  Assuming that you also have a class named CardDeck that implements the Deal  able interface, you might use a statement like this example to start a game of  Hearts:  Dealable d = new CardDeck  ; startGame d, "Hearts" ;  CHAPTER 5  Using Abstract Classes and Interfaces      305   Notice that the variable d is declared as a Dealable. You could just as easily declare  it as a CardDeck:  CardDeck d = new CardDeck  ; startGame d, "Hearts" ;  Because the CardDeck class implements the Dealable interface, it can be passed  as a parameter to the startGame method.  More Things You Can Do with Interfaces  There’s  more  to  interfaces  than  just  creating  abstract  methods.  The  following  sections describe some additional interesting things you can do with interfaces.  Read on. . . .  Adding fields to an interface  Besides  abstract  methods,  an  interface  can  include  final  fields  —  that  is,  con- stants. Interface fields are used to provide constant values that are related to the  interface. For example:  public interface GolfClub {     int DRIVER = 1;     int SPOON = 2;     int NIBLICK = 3;     int MASHIE = 4; }  Here any class that implements the GolfClub interface has these four fields  that  is, constants  available.  Note  that  interface  fields  are  automatically  assumed  to  be  static,  final,  and  public. You can include these keywords when you create interface constants, but  you don’t have to.  Extending interfaces  You can extend interfaces by using the extends keyword. An interface that extends  an existing interface is called a subinterface, and the interface being extended is  called the superinterface.  306      BOOK 3  Object-Oriented Programming   When you use the extends keyword with interfaces, all the fields and methods of  the superinterface are effectively copied into the subinterface. Thus the subinter- face consists of a combination of the fields and methods in the superinterface plus  the fields and methods defined for the subinterface.  Here’s an example:  public interface ThrowableBall {     void throwBall  ;     void catchBall  ; } public interface KickableBall {     void kickBall  ;     void catchBall  ; } public interface PlayableBall     extends ThrowableBall, KickableBall {     void dropBall  ; }  Here three interfaces are declared. The first, named ThrowableBall, defines two  methods:  throwBall  and  catchBall.  The  second,  named  KickableBall,  also  defines two methods: kickBall and catchBall. The third, named PlayableBall,  extends ThrowableBall and KickableBall, and adds a method of its own named  dropBall.  Thus  any  class  that  implements  the  PlayableBall  interface  must  provide  an  implementation for four methods: throwBall, catchBall, kickBall, and drop- Ball. Note that because the catchBall methods defined by the ThrowableBall  and  KickableBall  interfaces  have  the  same  signature,  only  one  version  of  the  catchBall method is included in the PlayableBall interface.  Using interfaces for callbacks  In the theater, a callback is when you show up for an initial audition, they like  what they see, and they tell you that they want you to come back so they can have  another look.  In Java, a callback is sort of like that. It’s a programming technique in which an  object lets another object know that the second object should call one of the first  object’s methods whenever a certain event happens. The first object is called an   CHAPTER 5  Using Abstract Classes and Interfaces      307   event listener because it waits patiently until the other object calls it. The second  object is called the event source because it’s the source of events that result in calls  to the listener.  Okay, my theater analogy was a bit of a stretch. Callbacks in Java aren’t really that  much like callbacks when you’re auditioning for a big part. A callback is more like  when you need to get hold of someone on the phone, and you call him when you know  he isn’t there and leave your phone number on his voicemail so he can call you back.  Callbacks are handled in Java by a set of interfaces designed for this purpose. The  most common use of callbacks is in graphical applications built with Swing, where  you create event listeners that handle user-interface events, such as mouse clicks.  You find out all about Swing in Book 6. For now, I look at callbacks by using the  Timer  class,  which  is  part  of  the  javax.Swing  package.  This  class  implements  a  basic  timer  that  generates  events  at  regular  intervals  —  and  lets  you  set  up  a listener object to handle these events. The listener object must implement the  ActionListener  interface,  which  defines  a  method  named  actionPerformed  that’s called for each timer event.  THE MARKER INTERFACE PATTERN  A marker interface is an interface that doesn’t have any members. Its sole purpose in life  is to identify a class as belonging to a set of classes that possess some capability or have  some characteristic in common.  The best-known example of a marker interface is the Java API Cloneable interface,  which marks classes that can be cloned. The Object class, which all classes ultimately  inherit, provides a method named clone that can be used to create a copy of the  object. You’re allowed to call the clone method only if the object implements the  Cloneable interface, however. If you try to call clone for an object that doesn’t imple- ment Cloneable, CloneNotSupportedException is thrown.  For more information  about the clone method, refer to Book 3, Chapter 6.   Here’s the actual code for the Cloneable interface:  public interface Cloneable { }  In some cases, you might find a use for marker interfaces in your own application. If  you’re working on a series of classes for creating games, you might create a marker  interface named Winnable to distinguish games that have a winner from games that  you just play for enjoyment.  308      BOOK 3  Object-Oriented Programming   The Timer class constructor accepts two parameters:   » The first parameter is an int value that represents how often the timer   events occur.   » The second parameter is an object that implements the ActionListener  interface. This object’s actionPerformed method is called when each timer  event occurs.  The  ActionListener  interface  is  defined  in  the  java.awt.event  package.  It  includes the following code:  public interface ActionListener extends EventListener {      **      * Invoked when an action occurs.      *      public void actionPerformed ActionEvent e ; }  As you can see, the ActionListener interface consists of a single method named  actionPerformed. It receives a parameter of type ActionEvent, but you don’t use  this parameter here.  You do use the ActionEvent class in Book 6.   The Timer class has about 20 methods, but I talk about only one of them here:  start, which sets the timer in motion. This method doesn’t require any param- eters and doesn’t return a value.  Listing 5-1 shows a program that uses the Timer class to alternately display the  messages Tick. . . and Tock. . . on the console at 1-second intervals. The JOption  Pane class is used to display a dialog box; the program runs until the user clicks  the  OK  button  in  this  box.  Figure  5-1  shows  the  Tick  Tock  program  in  action.   Actually it takes a while for the JOptionPane class to shut down the timer, so  you’ll see a few extra tick-tocks after clicking OK.   import java.awt.event.*;  import javax.swing.*;  public class TickTock {     public static void main String[] args      {            create a timer that calls the Ticker class            at one second intervals  →1 →2   continued   CHAPTER 5  Using Abstract Classes and Interfaces      309  LISTING 5-1:   The Tick Tock Program   LISTING 5-1:    continued           Timer t = new Timer 1000, new Ticker   ;          t.start  ;             display a message box to prevent the            program from ending immediately         JOptionPane.showMessageDialog null,              "Click OK to exit program" ;     } } class Ticker implements ActionListener  {     private boolean tick = true;      public void actionPerformed ActionEvent event       {         if  tick          {             System.out.println "Tick..." ;          }         else         {             System.out.println "Tock..." ;          }         tick = !tick;      } }  →10 →11  →15  →20  →22 →24  →28  →32  →34  FIGURE 5-1:   The Tick Tock  application in  action.  310      BOOK 3  Object-Oriented Programming   The  following  paragraphs  describe  the  important  details  of  this  program’s  operation:  →1    The ActionListener interface is part of the java.awt.event package,  so this import statement is required.   →2    →10    →11   →15    →20    →22    →24    →28   →32   →34    The Timer class is part of the javax.swing package, so this import  statement is required.   This statement creates a new Timer object. The timer’s interval is set to  1,000 milliseconds — which is equivalent to 1 second. A new instance of  the Ticker class is passed as the second parameter. The timer calls this  object’s actionPerformed method at each timer tick — in other words,  once per second.   This statement calls the start method to kick the timer into action.   The JOptionPane class is used to display a dialog box that tells the user  to click the OK button to stop the application. You might think I include  this dialog box to give the user a way to end the program. In reality, I use  it to give the timer some time to run. If I just end the main method after  starting the timer, the application ends, which kills the timer. Because I  use JOptionPane here, the application continues to run as long as the  dialog box is displayed.  For more information about JOptionPane, see  Book 2, Chapter 2.    This line is the declaration of the Ticker class, which implements the  ActionListener interface.   This line is a private boolean class field that’s used to keep track of  whether the Ticker displays Tick... or Tock... Each time the  actionPerformed method is called, this field is toggled.   This line is the actionPerformed method, which is called at each timer  interval.  This line prints Tick... on the console if tick is true.  This line prints Tock... on the console if tick is false.   This line toggles the value of the tick variable. In other words, if tick is  true, it’s set to false. If tick is false, it’s set to true.  Using Default Methods  Although interfaces are an incredibly useful feature of Java, they have an inherent  limitation: After you define an interface and then build classes that implement   CHAPTER 5  Using Abstract Classes and Interfaces      311   the interface,  there’s no easy way to modify the interface  by adding additional  methods to it.  For example, suppose you have created the following interface:  You  then  build  several  classes  that  implement  this  interface.  Here’s  a  simple  example:  public interface Playable {     void play  ; }  class Game implements Playable {     public void play       {         System.out.println "Good luck!" ;     } }  This  is  a  pretty  pointless  game,  of  course;  it  simply  prints  the  message  “Good  luck!” whenever the play method is called.  Now suppose that you decide that the Playable interface should have an addi- tional feature — specifically, you want to add the ability to end the game by call- ing a method named quit.  You’d be tempted to just add the new method to the existing interface, like this:  public interface Playable {     void play  ;     void quit  ; }  Unfortunately, however, doing so will break the Game class because it doesn’t pro- vide an implementation of the quit method.  You could, of course, modify the Game class by adding an implementation of the  quit method. But what if you have written dozens, or even hundreds, of classes  that  implement  Playable?  As  you  can  imagine,  once  an  interface  has  become  popular, it becomes nearly impossible to modify.  312      BOOK 3  Object-Oriented Programming   To alleviate this problem, Java 1.8 introduces a new type of interface method called  a default method, which supplies code that will be used as the implementation of  the method for any classes that implement the interface but do not themselves  provide an implementation for the default method.  Thus, Java 8 allows you to  safely add the quit method to the Playable interface  by specifying it as a default method, like this:  interface Playable { void play  ; default void quit   { System.out.println "Sorry, quitting is not allowed." ; } }  Here the Playable interface specifies that if an implementing class does not pro- vide an implementation of the quit method, the default method will be used. In  this case, the default method simply prints the message "Sorry,  quitting  is  not allowed."  Note that the preceding example won’t compile on versions of Java prior to 1.8.  If you get an error message when you try to compile an interface that uses the  default keyword, check your Java version to make sure you’re running version  1.8 or later.  Here’s  a  complete  example  that  uses  the  Playable  interface  and  its  default  method:  public class TestLambdaCollection {     public static void main String[] args      {         Game g = new Game  ;         g.play  ;         g.quit  ;     } } interface Playable {     void play  ;     default void quit    CHAPTER 5  Using Abstract Classes and Interfaces      313       {         System.out.println "Sorry, quitting is not allowed." ;     } } class Game implements Playable {     public void play       {         System.out.println "Good luck!" ;     } }  When you run this program, the following will be displayed on the console:  Good luck! Sorry, quitting is not allowed.  314      BOOK 3  Object-Oriented Programming   IN THIS CHAPTER  » Using the toString method   » Implementing the equals method   » Trying out the clone method   » Understanding the Class class  Chapter 6 Using the Object and  Class Classes  I   n  this  chapter,  you  find  out  how  to  use  two  classes  of  the  Java  API  that  are  important to object-oriented programming:   » The Object class, which every other class inherits — including all the classes   in the Java API and any classes you create yourself   » The Class class, which is used to get information about an object’s type  If I could, I’d plant a huge Technical Stuff icon on this entire chapter. All this stuff  is a bit on the technical side, and many Java programmers get by for years without  understanding or using it. Still, I recommend that you read this chapter carefully.  Even if it all doesn’t sink in, it may help explain why some things in Java don’t  work quite the way you think they should, and the information in this chapter  may someday help you program your way out of a difficult corner.  CHAPTER 6  Using the Object and Class Classes      315   The Mother of All Classes: Object  Object is the mother of all classes. In Java, every class ultimately inherits the Object  class. This class provides a set of methods that is available to every Java object.  Every object is an Object  Any class that doesn’t have an  extends clause implicitly inherits  Object. Thus  you never have to code a class like this:  public class Product extends Object...  If a subclass has an extends clause that specifies a superclass other than Object,  the class still inherits Object. That’s because the inheritance hierarchy eventu- ally gets to a superclass that doesn’t have an extends clause, and that superclass  inherits Object and passes it down to all its subclasses.  Suppose you have these classes:  public class Manager extends SalariedEmployee... public class SalariedEmployee extends Employee... public class Employee extends Person... public class Person...  Here  the  Manager  class  inherits  the  Object  class  indirectly  because  it  inher- its  SalariedEmployee,  which  inherits  Employee,  which  inherits  Person,  which  inherits Object.  In Java, creating a class that doesn’t inherit Object is not possible.  Object as a type  If you don’t know or care about the type of an object referenced by a variable, you  can specify its type as Object. The following example is perfectly legal:  Object emp = new Employee  ;  You can’t do anything useful with the emp variable, however, because the compiler  doesn’t know that it’s an Employee. If the Employee class has a method named  setLastName, the following code doesn’t work:  Object emp = new Employee  ; emp.setLastName "Smith" ;        error: won't compile  316      BOOK 3  Object-Oriented Programming   Because emp is an Object, not an Employee, the compiler doesn’t know about the  setLastName method.  Note that you could still cast the object to an Employee:  Object emp = new Employee  ;   Employee emp .setLastName "Smith" ;     this works  But what’s the point? You may as well make emp an Employee in the first place.  Declaring a variable, parameter, or return  type as  Object in certain situations,  however, does make perfect sense. The Java API provides a set of classes designed  to maintain collections of objects. One of the most commonly used of these classes  is the ArrayList class, which has a method named add that accepts an Object as  a parameter. This method adds the specified object to the collection. Because the  parameter type is Object, you can use the ArrayList class to create collections  of any type of object.  For more information about the ArrayList class and other  collection classes, see Book 4.   Methods of the Object class  Table 6-1 lists all the methods of the Object class. Ordinarily, I wouldn’t list all  the methods of a class; I’d just list the ones that I think are most useful. Because  Object is such an important player in the game of object-oriented programming,  however, I thought it best to show you all its capabilities, even though some of  them are a bit obscure.  I warned you — this entire chapter should have a Technical Stuff icon.  protected Object clone    Returns a copy of this object.  boolean equals Object obj   Indicates whether this object is equal to the  obj object.  protected void finalize    Is called by the garbage collector when the object  is destroyed.  Class getClass    Returns a Class object that represents this  object’s runtime class.  int hashCode    Returns this object’s hash code.   continued   CHAPTER 6  Using the Object and Class Classes      317  TABLE 6-1	  Methods of the Object Class Method  What It Does   TABLE	6-1	 continued   Method  void notify    void notifyAll    What It Does  Is used with threaded applications to wake up a  thread that’s waiting on this object.  Is used with threaded applications to wake up all  threads that are waiting on this object.  String toString    Returns a String representation of this object.  void wait    Causes this object’s thread to wait until another  thread calls notify or notifyAll.  void wait Long timeout   Is a variation of the basic wait method.  void wait Long timeout,  int nanos   Is yet another variation of the wait method.  Note: Almost half of these methods  notify, notifyAll, and the three wait meth- ods   are  related  to  threading.  You  find  complete  information  about  those  five  methods in Book 5, Chapter  1. Here’s the rundown on the remaining six methods:   » clone: This method is commonly used to make copies of objects, and   overriding it in your own classes is not uncommon. I explain this method in  detail later in this chapter, in the section “The clone Method.”   » equals: This method is commonly used to compare objects. Any class that   represents an object that can be compared with another object should  override this method. Turn to the section “The equals Method,” later in this  chapter, for more info.   » finalize: This method is called when the garbage collector realizes that an   object is no longer being used and can be discarded. The intent of this  method is to let you create objects that clean up after themselves by closing  open files and performing other cleanup tasks before being discarded. But  because of the way the Java garbage collector works, there’s no guarantee  that the finalize method is ever actually called. As a result, this method isn’t  commonly used.   » getClass: This method is sometimes used in conjunction with the Class  class, which I describe later in this chapter, in the section “The Class Class.”   » hashCode: Every Java object has a hash code, which is an int representation of   the class that’s useful for certain operations. This method isn’t terribly  important until you start to work with hash tables — which is a pretty  advanced technique, best left to people with pocket protectors and tape  holding their glasses together.  318      BOOK 3  Object-Oriented Programming    » toString: This method is one of the most commonly used methods in Java.    I describe it in the section “The toString Method,” later in this chapter.  Primitives aren’t objects  I need to note that primitive types, such as int and double, are not objects. As a  result, they do not inherit the Object class and don’t have access to the methods  listed in the preceding section.  As a result, the following code won’t work:  int x = 50; String s = x.toString  ;     error: won't compile  If you really want to convert an int to a string in this way, you can use a wrapper  class such as Integer to create an object from the value and then call its toString  method:  String s = new Integer x .toString  ;     OK  Each of the wrapper classes also defines a static toString method, which you can  use like this:  String s = Integer.toString x ;  Sometimes, using the compiler shortcut that lets you use primitive types in string  concatenation expressions is easier:  String s = "" + x;  Here the int variable x is concatenated with an empty string.  The point of all this is that primitive types aren’t objects, so they don’t inherit  anything from Object. If you want to treat a primitive value as an object, you can  use the primitive type’s wrapper class  as I describe in Book 2, Chapter  2 .  The toString Method  The toString method returns a String representation of an object. By default, the  toString method returns the name of the object’s class plus its hash code. In the  sections that follow, I show you how to use the toString method and how to over- ride it in your own classes to create more useful strings.  CHAPTER 6  Using the Object and Class Classes      319   Using toString  Here’s a simple program that puts the toString method to work:  public class TestToString {     public static void main String[] args      {         Employee emp = new Employee "Martinez",             "Anthony" ;         System.out.println emp.toString   ;     } } class Employee {     private String lastName;     private String firstName;     public Employee String lastName, String firstName      {         this.lastName = lastName;         this.firstName = firstName;     } }  This code creates a new Employee object; then the result of its toString method  is printed to the console. When you run this program, the following line is printed  on the console:  Employee@82ba41  Note: The hash code — in this case, 82ba41 — will undoubtedly be different on  your system.  It turns out that the explicit call to toString isn’t really necessary in this exam- ple. I could just as easily have written the second line of the main method like this:  System.out.println emp ;  That’s because the println method automatically calls the toString method of  any object you pass it.  320      BOOK 3  Object-Oriented Programming   Overriding toString  The default implementation of toString isn’t very useful in most situations. You  don’t  really  learn  much  about  an  Employee  object  by  seeing  its  hash  code,  for  example. Wouldn’t it be better if the toString method returned some actual data  from the object, such as the employee’s name?  To do that, you must override the toString method in your classes. In fact, one  of the basic guidelines of object-oriented programming in Java is to always over- ride  toString.  Here’s  a  simple  program  with  an  Employee  class  that  overrides  toString:  public class TestToString {     public static void main String[] args      {         Employee emp = new Employee "Martinez",             "Anthony" ;         System.out.println emp.toString   ;     } } class Employee {     private String lastName;     private String firstName;     public Employee String lastName, String firstName      {         this.lastName = lastName;         this.firstName = firstName;     }     public String toString       {         return "Employee["             + this.firstName + " "             + this.lastName + "]";     } }  When you run this program, the following line is displayed on the console:  Employee[Anthony Martinez]  Note that the output consists of the class name followed by some data from the  object in brackets. This convention is common in Java programming.  CHAPTER 6  Using the Object and Class Classes      321   The  only  problem  with  the  preceding  example  is  that  the  class  name  is  hard- coded into the toString method. You can use the getClass method to retrieve the  actual class name at runtime:      public String toString       {         return this.getClass  .getName   + "["             + this.firstName + " "             + this.lastName + "]";     }  Here the getClass method returns a Class object that represents the class of the  current object. Then the Class object’s getName method is used to get the actual  class name.  You discover more about the Class object later in this chapter.   The equals Method  Testing  objects  to  see  whether  they  are  equal  is  one  of  the  basic  tasks  of  any  object-oriented programming language. Unfortunately, Java isn’t very good at it.  Consider this program:  public class TestEquality1 {     public static void main String[] args      {         Employee emp1 = new Employee              "Martinez", "Anthony" ;         Employee emp2 = new Employee              "Martinez", "Anthony" ;         if  emp1 == emp2              System.out.println                  "These employees are the same." ;         else             System.out.println                  "These are different employees." ;     } } class Employee {     private String lastName;     private String firstName;  322      BOOK 3  Object-Oriented Programming       public Employee String lastName, String firstName      {         this.lastName = lastName;         this.firstName = firstName;     } }  Here the main method creates two Employee objects with identical data and then  compares them. Alas, the comparison returns false. Even though the Employee  objects have identical data, they’re not considered to be equal because the equal- ity operator  ==  compares the object references, not the data contained by the  objects. Thus the comparison returns true only if both emp1 and emp2 refer to the  same instance of the Employee class.  If you want to create objects that are considered to be equal if they contain identi- cal data, you have to do two things:   » Compare them with the equals method rather than the equality operator.  » Override the equals method in your class to compare objects based on   their data.  The following sections describe both of these steps.  Using equals  To test objects using the equals method rather than the equality operator, you  simply rewrite the comparison expression like this:  if  emp1.equals emp2       System.out.println "These employees are the same." ; else     System.out.println          "These are different employees." ;  Here, the equals method of emp1 is used to compare emp1 with emp2.  By default, the equals operator returns the same result as the equality operator.  So just replacing == with the equals method doesn’t have any effect unless you  also override the equals method, as explained in the next section.  CHAPTER 6  Using the Object and Class Classes      323   Which object’s equals method you use shouldn’t matter. Thus the if statement  shown here returns the same result:  if  emp2.equals emp1       System.out.println "These employees are the same." ; else     System.out.println          "These are different employees." ;  Note that I said it shouldn’t matter. Whenever you override the equals method,  you’re supposed to make sure that comparisons work in both directions. Sloppy  programming, however, sometimes results in equals methods where a equals b  but b doesn’t equal a. Be on your toes.  Overriding the equals method  You can override the equals method so that objects can be compared based on  their  values.  At  the  surface,  you  might  think  this  is  easy  to  do.  You  could  be  tempted to write the equals method for the Employee class like this:     warning -- there are several errors in this code! public boolean equals Employee emp  {     if  this.getLastName  .equals emp.getLastName         && this.getFirstName  .equals emp.getFirstName             return true;     else         return false; }  The basic problem with this code — and the challenge of coding a good equals  method — is that the parameter passed to the equals method must be an Object,  not an Employee. That means that the equals method must be prepared to deal  with anything that comes its way. Someone might try to compare an Employee  object with a Banana object, for example, or with a null. The equals method must  be prepared to deal with all possibilities.  Specifically,  the  Java  API  documentation  says  that  whenever  you  override  the  equals method, you must ensure that the equals method meets five specific con- ditions. Here they are, quoted right out of the API documentation:   » It is reflexive. For any non-null reference value x, x.equals x  should   return true.  324      BOOK 3  Object-Oriented Programming    » It is symmetric. For any non-null reference values x and y, x.equals y    should return true if — and only if — y.equals x  returns true.   » It is transitive. For any non-null reference values x, y, and z, if x.equals y   returns true and y.equals z  returns true, x.equals z  should return  true.   » It is consistent. For any non-null reference values x and y, multiple invoca- tions of x.equals y  consistently return true or consistently return false,  provided that no information used in equals comparisons on the objects is  modified.   » For any non-null reference value x, x.equals null  should return false.  Sound  confusing?  Fortunately,  it’s  not  as  complicated  as  it  seems  at  first.  You  can safely ignore the transitive rule, because if you get the other rules right, this  one happens automatically. The consistency rule basically means that you return  consistent results. As long as you don’t throw a call to Math.random into the com- parison, that shouldn’t be a problem.  Here’s  a  general  formula  for  creating  a  good  equals  method   assume  that  the  parameter is named obj : 1.  Test the reflexive rule. Use a statement like this:  In other words, if someone is silly enough to see whether an object is equal to  itself, it returns true.  if  this == obj      return true;  2.  Test the non-null rule. Use a statement like this:  if  this == null      return false;  Null isn’t equal to anything.  3.  Test that obj is of the same type as this.  You can use the getClass method to do that, like this:  if  this.getClass   != obj.getClass        return false;  The two objects can’t possibly be the same if they aren’t of the same type.  It  may not be apparent at first, but this test is required to fulfill the symmetry  rule — that if x equals y, y must also equal x.   CHAPTER 6  Using the Object and Class Classes      325   LISTING	6-1:	  Comparing Objects  4.  Cast obj to a variable of your class; then compare the fields you want to   base the return value on, and return the result.  Here’s an example:  Employee emp =  Employee  obj; return this.lastName.equals emp.getLastName        && this.firstname.equals emp.getFirstName   ;  Notice that the field comparisons for the String values use the equals method  rather than ==. This is because you can’t trust == to compare strings. If you  need to compare primitive types, you can use ==. But you should use equals  to compare strings and any other reference types.  Putting it all together, Listing 6-1 shows a program that compares two Employee  objects by using a properly constructed equals method.  public class TestEquality2 {    public static void main String[] args     {       Employee emp1 = new Employee            "Martinez", "Anthony" ;       Employee emp2 = new Employee            "Martinez", "Anthony" ;       if  emp1.equals emp2             System.out.println               "These employees are the same." ;       else          System.out.println               "These are different employees." ;    } } class Employee  {    private String lastName;    private String firstName;    public Employee String lastName, String firstName     {       this.lastName = lastName;       this.firstName = firstName;    }    public String getLastName    →5  →7  →9  →18  326      BOOK 3  Object-Oriented Programming      {       return this.lastName;    }    public String getFirstName      {       return this.firstName;    }    public boolean equals Object obj      {          an object must equal itself       if  this == obj            return true;          no object equals null       if  this == null            return false;          objects of different types are never equal       if  this.getClass   != obj.getClass              return false;          cast to an Employee, then compare the fields       Employee emp =  Employee  obj;        return this.lastName.equals emp.getLastName             && this.firstName.equals emp.getFirstName   ;    } }  →39  →42  →46  →50  →54 →55  Creates an Employee object with the name Anthony Martinez.   Creates another Employee object with the name Anthony Martinez.   Compares the two Employee objects by using the equals method.  Following are some noteworthy points in this listing: →5  →7  →9  →18  →39  →42   The overridden equals method.  The Employee class.   Returns true if the same object instances are being compared. This  meets the first equality test: that an object must always be equal to  itself.  →46   →50    Returns false if the object being compared is null. This meets the last  equality test: that nothing is equal to null.   Returns false if the object being compared isn’t of the correct type.  This helps ensure the symmetry test: that if x equals y, y must equal x.  CHAPTER 6  Using the Object and Class Classes      327   →54   →55    Having slid through the other tests, you can assume that you’re  comparing two different Employee objects, so the next step is to cast  the other object to an Employee.   Having cast the other object to an Employee, the two fields  last  Name and firstName  are compared, and the result of the compound  comparison is returned.  The clone Method  Cloning refers to the process of making an exact duplicate of an object. Unfortu- nately, this process turns out to be a pretty difficult task in an object-oriented  language such as Java. You’d think that cloning would be as easy as this:  Employee emp1 = new Employee "Stewart", "Martha" ; Employee emp2 = emp1;  This code doesn’t make a copy of the Employee object at all, however. Instead, you  now have two variables that refer to the same object, which usually isn’t what you  want. Suppose that you execute these statements:  emp1.setLastName "Washington" ; emp2.setLastName "Graham" ; String lastName = emp1.getLastName  ;  After these statements execute, does lastName return Washington or Graham? The  correct answer is Graham, because both emp1 and emp2 refer to the same Employee  object.  By contrast, a clone is an altogether new object that has the same values as the  original object. Often you can create a clone manually by using code like this:  Employee emp1 = new Employee "Stewart", "Martha" ; Employee emp2 = new Employee  ; emp2.setLastName emp1.getLastName   ; emp2.setFirstName emp1.getFirstName   ; emp2.setSalary emp1.getSalary   ;  Here a new Employee object is created, and its fields are set to the same values as  the original object.  328      BOOK 3  Object-Oriented Programming   Java provides a more elegant way to create object copies: the clone method, which  is available to all classes because it’s inherited from the Object class. As you dis- cover in the following sections, however, the clone method can be difficult to cre- ate and use. For this reason, you want to implement it only for those classes that  you think can really benefit from cloning.  Implementing the clone method  The  clone  method  is  defined  by  the  Object  class,  so  it’s  available  to  all  Java  classes,  but  clone  is  declared  with  protected  access  in  the  Object  class.  As  a  result, the clone method for a given class is available only within that class. If you  want other objects to be able to clone your object, you must override the clone  method and give it public access.  Note that the clone method defined by the Object class returns an Object type.  That makes perfect sense, because the Object class doesn’t know the type of the  class in which you’ll be overriding the clone method. An inconvenient side effect  of returning an Object is that whenever you call the clone method for a class that  overrides clone, you must cast the result to the desired object type.  Listing 6-2 gives a simple example of a program that clones Employee objects.  In a nutshell, this program overrides the clone method for the Employee class: It  creates an Employee object, clones it, changes the name of the original Employee  object, and prints out both objects to the console.  LISTING	6-2:	 A Cloning Example  public class CloneTest {     public static void main String[] args      {         Employee emp1 = new Employee               "Martinez", "Anthony" ;         emp1.setSalary 40000.0 ;          Employee emp2 =  Employee emp1.clone  ;          emp1.setLastName "Smith" ;          System.out.println emp1 ;          System.out.println emp2 ;      } } class Employee   →5  →7 →8 →9 →10 →11  →15   continued   CHAPTER 6  Using the Object and Class Classes      329   LISTING	6-2:	   continued   {     private String lastName;     private String firstName;     private Double salary;     public Employee String lastName,                     String firstName      {         this.lastName = lastName;         this.firstName = firstName;     }     public String getLastName       {         return this.lastName;     }     public void setLastName String lastName      {         this.lastName = lastName;     }     public String getFirstName       {         return this.firstName;     }     public void setFirstName String firstName      {         this.firstName = firstName;     }     public Double getSalary       {         return this.salary;     }     public void setSalary Double salary      {         this.salary = salary;     }     public Object clone        {         Employee emp;         emp = new Employee               this.lastName, this.firstName ;         emp.setSalary this.salary ;          return emp;      }     public String toString       {  330      BOOK 3  Object-Oriented Programming  →57  →60  →62 →63           return this.getClass  .getName   + "["             + this.firstName + " "             + this.lastName + ", "             + this.salary + "]";     } }  When you run this program, the following lines appear on the console:  Employee[Anthony Smith, 40000.0] Employee[Anthony Martinez, 40000.0]  As you can see, the name of the second Employee object was successfully changed  without affecting the name of the first Employee object.  The following paragraphs draw your attention to some of the highlights of this  program: →5    Creates the first Employee object for an employee named Anthony  Martinez.  →7  →8   →9  →10  →11  →15   →57   →60   →62  →63   Sets Mr. Martinez’s salary.   Creates a clone of the Employee object for Mr. Martinez. Notice that the  return value must be cast to an Employee, because the return value of  the clone method is Object.  Changes the last name for the second Employee object.  Prints the first Employee object.  Prints the second Employee object.   The Employee class. This class defines private fields to store the last  name, first name, and salary, as well as getter and setter methods for  each field.   Overrides the clone method. Notice that its return type is Object, not  Employee.   Creates a new Employee object, using the last name and first name  from the current object.  Sets the new employee’s salary to the current object’s salary.  Returns the cloned Employee object.  CHAPTER 6  Using the Object and Class Classes      331   Using clone to create a shallow copy  In the preceding example, the clone method manually creates a copy of the origi- nal object and returns it. In many cases, this is the easiest way to create a clone.  But what if your class has a hundred or more fields that need to be duplicated? The  chance of forgetting to copy one of the fields is high, and if you add a field to the  class later on, you may forget to modify the clone method to include the new field.  Fortunately, you can solve this problem by using the clone method of the Object  class directly in your own clone method. The clone method of the Object class  can automatically create a copy of your object that contains duplicates of all the  fields  that  are  primitive  types   such  as  int  and  double ,  as  well  as  copies  of  immutable reference types — most notably, strings. So if all the fields in your  class are either primitives or strings, you can use the clone method provided by  the Object class to clone your class.  This type of clone is known as a shallow copy, for reasons that I explain in the next  section.  To  call  the  clone  method  from  your  own  clone  method,  just  specify  super. clone  . Before you can do that, however, you must do two things:   » Declare that the class supports the Cloneable interface. The Cloneable  interface is a tagging interface that doesn’t provide any methods. It simply  marks a class as being appropriate for cloning.   » Enclose the call to super.clone   in a try catch statement that catches the  exception CloneNotSupportedException. This exception is thrown if you try  to call clone on a class that doesn’t implement the Cloneable interface.  Provided that you implement Cloneable, this exception won’t ever happen,  but because CloneNotSupportedException is a checked exception, you  must catch it.  Here’s an example of an  Employee class with a clone method that uses  super. clone   to clone itself:  class Employee implements Cloneable {        Fields and methods omitted...     public Object clone       {         Employee emp;         try         {  332      BOOK 3  Object-Oriented Programming               emp =  Employee  super.clone  ;         }         catch  CloneNotSupportedException e          {             return null;      will never happen         }         return emp;     } }  Notice that this method doesn’t have to be aware of any of the fields declared in  the Employee class. This clone method, however, works only for classes whose  fields are all either primitive types or immutable objects such as strings.  Creating deep copies  It’s  not  uncommon  for  some  fields  in  a  class  actually  to  be  other  objects.  The  Employee class, for example, might have a field of type  Address that’s used to  store each employee’s address:  class Employee {     public Address address;        other fields and methods omitted }  If that’s the case, the super.clone   method won’t make a complete copy of the  object. The clone won’t get a clone of the address field. Instead, it has a reference  to the same address object as the original.  To  solve  this  problem,  you  must  do  a  deep  copy  of  the  Employee  object.  A  deep  copy is a clone in which any subobjects within the main object are also cloned. To  accomplish this feat, the clone method override first calls super.clone   to create  a shallow copy of the object. Then it calls the clone method of each of the subob- jects contained by the main object to create clones of those objects.  For a deep copy  to work, of course, those objects must also support the clone methods.   Listing  6-3  shows  an  example.  Here,  an  Employee  class  contains  a  public  field  named address, which holds an instance of the Address class. As you can see,  the clone method of the Employee class creates a shallow copy of the Employee  object and then sets the copy’s address field to a clone of the original object’s  address field. To make this example work, the Address class also overrides the  clone method. Its clone method calls super.clone   to create a shallow copy of  the Address object.  CHAPTER 6  Using the Object and Class Classes      333   LISTING	6-3:	  Creating a Deep Copy  public class CloneTest2 {    public static void main String[] args     {       Employee emp1 = new Employee             "Martinez", "Anthony" ;       emp1.setSalary 40000.0 ;       emp1.address = new Address             "1300 N. First Street",           "Fresno", "CA", "93702" ;       Employee emp2 =  Employee emp1.clone  ;        System.out.println             "**** after cloning ****\n" ;       printEmployee emp1 ;       printEmployee emp2 ;       emp2.setLastName "Smith" ;        emp2.address = new Address             "2503 N. 6th Street",           "Fresno", "CA", "93722" ;       System.out.println             "**** after changing emp2 ****\n" ;       printEmployee emp1 ;       printEmployee emp2 ;    }    private static void printEmployee Employee e      {       System.out.println e.getFirstName             + " " + e.getLastName   ;       System.out.println e.address.getAddress   ;       System.out.println "Salary: " + e.getSalary   ;       System.out.println  ;    } } class Employee implements Cloneable  {    private String lastName;    private String firstName;    private Double salary;    public Address address;     public Employee String lastName, String firstName     {       this.lastName = lastName;       this.firstName = firstName;  →5  →8  →11 →13  →18 →19  →23  →30  →40  →46  334      BOOK 3  Object-Oriented Programming         this.address = new Address  ;    }    public String getLastName      {       return this.lastName;    }    public void setLastName String lastName     {       this.lastName = lastName;    }    public String getFirstName      {       return this.firstName;    }    public void setFirstName String firstName     {       this.firstName = firstName;    }    public Double getSalary      {       return this.salary;    }    public void setSalary Double salary     {       this.salary = salary;    }    public Object clone       {       Employee emp;       try       {           emp =  Employee  super.clone  ;            emp.address =  Address address.clone  ;        }       catch  CloneNotSupportedException e         {           return null;      will never happen       }       return emp;     }    public String toString      {       return this.getClass  .getName   + "["           + this.firstName + " "  →85  →90 →91  →93  →97  CHAPTER 6  Using the Object and Class Classes      335   continued    →109  →133  →137  LISTING	6-3:	   continued             + this.lastName + ", "           + this.salary + "]";    } } class Address implements Cloneable  {    private String street;    private String city;    private String state;    private String zipCode;    public Address      {       this.street = "";       this.city = "";       this.state = "";       this.zipCode = "";    }    public Address String street, String city,                  String state, String zipCode     {       this.street = street;       this.city = city;       this.state = state;       this.zipCode = zipCode;    }    public Object clone       {       try       {           return super.clone  ;        }       catch  CloneNotSupportedException e        {           return null;      will never happen       }    }    public String getAddress      {       return this.street + "\n"           + this.city + ", "           + this.state + " "           + this.zipCode;    } }  336      BOOK 3  Object-Oriented Programming   The main method in the CloneTest2 class creates an Employee object and sets its  name, salary, and address. Then it creates a clone of this object and prints the data  contained in both objects. Next, it changes the last name and address of the sec- ond employee and prints the data again. Here’s the output that’s produced when  this program is run:  **** after cloning **** Anthony Martinez 1300 N. First Street Fresno, CA 93702 Salary: 40000.0 Anthony Martinez 1300 N. First Street Fresno, CA 93702 Salary: 40000.0 **** after changing emp2 **** Anthony Martinez 1300 N. First Street Fresno, CA 93702 Salary: 40000.0 Anthony Smith 2503 N. 6th Street Fresno, CA 93722 Salary: 40000.0  As you can see, the two Employee objects have identical data after they are cloned,  but they have different data after the fields for the second employee have been  changed.  Thus,  you  can  safely  change  the  data  in  one  of  the  objects  without  affecting the other object.  Creates an employee named Anthony Martinez.  The following paragraphs describe some of the highlights of this program: →5  →8  →11  →13    Prints the two Employee objects after cloning. They should have  identical data.  Clones the employee  okay, just the object, not the co-worker .  Sets the employee’s address.  Changes the second employee’s name.  Changes the second employee’s address.  →18  →19  →23    Prints the two Employee objects after changing the data for the second  employee. The objects should now have different data.  CHAPTER 6  Using the Object and Class Classes      337   →30  →40  →46  →85  →90  →91   →93   →97  →109  →133  →137    A utility method that prints the data for an Employee object.  The Employee class. Notice that this class implements Cloneable.  The address field, which holds an object of type Address.  The clone method in the Employee class.  Creates a shallow copy of the Employee object.   Creates a shallow copy of the Address object and assigns it to the  address field of the cloned Employee object.   Catches CloneNotSupportedException, which won’t ever happen  because the class implements Cloneable. The compiler requires the  try catch statement here because CloneNotSupportedException is  a checked exception.  Returns the cloned Employee object.  The Address class, which also implements Cloneable.  The clone method of the Address class.  Returns a shallow copy of the Address object.  The Class Class  Okay, class, it’s time for one last class in this chapter: the Class class. The word- ing might get confusing, so put your thinking cap on.  Every class used by a Java application is represented in memory by an object of  type Class. If your program uses Employee objects, for example, there’s also a  Class object for the Employee class. This Class object has information not about  specific employees but about the Employee class itself.  You’ve already seen how you can get a Class object by using the getClass method.  This method is defined by the Object class, so it’s available to every object. Here’s  an example:  Employee emp = new Employee  ; Class c = emp.getClass  ;  338      BOOK 3  Object-Oriented Programming   Note that you have to initialize a variable with an object instance before you can  call its getClass method. That’s because the getClass method returns a Class  object that corresponds to the type of object the variable refers to, not the type the  variable is declared as.  Suppose that an HourlyEmployee class extends the Employee class. Then consider  these statements:  HourlyEmployee emp = new Employee  ; Class c = emp.getClass  ;  Here c refers to a Class object for the HourlyEmployee class, not the Employee  class.  The Class class has more than 50 methods, but only 2 of them are worthy of your  attention:   » getName  : Returns a String representing the name of the class  » getSuperclass  : Returns another Class object representing this Class   object’s superclass  If you’re interested in the other capabilities of the Class class, you can always  check it out in the Java API documentation.  One  of  the  most  common  uses  of  the  getClass  method  is  to  tell  whether  two  objects are of the same type by comparing their Class objects. This works because  Java guarantees that the Class object has only one instance for each different class  used by the application. So even if your application instantiates 1,000 Employee  objects, there is only one Class object for the Employee class.  As a result, the following code can determine whether two objects are both objects  of the same type:  Object o1 = new Employee  ; Object o2 = new Employee  ; if  o1.getClass   == o2.getClass        System.out.println "They're the same." ; else     System.out.println "They are not the same." ;  In this case, the type of both objects is Employee, so the comparison is true.  CHAPTER 6  Using the Object and Class Classes      339   To find out whether an object is of a particular type, use the object’s getClass  method to get the corresponding Class object. Then use the getName method to  get the class name, and use a string comparison to check the class name. Here’s  an example:  if  emp.getClass  .getName  .equals "Employee"       System.out.println "This is an employee object." ;  If all the strung-out method calls give you a headache, you can break the code  apart:  Class c = emp.getClass  ; String s = c.getName  ; if  s.equals "Employee"       System.out.println "This is an employee object." ;  The result is the same.  340      BOOK 3  Object-Oriented Programming   IN THIS CHAPTER  » Using inner classes   » Creating static inner classes   » Implementing anonymous classes   » Adding Lambda expressions  Chapter 7 Using Inner Classes,  Anonymous Classes, and  Lambda Expressions  In this chapter, you find out how to use three advanced types of classes: inner   classes, static inner classes, and anonymous inner classes. All three types are  useful  in  certain  circumstances.  In  particular,  inner  classes  and  anonymous  inner classes are commonly used with graphical applications created with Swing.  For more information about Swing, refer to Book 6. In this chapter, I concentrate  on the mechanics of creating these types of classes.  You’ll also learn about a feature that was introduced with Java 8 called lambda  expressions, which simplify the task of creating and using anonymous classes.  Once again, this chapter could have a Technical Stuff icon pasted next to every  other paragraph. The immediate usefulness of some of the information I present  in this chapter may seem questionable. But trust me — you need to know this  stuff when you start writing Swing applications. If you want to skip this chapter  for now, that’s okay. You can always come back to it when you’re learning Swing  and need to know how inner classes and anonymous inner classes work.  CHAPTER 7  Using Inner Classes, Anonymous Classes, and Lambda Expressions      341   Declaring Inner Classes  An inner class is a class that’s declared inside another class. Thus the basic struc- ture for creating an inner class is as follows:  class outerClassName {     private class innerClassName     {            body of inner class     } }  The  class  that  contains  the  inner  class  is  called  an  outer  class.  You  can  use  a   visibility  modifier  with  the  inner  class  to  specify  whether  the  class  should  be   public, protected, or private. This visibility determines whether other classes  can see the inner class.  Understanding inner classes  At the surface, an inner class is simply a class that’s contained inside another class,  but there’s more to it than that. Here are some key points about inner classes:   » An inner class automatically has access to all the fields and methods of the  outer class, even to private fields and methods. Thus an inner class has more  access to its outer class than a subclass has to its superclass.  A subclass can  access public and protected members of its superclass, but not pri- vate members.    » An inner class carries with it a reference to the current instance of the outer   class that enables it to access instance data for the outer class.   » Because of the outer-class instance reference, you can’t create or refer to an  inner class from a static method of the outer class. You can, however, create a  static inner class, as I describe in the section “Using Static Inner Classes,” later  in this chapter.   » One of the main reasons for creating an inner class is to create a class-that’s  of interest only to the outer class. As a result, you usually declare inner classes  to be private so that other classes can’t access them.   » Occasionally, code in an inner class needs to refer to the instance of its outer   class. To do that, you list the name of the outer class followed by the dot  operator and this. If the outer class is named MyOuterClass, for example,  you would use MyOuterClass.this to refer to the instance of the outer class.  342      BOOK 3  Object-Oriented Programming   Viewing an example  Book 3, Chapter 5 introduces an application that uses the Timer class in the Swing  package  javax.swing.Timer  that displays the lines Tick... and Tock... on the  console at one-second intervals. It uses a class named Ticker that implements  the ActionListener interface to handle the Timer object’s clock events.  In this chapter, you see three versions of this application. You may want to quickly  review Book 3, Chapter 5 if you’re unclear on how this application uses the Timer  class  to  display  the  Tick...  and  Tock...  messages  or  why  the  JOptionPane   dialog box is required.  Listing 7-1 shows a version of this application that implements the Ticker class  as an inner class.  LISTING 7-1:   Tick Tock with an Inner Class  import java.awt.event.*; import javax.swing.*;  public class TickTockInner {    private String tickMessage = "Tick...";     private String tockMessage = "Tock...";      public static void main String[] args     {        TickTockInner t = new TickTockInner  ;         t.go  ;     }    private void go       {           create a timer that calls the Ticker class           at one second intervals        Timer t = new Timer 1000, new Ticker   ;         t.start  ;            display a message box to prevent the           program from ending immediately        JOptionPane.showMessageDialog null,             "Click OK to exit program" ;        System.exit 0 ;     }  →6 →7  →11 →12  →15  →19  →24  →26   continued   CHAPTER 7  Using Inner Classes, Anonymous Classes, and Lambda Expressions      343   LISTING 7-1:    continued      class Ticker implements ActionListener     {        private boolean tick = true;         public void actionPerformed ActionEvent event          {            if  tick             {                System.out.println tickMessage ;             }            else            {                System.out.println tockMessage ;             }            tick = !tick;        }    } }  →29  →33  →37  →41  The following paragraphs describe some of the highlights of this program: →6    The String variables named tickMessage and tockMessage  line 7   contain the messages to be printed on the console. Note that these  variables are defined as fields of the outer class. As you’ll see, the inner  class Ticker is able to access these fields directly.  THE OBSERVER PATTERN  Event listeners in Java are part of a Java model called the Delegation Event Model, which is  an implementation of a more general design pattern called the Observer pattern. This  pattern is useful when you need to create objects that interact with one another when  a change in the status of one of the objects occurs. The object whose changes are being  monitored is called the observable object, and the object that monitors those changes is  called the observer object. The observer object registers itself with the observable object,  which then notifies the observer object when its status changes.  You discover more about how Java implements this pattern for event handling in Book 6.  But if you’re interested, you may want to investigate the Observer and Observable   interfaces that are part of the Java API. They provide a standard way to create simple  implementations of the Observer pattern.  344      BOOK 3  Object-Oriented Programming   →11   →12   →15  →19   →24   →26   →29   →33   →37    Because an inner class can be used only by an instantiated object, you  can’t use it directly from the static main method. As a result, the main  method in this program simply creates an instance of the application  class  TickTockInner .   This line executes the go method of the new instance of the  TickTockInner class.  The technique used in lines 11 and 12 is a fairly common programming  technique that lets an application get out of a static context quickly and  into an object-oriented mode.  This line is the go method, called from line 12.   This line creates an instance of the Timer class with the timer interval  set to 1,000 milliseconds  1 second  and the ActionListener set to a  new instance of the inner class named Ticker.   Here, the JOptionPane class is used to display a dialog box. This dialog  box is necessary to give the timer a chance to run. The application ends  when the user clicks OK.   This line calls the exit method of the System class, which immediately  shuts down the Java Virtual Machine. This method call isn’t strictly  required here, but if you leave it out, the timer continues to run for a  few seconds after you click OK before the JVM figures out that it should  kill the timer.   This line is the declaration for the inner class named Ticker. Note that  this class implements the ActionListener interface.   The actionPerformed method is called by the Timer object every  1,000 milliseconds.   In this line and in line 41, the inner class directly accesses a field of the  outer class.  Using Static Inner Classes  A static inner class is similar to an inner class but doesn’t require an instance of the  outer class. Its basic form is the following:  class outerClassName {     private static class innerClassName     {  CHAPTER 7  Using Inner Classes, Anonymous Classes, and Lambda Expressions      345              body of inner class     } }  Like a static method, a static inner class can’t access any nonstatic fields or meth- ods in its outer class. It can access static fields or methods, however.  Listing 7-2 shows a version of the Tick Tock application that uses a static inner  class rather than a regular inner class.  LISTING 7-2:   Tick Tock with a Static Inner Class  import java.awt.event.*; import javax.swing.*;  public class TickTockStatic {     private static String tickMessage = "Tick...";      private static String tockMessage = "Tock...";   →6 →7      public static void main String[] args      {         TickTockStatic t = new TickTockStatic  ;         t.go  ;     }     private void go       {            create a timer that calls the Ticker class            at one second intervals         Timer t = new Timer 1000, new Ticker   ;         t.start  ;             display a message box to prevent the            program from ending immediately         JOptionPane.showMessageDialog null,             "Click OK to exit program" ;         System.exit 0 ;     }      static class Ticker implements ActionListener      {         private boolean tick = true;  →29          public void actionPerformed              ActionEvent event   346      BOOK 3  Object-Oriented Programming           {             if  tick              {                 System.out.println tickMessage ;             }             else             {                 System.out.println tockMessage ;             }             tick = !tick;         }     } }  This  version  of  the  application  and  the  Listing  7-1  version  have  only  three  differences: →6    The tickMessage field is declared as static. This is necessary so that  the static class can access it.  →7  →29   The tockMessage field is also declared as static.  The Ticker class is declared as static.  Using Anonymous Inner Classes  Anonymous  inner  classes   usually  just  called  anonymous  classes   are  probably  the  strangest feature of the Java programming language. The first time you see an  anonymous class, you’ll almost certainly think that someone made a mistake and  that the code can’t possibly compile. But compile it does, and it even works. When  you get the hang of working with anonymous classes, you’ll wonder how you got  by without them.  An anonymous class is a class that’s defined on the spot, right at the point where  you want to instantiate it. Because you code the body of the class right where you  need it, you don’t have to give it a name.  That’s why it’s called an anonymous class.   Creating an anonymous class  The basic form for declaring and instantiating an anonymous class is this:  new ClassOrInterface   { class-body }  CHAPTER 7  Using Inner Classes, Anonymous Classes, and Lambda Expressions      347   As you can see, you specify the new keyword followed by the name of a class or inter- face that specifies the type of the object created from the anonymous class. This  class or interface name is followed by parentheses, which may include a parameter  list that’s passed to the constructor of the anonymous class. Then you code a class  body enclosed in braces. This class body can include anything that a regular class  body can include: fields, methods, and even other classes or interfaces.  Here’s an example of a simple anonymous class:  public class AnonClass {     public static void main String[] args      {         Ball b = new Ball               {                 public void hit                   {                     System.out.println "You hit it!" ;                 }             };         b.hit  ;     }      interface Ball     {         void hit  ;     } }  In this example, I create an interface named Ball that has a single method named  hit. Then, back in the main method, I declare a variable of type Ball and use an  anonymous class to create an object. The body of the anonymous class consists of  an implementation of the hit method that simply displays the message You hit  it! on the console. After the anonymous class is instantiated and assigned to the  b variable, the next statement calls the hit method.  When you run this program, the single line You hit it! is displayed on the console.  Here are some things to ponder when you work with anonymous classes:   » You can’t create a constructor for an anonymous class, because the anony-  mous class doesn’t have a name. What would you call the constructor, anyway?   » You can’t pass parameters if the anonymous class is based on an interface.  That makes sense; interfaces don’t have constructors, so Java wouldn’t have  anything to pass the parameters to.  348      BOOK 3  Object-Oriented Programming   LISTING 7-3:   Tick Tock with an Anonymous Class   » An assignment statement can use an anonymous class as shown in this   example. In that case, the anonymous class body is followed by a semicolon  that marks the end of the assignment statement. Note that this semicolon is  part of the assignment statement, not the anonymous class.  In the next  section, you see an example of an anonymous class that’s passed as a method  parameter. In that example, the body isn’t followed by a semicolon.    » An anonymous class is a special type of inner class; like any inner class, it   automatically has access to the fields and methods of its outer class.   » An anonymous class can’t be static.  Creating a program with   an anonymous class  Listing 7-3 shows a more complex example of an anonymous class: a version of  the Tick Tock application that uses an anonymous class as the action listener for  the timer.  import java.awt.event.*; import javax.swing.*; public class TickTockAnonymous {    private String tickMessage = "Tick...";    private String tockMessage = "Tock...";     public static void main String[] args      {       TickTockAnonymous t = new TickTockAnonymous  ;       t.go  ;    }     private void go      {          create a timer that calls the Ticker class          at one second intervals       Timer t = new Timer 1000,           new ActionListener             {               private boolean tick = true;  →9  →19 →20 →21   continued   CHAPTER 7  Using Inner Classes, Anonymous Classes, and Lambda Expressions      349   LISTING 7-3:    continued   →24  →37               public void actionPerformed                    ActionEvent event               {                  if  tick                   {                      System.out.println tickMessage ;                  }                  else                  {                      System.out.println tockMessage ;                  }                  tick = !tick;              }          }  ;         t.start  ;          display a message box to prevent the          program from ending immediately       JOptionPane.showMessageDialog null,          "Click OK to exit program" ;       System.exit 0 ;    } }  By now, you’ve seen enough versions of this program that you should understand  how it works. The following paragraphs explain how this version uses an anony- mous class as the ActionListener parameter supplied to the Timer constructor: →9    Anonymous classes won’t work in a static context, so the main method  creates an instance of the TickTockAnonymous class and executes the  go method.  →19  →20   →21  →24   In the go method, an instance of the Timer class is created.   The second parameter of the TimerClass constructor is an object that  implements the ActionListener interface. This object is created here  via an anonymous class. ActionListener is specified as the type for  this class.   This left brace marks the beginning of the body of the anonymous class.    The actionPerformed method is called every 1,000 milliseconds by  the timer. Note that this method can freely access fields defined in the  outer class.  350      BOOK 3  Object-Oriented Programming   →37     The right brace on this line marks the end of the body of the anony- mous class. Then the right parenthesis marks the end of the parameter  list for the Timer constructor. The left parenthesis that’s paired with  this right parenthesis is on line 19. Finally, the semicolon marks the end  of the assignment statement that started on line 19.  Using Lambda Expressions  Java 8 introduces a new feature that in some ways is similar to anonymous classes,  but  with  more  concise  syntax.  More  specifically,  a  lambda  expression  lets  you   create an anonymous class that implements a specific type of interface called a  functional interface — which has one and only one abstract method.  The Ball interface that was presented in the previous section meets that definition:  interface Ball {     void hit  ; }  Here the only abstract method is the hit method.  A  functional  interface  can  contain  additional  methods,  provided  they  are  not  abstract.  Until  Java  8,  this  was  not  possible  because  an  interface  could  contain  only abstract methods. However, in Java 8 you can create default methods which  provide  a  default  implementation.  Thus  a  functional  interface  can  contain  one  or more default methods, but can contain only one abstract method.  For more  information about default methods, refer to Chapter 5 of this minibook.   A lambda expression is a concise way to create an anonymous class that imple- ments a functional interface. Instead of providing a formal method declaration  that includes the return type, method name, parameter types, and method body,  you simply define the parameter types and the method body. The Java compiler  infers the rest based on the context in which you use the lambda expression.  The  parameter  types  are  separated  from  the  method  body  by  a  new  operator,  called the arrow operator, which consists of a hyphen followed by a greater-than  symbol. Here’s an example that implements the Ball interface:     -> { System.out.println "You hit it!" ;}  CHAPTER 7  Using Inner Classes, Anonymous Classes, and Lambda Expressions      351   Here  the  lambda  expression  implements  a  functional  interface  whose  single  method does not accept parameters. When the method is called, the text "You hit  it!" is printed.  You can use a lambda expression anywhere you can use a normal Java expression.  You’ll use them most in assignment statements or as passed parameters. The only  restriction is that you can use a lambda expression only in a context that requires  an instance of a functional interface. For example, here’s a complete program that  uses a lambda expression to implement the Ball interface:  public class LambdaBall {     public static void main String[] args      {         Ball b =    -> { System.out.println "You hit it!" ; };         b.hit  ;     }     interface Ball     {         void hit  ;     } }  The general syntax for a lambda expression is this:   parameters  -> expression  or this:   parameters  -> { statement;...}  If  you  use  an  expression,  a  semicolon  is  not  required.  If  you  use  one  or  more  statements, the statements must be enclosed in curly braces and a semicolon is  required at the end of each statement.  Don’t  forget  that  the  statement  in  which  you  use  the  lambda  expression  must  itself end with a semicolon. Thus, the lambda expression in the previous example  has two semicolons in close proximity:  Ball b =    -> { System.out.println "You hit it!" ; };  The  first  semicolon  marks  the  end  of  the  statement  that  calls  System.out. println; the second semicolon marks the end of the assignment statement that  assigns the lambda expression to the variable b.  352      BOOK 3  Object-Oriented Programming   IN THIS CHAPTER  » Creating packages for your classes   » Archiving your packages in JAR files   » Documenting your classes with   JavaDocs   » Using the Java Module System  Chapter 8 Working with Packages  and the New Java  Module System  This chapter shows you what to do with the classes you create. Specifically, I   show you how to organize classes into neat packages. Packages enable you  to keep your classes separate from classes in the Java API, allow you to reuse  your classes in other applications, and even let you distribute your classes to oth- ers, assuming other people might be interested in your classes. If that’s the case,  you probably won’t want to send those people all your separate class files. Instead,  bundle them into a single file called a JAR file. That’s covered in this chapter too.  I then show you how to use a feature called JavaDocs that lets you add documenta- tion comments to your classes. With JavaDocs, you can build professional-looking  documentation pages automatically. Your friends will think you’re a real Java guru  when you post your JavaDoc pages to your website.  Finally, I show you how to use a new feature of Java 9 called the Java Module Sys- tem, which provides an improved way of working with packages that avoids some  of the more common pitfalls of the old Java package system.  CHAPTER 8  Working with Packages and the New Java Module System      353   Working with Packages  A package is a group of classes that belong together. Without packages, the entire  universe of Java classes would be a huge, unorganized mess. Imagine the thou- sands of classes that are available in the Java API combined with millions of Java  classes created by Java programmers throughout the world and all thrown into  one big pot. Packages let you organize this mass into smaller, manageable collec- tions of related classes.  Importing classes and packages  When you use import statements at the beginning of a Java source file, you make  classes from the packages mentioned in the import statements available through- out the file.  I cover import statements in Book 2, Chapter 1, but it doesn’t hurt  to repeat it here.   An import statement can import all the classes in a package by using an asterisk  wildcard. Here all the classes in the java.util package are imported:  import java.util.*;  Alternatively, you can import classes one at a time. Here just the ArrayList class  is imported:  import java.util.ArrayList;  Note: You don’t have to use an import statement to use a class from a package.  But if you don’t use an import statement, you must fully qualify any references to  the class. For example, you can use the ArrayList class without importing java. util:  java.util.ArrayList = new java.util.ArrayList  ;  Because fully qualified names are a pain to always spell out, you should always  use import statements to import the packages or individual classes your applica- tion uses.  You never have to explicitly import two packages:   » java.lang: This package contains classes that are so commonly used that the   Java compiler makes them available to every program. Examples of the  classes in this package are String, Exception, and the various wrapper  classes, such as Integer and Boolean.  For complete documentation on this   354      BOOK 3  Object-Oriented Programming   package and all of the other Java packages described in this book, refer to  http:  download.java.net jdk8 docs api.    » The default package: This package contains classes that aren’t specifically  put in some other package. All the programs I show in this book up to this  point rely on the default package.  For simple program development and experimentation, using the default package  is acceptable. However, if you start work on a serious Java application, create a  separate package for it and place all of the application’s classes there. You find out  how to do that in the next section.  You can’t import the default package, even if you want to. Suppose you have two  packages  —  the  default  package  and  the  com.lowewriter.util  package.  The  default package’s code contains the statement import com.lowewriter.util.*.  That’s okay. But the default package doesn’t have a name — at least it has no  name  that  you  can  use  inside  a  program.  The  com.lowewriter.util  package’s  code can’t contain a statement like this one:  import that_default_package.you_know.the_one_with_no_name  Creating your own packages  Creating  your  own  packages  to  hold  your  classes  is  easy.  Well,  relatively  easy,  anyway. You must go through a few steps: 1.  Pick a name for your package.  You can use any name you wish, but I recommend you follow the established  convention of using your Internet domain name  if you have one , only  backwards. I own a domain called LoweWriter.com, so I use the name com. lowewriter for all my packages.  Using your domain name backwards  ensures that your package names are unique.   Notice that package names are in all-lowercase letters. That’s not an absolute  requirement, but it’s a Java convention that you ought to stick to. If you start  using capital letters in your package names, you’ll be branded a rebel for sure.  And since Java is case-sensitive, a package named com.lowewriter is a  different package from one named com.LoweWriter.  You can add additional levels beyond the domain name if you want. For  example, I put my utility classes in a package named com.lowewriter.util.  If you don’t have a domain all to yourself, try using your e-mail address  backwards. For example, if your e-mail address is SomeBody@SomeCompany. com, use com.somecompany.somebody for your package names. That way   CHAPTER 8  Working with Packages and the New Java Module System      355   they are still unique.  If you ever want to distribute your Java packages, you  should register a domain name. Nothing says “Amateur” like a package name  that starts with com.gmail. And, although a package name created from a  backwards e-mail address is almost sure to be unique, there is a small chance  that it won’t be.   2.  Choose a directory on your hard drive to be the root of your class library. You need a place on your hard drive to store your classes. I suggest you create  a directory such as c:\javaclasses.  This folder becomes the root directory for your Java packages.  3.  Create subdirectories within the root directory for your package name.  For example, for the package named com.lowewriter.util, create a  directory named com in the c:\javaclasses directory  assuming that’s the  name of your root . Then, in the com directory, create a directory named  lowewriter. Then, in lowewriter, create a directory named util. Thus, the  complete path to the directory that contains the classes for the com.lowe- writer.util package is c:\javaclasses\com\lowewriter\util.  4.  Add the root directory for your package to the ClassPath environment   variable.  The exact procedure for doing this depends on your operating system. You can  set the ClassPath by double-clicking System from the Control Panel. Click the  Advanced tab, and then click Environment Variables.  Be careful not to disturb any directories already listed in the ClassPath. To  add your root directory to the ClassPath, add a semicolon followed by the  path to your root directory to the end of the ClassPath value. For example,  suppose your ClassPath is already set to this:  .;c:\util\classes  Then you modify it to look like this:  .;c:\util\classes;c:\javaclasses  Here I added ;c:\javaclasses to the end of the ClassPath value.  5.  Save the files for any classes you want to be in a particular package in the   directory for that package.  For example, save the files for a class that belongs to the com.lowewriter.  util package in c:\javaclasses\com\lowewriter\util.  6.  Add a package statement to the beginning of each source file that   belongs in a package.  356      BOOK 3  Object-Oriented Programming   The package statement simply provides the name for the package that any  class in the file is placed in. For example:  package com.lowewriter.util;  The package statement must be the first non-comment statement in the file.  An example  Suppose you’ve developed a utility class named Console that has a bunch of handy  static methods for getting user input from the console. For example, this class  has a static method named askYorN that gets a Y or N from the user and returns  a boolean value to indicate which value the user entered. You decide to make this  class available in a package named com.lowewriter.util so you and other like- minded programmers can use it in their programs.  Here’s the source file for the Console class:  package com.lowewriter.util;  import java.util.Scanner;  public class Console {    static Scanner sc = new Scanner System.in ;    public static boolean askYorN String prompt     {       while  true        {          String answer;          System.out.print "\n" + prompt             + "  Y or N  " ;          answer = sc.next  ;          if  answer.equalsIgnoreCase "Y"                return true;          else if  answer.equalsIgnoreCase "N"                return false;       }    } }  Okay, so far this class has just the one method  askYorN , but one of these days  you’ll add a bunch of other useful methods to it. In the meantime, you want to get  it set up in a package so you can start using it right away.  CHAPTER 8  Working with Packages and the New Java Module System      357   So  you  create  a  directory  named  c:\javaclasses\com\lowewriter\util   as  described in the preceding section  and save the source file to this directory. Then  you compile the program so the Console.class file is stored in that directory too.  And you add c:\javaclasses to your ClassPath environment variable.  Now you can use the following program to test that your package is alive and well:  import com.lowewriter.util.*;  public class PackageTest {     public static void main String[] args      {         while  Console.askYorN "Keep going?"           {             System.out.println "D'oh!" ;         }     } }  Here the import statement imports all the classes in the com.lowewriter.util  package. Then, the while loop in the main method repeatedly asks the user if he  or she wants to keep going.  Putting Your Classes in a JAR File  A JAR file is a single file that can contain more than one class in a compressed  format  that  the  Java  Runtime  Environment  can  access  quickly.   JAR  stands  for  Java archive.  A JAR file can have just a few classes in it, or thousands. In fact, the  entire Java API is stored in a single JAR file named rt.java.  The rt stands for  runtime.  It’s a pretty big file — over 35MB — but that’s not bad, considering that  it contains more than 12,000 classes.  JAR files are created by the jar utility, which you find in the Java bin directory  along with the other Java command-line tools, such as java and javac. JAR files  are similar in format to Zip files, a compressed format made popular by the PKZIP  program. The  main  difference  is  that  JAR  files  contain  a  special  file,  called  the  manifest file, that contains information about the files in the archive. This manifest  is automatically created by the jar utility, but you can supply a manifest of your  own to provide additional information about the archived files.  358      BOOK 3  Object-Oriented Programming   JAR files are the normal way to distribute finished Java applications. After finish- ing your application, you run the jar command from a command prompt to pre- pare the JAR file. Then, another user can copy the JAR file to his or her computer.  The user can then run the application directly from the JAR file.  JAR files are also used to distribute class libraries. You can add a JAR file to the  ClassPath environment variable. Then the classes in the JAR file are automatically  available to any Java program that imports the package that contains the classes.  jar command-line options  The jar command is an old-fashioned Unix-like command, complete with arcane  command-line options that you have to get right if you expect to coax jar into  doing something useful.  The basic format of the jar command is this:  jar options jar-file [manifest-file] class-files...  The options specify the basic action you want jar to perform and provide addi- tional information about how you want the command to work. Table 8-1 lists the  options.  TABLE 8-1	  Options for the jar Command Option  Description  Creates a new jar file.  Updates an existing jar file.  Extracts files from an existing jar file.  Lists the contents of a jar file.  c  u  x  t  f  v  0  m  M  Indicates that the jar file is specified as an argument. You almost always  want to use this option.  Verbose output. This option tells the jar command to display extra  information while it works.  Doesn’t compress files when it adds them to the archive. This option isn’t  used much.  Specifies that a manifest file is provided. It’s listed as the next argument  following the jar file.  Specifies that a manifest file should not be added to the archive. This option  is rarely used.  CHAPTER 8  Working with Packages and the New Java Module System      359   Note that you must specify at least the c, u, x, or t option to tell jar what action  you want to perform.  Archiving a package  The most common use for the jar utility is to create an archive of an entire pack- age.  The  procedure  for  doing  that  varies  slightly  depending  on  what  operating  system you’re using. However, the jar command itself is the same regardless of  your operating system. Here’s the procedure for archiving a package on a PC run- ning any version of Windows: 1.  Open a command window.  The easiest way to do that is to choose Start ➪  Run, type cmd in the Open text  box, and click OK. On Windows 8, right-click the Start button, and then choose  Command Prompt on the menu that appears.  If you have trouble running the jar command in Step 3, you may need to open  the command prompt in Administrator mode. To do so, click the Start menu,  type cmd, right-click cmd.exe at the top of the Start menu, and choose Run as  Administrator.  2.  Use a cd command to navigate to your package root.  For example, if your packages are stored in c:\javaclasses, use this  command:  cd \javaclasses  3.  Use a jar command that specifies the options cf, the name of the jar file,   and the path to the class files you want to archive.  For example, to create an archive named utils.jar that contains all the class  files in the com.lowewriter.util package, use this command:  jar cf utils.jar com\lowewriter\util\*.class  4.  To verify that the jar file was created correctly, use the jar command   that specifies the options tf and the name of the jar file.  For example, if the jar file is named utils.jar, use this command:  jar tf utils.jar  This lists the contents of the jar file so you can see what classes were added.  Here’s some typical output from this command:  META-INF  META-INF MANIFEST.MF com lowewriter util Console.class  360      BOOK 3  Object-Oriented Programming   As you can see, the utils.jar file contains the Console class, which is in my  com.lowewriter.util package.  5.  That’s all!  You’re done. You can leave the jar file where it is, or you can give it to your  friends so they can use the classes it contains.  Adding a jar to your classpath  To use the classes in an archive, you must add the jar file to your ClassPath envi- ronment variable. I describe the procedure for modifying the ClassPath variable  in Windows XP earlier in this chapter, in the section “Creating your own pack- ages.” So I won’t repeat the details here.  To  add  an  archive  to  the  ClassPath  variable,  just  add  the  complete  path  to  the  archive, making sure to separate it from any other paths already in the ClassPath  with a semicolon. Here’s an example:  .;c:\javaclasses\utils.jar;c:\javaclasses  Here I added the path c:\javaclasses\utils.jar to my ClassPath variable.  Starting with Java 1.6, you can add all the jar files from a particular directory to  the ClassPath in one fell swoop. For example, imagine that your c:\javaclasses  directory contains two jar files — utils.jar and extras.jar. To add both jar  files to the ClassPath, use a forward slash     followed by an asterisk:  .;c:\javaclasses *  The forward slash looks strange, especially when combined with the back slash in  c:\javaclasses. But that’s the way you use a ClassPath wildcard.  The first path in a ClassPath variable is always a single dot  . , which allows Java  to find classes in the current directory.  Also, be aware that Java searches the various paths and archive files in the Class  Path variable in the order in which you list them. Thus, with the ClassPath.;c:\ javaclasses\utils.jar;c:\javaclasses, Java searches for classes first in the  current directory, then in the utils archive, and finally in the c:\javaclasses  directory.  CHAPTER 8  Working with Packages and the New Java Module System      361   Running a program directly from an archive  With just a little work, you can set up an archive so that a Java program can be run  directly from it. All you have to do is create a manifest file before you create the  archive. Then, when you run the jar utility to create the archive, you include the  manifest file on the jar command line.  A manifest file is a simple text file that contains information about the files in the  archive. Although it can contain many lines of information, it needs just one line  to make an executable jar file:  Main-Class: ClassName  The  class  name  is  the  fully  qualified  name  of  the  class  that  contains  the  main  method that is executed to start the application. It isn’t required, but it’s typical  to use the extension .mf for manifest files.  For example, suppose you have an application whose main class is GuessingGame,  and all the class files for the application are in the package com.lowewriter.game.  First, create a manifest file named game.mf in the com\lowewriter\game direc- tory. This file contains the following line:  Main-Class: com.lowewriter.game.GuessingGame  Then  run  the  jar  command  with  the  options  cfm,  the  name  of  the  archive  to  create, the name of the manifest file, and the path for the class files. Here’s an  example:  jar cfm game.jar com\lowewriter\game\game.mf com\lowewriter\game\*.class  Now you can run the application directly from a command prompt by using the  java command with the -jar switch and the name of the archive file. Here’s an  example:  java -jar game.jar  This command starts the JRE and executes the main method of the class specified  by the manifest file in the game.jar archive file.  If your operating system is configured properly, you can also run the application  by double-clicking an icon for the jar file.  362      BOOK 3  Object-Oriented Programming   Using JavaDoc to Document Your Classes  One last step remains before you can go public with your hot new class library  or  application:  preparing  the  documentation  for  its  classes.  Fortunately,  Java  provides  a  tool  called  JavaDoc  that  can  automatically  create  fancy  HTML-based  documentation based on comments in your source files. All you have to do is add  a  comment  for  each  public  class,  field,  and  method;  then  run  the  source  files  through the javadoc command; voilá! you have professional-looking, web-based  documentation for your classes.  The following sections show you how to add JavaDoc comments to your source  files, how to run the source files through the javadoc command, and how to view  the resulting documentation pages.  Adding JavaDoc comments  The basic rule for creating JavaDoc comments is that they begin with  ** and end  with * . You can place JavaDoc comments in any of three different locations in a  source file:   » Immediately before the declaration of a public class  » Immediately before the declaration of a public field  » Immediately before the declaration of a public method or constructor  A  JavaDoc  comment  can  include  text  that  describes  the  class,  field,  or  method.  Each  subsequent  line  of  a  multiline  JavaDoc  comment  usually  begins  with  an  asterisk.  JavaDoc  ignores  this  asterisk  and  any  white  space  between  it  and  the  first word on the line.  The text in a JavaDoc comment can include HTML markup if you want to apply  fancy formatting. You should avoid using heading tags    and so on  because  JavaDoc creates those, and your heading tags just confuse things. But you can use  tags for boldface and italics    and    or to format code examples  use the    tag .  In addition, you can include special doc tags that provide specific information used  by JavaDoc to format the documentation pages. Table 8-2 summarizes the most  commonly used tags.  CHAPTER 8  Working with Packages and the New Java Module System      363   Commonly Used JavaDoc Tags Explanation  TABLE 8-2	  Tag  @author  @since  @param  @return  @throws  Provides information about the author, typically the author’s name, e-mail address, website  information, and so on.  @version  Indicates the version number.  Used to indicate the version with which this class, field, or method was added.  Provides the name and description of a method or constructor .  Provides a description of a method’s return value.  Indicates exceptions that are thrown by a method or constructor.  @deprecated  Indicates that the class, field, or method is deprecated and shouldn’t be used.  To  give  you  an  idea  of  how  JavaDoc  comments  are  typically  used,  Listing  8-1  shows a class named Employee with JavaDoc comments included.  This Java file  also includes a class named Address, which is required for the Employee class to  work. For the sake of brevity, I do not provide JavaDoc comments for the Address  class.   LISTING	8-1:	 An Employee Class with JavaDoc Comments  package com.lowewriter.payroll;   ** Represents an employee.  * @author Doug Lowe  * @author www.LoweWriter.com  * @version 1.5  * @since 1.0 *  public class Employee {    private String lastName;    private String firstName;    private Double salary;   ** Represents the employee's address. *     public Address address;  364      BOOK 3  Object-Oriented Programming    ** Creates an employee with the specified name.  * @param lastName The employee's last name.  * @param firstName The employee's first name. *     public Employee String lastName, String firstName     {        this.lastName = lastName;        this.firstName = firstName;        this.address = new Address  ;    }   ** Gets the employee's last name.  * @return A string representing the employee's last  *                  name. *     public String getLastName      {        return this.lastName;    }   ** Sets the employee's last name.  * @param lastName A String containing the employee's  *                 last name. *     public void setLastName String lastName     {        this.lastName = lastName;    }  ** Gets the employee's first name.  * @return A string representing the employee's first  *                  name. *     public String getFirstName      {        return this.firstName;    }  ** Sets the employee's first name.  * @param firstName A String containing the  *                    employee's first name. *     public void setFirstName String firstName     {        this.firstName = firstName;    }  CHAPTER 8  Working with Packages and the New Java Module System      365   continued    LISTING	8-1:	   continued    ** Gets the employee's salary.  * @return A double representing the employee's salary. *     public double getSalary      {        return this.salary;    }   ** Sets the employee's salary.  * @param salary A double containing the employee's  *                  salary. *     public void setSalary double salary     {        this.salary = salary;    } }  public class Address implements Cloneable {   public String street;   public String city;   public String state;   public String zipCode; }  Using the javadoc command  The javadoc command has a few dozen options you can set, making it a compli- cated command to use. However, you can ignore all these options to create a basic  set of documentation pages. Just specify the complete path to all the Java files you  want to create documentation for, like this:  javadoc com\lowewriter\payroll\*.java  The javadoc command creates the documentation pages in the current directory,  so you may want to switch to the directory where you want the pages to reside  first.  For more complete information about using this command, refer to the javadoc  documentation at the Oracle website. You can find it here: http:  www.oracle. com technetwork articles java index-jsp-135444.html.  366      BOOK 3  Object-Oriented Programming   Viewing JavaDoc pages  After you run the javadoc command, you can access the documentation pages by  starting with the index.html page. To quickly display this page, just type index. html at the command prompt after you run the javadoc command. Or you can  start your browser, navigate to the directory where you created the documentation  pages, and open the index.html page. Either way, Figure 8-1 shows an index page  that lists two classes.  FIGURE 8-1:   A JavaDocs   index page.  If you think this page looks familiar, that’s because the documentation for the  Java API was created using JavaDocs. So you should already know how to find your  way around these pages.  To look at the documentation for a class, click the class name’s link. A page with  complete documentation for the class comes up. For example, Figure 8-2 shows  part of the documentation page for the Employee class. JavaDocs generated this  page from the source file shown in Listing 8-1.  CHAPTER 8  Working with Packages and the New Java Module System      367   FIGURE 8-2:   Documentation  for the Employee  class.  Using the Java Module System  Java packages as described so far in this chapter have served Java programmers  well since the very first version of Java, introduced back in 1995. Packages were  state-of-the-art when Java was first released, but they’ve been showing their age  now  for  several  years.  For  example,  developers  often  have  problems  managing  packages for large applications that use a large numbers of packages, especially  when those packages require different versions of Java.  Another problem with packages is that they don’t provide an easy way to create a  lightweight application whose runtime contains only those portions of Java that  are actually needed. This can limit Java’s ability to run on devices with limited  resources, such as embedded controllers or smartphones.  The Java Module System, new with Java 9, is designed to address these two issues  and a few other more subtle problems with the old package system. The Java Mod- ule System, also known as Project Jigsaw, has been in development now for more  than six years. It was originally planned to be released with Java 7 in 2011, but it  wasn’t finished in time so it was deferred to Java 8. When Java 8 rolled out in 2014,  Project Jigsaw still wasn’t finished, so it was deferred to Java 9. The release of Java  9 was delayed several times so that Project Jigsaw could be finished, and the good  news is that the Java Module System is finally here!  368      BOOK 3  Object-Oriented Programming   The fact that Project Jigsaw took so long to develop is a testament to the impor- tance of the project. The Project Jigsaw developers wanted to make sure that they  got  it  right,  and  also  that  the  Java  Module  System  would  in  no  way  break  any  existing applications that rely on the time-tested Java package system. In fact, the  Java Module System is designed to work right alongside existing Java packages,  so you don’t have to convert any of your existing Java code to Project Jigsaw until  you’re ready and willing to do so.  With that in mind, the following sections introduce you to the basics of the Java  Module System.  Understanding modules  A module is a new way of grouping classes in a way that explicitly lists which other  modules the module depends on and what specific public types  that is, classes  and interfaces  within the classes contained in the module are to be made avail- able for other modules to use. To be more specific:   » A module must explicitly list its dependencies — that is, what other modules are  required for the module to compile and run. For example, if one or more of the  classes in the module require database access, the module must explicitly  indicate that it requires the Java database module  known as java.sql .   » A module must also explicitly list the visibility of any packages contained within   the module. As you already know, you can create public types within a  traditional package, and those public classes are available throughout the  package and also externally to the package. With modules, public types in a  package are visible outside of the module only if the package is explicitly listed  as an exported type.  If  this  sounds  complicated,  don’t  worry  —  it  isn’t.  Like  traditional  packages,  modules are stored in JAR files. A JAR file that contains a module is called a modu- lar JAR file. The only difference between a modular JAR file and a regular JAR file  is that a modular JAR file contains a special class called module-info.class. The  module-info.class class file identifies the module’s dependencies  that is, what  other modules are required  and the packages that are visible to other modules. All  this is done by means of a source file called module-info.java, which is explained  in the next section.  The module-info.java file  The module-info.java file is a Java source file that defines a module. The module  is defined by using a combination of several new Java language elements that are  introduced by Java 9.  CHAPTER 8  Working with Packages and the New Java Module System      369   Here is a simple module-info.java file that does creates a module but does not  define any dependencies or exported packages:  module com.lowewriter.payroll {}  In this example, the name of the module is com.lowewriter.payroll. Note that  modules are named just like packages, typically using the reverse-domain nota- tion.  In  other  words,  for  this  example,  I  used  my  own  personal  domain   lowe  writer.com  in reverse, followed by the name of the module.  To specify that the module is dependent on another module, you add a requires  statement that specifies the name of the module. For example, if the module will  require database access, it will need the standard java.SQL module:  If  the  module  also  depends  on  another  module  you’ve  created  named  com.  lowewriter.util, you would add a requires statement for that module as well:  module com.lowewriter.payroll {     requires java.SQL; }  module com.lowewriter.payroll {     requires java.SQL;     requires com.lowewriter.util; }  module com.lowewriter.payroll {     requires java.SQL;     requires com.lowewriter.util;     exports com.lowewriter.payrolldb; }  You can also add exports statements to export packages that are contained in the  module. When you export a package, any public classes or interfaces within the  package are visible to other modules. For example:  In  this  example,  any  public  classes  or  interfaces  defined  by  the  package  com.  lowewriter.payrolldb are visible to other modules.  370      BOOK 3  Object-Oriented Programming   Setting up folders for a module  Getting the source folders set up for a module is similar to setting up the folders  for  a  package,  but  with  the  added  requirement  that  the  module-info.java  file  must be in the root folder for the module. Typically, the root folder for the module  is named the same as the module, using the dots. For example, the root folder for  the com.lowewriter.payroll module is com.lowewriter.payroll.  The module-info.java file lives within the root folder. In addition, the path to  packages that are a part of the module typically follow the same convention as  for normal packages. Thus, within the module root folder is a folder named com,  within the com folder is a folder named lowewriter, and within the lowewriter  folder is a folder named payroll. The java files for the payroll package are within  the payroll folder.  Assuming that there are two source files for the payroll package  named Address. java and Employee.java , the complete folder structure including the source files  for the payroll example looks like this:  com.lowewriter.payroll     module-info.java     com         lowewriter             payroll                 Address.java                 Employee.java  Maybe  now  the  exports  command  in  the  module-info.java  file  makes  more  sense:  exports com.lowewriter.payroll;  Notice that the path from the module root to the source files for the package cor- respond to the package name.  Compiling a module  To compile a module, you can use the javac command from a command prompt,  specifying the name of all the source files you want to compile. First, navigate to  the root folder for the module  in this case, C:\java9\com.lowewriter.payroll .  Then use a javac command like this one:  javac module-info.java com\lowewriter\payroll\*.java  CHAPTER 8  Working with Packages and the New Java Module System      371   This command will create a module-info.class file in the module’s root folder as  well as .class files for all Java source files in com\lowewriter\payroll. For this  example, two class files will be created in the com\lowewriter\payroll folder:  Address.class and Employee.class.  Creating a modular JAR file  The final step for creating a Java module is to assemble the compiled class files   including module-info.class  into a module JAR file. You can do that by using  the jar command, like this:  jar cf com.lowewriter.payroll.jar *.class com\lowewriter\payroll\*.class  In  this  example,  cf  means  to  create  a  Jar  file.  The  cf  is  followed  by  the  class  files to include. To keep the command simple, I used wildcards to include all the  class files in the module root folder and all the class files in the com\lowewriter\  payroll folder.  You can verify that the Jar file contains the correct contents by running the jar  command with the tf option followed by the name of the Jar file. For example:  C:\Java9\com.lowewriter.payroll>jar tf com.lowewriter.payroll.jar META-INF  META-INF MANIFEST.MF module-info.class com lowewriter payroll Address.class com lowewriter payroll Employee.class  As you can see, the  jar  tf command indicates  that the Jar file contains  three  classes as expected: module-info.class and the two com.lowewriter.payroll  classes.  There is a lot more to learn about the Java Module System that’s beyond the scope  of this book, but this should be enough to get you started with it. For more infor- mation, search the web for Java Module System. You’ll find plenty of good informa- tion from Oracle and other sources about the advanced details of working with  modules for larger applications.  372      BOOK 3  Object-Oriented Programming   Strings, Arrays,  and Collections  4   Contents at a Glance  CHAPTER 1:  Working with Strings  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 375 CHAPTER 2:  Using Arrays  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 393 CHAPTER 3:  Using the ArrayList Class  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 423 CHAPTER 4:  Using the LinkedList Class   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 437 CHAPTER 5:  Creating Generic Collection Classes   .  .  .  .  .  .  .  .  .  .  .  .  . 449 CHAPTER 6:  Using Bulk Data Operations with Collections  .  . . 463   IN THIS CHAPTER  » Quickly reviewing what you already   know about strings   » Examining string class methods   » Working with substrings   » Splitting strings   » Using the StringBuilder and   StringBuffer classes   » Using the CharSequence interface  Chapter 1 Working with Strings  Strings  are  among  the  most  common  types  of  objects  in  Java.  Throughout   this book are various techniques for working with strings. You’ve seen how  to create string variables, how to concatenate strings, and how to compare  strings. But so far, I’ve only scratched the surface of what you can do with strings.  In this chapter, I dive deeper into what Java can do with strings.  I start with a brief review of what I’ve covered so far about strings, so that you  don’t have to go flipping back through the book to find basic information. Then I  look at the String class itself and some of the methods it provides for working with  strings. Finally, I examine two almost identical classes named StringBuilder and  StringBuffer that offer features not available in the basic String class as well as  an interface named CharSequence that is implemented by String, StringBuilder,  and StringBuffer.  CHAPTER 1  Working with Strings      375   Reviewing Strings  To save you the hassle of flipping back through this book, the following para- graphs summarize what I present about strings in earlier chapters:   » Strings are reference types, not value types, such as int or boolean. As a   result, a string variable holds a reference to an object created from the  String class, not the value of the string itself.   » Even though strings aren’t primitive types, the Java compiler has some   features designed to let you work with strings almost as though they were  primitive types. Java lets you assign string literals to string variables, for  example, like this:  String line1 = "Oh what a beautiful morning!";   » Strings can include escape sequences that consist of a slash followed by   another character. The most common escape sequences are \n for new line  and \t for tab. If you want to include a back slash in a string, you must use the  escape sequence \\. Here is a complete list of all the escape sequences you  can use:  Escape Sequence  Explanation  \n  \t  \b  \r  \f  \'  \"  \\  Newline  Tab  Backspace  Carriage return  Form feed  Apostrophe  Quotation mark  Back slash   » Strings and characters are different. String literals are marked by quotation  marks; character literals are marked by apostrophes. Thus, "a" is a string  literal that happens to be one character long. By contrast, 'a' is a character  literal.  376      BOOK 4  Strings, Arrays, and Collections   THE IMMUTABLE PATTERN  Many applications can benefit from classes that describe immutable objects. An immu- table object is an object that, once created, can never be changed. The String class is  the most common example of an immutable object. After you create a String object,  you can’t change it.  Suppose that you’re designing a game in which the playing surface has fixed obstacles,  such as trees. You can create the Tree class by using the Immutable pattern. The con- structor for the Tree class could accept parameters that define the size, type, and loca- tion of the tree. But after you create the tree, you can’t move it.  Follow these three simple rules for creating an immutable object:     Provide one or more constructors that accept parameters to set the initial state of   the object.     Don’t allow any methods to modify any instance variables in the object. Set instance   variables with constructors and then leave them alone.     Any method that modifies the object should do so by creating a new object with the   modified values. Then this method returns the new object as its return value.   » You can combine, or concatenate, strings by using the + operator, like this:  String line2 = line1 + “\nOh what a beautiful day!”;   » You can also use the += operator with strings, like this:  line2 += “\nI’ve got a beautiful feeling”;   » When a primitive type is used in a concatenation expression, Java automati- cally converts the primitive type to a string. Thus Java allows the following:  int empCount = 50; String msg = "Number of employees: " + empCount;   » The various primitive wrapper classes  such as integer and double  have  parse methods that can convert string values to numeric types. Here’s an  example:  String s = "50"; int i = Integer.parseInt s ;     s g n i r t S h t i w g n k r o W  i     CHAPTER 1  Working with Strings      377    » You can’t compare strings by using the equality operator  == . Instead, you   should use the equals method. Here’s an example:  if  lastName.equals "Lowe"       System.out.println "This is me!" ;   » The String class also has an equalsIgnoreCase method that compares   strings without considering case. Here’s an example:  if  lastName.equalsIgnoreCase "lowe"       System.out.println "This is me again!" ;  Using the String Class  The String class is the class you use to create string objects. It has a whole gaggle  of  methods  that  are  designed  to  let  you  find  out  information  about  the  string  that’s represented by the  String class. Table 1-1 lists the most useful of these  methods.  TABLE 1-1	  Method  String Class Methods  Description  char charAt int   int compareTo String   Returns the character at the specified position in the string.  Compares this string to another string, using alphabetical  order. Returns -1 if this string comes before the other string, 0  if the strings are the same, and 1 if this string comes after the  other string.  int compareToIgnoreCase String   Similar to compareTo but ignores case.  boolean contains CharSequence   Returns true if this string contains the parameter value.  The parameter can be a String, StringBuilder, or  StringBuffer.  boolean endsWith String   Returns true if this string ends with the parameter string.  boolean equals String   Returns true if this string has the same value as the  parameter string.  boolean  equalsIgnoreCase String   int indexOf char   Similar to equals but ignores case.  Returns the index of the first occurrence of the char parameter  in this string. Returns -1 if the character isn’t in the string.  378      BOOK 4  Strings, Arrays, and Collections   Method  int indexOf String   Description  Returns the index of the first occurrence of the String  parameter in this string. Returns -1 if the string isn’t in  this string.  int indexOf String, int start   Similar to indexOf, but starts the search at the specified  position in the string.  int lastIndexOf char   int lastIndexOf String   Returns the index of the last occurrence of the char parameter  in this string. Returns -1 if the character isn’t in the string.  Returns the index of the last occurrence of the String  parameter in this string. Returns -1 if the string isn’t in  this string.  int lastIndexOf String, int   Similar to lastIndexOf, but starts the search at the specified  position in the string.  int length    Returns the length of this string.  String replace char, char   String replaceAll String old,  String new   String replaceFirst String  old, String new   String[] split String   Returns a new string that’s based on the original string, but with  every occurrence of the first parameter replaced by the second  parameter.  Returns a new string that’s based on the original string, but  with every occurrence of the first string replaced by the second  parameter. Note that the first parameter can be a regular  expression.  Returns a new string that’s based on the original string, but with  the first occurrence of the first string replaced by the second  parameter. Note that the first parameter can be a regular  expression.  Splits the string into an array of strings, using the string  parameter as a pattern to determine where to split the strings.  boolean startsWith String   Returns true if this string starts with the parameter string.  boolean startsWith String, int   Returns true if this string contains the parameter string at the  position indicated by the int parameter.  String substring int   String substring int, int   char[] toCharArray    String toLowerCase    Extracts a substring from this string, beginning at the position  indicated by the int parameter and continuing to the end of  the string.  Extracts a substring from this string, beginning at the position  indicated by the first parameter and ending at the position one  character before the value of the second parameter.  Converts the string to an array of individual characters.  Converts the string to lowercase.     s g n i r t S h t i w g n k r o W  i      continued   CHAPTER 1  Working with Strings      379   TABLE 1-1	 continued   Method  String toString    Description  Returns the string as a String  pretty pointless, if you ask me,  but all classes must have a toString method .  String toUpperCase    Converts the string to uppercase.  String trim    Returns a copy of the string with all leading and trailing white  spaces removed.  String valueOf primitiveType   Returns a string representation of any primitive type.  The  most  important  thing  to  remember  about  the  String  class  is  that  in  spite  of the fact that it has a bazillion methods, none of those methods let you alter  the string in any way. A String object is immutable, which means that it can’t be  changed.  Although you can’t change a string after you create it, you can use methods of the  String class to create new strings that are variations of the original string. The  following sections describe some of the more interesting things you can do with  these methods.  Finding the length of a string  One of the most basic string operations is determining the length of a string. You  do that with the length method. For example:  String s = "A wonderful day for a neighbor."; int len = s.length  ;  Here len is assigned a value of 31 because the string s consists of 30 characters.  Getting the length of a string usually isn’t very useful by itself, but the length  method often plays an important role in other string manipulations, as you see  throughout the following sections.  Making simple string modifications  Several of the methods of the String class return modified versions of the original  string. toLowerCase, for example, converts a string to all-lowercase letters:  String s1 = "Oompa Loompa"; String s2 = s1.toLowerCase  ;  380      BOOK 4  Strings, Arrays, and Collections   Here s2 is set to the string oompa  loompa. The toUpperCase method works the  same way but converts strings to all-uppercase letters.  The trim method removes white-space characters  spaces, tabs, newlines, and so  on  from the start and end of a word. Here’s an example:  String s = "   Oompa Loompa  "; s = s.trim  ;  Here the spaces before and after Oompa Loompa are removed. Thus, the resulting  string is ten characters long.  Bear in mind that because strings are immutable, these methods don’t actually  change the String object. Instead, they create a new String with the modified  value. A common mistake — especially for programmers who are new to Java but  experienced in other languages — is to forget to assign the return value from one  of these methods. The following statement has no effect on s:  Here  the  trim  method  trims  the  string  —  but  then  the  program  discards  the  result. The remedy is to assign the result of this expression back to s, like this:  s.trim  ;  s = s.trim  ;  Extracting characters from a string  You can use the charAt method to extract a character from a specific position in a  string. When you do, keep in mind that the index number for the  first character in  a string is 0, not 1. Also, you should check the length of the string before extract- ing a character. If you specify an index value that’s beyond the end of the string,  the exception  StringIndexOutOfBoundsException is thrown.  Fortunately, this  is an unchecked exception, so you don’t have to enclose the charAt method in a  try catch statement.   Here’s an example of a program that uses the charAt method to count the number  of vowels in a string entered by the user:  import java.util.Scanner;  public class CountVowels {     static Scanner sc = new Scanner System.in ;     s g n i r t S h t i w g n k r o W  i     CHAPTER 1  Working with Strings      381       public static void main String[] args      {         System.out.print "Enter a string: " ;         String s = sc.nextLine  ;          int vowelCount = 0;          for  int i = 0; i < s.length  ; i++          {             char c = s.charAt i ;             if       c == 'A'    c == 'a'                     c == 'E'    c == 'e'                     c == 'I'    c == 'i'                     c == 'O'    c == 'o'                     c == 'U'    c == 'u'                    vowelCount++;         }         System.out.println "That string contains "             + vowelCount + " vowels." ;     } }  Here  the  for  loop  checks  the  length  of  the  string  to  make  sure  that  the  index  variable i doesn’t exceed the string length. Then each character is extracted and  checked with an if statement to see whether it is a vowel. The condition expres- sion in this if statement is a little complicated because it must check for five dif- ferent vowels, both uppercase and lowercase.  Following  is  an  example  that  shows  the  output  created  by  this  program  if  you  enter a string listing all of the letters of the alphabet:  Enter a string: abcdefghijklmnopqrstuvwxyz That string contains 5 vowels.  Extracting substrings from a string  The  substring  method  lets  you  extract  a  portion  of  a  string.  This  method  has  two  forms.  The  first  version  accepts  a  single  integer  parameter.  It  returns  the  substring that starts at the position indicated by this parameter and extends to  the rest of the string.  Remember that string positions start with 0, not 1.  Here’s  an example:  String s = "Baseball"; String b = s.substring 4 ;         "ball"  382      BOOK 4  Strings, Arrays, and Collections   Here b is assigned the string ball.  The second version of the substring method accepts two parameters to indicate  the start and end of the substring you want to extract. Note that the substring  actually  ends  at  the  character  that’s  immediately  before  the  position  indicated  by the second parameter. So, to extract the characters at positions 2 through 5,  specify 1 as the start position and 6 as the ending position. For example:  String s = "Baseball"; String b = s.substring 2, 6 ;       "seba"  Here b is assigned the string seba.  The following program uses substrings to replace all the vowels in a string entered  by the user with asterisks:  import java.util.Scanner;  public class MarkVowels {     static Scanner sc = new Scanner System.in ;      public static void main String[] args      {         System.out.print "Enter a string: " ;         String s = sc.nextLine  ;         String originalString = s;          int vowelCount = 0;          for  int i = 0; i < s.length  ; i++          {             char c = s.charAt i ;             if       c == 'A'    c == 'a'                     c == 'E'    c == 'e'                     c == 'I'    c == 'i'                     c == 'O'    c == 'o'                     c == 'U'    c == 'u'                {                 String front = s.substring 0, i ;                 String back = s.substring i+1 ;                 s = front + "*" + back;             }         }     s g n i r t S h t i w g n k r o W  i     CHAPTER 1  Working with Strings      383           System.out.println  ;         System.out.println originalString ;         System.out.println s ;     } }  This program uses a for loop and the charAt method to extract each character  from the string. Then, if the character is a vowel, a string named front is created  that consists of all the characters that appear before the vowel. Next, a second  string named back is created with all the characters that appear after the vowel.  Finally, the s string is replaced by a new string that’s constructed from the front  string, an asterisk, and the back string.  Here’s some sample console output from this program so that you can see how it  works:  Enter a string: Where have all the vowels gone?  Where have all the vowels gone? Wh*r* h*v* *ll th* v*w*ls g*n*?  Splitting a string  The split command is especially useful for splitting a string into separate strings  based on a delimiter character. Suppose you have a string with the parts of an  address separated by colons, like this:  1500 N. Third Street:Fresno:CA:93722  With the split method, you can easily separate this string into four strings. In the  process, the colons are discarded.  Unfortunately, the use of the split method requires that you use an array, and  arrays are covered in the next chapter. I’m going to plow ahead with this section  anyway on a hunch that you already know a few basic things about arrays.  If not,  you can always come back to this section after you read the next chapter.   The split method carves a string into an array of strings separated by the delim- iter character passed via a string parameter. Here’s a routine that splits an address  into separate strings and then prints out all the strings:  String address =     "1500 N. Third Street:Fresno:CA:93722";  String[] parts = address.split ":" ;  384      BOOK 4  Strings, Arrays, and Collections   for  int i = 0; i < parts.length; i++      System.out.println parts[i] ;  If you run this code, the following lines are displayed on the console:  1500 N. Third Street Fresno CA 93722  The string passed to the split method is actually a special type of string used for  pattern recognition, called a regular expression. You discover regular expressions  in Book 5. For now, here are a few regular expressions that might be useful when  you use the split method:  Regular Expression  Explanation  \\t  \\n  \\  \\s  \\s+  A tab character  A newline character  A vertical bar  Any white-space character  One or more occurrences of any white-space character  The last regular expression in this table, \\s+, is especially useful for breaking a  string into separate words. The following program accepts a string from the user,  breaks it into separate words, and then displays the words on separate lines:  import java.util.Scanner;  public class ListWords {     static Scanner sc = new Scanner System.in ;      public static void main String[] args      {         System.out.print "Enter a string: " ;         String s = sc.nextLine  ;         String[] word = s.split "\\s+" ;         for  String w : word              System.out.println w ;     } }     s g n i r t S h t i w g n k r o W  i     CHAPTER 1  Working with Strings      385   Here’s a sample of the console output for a typical execution of this program:  Enter a string: This string   has   several    words This string has several words  Notice that some of the words in the string entered by the user are preceded by  more than one space character. The \\s+ pattern used by the split method treats  any  consecutive  white-space  character  as  a  single  delimiter  when  splitting  the  words.  Replacing parts of a string  You can use the replaceFirst or replaceAll method to replace a part of a string  that matches a pattern you supply with some other text. Here’s the main method  of a program that gets a line of text from the user and then replaces all occur- rences of the string cat with dog:      public static void main String[] args      {         Scanner sc = new Scanner System.in ;         System.out.print "Enter a string: " ;         String s = sc.nextLine  ;          s = s.replaceAll "cat", "dog" ;          System.out.println s ;     }  And here’s the console for a typical execution of this program:  Enter a string: I love cats. I love dogs.  As  with  the  split  methods,  the  first  parameter  of  replace  methods  can  be  a  regular expression that provides a complex matching string.  For more informa- tion, see Book 5, Chapter 3.   386      BOOK 4  Strings, Arrays, and Collections   Once  again,  don’t  forget  that  strings  are  immutable.  As  a  result,  the  replace  methods don’t actually modify the String object itself. Instead, they return a new  String object with the modified value.  Using the StringBuilder and   StringBuffer Classes  The String class is powerful, but it’s not very efficient for programs that require  heavy-duty  string  manipulation.  Because  String  objects  are  immutable,  any  method of the String class that modifies the string in any way must create a new  String object and copy the modified contents of the original string object to the  new string. That’s not so bad if it happens only occasionally, but it can be inef- ficient in programs that do it a lot.  Even string concatenation is inherently inefficient. Consider these statements:  int count = 5; String msg = "There are "; String msg += count; String msg += " apples in the basket.";  These four statements actually create five String objects:   » "There are ": Created for the literal in the second statement. The msg   variable is assigned a reference to this string.   » "5": Created to hold the result of count.toString  . The toString method  is implicitly called by the third statement, so count is concatenated with msg.  » "There are 5": Created as a result of the concatenation in the third state-  ment. A reference to this object is assigned to msg.   » "apples in the basket.": Created to hold the literal in the fourth   statement.   » "There are 5 apples in the basket.": Created to hold the result of the  concatenation in the fourth statement. A reference to this object is assigned  to msg.     s g n i r t S h t i w g n k r o W  i     For  programs  that  do  only  occasional  string  concatenation  and  simple  string  manipulations,  these  inefficiencies  aren’t  a  big  deal.  For  programs  that  do   CHAPTER 1  Working with Strings      387   extensive string manipulation, however, Java offers two alternatives to the String  class: the StringBuilder and StringBuffer classes.  The StringBuilder and StringBuffer classes are mirror images. Both have the  same methods and perform the same string manipulations. The only difference  is that whereas the StringBuffer class is safe to use in applications that work  with multiple threads, StringBuilder is not safe for threaded applications but is  more efficient than StringBuffer. As a result, you should use the StringBuilder  class unless your application uses threads.  Find out how to work with threads in  Book 5, Chapter 1.   Note: The StringBuilder class was introduced in Java version 1.5. If you’re using  an older Java compiler, you have to use StringBuffer instead.  Creating a StringBuilder object  You  can’t  assign  string  literals  directly  to  a  StringBuilder  object,  as  you  can  with a String object. The StringBuilder class, however, has a constructor that  accepts a String as a parameter. So to create a StringBuilder object, you use a  statement such as this:  StringBuilder sb = new StringBuilder "Today is the day!" ;  Internally,  a  StringBuilder  object  maintains  a  fixed  area  of  memory  where  it  stores a string value. This area of memory is called the buffer. The string held in  this  buffer  doesn’t  have  to  use  the  entire  buffer.  As  a  result,  a  StringBuilder  object has both a length and a capacity. The length represents the current length of  the string maintained by the StringBuilder, and the capacity represents the size  of the buffer itself. Note that the length can’t exceed the capacity.  When you create a StringBuilder object, initially the capacity is set to the length  of the string plus 16. The StringBuilder class automatically increases its capac- ity whenever necessary, so you don’t have to worry about exceeding the capacity.  Using StringBuilder methods  Table  1-2  lists  the  most  useful  methods  of  the  StringBuilder  class.  Note  that  the StringBuffer class uses the same methods. If you have to use StringBuffer  instead of StringBuilder, just change the class name and use the same methods.  388      BOOK 4  Strings, Arrays, and Collections   TABLE		1-2	  Method  StringBuilder Methods  Description  append primitiveType   Appends the string representation of the primitive type to the end of  the string.  append Object   Calls the object’s toString method and appends the result to the end  of the string.  append CharSequence   Appends the string to the end of the StringBuilder’s string value. The  parameter can be a String, StringBuilder, or StringBuffer.  char charAt int   delete int, int   Returns the character at the specified position in the string.  Deletes characters starting with the first int and ending with the  character before the second int.  deleteCharAt int   Deletes the character at the specified position.  ensureCapacity int   Ensures that the capacity of String-Builder is at least equal to the  int value; increases the capacity if necessary.  int capacity    Returns the capacity of this StringBuilder.  int indexOf String   Returns the index of the first occurrence of the specified string. If the  string doesn’t appear, returns -1.  int indexOf String, int   insert int,  primitiveType   insert int, Object   Returns the index of the first occurrence of the specified string, starting  the search at the specified index position. If the string doesn’t appear,  returns -1.  Inserts the string representation of the primitive type at the point  specified by the int argument.  Calls the toString method of the Object parameter and then inserts  the resulting string at the point specified by the int argument.  insert int, CharSequence   Inserts the string at the point specified by the int argument. The second  parameter can be a String, StringBuilder, or StringBuffer.  int lastIndexOf String   Returns the index of the last occurrence of the specified string. If the  string doesn’t appear, returns -1.  int  lastIndexOf String, int   Returns the index of the last occurrence of the specified string, starting  the search at the specified index position. If the string doesn’t appear,  returns -1.  int length    Returns the length of this string.  replace int, int, String   Replaces the substring indicated by the first two parameters with the  string provided by the third parameter.  reverse    Reverses the order of characters.     s g n i r t S h t i w g n k r o W  i      continued   CHAPTER 1  Working with Strings      389   TABLE		1-2	 continued   Method  Description  setCharAt int, char   Sets the character at the specified position to the specified character.  setLength int   Sets the length of the string. If that length is less than the current  length, the string is truncated; if it’s greater than the current length, new  characters — hexadecimal zeros — are added.  String substring int   Extracts a substring, beginning at the position indicated by the int  parameter and continuing to the end of the string.  String  substring int, int   Extracts a substring, beginning at the position indicated by the first  parameter and ending at the position one character before the value of  the second parameter.  String toString    Returns the current value as a String.  String trimToSize    Reduces the capacity of the StringBuffer to match the size of  the string.  Viewing a StringBuilder example  To illustrate how the StringBuilder class works, here’s a StringBuilder version  of the MarkVowels program from earlier in this chapter:  import java.util.Scanner;  public class StringBuilderApp {     static Scanner sc = new Scanner System.in ;      public static void main String[] args      {         System.out.print "Enter a string: " ;          String s = sc.nextLine  ;         StringBuilder sb = new StringBuilder s ;          int vowelCount = 0;          for  int i = 0; i < s.length  ; i++          {             char c = s.charAt i ;             if       c == 'A'    c == 'a'                     c == 'E'    c == 'e'                     c == 'I'    c == 'i'   390      BOOK 4  Strings, Arrays, and Collections                      c == 'O'    c == 'o'                     c == 'U'    c == 'u'                {                 sb.setCharAt i, '*' ; }         }         System.out.println  ;         System.out.println s ;         System.out.println sb.toString   ;     } }  This program uses the setCharAt method to directly replace any vowels it finds  with asterisks. That’s much more efficient than concatenating substrings  which  is the way the String version of this program worked .  Using the CharSequence Interface  The  Java  API  includes  a  useful  interface  called  CharSequence.  All  three  of  the  classes  discussed  in  this  chapter  —  String,  StringBuilder,  and  String  Buffer — implement this interface. This method exists primarily to let you use  String, StringBuilder, and StringBuffer interchangeably.  Toward  that  end,  several  of  the  methods  of  the  String,  StringBuilder,  and  StringBuffer  classes  use  CharSequence  as  a  parameter  type.  For  those  meth- ods, you can pass a String, StringBuilder, or StringBuffer object. Note that a  string literal is treated as a String object, so you can use a string literal anywhere  a CharSequence is called for.  In case you’re interested, the CharSequence interface defines four methods:   » char charAt int : Returns the character at the specified position.  » int length  : Returns the length of the sequence.  » subSequence int start, int end : Returns the substring indicated by the   start and end parameters.   » toString  : Returns a String representation of the sequence.     s g n i r t S h t i w g n k r o W  i     If you’re inclined to use CharSequence as a parameter type for a method so that  the  method  works  with  a  String,  StringBuilder,  or  StringBuffer  object,  be  advised that you can use only these four methods.  CHAPTER 1  Working with Strings      391    IN THIS CHAPTER  » Working with basic one-dimensional   arrays   » Using array initializers to set the   initial values of an array   » Using for loops with arrays   » Working with two-dimensional arrays   » Working with the Arrays class  Chapter 2 Using Arrays  I      could use a raise. . . .  Oh, arrays. Sorry.  Understanding Arrays  Arrays are an important aspect of any programming language, and Java is no excep- tion. In this chapter, you discover just about everything you need to know about  using arrays. I cover run-of-the-mill one-dimensional arrays; multidimensional  arrays; and two classes that are used to work with arrays, named Array and Arrays.  An array is a set of variables that is referenced by using a single variable name  combined with an index number. Each item of an array is called an element. All  the elements in an array must be of the same type. Thus the array itself has a type  that specifies what kind of elements it can contain. An int array can contain int  values, for example, and a String array can contain strings.  The index number is written after the variable name and enclosed in brackets. So  if the variable name is x, you could access a specific element with an expression  like x[5].  CHAPTER 2  Using Arrays      393   You might think that x[5] would refer to the fifth element in the array. But index  numbers start with zero for the first element, so x[5] actually refers to the sixth  element. This little detail is one of the chief causes of problems when working  with arrays — especially if you cut your array-programming teeth in a language  in which arrays are indexed from one instead of from zero. So, in Java, get used to  counting from zero instead of from one.  The real power of arrays comes from the simple fact that you can use a variable or  even a complete expression as an array index. So  for example  instead of coding  x[5]to refer to a specific array element, you can code x[i]to refer to the element  indicated by the index variable i. You see plenty of examples of index variables  throughout this chapter.  Here are a few additional tidbits of array information to ponder before you get into  the details of creating and using arrays:   » An array is itself an object. You can refer to the array object as a whole, rather   than to a specific element of the array, by using the array’s variable name without  an index. Thus, if x[5]refers to an element of an array, x refers to the array itself.   » An array has a fixed length that’s set when the array is created. This length   determines the number of elements that can be stored in the array. The maxi- mum index value you can use with any array is one less than the array’s length.  Thus, if you create an array of ten elements, you can use index values from 0 to 9.   » You can’t change the length of an array after you create the array.  » You can access the length of an array by using the length field of the array   variable. x.length, for example, returns the length of the array x.  Creating Arrays  Before you can create an array, you must declare a variable that refers to the array.  This variable declaration should indicate the type of elements that are stored by the  array followed by a set of empty brackets, like this:  String[] names;  Here a variable named names is declared. Its type is an array of String objects.  Just  to  make  sure  that  you’re  confused  as  much  as  possible,  Java  also  lets  you  put the brackets on the variable name rather than on the type. The following two  statements both create arrays of int elements:  394      BOOK 4  Strings, Arrays, and Collections   int[] array1;      an array of int elements int array2[];      another array of int elements  Both of these statements have exactly the same effect. Most Java programmers  prefer to put the brackets on the type rather than on the variable name.  By itself, that statement doesn’t create an array; it merely declares a variable that  can refer to an array. You can actually create the array in two ways:   » Use the new keyword followed by the array type, this time with the brackets   filled in to indicate how many elements the array can hold. For example:  s y a r r A g n i s U     String[] names; names = new String[10];  Here, an array of String objects that can hold ten strings is created. Each of  the strings in this array is initialized to an empty string.   » As with any other variable, you can combine the declaration and the creation   into one statement:  String[] names = new String[10];  Here the array variable is declared and an array is created in one statement.  If  you  don’t  know  how  many  elements  the  array  needs  at  compile  time,  you  can use a variable or an expression for the array length. Here’s a routine from a  method that stores player names in an array of strings. It starts by asking the user  how many players are on the team. Then it creates an array of the correct size:  System.out.print "How many players? " ; int count = sc.nextInt  ;             sc is a Scanner String[] players = new String[count];  Initializing an Array  One way to initialize the values in an array is to simply assign them one by one:  String[] days = new Array[7]; Days[0] = "Sunday"; Days[1] = "Monday"; Days[2] = "Tuesday"; Days[3] = "Wednesday"; Days[4] = "Thursday";  CHAPTER 2  Using Arrays      395   Days[5] = "Friday"; Days[6] = "Saturday";  Java has a shorthand way to create an array and initialize it with constant values:  String[] days = { "Sunday", "Monday", "Tuesday",                   "Wednesday", "Thursday",                   "Friday", "Saturday" };  Here each element to be assigned to the array is listed in an array initializer. Here’s  an example of an array initializer for an int array:  int[] primes = { 2, 3, 5, 7, 11, 13, 17 };  Note: The length of an array created with an initializer is determined by the num- ber of values listed in the initializer.  An alternative way to code an initializer is this:  int[] primes = new int[] { 2, 3, 5, 7, 11, 13, 17 };  To use this type of initializer, you use the new keyword followed by the array type  and a set of empty brackets. Then you code the initializer.  One of the most common ways to process an array is with a for loop. In fact, for  loops were invented specifically to deal with arrays. Here’s a for loop that creates  an array of 100 random numbers, with values ranging from 1 to 100:  int[] numbers = new int[100]; for  int i = 0; i < 100; i++      numbers[i] =  int  Math.random   * 100  + 1;  And here’s a loop that fills an array of player names with strings entered by the  user:  String[] players = new String[count]; for  int i = 0; i < count; i++  {     System.out.print "Enter player name: " ;     players[i] = sc.nextLine  ;        sc is a Scanner }  Using for Loops with Arrays  396      BOOK 4  Strings, Arrays, and Collections   For this example, assume that count is an int variable that holds the number of  players to enter.  You can also use a for loop to print the contents of an array. For example:  for  int i = 0; i < count; i++      System.out.println players[i] ;  Here the elements of a String array named players are printed to the console.  The previous example assumes that the length of the array was stored in a vari- able before the loop was executed. If you don’t have the array length handy, you  can get it from the array’s length property:  for  int i = 0; i < players.length; i++      System.out.println players[i] ;  s y a r r A g n i s U     Solving Homework Problems with Arrays  Every once in a while, an array and a  for loop or two can help you solve your  kids’  homework  problems  for  them.  I  once  helped  my  daughter  solve  a  tough  homework assignment for a seventh-grade math class. The problem was stated  something like this:  Bobo  these problems always had a character named Bobo in them  visits the local  high school on a Saturday and finds that all the school’s 1,000 lockers are neatly  closed. So he starts at one end of the school and opens them all. Then he goes  back to the start and closes every other locker  lockers 2, 4, 6, and so on . Then he  goes back to the start and hits every third locker: If it’s open, he closes it; if it’s  closed, he opens it. Then he hits every fourth locker, every fifth locker, and so on.  He keeps doing this all weekend long, walking the hallways opening and closing  lockers 1,000 times. Then he gets bored and goes home. How many of the school’s  1,000 lockers are left open, and which ones are they?  Sheesh!  This problem presented a challenge, and being the computer-nerd father I am, I  figured that this was the time to teach my daughter about for loops and arrays. So  I wrote a little program that set up an array of 1,000 booleans. Each represented  a locker: true meant open, and false meant closed. Then I wrote a pair of nested  for loops to do the calculation.  CHAPTER 2  Using Arrays      397   My first attempt told me that 10,000 of the 1,000 lockers were opened, so I figured  that I’d made a mistake somewhere. And while I was looking at the code, I real- ized that the lockers were numbered 1 to 1,000, but the elements in my array were  numbered 0 to 999, and that was part of what led to the confusion that caused my  first answer to be ridiculous.  So I decided to create the array with 1,001 elements and ignore the first one. That  way, the indexes corresponded nicely to the locker numbers.  After a few hours of work, I came up with the program in Listing 2-1.  LISTING 2-1:   The Classic Locker Problem Solved  public clas s BoboAndTheLockers {    public static void main String[] args     {          true = open; false = closed       boolean[] lockers = new boolean[1001];           close all the lockers      for  int i = 1; i <= 1000; i++            lockers[i] = false;       for  int skip = 1; skip <= 1000; skip++         {          System.out.println "Bobo is changing every "              + skip + " lockers." ;          for  int locker = skip; locker < 1000;                   locker += skip               lockers[locker] = !lockers[locker];        }       System.out.println "Bobo is bored"          + " now so he's going home." ;          count and list the open lockers       String list = "";       int openCount = 0;       for  int i = 1; i <= 1000; i++            if  lockers[i]           {              openCount++;              list += i + " ";          }       System.out.println "Bobo left " + openCount          + " lockers open." ;  →6  →9  →12  →16  →18  →27  398      BOOK 4  Strings, Arrays, and Collections   s y a r r A g n i s U           System.out.println "The open lockers are: "          + list ;    } }  Here are the highlights of how this program works: →6         This line sets up an array of booleans with 1,001 elements. I created one   more element than I needed so I could ignore element 0.   →9        This for loop closes all the lockers. This step isn’t really necessary   because booleans initialize to false, but being explicit about initializa- tion is good.   →12      Every iteration of this loop represents one complete trip through the   hallways opening and closing lockers. The skip variable represents how  many lockers Bobo skips on each trip. First he does every locker, then  every second locker, and then every third locker. So this loop simply  counts from 1 to 1,000.   →16      Every iteration of this loop represents one stop at a locker on a trip   through the hallways. This third expression in the for statement  on the  next line  adds the skip variable to the index variable so that Bobo can  access every nth locker on each trip through the hallways.   →18      This statement uses the not operator  !  to reverse the setting of each  locker. Thus, if the locker is open  true , it’s set to closed  false , and  vice versa.   →27      Yet another for loop spins through all the lockers and counts the ones  that are open. It also adds the locker number for each open locker to the  end of a string so that all the open lockers can be printed.  This program produces more than 1,000 lines of output, but only the last few lines  are important. Here they are:  Bobo is bored now so he's going home. Bobo left 31 lockers open. The open lockers are: 1 4 9 16 25 36 49 64 81 100 121 144 169  196 225 256 289 324 361 400 441 484 529 576 625 676 729 784  841 900 961  So there’s the answer: 31 lockers are left open. I got an A.  I mean, my daughter  got an A.   CHAPTER 2  Using Arrays      399   By the way, did you notice that the lockers that were left open were the ones whose  numbers are perfect squares? Or that 31 is the largest number whose square is less  than 1,000? I didn’t, either — until my daughter told me after school the next day.  Using the Enhanced for Loop  Java  1.5  introduced  a  new  type  of  for  loop  called  an  enhanced  for  loop  that’s  designed to simplify loops that process arrays and collections  which I cover in  the next chapter . When it’s used with an array, the enhanced for loop has this  format:  for  type identifier : array  { Statements ... }  The type identifies the type of the elements in the array, and the identifier pro- vides a name for a local variable that is used to access each element. array names  the array you want to process.  Here’s an example:  String[] days = { "Sunday", "Monday", "Tuesday",                   "Wednesday", "Thursday",                   "Friday", "Saturday" }; for  String day : days  {     System.out.println day ; }  This loop prints the following lines to the console:  Sunday Monday Tuesday Wednesday Thursday Friday Saturday  In other words, it prints each of the strings in the array on a separate line.  400      BOOK 4  Strings, Arrays, and Collections   Using Arrays with Methods  You  can  write  methods  that  accept  arrays  as  parameters  and  return  arrays  as  return values. You just use an empty set of brackets to indicate that the parameter  type or return type is an array.  Here’s a static method that creates and returns a String array with the names of  the days of the week:  s y a r r A g n i s U     public static String[] getDaysOfWeek   {     String[] days = { "Sunday", "Monday", "Tuesday",                       "Wednesday", "Thursday",                       "Friday", "Saturday" };     return days; }  And here’s a static method that prints the contents of any  String array to the  console, one string per line:  public static void printStringArray String[] strings  {     for  String s : strings          System.out.println s ; }  Finally, here are two lines of code that call these methods:  String[] days = getDaysOfWeek  ; printStringArray days ;  The first statement declares a String array and then calls getDaysOfWeek to cre- ate the array. The second statement passes the array to the printString Array  method as a parameter.  Using Two-Dimensional Arrays  The elements of an array can be any type of object you want, including another  array. In the latter case, you have a two-dimensional array, sometimes called an  array of arrays.  CHAPTER 2  Using Arrays      401   Two-dimensional  arrays  are  often  used  to  track  data  in  column-and-row  for- mat, much the way that a spreadsheet works. Suppose that you’re working on a  program that tracks five years’ worth of sales  2004 through 2008  for a com- pany, with the data broken down for each of four sales territories  North, South,  East, and West . You could create 20 separate variables, with names such as sale- s2001North,  sales2001South,  sales2001East,  and  so  on.  But  that  gets  a  little  tedious.  Alternatively, you could create an array with 20 elements, like this:  double[] sales = new sales[20];  But then how would you organize the data in this array so that you know the year  and sales region for each element?  With a two-dimensional array, you can create an array with an element for each  year. Each of those elements in turn is another array with an element for each  region.  Thinking of a two-dimensional array as a table or spreadsheet is common, like this:  Year  2004  2005  2006  2007  2008  North  23,853  25,483  24,872  28,492  31,932  South  22,838  22,943  23,049  23,784  23,732  East  36,483  38,274  39,002  42,374  42,943  West  31,352  33,294  36,888  39,573  41,734  Here  each  row  of  the  spreadsheet  represents  a  year  of  sales,  and  each  column  represents one of the four sales regions.  Creating a two-dimensional array  To declare a two-dimensional array for this sales data, you simply list two sets of  empty brackets, like this:  double sales[][];  Here  sales  is  a  two-dimensional  array  of  type  double.  To  put  it  another  way,  sales is an array of double arrays.  402      BOOK 4  Strings, Arrays, and Collections   To create the array, you use the new keyword and provide lengths for each set of  brackets, as in this example:  sales = new double[5][4];  Here the first dimension specifies that the  sales array has five elements. This  array represents the rows in the table. The second dimension specifies that each  of those elements has an array of type double with four elements. This array rep- resents the columns in the table.  A key point to grasp here is that one instance is of the first array, but a separate  instance of the second array for each element is in the first array. So this state- ment actually creates five double arrays with four elements each. Then those five  arrays are used as the elements for the first array.  Note  that  as  with  a  one-dimensional  array,  you  can  declare  and  create  a  two- dimensional array in one statement, like this:  s y a r r A g n i s U     double[][] sales = new double[5][4];  Here the sales array is declared and created all in one statement.  Accessing two-dimensional array elements  To  access  the  elements  of  a  two-dimensional  array,  you  use  two  indexes.  This  statement sets the 2004 sales for the North region:  sales[0][0] = 23853.0;  As you might imagine, accessing the data in a two-dimensional array by hard- coding each index value can get tedious. No wonder for loops are normally used  instead. The following bit of code uses a for loop to print the contents of the sales  array to the console, separated by tabs. Each year is printed on a separate line,  with the year at the beginning of the line. In addition, a line of headings for the  sales regions is printed before the sales data. Here’s the code:  NumberFormat cf = NumberFormat.getCurrencyInstance  ; System.out.println "\tNorth\t\tSouth\t\tEast\t\tWest" ; int year = 2004; for  int y = 0; y < 5; y++  {     System.out.print year + "\t" ;     for  int region = 0; region < 4; region++   CHAPTER 2  Using Arrays      403       {         System.out.print cf.format sales[y][region]  ;         System.out.print "\t" ;     }     year++;     System.out.println  ; }  Assuming that the sales array has already been initialized, this code produces the  following output on the console:          North           South           East            West 2004    $23,853.00      $22,838.00      $36,483.00      $31,352.00 2005    $25,483.00      $22,943.00      $38,274.00      $33,294.00 2006    $24,872.00      $23,049.00      $39,002.00      $36,888.00 2007    $28,492.00      $23,784.00      $42,374.00      $39,573.00 2008    $31,932.00      $23,732.00      $42,943.00      $41,734.00  The  order  in  which  you  nest  the  for  loops  that  access  each  index  in  a  two- dimensional array is crucial! The preceding example lists the sales for each year  on a separate line, with the sales regions arranged in columns. You can print a  listing with the sales for each region on a separate line, with the years arranged  in columns, by reversing the order in which the for loops that index the arrays  are nested:  for  int region = 0; region < 4; region++  {     for  int y = 0; y < 5; y++      {         System.out.print cf.format sales[y][region]  ;         System.out.print "   " ;     }     System.out.println  ; }  Here the outer loop indexes the region and the inner loop indexes the year:  $23,853.00   $25,483.00   $24,872.00   $28,492.00   $31,932.00 $22,838.00   $22,943.00   $23,049.00   $23,784.00   $23,732.00 $36,483.00   $38,274.00   $39,002.00   $42,374.00   $42,943.00 $31,352.00   $33,294.00   $36,888.00   $39,573.00   $41,734.00  404      BOOK 4  Strings, Arrays, and Collections   Initializing a two-dimensional array  The technique for initializing arrays by coding the array element values in curly  braces  works  for  two-dimensional  arrays  too.  You  just  have  to  remember  that  each element of the main array is actually another array. So you have to nest the  array initializers.  s y a r r A g n i s U     Here’s an example that initializes the sales array:  double[][] sales =     { {23853.0, 22838.0, 36483.0, 31352.0},       2004       {25483.0, 22943.0, 38274.0, 33294.0},       2005       {24872.0, 23049.0, 39002.0, 36888.0},       2006       {28492.0, 23784.0, 42374.0, 39573.0},       2007       {31932.0, 23732.0, 42943.0, 41734.0} };     2008  Here I added a comment to the end of each line to show the year that the line  initializes. Notice that the left brace for the entire initializer is at the beginning of  the second line, and the right brace that closes the entire initializer is at the end of  the last line. Then the initializer for each year is contained in its own set of braces.  Using jagged arrays  When  you  create  an  array  with  an  expression  such  as  new  int[5][3],  you’re  specifying that each element of the main array is actually an array of type int with  three elements. Java, however, lets you create two-dimensional arrays in which  the length of each element of the main array is different. This is sometimes called  a jagged array because the array doesn’t form a nice rectangle. Instead, its edges  are jagged.  Suppose that you need to keep track of four teams, each consisting of two or three  people. The teams are as follows:  Team  Members  A  B  C  D  Henry Blake, Johnny Mulcahy  Benjamin Pierce, John McIntyre, Jonathan Tuttle  Margaret Houlihan, Frank Burns  Max Klinger, Radar O’Reilly, Igor Straminsky  CHAPTER 2  Using Arrays      405   The following code creates a jagged array for these teams:  String[][] teams     = { {"Henry Blake", "Johnny Mulcahy"},         {"Benjamin Pierce", "John McIntyre",              "Jonathan Tuttle"},         {"Margaret Houlihan", "Frank Burns"},         {"Max Klinger", "Radar O'Reilly",              "Igor Straminsky"} };  Here each nested array initializer indicates the number of strings for each subar- ray. The first subarray has two strings, the second has three strings, and so on.  You can use nested for loops to access the individual elements in a jagged array.  For each element of the main array, you can use the length property to determine  how many entries are in that element’s subarray. For example:  for  int i = 0; i < teams.length; i++  {     for  int j = 0; j < teams[i].length; j++          System.out.println teams[i][j] ;     System.out.println  ; }  Notice  that  the  length  of  each  subarray  is  determined  with  the  expression  teams[i].length. This for loop prints one name on each line, with a blank line  between teams, like this:  Margaret Houlihan Frank Burns  Max Klinger Radar O'Reilly Igor Straminsky  Henry Blake Johnny Mulcahy  Benjamin Pierce John McIntyre Jonathan Tuttle  If you don’t want to fuss with keeping track of the indexes yourself, you can use  an enhanced for loop and let Java take care of the indexes. For example:  406      BOOK 4  Strings, Arrays, and Collections   s y a r r A g n i s U     for  String[] team : teams  {     for  String player : team          System.out.println player ;     System.out.println  ; }  Here the first enhanced for statement specifies that the type for the team variable  is String[]. As a result, each cycle of this loop sets team to one of the subarrays in  the main teams array. Then the second enhanced for loop accesses the individual  strings in each subarray.  Going beyond two dimensions  Java  doesn’t  limit  you  to  two-dimensional  arrays.  Arrays  can  be  nested  within  arrays, to as many levels as your program needs. To declare an array with more  than two dimensions, you just specify as many sets of empty brackets as you need.  For example:  int[][][] threeD = new int[3][3][3];  Here a three-dimensional array is created, with each dimension having three ele- ments. You can think of this array as a cube. Each element requires three indexes  to access.  You  can  access  an  element  in  a  multidimensional  array  by  specifying  as  many  indexes as the array needs. For example:  threeD[0][1][2] = 100;  This statement sets element 2 in column 1 of row 0 to 100.  You can nest initializers as deep as necessary, too. For example:  int[][][] threeD =     {  { {1,   2,  3}, { 4,  5,  6}, { 7,  8,  9} },        { {10, 11, 12}, {13, 14, 15}, {16, 17, 18} },        { {19, 20, 21}, {22, 23, 24}, {25, 26, 27} } };  Here a three-dimensional array is initialized with the numbers 1 through 27.  CHAPTER 2  Using Arrays      407   You can also use multiple nested if statements to process an array with three or  more dimensions. Here’s another way to initialize a three-dimensional array with  the numbers 1 to 27:  int[][][] threeD2 = new int[3][3][3]; int value = 1; for  int i = 0; i < 3; i++      for  int j = 0; j < 3; j++          for  int k = 0; k < 3; k++              threeD2[i][j][k] = value++;  Working with a Fun but Complicated  Example: A Chessboard  Okay,  so  much  for  the  business  examples.  Here’s  an  example  that’s  more  fun — assuming you think chess is fun. The program in Listing 2-2 uses a two- dimensional array to represent a chessboard. Its sole purpose is to figure out the  possible moves for a knight  that’s the horsey, for the non-chess players among  us , given its starting position. The user is asked to enter a starting position  such  as f1 , and the program responds by displaying the possible squares. Then the  program prints out a crude-but-recognizable representation of the board, with  the knight’s position indicated with an X and each possible move indicated with a  question mark  ? .  In case you’re not familiar with chess, it’s played on a board that’s 8 by 8 squares,  with alternating light and dark squares. The normal way to identify each square is  to use a letter and a number, where the letter represents the column  called a file   and the number represents the row  called a rank , as shown in Figure 2-1. The  knight has an interesting movement pattern: He moves two squares in one direc- tion and then makes a 90-degree turn and moves one square to the left or right. The  possible moves for the knight, given a starting position of e4, are shaded dark. As  you can see, this knight has eight possible moves: c3, c5, d6, f6, g5, g3, f2, and d2.  Here’s a sample of what the console looks like if you enter e4 for the knight’s position:  Welcome to the Knight Move calculator.  Enter knight's position: e4  The knight is at square e4 From here the knight can move to:  408      BOOK 4  Strings, Arrays, and Collections   c5 d6 f6 g5 g3 f2 d2 c3  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  ?  -  ?  -  -  -  -  ?  -  -  -  ?  -  -  -  -  -  X  -  -  -  -  -  ?  -  -  -  ?  -  -  -  -  ?  -  ?  -  -  -  -  -  -  -  -  -  - Do it again?  Y or N  n  s y a r r A g n i s U     FIGURE 2-1:   A classic  chessboard.  As you can see, the program indicates that the knight’s legal moves from e4 are  c5, d6, f6, g5, g3, f2, d2, and c3. Also, the graphic representation of the board  indicates where the knight is and where he can go.  CHAPTER 2  Using Arrays      409   LISTING 2-2:   Playing Chess in a For Dummies Book  import java.util.Scanner; public class KnightMoves {     static Scanner sc = new Scanner System.in ;         the following static array represents the 8        possible moves a knight can make        this is an 8 x 2 array     static int[][] moves = { {-2, +1},                               {-1, +2},                              {+1, +2},                              {+2, +1},                              {+2, -1},                              {+1, -2},                              {-1, -2},                              {-2, -1} };      public static void main String[] args      {         System.out.println "Welcome to the "             + "Knight Move calculator.\n" ;         do         {             showKnightMoves  ;          }         while  getYorN "Do it again?"  ;     }     public static void showKnightMoves        {            The first dimension is the file  a, b, c, etc.             The second dimension is the rank  1, 2, 3, etc.             Thus, board[3][4] is square d5.            A value of 0 means the square is empty            1 means the knight is in the square            2 means the knight could move to the square         int[][] board = new int[8][8];           String kSquare;    the knight's position as a square         Pos kPos;          the knight's position as a Pos             get the knight's initial position         do          {             System.out.print "Enter knight's position: " ;             kSquare = sc.nextLine  ;             kPos = convertSquareToPos kSquare ;         } while  kPos == null ;  410      BOOK 4  Strings, Arrays, and Collections  →10  →26  →31  →39  →45   s y a r r A g n i s U     →52  →59  →72  →78          board[kPos.x][kPos.y] = 1;          System.out.println "\nThe knight is at square "             + convertPosToSquare kPos  ;         System.out.println              "From here the knight can move to:" ;         for  int move = 0; move < moves.length; move ++           {             int x, y;             x = moves[move][0];     the x for this move             y = moves[move][1];     the y for this move             Pos p = calculateNewPos kPos, x, y ;             if  p != null              {                 System.out.println convertPosToSquare p  ;                 board[p.x][p.y] = 2;             }         }          printBoard board ;       }        this method converts squares such as a1 or d5 to        x, y coordinates such as [0][0] or [3][4]     public static Pos convertSquareToPos String square       {         int x = -1;         int y = -1;         char rank, file;          file = square.charAt 0 ;         if  file == 'a'  x = 0;         if  file == 'b'  x = 1;         if  file == 'c'  x = 2;         if  file == 'd'  x = 3;         if  file == 'e'  x = 4;         if  file == 'f'  x = 5;         if  file == 'g'  x = 6;         if  file == 'h'  x = 7;          rank = square.charAt 1 ;         if  rank == '1'  y = 0;         if  rank == '2'  y = 1;         if  rank == '3'  y = 2;         if  rank == '4'  y = 3;         if  rank == '5'  y = 4;         if  rank == '6'  y = 5;         if  rank == '7'  y = 6;   continued   CHAPTER 2  Using Arrays      411   LISTING 2-2:    continued           if  rank == '8'  y = 7;          if  x == -1  y == -1          {             return null;         }         else             return new Pos x, y ;     }         this method converts x, y coordinates such as        [0][0] or [3][4] to squares such as a1 or d5.     public static String convertPosToSquare Pos p       {         String file = "";          if  p.x == 0  file = "a";         if  p.x == 1  file = "b";         if  p.x == 2  file = "c";         if  p.x == 3  file = "d";         if  p.x == 4  file = "e";         if  p.x == 5  file = "f";         if  p.x == 6  file = "g";         if  p.x == 7  file = "h";          return file +  p.y + 1 ;     }       this method calculates a new Pos given a       starting Pos, an x move, and a y move        it returns null if the resulting move would        be off the board.     public static Pos calculateNewPos Pos p, int x, int y       {            rule out legal moves         if  p.x + x < 0              return null;         if  p.x + x > 7              return null;         if  p.y + y < 0              return null;         if  p.y + y > 7              return null;  →114  →134  412      BOOK 4  Strings, Arrays, and Collections              return new position         return new Pos p.x + x, p.y + y ;     }      public static void printBoard int[][] b       {         for  int y = 7; y >= 0; y--          {             for  int x = 0; x < 8; x++              {                 if  b[x][y] == 1                      System.out.print " X " ;                 else if  b[x][y] == 2                      System.out.print " ? " ;                 else                     System.out.print " - " ;             }             System.out.println  ;         }     }     public static boolean getYorN String prompt       {         while  true          {             String answer;             System.out.print "\n" + prompt + "  Y or N  " ;             answer = sc.nextLine  ;             if  answer.equalsIgnoreCase "Y"                   return true;             else if  answer.equalsIgnoreCase "N"                   return false;         }     } }     this class represents x, y coordinates on the board class Pos  {     public int x;     public int y;      public Pos int x, int y      {         this.x = x;         this.y = y;     } }  →150  s y a r r A g n i s U     →167  →183  CHAPTER 2  Using Arrays      413   You have to put your thinking cap on to make your way through this program,  which is a bit on the complicated side. The following paragraphs can help clear up  the more complicated lines: →10        This line declares a two-dimensional array that’s used to store the   possible moves for a knight in terms of x and y. The knight’s move of two  squares left and one square up, for example, is represented as {–2, 1}.  There are a total of eight possible moves, and each move has two values   x and y . So this two-dimensional array has eight rows and two columns.   →26        The code that gets the user’s starting position for the knight and does  all the calculations is complicated enough that I didn’t want to include it  in the main method, so I put it in a separate method named showN- ightMoves. That way, the do loop in the main method is kept simple. It  just keeps going until the user enters N when getYorN is called.   →31        The showNightMoves method begins here.  →39        The board array represents the chessboard as a two-dimensional array  with eight rows for the ranks and eight columns for the files. This array  holds int values. A value of 0 indicates that the square is empty. The  square where the knight resides gets a 1, and any square that the  knight can move to gets a 2.   →45        This do loop prompts the user for a valid square to plant the knight in.  The loop includes a call to the method convertSquareToPos, which  converts the user’s entry  such as e4  to a Pos object.  The Pos class is  defined later in the program; it represents a board position as an x, y  pair.  This method returns null if the user enters an incorrect square,  such as a9 or x4. So to get the user to enter a valid square, the loop just  repeats if the converSquareToPos returns null.   →52        The board position entered by the user is set to 1 to indicate the   position of the knight.  →59        A for loop is used to test all the possible moves for the knight to see   whether they’re valid from the knight’s current position, using the moves  array that was created way back in line 10. In the body of this loop, the  calculateNewPos method is called. This method accepts a board posi- tion and x and y values to indicate where the knight can be moved. If the  resulting move is legal, it returns a new Pos object that indicates the  position the move leads to. If the move is not legal  that is, it takes the  knight off the board , the calculateNewPos method returns null.  Assuming that calculateNewPos returns a non-null value, the body of  this loop prints the square  it calls convertPosTosquare to convert the  Pos object to a string, such as c3 . Then it marks the board position  represented by the move with 2 to indicate that the knight can move to  this square.  414      BOOK 4  Strings, Arrays, and Collections   s y a r r A g n i s U      →72        After all the moves are calculated, the printBoard method is called to   print the board array.  →78        This is the convertSquareToPos method. It uses a pair of brute-force if   statements to convert a string such as a1 or e4 to a Pos object repre- senting the same position. I probably could have made this method a  little more elegant by converting the first letter in the string to a Char  and then subtracting the offset of the letter a to convert the value to a  proper integer. But I think the brute-force method is clearer, and it  requires only a few more lines of code.  Note that if the user enters an incorrect square  such as a9 or x2 , null is  returned.   →114      This is the convertPosToSquare method, which does the opposite of   the convertSquareToPos method. It accepts a Pos argument and  returns a string that corresponds to the position. It uses a series of  brute-force if statements to determine the letter that corresponds to  the file but does a simple addition to calculate the rank.  The Pos  object’s y member is an array for the y position. Array indexes are  numbered starting with 0, but chess rank numbers start with 1. That’s  why 1 is added to the y position to get the rank number.    →134      The calculateNewPos method accepts a starting position, an x offset,  and a y offset. It returns a new position if the move is legal; otherwise it  returns null. To find illegal moves, it adds the x and y offsets to the  starting x and y position and checks to see whether the result is less  than 0 or greater than 7. If the move is legal, it creates a new Pos object  whose position is calculated by adding the x and y offsets to the x and  y values of the starting position.   →150      The printBoard method uses a nested for loop to print the board. The  outer loop prints each rank. Notice that it indexes the array backward,  starting with 7 and going down to 0. That’s necessary so that the first rank  is printed at the bottom of the console output. An inner for loop is used to  print the squares for each rank. In this loop, an if statement checks the  value of the board array element that corresponds to the square to  determine whether it prints an X, a question mark, or a hyphen.   →167      The getYorN method simply displays a prompt on-screen and asks the  user to enter Y or N. It returns true if the user enters Y or false if the  user enters N. If the user enters anything else, this method prompts the  user again.  →183      The Pos class simply defines two public fields, x and y, to keep track of  board positions. It also defines a constructor that accepts the x and y  positions as parameters.  CHAPTER 2  Using Arrays      415   Using the Arrays Class  The final topic for this chapter is the Arrays class, which provides a collection of  static methods that are useful for working with arrays. The Arrays class is in the  java.util package, so you have to use an import statement for the java.util. Arrays class or the entire java.util.* package to use this class. Table  2-1 lists  the most commonly used methods of the Arrays class.  TABLE  2-1   Method  Handy Methods of the Arrays Class  Description  static int binarySearch array, key   static array copyOf arrayOriginal,  newLength   static array  copyOfRange arrayOriginal, from, to   boolean deepEquals array1, array2   boolean equals array1, array2   static void fill array, value   static void fill array, from, to, value   Searches for the specified key value in an array. The  return value is the index of the element that matches  the key. The method returns –1 if the key couldn’t be  found. The array and the key must be of the same  type and can be any primitive type or an object.  Returns an array that’s a copy of arrayOriginal.  The newLength parameter need not equal the  original array’s length. If newLength is larger,  the method pads the new array with zeros. If  newLength is smaller, the method doesn’t copy all  of the original array’s values.  Does basically what the copyOf method does, but  copies only a selected slice of values  from one index  to another  of the original array.  Returns true if the two arrays have the same  element values. This method works for arrays of two  or more dimensions.  Returns true if the two arrays have the same  element values. This method checks equality only for  one-dimensional arrays.  Fills the array with the specified value. The value  and array must be of the same type and can be any  primitive type or an object.  Fills the elements indicated by the from and to  int parameters with the specified value. The value  and array must be of the same type and can be any  primitive type or an object.  static void sort array   Sorts the array in ascending sequence.  416      BOOK 4  Strings, Arrays, and Collections   Method  Description  static void sort array, from, to   static String toString array   Sorts the specified elements of the array in  ascending sequence.  Formats the array values in a string. Each element  value is enclosed in brackets, and the element values  are separated with commas.  s y a r r A g n i s U     Filling an array  The fill method can be handy if you want to prefill an array with values other  than the default values for the array type. Here’s a routine that creates an array of  integers and initializes each element to 100:  int[] startValues = new int[10]; Arrays.fill startValues, 100 ;  Although  you  can  code  a  complicated  expression  as  the  second  parameter,  the  fill method evaluates this expression only once. Then it assigns the result of this  expression to each element in the array.  You might think that you could fill an array of 1,000 integers with random num- bers from 1 to 100, like this:  int[] ran = new int[1000] Arrays.fill ran,  int  Math.random   * 100  + 1 ;  Unfortunately, this code won’t work. What happens is that the expression is eval- uated once to get a random number; then all 1,000 elements in the array are set  to that random number.  Copying an array  In Java 1.6, the Arrays class has some useful new methods. Using the new copyOf  and copyOfRange methods, you can copy a bunch of elements from an existing  array into a brand-new array. If you start with something named arrayOrigi- nal, for example, you can copy the arrayOriginal elements to something named  arrayNew, as shown in Listing 2-3.  CHAPTER 2  Using Arrays      417   LISTING 2-3:   The Copycat  import java.util.Arrays;  class CopyDemo {     public static void main String args[]      {         int arrayOriginal[] = {42, 55, 21};         int arrayNew[] =             Arrays.copyOf arrayOriginal, 3 ;          printIntArray arrayNew ;     }     static void printIntArray int arrayNew[]      {         for  int i : arrayNew          {             System.out.print i ;             System.out.print ' ' ;         }         System.out.println  ;     } }  →9  The output of the CopyDemo program looks like this:  42 55 21 →9      This is the line where you can change the number 3 to something smaller.  You can do the following, for example:  int arrayNew[] = Arrays.copyOf arrayOriginal, 2 ;  If you do, arrayNew has fewer than three elements:  42 55  You can also change the number 3 to something larger:  int arrayNew[] = Arrays.copyOf arrayOriginal, 8 ;  418      BOOK 4  Strings, Arrays, and Collections   Then arrayNew has more than three elements:  42 55 21 0 0 0 0 0  The copyOfRange method is even more versatile. If you execute the instructions  int arrayOriginal[] = {42, 55, 21, 16, 100, 88}; int arrayNew[] = Arrays.copyOfRange arrayOriginal, 2, 5 ;  s y a r r A g n i s U     the values in arrayNew are  21 16 100  Sorting an array  The sort method is a quick way to sort an array in sequence. These statements  create an array with 100 random numbers and then sort the array in sequence so  that the random numbers are in order:  int[] lotto = new int[6]; for  int i = 0; i < 6; i++      lotto[i] =  int  Math.random   * 100  + 1; Arrays.sort lotto ;  Searching an array  The binarySearch method is an efficient way to locate an item in an array by its  value. Suppose you want to find out whether your lucky number is in the lotto  array created in the preceding example. You could just use a for loop, like this:  int lucky = 13x; int foundAt = -1; for  int i = 0; i < lotto.length; i++      if  lotto[i] == lucky          foundAt = i; if  foundAt > -1      System.out.println "My number came up!" ; else     System.out.println "I'm not lucky today." ;  Here the for loop compares each element in the array with your lucky number.  This code works fine for small arrays, but what if the array had 1,000,000 ele- ments instead of 6? In that case, it would take a while to look at each element.   CHAPTER 2  Using Arrays      419   If the array is sorted in sequence, the binarySearch method can find your lucky  number more efficiently and with less code:  int lucky = 13; int foundAt = Arrays.binarySearch lotto, lucky ; if  foundAt > -1      System.out.println "My number came up!" ; else     System.out.println "I'm not lucky today." ;  The binarySearch method uses a technique similar to the strategy for guessing  a number. If I say that I’m thinking of a number between 1 and 100, you don’t  start guessing the numbers in sequence starting with 1. Instead, you guess 50. If I  tell you that 50 is low, you guess 75. Then if I tell you 75 is high, you guess half- way between 50 and 75, and so on until you find the number. The binarySearch  method uses a similar technique, but it works only if the array is sorted first.  Comparing arrays  If you use the equality operator  ==  to compare array variables, the array vari- ables are considered to be equal only if both variables point to exactly the same  array instance. To compare two arrays element by element, you should use the  Arrays.equal method instead. For example:  if  Arrays.equal array1, array2       System.out.println "The arrays are equal!" ;  Here  the  arrays  array1  and  array2  are  compared  element  by  element.  If  both  arrays have the same number of elements, and all elements have the same value,  the equals method returns true. If the elements are not equal, or if one array has  more elements than the other, the equals method returns false.  If the array has more than one dimension, you can use the deepEquals method  instead. It compares any two subarrays, element by element, to determine whether  they’re identical.  Converting arrays to strings  The toString method of the Arrays class is handy if you want to quickly dump the  contents of an array to the console to see what it contains. This method returns  a string that shows the array’s elements enclosed in brackets, with the elements  separated by commas.  420      BOOK 4  Strings, Arrays, and Collections   Here’s a routine that creates an array, fills it with random numbers, and then uses  the toString method to print the array elements:  int[] lotto = new int[6]; for  int i = 0; i < 6; i++      lotto[i] =  int  Math.random   * 100  + 1; System.out.println Arrays.toString lotto  ;  Here’s a sample of the console output created by this code:  [4, 90, 65, 84, 99, 81]  s y a r r A g n i s U     Note that the toString method works only for one-dimensional arrays. To print  the contents of a two-dimensional array with the  toString method, use a  for  loop to call the toString method for each subarray.  CHAPTER 2  Using Arrays      421    IN THIS CHAPTER  » Working with the ArrayList class   » Creating an array list   » Introducing generics   » Adding elements to an array list   » Deleting elements from or modifying   elements in an array list  Chapter 3 Using the ArrayList Class  S   ome  people  love  to  collect  things:  nick-knacks,  baseball  cards,  postage  stamps, dolls — you name it, someone collects it.  If I were a collector of some random thing — say, old tin advertising signs — an  array would be a poor choice for storing the data. That’s because on any given  day, I may find another tin sign at a yard sale. So if I had 87 tin signs before, and I  had created an array big enough to hold all 87 signs, I’d have to change the array  declaration to hold 88 signs.  Java’s collection classes are designed to simplify the programming for applications  that have to keep track of groups of objects. These classes are very powerful and  surprisingly easy to use — at least the basics, anyway. The more advanced fea- tures of collection classes take some serious programming to get right, but for  most applications, a few simple methods are all you need to use collection classes.  Unfortunately, Java’s collection classes are organized according to a pretty com- plicated inheritance hierarchy that can be very confusing for beginners. Most of  the Java books I have on my shelf start by explaining this inheritance scheme and  showing how each of the various collection classes fits into this scheme, and why.  I’m not going to do that. I think it’s very confusing for newcomers to collections  to have to wade through a class hierarchy that doesn’t make sense until they know  some of the details of how the basic classes work. Instead, I just show you how to  use two of the best of these classes.  CHAPTER 3  Using the ArrayList Class      423   In this chapter, you find out how to use the ArrayList class. Then, in the next  chapter, you find out how to use its first cousin, the LinkedList. When you know  how to use these two classes, you shouldn’t have any trouble figuring out how to  use the other collection classes from the API documentation.  Java  1.5  introduced  a  major  new  language  feature  called  generics  that  is  aimed  specifically at making collections easier to work with. Specifically, the generics  feature  lets  you  create  list  objects,  such  as  ArrayList  or  LinkedList,  that  are  bound to a specific data type, such as strings or integers.  Because generics are an integral part of how collections work in Java 1.5 and sub- sequent versions, I incorporate the generics feature into this chapter from the very  start. I point out the differences for using ArrayList without generics along the  way, just in case you’re using an older version of Java or are working with pro- grams that were written before Java 1.5 became available.  For a complete explana- tion of how the generics feature works, you can move ahead to Book 4, Chapter 5.   I have even more good news about new features: the major new feature that was  introduced with Java 8, lambda expressions, provides an entirely new way of work- ing with collections that is especially useful for efficiently dealing with collections  that  have  a  large  number  of  items.  For  more  information  about  working  with  these new collection features, see Chapter 6 of this minibook. And for more infor- mation about lambda expressions, see Book 3, Chapter 7.  An array list is the most basic type of Java collection. You can think of an array list  as being an array on steroids. It’s similar to an array but averts many of the most  common problems of working with arrays, specifically the following:   » An array list automatically resizes itself whenever necessary. If you create  an array with 100 elements, and then fill it up and need to add a 101st element,  you’re out of luck. The best you can do is create a new array with 101 elements,  copy the 100 elements from the old array to the new one, and then put the new  data in the 101st element. With an array list, there’s never a limit to how many  elements you can create. You can keep adding elements as long as you want.  » An array list lets you insert elements into the middle of the collection.  With an array, inserting elements is pretty hard to do. Suppose that you have  an array that can hold 100 elements, but only the first 50 have data. If you  need to insert a new element after the 25th item, you first must make a copy  of elements 26 through 50 to make room for the new element. With an array   Understanding the ArrayList Class  424      BOOK 4  Strings, Arrays, and Collections   list, you just tell the array list you want to insert the new element after the  25th item; the array list takes care of shuffling things around.   » An array list lets you delete items. If you delete an item from an array, the  deleted element becomes null, but the empty slot that was occupied by the  item stays in the array. When you delete an item from an array list, any  subsequent items in the array are automatically moved forward one position  to fill the spot that was occupied by the deleted item.   » The ArrayList class actually uses an array internally to store the data  you add to the array list. The ArrayList class takes care of managing the  size of this array. When you add an item to the array list, and the underlying  array is full, the ArrayList class automatically creates a new array with a  larger capacity and copies the existing items to the new array before it adds  the new item.  The ArrayList class has several constructors and a ton of methods. For your ref- erence, Table 3-1 lists the constructors and methods of the ArrayList class.  The rest of this chapter shows you how to use these constructors and methods to  work with ArrayList objects.  s s a l C   t s i L y a r r A e h t   g n i s U     TABLE 3-1	  Constructor  ArrayList    The ArrayList Class  Explanation  Creates an array list with an initial capacity of ten elements.  ArrayList int capacity   Creates an array list with the specified initial capacity.  ArrayList Collection c   Creates an array list and copies all the elements from the specified  collection into the new array list.  Method  Explanation  add Object element   add int index,  Object element   Adds the specified object to the array list. If you specified a  type when you created the array list, the object must be of the  correct type.  Adds the specified object to the array list at the specified index  position. If you specified a type when you created the array list, the  object must be of the correct type.  addAll Collection c   Adds all the elements of the specified collection to this array list.  addAll int index,  Collection c   clear    Adds all the elements of the specified collection to this array list at  the specified index position.  Deletes all elements from the array list.   continued   CHAPTER 3  Using the ArrayList Class      425   TABLE 3-1	 continued   Constructor  clone    Explanation  Returns a shallow copy of the array list. The elements contained  in the copy are the same object instances as the elements in  the original.  contains Object elem   Returns a boolean that indicates whether the specified object is in  the array list.  containsAll Collection c   Returns a boolean that indicates whether this array list contains all  the objects that are in the specified collection.  ensureCapacity int  minCapacity   get int index   indexOf Object elem   isEmpty    iterator    Increases the array list’s capacity to the specified value.  If the capacity  is already greater than the specified value, this method does nothing.   Returns the object at the specified position in the list.  Returns the index position of the first occurrence of the specified  object in the array list. If the object isn’t in the list, it returns -1.  Returns a boolean value that indicates whether the array  list is empty.  Returns an iterator for the array list.  lastIndexOf Object elem   Returns the index position of the last occurrence of the specified  object in the array list. If the object isn’t in the list, it returns -1.  remove int index   remove Object elem   remove int fromIndex,  int toIndex   Removes the object at the specified index and returns the element  that was removed.  Removes an object from the list. Note that more than one element  refers to the object; this method removes only one of them. It  returns a boolean that indicates whether the object was in the list.  Removes all objects whose index values are between the values  specified. Note that the elements at the fromIndex and toIndex  positions are not themselves removed.  removeAll Collection c   Removes all the objects in the specified collection from this array list.  retainAll Collection c   Removes all the objects that are not in the specified collection from  this array list.  set int index, Object elem   size    toArray    Sets the specified element to the specified object. The element  that was previously at that position is returned as the method’s  return value.  Returns the number of elements in the list.  Returns the elements of the array list as an array of objects   Object[] .  toArray type[] array   Returns the elements of the array list as an array whose type is the  same as the array passed via the parameter.  426      BOOK 4  Strings, Arrays, and Collections   Creating an ArrayList Object  To create an array list, you first declare an ArrayList variable and then call the  ArrayList  constructor  to  instantiate  an  ArrayList  object  and  assign  it  to  the  variable. You can do this on separate lines:  s s a l C   t s i L y a r r A e h t   g n i s U     ArrayList signs; signs = new ArrayList  ;  Alternatively, you can do it on a single line:  ArrayList signs = new ArrayList  ;  Here are a few things to note about creating array lists:   » The ArrayList class is in the java.util package, so your program must   import either java.util.ArrayList or java.util.*.   » Unlike an array, an array list doesn’t make you specify a capacity — though   you can if you want. Here’s a statement that creates an array list with an initial  capacity of 100:  ArrayList signs = new ArrayList 100 ;  If you don’t specify a capacity for the array list, the initial capacity is set to 10.  Providing at least a rough estimate of how many elements each array list can  hold when you create it is a good idea.   » The capacity of an array list is not a fixed limit. The ArrayList class automati-  cally increases the list’s capacity whenever necessary.   » If you’re using Java 1.5 or later, you can also specify the type of elements the  array list is allowed to contain. This statement creates an array list that holds  String objects:  ArrayList  signs = new ArrayList   ;  The advantage of specifying a type when you declare an array list is that the  compiler complains if you then try to add an object of the wrong type to the  list.  This feature is called generics because it lets the Java API designers create  generic collection classes that can be used to store any type of object. For  more information, see Book 4, Chapter 5.    » The ArrayList class also has a constructor that lets you specify another   collection object  typically, another array list  whose items are copied into the  new array list. This provides an easy way to make a copy of an array list, but  you can also use it to convert any other type of collection to an array list.  CHAPTER 3  Using the ArrayList Class      427   Adding Elements  After you create an array list, you can use the add method to add objects to the  array list. Here’s code that adds strings to an array list:  signs.add "Drink Pepsi" ; signs.add "No minors allowed" ; signs.add "Say Pepsi, Please" ; signs.add "7-Up: You Like It, It Likes You" ; signs.add "Dr. Pepper 10, 2, 4" ;  If you specified a type when you created the array list, the objects you add via the  add method must be of the correct type.  You can insert an object at a specific position in the list by listing the position in  the add method. Consider these statements:  ArrayList  nums = new ArrayList   ; nums.add "One" ; nums.add "Two" ; nums.add "Three" ; nums.add "Four" ; nums.add 2, "Two and a half" ;  After these statements execute, the nums array list contains the following strings:  One Two Two and a half Three Four  Here are some important points to keep in mind when you add elements to array  lists:   » If an array list is already at its capacity when you add an element, the array list  automatically expands its capacity. Although this capacity is flexible, it’s also  inefficient. Whenever possible, you should anticipate how many elements  you’re adding to an array list and set the list’s initial capacity accordingly.  You  can also change the capacity at any time by calling the ensureCapac- ity method.    » Like arrays, array lists are indexed starting with zero. Keep this in mind when   you use the version of the add method that accepts an index number.  428      BOOK 4  Strings, Arrays, and Collections    » The add method that inserts elements at a specific index position throws the  unchecked exception IndexOutOfBoundsException if an object isn’t already  at the index position you specify.  Accessing Elements  To access a specific element in an array list, you can use the get method, which  specifies the index value of the element you want to retrieve. Here’s a for loop  that prints all the strings in an array list:  for  int i = 0; i < nums.size  ; i++      System.out.println nums.get i  ;  Here the size method is used to set the limit of the for loop’s index variable.  The easiest way to access all the elements in an array list is to use an enhanced for  statement, which lets you retrieve the elements without bothering with indexes or  the get method. For example:  s s a l C   t s i L y a r r A e h t   g n i s U     for  String s : nums      System.out.println s ;  Here each String element in the nums array list is printed to the console.  If you need to know the index number of a particular object in an array list, and you  have a reference to the object, you can use the indexOf method. Here’s an enhanced  for loop that prints the index number of each string along with the string:  for  String s : nums  {     int i = nums.indexOf s ;     System.out.println "Item " + i + ": " + s ; }  Depending on the contents of the array list, the output from this loop may look  something like this:  Item 0: One Item 1: Two Item 2: Three Item 3: Four  CHAPTER 3  Using the ArrayList Class      429   Printing an ArrayList  The toString method of the ArrayList class  as well as other collection classes   is designed to make it easy to quickly print out the contents of the list. It returns  the contents of the array list enclosed in a set of brackets, with each element value  separated by commas. The toString method of each element is called to obtain  the element value.  Consider these statements:  ArrayList  nums = new ArrayList   ; nums.add "One" ; nums.add "Two" ; nums.add "Three" ; nums.add "Four" ; System.out.println nums ;  When you run these statements, the following is displayed on the console:  [One, Two, Three, Four]  Although this output isn’t very useful for actual applications, it’s convenient for  testing purposes or for debugging problems in programs that use array lists.  Another way to access all the elements in an array list  or any other collection  type  is to use an iterator. An iterator is a special type of object whose sole purpose  in life is to let you step through the elements of a collection.  The enhanced for statement introduced with Java 1.5 is designed to simplify pro- grams that use iterators. As a result, if you’re using Java 1.5 or later, you can use  the enhanced for statement instead of iterators. Still, you’ll probably encounter  existing programs that use iterators, so you need to know how they work.  An iterator  object  implements  the  Iterator interface,  which is  defined as part  of the java.util package. As a result, to use an iterator, you must import either  java.util.Iterator or java.util.*. The Iterator interface defines just three  methods, as listed in Table 3-2. These methods are all you need to access each  element of a collection.  Actually, you need only the hasNext and next methods.  The remove method is gravy.   Using an Iterator  430      BOOK 4  Strings, Arrays, and Collections   TABLE 3-2	  Method  The Iterator Interface Explanation  hasNext    Returns true if the collection has at least one element that hasn’t yet been retrieved  next    remove    Returns the next element in the collection  Removes the most recently retrieved element  To use an iterator, you first call the array list’s iterator method to get the itera- tor. Then you use the iterator’s hasNext and next methods to retrieve each item in  the collection. The normal way to do that is with a while loop. Here’s an example:  ArrayList  nums = new ArrayList   ; nums.add "One" ; nums.add "Two" ; nums.add "Three" ;  s s a l C   t s i L y a r r A e h t   g n i s U     THE ITERATOR PATTERN  Java’s iterators follow a common design pattern called the Iterator pattern, which is  useful whenever you need to provide sequential access to a collection of objects. The  Iterator pattern relies on interfaces so that the code that’s using the iterator doesn’t  have to know what actual class is being iterated. As long as the class implements the  iterator interface, it can be iterated.  The Iterator interface itself defines the methods used for sequential access. The  common pattern is for this interface to provide at least two methods:     hasNext: Returns a boolean value that indicates whether another item is   available.     next: Returns the next item.  Java also defines a third method for its Iterator interface: remove, which removes the  most recently retrieved object.  In addition to the Iterator interface, the collection class itself needs a way to get  an iterator object. It does so via the iterator method, which simply returns an  iterator object for the collection. The iterator method is defined by the Iterable  interface. Thus, any object that implements Iterable has an iterator method that  provides an iterator for the object.  CHAPTER 3  Using the ArrayList Class      431   nums.add "Four" ; String s; Iterator e = nums.iterator  ; while  e.hasNext    {     s =  String e.next  ;     System.out.println s ; }  Here the first five statements create an array list and add four strings to it. Next,  the  iterator  method  is  called  to  get  an  iterator  for  the  nums  array  list.  The   hasNext method is called in the while statement, and the next method is called  to get the element to be printed.  Note that the object returned by the next method must be cast to a String. That’s  because the Iterator interface has no knowledge of the type of objects stored in  the collection. As a result, it simply returns an Object. You must cast this object  to the correct type before you can use it.  Updating Elements  You  can  use  the  set  method  to  replace  an  existing  object  with  another  object.  Consider this example:  ArrayList  nums = new ArrayList   ; nums.clear  ; nums.add "One" ; nums.add "Two" ; nums.add "Three" ; System.out.println nums ; nums.set 0, "Uno" ; nums.set 1, "Dos" ; nums.set 2, "Tres" ; System.out.println nums ;  Here an array list is created with three strings, and the contents of the array list  are printed to the console. Then each of the three strings is replaced by another  string, and the contents print to the console again. When you run this code, the  following is what you see printed on the console:  432      BOOK 4  Strings, Arrays, and Collections   [One, Two, Three] [Uno, Dos, Tres]  Because array lists contain references to objects, not the objects themselves, any  changes you make to an object in an array list are automatically reflected in the  list. As a result, you don’t often have to use the set method.  For example:  ArrayList  emps = new ArrayList   ;     add employees to array list emps.add new Employee "Addams", "Gomez"  ; emps.add new Employee "Taylor", "Andy"  ; emps.add new Employee "Kirk", "James"  ;     print array list System.out.println emps ;     change one of the employee's names Employee e = emps.get 1 ; e.changeName "Petrie", "Robert" ;     print the array list again System.out.println emps ;  s s a l C   t s i L y a r r A e h t   g n i s U     This example uses the Employee class, whose constructor accepts an employee’s  last name and first name to create a new employee object, as well as a changeName  method that also accepts a last name and a first name. In addition, the Employee  class overrides the toString method to return the employee’s first name and last  name.  The  main  method  begins  by  creating  an  ArrayList  object  and  adding  three  employees. Then it prints out the contents of the array list. Next, it retrieves the  employee  with  index  number  1  and  changes  that  employee’s  name.  Finally,  it  prints the contents of the array list again.  Here’s what this code produces on the console:  [Gomez Addams, Andy Taylor, James Kirk] [Gomez Addams, Robert Petrie, James Kirk]  CHAPTER 3  Using the ArrayList Class      433   Notice that the second employee’s name was changed, even though the program  doesn’t use the set method to replace the changed Employee object in the collec- tion. That’s because the array list merely stores references to the Employee objects.  Deleting Elements  The ArrayList class provides several methods that let you remove elements from  the collection. To remove all the elements, use the clear method, like this:  To remove a specific element, use the remove method. It lets you remove an ele- ment based on the index number, like this:  emps.clear  ;  emps.remove 0 ;  Here the first element in the array list is removed.  Alternatively, you can pass the actual object you want removed. This is useful if  you don’t know the index of the object you want to remove, but you happen to  have a reference to the actual object, as in this example:  ArrayList  emps = new ArrayList   ;     create employee objects Employee emp1 = new Employee "Addams", "Gomez" ; Employee emp2 = new Employee "Taylor", "Andy" ; Employee emp3 = new Employee "Kirk", "James" ;     add employee objects to array list emps.add emp1 ; emps.add emp2 ; emps.add emp3 ;     print the array list System.out.println emps ;     remove one of the employees emps.remove emp2 ;     print the array list again System.out.println emps ;  434      BOOK 4  Strings, Arrays, and Collections   Here’s what this code produces on the console:  [Gomez Addams, Andy Taylor, James Kirk] [Gomez Addams, James Kirk]  As you can see, the program was able to remove Andy Taylor from the list without  knowing his index position.  Here are a few important details to keep in mind:   » The clear and remove methods don’t actually delete objects; they simply   remove the references to the objects from the array list. Like any other  objects, the objects in a collection are deleted automatically by the garbage  collector — and then only if the objects are no longer being referenced by  the program.   » You can remove more than one element at the same time by using the  removeRange method. On it, you specify the starting and ending index  numbers.  Note that this method removes all elements between the elements  you specify, but the elements you specify aren’t themselves removed.  removeRange 5, 8 , for example, removes elements 6 and 7, but elements 5  and 8 aren’t removed.    » You can also use the removeAll method to remove all the objects in one   collection from another collection. A similar method, retainAll, removes all  the objects that are not in another collection.  s s a l C   t s i L y a r r A e h t   g n i s U     CHAPTER 3  Using the ArrayList Class      435    IN THIS CHAPTER  » Introducing linked lists   » Comparing linked lists with array lists   » Creating linked lists   » Adding items to a linked list   » Retrieving items from a linked list   » Updating and deleting items in a   linked list  Chapter 4 Using the LinkedList Class The ArrayList class, which I cover in the preceding chapter, is a collection   class that’s based on an array. Arrays have their strengths and their weak- nesses. The strength of an array is that it’s very efficient — at least until  you fill it up or try to reorganize it by inserting or deleting elements. Then it sud- denly becomes very inefficient.  Over the years, computer scientists have developed various alternatives to arrays  that are more efficient for certain types of access. One of the oldest of these alter- natives is the linked list. A linked list is less efficient than an array for tasks such as  directly accessing an element based on its index number, but linked lists run cir- cles around arrays when you need to insert or delete items in the middle of the list.  In this chapter, you find out how to use Java’s LinkedList class, which provides  a  collection  that’s  based  on  a  linked  list  rather  than  an  array.  You’ll  find  that  although  the  LinkedList  class  provides  many  of  the  same  features  as  the  ArrayList class, it also has some tricks of its own.  Java  1.5  introduced  a  major  new  language  feature  called  generics  that  is  aimed  specifically  at  making  collections  easier  to  work  with.  Specifically,  the  gener- ics feature makes it possible for you to create list objects, such as ArrayList or  LinkedList, that are bound to a specific data type, such as strings or integers.  CHAPTER 4  Using the LinkedList Class      437   Understanding the LinkedList Class  Because generics are an integral part of how collections work in Java 1.5 and up,  I incorporate the generics  feature into this  chapter from the very start. I point  out the differences for using ArrayList without generics along the way, just in  case you’re using an older version of Java or are working with programs that were  written before Java 1.5 became available.  For a complete explanation of how the  generics feature works, you can read Book 4, Chapter 5.   Also, be aware that lambda expressions, introduced with Java 8, provide an alter- native method for working with collections, including the  LinkedList class. For  more information about working with these new collection features, see Chapter 6  of this minibook. And for more information about lambda expressions, see Book 3,  Chapter 7.  A  linked list  is  a  collection  in  which  every  object  in  the  list  maintains  with  it  a  pointer  to the following  object in  the list  and another pointer to the preceding  object in the list. No array is involved at all in a linked list. Instead, the list is man- aged entirely by these pointers.  Don’t worry — you don’t have to do any of this pointer management yourself. It’s  all taken care of for you by the LinkedList class.  This arrangement has some compelling advantages over arrays:   » Because the ArrayList class uses an array to store list data, the ArrayList  class frequently has to reallocate its array when you add items to the list. Not  so with the LinkedList class. Linked lists don’t have any size issues. You can  keep adding items to a linked list until your computer runs out of memory.   » Like the ArrayList class, the LinkedList class lets you insert items into the  middle of the list. With the ArrayList class, however, this operation is pretty  inefficient. It has to copy all the items past the insertion point one slot over to  free a slot for the item you’re inserting. Not so with the LinkedList class. To  insert an item into the middle of a linked list, all you have to do is change the  pointers in the preceding and the following objects.   » With an array list, removing items from the list is pretty inefficient. The   ArrayList class has to copy every item after the deleted item one slot closer  to the front of the array to fill the gap left by the deleted item. Not so with the  LinkedList class. To remove an item from a linked list, all that’s necessary is  to update the pointers in the items that were before and after the item to be  removed.  438      BOOK 4  Strings, Arrays, and Collections   If you want to remove the third item from a list that has 10,000 items in it, for  example, the ArrayList class has to copy 9,997 items. By contrast, the  LinkedList class does it by updating just two of the items. By the time the  ArrayList class is done, the LinkedList class has had time to mow the  lawn, read a book, and go to Disneyland.   » Linked lists are especially well suited for creating two common types of lists:    Stacks: A stack is a list in which items can be added to and retrieved from   only the front of the list.     Queues: A queue is a list in which items are always added to the back of the   list and always retrieved from the front.  Arrays are terribly inefficient for the sort of processing required by stacks and  queues.  You see examples of how to use linked lists to create stacks and  queues in Book 4, Chapter 5.    » The ArrayList class actually uses an array internally to store the data you add   to the array list. The ArrayList class takes care of managing the size of this  array. When you add an item to the array list, and the underlying array is full,  the ArrayList class automatically creates a new array with a larger capacity  and copies the existing items to the new array before it adds the new item.  There’s  no  such  thing  as  a  free  lunch,  however.  The  flexibility  of  a  linked  list  comes  at  a  cost:  Linked  lists  require  more  memory  than  arrays  and  are  slower  than arrays when it comes to simple sequential access.  Like the ArrayList class, the LinkedList class has several constructors and a ton  of methods. For your reference, Table 4-1 lists the constructors and methods of  the LinkedList class.  As  you  look  over  these  methods,  you’ll  find  several  that  seem  to  do  the  same  thing. These similar methods usually have subtle differences. The getFirst and  peek methods, for example, both return the first element from the list without  removing the element. The only difference is what happens if the list is empty. In  that case, getFirst throws an exception, but peek returns null.  In  some  cases,  however,  the  methods  are  identical,  such  as  the  remove  and  removeFirst methods. In fact, if you’re crazy enough to look at the source code  for the LinkedList class, you’ll find that the remove method consists of a single  line: a call to the removeFirst method.  CHAPTER 4  Using the LinkedList Class      439   The LinkedList Class  TABLE 4-1	  Constructor  LinkedList    Explanation  Creates an empty linked list.  LinkedList Collection c   Creates a linked list and copies all the elements from the  specified collection into the new linked list.  Method  add Object element   Explanation  add int index, Object element   addAll Collection c   addAll int index, Collection c   addFirst Object element   addLast Object element   clear    clone    contains Object elem   containsAll Collection c   descendingIterator    element    get int index   getFirst    Adds the specified object to the end of the linked list. If you  specified a type when you created the linked list, the object  must be of the correct type.  Adds the specified object to the linked list at the specified  index position. If you specified a type when you created the  linked list, the object must be of the correct type.  Adds all the elements of the specified collection to this  linked list.  Adds all the elements of the specified collection to this linked  list at the specified index position.  Inserts the specified object at the beginning of the list. If you  specified a type when you created the linked list, the object  must be of the correct type.  Adds the specified object to the end of the list. This method  performs the same function as the add method. If you  specified a type when you created the linked list, the object  must be of the correct type.  Deletes all elements from the linked list.  Returns a copy of the linked list. The elements contained in  the copy are the same object instances as the elements in  the original.  Returns a boolean that indicates whether the specified  object is in the linked list.  Returns a boolean that indicates whether this linked list  contains all the objects that are in the specified collection.  Returns an iterator that steps backward from the end to the  beginning of the linked list.  Retrieves the first element from the list.  The element is  not removed.   Returns the object at the specified position in the list.  Returns the first element in the list. If the list is empty, it  throws NoSuchElementException.  440      BOOK 4  Strings, Arrays, and Collections   indexOf Object elem   Constructor  getLast    isEmpty    iterator    lastIndexOf Object elem   offer Object elem   offerFirst Object elem   offerLast Object elem   peek    peekFirst    peekLast    poll    pollFirst    pollLast    pop    push Object elem   remove    Explanation  Returns the last element in the list. If the list is empty, it  throws NoSuchElementException.  Returns the index position of the first occurrence of the  specified object in the list. If the object isn’t in the list, it  returns -1.  Returns a boolean value that indicates whether the linked  list is empty.  Returns an iterator for the linked list.  Returns the index position of the last occurrence of the  specified object in the linked list. If the object isn’t in the list,  it returns -1.  Adds the specified object to the end of the list. This method  returns a boolean value, which is always true.  Adds the specified object to the front of the list. This method  returns a boolean value, which is always true.  Adds the specified object to the end of the list. This method  returns a boolean value, which is always true.  Returns  but does not remove  the first element in the list.  If the list is empty, it returns null.  Returns  but does not remove  the first element in the list.  If the list is empty, it returns null.  Returns  but does not remove  the last element in the list.  If the list is empty, it returns null.  Retrieves the first element and removes it from the list.  It returns the element that was retrieved or, if the list is  empty, null.  Retrieves the first element and removes it from the list.  It returns the element that was retrieved or, if the list is  empty, null.  Retrieves the last element and removes it from the list.  It returns the element that was retrieved or, if the list is  empty, null.  Pops an element from the stack represented by this list.  Pushes an element onto the stack represented by this list.  Retrieves the first element and removes it from the list. It  returns the element that was retrieved. If the list is empty, it  throws NoSuchElementException.   continued   CHAPTER 4  Using the LinkedList Class      441   TABLE 4-1	 continued   Constructor  remove int index   remove Object elem   removeAll Collection c   removeFirst    removeFirstOccurrence Object elem   removeLast    removeLastOccurrence Object elem   retainAll Collection c   set int index, Object elem   size    toArray    toArray type[] array   Explanation  Removes the object at the specified index and returns the  element that was removed.  Removes an object from the list. Note that if more than one  element refers to the object, this method removes only one  of them. It returns a boolean that indicates whether the  object was in the list.  Removes all the objects in the specified collection from this  linked list.  Retrieves the first element and removes it from the list. It  returns the element that was retrieved. If the list is empty, it  throws NoSuchElementException.  Finds the first occurrence of elem in the list and removes  this occurrence from the list. It returns false if the list has  no such occurrence.  Retrieves the last element and removes it from the list. It  returns the element that was retrieved. If the list is empty, it  throws NoSuchElementException.  Finds the last occurrence of elem in the list and removes this  occurrence from the list. It returns false if the list has no  such occurrence.  Removes all the objects that are not in the specified  collection from this linked list.  Sets the specified element to the specified object. The  element that was previously at that position is returned as  the method’s return value.  Returns the number of elements in the list.  Returns the elements of the linked list as an array of objects   Object[] .  Returns the elements of the linked list as an array whose  type is the same as the array passed via the parameter.  Creating a LinkedList  As with any other kind of object, creating a linked list is a two-step affair. First,  you declare a LinkedList variable; then you call one of the LinkedList construc- tors to create the object, as in this example:  LinkedList officers = new LinkedList  ;  442      BOOK 4  Strings, Arrays, and Collections   Adding Items to a LinkedList  Here a linked list is created and assigned to the variable officers.  If you’re using Java 1.5 or later, you can use the generics feature to specify a type  when you declare the linked list. Here’s a statement that creates a linked list that  holds strings:  LinkedList  officers = new LinkedList   ;  Then you can add only String objects to this list. If you try to add any other type  of object, the compiler balks.  Base runners advance.   The LinkedList class gives you many ways to add items to the list. The most basic  is the add method, which works pretty much the same way that it does for the  ArrayList class. Here’s an example:  LinkedList  officers = new LinkedList   ; officers.add "Blake" ; officers.add "Burns" ; officers.add "Houlihan" ; officers.add "Pierce" ; officers.add "McIntyre" ; for  String s : officers      System.out.println s ;  The add method adds these items to the end of the list. So the resulting output is this:  Blake Burns Houlihan Pierce McIntyre  The addLast method works the same way, but the addFirst method adds items to  the front of the list. Consider these statements:  LinkedList  officers = new LinkedList   ; officers.addFirst "Blake" ; officers.addFirst "Burns" ; officers.addFirst "Houlihan" ; officers.addFirst "Pierce" ;  CHAPTER 4  Using the LinkedList Class      443   officers.addFirst "McIntyre" ; for  String s : officers      System.out.println s ;  Here the resulting output shows the officers in reverse order:  To insert an object into a specific position into the list, specify the index in the add  method, as in this example:  LinkedList  officers = new LinkedList   ; officers.add "Blake" ; officers.add "Burns" ; officers.add "Houlihan" ; officers.add "Pierce" ; officers.add "McIntyre" ; officers.add 2, "Tuttle" ; for  String s : officers      System.out.println s ;  The console output from these statements is this:  McIntyre Pierce Houlihan Burns Blake  Blake Burns Tuttle Houlihan Pierce McIntyre   In case you’re not a M*A*S*H fan, Tuttle was a fictitious officer that Hawkeye  and Trapper made up in one episode so that they could collect his paychecks and  donate the money to the local orphanage. Unfortunately, the ruse got out of hand.  When  Tuttle  won  a  medal,  and  a  general  wanted  to  present  it  in  person,  they  arranged for “Tuttle” to “die” in an unfortunate helicopter accident.   Here are some other thoughts to consider when you ponder how to add elements  to linked lists:   » If you specified a type for the list when you created it, the items you add must   be of the correct type. The compiler kvetches if they aren’t.  444      BOOK 4  Strings, Arrays, and Collections   Retrieving Items from a LinkedList   » Like arrays and everything else in Java, linked lists are indexed starting with zero.  » If you specify an index that doesn’t exist, the add method throws   IndexOutOfBoundsException. This is an unchecked exception, so you don’t  have to handle it.   » LinkedList also has weird methods named offer, offerFirst, and   offerLast. The offer method adds an item to the end of the list and has a  return type of boolean, but it always returns true. The offer method is  defined by the Queue interface, which LinkedList implements. Some classes  that implement Queue can refuse to accept an object added to the list via  offer. In that case, the offer method returns false. But because a linked  list never runs out of room, the offer method always returns true to indicate  that the object offered to the list was accepted.  As with the ArrayList class, you can use the get method to retrieve an item based  on its index. If you pass it an invalid index number, the get method throws the  unchecked IndexOutOfBoundsException.  You can also use an enhanced for loop to retrieve all the items in the linked list.  The examples in the preceding section use this enhanced  for loop to print the  contents of the officers linked list:  for  String s : officers      System.out.println s ;  If  you  want,  you  can  also  use  the  iterator  method  to  get  an  iterator  that  can  access the list.  For more information about iterators, refer to Book 4, Chapter 3.   The LinkedList class also has a variety of other methods that retrieve items from  the  list.  Some  of  these  methods  remove  the  items  as  they  are  retrieved;  some  throw exceptions if the list is empty; others return null.  Nine methods retrieve the first item in the list:   » getFirst: Retrieves the first item from the list. This method doesn’t delete   the item. If the list is empty, NoSuchElement-Exception is thrown.   » element: Identical to the getFirst method. This strangely named method  exists because it’s defined by the Queue interface, and the LinkedList class  implements Queue.  CHAPTER 4  Using the LinkedList Class      445    » peek: Similar to getFirst but doesn’t throw an exception if the list is empty.  Instead, it just returns null.  The Queue interface also defines this method.   » peekFirst: Identical to peek. Only the name of the method is changed to   protect the innocent.   » remove: Similar to getFirst but also removes the item from the list. If the list   is empty, it throws NoSuchElementException.   » removeFirst: Identical to remove. If the list is empty, it throws   NoSuchElementException.   » poll: Similar to removeFirst but returns null if the list is empty.  This   method is yet another method that the Queue interface defines.    » pollFirst: Identical to poll  well, identical except for the name of the method .  » pop: Identical to removeFirst  but with a catchier name .  Four methods also retrieve the last item in the list:   » getLast: Retrieves the last item from the list. This method doesn’t delete the   item. If the list is empty, NoSuchElement-Exception is thrown.   » peekLast: Similar to getLast but doesn’t throw an exception if the list is   empty. Instead, it just returns null.   » removeLast: Similar to getLast but also removes the item. If the list is empty,   it throws NoSuchElementException.   » pollLast: Similar to removeLast but returns null if the list is empty.  Updating LinkedList Items  As with the ArrayList class, you can use the set method to replace an object in  a linked list with another object. In that M*A*S*H episode in which Hawkeye and  Trapper made up Captain Tuttle, they quickly found a replacement for him when  he died in that unfortunate helicopter accident. Here’s how Java implements that  episode:  LinkedList  officers = new LinkedList   ;    add the original officers officers.add "Blake" ; officers.add "Burns" ; officers.add "Tuttle" ;  446      BOOK 4  Strings, Arrays, and Collections   Removing LinkedList Items  officers.add "Houlihan" ; officers.add "Pierce" ; officers.add "McIntyre" ; System.out.println officers ;    replace Tuttle with Murdock officers.set 2, "Murdock" ; System.out.println "\nTuttle is replaced:" ; System.out.println officers ;  The output from this code looks like this:  [Blake, Burns, Tuttle, Houlihan, Pierce, McIntyre] Tuttle is replaced: [Blake, Burns, Murdock, Houlihan, Pierce, McIntyre]  As with an ArrayList, any changes you make to an object retrieved from a linked  list are automatically reflected in the list. That’s because the list contains refer- ences  to  objects,  not  the  objects  themselves.   For  more  information  about  this  issue, refer to Book 4, Chapter 3.   You’ve already seen that several of the methods that retrieve items from a linked  list  also  remove  the  items.  In  particular,  the  remove,  removeFirst,  and  poll  methods remove the first item from the list, and the removeLast method removes  the last item.  You can also remove any arbitrary item by specifying either its index number or  a reference to the object you want to remove on the remove method. To remove  item 3, for example, use a statement like this:  officers.remove 3 ;  If  you  have  a  reference  to  the  item  that  you  want  to  remove,  use  the  remove  method, like this:  officers.remove tuttle ;  To remove all the items from the list, use the clear method:  officers.clear  ;         Goodbye, Farewell, and Amen.  CHAPTER 4  Using the LinkedList Class      447    IN THIS CHAPTER  » Discovering why the generics feature   was invented   » Using generics in your own classes   » Working with wildcards in a generic   class   » Examining a pair of classes that   demonstrate generics  Chapter 5 Creating Generic  Collection Classes  In the previous two chapters, you’ve seen how you can specify the type for an   ArrayList or a LinkedList so the compiler can prevent you from accidentally  adding the wrong type of data to the collection. The ArrayList and LinkedList  classes  can  do  this  because  they  take  advantage  of  a  feature  called  generics.  Generics first became available in Java 1.5.  In this chapter, I show you how the generics feature works and how to put it to  use in your own classes. Specifically, you see examples of two classes that use the  LinkedList class to implement a specific kind of collection. The first is a stack, a  collection in which items are always added to the front of the list and retrieved  from the front of the list. The second is a queue, a collection in which items are  added to the end of the list and retrieved from the front.  This is one of those chapters where the entire chapter could get a Technical Stuff  icon. Frankly, generics is on the leading edge of object-oriented programming.  You can get by without knowing any of the information in this chapter, so feel  free  to  skip  it  if  you’re  on  your  way  to  something  more  interesting.  However,  this chapter is worth looking at, even if you just want to get an idea of how the  ArrayList and LinkedList classes use the new generics feature. And you might  find that someday you want to create your own generic classes. Your friends will  surely think you’re a genius.  CHAPTER 5  Creating Generic Collection Classes      449   To be sure, I won’t be covering all the intricacies of programming with generics.  If your next job happens to be writing Java class libraries for Oracle, you’ll need to  know a lot more about generics than this chapter covers. I focus just on the basics  of writing simple generic classes.  Why Generics?  Before Java 1.5, collection classes could hold any type of object. For example, the  add method for the ArrayList class had this declaration:  public boolean add Object o  {        code to implement the add method }  Thus, you could pass any type of object to the add method — and the array list  gladly accepted it.  When you retrieved an item from a collection, you had to cast it to the correct  object type before you could do anything with it. For example, if you had an array  list named empList with Employee objects, you’d use a statement like this one to  get the first Employee from the list:  Employee e =  Employee empList.get 0 ;  The trouble is, what if the first item in the list isn’t an Employee? Because the add  method accepts any type of object, there was no way to guarantee that only certain  types of objects could be added to the collection.  That’s why generics were invented. Now you can declare the ArrayList like this:  ArrayList  empList = new ArrayList   ;  Here empList is declared as an ArrayList that can hold only Employee types. Now  the add method has a declaration that is the equivalent of this:  public boolean add Employee o  {        code to implement the add method }  450      BOOK 4  Strings, Arrays, and Collections   Creating a Generic Class  Thus you can only add  Employee objects to the list. And the  get method has a  declaration that’s equivalent to this:  public Employee get int index  {        code to implement the get method }  Thus the get method returns Employee objects. You don’t have to cast the result  to an Employee because the compiler already knows the object is an Employee.  Generics let you create classes that can be used for any type specified by the pro- grammer  at  compile  time.  To  accomplish  that,  the  Java  designers  introduced  a  new feature to the language, called formal type parameters. To create a class that  uses a formal type parameter, you list the type parameter after the class name  in  angle  brackets.  The  type  parameter  has  a  name  —  Oracle  recommends  you  use single uppercase letters for type parameter names — that you can then use  throughout the class anywhere you’d otherwise use a type.  For  example,  here’s  a  simplified  version  of  the  class  declaration  for  the  Array  List class:  public class ArrayList   I left out the extends and implements clauses to focus on the formal type param- eter:  . The E parameter specifies the type of the elements that are stored in the  list. Oracle recommends the type parameter name E  for Element  for any param- eter that specifies element types in a collection.  So consider this statement:  ArrayList  empList;  Here the E parameter is Employee, which simply means that the element type for  this instance of the ArrayList class is Employee.  CHAPTER 5  Creating Generic Collection Classes      451   Now take a look at the declaration for the add method for the ArrayList class:  public boolean add E o  {       body of method omitted  thank you  }  Where you normally expect to see a parameter type, you see the letter E. Thus, this  method declaration specifies that the type for the o parameter is the type specified  for the formal type parameter E. If E is Employee, that means the add method only  accepts Employee objects.  So far, so good. Now take a look at how you can use a formal type parameter as a  return type. Here’s the declaration for the get method:  public E get int index  {        body of method omitted  you're welcome  }  Here  E  is  specified  as  the  return  type.  That  means  that  if  E  is  Employee,  this  method returns Employee objects.  One final technique you need to know before moving on: You can use the formal  type parameter within your class to create objects of any other class that accepts  formal type parameters. For example, the clone method of the ArrayList class  is written like this:  public Object clone   {     try     {         ArrayList  v =  ArrayList   super.clone  ;         v.elementData =  E[] new Object[size];         System.arraycopy elementData, 0,             v.elementData, 0, size ;         v.modCount = 0;         return v;     }     catch  CloneNotSupportedException e      {            this shouldn't happen since we're Cloneable         throw new InternalError  ;     } }  452      BOOK 4  Strings, Arrays, and Collections   A Generic Stack Class  You don’t need to look much at the details in this method; just notice that the first  statement in the try block declares an ArrayList of type  . In other words, the  ArrayList class uses its own formal type parameter to create another array list  object of the same type. If you think about it, that makes perfect sense. After all,  that’s what the clone method does: It creates another array list just like this one.  The key benefit of generics is that this typing happens at compile time. Thus, after  you specify the value of a formal type parameter, the compiler knows how to do  the type checking implied by the parameter. That’s how it knows not to let you  add String objects to an Employee collection.  Now that you’ve seen the basics of creating generic classes, in this section you  look at a simple generic class that implements a stack. A stack is a simple type of  collection that lets you add objects to the top of the collection and remove them  from the top. I name this  Stack class in this  section  GenStack, and it has five  methods:   » push: This method adds an object to the top of the stack.  » pop: This method retrieves the top item from the stack. The item is removed  from the stack in the process. If the stack is empty, this method returns null.  » peek: This method lets you peek at the top item on the stack. In other words,   it returns the top item without removing it. If the stack is empty, it returns  null.   » hasItems: This method returns a boolean value of true if the stack has at    » size: This method returns an int value that indicates how many items are in   least one item in it.  the stack.  The GenStack class uses a LinkedList to implement the stack. For the most part,  this  class  simply  exposes  the  various  methods  of  the  LinkedList  class  using  names that are more appropriate for a stack. The complete code for the GenStack  class is shown in Listing 5-1.  CHAPTER 5  Creating Generic Collection Classes      453   LISTING 5-1:   The GenStack Class  import java.util.*;  public class GenStack   {     private LinkedList  list = new LinkedList   ;       public void push E item       {         list.addFirst item ;     }      public E pop        {         return list.poll  ;     }      public E peek        {         return list.peek  ;     }      public boolean hasItems        {         return !list.isEmpty  ;     }      public int size        {         return list.size  ;     } }  →3  →5  →7  →12  →17  →22  →27  The following paragraphs highlight the important details in this class: →3         The class declaration specifies the formal type parameter  . Thus   users of this class can specify the type for the stack’s elements.   →5         This class uses a private LinkedList object list to keep the items stored   in the stack. The LinkedList is declared with the same type as the  GenStack class itself. Thus, if the E type parameter is Employee, the type  for this LinkedList is Employee.  454      BOOK 4  Strings, Arrays, and Collections    →7         The push method accepts a parameter of type E. It uses the linked list’s   addFirst method to add the item to the beginning of the list.   →12      The pop method returns a value of type E. It uses the linked list’s poll  method, which removes and returns the first element in the linked list.  If the list is empty, the poll method — and therefore the pop method —  returns null.   →17      The peek method also returns a value of type E. It simply returns the   result of the linked list’s peek method.   →22      The hasItems method returns the opposite of the linked list’s isEmpty   method.  →27      The size method simply returns the result of the linked list’s size method.  That’s all there is to it. The following program gives the GenStack class a little  workout to make sure it functions properly:  public class GenStackTest {     public static void main String[] args      {         GenStack  gs = new GenStack   ;          System.out.println              "Pushing four items onto the stack." ;         gs.push "One" ;         gs.push "Two" ;         gs.push "Three" ;         gs.push "Four" ;          System.out.println "There are "             + gs.size   + " items in the stack.\n" ;          System.out.println "The top item is: "             +gs.peek   + "\n" ;          System.out.println "There are still "             + gs.size   + " items in the stack.\n" ;          System.out.println "Popping everything:" ;         while  gs.hasItems                System.out.println gs.pop   ;  CHAPTER 5  Creating Generic Collection Classes      455           System.out.println "There are now "             + gs.size   + " items in the stack.\n" ;          System.out.println "The top item is: "             +gs.peek   + "\n" ;      } }  This  program  creates  a  GenStack  object  that  can  hold  String  objects.  It  then  pushes four strings onto the stack and prints the number of items in the stack.  Next, it uses the peek method to print the top item and again prints the number of  items in the stack, just to make sure the peek method doesn’t accidentally remove  the item. Next, it uses a while loop to pop each item off the stack and print it.  Then, once again, it prints the number of items  which should now be zero , and  it peeks at the top item  which should be null .  Here’s the output that results when you run this program:  Pushing four items onto the stack. There are 4 items in the stack.  The top item is: Four  There are still 4 items in the stack.  Popping everything: Four Three Two One There are now 0 items in the stack.  The top item is: null  Notice  that  when  the  program  pops  the  items  off  the  stack,  they  come  out  in  reverse order in which they were pushed onto the stack. That’s normal behavior  for stacks. In fact, stacks are sometimes called Last-In, First-Out lists, or LIFO lists,  for this very reason.  456      BOOK 4  Strings, Arrays, and Collections   Using Wildcard-Type Parameters  Suppose you have a method that’s declared like this:  public void addItems ArrayList  list  {        body of method not shown }  Thought question: Does the following statement compile?  addItems new ArrayList    ;  Answer: Nope.  That’s surprising because String is a subtype of Object. So you’d think that a  parameter that says it accepts an ArrayList of objects accepts an ArrayList of  strings.  Unfortunately,  inheritance  doesn’t  work  quite  that  way  when  it  comes  to  for- mal type parameters. Instead, you have to use another feature of generics, called  wildcards.  In short, if you want to create a method that accepts any type of ArrayList, you  have to code the method like this:  public void addItems ArrayList  list   In this case, the question mark indicates that you can code any kind of type here.  That’s almost as good as inheritance, but what if you want to actually limit the  parameter  to  collections  of  a  specific  superclass?  For  example,  suppose  you’re  working on a payroll system that has an Employee superclass with two subclasses  named  HourlyEmployee  and  SalariedEmployee,  and  you  want  this  method  to  accept an ArrayList of Employee objects, HourlyEmployee objects, or Salaried  Employee objects?  In that case, you can add an extends clause to the wildcard, like this:  public void addItems ArrayList  list   Then  you  can  call  the  addItems  method  with  an  ArrayList  of  type  Employee,  HourlyEmployee, or SalariedEmployee.  CHAPTER 5  Creating Generic Collection Classes      457   A Generic Queue Class  Now, before you call it a day, take this example one step further: Suppose this  addItems method appears in a generic class that uses a formal type parameter    to specify the type of elements the class accepts, and you want the addItems  method to accept an ArrayList of type E or any of its subclasses. To do that, you’d  declare the addItems method like this:  public void addItems ArrayList  list   Here the wildcard type parameter   simply means that the Array  List can be of type E or any type that extends E.  Now that you’ve seen how to use wildcards in a generic class, this section pres- ents a generic class that implements a queue. A queue is another type of collection  that lets you add objects to the end of the collection and remove them from the  top. Queues are commonly used in all sorts of applications, from data processing  applications to sophisticated networking systems.  This queue class is named GenQueue and has the following methods:   » enqueue: This method adds an object to the end of the queue.  » dequeue: This method retrieves the first item from the queue. The item is  removed from the queue in the process. If the queue is empty, this method  returns null.   » hasItems: This method returns a boolean value of true if the queue has at   least one item in it.  the stack.   » size: This method returns an int value that indicates how many items are in    » addItems: This method accepts another GenQueue object as a parameter. All  the items in that queue are added to this queue. In the process, all the items  from the queue passed to the method are removed. The GenQueue parameter  must be of the same type as this queue or a subtype of this queue’s type.  The GenQueue class uses a LinkedList to implement its queue. The complete code  for the GenQueue class is shown in Listing 5-2.  458      BOOK 4  Strings, Arrays, and Collections   LISTING 5-2:   The GenQueue Class  import java.util.*;  public class GenQueue   {     private LinkedList  list = new LinkedList   ;       public void enqueue E item       {         list.addLast item ;     }      public E dequeue        {         return list.poll  ;     }      public boolean hasItems        {         return !list.isEmpty  ;     }      public int size        {         return list.size  ;     }  →3  →5  →7  →12  →a17  →a22  →a27      public void addItems GenQueue  q       {         while  q.hasItems                list.addLast q.dequeue   ;     } }  The following paragraphs point out the highlights of this class: →3        The class declaration specifies the formal type parameter  . Thus,  users of this class can specify the type for the elements of the queue.   →5        Like the GenStack class, this class uses a private LinkedList object list   to keep its items.   →7        The enqueue method accepts a parameter of type E. It uses the linked   list’s addLast method to add the item to the end of the queue.  CHAPTER 5  Creating Generic Collection Classes      459    →12      The dequeue method returns a value of type E. Like the pop method of  the GenStack class, this method uses the linked list’s poll method to  return the first item in the list.   →17      The hasItems method returns the opposite of the linked list’s isEmpty   method.   →22      The size method returns the result of the linked list’s size method.  →27      The addItems method accepts a parameter that must be another  GenQueue object whose element type is either the same type as this  GenQueue object’s elements or a subtype of this GenQueue object’s   element type. This method uses a while loop to remove all the items  from the q parameter and add them to this queue.  The following program exercises the GenQueue class:  public class GenQueueTest {     public static void main String[] args      {         GenQueue  empList;         empList = new GenQueue   ;          GenQueue  hList;         hList = new GenQueue   ;         hList.enqueue new HourlyEmployee              "Trump", "Donald"  ;         hList.enqueue new HourlyEmployee              "Gates", "Bill"  ;         hList.enqueue new HourlyEmployee              "Forbes", "Steve"  ;          empList.addItems hList ;          while  empList.hasItems            {             Employee emp = empList.dequeue  ;             System.out.println emp.firstName                 + " " + emp.lastName ;         }     } } class Employee {  460      BOOK 4  Strings, Arrays, and Collections       public String lastName;     public String firstName;      public Employee   {}      public Employee String last, String first      {         this.lastName = last;         this.firstName = first;     }     public String toString       {         return firstName + " " + lastName;     } } class HourlyEmployee extends Employee {     public double hourlyRate;      public HourlyEmployee String last, String first      {         super last, first ;     } }  This program begins by creating a GenQueue object that can hold Employee objects.  This queue is assigned to a variable named empList.  Next,  the  program  creates  another  GenQueue  object.  This  one  can  hold  HourlyEmployee  objects   HourlyEmployee  is  a  subclass  of  Employee   and  is  assigned to a variable named hList.  Then  three  rookie  employees  are  created  and  added  to  the  hList  queue.  The  addItems method of the empList queue is then called to transfer these employees  from the hList queue to the empList queue. Because HourlyEmployee is a sub- class of Employee, the addItems method of the empList queue accepts hList as a  parameter.  Finally, a while loop is used to print the employees that are now in the empList  queue.  CHAPTER 5  Creating Generic Collection Classes      461   When this program is run, the following is printed on the console:  Donald Trump Bill Gates Steve Forbes  Thus the addItems method successfully transferred the employees from the hlist  queue, which held  HourlyEmployee objects, to the  empList queue, which holds  Employee objects.  Using the Diamond Operator  One of the more annoying things about working with generics is that you have to  specify the types twice when you create a variable of a generic type, and then use  the constructor to instantiate an object. For example, to create an ArrayList of  type String, you must code this:  ArrayList  nums = new ArrayList   ;  Here the type String must be specified twice: once in the type declaration for the  variable, and again in the call to the constructor.  Java 7 introduced a new feature called the diamond operator that lets you skip the  type when you call the constructor, like this:  ArrayList  nums = new ArrayList   ;  Here’s another example:  ArrayList  nums; nums = new ArrayList   ;  The  diamond  operator  simply  deduces  the  correct  type  based  on  the  variable’s  type.  462      BOOK 4  Strings, Arrays, and Collections   IN THIS CHAPTER  » Understanding basic stream   operations   » Examining the stream interface   » Filtering and sorting streams   » Computing sums, averages, and other   values  Chapter 6 Using Bulk Data  Operations with  Collections  One of the most common things to do with a collection is to iterate over it,   performing some type of operation on all of its elements. For example,  you might use a foreach loop to print all of the elements. The body of the  foreach loop might contain an if statement to select which elements to print. Or  it might perform a calculation such as accumulating a grand total or counting the  number of elements that meet a given condition.  In Java, foreach loops are easy to create and can be very powerful. However, they  have one significant drawback: They iterate over the collection’s elements one at  a time, beginning with the first element and proceeding sequentially to the last  element. As a result, a foreach loop must be executed sequentially within a single  tread.  That’s a shame, since modern computers have multicore processors that are capable  of doing several things at once. Wouldn’t it be great if you could divide a foreach  loop into several parts, each of which can be run independently on one of the proces- sor cores? For a small collection, the user probably wouldn’t notice the difference.  But if the collection is extremely large  say, a few million elements , unleashing the  power of a multicore processor could make the program run much faster.  CHAPTER 6  Using Bulk Data Operations with Collections      463   While you can do that with earlier versions of Java, the programming is tricky. You  have to master one of the more difficult aspects of programming in Java: working  with threads, which are like separate sections of your program that can be exe- cuted simultaneously. You’ll learn the basics of working with threads in Book 5,   Chapter 1. For now, take my word for it: Writing programs that work with large  collections of data and take advantage of multiple threads was a difficult under- taking. At least until Java 8.  With Java 8 or later, you can use a feature called bulk data operations that’s designed  specifically to attack this very problem. When you use bulk data operations, you  do not directly iterate over the collection data using a foreach loop. Instead, you  simply provide the operations that will be done on each of the collection’s ele- ments and let Java take care of the messy details required to spread the work over  multiple threads.  At the heart of the bulk data operations feature is a new type of object called a  stream, defined by the stream interface. A stream is simply a sequence of elements  of any data type which can be processed sequentially or in parallel. The stream  interface provides methods that let you perform various operations such as filter- ing the elements or performing an operation on each of the elements.  Don’t confuse the type of stream I describe in this chapter with the file streams  that are described in Book 8, Chapter 2. File streams are used to read and write  data to disk files. The streams described in this chapter are used to process data  extracted from collection classes.  Streams  rely  on  the  use  of  lambda  expressions  to  pass  the  operations  that  are   performed  on  stream  elements.  In  fact,  the  primary  reason  Java’s  developers  introduced lambda expressions into the Java language was to facilitate streams.  If you haven’t yet read Book 3, Chapter 7, I suggest you do so now, before reading  further into this chapter. Otherwise you’ll find yourself hopelessly confused by  the peculiar syntax of the lambda expressions used throughout this chapter.  In this chapter, you learn the basics of using streams to perform simple bulk data  operations.  Looking At a Basic Bulk Data Operation  Suppose you have a list of spells used by a certain wizard who, for copyright pur- poses, we’ll refer to simply as HP. The spells are represented by a class named  Spell, which is defined as follows:  464      BOOK 4  Strings, Arrays, and Collections   public class Spell {     public String name;     public SpellType type;     public String description;      public enum SpellType {SPELL, CHARM, CURSE}      public Spell String spellName, SpellType spellType,         String spellDescription      {         name = spellName;         type = spellType;         description = spellDescription;     }      public String toString       {         return name;     } }  As you can see, the Spell class has three public fields that represent the spell’s  name, type  SPELL, CHARM, or CURSE , and description, as well as a constructor that  lets you specify the name, type, and description for the spell. Also, the toString    method is overridden to return simply the spell name.  Let’s load a few of HP’s spells into an ArrayList:  ArrayList  spells = new ArrayList   ; spells.add new Spell "Aparecium", Spell.SpellType.SPELL,     "Makes invisible ink appear."  ; spells.add new Spell "Avis", Spell.SpellType.SPELL,     "Launches birds from your wand."  ; spells.add new Spell "Engorgio", Spell.SpellType.CHARM,     "Enlarges something."  ; spells.add new Spell "Fidelius", Spell.SpellType.CHARM,     "Hides a secret within someone."  ; spells.add new Spell "Finite Incatatum", Spell.SpellType.SPELL,     "Stops all current spells."  ; spells.add new Spell "Locomotor Mortis", Spell.SpellType.CURSE,     "Locks an opponent's legs."  ;  CHAPTER 6  Using Bulk Data Operations with Collections      465   Now, suppose you want to list the name of each spell on the console. You could do  that using a foreach loop like this:  for  Spell spell : spells      System.out.println spell.name ;  The equivalent code using the streams looks like this:  spells.stream  .forEach s -> System.out.println s  ;  Here, I first use the stream method of the ArrayList class to convert the ArrayL- ist to a stream. All of the classes that inherit from java.Collection implement  a stream method that returns a Stream object. That includes not only ArrayList,  but also LinkedList and Stack.  Next, I use the stream’s forEach method to iterate the stream, passing a lambda  expression  that  calls  System.out.println  for  each  item  in  the  stream.  The  forEach method processes the entire stream, writing each element to the console.  Suppose you want to list just the spells, not the charms or curses. Using a tradi- tional foreach loop, you’d do it like this:  for  Spell spell : spells  {     if  spell.type == Spell.SpellType.SPELL          System.out.println spell.name ; }  Here an if statement selects just the spells so that the charms and curses aren’t  listed.  Here’s the same thing using streams:  spells.stream       .filter s -> s.type == Spell.SpellType.SPELL      .forEach s -> System.out.println s  ;  In this example, the stream method converts the ArrayList to a stream. Then  the stream’s filter method is used to select just the SPELL items. Finally, the  forEach  method  sends  the  selected  items  to  the  console.  Notice  that  lambda  expressions are used in both the forEach method and the filter method.  466      BOOK 4  Strings, Arrays, and Collections   Looking Closer at the Stream Interface  The filter method of the Stream class returns a Stream object. Thus, it is pos- sible to apply a second filter to the result of the first filter, like this:  spells.parallelStream       .filter s -> s.type == Spell.SpellType.SPELL      .filter s -> s.name.toLowerCase  .startsWith "a"       .forEach s -> System.out.println s  ;  In this example, just the spells that start with the letter A are listed.  The term pipeline is often used to describe a sequence of method calls that start by  creating a stream, then manipulate the stream in various ways by calling methods  such as filter, and finally end by calling a method that does not return another  stream object, such as forEach.  The  Stream  interface  defines  about  40  methods.  In  addition,  three  related  interfaces —  DoubleStream,  IntStream, and  LongStream — extend the  Stream  interface to define operations that are specific to a single date type: double, int,  and long. Table 6-1 lists the most commonly used methods of these interfaces.  The first group of methods in Table 6-1 define methods that return other Stream  objects. Each of these methods manipulates the stream in some way, then passes  the altered stream down the pipeline to be processed by another operation.  The filter method is one of the most commonly used stream methods. It’s argu- ment, called a predicate, is a function that returns a boolean value. The function is  called once for every element in the stream and is passed a single argument that  contains the element under question. If the method returns true, the element is  passed on to the result stream. If it returns false, the element is not passed on.  The easiest way to implement a filter predicate is to use a lambda expression that  specifies a conditional expression. For example, the following lambda expression  inspects the name field of the stream element and returns true if it begins with  the letter a  upper- or lowercase :  s -> s.name.toLowerCase  .startsWith "a"   The other methods in the first group let you limit the number of elements in a  stream or sort the elements of the stream. To sort a stream, you can use either the  element’s natural sorting order, or you can supply your own comparator function.  CHAPTER 6  Using Bulk Data Operations with Collections      467   The  second  group  of  methods  in  Table  6-1  are  called  mapping methods  because  they convert a stream whose elements are of one type to a stream whose elements  are of another type. The mapping function, which you must pass as a parameter,  is responsible for converting the data from the first type to the second.  TABLE 6-1	  The Stream and Related Interfaces  Methods that Return Streams  Explanation  Stream distinct    Stream limit long maxSize   Returns a stream consisting of distinct elements of the input  stream. In other words, duplicates are removed.  Returns a stream having no more than maxSize elements  derived from the input stream.  Stream filter Predicate<? super  T> predicate   Returns a stream consisting of those elements in the input  stream that match the conditions of the predicate.  Stream sorted    Stream sorted Comparator<? super  T> comparator   Returns the stream elements in sorted order using the natural  sorting method for the stream’s data type.  Returns the stream elements in sorted order using the  specified Comparator function. The Comparator function  accepts two parameters and returns a negative value if the  first is less than the second, zero if they are equal, and a  positive value if the first is greater than the second.  Mapping Methods  Explanation    Stream  map Function<?  super T,? extends R> mapper  Returns a stream created by applying the mapper function to  each element of the input stream.  DoubleStream  mapToDouble ToDoubleFunction<?  super T> mapper   IntStream  mapToInt ToIntFunction<? super  T> mapper   LongStream  mapToLong ToLongFunction<? super  T> mapper   Returns a DoubleStream created by applying the mapper  function to each element of the input stream.  Returns an IntStream created by applying the mapper  function to each element of the input stream.  Returns a LongStream created by applying the mapper  function to each element of the input stream.  Terminal and Aggregate Methods  Explanation  void forEach Consumer<? super  T> action   void forEachOrdered  Consumer<?  super T> action   Executes the action against each element of the input stream.  Executes the action against each element of the input  stream, ensuring that the elements of the input stream are  processed in order.  468      BOOK 4  Strings, Arrays, and Collections   Methods that Return Streams  Explanation  long count    Returns the number of elements in the stream.  Optional  max Comparator<?  super T> comparator   Optional  min Comparator<?  super T> comparator   OptionalDouble average    resultType sum    resultType summaryStatistics    Returns the largest element in the stream.  Returns the smallest element in the stream.  Returns the average value of the elements in the stream. Valid  only for DoubleStream, IntStream, and Longstream.  Returns the sum of the elements in the stream. Result type is  double for DoubleStream, int for IntStream, and long for  LongStream.  Returns a summary statistics object that includes property  methods named getCount, getSum, getAverage, getMax,  and getMmin of the elements in the stream. The result  type is IntSummaryStatistics for an IntStream,  DoubleSummaryStatistics for a DoubleStream, and  LongSummaryStatistics for a LongStream.  One common use for mapping methods is to convert a stream of complex types  to  a  stream  of  simple  numeric  values  of  type  double,  int,  or  long,  which  you  can  then  use  to  perform  an  aggregate  calculation  such  as  sum  or  average.  For  example, suppose HP’s spells were for sale and the Spell class included a public  field named price. To calculate the average price of all the spells, you would first  have to convert the stream of Spell objects to a stream of doubles. To do that,  you use the mapToDouble method. The mapping function would simply return the  price field:  .mapToDouble s -> s.price   Methods in the last group in Table 6-1 are called terminal methods because they do  not return another stream. As a result, they are always the last methods called in  stream pipelines.  You have already seen the forEach method in action; it provides a function that  is called once for each element in the stream. Note that in the examples so far,  the function to be executed on each element has consisted of just a single method  call, so I’ve included it directly in the lambda expression. If the function is more  complicated, you can isolate it in its own method. Then the lambda expression  should call the method that defines the function.  Aggregate methods perform a calculation on all of the elements in the stream,  then  return  the  result.  Of  the  aggregate  methods,  count  is  straightforward:  It   CHAPTER 6  Using Bulk Data Operations with Collections      469   simply returns the number of elements in the stream. The other aggregate meth- ods need a little explanation because they return an optional data type. An optional  data type is an object that might contain a value, or it might not.  For example, the average method calculates the average value of a stream of inte- gers, longs, or doubles and returns the result as an OptionalDouble. If the stream  was empty, the average is undefined, so the OptionalDouble contains no value.  You can determine if the OptionalDouble contains a value by calling its isPre- sent method, which returns true if there is a value present. If there is a value, you  can get it by calling the getAsDouble method.  Note  that  getAsDouble  will  throw  an  exception  if  no  value  is  present,  so  you  should always call isPresent before you call getAsDouble.  Here’s an example that calculates the average price of spells:  OptionalDouble avg = spells.stream               .mapToDouble s -> s.price              .average  ;  Here is how you would write the average price to the console:  if  avg.isPresent    {     System.out.println "Average = "         + avg.getAsDouble   ; }  Using Parallel Streams  Streams come in two basic flavors: sequential and parallel. Elements in a sequential  stream are produced by the stream method and create streams that are processed  one element after the next. Parallel streams, in contrast, can take full advantage of  multicore processors by breaking its elements into two or more smaller streams,  performing operations on them, and then recombining the separate streams to  create the final result stream. Each of the intermediate streams can be processed  by a separate thread, which can improve performance for large streams.  By default, streams are sequential. But creating a parallel stream is easy: Just use  the  parallelStream method instead of the  stream method at the beginning of  the pipeline.  470      BOOK 4  Strings, Arrays, and Collections   For example, to print all of HP’s spells using a parallel stream, use this code:  spells.parallelStream       .forEach s -> System.out.println s  ;  Note that when you use a parallel stream, you can’t predict the order in which  each element of the stream is processed. That’s because when the stream is split  and run on two or more threads, the order in which the processor executes the  threads is not predictable.  To demonstrate this point, consider this simple example:  System.out.println "First Parallel stream: " ; spells.parallelStream       .forEach s -> System.out.println s  ; System.out.println "\nSecond Parallel stream: " ; spells.parallelStream       .forEach s -> System.out.println s  ;  When you execute this code, the results will look something like this:  First parallel stream: Fidelius Finite Incatatum Engorgio Locomotor Mortis Aparecium  Avis Second parallel stream: Fidelius Engorgio Finite Incatatum Locomotor Mortis Avis Aparecium  Notice that although the same spells are printed for each of the streams, they are  printed in a different order.  CHAPTER 6  Using Bulk Data Operations with Collections      471    Programming  Techniques  5   Contents at a Glance  CHAPTER 1:  Programming Threads  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 475 CHAPTER 2:  Using Regular Expressions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 505 CHAPTER 3:  Using Recursion .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 523 CHAPTER 4:	 Working	with	Dates	and Times  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 539   IN THIS CHAPTER  » Examining threads   » Creating threads from the Thread   class   » Working with the Runnable interface   » Creating threads that cooperate   » Executing threads   » Making methods cooperate   » Using a lock   » Interrupting threads  Chapter 1 Programming Threads  Remember the guy from the old Ed Sullivan Show who used to spin plates?   Somehow, he managed to keep all those plates spinning, running from pole  to pole to give each plate a little nudge — just enough to keep it going.  In Java, threads are the equivalent of the spinning-plate guy. Threads let you divide  the work of an application into separate pieces, all of which then run simulta- neously.  The  result  is  a  faster  and  more  efficient  program,  but  along  with  the  increased speed come more difficult programming and debugging.  Truthfully,  the  subtleties  of  threaded  programming  are  a  topic  for  computer   science  majors,  but  the  basics  of  working  with  threads  aren’t  all  that  difficult  to  understand.  In  this  chapter,  I  focus  on  those  basics  and  leave  the  advanced   techniques for the grad students.  The main application I use to illustrate threading in this chapter simulates the  countdown  clock  for  the  spacecraft.  Working  with  threads  isn’t  really  rocket   science,  but  threading  is  used  to  solve  difficult  programming  problems.  You  invariably find yourself trying to get two or more separate pieces of code to coor- dinate their activities, and that’s not as easy as you might think at first guess. As a   CHAPTER 1  Programming Threads      475   result, I can’t possibly talk about threading without getting into some challenging  mental exercises, so be prepared to spend some mental energy figuring out how  it works.  The  listings  in  this  chapter,  as  well  as  throughout  the  book,  are  available  at   www.dummies.com go javaaiofd5e.  Understanding Threads  A thread is a single sequence of executable code within a larger program. All the  programs shown so far in this book have used just one thread — the main thread  that starts automatically when you run the program — but Java lets you create  programs that start additional threads to perform specific tasks.  You’re probably familiar with programs that use threads to perform several tasks  at the same time. Here are some common examples:   » Web browsers can download files while letting you view web pages. When you   download a file in a web browser, the browser starts a separate thread to  handle the download.   » Email programs don’t make you wait for all your messages to download   before you can read the first message. Instead, these programs use separate  threads to display and download messages.   » Word processors can print long documents in the background while you  continue to work. These programs start a separate thread to handle print  jobs.   » Word processors can also check your spelling as you type. Depending on how  the word processor is written, it may run the spell check in a separate thread.  » Game programs commonly use several threads to handle different parts of   the game to improve the overall responsiveness of the game.   » All GUI-based programs use at least two threads — one thread to run the   application’s main logic and another thread to monitor mouse and keyboard  events. You find out about creating GUI programs in Java in Book 6.   » Indeed, the Java Virtual Machine itself uses threading for some of its house-  keeping chores. The garbage collector, for example, runs as a separate thread  so it can constantly monitor the state of the VM’s memory and decide when it  needs to create some free memory by removing objects that are no longer  being used.  476      BOOK 5  Programming Techniques   Creating a Thread     s d a e r h T g n m m a r g o r P  i  Suppose you’re developing software for NASA, and you’re in charge of the pro- gram that controls the final 31 seconds of the countdown for a manned space- craft. Your software has to coordinate several key events that occur when the clock  reaches certain points:   » T minus 16 seconds: Flood launch pad. This event releases 350,000 gallons of   water onto the launch pad, which helps protect the spacecraft systems  during launch.   » T minus 6 seconds: Start the main engines. Huge clamps hold the spacecraft   in place while the engines build up thrust.   » T minus 0: Lift off! The clamps are released, and the spacecraft flies into   space.  For this program, I don’t actually start any rocket engines or release huge amounts  of water. Instead, I just display messages on the console to simulate these events.  But I do create four separate threads to make everything work. One thread man- ages the countdown clock. The other three threads fire off their respective events  at T minus 16 seconds  flood the pad , T minus 6 seconds  fire the engines , and  T minus 0  launch .  For the first attempt at this program, I just get the countdown clock up and run- ning. The countdown clock is represented by a class named CountDownClock. All  this class does is count down from 20 to 0 at 1-second intervals, displaying mes- sages such as T minus 20 on the console as it counts. This version of the program  doesn’t do much of anything, but it does demonstrate how to get a thread going.  We’ll start by looking at the Thread class.  Understanding the Thread class  The Thread class lets you create an object that can be run as a thread in a mul- tithreaded  Java  application.  The  Thread  class  has  quite  a  few  constructors  and  methods,  but  for  most  applications,  you  need  to  use  only  the  ones  listed  in  Table 1-1.  Note that this table is here to give you an overview of the Thread class  and to serve as a reference. Don’t worry about the details of each constructor and  method just yet. By the end of this chapter, I explain each of the constructors and  methods.   CHAPTER 1  Programming Threads      477   TABLE 1-1	 Constructor  Thread    Constructors and Methods of the Thread Class  Explanation  Creates an instance of the Thread class. This constructor is the  basic Thread constructor without parameters.  Thread String name   Creates a Thread object and assigns the specified name to  the thread.  Thread Runnable target   Turns any object that implements an API interface called Runnable  into a thread. You see how this more-advanced constructor is used  later in this chapter.  Thread Runnable target,  String name   Creates a thread from any object that implements Runnable and  assigns the specified name to the thread.  static int activeCount    Returns the number of active threads.  static int  enumerate Thread[] t   Fills the specified array with a copy of each active thread. The return  value is the number of threads added to the array.  String getName    int getPriority    void interrupt    Returns the name of the thread.  Returns the thread’s priority.  Interrupts this thread.  boolean isInterrupted    Checks whether the thread has been interrupted.  void  setPriority int priority   Sets the thread’s priority.  void setName String name   Sets the thread’s name.  static void Sleep  void run    void start    static void yield    Causes the currently executing thread  int milliseconds  to  sleep for the specified number of milliseconds.  Is called when the thread is started. Place the code that you want  the thread to execute inside this method.  Starts the thread.  Causes the currently executing thread to yield to other threads that  are waiting to execute.  Extending the Thread class  The easiest way to create a thread is to write a class that extends the Thread class.  Then all you have to do to start a thread is create an instance of your thread class  and call its start method.  478      BOOK 5  Programming Techniques   Listing 1-1 is a version of the CountDownClock class that extends the Thread class.  LISTING	1-1:	  The CountDownClock Class  Version 1   public class CountDownClock extends Thread  {     public void run        {         for  int t = 20; t >= 0; t--           {             System.out.println "T minus " + t ;             try             {                 Thread.sleep 1000 ;              }             catch  InterruptedException e              {}         }     } }  →1  →3  →5  →10     s d a e r h T g n m m a r g o r P  i  Here are a few key points to notice in this class: →1    The CountDownClock class extends the Thread class. Thread is defined  in the java.language package, so you don’t have to provide an import  statement to use it.  →3    The CountDownClock class has a single method, named run. This   method is called by Java when the clock thread has been started. All the  processing done by the thread must either be in the run method or in  some other method called by the run method.  →5   The run method includes a for loop that counts down from 20 to 0. →10   The CountDownClock class uses the sleep method to pause for 1   second. Because the sleep method throws Interrupted Exception, a  try catch statement handles this exception. If the exception is caught, it  is simply ignored.  At some point in its execution, the run method must either call sleep or yield to  give other threads a chance to execute.  CHAPTER 1  Programming Threads      479   Creating and starting a thread  After you define a class that defines a Thread object, you can create and start the  thread. Here’s the main class for the first version of the countdown application:  public class CountDownApp {     public static void main String[] args      {         Thread clock = new CountDownClock  ;         clock.start  ;     } }  Here a variable of type Thread is declared, and an instance of the Count  Down- Clock is created and assigned to it. This creates a Thread object, but the thread  doesn’t begin executing until you call its start method.  When you run this program, the thread starts counting down in 1-second incre- ments, displaying messages such as the following on the console:  T minus 20 T minus 19 T minus 18  And so on, all the way to zero. So far, so good.  Implementing the Runnable Interface  For the threads that trigger specific countdown events such as flooding the launch  pad, starting the events, and lifting off, I create another class called LaunchEvent.  This class uses another technique for creating and starting threads — one that  requires a few more lines of code but is more flexible.  The problem with creating a class that extends the Thread class is that a class can  have one superclass. What if you’d rather have your thread object extend some  other  class?  In  that  case,  you  can  create  a  class  that  implements  the  Runnable  interface rather than extends the Thread class. The Runnable interface marks an  object that can be run as a thread. It has only one method, run, that contains the  code that’s executed in the thread.  The Thread class itself implements Runnable,  which is why the Thread class has a run method.   480      BOOK 5  Programming Techniques   Using the Runnable interface  To  use  the  Runnable  interface  to  create  and  start  a  thread,  you  have  to  do  the  following: 1.  Create a class that implements Runnable. 2.  Provide a run method in the class you created in Step 1. 3.  Create an instance of the Thread class and pass your Runnable object to   its constructor as a parameter.  A Thread object is created that can run your Runnable class.  4.  Call the Thread object’s start method.  The run method of your Runnable object is called and executes in a separate  thread.  The first two of these steps are easy. The trick is in the third and fourth steps,  because you can complete them in several ways. Here’s one way, assuming that  your Runnable class is named RunnableClass:     s d a e r h T g n m m a r g o r P  i  RunnableClass rc = new RunnableClass  ; Thread t = new Thread rc ; t.start  ;  Java  programmers  like  to  be  as  concise  as  possible,  so  you  often  see  this  code  compressed to something more like  Thread t = new Thread new RunnableClass   ; t.start  ;  or even just this: new Thread new RunnableClass   .start  ;  This  single-line  version  works  —  provided  that  you  don’t  need  to  access  the  thread object later in the program.  Creating a class that implements Runnable  To sequence the launch events for the NASA application, I create a Runnable object  named LaunchEvent. The constructor for this class accepts two parameters: the  countdown time at which the event fires and the message that is displayed when  the time arrives. The run method for this class uses Thread.sleep to wait until  the desired time arrives. Then it displays the message.  CHAPTER 1  Programming Threads      481   Listing 1-2 shows the code for this class.  LISTING	1-2:	  The LaunchEvent Class  Version 1   public class LaunchEvent implements Runnable  {     private int start;     private String message;     public LaunchEvent int start, String message       {         this.start = start;         this.message = message;     }     public void run       {         try         {             Thread.sleep 20000 -  start * 1000  ;          }         catch  InterruptedException e          {}         System.out.println message ;      } }  →1  →6  →16  →20  The following paragraphs draw your attention to the listing’s key lines: →1   This class implements the Runnable interface. →6    The constructor accepts two parameters: an integer representing the  start time  in seconds  and a string message that’s displayed when the  time arrives. The constructor simply stores these parameter values in  private fields.  →16   In the run method, the Thread.sleep method is called to put the thread  to sleep until the desired countdown time arrives. The length of time that  the thread should sleep is calculated by the expression 20000 -  start  * 1000 . The countdown clock starts at 20 seconds, which is 20,000  milliseconds. This expression simply subtracts the number of millisec- onds that corresponds to the desired start time from 20,000. Thus, if the  desired start time is 6 seconds, the sleep method sleeps for 14,000  milliseconds — that is, 14 seconds.  →20   When the thread wakes up, it displays the message passed via its   constructor on the console.  482      BOOK 5  Programming Techniques   Using the CountDownApp class  Now that you’ve seen the code for the LaunchEvent and CountDownClock classes,  Listing  1-3 shows  the code for a  CountDownApp class that uses these  classes to  launch a spacecraft.  LISTING	1-3:	  The CountDownApp Class  Version 2   public class CountDownApp {    public static void main String[] args     {       Thread clock = new CountDownClock  ;        Runnable flood, ignition, liftoff;        flood = new LaunchEvent 16, "Flood the pad!" ;       ignition = new LaunchEvent 6, "Start engines!" ;       liftoff = new LaunchEvent 0, "Liftoff!" ;       clock.start  ;        new Thread flood .start  ;        new Thread ignition .start  ;       new Thread liftoff .start  ;    } }  →5 →7  →12 →14     s d a e r h T g n m m a r g o r P  i  The following paragraphs summarize how this program works: →5    The main method starts by creating an instance of the Count DownClock   class and saving it in the clock variable.  →7    Next, it creates three LaunchEvent objects to flood the pad at 16   seconds, start the engines at 6 seconds, and lift off at 0 seconds. These  objects are assigned to variables of type Runnable named flood,  ignition, and liftoff.  →12  The clock thread is started. The countdown starts ticking. →14   Finally, the program starts the three LaunchEvent objects as threads.  It does this by creating a new instance of the Thread class, passing the  LaunchEvent objects as parameters to the Thread constructor, and then  calling the start method to start the thread.       Note that because this program doesn’t need to do anything with these   threads after they’re started, it doesn’t bother creating variables for  them.  CHAPTER 1  Programming Threads      483   When you run this program, output similar to the following is displayed on the  console:  T minus 20 T minus 19 T minus 18 T minus 17 T minus 16 Flood the pad! T minus 15 T minus 14 T minus 13 T minus 12 T minus 11 T minus 10 T minus 9 T minus 8 T minus 7 T minus 6 Start engines! T minus 5 T minus 4 T minus 3 T minus 2 T minus 1 Liftoff! T minus 0  As you can see, the LaunchEvent messages are interspersed with the CountDown  Clock messages. Thus, the launch events are triggered at the correct times.  Note that the exact order in which some of the messages appear may vary slightly.  For example, "Flood the pad!" might sometimes come before "T minus 16."  because of slight variations in the precise timing of these independently operating  threads. Later in this chapter, the section “Creating Threads That Work Together”  shows you how to avoid such inconsistencies.  You can improve the main method for this class by using an ArrayList to store  the Runnable objects. Then you can start all the LaunchEvent threads by using an  enhanced for loop. Here’s what the improved code looks like:  484      BOOK 5  Programming Techniques   public static void main String[] args  {     Thread clock = new CountDownClock  ;     ArrayList  events         = new ArrayList   ;     events.add new LaunchEvent 16, "Flood the pad!"  ;     events.add new LaunchEvent 6, "Start engines!"  ;     events.add new LaunchEvent 0, "Liftoff!"  ;     clock.start  ;     for  Runnable e : events          new Thread e .start  ; }  The advantage of this technique is that you don’t need to create a separate variable  for each  LaunchEvent.  Don’t  forget to add an  import statement  for the  java. util.* to gain access to the ArrayList class.   Creating Threads That Work Together     s d a e r h T g n m m a r g o r P  i  Unfortunately, the countdown application presented in the preceding section has  a major deficiency: The CountDownClock and LaunchEvent threads depend strictly  on timing to coordinate their activities. After these threads start, they run indepen- dently of one another. As a result, random variations in their timings can cause the  thread behaviors to change. If you run the program several times in a row, you’ll  discover that sometimes the Start engines! message appears after the T minus 6  message, and sometimes it appears before the T minus 6 message. That might not  seem like a big deal to you, but it probably would be disastrous for the astronauts  on the spacecraft. What these classes really need is a way to communicate.  Listing 1-4 shows an improved version of the countdown application that incor- porates several enhancements. The CountDownClock class in this version adds a  new method named getTime that gets the current time in the countdown. Then  the LaunchEvent class checks the countdown time every 10 milliseconds and trig- gers the events only when the countdown clock actually says that it’s time. This  version of the application runs consistently.  In  addition,  you  want  to  enable  the  LaunchEvent  class  to  monitor  the  status  of  the  CountDownClock,  but  you  don’t  want  to  couple  the  LaunchEvent  and  CountDownClock  classes  too  closely.  Suppose  that  later,  you  develop  a  better  countdown clock. If the LaunchEvent class knows what class is doing the counting,  you have to recompile it if you use a different countdown class.  CHAPTER 1  Programming Threads      485   The solution is to use an interface as a buffer between the classes. This interface  defines a method that gets the current status of the clock. Then the CountDown  Clock class can implement this interface, and the LaunchEvent class can use any  object that implements this interface to get the time.  LISTING	1-4:	  The Coordinated CountDown Application  import java.util.ArrayList;    version 2.0 of the Countdown application public class CountDownApp {     public static void main String[] args      {         CountDownClock clock = new CountDownClock 20 ;          ArrayList  events =             new ArrayList   ;          events.add new LaunchEvent 16,              "Flood the pad!", clock  ;         events.add new LaunchEvent 6,             "Start engines!", clock  ;         events.add new LaunchEvent 0,             "Liftoff!", clock  ;         clock.start  ;          for  Runnable e : events               new Thread e .start  ;     } } interface TimeMonitor  {     int getTime  ; } class CountDownClock extends Thread     implements TimeMonitor  {     private int t;      public CountDownClock int start       {         this.t = start;     }     public void run       {         for  ; t >= 0; t--           {             System.out.println "T minus " + t ;  →8  →10 →12  →19 →21  →26  →31  →33 →35  →42  486      BOOK 5  Programming Techniques               try             {                 Thread.sleep 1000 ;             }             catch  InterruptedException e              {}         }     }     public int getTime        {         return t;     } } class LaunchEvent implements Runnable  {     private int start;     private String message;     TimeMonitor tm;      public LaunchEvent int start, String message,         TimeMonitor monitor      {         this.start = start;         this.message = message;         this.tm = monitor;     }     public void run       {        boolean eventDone = false;         while  !eventDone          {             try             {                 Thread.sleep 10 ;              }             catch  InterruptedException e              {}             if  tm.getTime   <= start               {                 System.out.println this.message ;                 eventDone = true;             }         }     } }     s d a e r h T g n m m a r g o r P  i  →54  →60  →64  →81  →85  CHAPTER 1  Programming Threads      487   The following paragraphs describe the high points of this version: →8    As you see in line 35, the constructor for the CountDownClock class now  accepts a parameter to specify the starting time for the countdown. As a  result, this line specifies 20 as the starting time for the CountDownClock  object.  →10   An ArrayList of LaunchEvent objects is used to store each launch   event.  →12   The lines that create the LaunchEvent objects pass the Count Down   Clock object as a parameter to the LaunchEvent constructor. That way  the LaunchEvent objects can call the clock’s abort method if necessary.  →19  The clock is started! →21  An enhanced for loop starts threads to run the LaunchEvent objects. →26   The TimeMonitor interface defines just one method, named getTime.  This method returns an integer that represents the number of seconds  left on the countdown timer.  →31  The CountDownClock class implements the TimeMonitor interface. →33   A private field named t is used to store the current value of the count- down clock. That way, the current clock value can be accessed by the  constructor, the run method, and the getTime method.  →35   The constructor for the CountDownClock class accepts the starting time  for the countdown as a parameter. Thus, this countdown clock doesn’t  have to start at 20 seconds. The value passed via this parameter is saved  in the t field.  →42   The for loop in the run method tests and decrements the t variable. But  because this variable is already initialized, it doesn’t have an initialization  expression.  →54  The getTime   method simply returns the value of the t variable. →60  This line is the start of the LaunchEvent class. →64   A private field of type TimeMonitor is used to access the countdown  clock. A reference to this object is passed to the LaunchEvent class via  its constructor. The constructor simply stores that reference in this field.  →81   The while loop includes a call to Thread.sleep that sleeps for just  10 milliseconds. Thus, this loop checks the countdown clock every  10 milliseconds to see whether its time has arrived.  488      BOOK 5  Programming Techniques   →85   This statement calls the getTime method of the countdown clock to see   whether it’s time to start the event. If so, a message is displayed, and  eventDone is set to true to terminate the thread.  Using an Executor  The countdown application in Listings 1-1 through 1-4 uses Java’s original thread- ing mechanisms — tools that were available in the mid-1990s, when Java was in  diapers. Since then, Java programmers have longed for newer, more sophisticated  threading techniques. The big breakthrough came in 2004, with the release of Java  1.5. The Java API gained a large assortment of classes for fine-grained control of  the running of threads. Since then, subsequent releases of Java have added even  more classes to give you even better control over how threads execute.  A full discussion of Java threading would require another 850 pages.  How about  Java Threading All-in-One For Masochists?  This chapter presents only a small sam- pling of these Java threading features.  Listings 1-5 through 1-7 repeat the work done by Listings 1-1 through 1-4, but  Listings 1-5 through 1-7 use Java 1.5 threading classes.     s d a e r h T g n m m a r g o r P  i  LISTING	1-5:	 A New CountDownClock  public class CountDownClockNew implements Runnable {     int t;     public CountDownClockNew int t      {         this.t = t;     }     public void run       {         System.out.println "T minus " + t ;     } }  CHAPTER 1  Programming Threads      489   LISTING	1-6:	 A New Event Launcher  public class LaunchEventNew implements Runnable {     private String message;     public LaunchEventNew String message      {         this.message = message;     }     public void run       {         System.out.println message ;     } }  LISTING	1-7:	 A New CountDown Application  import java.util.concurrent.ScheduledThreadPoolExecutor; import java.util.concurrent.TimeUnit; class CountDownAppNew {     public static void main String[] args      {         ScheduledThreadPoolExecutor pool =             new ScheduledThreadPoolExecutor 25 ;         Runnable flood, ignition, liftoff;         flood = new LaunchEventNew "Flood the pad!" ;         ignition = new LaunchEventNew "Start engines!" ;         liftoff = new LaunchEventNew "Liftoff!" ;         for  int t = 20; t >= 0; t--              pool.schedule new CountDownClockNew t ,                  long   20 - t , TimeUnit.SECONDS ;         pool.schedule flood, 3L, TimeUnit.SECONDS ;         pool.schedule ignition, 13L, TimeUnit.SECONDS ;         pool.schedule liftoff, 19L, TimeUnit.SECONDS ;         pool.shutdown  ;     } }  In the new version of the countdown application, Listing 1-7 does all the busy- work. The listing uses the ScheduledThreadPoolExecutor class. The class’s long  name tells much of the story:  490      BOOK 5  Programming Techniques   Synchronizing Methods   » Scheduled: Using this class, you can schedule a run of code for some   future time.   » ThreadPool: This class typically creates several threads  a pool of threads  at   the same time. When you want to run some code, you grab an available  thread from the pool and use that thread to run your code.   » Executor: An Executor executes something. No big surprise here!  The loop in Listing 1-7 spawns 20 threads, each with its own initial delay. The  fifth loop iteration, for example, calls  pool.schedule new CountDownClockNew 16 ,      long   20 - 16 , TimeUnit.SECONDS ;  In the pool.schedule method call, the number  long    20  -  16  tells Java to  wait 4 seconds before running the T minus 16 thread. Each of the T minus threads  has a different delay, so each thread runs at the appropriate time. The same is true  of the flood, ignition, and liftoff events.     s d a e r h T g n m m a r g o r P  i  Whenever you work on a program that uses threads, you have to consider the nasty  issue of concurrency. In particular, what if two threads try to access a method of  an object at precisely the same time? Unless you program carefully, the result can  be  disastrous.  A  method  that  performs  a  simple  calculation  returns  inaccurate  results. In an online banking application, you might discover that some deposits  are credited twice and some withdrawals aren’t credited at all. In an online order- ing system, one customer’s  order might get recorded in a different customer’s  account.  The key to handling concurrency issues is recognizing methods that update data  and that might be called by more than one thread. After you identify those meth- ods, the solution is simple. You just add the synchronized keyword to the method  declaration, like this:  public synchronized void someMethod  ...  This code tells Java to place a lock on the object so that no other methods can call  any other synchronized methods for the object until this method finishes. In other  words, it temporarily disables multithreading for the object.  I discuss locking in  the section “Creating a Lock,” later in this chapter.   CHAPTER 1  Programming Threads      491   The next several listings present some concrete examples. Listing 1-8 creates an  instance of the CountDownClock class  the class in Listing 1-1 .  LISTING	1-8:	  Creating Two CountDownClock Threads  import java.util.concurrent.ScheduledThreadPoolExecutor; public class DoTwoThings {     ScheduledThreadPoolExecutor pool =         new ScheduledThreadPoolExecutor 2 ;     CountDownClock clock = new CountDownClock 20 ;     public static void main String[] args      {         new DoTwoThings  ;     }     DoTwoThings       {         pool.execute clock ;         pool.execute clock ;         pool.shutdown  ;     } }  The resulting output is an unpredictable mishmash of two threads’ outputs, with  some of the counts duplicated and others skipped altogether, like this:  T minus 20 T minus 20 T minus 19 T minus 19 T minus 18 T minus 17 T minus 16 T minus 15 T minus 13 T minus 13 T minus 12 T minus 12 T minus 11 T minus 11 T minus 10 T minus 9 T minus 7 T minus 7  492      BOOK 5  Programming Techniques   T minus 6 T minus 5 T minus 4 T minus 3 T minus 2 T minus 2 T minus 1 T minus 0  The two threads execute their loops simultaneously, so after one thread displays  its T  minus  20, the other thread displays its own T  minus  20. The same thing  happens for T minus 19, T minus 18, and so on.  Then Listing 1-9 spawns two threads, each of which runs a copy of the Count- DownClock instance’s code.  LISTING	1-9:	  Creating Two More CountDownClock Threads     s d a e r h T g n m m a r g o r P  i  import java.util.concurrent.ScheduledThreadPoolExecutor; public class DoTwoThingsSync {     ScheduledThreadPoolExecutor pool =         new ScheduledThreadPoolExecutor 2 ;     CountDownClockSync clock =         new CountDownClockSync 20 ;     public static void main String[] args      {         new DoTwoThingsSync  ;     }     DoTwoThingsSync       {         pool.execute clock ;         pool.execute clock ;         pool.shutdown  ;     } }  In Listing 1-10, Java’s synchronized keyword ensures that only one thread at a  time calls the run method. The resulting output shows one complete execution of  the run method followed by another.  CHAPTER 1  Programming Threads      493   LISTING	1-10:	 Using the synchronized Keyword  class CountDownClockSync extends Thread {     private int start;     public CountDownClockSync int start      {         this.start = start;     }     synchronized public void run       {         for  int t = start; t >= 0; t--          {             System.out.println "T minus " + t ;             try             {                 Thread.sleep 1000 ;             }             catch  InterruptedException e              {}         }     } }  The two threads’ calls to the run method are not interleaved, so the output counts  down from 20 to 0 and then counts down a second time from 20 to 0:  And so on, down to  T minus 20 T minus 19 T minus 18  T minus 2 T minus 1 T minus 0 T minus 20 T minus 19 T minus 18  T minus 2 T minus 1 T minus 0  And so on, down to  494      BOOK 5  Programming Techniques      s d a e r h T g n m m a r g o r P  i  The tough part is knowing which methods to synchronize. When I said that any  method that updates data can be synchronized, I didn’t mean just any method  that updates a database. Any method that updates instance variables is at risk —  and  needs  to  be  synchronized.  That’s  because  when  two  or  more  threads  run  a  method  at  the  same  time,  the  threads  have  a  common  copy  of  the  method’s  instance variables.  Even methods that consist of just one line of code are at risk. Consider this method:  int sequenceNumber = 0; public int getNextSequenceNumber   {     return sequenceNumber++; }  You’d think that because this method has just one statement, some other thread  could not interrupt it in the middle. Alas, that’s not the case. This method must  get the value of the sequenceNumber field, add 1 to it, save the updated value back  to the sequenceNumber field, and return the value. In fact, this single Java state- ment compiles to 11 bytecode instructions. If the thread is preempted between any  of those bytecodes by another thread calling the same method, the serial numbers  get munged.  For safety’s sake, why not just make all the methods synchronized? You have two  reasons not to do so:   » Synchronizing methods takes time. Java has to acquire a lock  see the next  section  on the object being synchronized, run the method, and then release  the lock. But before it can do that, it has to check to make sure that some  other thread doesn’t already have a lock on the object. All this work  takes time.   » More important, synchronizing all your methods defeats the purpose of   multithreading, so you should synchronize only those methods that require it.  The synchronized keyword doesn’t block all access to an object. Other threads  can still run unsynchronized methods of the object while the object is locked.  The  Object  class  provides  three  methods  that  can  let  synchronized  objects  coordinate their activities. The wait method puts a thread in the waiting state until  some other thread calls either the object’s notify or  more commonly  notifyAll  method.  These  methods  are  useful  when  one  thread  has  to  wait  for  another  thread to do something before it can proceed. The classic example is a banking  system  in  which  one  thread  makes  withdrawals  and  the  other  makes  deposits.   CHAPTER 1  Programming Threads      495   If a customer’s account balance drops to zero, the thread that makes withdrawals  can call wait; then the thread that makes deposits can call notifyAll. That way,  each time a deposit is made, the withdrawal thread can recheck the customer’s  account  balance  to  see  whether  it  now  has  enough  money  for  the  customer  to  make a withdrawal.  Creating a Lock  A few years back, Java version 1.5 introduced many new threading features. One  such  feature  was  the  introduction  of  locks.  A  lock  can  take  the  place  of  Java’s  synchronized keyword, but a lock is much more versatile. Listings 1-11 and 1-12  illustrate the use of a lock.  LISTING	1-11:	 Creating CountDownClock Threads  Again   import java.util.concurrent.ScheduledThreadPoolExecutor; public class DoTwoThingsLocked {     ScheduledThreadPoolExecutor pool =         new ScheduledThreadPoolExecutor 2 ;     CountDownClockLocked clock =         new CountDownClockLocked  ;     public static void main String[] args      {         new DoTwoThingsLocked  ;     }     DoTwoThingsLocked       {         pool.execute clock ;         pool.execute clock ;         pool.shutdown  ;     } }  LISTING	1-12:	 Using a Lock  import java.util.concurrent.locks.ReentrantLock; public class CountDownClockLocked extends Thread {     ReentrantLock lock = new ReentrantLock  ;     public void run    496      BOOK 5  Programming Techniques       {         lock.lock  ;         for  int t = 20; t >= 0; t--          {             System.out.println "T minus " + t ;             try             {                 Thread.sleep 1000 ;             }             catch  InterruptedException e              {}         }         lock.unlock  ;     } }     s d a e r h T g n m m a r g o r P  i  Listing  1-12  is  remarkably  similar  to  Listing  1-10.  The  only  significant  differ- ence is the replacement of the synchronized keyword by calls to ReentrantLock  methods.  At the start of Listing 1-12, the code declares the variable lock — an instance of  the  ReentrantLock class. This  lock object is  like  a gas station’s  restroom  key:  Only  one  thread  at  a  time  can  have  the  lock  object.  When  one  thread  gets  the  lock object — by calling lock.lock   at the start of the run method — no other  thread can get past the lock.lock   call. A second thread must wait at the lock. lock   call until the “restroom key” becomes available. In Listing 1-12, the key  becomes available only when the first thread reaches the lock.unlock   state- ment. After the first thread calls lock.unlock  , the second thread proceeds into  the method’s for loop.  The  overall  result  is  the  same  as  the  output  of  Listings  1-9  and  1-10.  In  this  example,  using  a  lock  is  no  better  than  using  Java’s  synchronized  keyword.  But Java 1.5 has several kinds of locks, and each kind of lock has its own useful  features.  Coping with Threadus Interruptus  You can interrupt another thread by calling its interrupt method, provided that  you have a reference to the thread, as in this example:  t.interrupt  ;  CHAPTER 1  Programming Threads      497   Here the thread referenced by the t variable is interrupted. Now all the interrupted  thread has to do is find out that it has been interrupted and respond accordingly.  That’s the topic of the following sections.  Finding out whether you’ve   been interrupted  As  you’ve  already  seen,  several  methods  of  the  Thread  class,  including  sleep  and  yield,  throw  InterruptedException.  Up  until  now,  I’ve  told  you  to  sim- ply ignore this exception — and in many cases, that’s appropriate. Many  if not  most  threads, however, should respond to InterruptedException in one way or  another. In most cases, the thread should terminate when it’s interrupted.  Unfortunately,  finding  out  whether  a  thread  has  been  interrupted  isn’t  as  easy  as  it  sounds.  InterruptedException  is  thrown  when  another  thread  calls  the   interrupt method on this thread while the thread is not executing. That’s why  the methods that can cause the thread to give up control to another thread throw  this exception. That way, when the thread resumes execution, you know that it  was interrupted.  The  yield  and  sleep  methods  aren’t  the  only  way  for  control  to  be  wrested  away from a thread, however. Sometimes the thread scheduler just steps in and  says,  “You’ve  had  enough  time;  now  it’s  someone  else’s  turn  to  play.”  If  that  happens  and  then  some  other  thread  calls  your  thread’s  interrupt  method,  InterruptedException isn’t thrown. Instead, a special flag called the interrupted  flag is set to indicate that the thread was interrupted. You can test the status of  this flag by calling the static interrupted method.  Unfortunately, that means your threads have to check twice to see whether they  have been interrupted. The usual way to do that is to follow this form:  public void run   {     boolean done = false     boolean abort = false;     while !done      {            do the thread_s work here            set done to true when finished         try         {             sleep 100 ;     sleep a bit         }  498      BOOK 5  Programming Techniques           catch InterruptedException e          {             abort = true;         }         if  Thread.interrupted                abort = true;         if  abort              break;     } }     s d a e r h T g n m m a r g o r P  i  Here the boolean variable abort is set to true if InterruptedException is thrown  or if the interrupted flag is set. Then, if abort has been set to true, a break state- ment is executed to leave the while loop. This scheme has a million variations, of  course, but this one works in most situations.  Aborting the countdown  To illustrate how you can interrupt threads, Listing 1-13 shows yet another ver- sion of the countdown application. This version aborts the countdown if some- thing goes wrong with any of the launch events.  To simplify the code a bit, I assume that things aren’t going well at NASA, so every  launch  event  results  in  a  failure  that  indicates  a  need  to  abort  the  countdown.  Thus, whenever the start time for a LaunchEvent arrives, the LaunchEvent class  attempts to abort the countdown. It goes without saying that in a real launch- control program, you wouldn’t want to abort the launch unless something actu- ally does go wrong.  LISTING	1-13:	 The Countdown Application with Aborts  →3  import java.util.ArrayList; public class CountDownApp  {     public static void main String[] args      {         CountDownClock clock = new CountDownClock 20 ;         ArrayList  events =             new ArrayList   ;         events.add new LaunchEvent 16,             "Flood the pad!", clock  ;         events.add new LaunchEvent 6,             "Start engines!", clock  ;   continued   CHAPTER 1  Programming Threads      499   LISTING	1-13:	   continued           events.add new LaunchEvent 0,             "Liftoff!", clock  ;         clock.start  ;         for  Runnable e : events              new Thread e .start  ;     } } interface TimeMonitor {     int getTime  ;     void abortCountDown  ;  } class CountDownClock extends Thread     implements TimeMonitor {     private int t;     public CountDownClock int start      {         this.t = start;     }     public void run       {         boolean aborted = false;          for  ; t >= 0; t--          {             System.out.println "T minus " + t ;             try             {                 Thread.sleep 1000 ;             }             catch  InterruptedException e              {                 aborted = true;              }             if  Thread.interrupted                    aborted = true;              if  aborted               {                 System.out.println                      "Stopping the clock!" ;                 break;             }         }     }  500      BOOK 5  Programming Techniques  →26  →40  →50  →53 →54       public int getTime       {         return t;     }     public synchronized void abortCountDown        {         Thread[] threads =             new Thread[Thread.activeCount  ];          Thread.enumerate threads ;          for Thread t : threads               t.interrupt  ;     } } class LaunchEvent implements Runnable {     private int start;     private String message;     TimeMonitor tm;     public LaunchEvent int start, String message,         TimeMonitor monitor      {         this.start = start;         this.message = message;         this.tm = monitor;     }     public void run       {         boolean eventDone = false;         boolean aborted = false;          while  !eventDone          {             try             {                 Thread.sleep 10 ;             }             catch  InterruptedException e              {                 aborted = true;              }             if  tm.getTime   <= start              {                 System.out.println this.message ;                 eventDone = true;                 System.out.println "ABORT!!!!" ;   →67  →69 →70 →71     s d a e r h T g n m m a r g o r P  i  →92  →101  →107   continued   CHAPTER 1  Programming Threads      501   LISTING	1-13:	   continued                   tm.abortCountDown  ;              }             if  Thread.interrupted                    aborted = true;              if  aborted               {                 System.out.println                      "Aborting " + message ;                 break;             }         }     } }  →108  →111 →112  The following paragraphs point out the highlights of this program: →3    The CountDownApp class itself hasn’t changed. That’s the beauty of   object-oriented programming. Although I changed the implementations  of the CountDownClock and LaunchEvent classes, I didn’t change the  public interfaces for these classes. As a result, no changes are needed in  the CountDownApp class.  →26   The LaunchEvent class needs a way to notify the CountDown Timer  class that the countdown should be aborted. To do that, I added an  abortCountDown method to the TimeMonitor interface.  →40   The run method of the CountDownClass uses a boolean variable   named aborted to indicate whether the thread has been interrupted.  This variable is set to true in line 50 if InterruptedException is  caught. It’s also set to true in line 53 if Thread.interrupted   returns  true.  →54   If the aborted field has been set to true, it means that the thread has  been interrupted, so the message Stopping the clock! is displayed,  and a break statement exits the loop. Thus the thread is terminated. →67   The abortCountDown method is synchronized. That happens because   any of the LaunchEvent objects can call it, and there’s no guarantee that  they won’t all try to call it at the same time.  →69   The abortCountDown method starts by creating an array of Thread   objects that’s large enough to hold all the active threads. The number of  active threads is provided by the activeCount method of the Thread  class.  502      BOOK 5  Programming Techniques   →70   The abortCountDown method calls the enumerate method of the   Thread class to copy all the active threads into this array. Note that this  method is static, so you don’t need a reference to any particular thread  to use it.  The activeCount method used in line 69 is static too.   →71   An enhanced for loop is used to call the interrupt method on all the   active threads. That method shuts down everything.  →92   Like the CountDownClock class, the LaunchEvent class uses a boolean   variable to indicate whether the thread has been interrupted. This  variable is set if InterruptedException is caught in line 101 or if  Thread.interrupted   returns true in line 111; then it’s tested in line  112. If the aborted variable has been set to true, the thread prints a  message indicating that the launch event has been aborted, and a break  statement is used to exit the loop and  therefore  terminate the thread.  →101    When the launch event’s start time arrives, the LaunchEvent class   displays the message ABORT! and calls the abortCountDown method.  Thus the countdown is aborted the first time any launch event occurs.  When you run this version of the countdown application, the console output will  appear something like this  minor variations might occur because of the synchro- nization of the threads :     s d a e r h T g n m m a r g o r P  i  T minus 20 T minus 19 T minus 18 T minus 17 T minus 16 Flood the pad! ABORT!!!! Stopping the clock! Aborting Flood the pad! Aborting Start engines! Aborting Liftoff!  CHAPTER 1  Programming Threads      503    IN THIS CHAPTER  » Introducing regular expressions   » Trying out regular expressions with a   helpful program   » Creating simple expressions that   match patterns of characters   » Using regular expression features   such as custom classes, quantifiers,  and groups   » Using regular expressions with the   String class   » Using the Pattern and Matcher   classes for more-extensive regular  expressions  Chapter 2 Using Regular  Expressions  Regular expressions are not expressions that have a lot of fiber in their diet.   Instead,  a  regular  expression  is  a  special  type  of  pattern-matching  string  that can be very useful for programs that do string manipulation. Regular  expression  strings  contain  special  pattern-matching  characters  that  can  be  matched against another string to see whether the other string fits the pattern.  You’ll  find  that  regular  expressions  are  very  handy  for  doing  complex  data  validation — for making sure that users enter properly formatted phone numbers,  email addresses, or Social Security numbers, for example.  Regular expressions are also useful for many other purposes, including search- ing text files to see whether they contain certain patterns  can you say, Google? ,  filtering  email  based  on  its  contents,  or  performing  complicated  search-and-  replace functions.  CHAPTER 2  Using Regular Expressions      505   In this chapter, you find out the basics of using regular expressions. I empha- size validation and focus on comparing strings entered by users against patterns  specified by regular expressions to see whether they match up. For more complex  uses of regular expressions, you have to turn to a more extensive regular expres- sion reference. You can find several in-depth tutorials using a search engine such  as Google; search for regular expression tutorial.  Regular expressions are constructed in a simple but powerful mini-language, so  they’re like little programs unto themselves. Unfortunately, this mini-language is  terse — very terse — to the point of sometimes being downright arcane. Much of  it depends on single characters packed with meaning that’s often obscure. So be  warned — the syntax for regular expressions takes a little getting used to. After  you  get  your  mind  around  the  basics,  however,  you’ll  find  that  simple  regular  expressions aren’t that tough to create and can be very useful.  Also be aware that this chapter covers only a portion of all you can do with regular  expressions. If you find that you need to use more complicated patterns, you can  find plenty of helpful information on the Internet. Just search any search engine  for regular expression.  A regular expression is often called a regex. Most people pronounce that with a  soft g, as though it were spelled rejex, and some people pronounce it as though it  were spelled rejects.  Creating a Program for Experimenting  with Regular Expressions  Before I get into the details of putting together regular expressions, let me direct  your attention to Listing 2-1, which presents a short program that can be very  useful while you’re learning how to create regular expressions. First, this pro- gram lets you enter a regular expression. Next, you can enter a string, and the  program tests it against the regular expression and lets you know whether the  string matches the regex. Then the program prompts you for another string to  compare. You can keep entering strings to compare with the regex you’ve already  entered.  When  you’re  done,  just  press  the  Enter  key  without  entering  a  string.  The program asks whether you want to enter another regular expression. If you  answer yes  y , the whole process repeats. If you answer no  n , the program ends.  506      BOOK 5  Programming Techniques   LISTING 2-1:   The Regular Expression Test Program  import java.util.regex.*; import java.util.Scanner; public final class Reg {    static String r, s;    static Pattern pattern;    static Matcher matcher;    static boolean match, validRegex, doneMatching;    private static Scanner sc =       new Scanner System.in ;    public static void main String[] args     {       System.out.println "Welcome to the "         + "Regex Tester\n" ;       do       {          do          {              System.out.print "\nEnter regex:  " ;              r = sc.nextLine  ;              validRegex = true;              try              {                 pattern = Pattern.compile r ;              }              catch  Exception e               {                 System.out.println e.getMessage   ;                 validRegex = false;              }          } while  !validRegex ;          doneMatching = false;          while  !doneMatching           {              System.out.print "Enter string: " ;              s = sc.nextLine  ;              if  s.length   == 0                  doneMatching = true;              else              {                 matcher = pattern.matcher s ;                 if  matcher.matches                        System.out.println "Match." ;   continued   CHAPTER 2  Using Regular Expressions      507   LISTING 2-1:    continued                   else                     System.out.println                          "Does not match." ;              }          }       } while  askAgain   ;     }     private static boolean askAgain       {        System.out.print "Another?  Y or N  " ;        String reply = sc.nextLine  ;        if  reply.equalsIgnoreCase "Y"             return true;        return false;     } }  Here’s a sample run of this program. For now, don’t worry about the details of  the regular expression string. Just note that it should match any three-letter word  that begins with f; ends with r; and has a, i, or o in the middle.  Welcome to the Regex Tester Enter regex:  f[aio]r Enter string: for Match. Enter string: fir Match. Enter string: fur Does not match. Enter string: fod Does not match. Enter string: Another?  Y or N  n  In  this  test,  I  entered  the  regular  expression  f[aio]r.  Then  I  entered  the  string  for. The program indicated that this string matched the expression and asked for  another string. So I entered fir, which also matched. Then I entered fur and fod,  which didn’t match. Next, I entered a blank string, so the program asked whether  I wanted to test another regex. I entered n, so the program ended.  This program uses the Pattern and Matcher classes, which I don’t explain until  the end of the chapter. I suggest that you use this program alongside this chapter,   508      BOOK 5  Programming Techniques   however. Regular expressions make a lot more sense if you actually try them out  to  see  them  in  action.  Also,  you  can  learn  a  lot  by  trying  simple  variations  as  you  go.   You  can  always  download  the  source  code  for  this  program  from  this  book’s website at www.dummies.com go javaaiofd5e if you don’t want to enter  it yourself.   In fact, I use portions of console output from this program throughout the rest  of this chapter to illustrate regular expressions. There’s no better way to see how  regular expressions work than to see an expression and some samples of strings  that match and don’t match the expression.  Performing Basic Character Matching  Most regular expressions simply match characters to see whether a string com- plies  with  a  simple  pattern.  You  can  check  a  string  to  see  whether  it  matches  the  format  for  Social  Security  numbers   xxx-xx-xxxx ,  phone  numbers  [ xxx   xxx-xxxx], or more complicated patterns such as email addresses.  Well, actually,  Social Security and phone numbers are more complicated than you may think —  more  on  that  in  the  section  “Using  predefined  character  classes,”  later  in  this  chapter.  In the following sections, you find out how to create regex patterns for  basic character matching.  Matching single characters  The simplest regex patterns match a string literal exactly, as in this example:  Enter regex:  abc Enter string: abc Match. Enter string: abcd Does not match.  Here the pattern abc matches the string abc but not abcd.  Using predefined character classes  A  character class  represents  a  particular  type  of  character  rather  than  a  specific  character.  A  regex  pattern  lets  you  use  two  types  of  character  classes:  pre- defined classes and custom classes. The predefined character classes are shown  in Table 2-1.  CHAPTER 2  Using Regular Expressions      509   Character Classes  Matches  Any character  Any digit  0–9   TABLE 2-1	  Regex  .  \d  \D  \s  \S  \w  \W  Any nondigit  anything other than 0–9   Any white-space character  space, tab, new line, return, or backspace   Any character other than a white-space character  Any word character  a–z, A–Z, 0–9, or an underscore   Any character other than a word character  The period is like a wildcard that matches any character, as in this example:  Enter regex:  c.t Enter string: cat Match. Enter string: cot Match. Enter string: cart Does not match.  Here c.t matches any three-letter string that starts with c and ends with t. In  this example, the first two strings  cat and cot  match, but the third string  cart   doesn’t because it’s more than three characters.  The \d class represents a digit and is often used in regex patterns to validate input  data. Here’s a simple regex pattern that validates a U.S. Social Security number,  which must be entered in the form xxx-xx-xxxx:  Enter regex:  \d\d\d-\d\d-\d\d\d\d Enter string: 779-54-3994 Match. Enter string: 550-403-004 Does not match.  Here  the  regex  pattern  specifies  that  the  string  must  contain  three  digits,  a  hyphen, two digits, another hyphen, and four digits.  510      BOOK 5  Programming Techniques   Note that this regex pattern isn’t enough to validate real Social Security numbers  because the government places more restrictions on these numbers than just the  pattern xxx-xx-xxxx. No Social Security number can begin with 779, for exam- ple. Thus the number 779-54-3994 entered in the preceding example isn’t a valid  Social Security number.  Note that the \d class has a counterpart: \D. The \D class matches any character  that is not a digit. Here’s a first attempt at a regex for validating droid names:  Enter regex:  \D\d-\D\d Enter string: R2-D2 Match. Enter string: C2-D0 Match. Enter string: C-3PO Does not match.  Here  the  pattern  matches  strings  that  begin  with  a  character  that  isn’t  a  digit,  followed by a character that is a digit, followed by a hyphen, followed by another  nondigit character, and ending with a digit. Thus, R2-D2 and C3-P0 match. Unfor- tunately, this regex is far from perfect, as any Star Wars fan can tell you, because the  proper spelling of the shiny gold protocol droid’s name is C-3PO, not C3-P0. Typical.  The  \s  class  matches  white-space  characters  including  spaces,  tabs,  newlines,  returns, and backspaces. This class is useful when you want to allow the user to  separate parts of a string in various ways, as in this example.  Note that in the  fourth line, I use the Tab key to separate abc from def.   Enter regex: ...\s... Enter string: abc def Match. Enter string: abc       def Match.  Here the pattern specifies that the string can be two groups of any three char- acters separated by one white-space character. In the first string that’s entered,  the groups are separated by a space; in the second group, they’re separated by a  tab. The \s class also has a counterpart: \S. It matches any character that isn’t a  white-space character.  If you want to limit white-space characters to actual spaces, use a space in the  regex, like this:  Enter regex: ...  ... Enter string: abc def  CHAPTER 2  Using Regular Expressions      511   Match. Enter string: abc       def Does not match.  Here the regex specifies two groups of any character separated by a space. The  first input string matches this pattern, but the second does not because the groups  are separated by a tab.  The last set of predefined classes is \w and \W. The \w class identifies any character  that’s normally used in words, including uppercase and lowercase letters, digits,  and underscores. An example shows how all that looks:  Enter regex:  \w\w\w\W\w\w\w Enter string: abc def Match. Enter string: 123 456 Match. Enter string: 123_456 Does not match.  Here the pattern calls for two groups of word characters separated by a nonword  character.  Isn’t  it  strange  that  underscores  are  considered  to  be  word  characters?  I  don’t  know of too many words in the English language  or any other language, for that  matter  that have underscores in them. I guess that’s the computer-nerd origins  of regular expressions showing through.  Using custom character classes  To create a custom character class, you simply list all the characters that you want  to include in the class within a set of brackets. Here’s an example:  Enter regex:  b[aeiou]t Enter string: bat Match. Enter string: bet Match. Enter string: bit Match. Enter string: bot Match. Enter string: but  512      BOOK 5  Programming Techniques   Match. Enter string: bmt Does not match.  Here the pattern specifies that the string must start with the letter b, followed by  a class that can include a, e, i, o, or u, followed by t. In other words, it accepts  three-letter words that begin with b, end with t, and have a vowel in the middle.  If you want to let the pattern include uppercase letters as well as lowercase letters,  you have to list them both:  Enter regex:  b[aAeEiIoOuU]t Enter string: bat Match. Enter string: BAT Does not match. Enter string: bAt Match.  Enter regex:  [bB][aAeEiIoOuU][tT] Enter string: bat Match. Enter string: BAT Match.  You can use as many custom groups on a line as you want. Here’s an example that  defines classes for the first and last characters so that they too can be uppercase  or lowercase:  This pattern specifies three character classes. The first can be b or B, the second  can be any uppercase or lowercase vowel, and the third can be t or T.  Custom character classes can also specify ranges of letters and numbers, like this:  Using ranges  Enter regex:  [a-z][0-5] Enter string: r2 Match. Enter string: b9 Does not match.  Here the string can be two characters long. The first must be a character from  a–z, and the second must be 0–5.  CHAPTER 2  Using Regular Expressions      513   You can also use more than one range in a class, like this:  Enter regex:  [a-zA-Z][0-5] Enter string: r2 Match. Enter string: R2 Match.  Here the first character can be lowercase a–z or uppercase A–Z.  You can use ranges to build a class that accepts only characters that appear in real  words  as opposed to the \w class, which allows underscores :  Enter regex:  [a-zA-Z0-9] Enter string: a Match. Enter string: N Match. Enter string: 9 Match.  Using negation  Enter regex:  [^cf]at Enter string: bat Match. Enter string: cat Does not match. Enter string: fat Does not match.  Regular  expressions  can  include  classes  that  match  any  character  but  the  ones  listed for the class. To do that, you start the class with a caret, like this:  Here the string must be a three-letter word that ends in at but isn’t fat or cat.  Matching multiple characters  The  regex  patterns  described  so  far  in  this  chapter  require  that  each  position  in the input string match a specific character class. The pattern \d\W[a-z], for  example, requires a digit in the first position, a white-space character in the sec- ond position, and one of the letters a–z in the third position. These requirements  are pretty rigid.  514      BOOK 5  Programming Techniques   To  create  more  flexible  patterns,  you  can  use  any  of  the  quantifiers  listed  in  Table  2-2.  Quantifiers  let  you  create  patterns  that  match  a  variable  number  of  characters at a certain position in the string.  TABLE 2-2	  Quantifiers Regex  ?  *  +  {n}  {n,}  {n,m}  Matches the Preceding Element  Zero times or one time  Zero or more times  One or more times  Exactly n times  At least n times  At least n times but no more than m times  To use a quantifier, you code it immediately after the element you want it to apply  to. Here’s a version of the Social Security number pattern that uses quantifiers:  Enter regex:  \d{3}-\d{2}-\d{4} Enter string: 779-48-9955 Match. Enter string: 483-488-9944 Does not match.  The pattern matches three digits, followed by a hyphen, followed by two digits,  followed by another hyphen, followed by four digits.  Simply duplicating elements rather than using a quantifier is just as easy, if not  easier. \d\d is just as easy as \d{2}.  The ? quantifier lets you create an optional element that may or may not be pres- ent in the string. Suppose you want to allow the user to enter Social Security num- bers without the hyphens. You could use this pattern:  Enter regex:  \d{3}-?\d{2}-?\d{4} Enter string: 779-48-9955 Match. Enter string: 779489955 Match. Enter string: 779-489955  CHAPTER 2  Using Regular Expressions      515   Match. Enter string: 77948995 Does not match.  The question marks indicate that the hyphens are optional. Notice that this pat- tern lets you include or omit either hyphen. The last string entered doesn’t match  because it has only eight digits, and the pattern requires nine.  Using escapes  In regular expressions, certain characters have special meaning. What if you want  to search for one of those special characters? In that case, you escape the character  by preceding it with a backslash. Here’s an example:  Enter regex:  \ \d{3}\  \d{3}-\d{4} Enter string:  559  555-1234 Match. Enter string: 559 555-1234 Does not match.  Here \  represents a left parenthesis, and \  represents a right parenthesis. With- out the backslashes, the regular expression treats the parenthesis as a grouping  element.  Here are a few additional points to ponder about escapes:   » Strictly speaking, you need to use the backslash escape only for characters  that have special meanings in regular expressions. I recommend, however,  that you escape any punctuation character or symbol, just to be sure.   » You can’t escape alphabetic characters  letters  because a backslash followed  by certain alphabetic characters represents a character, a class, or some other  regex element.   » To escape a backslash, code two slashes in a row. The regex \d\d\\\d\d, for  example, accepts strings made up of two digits followed by a backslash and  two more digits, such as 23\88 and 95\55.  Using parentheses to group characters  You  can  use  parentheses  to  create  groups  of  characters  to  apply  other  regex   elements to, as in this example:  516      BOOK 5  Programming Techniques   Enter regex:   bla + Enter string: bla Match. Enter string: blabla Match. Enter string: blablabla Match. Enter string: bla bla bla Does not match.  Here the parentheses treat bla as a group, so the + quantifier applies to the entire  sequence. Thus, this pattern looks for one or more occurrences of the sequence  bla.  Here’s an example that finds U.S. phone numbers that can have an optional area  code:  Enter regex:   \ \d{3}\ \s? ?\d{3}-\d{4} Enter string: 555-1234 Match. Enter string:  559  555-1234 Match. Enter string:  559 555-1239 Match.  This regex pattern is a little complicated, but if you examine it element by ele- ment, you should be able to figure it out. It starts with a group that indicates the  optional area code:  \ \d{3}\ \s? ?. This group begins with the left parenthe- sis, which marks the start of the group. The characters in the group consist of  an  escaped  left  parenthesis,  three  digits,  an  escaped  right  parenthesis,  and  an  optional white-space character. Then a right parenthesis closes the group, and  the question mark indicates that the entire group is optional. The rest of the regex  pattern looks for three digits followed by a hyphen and four more digits.  When you mark a group of characters with parentheses, the text that matches that  group is captured so that you can use it later in the pattern. The groups that are  captured are called capture groups and are numbered beginning with 1. Then you  can use a backslash followed by the capture-group number to indicate that the  text must match the text that was captured for the specified capture group.  Suppose that droids named following the pattern \w\d-\w\d must have the same  digit in the second and fifth characters. In other words, r2-d2 and b9-k9 are valid  droid names, but r2-d4 and d3-r4 are not.  CHAPTER 2  Using Regular Expressions      517   Here’s an example that can validate that type of name:  Enter regex:  \w \d -\w\1 Enter string: r2-d2 Match. Enter string: d3-r4 Does not match. Enter string: b9-k9 Match.  Here \1 refers to the first capture group. Thus the last character in the string must  be the same as the second character, which must be a digit.  Using the pipe symbol  The vertical bar    symbol defines an or operation, which lets you create patterns  that accept any of two or more variations. Here’s an improvement of the pattern  for validating droid names:  Enter regex:   \w\d-\w\d  \w-\d\w\w  Enter string: r2-d2 Match. Enter string: c-3po Match.  The  character indicates that either the group on the left or the group on the right  can be used to match the string. The group on the left matches a word character,  a  digit,  a  hyphen,  a  word  character,  and  another  digit.  The  group  on  the  right  matches a word character, a hyphen, a digit, and two word characters.  You may want to use an additional set of parentheses around the entire part of the  pattern that the  applies to. Then you can add pattern elements before or after  the  groups. What if you want to let a user enter the area code for a phone number  with or without parentheses? Here’s a regex pattern that does the trick:  Enter regex:    \d{3}   \ \d{3}\    ?\d{3}-\d{4} Enter string:  559  555-1234 Match. Enter string: 559 555-1234 Match. Enter string: 555-1234 Match.  518      BOOK 5  Programming Techniques   The first part of this pattern is a group that consists of two smaller groups sep- arated  by  a    character.  The  first  of  these  groups  matches  an  area  code  with- out parentheses followed by a space, and the second matches an area code with  parentheses followed by a space. So the outer group matches an area code with  or  without  parentheses.  This  entire  group  is  marked  with  a  question  mark  as  optional; then the pattern continues with three digits, a hyphen, and four digits.  Using Regular Expressions   in Java Programs  So far, this chapter has shown you the basics of creating regular expressions. The  following sections show you how to put them to use in Java programs.  Understanding the String problem  Before getting into the classes for working with regular expressions, I want to clue  you in about a problem that Java has in dealing with strings that contain regular  expressions. As you’ve seen throughout this chapter, regex patterns rely on the  backslash character to mark different elements of a pattern. The bad news is that  Java treats the backslash character in a string literal as an escape character. Thus,  you can’t just quote regular expressions in string literals, because Java steals the  backslash characters before they get to the regular expression classes.  In most cases, the compiler simply complains that the string literal is not correct.  The following line won’t compile:  String regex = "\w\d-\w\d";      error: won't compile  The compiler sees the backslashes in the string and expects to find a valid Java  escape sequence, not a regular expression.  Unfortunately, the solution to this problem is ugly: You have to double the back- slashes wherever they occur. Java treats two backslashes in a row as an escaped  backslash and places a single backslash in the string. Thus you have to code the  statement shown in the preceding example like this:  String regex = "\\w\\d-\\w\\d";      now it will                                      compile  Here each backslash I want in the regular expression is coded as a pair of backs- lashes in the string literal.  CHAPTER 2  Using Regular Expressions      519   If you’re in doubt about whether you’re coding your string literals right, just use  System.out.println to print the resulting string. Then you can check the console  output to make sure that you wrote the string literal right. If I followed the pre- ceding statement with System.out.println regex , the following output would  appear on the console:  \w\d-\w\d  Thus I know that I coded the string literal for the regular expression correctly.  Using regular expressions   with the String class  If all you want to do with a regular expression is check whether a string matches a  pattern, you can use the matches method of the String class. This method accepts  a regular expression as a parameter and returns a boolean that indicates whether  the string matches the pattern.  Here’s a static method that validates droid names:  private static boolean validDroidName String droid  {     String regex = " \\w\\d-\\w\\d  \\w-\\d\\w\\w ";     return droid.matches regex ; }  Here the name of the droid is passed via a parameter, and the method returns a  boolean that indicates whether the droid’s name is valid. The method simply cre- ates a regular expression from a string literal and then uses the matches method  of the droid string to match the pattern.  You can also use the split method to split a string into an array of String objects  based on delimiters that match a regular expression. One common way to do that  is to simply create a custom class of characters that can be used for delimiters, as  in this example:  String s = "One:Two;ThreeFour\tFive"; String regex = "[:;\\t]"; String strings[] = s.split regex ; for  String word : strings      System.out.println word ;  520      BOOK 5  Programming Techniques   Here a string is split into words marked by colons, semicolons, vertical bars, or  tab characters. When you run this program, the following text is displayed on the  console:  One Two Three Four Five  Using the Pattern and Matcher classes  The matches method is fine for occasional use of regular expressions, but if you  want your program to do a lot of pattern matching, you should use the Pattern  and Matcher classes instead. The Pattern class represents a regular expression  that has been compiled into executable form.  Remember that regular expressions  are like little programs.  Then you can use the compiled Pattern object to create  a Matcher object, which you can use to match strings.  The Pattern class itself is pretty simple. Although it has about ten methods, you  usually use just these two:   » static Pattern compile  String pattern : Compiles the specified pattern.   This static method returns a Pattern object. It throws PatternSyntax  Exception if the pattern contains an error.   » Matcher matcher  String input : Creates a Matcher object to match this   pattern against the specified string.  First,  you  use  the  compile  method  to  create  a  Pattern  object.   Pattern  is  one  of  those  weird  classes  that  doesn’t  have  constructors.  Instead,  it  relies  on  the  static compile method to create instances.  Because the compile method throws  PatternSyntaxException,  you  must  use  a  try catch  statement  to  catch  this  exception when you compile a pattern.  After  you  have  a  Pattern  instance,  you  use  the  matcher  method  to  create  an  instance of the Matcher class. This class has more than 30 methods that let you  do all sorts of things with regular expressions that aren’t covered in this chapter,  such  as finding  multiple  occurrences  of  a pattern  in  an input  string  or  replac- ing text that matches a pattern with a replacement string. For purposes of this  book, I’m concerned only with the matches method: static boolean matches    returns a boolean that indicates whether the entire string matches the pattern.  CHAPTER 2  Using Regular Expressions      521   To illustrate how to use these methods, here’s an enhanced version of the valid  DroidName method that creates a pattern for the droid-validation regex and saves  it in a static class field:  private static Pattern droidPattern; private static boolean validDroidName String droid  {     if  droidPattern == null      {         String regex = " \\w\\d-\\w\\d "             + " \\w-\\d\\w\\w ";         droidPattern = Pattern.compile regex ;     }     Matcher m = droidPattern.matcher droid ;     return m.matches  ; }  Here the private class field droidPattern saves the compiled pattern for validat- ing droids. The if statement in the validDroidName method checks whether the  pattern has already been created. If not, the pattern is created by calling the static  compile method of the Pattern class. Then the matcher method is used to create  a Matcher object for the string passed as a parameter, and the string is validated  by calling the matches method of the Matcher object.  522      BOOK 5  Programming Techniques   IN THIS CHAPTER  » Introducing recursion   » Calculating factors with recursion   » Listing directories with recursion   » Sorting with recursion  Chapter 3 Using Recursion  Recursion is a basic programming technique in which a method calls itself to   solve some problem. A method that uses this technique is called recursive.  Many programming problems can be solved only by recursion, and some   problems that can be solved by other techniques are better solved by recursion.  I’m  not  sure,  but  I  think  that  the  term  recursion  comes  from  the  Latin  recurse,  recurset, recursum, which means to curse repeatedly. I do know that that’s exactly  what many programmers feel like doing when they’re struggling with complex  recursive programming problems.  True,  the  concept  of  recursion  can  get  a  little  tricky.  Many  programmers  steer  clear of it, looking for other techniques to solve the problem at hand, and in many  cases, a nonrecursive solution is best. Many problems just cry out for recursion,  however.  Calculating the Classic Factorial Example  One of the classic problems for introducing recursion is calculating the factorial  of  an  integer.  The  factorial  of  any  given  integer  —  I’ll  call  it  n  so  that  I  sound  mathematical — is the product of all the integers from 1 to n. Thus the factorial of  5 is 120: 5 × 4 × 3 × 2 × 1.  CHAPTER 3  Using Recursion      523   The nonrecursive solution  You  don’t  have  to  use  recursion  to  calculate  factorials.  Instead,  you  can  use  a  simple  for  loop.  Here’s  a  method  that  accepts  an  int  number  and  returns  the  number’s factorial as a long:  private static long factorial int n  {     long f = 1;     for  int i = 1; i <=n; i++          f = f * i;     return f; }  This method uses a for loop to count from 1 to the number, keeping track of the  product as it goes. Here’s a snippet of code that calls this method and displays the  result:  int n = 5; long fact; fact = factorial n ; System.out.println "The factorial of "+ n + " is "     + fact + "." ;  If you run this code, the following line is displayed on the console:  The factorial of 5 is 120.  Factorials get big fast. You should use a long rather than an int to calculate the  result. Also, you should use the NumberFormat class to format the result. If int is  20 instead of 5, the preceding code prints this on the console:  The factorial of 20 is 2432902008176640000.  If you use the NumberFormat class to format the result, the console output is more  readable:  The factorial of 20 is 2,432,902,008,176,640,000.  The recursive solution  The nonrecursive solution to the factorial problem works, but it isn’t much fun.  The recursive solution is based on the notion that the factorial for any number n  is equal to n times the factorial of n – 1, provided that n is greater than 1. If n is 1,  the factorial of n is 1.  524      BOOK 5  Programming Techniques   This definition of factorial is recursive because the definition includes the fac- torial  method  itself.  It  also  includes  the  most  important  part  of  any  recursive  method: an end condition. The end condition indicates when the recursive method  should stop calling itself. In this case, when n is 1, I just return 1. Without an end  condition, the recursive method keeps calling itself forever.  Here’s the recursive version of the factorial method:  private static long factorial int n  {     if  n == 1          return 1;     else         return n * factorial n-1 ; }  This  method  returns  exactly  the  same  result  as  the  version  in  the  preceding   section, but it uses recursion to calculate the factorial.  One way to visualize how recursion works is to imagine that you have five friends:  Jordan, Jeremy, Jacob, Justin, and Bob. Your friends aren’t very smart, but they’re  very  much  alike.  In  fact,  they’re  clones  of  one  another.  Cloning  isn’t  a  perfect  process yet, so these clones have limitations. Each can do only one multiplication  problem and can ask one of its clones one question.  Now suppose that you walk up to Jordan and ask, “Jordan, what’s the factorial of 5?”  Jordan says, “I don’t know, but I do know it’s 5 × the factorial of 4. Jeremy, what’s  the factorial of 4?”  Jeremy says, “I don’t know, but I do know it’s 4 × the factorial of 3. Jacob, what’s  the factorial of 3?”  Jacob says, “I don’t know, but I do know it’s 3 × the factorial of 2. Justin, what’s  the factorial of 2?”  Justin  says,  “I  don’t  know,  but  I  do  know  it’s  2  ×  the  factorial  of  1.  Hey,  Bob!  What’s the factorial of 1?”  Bob, being the most intelligent of the bunch on account of not having a J-name,  replies, “Why, 1, of course.” He tells Justin his answer.  n o i s r u c e R g n i s U     Justin says, “Ah — 2 × 1 is 2.” He tells Jacob his answer.  Jacob says, “Thanks — 3 × 2 is 6.” Jacob tells Jeremy his answer.  CHAPTER 3  Using Recursion      525   Jeremy says, “Dude — 4 × 6 is 24.” Jeremy tells Jordan his answer.  Jordan says, “Very good — 5 × 24 is 120.” He tells you the answer.  That’s pretty much how recursion works.  Displaying Directories  Recursion lends itself well to applications that have to navigate directory struc- tures, such as a Windows or Unix file system. In a file system, a directory is a list  of files and other directories. Each of those directories is itself a list of files and  other directories, and so on. Directories can be snugly nestled inside other direc- tories and have no limit in number.  Listing  3-1,  at  the  end  of  this  section,  shows  a  program  that  uses  a  recursive  method to list all the directories that are found starting from a given path. I use  indentation to show the directory structure.  Here’s the console output for the directories I used to organize the documents for  this book:  Welcome to the Directory Lister Enter a path: C:\Java AIO  Listing directory tree of: C:\Java AIO   Apps     Book 1     Book 2     Book 3     Book 4     Book 5   Manuscript     Book 1     Book 2     Book 3     Book 4     Book 5     Front   Plans Another?  Y or N  n  526      BOOK 5  Programming Techniques   As you can see, I haven’t done Books 6–8 yet. By the time you read this chapter,  there will be even more directories to list!  Don’t enter c:\ unless you’re prepared to wait a long time for the program to fin- ish listing all the directories on your hard drive.  Of course, you can always press  Ctrl+C to stop the program, or just close the console window.   The Directory Listing application is remarkably simple. Before I explain its details,  though, I want to point out that this program uses the File class, which is part of  the java.io package. The File class represents a single file or directory. You find  out much more about this class in Book 8. For now, you just need to know these  five details:   » The constructor for this class accepts a directory path as a parameter and   creates an object that represents the specified directory.   » You can use the exists method to find out whether the directory specified by   the path parameter exists.   » The listFiles method returns an array of File objects that represent every   file and directory in the current File object.   » The isDirectory method returns a boolean that indicates whether the  current File object is a directory. If this method returns false, you can  assume that the File object is a file.   » The getName method returns the name of the file.  LISTING 3-1:   The Directory Listing Application  import java.io.File;  import java.util.Scanner;  public class DirList {    static Scanner sc = new Scanner System.in ;    public static void main String[] args     {       System.out.print            "Welcome to the Directory Lister" ;       do       {           System.out.print "\nEnter a path: " ;           String path = sc.nextLine  ;   →1  n o i s r u c e R g n i s U     →15   continued   CHAPTER 3  Using Recursion      527   LISTING 3-1:    continued   →17 →18  →25 →26  →28  →31  →34 →35  →37  →40 →41            File dir = new File path ;            if  !dir.exists    !dir.isDirectory                   System.out.println                    "\nThat directory doesn't exist." ;           else           {               System.out.println                    "\nListing directory tree of:" ;               System.out.println dir.getPath   ;                listDirectories dir, "  " ;            }       } while askAgain   ;     }     private static void listDirectories         File dir, String indent     {       File[] dirs = dir.listFiles  ;        for  File f : dirs         {           if  f.isDirectory               {               System.out.println                    indent + f.getName   ;                listDirectories f, indent + "  " ;            }       }    }    private static boolean askAgain      {       System.out.print "Another?  Y or N  " ;       String reply = sc.nextLine  ;       if  reply.equalsIgnoreCase "Y"            return true;       return false;    } }  The following paragraphs point out the highlights of how this program works: →1        This import statement is required to use the File class. →15      A Scanner object is used to get the pathname from the user.  528      BOOK 5  Programming Techniques   →17      The pathname is passed to the File class constructor to create a new   File object for the directory entered by the user.  →18      The exists and isDirectory methods are called to make sure that the  path entered by the user exists and points to a directory rather than a file. →25      If the user entered a good path, the getPath method is called to display   the name of the path represented by the File object.  I could just as  easily have displayed the path variable here.   →26      The listDirectories method is called to list all the subdirectories in   the directory specified by the user.  →28      The user is asked whether he wants to list another directory, and the   loop repeats if the user answers Y.  →31      This line is the start of the listDirectories method. This method takes   two parameters: a File object representing the directory to be listed  and a String object that provides the spaces used to indent each line of  the listing. When this method is first called from the main method, the  indentation is set to two spaces by a string literal.  →34      The listFiles method is called to get an array of all the File objects in   this directory.  →35      An enhanced for loop is used to process all the File objects in the array. →37      This if statement checks to see whether a file is a directory rather than a file. →40      If the File object is a directory, the indentation string is printed, followed   by the name of the directory as returned by the getName method. →41      Next, the listDirectories method is called recursively to list the  contents of the f directory. Two spaces are added to the indentation  string, however, so that any directories in the f directory are indented  two spaces to the right of the current directory.  If you’re having trouble understanding how the recursion in this program works,  think of it this way: The listDirectory method lists all the subdirectories in a  single directory. For each directory, this method does two things:  1  prints the  directory’s name and  2  calls itself to print any subdirectories of that directory.  Earlier in this chapter, I mention that all recursive methods must have some type  of condition test that causes the method to stop calling itself. In this program,  the condition test may not be obvious. Eventually, however, the listDirectories  method is passed a directory that doesn’t have any subdirectories. When that hap- pens, the recursion ends — at least for that branch of the directory tree.  n o i s r u c e R g n i s U     CHAPTER 3  Using Recursion      529   Writing Your Own Sorting Routine  The  world  is  full  of  computer  science  majors  who  don’t  know  anything  more  about computers than you do, but they once attended a class in which the instruc- tor explained how sorting algorithms worked. They may have received a C in that  class, but it was good enough to graduate.  Now you have a chance to find out what you missed by not majoring in computer  science. I’m going to show you how one of the most commonly used sorting tech- niques actually works. This technique is called Quicksort, and it’s a very ingenious  use of recursion. I even show you a simple Java implementation of it.  Quicksort is easily the most technical part of this entire book. If you never wanted  to major in computer science  and if you don’t even want to talk to people who  did , you may want to skip the rest of this chapter now.  For  most  of  us,  figuring  out  how  sorting  algorithms  such  as  Quicksort  work  is  merely an intellectual exercise. The Java API has sorting already built in.  Check  out the  Arrays.sort method, for example.  Those sort routines are way better  than any that you or I will ever write.  Understanding how Quicksort works  The Quicksort technique sorts an array of values by using recursion. Its basic steps  are thus: 1.  Pick an arbitrary value that lies within the range of values in the array. This value is the pivot point. The most common way to choose the pivot point  is to simply pick the first value in the array. Folks have written doctoral degrees  on more-sophisticated ways to pick a pivot point that results in faster sorting.  I like to stick with using the first element in the array.  2.  Rearrange the values in the array so that all the values that are less than  the pivot point are on the left side of the array and all the values that are  greater than or equal to the pivot point are on the right side of the array.  The pivot value indicates the boundary between the left side and the right side  of the array. It probably won’t be dead center, but that doesn’t matter. This step  is called partitioning, and the left and right sides of the arrays are partitions.  3.  Now treat each of the two sections of the array as a separate array, and   start over with Step 1 for that section.  That’s the recursive part of the algorithm.  530      BOOK 5  Programming Techniques   The hardest part of the Quicksort algorithm is the partitioning step, which must  rearrange the partition so that all values that are smaller than the pivot point are  on the left and all elements that are larger than the pivot point are on the right.  Suppose that the array has these ten values:  38 17 58 22 69 31 88 28 86 12  Here the pivot point is 38, and the task of the partitioning step is to rearrange the  array to something like this:  17 12 22 28 31 38 88 69 86 58  Notice that the values are still out of order. The array, however, has been divided  around the value 38: All values that are less than 38 are to the left of 38, and all  values that are greater than 38 are to the right of 38.  Now you can divide the array into two partitions at the value 38 and repeat the  process for each side. The pivot value itself goes with the left partition, so the left  partition is this:  This time, the partitioning step picks 17 as the pivot point and rearranges the ele- ments as follows:  17 12 22 28 31 38  12 17 22 28 31 38  As you can see, this portion of the array is sorted now. Unfortunately, Quicksort  doesn’t realize that at this point, so it takes a few more recursions to be sure. But  that’s the basic process.  Using the sort method  The actual code that drives a Quicksort routine is surprisingly simple:  public static void sort int low, int high  {     if  low >= high          return;     int p = partition low, high ;     sort  low, p ;     sort  p+1, high ; }  n o i s r u c e R g n i s U     CHAPTER 3  Using Recursion      531   This method sorts the portion of an array indicated by the low and high index  values passed to it. Ignoring the if statement for now, the sort method works by  calling a partition method. This method rearranges the array into two partitions  so that all the values in the left partition are smaller than all the values in the right  partition. The partition method returns the index of the end of the left partition.  Then the sort method calls itself twice: once to sort the left partition and again  to sort the right partition.  To get the sort method started, you call it with 0 as the low value and the array  length and 1 as the high value. Thus the sort method begins by sorting the entire  array.  Each  time  the  sort  method  executes,  it  calls  itself  twice  to  sort  smaller  partitions of the array.  The if statement at the beginning of the sort method compares the low value  with the high value. If the low value is equal to or greater than the high value, the  partition has only one element  or perhaps no elements  and therefore is already  sorted. In that case, the sort method simply returns without calling itself again.  That’s the condition that ends the recursion.  Using the partition method  The sort method itself is the simple part of the Quicksort technique. The hard  part is the partition method. This method accepts two parameters: the low and  high indexes that mark the portion of the array that should be sorted. The basic  outline of the partition method goes something like this: 1.  Pick a pivot point. 2.  Move all elements that are less than the pivot point to the left side of   the partition.  3.  Move all elements that are greater than the pivot point to the right side   of the partition.  4.  Return the index of the pivot point.  The most common technique for partitioning the array is to maintain two index  variables, named i and j, that work from both ends of the array toward the center.  First, i starts at the beginning of the array and moves forward until it encounters  a value that’s greater than the pivot value. Then j starts at the opposite end of the  array and moves backward until it finds a value that’s less than the pivot point. At  that point, the partition method has a value that’s greater than the pivot point  on the left side of the array and a value that’s less than the pivot point on the right  side of the array. So it swaps them.  532      BOOK 5  Programming Techniques   Next, the cycle repeats: i is incremented until it finds another value that’s greater  than the pivot value, j is decremented until it finds another value that’s less than  the pivot value, and the elements are swapped. This process repeats until j is less  than i, which means that the indexes have crossed and the partitioning is done.  Here’s some code that puts everything together:  public static int partition int low, int high  {     int pivot = a[low];      int i = low - 1;     int j = high + 1;     while  i < j      {         for  i++; a[i] < pivot; i++ ;         for  j--; a[j] > pivot; j-- ;         if  i < j              swap i, j ;     }     return j; }  Notice that in this code, the array being sorted is a static int array named a. The  low and high ends of the partition to be partitioned are passed in as parameters,  and the method starts by choosing the first element in the partition as the value  for the pivot point. Next, it initializes the index variables i and j from the param- eters. Notice that 1 is subtracted from the low value and that 1 is added to the high  value. The index variables take one step back from the array before the looping  starts so they can get a good start.  The while loop is used to indicate when the partitioning is finished. It repeats as  long as i is less than j. After these index variables stop, the partitioning is done,  and the value of j is returned to indicate the index point that divides the left parti- tion from the right partition.  In the body of the while loop are two strange bodyless for loops. These for loops  don’t have bodies because their only purpose is to move their index values until  they find a value that’s either less than or greater than the pivot value.  The  first  for  loop  increments  the  i  index  variable  until  it  finds  a  value  that’s  greater than the pivot point. This for loop finds the first value that might need to  be moved to the other side of the array.  n o i s r u c e R g n i s U     CHAPTER 3  Using Recursion      533   Next, the second for loop decrements the j index variable until it finds a value  that’s less than the pivot point. So this loop finds a value that may need to be  swapped with the value found by the first for loop.  Finally, the if statement checks whether the indexes have crossed. Assuming that  they haven’t, a swap method is called to swap the elements. The swap method is  mercifully simple:  public static void swap int i, int j  {     int temp = a[i];     a[i] = a[j];     a[j] = temp; }  This method moves the i element to a temporary variable, moves the j element to  the i element, and then moves the temporary variable to the j element.  Putting it all together  Now  that  you’ve  seen  the  basic  steps  necessary  to  create  a  Quicksort  program,  Listing 3-2 shows a program that gives these methods a workout. This program  creates  an  array  of  100  randomly  selected  numbers  with  values  from  1–100.  It  prints the array, uses the sorting methods shown in the previous sections to sort  the array, and then prints the sorted array. Here’s a sample run:  Unsorted array:  65 51 38 47 93 87 50 36 77 58 22 92 46 60 49 90 28 39 27  8 66 76 40 99 90 35 34 30  7 41 45 34 41 17 36 63 52 65 50 77  2 93 48  6 91 67 34 69 33 47 50 12 88 15 65 40 29 74 34 14 55 37 28 25 98 66 69 88 66 27 29 88 29 87  9 29 77 32  4 11 68 40 17 61 50 90 24  1 59 91 69  5 82 69 51 45 29 38 61 86 Sorted array:   1  2  4  5  6  7  8  9 11 12 14 15 17 17 22 24 25 27 27 28 28 29 29 29 29 29 30 32 33 34 34 34 34 35 36 36 37 38 38 39 40 40 40 41 41 45 45 46 47 47 48 49 50 50 50 50 51 51 52 55 58 59 60 61 61 63 65 65 65 66 66 66 67 68 69 69 69 69 74 76 77 77 77 82 86 87 87 88 88 88 90 90 90 91 91 92 93 93 98 99  As you can see, the first array is in random order, but the second array is nicely  sorted.  Your results will vary, of course, because the unsorted array will be in a  different order every time you run the program.   534      BOOK 5  Programming Techniques   LISTING 3-2:  A Sorting Program  public class QuickSortApp {    public static void main String[] args     {       int LEN = 100;       int[] unsorted = new int[LEN];       for  int i = 0; i<LEN; i++            unsorted[i] =              int  Math.random   * 100  + 1;       System.out.println "Unsorted array:" ;       printArray unsorted ;        int[] sorted = sort unsorted ;        System.out.println "\n\nSorted array:" ;       printArray sorted ;     }    private static void printArray int[] array      {       System.out.println  ;       for  int i = 0; i < array.length; i++        {          if  array[i] < 10               System.out.print " " ;          System.out.print array[i] + " " ;          if   i+1  % 20 == 0               System.out.println  ;       }    }    private static int[] a;     public static int[] sort int[] array      {       a = array;       sort 0, a.length - 1 ;       return a;    }    public static void sort int low, int high      {       if  low >= high           return;       int p = partition low, high ;       sort  low, p ;       sort  p+1, high ;    }  →7  →10 →11  →13  →16  →29 →31  →38  n o i s r u c e R g n i s U      continued   CHAPTER 3  Using Recursion      535   LISTING 3-2:    continued      public static int partition int low, int high      {       int pivot = a[low];       int i = low - 1;       int j = high + 1;       while  i < j        {          for  i++; a[i] < pivot; i++ ;          for  j--; a[j] > pivot; j-- ;          if  i < j               swap i, j ;       }       return j;    }    public static void swap int i, int j      {       int temp = a[i];       a[i] = a[j];       a[j] = temp;    } }  →47  →64  Most of the code in this program has already been explained, so I just point out a  few of the highlights here: →7        This for loop assigns 100 random values to the array. →10      The printArray method is called to print the unsorted array. →11      The sort method is called to sort the array. →13      The printArray method is called again to print the sorted array. →16      The printArray method uses a for loop to print array elements. Each  element is separated by two spaces. An additional space, however, is  printed before each element if the element’s value is less than 10. That  way, the values line up in columns. Also, the remainder operator  %  is  used to call the println method every 20 elements. Thus this method  prints 5 lines with 20 values on each line.  The last few values in the array  won’t line up exactly if they happen to be 100, but that’s okay.   →29      A static variable named a is used to hold the array while it is being sorted.  536      BOOK 5  Programming Techniques   →31      The sort method has two versions. The first accepts an int array as a  parameter and returns an int array with the sorted values. This method  sets the static a variable to the array passed via the parameters, calls the  second version of the sort method to sort the entire array, and then  returns the sorted array.  →38      This line is the second sort method. It sorts the partition indicated by the   parameters.  The operation of this method is explained in detail in the  section “Using the sort method,” earlier in this chapter.   →47      The partition method is explained in detail in the preceding section. →64      The swap method simply exchanges the two indicated values.  Remember the cool XOR technique for exchanging two integer values  without the need for a temporary variable? You can improve the perfor- mance of your sort ever so slightly by replacing the swap method with  this code:  public static void swap int i, int j  {     a[i] ^= a[j];     a[j] ^= a[i];     a[i] ^= a[j]; }  n o i s r u c e R g n i s U     CHAPTER 3  Using Recursion      537    IN THIS CHAPTER  » Understanding human and computer   dates and times   » Using java.time classes to represent   dates and times   » Comparing dates and times   » Performing calculations with dates   and times   » Formatting dates and times  Chapter 4 Working with Dates  and Times  D     oes anybody really know what time it is? Does anybody really care about time?  So  mused  Robert  Lamm  of  The Chicago Transit Authority   later  known  as  simply  Chicago  in 1969.  I’m not sure who cared much about time in 1969, but I do know that the people  who designed the original version of Java in 1995 didn’t care much about it, at  least as evidenced by the weak classes they provided for working with times and  dates in the Java.util package. Java programmers have long struggled with sim- ple calculations involving dates and times, such as determining what the date will  be 45 days from today or calculating the number of days between two given dates.  Java  finally  got  with  the  times  with  the  release  of  Java  8,  which  introduced  an  entirely  new  framework  for  working  with  dates  and  times,  usually  referred  to  as  the  Date-Time  API.  This  new  API  is  pretty  complicated,  involving  about  50  new  classes  and  interfaces  and  hundreds  of  new  methods.  In  this  chapter,  I’ll   CHAPTER 4  Working with Dates and Times      539   introduce you to just a few of the most important and useful classes of the new  Date-Time API. Then you can explore the rest online via Oracle’s documentation  at http:  download.java.net jdk9 docs api index.html.  Pondering How Time is Represented  Before I launch into the details of the new Date-Time API’s classes, let’s review  a few basic concepts about time. Probably the most important basic concept to  understand about time  at least from a programming point of view  is that com- puters and humans use two entirely different methods of keeping track of time.  Humans measure time using a system of progressively longer units, starting with  seconds and increasing to minutes, hours, days, weeks, months, years, decades,  and centuries.  Our human time units are intuitively familiar to us, but their precise definitions  are more complicated than you might guess. All kinds of factors muck up the way  we represent time: leap days, time zones, and daylight-saving time. And did you  know that about once every 18 months, scientists pick a day  they usually choose  June 30 or December 31  that they add one second to? This is necessary because  the speed of the earth’s rotation varies ever so slightly, throwing our clocks off.  In contrast, the way computers keep track of time is much simpler: Computers  simply  count  the  number  of  units   typically  milliseconds  or  nanoseconds   that  have elapsed since a given start time. Thus, to a computer, a time is just a number.  In Java, machine time is set as the number of nanoseconds that have elapsed since  midnight, January 1, 1970. Why January 1, 1970? There’s no particular reason other  than historical: Java inherited that date from the Unix operating system, which  was  developed  in  the  1970s.   For  more  information,  see  the  sidebar  “And  you  thought Y2K was bad!”   The designers of Microsoft Windows decided to use January 1, 1601 as the start day  for their clock. I guess that was a big year for William Shakespeare; in 1601 he was  able to use the first version of Microsoft Word to write his plays.  The difference between how humans and computers keep track of time makes any  computer program that deals with dates and times a bit tricky. For example, suppose  you want to schedule a phone call between two people, one in Los Angeles, the other  in New York. Obviously, the time that you agree upon for the call must take into  account the time zone of each participant. Thus you might agree to make the call  at 1 p.m. local time for the West Coast participant and 4 p.m. local time for the East   Coast participant. So, how would you represent that appointment time in a database?  540      BOOK 5  Programming Techniques   AND YOU THOUGHT Y2K WAS BAD!  Java counts time in nanoseconds starting with January 1, 1970. Why that particular date?  It turns out that January 1, 1970 was the date the original designers of Unix chose as  their origin time for the Unix operating system. That tradition was carried on into Linux,  and then into Java.  The original Unix used a signed 32-bit number to count time, and counted time in full  seconds rather than nanoseconds. Thus, in Unix time was represented as the number  of seconds that have elapsed since January 1, 1970. Because the largest number that  can be represented by a signed 32-bit number is relatively small, Unix time will come to  an end on January 19, 2038.  Today, most Unix- and Linux-based systems have been upgraded to use 64-bit numbers  to count time, so the world will not end in 2038 for those systems. But systems that still  use old-style 32-bit time values will break in 2038.  I am already looking forward to the end-of-the-world party.  Or suppose you want to calculate the due date for an invoice that is dated January  27, 2015, when the payment due date is 45 days after the invoice date. The algo- rithm that calculates the due date must be aware that January has 31 days and that  February has 28 days in 2015.  Fortunately, the new Date-Time API is designed to handle all those nuances for  you. The Date-Time API includes all the classes you need to represent dates and  times in just about any imaginable context, for performing calculations and com- parisons  between  date  and  time  objects,  and  for  converting  dates  and  times  to  string representations in just about any imaginable format.  Picking the Right Date and Time Class  for Your Application  The first order of business when developing an application that must work with  dates or times  or both  is picking the Date-Time class to represent your date and  time values. The java.time package defines ten distinct classes used to represent  different types of times and dates, as described in Table 4-1.  CHAPTER 4  Working with Dates and Times      541   TABLE 4-1	  Class  LocalTime  Ten Date-Time Classes in java.time  What It Represents  A time  hours, minutes, and seconds to nanosecond precision  without an associated  time zone.  LocalDate  A date  year, month, and day  without an associated time zone.  LocalDateTime  A date and time without an associated time zone.  OffsetTime  A time and an offset from UTC  Coordinated Universal Time, also known as Greenwich  Mean Time , such as 12:30:00-8.00, which means the time is 12:30 with an offset of  -8 hours from UTC.  OffsetDateTime  A date and time with an offset value from UTC.  ZonedDateTime  A date and time with an associated time zone, such as America Los_Angeles.  MonthDay  YearMonth  Year  Instant  A month and day without an associated year. You can use a MonthDay object to  represent a date such as a birthday, anniversary, or holiday.  A year and month, such as December, 2015. No day, time, or time zone values are  associated with the year and month.  A year, such as 2038. No month, day, time, or time zone values are associated  with the year.  A single point of time, represented internally as the number of nanoseconds that have  elapsed since midnight, January 1, 1970. The value assumes a UTC GMT time offset of 0.  Each  of  these  classes  has  many  different  methods  that  let  you  create  date  and  time objects, perform calculations on them, compare them, and convert them to  strings that can be displayed and read by humans. You can find complete docu- mentation of the methods for each of these classes online at http:  download. java.net jdk9 docs api index.html.  Using the now Method to Create a   Date-Time Object  All Date-Time classes have a static now method, which creates an object repre- senting the current date and or time. For example, to get the current date, you  would use code similar to this:  LocalDate date = LocalDate.now  ;  542      BOOK 5  Programming Techniques   To get the current date and time with time zone, use this code:  ZonedDateTime datetime = ZonedDateTime.now  ;  The following program displays the current time using all ten classes, creating an  object of each class using now   and printing it with toString  :  import java.util.*; import java.time.*;  public class TimeTester {     public static void main String[] args      {         System.out.println "\nLocalTime: "             + LocalTime.now  .toString   ;         System.out.println "\nLocalDateTime: "             + LocalDateTime.now  .toString   ;         System.out.println "\nZonedDateTime: "             + ZonedDateTime.now  .toString   ;         System.out.println "\nOffsetTime: "             + OffsetTime.now  .toString   ;         System.out.println "\nOffsetDateTime: "             + OffsetDateTime.now  .toString   ;         System.out.println "\nMonthDay: "             + MonthDay.now  .toString   ;         System.out.println "\nYearMonth: "             + YearMonth.now  .toString   ;         System.out.println "\nInstant: "             + Instant.now  .toString   ;     } }  If you compile and run this program, the output will appear something like this:  LocalTime: 20:56:26.325  LocalDateTime: 2013-10-07T20:56:26.388  ZonedDateTime: 2013-10-07T20:56:26.388-07:00[America Los_Angeles]  OffsetTime: 20:56:26.388-07:00  OffsetDateTime: 2013-10-07T20:56:26.388-07:00  MonthDay: --10-07  CHAPTER 4  Working with Dates and Times      543   YearMonth: 2013-10  Instant: 2013-10-08T03:56:26.388Z  From this output, you can get an idea of the information represented by the vari- ous Date-Time classes.  Using the parse Method to Create a   Date-Time Object  Another  way  to  create  a  Date-Time  object  is  to  use  the  static  parse  method,  which creates a Date-Time object from a string that represents a specific date or  time.  For  example,  the  following  code  creates  a  LocalDate  object  representing   December 15, 2014:  LocalDate d = LocalDate.parse "2014-12-15" ;  To  create  a  LocalDateTime  object  that  represents  a  specific  time  on  a  specific  date, use the parse method. Here’s an example that sets the time to 3:45 p.m. on  December 15, 2014:  LocalDateTime dt; dt = LocalDateTime.parse "2014-12-15T15:45" ;  Note that the letter T separates the date from the time, and the time is expressed  in 24-hour clock format. If you need to be more precise, you can also specify sec- onds, as in this example:  dt = LocalDateTime.parse "2014-12-15T15:45:13.5" ;  Here the time is set to 13.5 seconds after 2:45 p.m.  If  the  string  is  not  in  the  correct  format,  the  parse  method  throws  a  DateTimeParseException.  Whenever  you  use  the  parse  method,  you  should  enclose it in a try block and catch this exception, as in this example:  LocalDateTime dt; try {     dt = LocalDateTime.parse "2014-12-15T03:45PM" ; }  544      BOOK 5  Programming Techniques   catch  DateTimeParseException ex  {     System.out.println ex.toString   ; }  The parse method is especially useful for converting user input to a Date-Time  object. For example, you might use it along with the Scanner class to read a date  from the console, or you can use parse in a Swing application to read a date from a  text box. When you do, you should prompt the user with the expected date format  and catch DateTimeParseException in case the user enters the date in the wrong  format.  Using the of Method to Create a   Date-Time Object  A  third  way  to  create  Date-Time  objects  is  to  use  the  static  of  method  to  cre- ate a Date-Time object from its constituent parts. For example, you can create a  LocalDate object by supplying integers that represent the year, month, and day  like this:  LocalDate date = LocalDate.of 2014,12,15 ;  Each of the Date-Time classes has one or more variations of the of method, as  spelled out in Table 4-2.  Note  that  several  of  the  methods  in  Table  4-2  use  the  additional  types  Month,  ZoneOffset, and ZoneId. These types are described in the following sections.  Using the Month enumeration  Several of the methods listed in Table 4-2 let you specify the month as a Month  object. Month is an enumeration that represents the twelve months of the year, as  follows:  Month.JANUARY  Month.MAY  Month.SEPTEMBER  Month.FEBRUARY  Month.JUNE  Month.OCTOBER  Month.MARCH  Month.APRIL  Month.JULY  Month.NOVEMBER  Month.AUGUST  Month.DECEMBER  CHAPTER 4  Working with Dates and Times      545   TABLE 4-2	  Class  Date-Time of Methods  Method  LocalTime  of int hour, int minute   of int hour, int minute, int second   of int hour, int minute, int second, int nanoOfSecond   LocalDate  of int year, int month, int dayOfMonth   of int year, Month month, int dayOfMonth   LocalDateTime  of int year, int month, int dayOfMonth, int hour, int minute   of int year, int month, int dayOfMonth, int hour, int minute,  int second   of int year, int month, int dayOfMonth, int hour, int minute, int  second, int nanoOfSecond   of int year, Month month, int dayOfMonth, int hour, int minute   of int year, Month month, int dayOfMonth, int hour, int minute,  int second   of int year, Month month, int dayOfMonth, int hour, int minute,  int second, int nanoOfSecond   of LocalDate date, LocalTime time   OffsetTime  of int hour, int minute, int second, int nanoOfSecond,  ZoneOffset offset   of LocalTime time, ZoneOffset offset   OffsetDateTime  of int year, int month, int dayOfMonth, int hour, int minute, int  second, int nanoOfSecond, ZoneOffset offset   of LocalDate date, LocalTime time, ZoneOffset offset   of LocalDateTime dateTime, ZoneOffset offset   MonthDay  of int month, int dayOfMonth   of Month month, int dayOfMonth   YearMonth  of int year, int month   of int year, Month month   Year  of int year   546      BOOK 5  Programming Techniques   Thus you can create a date like this:  LocalDate date = LocalDate.of 2014,Month.DECEMBER,15 ;  Interestingly, the  Month enumeration has some interesting methods which you  might find occasionally useful. For example, you can print the number of days in  December like this:  System.out.println "December hath "     + Month.DECEMBER.length false  + " days." ;  The  boolean  argument  in  the  length  method  indicates  whether  the  calcula- tion should be for a leap year. Consult the online documentation for other useful  methods of the Month enumeration.  Using the ZoneId class  To create a ZonedDateTime, you must first create a time zone object by using the  ZoneId class. To create a time zone, you must know the standard name of the time  zone you want to create. Unfortunately, there are more than 500 distinct zone IDs,  and they periodically change. So listing them here would be impractical, but you  can easily list them all by using this handy bit of code:   for  String id : ZoneId.getAvailableZoneIds        System.out.println id ;  This for loop will write the names of each ZoneId to the console.  Once you know the name of the ZoneId you want to use, you can create it using  ZoneId.of , then use it to create a ZonedDateTime as in this example:  ZoneId z = ZoneId.of "America Los_Angeles" ; ZonedDateTime zdate; zdate = ZonedDateTime.of 2014, 12, 15, 0, 0, 0, 0, z ;  Or,  if  you  prefer,  you  can  create  the  ZoneId  directly  when  you  create  the  ZonedDateTime:  zdate = ZonedDateTime.of 2014, 12, 15, 0, 0, 0, 0,     ZoneId.of "America Los_Angeles"  ;  CHAPTER 4  Working with Dates and Times      547   Using the ZoneOffset class  The of method OffsetTime and OffsetDateTime classes use an additional class  named ZoneOffset to indicate the offset from UTC. You can create a ZoneOffset  by using any of the following methods of the ZoneOffset class:   » of String offsetId   » ofHours int hours   » ofHoursMinutes int hours, int minutes   » ofHoursMinutesSeconds int hours, int minutes, int seconds   » ofTotalSeconds int totalSeconds   For example, you can create a ZoneOffset of -8 hours like this:  ZoneOffset z = ZoneOffset.ofHours -8 ;  Alternatively, you could specify the offset as a string, as in this example:  ZoneOffset z = ZoneOffset.of "-08:00" ;  Note that when you use a string offset, you must provide two digits for the hours,  minutes, and  optionally  seconds.  Once you have a ZoneOffset object, you can use it to create an OffsetTime, as in  this example:  OffsetTime time = OffsetTime.of 10, 30, 0, 0, z ;  Or if you prefer, you can create the ZoneOffset directly in the call to the Offset- Time’s of method:  OffsetTime time = OffsetTime.of 10, 30, 0, 0,     ZoneOffset.ofHours -8  ;  Looking Closer at the LocalDate Class  The basic java.time classes are similar enough that once you learn how to use  one of them, you’ll find it easy to learn how to use the rest. Thus, for the rest of  this chapter, I’ll focus on just one: the LocalDate class. This class represents a  date  year, month, and day  without an associated time. In this section and in the   548      BOOK 5  Programming Techniques   sections that follow, you’ll learn how to use many of the methods of this class to  extract information about a date, to compare two dates, and to perform calcula- tions on a date.  Table 4-3 shows the most commonly used methods of the LocalDate class. For  your convenience, this table includes the methods used to create LocalDate objects,  even though those methods have already been covered earlier in this chapter.  TABLE 4-3	  Method  Methods of the LocalDate Class Explanation  Methods that create a LocalDate object  LocalDate now    Creates a LocalDate object that represents the  current date.  LocalDate of int year, int month, int  dayOfMonth   Creates a LocalDate object with a given year,  month, and day.  LocalDate of int year, Month month,  int dayOfMonth   Creates a LocalDate object with a given year,  month, and day.  LocalDate parse String text   Creates a LocalDate object by parsing the text string.  Methods that extract information about a date  int getYear    Month getMonth    int getMonthValue    int getDayOfMonth    int getDayOfYear    int lengthOfMonth    int lengthOfYear    Methods that compare dates  Returns the year.  Returns the month as a Month object.  Returns the month as an int from 1 through 12.  Returns the day of the month.  Returns the day of the year.  Returns the number of days in this month.  Returns the number of days in this year.  DayOfWeek getDayOfWeek    Returns the day of the week as a DayOfWeek object.  boolean isAfter LocalDate other   Returns true if other occurs after this date.  boolean isBefore LocalDate other   Returns true if other occurs after this date.  boolean isEqual LocalDate other   Returns true if this date and other represent the  same date.   continued   CHAPTER 4  Working with Dates and Times      549   TABLE 4-3	 continued   Method  Explanation  Methods that perform date calculations  LocalDate plusDays long days   LocalDate plusNMonths long days   LocalDate plusWeeks long months   LocalDate plusYears long days   LocalDate minusDays long days   LocalDate minusMonths long months   LocalDate minusWeeks long months   LocalDate minusYears long years   Returns a copy of the LocalDate with the specified  number of days added.  Returns a copy of the LocalDate with the specified  number of months added.  Returns a copy of the LocalDate with the specified  number of weeks added.  Returns a copy of the LocalDate with the specified  number of years added.  Returns a copy of the LocalDate with the specified  number of days subtracted.  Returns a copy of the LocalDate with the specified  number of months subtracted.  Returns a copy of the LocalDate with the specified  number of weeks subtracted.  Returns a copy of the LocalDate with the specified  number of years subtracted.  long until LocalDate endDate,  ChronoUnit unit   Returns the difference between this date and the  specified date measured in the specified units.  Extracting Information About a Date  Several methods of the LocalDate class let you extract useful information about  a given date. For instance, the following example shows how you can extract the  current year, month, and day:  LocalDate date = LocalDate.now  ; int year = date.getYear  ; int month = date.getMonthValue  ; int day = date.getDayOfMonth  ;  If you need to know how many days into the year a particular date is, you can use  this code:  LocalDate date = LocalDate.parse "2016-04-09" ; System.out.println date.getDayOfYear   ;  550      BOOK 5  Programming Techniques   This example will print the number 100, as April 9 is the 100th day of 2016.  The getDayOfWeek method returns a value of type DayOfWeek, which is an enu- meration with the following values:  SUNDAY  MONDAY  TUESDAY  WEDNESDAY  THURSDAY  FRIDAY  SATURDAY  Here’s an example of how you might use this method:  LocalDate date = LocalDate.parse "2016-04-09" ; System.out.println date.getDayOfWeek   ;  In this example, the string SATURDAY will be printed because in 2016, April 9 falls  on a Saturday.  The lengthOfMonth and lengthOfYear are useful if you want to know the number  of days in the month or year represented by a LocalDate. Both methods take into  account leap years.  You can’t compare Date-Time objects using Java’s standard comparison opera- tors. Consider the following example:  if  LocalDate.now   == LocalDate.now        System.out.println "All is right in the universe." ; else     System.out.println "There must be a disturbance " +         "in the space-time continuum!" ;  If you run this code, There must be a disturbance in the space-time con- tinuum! will be printed. That’s because when used on objects, the equality opera- tor tests whether two expressions refer to the same object, not to objects with the  same value.  CHAPTER 4  Working with Dates and Times      551  Comparing Dates   Calculating with Dates  To test the equality of two dates, you must use the isEqual method, as in this  example:  if  LocalDate.now  .isEqual LocalDate.now         System.out.println "All is right in the universe." ;  Similarly, you must use either the isBefore or the isAfter method to determine  whether one date falls before or after another date.  Note that you can use built-in operators with methods that return integer results.  Thus, the following code will work just as you would expect:  if  LocalDate.now  .getDayOfMonth   < 15      System.out.println "It is not yet the 15th." ;  Because the getDayOfMonth method returns an integer, you can use the < operator  to determine if the 15th of the month has yet arrived.  Just as you cannot use Java’s built-in comparison operators with dates, you also  may not use built-in mathematical operators. Instead, you can perform addition  and subtraction on dates using the various plus and minus methods, and you can  determine the difference between two dates by using the until method.  An important fact to consider when doing date and time calculations is that Date- Time objects are immutable. That means that once you create a Date-Time object,  you  cannot  change  its  value.  When  you  perform  a  calculation  on  a  Date-Time  object, the result is a new Date-Time object with a new value.  The plus and minus methods let you add various date and time units to a Date- Time object. Table 4-3 lists four variants of each for the LocalDate class, allowing  you to add or subtract years, months, weeks, and days to a LocalDate object. The  following code prints the current date, tomorrow’s date, and the date one week,  one month, and one year from now:  System.out.println "Today: " + LocalDate.now   ; System.out.println "Tomorrow: " + LocalDate.now  .plusDays 1  ; System.out.println "Next week: " + LocalDate.now  .plusWeeks 1  ; System.out.println "Next month: " + LocalDate.now  .plusMonths 1  ; System.out.println "Next year: " + LocalDate.now  .plusYears 1  ;  552      BOOK 5  Programming Techniques   To determine the difference between two dates, use the until method. It calcu- lates the difference between a date and the date passed as the first parameter,  measured in the units indicated by the second parameter. For example, the fol- lowing code determines the number of days between May 16, 2014 and December  15, 2014:  LocalDate date1 = LocalDate.parse "2014-05-16" ; LocalDate date2 = LocalDate.parse "2014-12-15" ; System.out.println date1.until date2, ChronoUnit.DAYS  ;  Some date calculations can be a bit more complex. For example, consider a busi- ness that prepares invoices on the 15th of each month. The following snippet of  code displays the number of days from the current date until the next invoicing  date:  LocalDate today = LocalDate.now  ; LocalDate invDate = LocalDate.of today.getYear  ,     today.getMonthValue  , 15 ; if  today.getDayOfMonth   > 15      invDate = invDate.plusMonths 1 ; long daysToInvoice = today.until invDate,     ChronoUnit.DAYS ; System.out.println daysToInvoice     + " until next invoice date." ;  This example works by first getting the current date, then creating a new Local- Date object that represents the 15th of the current month. Then, if the current day  of the month is greater than 15, it adds one month to the invoicing date. In other  words, if it is the 16th or later, invoicing occurs on the 15th of the following month,  not of this month. Then it uses the until method to determine the number of days  between the current date and the next invoicing date.  ChronoUnit is an enumeration that defines the various units of time that can be  used in date and time calculations. The possible values are:  CENTURIES DAYS DECADES ERAS FOREVER HALF-DAYS HOURS MICROS MILLENNIA  CHAPTER 4  Working with Dates and Times      553   MILLIS MINUTES MONTHS NANOS SECONDS WEEKS YEARS  Most of these are self-explanatory, but two of them are a bit peculiar:   » ERA indicates whether the date refers to the Common Era  CE, also known as   AD  or Before Era  BCE, also known as BC .   » FOREVER represents the largest value that can be represented as a duration.  Sadly, Java won’t let you live forever. The following code throws an exception:  LocalDate birthday = LocalDate.parse "1959-05-16 ; birthday = birthday.plus 1,ChronoUnit.FOREVER ;  Note that ChronoUnit is in the java.time.temporal package, so be sure to include  the following statement at the top of any program that uses ChronoUnit:  import java.time.temporal.*;  Formatting Dates  If  you  use  the  toString    method  to  convert  a  LocalDate  to  a  string,  you  get  a string such as 2014-10-31. What if you want to display the date in a different  format, such as 10-31-2014 or October 31, 2014? To accomplish that, you can  use  the  format  method  of  the  LocalDate  class  along  with  a  custom  formatter  you create using the DateTimeFormatter class. To specify the format you want to  use, you pass the DateTimeFormatter class a pattern string, using the formatting  symbols listed in Table 4-4.  The  easiest  way  to  create  a  DateTimeFormatter  object  is  to  use  the  static  of  Pattern method along with a pattern string. For example:  DateTimeFormatter formatter; formatter = DateTimeFormatter.ofPattern "dd MMM YYYY" ;  554      BOOK 5  Programming Techniques   TABLE 4-4	  Formatting Characters for the DateTimeFormatter Class Format pattern  Explanation  y  M  d  H  m  s  h  a  V  z  Year  two or four digits   Month  one or two digits or three or more letters   Day of month  such as 1, 28   Hour  Minute  Second  0 to 59   Clock hour  1 to 12   AM or PM  Time zone ID  such as America Los_Angeles   Time zone name  such as Pacific Daylight Time   This formatter produces dates formatted like 04 SEP 2014. You can then use the  formatter to produce a formatted date string like this:  LocalDate date = LocalDate.now  ; String formattedDate = date.format formatter ;  Here’s a simple program that prints the current date in several different formats:  import java.util.*; import java.time.*; import java.time.format.*;  public class FormatDateTime {     public static void main String[] args      {         LocalDateTime  now = LocalDateTime.now  ;         printDate now, "YYYY-MM-dd" ;         printDate now, "MM-dd-YYYY" ;         printDate now, "dd MMM YYYY" ;         printDate now, "MMMM d, YYYY" ;         printDate now, "HH:mm" ;         printDate now, "h:mm a" ;     }  CHAPTER 4  Working with Dates and Times      555       public static void printDate LocalDateTime date, String pattern      {         DateTimeFormatter f;         f = DateTimeFormatter.ofPattern pattern ;         pattern =  pattern + "             " .substring 0, 14 ;         System.out.println pattern + " " + date.format f  ;     } }  When you run this program, you’ll get console output that resembles this:  YYYY-MM-dd     2013-10-09 MM-dd-YYYY     10-09-2013 dd MMM YYYY    09 Oct 2013 MMMM d, YYYY   October 9, 2013 HH:mm          20:29 h:mm a         8:29 PM  Did you notice the cool formatting trick I used? I forced the System.out.println    patterns  to  print  14-character-long  strings  so  all  the  dates  would  line  up.  The  padding is accomplished by this slick line of code:  pattern =  pattern + "             " .substring 0, 14 ;  Here a string of 14 spaces is added to the pattern string, then a 14-character-long  substring is taken starting at the first character. I figured the nice spacing in the  output would make it easier for you to see the effect of each of the pattern strings.  Looking at a Fun Birthday Calculator  Now  that  you’ve  seen  the  techniques  for  working  with  Date-Time  objects,  it’s  time to look at a complete programming example. Listing 4-1 presents a program  that prompts the user to enter his or her birthday and then prints a variety of  interesting information deduced from the date, including:   » The day of the week on which the user was born  » The user’s age in years  » The date of the user’s next birthday  » The number of days until the user’s next birthday  » The user’s half-birthday  six months from his or her birthday   556      BOOK 5  Programming Techniques   Here’s an example of the BirthdayFun application in action:  Today is October 9, 2013.  Please enter your birthdate  yyyy-mm-dd : 1959-12-15  December 15, 1959 was a very good day! You were born on a TUESDAY. You are 53 years young. Your next birthday is December 15, 2013. That's just 67 days from now! Your half-birthday is June 15.  Another?  Y or N  N  LISTING	4-1:	  The BirthdayFun Application  import java.util.*; import java.time.*;  import java.time.format.*; import java.time.temporal.*;  public class BirthdayFun {     static Scanner sc = new Scanner System.in ;       public static void main String[] args      {         do         {             LocalDate birthDate;               DateTimeFormatter fullFormat =                  DateTimeFormatter.ofPattern "MMMM d, YYYY" ;             DateTimeFormatter monthDayFormat =                 DateTimeFormatter.ofPattern "MMMM d" ;              System.out.println "Today is "                  + LocalDate.now  .format fullFormat  + "." ;              System.out.println  ;             System.out.print "Please enter your birthdate "                 + " yyyy-mm-dd : " ;             String input = sc.nextLine  ;  →2  →8  →14  →16  →21   continued   CHAPTER 4  Working with Dates and Times      557   LISTING	4-1:	   continued               try             {                 birthDate = LocalDate.parse input ;                   if  birthDate.isAfter LocalDate.now                      {                     System.out.println "You haven't been born yet!" ;                     continue;                 }                 System.out.println  ;                 System.out.println birthDate.format fullFormat                       + " was a very good day!" ;                  DayOfWeek birthDayOfWeek = birthDate.getDayOfWeek  ;                  System.out.println "You were born on a "                     + birthDayOfWeek + "." ;                  long years = birthDate.until LocalDate.now  ,                      ChronoUnit.YEARS ;                 System.out.println "You are " + years + " years young." ;                  LocalDate nextBDay = birthDate.plusYears years + 1 ;                  System.out.println "Your next birthday is "                     + nextBDay.format fullFormat  + "." ;                  long wait = LocalDate.now  .until nextBDay,                      ChronoUnit.DAYS ;                 System.out.println "That's just " + wait                     + " days from now!" ;                  LocalDate halfBirthday = birthDate.plusMonths 6 ;                  System.out.println "Your half-birthday is "                     + halfBirthday.format monthDayFormat  + "." ;             }             catch  DateTimeParseException ex              {                 System.out.println "Sorry, that is not a valid date." ;             }         } while askAgain   ;     }  →30  →32  →40  →42  →46  →50  →54  →59      private static boolean askAgain       {         System.out.println  ;         System.out.print "Another?  Y or N  " ;  558      BOOK 5  Programming Techniques           String reply = sc.nextLine  ;         if  reply.equalsIgnoreCase "Y"           {             return true;          }          return false;     } }  The following paragraphs explain the most important lines in this program: →2         The program uses classes from three packages: java.time, java.time.  format, and java.time.temporal.  →8         A Scanner is used to get the user input. The Scanner is defined as a   class variable so that it can be accessed by both the main and the  askAgain methods.  →14      The birthdate variable is used to store the birthdate entered by the user. →16      The program uses two formatters: fullFormat formats the date in  full-text format  such as December 15, 1959  and monthDay Format  formats the date as just a month and day.  →21      This line displays the current date. →21      This line displays the current date. →31      The string entered by the user is parsed. →32      The if statement ensures that the user has not entered a date in the   future.  →40      The date entered by the user is displayed. →42      The day of the week is calculated and displayed. →46      The person’s age is calculated by determining the difference between the   current date and the birthdate in years.  →50      The date of the person’s next birthday is calculated by adding the   person’s age plus 1 year to the original birthdate.  →54      The number of days until the person’s next birthday is calculated. →59      The person’s half birthday is calculated by adding six months to the   original birthdate.  CHAPTER 4  Working with Dates and Times      559    JavaFX  6   Contents at a Glance  CHAPTER 1:  Hello, JavaFX!  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 563 CHAPTER 2:  Handling Events   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 583 CHAPTER 3:  Setting the Stage and Scene Layout   .  .  .  .  .  .  .  .  .  .  .  .  . 603 CHAPTER 4:  Using Layout Panes to Arrange Your Scenes  .  .  .  . 625 CHAPTER 5:  Getting Input from the User  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 659 CHAPTER 6:  Choosing from a List  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 681   IN THIS CHAPTER  » Getting a quick overview of what   JavaFX is and what you can do with it   » Looking at a basic JavaFX program   » Importing the classes you need to   create a JavaFX program   » Creating a class that extends the   JavaFX Application class   » Using classes such as Button,   BorderPane, and Scene to create a  user interface   » Create an event handler that will be  called when the user clicks a button   » Examining an enhanced version of   the Click Me program  Chapter 1 Hello, JavaFX!  Up to this point in this book, all the programs are console-based, like some-  thing right out of the 1980s. Console-based Java programs have their place,  especially when you’re just starting with Java. But eventually you’ll want   to create programs that work with a graphical user interface  GUI .  This  chapter  gets  you  started  in  that  direction  using  a  Java  GUI  package  called  JavaFX to create simple GUI programs that display simple buttons and text labels.  Along the way, you learn about several of the key JavaFX classes that let you create  the layout of a GUI.  Prior  to  JavaFX,  the  main  way  to  create  GUIs  in  Java  was  through  the  Swing  API.  JavaFX  is  similar  to  Swing  in  many  ways,  so  if  you’ve  ever  used  Swing  to  create a user interface for a Java program, you have a good head start at learning  JavaFX.  CHAPTER 1  Hello, JavaFX!      563   Oracle has announced that JavaFX will eventually replace Swing. Although Swing  is still supported in Java 8 and will be supported for the foreseeable future, Oracle  is concentrating new features on JavaFX. Eventually, Swing will become obsolete.  Perusing the Possibilities of JavaFX  One of the basic strengths of JavaFX is its ability to let you easily create compli- cated GUIs with all the classic user interface gizmos everyone knows and loves.  Thus, JavaFX provides a full range of controls — dozens of them in fact, including  the classics such as buttons, labels, text boxes, check boxes, drop-down lists, and  menus, as well as more exotic controls such as tabbed panes and accordion panes.  Figure 1-1 shows a typical JavaFX user interface that uses several of these control  types to create a form for data entry.  FIGURE 1-1:   A typical JavaFX  program.  564      BOOK 6  JavaFX  Truthfully, the data-entry form shown in Figure 1-1 is pretty plain. For example,  the appearance of the buttons, labels, text fields, radio buttons, and check boxes  are a bit dated. The visual difference between this dialog box and one you could  have created in Visual Basic on a Windows 95 computer 20 years ago are minor.  Where JavaFX begins to shine is in its ability to allow you to easily improve the  appearance of your user interface by using Cascading Style Sheets  CSS . CSS makes  it easy to customize many aspects of the appearance of your user interface controls  by placing all the formatting information in a separate file dubbed a style sheet.   A  style sheet  is  a  simple  text  file  that  provides  a  set  of  rules  for  formatting  the    FIGURE 1-2:   JavaFX lets you  use CSS to specify  formatting for  user interface  elements.  various elements of the user interface. You can use CSS to control literally hundreds  of formatting properties. For example, you can easily change the text properties  such as font, size, color, and weight, and you can add a background image, gradi- ent fills, borders, and special effects such as shadows, blurs, and light sources.  Figure 1-2 shows a variation of the form that was shown in Figure 1-1, this time  formatted with CSS. The simple CSS file for this form adds a background image,  enhances the text formatting, and modifies the appearance of the buttons.  !  X F a v a J   ,  o  l l e H  Besides CSS, JavaFX offers many other capabilities. For example:   » Visual effects: You can add a wide variety of visual effects to your user  interface elements, including shadows, reflections, blurs, lighting, and  perspective effects.   » Animation: You can specify animation effects that apply transitions gradually   over time.   » 3-D objects: You can draw three-dimensional objects such as cubes, cylinders,   spheres, and more complex shapes.   » Touch interface: JavaFX can handle touchscreen devices, such as smart-  phones and tablet computers with ease.  You discover all these features and more in later chapters of this minibook. But for  now, it’s time to have a look at a simple JavaFX program so you can get a feel for  what JavaFX programs look like.  CHAPTER 1  Hello, JavaFX!      565   Looking at a Simple JavaFX Program  Figure 1-3 shows the user interface for a very simple JavaFX program that includes  just a single button. Initially, the text of this button says Click me please! When  you click it, the text of the button changes to You  clicked  me! If you click the  button again, the text changes back to Click me please! Thereafter, each time  you click the button, the text cycles between Click me please! and You clicked  me! To quit the program, simply click the Close button  the X at the upper-right  corner.   FIGURE 1-3:   The Click Me  program.  Listing 1-1 shows the complete listing for this program.  LISTING 1-1:   The Click Me Program  import javafx.application.*; import javafx.stage.*; import javafx.scene.*; import javafx.scene.layout.*; import javafx.scene.control.*;  public class ClickMe extends Application {     public static void main String[] args      {         launch args ;     }      Button btn;      @Override public void start Stage primaryStage      {            Create the button  566      BOOK 6  JavaFX           btn = new Button  ;         btn.setText "Click me please!" ;         btn.setOnAction e -> buttonClick   ;             Add the button to a layout pane         BorderPane pane = new BorderPane  ;         pane.setCenter btn ;            Add the layout pane to a scene         Scene scene = new Scene pane, 300, 250 ;             Finalize and show the stage         primaryStage.setScene scene ;         primaryStage.setTitle "The Click Me App" ;         primaryStage.show  ;     }      public void buttonClick       {         if  btn.getText   == "Click me please!"          {                  }       else         {                   }     } }  !  X F a v a J   ,  o  l l e H  btn.setText "You clicked me!" ;  btn.setText "Click me please!" ;  The sections that follow describe the key aspects of this basic JavaFX program.  Importing JavaFX Packages  Like any Java program, JavaFX programs begin with a series of import statements  that reference the various JavaFX packages that the program will use. The Click  Me program includes the following five import statements:  import javafx.application.*; import javafx.stage.*; import javafx.scene.*; import javafx.scene.layout.*; import javafx.scene.control.*;  CHAPTER 1  Hello, JavaFX!      567   As you can see, all the JavaFX packages begin with javafx. The Click Me program  uses classes from five distinct JavaFX packages:   » javafx.application: This package defines the core class on which all JavaFX  applications depend: Application. You read more about the Application  class in the section “Extending the Application Class” later in this chapter.   » javafx.stage: The most important class in this package is the Stage class,  which defines the top-level container for all user interface objects. Stage is a  JavaFX application’s highest-level window, within which all the application’s  user-interface elements are displayed.   » javafx.scene: The most important class in this package is the Scene class,   which is a container that holds all the user interface elements displayed by the  program.   » javafx.scene.layout: This package defines a special type of user-interface  element called a layout manager. The job of a layout manager is to determine  the position of each control displayed in the user interface.   » java.scene.control: This package contains the classes that define individ- ual user interface controls such as buttons, text boxes, and labels. The Click  Me program uses just one class from this package, Button, which represents  a button that the user can click.  Extending the Application Class  A  JavaFX  application  is  a  Java  class  that  extends  the  javafx.application.  Application class. Thus, the declaration for the Click Me application’s main class  is this:  public class ClickMe extends Application  Here, the Click Me application is defined by a class named ClickMe, which extends  the Application class.  Because the entire javafx.application package is imported in line 1 of the Click  Me program, the Application class does not have to be fully qualified. If you omit  the  import  statement  for  the  javafx.application  package,  the  ClickMe  class  declaration would have to look like this:  public class ClickMe     extends javafx.application.Application  568      BOOK 6  JavaFX   The Application class is responsible for managing what is called the life cycle of a  JavaFX application. The life cycle consists of the following steps: 1.  Create an instance of the Application class. 2.  Call the init method.  The default implementation of the init method does nothing, but you can  override the init method to provide any processing you want to be per- formed before the application’s user interface displays.  3.  Call the start method.  The start method is an abstract method, which means that there is no default  implementation provided as a part of the Application class. Therefore, you  must provide your own version of the start method. The start method is  responsible for building and displaying the user interface.  For more informa- tion, see the section “Overriding the start Method” later in this chapter.   4.  Wait for the application to end, which typically happens when the user   signals the end of the program by closing the main application window or  choosing the program’s exit command.  During this time, the application isn’t really idle. Instead, it’s busy performing  actions in response to user events, such as clicking a button or choosing an  item from a drop-down list.  5.  Call the stop method.  Like the init method, the default implementation of the stop method doesn’t  do anything, but you can override it to perform any processing necessary as  the program terminates, such as closing database resources or saving files.  !  X F a v a J   ,  o  l l e H  Launching the Application  As  you  know,  the  standard  entry-point  for  Java  programs  is  the  main  method.  Here is the main method for the Click Me program:  public static void main String[] args  {     launch args ; }  As  you  can  see,  the  main  method  consists  of  just  one  statement,  a  call  to  the  Application class’ launch method.  CHAPTER 1  Hello, JavaFX!      569   The  launch  method  is  what  actually  starts  a  JavaFX  application.  The  launch  method is a static method, so it can be called in the static context of the main  method. It creates an instance of the Application class and then starts the JavaFX  lifecycle, calling the init and start methods, waiting for the application to fin- ish, and then calling the stop method.  The launch method doesn’t return until the JavaFX application ends. Suppose you  wrote the main method for the Click Me program like this:  public static void main String[] args  {     System.out.println "Launching JavaFX" ;     launch args ;     System.out.println "Finished" ; }  Then, you would see Launching  JavaFX displayed in the console window while  the  JavaFX  application  window  opens.  When  you  close  the  JavaFX  application   window, you would then see Finished in the console window.  Overriding the start Method  Every JavaFX application must include a start method. You write the code that  creates the user interface elements your program’s user will interact with in the  start method. For example, the start method in Listing 1-1 contains code that  displays a button with the text Click Me!  When  a  JavaFX  application  is  launched,  the  JavaFX  framework  calls  the  start  method after the Application class has been initialized.  The start method for the Click Me program looks like this:  @Override public void start Stage primaryStage  {        Create the button     btn = new Button  ;     btn.setText "Click me please!" ;     btn.setOnAction e -> buttonClick   ;         Add the button to a layout pane     BorderPane pane = new BorderPane  ;     pane.setCenter btn ;  570      BOOK 6  JavaFX          Add the layout pane to a scene     Scene scene = new Scene pane, 300, 250 ;         Finalize and show the stage     primaryStage.setScene scene ;     primaryStage.setTitle "The Click Me App" ;     primaryStage.show  ; }  !  X F a v a J   ,  o  l l e H  To create the user interface for the Click Me program, the start method performs  the following four basic steps: 1.  Create a button control named btn. The button’s text is set to Click me  please!, and a method named buttonClick will be called when the user  clicks the button.  For a more detailed explanation of this code, see the sections “Creating a  Button” and “Handling an Action Event” later in this chapter.  2.  Create a layout pane named pane and add the button to it.  For more details, see the section “Creating a Layout Pane” later in this chapter.  3.  Create a scene named scene and add the layout pane to it.  For more details, see the “Making a Scene” section later in this chapter. 4.  Finalize the stage by setting the scene, setting the stage title, and   showing the stage.  See the “Setting the Stage” section later in this chapter for more details.  You  find  pertinent  details  of  each  of  these  blocks  of  code  later  in  this  chapter.  But before I proceed, I want to point out a few additional salient details about the  start method:   » The start method is defined as an abstract method in the Application  class, so when you include a start method in a JavaFX program, you’re  actually overriding the abstract start method.  Although it isn’t required, it’s always a good idea to include the @override  annotation to explicitly state that you’re overriding the start method. If you omit  this annotation and then make a mistake in spelling the method named  for  example, Start instead of start  or if you list the parameters incorrectly, Java  thinks you’re defining a new method instead of overriding the start method.  » Unlike the main method, the start method is not a static method. When you   call the launch method from the static main method, the launch method  creates an instance of your Application class and then calls the start  method.  CHAPTER 1  Hello, JavaFX!      571    » The start method accepts one parameter: the Stage object on which the   application’s user interface will display. When the application calls your start  method, the application passes the main stage — known as the primary  stage — via the primaryStage parameter. Thus, you can use the primaryStage  parameter later in the start method to refer to the application’s stage.  Creating a Button  The  button  displayed  by  the  Click  Me  program  is  created  using  a  class  named  Button. This class is one of many classes that you can use to create user interface  controls. The Button class and most of the other control classes are found in the  package javafx.scene.control.  To  create  a  button,  simply  define  a  variable  of  type  Button  and  then  call  the  Button constructor like this:  Button btn; btn = new Button  ;  In the code in Listing 1-1, the btn variable is declared as a class variable outside  of the start method but the Button object is actually created within the start  method. Controls are often declared as class variables so that you can access them  from any method defined within the class. As you discover in the following section   “Handling an Action Event” , a separate method named buttonClicked is called  when the user clicks the button. By defining the btn variable as a class variable,  both the start method and the buttonClicked method have access to the button.  To set the text value displayed by the button, call the setText method, passing the  text to be displayed as a string:  btn.setText "Click me please!" ;  Here are a few additional tidbits about buttons:   » The Button constructor allows you to pass the text to be displayed on the   button as a parameter, as in this example:  Btn = new Button "Click me please!" ;  If you set the button’s text in this way, you don’t need to call the setTitle  method.  572      BOOK 6  JavaFX   Handling an Action Event   » The Button class is one of many classes that are derived from a parent class  known as javafx.scene.control.Control. Many other classes derive from  this class, including Label, TextField, ComboBox, CheckBox, and  RadioButton.   » The Control class is one of several different classes that are derived from   higher-level parent class called javafx.scene.Node. Node is the base class of  all user-interface elements that can be displayed in a scene. A control is a  specific type of node, but there are other types of nodes. In other words, all  controls are nodes, but not all nodes are controls. You can read more about  several other types of nodes later in this minibook.  !  X F a v a J   ,  o  l l e H  When  the  user  clicks  a  button,  an  action  event  is  triggered.  Your  program  can  respond to the event by providing an event handler, which is simply a bit of code  that will be executed whenever the event occurs. The Click Me program works by  setting up an event handler for the button; the code for the event handler changes  the text displayed on the button.  There are several ways to handle events in JavaFX. The most straightforward is to  simply specify that a method be called whenever the event occurs and then pro- vide the code to implement that method.  To specify the method to be called, you call the setOnAction method of the button  class. Here’s how it’s done in Listing 1-1:  btn.setOnAction e -> buttonClick   ;  If  the  syntax  used  here  seems  a  little  foreign,  that’s  because  it  uses  a  lambda  expression, which is a feature that was introduced into Java in version 1.8. As used  in this example, there are three elements to this new syntax:   » The argument e represents an object of type ActionEvent, which the   program can use to get detailed information about the event.  The Click Me program ignores this argument, so you can ignore it too, at least  for now.   » The arrow operator  ->  is a new operator introduced in Java 8 for use with   Lambda expressions.   » The method call buttonClick   simply calls the method named buttonClick.  CHAPTER 1  Hello, JavaFX!      573   You’ll see more examples of Lambda expressions used to handle events in Chap- ter 2 of this minibook, and you can find a more complete discussion of Lambda  expressions in Chapter 7 of Book 3.  After buttonClick has been established as the method to call when the user clicks  the button, the next step is to code the buttonClick method. You find it near the  bottom of Listing 1-1:  public void buttonClick   {     if  btn.getText   == "Click me please!"      {         btn.setText "You clicked me!" ;     }     else     {         btn.setText "Click me please!" ;     } }  This  method  uses  an  if  statement  to  alternately  change  the  text  displayed  by  the button to either  You  clicked  me! or  Click  me  please!. In other words,  if the button’s text is  Click  me  please! when the user clicks the button, the  buttonClicked method changes the text to You clicked me!. Otherwise, the if  statement changes the button’s text back to Click me please!.  The  buttonClicked  method  uses  two  methods  of  the  Button  class  to  perform   its work:   » getText: Returns the text displayed by the button as a string  » setText: Sets the text displayed by the button  For more information about handling events, see Chapter 2 of this minibook.  Creating a Layout Pane  By itself, a button is not very useful. You must actually display it on the screen  for the user to be able to click it. And any realistic JavaFX program will have more  than one control. The moment you add a second control to your user interface,  you need a way to specify how the controls are positioned relative to one another.   574      BOOK 6  JavaFX   For example, if your application has two buttons, do you want them to be stacked  vertically, one above the other, or side by side?  That’s where layout panes come in. A layout pane is a container class to which you  can add one or more user-interface elements. The layout pane then determines  exactly how to display those elements relative to each other.  To use a layout pane, you first create an instance of the pane. Then, you add one or  more controls to the pane. When you do so, you can specify the details of how the  controls will be arranged when the pane is displayed. After you add all the controls  to the pane and arrange them just so, you add the pane to the scene.  JavaFX  provides  a  total  of  eight  distinct  types  of  layout  panes,  all  defined  by  classes in the package javafx.scene.layout. The Click Me program uses a type  of layout called a border pane, which arranges the contents of the pane into five  general regions: top, left, right, bottom, and center. The BorderPane class is ideal  for layouts in which you have elements such as a menu and toolbar at the top, a  status bar at the bottom, optional task panes or toolbars on the left or right, and a  main working area in the center of the screen.  !  X F a v a J   ,  o  l l e H  The lines that create the border pane in the Click Me program are  BorderPane pane = new BorderPane  ; pane.setCenter btn ;  Here,  a  variable  of  type  BorderPane  is  declared  with  the  name  pane,  and  the  BorderPane  constructor  is  called  to  create  a  new  BorderPane  object.  Then,  the  setCenter  method  is  used  to  display  the  button   btn   in  the  center  region  of  the pane.  Here are a few other interesting details about layout panes:   » Layout panes automatically adjust the exact position of the elements they  contain based on the size of the elements contained in the layout as well as  on the size of the space in which the layout pane is displayed.   » I said earlier that controls are a type of node, and that you would read about  other types of nodes later in this book. Well, you just read about one: A layout  pane is also a type of node.   » Each region of a border pane can contain a node. Because a layout pane itself   is a type of node, each region of a border pane can contain another layout  pane. For example, suppose you want to display three controls in the center  region of a border pane. To do that, you’d create a second layout pane and   CHAPTER 1  Hello, JavaFX!      575   add the three controls to it. Then, you’d set the second layout pane as the  node to be displayed in the center region of the first layout pane.   » You read more about the BorderPane class and a few other commonly used   layout panes in Chapter 4 of this minibook.  Making a Scene  After you create a layout pane that contains the controls you want to display, the  next step is to create a scene that will display the layout pane. You can do that in a  single line of code that declares a variable of type Scene and calls the Scene class  constructor. Here’s how I did it in the Click Me program:  Scene scene = new Scene pane, 300, 250 ;  The Scene constructor accepts three arguments:   » A node object that represents the root node to be displayed by the scene. A scene can have only one root node, so the root node is usually a layout  pane, which in turn contains other controls to be displayed. In the Click Me  program, the root note is the border layout pane that contains the button.   » The width of the scene in pixels.  » The height of the scene in pixels.  Note: If you omit the width and height, the scene will be sized automatically based  on the size of the elements contained within the root node.  You can find out about some additional capabilities of the Scene class in Chapter 3  of this minibook.  Setting the Stage  If the scene represents the nodes  controls and layout panes  that are displayed by  the application, the stage represents the window in which the scene is displayed.  When the JavaFX framework calls your application’s start method, it passes you  an instance of the Stage class that represents the application’s primary stage —  that is, the stage that represents the application’s main window. This reference is  passed via the primaryStage argument.  576      BOOK 6  JavaFX   Having created your scene, you’re now ready to finalize the primary stage so that  the scene can be displayed. To do that, you must do at least two things:   » Call the setScene method of the primary stage to set the scene to be displayed.  » Call the show method of the primary stage to display the scene.  After you call the show method, your application’s window becomes visible to  the user and the user can then begin to interact with its controls.  It’s also customary to set the title displayed in the application’s title bar. You do  that by calling the setTitle method of the primary stage. The last three lines of  the start method for the Click Me application perform these functions:  primaryStage.setScene scene ; primaryStage.setTitle "The Click Me App" ; primaryStage.show  ;  When the last line calls the show method, the Stage displays — in other words,  the window that was shown in Figure 2-1 displays onscreen.  You can read about additional capabilities of the Stage class in Chapter 3 of this  minibook.  !  X F a v a J   ,  o  l l e H  Examining the Click Counter Program  Now that I’ve explained the details of every line of the Click Me program, I look  at a slightly enhanced version of the Click Me program called the Click Counter  program. In the original Click Me program that was shown earlier in this chapter   Listing 1-1 , the text displayed on the button changes when the user clicks the  button. In the Click Counter program, an additional type of control called a label  displays the number of times the user has clicked the button.  Figure 1-4 shows the Click Counter program in operation. The window at the top  of this figure shows how the Click Counter program appears when you first start  it. As you can see, the text label at the top of the window displays the text You  have  not  clicked  the  button. The second window shows what the program  looks like after you click the button the first time. Here, the label reads You have  clicked the button once. When the button is clicked a second time, the label  changes  again,  as  shown  in  the  third  window.  Here,  the  label  reads  You  have  clicked  the  button  2  times. After that, the number displayed by the label  updates each time you click the button to indicate how many times the button has  been clicked.  CHAPTER 1  Hello, JavaFX!      577   Listing 1-2 shows the source code for the Click Counter program, and the follow- ing paragraphs describe the key points of how it works:  FIGURE 1-4:   The Click Counter  program in  action.  LISTING 1-2:   The Click Counter Program  import javafx.application.*;  import javafx.stage.*; import javafx.scene.*; import javafx.scene.layout.*; import javafx.scene.control.*;  public class ClickCounter extends Application  {     public static void main String[] args       {         launch args ;      }      Button btn;      Label lbl;      int iClickCount = 0;       @Override public void start Stage primaryStage       {  578      BOOK 6  JavaFX  →1  →7  →9  →11  →14 →15 →16  →18              Create the button         btn = new Button  ;          btn.setText "Click me please!" ;          btn.setOnAction e -> buttonClick   ;              Create the Label         lbl = new Label  ;          lbl.setText "You have not clicked the button." ;              Add the label and the button to a layout pane         BorderPane pane = new BorderPane  ;          pane.setTop lbl ;          pane.setCenter btn ;              Add the layout pane to a scene         Scene scene = new Scene pane, 250, 150 ;              Add the scene to the stage, set the title            and show the stage         primaryStage.setScene scene ;          primaryStage.setTitle "Click Counter" ;          primaryStage.show  ;      }      public void buttonClick        {         iClickCount++;          if  iClickCount == 1           {             lbl.setText "You have clicked once." ;          }         else         {             lbl.setText "You have clicked "                  + iClickCount + " times."  ;         }     }  }  →21 →22 →23  →26 →27  →30 →31 →32  →35  →39 →40 →41  →44  →46 →47  →49  →53  !  X F a v a J   ,  o  l l e H  The following paragraphs explain the key points of the Click Me program: →1        The import statements reference the javafx packages that will be used   by the Click me program.  →7        The ClickMe class extends javafx.application.Application, thus   specifying that the ClickMe class is a JavaFX application.  CHAPTER 1  Hello, JavaFX!      579   →9        As with any Java program, the main method is the main entry point for all   JavaFX programs.  →11      The main method calls the launch method, which is defined by the   Application class. The launch method, in turn, creates an instance of  the ClickMe class and then calls the start method.  →14      A variable named btn of type javafx.scene.control.Button is   declared as a class variable. Variables representing JavaFX controls are  commonly defined as class variables so that they can be accessed by any  method in the class.  →15      A class variable named lbl of type javafx.scene.control.Label   represents the Label control so that it can be accessed from any  method in the class.  →16      A class variable named iClickCount will be used to keep track of the   number of times the user clicks the button.  →18      The declaration of the start method uses the @override annotation,  indicating that this method overrides the default start method pro- vided by the Application class. The start method accepts a parameter  named primaryStage, which represents the window in which the Click  Me application will display its user interface.  →21      The start method begins by creating a Button object and assigning it to   a variable named btn.  →22      The button’s setText method is called to set the text displayed by the   button to Click Me Please!.  →23      The setOnAction is called to create an event handler for the button.  Here, a Lambda expression is used to simply call the buttonClick  method whenever the user clicks the button.  →26      The constructor of the Label class is called to create a new label. →27      The label’s setText method is called to set the initial text value of the   label to You have not clicked the button..  →30      A border pane object is created by calling the constructor of the   BorderPane class, referencing the border pane via a variable named  pane. The border pane will be used to control the layout of the controls  displayed on the screen.  →31      The border pane’s setTop method is called to add the label to the top   region of the border pane.  →32      The border pane’s setCenter method is called to add the button to the   center region of the border pane.  580      BOOK 6  JavaFX   →35      A scene object is created by calling the constructor of the Scene class,   passing the border pane created in line 30 to the constructor to establish  the border pane as the root node of the scene. In addition, the dimen- sions of the scene are set to 300 pixels in width and 250 pixels in height. →39      The setScene method of the primaryStage is used to add the scene to   the primary stage.  stage’s title bar.  →40      The setTitle method is used to set the text displayed in the primary   →41      The show method is called to display the primary stage. When this line is   executed, the window that was shown in Figure 2-1 displays on the  screen and the user can begin to interact with the program.  →44      The buttonClick method is called whenever the user clicks the button. →46      The iClickCount variable is incremented to indicate that the user has   clicked the button.  →47      An if statement is used to determine whether the button has been   clicked one or more times.  →49      If the button has been clicked once, the label text is set to You have   clicked once..  →53      Otherwise, the label text is set to a string that indicates how many times   the button has been clicked.  !  X F a v a J   ,  o  l l e H  That’s all there is to it. If you understand the details of how the Click Counter  program works, you’re ready to move on to Chapter 3. If you’re still struggling  with  a  few  points,  I  suggest  you  spend  some  time  reviewing  this  chapter  and  experimenting with the Click Counter program in TextPad, Eclipse, or NetBeans.  The following paragraphs help clarify some of the key sticking points that might  be tripping you up about the Click Counter program and JavaFX in general:   » When does the program switch from static to non-static? Like every Java  program, the main entry point of a JavaFX program is the static main method.  In most JavaFX programs, the static main method does just one thing: It calls  the launch method to start the JavaFX portion of the program. The launch  method creates an instance of the ClickCounter class and then calls the  start method. At that point, the program is no longer running in a static  context because an instance of the ClickCounter class has been created.  CHAPTER 1  Hello, JavaFX!      581    » Where does the primaryStage variable come from? The primaryStage  variable is passed to the start method when the launch method calls the  start method. Thus, the start method receives the primaryStage variable  as a parameter.  That’s why you won’t find a separate variable declaration for the primary  Stage variable.   » How does the -> operator work? The -> operator is used to create what is  known as a Lambda expression. Lambda expressions were introduced with  Java 8 and are often used in situations that would’ve previously required an  anonymous class. For more information, please refer to Chapter 7 of Book 3.  582      BOOK 6  JavaFX   IN THIS CHAPTER  » Understanding important event   concepts   » Working with event-handling classes   and interfaces   » Extending the EventHandler interface   » Using inner and anonymous classes   for event handling   » Using lambda expressions for event   handling  Chapter 2 Handling Events  In Chapter 1 of this minibook, you examined two programs that display simple   scenes that include a button and that respond when the user clicks the button.  These programs respond to the event triggered when the user clicks the button   by providing an event handler that’s executed when the event occurs.  In this chapter, you read more details about how event handling works in JavaFX.   I discuss how events are generated and how they’re dispatched by JavaFX so that  your programs can respond to them. You discover the many varieties of events  that can be processed by a JavaFX program. And you figure out several program- ming techniques for handling JavaFX events.  Finally, in this chapter you’re introduced to the idea of property bindings, which  let you write code that responds to changes in the value of certain types of class  fields, dubbed property fields.  Although event handling is used mostly to respond to button clicks, it can also be  used to respond to other types of user interactions. You can use event handling,  for example, to write code that’s executed when the user makes a selection from  a combo box, moves the mouse over a label, or presses a key on the keyboard. The  event-handling techniques in this chapter work for those events as well.  CHAPTER 2  Handling Events      583   Examining Events  An event is an object that’s generated when the user does something noteworthy  with one of your user-interface components. Then this event object is passed to a  special method you create, called an event handler. The event handler can examine  the  event  object,  determine  exactly  what  type  of  event  occurred,  and  respond  accordingly. If the user clicks a button, the event handler might write any data  entered by the user via text fields to a file. If the user passes the mouse cursor  over a label, the event handler might change the text displayed by the label. And  if the user selects an item from a combo box, the event handler might use the  value that was selected to look up information in a database. The possibilities are  endless!  An event is represented by an instance of the class javafx.event.Event or one of  its many subclasses. Table 2-1 lists the most commonly used event classes.  TABLE 2-1	  Event Class  Commonly Used Event Classes Description  Package  ActionEvent  javafx.event  Created when the user performs an action with a  button or other component. Usually this means that  the user clicked the button, but the user can also  invoke a button action by tabbing to the button and  pressing the Enter key. This is the most commonly used  event class, as it represents the most common types of  user-interface events.  Created when an event that results from user input,  such as a mouse or key click, occurs.  Created when the user presses a key on the keyboard.  This event can be used to watch for specific keystrokes  entered by the user.  KeyEvent is a subclass of  InputEvent.   Created when the user does something interesting  with the mouse, such as clicking one of the buttons,  dragging the mouse, or simply moving the mouse  cursor over another object.  MouseEvent is a subclass  of InputEvent.   Created when a user initiates a touch event on a device  that allows touch input.  Created when the status of the window  stage    changes.  InputEvent  javafx.scene.input  KeyEvent  javafx.scene.input  MouseEvent  javafx.scene.input  TouchEvent  javafx.scene.input  WindowEvent  javafx.stage  584      BOOK 6  JavaFX   Here are four important terms you need to know:   » Event: An object that’s created when the user does something noteworthy   with a component, such as clicking it.   » Event source: The object on which the event initially occurred.  » Event target: The node that the event is directed at.  This is usually the button or other control that the user clicked or otherwise  manipulated.  In most cases, the event source and the event target are the  same.    » Event handler: The object that listens for events and handles them when   they occur.  The event-listener object must implement the EventHandler interface, which  defines a single method named handle  see Table 2-2 . The EventHandler  interface is defined in the package javafx.event.  TABLE 2-2	  The EventHandler Interface Method  Description  void handle   Called when an event occurs  Handling Events  s t n e v E g n     i l  d n a H  Now that you know the basic classes and interfaces that are used for event han- dling,  you’re  ready  to  figure  out  how  to  wire  them  to  create  a  program  that  responds to events.  In this section, I discuss how to implement the event handler by coding the pro- gram’s  Application so that in addition to extending the  Application class, it  also implements the EventHandler interface. In subsequent sections of this chap- ter, I discuss alternative techniques to implement event handlers that are more  concise and, in many cases, easier to work with.  Note that the programs that were shown in Chapter 1 of this minibook use the   concise  lambda  expressions  technique,  and  most  of  the  programs  featured  throughout the rest of this Book also use lambda expressions. But it’s important  that you know the other techniques so that you have a complete understanding of  how event handling actually works.  CHAPTER 2  Handling Events      585   Here are three steps you must take to handle a JavaFX event: 1.  Create an event source.  An event source is simply a control, such as a button, that can generate  events. Usually, you declare the variable that refers to the event source  as a private class field, outside the start method or any other class   methods:  private Button btn;  Then, in the start method, you can create the button like this:  btn = new Button  ; btn.setText "Click me please!" ;  2.  Create an event handler.  To create an event handler, you must create an object that implements an  interface appropriately named EventHandler. This object must provide an  implementation of the handle method.  Here are four ways to create an event handler:    Add implements EventHandler to the program’s Application class and   provide an implementation of the handle method.  You figure out how to use this technique in the section “Implementing the  EventHandler Interface.”     Create an inner class that implements EventHandler within the   Application class.  You figure out how to use this technique in the section “Handling Events  with Inner Classes.”     Create an anonymous class that implements EventHandler.  I show you how to use this technique in the section “Handling Events with  Anonymous Inner Classes.”     Use a lambda expression to implement the handle method.  You read about how to use this technique in the section “Using Lambda  Expressions to Handle Events.”  3.  Register the event handler with the event source.  The final step is to register the event handler with the event source so that the  handle method is called whenever the event occurs.  586      BOOK 6  JavaFX   Every component that serves as an event source provides a method that lets  you register event handlers to listen for the event. For example, a Button  control provides a setOnAction method that lets you register an event  handler for the action event. In the setOnAction method, you specify the  event handler object as a parameter. The exact way you do that depends on  which of the various techniques you used to create the event handler.  Implementing the EventHandler Interface  To see how all these elements work together in a complete program, Figure 2-1  shows the output from a simple program called AddSubtract1. This program dis- plays a label and two buttons, one titled Add and the other titled Subtract. The  label initially displays the number 0. Each time the user clicks the Add button,  the value displayed by the label is increased by one; each time the user clicks the  Subtract button, the value is decreased by one.  FIGURE 2-1:   The AddSubtract1  program.  Listing 2-1 shows the complete code for this program.  LISTING	2-1:	  The AddSubtract1 Program  import javafx.application.*; import javafx.stage.*; import javafx.scene.*; import javafx.scene.layout.*; import javafx.scene.control.*; import javafx.event.*;   public class AddSubtract extends Application     implements EventHandler    {     public static void main String[] args       {         launch args ;     }  s t n e v E g n     i l  d n a H  →6  →9  →11   continued   CHAPTER 2  Handling Events      587   LISTING	2-1:	   continued       Button btnAdd;      Button btnSubtract;     Label lbl;     int iCounter = 0;       @Override public void start Stage primaryStage       {            Create the Add button         btnAdd = new Button  ;          btnAdd.setText "Add" ;         btnAdd.setOnAction this ;              Create the Subtract button         btnSubtract = new Button  ;          btnSubtract.setText "Subtract" ;         btnSubtract.setOnAction this ;             Create the Label          lbl = new Label  ;         lbl.setText Integer.toString iCounter  ;             Add the buttons and label to an HBox pane         HBox pane = new HBox 10 ;          pane.getChildren  .addAll lbl, btnAdd, btnSubtract ;              Add the layout pane to a scene         Scene scene = new Scene pane, 200, 75 ;              Add the scene to the stage, set the title            and show the stage         primaryStage.setScene scene ;          primaryStage.setTitle "Add Sub" ;         primaryStage.show  ;     }      @Override public void handle ActionEvent e       {         if  e.getSource  ==btnAdd           {             iCounter++;         }         else         {             if  e.getSource  ==btnSubtract    588      BOOK 6  JavaFX  →16  →19  →21  →24  →26  →29  →33  →38 →39  →42  →46  →51  →53  →59               {                 iCounter--;             }         }         lbl.setText Integer.toString iCounter  ;      }  }  →64  The following paragraphs point out some key lines of the program:  →6        The program must import the javafx.event package, which defines the   ActionEvent class and the EventHandler interfaces.  →9        As in any JavaFX program, the AddSubtract1 class extends the   Application class. However, the AddSubtract1 class also implements  the EventHandler interface so that it can define a handle method that  will handle ActionEvent events that are generated by the buttons.          The EventHandler interface is a generic interface, which means that you  must specify the specific event type that the interface will implement. In  this case, the class will handle ActionEvent events.  →11      The main method is required as usual. This method simply calls the   launch method to create an instance of the AddSubtract class, which in  turn calls the start method.  →16      Two buttons  btnAdd and btnSubtract  and a label  lbl  are defined as   class fields so that they can be accessed throughout the class.  →19      The iCounter variable keeps track of the value displayed by the label.  The value will be incremented when the user clicks the btnAdd button  and decremented when the user clicks the btnSubtract button.  →21      The start method is called when the application is started. →24      This line and the next line create the Add button and set its text to   display the word Add.  →26      This line sets the current object as the event handler for the btnAdd   button. The this keyword is used here because the AddSubtract class  implements the EventHandler. In effect, the AddSubtract class itself  handles any events that are created by its own controls.  s t n e v E g n     i l  d n a H  CHAPTER 2  Handling Events      589   →29      These lines create the Subtract button, set its text to the word Subtract,  and set the current object  this  as the event handler for the button. →33      These two lines create the label and set its initial text value to a string   equivalent of the iCounter variable.  →38      For this program, a border pane is not the appropriate type of layout   pane. Instead, for this program, use a new type of layout pane called an  HBox. An HBox pane arranges any controls you add to it in a horizontal  row. The parameter 10 indicates that the controls should be separated  from one another by a space ten pixels wide.  →39      This line adds the label and the two buttons to the horizontal box. The  code required to do this is admittedly a bit convoluted. First, you must  call the getChildren method to get a list of all the child nodes that are  in the HBox. Then, you call the addAll method to add one or more  controls. In this case, three controls are added: the label  lbl , the Add  button  btnAdd , and the Subtract button  btnSubtract .  →42      This line creates a new scene, using the HBox pane as its root node. →46      This line sets the scene created in line 42 as the primary scene for the   stage, sets the stage title, and then shows the stage.  →51      The handle method must be coded because the AddSubtract class   implements the EventHandler interface. This method is called by either  of the button objects whenever the user clicks one of the buttons. The  ActionEvent parameter is the event generated by the button click and  passed to the handle method.  →53      The getSource method of the ActionEvent parameter is called to   determine the event source. If the event source is btnAdd, the iCounter  variable is incremented.  →59      If, on the other hand, the event source is btnSubtract, the iCounter   variable is decremented.  →64      The label’s text value is set to the string equivalent of the iCounter   →35      This statement increments the click count to indicate that the button has   variable.  been clicked.  →36      This if statement tests the value of the clickCount field and changes   the text displayed by the button accordingly.  590      BOOK 6  JavaFX   Handling Events with Inner Classes  An inner class is a class that’s nested within another class. Inner classes are com- monly used for event handlers. That way, the class that defines the application  doesn’t also have to implement the event handler. Instead, it includes an inner  class that handles the events.  Listing 2-2 shows the AddSubtract2 program, which uses an inner class to handle  the action event for the buttons.  LISTING	2-2:	  The AddSubtract2 Program with an Inner Class  import javafx.application.*; import javafx.stage.*; import javafx.scene.*; import javafx.scene.layout.*; import javafx.scene.control.*; import javafx.event.*;  public class AddSubtract2 extends Application  {     public static void main String[] args      {         launch args ;     }      Button btnAdd;     Button btnSubtract;     Label lbl;     int iCounter = 0;      @Override public void start Stage primaryStage      {            Create a ClickHandler instance         ClickHandler ch = new ClickHandler  ;              Create the Add button         btnAdd = new Button  ;         btnAdd.setText "Add" ;         btnAdd.setOnAction ch ;              Create the Subtract button         btnSubtract = new Button  ;         btnSubtract.setText "Subtract" ;         btnSubtract.setOnAction ch ;   s t n e v E g n     i l  d n a H  →8  →23  →28  →33   continued   CHAPTER 2  Handling Events      591   LISTING	2-2:	   continued              Create the Label         lbl = new Label  ;         lbl.setText Integer.toString iCounter  ;             Add the buttons and label to an HBox pane         HBox pane = new HBox 10 ;         pane.getChildren  .addAll lbl, btnAdd, btnSubtract ;             Add the layout pane to a scene         Scene scene = new Scene pane, 200, 75 ;             Add the scene to the stage, set the title            and show the stage         primaryStage.setScene scene ;         primaryStage.setTitle "Add Sub" ;         primaryStage.show  ;     }      private class ClickHandler          implements EventHandler       {         @Override public void handle ActionEvent e           {             if  e.getSource  ==btnAdd              {                 iCounter++;             }             else             {                 if  e.getSource  ==btnSubtract                  {                     iCounter--;                 }             }             lbl.setText Integer.toString iCounter  ;         }     }  }  →53  →56  This program works essentially the same way as the program shown in Listing 2-1,  so I don’t review every detail. Instead, I just highlight the differences:  →8        The AddSubtract2 class still extends Application but doesn’t    implement EventHandler.  592      BOOK 6  JavaFX   →23      This statement creates an instance of the ClickHandler class  the inner   class  and assigns it to the variable ch.  →28      This statement sets ch as the action listener for the Add button. →33      This statement sets ch as the action listener for the Subtract button. →53      The ClickHandler class is declared as an inner class by placing its   declaration completely within the AddSubtract2 class. The  ClickHandler class implements the EventHandler interface so that it  can handle events.  →38      The handle method here is identical to the handle method in the   AddSubtract1 program  see Listing 2-1  but resides in the inner  ClickHandler class instead of in the outer class.  Handling Events with Anonymous  Inner Classes  An anonymous inner class, usually just called an anonymous class, is a class that’s  defined on the spot, right at the point where you need it. Because you code the  body of the class right where you need it, you don’t have to give it a name; that’s  why it’s called an anonymous class.  Anonymous classes are often used for event handlers to avoid the need to create a  separate class that explicitly implements the EventHandler interface.  One advantage of using anonymous classes for event handlers is that you can eas- ily create a separate event handler for each control that generates events. Then, in  the handle method for those event handlers, you can dispense with the if state- ments that check the event source.  s t n e v E g n     i l  d n a H  Consider  the  event  handler  for  the  AddSubtract2  program  shown  earlier  in  Listing 2-2: It must check the event source to determine whether to increment  or decrement the iCounter variable. By using anonymous classes, you can create  separate event handlers for the Add and Subtract buttons. The event handler for  the Add button increments iCounter, and the event handler for the Subtract button  decrements it. Neither event handler needs to check the event source because the  event handler’s handle method will be called only when an event is raised on the  button with which the handler is associated.  CHAPTER 2  Handling Events      593   Listing  2-3  shows  the  AddSubtract3  program,  which  uses  anonymous  inner  classes in this way.  LISTING	2-3:	  The AddSubtract3 Program with Anonymous Inner Classes  import javafx.application.*; import javafx.stage.*; import javafx.scene.*; import javafx.scene.layout.*; import javafx.scene.control.*; import javafx.event.*;  public class AddSubtract3 extends Application {     public static void main String[] args      {         launch args ;     }      Button btnAdd;     Button btnSubtract;     Label lbl;     int iCounter = 0;      @Override public void start Stage primaryStage      {            Create the Add button         btnAdd = new Button  ;         btnAdd.setText "Add" ;         btnAdd.setOnAction              new EventHandler                 {                 public void handle ActionEvent e                   {                     iCounter++;                      lbl.setText Integer.toString iCounter  ;                 }             }  ;             Create the Subtract button         btnSubtract = new Button  ;         btnSubtract.setText "Subtract" ;         btnSubtract.setOnAction              new EventHandler                 {                 public void handle ActionEvent e                   {  →26  →28  →30  →39  →41  594      BOOK 6  JavaFX                       iCounter--;                     lbl.setText Integer.toString iCounter  ;                 }             }  ;             Create the Label         lbl = new Label  ;         lbl.setText Integer.toString iCounter  ;             Add the buttons and label to an HBox pane         HBox pane = new HBox 10 ;         pane.getChildren  .addAll lbl, btnAdd, btnSubtract ;             Add the layout pane to a scene         Scene scene = new Scene pane, 200, 75 ;             Add the scene to the stage, set the title            and show the stage         primaryStage.setScene scene ;         primaryStage.setTitle "Add Sub" ;         primaryStage.show  ;     } }  s t n e v E g n     i l  d n a H  The  following  paragraphs  highlight  the  key  points  of  how  this  program  uses  anonymous inner classes to handle the button events:  →26      This line calls the setOnAction method of the Add button and creates   an anonymous instance of the EventHandler class, specifying  ActionEvent as the type.  →28      The handle method must be defined within the body of the anonymous   class.  →30      Because this handle method will be called only when the Add button is   clicked  not when the Subtract button is clicked , it does not need to  determine the event source. Instead, the method simply increments the  counter variable and sets the label text to display the new value of the  counter.  →39      This line calls the setOnAction method of the Subtract button and  creates another anonymous instance of the EventHandler class.  →41      This time, the handle method decrements the counter variable and   updates the label text to display the new counter value.  CHAPTER 2  Handling Events      595   Using Lambda Expressions   to Handle Events  Java  8  introduces  a  new  feature  that  in  some  ways  is  similar  to  anonymous  classes, but with more concise syntax. More specifically, a lambda expression lets  you create an anonymous class that implements a specific type of interface — a   functional interface — which has one and only one abstract method.  The EventHandler interface used to handle JavaFX events meets that definition: It  has just one abstract method, handle. Thus, EventHandler is a functional inter- face and can be used with lambda expressions.  A lambda expression is a concise way to create an anonymous class that imple- ments a functional interface. Instead of providing a formal method declaration  that includes the return type, method name, parameter types, and method body,  you simply define the parameter types and the method body. The Java compiler  infers the rest based on the context in which you use the lambda expression.  The parameter types are separated from the method body by a new operator — the  arrow operator — which consists of a hyphen followed by a greater-than symbol.  Here’s  an  example  of  a  lambda  expression  that  implements  the  EventHandler  interface:  e ->     {         iCounter++;         lbl.setText Integer.toString iCounter ;     }  In this case the lambda expression implements a functional interface whose sin- gle method accepts a single parameter, identified as e. When the method is called,  the iCounter variable is incremented and the label text is updated to display the  new counter value.  Here’s  how  you’d  register  this  lambda  expression  as  the  event  handler  for  a  button:  btnAdd.setOnAction  e ->     {         iCounter++;         lbl.setText Integer.toString iCounter  ;     }  ;  596      BOOK 6  JavaFX   One of the interesting things about lambda expressions is that you don’t need to  know the name of the method being called. This is possible because a functional  interface used with a lambda expression can have only one abstract method. In the  case of the EventHandler interface, the method is named handle.  You also do not need to know the name of the interface being implemented. This  is possible because the interface is determined by the context. The setOnAction  method  takes  a  single  parameter  of  type  EventHandler.  Thus,  when  you  use  a  lambda expression in a call to  setOnAction, the Java compiler can deduce that  the lambda expression will implement the EventHandler interface. And because  the only abstract method of  EventHandler is the  handle method, the compiler  can deduce that the method body you supply is an implementation of the handle  method.  In a way, lambda expressions take the concept of anonymous classes two steps  further. When you use an anonymous class to set an event handler, you must know  and specify the name of the class  EventHandler  and the name of the method to  be called  handle , so the only sense in which the class is anonymous is that you  don’t need to provide a name for a variable that will reference the class. But when  you use a lambda expression, you don’t have to know or specify the name of the  class, the method, or a variable used to reference it. All you have to do, essentially,  is provide the body of the handle method.  Listing 2-4 shows the AddSubtract4 program, which uses lambda expressions to  handle the button clicks.  LISTING	2-4:	  The AddSubtract4 Program with Lambda Expressions  s t n e v E g n     i l  d n a H  import javafx.application.*; import javafx.stage.*; import javafx.scene.*; import javafx.scene.layout.*; import javafx.scene.control.*; import javafx.event.*;  public class AddSubtract4 extends Application {     public static void main String[] args      {         launch args ;     }      Button btnAdd;     Button btnSubtract;   continued   CHAPTER 2  Handling Events      597   LISTING	2-4:	   continued       Label lbl;     int iCounter = 0;  →25  →34      @Override public void start Stage primaryStage      {            Create the Add button         btnAdd = new Button  ;         btnAdd.setText "Add" ;         btnAdd.setOnAction  e ->              {                 iCounter++;                 lbl.setText Integer.toString iCounter  ;             }  ;             Create the Subtract button         btnSubtract = new Button  ;         btnSubtract.setText "Subtract" ;         btnSubtract.setOnAction  e ->              {                 iCounter--;                 lbl.setText Integer.toString iCounter  ;             }  ;             Create the Label         lbl = new Label  ;         lbl.setText Integer.toString iCounter  ;             Add the buttons and label to an HBox pane         HBox pane = new HBox 10 ;         pane.getChildren  .addAll lbl, btnAdd, btnSubtract ;             Add the layout pane to a scene         Scene scene = new Scene pane, 200, 75 ;             Add the scene to the stage, set the title            and show the stage         primaryStage.setScene scene ;         primaryStage.setTitle "Add Sub" ;         primaryStage.show  ;     }  }  598      BOOK 6  JavaFX   This  program  works  essentially  the  same  way  as  the  program  shown  in   Listing 2-3, so I just point out the features directly related to the use of the lambda  expression:  →25      This statement uses a lambda expression to add an event handler to the  Add button. The method body of this lambda expression increments the  counter variable and then sets the label text to reflect the updated value.  →34      This statement uses a similar lambda expression to create the event   handler for the Subtract button. The only difference between this  lambda expression and the one for the Add button is that here the  counter variable is decremented instead of incremented.  Note that in this example, the lambda expressions for the two event handlers are  simple because very little processing needs to be done when either of the buttons  in this program are clicked. What would the program look like, however, if the  processing required for one or more of the button clicks required hundreds of lines  of Java code to implement? The lambda expression would become unwieldy. For  this reason, I often prefer to isolate the actual processing to be done by an event  handler in a separate method. Then, the lambda expression itself includes just one  line of code that simply calls the method.  Listing 2-5 shows another variation of the AddSubtract5 program implemented  using that technique. Note that the technique used in Listing 2-5 is the technique  that most of the remaining programs in this book use.  LISTING	2-5:	  The AddSubtract5 Program with Lambda Expressions  s t n e v E g n     i l  d n a H  import javafx.application.*; import javafx.stage.*; import javafx.scene.*; import javafx.scene.layout.*; import javafx.scene.control.*; import javafx.event.*;  public class AddSubtract5 extends Application {     public static void main String[] args      {         launch args ;     }      Button btnAdd;   continued   CHAPTER 2  Handling Events      599   LISTING	2-5:	   continued       Button btnSubtract;     Label lbl;     int iCounter = 0;      @Override public void start Stage primaryStage      {            Create the Add button         btnAdd = new Button  ;         btnAdd.setText "Add" ;         btnAdd.setOnAction  e -> btnAdd_Click    ;              Create the Subtract button         btnSubtract = new Button  ;         btnSubtract.setText "Subtract" ;         btnSubtract.setOnAction  e -> btnSubtract_Click    ;              Create the Label         lbl = new Label  ;         lbl.setText Integer.toString iCounter  ;             Add the buttons and label to an HBox pane         HBox pane = new HBox 10 ;         pane.getChildren  .addAll lbl, btnAdd, btnSubtract ;             Add the layout pane to a scene         Scene scene = new Scene pane, 200, 75 ;             Add the scene to the stage, set the title            and show the stage         primaryStage.setScene scene ;         primaryStage.setTitle "Add Sub" ;         primaryStage.show  ;     }      private void btnAdd_Click        {         iCounter++;         lbl.setText Integer.toString iCounter  ;     }      private void btnSubtract_Click     →25  →30  →50  →56  600      BOOK 6  JavaFX       {         iCounter--;         lbl.setText Integer.toString iCounter  ;     }  }  The  following  paragraphs  highlight  the  important  points  of  this  version  of  the  program:  →25      The setOnAction method for the Add button uses a lambda expression  to specify that the method named btnAdd_Click should be called when  the user clicks the button.  →30      The setOnAction method for the Subtract button uses a lambda  expression to specify that the method named btnSubtract_Click  should be called when the user clicks the button.  →50      The btnAdd_Click method increments the counter and updates the   label’s text to reflect the updated counter value.  →56      Likewise, the btnSubtract_Click method decrements the counter and   updates the label’s text accordingly.  s t n e v E g n     i l  d n a H  CHAPTER 2  Handling Events      601    IN THIS CHAPTER  » Looking at some useful methods of   the Stage and Scene classes   » Alternating scenes within a single   stage   » Displaying alert boxes   » Discovering the proper way to exit    a JavaFX program  Chapter 3 Setting the Stage and  Scene Layout  O for a Muse of fire, that would ascend The brightest heaven of Invention,  A kingdom for a stage, princes to act, And monarchs to behold the swelling scene!  So begins William Shakespeare’s play Henry V, and so also begins this  chapter,   in which I explore the various ways to manipulate the appearance of a JavaFX  application by manipulating its stage and its swelling scenes.  Specifically, this chapter introduces you to important details about the Stage class  and the Scene class so that you can control such things as whether the window  is resizable and if so, whether it has a maximum or a minimum size. You also  learn how to coerce your programs into displaying additional stages beyond the  primary stage, such as an alert or confirmation dialog box. And finally, you learn  the proper way to end a JavaFX program by handling the events generated when  the user closes the stage.  CHAPTER 3  Setting the Stage and Scene Layout      603   Examining the Stage Class  A  stage,  which  is  represented  by  the  Stage  class,  is  the  topmost  container  in  which a JavaFX user interface appears. In Windows, on a Mac, or in Linux, a stage  is usually a window. On other types of devices, such as a smartphone or tablet, the  stage may be the full screen or a tiled region of the screen.  When a JavaFX application is launched, a stage known as the primary stage is auto- matically created. A reference to this stage is passed to the application’s start  method via the primaryStage parameter:  @Override public void start Stage primaryStage  {        primaryStage refers to the        application's primary stage. }  You  can  then  use  the  primary  stage  to  create  the  application’s  user  interface   by adding a scene, which contains one or more controls or other user-interface  nodes.  In many cases, you will need to access the primary stage outside of the scope of  the start method. You can easily make this possible by defining a class field and  using it to reference the primary stage. You see an example of how to do that later  in this chapter, in the section “Switching Scenes.”  The  primary  stage  initially  takes  on  the  default  characteristics  of  a  normal   windowed application, which depends on the operating system within which the  program will run. You can, if you choose, change these defaults to suit the needs  of your application. At the minimum, you should always set the window title. You  may also want to change such details as whether the stage is resizable and various  aspects of the stage’s appearance.  The Stage class comes equipped with many methods that let you manipulate the  appearance and behavior of a stage. Table 3-1 lists the ones you’re most likely   to use.  604      BOOK 6  JavaFX   TABLE 3-1	  Method  void close    Commonly Used Methods of the Stage Class  Description  Closes the stage.  void initModality Modality modality   Sets the modality of the stage. This method must be  called before the show method is called. The modality  can be one of the following:  void initStyle StageStyle style   Sets the style for the stage. This method must be called  before the show method is called. The style can be one  of the following:  Modality.NONE  Modality.APPLICATION_MODAL  Modality.WINDOW_MODAL  StageStyle.DECORATED  StageStyle.UNDECORATED  StageStyle.TRANSPARENT  StageStyle.UNIFIED  StageStyle.UTILITY  void getMaxHeight double maxheight   Gets the maximum height for the stage.  void getMaxWidth double maxwidth   Gets the maximum width for the stage.  void getMinHeight double maxheight   Gets the minimum height for the stage.  void getMinWidth double maxwidth   Gets the minimum width for the stage.  void setFullScreen boolean fullscreen   Sets the fullscreen status of the stage.  void setIconified boolean iconified   Sets the iconified status of the stage.  void setMaximized boolean maximized   Sets the maximized status of the stage.  void setMaxHeight double maxheight   Sets the maximum height for the stage.  void setMaxWidth double maxwidth   Sets the maximum width for the stage.  void setMinHeight double maxheight   Sets the minimum height for the stage.  void setMinWidth double maxwidth   Sets the minimum width for the stage.  void setResizable boolean resizable   Sets the fullscreen status of the stage.  void setScene Scene scene   Sets the scene to be displayed on the stage.   continued   CHAPTER 3  Setting the Stage and Scene Layout      605   TABLE 3-1	 continued   Method  void setTitle String title   void show    void showAndWait    void toFront    void toBack    Description  Sets the title to be displayed in the stage’s title bar, if a  title bar is visible.  Makes the stage visible.  Makes the stage visible and then waits until the stage is  closed before continuing.  Forces the stage to the foreground.  Forces the stage to the background.  The following paragraphs point out some of the ins and outs of using the Stage  class methods listed in Table 3-1:   » For many  if not most  applications, the only three methods from   Table 3-1 you need to use are setScene, setTitle, and show.    Every stage must have a scene.    Every stage should have a title.    There’s not much point in creating a stage if you don’t intend on showing it   to the user.  The other methods in the table let you change the appearance or behavior of  the stage, but the defaults are acceptable in most cases.   » If you want to prevent the user from resizing the stage, use the    setResizable method like this:  primaryStage.setResizable false ;  Then, the user can’t change the size of the window.  By default, the stage is  resizable. Thus, you don’t need to call the setResizable method unless you  want to make the stage non-resizable.    » If the stage is resizable, you can set the minimum and maximum size for   the window. For example:  primaryStage.setResizable true ; primaryStage.setMinWidth 200 ; primaryStage.setMinHeight 200 ; primaryStage.setMaxWidth 600 ; primaryStage.setMaxHeight 600 ;  In this example, the user can resize the window, but the smallest allowable  size is 200-x-200 pixels and the largest allowable size is 600-x-600 pixels.  606      BOOK 6  JavaFX    » If you want to display the stage in a maximized window, call   setMaximized:  primaryStage.setMaximized true ;  A maximized window still has the usual decorations  a title bar, window  borders, and Minimize, Restore, and Close buttons . If you want the stage   to completely take over the screen with no such decorations, use the   setFullScreen method instead:  primaryStage.setFullScreen true ;  When your stage enters fullscreen mode, JavaFX displays a message advising  the user on how to exit fullscreen mode.   » If, for some reason, you want to start your program minimized to an   icon, use the setIconified method:  primaryStage.setIconified true ;   » For more information about the close method, see the section “Exit, Stage   Right” later in this chapter.   » The initModality and initStyle methods are interesting because they   can be called only before you call the show method. The initModality  method allows you to create a modal dialog box — that is, a window that must  be closed before the user can continue using other functions within the  program. And the initStyle method lets you create windows that do not have  the usual decorations such as a title bar or Minimize, Restore, and Close  buttons. You typically use these methods when you need to create additional  stages for your application beyond the primary stage. You can read more about  how that works later in this chapter, in the section “Creating a Dialog Box.”  Examining the Scene Class  Like  the  Stage  class,  the  Scene  class  is  fundamental  to  JavaFX  programs.  In  every JavaFX program, you use at least one instance of the  Scene class to hold  the   user-interface  controls  that  your  users  will  interact  with  as  they  use  your  program.  Table 3-2 lists the more commonly used constructors and methods of the Scene  class.  CHAPTER 3  Setting the Stage and Scene Layout      607   TABLE 3-2	  Commonly Used Constructors and Methods of the   Scene class Constructor  Description  Scene Parent root   Creates a new scene with the specified root node  Scene Parent root, double  width, double height   Creates a new scene with the specified root node,  width, and height  Method  Description  double getHeight    Gets the height of the scene  double getWidth    Gets the width of the scene  double getX    double getY    Gets the horizontal position of the scene  Gets the vertical position of the screen  void setRoot Parent root   Sets the root node  The  following  paragraphs  explain  some  of  the  more  interesting  details  of  the   constructors and methods of the Scene class:   » All the Scene class constructors require that you specify the root node.  You can change the root node later by calling the setRoot method, but it’s not  possible to create a scene without a root node.   » You might be wondering why the root node is an instance of the Parent  class rather than an instance of the Node class. The Parent class is actually  a subclass of the Node class, which represents a node that can have child  nodes. There are several other subclasses of Node, which represent nodes that  can’t have children; those nodes can’t be used as the root node for a scene.  » You can set the scene’s initial size when you create it by specifying the   Width and Height parameters.  If you don’t set the size, the scene will determine its own size based on its  content.   » You can retrieve the size of the scene via the getHeight and getWidth   methods.  There are no corresponding set methods that let you set the height or width.   » In general, the size of the scene determines the size of the stage,   provided that that scene is not smaller than the minimum size specified for  the stage or larger than the maximum size.   » If the user resizes the stage, the size of the scene is resized accordingly.  608      BOOK 6  JavaFX   Switching Scenes  The primary stage of a JavaFX program  or any other stage, for that matter  can  have only one scene displayed within it at any given time. However, that doesn’t  mean  that  your  program  can’t  create  several  scenes  and  then  swap  them  as  needed. For example, suppose you’re developing a word-processing program and  you want to let the user switch between an editing view and a page preview view.  You  could  do  that  by  creating  two  distinct  scenes,  one  for  each  view.  Then,  to  switch the user between views, you simply call the stage’s setScene method to  switch the scene.  In Chapter 1 of this minibook, you read about a ClickCounter program whose scene  displays a label and a button and then updates the label to indicate how many  times the user has clicked the button. Then, in Chapter 2 of this minibook, you  saw several variations of an AddSubtract program whose scene displayed a label  and two buttons: One button added one to a counter when clicked, the other sub- tracted one from the counter.  Listing 3-1 shows a program named SceneSwitcher that combines the scenes from  the  ClickCounter  and  AddSubtract  programs  into  a  single  program.  Figure  3-1  shows this program in action:   » When the SceneSwitcher program is first run, it displays the ClickCounter   scene as shown on the left side of the figure.   » When the user clicks the Switch Scene button, the scene switches to the   AddSubtract scene, as shown in the right side of the figure.  FIGURE 3-1:   The Scene  Switcher   program.  LISTING	3-1:	  The SceneSwitcher Program  import javafx.application.*; import javafx.stage.*; import javafx.scene.*; import javafx.scene.layout.*; import javafx.scene.control.*;  CHAPTER 3  Setting the Stage and Scene Layout      609   continued    LISTING	3-1:	   continued   import javafx.event.*;  public class SceneSwitcher extends Application {     public static void main String[] args      {         launch args ;     }         class fields for Click-Counter scene      int iClickCount = 0;     Label lblClicks;     Button btnClickMe;     Button btnSwitchToScene2;     Scene scene1;         class fields for Add-Subtract scene      int iCounter = 0;     Label lblCounter;     Button btnAdd;     Button btnSubtract;     Button btnSwitchToScene1;     Scene scene2;         class field for stage     Stage stage;       @Override public void start Stage primaryStage      {         stage = primaryStage;              Build the Click-Counter scene           lblClicks = new Label  ;         lblClicks.setText "You have not clicked the button." ;          btnClickMe = new Button  ;         btnClickMe.setText "Click me please!" ;         btnClickMe.setOnAction              e -> btnClickMe_Click    ;          btnSwitchToScene2 = new Button  ;         btnSwitchToScene2.setText "Switch!" ;         btnSwitchToScene2.setOnAction              e -> btnSwitchToScene2_Click    ;  →15  →22  →31  →35  →37  610      BOOK 6  JavaFX           VBox pane1 = new VBox 10 ;         pane1.getChildren  .addAll lblClicks, btnClickMe,             btnSwitchToScene2 ;          scene1 = new Scene pane1, 250, 150 ;             Build the Add-Subtract scene   →59          lblCounter = new Label  ;         lblCounter.setText Integer.toString iCounter  ;          btnAdd = new Button  ;         btnAdd.setText "Add" ;         btnAdd.setOnAction              e -> btnAdd_Click    ;          btnSubtract = new Button  ;         btnSubtract.setText "Subtract" ;         btnSubtract.setOnAction              e -> btnSubtract_Click    ;          btnSwitchToScene2 = new Button  ;         btnSwitchToScene2.setText "Switch!" ;         btnSwitchToScene2.setOnAction              e -> btnSwitchToScene1_Click    ;          HBox pane2 = new HBox 10 ;         pane2.getChildren  .addAll lblCounter, btnAdd,             btnSubtract, btnSwitchToScene2 ;         scene2 = new Scene pane2, 300, 75 ;             Set the stage with scene 1 and show the stage          primaryStage.setScene scene1 ;         primaryStage.setTitle "Scene Switcher" ;         primaryStage.show  ;     }         Event handlers for scene 1       public void btnClickMe_Click       {         iClickCount++;         if  iClickCount == 1   →84  →91   continued   CHAPTER 3  Setting the Stage and Scene Layout      611   LISTING	3-1:	   continued           {             lblClicks.setText "You have clicked once." ;         }         else         {             lblClicks.setText "You have clicked "                 + iClickCount + " times."  ;         }     }      private void btnSwitchToScene2_Click       {         stage.setScene scene2 ;     }      private void btnAdd_Click       {         iCounter++;         lblCounter.setText Integer.toString iCounter  ;     }      private void btnSubtract_Click       {         iCounter--;         lblCounter.setText Integer.toString iCounter  ;     }      private void btnSwitchToScene1_Click       {         stage.setScene scene1 ;     }         Event handlers for scene 2   →112  }  →15:     The following paragraphs point out some key sections of the program:   The section of the programs defines class fields that will be used by the  scene for the Click-Counter portion of the program. These fields include  iClickCount, used to count the number of times the user has clicked the  Click Me! Button; the label used to display the count of how many times  the Click Me! button has been clicked; the Click Me! button itself; and the  button used to switch to the Add-Subtract scene. Also included is a Scene  field named scene1 that will be used to reference the Click Counter scene.  612      BOOK 6  JavaFX   →22:      These lines define class variables used by the Add-Subtract portion of  the program, including the counter  iCounter , the label used to display  the counter, the two buttons used to increment and decrement the  counter, the button used to switch back to the Click-Counter scene, and  a Scene field named scene2 that will be used to reference the Add- Subtract scene.  →31:      A class field named stage is used to hold a reference to the primary  stage so that it can be accessed throughout the program.  →35:    This line sets stage class field to reference the primary stage. →37:      This section of the program builds the Click-Counter scene. First, it  creates the label and buttons displayed by the scene. Then it creates a  VBox layout pane  which lays out its controls in a vertical stack  and adds  the label and buttons to the pane. Finally, it creates the scene using the  VBox pane as its root.  →59:     →84:     →91:     →112:    This section of the program builds the Add-Subtract scene by creating  the label and the buttons displayed by the scene, arranging them in   an HBox layout pane, and creating the scene using the HBox pane as   its root.   These lines set the Click-Counter scene as the root scene for the primary  stage, sets the stage title, and then shows the stage.   This section of the program provides the event handlers for the buttons  in the Click-Counter scene. The event handler for the Click Me! button  increments the click counter, then sets the label to display an appropriate  message. The handler for btnSwitchToScene2 simply switches the scene  of the primary stage to scene2, which instantly switches the display to the  Add-Subtract scene as shown in the right side of Figure 3-1.   This section of the program provides the event handlers for the buttons  in the Add-Subtract scene. The event handler for the Add and Subtract  buttons increment or decrement the counter and update the text  displayed by the label. The handler for btnSwitchToScene1 switches  the scene back to scene1, which switches the display back to the  Click-Counter scene shown in the left right side of Figure 3-1.  Creating an Alert Box  JavaFX  provides  a  simple  means  of  displaying  a  basic  message  box  by  using  the  Alert  class,  which  is  similar  to  the  JOptionPane  class  you  learned  back   CHAPTER 3  Setting the Stage and Scene Layout      613   in   Chapter  2  of  Book  2.  Table  3-3  shows  the  commonly  used  constructors  and   methods for this class.  TABLE 3-3	  Commonly Used Constructors and Methods of the  Alert class  Constructor  Description  Alert Alert.AlertType   Creates a new alert of the specified type  Alert Alert.AlertType,  String text   Alert Alert.AlertType, String  text, ButtonType type...   Method  void setTitle String text   Description  Sets the title  Creates a new alert of the specified type and sets the message text  Creates a new alert and sets the buttons to be displayed  Optional   showAndWait    Shows the alert and waits for the user’s response, which is returned  as a ButtonType object  The Alert class was introduced with Java version 1.8.0_40, so you must be using a  version of Java more recent than that to use this feature. If you get compiler errors  when you try to use the Alert class, upgrade to the most current version of Java.  The AlertType parameter lets you specify one of several types of Alert dialogs:   » AlertType.CONFIRMATION, which prompts the user to confirm an action.  » AlertType.ERROR, which display an error message.  » AlertType.INFORMATION, which displays an information dialog box.  » AlertType.WARNING, which displays a warning message.  » AlertType.NONE, which display a generic alert dialog.  Here’s a snippet of code that displays a simple informational message using the  Alert class:  Alert a = new Alert Alert.AlertType.INFORMATION, "You have clicked once." ; a.showAndWait  ;  Figure 3-2 shows the resulting alert box.  614      BOOK 6  JavaFX   FIGURE 3-2:   An Alert   dialog box.  You  can  control  what  buttons  appear  on  the  Alert  box  by  using  the  optional   ButtonType parameter. You can choose from among the following types of buttons:   » ButtonType.APPLY  » ButtonType.CANCEL  » ButtonType.CLOSE  » ButtonType.FINISH  » ButtonType.NEXT  » ButtonType.NO  » ButtonType.OK  » ButtonType.PREVIOUS  » ButtonType.YES  You can include more than one button on an Alert box by simply specifying more  than one ButtonType parameters in the constructor. For example:  Alert a = new Alert Alert.AlertType.INFORMATION, "Are you certain?",             ButtonType.YES, ButtonType.NO ;  In this example, the Alert box will include both a YES and a NO button.  To determine which button the user clicked, you must test the value returned by  the showAndWait method. This value is an object of type Optional, since the user  can close the dialog box without clicking any of the displayed buttons. You should  first  test  whether  the  user  clicked  a  button  by  calling  the  isPresent  method.  Then, you can call the get method to retrieve the actual result.  CHAPTER 3  Setting the Stage and Scene Layout      615   Here’s an example that determines whether the user clicked the YES button:  Alert a = new Alert Alert.AlertType.INFORMATION, "Are you certain?",             ButtonType.YES, ButtonType.NO ; Optional  r = a.showAndWait  ; if  r.isPresent   && r.get   == ButtonType.YES  {        The user clicked OK! }  To  demonstrate  how  you  might  use  the  ALERT  class,  the  program  shown  in   Listing  3-2  is  a  variation  of  the  ClickCounter  program  that  was  originally  dis- cussed in Chapter 2. The original version of this program displayed a label and a  button, using the label to display a count of how many times the user has clicked  the button. This version of the program dispenses with the label and instead uses  the  Alert  class  to  display  a  message  indicating  how  many  times  the  user  has  clicked the button.  LISTING	3-2:	  The ClickCounterAlert Program  import javafx.application.*; import javafx.stage.*; import javafx.scene.*; import javafx.scene.layout.*; import javafx.scene.control.*;  public class ClickCounterAlert extends Application {     public static void main String[] args      {         launch args ;     }      Button btn;     Label lbl;     int iClickCount = 0;      @Override public void start Stage primaryStage      {        Create the button         btn = new Button  ;         btn.setText "Click me please!" ;         btn.setOnAction e -> buttonClick   ;  616      BOOK 6  JavaFX              Add the button to a layout pane         BorderPane pane = new BorderPane  ;         pane.setCenter btn ;             Add the layout pane to a scene         Scene scene = new Scene pane, 250, 150 ;             Add the scene to the stage, set the title            and show the stage         primaryStage.setScene scene ;         primaryStage.setTitle "Click Counter" ;         primaryStage.show  ;     }      public void buttonClick       {         iClickCount++;         if  iClickCount == 1          {             Alert a = new Alert Alert.AlertType.INFORMATION,    "You have clicked once."  ;              a.showAndWait  ;         }         else         {             Alert a = new Alert Alert.AlertType.INFORMATION, "You   have clicked "                  + iClickCount + " times." ;             a.showAndWait  ;         }     } }  This program is nearly identical to the version that was presented in Chapter 2  in  Listing 2-2 . In fact, here are the only two differences:   » No label is defined in this program because a message box, not a label, is   used to display the number of times the button has been clicked.   » In the buttonClick method of the Chapter 2 version, the label’s setText   method was called to display the number of times the button has been  clicked. In this version, an Alert box is used instead.  CHAPTER 3  Setting the Stage and Scene Layout      617   Figure 3-2 shows the new version of the ClickCounter program in action. Here,  you can see the alert box displayed when the user clicks the button the first time.   In this example, I moved the message box to the side a little so that you can see  the primary stage beneath it. When you actually run the program, the message  box is centered over the primary stage.   Exit, Stage Right  Because I started this chapter by quoting Shakespeare, I thought it’d be nice to end  it by quoting Snagglepuss, the famous pink mountain lion from the old Hanna- Barbera cartoons. He’d often leave the scene by saying, “Exit, stage left” or “Exit,  stage right.”  Heavens to Mergatroyd!  There’s a right way and a wrong way to exit the stage, even. And so far, none of  the programs presented in this book have done it the right way. The only mecha- nism the programs you’ve seen so far have provided to quit the program is for the  user to click the standard window close button, typically represented by an X in  the upper-right corner of the window’s title bar. That is almost always the wrong  way to exit a program.  In most cases, the correct way to exit a program involves the following details:   » Adding a button, menu command, or other way for the user to signal   that she wishes to close the program.  Many programs include a button labeled Exit or Close, and programs that use  a menu usually have an Exit command.   » Optionally displaying a confirmation box that verifies whether the   user really wants to close the program. You can do that by using the  ConfirmationBox class shown in the preceding section or by using a similar  class.  Depending on the program, you might want to display this dialog box only if  the user has made changes to a document, database, or other file that have  not yet been saved.  618      BOOK 6  JavaFX    » If the user really does want to close the program, the program should   perform any necessary clean-up work, such as    Saving changes to documents, databases, or other files.    Properly closing databases and other resources.   » After you’ve done any necessary clean-up work, you can close the   application by calling the primary stage’s close method.   » The verification and clean-up steps should be taken whether the user   attempts to close the program by using a button or menu command you’ve  provided in your user interface or by clicking the built-in window close button.  In the following sections, you read about how to add a Close button to your applica- tion, how to prevent the window close button from unceremoniously terminating  your application, and how to put these two elements together in a complete program.  Creating a Close button  To add a button or other user-interface element that allows the user to close the  button, all you have to do is provide an action event handler that calls the stage’s  close method.  For example, suppose you create a Close button using the following code:  Button btnClose = new Button  ; btnClose.setText "Close" ; btnClose.setOnAction  e -> primaryStage.close    ;  In this case, the action event handler simply calls primaryStage.close   to close  the application.  If  you  want  to  do  more  than  simply  call  the  close  method  in  the  action  event  handler, you may want to isolate the event handler in a separate method, as in  this example:  btnClose.setOnAction  e -> btnClose_Clicked   ;  Because the btnClose_Clicked method will need to access the primary stage to  close it, you need to define a class field of type Stage and use it to reference the   CHAPTER 3  Setting the Stage and Scene Layout      619   primary stage. Then, your btnClose_Clicked method can easily perform addi- tional tasks. For example:  private void btnClose_Click   {     boolean reallyQuit = false;     reallyQuit = ConfirmationBox.show          "Are you sure you want to quit?",         "Confirmation",         "Yes", "No" ;     if  reallyQuit      {            Perform cleanup tasks here            such as saving files or freeing resources         stage.close  ;     } }  SHAKESPEARE’S BEST STAGE DIRECTION  So far in this chapter, I’ve quoted William Shakespeare once and Snagglepuss once.  Both quotes are appropriate for the topic of this chapter: The Shakespeare quotation  from Henry V refers to stages and scenes, and the Snagglepuss quotation refers to the  proper way to exit the stage. Even so, quoting Snagglepuss as often as Shakespeare  seems a little out of balance. Thus, I think it’s best to throw in another Shakespeare  quote to save what little respect I may still have from my college English professors.  Shakespeare’s plays are liberally sprinkled with stage directions. Most of them are very  brief, such as Enter Tybalt or Exit Romeo found in Romeo and Juliet. A few are a bit more  detailed, such as Enter several of both houses, who join the fray, also from Romeo and  Juliet. And sometimes they’re a bit ambiguous, such as Enter a messenger with two heads  and a hand from Titus Andronicus.  But in my opinion, the most interesting of all Shakespeare’s stage directions is found  in The Winter’s Tale, when Antigonus is thwarted from rescuing Perdita following a ship- wreck: Exit, pursued by a bear.  When you exit the stage, because you’re pursued by a bear, you don’t get to collect  your things or accomplish any of the other important tasks you had set out to do, such  as saving the princess or saving the important changes the user made to a document.  Instead, you just turn and run, which is pretty much what happens when the user clicks  the window close button unless you properly handle the CloseRequest event.  620      BOOK 6  JavaFX   In  this  example,  a  confirmation  box  is  displayed  to  make  sure  the  user  really  wants to exit the program.  Handling the CloseRequest event  Providing a Close button is an excellent way to allow your users to cleanly exit  from your program. However, the user can bypass your exit processing by sim- ply closing the window — that is, by clicking the window close button, usually  represented as an X in the upper-right corner of the window border. Unless you  provide otherwise, clicking this button unceremoniously terminates the applica- tion, bypassing all your nice code that confirms whether the user wants to save  his work, closes any open resources, and otherwise provides for a graceful exit.  Fortunately, you can easily avoid such ungraceful exits. Whenever the user attempts  to close the window within which a JavaFX stage is displayed, JavaFX generates a  CloseRequest event, which is sent to the stage. You can provide an event handler  for this event by calling the setOnCloseRequest method of the Stage class. Then,  the event handler is called whenever the user tries to close the window.  You might be tempted to create a single method that can serve as the event han- dler for both the Action event of your Close button and the CloseRequest event,  like this:  btnClose.setText "Close" ; btnClose.setOnAction  e -> btnClose_Click     ; primaryStage.setOnCloseRequest  e -> btnClose_Click     ;  Here, the intent is to handle the CloseRequest event exactly as if the user had  clicked the btnClose button.  That’s a good idea, but it doesn’t work if the btnClose_Click event displays a con- firmation box and closes the stage only if the user confirms that she really wants  to quit the program. That’s because when the event handler for the CloseRequest  event  ends,  JavaFX  automatically  closes  the  stage  if  the  event  handler  doesn’t  explicitly close the stage.  To  prevent  that  from  happening,  you  call  the  consume  method  of  the  Close  Request event object. Consuming the event causes it to be stopped in its tracks  within the event handler, thus preventing JavaFX from automatically closing the  stage when the event handler ends.  In the Lambda expression passed to the setOnCloseRequest method, the Close  Request event object is represented by the argument e. Thus, you can consume  the CloseRequest event by calling e.consume  .  CHAPTER 3  Setting the Stage and Scene Layout      621   An easy way to provide a method that handles both the Action event for a Close  button and the CloseRequest event for a stage is to craft the Lambda expression  for the setOnCloseRequest method so that it consumes the event before calling  the method that will handle the event:  btnClose.setText "Close" ; btnClose.setOnAction  e -> btnClose_Click     ; primaryStage.setOnCloseRequest      e -> {              e.consume  ;              btnClose_Click   ;          }  ;  Here, the event handler for the CloseRequest event first consumes the event and  then calls btnClose_Click. The btnClose_Click method, in turn, displays a con- firmation box and closes the stage if the user confirms that this is indeed what he  wishes to do.  Putting it all together  Now that you know how to add a Close button to a scene and how to handle the  CloseRequest event, I look at a program that puts together these two elements to  demonstrate the correct way to exit a JavaFX program.  This section presents a variation of the ClickCounter program that includes a Close  button  in  addition  to  the  Click  Me!  button.  When  the  user  clicks  the  Click  Me!  button, a message box displays to indicate how many times the button has been  clicked. But when the user attempts to exit the program, whether by clicking the  Close button or by simply closing the window, the  ConfirmationBox class that  was shown in Listing 3-3 is used to ask the user whether she really wants to exit  the program. Then, the stage is closed only if the user clicks the Yes button in the  confirmation box.  The source code for this program is shown in Listing 3-3.  LISTING	3-3:	  The ClickCounterExit program  import javafx.application.*; import javafx.stage.*; import javafx.scene.*; import javafx.scene.layout.*; import javafx.scene.control.*; import javafx.geometry.*; import java.util.*;  622      BOOK 6  JavaFX   public class ClickCounterExit extends Application {     public static void main String[] args      {         launch args ;     }      Stage stage;     int iClickCount = 0;      @Override public void start Stage primaryStage      {         stage = primaryStage;             Create the Click Me button         Button btnClickMe = new Button  ;         btnClickMe.setText "Click me please!" ;         btnClickMe.setOnAction e -> btnClickMe_Click   ;             Create the Close button         Button btnClose = new Button  ;         btnClose.setText "Close" ;         btnClose.setOnAction e -> btnClose_Click   ;             Add the buttons to a layout pane         VBox pane = new VBox 10 ;         pane.getChildren  .addAll btnClickMe, btnClose ;         pane.setAlignment Pos.CENTER ;             Add the layout pane to a scene         Scene scene = new Scene pane, 250, 150 ;             Finish and show the stage         primaryStage.setScene scene ;         primaryStage.setTitle "Click Counter" ;         primaryStage.setOnCloseRequest  e ->             {                 e.consume  ;                 btnClose_Click  ;             }  ;         primaryStage.show  ;     }  CHAPTER 3  Setting the Stage and Scene Layout      623   continued    LISTING	3-3:	   continued       public void btnClickMe_Click       {         iClickCount++;         if  iClickCount == 1          {             Alert a = new Alert Alert.AlertType.INFORMATION, "You   have clicked once."  ;              a.showAndWait  ;         }         else         {             Alert a = new Alert Alert.AlertType.INFORMATION, "You   have clicked "                  + iClickCount + " times." ;             a.showAndWait  ;         }     }      public void btnClose_Click       {         Alert a = new Alert Alert.AlertType.CONFIRMATION,             "Are you sure you want to quit?",             ButtonType.YES, ButtonType.NO ;         Optional  confirm = a.showAndWait  ;         if  confirm.isPresent   && confirm.get   ==    ButtonType.YES           {             stage.close  ;         }     }  }  624      BOOK 6  JavaFX   IN THIS CHAPTER  » Using five popular layout pane  classes: HBox, VBox, FlowPane,  BorderPane, and GridPane.   » Adjusting the size of layout panes and   the nodes they contain   » Fiddling with various options for  spacing out the nodes in a layout  pane  Chapter 4 Using Layout Panes to  Arrange Your Scenes  Controlling the layout of components in a scene is often one of the most dif-  ficult aspects of working with JavaFX. In fact, at times it can be downright  exasperating.  Often  the  components  almost  seem  to  have  minds  of  their  own. They get stubborn and refuse to budge. They line up on top of one another  when you want them to be side by side. You make a slight change to a label or text  field, and the whole scene seems to rearrange itself. At times, you want to put your  fist through the monitor.  I recommend against putting your fist through your monitor. You’ll make a mess,  cut your hand, and have to spend money on a new monitor — and when you get  your  computer  working  again,  the  components  still  won’t  line  up  the  way  you  want them to be.  The problem isn’t with the components; it’s with the layout panes, which  determine  where  each  component  appears  in  its  frame  or  panel.  Layout  panes  are  special  classes whose sole purpose in life is to control the arrangement of the nodes that  appear in a scene. JavaFX provides several distinct types of layout panes; each type  uses a different approach to controlling the arrangement of nodes. The trick to  successfully lay out a scene is to use the layout panes in the correct combination  to achieve the arrangement you want.  CHAPTER 4  Using Layout Panes to Arrange Your Scenes      625   Working with Layout Panes  Understanding layout panes is the key to creating JavaFX frames that are  attractive  and usable.  Introducing five JavaFX layout panes  JavaFX provides many different layout panes for you to work with. I explain the  following five in this chapter:   » HBox: This layout pane arranges nodes horizontally, one next to the other. You   use it to create controls arranged neatly in rows.   » VBox: This layout pane arranges nodes vertically, one above the other. You   use it to create controls arranged neatly in columns.   » FlowPane: This layout pane arranges nodes next to each other until it runs  out of room; then, it wraps to continue layout nodes. You can configure a  FlowPane to arrange nodes horizontally in rows or vertically in columns.   » Border: This layout pane divides the pane into five regions: Top, Left, Center,  Right, and Bottom. When you add a node, you can specify which region you  want to place the node in.   » GridPane: This layout pane divides the pane into a grid, affording you  complete control of the arrangement of elements in rows and columns.  To give you a general idea of the results that can be achieved with the first four  layout types, Figure 4-1 shows four sample windows that each use one of the lay- out panes. You’ll see a detailed example of how the GridPane layout works later  in this chapter.  Creating layout panes  The  basic  process  of  working  with  layout  panes  is  simple.  Here  is  the  general   procedure for creating a layout node: 1.  Create the controls or other nodes you want to add to the pane.  For example, if the layout pane will contain two buttons, you should create the  two buttons using code similar to this:  626      BOOK 6  JavaFX   FIGURE 4-1:   Four commonly  used types of  layout panes.  Button btnOK = new Button  ; btnOK.setText "OK" ; btnOK.setOnAction  e -> btnOK_Click    ; Button btnCancel = new Button  ; btnCancel.setText "Cancel" ; btnCancel.setOnAction  e -> btnCancel_Click    ;  2.  Create a layout pane by calling its constructor.  For example:  HBox pane = new HBox  ;  3.  Fine-tune the optional settings used by the layout pane.  Each type of layout pane has a unique assortment of optional parameters that  govern the details of how nodes are laid out within the pane. For example, the  HBox pane lets you set the number of pixels that will be used to separate each  node in the pane. You can set this value as follows:  HBox.setSpacing 10 ;  4.  Add each of the nodes that will appear in the layout pane.  Each type of layout pane provides a method for adding nodes to the pane. For  the HBox pane, you must first call the getChildren method to get a list of all  the nodes that have been added to the pane. Then, you call the addAll  method to add one or more nodes to the pane. For example:  pane.getChildren  .addAll btnOK, btnCancel ;  CHAPTER 4  Using Layout Panes to Arrange Your Scenes      627   5.  Create the scene, specifying the layout pane as the scene’s root node.  For example:  Scene scene = new Scene pane, 300, 400 ;  In this example, pane is added as the root node for the scene.  Combining layout panes  You can combine several layout panes to create layouts that are more complicated  than a single layout pane can provide. For example, suppose you want to create  a layout that has a horizontal row of buttons at the bottom and a vertical column  of buttons at the right. To do that, you could create an HBox for the buttons at the  bottom and a VBox for the buttons at the right. Then, you could create a Border  Pane and add the HBox to the bottom region and the VBox to the right region.  Combinations like this are possible because all the layout panes inherit the base  class javafx.scene.layout.Pane, which in turn inherits the class javafx.scene. node. In other words, all panes are also nodes. Each node that you add to a layout  pane can be another layout pane. You can nest layout panes within layout panes  as deeply as you need to achieve the exact layout you need for your application.  The HBox class provides one of the simplest of all JavaFX’s layout managers: It  arranges one or more nodes into a horizontal row. Table 4-1 presents the most  commonly used constructors and methods of the HBox class.  The  HBox  class  is  defined  in  the  javafx.scene.layout  package,  so  you  should  include the following import statement in any program that uses an HBox:  import javafx.scene.layout.*;  The easiest way to create an HBox is to first create the nodes that you want to place  in the HBox and then call the HBox constructor and pass the nodes as arguments.  For example:  Button btn1 = new Button "Button One" ; Button btn2 = new Button "Button Two" ; Button btn3 = new Button "Button Three" ; HBox hbox = new HBox btn1, btn2, btn3 ;  Using the HBox Layout  628      BOOK 6  JavaFX   TABLE 4-1	  Constructor  HBox    HBox Constructors and Methods  Description  Creates an empty HBox.  HBox double spacing   Creates an empty HBox with the specified spacing.  HBox Node... children   Creates an HBox with the specified child nodes. This constructor lets  you create an HBox and add child nodes to it at the same time.  Creates an HBox with the specified spacing and child nodes.  Method  Description  HBox double spacing,  Node... children   ObservableList   getChildren    static void  setAlignment Pos alignment   Sets the alignment for child nodes within the HBox.  Returns the collection of all child nodes that have been added to the  HBox. The collection is returned as an ObservableList type, which  includes the method addAll, letting you add one or more nodes  to the list.  See Table 4-5 for an explanation of the Pos enumeration. For more  information, see the section “Aligning Nodes in a Layout Pane” later in  this chapter.  Sets the growth behavior of the given child node.  See Table 4-3 for an explanation of the Priority enumeration. For  more information, see the section “Adding Space by Growing Nodes”  later in this chapter.  static void setHgrow Node  child, Priority priority   static void setMargin Node  child, Insets value   Sets the margins for a given child node. See Table 4-2 for the  constructors of the Insets class.  For more information, see the section “Adding Space with Margins”  later in this chapter.  void setPadding   Insets value   Sets the padding around the inside edges of the Hbox.  See Table 4-2 for the constructors of the Insets class.  void setSpacing   double value   For more information, see the section “Spacing Things Out” later in  this chapter.  Sets the spacing between nodes displayed within the HBox.  For more information, see the section “Spacing Things Out” later in  this chapter.  CHAPTER 4  Using Layout Panes to Arrange Your Scenes      629   Spacing Things Out  If you prefer to create the HBox control in an initially empty state and later add the  controls, you can do so like this:  HBox hbox = new HBox  ; Hbox.getChildren  .addAll btn1, btn2, btn3 ;  Here, the getChildren method is called, which returns a collection of all the chil- dren added to the HBox pane. This collection is defined by the class Observable  List, which includes a method named addAll that you can use to add one or more  nodes to the list.  By  default,  child  nodes  in  a  layout  pane  are  arranged  immediately  next  to  one  another, with no empty space in between. If you want to provide space between  the nodes in the pane, you can do so in four ways:   » Adding spacing between elements within the pane  » Adding padding around the inside edges of the pane  » Adding margins to the individual nodes in the pane  » Creating spacer nodes that can grow to fill available space  In this section, I show you how to add spacing and padding to a pane. Then, the  next three sections show you how to use the other two techniques.  Note  that  although  I  illustrate  the  techniques  in  these  sections  using  the  HBox  layout pane, the techniques apply to other types of panes as well.  To set the spacing for an HBox pane, you can use the spacing parameter on the  HBox constructor or by calling the setSpacing method. For example, this state- ment creates an HBox pane with a default spacing of 10 pixels:  HBox hbox = new HBox 10 ;  This example creates an HBox pane with 10-pixel spacing and adds three buttons:  HBox hbox = new HBox 10, btn1, btn2, btn3 ;  And this example creates an HBox pane using the default constructor, and then  calls the setSpacing method to set the spacing to 10 pixels:  630      BOOK 6  JavaFX   HBox hbox = new HBox  ; Hbox.setSpacing 10 ;  Although spacing adds space between nodes in an HBox pane, it doesn’t provide  any space between the nodes and the edges of the pane itself. For example, if you  set the spacing to 10 pixels and add three buttons to the pane, the three buttons  will be separated from one another by a gap of 10 pixels. However, there won’t be  any space at all between the left edge of the first button and the left edge of the  pane itself. Nor will there be any space between the top of the buttons and the top  of the pane. In other words, the three buttons will be crowded tightly into the pane.  To add space around the perimeter of the layout pane, use the setPadding method.  This method takes as a parameter an object of type Insets, which represents the  size of the padding  in pixels  for the top, right, bottom, and left edge of an object.  You  can  create  an  Insets  object  using  either  of  the  two  constructors  listed  in  Table 4-2. The first provides an even padding for all four edges of an object; the  second lets you set a different padding value for each edge.  To set the padding to a uniform 10 pixels, call the setPadding method like this:  hbox.setPadding new Insets 10  ;  To set a different padding value for each edge, call it like this:  hbox.setPadding new Insets 20, 10, 20, 10  ;  In this example, the top and bottom padding is set to 20 and the right and left  padding is set to 10.  Insets Constructors  TABLE 4-2	  Constructor  Insets double value   Description  Creates an Insets object that uses the same value  for the top, right, bottom, and left margins.  Insets double top, double right, double  bottom, double left   Creates an Insets object that uses the specified  top, right, bottom, and left margins.  The  Insets  enumeration  is  defined  in  the  javafx.geometry  package,  so  you  should include the following import statement in any program that uses Insets:  import javafx.geometry.*;  CHAPTER 4  Using Layout Panes to Arrange Your Scenes      631   Adding Space with Margins  Another way to add space around the nodes in a layout pane is to create margins  around the individual nodes. This technique allows you to set a different margin  size for each node in the layout pane, giving you complete control over the spac- ing of each node.  To create a margin, call the setMargin method for each node you want to add a  margin to. You might think that because each node can have its own margin, the  setMargin method would belong to the Node class. Instead, the setMargin method  is defined by the HBox class. The setMargin method accepts two parameters:   » The node you want to add the margin to  » An Insets object that defines the margins you want to add  Here’s an example that sets a margin of 10 pixels for all sides of a button named  btn1:  HBox hbox = new HBox  ; hbox.setMargin btn1, new Insets 10  ;  The setMargin method is a static method of the HBox class, so when you call it,  you can reference the HBox class itself rather than an actual instance of an HBox.  Thus, the following code will work equally as well:  Hbox.setMargin btn1, new Insets 10  ;   Yes it’s a subtle difference: In the first example, hbox refers to an instance of the  HBox class; in the second example, HBox refers to the class itself.   Here’s an example that sets a different margin for each side of the pane:  Hbox.setMargin btn1, new Insets 10, 15, 20, 10  ;  In this example, the top margin is 10 pixels, the right margin is 15 pixels, the bot- tom margin is 20 pixels, and the left margin is 10 pixels.  Note that margins, spacing, and padding can work together. Thus, if you create a  5-pixel margin on all sides of two buttons, add those two buttons to a pane whose  spacing is set to 10 pixels and whose padding is set to 10 pixels, the buttons will  be separated from one another by a space of 20 pixels and from the inside edges  of the pane by 15 pixels.  632      BOOK 6  JavaFX   Adding Space by Growing Nodes  A third way to add space between nodes in an HBox is to create a node whose sole  purpose  is  to  add  space  between  two  HBox  nodes.  Then,  you  can  configure  the  spacer node that will automatically grow to fill any extra space within the pane.  By  configuring  only  the  spacer  node  and  no  other  nodes  in  this  way,  only  the  spacer node will grow. This has the effect of pushing the nodes on either side of  the spacer node apart from one another.  For example, suppose you want to create an HBox layout pane that contains three  buttons.  Instead  of  spacing  all  three  buttons  evenly  within  the  pane,  you  want  the first two buttons to appear on the left side of the pane and the third button to  appear on the right side of the pane. The amount of space between the second and  third buttons will depend entirely on the size of the pane. Thus, if the user drags  the  window  to  expand  the  stage,  the  amount  of  space  between  the  second  and  third buttons should increase accordingly.  The easiest way to create a spacer node is by using the Region class. The Region  class is the base class for both the  Control class, from which controls such as  Button and Label derive. It is also the based class for the Pane class, from which  all the layout panes described in this chapter derive.  For my purposes here, I just use the simple default constructor of the Region class  to create a node that serves as a simple spacer in a layout pane. I don’t provide a  specific size for the region. Instead, I configure it so that it will grow horizontally  to fill any unused space within its container.  To do that, you use the static setHgrow method of the HBox class, specifying one of  the three constant values defined by an enumeration named Priority enumera- tion. Table 4-3 lists these constants and explains what each one does.  TABLE 4-3	  Constant  Priority.NEVER  The Priority enumeration  Description  Indicates that the width of the node should never be adjusted to fill the available  space in the pane. This is the default setting. Thus, by default, nodes are not  resized based on the size of the layout pane that contains them.  Priority.ALWAYS  Indicates that the width of the node should always be adjusted if necessary to  fill available space in the pane. If you set two or more nodes to ALWAYS, the  adjustment will be split equally among each of the nodes.  Priority.SOMETIMES  Indicates that the node’s width may be adjusted if necessary to fill out the pane.  However, the adjustment will be made only if there are no other nodes that  specify ALWAYS.  CHAPTER 4  Using Layout Panes to Arrange Your Scenes      633   The Priority enumeration is defined in the javafx.scene.layout package; the  same package that defines the layout managers that require it. So you don’t need  to include an additional import statement to use the Priority enumeration.  The following example creates three buttons and a spacer, set the margins for all  three buttons to 10 pixels, and then add the three buttons and the spacer to an  HBox such that the first two buttons appear on the left of the HBox and the third  button appears on the right:     Create the buttons Button btn1 = new Button "One" ; Button btn2 = new Button "Two" ; Button btn3 = new Button "Three" ;     Create the spacer Region spacer = new Region  ;     Set the margins hBox.setMargin btn1, new Insets 10  ; hBox.setMargin btn2, new Insets 10  ; hBox.setMargin btn3, new Insets 10  ;     Set the Hgrow for the spacer hBox.setHgrow spacer, Priority.ALWAYS ;     Create the HBox layout pane HBox hbox = new HBox 10, btn1, btn2, spacer, btn3 ;  Figure 4-2 shows how this pane appears when added to a stage. So that you can  see how the spacer works, the first shows three incarnations of the pane, each  with the window dragged to a different size. Notice how the spacing between the  second and third buttons is adjusted automatically so that the first two buttons  are on the left side of the pane and the third button is on the right.  Like  the  setMargin  method,  the  setHgrow  method  is  a  static  class  of  the  HBox  class. Thus, you can call it from an instance of the HBox class  as in the preceding  example , or you can call it from the HBox class itself. In other words, the second  two lines in the following code segment are redundant:  HBox pane = new HBox  ; pane.setHgrow spacer, Priority.ALWAYS ; HBOX.setHgrow spacer, Priority.ALWAYS ;  634      BOOK 6  JavaFX   FIGURE 4-2:   Using a spacer  node to space  out buttons in an  HBox pane.  Using the VBox Layout  The VBox class is similar to the HBox class, but instead of arranging nodes hori- zontally in a row, it arranges them vertically in a column. Table 4-4 shows the  most commonly used constructors and methods of the VBox class.  The  VBox  class  is  defined  in  the  javafx.scene.layout  package,  so  you  should  include the following import statement in any program that uses an VBox:  import javafx.scene.layout.*;  Here’s an example that creates three buttons and uses a  VBox to arrange them  into a column:  Button btn1 = new Button "Button One" ; Button btn2 = new Button "Button Two" ; Button btn3 = new Button "Button Three" ; VBox vbox = new VBox btn1, btn2, btn3 ;  You can accomplish the same thing by using the default constructor and calling  the getChildren method, as in this example:  VBox vbox = new VBox  ; Vbox.getChildren  .addAll btn1, btn2, btn3 ;  CHAPTER 4  Using Layout Panes to Arrange Your Scenes      635   TABLE 4-4	  Constructor  VBox    VBox Constructors and Methods  Description  Creates an empty VBox.  VBox double spacing   Creates an empty VBox with the specified spacing.  Method  Description  VBox Node... children   VBox double spacing,  Node... children   ObservableList   getChildren    static void setAlignment Pos  alignment   Creates an VBox with the specified child nodes. This constructor  lets you create a VBox and add child nodes to it at the same time.  Creates a VBox with the specified spacing and child nodes.  Returns the collection of all child nodes that have been added to  the VBox. The collection is returned as an ObservableList type,  which includes the method addAll, letting you add one or more  nodes to the list.  Sets the alignment for child nodes within the HBox.  See Table 4-5 for an explanation of the Pos enumeration. For  more information, see the section “Aligning Nodes in a Layout  Pane” later in this chapter.  static void setMargin Node  child, Insets value   Sets the margins for a given child node.  See Table 4-2 for the constructors of the Insets class. For more  information, see the section “Adding Space with Margins” earlier  in this chapter.  void setPadding Insets value   Sets the padding around the inside edges of the VBox.  static void setVgrow Node  child, Priority priority   See Table 4-2 for the constructors of the Insets class. For more  information, see the section “Spacing Things Out” earlier in  this chapter.  Sets the growth behavior of the given child node.  See Table 4-3 for an explanation of the Priority enumeration.  For more information, see the section “Adding Space by Growing  Nodes” earlier in this chapter.  As  with  the  HBox  class,  you  can  use  spacing,  padding,  margins,  and  spacer  nodes to control the spacing of nodes within a VBox. Here’s an example that sets   10 pixels of vertical space between nodes and 10 pixels of padding on each edge  of the pane:  Button btn1 = new Button "One" ; Button btn2 = new Button "Two" ; Button btn3 = new Button "Three" ;  636      BOOK 6  JavaFX   Aligning Nodes in a Layout Pane  VBox vbox = new VBox 10, btn1, btn2, btn3 ; vbox.setPadding new Insets 10  ;  Here’s an example that creates a column of three buttons, with one button at the  top of the column and two at the bottom, with 10 pixels of spacing and padding:     Create the buttons Button btn1 = new Button "One" ; Button btn2 = new Button "Two" ; Button btn3 = new Button "Three" ;     Create the spacer Region spacer = new Region  ;     Set the Vgrow for the spacer VBox.setVgrow spacer, Priority.ALWAYS ;     Create the VBox layout pane VBox vbox = new VBox 10, btn1, spacer, btn2, btn3 ; vbox.setPadding new Insets 10  ;  Both the HBox and the VBox layout panes have a setAlignment method that lets  you control how the nodes that are contained within the pane are aligned with one  another. The setAlignment method accepts a single argument, which is one of the  constants defined by the Pos enumeration, described in Table 4-5.  The Pos enumeration is defined in the javafx.geometry package, so you should  include the following import statement in any program that uses Insets:  import javafx.geometry.*;  The following example shows how you might create a vertical column of three  buttons, centered within the pane:  Button btn1 = new Button "Number One" ; Button btn2 = new Button "Two" ; Button btn3 = new Button "The Third Button" ; VBox vbox = new VBox 10, btn1, btn2, btn3 ; vbox.setPadding new Insets 10  ; vbox.setAlignment Pos.CENTERED ;  CHAPTER 4  Using Layout Panes to Arrange Your Scenes      637   TABLE 4-5	  The Pos enumeration Constant  Vertical Alignment Horizontal Alignment  Pos.TOP_LEFT  Pos.TOP_CENTER  Pos.TOP_RIGHT  Pos.CENTER_LEFT  Pos.CENTER  Pos.CENTER_RIGHT  Pos.BOTTOM_LEFT  Pos.BOTTOM_CENTER  Pos.BOTTOM_RIGHT  Pos.BASELINE_LEFT  Pos.BASELINE_CENTER  Pos.BASELINE_RIGHT  Top  Top  Top  Center  Center  Center  Bottom  Bottom  Bottom  Baseline  Baseline  Baseline  Left  Center  Right  Left  Center  Right  Left  Center  Right  Left  Center  Right  When this pane is added to a scene and then shown in a stage, the results resemble  the window shown in Figure 4-3.  FIGURE 4-3:   Three buttons  centered in a  VBox layout pane.  Making Nodes the Same Width  When you place a set of buttons or other controls in a layout pane, you may want  the buttons to all have the same width to create a neat, even appearance. This is  especially true when you place them in a vertical column in a VBox pane because  the  vertical  column  will  draw  attention  to  any  differences  in  the  widths  of  the  buttons.  638      BOOK 6  JavaFX   You can easily dictate that the buttons all have the same width by setting the max- imum width of each of the buttons to Double.MAX_VALUE. Here’s a revised version  of the preceding example in which the three buttons are set to the same width:  Button btn1 = new Button "Number One" ; Button btn2 = new Button "Two" ; Button btn3 = new Button "The Third Button" ; btn1.setMaxWidth Double.MAX_VALUE ; btn2.setMaxWidth Double.MAX_VALUE ; btn3.setMaxWidth Double.MAX_VALUE ; VBox vbox = new VBox 10, btn1, btn2, btn3 ; vbox.setPadding new Insets 10  ; vbox.setAlignment Pos.CENTERED ;  Figure 4-4 shows how these buttons appear when the pane is added to a scene and  the scene displayed in a stage. Notice that all three buttons have adopted the width  of the widest button  btn3 .  FIGURE 4-4:   Three buttons  with the same  width.  Using the Flow Layout  The flow layout comes in two flavors: horizontal and vertical. A horizontal flow  layout arranges its child nodes in a row until the width of the pane reaches a cer- tain size that you can specify. When that size is reached, the layout begins a new  row of child nodes beneath the first row. This flow continues, starting a new row  each time the size limit is reached, until all the child nodes have been placed.  A vertical flow layout works the same way except that child nodes are laid out in  columns until the size limit is reached. When the size limit is reached, a new col- umn immediately to the right of the first column is started.  You use the FlowPane class to create a flow layout. Table 4-6 shows the construc- tors and most commonly used methods for the FlowPane class.  CHAPTER 4  Using Layout Panes to Arrange Your Scenes      639   TABLE 4-6	  Constructor  FlowPane    FlowPane Constructors and Methods  Description  FlowPane double hgap, double vgap   FlowPane double hgap, double vgap,  Node... children   FlowPane Node... children   Creates an empty horizontal flow layout with both the  horizontal and vertical gaps set to zero.  Creates an empty horizontal flow layout with the  specified horizontal and vertical gaps.  Creates a horizontal flow layout with the specified  horizontal and vertical gaps and populated with the  specified child nodes.  Creates a horizontal flow layout with both the horizontal  and vertical gaps set to zero and populated with the  specified child nodes.  Note: In each of the following constructors, Orientation can be Orientation.HORIZONTAL or  Orientation.VERTICAL.  FlowPane Orientation orientation   Creates an empty flow layout with the specified  orientation and both the horizontal and vertical gaps  set to zero.  FlowPane Orientation orientation,  double hgap, double vgap   Creates an empty flow layout with the specified  orientation and the specified horizontal and vertical gaps.  FlowPane Orientation orientation,  double hgap, double vgap,  Node... children   Creates a flow layout with the specified orientation  and horizontal and vertical gaps, populated with the  specified children.  FlowPane Orientation orientation,  Node... children   Creates a flow layout with the specified orientation  and both the horizontal and vertical gaps set to zero,  populated with the specified children.  Method  Description  ObservableList  getChildren    void setAlignment Pos alignment   Sets the alignment for nodes within the rows  and columns.  Returns the collection of all child nodes. The collection is  returned as an ObservableList type, which includes  the method addAll, letting you add one or more nodes  to the list.  See Table 4-5 for an explanation of the Pos enumeration.  For more information, see the section “Aligning Nodes in a  Layout Pane” earlier in this chapter.  Sets the alignment for nodes within the columns.  See Table 4-5 for an explanation of the Pos enumeration.  For more information, see the section “Aligning Nodes in a  Layout Pane” earlier in this chapter.  void setColumnAlignment   Pos alignment   640      BOOK 6  JavaFX   Method  Description  void setHgap double value   static void setMargin Node child,  Insets value   Sets the horizontal gap. For a horizontal flow layout, this  is the amount of space between nodes. For a vertical flow  layout, this is the amount of space between columns.  Sets the margins for a given child node.  See Table 4-2 for the constructors of the Insets class.  For more information, see the section “Adding Space with  Margins” later in this chapter.  void setOrientation Orientation  orientation   void setPadding Insets value   Sets the orientation of the flow layout, which  can be Orientation.HORIZONTAL or  Orientation.VERTICAL.  Sets the padding around the inside edges of the  flow layout.  void setPrefWrapLength double value   void setRowAlignment Pos alignment   Sets the alignment for nodes within the rows.  See Table 4-2 for the constructors of the Insets class. For  more information, see the section “Spacing Things Out”  earlier in this chapter.  Sets the preferred wrap length for the pane. For a  horizontal flow layout, this represents the preferred width  of the pane; for a vertical flow layout, it represents the  preferred height.  See Table 4-5 for an explanation of the Pos enumeration.  For more information, see the section “Aligning Nodes in a  Layout Pane” earlier in this chapter.  Sets the spacing between nodes displayed within the flow  layout. For more information, see the section “Spacing  Things Out” earlier in this chapter.  Sets the vertical gap. For a vertical flow layout, this is the  amount of space between nodes. For a horizontal flow  layout, this is the amount of space between rows.  void setSpacing double value   void setVgap double value   The FlowPane class is defined in the javafx.scene.layout package, so you should  include the following import statement in any program that uses a flow layout:  import javafx.scene.layout.*;  The constructors for this class let you specify the horizontal and vertical gaps,  which  provide  the  spacing  between  the  horizontal  and  vertical  elements  of  the  layout, the orientation  horizontal or vertical , and the child nodes with which to  populate the layout.  To set the limit at which the flow layout wraps, you use the setPrefWrapLength  method. The wrap length is applied to the dimension in which the pane flows its   CHAPTER 4  Using Layout Panes to Arrange Your Scenes      641   contents. Thus, for a horizontal flow layout, the wrap length specifies the pre- ferred width of the pane; for a vertical flow layout, the wrap length specifies the  pane’s preferred height.  Note that regardless of the preferred wrap length, if you don’t call this method,  the wrap length defaults to 400 pixels.  The following example creates a horizontal layout with 10 pixels of horizontal and  vertical gaps, populated by five buttons, and a preferred wrap length of 300 pixels:  Button btn1 = new Button "Button One" ; Button btn2 = new Button "Button Two" ; Button btn3 = new Button "Button Three" ; Button btn4 = new Button "Button Four" ; Button btn5 = new Button "Button Five" ; FlowPane pane = new FlowPane Orientation.HORIZONTAL,         10, 10, btn1, btn2, btn3, btn4, btn5 ; pane.setPrefWrapLength 300 ;  Figure 4-5 shows how these buttons appear when the layout is added to a scene  and the scene displayed in a stage. This figure also shows how the buttons in the  flow layout are rearranged when the user resizes the window. Notice that initially,  the first three buttons appear on the first row and the next two appear on the sec- ond row. When the window is dragged a bit wider, the buttons reflow so that four  fit on the first row and just one spills to the second row. Then, when the window  is dragged smaller, just two buttons appear on the first two rows and a third row  is created for the fifth button.  FIGURE 4-5:   A flow layout  pane with five  buttons.  642      BOOK 6  JavaFX   Using the Border Layout  The  border  layout  is  a  pane  that  is  carved  into  five  regions:  Top,  Left,  Center,  Right, and Bottom, as shown in Figure 4-6. When you add a component to the  layout, you can specify which of these regions the component goes in.  FIGURE 4-6:   How the border  layout carves  things up.  Border layout is the ideal layout manager for applications that have a traditional  window  arrangement  in  which  menus  and  toolbars  are  displayed  at  the  top  of  the window, a status bar or OK and Cancel buttons are displayed at the bottom, a  navigation pane is displayed on the left, various task panes are displayed on the  right, and content is displayed in the middle.  You  use  the  BorderPane  class  to  create  a  border  layout.  Table  4-7  lists  the   constructors and the most commonly used methods for the BorderPane class.  The  BorderPane  class  is  defined  in  the  javafx.scene.layout  package,  so  you  should include the following import statement in any program that uses a border  layout:  import javafx.scene.layout.*;  CHAPTER 4  Using Layout Panes to Arrange Your Scenes      643   TABLE 4-7	  Constructor  BorderPane     BorderPane Constructors and Methods  Description  Creates an empty border layout.  BorderPane  Node center   Creates a border layout with the specified center node.  BorderPane  Node center, Node top,  Node right, Node bottom, Node left   Creates a border layout with the specified center, top, right,  bottom, and left nodes.  Method  void setCenter Node node   void setTop Node node   void setRight Node node   void setBottom Node node   void setLeft Node node   Description  Sets the center node.  Sets the top node.  Sets the right node.  Sets the bottom node.  Sets the left node.  void setAlignment Pos alignment   Sets the alignment for nodes within border pane.  static void setMargin Node child,  Insets value   See Table 4-5 for an explanation of the Pos enumeration.  For more information, see the section “Aligning Nodes in a  Layout Pane” earlier in this chapter.  Sets the margins for a given child node.  See Table 4-2 for the constructors of the Insets class.  For more information, see the section “Adding Space with  Margins” earlier in this chapter.  The default constructor for this class creates an empty border layout, to which you  can add nodes later, as in this example:  Button btn1 = new Button "Button One" ; Button btn2 = new Button "Button Two" ; Button btn3 = new Button "Button Three" ; VBox vbox = new VBox btn1, btn2, btn3 ; BorderPane pane = new BorderPane  ; pane.setCenter vbox ;  Here,  three  buttons  are  created  and  added  to  a  VBox.  Then,  a  border  layout  is   created, and the VBox is added to its center region.  644      BOOK 6  JavaFX   Alternatively,  you  can  add  a  node  to  the  center  region  via  the  BorderPane   constructor, like this:  BorderPane pane = new BorderPane vbox ;  The third constructor listed in Table 4-7 lets you add nodes to all five regions at  once. The following example assumes that you have already created five panes,  named centerPane, topPane, rightPane, bottomPane, and leftPane:  BorderPane pane = new BorderPane centerPane,     topPane, rightPane, bottomPane, leftPane ;  Here are a few additional important points to know about the BorderPane class:   » If you don’t add a node to one of the regions, that region is not rendered.  » The border layout regions are sized according to their contents.  Thus, if you add a VBox pane to the right region, the width of the VBox pane  will determine the width of the right region.   » If the user resizes the window to make it wider, the top, center, and  bottom regions will expand in width — the width of the left and right  regions remains unchanged.  Similarly, if the user drags the window to make it taller, the left, center, and  right regions expand in height; the height of the top and bottom regions  remains the same.   » The nodes you add to the regions of a border pane will themselves   almost always be other layout panes.  Using the GridPane Layout  The grid pane layout manager lets you arrange GUI elements in a grid of rows and  columns. Unlike a tile pane, the rows and columns of a grid pane do not have to  be the same size. Instead, the grid pane layout automatically adjusts the width of  each column and the height of each row based on the components you add to the  panel.  CHAPTER 4  Using Layout Panes to Arrange Your Scenes      645   Here are some important features of the grid pane layout manager:   » You can specify which cell you want each component to go in, and you can   control each component’s position in the panel.   » You can create components that span multiple rows or columns, such as a   button two columns wide or a list box four rows high.   » You can tell GridPane to stretch a component to fill the entire space allotted  to it if the component isn’t already big enough to fill the entire area. You can  specify that this stretching be done horizontally, vertically, or both.   » If a component doesn’t fill its allotted area, you can tell the grid pane layout   manager how you want the component to be positioned within the area — for  example, left- or right-aligned.  The following sections describe the ins and outs of working with grid pane layouts.  Sketching out a plan  Before you create a grid pane layout, draw a sketch showing how you want the  components to appear in the panel. Then slice the panel into rows and columns,  and  number  the  rows  and  columns  starting  with  zero  in  the  top-left  corner.   Figure 4-7 shows such a sketch for an application that lets a user order a pizza.  FIGURE 4-7:   Sketching   out a panel.  646      BOOK 6  JavaFX  After you have the panel sketched out, list the components, their x and y coordi- nates on the grid, their alignment, and whether each component spans more than  one row or column. Here’s an example:   Alignment  Spans  Component  Label "Name"  Label "Phone"  Label "Address"  Name text field  Phone text field  Address text field  Size radio buttons  Style radio buttons  x  0  0  0  1  1  1  0  1  2  2  y  0  1  2  0  1  2  3  3  3  4  Right  Right  Right  Left  Left  Left  Left  Left  Left  Toppings check boxes  OK and Close buttons  Right  2  2  2  After you lay out the grid, you can write the code to put each component in its  proper place.  Creating a grid pane  Table  4-8  shows  the  most  frequently  used  constructors  and  methods  of  the   GridPane class, which you use to create a grid pane.  To create a basic grid pane, you first call the GridPane constructor. Then, you use  the add method to add nodes to the grid pane’s cells. The parameters of the add  method specify the node to be added, the node’s column index, and the node’s row  index. For example, the following code snippet creates a label, and then creates a  grid pane and adds the label to the cell at column 0, row 0:  Label lblName = new Label "Name" ; GridPane grid = new GridPane  ; grid.add lblName, 0, 0 ;  CHAPTER 4  Using Layout Panes to Arrange Your Scenes      647   TABLE 4-8	  GridPane Constructors and Methods  Constructor  GridPane    Method  Creates an empty grid pane.  Description  Description  void add Node node, int col, int row   Adds a node at the specified column and row index.  void add Node node, int col, int row,  int colspan, int rowspan   Adds a node at the specified column and row index  with the specified column and row spans.  void addColumn int col, Node... nodes   Adds an entire column of nodes.  void addRow int row, Node... nodes   Adds an entire row of nodes.    getColumnConstraints      getRowConstraints    Returns the column constraints. For more  information, see to Table 11-6.  Returns the row constraints. For more information,  see Table 11-7.  Sets the column span for the specified node.  void setRowSpan Node node, int colspan   Sets the row span for the specified node.  void setColumnSpan Node node,  int colspan   void setHalignment Node node,  HPos value   void setValignment Node node,  VPos value   void setHgap double value   Sets the horizontal alignment for the node. Allowable  values are HPos.LEFT, HPos.CENTER, and  HPos.RIGHT.  Sets the vertical alignment for the node. Allowable  values are HPos.BOTTOM, HPos.CENTER,  and HPos.TOP.  Sets the size of the gap that appears  between columns.  void setVgap double value   Sets the size of the gap that appears between rows.  static void setMargin Node node,  Insets value   Sets the margin for a particular node. See Table 5-2 in  Chapter 5 for an explanation of the Insets class.  void setPadding Insets value   Sets the padding around the inside edges of the grid  pane. See Table 5-2 in Chapter 5 for an explanation of  the Insets class.  void setMinHeight double value   Sets the minimum height of the grid pane.  void setMaxHeight double value   Sets the maximum height of the grid pane.  648      BOOK 6  JavaFX   Constructor  Description  void setPrefHeight double value   Sets the preferred height of the grid pane.  void setMinWidth double value   Sets the minimum width of the grid pane.  void setMaxWidth double value   Sets the maximum width of the grid pane.  void setPrefWidth double value   Sets the preferred width of the grid pane.  The typical way to fill a grid pane with nodes is to call the add method for each  node. However, if you prefer, you can add an entire column or row of nodes with  a single call to either addColumn or addRow. For example, this example creates a  label and a text field, and then creates a grid pane and adds the label and the text  field to the first row:  Label lblName = new Label "Name" ; TextField txtName = new TextField  ; GridPane grid = new GridPane  ; grid.addRow 0, lblName, txtName ;  If  a  node  should  span  more  than  one  column,  you  can  call  the  setColumnSpan  method to specify the number of columns the node should span. For example:  grid.setColumnSpan txtName, 2 ;  Here, the txtName node will span two columns. You use the setRowSpan in a simi- lar way if you need to configure a node to span multiple rows.  To control the horizontal alignment of a node, use the setHalignment method as  in this example:  grid.setHalignment lblName, HPos.RIGHT ;  Here, the lblName node is right-aligned within its column. The setValignment  method works in a similar way.  Like  other  layout  panes,  the  GridPane  class  has  a  host  of  methods  for  setting  spacing and alignment details. You can use the setHgap and setVgap methods to  set the spacing between rows and columns so that your layouts won’t look so clut- tered. You can use the setPadding and setMargins methods to set padding and  margins, which work just as they do with other layout panes. And you can set the  minimum, maximum, and preferred width and height for the grid pane.  CHAPTER 4  Using Layout Panes to Arrange Your Scenes      649   Working with grid pane constraints  You  can  control  most  aspects  of  a  grid  pane’s  layouts  using  methods  of  the   GridPane class, but unfortunately, you can’t control the size of individual columns  or  rows.  To  do  that,  you  must  use  the  ColumnConstraints  or  RowConstraints  class, as described in Tables 4-9 and 4-10.  TABLE 4-9	  Constructor  The ColumnConstraints Class Description  ColumnConstraints    Creates an empty column constraints object.  ColumnConstraints double width   Creates a column constraint with a fixed width.  ColumnConstraints double min, double  pref, double max   Creates a column constraint with the specified minimum,  preferred, and maximum widths.  Method  Description  void setMinWidth double value   Sets the minimum width of the column.  void setMaxWidth double value   Sets the maximum width of the column.  void setPrefWidth double value   Sets the preferred width of the column.  void setPercentWidth double value   void setHgrow Priority value   void setFillWidth boolean value   void setHalignment HPos value   Sets the width as a percentage of the total width of the  grid pane.  Determines whether the width of the column should  grow if the grid pane’s overall width increases. Allowable  values are Priority.ALWAYS, Priority.NEVER, and  Priority.SOMETIMES.  If true, the grid pane will expand the nodes within this  column to fill empty space.  Sets the horizontal alignment for the entire column.  Allowable values are HPos.LEFT, HPos.CENTER, and  HPos.RIGHT.  To use column constraints to set a fixed width for each column in a grid pane, first  create a constraint for each column. Then, add the constraints to the grid pane’s  constraints collection. Here’s an example:  ColumnConstraints col1 = new ColumnConstraints 200 ; ColumnConstraints col2 = new ColumnConstraints 200 ; ColumnConstraints col3 = new ColumnConstraints 200 ; GridPane grid = new GridPane  ; grid.getColumnConstraints  .addAll col1, col2, col3 ;  650      BOOK 6  JavaFX   TABLE 4-10	  Constructor  The RowConstraints Class  Description  RowConstraints    Creates an empty row constraints object.  RowConstraints double height   Creates a column constraint with a fixed height.  RowConstraints double min, double  pref, double max   Creates a column constraint with the specified minimum,  preferred, and maximum heights.  Method  Description  void setMinHeight double value   Sets the minimum height of the row.  void setMaxHeight double value   Sets the maximum height of the row.  void setPrefHeight double value   Sets the preferred height of the row.  void setPercentHeight double value   void setVgrow Priority value   void setFillHeight boolean value   void setValignment VPos value   Sets the height as a percentage of the total height of the  grid pane.  Determines whether the height of the row should grow  if the grid pane’s overall height increases. Allowable  values are Priority.ALWAYS, Priority.NEVER, and  Priority.SOMETIMES.  If true, the grid pane will expand the nodes within this row  to fill empty space.  Sets the horizontal alignment for the entire row. Allowable  values are VPos.TOP, HPos.CENTER, and VPos.BOTTOM.  One of the most useful features of column constraints is their ability to distribute  the width of a grid pane’s columns as a percentage of the overall width of the grid  pane. For example, suppose the grid pane will consist of three columns and you  want them to all be of the same width regardless of the width of the grid pane. The  following code accomplishes this:  ColumnConstraints col1 = new ColumnConstraints  ; col1.setPercentWidth 33 ; ColumnConstraints col2 = new ColumnConstraints  ; col2.setPercentWidth 33 ; ColumnConstraints col3 = new ColumnConstraints  ; col3.setPercentWidth 33 ; GridPane grid = new GridPane  ; grid.getColumnConstraints  .addAll col1, col2, col3 ;  In this example, each column will fill 33 percent of the grid.  CHAPTER 4  Using Layout Panes to Arrange Your Scenes      651   Several  of  the  attributes  that  can  be  set  with  column  or  row  constraints  mir- ror attributes you can set for individual nodes via the GridPane class. For exam- ple,  you  can  set  the  horizontal  alignment  of  an  individual  node  by  calling  the  setHalignment method on the grid pane. Or, you can set the horizontal alignment  of an entire column by creating a column constraint, setting its horizontal align- ment, and then applying the column constraint to a column in the grid pane.  Examining a grid pane example  Listing  4-1  shows  the  code  for  a  program  that  displays  the  scene  I  drew  for   Figure 4-8, and Figure 4-8 shows how this scene appears when the program is  run. Figure 4-8 shows that the final appearance of this scene is pretty close to the  way I sketched it.  FIGURE 4-8:   The Pizza Order  application in  action.  LISTING	4-1:	  The Pizza Order Application  import javafx.application.*; import javafx.stage.*; import javafx.scene.*; import javafx.scene.layout.*; import javafx.scene.control.*; import javafx.geometry.*;  public class PizzaOrder extends Application {     public static void main String[] args      {         launch args ;     }  652      BOOK 6  JavaFX       Stage stage;     TextField txtName;     TextField txtPhone;     TextField txtAddress;     RadioButton rdoSmall;     RadioButton rdoMedium;     RadioButton rdoLarge;     RadioButton rdoThin;     RadioButton rdoThick;     CheckBox chkPepperoni;     CheckBox chkMushrooms;     CheckBox chkAnchovies;      @Override public void start Stage primaryStage      {         stage = primaryStage;             Create the name label and text field          Label lblName = new Label "Name:" ;         txtName = new TextField  ;         txtName.setMinWidth 100 ;         txtName.setPrefWidth 200 ;         txtName.setMaxWidth 300 ;         txtName.setPromptText "Enter the name here" ;             Create the phone number label and text field          Label lblPhone = new Label "Phone Number:" ;         txtPhone = new TextField  ;         txtPhone.setMinWidth 60 ;         txtPhone.setPrefWidth 120 ;         txtPhone.setMaxWidth 180 ;         txtPhone.setPromptText "Enter the phone number here" ;             Create the address label and text field          Label lblAddress = new Label "Address:" ;         txtAddress = new TextField  ;         txtAddress.setMinWidth 100 ;         txtAddress.setPrefWidth 200 ;         txtAddress.setMaxWidth 300 ;         txtAddress.setPromptText "Enter the address here" ;             Create the size pane          Label lblSize = new Label "Size" ;         rdoSmall = new RadioButton "Small" ;         rdoMedium = new RadioButton "Medium" ;         rdoLarge = new RadioButton "Large" ;         rdoMedium.setSelected true ;         ToggleGroup groupSize = new ToggleGroup  ;  →32  →40  →48  →56  CHAPTER 4  Using Layout Panes to Arrange Your Scenes      653   continued    LISTING	4-1:	   continued           rdoSmall.setToggleGroup groupSize ;         rdoMedium.setToggleGroup groupSize ;         rdoLarge.setToggleGroup groupSize ;          VBox paneSize = new VBox lblSize, rdoSmall, rdoMedium, rdoLarge ;         paneSize.setSpacing 10 ;             Create the crust pane          Label lblCrust = new Label "Crust" ;         rdoThin = new RadioButton "Thin" ;         rdoThick = new RadioButton "Thick" ;         rdoThin.setSelected true ;         ToggleGroup groupCrust = new ToggleGroup  ;         rdoThin.setToggleGroup groupCrust ;         rdoThick.setToggleGroup groupCrust ;          VBox paneCrust = new VBox lblCrust, rdoThin, rdoThick ;         paneCrust.setSpacing 10 ;             Create the toppings pane          Label lblToppings = new Label "Toppings" ;         chkPepperoni = new CheckBox "Pepperoni" ;         chkMushrooms = new CheckBox "Mushrooms" ;         chkAnchovies = new CheckBox "Anchovies" ;          VBox paneToppings = new VBox lblToppings, chkPepperoni,             chkMushrooms, chkAnchovies ;         paneToppings.setSpacing 10 ;             Create the buttons          Button btnOK = new Button "OK" ;         btnOK.setPrefWidth 80 ;         btnOK.setOnAction e -> btnOK_Click    ;          Button btnCancel = new Button "Cancel" ;         btnCancel.setPrefWidth 80 ;         btnCancel.setOnAction e -> btnCancel_Click    ;          HBox paneButtons = new HBox 10, btnOK, btnCancel ;             Create the GridPane layout          GridPane grid = new GridPane  ;         grid.setPadding new Insets 10  ;         grid.setHgap 10 ;         grid.setVgap 10 ;         grid.setMinWidth 500 ;         grid.setPrefWidth 500 ;         grid.setMaxWidth 800 ;  →70  →82  →92  →103  654      BOOK 6  JavaFX   →112  →119  →127  →136  →146             Add the nodes to the pane          grid.addRow 0, lblName, txtName ;         grid.addRow 1, lblPhone, txtPhone ;         grid.addRow 2, lblAddress, txtAddress ;         grid.addRow 3, paneSize, paneCrust, paneToppings ;         grid.add paneButtons,2,4 ;             Set alignments and spanning          grid.setHalignment lblName, HPos.RIGHT ;         grid.setHalignment lblPhone, HPos.RIGHT ;         grid.setHalignment lblAddress, HPos.RIGHT ;         grid.setColumnSpan txtName,2 ;         grid.setColumnSpan txtPhone,2 ;         grid.setColumnSpan txtAddress,2 ;             Set column widths          ColumnConstraints col1 = new ColumnConstraints  ;         col1.setPercentWidth 33 ;         ColumnConstraints col2 = new ColumnConstraints  ;         col2.setPercentWidth 33 ;         ColumnConstraints col3 = new ColumnConstraints  ;         col3.setPercentWidth 33 ;         grid.getColumnConstraints  .addAll col1, col2, col3 ;             Create the scene and the stage          Scene scene = new Scene grid ;         primaryStage.setScene scene ;         primaryStage.setTitle "Pizza Order" ;         primaryStage.setMinWidth 500 ;         primaryStage.setMaxWidth 900 ;         primaryStage.show  ;      }      public void btnOK_Click        {             Create a message string with the customer information         String msg = "Customer:\n\n";         msg += "\t" + txtName.getText   + "\n";         msg += "\t" + txtPhone.getText   + "\n\n";         msg += "\t" + txtAddress.getText   + "\n";         msg += "You have ordered a ";             Add the pizza size         if  rdoSmall.isSelected                msg += "small ";   continued   CHAPTER 4  Using Layout Panes to Arrange Your Scenes      655   LISTING	4-1:	   continued           if  rdoMedium.isSelected                msg += "medium ";         if  rdoLarge.isSelected                msg += "large ";             Add the crust style         if  rdoThin.isSelected                msg += "thin crust pizza with ";         if  rdoThick.isSelected                msg += "thick crust pizza with ";             Add the toppings         String toppings = "";         toppings = buildToppings chkPepperoni, toppings ;         toppings = buildToppings chkMushrooms, toppings ;         toppings = buildToppings chkAnchovies, toppings ;         if  toppings.equals ""               msg += "no toppings.";         else             msg += "the following toppings:\n"                 + toppings;             Display the message         Alert a = new Alert Alert.AlertType.INFORMATION, msg ;         a.setTitle "Order Details" ;         a.showAndWait  ;     }      public String buildToppings CheckBox chk, String msg       {            Helper method for displaying the list of toppings         if  chk.isSelected            {             if  !msg.equals ""               {                 msg += ", ";             }             msg += chk.getText  ;         }         return msg;     }      public void btnCancel_Click        {         stage.close  ;     }  →187  →201  }  656      BOOK 6  JavaFX   The following paragraphs point out the highlights of this program:  →32:    A label and text field are created for the customer’s name. →40:    A label and text field are created for the customer’s phone number. →48:    A label and text field are created for the customer’s address. →56:      A label and three radio buttons are created for the pizza’s size. The  label and radio buttons are added to a VBox named paneSize.  →70:     →82:     →92:     →103:   →119:    A label and two radio buttons are created for the pizza’s crust style.  The label and radio buttons are added to a VBox named paneStyle.   A label and three check boxes are created for the pizza’s toppings. The  label and check boxes are added to a VBox named paneToppings.   The OK and Cancel buttons are created and added to an HBox named  paneButton.   The grid pane layout is created. The padding and horizontal and  vertical gaps are set to 10, and the width is set to range from 500   to 800.   The nodes are added to the pane. The name, phone number, and  address labels and text fields are added to rows 0, 1, and 2. Then,   the size, crust, and toppings VBox panes are added to row 3. Finally,  the HBox that contains the buttons are added to column 2 of row 4.   Remember: Row and column indexes are numbered from 0, not   from 1.   The scene is created, and the stage is displayed.  →127:  Column constraints are created to distribute the column widths evenly. →136:  →146:    The btnOK_Click method is called when the user clicks OK. This  method creates a summary of the customer’s order and displays it  using the Alert class.  →187:   →201:    buildToppings is simply a helper method that assists in the construc- tion of the message string.  The stage is closed when the user clicks the Close button.  CHAPTER 4  Using Layout Panes to Arrange Your Scenes      657    IN THIS CHAPTER  » Working with text fields and areas   » Validating numeric data and creating   check boxes   » Setting radio buttons   » Using some of these components in a   complete program  Chapter 5 Getting Input from  the User  In  the  first  four  chapters  of  this  minibook,  I  discuss  how  to  create  JavaFX    programs using only two basic JavaFX input controls: labels and buttons. If all  you ever want to write are programs that display text when the user clicks a  button, you can put the book down now. But if you want to write programs that  actually do something worthwhile, you need to use other JavaFX input controls.  In this chapter, you find out how to use some of the most common JavaFX con- trols. First, you read about the label and controls that get information from the  user. You find out more details about the text field control, which gets a line of  text, and the text area control, which gets multiple lines. Then I move on to two  input  controls  that  get  either or  information  from  the  user:  radio  buttons  and  check boxes.  Along the way, you discover an important aspect of any JavaFX program that col- lects input data from the user: data validation. Data validation routines are essen- tial to ensure that the user doesn’t enter bogus data. For example, you can use  data validation to ensure that the user enters data into required fields or that the  data the user enters into a numeric field is indeed a valid number.  CHAPTER 5  Getting Input from the User      659   Using Text Fields  A text field is a box into which the user can type a single line of text. You create text  fields by using the TextField class. Table 5-1 shows some of the more interesting  and useful constructors and methods of this class.  Handy TextField Constructors and Methods  Description  Creates a new text field.  TextField String text, int cols   Creates a new text field with an initial text value.  TABLE 5-1	  Constructor  TextField    Method  String getText    void requestFocus    Description  Gets the text value entered in the field.  Asks for the focus to be moved to this text field. Note that the  field must be in a scene for the focus request to work.  void setEditable boolean value   If false, makes the field read-only.  void setMaxWidth double width   Sets the maximum width for the field.  void setMinWidth double width   Sets the minimum width for the field.  void setPrefColumnCount int cols   Sets the preferred size of the text field in columns  that is, the  number of average-width text characters .  void setPrefWidth double width   Sets the preferred width for the field.  void setPromptText String prompt   Sets the field’s prompt value. The prompt value will not be  displayed if the field has a text value or if the field has focus.  void setText String text   Sets the field’s text value.  The  TextField  class  is  defined  in  the  javafx.scene.control  package,  so  you  should include the following imports statement in any program that uses a text  field:  imports javafx.scene.control.*;  660      BOOK 6  JavaFX   The  most  common  way  to  create  a  text  field  is  to  call  the  constructor  without  arguments, like this:  TextField text1 = new TextField  ;  You can set the initial value to be displayed like this:  TextField text1 = new TextField "Initial value" ;  Or, if you need to set the value later, you can call the setText method:  text1.setText "Text value" ;  To retrieve the value that the user has entered into a text field, call the getText  method like this:  String value = text1.getText  ;  As with any JavaFX control, managing the width of a text field can be a bit tricky.  Ultimately, JavaFX will determine the width of the text field based on a number  of  factors,  including  the  size  of  the  window  that  contains  the  stage  and  scene  and any size constraints placed on the pane or panes that contain the text field.  You can set minimum and maximum limits for the text field size by calling the   setMinWidth and setMaxWidth methods, and you can indicate the preferred width  via the setPrefWidth method, as in this example:  TextField text1 = new TextField  ; text1.setMinWidth 150 ; text1.setMaxWidth 250 ; text1.setPrefWidth 200 ;  Another way to set the preferred width is with the setPrefColumnCount method,  which sets the width in terms of average-sized characters. For example, the fol- lowing line sizes the field large enough to display approximately 50 characters:  text1.setPrefColumnCount 50 ;  Note that the setPrefColumnCount method does not limit the number of charac- ters the user can enter into the field. Instead, it limits the number of characters  the field can display at one time.  CHAPTER 5  Getting Input from the User      661   Whenever you use a text field, provide a prompt that lets the user know what data  he should enter into the field. One common way to do that is to place a label con- trol immediately to the left of the text field. For example:  Label lblName = new Label "Name:" ; lblName.setMinWidth 75 ; TextField txtName = new TextField  ; txtName.setMinWidth 200 ; HBox pane = new HBox 10, lblName, txtName ;  Here, a label and a text field are created and added to an HBox pane so they will be  displayed side-by-side.  JavaFX also allows you to display a prompt inside of a text field. The prompt is  displayed in a lighter text color and disappears when the field receives focus. You  use the setPromptText method to create such a prompt:  TextField txtName = new TextField  ; txtName.setPromptText "Enter the customer's name" ;  Here, the text Enter the customer's name will appear inside the text field.  To retrieve the value entered by the user into a text field, you use the getText  method, as in this example:  String lastName = textLastName.getText  ;  Here the value entered by the user in the textLastName text field is assigned to  the String variable lastName.  Figure 5-1 shows the operation of a simple program that uses a text field to allow  the user to enter the name of a character in a play and the name of the actor who  will play the role. Assuming the user enters text in both fields, the program then  displays an alert box indicating who will play the role of the character. If the user  omits either or both fields, an alert box displays to indicate the error.  Figure 5-1 shows what the main stage for this program looks like, as well as the  message box windows displayed when the user enters both names or when the  user omits a name. The JavaFX code for this program is shown in Listing 5-1.  662      BOOK 6  JavaFX   FIGURE 5-1:   The Role Player  application   in action.  LISTING	5-1:	  The Role Player Program  import javafx.application.*; import javafx.stage.*; import javafx.scene.*; import javafx.scene.layout.*; import javafx.scene.control.*; import javafx.geometry.*;  public class RolePlayer extends Application  {     public static void main String[] args      {         launch args ;     }      TextField txtCharacter;      TextField txtActor;      @Override public void start Stage primaryStage      {             Create the Character   →8  →15  →20   continued   CHAPTER 5  Getting Input from the User      663   LISTING	5-1:	   continued           Label lblCharacter = new Label "Character's Name:" ;         lblCharacter.setMinWidth 100 ;         lblCharacter.setAlignment Pos.BOTTOM_RIGHT ;             Create the Character text field          txtCharacter = new TextField  ;         txtCharacter.setMinWidth 200 ;         txtCharacter.setMaxWidth 200 ;         txtCharacter.setPromptText              "Enter the name of the character here." ;             Create the Actor label          Label lblActor = new Label "Actor's Name:" ;         lblActor.setMinWidth 100 ;         lblActor.setAlignment Pos.BOTTOM_RIGHT ;             Create the Actor text field          txtActor = new TextField  ;         txtActor.setMinWidth 200 ;         txtActor.setMaxWidth 200 ;         txtActor.setPromptText "Enter the name of the actor here." ;             Create the OK button          Button btnOK = new Button "OK" ;         btnOK.setMinWidth 75 ;         btnOK.setOnAction e -> btnOK_Click    ;             Create the Character pane          HBox paneCharacter = new HBox 20, lblCharacter, txtCharacter ;         paneCharacter.setPadding new Insets 10  ;             Create the Actor pane          HBox paneActor = new HBox 20, lblActor, txtActor ;         paneActor.setPadding new Insets 10  ;             Create the Button pane          HBox paneButton = new HBox 20, btnOK ;         paneButton.setPadding new Insets 10  ;         paneButton.setAlignment Pos.BOTTOM_RIGHT ;             Add the Character, Actor, and Button panes to a VBox          VBox pane = new VBox 10, paneCharacter, paneActor, paneButton ;             Set the stage          Scene scene = new Scene pane ;         primaryStage.setScene scene ;         primaryStage.setTitle "Role Player" ;  →25  →32  →37  →43  →48  →52  →56  →61  →64  664      BOOK 6  JavaFX           primaryStage.show  ;     }      public void btnOK_Click        {         String errorMessage = "";           if  txtCharacter.getText  .length   == 0           {             errorMessage += "\nCharacter is a required field.";         }          if  txtActor.getText  .length   == 0           {             errorMessage += "\nActor is a required field.";         }         if  errorMessage.length   == 0           {             String message = "The role of "                 + txtCharacter.getText                   + " will be played by "                 + txtActor.getText                   + ".";             Alert a = new Alert Alert.AlertType.INFORMATION, message ;             a.setTitle "Cast" ;             a.showAndWait  ;         }         else         {             Alert a = new Alert Alert.AlertType.WARNING, errorMessage ;              a.setTitle "Missing Data" ;             a.showAndWait  ;         }     } }  →71  →73  →75  →80  →85  →98  This  program  isn’t  very  complicated,  so  the  following  paragraphs  just  hit  the  highlights:  →4:  →15:     →20:       The name of the program’s main class is RolePlayer.   These class variables allow any of the RolePlayer class methods to  access the two text fields.   These lines create a label to identify the Character text box. The field is  set to a minimum width of 100 pixels and is right-justified so that the  labels for that identify the two text fields will be aligned properly.  CHAPTER 5  Getting Input from the User      665    These lines create the Character text field with a minimum and maxi- mum width of 200 pixels. The prompt text is set to Enter the name of  the character here. This text will appear within the text field when- ever the text field does not have focus. In Figure 5-1, the Character text  field has focus so the prompt text isn’t visible.   These lines create a label to identify the Actor text field. Like the  Character label, the Actor label’s width is set to 100 pixels and it’s  right-aligned.   These lines create the Actor text field, set its width to 200 pixels, and  assign prompt text. You can see the prompt text in Figure 5-1 because  the Actor text field doesn’t have focus.   These lines create the OK button. The btnOK_Click method is called  when the user clicks the button.   These lines create an HBox pane and add the Character label and text  box to it.  →25:     →32:     →37:     →43:     →48:     →52:      These lines create another HBox pane and add the Actor label and text  box to it.  →56:    These lines create a third HBox pane to hold the button. →61:      Now that all the controls are created and added to HBox panes, the  three HBox panes are added to a VBox pane so that the text boxes with  their associated labels and the button are stacked vertically.  →64:      These lines create a scene to show the VBox pane and then add the  scene to the primary stage and show the stage.  →71:    The btnOK_Click method is called whenever the user clicks OK. →73:      The errorMessage variable holds any error message that might be  necessary to inform the user of missing data.  →75:     →80:     →85:     →98:      This if statement ensures that the user has entered data into the  Character text box. If no data is entered, an error message is created.   This if statement ensures that the user has entered data into the Actor  text box. If no data is entered, an error message is appended to the  errorMessage field.   This if statement determines whether any data validation errors have  occurred by testing the length of the errorMessage field. If the length is  zero, no error has been detected, so the program assembles the  message variable to display which actor will be playing which character.  Then, an Alert box is used to display the message.   This line displays the error message if the user forgets to enter data in  the Character or Actor text fields.  666      BOOK 6  JavaFX   Validating Numeric Data  You need to take special care if you’re using a text field to get numeric data from  the user. The getText method returns a string value. You can pass this value to  one of the parse methods of the wrapper classes for the primitive numeric types.  To convert the value entered in a text box to an int, use the parseInt method:  int count = Integer.parseInt txtCount.getText   ;  Here the result of the getText method is used as the parameter of the parseInt  method.  Table 5-2 lists the parse methods for the various wrapper classes. Note: Each of  these methods throws NumberFormatException if the string can’t be converted.  As a result, you need to call the parseInt method in a try catch block to catch  this exception.  TABLE 5-2	  Methods That Convert Strings to Numbers Wrapper Class  parse Method  Integer  parseInt String   Short  Long  Byte  Float  Double  parseShort String   parseLong String   parseByte String   parseFloat String   parseDouble String   If your program uses more than one or two numeric-entry text fields, consider  creating separate methods to validate the user’s input. The following code snippet  shows a method that accepts a text field and a string that provides an error mes- sage to be displayed if the data entered in the field can’t be converted to an int.  The method returns a Boolean value that indicates whether the field contains a  valid integer:  private boolean isInt TextField f, String msg  {     try     {         Integer.parseInt f.getText   ;  CHAPTER 5  Getting Input from the User      667           return true;     }     catch  NumberFormatException e      {         Alert a = new Alert Alert.AlertType.WARNING, msg ;         a.setTitle = "Invalid Data";         a.showAndWait  ;         return false;     } }  You can call this method whenever you need to check whether a text field has a  valid integer. Here’s a method that gets the value entered in a txtCount text field  and displays it in message box if the value entered is a valid integer:  public void buttonOKClick   {     if  isInt textCount,         "You must enter an integer."       {         Alert a = new             Alert Alert.AlertType.INFORMATION,                "You entered " +                Integer.parseInt textCount.getText   ,                "Your Number" ;         a.showAndWait  ;     }     textCount.requestFocus  ; }  Here the isInt method is called to make sure that the text entered by the user  can be converted to an int. If so, the text is converted to an int and displayed in  an alert box.  Using Check Boxes  A check box is a control that the user can click to check or clear. Check boxes let  the user specify a Yes or No setting for an option. Figure 5-2 shows a window with  three check boxes.  668      BOOK 6  JavaFX   Strictly  speaking,  a  check  box  can  have  three  states:  checked,  unchecked,  and  undefined. The undefined state is most often used in conjunction with a TreeView  control.  FIGURE 5-2:   Three check  boxes.  TABLE 5-3	  Constructor  CheckBox    Method  String getText    boolean isSelected    To create a check box, you use the CheckBox class. Its favorite constructors and  methods are shown in Table 5-3.  Notable CheckBox Constructors and Methods  Description  Creates a new check box that is initially unchecked  CheckBox String text   Creates a new check box that displays the specified text  Description  Gets the text displayed by the check box  Returns true if the check box is checked or false if the  check box is not checked  Sets an ActionEvent listener to handle action events  Checks the check box if the parameter is true; unchecks  it if the parameter is false  void setOnAction EventHandler<Action Event> value   void setSelected boolean value   void setText String text   Sets the check box text  As with any JavaFX control, if you want to refer to a check box in any method  within the program, declare a class variable to reference the control:  CheckBox chkPepperoni, chkMushrooms, chkAnchovies;  CHAPTER 5  Getting Input from the User      669   Then you can use statements like these in the start method to create the check  boxes and add them to a layout pane  in this case, pane1 :  chkPepperoni = new CheckBox "Pepperoni" ; pane1.add chkPepperoni ;  chkMushrooms = new CheckBox "Mushrooms" ; pane1.add chkMushrooms ;  chkAnchovies = new CheckBox "Anchovies" ; pane1.add chkAnchovies ;  Notice that I didn’t specify the initial state of these check boxes in the constructor.  As a result, they’re initially unchecked. If you want to create a check box that’s  initially checked, call setSelected method, like this:  chkPepperoni.setSelected true ;  In  an  event  listener,  you  can  test  the  state  of  a  check  box  by  using  the   isSelected method, and you can set the state of a check box by calling its set  Selected  method.  Here’s  a  method  that  displays  a  message  box  and  clears  all  three check boxes when the user clicks OK:  public void btnOK_Click   {     String msg = "";     if  chkPepperoni.isSelected            msg += "Pepperoni\n";     if  chkMushrooms.isSelected            msg += "Mushrooms\n";     if  chkAnchovies.isSelected            msg += "Anchovies\n";     if  msg.equals ""           msg = "You didn't order any toppings.";     else         msg = "You ordered these toppings:\n"                 + msg;     Alert a = new Alert Alert.AlertType.INFORMATION,         msg" ;     a.setTitle "Your Order" ;     a.showAndWait  ;     chkPepperoni.setSelected false ;     chkMushrooms.setSelected false ;     chkAnchovies.setSelected false ; }  670      BOOK 6  JavaFX   Here,  the  name  of  each  pizza  topping  selected  by  the  user  is  added  to  a  text  string. If you select pepperoni and anchovies, for example, the following message  displays:  You ordered these toppings: Pepperoni Anchovies  If you want, you can add event listeners to check boxes to respond to events gen- erated when the user clicks those check boxes. Suppose that your restaurant has  anchovies on the menu, but you refuse to actually make pizzas with anchovies on  them. Here’s a method you can call in an event listener to display a message if  the user tries to check the Anchovies check box; after displaying the message, the  method then clears the check box:  public void chkAnchovies_Click  {     Alert a = new Alert Alert.AlertType.WARNING,         "We don't do anchovies here." ;     a.setTitle "Yuck!"      a.showAndWait  ;     chkAnchovies.setSelected false ; }  To add this event listener to the Anchovies check box, call its setOnAction method,  like this:  chkAnchovies.setOnAction e -> chkAnchovies_Click    ;  Add a listener to a check box only if you need to provide immediate feedback to the  user when she selects or deselects the box. In most applications, you wait until the  user clicks a button to examine the state of any check boxes in the frame.  Using Radio Buttons  Radio buttons are similar to check boxes, but with a crucial difference: They travel  in groups, and a user can select only one radio button at a time from each group.  When you click a radio button to select it, the radio button within the same group  that  was  previously  selected  is  deselected  automatically.  Figure  5-3  shows  a   window with three radio buttons.  CHAPTER 5  Getting Input from the User      671   FIGURE 5-3:   A frame with  three radio   buttons.  To work with radio buttons, you use two classes. First, you create the radio but- tons  themselves  with  the  RadioButton  class,  whose  constructors  and  methods  are shown in Table 5-4. Then you create a group for the buttons with the Toggle  Group class and add the radio buttons to the toggle group.  A ToggleGroup object is simply a way of associating a set of radio buttons so that  only  one  of  the  buttons  can  be  selected.  The  toggle  group  object  itself  is  not  a  control and is not displayed. To display radio buttons, you add the individual radio  buttons, not the toggle group, to a layout pane.  Various RadioButton Constructors and Methods  Description  Creates a new radio button with no text  RadioButton String text   Creates a new radio button with the specified text  TABLE 5-4	  Constructor  RadioButton    Method  String getText    boolean isSelected    Description  Gets the text displayed by the radio button  Returns true if the radio button is selected or false if  the radio button is not selected  Sets an ActionEvent listener to handle action events  Selects the radio button if the parameter is true;  de-selects it if the parameter is false  void setOnAction EventHandler<Action  Event> value   void setSelected boolean value   void setText String text   Sets the check box text  The usual way to create a radio button is to declare a variable to refer to the but- ton as a class variable so that it can be accessed anywhere in the class, as in this  example:  RadioButton rdoSmall, rdoMedium, rdoLarge;  672      BOOK 6  JavaFX   Then, in the start method, you call the RadioButton constructor to create the  radio button:  rdoSmall = new RadioButton "Small" ;  Thereafter, you can add the radio button to a layout pane in the usual way.  To  create  a  toggle  group  to  group  radio  buttons  that  work  together,  call  the   ToggleGroup class constructor:  ToggleGroup sizeGroup = new ToggleGroup  ;  Then call the setToggleGroup method of each radio button:  rdoSmall.setToggleGroup sizeGroup ; rdoMedium.setToggleGroup sizeGroup ; rdoLarge.setToggleGroup sizeGroup ;  Toggle groups have nothing to do with how radio buttons display. To display radio  buttons, you must still add them to a layout pane. And there’s no rule that says  that all the radio buttons within a toggle group must be added to the same layout  pane. However, it is customary to display all the radio buttons in a single toggle  group together on the scene so that the user can easily see that the radio buttons  belong together.  If you’ve worked with radio buttons in Swing, you’ll want to note an important  distinction between the way JavaFX toggle groups work versus how button groups  work in Swing. In JavaFX, radio buttons that are outside a toggle group are inde- pendent of one another. In Swing, radio buttons that are outside a button group  are  all  part  of  a  default  group.  Thus,  in  JavaFX,  always  add  radio  buttons  to  a  toggle group, even if the scene has only a single toggle group.  Looking at a Pizza Order Application  This  section  presents  a  fairly  complicated  application  that  lets  the  user  order  a pizza. The user enters his name, address, and phone number into text fields,  selects the pizza’s size and crust style using radio buttons, and chooses toppings  via check boxes. Figure 5-4 shows the main window displayed by the Pizza Order  application.  When the user enters the data for his pizza order and clicks OK, this program dis- plays a message box summarizing the order, as shown in Figure 5-5.  CHAPTER 5  Getting Input from the User      673   FIGURE 5-4:   The Pizza Order  application’s main  window.  FIGURE 5-5:   The Pizza Order  application   confirms the  user’s order.  674      BOOK 6  JavaFX  It may not be obvious at first glance, but the scene displayed by the Pizza Order  application  uses  a  total  of  12  layout  panes  to  govern  the  arrangement  of  its   controls. The overall scene is organized with a border pane whose top region dis- plays the title  Order Your Pizza Now! . The center region displays the text fields,  radio buttons, and check boxes that let the user configure her pizza order. And the  bottom region contains the OK and Cancel buttons.  For your reference, Table 5-5 lists the 12 layout panes that are used to organize  this content.   TABLE 5-5	  Name  Layout Panes Used in the Pizza Order Application Class  Description  paneMain  BorderPane  The scene’s main root pane.  paneTop  HBox  paneName  HBox  Contains the title text that’s displayed in the top region of the  border pane.  Contains the label and text box for the customer’s name, placed  side-by-side.  panePhone  HBox  Contains the label and text box for the phone number, placed side-by-side.  paneAddress  HBox  Contains the label and the text box for the address, placed side-by-side.  paneCustomer  VBox  Contains the name, phone, and address panes, stacked vertically.  paneSize  VBox  paneCrust  VBox  Contains a label with the text “Size” and the three radio buttons that let  the user choose the pizza size, stacked vertically.  Contains a label with the text “Crust” and the two radio buttons that let  the user choose the crust style, stacked vertically.  paneToppings  FlowPane  A flow pane that contains the check boxes for the toppings.  paneTopping  VBox  paneOrder  HBox  paneBottom  HBox  Contains a label with the text “Toppings” and the flow pane that lists the  toppings, stacked vertically.  Contains the three VBox panes that list the sizes, crust styles, and  toppings arranged side-by-side. This pane is displayed in the center  region of the border pane.  Contains the OK and Cancel buttons arranged side-by-side. A spacer is  used to force the buttons to the right margin. This pane is displayed in  the bottom region of the border pane.  The source code for the Pizza Order application is shown in Listing 5-2.  LISTING	5-2:	  The Pizza Order Application  import javafx.application.*; import javafx.stage.*; import javafx.scene.*; import javafx.scene.layout.*; import javafx.scene.control.*; import javafx.geometry.*; import javafx.scene.text.*;  public class PizzaOrder extends Application {  CHAPTER 5  Getting Input from the User      675   continued    LISTING	5-2:	   continued       public static void main String[] args      {         launch args ;     }         Stage stage;         Customer name, phone and address fields      TextField txtName;     TextField txtPhone;     TextField txtAddress;         Size radio buttons      RadioButton rdoSmall;     RadioButton rdoMedium;     RadioButton rdoLarge;         Crust style radio buttons      RadioButton rdoThin;     RadioButton rdoThick;         Topping radio buttons      CheckBox chkPepperoni;     CheckBox chkSausage;     CheckBox chkLinguica;     CheckBox chkOlives;     CheckBox chkMushrooms;     CheckBox chkTomatoes;     CheckBox chkAnchovies;      @Override public void start Stage primaryStage      {         stage = primaryStage;             ----- Create the top pane -----          Text textHeading = new Text "Order Your Pizza Now!" ;         textHeading.setFont new Font 20  ;         HBox paneTop = new HBox textHeading ;         paneTop.setPadding new Insets 20, 10, 20, 10  ;             ---------- Create the customer pane ----------             Create the name label and text field  676      BOOK 6  JavaFX           Label lblName = new Label "Name:" ;         lblName.setPrefWidth 100 ;         txtName = new TextField  ;         txtName.setPrefColumnCount 20 ;         txtName.setPromptText "Enter the customer's name here" ;         txtName.setMaxWidth Double.MAX_VALUE ;         HBox paneName = new HBox lblName, txtName ;             Create the phone number label and text field          Label lblPhone = new Label "Phone Number:" ;         lblPhone.setPrefWidth 100 ;         txtPhone = new TextField  ;         txtPhone.setPrefColumnCount 20 ;         txtPhone.setPromptText "Enter the customer's phone number here" ;         HBox panePhone = new HBox lblPhone, txtPhone ;             Create the address label and text field          Label lblAddress = new Label "Address:" ;         lblAddress.setPrefWidth 100 ;         txtAddress = new TextField  ;         txtAddress.setPrefColumnCount 20 ;         txtAddress.setPromptText "Enter the customer's address here" ;         HBox paneAddress = new HBox lblAddress, txtAddress ;             Create the customer pane          VBox paneCustomer = new VBox 10, paneName,             panePhone, paneAddress ;             ---------- Create the order pane ----------             Create the size pane          Label lblSize = new Label "Size" ;         rdoSmall = new RadioButton "Small" ;         rdoMedium = new RadioButton "Medium" ;         rdoLarge = new RadioButton "Large" ;         rdoMedium.setSelected true ;         ToggleGroup groupSize = new ToggleGroup  ;         rdoSmall.setToggleGroup groupSize ;         rdoMedium.setToggleGroup groupSize ;         rdoLarge.setToggleGroup groupSize ;          VBox paneSize = new VBox lblSize, rdoSmall, rdoMedium, rdoLarge ;         paneSize.setSpacing 10 ;   continued   CHAPTER 5  Getting Input from the User      677   LISTING	5-2:	   continued              Create the crust pane          Label lblCrust = new Label "Crust" ;         rdoThin = new RadioButton "Thin" ;         rdoThick = new RadioButton "Thick" ;         rdoThin.setSelected true ;         ToggleGroup groupCrust = new ToggleGroup  ;         rdoThin.setToggleGroup groupCrust ;         rdoThick.setToggleGroup groupCrust ;          VBox paneCrust = new VBox lblCrust, rdoThin, rdoThick ;         paneCrust.setSpacing 10 ;             Create the toppings pane          Label lblToppings = new Label "Toppings" ;         chkPepperoni = new CheckBox "Pepperoni" ;         chkSausage = new CheckBox "Sausage" ;         chkLinguica = new CheckBox "Linguica" ;         chkOlives = new CheckBox "Olives" ;         chkMushrooms = new CheckBox "Mushrooms" ;         chkTomatoes = new CheckBox "Tomatoes" ;         chkAnchovies = new CheckBox "Anchovies" ;          FlowPane paneToppings = new FlowPane Orientation.VERTICAL,             chkPepperoni, chkSausage, chkLinguica, chkOlives,             chkMushrooms, chkTomatoes, chkAnchovies ;         paneToppings.setPadding new Insets 10, 0, 10, 0  ;         paneToppings.setHgap 20 ;         paneToppings.setVgap 10 ;         paneToppings.setPrefWrapLength 100 ;          VBox paneTopping = new VBox lblToppings, paneToppings ;             Add the size, crust, and toppings pane to the order pane          HBox paneOrder = new HBox 50, paneSize, paneCrust, paneTopping ;             Create the center pane          VBox paneCenter = new VBox 20, paneCustomer, paneOrder ;         paneCenter.setPadding new Insets 0,10, 0, 10  ;             ---------- Create the bottom pane ----------          Button btnOK = new Button "OK" ;         btnOK.setPrefWidth 80 ;         btnOK.setOnAction e -> btnOK_Click    ;  678      BOOK 6  JavaFX           Button btnCancel = new Button "Cancel" ;         btnCancel.setPrefWidth 80 ;         btnCancel.setOnAction e -> btnCancel_Click    ;          Region spacer = new Region  ;          HBox paneBottom = new HBox 10, spacer, btnOK, btnCancel ;         paneBottom.setHgrow spacer, Priority.ALWAYS ;         paneBottom.setPadding new Insets 20, 10, 20, 10  ;             Create a message string with the customer information             ---------- Finish the scene ----------          BorderPane paneMain = new BorderPane  ;         paneMain.setTop paneTop ;         paneMain.setCenter paneCenter ;         paneMain.setBottom paneBottom ;             Create the scene and the stage          Scene scene = new Scene paneMain ;         primaryStage.setScene scene ;         primaryStage.setTitle "Pizza Order" ;         primaryStage.show  ;     }      public void btnOK_Click       {          String msg = "Customer:\n\n";         msg += "\t" + txtName.getText   + "\n";         msg += "\t" + txtAddress.getText   + "\n";         msg += "\t" + txtPhone.getText   + "\n\n";         msg += "You have ordered a ";             Add the pizza size          if  rdoSmall.isSelected                msg += "small ";         if  rdoMedium.isSelected                msg += "medium ";         if  rdoLarge.isSelected                msg += "large ";             Add the crust style          if  rdoThin.isSelected                msg += "thin crust pizza with ";  CHAPTER 5  Getting Input from the User      679   continued    LISTING	5-2:	   continued           if  rdoThick.isSelected                msg += "thick crust pizza with ";             Add the toppings          String toppings = "";         toppings = buildToppings chkPepperoni, toppings ;         toppings = buildToppings chkSausage, toppings ;         toppings = buildToppings chkLinguica, toppings ;         toppings = buildToppings chkOlives, toppings ;         toppings = buildToppings chkTomatoes, toppings ;         toppings = buildToppings chkMushrooms, toppings ;         toppings = buildToppings chkAnchovies, toppings ;         if  toppings.equals ""               msg += "no toppings.";         else             msg += "the following toppings:\n"                 + toppings;             Display the message          Alert a = new Alert Alert.AlertType.INFORMATION,msg ;         a.setTitle "Order Details" ;         a.showAndWait  ;     }      public String buildToppings CheckBox chk, String msg      {            Helper method for displaying the list of toppings         if  chk.isSelected            {             if  !msg.equals ""               {                 msg += ", ";             }             msg += chk.getText  ;         }         return msg;     }      public void btnCancel_Click       {         stage.close  ;     }  }  680      BOOK 6  JavaFX   IN THIS CHAPTER  » Using the ChoiceBox control   » Working with the ObservableList   interface  selection  controls   » Listening for changes to the user’s    » Using the ComboBox and ListView    » Using the TreeView control  Chapter 6 Choosing from a List  An entire category of JavaFX controls are designed to let the user choose one   or more items from a list. This chapter presents three such controls: choice  boxes, combo boxes, and lists. Along the way, you discover how to use the  ObservableList interface, which is used to manage the list of items displayed by  a choice box, combo box, or a list view control.  Actually, if you’ve read along so far, you’ve already been briefly introduced to the  ObservableList interface, as it’s also used to manage the list of controls that are  displayed in a layout pane. In Chapter 5, you read about how to use the addAll  method of this interface. In this chapter, you read about the additional capabilities  of this interface.  You also discover how to add an event listener that can respond when the user  changes the current selection.  Using Choice Boxes  A choice box is a control that lets the user choose an item from a drop-down list.  Initially, the choice box shows just the item that’s currently selected. When the  user  clicks  the  choice  box,  the  list  of  choices  reveals.  The  user  can  change  the   CHAPTER 6  Choosing from a List      681   selection by clicking any of the items in the list. Figure 6-1 shows a scene with a  simple choice box.  FIGURE 6-1:   A scene with a  choice box.  TABLE 6-1	  Constructor  ChoiceBox     You use the ChoiceBox class to create choice boxes. Table 6-1 lists the most fre- quently used constructors and methods of this class.  Common ChoiceBox Constructors and Methods  Description  Creates an empty choice list of the specified type  Creates a choice list and fills it with the values in the  specified list  ChoiceBox  ObservableList  items   Method  ObservableList  getItems    Description  Gets the list of items  void setItems ObservableList  items   Sets the list of items  T getValue    void setValue T value   void show    void hide    Returns the currently selected item  Sets the currently selected item  Shows the list of items  Hides the list of items  boolean isShowing    Indicates whether the list of items is currently visible  682      BOOK 6  JavaFX   Creating a choice box  Creating a choice box is easy. The ChoiceBox class is generic, so specify a type for  the list that will be associated with the choice box. For example:  ChoiceBox  choice = new ChoiceBox   ;  Here, a choice box that displays strings is created.  The next step is to add items to the choice box. You can do that by calling the  getItems method to access the list of items and then calling the add method to  add an item:  choice.getItems  .add "Bashful" ; choice.getItems  .add "Doc" ; choice.getItems  .add "Dopey" ; choice.getItems  .add "Grumpy" ; choice.getItems  .add "Happy" ; choice.getItems  .add "Sleepy" ; choice.getItems  .add "Sneezy" ;        t s i L a m o r f   g n i s o o h C  Alternatively, you could call the addAll method and add all the strings at once,  like this:  choice.getItems  .addAll "Bashful", "Doc", "Dopey",                        "Grumpy", "Happy", "Sleepy",                        "Sneezy" ;  The getItems method returns an object of type ObservableList, which offers a  number of methods that let you work with the list. For more information, see the  section “Working with Observable Lists” later in this chapter.  The ChoiceBox class also includes a constructor that lets you add an Observable  List object when you create the choice box. This lets you create the list before  you create the choice box. You see an example of this constructor in action in the   section “Working with Observable Lists” in this chapter.  You can add any kind of object you want to a choice box. The choice box calls the  toString method of each item to determine the text to display in the choice list.  Suppose  you  have  a  class  named  Astronaut  that  represents  an  astronaut  on  a  space mission:  class Astronaut {     private String firstName;     private String lastName;  CHAPTER 6  Choosing from a List      683       public Astronaut String FirstName, String LastName      {         firstName = FirstName;         lastName = LastName;     }      public String toString       {         return firstName + " " + lastName;     } }  Then, you could create a choice box listing the crew of Apollo 13 like this:  ChoiceBox  apollo13; Apollo13 = new ChoiceBox   ; apollo13.getItems  .add new Astronaut "Jim", "Lovell"  ; apollo13.getItems  .add new Astronaut      "John", "Swigert"  ; apollo13.getItems  .add new Astronaut "Fred", "Haise"  ;  If you wish, you can display the contents of a choice box without waiting for the  user to click the box. To do that, call the show method, like this:  apollo13.show  ;  To hide the list, call the hide method:  apollo13.hide  ;  Setting a default value  By default, a choice box has no initial selection when it’s first displayed. To set an  initial value, call the setValue method, passing it the list object that you want to  make the initial selection.  If  the  choice  box  contains  strings,  you  can  set  the  initial  value  by  passing  the  desired string value to the setValue method:  choice.setValue "Dopey" ;  If  the  specified  string  doesn’t  exist  in  the  list,  the  initial  value  will  remain  unspecified.  684      BOOK 6  JavaFX   If the choice box contains objects, such as the Astronaut objects, illustrated in  the preceding section, you must pass a reference to the object you want to be the  default choice. For example:  Astronaut lovell = new Astronaut "Jim", "Lovell" ; Astronaut swigert = new Astronaut "John", "Swigert" ; Astronaut haise = new Astronaut "Fred", "Haise" ; ChoiceBox apollo13 = new ChoiceBox   ; apollo13.getItems  .addAll lovell, swigert, haise ; apollo13.setValue lovell ;  Here, Jim Lovell is set as the default astronaut.  Getting the selected item  You can call the getValue method to get the item selected by the user. The type of  the value returned depends on the type specified when you created the choice box.  For example, if you specified type String, the getValue method returns strings.  If you specified type Astronauts for the choice box, the getValue method returns  astronauts.  The getValue method is often used in the action event handler for a button. For  example:  public void btnOK_Click   {     String message = "You chose ";     message += apollo13.getValue  ;     Alert a = new Alert Alert.AlertType.INFORMATION, message ;     a.setTitle "Your Favorite Astronaut" ;     a.showAndWait  ; }        t s i L a m o r f   g n i s o o h C  Working with Observable Lists  As you saw in the previous section, the ChoiceBox class does not include methods  that  let  you  directly  add  or  remove  items  from  the  list  displayed  by  the  choice  box. Instead, it includes a method named getItems that returns an object of type  ObservableList. The object returned by this method is an observable list; it repre- sents the list displayed by the choice box.  CHAPTER 6  Choosing from a List      685   To  work  with  the  items  displayed  by  a  choice  box,  you  must  first  access  the  observable list and then use methods of the ObservableList class to access the  individual items in the list.  Observable lists are used not only by the ChoiceBox class, but also by other control  classes that display list items, such as ComboBox and List, which you can read  about later in this chapter. Both of those classes also have a getItems method that  returns an ObservableList.  Observable lists are also used by layout panes, such as HBox and VBox, which you  can read about in Chapter 5. The getChildren method that’s common to all layout  classes returns an ObservableList.  So far in this book, I’ve discussed just two methods of the ObservableList inter- face: add and addAll, which lets you add items to the observable list. Here’s an  example of the add method from earlier in this chapter:  cbox.getItems  .add "Bashful" ;  And  here’s  an  example  from  Chapter  5,  which  uses  the  addAll  method  to  add   buttons to a layout pane:  pane.getChildren  .addAll btnOK, btnCancel ;  The ObservableList interface has many other methods besides add and addAll.  Table 6-2 shows the methods you’re most likely to use.  TABLE 6-2	  Method  Commonly Used ObservableList Methods  Description  void add E element   Adds the specified element to the end of the list.  void add int index, E element   Adds the specified object to the list at the specified  index position.  void addAll E...elements   Adds all the specified elements to the end of the list.  void addAll Collection  c   E set int index, E elem   Adds all the elements of the specified collection to  the end of the list.  Sets the specified element to the specified object.  The element that was previously at that position is  returned as the method’s return value.  void clear    Deletes all elements from the array list.  686      BOOK 6  JavaFX   Method  Description  void remove int fromIndex, int toIndex   void removeAll E...elements   boolean contains Object elem   E get int index   int indexOf Object elem   boolean isEmpty    E remove int index   boolean remove Object elem   int size    Removes all objects whose index values are between  the values specified.  Removes all objects whose index values are between  the values specified.  Returns a boolean that indicates whether the  specified object is in the list.  Returns the object at the specified position in the list.  Returns the index position of the first occurrence of  the specified object in the list. If the object isn’t in the  list, it returns –1.  Returns a boolean value that indicates whether the  list is empty.  Removes the object at the specified index and returns  the element that was removed.  Removes an object from the list. Note: More than one  element refers to the object; this method removes  only one of them. It returns a boolean that indicates  whether the object was in the list.  Returns the number of elements in the list.  void addListener ListChangeListener   listener   Adds a ListChangeListener that’s called whenever  the list changes.        t s i L a m o r f   g n i s o o h C  If you’re familiar with Java collection classes, such as ArrayList, you may have  noticed that many of the methods listed in Table 6-2 are familiar. That’s because  the  ObservableList  class  extends  the  List  class,  which  is  implemented  by  classes, such as ArrayList and Vector. As a result, any method that can be used  with an ArrayList can also be used with an ObservableList.  For example, you can clear the contents of a choice box in the same way you’d  clear the contents of an array list:  cbox.getItems  .clear  ;  If you need to know how many items are in a choice box, call the size method:  int count = cbox.getItems  .size  ;  To remove a specific item from the list, use the remove method:  cbox.getItems  .remove "Grumpy" ;  CHAPTER 6  Choosing from a List      687   This method succeeds whether or not the string "Grumpy" appears in the list.  You can easily insert items from an existing Java collection, such as an array list,  into a choice box by specifying the collection in the addAll method. For example,  suppose you already have an array list named list that contains the items you  want to display in the choice box. You can add the items like this:  cbox.getItems  .addAll list ;  You might be wondering why an observable list is required for the items displayed  by list-based JavaFX controls. Why not just use the existing collection classes? The  reason is that for list-based controls to work efficiently, the controls  themselves  need  to  monitor  any  changes  you  might  make  to  the  list  of  items  so  that  the  control can automatically update the displayed items. The last method listed in  Table 6-2  addListener  provides this capability by allowing you to add a listener  that’s called whenever the contents of the list changes. You will rarely call this  method  directly.  But  the  controls  that  use  observable  lists  do  call  this  method   create event listeners that automatically update the control whenever the contents  of the list changes.  Note: You do not use the addListener method to respond when the user selects an  item in a choice box or other type of list control. Instead, you use an interesting  construct called a selection model to respond to changes in the selected item, as  described in the next section.  It’s not uncommon to want your program to respond immediately when the user  changes  the  selection  of  a  choice  box  or  other  list  control,  without  waiting  for  the user to click a button to submit the data. For example, you might have a label  whose  value  you  want  to  update  immediately  whenever  the  user  changes  the  selection. You might even want to show or hide different controls based on the  selection.  Unfortunately, the choice box and other list controls don’t generate an action event  when the user changes the selection. As a result, the ChoiceBox class doesn’t have  a setOnAction method. Instead, you must use a complicated sequence of method  calls to set up a different type of event listener, called a change listener.  Here’s the sequence: 1.  Get the selection model by calling the getSelectionModel method on the   choice box.  Listening for Selection Changes  688      BOOK 6  JavaFX   The getSelectionModel method returns the control’s selection model, which   is an object that manages how the user can select items from the list. The  selection model is an object that implements one of several classes that extend  the abstract SelectionModel class. For a choice box, the selection model is  always of type SingleSelectionMode, which implements a selection model  that allows the user to select just one item from the list at a time.  2.  Get the selectedItem property by calling the selectedItemProperty   method on the selection model.  The SelectionModel class has a method named selectedItemProperty  that accesses a property named selectedItem, which represents the item  currently selected.  A property is a special type of JavaFX object whose value can be  monitored by a listener that’s called whenever the value of the property changes.  3.  Add a change listener by calling the addListener method on the selected   Item property.  The listener will be called whenever the value of the selectedItem property  changes. The change listener implements a functional interface called, naturally,  ChangeListener. Because ChangeListener is a functional interface  that is, it  has just one method , you can use a lambda expression to implement the  change listener.  You normally do all three of these steps in a single statement, as in this example:  choice.getSelectionModel  .selectedItemProperty       .addListener   v, oldValue, newValue  ->         lbl.setText newValue ;  ;  In the preceding example, the change listener sets the value displayed by a label  control to the new value selected by the user.  Being a functional interface, ChangeListerner defines a single function named  changed, which is called whenever the value of the property changes. The changed  method receives three arguments:        t s i L a m o r f   g n i s o o h C   » observable: The property whose value has changed  » oldValue: The previous value of the property  » newValue: The new value of the property  These three parameters are specified in the parentheses at the beginning of the  Lambda expression. In the body of the Lambda expression, the newValue param- eter is assigned to the text of a label. Thus, the value selected by the user will be   CHAPTER 6  Choosing from a List      689   displayed by the label, and the label will be updated automatically whenever the  user changes the choice box selection.  Using Combo Boxes  A  combo  box  is  a  more  advanced  sibling  to  the  choice  box  control.  The  main  improvements you get with a combo box are   » A combo box includes the ability to limit the number of items displayed   when the list is shown.  If the number of items in the list exceeds the limit, a scroll bar is added  automatically to allow the user to scroll through the entire list.   » A combo box includes a text field that lets the user enter a value directly   rather than select the value from a list.  The text field is optional and is not shown by default, but you can add it with a  single method call.  Figure 6-2 shows a combo box with the text field shown.   » A combo box fires an action event whenever the user changes the   selection.  Thus, setting up an event handler to respond to the user’s selection change is  easier with a combo box than it is with a choice box.  You use the ComboBox class to create combo boxes. Table 6-3 lists the most fre- quently used constructors and methods of this class.  FIGURE 6-2:   A combo box.  690      BOOK 6  JavaFX   TABLE 6-3	  Constructor  ComboBox     Common ComboBox Constructors and Methods  Description  Creates an empty combo box of the specified type.  Creates a combo box and fills it with the values in the  specified list.  ComboBox  ObservableList  items   Method  Description  void setEditable boolean value   If true, a text field is displayed to allow the user to  directly edit the selection.  void setVisibleRowCount int value   Sets the number of items to display.  void setPromptText String text   Sets the prompt text initially displayed in the text field.  ObservableList  getItems    Gets the list of items.  void setItems ObservableList  items   Sets the list of items.  T getValue    void setValue T value   void show    void hide    Returns the currently selected item.  Sets the currently selected item.  Shows the list of items.  Hides the list of items.  void setOnAction EventHandler<Action  Event> handler   Sets an event handler that’s called whenever the  selection changes.  boolean isShowing    Indicates whether the list of items is currently visible.        t s i L a m o r f   g n i s o o h C  Creating combo boxes  Creating a combo box is much like creating a choice box. Because the ComboBox is  generic, specify a type for the items it will contain, as in this example:  ComboBox  cbox = new ComboBox   ;  Then you can use the getItems method to access the ObservableList object that  contains the content of the list displayed by the combo box. For example, you can  add items to the list like this:  cbox.getItems  .addAll "Bashful", "Doc", "Dopey",                        "Grumpy", "Happy", "Sleepy",                        "Sneezy" ;  CHAPTER 6  Choosing from a List      691   For more information about working with the ObservableList interface, flip to  the section “Working with Observable Lists” earlier in this chapter.  By default, the user isn’t allowed to edit the data in the text field portion of the  combo box. If you want to allow the user to edit the text field, use the setEditable  method, like this:  cbo.setEditable true ;  Then the user can type a value that’s not in the combo box.  If you want, you can limit the number of items displayed by the list by calling the  setVisibleRows method:  cbo.setVisibleRows 10 ;  Here, the list displays a maximum of ten items. If the list contains more than ten  items, a scroll is added automatically so the user can scroll through the entire list.  You  can  also  specify  a  prompt  text  to  display  in  the  text  field  component  of  a  combo box by calling the setPromptText method:  cbo.setPromptText "Make a choice" ;  Here, the text Make a choice displays in the text field.  Getting the selected item  To get the item selected by the user, use the getValue method, just as you do for  a choice box. You typically do that in an action event handler that responds to a  button click. For example:  public void btnOK_Click   {     String message = "You chose ";     message += cbo.getValue  ;     Alert a = new Alert Alert.AlertType.INFORMATION,         msg ;     a.setTitle "Your Choice" ;     a.showAndWait  ; }  692      BOOK 6  JavaFX   Bear in mind that the value returned by the getValue method may not be one of  the values in the combo box’s list. That’s because the user can enter anything he  wishes to in the text field of an editable combo box. If you want to know whether  the user selected an item from the list or entered a different item via the text field,  use the contains method of the ObservableList class, like this:  if  !cbo.getItems  .contains cbo.getValue     {     Alert a = new Alert Alert.AlertType.INFORMATION,         "You chose outside the box" ;     a.setTitle "Good Thinking!" ; }  Here, the alert displays if the user enters an item that’s not in the list.  Handling combo box events  When the user selects an item from a combo box, an action event is generated. In  most applications, you simply ignore this event because you usually don’t need to  do anything immediately when the user selects an item. Instead, the selected item  is processed when the user clicks a button.  If you want to provide immediate feedback when the user selects an item, you can  set up an event handler by calling the combo box’s setOnAction method. In most  cases, the easiest way to do that is to create a method that contains the code you  want to execute when the user selects an item and then pass this method to the  setOnAction method via a Lambda expression.  For example, the following method displays a message box that says My favorite  too! if the user picks Dopey:        t s i L a m o r f   g n i s o o h C  Public void cbo_Changed   {     if  if cbo.getValue  .equals "Dopey"       {         Alert a = new             Alert Alert.AlertType.INFORMATION,             "He's my favorite too!",         a.setTitle "Good Choice" ;         a.showAndWait  ;     } }  CHAPTER 6  Choosing from a List      693   Here’s  the  code  to  call  this  method  whenever  the  user  changes  the  combo  box  selection:  cbo.setOnAction  e -> cbo_Changed    ;  Using List Views  A list view is a powerful JavaFX control that displays a list of objects within a box.  Depending on how the list is configured, the user can select one item in the list or  multiple items. In addition, you have amazing control over how the items in the  list display. Figure 6-3 shows a sample scene with a list view.  FIGURE 6-3:   A list view control.  694      BOOK 6  JavaFX  List views and combo boxes have several important differences:   » A list view doesn’t have a text field that lets the user edit the selected   item. Instead, the user must select items directly from the list view.   » The list view doesn’t drop down. Instead, the list items display in a box   whose size you can specify.   » The items in a list view can be arranged vertically  the default  or   horizontally. Figure 6-4 shows a horizontal list box.   » List views allow users to select more than one item. By default, a list view   lets users select just one item, but you can easily configure it to allow for  multiple selections.  To select multiple items in a list, hold down the Ctrl key and click the items you  want to select. To select a range of items, click the first item, hold down the  Shift key, and click the last item.   FIGURE 6-4:   A horizontal list  view control.  TABLE 6-4	  Constructor  ListView     You use the ListView class to create a list view control. Table 6-4 lists the most  frequently used constructors and methods of this class.  Common ListView Constructors and Methods  Description  Creates an empty list view of the specified type.  Creates a list view and fills it with the values in the  specified list.  ListView  ObservableList  items   Method  ObservableList  getItems    Description  Gets the list of items.  void setItems ObservableList  items   Sets the list of items.  void setOrientation Orientation o   MultipleSelectionModel   getSelectionModel    Sets the orientation of the list. The orientation  can be Orientation.HORIZONTAL or  Orientation.VERTICAL.  Returns the selection model for the list view control.  You can use the selection model to get an observable  list of selected items by calling its getSelectedItems  method. You can also retrieve the most recently selected  item by calling getSelectedItem.        t s i L a m o r f   g n i s o o h C  Creating a list view  Creating a list view control is similar to creating a combo box. Here’s an example  that creates the list view that’s shown in Figure 6-3:  ListView list = new ListView  ; list.getItems  .addAll "Sausage", "Pepperoni",     "Linguica", "Salame", "Olives", "Mushrooms",     "Onions", "Peppers", "Pineapple", "Spinach",     "Canadian Bacon", "Tomatoes", "Kiwi",     "Anchovies", "Gummy Bears" ;  CHAPTER 6  Choosing from a List      695   Notice that the list view shown in Figure 6-3 shows only the first eight items in  the list. As with a combo box, a scroll bar is automatically added to a list view if the  total number of items in the items collection cannot be displayed.  By default, the list view control allows only a single selection to be made. To allow  multiple selections, add this line:  list.getSelectionModel  .setSelectionMode SelectionMode.MULTIPLE ;  To arrange the list view horizontally rather than vertically, add this line:  list.setOrientation Orientation.HORIZONTAL ;  Getting the selected items  Getting the selected items from a list view control is a bit tricky. First, you must  get  the  selection  model  object  by  calling  the  getSelectionModel.  Then,  you  call the selection model’s  getSelectedItems method. This returns a read-only  observable list that contains just the items that have been selected.  Here’s an example that builds a string that lists all the items selected by the user  for the pizza toppings list view that is shown in Figure 6-3:  String tops = ""; ObservableList  toppings; toppings = list.getSelectionModel  .getSelectedItems  ; for String topping : toppings  {     tops += topping + "\n"; }  In the preceding example, the tops string will contain all the toppings selected by  the user, separated by new line characters.  Using Tree Views  696      BOOK 6  JavaFX  A tree view is a fancy JavaFX control that displays hierarchical data in outline form,  which we computer nerds refer to as a tree. Tree structures are very common in  the world of computers. The folder structure of your disk drive is a tree, as is a  JavaFX scene graph.   Figure 6-5 shows a JavaFX scene that has a tree view control in it. In this example,  I use a tree control to represent a few of my favorite TV series, along with series  that were spun off from them.  FIGURE 6-5:   A tree view  control.        t s i L a m o r f   g n i s o o h C  Before I get into the mechanics of how to create a tree control, you need to know  a few terms that describe the elements in the tree itself:   » Node: Each element in the tree is a node. Each node in a tree is created from  TreeItem class. The TreeItem class is a generic class, so you can associate a  type with it. Thus, you can create a tree using objects of any type you wish,  including types you create yourself.   » Root node: A root node is the starting node for a tree. Every tree must have  one — and only one — root node. When you create a tree component, you  pass the root node to the TreeView constructor.   » Child node: The nodes that appear immediately below a given node are that   node’s child nodes. A node can have more than one child.   » Parent node: The node immediately above a given node is that node’s parent   node. Every node except the root node must have one — and only one —   parent.   » Sibling nodes: Sibling nodes are children of the same parent.  CHAPTER 6  Choosing from a List      697    » Leaf node: A leaf node is one that doesn’t have any children.  » Path: A path contains the node and all its ancestors — that is, its parent, its   parent’s parent, and so on — all the way back to the root.   » Expanded node: An expanded node is one whose children are visible.  » Collapsed node: A collapsed node is one whose children are hidden.  Before you can actually create a tree view, you must first build the tree it displays.  To do that, use the TreeItem class, the details of which I discuss in Table 6-5.  Building a tree  The TreeItem Class  TABLE 6-5	  Constructor  TreeItem      Method  T getValue    Description  Creates an empty tree node.  Description  Returns the tree item’s value.  TreeItem  T value   Creates a tree node with the specified value.  void setValue T value   Sets the tree item’s value.  ObservableList getChildren    Returns an ObservableList that represents the children of   this tree item.  TreeItem getParent    Gets this node’s parent.  void setExpanded   boolean expanded   boolean isExpanded    boolean isLeaf    TreeItem nextSibling    TreeItem prevSibling    Specify true to expand the node.  Returns a boolean that indicates whether the tree item  is expanded.  Returns a boolean that indicates whether the tree item is a leaf  node  that is, has no children . A leaf node can’t be expanded.  Returns the next sibling of this tree item. If there is no next  sibling, returns null.  Returns the previous sibling of this tree item. If there is no  previous sibling, returns null.  The TreeItem class provides three basic characteristics for each node:  698      BOOK 6  JavaFX    » The value, which contains the data represented by the node.  In my example, I use strings for the user objects, but you can use objects of  any type you want for the user object. The tree control calls the user object’s  toString method to determine what text to display for each node. The  easiest way to set the user object is to pass it via the TreeItem constructor.   » The parent of this node, unless the node happens to be the root.  » The children of this node, represented as an ObservableList.  The list will be empty if the node happens to be a leaf node. You can create or  retrieve child nodes using the familiar methods of the ObservableList  interface. For more information, refer to the section “Working with Observable  Lists” earlier in this chapter.  In this section, I build a tree that lists spinoff shows from three popular television  shows of the past:   » The Andy Griffith Show, which had two spinoffs: Gomer Pyle, U.S.M.C., and   Mayberry R.F.D.   » All in the Family, which directly spawned four spinoffs: The Jeffersons, Maude,   Gloria, and Archie Bunker’s Place.  In addition, two of these spinoffs had spinoffs of their own involving the  maids: The Jeffersons’ maid became the topic of a short-lived show called  Checking In, and Maude’s maid became the main character in Good Times.  » Happy Days, which spun off Mork and Mindy, Laverne and Shirley, and Joanie   Loves Chachi.  You  can  take  many  approaches  to  building  trees,  most  of  which  involve  some  recursive programming. I’m going to avoid recursive programming in this section  to keep things simple, but my avoidance means that you have to hard-code some  of the details of the tree into the program. Most real programs that work with  trees need some type of recursive programming to build the tree.  The first step in creating a tree is declaring a TreeItem variable for each node that  isn’t a leaf node. For my TV series example, I start with the following code:        t s i L a m o r f   g n i s o o h C  TreeItem andy, archie, happy,          george, maude;  These variables can be local variables within the start method because once you  get  the  tree  set  up,  you  won’t  need  these  variables  anymore.  You  see  why  you  don’t need variables for the leaf nodes in a moment.  CHAPTER 6  Choosing from a List      699   Next,  I  create  the  root  node  and  set  its  expanded  status  to  true  so  that  it  will  expand when the tree displays initially:  TreeItem root = new TreeItem "Spin Offs " ; root.setExpanded true ;  To  simplify  the  task  of  creating  all  the  other  nodes,  I  use  the  following  helper  method, makeShow:  public TreeItem  makeShow String title,     TreeItem  parent  {     TreeItem  show = new TreeItem  title ;     show.setExpanded true ;     parent.getChildren  .add show ;     return show; }  This method accepts a string and another node as parameters, and returns a node  whose user object is set to the String parameter. The returned node is also added  to the parent node as a child, and the node is expanded. Thus you can call this  method to both create a new node and place the node in the tree.  The next step is creating some nodes. Continuing my example, I start with the  nodes for The Andy Griffith Show and its spinoffs:  andy = makeShow "The Andy Griffith Show", root ; makeShow "Gomer Pyle, U.S.M.C.", andy ; makeShow "Mayberry R.F.D.", andy ;  Here, makeShow is called to create a node for The Andy Griffith Show, with the root  node  specified  as  its  parent.  The  node  returned  by  this  method  is  saved  in  the  andy variable. Then makeShow is called twice to create the spinoff shows, this time  specifying andy as the parent node.  Because neither Gomer Pyle, U.S.M.C., nor Mayberry R.F.D. had a spinoff show, I don’t  have to pass these nodes as the parent parameter to the makeShow method. That’s  why I don’t bother to create a variable to reference these nodes.  Next in my example, I create nodes for All in the Family and its spinoffs:  archie = makeShow "All in the Family", root ; george = makeShow "The Jeffersons", archie ; makeShow "Checking In", george ;  700      BOOK 6  JavaFX   maude = makeShow "Maude", archie ; makeShow "Good Times", maude ; makeShow "Gloria", archie ; makeShow "Archie Bunker's Place", archie ;  In this case, The Jeffersons and Maude have child nodes of their own. As a result,  variables are required for these two shows so that they can be passed as the par- ent parameter to makeShow when I create the nodes for Checking In and Good Times.  Finally, here’s the code that creates the nodes for Happy Days and its spinoffs:  happy = makeShow "Happy Days", root ; makeShow "Mork and Mindy", happy ; makeShow "Laverne and Shirley", happy ; makeShow "Joanie Loves Chachi", happy ;  The complete tree is successfully created in memory, so I can get on with the task  of creating a TreeView control to show off the tree.  Creating a TreeView control  You use the TreeView class to create a tree component that displays the nodes of a  tree. Table 6-6 shows the key constructors and methods of this class.        t s i L a m o r f   g n i s o o h C  TABLE 6-6	  Constructor  TreeView     The TreeView Class  Description  TreeView  TreeItem root   Method  TreeItem getRoot    void setRoot TreeItem root   MultipleSelectionModel   getSelectionModel    void setRootVisible   boolean visible   Creates an empty tree  not very useful, if you ask me .  Creates a tree that displays the tree that starts at the  specified node.  Description  Gets the root node.  Sets the root node.  Returns the selection model for the list view control. You can  use the selection model to get an observable list of selected  items by calling its getSelectedItems method. You can  also retrieve the most recently selected item by calling  getSelectedItem.  Determines whether the root node should be visible.  CHAPTER 6  Choosing from a List      701   The first step in creating a TreeView control is declaring a TreeView variable as a  class instance variable so that you can access it in any method within your pro- gram, as follows:  TreeView tree;  Then,  in  the  application’s  start  method,  you  call  the  TreeView  constructor  to  create the tree view control, passing the root node of the tree you want it to dis- play as a parameter:  tree = new TreeView root ;  By default, the user can select just one node from the tree. To allow the user to  select multiple nodes, use this strange incantation:  tree.getSelectionModel  .setSelectionMode      SelectionModel.MULTIPLE ;  Here  the  getSelectionModel  method  is  called  to  get  the  selection  model  that  manages the selection of nodes within the tree. This method returns an object of  type  MultipleSelectionModel, which includes a method named  setSelection  Mode that lets you set the selection mode. To allow multiple items to be selected,  you must pass this method the SelectionModel.MULTIPLE.  That’s it! You now have a TreeView control that you can add to a layout pane and  display in your scene.  Although the tree displayed by a tree view control must begin with a root node, in  many cases the root node is superfluous. For example, in the example you’ve been  looking at, what’s the point of showing the root node? The TreeView control lets  you suppress the display of the root node if you don’t want it to be shown. To hide  the root node, just call this method:  tree.setShowRoot false ;  Figure 6-6 shows how the tree appears with the root node hidden.  Getting the selected node  There are several ways to determine which node or nodes are currently selected  in  a  tree  view.  One  way  is  to  access  the  tree’s  selection  model  by  calling  the   getSelectionModel. Then, you can call the selection model’s getSelectedItems  method to return a read-only observable list that contains the items that have  been selected.  702      BOOK 6  JavaFX   FIGURE 6-6:   A tree view   control with the  root node hidden.  For example:  String msg = ""; ObservableList > shows =     tree.getSelectionModel  .getSelectedItems  ; for TreeItem show : shows  {     msg += show.getValue   + "\n"; }        t s i L a m o r f   g n i s o o h C  In the preceding example, the msg string will contain all the shows that the user  has selected from the tree, separated by new line characters.  An  alternative  is  to  add  an  event  handler  that’s  called  whenever  the  selection  changes. You can do that like this:  tree.getSelectionModel  .selectedItemProperty       .addListener   v, oldValue, newValue  ->             tree_SelectionChanged newValue   ;  Here,  the  getSelectionModel  method  is  called  to  retrieve  the  selection  model.  Then, the selectedItemProperty is called to retrieve the selected item property.  Finally, an event listener is created for this property by using a Lambda expression  that calls a method named tree_SelectionChanged. The value of the new selec- tion is passed as a parameter.  CHAPTER 6  Choosing from a List      703   Here’s what the tree_SelectionChanged method looks like:  public void tree_SelectionChanged TreeItem  item  {     if  item != null      {         lblShowName.setText item.getValue   ;     } }  Here,  a  label  named  lblShowName  is  updated  to  display  the  value  of  the  newly  selected item. Note: An if statement is used to ensure that the item is not null.  That’s  necessary  because  if  the  user  deselects  an  item,  the  tree_Selection  Changed method will be called with a null value as its item parameter.  Looking at a complete program   that uses a tree view  Whew! That was a lot of information to digest. In this section, I put it all together.  Listing  6-1  shows  the  complete  program  that  creates  the  scene  shown  in   Figure 6-6. This program lets the user select a show from the tree and displays  the title of the selected show in a label below the tree.  LISTING	6-1:	  The Spinoff Program  import javafx.application.*; import javafx.stage.*; import javafx.scene.*; import javafx.scene.layout.*; import javafx.scene.control.*; import javafx.geometry.*;  public class SpinOffs extends Application {     public static void main String[] args      {         launch args ;     }      TreeView  tree;      Label lblShowName;     @Override public void start Stage primaryStage      {         TreeItem   root, andy, archie,                            happy, george, maude;  →15  →20  704      BOOK 6  JavaFX           root = new TreeItem  "Spin Offs" ;          root.setExpanded true ;          andy = makeShow               "The Andy Griffith Show", root ;         makeShow "Gomer Pyle, U.S.M.C.", andy ;         makeShow "Mayberry R.F.D", andy ;          archie = makeShow "All in the Family", root ;          george = makeShow "The Jeffersons", archie ;         makeShow "Checking In", george ;         maude = makeShow "Maude", archie ;         makeShow "Good Times", maude ;         makeShow "Gloria", archie ;         makeShow "Archie Bunker's Place", archie ;          happy = makeShow "Happy Days", root ;          makeShow "Mork and Mindy", happy ;         makeShow "Laverne and Shirley", happy ;         makeShow "Joanie Loves Chachi", happy ;          tree = new TreeView  root ;          tree.setShowRoot false ;         tree.getSelectionModel  .selectedItemProperty                .addListener   v, oldValue, newValue  ->                 tree_SelectionChanged newValue   ;          lblShowName = new Label  ;          VBox pane = new VBox 10 ;         pane.setPadding new Insets 20,20,20,20  ;         pane.getChildren  .addAll tree, lblShowName ;           Scene scene = new Scene pane ;          primaryStage.setScene scene ;         primaryStage.setTitle "My Favorite Spin Offs" ;         primaryStage.show  ;      }  →23  →26  →31  →39  →44  →46  →54        t s i L a m o r f   g n i s o o h C      public TreeItem  makeShow String title,        TreeItem  parent       {         TreeItem  show = new TreeItem  title ;         show.setExpanded true ;         parent.getChildren  .add show ;  →64    continued   CHAPTER 6  Choosing from a List      705   LISTING	6-1:	   continued           return show;     }      public void tree_SelectionChanged TreeItem  item       {         if  item != null          {             lblShowName.setText item.getValue   ;         }     }  }  →73  All the code in this program has already been shown in this chapter, so I just point  out the highlights here:  →15:     The tree and list models are defined as class instance variables.  →20:      TreeItem variables are defined for the root node and each show that has   spinoff shows.  →23:     The root node is created with the text Spin-Offs.  →26:     These lines create the nodes for The Andy Griffith Show and its spinoffs.  →31:     These lines create the nodes for All in the Family and its spinoffs.  →39:     These lines create the nodes for Happy Days and its spinoffs.  →44:      This line creates the TreeView control, specifying root as the root node   for the tree. The next line hides the root node.  →46:      This line creates the event listener for the selected item property. The   Lambda expression causes the method named tree_Selection  Changed to be called whenever the selection status of the TreeView  control changes.  →54:      The TreeView control and the label are added to a VBox layout pane,   which is then added to the scene just before the stage is shown.  →64:      The makeShow method creates a node from a string and adds the node to   the node passed as the parent parameter.  →73:      The tree_SelectionChanged method is called whenever the selected   node changes. It simply displays the title of the selected show in the  lblShowName label, provided the passed TreeItem is not null.  706      BOOK 6  JavaFX   Web  Programming  7   Contents at a Glance  CHAPTER 1:  Using Java Web Start  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 709 CHAPTER 2:  Creating Servlets   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 721 CHAPTER 3:  Using JavaServer Pages  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 741 CHAPTER 4:  Using JavaBeans  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 757   IN THIS CHAPTER  » Using Java Web Start to launch Java   applications from a web page   » Creating a JNLP file to enable Java   Web Start for an application   » Crafting a Java Web Start HTML file   » Changing security settings to allow   Java Web Start  Chapter 1 Using Java Web Start  Java Web Start is a way to deploy Java applications via a web page. The web   page can reside on the Internet or on a local company intranet. Either way,  Java Web Start allows a user to run a Java program by browsing to a web page   and clicking a link.  Java Web Start can only be used to deploy programs that have a graphical user  interface   GUI .  The  best  way  to  develop  a  GUI  program  is  to  use  JavaFX,  as  described in Book 6. You can also deploy GUI programs developed using Swing, an  older method of creating GUI programs that isn’t covered in this book.  In this chapter, you learn how to deploy a simple JavaFX application via Java Web  Start.  Looking at a Simple JavaFX Program  The JavaFX application used to illustrate Java Web Start is called ClickMe. When  run, it simply displays the dialog box shown in Figure 1-1. As you can see, the  dialog box contains a button labeled “Click me please!” When the user clicks the  button, the button’s label changes to “You clicked me!” If the user clicks again,  the button reverts to “Click me please!” and the process repeats until the user  closes the program by clicking the Close button  the X in the upper-right corner  of the window .  CHAPTER 1  Using Java Web Start      709   FIGURE 1-1:   The ClickMe  program in  action.  The operation of this program is explained in detail in Chapter 1 of Book 6. You  don’t  really  need  to  know  anything  about  how  the  ClickMe  program  works  to  deploy via Java Web Start, but for reference the source code for the program is  shown  in  Listing  1-1.  The  code  shown  in  this  listing  should  be  saved  to  a  file  named ClickMe.java. If you want to know more about the program before you  learn how to deploy it using Java Web Start, please refer to Book 6, Chapter 1.  LISTING 1-1:   The ClickMe Program  import javafx.application.*; import javafx.stage.*; import javafx.scene.*; import javafx.scene.layout.*; import javafx.scene.control.*;  public class ClickMe extends Application {     public static void main String[] args      {         launch args ;         System.out.println "Done" ;     }      Button btn;      @Override public void start Stage primaryStage      {            Create the button         btn = new Button  ;         btn.setText "Click me please!" ;         btn.setOnAction e -> buttonClick   ;  710      BOOK 7  Web Programming              Add the button to a layout pane         BorderPane pane = new BorderPane  ;         pane.setCenter btn ;             Add the layout pane to a scene         Scene scene = new Scene pane, 300, 250 ;             Add the scene to the stage, set the title            and show the stage         primaryStage.setScene scene ;         primaryStage.setTitle "The Click Me App" ;         primaryStage.show  ;     }      public void buttonClick       {         if  btn.getText   == "Click me please!"          {             btn.setText "You clicked me!" ;         }         else         {              btn.setText "Click me please!" ;         }     }  }  The ClickMe.java source file can be compiled to a Java Class file by using the fol- lowing command from a command prompt:  The class file can then be used to create an executable JAR file using this command:  javac ClickMe.java  jar cf ClickMe.jar *.class  After the JAR file has been created, you’re ready to configure Java Web Start to  launch the ClickMe program from a web page.        t r a t S b e W a v a J   g n i s U  CHAPTER 1  Using Java Web Start      711   Understanding Java Web Start  Java Web Start works by providing a web link to a special file called a JNLP file.  This file contains  all the information  necessary to download and launch a Java  application on an end user’s computer. When the user clicks the link to the JNLP  file, the web server reads the contents of the JNLP file, downloads the Java pro- gram, and runs it on the user’s computer.  With Java Web Start, the Java program does not run within the user’s web browser  environment. Instead, Java Web Start runs the Java Virtual Machine  JVM  locally  on the user’s computer, and then runs the application within the JVM.  An older technology called applets allows Java programs to run directly within a  web browser. Doing so requires the assistance of a browser plugin, which can lead  to compatibility issues between different plugin versions. Browser manufactur- ers have recently announced that they will no longer include plugins to support  applets, and Oracle officially deprecated applets in Java 9.  If  the  user’s  computer  does  not  have  the  Java  runtime  installed   or  has  an  incorrect version of the runtime , Java Web Start offers to download and install  the  Java  runtime  automatically.  As  a  result,  even  if  the  user  doesn’t  have  Java  installed, the user can install Java and run the Java application with just a few  mouse clicks.  Ordinarily, applications that run via Java Web Start are prevented from perform- ing certain operations that might create security risks for the user, such as reading  and writing files on the user’s file system or accessing the user’s local network.  You can configure Java Web Start security features to allow these types of activity,  but doing so is beyond the scope of this book. For more information, search the  web for Java Web Start.  The general process for setting up an application to run with Java Web Start is as  follows: 1.  Create a JAR file that contains the Java application you want to run via   Java Web Start.  For information about how to create a JAR file, refer to Book 3, Chapter 8. For  the purposes of this chapter, I assume you’ve created a JAR file named  ClickMe.jar for the ClickMe application.  712      BOOK 7  Web Programming   2.  Create a JNLP file that specifies the necessary information to enable the   program to run from Java Web Start.  Among other things, the JNLP file must contain the location of the application’s  JAR file. For the application illustrated in this chapter, we’ll name the JNLP file  clickme.jnlp.  For more information about creating a JNLP file, see the next section.  3.  Create an HTML file that contains a link to the JNLP file.  The HTML file will be displayed in the user’s browser. When the user clicks the  link to the JNLP file, the application defined in the JNLP file is run. For this  chapter, the HTML file will be named clickme.html.  For more information about creating the HTML file, see the section “Creating  an HTML File to Launch a Java Application” later in this chapter.  4.  Copy the JAR, JNLP, and HTML files to the appropriate folders on the   web server.  You can use any FTP client  such as FileZilla  to upload the files to your web  server, or you can use your web host’s file management utilities to upload the  files. In most cases, the JAR, JNLP, and HTML file will all reside in the same  folder on the web server. However, it is possible to save each of the files to a  different folder.  Creating a JNLP File  To deploy a Java application via Java Web Start, you must create a JNLP file that  contains the details needed to locate and run the application. The JNLP file is a  small XML file that contains information such as the name of the application, a  URL that points to the application’s JAR file, the vendor who created the appli- cation, the Java version the application requires, and a URL that can be used to  download the Java runtime in case it isn’t already installed on the user’s computer.  JNLP stands for Java Network Launch Protocol, but that won’t be on the test.  If you aren’t already familiar with the basics of XML, you can learn about XML’s  syntax requirements in Book 8, Chapter 5.  Listing 1-2 shows a JNLP file named ClickMe.jnlp that can be used to run the  ClickMe  application  from  the  website  www.lowewriter.com.  for  the  ClickMe  application.        t r a t S b e W a v a J   g n i s U  CHAPTER 1  Using Java Web Start      713   LISTING 1-2:   The JNLP File for the ClickMe Application    <jnlp spec="1.0+"     codebase="http:  www.lowewriter.com ClickMe"      href="ClickMe.jnlp">                 ClickMe            LoweWriter                                           <j2se version="1.6+"             href="http:  www.oracle.com technetwork java javase downloads" >         <jar href="ClickMe.jar"              main="true"  >                              →3 →4  →6 →7  →14  →17  Most  of  the  lines  in  this  JNLP  file  are  written  the  same  for  all  Java  Web  Start  applications. The lines that you need to change for your particular Java Web Start  application are described in the following paragraphs:  →3        The codebase attribute should be changed to reflect the root location   where your application is saved on your website. In this case, the  application’s files are stored at http:  www.lowewriter.com ClickMe.  Although the codebase attribute is not absolutely required, using it can  simplify the rest of the JNLP file because URLs that appear elsewhere in  the JNLP file are relative to the codebase path. You’ll see what I mean in  the next paragraph.   →4        The href attribute indicates the path to the jnlp file. Note that in this  example, I specified just the name of the file rather than the complete  path. That’s because the path given here is relative to the path given in the  codebase attribute. Because the jnlp file is in the http:  lowewriter. com ClickMe folder, specifying just the filename is sufficient here to  identify the jnlp file.   →6        The   element provides the name of the application — in this   case, “ClickMe.”  714      BOOK 7  Web Programming    →7        The   attribute provides the name of the application’s vendor —   in this case, “LoweWriter.”   →14      The href attribute of the jar element provides the location of the  application’s JAR file. Again, because this file resides in the folder  indicated by the codebase, I specified just the filename here.   →17      The main-class attribute of the application-desc element indicates   the name of the application’s main class, which contains the main  method that is called to start the application. In this case, the main class  is ClickMe.  Creating an HTML File to   Launch a Java Application  Once you’ve created a JNLP file that describes your Java Web Start application, you  can create an HTML file that your users can view to launch the application. The  HTML file should have a link to the JNPL file. The easiest way to provide that link  is to use an a element in the HTML file, as shown in the ClickMe.html file shown  in Listing 1-3.  LISTING 1-3:  An HTML File That Links to a JNPL File                   ClickMe  Java Web Start                        ClickMe!           Run the ClickMe application           In Listing 1-3, the a element provides the necessary link:   Run the ClickMe application   Figure 1-2 shows how the ClickMe.html file appears when displayed in a browser  window.  CHAPTER 1  Using Java Web Start      715        t r a t S b e W a v a J   g n i s U   FIGURE 1-2:   The ClickMe  HTML page.  Uploading the Java Web Start   Files to Your Web Server  For this simple Java Web Start application, I’ve created a total of five files:   » ClickMe.java: The source file for the ClickMe application, shown in    » ClickMe.class: The compiled class file for the ClickMe application, created   Listing 1-1.  by the Java compiler.   » ClickMe.jar: The JAR file that contains the ClickMe class. This file will be   uploaded to the web server, and in turn downloaded to the user’s computer  when the user launches the application from the web page.   » ClickMe.jnlp: The JNLP file that references the ClickMe.jar file. This file   will also be uploaded to the web server.   » ClickMe.html: The HTML file that provides a link to the ClickMe.jnlp file. This   file, too, will be uploaded to the web server.  The JAR, JNLP, and HTML files all need to be uploaded to your web server so your  users can access them via a browser. You can use whatever means you prefer to   716      BOOK 7  Web Programming   upload the files. If you prefer FTP, use an FTP client such as FileZilla to upload  the files. If your web host provides an upload tool, you can use it. Or if your web  server is local to your own network  for example, if it is an intranet server , you  can simply use your operating system to copy the files.  Regardless of how you accomplish it, the goal is to get the JAR, JNLP, and HTML  files in a folder on your web server. For the ClickMe application, I uploaded the  files  to  the  ClickMe  folder  under  my  web  root  folder,  so  the  HTML  file  will  be  accessible via the URL http:  www.lowewriter.com ClickMe ClickMe.html.  Launching the ClickMe Application Using  Java Web Start  When  all  the  files  are  in  place,  a  web  user  can  access  the  ClickMe  application  by  opening  a  web  browser  and  navigating  to  the  URL  for  the  HTML  page   in  our  example,  http:  www.lowewriter.com ClickMe ClickMe.html .  Refer  to  Figure 1-2 to see how the page appears in the browser window.  When the user clicks the Run the ClickMe application link, the dialog box shown  in Figure 1-3 appears, asking the user whether she wants to run the application.        t r a t S b e W a v a J   g n i s U  FIGURE 1-3:   The Security  Warning prompt  displayed when a  user clicks a Java  Web Start link.  CHAPTER 1  Using Java Web Start      717   Assuming the user clicks Run, the ClickMe application is then run, as shown in  Figure 1-4.  FIGURE 1-4:   The ClickMe  application run  from Java Web  Start.  Creating an Exception to Allow Java Web  Start Applications to Run  In some cases, Java’s security settings may prevent a Java Web Start application  from running. If that happens, the user can correct the problem by adding the URL  of the application to the Java Exception Site List. Here are the steps for doing that  on a Windows computer: 1.  Open the Java Control Panel.  The easiest way to do that is to press the Start button, type java, press Enter,  and then click Configure Java.  Figure 1-5 shows the Java Control Panel for Java 9  previous versions are similar .  2.  Click the Web Settings tab.  Because you’re changing a security setting, you might think you’d need to click  the Security tab. But the Exception Site List is found on the Web Settings tab, as  shown in Figure 1-6.  718      BOOK 7  Web Programming   FIGURE 1-5:   The Java Control  Panel.  FIGURE 1-6:   The Web   Settings tab.  3.  Click Add.        t r a t S b e W a v a J   g n i s U  This pops up a text entry box in which you can enter a URL.  4.  Type the URL of the web site you want to add and press Enter.  In this example, type http:  www.lowewriter.com. The URL will be added to  the exception list.  5.  Click OK to close the Java Control Panel.  You should now be able to run the application via Java Web Start.  CHAPTER 1  Using Java Web Start      719    IN THIS CHAPTER  » Looking at servlets   » Downloading, installing, and   configuring Tomcat   » Creating simple servlets   » Working with forms to get data from   the user  Chapter 2 Creating Servlets  Servlets are among the most popular ways to develop web applications today.   Many of the best-known websites are powered by servlets, including Gmail,  Amazon, LinkedIn, and eBay. In this chapter, I give you just the basics: what  a servlet is, how to set up your computer so that you can code and test servlets,  and how to create a simple servlet. The next two chapters build on this topic, pre- senting additional web programming techniques.  Understanding Servlets  Before you can understand what a servlet is and how it works, you need to under- stand the basics of how web servers work. Web servers use a networking protocol  called HTTP to send web pages to users.  HTTP stands for Hypertext Transfer Pro- tocol, but that won’t be on the test.  With HTTP, a client computer uses a uni- form resource locator, or URL, to request a document that’s located on the server  computer. HTTP uses a request response model, which means that client computers   web users  send request messages to HTTP servers, which in turn send response  messages back to the clients.  CHAPTER 2  Creating Servlets      721   A basic HTTP interaction works something like this: 1.  Using a web-browser program running on a client computer, you specify the   URL of a file that you want to access.  In some cases, you actually type the URL of the address, but most of the time  you click a link that specifies the URL.  2.  Your web browser sends an HTTP request message to the server computer   indicated by the URL.  The request includes the name of the file that you want to retrieve.  3.  The server computer receives the file request, retrieves the requested file, and   sends the file back to you in the form of an HTTP response message.  4.  The web browser receives the file, interprets the HTML that it contains, and   displays the result onscreen.  The most important thing to note about normal web interactions is that they’re  static. By static, I mean that the content of the file sent to the user is always the  same. If the user requests the same file 20 times in a row, the same page displays  20 times.  By contrast, a servlet provides a way for the content to be dynamic. A servlet is   simply  a  Java  program  that  extends  the  javax.servlet.Servlet  class.  The  Servlet class enables the program to run on a web server in response to a user  request, and output from the servlet is sent back to the web user as an HTML page.  When you use servlets, Steps 1, 2, and 4 of the preceding procedure are the same;  the fateful third step is what sets servlets apart. If the URL specified by the user  refers to a servlet rather than a file, Step 3 goes more like this: 3.  The server computer receives the servlet request, locates the Java program  indicated by the request, runs it, and returns the output from the program in  the form of an HTTP response message.  In  other  words,  instead  of  sending  the  contents  of  a  file,  the  server  sends  the  output generated by the servlet program. Typically, the servlet program generates  some HTML that’s displayed by the browser.  Servlets  are  designed  to  get  their  work  done  quickly  and  then  end.  Each  time  a servlet runs, it processes one request from a browser, generates one page that’s  sent back to the browser, and then ends. The next time that user or any other user  requests the same servlet, the servlet runs again.  722      BOOK 7  Web Programming   Using Tomcat  Unfortunately,  you  can’t  run  servlet  programs  on  any  old  computer.  First,  you  have  to  install  a  special  program  called  a  servlet  engine  to  turn  your  computer  into a server that’s capable of running servlets. The best-known servlet engine is  Apache Tomcat, which is available free from the Apache Software Foundation at  http:  tomcat.apache.org. For this chapter, I used Tomcat version 8.     s t e l v r e S g n i t a e r C  Tomcat can also work as a basic web server. In actual production environments,  Tomcat  is  usually  used  in  combination  with  a  specialized  web  server,  such  as  Apache’s HTTP Server.  Installing and configuring Tomcat  Installing Tomcat isn’t rocket science, but it’s not as easy as making toast, either.  Here are the steps you can follow to set up Tomcat 8: 1.  Download the Tomcat Zip file from the Apache website  http:  tomcat.  apache.org .  Although Apache also offers an executable setup file for installing Tomcat,  I suggest that you download the Zip file instead.  2.  Extract the contents of the Zip file by right-clicking the file and choosing   Extract All; then specify c:\ as the location to extract the files to.  I know you don’t want to clutter your root directory with a bunch of files, but  the Tomcat Zip file contains a single folder named apache-tomcat-8_0_0  the  version number may vary , so only this one folder is created. After all the files  are extracted, give this folder a new name that’s a little easier to type. I suggest  c:\tomcat.  3.  Create an environment variable named JAVA_HOME that points to the   location of your Java Development Kit  JDK .  To create an environment variable, open Control Panel, double-click the  System icon, and then click Advanced System Settings➪  Environment  Variables➪  New, and create a variable named JAVA_HOME. The value of this  variable needs to be the complete path to your JDK installation folder, such as  c:\Program Files\Java\jdk-9.  A common mistake is to set this variable to the bin directory or to the directory  for the Java Runtime Environment  JRE , not the JDK. If Tomcat doesn’t start up  later, double-check the JAVA_HOME directory.  CHAPTER 2  Creating Servlets      723   4.  Copy the servlet-api.jar file to the jre\lib\ext folder in your JDK root. If your JDK is installed in c:\Program Files\Java\jdk-9, copy this file to c:\ Program Files\Java\jdk-9\jre\lib\ext. You find the servlet-api.jar file  in c:\tomcat\lib, assuming that you extracted the Tomcat files to c:\tomcat.  If you skip this step or copy the servlet-api.jar file to the wrong place, you  can’t compile your servlet programs. If you get compiler messages complaining  that the javax.servlet package doesn’t exist, double-check this step to make  sure you performed it right.  Starting and stopping Tomcat  After  you  install  and  configure  Tomcat,  you  can  start  it  by  opening  a  command  window, changing to the c:\tomcat\bin directory, and typing startup. A batch file  runs, starting Tomcat. When Tomcat starts, it opens a second command window  that displays various status messages. Figure 2-1 shows the status window in action.  FIGURE 2-1:   Starting Tomcat.  You know that Tomcat has started when you see a line such as the following, indi- cating how long the startup took:  INFO: Server startup in 1186 ms  If the Tomcat window appears for a few seconds, and then an exception message  flies by quickly and the window closes, the most likely problem is that you already  have a web server running on your system, and that server has already laid claim  to the port Tomcat wants to use for HTTP communication. The solution to that  problem is to edit the server.xml file in c:\tomcat\conf and look for this tag:     724      BOOK 7  Web Programming   Change the port number from 8080 to some other number, such as 18080. Later,  when you display servlets in a browser window, you have to specify this number  as the HTTP port number instead of 8080.  You don’t need to shut down Tomcat after you start it unless you make a change  in one of its configuration files. If you do, you can shut down Tomcat by running  the shutdown batch file from the c:\tomcat\bin directory. Then you can run the  startup batch file to get Tomcat going again.     s t e l v r e S g n i t a e r C  Testing Tomcat  http:  localhost:8080  To find out whether you installed Tomcat correctly, you can try running the test  servlets that are automatically installed when you install Tomcat. Open a web- browser window, and type this address:   If you changed the port number by editing the server.xml file, as I discuss in the  preceding section, use the port number you specified instead of 8080.   The page shown in Figure 2-2 appears. If it doesn’t, refer to the section “Install- ing and configuring Tomcat,” earlier in this chapter, and double-check each step  to make sure you did it correctly.  FIGURE 2-2:   Testing Tomcat.  CHAPTER 2  Creating Servlets      725   Creating a Simple Servlet  Okay,  enough  of  the  configuration  stuff;  now  you  can  start  writing  some code.  The following sections go over the basics of creating a simple HelloWorld–type  servlet.  Importing the servlet packages  Most  servlets  need  access  to  at  least  three  packages:  javax.servlet,  javax. servlet.http,  and  java.io.  As  a  result,  you  usually  start  with  these  import  statements:  import java.io.*; import javax.servlet.*; import javax.servlet.http.*;  Depending on what other processing your servlet does, you may need additional  import statements.  Extending the HttpServlet class  To create a servlet, you write a class that extends the HttpServlet class. Table 2-1  lists six methods you can override in your servlet class.  TABLE 2-1	 Method  The HttpServlet Class Signature  When Called  doDelete  HTTP DELETE request  doGet  HTTP GET request  doPost  HTTP POST request  doPut  HTTP PUT request  public void doDelete Http ServletRequest request,  HttpServletResponse response throws IOException,  ServletException  public void doGet HttpServletRequest request,  HttpServletResponse response  throwsIOException,  ServletException  public void doPost HttpServletRequest request,  HttpServletResponse response  throws IOException,  ServletException  public void doPut HttpServletRequest request,  HttpServletResponse response  throws IOException,  ServletException  init    First time servlet is run  public void init   throws ServletException  destroy    Servlet is destroyed  public void destroy    726      BOOK 7  Web Programming   Most servlets  override  at least the  doGet method. This  method is  called by the  servlet engine when a user requests the servlet by typing its address in the brows- er’s address bar or by clicking a link that leads to the servlet.  Two parameters are passed to the doGet method:   » An HttpServletRequest object representing the incoming request from the  user. You use the request parameter primarily to retrieve data entered by  the user in form fields. You find out how to do that later in this chapter, in the  section “Getting Input from the User.”   » An HttpServletResponse object representing the response that is sent back  to the user. You use the response parameter to compose the output that is  sent back to the user. You find out how to do that in the next section.     s t e l v r e S g n i t a e r C  Printing to a web page  One of the main jobs of most servlets is writing HTML output that’s sent back  to  the  user’s  browser.  To  do  that,  you  first  call  the  getWriter  method  of  the  HttpServletResponse  class,  which  returns  a  PrintWriter  object  that’s  con- nected to the response object. Thus, you can use the familiar print and println  methods to write HTML text.  Here’s a doGet method for a simple HelloWorld servlet:  public void doGet HttpServletRequest request,     HttpServletResponse response          throws IOException, ServletException {     PrintWriter out = response.getWriter  ;     out.println "Hello, World!" ; }  Here the PrintWriter object returned by response.getWriter   is used to send a  simple text string back to the browser. If you run this servlet, the browser displays  the text Hello, World!  Responding with HTML  In most cases, you don’t want to send simple text back to the browser. Instead,  you want to send formatted HTML. To do that, you must first tell the response  object  that  the  output  is  in  HTML  format.  You  can  do  that  by  calling  the  set  ContentType method, passing the string "text html" as the parameter. Then you  can use the PrintWriter object to send HTML.  CHAPTER 2  Creating Servlets      727   Listing 2-1 shows a basic HelloWorld servlet that sends an HTML response.  LISTING	2-1:	  The HelloWorld Servlet  import java.io.*; import javax.servlet.*; import javax.servlet.http.*; import java.util.*; public class HelloWorld extends HttpServlet {     public void doGet HttpServletRequest request,         HttpServletResponse response              throws IOException, ServletException     {         response.setContentType "text html" ;         PrintWriter out = response.getWriter  ;         out.println " " ;         out.println " " ;         out.println " HelloWorld " ;         out.println " " ;         out.println " " ;         out.println " Hello, World! " ;         out.println " " ;         out.println " " ;     } }  Here the following HTML is sent to the browser  I added indentation to show the  HTML’s structure :             HelloWorld               Hello, World!         When run, the HelloWorld servlet produces the page shown in Figure 2-3.  728      BOOK 7  Web Programming      s t e l v r e S g n i t a e r C  FIGURE 2-3:   The HelloWorld  servlet displayed  in a browser.  Obviously, you need a solid understanding of HTML to write servlets. If HTML is  like a foreign language, you need to pick up a good HTML book, such as HTML,  XHTML, & CSS For Dummies, 7th Edition, by Ed Tittel and Jeff Noble  Wiley , before  you go much further.  For your reference, Table 2-2 summarizes all the HTML tags that I use in this book.  TABLE 2-2	  HTML tag  Just Enough HTML to Get By  Description   ,    Marks the start and end of an HTML document.   ,    Marks the start and end of the head section of an HTML document.   ,   Marks a title element. The text between the start and end tags is shown in the title   bar of the browser window.   ,    Marks the start and end of the body section of an HTML document. The content of  the document is provided between these tags.   ,     ,     ,    Formats the text between these tags as a level-1 heading.  Formats the text between these tags as a level-2 heading.  Formats the text between these tags as a level-3 heading.  <form action=  "url", method=  "method">  Marks the start of a form. The action attribute specifies the name of the page,  servlet, or JavaServer Page  JSP  the form is posted to. The method attribute can be  GET or POST; it indicates the type of HTTP request sent to the server.     Marks the end of a form.  <input type=  "type", name=  "name">  Creates an input field. Specify type="text" to create a text field or  type="submit" to create a Submit button. The name attribute provides the name  you use in the program to retrieve data entered by the user.  &nbsp;  Represents a nonbreaking space.  CHAPTER 2  Creating Servlets      729   Running a Servlet  So exactly how do you run a servlet? First, you must compile the .java file to cre- ate a .class file; then you must move the .class file into a directory from which  Tomcat can run the servlet. For testing purposes, you can move the servlet’s class  file to c:\tomcat\webapps\Examples\WEB-INF\classes and then type an address  like this one in your browser’s address bar:  <http:  localhost:8080 servlet HelloWorld  You  may  also  want  to  override  the  doPost  method,  which  is  called  if  the  user  requests your servlet from a form. In many cases, you’ll just call doGet from the  doPost method, so that both get and post requests are processed in the same way.  As you know, the doGet method is called whenever the user enters the address  of your servlet in the address bar or clicks a link that leads to your servlet. But  many — if not most — servlets are associated with HTML forms, which provide  fields in which the user can enter data. The normal way to send form data from  the browser to the server is with an HTTP POST request, not a GET request.  If you want a servlet to respond to POST requests, you can override the doPost  method instead of, or in addition to, the doGet method. Other than the method  name, doPost has the same signature as doGet. In fact, it’s not uncommon to see  servlets in which the doPost method simply calls doGet, so that both POST and GET  requests are processed identically. To do that, code the doPost method like this:  public void doPost HttpServletRequest request,     HttpServletResponse response          throws IOException, ServletException {     doGet request, response ; }  Improving the HelloWorld Servlet  The  HelloWorld  servlet,  shown  in  Listing  2-1  earlier  in  this  chapter,  isn’t  very interesting because it always sends the same text. Essentially, it’s a static  servlet  —  which  pretty  much  defeats  the  purpose  of  using  servlets  in  the  first  place. You could just as easily have provided a static HTML page.  730      BOOK 7  Web Programming   Listing 2-2 shows the code for a more dynamic HelloWorld servlet. This version  randomly displays one of six greetings. It uses the  random method of the  Math  class to pick a random number from 1 to 6 and then uses this number to decide  which greeting to display. It also overrides the doPost method as well as the doGet  method, so posts and gets are handled identically.     s t e l v r e S g n i t a e r C  LISTING	2-2:	  The HelloServlet Servlet  import java.io.*; import javax.servlet.*; import javax.servlet.http.*; import java.util.*; public class HelloServlet extends HttpServlet {     public void doGet HttpServletRequest request,         HttpServletResponse response              throws IOException, ServletException     {         response.setContentType "text html" ;         PrintWriter out = response.getWriter  ;         String msg = getGreeting  ;         out.println " " ;         out.println " " ;         out.println              " HelloWorld Servlet " ;         out.println " " ;         out.println " " ;         out.println " " ;         out.println msg ;         out.println " " ;         out.println " " ;         out.println " " ;     }     public void doPost HttpServletRequest request,         HttpServletResponse response              throws IOException, ServletException     {         doGet request, response ;     }     private String getGreeting       {         String msg = "";         int rand =  int  Math.random   *  6   + 1;   continued   CHAPTER 2  Creating Servlets      731   LISTING	2-2:	   continued           switch  rand          {             case 1:                 return "Hello, World!";             case 2:                 return "Greetings!";             case 3:                 return "Felicitations!";             case 4:                 return "Yo, Dude!";             case 5:                 return "Whasssuuuup?";             case 6:                 return "Hark!";         }         return null;     } }  Getting Input from the User  If a servlet is called by an HTTP GET or POST request that came from a form, you  can call the getParameter method of the request object to get the values entered  by the user in each form field. Here’s an example:  String name = request.getParameter "name"  Here the value entered in the form input field named name is retrieved and assigned  to the String variable name.  Working with forms  As you can see, retrieving data entered by the user in a servlet is easy. The hard  part is creating a form in which the user can enter the data. To do that, you create  the form by using a separate HTML file. Listing 2-3 shows an HTML file named  InputServlet.html that displays the form shown in Figure 2-4.  732      BOOK 7  Web Programming      s t e l v r e S g n i t a e r C  FIGURE 2-4:   A simple input  form.  LISTING	2-3:	  The InputServlet.html File             Input Servlet              <form action=" servlet InputServlet"         method="post">       Enter your name:&nbsp;                                       The  action  attribute  in  the  form  tag  of  this  form  specifies  that   servlet  InputServlet  is  called  when  the  form  is  submitted,  and  the  method  attribute  indicates that the form is submitted via a POST rather than a GET request.  The form itself consists of an input text field named name and a Submit button.  It’s nothing fancy — just enough to get some text from the user and send it to a  servlet.  CHAPTER 2  Creating Servlets      733   Using the InputServlet servlet  Listing  2-4 shows  a servlet  that can retrieve  the data from  the form  shown  in  Listing 2-3.  LISTING	2-4:	  The InputServlet Servlet  import java.io.*; import javax.servlet.*; import javax.servlet.http.*; public class InputServlet extends HttpServlet {     public void doGet HttpServletRequest request,          HttpServletResponse response              throws IOException, ServletException     {         String name = request.getParameter "Name" ;         response.setContentType "text html" ;         PrintWriter out = response.getWriter  ;         out.println " " ;         out.println " " ;         out.println " Input Servlet " ;         out.println " " ;         out.println " " ;         out.println " " ;         out.println "Hello " + name ;         out.println " " ;         out.println " " ;         out.println " " ;     }     public void doPost HttpServletRequest request,          HttpServletResponse response                 throws IOException, ServletException     {         doGet request, response ;     } }  As you can see, this servlet really isn’t much different from the first HelloWorld  servlet in Listing 2-1. The biggest difference is that it retrieves the value entered  by the user in the name field and uses it in the HTML that’s sent to the response  PrintWriter object. If the user enters Calvin Coolidge in the name input field,  for example, the following HTML is generated:  734      BOOK 7  Web Programming   Using Classes in a Servlet             HelloWorld                Hello Calvin Coolidge            s t e l v r e S g n i t a e r C  Thus the message Hello Calvin Coolidge is displayed on the page.  Although real-life servlets do a lot more than just parrot back information entered  by the user, most of them follow this surprisingly simple structure — with a few  variations,  of  course.  Real-world  servlets  validate  input  data  and  display  error  messages if the user enters incorrect data or omits important data, and most real- world  servlets  retrieve  or  update  data  in  files  or  databases.  Even  so,  the  basic  structure is pretty much the same.  When you develop servlets, you often want to access other classes that you’ve cre- ated, such as input output  I O  classes that retrieve data from files or databases,  utility or helper classes that provide common functions such as data validation,  and  perhaps  even  classes  that  represent  business  objects  such  as  customers  or  products. To do that, all you have to do is save the class files in the classes direc- tory of the servlet’s home directory — which, for the purposes of this chapter, is  c:\tomcat\webapps\ROOT\WEB-INF\classes.  To illustrate a servlet that uses several classes, Figure 2-5 shows the output from  a servlet that lists movies read from a text file. This servlet uses three classes:   » Movie: A class that represents an individual movie.  » MovieIO: A class that has a static public method named getMovies. This   method returns an ArrayList object that contains all the movies read from  the file.   » ListFiles: The main servlet class. It calls the MovieIO.getMovies class to   get an ArrayList of movies and then displays the movies on the page.  CHAPTER 2  Creating Servlets      735   FIGURE 2-5:   The ListMovies  servlet.  The code for the Movie class is shown in Listing 2-5. As you can see, this class  doesn’t have much: It defines three public fields  title, year, and price  and a  constructor that lets you create a new Movie object and initialize the three fields.  Note that this servlet doesn’t use the price field.  LISTING	2-5:	  The Movie Class  public class Movie {     public String title;     public int year;     public double price;     public Movie String title, int year,                  double price      {         this.title = title;         this.year = year;         this.price = price;     } }  Listing 2-6 shows the MovieIO class. This class uses the file I O features that are  presented in Book 8, Chapter  2 to read data from a text file. The text file uses tabs  to separate the fields and contains these lines:  It's a Wonderful Life→1946→14.95 The Great Race→1965→12.95 Young Frankenstein→1974→16.95  736      BOOK 7  Web Programming   The Return of the Pink Panther→1975→11.95 Star Wars→1977→17.95 The Princess Bride→1987→16.95 Glory→1989→14.95 Apollo 13→1995→19.95 The Game→1997→14.95 The Lord of the Rings: The Fellowship of the Ring→2001→19.95     s t e l v r e S g n i t a e r C  Here the arrows represent tab characters in the file. I’m not going to go over the  details of this class here, except to point out that  getMovies is the only public  method  in  the  class,  and  it’s  static,  so  you  don’t  have  to  create  an  instance  of  the MovieIO class to use it. For details on how this class works, turn to Book 8,  Chapter  2.  LISTING	2-6:	  The MovieIO Class  import java.io.*; import java.util.*; public class MovieIO {     public static ArrayList  getMovies       {         ArrayList  movies =             new ArrayList   ;         BufferedReader in =             getReader "c:\\data\\movies.txt" ;         Movie movie = readMovie in ;         while  movie != null          {             movies.add movie ;             movie = readMovie in ;         }         return movies;     }     private static BufferedReader getReader          String name      {         BufferedReader in = null;         try         {             File file = new File name ;             in = new BufferedReader                  new FileReader file   ;         }   continued   CHAPTER 2  Creating Servlets      737   LISTING	2-6:	   continued           catch  FileNotFoundException e          {             System.out.println                  "The file doesn't exist." ;             System.exit 0 ;         }         return in;     }     private static Movie readMovie BufferedReader in      {         String title;         int year;         double price;         String line = "";         String[] data;         try         {             line = in.readLine  ;         }         catch  IOException e          {             System.out.println "I O Error" ;             System.exit 0 ;         }         if  line == null              return null;         else         {             data = line.split "\t" ;             title = data[0];             year = Integer.parseInt data[1] ;             price = Double.parseDouble data[2] ;             return new Movie title, year, price ;         }     } }  738      BOOK 7  Web Programming   Listing 2-7 shows the code for the ListMovie servlet class.  LISTING	2-7:	  The ListMovie Servlet Class  import java.io.*; import javax.servlet.*; import javax.servlet.http.*; import java.util.*; public class ListMovies extends HttpServlet {    public void doGet HttpServletRequest request,        HttpServletResponse response            throws IOException, ServletException    {       response.setContentType "text html" ;       PrintWriter out = response.getWriter  ;       String msg = getMovieList  ;       out.println " " ;       out.println " " ;       out.println            " List Movies Servlet " ;       out.println " " ;       out.println " " ;       out.println " Some of My Favorites " ;       out.println " " ;       out.println msg ;       out.println " " ;       out.println " " ;       out.println " " ;    }    public void doPost HttpServletRequest request,        HttpServletResponse response            throws IOException, ServletException    {       doGet request, response ;    }    private String getMovieList       {       String msg = "";       ArrayList  movies = MovieIO.getMovies  ;       for  Movie m : movies      s t e l v r e S g n i t a e r C  →8  →28  →35   continued   CHAPTER 2  Creating Servlets      739   LISTING	2-7:	   continued         {           msg += m.year + ": ";           msg += m.title + " ";       }       return msg;    } }  The following paragraphs describe what its methods do: →8        The doGet method calls the getMovieList method to get a string that  contains a list of all the movies, separated by break     tags. Then it  uses a series of out.println statements to write HTML that displays  this list.  →28      The doPost method simply calls the doGet method. That way, the servlet   works whether it is invoked by a GET or a POST request.  →35      The getMovieList method calls the MovieIO.getMovies method to get   an ArrayList that contains all the movies read from the file. Then it  uses an enhanced for loop to retrieve each Movie object. Each movie’s  year and title is added to the msg string, separated by   tags.  740      BOOK 7  Web Programming   IN THIS CHAPTER  » Seeing how servlets work   » Dealing with page directives   » Trying out expressions   » Putting scriptlets to work   » Devising declarations   » Comprehending classes  Chapter 3 Using JavaServer Pages  In Book 7, Chapter 2, you discover how to create servlets that write HTML data   directly to a page by using the PrintWriter object accessed through response. out. Although this technique works, it has one major drawback: You have to  compose the HTML manually as a bunch of string literals. If the HTML has an  error, you don’t know about it until you run the servlet to see how it looks. Also,  handcrafting HTML in out.println statements certainly isn’t the most efficient  way to create attractive web pages.  That’s where JavaServer Pages  a technology usually called JSP for short  comes  in. A JavaServer Page is an HTML file that has Java servlet code embedded in it in  special tags. When you run a JSP, all the HTML is automatically sent as part of  the response, along with any HTML that’s created by the Java code you embed in  the JSP file. As a result, JSP spares you the chore of writing all those out.println  statements.  In  this  chapter,  you  find  out  how  to  create  basic  JavaServer  Pages.  At   www.dummies.com extras javaaio, I show you how to incorporate special Java  classes called JavaBeans into your JSP pages.  Note:  To  work  with  JavaServer  Pages,  you  must  first  set  up  a  working  Tomcat  environment. For information on how to do that, please refer to Book 7, Chapter 2.  CHAPTER 3  Using JavaServer Pages      741   Understanding JavaServer Pages  A JSP is an HTML document that’s saved in a file with the extension .jsp instead  of .htm or .html. Unlike servlet-class files, a JSP file can be stored in any directory  that’s available to the web server.  The first time a user requests a JSP file, the file is run through a translator program  that converts the file to a Java servlet program and compiles it. All the HTML from  the original JSP file is converted to out.print statements that send the HTML to  the response, and the Java statements from the JSP file are incorporated into the  servlet program. Then the servlet program is executed and the results sent back  to the browser.  Note that this translation occurs only once: the first time someone requests the  JSP. After that, the servlet itself is run directly whenever a user requests the JSP.  Enough of the concept — now on to the code. When you create a JSP, you mix  special JSP elements into your normal HTML. You can include four types of JSP  elements:   » Directives: A directive is an option setting that affects how the servlet is   constructed from a JSP page. Directives let you do things such as specify what  import statements the servlet requires, specify whether the servlet is  thread-safe, and include other source files in the servlet. For example:      » Expressions: An expression can be any Java expression. The expression is  evaluated and converted to a string  if necessary , and the result is inserted  into the document. Expressions assume the following form:      » Scriptlets: A scriptlet is a sequence of Java statements inserted directly into  the servlet code generated for the JSP. You can do just about anything you  want in a scriptlet, including using if statements, looping, and calling other  methods. You can even use out.println to add output to the page; the  output is inserted into the page at the location where the scriptlet appears.  Scriptlets have the following form:     742      BOOK 7  Web Programming    » Declarations: A declaration is Java code that is placed in the servlet class   outside any methods. You use declarations to create class variables or define  methods that can be called by scriptlets or expressions. Declarations take   this form:     The  remaining  sections  of  this  chapter  show  you  how  to  create  JSP  pages  that  incorporate these elements.  s e g a P   r e v r e S a v a J   g n i s U  Using Page Directives  A page directive is a JSP element that sets options that determine how the JSP is  converted to a servlet. The basic format of a page directive is this:     The  attribute  can  be  any  of  the  attributes  listed  in  Table  3-1.   A  few  attributes  besides these are available, but they’re rarely used.   TABLE 3-1	  Name  Commonly Used Page Directive Attributes  Description  import="package.class"  Adds an import statement to the servlet so that you can use classes in  other JSP elements without having to qualify them fully.  content-Type="MIME-type"  Lets you specify the type of document created by the servlet. The default  is text html. You rarely need to change this setting.  isThreadSafe="boolean"  If true, the servlet is assumed to be thread-safe. If false, implements  SingleThreadModel is added to the servlet class declaration so that  the thread runs in the single-thread model. The default is true.  session="boolean"  If true, the servlet uses session management. The default is true.  buffer="size"  errorPage="URL"  Specifies the size of the buffer used by the out variable. The default  depends on the server but is never smaller than 8KB.  Specifies the name of an error page that is displayed if this servlet throws  an uncaught exception.  isErrorPage="boolean"  If true, this page is an error page for some other JSP page. The default   is false.  CHAPTER 3  Using JavaServer Pages      743   Using Expressions  The page directive you use most is import, as it lets you import the packages for  API classes so that you can use them in expression, scriptlet, and declaration ele- ments. Here’s a page directive that imports the java.util package:     You can place page directives anywhere you want in a JSP document, but I suggest  that you place them at or near the top so they will be easy to find.  A  JSP  expression  is  any  Java  expression  that  evaluates  to  a  string.  Actually,  the  expression doesn’t have to evaluate directly. Here’s how you can use the java. util.Date class to display the current date and time:     This  expression  creates  a  new  instance  of  the  java.util.Date    class,  which  represents the current date and time. The toString   method is implicitly called  to convert this object to a string.  If  you  include  a  page  import  directive,  you  can  omit  the  qualification  on  this  expression, as in this example:       To do more interesting things with expressions, you can use predefined variables,  also known as implicit objects — Java variables that are available to expressions,  scriptlets, or declarations throughout a JSP page. Table 3-2 lists the JSP implicit  objects you use most often.  The  implicit  objects  work  the  same  way  that  their  corresponding  objects  do  in  servlets. The response object, for example, is just the response parameter that’s  passed to the doGet or doPost method.  The implicit object you use most in expressions is request. In particular, you use  its getParameter method to get values entered by the user in forms. Here’s an  expression that displays the value entered in an input field titled Name:     744      BOOK 7  Web Programming   Implicit Objects  Description  TABLE 3-2	  Name  out  request  Used to write data to the response; equivalent to response.getWriter   in a servlet.  Used as the request object; equivalent to the request parameter in the doGet or doPost  method of a servlet.  response  Used as the response object; equivalent to the response parameter in the doGet or doPost  method of a servlet.  session  Used to manage sessions; equivalent to request.getSession   in a servlet.  The value of the Name field is inserted wherever this expression occurs in the JSP  file. Here’s a simple JSP file named InputJSP.jsp that displays an input text box  and a button. When the user clicks the button, whatever text he or she entered in  the input field is displayed below the button, as follows:  s e g a P   r e v r e S a v a J   g n i s U             Input JSP                        Enter some text:&nbsp;                                      You entered:&nbsp;               The  HTML  for  this  JSP  defines  a  form  that  contains  an  input  text  field  named  Text and a Submit button. When the user clicks the Submit button, an HTTP POST  request is sent to the server to request InputJSP.jsp. Any text entered by the user  is sent along with the request. When the servlet is run, the text is retrieved by  the expression request.getParameter "Text"  and displayed below the button.  Figure 3-1 shows this servlet in action.  Note: Expressions can also call methods that you add to the JSP with declaration  elements. You see examples of how to do that in the section “Using Declarations,”  later in this chapter.  CHAPTER 3  Using JavaServer Pages      745   FIGURE 3-1:   Input-JSP.jsp  in action.  Using Scriptlets  As mentioned earlier in the chapter, a scriptlet is a statement or group of state- ments that’s inserted directly into the servlet at the point where the out.print  statements that create the surrounding HTML are generated. In short, scriptlets  let you add your own code to the code that renders the page.  Scriptlets follow this basic form:     Here’s a JSP named  DateJSP.jsp that uses the  DateFormat class to format the  date and display it on the page:                     Date JSP                        Today is       <%           DateFormat df = DateFormat.getDateInstance                DateFormat.FULL ;           Date today = new Date  ;           String msg = df.format today ;  746      BOOK 7  Web Programming             out.println msg ;       %>            Have a nice day!         This JSP begins with a pair of page  import directives to import the java.text  and java.util packages. Then the following Java statements are inserted right  between the lines that generate the text Today is and Have a nice day!, like so:  DateFormat df     = DateFormat.getDateInstance DateFormat.FULL ; Date today = new Date  ; String msg = df.format today ; out.println msg ;  These  lines  create  a  string  variable  named  msg  and  then  use  out.println  to  write the string to the response output. As a result, the formatted date is inserted  between   Today  is     and   Have  a  nice  day! .  Figure  3-2  shows a page generated by this JSP.  s e g a P   r e v r e S a v a J   g n i s U  FIGURE 3-2:   DateJSP.jsp   in action.  If you want, you can get pretty tricky with scriptlets. No rule says that you have to  complete block statements such as if or while statements within a single script- let.  If  you  leave  a  block  open  at  the  end  of  a  scriptlet,  any  HTML  that  follows  is  generated  by  out.print  statements  that  are  included  in  the  block.  The  only  restriction is that you must eventually end the block with another scriptlet.  CHAPTER 3  Using JavaServer Pages      747   SCRIPTLETS  Scriptlets don’t have to add anything to the HTML output. In many cases, they perform  functions such as writing information to a file. Suppose that you have a JSP that gets  data from a form that includes input text fields named FirstName and LastName.  Suppose also that you have a class named CustFile with a static method named  writeCustomer that accepts a first and last name as parameters and writes them to  a file. Here’s a scriptlet that gets the first and last names and calls the writeCustomer  method to write the name to the customer file:  <% String firstName = request.getParameter "FirstName" ;    String lastName = request.getParameter "LastName" ;    CustFile.writeCustomer firstName, lastName ; %>  Here’s a scriptlet named LoopyJSP.jsp that repeats a line 12 times on the page by  including the line in the block of a for loop:             Can't you see I'm trying to work here?                <% for  int i = 0; i < 12; i++         {     %>     All work and no play makes Jack a dull boy.      <%        }     %>        If you run this scriptlet, the page appears as shown in Figure 3-3.  Obviously, this sort of programming structure is prone to error. I suggest that you  avoid it whenever you can.  748      BOOK 7  Web Programming   FIGURE 3-3:   The LoopyJSP.jsp  scriptlet doing   its thing.  Using Declarations  s e g a P   r e v r e S a v a J   g n i s U  A declaration is code that is included in the servlet but outside any method. Decla- rations are used to create class variables or methods that can be used in expres- sions, scriptlets, or other declarations. Declarations follow this format:     You can place declarations anywhere you want in a JSP.  Here’s a servlet that declares a static class field named count that’s incremented  each time the page is displayed:                     Counter JSP                        This JSP has been displayed         time.        <%! private static int count = 1; %>  CHAPTER 3  Using JavaServer Pages      749   In this servlet, the count variable is declared by the declaration element at the end  of the JSP document, as follows:  <%! private static int count = 1; %>  Then  the  expression  in  the  body  of  the  document  displays  and  increments  the  count variable, like this:     When run, the JSP displays the number of times the page has been displayed since  the server started.  Here’s  another  example,  this  time  declaring  a  method  that’s  called  in  an  expression:                     Date JSP                        Today is         Have a nice day!        <%! private String getDate   {     DateFormat df =         DateFormat.getDateInstance DateFormat.FULL ;     Date today = new Date  ;     return df.format today ; } %>  The declaration at the end of this document declares a method that returns the  current date as a string. Then the expression   is used to insert  the date into the document.  750      BOOK 7  Web Programming   Using Classes  Most JSP applications are complicated enough that they need additional classes  to keep their code manageable. Maybe you want to create classes that handle the  application’s file or database I O, and you want to create classes to represent busi- ness objects such as Products and Customers.  Setting up Tomcat to work with classes can be a little tricky, but it’s easy if you  follow these simple guidelines:   » Contain all classes in packages. Choose a nice package name for your  application and then add a package statement to the beginning of each  class file.   » Store the class files  not necessarily the source files  in the WEB-INF\  classes\package\directory below the directory in which the JSP pages  are stored. If the package name is com.lowewriter.movie, and you’re  storing your JSP pages in c:\tomcat\webapps\ROOT, save the class files in the  following directory:  s e g a P   r e v r e S a v a J   g n i s U  C:\tomcat\webapps\ROOT\WEB-INF\classes\com\lowewriter\movie   » In any JSP that uses one of your classes, include a page directive that   imports the package. Here’s an example:      » Add the directory in which you saved the packages to your ClassPath   environment variable. You want to add the directory that contains the  packages, not the directory that contains the classes themselves, because the  Java compiler uses the package name to find the package directory. So if you  put your classes in the webapps\ROOT\WIB-INF\classes directory, you need  to add c:\tomcat\webapps\ROOT\WEB-INF\classes to your ClassPath.  To  illustrate  how  a  JSP  can  use  classes,  Figure  3-4  shows  a  JSP  that  lists  the   movies in  the  movies.txt file. The JSP file that displays this  page is  shown  in  Listing 3-1. The JSP file itself is stored in c:\tomcat\webapps\ROOT.  CHAPTER 3  Using JavaServer Pages      751   FIGURE 3-4:   The ListMovies  JSP in action.  LISTING	3-1:	  ListMovies.jsp  <!doctype html public "-  W3C  DTD HTML 4.0 Transitional  EN">                 List Movies: The Servlet                 Some of My Favorites                             <%! private String getMovieList    {     String msg = "";     ArrayList  movies = MovieIO.getMovies  ;      for  Movie m : movies       {         msg += m.year + ": ";         msg += m.title + " ";     }     return msg;  } %>  →3  →12  →18  →21 →22  →28  752      BOOK 7  Web Programming   Following is an explanation of the key lines in this JSP:   →3    →12    →18   →21    →22    →28      The JSP includes two page directives that import the com.lowewriter.  movie and java.util packages.     An expression is used to call the getMovieList method, which returns   the list of movies to be displayed as a string.    The getMovieList method is defined in a declaration.     The getMovies method of the MovieIO class is called to retrieve an   ArrayList that contains all the movies from the movies.txt file.     The Movie objects are retrieved from the ArrayList, and the year and   title are added to the msg string.    The finished msg string is returned.  Listing 3-2 shows the Movie class. There’s nothing special to note here other than  the package statement that places the Movie class in the com.lowewriter.movie  package. The class file that’s compiled from this .java file is saved in c:\tomcat\ webaps\ROOT\WEB-INF\classes\com\lowewriter\movie.  s e g a P   r e v r e S a v a J   g n i s U  LISTING	3-2:	 Movie.java  package com.lowewriter.movie; public class Movie {     public String title;     public int year;     public double price;     public Movie String title, int year,                  double price      {         this.title = title;         this.year = year;         this.price = price;     } }  Finally, the  MovieIO class is shown in Listing 3-3. This class reads the movies  from a text file.  For a detailed explanation of how this class works, jump for- ward to Book 8, Chapter 2.  Notice that this class, like the Movie class, includes a   package  statement  that  dumps  the  MovieIO  class  into  the  movie  package.  The  class  file  compiled  from  this  .java  file  is  saved  in  c:\tomcat\webaps\ROOT\ WEB-INF\classes\com\lowewriter\movie.  CHAPTER 3  Using JavaServer Pages      753   LISTING	3-3:	 MovieIO.java  package com.lowewriter.movie; import java.io.*; import java.util.*; public class MovieIO {     public static ArrayList  getMovies       {         ArrayList  movies =             new ArrayList   ;         BufferedReader in =             getReader "c:\\data\\movies.txt" ;         Movie movie = readMovie in ;         while  movie != null          {             movies.add movie ;             movie = readMovie in ;         }         return movies;     }     private static BufferedReader getReader          String name      {         BufferedReader in = null;         try         {             File file = new File name ;             in = new BufferedReader                  new FileReader file   ;         }         catch  FileNotFoundException e          {             System.out.println                  "The file doesn't exist." ;             System.exit 0 ;         }         return in;     }     private static Movie readMovie BufferedReader in      {         String title;         int year;         double price;         String line = "";  754      BOOK 7  Web Programming           String[] data;         try         {             line = in.readLine  ;         }         catch  IOException e          {             System.out.println "I O Error" ;             System.exit 0 ;         }         if  line == null              return null;         else         {             data = line.split "\t" ;             title = data[0];             year = Integer.parseInt data[1] ;             price = Double.parseDouble data[2] ;             return new Movie title, year, price ;         }     } }  s e g a P   r e v r e S a v a J   g n i s U  CHAPTER 3  Using JavaServer Pages      755    IN THIS CHAPTER  » Defining JavaBeans   » Creating your own JavaBean classes   » Using JavaBeans in JSP pages   » Creating a simple shopping cart with   session scope  Chapter 4 Using JavaBeans  A JavaBean is a special type of Java class that you can use in several interest-  ing ways to simplify program development. Some beans are designed to  be visual components that you can use in a graphic user interface  GUI   editor to build user interfaces quickly. Other beans, known as Enterprise JavaBeans   EJB , are designed to run on special EJB servers and can run the data access and  business logic for large web applications.  In  this  chapter,  I  look  at  a  more  modest  type  of  JavaBean  that’s  designed  to  simplify the task of building JavaServer Pages  or JSP, which I cover in Book 7,  Chapter 3 . In a nutshell, you can use the simple JavaBeans to build JavaServer  Pages without writing any Java code in the JSP itself. JavaBeans let you access Java  classes by using special HTML-like tags in the JSP page.  To use JavaBeans, you must have Tomcat enabled. For more information about  installing and configuring Tomcat, please refer to Book 7, Chapter 2.  Getting to Know JavaBeans  Simply put, a JavaBean is any Java class that conforms to the following rules:   » It must have an empty constructor — that is, a constructor that accepts   no parameters. If the class doesn’t have any constructors at all, it qualifies   CHAPTER 4  Using JavaBeans      757   because the default constructor has no parameters. But if the class has at  least one constructor that accepts one or more parameters, it must also have  a constructor that has no parameters to qualify as a JavaBean.   » It must have no public instance variables. All the instance variables   defined by the class must be either private or protected.   » It must provide methods named getProperty and setProperty to get   and set the value of any properties the class provides, except for boolean  properties that use isProperty to get the property value. The term property  isn’t an official Java term. In a nutshell  or should that be in a beanpod? , a  property is any value of an object that can be retrieved by a get method  or  an is method, if the property is boolean  or set with a set method. If a class  has a property named lastName, for example, it should use a method named  getLastName to get the last name and setLastName to set the last name. Or,  if the class has a boolean property named taxable, the method to set it is  called setTaxable, and the method to retrieve it is isTaxable.  Note that a class doesn’t have to have any properties to be a JavaBean, but if it  does, the properties have to be accessed according to this naming pattern.  Also, not all properties must have both a get and a set accessor. A read-only  property can have just a get accessor, and a write-only property can have just a  set accessor.  The property name is capitalized in the methods that access it, but the property  name itself isn’t. Thus setAddress sets a property named address, not  Address.  That’s all there is to it. More advanced beans can also have other characteristics  that give them a visual interface so that they can be used drag-and-drop style in  an integrated development environment  IDE . Also, some beans implement an  interface that allows their state to be written to an output stream so that they can  be re-created later. But those features are optional; any class that meets the three  criteria stated here is a bean and can be used as a bean in JSP pages.  You’ve already seen plenty of classes that have methods with names like getCount  and setStatus. These names are part of a design pattern called the Accessor pat- tern, which I cover in Book 3, Chapter 2. Thus you’ve seen many examples of beans  throughout  this  book,  and  you’ve  probably  written  many  bean  classes  yourself  already.  Any class that conforms to this pattern is a bean. There’s no JavaBean class that  you have to extend; neither is there a Bean interface that you have to implement  to create a bean. All a class has to do to be a bean is stick to the pattern.  758      BOOK 7  Web Programming   Looking Over a Sample Bean  Listing 4-1 shows a sample JavaBean class named Triangle that calculates the  Pythagorean  Theorem,  which  calculates  the  long  side  of  a  right  triangle  if  you  know the length of the two short sides. This class defines three properties: sideA  and  sideB  represent  the  two  short  sides  of  the  triangle,  and  sideC  represents  the long side. The normal way to use this bean is to first use the setSideA and   setSideB  methods  to  set  the  sideA  and  sideB  properties  to  the  lengths  of  the  short sides and then use the getSideC method to get the length of the long side.  In case you can’t remember way back to high school, the long side is equal to the  square root of the first short side squared plus the second short side squared.  LISTING 4-1:   The Triangle Bean  →1  →5  →8  →14  →19  s n a e B a v a J   g n i s U  package com.lowewriter.calculators;  public class Triangle {     private double sideA;      private double sideB;     public Triangle        {         this.sideA = 0.0;         this.sideB = 0.0;     }     public String getSideA        {         return Double.toString this.sideA ;     }     public void setSideA String value       {         try         {             this.sideA = Double.parseDouble value ;         }         catch  Exception e          {             this.sideA = 0.0;         }     }     public String getSideB        {         return Double.toString this.sideB ;     }  →31   continued   CHAPTER 4  Using JavaBeans      759   LISTING 4-1:    continued   →36  →48      public void setSideB String value       {         try         {             this.sideB = Double.parseDouble value ;         }         catch  Exception e          {             this.sideB = 0.0;         }     }     public String getSideC        {         if  sideA == 0.0  sideB == 0.0              return "Please enter both sides.";         else         {             Double sideC;             sideC = Math.sqrt                   sideA * sideA  +  sideB * sideB  ;             return Double.toString sideC ;         }     } }  The following paragraphs point out the highlights of this bean class:   →1    →5    →8      As with most servlet classes, this bean is part of a package. In this case,  the package is named com.lowewriter.calculators.  I’m assuming  that if you need a bean to calculate the Pythagorean theorem, you  probably want other beans to calculate derivatives, prime numbers,  Demlo numbers, and the like. You can put those beans in this  package, too.      This class uses a pair of instance variables to keep track of the two short   sides. As per the rules for JavaBeans, these instance variables are  declared as private.     A constructor with no parameters is declared.  Strictly speaking, this   constructor doesn’t have to be explicitly coded here, because the default  constructor does the trick, and the two instance variables are initialized  to their default values of 0 automatically.   760      BOOK 7  Web Programming   string.  string.   →14    →19    →31    →36    →48      The getSideA method returns the value of the sideA property as a      The setSideA method lets you set the value of the sideA property with   a string. This method uses a try catch statement to catch the excep- tions that are thrown if the string can’t be parsed to a double. If the  string is invalid, the sideA property is set to 0.     The getSideB method returns the value of the sideB property as a      The setSideB method sets the value of the sideB property from a   string. Again, a try catch statement catches any exceptions and sets  the property to 0 if the string can’t be parsed to a double.     The getSideC method calculates the length of the long side and then  returns the result as a string. If either of the values is 0, however, the  method assumes that the user hasn’t entered any data, so it returns an  error message instead.  That’s a reasonable assumption, because none  of the sides of a triangle can be zero.  Notice that there is no setSideC  method. As a result, sideC is a read-only property.  Using Beans with JSP Pages  s n a e B a v a J   g n i s U  To work with a bean in a JSP page, you add special tags to the page to create the  bean, set its properties, and retrieve its properties. Table 4-1 lists these tags, and  the following sections describe the details of using each one.  Creating bean instances  To include a bean in a JSP page, you add a special jsp:useBean tag to the page. In  its simplest form, this tag looks like this:     The  id  attribute  provides  the  name  that  you  use  elsewhere  in  the  JSP  to  refer   to  the  bean,  and  the  class  attribute  provides  the  name  of  the  class,  qualified   with the package name. Here’s a jsp:useBean tag to use the Triangle bean:  <jsp:useBean id="triangle"    class="com.lowewriter.calculators.Triangle"  >  CHAPTER 4  Using JavaBeans      761   TABLE 4-1	  Tag  JSP Tags for Working with Beans  Description  <jsp:useBean id="name"  class="package.class"  >  Establishes a reference to the bean and creates an instance  if necessary. The name specified in the id attribute is used  by the other tags to refer to the bean.  <jsp:getProperty name="name"  property="property"  >  Retrieves the specified property from the bean identified  by the name attribute.  <jsp:setProperty name="name"  property="property" value="value"  >  Sets the specified property to the value specified in the  value attribute.  <jsp:setProperty name="name"  property="property"  param="parameter"  >  <jsp:setProperty name="name"  property="* "  >  Sets the specified property to the value of the parameter  specified in the param attribute. The parameter is usually  the name of a form field.  Sets all the properties defined by the bean to  corresponding parameter values, provided that a  parameter with the correct name exists.  The jsp:useBean tag creates an instance of the bean by calling the empty con- structor if an instance doesn’t already exist. If the bean does already exist, the  existing instance is used instead.  Here are a few additional things you should know about the jsp:useBean tag:   » The jsp:useBean tag can appear anywhere in the JSP document, but it must   appear before any other tag that refers to the bean.   » This tag and all bean tags are case-sensitive, so be sure to code them exactly   as shown.   won’t work.   » If Tomcat complains that it can’t find your bean when you run the JSP,   double-check the package and class name — they’re case-sensitive, too — and  make sure that the bean is stored in a directory under WEB-INF\classes  that’s named the same as the package. You might store the Triangle bean’s  class file in WEB-INF\classes\calculators, for example.  For more info on  Tomcat, flip to Book 7, Chapter 2.    » The jsp:useBean element can have a body containing jsp:setProperty  tags that initialize property values. Then the element is formed more like  normal HTML, with proper start and end tags, as in this example:             762      BOOK 7  Web Programming   Don’t worry about the details of the jsp:setProperty tags just yet. Instead,  just make a note that they’re executed only if a new instance of the bean is  actually created by the jsp:useBean tag. If an instance of the bean already  exists, the jsp:setProperty tags are not executed.   » The jspuseBean tag also has a scope attribute, which I explain in the section   “Scoping Your Beans,” later in this chapter.  Getting property values  To get the value of a bean’s property, you use the jsp:getProperty tag. The form  of this tag is straightforward:     Here’s a tag that gets the sideC property from the Triangle bean created in the  preceding section:     The name attribute must agree with the value you specify in the id attribute of  the jsp:useBean tag that created the bean. Also, the property attribute is used to  determine the name of the getter method — in this case, getSideC.  Always  begin  the  property  name  with  a  lowercase  letter.  If  you  specify  property="SideC",  you  get  an  error  message  from  the  server  when  you  run   the page.  In most cases, you use jsp:getProperty to insert the value of a property into a  page, but you can also use it to specify the value of an attribute for some other tag  in the JSP document, as in this example:  s n a e B a v a J   g n i s U  <input type="text" name="sideA"        value="<jsp:getProperty name="triangle"                    property="sideA"  >" >  Here the value of the sideA property is retrieved and used for the value attribute  of an input field named  sideA. As a result, when this input field is sent to the  browser, its initial value is the value from the Triangle bean.  Be extra careful to match up the quotation marks and the open and close brackets  for the tags. In this example, the entire jsp:getProperty tag is enclosed within  the quotation marks that indicate the value of the input field’s value attribute.  The right bracket that appears at the very end closes the input element itself.  CHAPTER 4  Using JavaBeans      763   Setting property values  To set a property value, you can use one of several variations of the jsp:setProperty  tag. If you want to set the property to a literal string, you write the tag like this:  <jsp:setProperty name="triangle"                  property="sideA"                  value="4.0"  >  Here the name attribute must match the id attribute from the jsp:useBean tag  that created the bean; the property attribute is used to determine the name of  the setter method  in this case, setSideA ; and the value attribute provides the  value to be set.  I put this tag on three lines only because it’s too long to fit within the margins of  this page on one line. In actual practice, most JSP developers string these tags out  on a single line unless they get really long, which doesn’t happen often.  Although this form of the jsp:setProperty tag is useful, the param form is more  useful. It lets you set the property to the value entered by the user in a form field  or passed to the JSP by way of a query string. If your JSP contains a form that has  an input field named FirstSide, you can assign that field’s value to the sideA  property like this:    <jsp:setProperty name="triangle"                  property="sideA"                  param="FirstSide"  >  Here, if the user enters a value in the FirstSide field, that value is assigned to the  bean’s sideA property.  In the preceding example, I deliberately use a name other than sideA for the input  field so that you won’t be confused by the fact that the property and param attri- butes specify the same value. In actual practice, you usually give the input field  the same name as the property it’s associated with, like this:    <jsp:setProperty name="triangle"                  property="sideA"                  param="sideA"  >  If your input fields have names that are identical to the property names, you can  assign all of them to their corresponding properties with one tag, like this:     764      BOOK 7  Web Programming   Here the asterisk  *  in the property attribute indicates that all properties that  have  names  identical  to  form  fields   or  query-string  parameters   are  assigned  automatically. For forms that have a lot of fields, this form of the jsp:setProperty  tag can save you a lot of coding.  Viewing a JSP page that uses a bean  So that you can see how these tags work together, Listing 4-2 shows a complete  JSP page using the bean that was presented in Listing 4-2. This page displays two  text input fields and a button. When the user enters the lengths of a triangle’s two  short sides in the fields and clicks the button, the page displays the sideC prop- erty of the bean to show the length of the third side. Figure 4-1 shows how this  page appears when the code is run.  FIGURE 4-1:   The Triangle.jsp  page displayed in  a browser.  LISTING 4-2:   The Triangle.jsp Page  s n a e B a v a J   g n i s U    <jsp:useBean id="triangle"       class="com.lowewriter.calculators.Triangle"  >             Right Triangle Calculator                 The Right Triangle Calculator               Side A:&nbsp;  →2  →4  →10   continued   CHAPTER 4  Using JavaBeans      765   LISTING 4-2:    continued         <input type="text" name="sideA"            value="<jsp:getProperty                       name="triangle"                       property="sideA"  >" >                Side B:&nbsp;       <input type="text" name="sideB"            value="<jsp:getProperty                       name="triangle"                       property="sideB"  >" >                Side C:&nbsp;       <jsp:getProperty name="triangle"             property="sideC"  >                                →12  →18  →24  →27  The following paragraphs explain the key lines in this JSP:   →2    →4    →10    →12    →18    →24    →27      The jsp:useBean tag creates an instance of the calculators.  Triangle bean and names it triangle.     The jsp:setProperty tag sets the sideA and sideB properties to the   corresponding input fields named sideA and sideB.     The form tag creates a form that posts back to the same JSP file using   the HTTP POST method.     This line creates the first of two input text fields. This one is named   sideA, and its initial value is set to the value of the bean’s sideA  property.     The second input text field is named sideB. Its initial value is set to the   value of the bean’s sideB property.     This line is where the sideC property is retrieved, thus calculating the   length of side C of the triangle based on the length of sides A and B. The  result is simply inserted into the document.     The Submit button submits the form so that the Triangle bean can do    its thing.  766      BOOK 7  Web Programming   Scoping Your Beans  The scope of a JavaBean indicates how long the bean is kept alive. You specify the  scope by using the scope attribute of the jsp:useBean tag. The scope attribute  can have any of the four values listed in Table 4-2.  Scope Settings Explanation  TABLE 4-2	  Scope  page  request  session  This setting associates the bean with the current page. Thus, every time the user requests  the page, a new bean is created. When the page is sent back to the browser, the bean is  destroyed. Thus each round trip to the server creates a new instance of the bean.  This setting is similar to page, but the bean is available to other pages that are processed by  the same request. This scope is useful for applications that use several servlets or JSPs for a  single request.  This setting associates the bean with a user’s session. The first time the user requests a  page from the application, a bean is created and associated with the user. Then the same  bean is used for subsequent requests by the same user.  application  This setting means that a single copy of the bean is used by all users of the application.  The default scope is page, which means that the bean is created and destroyed  each time the user requests a new page. The session scope, however, can be very  useful for web applications that need to keep track of information about a user  from one page to the next. The best-known example is a shopping cart, in which a  user can select items that he or she wants to purchase. The contents of the shop- ping cart can be kept in a session bean.  s n a e B a v a J   g n i s U  A shopping cart application  Figure 4-2 shows a simple shopping cart application in which the user has the  option to purchase three of my recent books by clicking one of the three buttons.  When the user clicks a button, an item is added to the shopping cart. If the user  has already added the book to the cart, the quantity is increased by 1. In the figure,  the user has clicked the button for Electronics All-in-One For Dummies once and the  button for Networking All-in-One For Dummies twice.  CHAPTER 4  Using JavaBeans      767   FIGURE 4-2:   A super-simple  shopping cart  application.  The following paragraphs describe the key techniques that make this shopping  cart work:   » The shopping cart itself is a JavaBean that has just two public methods:   setBook, which adds a book to the shopping cart, and getList, which returns  a string that shows the shopping cart items nicely formatted in an HTML table.  » The shopping cart class contains an inner class that represents a Book object.  To keep the application simple, the Book class has the three titles hard-coded  into it. In a real shopping cart program, you use a file or database instead of  hard-coding these values.   » The list of products that appears at the top of the page is actually three separate  forms, one for each product. Each of these forms specifies a parameter passed  via a query string to the JSP on the server. The name of this parameter is book,  and its value is the code of the book the user ordered. This parameter is bound  to the book property of the shopping cart bean, so when the user clicks one of  the buttons, the setBook method is called with the value passed via the book  parameter. That’s how the shopping cart knows which book the user ordered.  » Below the list of books, the JSP uses a jsp:getProperty tag to get the list   property, which displays the shopping cart.  The shopping cart page  Listing 4-3 shows the JSP for the shopping cart page.  768      BOOK 7  Web Programming   LISTING 4-3:  BuyMyBook.jsp    <jsp:useBean id="cart"   class="com.lowewriter.books.BookCart" scope="session" >             Buy My Books!                 Which of my books do you want to buy?      <form action="BuyMyBook.jsp?book=elecaio"            method="post">        &nbsp;&nbsp;       Electronics All-in-One For Dummies             <form action="BuyMyBook.jsp?book=netaio"            method="post">        &nbsp;&nbsp;       Networking All-in-One Desk Reference         For Dummies                    <form action="BuyMyBook.jsp?book=wordaio"            method="post">        &nbsp;&nbsp;       Java All-in-One Desk Reference For Dummies                      Your cart contains:                →2  →4  →10  →15  →21  →28  s n a e B a v a J   g n i s U  The following paragraphs describe the JSP’s most important lines:   →2    →4      The jsp:useBean tag loads the com.lowewriter.books.BookCart   JavaBean, specifying that it has session scope. Thus, the bean isn’t  deleted after each page is requested. Instead, the user works with the  same bean instance for his or her entire session.     The parameter properties are set. The first time the user displays the   BuyMyBook.jsp page, there are no parameters, so this method doesn’t  do anything. But when the user clicks one of the three form buttons, a   CHAPTER 4  Using JavaBeans      769   book parameter is added to the end of the URL that’s posted to the  server, so the cart’s setBook method is called. This causes one copy of  the selected book to be added to the cart.     This line is the form for the first book. Each book has its own form, with    a Submit button labeled Buy and a book title. The action attribute  specifies that when the Submit button is clicked, the form is posted to  BuyMyBook.jsp with the book parameter set to netfd.     This line is the second book form. This one specifies netaio as the book   parameter value.     This line is the form for the third book. This one specifies wordaio as the   value of the book parameter.     After the forms for the books, a jsp:getProperty tag calls the getList   method of the bean. This method returns a string containing an HTML  table that displays the current contents of the shopping cart.   →10    →15    →21    →28   The BookCart JavaBean  Now that you’ve seen the JSP for the shopping cart application, take a look at the  Java code for the BookCart bean, shown in Listing 4-4.  Listing 4-4 contains two classes: a BookCart class and an inner class named Book.  So when you compile the code in Listing 4-4, you get two class files: BookCart. class and BookCart$Book.class. To run this application, you have to copy both  class files to a Tomcat directory  a WEB-INF\classes\books directory .  LISTING 4-4:   The BookCart JavaBean  package com.lowewriter.books;  import java.util.ArrayList; import java.text.NumberFormat; public class BookCart {     private ArrayList  cart;      private NumberFormat cf         = NumberFormat.getCurrencyInstance  ;     public BookCart        {         cart = new ArrayList   ;     }     public void setBook String code       {         boolean found = false;  770      BOOK 7  Web Programming  →1  →8  →13  →18           for  Book b : cart              if  b.getCode  .equals code               {                 b.addQuantity 1 ;                 found = true;             }         if  !found              cart.add new Book code  ;     }     public String getList        {         String list = " ";         list +="  Title  Qty "              + " Price  Total  ";         double total = 0.0;         for  Book b : cart          {             list += "  "                  + b.getTitle   + " "                  + " " + b.getQuantity    + " "                  + " " + cf.format b.getPrice                     + " "                  + " " + cf.format b.getTotal                     + " "                  + " ";             total += b.getTotal  ;         }         list +="      Total: "              + " " + cf.format total               + "  ";         list += " ";         return list;     }     private class Book      {         private String code;          private int quantity;         public Book String code           {             this.code = code;             this.quantity = 1;         }         public String getCode            {             return this.code;         }         public String getTitle            {  →31  →52  →54  →57  →63  →68  s n a e B a v a J   g n i s U   continued   CHAPTER 4  Using JavaBeans      771   LISTING 4-4:    continued               if  code.equals "elecaio"                   return "Electronics All-in-One For Dummies";             else if  code.equals "netaio"                   return "Networking All-in-One For Dummies";             else if  code.equals "javaaio"                   return "Java All-in-One For Dummies";             else                 return "Unknown book";         }         public double getPrice            {             if  code.equals "elecaio"                   return 34.99;             else if  code.equals "netaio"                   return 22.99;             else if  code.equals "javaaio"                   return 29.99;             else                 return 0.0;         }         public int getQuantity            {             return this.quantity;         }         public void addQuantity int qty           {             this.quantity += qty;         }         public double getTotal            {             return this.quantity * this.getPrice  ;         }     } }  →82  →94  →99  →104  The following paragraphs describe the bean’s high points:   →1   →8    →13     The BookCart class lives in the books package.     The shopping cart itself is kept inside the BookCart bean as a private   array list of Book items.     To be a JavaBean, you need a no-parameter constructor. This one simply   initializes the cart array list.  772      BOOK 7  Web Programming    →18    →31    →52    →54    →57    →63   →68    →82      The setBook method is called to add a book to the shopping cart. The  book’s code is passed as a parameter. This method first looks at all the  books in the array list to see whether the user has already added a book  with this code. If so, that book’s addQuantity method is called to  increase the order quantity for that book by 1. If not, a new book with  the specified code is created and added to the cart.     This method builds a string that contains all the books in the cart   presented as an HTML table. If you’re not familiar with HTML tables, all  you really need to know is that the   and   tags mark the start  and end of each row, and the   and   tags mark the start and  end of each cell within the row. The table includes one row for each book  in the cart. Each row contains cells for the title, quantity, price, and total.  If you compare the code in this method with the actual table shown in  Figure 4-2, you can get an idea of the HTML that’s actually created by this  method.          Notice also that the loop that builds each table row keeps a running total   for the entire shopping cart, which is displayed in a separate row at the  bottom of the table. Also, a row of headings is displayed at the start of  the table.     The Book class is defined as an inner class so that it can represent books   in the array list.     The Book class stores only two items of information for each book: the  book code and the quantity. The latter represents the number of books  ordered by the user. The other values are calculated by the methods that  return them.     The constructor accepts a book code and initializes the instance fields.   Notice that the quantity is initialized to 1.  s n a e B a v a J   g n i s U    The getCode method simply returns the code variable.     The getTitle method returns one of three book titles, depending on   the code. If the code is not one of the three predefined codes, Unknown  book is returned.     Likewise, the getPrice method returns one of three prices, depending   on the code. If the code is not one of the three allowable codes, the book  is free!    The getQuantity method just returns the quantity variable.   →94   →99   →104    The getTotal method calculates the total by multiplying the price by the     The addQuantity method adds a value to the quantity variable.  quantity.  CHAPTER 4  Using JavaBeans      773    Files and  Databases  8   Contents at a Glance  CHAPTER 1:  Working with Files  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 777 CHAPTER 2:  Working with File Streams  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 799 CHAPTER 3:	 Database	for	$100,	Please  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 827 CHAPTER 4:  Using JDBC to Connect to a Database  .  .  .  .  .  .  .  .  .  .  .  . 845 CHAPTER 5:  Working with XML  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 861   IN THIS CHAPTER  » Examining the File class   » Understanding command-line   parameters   » Introducing the JFileChooser class  Chapter 1 Working with Files  In this chapter, you discover the ins and outs of working with files and directo-  ries. I don’t show you how to read or write files  for that info, you should flip  to Book 8, Chapter 2 , but you do find out how to find files on the hard drive;  create, delete, and rename files; and work with directories. You find out how to  use the Swing file-chooser dialog box that lets you add filing capabilities to Swing  applications. Finally, you find out how to retrieve parameters from the command  line — a useful technique, because command-line parameters are often used to  pass file information to console programs.  Beginning with Java 1.7, you have two choices for working with files and directo- ries: You can use the original File class or you can use the new Path class, which  is part of a new file-processing package called NIO.2.  NIO.2 stands for New I O  version 2.  This chapter covers both of these classes.  Using the File Class  The File class is your key to processing files and directories. A File object repre- sents a single file or directory. Note that the file or directory doesn’t actually have  to exist on your hard drive. Instead, the File object represents a file that may or  may not actually exist.  CHAPTER 1  Working with Files      777   Java uses a single class to represent both files and directories because a directory  is actually nothing more than a special type of file. I suppose that the designers  of Java could have created a separate Directory class to represent directories, but  then you’d have to know how to use two classes instead of one.  The  File  class  is  in  the  java.io  package,  so  any  program  that  uses  it  should  import java.io.File or java.io.*.  Java 1.7 introduces a new Path class, which is designed to replace the File class.  Knowing the class constructors   and methods  Table 1-1 lists the main constructors and methods of the File class.  TABLE 1-1	  Constructor  The File Class  File String pathname   Creates a file with the specified pathname.  String separator  Field  Method  boolean canRead    boolean canWrite    boolean createNewFile    boolean delete    boolean exists    Description  Description  Description  Separates components of a pathname on this system; usually  is \ or  .  Determines whether the file can be read.  Determines whether the file can be written.  Creates the file on the hard drive if it doesn’t exist. The  method returns true if the file was created or false if the file  already existed.  Deletes the file or directory. The method returns true if the file was  deleted successfully.  Returns true if the file exists on the hard drive and false if the file  doesn’t exist.  String getCanonicalPath    Returns the complete path to the file, including the drive letter if run  on a Windows system; throws IOException.  String getName    Gets the name of this file.  778      BOOK 8  Files and Databases   Constructor  Description  String getParent    Gets the name of the parent directory of this file or directory.  File getParentFile    Gets a File object representing the parent directory of this file or  directory.  boolean isDirectory    Returns true if this File object is a directory or false if it is a file.  boolean isFile    Returns true if this File object is a file or false if it is a directory.  boolean isHidden    long lastModified    long length    String[] list    File[] listFiles    static File[] listRoots    boolean mkdir    boolean mkdirs    Returns true if this file or directory is marked by the operating  system as hidden.  Returns the time when the file was last modified, expressed in  milliseconds since 0:00:00 a.m., January 1, 1970.  Returns the size of the file in bytes.  Returns an array of String objects with the name of each file and  directory in this directory. Each string is a simple filename, not a  complete path. If this File object is not a directory, the method  returns null.  Returns an array of File objects representing each file and directory  in this directory. If this File object is not a directory, the method  returns null.  Returns an array containing a File object for the root directory of  every file system available on the Java runtime. Unix systems usually  have just one root, but Windows systems have a root for each drive.  Creates a directory on the hard drive from this File object. The  method returns true if the directory was created successfully.  Creates a directory on the hard drive from this File object, including  any parent directories that are listed in the directory path but don’t  already exist. The method returns true if the directory was created  successfully.  boolean renameTo File dest   Renames the File object to the specified destination File object.  The method returns true if the rename was successful.  boolean  setLastModified long time   Sets the last modified time for the File object. The method returns  true if the time was set successfully.  boolean setReadOnly    Marks the file as read-only. The method returns true if the file was  marked successfully.  String toString    Returns the pathname for this file or directory as a string.     s e l i F h t i w g n k r o W  i     CHAPTER 1  Working with Files      779   Creating a File object  To create a File object, you call the File constructor, passing a string represent- ing the filename as a parameter. Here’s an example:  File f = new File "hits.log" ;  Here the file’s name is hits.log, and it lives in the current directory, which usu- ally is the directory from which the Java Virtual Machine  JVM  was started.  If you don’t want the file to live in the current directory, you can supply a com- plete  pathname  in  the  parameter  string.  You’re  now  entering  one  of  the  few  areas  of  Java  that  becomes  system-dependent,  however,  because  the  way  you  write  pathnames depends on the operating system you’re using. The pathname  c:\logs\hits.log is valid for Windows systems, for example, but not on Unix or  Macintosh systems, which don’t use drive letters and use forward slashes instead  of backslashes to separate directories.  If  you  hard-code  pathnames  as  string  literals,  the  backslash  character  is  the  escape character for Java strings. Thus you must code two backslashes to get one  backslash in the pathname. You must code the path c:\logs\hits.log like this:  String path = "c:\\logs\\hits.log";  Creating a file  Creating a File object doesn’t create a file on the hard drive. Instead, it creates an  in-memory object that represents a file or directory that may or may not actually  exist on the hard drive. To find out whether the file or directory exists, you can use  the exists method, as in this example:  File f = new File path ; if  !f.exists        System.out.println          "The input file does not exist!" ;  Here an error message is displayed on the console if the file doesn’t exist.  To create a new file on the hard drive, create a File object with the filename you  want to use and then use the createNewFile method, like this:  780      BOOK 8  Files and Databases   File f = new File path ; if  f.createNewFile        System.out.println "File created." ; else     System.out.println "File could not be created." ;  Note  that  the  createNewFile  method  returns  a  boolean  that  indicates  whether  the file was created successfully. If the file already exists, createNewFile returns  false, so you don’t have to use the exists method before you call createNewFile.  When you create a file with the createNewFile method, the file doesn’t have any- thing in it. If you want the file to contain data, you can use the classes I describe  in Book 8, Chapter 2, to write information to the file.  Getting information about a file  Several of the methods of the File class simply return information about a file or  directory. You can find out whether the File object represents a file or directory,  for example, by calling its isDirectory or isFile method. Other methods let you  find out whether a file is read-only or hidden, or retrieve the file’s age and the  time when it was last modified.  You can get the name of the file represented by a File object in several popular  ways:   » To get just the filename, use the getName method. This method returns a   string that includes just the filename, not the complete path.   » To get the path that was specified to create the File object  such as \logs\  hit.log , use the toString method instead.   » To get the full path for a file — that is, the complete path including the drive  letter  for Windows systems  and all the directories and subdirectories leading  to the file — use the getCannonicalPath method. This method removes any  system-dependent oddities such as relative paths, dots  which represent the  current directory , and double dots  which represent the parent directory  to  get the file’s actual path.  Getting the contents of a directory  A directory is a file that contains a list of other files or directories. Because a direc- tory is just a special type of file, it’s represented by an object of the File class. You  can tell whether a particular File object is a directory by calling its isDirectory   CHAPTER 1  Working with Files      781     s e l i F h t i w g n k r o W  i      method. If this method returns true, the File is a directory. Then you can get an  array of all the files contained in the directory by calling the listFiles method.  The following code snippet lists the name of every file in a directory whose path- name is stored in the String variable path:  The following snippet is a little more selective because it lists only files, not sub- directories, and doesn’t list hidden files:  File dir = new File path ; if  dir.isDirectory    {     File[] files = dir.listFiles  ;     for  File f : files          System.out.println f.getName   ; }  File dir = new File path ; if  dir.isDirectory    {     File[] files = dir.listFiles  ;     for  File f : files      {         if  f.isFile   && !f.isHidden                System.out.println f.getName   ;     } }  Directory  listings  are  especially  well  suited  to  recursive  programming,  because  each File object returned by the listFiles method may be another directory that  itself has a list of files and directories. For an explanation of recursive program- ming and an example that lists directories recursively, see Book 5, Chapter 4.  Renaming files  You can rename a file by using the renameTo method. This method uses another  File object as a parameter that specifies the file you want to rename the current  file  to.  It  returns  a  boolean  value  that  indicates  whether  the  file  was  renamed  successfully.  The  following  statements  change  the  name  of  a  file  named  hits.log  to  savedhits.log:  782      BOOK 8  Files and Databases   File f = new File "hits.log" ; if  f.renameTo new File "savedhits.log"        System.out.println "File renamed." ; else     System.out.println "File not renamed." ;  Depending on the capabilities of the operating system, the renameTo method can  also move a file from one directory to another. This code moves the file hits.log  from the folder logs to the folder savedlogs:  File f = new File "logs\\hits.log" ; if  f.renameTo new File "savedlogs\\hits.log"        System.out.println "File moved." ; else     System.out.println "File not moved." ;  Always test the return value of the renameTo method to make sure that the file was  renamed successfully.  Deleting a file  To delete a file, create a File object for the file and then call the delete method,  as in this example:  File f = new File "hits.log" ; if  f.delete        System.out.println "File deleted." ; else     System.out.println "File not deleted." ;  If the file is a directory, the directory must be empty to be deleted.  With some recursive programming, you can create a method that deletes a non- empty directory — but be sure to heed the upcoming warning. The method looks  something like this:  private static void deleteFile File dir  {     File[] files = dir.listFiles  ;     for  File f : files      {     if  f.isDirectory            deleteFile f ;     s e l i F h t i w g n k r o W  i     CHAPTER 1  Working with Files      783   Using Command-Line Parameters      else         f.delete  ;     }     dir.delete  ; }  Then, to delete a folder named folder1 along with all its files and subdirectories,  call the deleteFile method:  deleteFile new File "folder1" ;  This feature is extremely dangerous to add to a program. Don’t use it without first  testing it carefully. If you accidentally delete all the files on your hard drive, don’t  blame me!  Ever since Book 1, Chapter 1, I’ve used this construction in every Java program  presented so far:  public static void main String[] args   It’s  high  time  that  you  find  out  what  the  args  parameter  of  the  main  method  is  used  for.  The  args  parameter  is  an  array  of  strings  that  lets  you  access  any  command-line parameters that are specified by the user when he or she runs your  program.  Suppose that you run a Java program named Test from a command program like  this:  C:\>java Test the quick brown fox  In this case, the Java program is passed four parameters: the, quick, brown, and  fox. You can access these parameters via the args array.  Suppose that the main method of the Test class is written like this:  public static void main String[] args  {     for  String s : args          System.out.println s ; }  784      BOOK 8  Files and Databases   Then the program displays the following output on the console when run with the  command shown a few paragraphs back:  the quick brown fox  Command-line parameters are useful in Java programs that work with files as a  way to pass pathnames to the program. Here’s a program that lists all the files in  a directory passed to the program as a parameter:  import java.io.*; public class ListDirectory {     public static void main String[] args      {         if  args.length > 0          {             String path = args[0];             File dir = new File path ;             if  dir.isDirectory                {                 File[] files = dir.listFiles  ;                 for  File f : files                  {                     System.out.println f.getName   ;                 }             }             else                 System.out.println "Not a directory." ;         }     } }  Choosing Files in a Swing Application  For the most part, you don’t want to mess around with command-line parameters  in  Swing  applications.  Instead,  you  want  to  use  the  JFileChooser  class  to  let  users pick the files they want to work with. This class lets you display Open and      s e l i F h t i w g n k r o W  i     CHAPTER 1  Working with Files      785   Save dialog boxes similar to the ones you’ve seen in other graphic user interface   GUI  applications with just a few lines of code.  Figure 1-1 shows an Open dialog box created with just these two lines of code:  JFileChooser fc = new JFileChooser  ; int result = fc.showOpenDialog this ;  FIGURE 1-1:   An Open   dialog box   displayed by the   JFileChooser  class.  This code appears in a frame class that extends the JFrame class, so the this key- word in the showOpenDialog call refers to the parent frame.  The result returned by the  showOpenDialog method indicates whether the user  chose to open a file or click Cancel, and the JFileChooser class provides a handy  getSelectedFile method that you can use to get a File object for the file selected  by the user.  The  important  thing  to  know  about  the  JFileChooser  class  is  that  it  doesn’t   actually open or save the file selected by the user; instead, it returns a File object  for  the  file  the  user  selects.  Your  program  has  the  task  of  opening  or  saving  the file.  The JFileChooser class has many additional methods that you can use to tailor  its appearance and behavior in just about any way imaginable. Table 1-2 lists the  commonly used constructors and methods of this powerful class.  786      BOOK 8  Files and Databases   TABLE 1-2	  Constructor  JFileChooser    The JFileChooser Class  Description  JFileChooser File file   JFileChooser String path   Creates a file chooser that begins at the user’s default  directory. On Windows systems, this directory is usually  My Documents.  Creates a file chooser that begins at the location  indicated by the file parameter.  Creates a file chooser that begins at the location  indicated by the path string.  Method  void addChoosableFileFilter FileFi lter filter   Description  Adds a file filter to the chooser.  File getSelectedFile    Returns a File object for the file selected by the user.  File[] getSelectedFiles    void setAcceptAllFileFilterUsed bo olean value   void  setApproveButtonText String text   Returns an array of File objects for the files selected by  the user if the file chooser allows multiple selections.  If false, removes the All Files filter from the file chooser.  Sets the text for the Approve button.  void setDialogTitle String title   Sets the title displayed by the file-chooser dialog box.  void  setFileHidingEnabled boolean value   Doesn’t show hidden files if true.  void setMultiSelectionEnabled bo olean value   int showDialog Component parent,  String text   void setFileSelectionMode int mode   int showOpenDialog Component parent   int showSaveDialog Component parent   Allows the user to select more than one file if true.  Displays a custom dialog box with the specified  text for the Accept button. The return values are  JFileChooser.CANCEL_OPTION, APPROVE_OPTION,  and ERROR_OPTION.  Determines whether the user can select files,  directories, or both. The parameter can be specified as  JFileChooser.FILES_ONLY, DIRECTORIES_ONLY, or  FILES_AND_DIRECTORIES.  Displays an Open dialog box. The return values are the  same as for the showDialog method.  Displays a Save dialog box. The return values are the  same as for the showDialog method.     s e l i F h t i w g n k r o W  i     CHAPTER 1  Working with Files      787   Creating an Open dialog box  As you’ve just seen, you can create an Open dialog box with just a few lines of code.  First, you call the JFileChooser constructor to create a JFileChooser instance;  then you call the showOpenDialog method to display an Open dialog box.  If  you  don’t  pass  a  parameter  to  the  constructor,  the  file  chooser  starts  in  the  user’s default directory, which on most systems is the operating system’s current  directory. If you want to start in some other directory, you have two options:   » Create a File object for the directory and then pass the File object to the    » Pass the pathname for the directory where you want to start to the   constructor.  constructor.  The JFileChooser class also includes methods that let you control the appearance  of the chooser dialog box. You can use the setDialogTitle method to set the title   the default is Open , for example, and you can use the setFileHidingEnabled  method to control whether hidden files are shown. If you want to allow the user to  select more than one file, use the setMultiSelectionEnabled method.  A setFileSelectionMode method lets you specify whether users can select files,  directories, or both. The options for this method need a little explanation:   » JFileChooser.FILES_ONLY: With this option  which is the default , the user  can choose files only with the file-chooser dialog box. The user can navigate  directories in the file-chooser dialog box but can’t actually select a directory.   » JFileChooser.DIRECTORIES_ONLY: With this option, the user can select only  directories, not files. One common use for this option is to let the user choose  a default location for files used by your application without actually opening a  file.   » JFileChooser.FILES_AND_DIRECTORIES: This option lets the user select  either a file or a directory. For most applications, you want the user to pick  either a file or a directory, but not both, so you probably won’t use this option  much.  In addition to an Open dialog box, you can display a Save dialog box by calling the  showSaveDialog method. A Save dialog box is similar to an Open dialog box but  has different default values for the title and the text shown on the Approve button.  Otherwise these dialog boxes work pretty much the same way.  788      BOOK 8  Files and Databases   Getting the selected file  The file-chooser dialog box is a modal dialog box, which means that after you call  the showOpenDialog method, your application is tied up until the user closes the  file-chooser dialog box by clicking the Open or Cancel button.  You can find out which button the user clicked by inspecting the value returned by  the showOpenDialog method:   » If the user clicked Open, the return value is JFileChooser.APPROVE_OPTION.  » If the user clicked Cancel, the return value is JFileChooser.CANCEL_OPTION.  » If an I O  input output  or other error occurred, the return value is   JFileChooser.ERROR_OPTION.  Assuming that the showOpenDialog method returns APPROVE_OPTION, you can use  the getSelectedFile method to get a File object for the file selected by the user.  Then you can use this File object elsewhere in the program to read or write data.  Putting it all together, then, here’s a method that displays a file-chooser dialog  box and returns a File object for the file selected by the user. If the user cancels  or an error occurs, the method returns null.  private File getFile   {     JFileChooser fc = new JFileChooser  ;     int result = fc.showOpenDialog null ;     File file = null;     if  result == JFileChooser.APPROVE_OPTION          file = fc.getSelectedFile  ;     return file; }  You  can  call  this  method  from  an  action  event  handler  when  the  user  clicks  a  button, selects a menu command, or otherwise indicates that he or she wants to  open a file.  Using file filters  The file-chooser dialog box includes a Files of Type drop-down list filter that the  user can use to control what types of files are displayed by the chooser. By default,  the only item available in this drop-down list is All Files, which doesn’t filter the  files at all. If you want to add another filter to this list, you must create a class that      s e l i F h t i w g n k r o W  i     CHAPTER 1  Working with Files      789   extends the FileFilter abstract class and then pass an instance of this class to  the addChoosableFileFilter method.  Table  1-3  lists  the  methods  of  the  FileFilter  class.  Fortunately,  it  has  only  two  methods  that  you  need  to  implement.  This  class  is  in  the  javax.swing. filechooser package.  For some reason, the Java designers gave this class the same name as an interface  that’s in the java.io package, which is also frequently used in applications that  work with files. As a result, you need to fully qualify this class when you extend  it, like this:  class JavaFilter     extends javax.swing.filechooser.FileFilter  TABLE 1-3	  Method  The FileFilter Class Description  public boolean abstract  accept File f   You must implement this method to return true if you want the file to be  displayed in the chooser or false if you don’t want the file to be displayed.  public String abstract  getDescription    You must implement this method to return the description string that is  displayed in the Files of Type drop-down list in the chooser dialog box.  The  getDescription  method  simply  returns  the  text  displayed  in  the  Files  of Type drop-down list. You usually implement it with a single return statement  that returns the description. Here’s an example:  public String getDescription   {     return "Java files  *.java "; }  Here the string Java files  *.java  is displayed in the Files of Type drop-down  list.  The accept method does the work of a file filter. The file chooser calls this method  for every file it displays. The file is passed as a parameter. The accept method  returns a boolean that indicates whether the file is displayed.  The accept method can use any criteria it wants to decide which files to accept  and which files to reject. Most filters do this based on the file-extension part of  the filename. Unfortunately, the File class doesn’t have a method that returns   790      BOOK 8  Files and Databases   the file extension, but you can get the name with the getName method and then  use the matches method with a regular expression to determine whether the file  is of the type you’re looking for. Here’s an if statement that determines whether  the filename in the name variable is a .java file:  if  name.matches ".*\\.java"    Here  the  regular  expression  matches  strings  that  begin  with  any  sequence  of  characters and end with .java.  For more information about regular expressions,  refer to Book 5, Chapter 3.   Here’s a FileFilter class that displays files with the extension .java:  private class javaFilter     extends javax.swing.filechooser.FileFilter {     public boolean accept File f      {         if  f.isDirectory               return true;         String name = f.getName  ;         if  name.matches ".*\\.java"              return true;         else            return false;     }     public String getDescription       {         return "Java files  *.java ";     } }  After you create a class that implements a file filter, you can add the file filter to  the file chooser by calling the addChoosableFileFilter method, passing a new  instance of the FileFilter class, like this:  fc.setChoosableFileFilter new JavaFilter   ;  If you want, you can remove the All Files filter by calling the method setAccept  AllFileFilterUsed, like this:     s e l i F h t i w g n k r o W  i     fc.setAcceptAllFileFilterUsed false ;  Then only the file filters that you add to the file chooser appear in the Files of Type  drop-down list.  CHAPTER 1  Working with Files      791   Using Path Objects  Java 1.7 introduces a new type of object called a Path to address several weak- nesses of the File class, which has been part of Java since version 1.0. The most  egregious of the File class flaws addressed by Path objects is that many of the  operations of the File class don’t provide detailed error information when prob- lems occur. The delete method of the File class, for example, returns a boolean  value to indicate whether the file was deleted, but if the file could not be deleted,  there’s no way to find out why. Path objects correct this deficiency by throwing  exceptions that contain detailed error information if an operation fails.  Note that Path is not actually a class; instead, it’s an interface. That means you can’t  directly create a Path object by calling a constructor. Instead, you use a method  of new class called Paths to create Path objects. The naming is  confusing — Path  versus Paths, interfaces versus classes — but after working with the Paths class  to create Path objects, you get used to the distinction.  Both the Path interface and the Paths class are in the java.nio.File package, so  any program that uses them should import java.nio.file.*.  Table 1-4 lists the constructor and methods of the Path class.  TABLE 1-4	  Method  Path Methods  Description  Path copyTo Path target   Copies the file to the specified target file.  Path moveTo Path target   Moves the file to the target path and deletes the original file.  Path createDirectory    Creates the directory on the hard drive if it doesn’t already exist.  Path createFile    void delete    void deleteIfExists    boolean exists    boolean notExists    Creates the file on the hard drive if it doesn’t already exist.  Deletes the file or directory. The method throws an exception if the  file or directory doesn’t exist or couldn’t be deleted.  Deletes the file or directory if it exists. The method doesn’t throw an  exception if the file or directory doesn’t exist.  Returns true if the file exists on the hard drive or false if the file  doesn’t exist on the hard drive.  Returns true if the file doesn’t exist on the hard drive or false if  the file does exist on the hard drive.  String toAbsolutePath    Returns the full absolute path to the file, including the drive letter if  run on a Windows system.  792      BOOK 8  Files and Databases   Method  Description  DirectoryStream newDirectory  Stream    Gets a DirectoryStream object that you can use to read the  contents of the directory.  DirectoryStream newDirectory  Stream String filter   Gets a DirectoryStream object that’s filtered by the filter  string, which can contain wildcards such as *.txt to retrieve just  .txt files.  boolean isFile    Returns true if this File object is a file or false if it is a directory.  String toString    Returns the pathname for this file or directory as a string.  Creating files with the Paths class  One thing you may find confusing right off the bat is that the Path objects are cre- ated by calling a static method of the Paths class. Path and Paths are two distinct  things: Path is an interface, and Paths is a class. To create a Path object, use the  get method of the static Paths class, like this:  Path p = Paths.get "c:\\test.txt" ;  Here the file’s name is test.txt, and it resides in the root directory of the C:  drive.  Like a File object, a Path object represents a file that may or may not actually  exist on the hard drive. You can test to see whether a file exists like this:  Path p = Paths.get path ; if  !p.exists        System.out.println          "The input file does not exist!" ;  To create a new file, use the createFile method, like this:  Path p = Paths.get "c:\\test.txt" ; try {     p.createFile  ;     System.out.println  "File created!" ; } catch  Exception e  { System.out.println  "Error: " + e.getMessage   ; }     s e l i F h t i w g n k r o W  i     CHAPTER 1  Working with Files      793   Note that the createFile method throws an exception if the file couldn’t be cre- ated. The getMessage method of this exception returns a message that explains  why the file couldn’t be created.  Getting the contents of a directory  One  of  the  weaknesses  of  the  File  class  is  that  it  doesn’t  deal  well  with  large  directories. In particular, methods such as listFiles that allow you to access the  contents of a directory return an array of File objects. That’s fine if the direc- tory contains a few dozen or even a few hundred files, but what if the directory  contains thousands or tens of thousands of files? In short, the File class is not  scalable.  The  Path class remedies this deficiency by letting you access the contents of a  directory via a stream object defined by DirectoryStream. I say more about work- ing with streams in Book 8, Chapter 2, but for now, suffice it to say that a stream  provides a simple way to access a large number of data items one at a time. You  can retrieve the items in a directory stream easily by using an enhanced for state- ment, as in this example:  Path c = Paths.get "C:\\" ; try {     DirectoryStream  stream         = c.newDirectoryStream  ;     for  Path entry: stream          System.out.println entry.toString   ; } catch  Exception e  {     System.out.println "Error: " + e.getMessage   ; }  This example displays a listing of the contents of the C:\ directory, much as typ- ing DIR C:\ at a command prompt would.  You could change the preceding example to list just the text files  files with the  extension .txt  by changing the first statement after the try statement to this:      DirectoryStream  stream         = c.newDirectoryStream "*.txt" ;  794      BOOK 8  Files and Databases   Using a File Visitor to Walk a File Tree  In the section “Getting the contents of a directory,” earlier in this chapter, I men- tion  that  processing  subdirectories  of  a  main  directory  by  using  the  File  class  requires fancy recursive programming. With Java 1.7  and later versions , you can  use a new feature that does the difficult recursive part of the programming for  you. It does this by walking the file tree — visiting every file in the tree and calling  one or more methods defined by a special class you create, called a file visitor. Here  are the basic details of how this magic works: 1.  Create a file-visitor class, which is extended from FileVisitor or, more   often, SimpleFileVisitor.  The SimpleFileVisitor class defines several methods that are called for  every file in the file tree, as shown in Table 1-5.  TABLE 1-5	  Method  The SimpleFileVisitor Class Description  FileVisitResult visitFile T file,  BasicFileAttributes attr   FileVisitResult visitFileFailed   T file, IOException e   Called once for every file in the file tree.  Called if the file couldn’t be accessed.  FileVisitResult  preVisitDirectory T dir   Called once for every directory in the file tree. This method  is called before any of the files in the directory are visited.  FileVisitResult preVisitDirectory  Failed T dir, IOException e   Called once for every directory in the file tree that couldn’t  be accessed.  FileVisitResult postVisitDirectory   T dir   Called once for every directory in the file tree. This method  is called after all the files in the directory are visited.  2.  In the file visitor, override one or more methods that are defined by the   SimpleFileVisitor class.  These methods are where you write the code that you want to execute for  every file visited when the directory tree is walked. You always want to override  at least three of the methods listed in Table 1-5:    visitFile, which is called for every file in the file tree    visitFileFailed, which is called for every file that can’t be accessed    usually due to permissions issues      preVisitDirectoryFailed, which is called for every directory that   couldn’t be accessed     s e l i F h t i w g n k r o W  i     CHAPTER 1  Working with Files      795   LISTING	1-1:	  Simple File Visitor  3.  Create a Path object that indicates the starting point  that is, the root  of   the file tree you want to walk.  If you want to visit all the files on your C: drive, for example, this path should  point to C:\.  4.  Call the walkFileTree method of the static Files class to process the   files.  This method takes just two arguments: the Path object  which identifies the  root of your file tree  and an instance of your file-visitor class.  Confusing  enough?  An  example  should  clear  things  up.  Listing  1-1  shows  just  about the simplest example of a file visitor I can come up with. This program lists  all the files in C:\Windows\System32, including all its subfolders.  import java.nio.file.*; import java.io.*; import java.nio.file.attribute.*; public class FileVisitorDemo {     public static void main String[] args      {         Path start = Paths.get "c:\\Windows\\System32" ;          MyFileVisitor visitor = new MyFileVisitor  ;          try         {             Files.walkFileTree start, visitor ;          }         catch  Exception e          {             System.out.println e.getMessage   ;         }     }     private static class MyFileVisitor extends SimpleFileVisitor        {         public FileVisitResult visitFile Path file,              BasicFileAttributes attr          {             System.out.println file.toString   ;             return FileVisitResult.CONTINUE;          }         public FileVisitResult visitFileFailed Path file,              BasicFileAttributes attr          {             System.out.println file.toString   + " COULD NOT ACCESS!" ;  →9 →10  →13  →21  →23  →27  →30  796      BOOK 8  Files and Databases               return FileVisitResult.CONTINUE;         }         public FileVisitResult preVisitDirectoryFailed               Path dir, IOException e          {             System.out.println dir.toString   + " COULD NOT ACCESS!" ;             return FileVisitResult.CONTINUE;         }     } }  →36  Here are the highlights of how this program works: →9    Creates an instance of the Path class that starts the file tree at C:\Windows\ System32. You could substitute any directory you want for this path.  →10   →13   →21   →23   →27   →30   →36    Creates an instance of the MyFileVisitor class, which is defined later in  the program  at line 21 .   Walks the file tree, starting at the directory indicated by start, using the  MyFileVisitor object created in line 10.   Defines the MyFileVisitor class, which extends the  SimpleFileVisitor class. SimpleFileVisitor is a generic class,  so you must specify a type. Usually you specify the Path type so that  SimpleFileVisitor processes Path objects.   Overrides the visitFile method, which is called once for each file that  is accessed as the file tree is walked. This method simply prints the name  of the file to the console. In a more realistic program, you would perform  some more significant action on the file, such as copying it or opening  the file and reading its contents.   Produces the return value of the visitFile method, which is of type  FileVisitResult. The most commonly returned value is CONTINUE,  which indicates that the file-tree walker should continue processing files.  Other options include TERMINATE, SKIP_SIBLINGS, and SKIP_SUBTREE.   Overrides the visitFileFailed method, which is called whenever a file  can’t be accessed. In this program, the visitFileFailed method simply  prints an error message.   Overrides the preVisitDirectoryFailed method, which is called  whenever a directory can’t be accessed. Like the visitFileFailed  method, the preVisitDirectoryFailed method simply prints an error  message.     s e l i F h t i w g n k r o W  i     CHAPTER 1  Working with Files      797    IN THIS CHAPTER  » Knowing your Java streams   » Reading and writing text streams   » Reading and writing binary streams  Chapter 2 Working with File  Streams  I      O, I O, it’s off to work I go.  Or  so  goes  the  classic  song,  which  pretty  much  sums  up  the  whole  purpose  of  computers. Without I O  input output , computers — and the programs that run  on them — would be worthless.  Imagining any useful computer program that doesn’t do some form of I O is hard.  Even the very first program presented in this book — the classic Hello, World!  program — does I O; it displays a simple message onscreen.  In this chapter, you find out about Java’s most fundamental technique for getting  data  into  and  out  of  programs:  streams.  You’ve  been  working  with  streams  all  along in this book. When you use the System.out.print or System.out.println  method to display text on the console, you’re actually sending data to an output  stream, and when you use a Scanner object to get data from System.in, you’re  reading data from an input stream.  In this chapter, you build on what you already know about stream I O and see how  it can be used to read and write data to hard-drive files.  CHAPTER 2  Working with File Streams      799   Understanding Streams  A stream is simply a flow of characters to and from a program. The other end of  the stream can be anything that can accept or generate a stream of characters,  including  a  console  window,  a  printer,  a  file  on  a  disk  drive,  or  even  another  program.  Streams have no idea of the structure or meaning of your data; a stream is just a  sequence of characters. In later chapters of Book 8, you find out how to work with  data at a higher level by using databases and XML.  You can roughly divide the world of Java stream I O into two camps:   » Character streams: Character streams read and write text characters that  represent strings. You can connect a character stream to a text file to store  text data on a hard drive. Typically, text files use special characters called  delimiters to separate elements of the file. For example:    A comma-delimited file uses commas to separate individual fields of data.    A tab-delimited file uses tabs to separate fields. Usually you can display a text file in a text editor and make some sense of its  contents.   » Binary streams: Binary streams read and write individual bytes that represent  primitive data types. You can connect a binary stream to a binary file to store  binary data on a hard drive. The contents of binary files make perfect sense to  the programs that read and write them, but if you try to open a binary file in a  text editor, the file’s contents look like gibberish.  Conceptually,  the  trickiest  part  of  understanding  how  streams  work  is  getting  your mind around all the different classes. Java has nearly 100 classes for working  with streams. Fortunately, you need to know about only a few of them for most  file I O applications. In the rest of this chapter, I tell you about the most important  classes for working with character and binary streams.  For a complete list of file  I O classes, browse to http:  download.java.net jdk9 docs api and click java. io in the list of packages near the top left of the page.   All the classes in this chapter are in the java.io package, so programs that work  with file streams include an import java.io.* statement.  800      BOOK 8  Files and Databases   Reading Character Streams  To read a text file through a character stream, you usually work with the follow- ing classes:   » File: The File class  which I cover in detail in Book 8, Chapter 1  represents a  file on a hard drive. In file I O applications, the main purpose of the File class  is to identify the file you want to read from or write to.   » FileReader: The FileReader class provides basic methods for reading data  from a character stream that originates from a file. It provides methods that  let you read data one character at a time. Usually, you don’t work with this  class directly. Instead, you create a FileReader object to connect your  program to a file and then pass that object to the constructor of the  BufferedReader class, which provides more efficient access to the file.  This  class extends the abstract class Reader, which is the base class for a variety of  classes that can read character data from a stream.    » BufferedReader: This class “wraps” around the FileReader class to provide  more efficient input. This class adds a buffer to the input stream that allows  the input to be read from the hard drive in large chunks rather than a byte at  a time, which can result in a huge improvement in performance. The  BufferedReader class lets you read data one character at a time or a line at a  time. In most programs, you read data one line at a time and then use Java’s  string-handling features to break the line into individual fields.  Table 2-1 lists the most important constructors and methods of these classes.  TABLE 2-1	  Constructor  The BufferedReader and FileReader Classes  Description  BufferedReader Reader in   Creates a buffered reader from any object that extends the Reader  class. Typically you pass this constructor a FileReader object.  FileReader File file   FileReader String path   Creates a file reader from the specified File object. It throws  FileNotFoundException if the file doesn’t exist or if it’s a directory  rather than a file.  Creates a file reader from the specified pathname. It throws  FileNotFoundException if the file doesn’t exist or if it’s a directory  rather than a file.   continued   CHAPTER 2  Working with File Streams      801   TABLE	2-1	 continued   Constructor  Method  void close    int read    Description  Description  Closes the file and throws IOException.  Reads a single character from the file and returns it as an integer.  The method returns –1 if the end of the file has been reached. It  throws IOException.  String readLine    Reads an entire line and returns it as a string. The method returns  null if the end of the file has been reached. It throws IOException.  void skip long num   Skips ahead the specified number of characters.  In the following sections, you find out how to read a file named movies.txt that  contains one line each for ten of my favorite movies. Each line of the file contains  the title of the movie, a tab, the year when the movie was released, another tab,  and the price I paid for it. Here are the contents of the file:  It's a Wonderful Life→1946→14.95 Young Frankenstein→1974→16.95 Star Wars→1977→17.95 The Princess Bride→1987→16.95 Glory→1989→14.95 The Game→1997→14.95 Shakespeare in Love→1998→19.95 Zombieland→2009→18.95 The King's Speech→2010→17.85 Star Trek: Into Darkness→2013→19.95   In this list, the arrows represent tab characters.  Later in this chapter, I show you  a program that writes data to this file.  If you create this file with a text editor, make sure that your text editor preserves  the tabs correctly.  Creating a BufferedReader  The normal way to connect a character stream to a file is to create a File object  for the file, using one of the techniques presented in Book 8, Chapter 1. Then you  can call the FileReader constructor to create a FileReader object and pass this  object to the BufferedReader constructor to create a BufferedReader object, as  in this example:  802      BOOK 8  Files and Databases   File f = new File "movies.txt" ; BufferedReader in = new BufferedReader                      new FileReader f  ;  Here a BufferedReader object is created to read the movies.txt file.  Reading from a character stream  To read a line from the file, you use the readLine method of the BufferedReader  class. This method returns null when the end of the file is reached. As a result,  testing the string returned by the readLine method in a while loop to process all  the lines in the file is common.  This code snippet reads each line from the file and prints it to the console:  String line = in.readLine  ; while  line != null  {     System.out.println line ;     line = in.readLine  ; }  After you read a line of data from the file, you can use Java’s string-handling fea- tures to pull individual bits of data out of the line. In particular, you can use the  split method to separate the line into the individual strings that are separated  by tabs. Then you can use the appropriate parse methods  such as parseInt and  parseDouble  to convert each string to its correct data type.  Here’s a routine that converts a line read from the movies.txt file to the title  a  string , year  an int , and price  a double :  String[] data = line.split "\t" ; String title = data[0]; int year = Integer.parseInt data[1] ; double price = Double.parseDouble data[2] ;  After the entire file is read, you can close the stream by calling the close method,  like so:  in.close  ;  CHAPTER 2  Working with File Streams      803   Reading the movies.txt file  Listing 2-1 shows a complete, albeit simple, program that reads the movies.txt  file and prints the contents of the file to the console.  LISTING	2-1:	  Reading from a Text File  import java.io.*;  import java.text.NumberFormat; public class ReadFile {     public static void main String[] args      {         NumberFormat cf = NumberFormat.getCurrencyInstance  ;         BufferedReader in = getReader "movies.txt" ;          Movie movie = readMovie in ;          while  movie != null           {             String msg = Integer.toString movie.year ;             msg += ": " + movie.title;             msg += "  " + cf.format movie.price  + " ";             System.out.println msg ;             movie = readMovie in ;         }     }      private static BufferedReader getReader String name       {         BufferedReader in = null;         try         {             File file = new File name ;             in = new BufferedReader                  new FileReader file   ;         }         catch  FileNotFoundException e          {             System.out.println                  "The file doesn't exist." ;             System.exit 0 ;         }         return in;     }     private static Movie readMovie BufferedReader in       {  →1  →8 →9 →10  →18 →19  →36  804      BOOK 8  Files and Databases           String title;         int year;         double price;         String line = "";         String[] data;         try         {             line = in.readLine  ;         }         catch  IOException e          {             System.out.println "I O Error" ;             System.exit 0 ;         }         if  line == null              return null;         else         {             data = line.split "\t" ;             title = data[0];             year = Integer.parseInt data[1] ;             price = Double.parseDouble data[2] ;             return new Movie title, year, price ;         }     }     private static class Movie      {         public String title;         public int year;         public double price;         public Movie String title, int year, double price          {             this.title = title;             this.year = year;             this.price = price;         }     } }  →63  If you run this program, the following output is displayed on the console:  1946: It's a Wonderful Life  $14.95  1974: Young Frankenstein  $16.95  1977: Star Wars  $17.95   CHAPTER 2  Working with File Streams      805   1987: The Princess Bride  $16.95  1989: Glory  $14.95  1997: The Game  $14.95  1998: Shakespeare in Love  $19.95  2009: Zombieland  $18.95  2010: The King's Speech  $17.85  2013: Star Trek Into Darkness  $19.95   Because I’ve already explained most of this code, the following paragraphs pro- vide just a road map to this program: →1    The program begins with import java.io.* to import all the Java I O  classes used by the program.  →8   →9   →10   →18   →19   →36   →63    The program uses a method named getReader to create a Buffered  Reader object that can read the file. The name of the file is passed to this  method as a parameter. Note that in a real program, you’d probably get this  filename from the user via a JFileChooser dialog box or some other  means. In any event, the BufferedReader object returned by the getReader  method is saved in a variable named in.   Another method, named readMovie, is used to read each movie from the  file. This method returns a Movie object.  Movie is a private class that’s  defined later in the program.  If the end of the file has been reached, this  method returns null.   A while loop is used to process each movie. This loop simply builds a  message string from the Movie object, displays it on the console, and then  calls readMovie to read the next movie in the file.   The program ends without closing the file. That’s okay, though, because the  file is closed automatically when the program that opened it ends. If the  program were to go on with other processing after it finished with the file,  you’d want to close the file first.   The getReader method creates a BufferedReader object for the filename  passed as a parameter. If any exceptions are thrown during creation of the  BufferedReader object, the program exits.   The readMovie method reads a line from the reader passed as a parameter,  parses the data in the line, creates a Movie object from the data, and returns  the Movie object. If the end of the file is reached, this method returns null.  The statement that reads the line from the file is enclosed in a try catch  block that exits the program if an I O error occurs.   The Movie class is a private inner class that defines the movie objects. To  keep the class simple, it uses public fields and a single constructor that  initializes the fields.  806      BOOK 8  Files and Databases   Writing Character Streams  The usual way to write data to a text file is to use the PrintWriter class — which,  as luck would have it, you’re already familiar with. It’s the same class that pro- vides the print and println methods used to write console output. As a result,  the only real trick to writing output to a text file is figuring out how to connect a  print writer to a text file. To do that, you work with three classes:   » FileWriter: The FileWriter class connects to a File object but provides   only rudimentary writing ability.   » BufferedWriter: This class connects to a FileWriter and provides output  buffering. Without the buffer, data is written to the hard drive one character  at a time. This class lets the program accumulate data in a buffer and writes  the data only when the buffer is filled or when the program requests that the  data be written.   » PrintWriter: This class connects to a Writer, which can be a Buffered   Writer, a FileWriter, or any other object that extends the abstract Writer  class. Most often, you connect this class to a BufferedWriter.  The PrintWriter class is the only one of these classes whose methods you usually  use when you write data to a file. Table 2-2 lists the most important constructors  and methods of this class.  TABLE 2-2	  Constructor  Description  The PrintWriter, BufferedWriter, and  FileWriter Classes  PrintWriter Writer out   Creates a print writer for the specified output writer.  PrintWriter Writer out,  boolean flush   BufferedWriter Writer out   FileWriter File file   FileWriter File file,  boolean append   FileWriter String path   Creates a print writer for the specified output writer. If the second  parameter is true, the buffer is automatically flushed whenever  the println method is called.  Creates a buffered writer from the specified writer. Typically, you  pass this constructor a FileWriter object.  Creates a file writer from the specified File object and throws  IOException if an error occurs.  Creates a file writer from the specified File object and throws  IOException if an error occurs. If the second parameter is true,  data is added to the end of the file if the file already exists.  Creates a file writer from the specified pathname and throws  IOException if an error occurs.   continued   CHAPTER 2  Working with File Streams      807   TABLE	2-2	 continued   Constructor  FileWriter String path,  boolean append   PrintWriter Method  void close    void flush    int read    void print value   void println value   Creates a file writer from the specified pathname and throws  IOException if an error occurs. If the second parameter is true,  data is added to the end of the file if the file already exists.  Description  Description  Closes the file.  Writes the contents of the buffer to the hard drive.  Reads a single character from the file and returns it as an integer.  The method returns –1 if the end of the file has been reached. It  throws IOException.  Writes the value, which can be any primitive type or any object. If  the value is an object, the object’s toString   method is called.  Writes the value, which can be any primitive type or any object. If  the value is an object, the object’s toString   method is called.  A line break is written following the value.  Connecting a PrintWriter to a text file  To connect a character stream to an output file, you first create a File object for  the file, as I describe in Book 8, Chapter 1. Then you call the PrintWriter con- structor to create a PrintWriter object that you can use to write to the file. This  constructor wraps around a BufferedWriter object, which in turn wraps around  a FileWriter object like this:  File file = new File "movies.txt" ; PrintWriter out =     new PrintWriter          new BufferedWriter              new FileWriter file     ;  If you find this arrangement a little confusing, that’s good! That makes me feel a  little better, because I find it a little confusing too. The basic idea going on here is  that each of the classes is adding a capability to the class it wraps. At the bottom  is the FileWriter class, which has the ability to write characters to a file. The  BufferedWriter class adds buffering to the mix, saving data in a buffer until it  makes sense to write it all out to the file in one big spurt. The PrintWriter class  adds basic formatting capabilities, such as adding a line ending at the end of each  line and converting primitive types to strings.  808      BOOK 8  Files and Databases   Both  the  FileWriter  and  the  PrintWriter  classes  have  an  optional  boolean  parameter you can use to add extra capabilities to the file stream. If you specify  true  in  the  FileWriter  constructor,  the  file  is  appended  if  it  exists.  Appended  simply means that any data in the file is retained; data that you write to the file  in your program is simply added to the end of the file. Here’s a PrintWriter con- structor that appends data to its file:  File file = new File "movies.txt" ; PrintWriter out =     new PrintWriter          new BufferedWriter              new FileWriter file, true       append mode  If you specify false instead of true, or if you leave this parameter out, an existing  file is deleted, and its data is lost.  The boolean parameter in the PrintWriter class has less dire consequences. It  simply tells the PrintWriter class that it should tell the BufferedWriter class  to flush its buffer whenever you use the println method to write a line of data.  Although  this  option  may  decrease  the  efficiency  of  your  program  by  a  small  amount, it also makes the program a little more reliable, because it reduces the  odds of losing data if your program or the whole computer crashes while unwrit- ten data is in the buffer.  Unfortunately, the code for specifying this option looks a little goofy because of  the way that the constructors for the BufferedWriter and FileWriter classes are  nested:  File file = new File "movies.txt" ; PrintWriter out =     new PrintWriter          new BufferedWriter              new FileWriter file   , true ;     mode flush  If all these nested constructors make your head spin, you can always construct  each object separately and use variables to keep track of them. Here’s an example  that does just that, and also turns on append mode for FileWriter and flush mode  for PrintWriter:  FileWriter fw = new FileWriter file, true ; BufferedWriter bw = new BufferedWriter fw ; PrintWriter out = new PrintWriter bw, true ;  If you find this coding technique easier to understand, by all means use it.  CHAPTER 2  Working with File Streams      809   Writing to a character stream  After you successfully connect a character stream to a file, writing data to it is as  easy as writing text to the console. You just use the print and println methods  exactly as though you were writing to the console.  One minor complication is that if you’re writing data to a text file in a delimited  format, you have to include statements that write the delimiter characters to the  file. Suppose  for example  that the title and year of a movie that you want to write  to the text file are stored in String variables named title and year. This snippet  of code writes these fields with a tab delimiter between them:  System.out.print title ; System.out.print "\t" ; System.out.println year ;  Here the last item to be written is written with the println method rather than  the print method. That ends the current line.  If you prefer to be a little more efficient, you can build a string representing the  entire line and then write the line all at once, as follows:  String line = title + "\t" + year; System.out.println line ;  This method is a little more efficient than the preceding version, but not as much  as you’d think. In most cases, BufferedWriter holds your text in a buffer until the  println method is called anyway.  If you didn’t specify the flush option when you created the PrintWriter object,  you can still periodically force any data in the buffer to be written to the hard drive  by calling the flush method, as follows:  Also, when you’re finished writing data to the file, you can close the file by calling  the close method, like this:  out.flush  ;  out.close  ;  Writing the movies.txt file  Listing 2-2 shows a complete program that writes lines to a text file. The data  written is taken from an array that’s hard-coded into the file, but you can easily   810      BOOK 8  Files and Databases   imagine how to obtain the data from the user by prompting for console input or  using text fields in a Swing application.  For full coverage of Swing, see Book 6.   LISTING	2-2:	 Writing to a Text File  →4  →12  import java.io.*; public class WriteFile {     public static void main String[] args       {         Movie[] movies = getMovies  ;         PrintWriter out = openWriter "movies2.txt" ;         for  Movie m : movies              writeMovie m, out ;         out.close  ;     }     private static Movie[] getMovies        {         Movie[] movies = new Movie[10];         movies[0] = new Movie "It's a Wonderful Life",             1946, 14.95 ;         movies[1] = new Movie "Young Frankenstein",             1974, 16.95 ;         movies[2] = new Movie "Star Wars",             1977, 17.95 ;         movies[3] = new Movie "The Princess Bride",             1987, 16.95 ;         movies[4] = new Movie "Glory",             1989, 14.95 ;         movies[5] = new Movie "The Game",             1997, 14.95 ;         movies[6] = new Movie "Shakespeare in Love",             1998, 19.95 ;         movies[7] = new Movie "Zombieland",             1997, 18.95 ;         movies[8] = new Movie "The King's Speech",             1997, 19.95 ;         movies[9] = new Movie "Star Trek Into Darkness",             1997, 19.95 ;         return movies;     }     private static PrintWriter openWriter String name       {         try  →37   continued   CHAPTER 2  Working with File Streams      811   LISTING	2-2:	   continued           {             File file = new File name ;             PrintWriter out =                 new PrintWriter                      new BufferedWriter                          new FileWriter file   , true  ;             return out;         }         catch  IOException e          {             System.out.println "I O Error" ;             System.exit 0 ;         }         return null;     }     private static void writeMovie Movie m,          PrintWriter out      {         String line = m.title;         line += "\t" + Integer.toString m.year ;         line += "\t" + Double.toString m.price ;         out.println line ;     }     private static class Movie      {         public String title;         public int year;         public double price;         public Movie String title, int year, double price          {             this.title = title;             this.year = year;             this.price = price;         }     } }  →55  →63  Because all the coding elements in this program have already been explained in  this chapter, the following paragraphs just provide a road map to the major part  of the program: →4    The main method begins by calling a method named getMovies, which  returns an array of Movie objects to be written to the file.  The Movie class is   812      BOOK 8  Files and Databases   defined as an inner class later in the program.  Then it calls openWriter,  which creates a PrintWriter object that the program can use to write data  to the file. Next, it uses an enhanced for loop to call the writeMovie  method for each movie in the array. This method accepts a Movie object that  contains the movie to be written and a PrintWriter object to write the  movie to. Finally, the PrintWriter is closed.   The getMovies method returns an array of Movie objects that are written to  a file. In a real-life program, you’d probably do something other than  hard-code the movie information in this method. You might prompt the user  to enter the data, for example, or use a Swing frame to get the data.   The openWriter method creates a PrintWriter object for the filename  passed to it as a parameter. The PrintWriter uses a buffer that’s flushed  each time println is called.   The writeMovie method accepts as parameters a Movie object to be written  and the PrintWriter to which the movie should be written. It creates a  string that includes the title, a tab, the year, another tab, and the price; then it  writes the string to the file.   The Movie class is an inner class that defines a movie object. This class  simply consists of three public fields  title, year, and price  and a constructor  that initializes the fields.  →12   →37   →55   →63   Binary streams, used to store data in raw binary format rather than in text for- mat, are a bit tougher to read than character streams. The biggest obstacle to pass  when you’re reading a binary stream is that you need to know exactly the type  of each item that was written to the file. If any incorrect data is in the file, the  program won’t work, so you need to ensure that the file contains the data your  program expects it to contain.  To read a binary file, you usually work with the following classes:   » File: Once again, you use the File class to represent the file itself.  » FileInputStream: FileInputStream is what connects the input stream to a file.  » BufferedInputStream: This class adds buffering to the basic FileInput   Stream, which improves the stream’s efficiency and gives it a moist and chewy  texture.  CHAPTER 2  Working with File Streams      813  Reading Binary Streams    » DataInputStream: This class is the one you actually work with to read data  from the stream. The other Stream classes read a byte at a time. This class  knows how to read basic data types, including primitive types and strings.  Table 2-3 lists the vital constructors and methods of these classes.  TABLE 2-3	  Constructors  Classes for Reading Binary Streams  Description  BufferedInputStream InputStream in   Creates a buffered input stream from any object that  extends the InputStream class. Typically you pass this  constructor a FileInputStream object.  Creates a data input stream from any object that  extends the InputStream class. Typically you pass this  constructor a BufferedInputStream object.  Creates a file input stream from the specified object.  It throws FileNotFoundException if the file doesn’t  exist or if it’s a directory rather than a file.  Creates a file input stream from the specified pathname.  It throws FileNotFoundException if the file doesn’t  exist or if it’s a directory rather than a file.  Description  Reads a boolean value from the input stream. It throws  EOFException and IOException.  Reads a byte value from the input stream. It throws  EOFException and IOException.  Reads a char value from the input stream. It throws  EOFException and IOException.  Reads a double value from the input stream. It throws  EOFException and IOException.  Reads a float value from the input stream. It throws  EOFException and IOException.  Reads an int value from the input stream. It throws  EOFException and IOException.  Reads a long value from the input stream. It throws  EOFException and IOException.  Reads a short value from the input stream. It throws  EOFException and IOException.  Reads a string stored in UTF format from the input  stream. It throws EOFException, IOException, and  UTFDataFormatException.  DataInputStream InputStream in   FileInputStream File  File file   FileInputStream String path   DataInputStream Methods  boolean readBoolean    byte readByte    char readChar    double readDouble    float readFloat    int readInt    long readLong    short readShort    String readUTF    814      BOOK 8  Files and Databases   The following sections present programs that read and write data in a binary file  named movies.dat that contains information about movies. Each record in this  file consists of a UTF  Unicode  string containing the movie’s title, an int rep- resenting the year when the movie was released, and a double representing the  price I paid for the movie at my local discount video store. Although the format of  this file is different from that of the movies.txt file shown earlier in this chapter,  the file contains the same data. Refer to the section “Reading Character Streams,”  earlier in this chapter, to see a list of the movies in this file.  If  you’re  unfamiliar  with  UTF,  it  is  a  standardized  way  of  encoding  characters  in text files. The most commonly used forms of UTF are UTF-8, which encodes  each character as a single byte, and UTF-16, which encodes each character as a  2-byte sequence. For more information, use your favorite search engine to search  for UTF.  Creating a DataInputStream  To read data from a binary file, you want to connect a DataInputStream object to  an input file. To do that, you use a File object to represent the file, a FileInput  Stream object that represents the file as an input stream, a BufferedInputStream  object  that  adds  buffering  to  the  mix,  and  finally  a  DataInputStream  object  to  provide the methods that read various data types. The constructor for such a beast  looks like this:  File file = new File "movies.dat" ; DataInputStream in = new DataInputStream         new BufferedInputStream           new FileInputStream file     ;  If all this nesting makes you nauseous, you can use this format instead:  File file = new File "movies.dat" ; FileInputStream fs = new FileInputStream file ; BufferedInputStream bs = new BufferedInputStream fs ; DataInputStream in = new DataInputStream bs ;  Either way, the effect is the same.  Reading from a data input stream  With binary files, you don’t read an entire line into the program and parse it into  individual  fields.  Instead,  you  use  the  various  read  methods  of  the  DataInput  Stream class to read the fields one at a time. To do that, you have to know the  exact sequence in which data values appear in the file.  CHAPTER 2  Working with File Streams      815   Here’s a code snippet that reads the information for a single movie and stores the  data in variables:  String title = in.readUTF  ; int year = in.readInt  ; double price = in.readDouble  ;  All of the read methods throw EOFException if the end of the file is reached and  IOException if an I O error occurs, so you need to call these methods inside a  try catch block that catches these exceptions. The readUTF method also throws  UTFDataFormatException,  but  that  exception  is  a  type  of  IOException,  so  you  probably don’t need to catch it separately.  The read methods usually are used in a while loop to read all the data from the  file. When the end of the file is reached, EOFException is thrown. Then you can  catch this exception and stop the loop. One way to do that is to use a boolean vari- able to control the loop, as follows:  boolean eof = false; while  !eof  {     try     {         String title = in.readUTF  ;         int year = in.readInt  ;         double price = in.readDouble  ;            do something with the data here     }     catch  EOFException e      {         eof = true;     }     catch  IOException e      {         System.out.println "An I O error "             + "has occurred!" ;         System.exit 0 ;     } }  Here the boolean variable eof is set to true when EOFException is thrown, and  the loop continues to execute as long as eof is false.  816      BOOK 8  Files and Databases   After you read a line of data from the file, you can use Java’s string-handling fea- tures to pull individual bits of data out of the line. In particular, you can use the  split method to separate the line into the individual strings that are separated  by tabs. Then you can use the appropriate parse methods to parse each string to  its correct data type.  Here’s a routine that converts a line read from the movies.txt file to the title  a  string , year  an int , and price  a double :  String[] data = line.split "\t" ; String title = data[0]; int year = Integer.parseInt data[1] ; double price = Double.parseDouble data[2] ;  After the entire file has been read, you can close the stream by calling the close  method, like this:  in.close  ;  This method also throws IOException, so you want to place it inside a try catch  block.  Reading the movies.dat file  Now that you’ve seen the individual elements of reading data from a binary file,  Listing 2-3 presents a complete program that uses these techniques. This program  reads the  movies.dat file; creates a  Movie object for each title, year, and price  value; and prints a line on the console for each movie. If you run this program,  the output looks exactly like the output from the text-file version presented in the  section “Reading the movies.txt file,” earlier in this chapter.  Note that you must  first create the movies.dat file before you can run this program. The program that  creates the movies.dat file is found later in this chapter, in Listing 2-4.   import java.io.*; import java.text.NumberFormat; public class ReadBinaryFile {     public static void main String[] args       {         NumberFormat cf = NumberFormat.getCurrencyInstance  ;  →5   continued   CHAPTER 2  Working with File Streams      817  LISTING	2-3:	  Reading from a Binary File   LISTING	2-3:	   continued           DataInputStream in = getStream "movies.dat" ;         boolean eof = false;         while  !eof          {             Movie movie = readMovie in ;             if  movie == null                  eof = true;             else             {                 String msg = Integer.toString movie.year ;                 msg += ": " + movie.title;                 msg += "  " + cf.format movie.price  + " ";                 System.out.println msg ;             }         }         closeFile in ;     }     private static DataInputStream getStream String name       {         DataInputStream in = null;         try         {             File file = new File name ;             in = new DataInputStream                     new BufferedInputStream                       new FileInputStream file     ;         }         catch  FileNotFoundException e          {             System.out.println "The file doesn't exist." ;             System.exit 0 ;         }         return in;     }     private static Movie readMovie DataInputStream in       {         String title = "";         int year = 0;;         double price = 0.0;;         try         {  →25  →42  818      BOOK 8  Files and Databases               title = in.readUTF  ;             year = in.readInt  ;             price = in.readDouble  ;         }         catch  EOFException e          {             return null;         }         catch  IOException e          {             System.out.println "I O Error" ;             System.exit 0 ;         }         return new Movie title, year, price ;     }     private static void closeFile DataInputStream in       {         try         {             in.close  ;         }         catch IOException e          {             System.out.println "I O Error closing file." ;             System.out.println  ;         }     }     private static class Movie      {         public String title;         public int year;         public double price;         public Movie String title, int year, double price          {             this.title = title;             this.year = year;             this.price = price;         }     } }  →64  →76  CHAPTER 2  Working with File Streams      819   The following paragraphs describe what each method in this program does: →5    The main method is intentionally kept simple so that it can focus on control- ling the flow of the program rather than doing the detail work of accessing  the file. As a result, it calls a method named getStream to get a data input  stream object to read the file. Then it uses a while loop to call a method  named readMovie to get a movie object. If the Movie object isn’t null, the  movie’s data is printed to the console. Finally, when the loop ends, a method  named closeFile is called to close the file.  →25   →42   →64  →76    The getStream method creates a DataInputStream object for the filename  passed as a parameter. If any exceptions are thrown, the program exits.   The readMovie method reads the data for a single movie and creates a  Movie object. If the end of the file is reached, the method returns null.  The closeFile method closes the input stream.   As in the other programs in this chapter, the Movie class is defined as a  private inner class.  Writing Binary Streams  To write data to a binary file, you use the following classes:   » FileOutputStream: The FileOutputStream class connects to a File object  and creates an output stream that can write to the file. This output stream is  limited in its capabilities, however, in that it can write only raw bytes to the file.  In other words, it doesn’t know how to write values such as ints, doubles,  or strings.   » BufferedOutputStream: This class connects to a FileOutputStream and    » DataOutputStream: This class adds the ability to write primitive data types   adds output buffering.  and strings to a stream.  Table 2-4 lists the essential constructors and methods of these classes.  820      BOOK 8  Files and Databases   TABLE 2-4	  Constructor  The DataOutputStream, BufferedOutputStream, and   FileOutputStream Classes Description  DataOutputStream Output  Stream out   Creates a data output stream for the specified output stream.  BufferedIOutputStream Output Stream out   Creates a buffered output stream for the specified  stream.  Typically you pass this constructor a FileOutputStream object.  FileOutputStream File file   Creates a file writer from the file. It throws FileNotFound  Exception if an error occurs.  FileOutputStream File file,  boolean append   Creates a file writer from the file. It throws FileNotFound  Exception if an error occurs. If the second parameter is true,  data is added to the end of the file if the file already exists.  FileOutputStream String path   Creates a file writer from the specified pathname. It throws  FileNotFoundException if an error occurs.  FileOutputStream String path,  boolean append   Creates a file writer from the specified pathname. It throws  FileNotFoundException if an error occurs. If the second  parameter is true, data is added to the end of the file if the file  already exists.  DataInputStream Method  void close    void flush    int size    Description  Closes the file.  Writes the contents of the buffer to the hard drive.  Returns the number of bytes written to the file.  void writeBoolean boolean value  Writes a boolean value to the output stream. It throws   IOException.  void writeByte byte value   void writeChar char value   void writeDouble double value   void writeFloat float value   void writeInt int value   void writeLong long value   Writes a byte value to the output stream. It throws  IOException.  Writes a char value to the output stream. It throws  IOException.  Writes a double value to the output stream. It throws  IOException.  Writes a float value to the output stream. It throws  IOException.  Writes an int value to the output stream. It throws  IOException.  Writes a long value to the output stream. It throws  IOException.   continued   CHAPTER 2  Working with File Streams      821   TABLE	2-4	 continued   Constructor  void writeShort short value   void writeUTF String value   Description  Writes a short value to the output stream. It throws  IOException.  Writes a string stored in UTF format to the output  stream. It throws EOFException, IOException, and  UTFDataFormatException.  Creating a DataOutputStream  Creating  a  DataOutputStream  object  requires  yet  another  one  of  those  crazy  nested constructor things:  File file = new File name ; DataOutputStream out = new DataOutputStream          new BufferedOutputStream            new FileOutputStream file     ;  If you prefer, you can unravel the constructors like this:  File file = new File name ; FileOutputStream fos = new FileOutputStream file ; BufferedOutputStream bos = new BufferedOutputStream fos ; DataOutputStream out = new DataOutputStream bos ;  The FileOutputStream class has an optional boolean parameter that you can use  to indicate that the file should be appended if it exists. To use this feature, call the  constructors like this:  File file = new File name ; DataOutputStream out = new DataOutputStream          new BufferedOutputStream            new FileOutputStream file, true     ;  If you specify false instead of true or leave the parameter out, an existing file is  deleted, and its data is lost.  Writing to a binary stream  After you successfully connect a DataOutputStream to a file, writing data to it is  simply a matter of calling the various write methods to write different data types  to the file. The following code writes the data for a Movie object to the file:  822      BOOK 8  Files and Databases   out.writeUTF movie.title ; out.writeInt movie.year ; out.writeDouble movie.price ;  These  methods  throw  IOException,  of course.  As  a result,  you have to enclose  them in a try catch block.  If  you  included  the  BufferedOutputStream  class  in  the  stream,  it  accumulates  data in its buffer until it decides to write the data to the hard drive. If you want,  you  can  force  the  buffer  to  be  written  to  the  hard  drive  by  calling  the  flush  method, like this:  Also, when you finish writing data to the file, close the file by calling the close  method, like this:  out.flush  ;  out.close  ;  The flush and close methods also throw IOException, so you need a try catch  block to catch the exception.  Writing the movies.dat file  Listing 2-4 presents a program that writes the movies.dat file from an array of  Movie objects whose values are hard-coded into the program.  import java.io.*; public class WriteBinaryFile {     public static void main String[] args       {         Movie[] movies = getMovies  ;         DataOutputStream out = openOutputStream "movies.dat" ;         for  Movie m : movies              writeMovie m, out ;         closeFile out ;     }     private static Movie[] getMovies        {         Movie[] movies = new Movie[10];         movies[0] = new Movie "It's a Wonderful Life",             1946, 14.95 ;  →4  →12  CHAPTER 2  Working with File Streams      823   continued   LISTING	2-4:	 Writing to a Binary File   LISTING	2-4:	   continued           movies[1] = new Movie "Young Frankenstein",             1974, 16.95 ;         movies[2] = new Movie "Star Wars",             1977, 17.95 ;         movies[3] = new Movie "The Princess Bride",             1987, 16.95 ;         movies[4] = new Movie "Glory",             1989, 14.95 ;         movies[5] = new Movie "The Game",             1997, 14.95 ;         movies[6] = new Movie "Shakespeare in Love",             1998, 19.95 ;         movies[7] = new Movie "Zombieland",             1997, 18.95 ;         movies[8] = new Movie "The King's Speech",             1997, 19.95 ;         movies[9] = new Movie "Star Trek Into Darkness",             1997, 19.95 ;         return movies;     }     private static DataOutputStream         openOutputStream String name       {         DataOutputStream out = null;         try         {             File file = new File name ;             out = new DataOutputStream                      new BufferedOutputStream                        new FileOutputStream file     ;             return out;         }         catch  IOException e          {             System.out.println                  "I O Exception opening file." ;             System.exit 0 ;         }         return out;     }     private static void writeMovie Movie m,          DataOutputStream out      {         try         {  824      BOOK 8  Files and Databases  →38  →57               out.writeUTF m.title ;             out.writeInt m.year ;             out.writeDouble m.price ;         }         catch  IOException e          {             System.out.println                  "I O Exception writing data." ;             System.exit 0 ;         }     }     private static void closeFile DataOutputStream out       {         try         {             out.close  ;         }         catch  IOException e          {             System.out.println "I O Exception closing file." ;             System.exit 0 ;         }     }     private static class Movie      {         public String title;         public int year;         public double price;         public Movie String title, int year, double price          {             this.title = title;             this.year = year;             this.price = price;         }     } }  →73  →85  Because this chapter explains all the coding elements in this program, the follow- ing paragraphs just provide a road map to the major parts of the program: →4    The main method calls getMovies to get an array of Movie objects. Next, it  calls openOutputStream to get an output stream to write data to the file.  Then an enhanced for loop calls writeMovie to write the movies to the file.  Finally, the method calls closeFile to close the file.  →12    The getMovies method creates an array of movies to be written to the file.  CHAPTER 2  Working with File Streams      825   →38   →57    The openOutputStream method creates a DataOutputStream object so that  the program can write data to the file.   The writeMovie method accepts two parameters: the movie to be written  and the output stream to write the data to.  The closeFile method closes the file.  →73  →85  Once again, the Movie class is included as an inner class.  826      BOOK 8  Files and Databases   IN THIS CHAPTER  » Understanding some basic database   concepts   » Taking a quick look at SQL   » Creating tables   » Selecting data   » Joining data   » Updating and deleting data  Chapter 3 Database for $100,  Please  SQL stands for Structured Query Language. SQL is the lingua franca  that’s not   a type of pasta but a type of tongue  of relational databases. It’s the stan- dard language used for creating and accessing relational databases and is   the foundation of database processing in Java.  Java  provides  Java  Database  Connectivity   JDBC ,  which  lets  you  formulate  SQL  statements, send them off to a database server, and process the results. To use  JDBC, however, you need to know some basic concepts of SQL databases and at  least enough SQL to formulate some sensible SQL statements.  This chapter won’t make you a database guru or an expert on SQL — a complicated  language that’s the subject of many entire books, including SQL For  Dummies, 8th  Edition, by Allen G. Taylor  Wiley . This chapter covers just enough SQL to get you  going with JDBC.  Also,  this  chapter  doesn’t  cover  JDBC.  I  decided  to  save  that  topic  for  Book  8,  Chapter 4, so if you already know SQL, you can skip this chapter.  CHAPTER 3  Database for $100, Please      827   Defining a Relational Database  The term relational database is one of the most used and abused buzzwords in all  of computerdom. A relational database can be   » A database in which data is stored in tables: Relationships can be estab- lished between tables based on common information. A table of customers  and a table of invoices, for example, might both contain a customer-number  column. This column can serve as the basis for a relationship between  the tables.   » A database that is accessed via SQL: IBM invented SQL to provide a   practical way to access data stored in relational databases.  From a Java programmer’s perspective, the second definition is the only one that  matters. If you can use SQL to access the database, the database is relational.  Understanding  and Pronouncing  SQL  SQL is a query language, which means that it’s designed to extract, organize, and  update information in relational databases. Way back in the 1970s, when it was  invented  SQL is old enough to be Java’s grandfather , SQL was supposed to be  an English-like query language that untrained users could employ to access and  update relational database data without the need for programming. That didn’t  happen, of course. SQL is nothing like English. It’s way too complicated and eso- teric for untrained users to figure out. But it has become the overwhelming favor- ite among programmers.  Ever since you first saw the acronym SQL, you’ve probably been wondering how  to pronounce it.  If not, humor me.  Two schools of thought exist on this subject:   » Spell out the letters: Ess-Queue-El.  » Pronounce it like the word sequel.  Either one does the job, but be warned: Some people are adamant that it must  be pronounced one way or the other. Those people also tend to hold the opinion  that anyone who pronounces it the “wrong” way  in their opinion  is an illiterate  dweeb.  828      BOOK 8  Files and Databases   Introducing SQL Statements  Unlike Java, SQL is not object-oriented. Remember, SQL was invented during the  Nixon administration. Like Java, however, SQL uses statements to get work done.  Table 3-1 lists the SQL statements you use most often.  TABLE 3-1	  Common SQL Statements Description SQL Statement  Data Manipulation  select  insert  delete  update  create  alter  drop  use  Data Definition  Retrieves data from one or more tables. This statement is the  one you use most often.  Inserts one or more rows into a table.  Deletes one or more rows from a table.  Updates existing rows in a table.  Creates tables and other database objects.  Changes the definitions of a table or other database object.  Deletes a table or other database object.  In scripts, indicates what database subsequent  statements apply to.  Unlike  Java  statements,  statements  in  SQL  aren’t  case-sensitive,  which  means  that  you  can  write  select,  Select,  or  SELECT.  You  can  even  write  sElEcT  for  kicks, if you want.  Creating a SQL Database  Before you can store data in a relational database, you must create the database.  Normally you don’t do that from a Java program. Instead, you do it by writing a  script file that contains the Create statements necessary to create the table and  then running the script through the database server’s administration program.   Some database servers also let you define databases interactively, but the script  approach is preferred because you often need to delete and re-create a database  while testing your applications.   CHAPTER 3  Database for $100, Please      829   LISTING	3-1:	 A Database Creation Script  The scripts shown in this section  and in the rest of this chapter  are for version  5.5 of MySQL. MySQL is a free SQL database server that you can download from  dev.mysql.com downloads mysql. The complete MySQL download includes both  the server and a handy program called the MySQL Command Line Client, which  lets you enter SQL commands from a prompt and see the results immediately.  To  install MySQL, go to the website mentioned at the start of this paragraph, click the  link for the installer that’s appropriate for your Windows version, and then follow  the onscreen instructions.   Script statements end with semicolons, which is about the only thing that SQL  scripts have in common with Java scripts. Be aware, however, that the semicolon  isn’t required when you use SQL statements in a Java program. The semicolon is  required only when you use SQL statements in a script or interactively from the  MySQL Command Line Client program.  I don’t have room in this book to provide a complete tutorial on writing scripts  that create SQL databases. Instead, I present Listing 3-1 — a sample script that  creates a database named movies, which I use in the rest of this chapter and the  next one — and walk you through its most important lines.  →1 →2 →3 →4 →5 →6 →7 →8 →9  →11  drop database if exists movies;  create database movies;  use movies;  create table movie        id int not null auto_increment,      title varchar 50 ,      year int,      price decimal 8,2 ,      primary key id    ; insert into movie  title, year, price       values  "It's a Wonderful Life", 1946, 14.95 ; insert into movie  title, year, price      values  "Young Frankenstein", 1974, 16.95 ; insert into movie  title, year, price      values  "Star Wars", 1977, 17.95 ; insert into movie  title, year, price      values  "The Princess Bride", 1987, 16.95 ; insert into movie  title, year, price      values  "Glory", 1989, 14.95 ; insert into movie  title, year, price      values "The Game",1997,14.95 ;  830      BOOK 8  Files and Databases   insert into movie  title, year, price      values "Shakespeare in Love",1998,19.95 ; insert into movie  title, year, price      values "Zombieland",2009,18.95 ; insert into movie  title, year, price      values "The King's Speech",2010,17.85 ; insert into movie  title, year, price      values "Star Trek Into Darkness",2013,19.95 ;  The following paragraphs describe the important lines of this script:  →1   →2  →3   →4   →5   →6  →7  →8   →9   →11    It’s common for a script that creates a database to begin with a drop data- base statement to delete any existing database with the same name. During  testing, it’s common to delete and re-create the database, so you want to  include this statement in your scripts.  This statement creates a new database named movies.   The use statement indicates that the script statements that follow apply to  the newly created movies database.   This create table statement creates a table named movie with columns  named id, title, year, and price. This statement also specifies that the  primary key for the table is the id column.   The id column’s data type is int, which corresponds to Java’s int type. This  column also specifies not null, which means that it must have a value for  every row, and it specifies auto increment, which means that the database  server itself provides values for this column. Each time a new row is added to  the table, the value for the id column is incremented automatically.  The title column’s data type is varchar, which is like a Java String.  The year column’s data type is int.   The price column’s data type is decimal. Java doesn’t have a decimal type,  so the values from this column are converted to double.   The create table statement specifies that the id column is the table’s  primary key. A primary key is a column  or a combination of columns  containing  a unique value for each row in a table. Every table should have a primary key.   The insert statements add data to the database. Each of these ten state- ments adds a row to the movie table. The syntax of the insert statements is  weird, because you first list all the columns that you want to insert data for  and then list the actual data. Each of the insert statements, for example,  inserts data for three columns: title, year, and price. The first insert  statement  the one in line 12  inserts the values "It's a Wonderful Life",  1946, and 14.95.  CHAPTER 3  Database for $100, Please      831   Querying a Database  To run this script in MySQL, start the MySQL Command Line Client from the Start  menu and then use a source command that names the script, as in this example:  mysql> source c:\data\create.sql  Note that the first time you run this script, you see an error message indicating  that the movies database can’t be dropped because it doesn’t exist. You can safely  ignore this error.  As the name Structured Query Language suggests, queries are what SQL is all about.  A  query  is  an  operation  performed  against  one  or  more  SQL  tables;  it  extracts  data from the tables and creates a result set, which contains the selected rows and  columns.  A crucial point to understand is that the result set is itself a table consisting of  rows and columns. When you query a database from a Java program, the result  set is returned to the program in an object created from the ResultSet class. This  class has methods that let you extract the data from each column of each row in  the result set.  Using a basic select statement  To query a database, you use the select statement. In this statement, you list the  table or tables from which you want to retrieve the data; the specific table columns  you want to retrieve  you may not be interested in everything that’s in the table ;  and other clauses that indicate which rows to retrieve, what order to present the  rows in, and so on. Here’s a simple select statement that lists all the movies in  the movie table:  select title, year     from movie     order by year;  In the following list, I take this statement apart piece by piece:   » select title, year names the columns you want to include in the   query result.   » from movie names the table from which you want to retrieve the rows.  832      BOOK 8  Files and Databases    » order by year indicates that the result is sorted by the year column so that   the oldest movie appears first.  In other words, this  select statement retrieves the  title and  year for all the  rows in the movie table and sorts them in year sequence. You can run this query  by typing it directly in the Command Line Client. Here’s what you get:  mysql> select title, year from movie order by year; +-------------------------+------+  title                    year  +-------------------------+------+  It's a Wonderful Life    1946   Young Frankenstein       1974   Star Wars                1977   The Princess Bride       1987   Glory                    1989   The Game                 1997   Shakespeare in Love      1998   Zombieland               2009   The King's Speech        2010   Star Trek Into Darkness  2013  +-------------------------+------+ 10 rows in set  0.00 sec   As you can see, the Command Line Client displays the rows returned by the select  statement. This feature can be very handy when you’re planning the select state- ments that your program needs, or when you’re testing a program that updates a  table and want to make sure that the updates are made correctly.  If  you  want  the  query  to  retrieve  all  the  columns  in  each  row,  you  can  use  an  asterisk instead of naming the individual columns, like so:  select * from movie order by year;  Using an asterisk in this manner isn’t a good idea, however, because the columns  that make up the table may change. If you use an asterisk, your program can’t deal  with changes in the table’s structure.  Both examples so far include an  order  by clause. In a SQL database, the rows  stored in a table aren’t assumed to be in any particular sequence. As a result, if  you want to display the results of a query in sequence, you must include an order  by in the select statement.  CHAPTER 3  Database for $100, Please      833   Narrowing the query  Suppose  that  you  want  to  find  information  about  one  particular  video  title.  To  select certain rows from a table, use the where clause in a select statement, as  in this example:  Here the select statement selects all the rows in which the year column is less  than or equal to 1980. The results are ordered by the year column.  Excluding rows  Perhaps  you  want  to  retrieve  all  rows  except  those  that  match  certain  criteria.  Here’s a query that ignores movies made in the 1970s  which is probably a good  idea :  mysql> select title, year from movie     ->     where year <= 1980     ->     order by year; +-----------------------+------+  title                  year  +-----------------------+------+  It's a Wonderful Life  1946   Young Frankenstein     1974   Star Wars              1977  +-----------------------+------+ 3 rows in set  0.00 sec   mysql> select title, year from movie     ->     where year   1979     ->     order by year; +-------------------------+------+  title                    year  +-------------------------+------+  It's a Wonderful Life    1946   The Princess Bride       1987   Glory                    1989   The Game                 1997   Shakespeare in Love      1998   Zombieland               2009   The King's Speech        2010   Star Trek Into Darkness  2013  +-------------------------+------+ 8 rows in set  0.01 sec   834      BOOK 8  Files and Databases   Using singleton selects  When you want to retrieve information for a specific row, mention the primary  key column in the where clause, like this:  mysql> select title, year from movie where id = 7; +---------------------+------+  title                year  +---------------------+------+  Shakespeare in Love  1998  +---------------------+------+ 1 row in set  0.49 sec   Here  the  where  clause  selects  the  row  whose  id  column  equals  7.  This  type  of  select  statement  is  called  a  singleton  select  because  it  retrieves  only  one  row.   Singleton selects are commonly used in Java programs to allow users to access or  update a specific database row.  Finding what something sounds like  Suppose  that  you  want  to  retrieve  information  about  a  movie  and  can’t  quite  remember the name, but you know that it includes the word princess. One of the  most interesting variations of the where clause throws in the word like, which  lets you search rows using wildcards. Here’s an example in which the percent sign   %  is a wildcard character:  mysql> select title, year from movie     ->     where title like "%princess%"; +--------------------+------+  title               year  +--------------------+------+  The Princess Bride  1987  +--------------------+------+ 1 row in set  0.01 sec   Using column functions  What if you want a count of the total number of movies in the movie table or a  count of the number of movies that were made before 1970? To do that, you use a  column function. SQL’s column functions let you make calculations on columns.   CHAPTER 3  Database for $100, Please      835   You  can  calculate  the  sum,  average,  or  largest  or  smallest  value,  or  count  the  number of values for an entire column.  Table 3-2 summarizes these functions. Note: The functions operate on the values  returned in a result set, which isn’t necessarily the entire table.  TABLE 3-2	  Function  Column Functions  Description  sum column-name   avg column-name   min column-name   max column-name   Adds the values in the column.  Calculates the average value for the column. Null values aren’t included  in the calculation.  Determines the lowest value in the column.  Determines the highest value in the column.  count column-name   Counts the number of rows that have data values for the column.  countDistinct column-name   Counts the number of distinct values for the column.  count *   Counts the number of rows in the result set.  To use one of these functions, specify the function rather than a column name in a  select statement. The following select statement calculates the number of rows  in the table and the year of the oldest movie:  mysql> select count * , min year  from movie; +----------+-----------+  count *   min year   +----------+-----------+        10       1946  +----------+-----------+ 1 row in set  0.00 sec   As you can see, ten movies are in the table, and the oldest was made in 1946.  If the  select statement includes a  where clause, only the rows that match the  criteria are included in the calculation. This statement finds out how many movies  in the table were made before 1970:  836      BOOK 8  Files and Databases   mysql> select count *  from movie where year < 1970; +----------+  count *   +----------+         1  +----------+ 1 row in set  0.00 sec   The result is 2.  Selecting data from more   than one table  In the real world, most select statements retrieve data from two or more tables.  Suppose  that  you  want  a  list  of  all  the  movies  you’ve  currently  loaned  out  to  friends. To do that, you have to create another table in your database that lists  your friends’ names and the ids of any movies they’ve borrowed. Here’s a create  table statement that creates just such a table:  create table friend       lastname varchar 50 ,     firstname varchar 50 ,     movieid int  ;  Now load it up with some data, like so:  insert into friend  lastname, firstname, movieid      values  "Haskell", "Eddie", 3 ; insert into friend  lastname, firstname, movieid      values  "Haskell", "Eddie", 5 ; insert into friend  lastname, firstname, movieid      values  "Cleaver", "Wally", 9 ; insert into friend  lastname, firstname, movieid      values  "Mondello", "Lumpy", 2 ; insert into friend  lastname, firstname, movieid      values  "Cleaver", "Wally", 3 ;  With that out of the way, you can get to the business of using both the friend and  movie tables in a single select statement. All you have to do is list both tables in   CHAPTER 3  Database for $100, Please      837   the from clause and then provide a condition in the where clause that correlates  the tables, as follows:  mysql> select lastname, firstname, title     ->     from movie, friend     ->     where movie.id = friend.movieid; +----------+-----------+--------------------+  lastname  firstname  title               +----------+-----------+--------------------+  Haskell   Eddie      Star Wars            Haskell   Eddie      Glory                Cleaver   Wally      The King's Speech    Mondello  Lumpy      Young Frankenstein   Cleaver   Wally      Star Wars           +----------+-----------+--------------------+ 5 rows in set  0.00 sec   Here you can see which movies have been loaned out and who has them. Notice  that the id and movieid columns in the where clause are qualified with the name  of the table the column belongs to.  Here’s a select statement that lists all the movies Eddie Haskell has borrowed:  mysql> select title from movie, friend     ->     where movie.id = friend.movieid     ->     and lastname = "Haskell"; +-----------+  title      +-----------+  Star Wars   Glory      +-----------+ 2 rows in set  0.00 sec   That rat has two of your best movies!  Notice in this example that you can refer to the friend table in the where clause,  even though you’re not actually retrieving any of its columns. You must still men- tion both tables in the from clause, however.  Eliminating duplicates  If you want to know just the names of all your friends who have a movie checked  out, you can do a simple select from the friend table, like this:  838      BOOK 8  Files and Databases   mysql> select lastname, firstname from friend; +----------+-----------+  lastname  firstname  +----------+-----------+  Haskell   Eddie       Haskell   Eddie       Cleaver   Wally       Mondello  Lumpy       Cleaver   Wally      +----------+-----------+ 5 rows in set  0.00 sec   This result set has a problem, however: Eddie Haskell and Wally Cleaver are listed  twice. Wouldn’t it be nice if you could eliminate the duplicate rows? Your wish is  granted in the next paragraph.  You can eliminate duplicate rows by adding the distinct keyword in the select  statement, as follows:  mysql> select distinct lastname, firstname from friend; +----------+-----------+  lastname  firstname  +----------+-----------+  Haskell   Eddie       Cleaver   Wally       Mondello  Lumpy      +----------+-----------+ 3 rows in set  0.07 sec   Notice  that  no  duplicates  appear;  each  distinct  name  appears  only  once  in  the  result set.  Updating and Deleting Rows  You’ve already seen how to create databases, insert rows, and retrieve result sets.  All that remains now is updating and deleting data in a table. For that, you use the  update and delete statements, as described in the following sections. I explain  the delete statement first because its syntax is simpler.  CHAPTER 3  Database for $100, Please      839   Using the delete statement  The basic syntax of the delete statement is  delete from table-name where condition;  Here’s a statement that deletes the movie whose id is 10:  mysql> delete from movie where id = 10; Query OK, 1 row affected  0.44 sec   Notice that the Command Line Client shows that this statement affected one line.  You can confirm that the movie was deleted by following up with a select state- ment, like so:  mysql> select * from movie; +----+-----------------------+------+-------+  id  title                  year  price  +----+-----------------------+------+-------+   1  It's a Wonderful Life  1946  14.95    2  Young Frankenstein     1974  16.95    3  Star Wars              1977  17.95    4  The Princess Bride     1987  16.95    5  Glory                  1989  14.95    6  The Game               1997  14.95    7  Shakespeare in Love    1998  19.95    8  Zombieland             2009  18.95    9  The King's Speech      2010  17.85  +----+-----------------------+------+-------+ 9 rows in set  0.00 sec   As you can see, movie 10 is gone.  If the where clause selects more than one row, all the selected rows are deleted,  as in this example:  mysql> delete from friend where lastname = "Haskell"; Query OK, 2 rows affected  0.45 sec   A quick query of the friend table shows that both records for Eddie Haskell are  deleted, like so:  840      BOOK 8  Files and Databases   mysql> select * from friend; +----------+-----------+---------+  lastname  firstname  movieid  +----------+-----------+---------+  Cleaver   Wally            9   Mondello  Lumpy            2   Cleaver   Wally            3  +----------+-----------+---------+ 3 rows in set  0.00 sec   If  you  don’t  include  a  where  clause,  the  entire  table  is  deleted.  This  statement  deletes all the rows in the movie table:  mysql> delete from movie; Query OK, 9 rows affected  0.44 sec   A quick select of the movie table confirms that it is now empty, as follows:  mysql> select * from movie; Empty set  0.00 sec   Fortunately, you can just run the create.sql script again to create the table.  Using the update statement  The update statement selects one or more rows in a table and then modifies the  value of one or more columns in the selected rows. Its syntax is this:  update table-name     set expressions...     where condition;  The  set  expressions  resemble  Java  assignment  statements.  Here’s  a  statement  that changes the price of movie 8 to 18.95:  mysql> update movie set price = 18.95 where id = 8; Query OK, 1 row affected  0.44 sec  Rows matched: 1  Changed: 1  Warnings: 0  CHAPTER 3  Database for $100, Please      841   You can use a quick  select statement to verify that the price was changed, as  follows:  mysql> select id, price from movie; +----+-------+  id  price  +----+-------+   1  14.95    2  16.95    3  17.95    4  16.95    5  14.95    6  14.95    7  19.95    8  18.95    9  17.85  +----+-------+ 9 rows in set  0.00 sec   To update more than one column, use commas to separate the expressions. Here’s  a statement that changes Eddie Haskell’s name in the friend table:  Again, a quick select shows that the rows are properly updated, as follows:  mysql> update friend set lastname = "Bully",     ->     firstname = "Big"     ->     where lastname = "Haskell"; Query OK, 2 rows affected  0.46 sec  Rows matched: 2  Changed: 2  Warnings: 0  mysql> select firstname, lastname from friend; +-----------+----------+  firstname  lastname  +-----------+----------+  Big        Bully      Big        Bully      Wally      Cleaver    Lumpy      Mondello   Wally      Cleaver   +-----------+----------+ 5 rows in set  0.00 sec   842      BOOK 8  Files and Databases   One final trick with the update statement you should know about is that the set  expressions can include calculations. The following statement increases the prices  of all the movies by 10 percent:  mysql> update movie set price = price * 1.1; Query OK, 10 rows affected  0.46 sec  Rows matched: 10  Changed: 10  Warnings: 0  Here’s a select statement to verify that this update worked:  mysql> select id, price from movie; +----+-------+  id  price  +----+-------+   1  16.45    2  18.65    3  19.75    4  18.65    5  16.45    6  16.45    7  21.95    8  20.85    9  19.64   10  21.95  +----+-------+ 10 rows in set  0.01 sec   CHAPTER 3  Database for $100, Please      843    IN THIS CHAPTER  » Configuring JDBC drivers   » Creating a connection   » Executing SQL statements   » Retrieving result data   » Updating and deleting data  Chapter 4 Using JDBC to Connect  to a Database  JDBC — Java Database Connectivity — is a Java feature that lets you connect to   almost any relational database system, execute SQL commands, and process  the results, all from within a Java program. In this chapter, you set up JDBC   and use it to access data in a MySQL database.  If  you  aren’t  familiar  with  the  basics  of  SQL,  read  the  previous  chapter  before  tackling this chapter.  Setting Up a Driver  Before  you  can  write  a  Java  program  to  access  a  database  via  JDBC,  you  must  first install a driver that links Java’s database API classes to an actual database.   Correctly setting up the driver can be tricky, but once you get it working, accessing  the database is easy.  To  install  the  JDBC  driver  for  MySQL,  browse  to  www.mysql.com products   connector and click the link for JDBC Driver for MySQL  Connector J . Then  follow   CHAPTER 4  Using JDBC to Connect to a Database      845   the  instructions  provided  to  download  and  install  the  binary  version  of  the  installer.  Connecting to a Database  Before  you  can  use  JDBC  to  access  a  SQL  database,  you  must  first  establish  a   connection to the database. The first step to establishing a connection involves  registering the driver class so the class is available. To do that, use the forName  method of the Class class, specifying the package and class name of the driver.  To register the MySQL connector, use this statement:  Class.forName "com.mysql.jdbc.Driver" ;  To register the standard ODBC driver, use this statement instead:  Class.forName "sun.jdbc.odbc.JdbcOdbcDriver" ;  Note that the forName method throws ClassNotFoundException, so you have to  enclose this statement in a try catch block that catches ClassNotFoundException.  After you register the driver class, you can call the static getConnection method of  the DriverManager class to open the connection. This method takes three String  parameters: the database URL, the username, and a password. Here’s an example:  String url = "jdbc:mysql:  localhost Movies"; String user = "root"; String pw = "pw"; con = DriverManager.getConnection url, user, pw ;  The URL parameter has the following syntax:  jdbc:subprotocol:subname  where subprotocol is mysql for a MySQL database and odbc for an ODBC driver.  The subname is the database name. For a MySQL database, this can be a complete  URL, but for a database on your own computer, just specify   localhost  plus the  name of the database.  For  ODBC,  you  use  the  name  you  used  when  you  created  the  data  source.  For  example:  String url = "jdbc:odbc:Movies";  846      BOOK 8  Files and Databases   The  user  and  password  parameters  must  also  be  valid  for  the  database  server  you’re using. For testing purposes on a MySQL database, you can use root and the  password you created when you installed MySQL.  Note: In the examples that follow, I assume the root password is PassWord, but you  should use whatever password you created when you installed MySQL. For ODBC,  use admin with no password for testing.  Note  that  the  getConnection  method  throws  SQLException,  so  you  need  to  enclose it in a try catch block statement that catches this exception.  Putting  it  all  together,  here’s  a  method  that  returns  a  Connection  object  that   connects to the movies database in MySQL:  private static Connection getConnection   {    Connection con = null;    try    {       Class.forName "com.mysql.jdbc.Driver" ;       String url = "jdbc:mysql:  localhost Movies";       String user = "root";       String pw = "PassWord";       con = DriverManager.getConnection url, user, pw ;    }    catch  ClassNotFoundException e     {       System.out.println e.getMessage   ;       System.exit 0 ;    }    catch  SQLException e     {       System.out.println e.getMessage   ;       System.exit 0 ;    }    return con; }  You  can  find  these  classes  —  and  the  other  classes  for  working  with  SQL   databases — in the java.sql package. As a result, you have to include an import  statement that specifies this package in any program that uses JDBC.  CHAPTER 4  Using JDBC to Connect to a Database      847   Querying a Database  After you establish a connection to a database, you can execute select statements  to retrieve data. To do so, you have to use several classes and interfaces:   » Connection: The Connection class has two methods you’re likely to use. The   close method closes the connection, and the createStatement method  returns a Statement object, which you then use to execute statements.   » Statement: The Statement interface contains the methods necessary to send  statements to the database for execution and return the results. In particular,  you use the executeQuery method to execute a select statement or the  executeUpdate method to execute an insert, update, or delete statement.  » ResultSet: The ResultSet interface represents rows returned from a query.  It provides methods you can use to move from row to row and to get the data  for a column.  Table  4-1  lists  the  methods  of  the  Connection  class  and  the  Statement  inter- face  you  use  to  execute  queries.   You  find  out  about  the  many  methods  of  the  ResultSet interface later in this chapter, in the section “Navigating through the  result set.”   TABLE 4-1	  Connection and Statement Methods  Connection Class Method  Description  void close    Closes the connection.  Statement createStatement    Creates a Statement object that can execute a SQL statement  on the database connected by the connection.  Statement createStatement int  type, int concur   Creates a Statement object that can execute a SQL statement  on the database connected by the connection.  Statement Interface Methods  Description  ResultSet  executeQuery String sql   ResultSet  executeQuery String sql   int executeUpdate String sql   Executes the select statement contained in the string  parameter and returns the result data as a ResultSet object.  Executes the select statement contained in the string  parameter and returns the result data as a ResultSet object.  Executes the insert, update, or delete statements  contained in the string parameter and returns the result data  as a ResultSet object.  848      BOOK 8  Files and Databases   The first parameter of the createStatement method specifies the type of result  set that is created, and can be one of the following:  ResultSet.TYPE_FORWARD_ONLY ResultSet.TYPE_SCROLL_INSENSITIVE ResultSet.TYPE_SCROLL_SENSITIVE  ResultSet.CONCUR_READ_ONLY ResultSet.CONCUR_UPDATABLE  The second parameter indicates whether the result set is read-only or updatable,  and can be one of the following:  Executing a select statement  The following snippet executes a select statement and gets the result set:  Statement s = con.createStatement  ; String select = "Select title, year, price "     + "from movie order by year"; ResultSet rows = s.executeQuery select ;  Here the result set is stored in the rows variable.  Navigating through the result set  The ResultSet object returned by the executeQuery statement contains all the  rows that are retrieved by the select statement. You can access only one of those  rows at a time. The result set maintains a pointer called a cursor to keep track of  the current row. You can use the methods shown in Table 4-2 to move the cursor  through a result set.  TABLE 4-2	  Navigation Methods of the ResultSet Interface Method  Description  void close    void last    int getRow    boolean next    Closes the result set.  Moves the cursor to the last row.  Gets the current row number.  Moves to the next row.  CHAPTER 4  Using JDBC to Connect to a Database      849   The following snippet shows how you can structure code that processes each row  in a result set:  while rows.next    {        process the current row }  All you have to do is replace the comment with statements that retrieve data from  the result set and process it, as described in the next section.  Getting data from a result set  Table 4-3 lists the methods of the  ResultSet interface  you can use to retrieve  data from the current row. As you can see, each of these methods comes in two  versions: One specifies the column by name, the other by index number. If you  know the index number, using it to access the column values is more efficient  than using the column names.  TABLE 4-3	  Method  Get Methods of the ResultSet Interface  BigDecimal getBigDecimal String  columnName   BigDecimal getBigDecimal int columnIndex   boolean getBoolean String columnName   boolean getBoolean int columnIndex   Description  Gets the value of the specified column as a  BigDecimal.  Gets the value of the specified column as a  BigDecimal.  Gets the value of the specified column as a   boolean.  Gets the value of the specified column as a   boolean.  Date getDate String columnName   Gets the value of the specified column as a Date.  Date getDate int columnIndex   Gets the value of the specified column as a Date.  double getDouble String columnName   Gets the value of the specified column as a double.  double getDouble int columnIndex   Gets the value of the specified column as a double.  float getFloat String columnName   Gets the value of the specified column as a float.  float getFloat int columnIndex   Gets the value of the specified column as a float.  850      BOOK 8  Files and Databases   Method  Description  int getInt String columnName   Gets the value of the specified column as an int.  int getInt int columnIndex   Gets the value of the specified column as an int.  long getLong String columnName   Gets the value of the specified column as a long.  long getLong int columnIndex   Gets the value of the specified column as a long.  short getShort String columnName   Gets the value of the specified column as a short.  short getShort int columnIndex   Gets the value of the specified column as a short.  String getString String columnName   Gets the value of the specified column as a String.  String getString int columnIndex   Gets the value of the specified column as a String.  Here’s a bit of code that gets the title, year, and price for the current row:  String title = row.getString "title" ; int year = row.getInt "year" ; double price = row.getDouble "price" ;  The following code does the same thing, assuming the columns appear in order:  String title = row.getString 1 ; int year = row.getInt 2 ; double price = row.getDouble 3 ;  Note that unlike almost every other index in Java, column indexes start with 1,  not 0.  Putting it all together: A program  that reads from a database  Now that you’ve seen the various elements that make up a program that uses JDBC  to query a database, Listing 4-1 shows a program that reads data from the movies  database and lists it on the console. When you run this program, the following  appears on the console:  1946: It's a Wonderful Life  $16.45  1974: Young Frankenstein  $18.65  1977: Star Wars  $19.75  1987: The Princess Bride  $18.65   CHAPTER 4  Using JDBC to Connect to a Database      851   1989: Glory  $16.45  1997: The Game  $16.45  1998: Shakespeare in Love  $21.95  2009: Zombieland  $20.85  2010: The King's Speech  $19.64  2013: Star Trek Into Darkness  $21.95   Note that you may also get a message suggesting that you should install an SSL  certificate to provide more secure access to the MySQL database. For the purpose  of testing JDBC, you can ignore this message.  LISTING	4-1:	  The Movie Listing Program  import java.sql.*; import java.text.NumberFormat; public class ListMovies {     public static void main String[] args       {         NumberFormat cf = NumberFormat.getCurrencyInstance  ;         ResultSet movies = getMovies  ;         try         {             while  movies.next                {                 Movie m = getMovie movies ;                 String msg = Integer.toString m.year ;                 msg += ": " + m.title;                 msg += "  " + cf.format m.price  + " ";                 System.out.println msg ;             }         }         catch  SQLException e          {             System.out.println e.getMessage   ;         }     }     private static ResultSet getMovies        {         Connection con = getConnection  ;         try         {             Statement s = con.createStatement  ;             String select = "Select title, year, price "  →6  →28  852      BOOK 8  Files and Databases                   + "from movie order by year";             ResultSet rows;             rows = s.executeQuery select ;             return rows;         }         catch  SQLException e          {             System.out.println e.getMessage   ;         }         return null;     }     private static Connection getConnection        {         Connection con = null;         try         {             Class.forName "com.mysql.jdbc.Driver" ;             String url = "jdbc:mysql:  localhost Movies";             String user = "root";             String pw = "PassWord";             con = DriverManager.getConnection url, user, pw ;         }         catch  ClassNotFoundException e          {             System.out.println e.getMessage   ;             System.exit 0 ;          }         catch  SQLException e          {             System.out.println e.getMessage   ;             System.exit 0 ;         }         return con;     }     private static Movie getMovie ResultSet movies       {         try         {             String title = movies.getString "Title" ;             int year = movies.getInt "Year" ;             double price = movies.getDouble "Price" ;             return new Movie title, year, price ;         }         catch  SQLException e   →46  →70  CHAPTER 4  Using JDBC to Connect to a Database      853   continued    LISTING	4-1:	   continued           {             System.out.println e.getMessage   ;         }         return null;     }     private static class Movie      {         public String title;         public int year;         public double price;         public Movie String title, int year, double price          {             this.title = title;             this.year = year;             this.price = price;         }     } }  →86  The following paragraphs describe the basics of how this program works: →6   The main method begins by calling the getMovies method to get a  ResultSet object that contains the movies to be listed. Then a while  loop reads each row of the result set. The getMovie method is called to  create a Movie object from the data in the current row. Then an output  string is created and sent to the console. The loop is contained in a try  catch statement because the next method may throw SQLException.  →28   →46   →70   The getMovies method is responsible for getting a database connection,  and then querying the database to get the movies. The first task is  delegated to the getConnection method. Then a Statement is created  and executed with the following select statement:  select title, year, price from movie order by year  Then the result set is returned to the main method.  The getConnection method creates a Connection object to the  database. Note that the user ID and password are hard-coded into this  method. In a real application, you get this information from the user or  from a configuration file.  The getMovie method extracts the title, year, and price from the current  row and uses these values to create a Movie object.  854      BOOK 8  Files and Databases   →86   The Movie class is created as an inner class. To keep this application  simple, this class uses public fields and a single constructor that initializes  the fields with the values passed as parameters.  Updating SQL Data  Besides  executing  select  statements,  you  can  also  use  a  Statement  object  to   execute  insert,  update,  or  delete  statements  as  well.  To  do  that,  call  the  executeUpdate  method  instead  of  the  executeQuery  method.  This  method  returns an int value that indicates how many rows were updated. You can test the  return value to determine whether the data was properly updated.  Here’s a method that accepts a movie ID, a last name, and a first name, and then  inserts a row into the friend table:  private static void loanMovie int id, String lastName,     String firstName  {     Connection con = getConnection  ;     try     {         Statement stmt = con.createStatement  ;         String insert = "insert into friend "             + " lastname, firstname, movieid  "             + "values  "             + "\"" + lastName + "\", \""             + firstName + "\", " +             + id + " ";         int i = stmt.executeUpdate insert ;         if  i == 1              System.out.println "Loan recorded." ;         else             System.out.println "Loan not recorded." ;     }     catch  SQLException e      {         System.out.println e.getMessage   ;         System.exit 0 ;     } }  CHAPTER 4  Using JDBC to Connect to a Database      855   Using an Updatable RowSet Object  The  getConnection  method  called  at  the  start  of  this  method  is  the  same  get  Connection  method  in  Listing  4-1.  After  a  connection  is  created,  a  Statement  object is created, and an insert statement is constructed using the values passed  via the parameters. For example, if you pass id  3, last name Haskell, and first  name Eddie, the following insert statement is built:  Insert into friend  lastname, firstname, movieid      Values  "Haskell", "Eddie", 3   Then the executeUpdate method is called to execute the insert statement. An if  statement is used to determine whether the row is inserted.  You can execute update or delete statements in the same manner.  While you’re testing database code that executes SQL statements constructed from  strings like this, throw in a System.out.println call to print the statement to the  console. That way, you can verify that the statement is being created properly.  If you’re using a newer JDBC driver  one that supports JDBC 2.0 or later , you have  another option for updating data: with an updatable result set. With an updatable  result set, you can change data in a result set row, add a row to the result set, or  delete a row from the result set. When you do, the updates are automatically writ- ten back to the underlying database.  To  create  an  updatable  result  set,  you  must  specify  the  ResultSet.CONCUR_  UPDATABLE field on the createStatement method when you create the Statement  object, like this:  Statement stmt = con.createStatement      ResultSet.TYPE_SCROLL_SENSITIVE,     ResultSet.TYPE_CONCUR_UPDATABLE ;  The first parameter indicates that the result set is scrollable, which means you  can move the cursor backward and forward through the result set. You can use the  methods listed in Table 4-4 to scroll the result set. This parameter also indicates  that  the  result  set  can  be  synchronized  with  the  database  so  that  any  changes  made by other users are reflected in the result set.  856      BOOK 8  Files and Databases   TABLE 4-4	  Method  Methods for Scrollable Result Sets  Description  boolean absolute int row   Moves the cursor to the given row number in this ResultSet object.  void afterLast    void beforeFirst    Moves the cursor to the end of this ResultSet object, just after  the last row.  Moves the cursor to the front of this ResultSet object, just before the  first row.  boolean first    Moves the cursor to the first row in this ResultSet object.  boolean last    boolean next    Moves the cursor to the last row in this ResultSet object.  Moves the cursor down one row from its current position.  boolean previous    Moves the cursor to the previous row in this ResultSet object.  boolean relative int rows  Moves the cursor a relative number of rows, either positive or negative.  The second parameter indicates that the result set is updatable, and any changes  you  make  to  the  result  set  are  automatically  written  back  to  the  database.  You  can use any of the methods listed in Table 4-5 to update the result set, and thus  update the underlying database.  TABLE 4-5	  Method  Methods for Updatable Result Sets  Description  void cancelRowUpdates    Cancels the updates made to the current row in this  ResultSet object.  void deleteRow    void insertRow    Deletes the current row from this ResultSet object and from the  underlying database.  Inserts the contents of the insert row into this ResultSet object and  into the database.  void moveToCurrentRow    Moves the cursor to the remembered cursor position, usually the  current row.  void moveToInsertRow    Moves the cursor to the insert row.  void refreshRow    void updateRow    Refreshes the current row with its most recent value in the database.  Updates the underlying database with the new contents of the current  row of this ResultSet object.  CHAPTER 4  Using JDBC to Connect to a Database      857   Deleting a row  To delete a row from a result set, use one of the navigation methods in Table 4-4  to move to the row you want to delete, and then use the deleteRow method to  delete the row. Here’s code that deletes the third row in the result set:  Updating the value of a row column  To update the value of a row column, navigate to the row you want to update, and  then use one of the updater methods listed in Table 4-6 to change one or more  column values. Finally, call updateRow to apply the changes. For example:  try {     rs.absolute 3 ;     rs.deleteRow  ; } catch  SQLException e  {     System.out.println e.getMessage   ;     System.exit 0 ; }  try {     rs.absolute 6 ;     rs.updateInt "year", 1975 ;     rs.updateRow  ; } catch  SQLException e  {     System.out.println e.getMessage   ;     System.exit 0 ; }  Here the year column of the sixth row in the result set is changed to 1975.  858      BOOK 8  Files and Databases   TABLE 4-6	  Update by Column Name  Update Methods of the ResultSet Interface Update by Column Index  void updateBigDecimal String columnName,  BigDecimal value   void updateBigDecimal int columnIndex,  BigDecimal value   void updateBoolean String columnName,  boolean value   void updateBoolean int columnIndex,  boolean value   void updateDate String columnName,  Date value   void updateDate int columnIndex,  Date value   void updateDouble String columnName,  double value   void updateDouble int columnIndex,  double value   void updateFloat String columnName,  float value   void updateFloat int columnIndex,  float value   void updateInt String columnName,  int value   void updateInt int columnIndex,  int value   void updateLong String columnName,  long value   void updateLong int columnIndex,  long value   void updateShort String columnName,  short value   void updateShort int columnIndex,  short value   void updateString String columnName,  String value   void updateString int columnIndex,  String value   Inserting a row  To insert a row, you use a special row in the result set called the insert row. First,  call the moveToInsertRow method to move the cursor to the insert row. Then use  update methods to set the value for each column in the insert row. You then call  the insertRow method to copy the insert row into the result set, which in turn  writes  a  new  row  to  the  database.  And  finally,  call  moveToCurrentRow  to  move  back to the previous position in the result set.  Here’s an example:  try {     rs.moveToInsertRow  ;     rs.updateString "title",         "Monty Python and the Holy Grail" ;  CHAPTER 4  Using JDBC to Connect to a Database      859       rs.updateInt "year", 1975 ;     rs.updateDouble "price", 13.95 ;     rs.insertRow  ;     rs.moveToCurrentRow  ; } catch  SQLException e  {     System.out.println e.getMessage   ;     System.exit 0 ; }  860      BOOK 8  Files and Databases   IN THIS CHAPTER  » Understanding XML   » Defining structure with DTD   » Looking at DOM and SAX   » Reading a document into memory   » Navigating a document   » Getting attribute and element values  Chapter 5 Working with XML  Defining XML  In  this  chapter,  you  find  out  how  to  work  with  Extensible  Markup  Language    XML   —  the  best  thing  to  happen  to  computing  since  the  invention  of  the   vacuum tube  at least, according to some overenthusiastic prognosticators .  This chapter focuses on the basics of reading an XML document into memory and  extracting data from it. With the background in this chapter, you shouldn’t have  much trouble studying the API documentation on your own to find out more about  XML programming.  Most computer-industry pundits agree that XML will completely change the way  you work with computers. Here are just some of the ways XML will revolutionize  the world of computers:   » Unlock the vast warehouses of data that are locked up in the vaults of   corporate mainframe computers   » Enable every electronic device on the planet, from the most complex    supercomputers to desktop computers to cellphones to wristwatches, to  communicate with one another  CHAPTER 5  Working with XML      861    » Allow every computer program ever written to exchange data with every   other computer program ever written   » Probably cure cancer and solve the budget deficit, too  So what is XML, really? Simply put, XML is a way to store and exchange informa- tion in a standardized way that’s easy to create, retrieve, and transfer between  different types of computer systems or programs.  When XML is stored in a file, the file is usually given the extension .xml.  Yawn.  Tags  Like Hypertext Markup Language  HTML , XML uses tags to mark the data. Here’s  a bit of XML that describes a book:       Java All-In-One For Dummies     Lowe     This chunk of XML defines an element called Book, which contains information  for a single book. The Book element in turn contains two subordinate elements:  Title and Author.  Notice that each element begins with a tag that lists the element’s name. This tag  is called the start tag. The element ends with an element that repeats the element  name, preceded by a slash — an end tag.  Everything that appears between the start tag and the end tag is the element’s  content, which can consist of text data or of one or more additional elements. In  the latter case, the additional elements nested within an element are called child  elements, and the element that contains them is called the parent element.  The highest-level element in an XML document is called the root element. A prop- erly formed XML document consists of a single root element, which can contain  elements  nested  within  it.  Suppose  that  you  want  to  create  an  XML  document  with information about two movies. The XML document might look something  like this:         862      BOOK 8  Files and Databases        It's a Wonderful Life       1946       14.95               Young Frankenstein       1974       16.95         Here the root element named Movies contains two Movie elements, each of which  contains Title, Year, and Price elements.  Although XML superficially resembles HTML, you find two key differences:   » The tags used in HTML indicate the format of data that displays, whereas tags  in an XML document indicate the meaning of the data. HTML has tags such as    and   that indicate whether data is bold or italic, for example. By  contrast, an XML document that holds information about books may have  tags such as   and   that provide the title and author  of the book.   » The tags used in an HTML document are set in stone, whereas you can make  up any tags you want to use in an XML document. If you’re creating an XML  document about cars, you may use tags such as  ,  , and   . But if you’re creating an XML document about classes taught at a  university, you may use tags such as  ,  ,  ,   , and  .  Attributes  Instead  of  using  child  elements,  you  can  use  attributes  to  provide  data  for  an   element. An attribute is a name-and-value pair that’s written inside the start tag  for an element. Here’s a Movie element that uses an attribute instead of a child  element to record the year:       It's a Wonderful Life     14.95     Whether you use attributes or child elements is largely a matter of personal pref- erence. Many XML purists say that you should avoid using attributes or use them   CHAPTER 5  Working with XML      863     L M X h t i w g n k r o W  i      only to identify data such as identification numbers or codes; others suggest using  attributes freely. In my experience, a few attributes here and there don’t hurt, but  for the most part I avoid using them.  The XML declaration  Every XML file should begin with an XML declaration that identifies the version of  XML being used. For most XML documents, the declaration should look like this:     Note that the XML declaration does not require an end tag. The XML declaration  should be the first line in the file.  The movies.xml file  For your reference, Listing 5-1 shows the movies.xml file, which the programs  that appear later in this chapter use.  LISTING 5-1:   The movies.xml File               It's a Wonderful Life       14.95               Young Frankenstein       16.95               Star Wars       17.95               The Princess Bride       16.95               Glory       14.95       864      BOOK 8  Files and Databases            The Game       14.95               Shakespeare in Love       19.95               Zombieland       18.95               The King's Speech       17.95               Star Trek Into Darkness       19.95         Using a DTD  An XML document can have a DTD, which spells out exactly what elements can  appear  in  an  XML  document  and  in  what  order  the  elements  can  appear.  DTD  stands for Document Type Definition, but that won’t be on the test.  A DTD for an XML document about movies, for example, may specify that each  Movie element must have Title and Price subelements and an attribute named  year. It can also specify that the root element must be named Movies and consist  of any number of Movie elements.  The main purpose of the DTD is to spell out the structure of an XML document so  that users of the document know how to interpret it. Another, equally important  use of the DTD is to validate the document to make sure that it doesn’t have any  structural errors. If you create a Movies XML document that has two titles for a  movie, for example, you can use the DTD to detect the error.     L M X h t i w g n k r o W  i     You can store the DTD for an XML document in the same file as the XML data,  but more often, you store the DTD in a separate file. That way, you can use a DTD   CHAPTER 5  Working with XML      865   to govern the format of several XML documents of the same type. To indicate the  name of the file that contains the DTD, you add a   declaration to the  XML document. Here’s an example:     Here the XML file is identified as a Movies document, whose DTD you can find in  the file movies.dtd. Add this tag near the beginning of the movies.xml file, right  after the   tag.  Listing 5-2 shows a DTD file for the movies.xml file that was shown in Listing 5-1.  LISTING 5-2:  A DTD File for the movies.xml File               Each of the ELEMENT tags in a DTD defines a type of element that can appear in the  document and indicates what can appear as the content for that element type. The  general form of the ELEMENT tag is this:     Use the rules listed in Table 5-1 to express the content.  The first ELEMENT tag in the DTD I show in Listing 5-2, for example, says that a  Movies element consists of zero or more Movie elements. The second ELEMENT tag  says that a Movie element consists of a Title element followed by a Price ele- ment. The third and fourth ELEMENT tags say that the Title and Price elements  consist of text data.  If this notation looks vaguely familiar, that’s because it’s derived from regular  expressions.  The ATTLIST tag provides the name of each attribute. Its general form is this:     866      BOOK 8  Files and Databases   TABLE 5-1	  Specifying Element Content Description Content  The specified element can occur 0 or more times.  The specified element can occur 1 or more times.  The specified element can occur 0 or 1 time.  element1element2  Either element1 or element2 can appear.  element1, element2  element1 appears, followed by element2.  Text data is allowed.  Any child elements are allowed.  No child elements of any type are allowed.  element*  element+  element?  PCDATA  ANY  EMPTY  Here’s a breakdown of this tag:   » element names the element whose tag the attribute can appear in.  » attribute provides the name of the attribute.  » type specifies what can appear as the attribute’s value. The type can be any   of the items listed in Table 5-2.   » default provides a default value and indicates whether the attribute is  required or optional. default can be any of the items listed in Table 5-3.  Attribute Types  The Attribute Value . . .  Can be any character string.   string1string2...   Can be one of the listed strings.  TABLE 5-2	  Element  CDATA  NMTOKEN  NMTOKENS  ID  IDREF  IDREFS  Must be a name token, which is a string made up of letters and numbers.  Must be one or more name tokens separated by white space.  Is a name token that must be unique. In other words, no other element   in the document can have the same value for this attribute.  Must be the same as an ID value used elsewhere in the document.  Is a list of IDREF values separated by white space.     L M X h t i w g n k r o W  i     CHAPTER 5  Working with XML      867   TABLE 5-3	  Attribute Defaults Default  Optional or Required?  REQUIRED  IMPLIED  value  Required.  Optional.  Optional. This value is used if the attribute is omitted.  FIXED value Optional. If included, however, it must be this value,   and if omitted, this value is used by default.  Here’s the ATTLIST tag declaration from movies.dtd:     This  declaration  indicates  that  the  attribute  goes  with  the  Movie  element,  is  named year, can be any kind of data, and is required.  Here’s an ATTLIST tag that specifies a list of possible values along with a default:     This  form  of  the  ATTLIST  tag  lets  you  create  an  attribute  that’s  similar  to  an   enumeration, with a list of acceptable values.  Processing XML in Two Ways:   DOM and SAX  In general, you can use either of two approaches to process XML documents in a  Java program:   » DOM: Stands for Document Object Model. The basic idea of DOM is that you  read an entire XML document from a file into memory, where the document  is stored as a collection of objects that are structured as a tree. Then you can  process the elements of the tree  called nodes  however you want. If you  change any of the nodes, you can write the document back to a file.   » SAX: Stands for Simple API for XML. SAX is a read-only technique for process- ing XML that lets you read the elements of an XML document from a file and  react to them as they come. Because SAX doesn’t require you to store an  entire XML document in memory at one time, it’s often used for very large  XML documents.  868      BOOK 8  Files and Databases   In this section, I cover the basics of using DOM to retrieve information from an  XML document. DOM represents an XML document in memory as a tree of Node  objects. Figure 5-1 shows a simplified DOM tree for an XML document that has  two Movie elements. Notice that the root element  Movies  is a node, each Movie   element  is  a  node,  and  each  Title  and  Price  element  is  a  node.  In  addition,  text values are stored as child nodes of the elements they belong to. Thus, the  Title and Price elements each have a child node that contains the text for these  elements.  FIGURE 5-1:   A DOM   document tree.  Reading a DOM Document  Before  you  can  process  a  DOM  document,  you  have  to  read  the  document  into  memory from an XML file. You’d think that this would be a fairly straightforward  proposition, but unfortunately, it involves some pretty strange incantations. Rather  than go through all the classes and methods you have to use, I just look at the fin- ished code for a complete method that accepts a String containing a filename as  a parameter and returns a document object as its return value. Along the way, you  find out what each class and method does.     L M X h t i w g n k r o W  i     CHAPTER 5  Working with XML      869   Here’s a method that reads an XML file into a DOM document:  private static Document getDocument String name  {    try    {       DocumentBuilderFactory factory =           DocumentBuilderFactory.newInstance  ;       factory.setIgnoringComments true ;       factory.setIgnoringElementContentWhitespace true ;       factory.setValidating true ;       DocumentBuilder builder =           factory.newDocumentBuilder  ;       return builder.parse new InputSource name  ;    }    catch  Exception e     {       System.out.println e.getMessage   ;    }    return null; }  Creating a DocumentBuilderFactory  The first statement of the preceding example calls the newInstance method of the  DocumentBuilderFactory class to create a new DocumentBuilderFactory object.  The  job  of  the  DocumentBuilderFactory  is  to  create  DocumentBuilder  objects  that can read XML input and create DOM documents in memory.  Why  not  just  call  the  DocumentBuilderFactory  constructor?  It  turns  out  that  DocumentBuilderFactory is an abstract class, so it doesn’t have a constructor.  newInstance is a static method that determines which class to create an instance  of based on the way your system is configured.  Configuring the DocumentBuilderFactory  After you get a DocumentBuilderFactory, you can configure it to read the docu- ment the way you want. The next three statements configure three options that  are applied to document builders created by this factory object:  factory.setIgnoringComments true ; factory.setIgnoringElementContentWhitespace true ; factory.setValidating true ;  870      BOOK 8  Files and Databases   Here’s a closer look at these statements:   » The setIgnoringComments method tells the document builder not to  create nodes for comments in the XML file. Most XML files don’t contain  comments, but if they do, they’re not part of the data represented by the  document, so they can be safely ignored. Setting this option causes them to  be ignored automatically.  If you don’t set this option, a node is created for  each comment in the document, and because you can’t predict when or  where comments appear, your program has to check every node it processes  to make sure that the node isn’t a comment.    » The setIgnoringElementContentWhitespace method causes the   document builder to ignore any white space that isn’t part of a text  value. If you don’t include this option, the DOM document includes nodes  that represent white space. The only thing that these white space nodes are  good for is making the DOM document harder to process, so you should  always set this option.   » The setValidating method tells the document builder to validate the  input XML if it specifies a DTD. Validating the input can also dramatically  simplify your program, because you know that the DOM document conforms  to the requirements of the DTD. If you’re processing the movies.xml file shown  in Listing 5-1 earlier in this chapter, you know for certain that the first child   of a Movie element is a Title element and that the second child is a Price  element. Without the validation, all you know is that the first child of a Movie  element should be a Title element, but you have to check it to make sure.  Creating a document builder   and the document  After you set the options, you can call the newDocumentBuilder method to create  a document builder, as follows:  DocumentBuilder builder =     factory.newDocumentBuilder  ;  Here the document builder is referenced by a variable named builder.  Finally, you can create the DOM document by calling the parse method of the doc- ument builder. This method accepts an InputSource object as a parameter. Fortu- nately, the InputSource class has a constructor that takes a filename parameter  and returns an input source linked to the file. So you can create the input source,      L M X h t i w g n k r o W  i     CHAPTER 5  Working with XML      871   parse the XML file, create a DOM document, and return the DOM document to the  caller, all in one statement:  return builder.parse new InputSource name  ;  Note that several of these methods throw exceptions. In particular, newDocument  Builder throws ParserConfigurationException, and parse throws IOException  and SAXException. To keep this example simple, I caught all exceptions in one  catch clause and printed the exception message to the console.  Using the getDocument method  By adding the getDocument method, you can create a DOM document from a file  with a single statement, like this:  Document doc = getDocument "movies.xml" ;  Here the movies.xml file is read, and a DOM document is created and assigned to  the doc variable.  Also note that you must provide three import statements to use the getDocument  method, as follows:  import javax.xml.parsers.*; import org.w3c.dom.*; import org.xml.sax.*;  DocumentBuilder and  DocumentBuilderFactory are in the  javax.xml.parsers  package, Document is in org.w3c.dom, and InputSource is in org.xml.sax.  Reading DOM Nodes  After you have a DOM document in memory, you can easily retrieve data from the  document’s  nodes.  The  DOM  API  is  based  on  interfaces  rather  than  classes,  so  each node of the DOM document is represented by an object that implements one  or more DOM interfaces. The following paragraphs give you an overview of the  interfaces you need to work with:   » Document: The entire document is represented by an object that implements   the Document interface. The method you use most from this interface is  getDocumentElement, which returns an Element object that represents the   872      BOOK 8  Files and Databases   document’s root node. After you have the root node, you can navigate to  other nodes in the document to get the information you’re looking for.   » Node: The Node interface represents a node in the DOM document. This   interface provides methods that are common to all nodes. Table 5-4 lists the  most useful of these methods. This table also lists some of the field values  that the getNodeType method can return.  TABLE 5-4	  Method  The Node Interface Description  NodeList getChildNodes    Gets a NodeList object that contains all this node’s child nodes.  Node getFirstChild    Gets the first child of this node.  Node getLastChild    Gets the last child of this node.  int getNodeType    Gets an int that indicates the type of the node. The value can be   one of the fields listed later in this table.  String getNodeValue    Gets the value of this node, if the node has a value.  Node getNextSibling    Gets the next sibling node.  Node getPrevSibling    Gets the preceding sibling node.  boolean hasChildNodes    Determines whether the node has any child nodes.  Field  Description  ATTRIBUTE_NODE  The node is an attribute node.  CDATA_SECTION_NODE  The node has content data.  COMMENT_NODE  DOCUMENT_NODE  ELEMENT_NODE  TEXT_NODE  The node is a comment.  The node is a document node.  The node is an element node.  The node is a text node.     L M X h t i w g n k r o W  i      » Element: The Element interface represents nodes that correspond to   elements in the XML document. Element extends Node, so any object that  implements Element is also a Node. Table 5-5 lists some of the most useful  methods of this interface.  CHAPTER 5  Working with XML      873   TABLE 5-5	  Method  The Element Interface  Description  String getAttribute String name   Gets the value of the specified attribute.  NodeList getElementsBy  TagName String name   Gets a NodeList object that contains all the element nodes that  are contained within this element and have the specified name.  boolean hasAttribute String name   Determines whether the element has the specified attribute.   » Text: The text content of an element isn’t contained in the element itself, but  in a Text node that’s stored as a child of the element. The Text interface has  a few interesting methods you may want to look up, but for most applications,  you just use the getNodeValue method inherited from the Node interface to  retrieve the text stored by a text node.   » NodeList: A NodeList is a collection of nodes that’s returned by meth- ods such as the getChildNodes method of the Node interface or the get  ElementsByTagName of the Element interface. NodeList has just two  methods: item int i , which returns the node at the specified index,  and getLength  , which returns the number of items in the list.  As with  almost every other index in Java, the first node is index 0, not 1.   Processing elements  Assuming that you use a DTD to validate the XML file when you build the docu- ment, you can usually navigate the document to pick up the information you need  without resorting to NodeList objects. Here’s a routine that simply counts all the  Movie elements in the movies.xml file  shown in Listing 5-1 earlier in this chap- ter  after it’s been parsed into a Document object named doc:  int count = 0; Element root = doc.getDocumentElement  ; Node movie = root.getFirstChild  ; while  movie != null  {     count++;     movie = movie.getNextSibling  ; } System.out.println "There are " + count + " movies." ;  874      BOOK 8  Files and Databases   This method first calls the getFirstChild method to get the first child of the root  element.  Then  it  uses  each  child  element’s  getNextSibling  method  to  get  the  next element that’s also a child of the root element.  If you run a program that contains these lines, the following line appears on the  console:  There are 10 movies.  This  program  doesn’t  do  anything  with  the  Movie  elements  other  than  count  them, but in the next section  “Getting attribute values” , you see how to extract  data from the Movie elements.  An alternative way to process all the elements in the movies.xml file is to use the  getChildNodes method to return a NodeList object that contains all the elements.  Then you can use a for loop to access each element individually. Here’s a snippet  of code that lists the name of each element:  Element root = doc.getDocumentElement  ; NodeList movies = root.getChildNodes  ; for  int i = 0; i < movies.getLength  ; i++  {     Node movie = movies.item i ;     System.out.println movie.getNodeName   ; }  Here the item method is used in the for loop to retrieve each Movie element. If  you run a program that contains these lines, ten lines with the word Movie are  displayed on the console.  Getting attribute values  To get the value of an element’s attribute, call the getAttribute method and pass  the name of the attribute as the parameter. This code returns the string value of  the attribute. Then you can convert this value to another type if necessary. Note  that the value may include some white space, so you should run the value through  the trim method to get rid of any superfluous white space.  Here’s an example that gets the year attribute from each movie in the movies.xml  file and determines the year of the oldest movie in the collection:     L M X h t i w g n k r o W  i     Element root = doc.getDocumentElement  ; Element movie =  Element root.getFirstChild  ;  CHAPTER 5  Working with XML      875   int oldest = 9999; while  movie != null  {     String s = movie.getAttribute "year" ;     int year = Integer.parseInt s ;     if  year < oldest          oldest = year;     movie =  Element movie.getNextSibling  ; } System.out.println "The oldest movie in the file "     + "is from " + oldest + "." ;  The year attribute is extracted with these two lines of code:  String s = movie.getAttribute "year" ; int year = Integer.parseInt s ;  The first line gets the string value of the year attribute, and the second line con- verts it to an int.  Notice  the  extra  casting  that’s  done  in  this  method.  It’s  necessary  because  the  movie variable has to be an Element type so that you can call the getAttribute  method. The getNextSibling method returns a Node, however, not an Element.  As  a  result,  the  compiler  doesn’t  let  you  assign  the  node  to  the  movie  variable  unless you first cast it to an Element.  Getting child element values  You may be surprised to find that the text content of an element isn’t stored with  the element. Instead, it’s stored in a child node of type Text. Consider the follow- ing XML:   The Princess Bride   This element results in two nodes in the XML document: an Element node named  Title and a Text node that contains the text The Princess Bride.  Thus, if you have a Title element in hand, you must get the Text element before  you can get the text content, as in this example:  Node textElement = titleElement.getFirstChild  ; String title = textElement.getNodeValue  ;  876      BOOK 8  Files and Databases   If you prefer to write your code a little more tersely, you can use a single state- ment like this:  String title =     titleElement.getFirstChild  .getNodeValue  ;  If you find this incantation to be a little tedious, and you’re doing a lot of it in your  program, write yourself a little helper method, like this one:  private static String getTextValue Node n  {     return n.getFirstChild  .getNodeValue  ; }  Then  you  can  get  the  text  content  for  an  element  by  calling  the  getTextValue  method, like this:  String title = getTextValue titleElement ;  After you get the text content, you can parse it to a numeric type if you need to.  Putting It All Together: A Program   That Lists Movies  Now that you’ve seen the various interfaces and classes you use to get data from  an XML file, Listing 5-3 shows a complete program that reads the movies.xml file   shown in Listing 5-1 earlier in this chapter  and lists the title, year, and price of  each movie on the console. When you run this program, the following appears on  the console:  1946: It's a Wonderful Life  $14.95  1974: Young Frankenstein  $16.95  1977: Star Wars  $17.95  1987: The Princess Bride  $16.95  1989: Glory  $14.95  1997: The Game  $14.95  1998: Shakespeare in Love  $19.95  2009: Zombieland  $18.95  2010: The Kings Speech  $17.95  2013: Star Trek Into Darkness  $19.95      L M X h t i w g n k r o W  i     CHAPTER 5  Working with XML      877   LISTING	5-3:	  Reading an XML Document  →1  →11  →29  import javax.xml.parsers.*;  import org.xml.sax.*; import org.w3c.dom.*; import java.text.*; public class ListMoviesXML {     private static NumberFormat cf =         NumberFormat.getCurrencyInstance  ;     public static void main String[] args       {         Document doc = getDocument "movies.xml" ;         Element root = doc.getDocumentElement  ;         Element movieElement =  Element root.getFirstChild  ;         Movie m;         while  movieElement != null          {             m = getMovie movieElement ;             String msg = Integer.toString m.year ;             msg += ": " + m.title;             msg += "  " + cf.format m.price  + " ";             System.out.println msg ;             movieElement =                  Element movieElement.getNextSibling  ;         }     }     private static Document getDocument String name       {         try         {             DocumentBuilderFactory factory =                 DocumentBuilderFactory.newInstance  ;             factory.setIgnoringComments true ;     factory.setIgnoringElementContentWhitespace true ;             factory.setValidating true ;             DocumentBuilder builder =                 factory.newDocumentBuilder  ;             return builder.parse new InputSource name  ;         }         catch  Exception e          {             System.out.println e.getMessage   ;         }         return null;  878      BOOK 8  Files and Databases   →49  →65  →70      }     private static Movie getMovie Element e       {            get the year attribute         String yearString = e.getAttribute "year" ;         int year = Integer.parseInt yearString ;            get the Title element         Element tElement =  Element e.getFirstChild  ;         String title = getTextValue tElement .trim  ;            get the Price element         Element pElement =              Element tElement.getNextSibling  ;         String pString = getTextValue pElement .trim  ;         double price = Double.parseDouble pString ;         return new Movie title, year, price ;     }     private static String getTextValue Node n       {         return n.getFirstChild  .getNodeValue  ;     }     private static class Movie      {         public String title;         public int year;         public double price;         public Movie String title, int year, double price          {             this.title = title;             this.year = year;             this.price = price;         }     } }  Because all the code in this program appears elsewhere in this chapter, the fol- lowing paragraphs just provide a simple description of what each method in this  program does:   →1  Wow, that’s a lot of packages to import. Too bad that Java’s designers   couldn’t have put all these XML classes in one big package.   →11   The main method starts by calling the getDocument method to get a  Document object from the file movies.xml. Then it gets the root      L M X h t i w g n k r o W  i     CHAPTER 5  Working with XML      879   element and uses a while loop to spin through all the child elements,  which you know to be Movie elements because the document was  validated when it was parsed. As each Movie element is processed, it’s  passed to the getMovie method, which extracts the year attribute and  the title and price elements, and returns a Movie object. Then the  movie is printed on the console.  The getDocument method accepts a filename as a parameter and  returns a Document object. Before it creates the DocumentBuilder  object, it sets the configuration options so that comments and white  space are ignored and the XML file is validated. Because the XML file is  validated, you must create a DTD file  like the file in Listing 5-2 earlier in  this chapter . Also, you must begin the XML file with a DOCTYPE declara- tion  such as   .  The getMovie method is passed an Element object that represents a  Movie element. It extracts the year attribute, gets the text value of the  title element, and parses the text value of the price element to a  double. Then it uses these values to create a new Movie object, which is  returned to the caller.  The getTextValue method is simply a little helper method that gets the  text content from a node. This method assumes that the node has a  child node containing the text value, so you shouldn’t call this method  unless you know that to be the case.  Because the XML document was  validated, you do.   The Movie class is a private inner class that represents a single movie. It  uses public fields to hold the title, year, and price data, and it  provides a simple constructor that initializes these fields.   →29    →49    →65    →70   880      BOOK 8  Files and Databases   Index  Special Characters &  Numerics  −  minus sign , 99 − −  decrement operator , 100 !  not  logical operator, 141, 142–143 !=  not equals  relational operator, 130, 142 $  dollar sign , 55 %  percent sign , 99 %= operator, 111 &  and  logical operator, 141, 143–144 &&  conditional and  logical operator, 142,    143–144  *  asterisk , 64, 99, 765 *= operator, 111 .  dot , 361    forward slash , 99, 361  = operator, 111 ;  semicolon , 12, 51, 301, 352, 830 \  backslash , 79, 376 ^  Xor  logical operator, 142, 145–146 {}  braces , 12, 47–48, 54, 352   or  logical operator, 141, 144–145   pipe symbol , 518–519   conditional or  logical operator, 142, 144–145 +  plus sign , 100, 377 ++  increment operator , 100 += operator, 111, 377    angle brackets , 130    diamond  operator, 462 <= operator, 130 =  equal sign , 59, 108, 131 −= operator, 111 ==  equality  operator, 130, 131, 238, 377, 420 >  greater-than  symbol, 91 >= operator, 130 0 jar command option, 359 ‘  apostrophe , 376 "  double quote , 79, 376 ′  single quote , 79 3-D objects, JavaFX, 565  A  a format pattern, 555 abortCountDown method, 502–503 aborted field, 502 abs method, 114 absolute method, 857 abstract class defined, 301 Java API, 301 overview, 299–302 variable declarations, 301 Abstract Factory class, 301 abstract method, 300–301, 569 AbstractBorder class, 301 AbstractCollection class, 301 AbstractMap class, 301 accept method, 790 accessors  getter, 255–256 JavaBeans, 758 patterns, 257, 758 setter, 255–256  action attribute, 733 Action event, 620 action events, 573–574 ActionEvent class, 584, 589 ActionListener interface, 308, 309, 311 actionPerformed method, 308, 309 actions, 58 activeCount method, 478 Actor program, 262 add method  ArrayList class, 425, 429, 452 GridPane layout, 648 LinkedList class, 440, 443–444 ObservableList class, 686  addAll method  ArrayList class, 425 ChoiceBox class, 683 JavaFX, 627  Index      881   addAll method  continued   LinkedList class, 440 ObservableList class, 686, 688  addChoosableFileFilter method, 787, 790, 791 addColumn method, 648 addFirst method, 440 addItems method  GenQueue class, 458, 461 Stack class, 458  addLast method, 440, 443 addListener method, 688, 689 addQuantity method, 773 addRow method, 648 AddSubtract program  with anonymous inner classes, 593–594 EventHandler interface, 587–590 with inner classes, 591–593 with lambda expressions, 597–601  Add-Subtract scene, 612–613 afterLast method, 857 aggregate methods, streams, 468–469 alert box, 613–617 Alert class  AlertType parameter, 614 ButtonType parameter, 614–615 JavaFX, 613–617  AlertType parameter, 614 aload instruction, 31 alter SQL statement, 829 Amazon, 721 and  &  logical operator, 141, 143–144 angle brackets    , 130 animation, JavaFX, 565 anonymous inner class  creating, 347–349 defined, 347 example, 349–351 handling events with, 593–594  Apache Tomcat  configuring, 723–724 installing, 723–724 starting, 724–725 stopping, 724–725 testing, 725 website, 723 Zip file, 723  882      Java All-in-One For Dummies  API, Date-Time  class listing, 542 Java 8, 539 LocalDate class, 548–550 of method, 545–546 methods, 546 Month enumeration, 545–547 now method, 542–544 parse method, 544–545 ZoneID class, 547, 548  API, Java  class names and, 250 Cloneable interface, 308 disadvantages, 16–17 documentation, 32–33 importing classes, 63–64 overview, 10–11  apostrophe   ‘  , 376 append method, 389 applets, 11, 712 Application class, extending, 568–569 application scope setting, 767 applications. See programs args parameter, 784 argument files, 27–28 arithmetic operators combining, 104–105 compound assignment operators, 110–111 increment and decrement, 106–108 overview, 99–102 unary operators, 105–106  ArithmeticException, 214, 218, 220, 295 array list  capacity of, 427 creating, 427 defined, 424 elements  accessing elements, 429 adding elements, 428–429 deleting, 434–435, 438 inserting, 424–425 specifying elements, 427 updating, 432–433  printing, 430 sizes, 424   array of arrays, 401 ArrayList class  class declaration for, 451–452 constructors, 425–426 creating object, 427 delegation pattern, 282 methods, 317, 425–426 observable list, 687 overview, 424–426 printing, 430 storing data, 425  arrays  array of, 401 chessboard example, 408–415 comparing, 420 converting to strings, 420–421 copying, 417–419 creating, 394–395 defined, 74, 393 filling, 417 initializing, 395–396 jagged, 405–406 length of, 394 multi-dimensional, 407–408 overview, 393–394 school lockers example, 397–400 searching, 419–420 two-dimensional  accessing elements, 403–404 creating, 402–403 initializing, 405 overview, 401–402  using with enhanced for loops, 400 using with for loops, 396–397 using with methods, 401  Arrays class  binarySearch method, 419–420 deepEquals method, 420 equals method, 420 fill method, 417 methods, 416–417 overview, 416 toString method, 421–422  arrow operator, 351 arrows, 246–247 askForAnotherRound method, 204, 210 assigned statements, 71 assignment operators compound, 110–111 defined, 59 overview, 108–109  association, 247 asterisk  * , 64, 765 ATTLIST tag, 868 ATTRIBUTE_NODE field, 873 attributes JSP, 743 XML, 863–864 defaults, 868 defined, 863–864 types, 867 values, 875–878  @author JavaDoc tag, 364 automatic memory management, 15 average method, 469 avg column function, 836  B  \b escape sequence, 79, 376 backslash  \ , 79, 376 backspace  \b  escape sequence, 79, 376 BadActorApp program, 262 Ball class, 286–287, 301 BallFactoryInstance class, 301 base class, 242, 278 Baseball class, 285, 289 Basic, 9 basic constructors, 259–260 batch files, 41 beforeFirst method, 857 behavior, 10, 58, 240 BetterPlayer subclass, 294 BigDecimal class, 58–59 BigInteger class, 117 bin directory, 723  Index      883   bin folder, JDK, 24, 25 binary file, 800 binary operators, 101, 141–142 binary streams  classes for reading, 814 defined, 800 reading, 813–820 reading from data input stream, 815–817 reading from file, 817–820 writing, 820–826 writing to file, 823–827  binarySearch method, 416, 419–420 BirthdayFun program, 557–559 blocks  defined, 53, 87 initializer, 265–266 overview, 53–54  Book class, 773 BookCart class, 770–773 Boolean expressions, 130–131 Boolean operator, 141 boolean type overview, 79 primitive data types, 74 wrapper class, 80  -bootclasspath compiler option, 28 Border layout defined, 626 overview, 643  border pane, 575 BorderPane class  constructors, 644–645 creating object, 575–576 methods, 644–645 overview, 643 Pizza Order application, 674  BouncingBall class, 281 bounds checking, 15 boxing, 87 braces  {} , 12, 47, 54 break statement  for loops, 154, 155 switch statement, 183 switch statement, omitting in, 188–191  btnAdd button, 589  884      Java All-in-One For Dummies  btnAdd_Click method, 601 btnClose button, 620 btnClose_Click event, 621 btnClose_Clicked method, 618–619 btnOK_Click method, 657, 666 btnSubtract button, 589 btnSubtract_Click method, 601 buffer, 388 BufferedInputStream class, 813 BufferedOutputStream  description, 821 overview, 820  BufferedReader class constructors, 801–802 creating object, 802–803 methods, 801–802 overview, 801  BufferedWriter class  constructors, 809 description, 807  bulk data operations  defined, 464 example, 464–467 overview, 464 stream, 464  Burns, Robert, 16 business programs, 236 business rules layer, 243 Button class, 572–573 buttonClick method, 573–574 buttonClicked method, 572, 574 buttons  creating, 572–573 radio buttons  creating, 672, 673 defined, 671 toggle groups, 673  ButtonType parameter, 614–615 BuyMyBook.jsp, 769–770 byte type  parse method, 667 primitive data types, 74 size of, 75 wrapper class, 80 bytecode, defined, 8   C  c jar command option, 359 calculateNewPos method, 414 callback, 307–309 calling, 193 cancelRowUpdates method, 857 canRead method, 778 canWrite method, 778 capture groups, 517 CardDeck class, 305–306 CardGame interface, 304 carriage return  \r  escape sequence, 79 CarWashApp program, 188–190 CarWashStringApp program, 191–192 Cascading Style Sheets  CSS , 564–565 case constant, 185–186 case keyword, 183 cast operator, 86 casting  operand, 101 overview, 86  statement  catch block, 217, 219, 222, 223. See also try   catchBall method, 307 catch-or-throw compiler error, 227–228 catch-or-throw rule, 227 cbrt method, 114 C C++  integer values, 79 Java background, 7 Java versus, 12–13 memory leak, 15 size of integer data types, 75  CDATA attribute type, 867 CDATA_SECTION_NODE field, 873 ceil method, 120 CENTURIES, 553 change listener  adding, 689 defined, 688 selecting items, 689 sequence method, 688–689  changed method, 689 ChangeListener, 689  ChangeParameters program, 209 char type  overview, 78 primitive data types, 74 in switch statements, 185–186 wrapper class, 80  character class  custom, 512–513 defined, 509 ranges, 513–514 character streams  defined, 800 reading, 801–806 reading from file, 803–806 writing, 807–813  Character text box, 665–666 characters  extracting, 380–381 grouping with parentheses, 516–518 multiple, matching, 514–516 single, matching, 509 strings versus, 376  charAt method, 381, 389, 391 CharSequence interface, 391 check boxes  checked state, 669 creating, 669–670 defined, 668 undefined state, 669  CheckBox class  constructors, 669 example, 670–671 methods, 669 overview, 573  checked exceptions  catch-or-throw compiler error, 227–228 defined, 214 FileNotFoundException  catching, 227–228 throwing, 228–229  Chess class, 283 chessboard example, 408–415 child class, 242 child elements, XML, 862, 876–877  Index      885   child node, 697, 699 choice box  clearing contents of, 687 creating, 683–684 default value, 684–685 defined, 681 selected items, 685  ChoiceBox class  constructors, 682 methods, 682  choosing from list change listener  adding, 689 defined, 688 selecting items, 689 sequence method, 688–689  choice box  creating, 683–684 default value, 684–685 defined, 681 selected items, 685  combo boxes  adding items, 691 creating, 691–692 defined, 690 displaying items, 692 getting selected items, 692–693 handling events with, 693–694 improvements with, 690  list views  combo box versus, 694 constructors, 695 creating, 695–696 defined, 694 getting selected items, 696 methods, 695 selecting items, 694 view control, 694–695  observable list  accessing items, 686 defined, 685 inserting items, 688 removing items, 687  tree views  building tree, 698–701 child node, 697, 699  886      Java All-in-One For Dummies  collapsed node, 698 creating control, 699, 702 defined, 697 elements, 697 expanded node, 698 getting selected node, 702–704 leaf node, 698 nodes, 697 parent node, 697, 699 path, 698 root node, 697 sibling node, 697 Spinoff program, 704–706 value, 699  ChronoUnit, 553 class  abstract class defined, 301 Java API, 301 overview, 299–302 variable declarations, 301  ArrayList class  class declaration for, 451–452 constructors, 425–426 creating object, 427 delegation pattern, 282 methods, 317, 425–426 overview, 424–426 printing, 430 storing data, 425  BigDecimal class, 58–59 body of, 47, 250–251 character class  custom, 512–513 defined, 509 ranges, 513–514  CheckBox class  constructors, 669 example, 670–671 methods, 669 overview, 573 collection, 423 ComboBox class, 573  constructors, 691 methods, 691 overview, 690   constructors  basic, 259–260 basic format for coding, 259 calling, 261–262 creating, 259–262 default, 260–262 defined, 81, 241, 251, 259 inheritance and, 286–287 superclass, 287  creating objects from, 59 declaring, 249–253 defined, 57 diagramming with UML, 243–247 diagrams  arrows, 246–247 drawing, 245–246 overview, 244  disassembling, 31 drawing, 245–246 File class  constructors, 778–779 creating object, 780 directories, 781–782 files, 780–784 methods, 778–779 overview, 777–778 Swing file chooser, 785–786, 788, 789–791  final, 288 HttpServlet class, 726–727 importing, 354–355 inheritance, 242  casting type, 289–290 constructors and, 286–287 defined, 242 delegation pattern, 282 final keyword, 287–288 game analogy, 279–280 hierarchies, 280–281 interface versus, 302 overview, 14–15, 277–278 payroll system analogy, 280 polymorphism, 291–294 using, 266 vehicle analogy, 279  inner  anonymous, 347–351 creating, 342 defined, 252, 342, 591 example, 343–347 handling events with, 591–593 overview, 342 static, 342  instance of, 58 interface, 240, 242–243, 246 JAR files, 358–362 JavaDoc comments, 363–366 JavaServer Pages, 751–755 JFileChooser class  constructors, 787 creating dialog box, 788 file filters, 789–791 getting selected file, 788 methods, 787 overview, 785–786  LinkedList class  adding items, 443–444 advantages of, 438 inserting items, 438 methods, 439–442 overview, 438–439 removing items, 438–439, 447 retrieving items, 445–446 storing data, 439 updating items, 446–447  members  defined, 251, 253 fields, 253–254 internal, 255 visibility of, 254–255  methods  abstract, 300–301 accessor, 254–255 body, 196 declaring, 195–196 default, 299, 311–314 defined, 10, 47, 193, 251 fields, 254 final, 287–288  Index      887   class  continued   guessing game example, 203–206, 210–212 naming, 195 overloading, 257–258 overriding, 283 overview, 194 parameter list, 196 parameters, 206–210 pass-by-value, 209–210 private, 254 random, 114, 117 return statement, 201–203 return type for, 195, 199–200, 201, 258 signature of, 258 static, 58–59, 267, 267–268, 268, 269 using arrays with, 401  naming, 250 Object class  clone method, 318, 328–338 defined, 315 equals method, 318, 322–326 methods of, 317–319 overview, 315, 316 toString method, 319, 320, 321–322 using as type, 316–317 objects versus, 10, 57–58 overview, 57–58 Path class  creating files, 793–794 getting directory contents, 794 methods, 792 overview, 778, 792 walking file tree, 795–797  public, 251–253 public interface, 255 Scanner class  exceptions, 215–216 getting input, 94–95 hasNext method, 220 importing, 92–93 methods, 94, 96 overview, 92–93  Scene class, 607–608 in servlets, 735–740 Stage class  methods, 605–606 overview, 604  888      Java All-in-One For Dummies  String class  documentation page for, 34 in Hello World! program, 47 methods, 378–380 regular expression, 520–521  StringBuilder class  capacity, 388 creating object, 388 example, 390–391 length, 388 methods, 388–390 overview, 387–388  subclass  creating, 281–282 defined, 242, 278 inheritance, 266 super keyword, 284–285 this keyword, 284–285  TreeItem class  constructors, 698 methods, 698 overview, 697 TreeView class  constructors, 701 methods, 701 overview, 701  Class class, 338–340, 846 class constant, 73 class keyword, in Hello World! program, 46 Class object, defined, 315 class variables, declaring, 67–68 ClassName, 250 ClassNotFoundException, 214, 846 -classpath compiler option, 28, 29 -classpath option, 30 ClassPath variable  jar files in, 361 root directory, 356 wildcard, 361 clear method  ArrayList class, 425, 435 LinkedList class, 440 ObservableList class, 686 Click Me! button, 612–613 ClickCounter program, 577–582 Click-Counter scene, 612–613   ClickCounterAlert program, 615–617 ClickCounterExit program, 622–624 ClickHandler class, 593 ClickMe program  HTML file that links to JNPL file, 715–716 JNLP file, 713–715 launching, 717–718 source code, 566–567, 710–711 start method, 570–572  -client option, 30 clone method  ArrayList class, 426, 452 deep copies, 333–338 defined, 318 implementing, 329 LinkedList class, 440 reasons for, 328–329 shallow copies, 332–333  Cloneable interface, 308, 332 CloneNotSupportedException, 332–333 CloneTest program, 329–331, 334–338 cloning, 328 Close button, 618–619 close method  BufferedReader class, 802 Connection class, 848 DataOutputStream class, 821, 823 FileReader class, 802 JavaFX, 618 PrintWriter class, 808 ResultSet interface, 849 Stage class, 605  closeFile method, 820, 825–826 CloseRequest event, 620, 621 COBOL, 236 codebase attribute, 714 collapsed node, 698 collection classes, 423 column functions, 835–837 ColumnConstraints class, 650 combo boxes  adding items, 691 creating, 691–692 defined, 690 displaying items, 692  getting selected items, 692–693 handling events with, 693–694 improvements with, 690 list view versus, 694  ComboBox class  constructors, 691 methods, 691 overview, 573, 690  com.lowewriter.calculators package, 760 com.lowewriter.util package, 355 comma-delimited file, 800 command-line parameters, 784–785 command-line tools applet viewer, 32 compiling multiple files, 27–28 compiling program, 26–27 creating jar archives, 32 disassembling classes, 31 documenting classes, 32 jar, 32 Java compiler options, 28–29 javadoc, 32 running program, 29–30 COMMENT_NODE field, 873 comments  defined, 55–56 end-of-line, 56 JavaDoc, 57 traditional, 56–57  comparing  arrays, 420 dates, 551–552 objects, 326–328 strings, 149–150, 378  Compile Java tool, Text Pad, 36 compile method, 521 compiling program  catch-or-throw error, 227–228 compiler  defined, 8 options, 28–29 in TextPad, 40–42 using javac, 26–27  complement operator, 142 compound assignment operators, 110–111  Index      889   computer simulation, 236 concatenation, 377 conditional and  &&  logical operator, 142, 143–144 conditional operator, 101, 148 conditional or    logical operator, 142, 144–145 conf folder, JDK, 24 ConfirmationBox class, 618, 622 Connection class, 848 console, 45 Console class, 357–358 const keyword, 49 constants. See also final variables  advantages of, 73 of float and double classes, 128 Math class, 112–113 overview, 72–73  constructors  basic, 259–260 basic format for coding, 259 calling, 261–262 creating, 259–262 default, 260–262 defined, 81, 241, 251, 259 inheritance and, 286–287 insets, 631 superclass, 287  consume method, 621 contains method  ArrayList class, 426 LinkedList class, 440 ObservableList class, 687  containsAll method, 440 continue statement, 157–158 Control class, 633 convertPosToSquare method, 415 convertSquareToPos method, 415 CopyDemo program, 418–419 copyOf method, 416, 417–419 copyOfRange method, 416, 417–419 copyright, 24 copyTo method, 792 count column function, 836 count expression, 164 count method, 469 countDistinct column function, 836  890      Java All-in-One For Dummies  CountDown program, 168–169 CountDownApp program  with aborts, 499–503 coordinated, 486–489 source code, 483–484  CountDownAppNew program, 490 CountDownClock class, 488 CountDownClock program, 478–479, 496 CountDownClockLocked program, 496–497, 503 CountDownClockNew program, 489 CountDownClockSync program, 494 counter variable, 166–167 CounterForever program, 155 CountTestApp program, 271–272 CountToTen program, 164–165 -cp compiler option, 28, 29 -cp option, 30 crashes, 95 CrazyClass program, 263 CrazywithZeros program, 223–226 create SQL statement, 829, 831 createDirectory method, 792 createFile method, 792, 793–794 createNewFile method, 778, 781 createStatement method, 848–849, 856 CSS  Cascading Style Sheets , 564–565 curly braces  {} , 47–48, 352 custom character classes, 512–513 custom exceptions creating, 294–297 throwable hierarchy, 294–295 throwing, 296–297  -d compiler option, 28  D  d format pattern, 555 -D option, 30 \d regular expression, 510 \D regular expression, 510, 511 data types  boolean type overview, 79 primitive data types, 74 wrapper class, 80   byte type  primitive data types, 74 size of, 75 wrapper class, 80  casting  automatic numeric conversions, 85–86 overview, 86–87  char type  overview, 78 primitive data types, 74 in switch statements, 185–186 wrapper class, 80  converting to from strings, 83–85 defined, 73, 74 double type  exponent, 76 primitive data types, 74 wrapper class, 80  enum type, 97–98 float type  exponent, 76 precision of, 76 primitive data types, 74 wrapper class, 80  floating-point data types  125–126  overview, 76–78 rounding numbers, 119–120 scientific notation, 76–77 zero values for, 78  int type  primitive data types, 74 size of, 75 wrapper class, 80  integer types  overview, 75–76 promoting, 75  long type  primitive data types, 74 wrapper class, 80 objects versus, 319 optional, 470 overview, 73–74 primitive data types, 73–74  complications with binary number system,   reference types  defined, 74 overview, 80–81 return type, 200  short type  overview, 75 primitive data types, 74 wrapper class, 80  type checking, 13 wrapper classes, 79–80  database. See also database column functions, 835–837 connecting, 846–847 creating, 829–832 deleting rows, 840–841 eliminating duplicates, 838–839 excluding rows, 834 layer, 243–244 narrowing query, 834 querying, 832–839, 848–849 relational, 828 selecting data from multiple tables, 837–838  DataInputStream class, 813, 815 DataOutputStream class, 820, 821 date and time  birthday calculator, 556–559 calculating, 552–554 comparing, 551–552 creating objects, 542–547 Date-Time API  class listing, 542 Java 8, 539 LocalDate class, 548–550 of method, 545–546 methods, 546 Month enumeration, 545–547 now method, 542–544 parse method, 544–545 ZoneID class, 547, 548  extracting information, 550–551 formatting, 554–555 human time, 540 immutable objects, 552 machine calculation of, 540–541 representation, 540–541  Index      891   Date-Time API  class listing, 542 Java 8, 539 LocalDate class, 548–550 of method, 545–546 methods, 546 Month enumeration, 545–547 now method, 542–544 parse method, 544–545 ZoneID class, 547, 548  DateTimeFormatter class, 554–555 DateTimeParseException, 544–545 DAYS, 553 Dealable object, 305–306 DECADES, 553 declarations  JSP, 743, 749–750 statements, 51  declaring  class, 249–253 class variables, 67–68 local variables, 69–70 methods, 195–196 parameters, 207–208 strings, 82 variables  class variables, 67–68 final variables, 72–73 instance variables, 68–69 local variables, 69–70 multiple variables in one statement, 67 overview, 66  decrement operator  - - , 100, 106–108 deep copies, 333–338 deepEquals method, 416, 420 default constructors, 260–262 default group, 183 default methods, 299, 311–314 default package, 355 delegation event model, 344 delegation pattern, 282 delete method  File class, 778, 783 Path class, 792 StringBuilder class, 389  892      Java All-in-One For Dummies  delete SQL statement, 829, 840–841, 856 deleteCharAt method, 389 deleteFile method, 784 deleteRow method, 857, 858 delimiters, 800 dependencies, 369 @deprecated JavaDoc tag, 364 -deprecation compiler option, 28, 29 dequeue method, 458 derived class, 242, 278 descendingIterator method, 440 destroy method, 726 developer version, 18 diagrams  arrows, 246–247 drawing, 245–246 overview, 244  diamond     operator, 462 DiceApp class example, 118 DiceGame program, 252–253 directives, 742, 781 directories  displaying, 526–527 getting contents of, 794  Directory class, 778 DirList program, 527–529 -disablesystemassertions option, 31 disassembler, 31 DividedByZero program, 217–218 do statements, 51 doc tags, 363–364   declaration, 865–868, 879 Document interface, 872–873 Document Object Model  DOM  creating document, 871–872 defined, 868 document tree, 869–870 reading document, 869–872 reading DOM nodes, 872–877  Document Type Definition  DTD , 865–868 DOCUMENT_NODE field, 873 documentation for classes, 32 Java SE API, 32–33 on Oracle Java website, 32   DocumentBuilderFactory class  configuring, 870–871 creating document builder and document,    871–872  creating object, 869 getDocument method, 872 setIgnoringComments method, 871 setIgnoringElementContentWhitespace   method, 871  setValidating method, 871  Dodecaphobia program, 154–155, 158 doDelete method, 726 doGet method, 726–727, 730, 739–740 dollar sign  $ , 55 DOM  Document Object Model . See also XML    Extensible Markup Language   creating document, 871–872 defined, 868 document tree, 869–870 reading document, 869–872 reading DOM nodes, 872–877  doPost method, 726, 730, 739–740 doPut method, 726 dot  . , 361 DoTwoThings program, 492–493 DoTwoThingsLocked program, 496 DoTwoThingsSync program, 493 double data type, 14 double quote  " , 79, 376 DoubleStream interface, 467, 468 do-while loops, 159–160 downloading JDK, 22–23 TextPad, 35–36  DriverManager class, 846 drop SQL statement, 829 dropBall method, 307 DTD  Document Type Definition , 865–868 dump, 213  E  E constant, 112   formal type parameter, 457–458 eBay, 721 e.consume method, 621  EJB  Enterprise JavaBeans , 757 Element interface, 873–874 element method, 440, 445 ELEMENT_NODE field, 873 else-if statements  defined, 139–141 switch statement versus, 179–182  email programs, 476 empList variable, 461 Employee class  JavaDoc comments, 364–366 setLastName method, 316–317 EmployeeCollection class, 282 emulator, 8 -enableassertions option, 31 -enablesystemassertions option, 31 -encoding compiler option, 28 end condition, 525 end tag, XML, 862 end-of-line comments, 56 -endorsedirs compiler option, 28 enhanced for loop, 400, 503. See also for loops enqueue method, 458 ensureCapacity method, 389, 428 Enterprise JavaBeans  EJB , 757 enum type, 97–98 enumerate method, 478 Environment Variables dialog box, 25 equal sign  = , 59, 108, 131 equality operator  == , 238, 377, 420 equals method  ArrayList class, 416 Arrays class, 420 defined, 318 overriding, 324–326 overview, 322–323 rules, 325–326 using, 323–324  equalsIgnoreCase method, 378 ERAS, 553, 554 err variable, 171 Error class, 295 error messages  keywords, 50–51 running program, 30  Index      893   error streams, 91 errorMessage variable, 666 escape sequences, 78–79, 357 escapes, 516 EvenCounter program, 152, 159 event handlers creating, 586 defined, 573, 583, 585 registering, 586–587  event listener, 308 event source, 308 EventHandler interface, 585–590 events  classes, 584 defined, 585 examining, 584 handling  with anonymous inner classes, 593–594 combo box, 693–694 with inner classes, 591–593 JavaFX, 585–587 using lambda expressions, 596–601  source, 585, 586 target, 585  Exception class  creating, 231, 296 description, 295 methods for, 223 overview, 221–222  exceptions, 213  ArithmeticException, 214, 218, 220, 295 catching  examples, 217–219 multiple, 221–222, 232 try statement, 216–217  checked  catch-or-throw compiler error, 227–228 defined, 214 FileNotFoundException, 227–229 ClassNotFoundException, 214, 846 CloneNotSupportedException, 332–333 custom  creating, 294–297 throwable hierarchy, 294–295 throwing, 296–297  894      Java All-in-One For Dummies  DateTimeParseException, 544–545 defined, 127, 214 Exception class, 222–223 FileNotFoundException, 227–229 finally block, 223–226 guessing game example, 215 handling, 16, 220–221 IllegalArgumentException, 214 IndexOutOfBoundsException, 445 InputMismatchException, 95, 214, 215, 219, 222 InterruptedException, 498–499 IOException, 214, 222, 295, 296, 823 Java Web Start, 718–719 messages, displaying, 223 NullPointerException, 295 NumberFormatException, 97, 667 objects, 16 overview, 214–215 ProductDataException, 296 RuntimeException, 295 SAXException, 872 SQLException, 847 stack trace, 215–216 StringIndexOutOfBoundsException, 381 swallowing, 229–230 throwing, 231–232 throwing from main method, 229 types of, 214–215 unchecked, 215  executeQuery method, 848 executeUpdate method, 848, 856 executor, 489–491 Executor class, 491 exists method File class, 778 Path class, 792 exp method, 114 expanded node, 698 exponential notation, 76 expression statements, 51 expressions count, 164 ForInit , 166 initialization, 164 JavaServer Pages, 742, 744–746   lambda expressions  action events, 573–574 arrow operator, 351 defined, 341 functional interface, 351 handling events with, 596–601 introduction of, 18 JavaFX, 573–574, 582 overview, 351–352 for loops, 170–171 regular expression  capture groups, 517 character class, 509, 512–514 defined, 385, 505 escapes, 516 grouping characters, 516–518 in Java programs, 519–522 Matcher class, 521–522 matching multiple characters, 514–516 matching single characters, 509 negation, 514 overview, 505–506 Pattern class, 521–522 pipe symbol, 518–519 quantifiers, 515 String class, 520–521 String problem, 519–520 test program, 507–509  test, 164  -extdirs compiler option, 28 Extensible Markup Language  XML   attributes  defaults, 868 defined, 863–864 types, 867 values, 875–878  child elements, 876–877 declaration, 864 DOM  creating document, 871–872 defined, 868 document tree, 869–870 reading document, 869–872 reading DOM nodes, 872–877  DTD, 865–868 element content, 867  ListMovies program, 877–880 movie.xml file, 864–865 overview, 861–862 processing elements, 874–875 SAX, 868 tags, 862–863  extras.jar file, 361  F  \f escape sequence, 79, 376 f jar command option, 359 factorials  defined, 523 nonrecursive method, 524 recursive method, 524–526  false, 49 fExists method, 792 fields  creating, 254 defined, 251 in interfaces, 306 methods, 254 private, 254, 255 static fields  defined, 269 overview, 267–268 uses of, 268  text field, user input creating, 660–663 defined, 660 displaying prompt inside, 662 retrieving value, 662 RolePlayer program, 663–666 validating numeric data, 667 File class. See also Path class  constructors, 778–779 creating object, 780 directories, getting contents of,    781–782  files  creating, 780–781 deleting, 783–784 getting information about, 781 renaming, 782–783  Index      895   File class  continued  methods, 778–779 overview, 777–778 reading binary streams, 813 reading character streams, 801 Swing file chooser  creating dialog box, 788 file filters, 789–791 getting selected file, 788 overview, 785–786  file filters, 789–791 file visitor, 795–797 FileFilter class, 790–791 FileInputStream class, 226–227, 813 FileNotFoundException  catching, 227–228 throwing, 228–229  FileOutputStream class  description, 821 overview, 820  FileReader class  constructors, 801–802 methods, 801–802 overview, 801  FileWriter class, 807–808  append mode, 809 constructors, 809  FileZilla, 713, 717 fill method, 416, 417 filter method, 466–467 final class, 288 Final Fantasy IV, 236 final keyword, 49 final methods, 287–288 final variables, 72–73. See also constants finalize method, 318 finally block, 217, 223–226 first method, 857 flight-simulator programs, 236 float type  exponent, 76 parse method, 667 precision of, 76 primitive data types, 74 wrapper class, 80  896      Java All-in-One For Dummies  floating-point data types  complications with binary number system, 125–126 overview, 76–78 rounding numbers, 119–120 scientific notation, 76–77 zero values for, 78 floor method, 120 FlowPane layout  constructors, 640 defined, 626 methods, 640–642 overview, 639 Pizza Order application, 674  flush method  DataOutputStream class, 821, 823 PrintWriter class, 808  for loops  breaking and continuing, 172–173 counter variable scope, 166–167 counting backward with, 168 counting even numbers using, 167 enhanced, 400 formal format, 164–166 multiple expressions, 170–171 omitting expressions in, 171–172 overview, 161–163 using with arrays, 396–397 without bodies, 169–170  for statements, 51 ForDodecaphobia program, 172–173 forEach method, 466, 468 forEachOrdered method, 468 ForEvenCounter program, 167 FOREVER, 553, 554 ForInit expression, 166 form feed  \f  escape sequence, 79, 376 form tag, 733, 766 formal type parameters, 451 format method, 122 forms, 732–733 forName method, 846 forward slash    , 361 FTP client, 713, 717 functional interface, 351–352 -g compiler option, 28   G  Game class, 283, 312 game programs, 476 garbage collector, 15, 241 generics  creating array list, 427 creating class, 451–452 diamond operator, 462 Java 1.5, 424, 437–438 queue class, 458–462 reasons for, 450–451 stack class, 453–456 wildcard parameters, 457–458  GenQueue class, 458–462 GenStack class, 454–456 get accessor, 255–256 get method, 440, 687 GetABet program, 161–163 getAsDouble method, 470 getAttribute method, 874 getBigDecimal method, 850 getBoolean method, 850 getCanonicalPath method, 778, 781 getChildNodes method, 873 getChildren method FlowPane layout, 640 HBox layout, 627, 630 TreeItem class, 698 VBox layout, 636, 637  getClass method, 318, 339–340 getCode method, 773 getColumn method, 648 getConnection method, 846–847,    854, 856  getCount method, 758 getCurrencyInstance method, 122 getDate method, 850 getDayOfMonth method, 549 getDayOfWeek method, 549 getDayOfYear method, 549 getDocument method, 872, 879–880 getDouble method, 850 getElementsByTagName method, 874 getEmployee method., 291 getFirst method, 440, 445 getFirstChild method, 873, 875  getFloat method, 850 getFormattedRate method, 291 getFormattedSalary method, 291 getGuess method, 204, 210 getHeight method, 608 getInt method, 851 GetInteger program, 218–219, 220 getItems method  ChoiceBox class, 682, 683 ComboBox class, 691 ListView class, 695  getLast method, 441, 446 getLastChild method, 873 getLong method, 851 getMaxHeight method, 605 getMaxWidth method, 605 getMessage method, 794 getMinHeight method, 605 getMinWidth method, 605 getMonth method, 549 getMonthValue method, 549 getMovie method, 880 getMovieList method, 739–740 getMovies method, 812–813, 825–826, 854 getName method  File class, 778, 781 FileFilter class, 791 Thread class, 478  getNextSibling method, 873, 875 getNodeType method, 873 getNodeValue method, 873 getNumberInstance method, 122 getParameter method, 744 getParent method, 698, 779 getParentFile method, 779 getPercentInstance method, 122 getPreviousSibling method, 873 getPrice method, 773 getPriority method, 478 getProperty method, 758 getQuantity method, 773 getRandomNumber method  guessing game example, 210 parameters, 207–208 return type, 200–203 value returned by, 206  Index      897   getReader method, 806 getRoot method, 701 getRow method  GridPane layout, 648 ResultSet interface, 849  gets method, 426 getSelectedFile method, 787, 789 getSelectedItems method, 702 getSelectionModel method  ListView class, 695, 696 ObservableList class, 688–689 TreeView class, 702  getShort method, 851 getStream method, 820 getString method, 851 getters, 255–256 getText method  CheckBox class, 669 RadioButton class, 672 TextField class, 660, 662, 667 getTextValue method, 877, 880 getTime method, 488–489 getTitle method, 773 getTotal method, 773 getValue method  ChoiceBox class, 682, 685 ComboBox class, 691, 692–693 TreeItem class, 698  getWidth method, 608 getWriter method, 727 getYear method, 549 getYorN method, 415 Gmail, 721 GolfClub interface, 306 Gore, Al, 11 goto keyword, 49 greater-than  >  symbol, 91 Greeter class, 61–63 GridPane layout  column constraints, 650 constraints, 650–652 constructors, 648–649 creating grid pane, 647–649 defined, 626 features, 646  898      Java All-in-One For Dummies  methods, 648–649 overview, 645–646 row constraints, 651 sketching out plan, 646–647  GuessingGame program, 175–177, 362 GuessingGameMethod program, 197–199, 204–206,   210–212  GUI-based programs, 476  H  H format pattern, 555 h format pattern, 555 HALF-DAYS, 553 hasAttribute method, 874 hasChildNodes method, 873 hash code, 238, 318 hashCode method, 318 hasItems method  GenQueue class, 458, 460 Stack class, 453  hasNext method, 431 HBox layout  adding space by growing nodes, 633–635 adding space with margins, 632 constructors, 629 creating, 628 defined, 626 methods, 629 Pizza Order application, 674 spacing, 630–631  health field, 255–256 Hearts class, 304 Hello World! program  class keyword in, 46 identifiers in, 46–47 Java versus other languages, 12 main method in, 47, 196–197 overview, 46–48 public keyword in, 46, 47 running, 48 servlets, 727–729, 730–732 static keyword in, 47 String class in, 47 void keyword in, 47   HelloApp class, 48, 60–63, 69 helloMessage variable, 69–70 HelloServlet servlet, 730–732 HelloWorldMethod program, 196–197 -help compiler option, 28, 29 -help option, 30 hide method  ChoiceBox class, 682, 683 ComboBox class, 691  hierarchies  inheritance, 280–281 throwable, 294–295 hit method, 285, 301 horizontal flow layout, 639 horizontal tab  \t  escape sequence, 79 HOURS, 553 href attribute, 714–715 HTML  Hypertext Markup Language   file, 713 sending HTML content from servlet, 727–729 tags, 729, 863  HTTP  Hypertext Transfer Protocol , 721–722 HttpServlet class, 726–727 HttpServletResponse object, 727 Hypertext Transfer Protocol  HTTP , 721–722 hypot method, 114  I  iClickCount variable, 580, 612 iCounter variable, 589, 612 ID attribute type, 867 IDE  integrated development environment ,    defined, 21  identifiers  creating, 55 defined, 55 in Hello World! program, 46–47 rules, 55  identity, 237–238 IDREF attribute type, 867 IDREFS attribute type, 867 if statements  else-if statements, 139–141 if-else statements, 134–135 inner, 136  inside switch statements, 185–186 nested, 135–139 outer, 136 overview, 132–134  if-else statements, 134–135 if-then statements, 52 IllegalArgumentException, 214 immutable objects, 377, 552 implicit objects, 744–745 import directive, 744, 747 import statement  classes and packages, 354–355 HBox layout, 628 Java API, 63–64 JavaFX, 567  include folder, JDK, 24 increment operator  ++ , 100, 106–108 indexOf method  ArrayList class, 426, 429 LinkedList class, 441 ObservableList class, 687 StringBuilder class, 389  IndexOutOfBoundsException class, 445 infinite loops. See also loops  allowing user to quit, 156–157 defined, 154 stopping, 155  infix operator, 101 inheritance  casting type, 289–290 constructors and, 286–287 defined, 242 delegation pattern, 282 final keyword, 287–288 game analogy, 279–280 hierarchies, 280–281 interface versus, 302 overview, 14–15, 277–278 payroll system analogy, 280 polymorphism, 291–294 using, 266 vehicle analogy, 279  init method  HttpServlet class, 726 JavaFX, 569–570  Index      899   initialization expression, 164 initializer block, 265 initializers  defined, 251, 265 initializing variables with, 72 instance, 251 overview, 265–266 static, 251, 266, 269, 274–275 types of, 251  initModality method, 605, 607 initStyle method, 605, 607 inner classes  anonymous, 347–351 creating, 342 defined, 252, 342, 591 example, 343–347 handling events with, 591–593 overview, 342 static, 342  inner if statements, 136 input  check boxes  checked state, 669 creating, 669–670 defined, 668 undefined state, 669  JSP  forms, 732–733 InputServlet servlet, 733–734  overview, 659 Pizza Order application  layout pane, 674 main window, 674 overview, 673 source code, 675–680 user order confirmation, 674  radio buttons  creating, 672, 673 defined, 671 toggle groups, 673  servlets, 732–735 text field  creating, 660–663 defined, 660 displaying prompt inside, 662  900      Java All-in-One For Dummies  retrieving value, 662 RolePlayer program, 663–666 validating numeric data, 667  validating numeric data, 667–668  input streams, 90–91, 94 InputEvent class, 584 InputJSP.jsp, 745–746 InputMismatchException, 95, 214, 215,    219, 222  input output streams. See I O streams InputServlet servlet, 734–735 InputServlet.html, 732–733 insert method, 389 insert SQL statement, 829, 831 insertRow method, 857, 859 Insets enumeration, 631 inside loop, 173 installing TextPad, 35–36 Tomcat, 723–724 instances  beans with JSP pages, 761–763 of classes, 58 counting instances using static field, 270–271 defined, 237 initializers, 251 preventing, 273–274 singleton pattern, 272–273 variables, 68–69  Instant class, 542 int type  primitive data types, 74 size of, 75 wrapper class, 80  integer data type dividing, 102–104 overflow of, 125 overview, 14, 75–76 parse method, 667 promoting, 75 size of, 75  interface  ActionListener interface, 308, 309, 311 CardGame interface, 304 CharSequence interface, 391   class diagram, 246 Cloneable interface, 308, 332 creating, 303 defined, 240, 242–243, 302 Document interface, 872–873 DoubleStream interface, 467, 468 Element interface, 873–874 EventHandler interface, 585–590 extending, 306–307 fields in, 306 functional, 351–352 implementing, 302, 304 inheritance versus, 302 IntStream interface, 467, 468 Iterator interface, 430 LongStream interface, 467, 468 marker, 308 Node interface, 873 NodeList interface, 874 Playable interface, 304, 313–314 PlayableBall interface, 307 Queue interface, 445 Runnable interface  creating class, 481–482 overview, 480 using, 418 stream, 464 Stream interface, 464, 467–470 subinterface, 306–307 superinterface, 306–307 Text interface, 874 ThrowableBall interface, 307 TimeMonitor interface, 488 using as type, 305–306 using for callbacks, 307–309  internal members, 255 Internet, 11 interrupt method, 478 interrupted flag, 498 InterruptedException, 498–499 IntStream interface, 467, 468 Invoice program, 270 invokevirtual instruction, 31 invoking, 193  I O streams  binary streams  classes for reading, 814 defined, 800 reading, 813–820 reading from data input stream, 815–817 reading from file, 817–820 writing, 820–826 writing to file, 823–827 character streams, 800  defined, 800 reading, 801–806 reading from file, 803–806 writing, 807–813  IOException, 214, 222, 295, 296, 823 isAfter method, 549 isBefore method, 549 isDirectory method, 529, 779, 781–782 isEmpty method  ArrayList class, 426 LinkedList class, 441 ObservableList class, 687  isEqual method, 549 isExpanded method, 698 isFile method, 779, 793 isHidden method, 779 isInterrupted method, 478 isLeaf method, 698 isSelected method  CheckBox class, 669–670 RadioButton class, 672 isShowing method, 682 Iterator interface, 430 iterator method, 426, 430–432, 441 iterator pattern, 431 -J compiler option, 28  J  J2SE  Java 2 Standard Edition , defined, 19 jagged arrays, 405–406 JAR  Java archive  files  adding to classpath, 361 in classes, 358–362  Index      901   JAR  Java archive  files  continued   creating, 372, 712–713 defined, 358 jar command, 359–-360 Java Web Start, 712–713 modular, 372 overview, 358–359 running program from, 362  jar command, 359–-360 jar tf command, 372 Java  applets, 11 automatic memory management, 15 C C++ experience and, 7 C C++ versus, 12–13 command-line tools, 26–32 disadvantages, 16–17 exception handling, 16 Internet and, 12 language specification, 33–34 machine time, 540–541 object-oriented, 9–10 platform independence, 8–9 servlets, 11 type checking, 13–15 version history, 17–18  Java 1.5  generics, 424, 437–438 lock, 496  Java 1.7, Path class, 778 Java 7, diamond operator, 462 Java 8  bulk data operations, 464 Date-Time API, 539 default method, 313  Java 9  API documentation, 32–33 Java Module System, 353, 368–372 Java Platform Module System, 64  Java API  class names and, 250 Cloneable interface, 308 disadvantages, 16–17 documentation, 32–33 equals method, overriding, 324–325 importing classes, 63–64 overview, 10–11  902      Java All-in-One For Dummies  Java archive  JAR  files  adding to classpath, 361 in classes, 358–362 creating, 372, 712–713 defined, 358 jar command, 359–-360 Java Web Start, 712–713 modular, 372 overview, 358–359 running program from, 362 Java Control Panel, 718–719 Java Database Connectivity  JDBC  connecting to database, 846–847 defined, 827, 845 executing select statement, 849 ListMovies program, 852–855 querying database, 848–849 result set  getting data from, 850–851 navigating, 849–850  setting up driver, 845–846 updatable result set deleting rows, 858 inserting rows, 859–860 methods for, 857 overview, 856–857 updating rows, 858  updating SQL data, 855–856  Java Development Kit  JDK   defined, 19 downloading, 22–23 folders in, 23–24 location of, 723 servlet-api.jar file, 724 setting path for, 24–25  Java EE  Java Enterprise Edition , 19 Java Module System  compiling module, 371–372 defined, 18 folders, 371 modular, 369 module-info.java file, 369–370 overview, 368–369  Java Network Launch Protocol  JNLP   creating file, 713–715 HTML file, 713 web link, 712, 713   Java Platform Module System, 64 Java SE  Standard Edition , defined, 19 Java Virtual Machine  JVM   bytecode, 8 defined, 8, 19 Java Web Start and, 712 stack-oriented, 9 threading, 476  Java Web Start  creating HML file, 715–716 creating JNLP file, 713–715 defined, 11 exceptions, 718–719 launching application, 717–718 overview, 712 setting application to run, 712–713 uploading files to Web server, 716–717  JAVA_HOME variable, 723 JavaBeans  accessor, 758 constructors, 757–758 defined, 757 instance variables, 758 in JSP  creating instances, 761–763 getting property values, 763 jsp:setProperty tag, 764 jsp:useBean tag, 762–763 setting property values, 764–765 viewing pages, 765–766  methods, 758 overview, 757–758 properties, 758 scope for, 767 shopping cart application, 767–773 Triangle class example, 759–761  javac command-line tool  compiling modules, 371–372 compiling multiple files, 27–28 compiling program, 26–27 options, 28–29 overview, 26  JavaDoc  adding comments, 363–366 javadoc command, 366  overview, 353 tags, 363–364 viewing pages, 367–368 javadoc command, 366 JavaDoc comments, 57 JavaFX  3-D objects, 565 action events, 573–574 advantages of, 563–564 alert box, 613–617 Alert class, 613–617 animation, 565 Border layout  constructors, 644–645 creating object, 575–576 defined, 626 methods, 644–645 overview, 643  Click Counter program, 577–582 ClickMe program, 710–711 CloseRequest event, 620 constructors, 613 creating buttons, 570–572 creating Close button, 618–619 creating layout pane, 574–576 exiting program, 618 extending Application class, 568–569 features, 565 FlowPane layout  constructors, 640 defined, 626 methods, 640–642 overview, 639  GridPane layout  column constraints, 650 constraints, 650–652 constructors, 648–649 creating grid pane, 647–649 defined, 626 features, 646 methods, 648–649 overview, 645–646 row constraints, 651 sketching out plan, 646–647  Index      903   JavaFX  continued   handling events, 585–587 HBox layout  adding space by growing nodes, 633–635 adding space with margins, 632 constructors, 629 creating, 628 defined, 626 methods, 629 spacing, 630–631  importing packages, 567–568 lambda expressions, 573–574, 582 launch method, 569–570 layout manager, 568 layout pane  combining, 628 creating, 626–628  life cycle of application, 568–569 making scenes, 576 methods, 613 overriding start method, 570–572 overview, 563–564 program, 566–567 property, 689 Scene class, 607–608 setOnCloseRequest method, 620 setting stage, 576–577 stage, 576–577, 604–607 switching scenes, 608–613 touch interface, 565 VBox layout  JavaServer Pages  JSP  advantages of, 741 attributes, 743 classes, 751–755 declarations, 743, 749–750 defined, 741 directives, 742 expressions, 742, 744–746 JavaBeans in  creating instances, 761–763 getting property values, 763 jsp:setProperty tag, 764 jsp:useBean tag, 762–763 setting property values, 764–765 viewing pages, 765–766  overview, 741 page directives, 743–744 scriptlets, 742, 746–749 tags, 762  java.sql package, 847 java.text package, 747 java.time package, 559 java.time.format package, 559 java.time.temporal package, 559 java.util package, 354, 747 java.util.Date, 744 javax.servlet package, 726 javax.servlet.http package, 726 javax.swing package, 63–64 JDBC  Java Database Connectivity . See also SQL   constructors, 636 defined, 626 making nodes the same width, 638–639 methods, 636 overview, 635–637  visual effects, 565  javafx.application package, 568 javafx.geometry package, 637 javafx.scene package, 568 javafx.scene.control package, 568, 572–573 javafx.scene.layout package, 568, 627, 628, 634,   635, 641  javafx.stage package, 568 java.io package, 726, 778, 790, 800 java.lang package, 354–355 javap command, 31  904      Java All-in-One For Dummies   Structured Query Language  connecting to database, 846–847 defined, 827, 845 executing select statement, 849 ListMovies program, 852–855 querying database, 848–849 result set  getting data from, 850–851 navigating, 849–850  setting up driver, 845–846 updatable result set deleting rows, 858 inserting rows, 859–860 methods for, 857 overview, 856–857 updating rows, 858  updating SQL data, 855–856   JDK  Java Development Kit   defined, 19 downloading, 22–23 folders in, 23–24 location of, 723 servlet-api.jar file, 724 setting path for, 24–25  JFileChooser class  constructors, 787 creating dialog box, 788 file filters, 789–791 getting selected file, 788 methods, 787 overview, 785–786  JFrame class, 786 jmods folder, JDK, 24 JNLP  Java Network Launch Protocol   creating file, 713–715 HTML file, 713 web link, 712, 713  JOptionPane class, 63–64,    96–97, 311  JRE  Java Runtime Environment , 8, 19 jre folder, JDK, 24 JSP  JavaServer Pages  advantages of, 741 attributes, 743 classes, 751–755 declarations, 743, 749–750 defined, 741 directives, 742 expressions, 742, 744–746 JavaBeans in  creating instances, 761–763 getting property values, 763 jsp:setProperty tag, 764 jsp:useBean tag, 762–763 setting property values, 764–765 viewing pages, 765–766  overview, 741 page directives, 743–744 scriptlets, 742, 746–749 tags, 762  jsp:getProperty tag, 763 jsp:setProperty tag, 764, 766  jsp:useBean tag, 762–763, 766 JVM  Java Virtual Machine   bytecode, 8 defined, 8, 19 Java Web Start and, 712 stack-oriented, 9 threading, 476  K  L  KeyEvent class, 584 keywords  case sensitivity of, 49–51 defined, 49 error messages, 50–51 overview, 49–51  KickableBall interface, 307 kickBall method, 307 KnightMoves program, 410–413  \\l regular expression, 385 Label class, 573 labels, 577 lambda expressions  action events, 573–574 arrow operator, 351 defined, 341 functional interface, 351 handling events with, 596–601 introduction of, 18 JavaFX, 573–574, 582 overview, 351–352  language specification, 33–34 last method, 849, 857 lastIndexOf method ArrayList class, 426 LinkedList class, 441 StringBuilder class, 389 lastModified method, 779 launch method, 569–570 LaunchEvent program, 482, 502 LaunchEventNew program, 490 layout manager, JavaFX, 568  Index      905   layout pane  adding space by growing nodes, 633–635 adding space with margins, 632 aligning nodes in, 637–638 border pane, 643–645 combining, 628 creating, 574–576, 626–628 flow layout, 638–642 grid, 646–657 GridPane layout  column constraints, 650 constraints, 650–652 constructors, 648–649 creating grid pane, 647–649 defined, 626 features, 646 methods, 648–649 overview, 645–646 row constraints, 651 sketching out plan, 646–647  HBox layout  adding space by growing nodes, 633–635 adding space with margins, 632 constructors, 629 creating, 628 defined, 626 methods, 629 spacing, 630–631  making nodes the same width, 638–639 observable list, 686 padding, 631 Pizza Order application, 674 spacing, 630–631 VBox layout  constructors, 636 defined, 626 making nodes the same width, 638–639 methods, 636 overview, 635–637  leaf node, 698 length method, 389, 391, 779 lengthOfMonth method, 549 lengthOfYear method, 549 lib folder, JDK, 24 license agreement, 22 life cycle, of object, 240  906      Java All-in-One For Dummies  line feed  \n  escape sequence, 79 linked list  defined, 438 queues, 439 stacks, 439 LinkedIn, 721 LinkedList class  adding items, 443–444 advantages of, 438 inserting items, 438 methods, 439–442 overview, 438–439 removing items, 438–439, 447 retrieving items, 445–446 storing data, 439 updating items, 446–447  Linux operating system, 541 LISP programming language, 236 list method, 779 list views  combo box versus, 694 constructors, 695 creating, 695–696 defined, 694 getting selected items, 696 methods, 695 selecting items, 694 view control, 694–695  listDirectories method, 529 listener object, 308 ListFiles class, 735 listFiles method, 529, 779, 782 ListMovie class, 739–740, 752–753 ListMovies program, 852–855, 877–880 listRoots method, 779 lists  change listener  adding, 689 defined, 688 selecting items, 689 sequence method, 688–689  choice box  creating, 683–684 default value, 684–685 defined, 681 selected items, 685   combo boxes  adding items, 691 creating, 691–692 defined, 690 displaying items, 692 getting selected items, 692–693 handling events with, 693–694 improvements with, 690  list views  combo box versus, 694 constructors, 695 creating, 695–696 defined, 694 getting selected items, 696 methods, 695 selecting items, 694 view control, 694–695  observable list  accessing items, 686 defined, 685 inserting items, 688 removing items, 687  tree views  building tree, 698–701 child node, 697, 699 collapsed node, 698 creating control, 699, 702 defined, 697 elements, 697 expanded node, 698 getting selected node, 702–704 leaf node, 698 nodes, 697 parent node, 697, 699 path, 698 root node, 697 sibling node, 697 Spinoff program, 704–706 value, 699  literals  defined, 49 string, 82  local variables  declaring, 69–70 initializing, 70–71  LocalDate class, 542, 544, 546, 548–550 LocalDateTime class, 542, 546 LocalTime class, 542, 546 lock, 496–497 log method, 114 log10 method, 114 logic layer, 243–244 logical operators &  and , 143–144 &&  conditional and , 143–144 ^  Xor , 145–146   or , 144–145   conditional or , 144–145 binary, 141–142 combining, 146–147 defined, 141 unary, 141  long type  parse method, 667 primitive data types, 74 wrapper class, 80  LongStream interface, 467, 468 loops  breaking out of, 154 continue statement, 157–158 defined, 151 do-while loop, 159–160 infinite  allowing user to quit, 156–157 defined, 154 stopping, 155  inside, 173 for loops  breaking and continuing, 172–173 counter variable scope, 166–167 counting backward with, 168 counting even numbers using, 167 enhanced, 400 formal format, 164–166 multiple expressions, 170–171 omitting expressions in, 171–172 overview, 161–163 using with arrays, 396–397 without bodies, 169–170  Index      907   loops  continued   nesting  guessing game example, 174–177 overview, 173–174  outside, 173 validating user input using, 161–163 while loop, 152–153, 461  M  m format pattern, 555 M format pattern, 555 m jar command option, 359 M jar command option, 359 machine time, 540–541 main method  AddSubtract class, 589 C C++, 12 in Hello World! program, 47, 196–197 pass-by-value, 209 static, 270 throwing exception from, 229  main threads, 476 main-class attribute, 715 manifest file, 358, 362 mantissa, 76 margins, adding space with, 632 market interface, 308 markup languages  HTML  Hypertext Markup Language   sending HTML content from servlet, 727–729 tags, 729, 863  XML  Extensible Markup Language   attributes, 863–864, 867, 868, 875–878 child elements, 876–877 declaration, 864 DOM, 868, 869–870, 869–872, 871–872, 872–877 DTD, 865–868 element content, 867 ListMovies program, 877–880 movie.xml file, 864–865 overview, 861–862 processing elements, 874–875 SAX, 868 tags, 862–863  908      Java All-in-One For Dummies  MarkVowels program, 390 Match Bracket feature, Text Pad, 38 Matcher class, 521–522 matches method, 521, 791 Math class  constants of, 112–113 mathematical functions, 114 overview, 111 preventing instances, 274 rounding methods, 119–120  MathFunctionsApp class example, 115 max column function, 836 max method, 114, 469 members  defined, 251, 253 fields, 253–254 internal, 255 protecting, 284 visibility of, 254–255  memory leak, 15 memory management, 15 methods  abstract, 300–301 accessor, 254–255 add, 443–444, 686 addAll, 425, 440, 627, 683, 686, 688 addChoosableFileFilter, 787, 790, 791 addColumn, 648 addFirst, 440 addItems, 458, 461 addLast, 440, 443 addListener, 688, 689 addQuantity, 773 addRow, 648 afterLast, 857 askForAnotherRound, 204, 210 average, 469 beforeFirst, 857 binarySearch, 416, 419–420 body, 196 btnAdd_Click, 601 btnClose_Clicked, 618–619 btnOK_Click, 657, 666 btnSubtract_Click, 601 buttonClick, 573–574   buttonClicked, 572, 574 class  ArrayList class, 317, 425–426 CheckBox class, 669 ChoiceBox class, 682 ComboBox class, 691 declaring, 195–196 File class, 778–779 FileReader class, 801–802 JFileChooser class, 787 LinkedList class, 439–442 NumberFormat class, 122 Object class, 317–319 ObservableList class, 686–687 Path class, 792 PrintWriter class, 808 RadioButton class, 672 RowConstraints class, 651 Scanner class, 94, 96 String class, 378–380 StringBuilder class, 388–390 TreeItem class, 698 TreeView class, 701  clear, 425, 435, 440, 686 closeFile, 820, 825–826 ComboBox class, 691 compile, 521 consume, 621 contains, 426, 440, 687 containsAll, 440 convertPosToSquare, 415 convertSquareToPos, 415 copyOf, 416, 417–419 copyOfRange, 416, 417–419 copyTo, 792 count, 469 createDirectory, 792 createFile, 792, 793–794 createNewFile, 778, 781 createStatement, 848–849, 856 Date-Time API, 546 declaring, 195–196 deepEquals, 416, 420 default, 299, 311–314 defined, 10, 47, 193, 251  delete, 389, 778, 783, 792 deleteCharAt, 389 deleteFile, 784 deleteRow, 857, 858 dequeue, 458 descendingIterator, 440 destroy, 726 doDelete, 726 doGet, 726–727, 730, 739–740 doPost, 726, 730, 739–740 dropBall, 307 e.consume, 621 element, 440, 445 enqueue, 458 ensureCapacity, 389, 428 enumerate, 478 fields, 254 fill, 416, 417 filter, 466–467 final, 287–288 finalize, 318 first, 857 floor, 121 FlowPane layout, 640–642 flush, 808, 821, 823 forEach, 466, 468 forEachOrdered, 468 format, 122 forName, 846 get, 440, 687 getAsDouble, 470 getAttribute, 874 getBigDecimal, 850 getBoolean, 850 getCanonicalPath, 778, 781 getChildNodes, 873 getChildren, 627, 630, 636, 637, 640, 698 getClass, 318, 339–340 getCode, 773 getColumn, 648 getConnection, 846–847, 854, 856 getCount, 758 getCurrencyInstance, 122 getDate, 850 getDayOfMonth, 549  Index      909   methods  continued   getDayOfWeek, 549 getDayOfYear, 549 getDocument, 872, 879–880 getDouble, 850 getElementsByTagName, 874 getEmployee ., 291 getFirst, 440, 445 getFirstChild, 873, 875 getFloat, 850 getFormattedRate, 291 getFormattedSalary, 291 getGuess, 204, 210 getHeight, 608 getInt, 851 getItems, 682, 683, 691, 695 getLast, 441, 446 getLastChild, 873 getLong, 851 getMaxHeight, 605 getMaxWidth, 605 getMessage, 794 getMinHeight, 605 getMinWidth, 605 getMonth, 549 getMonthValue, 549 getMovie, 880 getMovieList, 739–740 getMovies, 812–813, 825–826, 854 getName, 478, 778, 781, 791 getNextSibling, 873, 875 getNodeType, 873 getNodeValue, 873 getNumberInstance, 122 getParameter, 744 getParent, 698, 779 getParentFile, 779 getPercentInstance, 122 getPreviousSibling, 873 getPrice, 773 getPriority, 478 getProperty, 758 getQuantity, 773 getRandomNumber, 200–203, 206, 207–208, 210 getReader, 806  910      Java All-in-One For Dummies  getRoot, 701 getRow, 648, 849 gets, 426 getSelectedFile, 787, 789 getSelectedItems, 702 getSelectionModel, 688–689, 695, 696, 702 getShort, 851 getStream, 820 getString, 851 getText, 660, 662, 667, 669, 672 getTextValue, 877, 880 getTime, 488–489 getTitle, 773 getTotal, 773 getValue, 682, 685, 691, 692–693, 698 getWidth, 608 getWriter, 727 getYear, 549 getYorN, 415 GridPane layout, 648–649 guessing game example, 203–206, 210–212 GuessingGame program, 197–199, 204–206,   210–212  hasAttribute, 874 hasChildNodes, 873 hashCode, 318 hasItems, 453, 458, 460 hasNext, 431 HBox layout, 629 hide, 682, 683, 691 hit, 285, 301 hypot, 114 indexOf, 389, 426, 429, 441, 687 init, 569–570, 726 initModality, 605, 607 initStyle, 605, 607 insert, 389 insertRow, 857, 859 integer types, 667 interrupt, 478 isAfter, 549 isBefore, 549 isDirectory, 579, 779, 781–782 isEmpty, 426, 441, 687 isEqual, 549   isExpanded, 698 isFile, 779, 793 isHidden, 779 isInterrupted, 478 isLeaf, 698 isSelected, 669–670, 672 isShowing, 682 iterator, 426, 430–432, 441 kickBall, 307 last, 849, 857 lastIndexOf, 389, 426, 441 lastModified, 779 length, 389, 391, 779 lengthOfMonth, 549 lengthOfYear, 549 list, 779 listDirectories, 529 listFiles, 529, 779, 782 listRoots, 779 log, 114 log10, 114 min, 114, 469 minusDays, 549 minusMonths, 549 minusWeeks, 549 minusYears, 549 mkdir, 779 mkdirs, 779 move, 294 moveTo, 792 moveToCurrent, 857, 859 moveToInsert, 857, 859 MultipleSelectionModel, 701, 702 naming, 195 newDirectoryStream, 793 newDocumentBuilder, 872 newInstance, 870 next, 431, 849, 857 nextInt, 95, 215 nextSibling, 698 notExists, 792 now, 542–544, 549 ObservableList, 629 of, 545–546 offer, 441, 445  offerFirst, 441, 445 offerLast, 441, 445 openFile, 230 openOutputStream, 825–826 openWriter, 812–813 OptionalDouble, 470 overloading, 257–258 overriding, 283 overview, 194 parameter list, 196 parameters, 206–210 parse, 377, 544–545, 549, 667 parseByte, 667 parseDouble, 667 parseFloat, 667 parseInt, 667–668 parseLong, 667 parseShort, 667 partition, 532–534, 537 pass-by-value, 209–210 peek, 441, 446, 453 peekFirst, 441, 446 peekLast, 441, 446 play, 312 Playable, 303 playARound, 197–199, 203, 210 plusDays, 549 plusMonths, 549 plusWeeks, 549 plusYears, 549 poll, 441, 446 pollFirst, 441, 446 pollLast, 441, 446 pop, 441, 446, 453 postVisitDirectoryFailred, 795 pow, 114 previous, 857 preVisitDirectory, 795, 797 prevSibling, 698 print, 92, 727, 808 printArray, 536 println, 13, 92, 264, 727, 808 private, 254 push, 441, 453 quit, 313  Index      911   methods  continued  random, 114, 117 randomInt, 118 read, 802, 808 readBoolean, 814 readByte, 814 readChar, 814 readDouble, 814 readFloat, 814 readInt, 814 readLine, 802 readLong, 814 readMovie, 820 readShort, 814 readUTF, 814 retainAll, 435, 441–442 return statement, 201–203 return type for, 195, 199–200, 201, 258 reverse, 389 rint, 121 round, 119–120, 121 run, 478, 502 selectedItemProperty, 689 set, 426, 686 setAcceptAllFileFilterUsed, 787, 791 setAlignment, 629, 637, 640, 644 setApproveButtonText, 787 setBook, 773 setBottom, 644 setCenter, 575, 580–581, 644 setCharAt, 390 setColumnAlignment, 640 setColumnSpan, 648 setContentType, 727 setDialogTitle, 787, 788 setEditable, 660, 691, 692 signature of, 258 static  defined, 267, 269 overview, 58–59, 267–268 uses of, 268  subSequence, 391 sum, 469 summaryStatistics, 469 swap, 534 synchronizing, 491–496  912      Java All-in-One For Dummies  trimToSize, 390 tryToChangeNumber, 209–210 until, 549 updateBigDecimal, 859 updateBoolean, 859 updateDate, 859 updateDouble, 859 updateFloat, 859 updateInt, 859 updateLong, 859 updateRow, 857 updateShort, 859 updateString, 859 using arrays with, 401 visitFile, 795, 797 visitFileFailed, 795, 797 write, 822 writeBoolean, 821 writeByte, 821 writeChar, 821 writeDouble, 821 writeFloat, 821 writeInt, 821 writeLong, 821 writeMovie, 812–813, 825–826 writeShort, 822 writeUTF, 822 yield, 478, 498  MILLENIA, 553 MILLIS, 554 min column function, 836 min method, 114, 469 minus sign  - , 100 minusDays method, 549 minusMonths method, 549 minusWeeks method, 549 minusYears method, 549 MINUTES, 554 missing return statement, 202 mkdir method, 779 mkdirs method, 779 modal dialog box, 788 module-info.java file, 369–370 modules  compiling, 371–372 defined, 369   dependencies, 369 visibility, 369  modulus operator, 102 Month enumeration, 545–547 MonthDay class, 542, 546 MONTHS, 554 MouseEvent class, 584 move method, 294 moveTo method, 792 moveToCurrent method, 857, 859 moveToInsert method, 857, 859 Movie class, 735–737, 753, 826, 855, 880 MovieIO class, 735, 737–738, 754–755 multi-dimensional arrays, 407–408 MultipleSelectionModel method, 701, 702 MySQL, 830, 845 MySQL Command Line Client, 830, 833 MySQL database, 846–847  N  \n escape sequence, 79, 376 \\n regular expression, 385 names, 47, 55 NaN constant, 128 NANOS, 554 negation, 514 NEGATIVE_INFINITY constant, 128 nested if statements, 135–139 nested loops, 173–174 new keyword, 59, 259 newDirectoryStream method, 793 newDocumentBuilder method, 872 newInstance method, 870 newline  \n  escape sequence, 376 newValue parameter, 689 next method  Iterator interface, 431 ResultSet class, 857 ResultSet interface, 849  nextInt method, 95, 215 nextSibling method, 698 NMTOKEN attribute type, 867 NMTOKENS attribute type, 867 Node class, 608 Node interface, 873  NodeList interface, 874 nodes  aligning in layout pane, 637–638 child, 697, 699 collapsed, 698 expanded, 698 leaf, 698 parent, 697, 699 root, 697 sibling, 697 tree views, 697 width, 638–639 non-null rule, 325 nonrecursive method, 524 not  !  logical operator, 141, 142–143 not equals  !=  relational operator, 142 notExists method, 792 nouns, class names, 250 now method  Date-Time API, 542–544 LocalDate class, 549  -nowarn compiler option, 28 null, 49 NullPointerException, 295 number variable, 209 NumberFormat class  methods, 122 overview, 121–123  NumberFormatClassApp class example, 124 NumberFormatException, 97, 667 NumberPhobia program, 156 numbers  converting strings to, 667–668 creating random numbers, 116–119 division by zero, 126–128 formatting, 121–124 validating numeric data, 667–668  nums array, 429  O  Object class  clone method  deep copies, 333–338 defined, 318 implementing, 329  Index      913   Object class  continued   overview, 328–329 reasons for, 328–329 shallow copies, 332–333  defined, 315 equals method  defined, 318 overriding, 324–326 overview, 322–323 using, 323–324  methods of, 317–319 overview, 315, 316 toString method  overriding, 321–322 overview, 319 using, 320  classes, 57–58 objects, 59  creating from class, 59 overview, 57–58 overview, 235–236 static methods, 58–59  objects  using as type, 316–317  object-oriented programming  OOP   actions of, 58 behavior, 10, 58, 239 classes versus, 10, 57–58 comparing, 326–328 creating, 780 creating from class, 59 defined, 10 designing for programs, 243–244 exception, 16, 213 hash code for, 238 identity, 237–238 immutable, 377, 552 implicit, 744–745 life cycle, 240–241 methods for, 10 observable, 344 observer, 344 orientation, 9–10 overview, 57–58  914      Java All-in-One For Dummies  primitive data types versus, 319 state, 10, 58, 239 synchronizing, 495 type, 238–239 observable list  accessing items, 686 defined, 685 inserting items, 688 removing items, 687 observable object, 344 observable parameter, 689 ObservableList class, 683 constructors, 683  methods, 629, 686–687 overview, 686  observer object, 344 ODBC driver, 846 of method, 545–546 offer method, 441, 445 offerFirst method, 441, 445 offerLast method, 441, 445 OffsetDateTime class, 542 OffsetTime class, 542, 546 oldValue parameter, 689 Olivetti Programma 101, 9 OOP  object-oriented programming   classes, 57–58 objects, 59  creating from class, 59 overview, 57–58 overview, 235–236 static methods, 58–59  Open dialog box, 788 openFile method, 230 openOutputStream method, 825–826 openWriter method, 812–813 operand, 99 operators %=, 111 *=, 111  =, 111 +=, 111 −=, 111 arithmetic   combining, 104–105 compound assignment operators, 110–111 increment and decrement, 106–108 overview, 99–102 unary operators, 105–106  assignment, 59 binary, 101 combining, 104–105 complement, 142 conditional, 101, 148 decrement, 106–108 defined, 99 increment, 106–108 infix, 101 logical  &  and , 143–144 &&  conditional and , 143–144 ^  Xor , 145–146   or , 144–145   conditional or , 144–145 binary, 141–142 combining, 146–147 defined, 141 unary, 141 modulus, 102 postfix, 101 relational, 130 ternary, 101, 148 unary  defined, 101 plus and minus, 105–106  optional data type, 470 OptionalDouble method, 470 or    logical operator, 142, 144–145 out field, 13 out object, 745 outer if statements, 136 out.print statements, 742, 747 output streams, 90–91 outside loops, 173  P  packages  archiving, 360–361 creating, 355–357  defined, 63, 354 example, 357–358 importing, 354–355 JavaFX, 567–568 java.util, 354 naming, 355–356  Pacman, 236 padding, 631 page directives, 743–744 page scope setting, 767 parallel stream, 470–471 param attribute, 764 @param JavaDoc tag, 364 parameter list, 47, 207 parameters  declaring, 207–208 defined, 206 names, 258 scoping out, 208–209  ParameterScope program, 208–209 parent class, 242, 278 parent element, XML, 862 parent node, 697, 699 parentheses, 516–518 parse method  Date-Time API, 544–545 LocalDate class, 549 of wrapper classes, 377 parseByte method, 667 parseDouble method, 667 parseFloat method, 667 parseInt method, 667–668 parseLong method, 667 ParserConfigurationException, 872 parseShort method, 667 partition method, 532–534, 537 partitioning, 530–531 partitions, 530–531 pass-by-value, 209–210 path, 698 Path class. See also File class  creating files, 793–794 getting directory contents, 794 methods, 792 overview, 778, 792 walking file tree, 795–797  Index      915   Path variable, 24–25 Pattern class, 521–522 pattern-matching. See regular expression PAUSE command, 42 peek method  LinkedList class, 441, 446 Stack class, 453  peekFirst method, 441, 446 peekLast method, 441, 446 percent sign  % , 100 Perl  Java versus, 9 type checking, 14  PI constant, 112 pipe symbol   , 518–519 pipeline, 467 pivot point, 530 pivot value, 530 Pizza Order application  layout pane, 674 main window, 674 overview, 673 source code, 652–657, 675–680 user order confirmation, 674  PKZIP program, 358 platform independence, 8–9 play method, 312 Playable interface, 304, 313–314 Playable method, 303 PlayableBall interface, 307 playARound method, 197–199, 203, 210 Player class, 292–294 Player program, 255–256 plus sign  + , 100, 377 plusDays method, 549 plusMonths method, 549 plusWeeks method, 549 plusYears method, 549 pointers, 74 poll method, 441, 446 pollFirst method, 441, 446 pollLast method, 441, 446 polymorphism defined, 292 Tic-Tac-Toe example, 292–294  916      Java All-in-One For Dummies  pop method  LinkedList class, 441, 446 Stack class, 453  Pos enumeration, 637–638 POSITIVE_INFINITY constant, 128 postfix operator, 101 postVisitDirectoryFailred method, 795 pow method, 114 predicate, 467 presentation layer, 243–244 previous method, 857 preVisitDirectory method, 795, 797 prevSibling method, 698 primary key, 831 primary stage, 604 primaryStage parameter, 580 primaryStage variable, 581 PrimeClass program, 265 primitive data types  boolean type overview, 79 wrapper class, 80  byte type size of, 75 wrapper class, 80  char type  overview, 78 in switch statements, 185–186 wrapper class, 80  converting to from strings, 83–85 defined, 74 double type  exponent, 76 parse method, 667 wrapper class, 80  float type  exponent, 76 precision of, 76 wrapper class, 80  int type  primitive data types, 74 size of, 75 wrapper class, 80  long type   parse method, 667 wrapper class, 80 objects versus, 319 overview, 73–74 short type  overview, 75 parse method, 667 wrapper class, 80  print method  HTML text, 727 overview, 92 PrintWriter class, 808 printArray method, 536 printf, 12 println method HTML text, 727 overview, 13, 92 PrintWriter class, 808 toString method and, 264  PrintStream class, 12–13 PrintWriter class  connecting to text file, 808–809 description, 807 flush mode, 809, 810 methods, 808 System.err, 92 System.out, 92  PrintWriter method, 727 Priority enumeration, 633–634 private constructor, 259 private fields, 254–255 private instance variables, 760 private keyword, 254 product version, 18 ProductDataException    class, 296  programming, object-oriented  OOP   classes, 57–58 definition, 235–236 objects  creating from class, 59 overview, 57–58  static methods, 58–59 programming languages  Basic, 9  Java  applets, 11 automatic memory management, 15 C C++ experience and, 7 C C++ versus, 12–13 command-line tools, 26–32 disadvantages, 16–17 exception handling, 16 Internet and, 12 language specification, 33–34 machine time, 540–541 object-oriented, 9–10 platform independence, 8–9 servlets, 11 type checking, 13–15 version history, 17–18  LISP programming language, 236 Perl  Java versus, 9 type checking, 14  Simula language, 236 SQL  Structured Query Language   column functions, 835–837 common statements, 829 creating database, 829–832 data definition, 829 data manipulation, 829 defined, 827 deleting rows, 840–841 eliminating duplicates, 838–839 excluding rows, 834 narrowing query, 834 overview, 828 pronouncing, 828 querying database, 832–839 select statement, 832–833 selecting data from multiple tables, 837–838 singleton selects, 835 updating data, 855–856 updating rows, 841–843  UML  Unified Modeling Language   defined, 244 diagramming classes with, 243–247 drawing arrows, 246–247 drawing classes, 245–246  Index      917   programming threads  coordinating, 485–489 creating, 476–480 defined, 476 example, 476 interrupting, 497–503 locks, 496–497 main, 476 overview, 475–476 starting, 480  programs  Actor program, 262 AddSubtract program, 587–590  with anonymous inner classes, 593–594 EventHandler interface, 587–590 with inner classes, 591–593 with lambda expressions, 597–601  BadActorApp program, 262 BirthdayFun program, 557–559 CarWashApp program, 188–190 CarWashStringApp program, 191–192 ChangeParameters program, 209 ClickCounter program, 577–582 ClickCounterAlert program, 615–617 ClickCounterExit program, 622–624 ClickMe program  HTML file that links to JNPL file, 715–716 JNLP file, 713–715 launching, 717–718 source code, 566–567, 710–711 start method, 570–572  CloneTest program, 329–331, 334–338 CopyDemo program, 418–419 CountDown program, 168–169 CountDownApp program, 483–484, 486–489 CountDownAppNew program, 490 CountDownClock program, 479, 496 CountDownClockLocked program, 496–497 CountDownClockNew program, 489 CounterForever program, 155 CounToTen program, 164–165 CountTestApp program, 271–272 CrazyClass program, 263 CrazywithZeros program, 223–226 DiceGame program, 252–253 DirList, 527–529  918      Java All-in-One For Dummies  DividedByZero program, 217–218 Dodecaphobia program, 154–155, 158 DoTwoThingsLocked program, 496 EvenCounter program, 152, 159 ForDodecaphobia program, 172–173 ForEvenCounter program, 167 GenQueue, 458–462 GetABet program, 161–163 GetInteger program, 218–219, 220 GuessingGame program, 175–177, 362 GuessingGameMethod program, 197–199,   204–206, 210–212 Hello World! program  class keyword in, 46 identifiers in, 46–47 main method in, 47, 196–197 overview, 46–48 public keyword in, 46, 47 running, 48 servlets, 727–729 static keyword in, 47 String class in, 47 void keyword in, 47 Invoice program, 270 KnightMoves program, 410–413 LaunchEvent program, 482 LaunchEventNew program, 490 ListMovies, 852–855, 877–880 MarkVowels program, 390 NumberPhobia program, 156 object-oriented programming  OOP   classes, 57–58 objects, 57–58, 59 overview, 235–236 static methods, 58–59  ParameterScope program, 208–209 PizzaOrder program, 652–657 Player program, 255–256 PrimeClass program, 265 RolePlayer program, 663–666 RoundingApp program, 121 SceneSwitcher program, 609–613 SingletonClass program, 272–273 StringBuilderApp program, 390–391 TestClass program, 270 TestEquality program, 322–323   Tick Tock program  with anonymous class, 349–351 with inner class, 343–345 source code, 309–311 with static inner class, 346–347  Validation program, 274 VoterApp program, 179–182 WriteFile program, 811–813  Project Jigsaw. See Java Module System property  attribute, 764 bindings, 583 fields, 583 JavaFX, 689  pseudorandom numbers, 116 public class, 251–253 public instance variables, 758 public interface, 255 public keyword  defined, 195 in Hello World! program, 46, 47 removing, 252–253  push method  LinkedList class, 441 Stack class, 453  quantifiers, 515 queue, 439, 458–462 Queue interface, 445 Quicksort, 530–531 quit method, 313  Q  R  \r escape sequence, 79 radio buttons  creating, 672, 673 defined, 671 toggle groups, 673 RadioButton class constructors, 672 description, 672 methods, 672 overview, 573  random method, 114, 117 random numbers, 116–119 randomInt method, 118 ranges, 513–514 read method, 802, 808 readBoolean method, 814 readByte method, 814 readChar method, 814 readDouble method, 814 readFloat method, 814 readInt method, 814 readLine method, 802 readLong method, 814 README.html, JDK, 24 README.txt, JDK, 24 readMovie method, 820 read-only property, 758 readShort method, 814 readUTF method, 814 recursion  defined, 523 displaying directories, 526–527 factorials  defined, 523 nonrecursive method, 524 recursive method, 524–526  sorting  partition method, 532–534 program, 535–537 Quicksort, 530–531 sort method, 531–532 recursive method, 524–526 reference types  defined, 74 overview, 80–81 return type, 200 reflexive rule, 325 refreshRow method, 857 Region class, 633 regular expression  capture groups, 517 character class  custom, 512–513 defined, 509 ranges, 513–514  Index      919   regular expression  continued   defined, 385, 505 escapes, 516 grouping characters, 516–518 in Java programs, 519–522 Matcher class, 521–522 matching multiple characters, 514–516 matching single characters, 509 negation, 514 overview, 505–506 Pattern class, 521–522 pipe symbol, 518–519 quantifiers, 515 String class, 520–521 String problem, 519–520 test program, 507–509  relational database, 828. See also database relational operators  !=  not equals , 142 overview, 130  relative method, 857 remove method  ArrayList class, 426, 435 Iterator interface, 431 LinkedList class, 441–442, 446 ObservableList class, 687  removeAll method  ArrayList class, 426, 435 LinkedList class, 441–442 ObservableList class, 687  removeFirst method, 441–442, 446 removeFirstOccurrence method, 441–442 removeLast method, 441–442, 446 removeLastOccurrence method, 441–442 removeRange method, 435 renameTo method, 779, 782–783 replace method, 389 representations, 236 request object, 744–745 request scope setting, 767 requestFocus method, 660 request response model, 721 response object, 745 ResultSet interface  description, 848 get methods, 850–851  920      Java All-in-One For Dummies  navigation methods, 849 update methods, 859  retainAll method, 435, 441–442 @return JavaDoc tag, 364 return statement, 201–203 return type, 195, 201, 258 reverse method, 389 rint method, 120 RolePlayer program, 663–666 root directory, 356 root element, XML, 862 root node, 608, 697 round method, 119–120 RoundingApp program, 121 RowConstraints class  constructors, 651 description, 651 example, 652–657 methods, 651  rows  deleting, 840–841 updating, 841–843 rt.java JAR file, 358 Run Java Applet tool, Text Pad, 36 Run Java Application tool, Text Pad, 36 run method, 478, 502 Runnable interface. See also Thread class  creating class, 481–482 overview, 480 using, 418  running program  error messages, 30 java command options, 30 using javac, 29–30  RuntimeException class, 295  S  s format pattern, 555 \\s regular expression, 385 \S regular expression, 510 \s regular expression, 510–511 \\s+ regular expression, 385–386 SalariedEmployee class, 290–291 SAX  Simple API for XML , 868 SAXException, 872   Scanner class defined, 559 exceptions, 215–216 getting input, 94–95 hasNext method, 220 importing, 92–93 methods, 94, 96 overview, 92–93  Scene class, 607–608 Scene constructor, 576 scenes  JavaFX, 607–608 size of, 608 switching, 608–613  SceneSwitcher program, 609–613 Scheduled class, 491 ScheduledThreadPoolExecutor class, 490 scientific notation, 76–77 scope, for variables, 87–89 scriptlets, 742, 746–749 SDK  Software Development Kit , 19 SECONDS, 554 Security Warning prompt, 717 select SQL statement, 829, 832–833, 837–838,   842–843, 849  selectedItemProperty method, 689 selection model, 688–689, 696 SelectionModel class, 689 semicolon  ; , 12, 51, 301, 352, 830 sequenceNumber field, 495 sequential stream, 470 -server option, 30 Servlet class, 722 servlets  classes in, 735–740 creating, 726–729 defined, 11, 722 forms for, 732–733 getting input from user, 732–735 Hello World! program, 727–729 HelloServlet, 730–732 HTTP interaction, 722 HttpServlet class, 726–727 importing packages, 726 InputServlet, 734–735  overview, 721–722 printing to web page, 727 responding with HTML, 727 running, 730 Tomcat  configuring, 723–724 installing, 723–724 starting, 724–725 stopping, 724–725 testing, 725 website, 723 Zip file, 723  session object, 745 session scope setting, 767 set accessor, 255–256 set expressions, 841 set method  ArrayList class, 426 ObservableList class, 686  787, 791  setAlignment method BorderPane class, 644 FlowPane layout, 640 HBox layout, 629 VBox layout, 637  setAcceptAllFileFilterUsed method,    setApproveButtonText method, 787 setBook method, 773 setBottom method, 644 setCenter method  BorderPane class, 575, 644 JavaFX, 580–581  setCharAt method, 390 setColumnAlignment method, 640 setColumnSpan method, 648 setContentType method, 727 setDialogTitle method, 787, 788 setEditable method  ComboBox class, 691, 692 TextField class, 660  setExpanded method, 698 setFileHidingEnabled method, 787, 788 setFileSelectionMode method, 787, 788 setFillHeight method, 651 setFillWidth method, 650  Index      921   setFullScreen method, 605 setHalignment method, 648, 650 setHgap method  FlowPane layout, 641 GridPane layout, 648  setHgrow method  ColumnConstraints class, 650 HBox layout, 629, 633 VBox layout, 636  setIconified method, 605 setIgnoringComments method, 871 setIgnoringElementContentWhitespace   method, 871  setItems method  ChoiceBox class, 682 ComboBox class, 691 ListView class, 695  setLastModified method, 779 setLastName method, 316–317 setLeft method, 644 setLength method, 390 setMargin method  BorderPane class, 644 FlowPane layout, 641 GridPane layout, 648 HBox layout, 629 VBox layout, 636  setMaxHeight method GridPane layout, 648 RowColumnConstraints class, 651 Stage class, 605  setMaximized method, 605, 607 setMaximumFractionDigits method, 122 setMaxWidth method  ColumnConstraints class, 650 GridPane layout, 649 Stage class, 605 TextField class, 660 setMinHeight method GridPane layout, 648 RowColumnConstraints class, 651 Stage class, 605  setMinimumFractionDigits method, 122 setMinWidth method  ColumnConstraints class, 650  922      Java All-in-One For Dummies  GridPane layout, 649 Stage class, 605 TextField class, 660  setMultiSelectionEnabled method, 787 setName method, 478 setOnAction method CheckBox class, 669 ComboBox class, 693 JavaFX, 580 lambda expression, 601 overview, 573 RadioButton class, 672  setOnCloseRequest method, 620, 621 setOrientation method  FlowPane layout, 641 ListView class, 695 setPadding method  FlowPane layout, 641 GridPane layout, 648 HBox layout, 629, 631  setPercentHeight method, 651 setPercentWidth method, 650 setPrefColumnCount method,    660, 663  setPrefHeight method  GridPane layout, 648 RowColumnConstraints class, 651  setPrefWidth method  ColumnConstraints class, 650 GridPane layout, 649 TextField class, 660  setPrefWrapLength method, 641 setPriority method, 478 setPromptText method  ComboBox class, 691, 692 TextField class, 660  setProperty method, 758 setReadOnly method, 779 setResizable method, 605, 606 setRight method, 644 setRoot method, 608, 701 setRootVisible method, 701 setRowAlignment method, 641 setRowSpan method, 648 setScene method, 577, 605   setSelected method  CheckBox class, 669, 670 RadioButton class, 672  setSelectionModel method, 702 setSpacing method  FlowPane layout, 641 HBox layout, 629, 630  setStatus method, 758 setters, 255–256 setText method  CheckBox class, 669 JavaFX, 572–573, 580 RadioButton class, 672 TextField class, 660  setTitle method, 577, 606, 613 setToggleGroup constructor, 673 setTop method, 644 setValidating method, 871 setValignment method, 648, 651 setValue method  ChoiceBox class, 684 TreeItem class, 698  setVgap method, 641, 648 setVgrow method, 651 setVisibleRowCount method, 691 shadowed variables, 89–90 shallow copies, 332–333 shopping cart application, 767–773 short type  overview, 75 parse method, 667 primitive data types, 74 wrapper class, 80  show method  ChoiceBox class, 682, 683 ComboBox class, 691 setting stage, 577 Stage class, 606  signature, 258 signum method, 114 Simple API for XML  SAX , 868 SimpleFileVisitor class, 795–797 Simula language, 236 simulation, 236 @since JavaDoc tag, 364 single quote  \’  escape sequence, 79 singleton, 272–273 singleton selects, 835 SingletonClass program, 272–273 size method  ArrayList class, 426 DataOutputStream class, 821 GenQueue class, 458 LinkedList class, 441–442 ObservableList class, 687 Stack class, 453 skip method, 802 sleep method, 498 Softball class, 290 sort method  Arrays class, 416–417 Quicksort, 531–532 versions, 537  sorting  partition method, 532–534 program, 535–537 Quicksort, 530–531 sort method, 531–532  source code, 24 -source compiler option, 28, 29 source files  defined, 21 editing in TextPad, 36–38  -sourcepath compiler option, 28 Spinoff program, 704–706 SQL  Structured Query Language . See also JDBC  Java   showAndWait method, 606 showDialog method, 787 showNightMoves method, 414 showOpenDialog method, 786, 787, 789 showSaveDialog method, 787, 788 -showversion option, 30 sibling node, 697  Database Connectivity  column functions, 835–837 common statements, 829 creating database, 829–832 data definition, 829 data manipulation, 829 defined, 827  Index      923   SQL  Structured Query Language   continued   deleting rows, 840–841 eliminating duplicates, 838–839 excluding rows, 834 narrowing query, 834 overview, 828 pronouncing, 828 querying database, 832–839 select statement, 832–833 selecting data from multiple tables, 837–838 singleton selects, 835 updating data, 855–856 updating rows, 841–843  SQLException, 847 sqrt method, 114 stack trace, 215–216 stacks, 439, 453–456 stage  JavaFX, 576–577 primary, 604  Stage class  methods, 605–606 overview, 604 start method  CheckBox class, 670 JavaFX, 569–572, 580, 604 Thread class, 478 start tag, XML, 862 startGame method, 305 state, 10, 58 Statement interface, 848 statements  assigned, 71 break statement  for loops, 154, 155 switch statement, 183 switch statement. omitting in, 188–191  declaration, 51 defined, 51 else-if statements  defined, 139–141 switch statement versus, 179–182  expression, 51 if statements  else-if statements, 139–141 if-else statements, 134–135  924      Java All-in-One For Dummies  if-then statements, 52 inner, 136 nested, 135–139 outer, 136 overview, 132–134  return statement, 201–203 switch statements  char type cases, 185–186 commission rate example, 184–185 default group, 183 else-if statement versus, 179–182 if statements inside of, 185–186 omitting break statements, 188–191 overview, 183 string type cases, 191–192 voting machine error decoder program, 179–182  try statements  catching exceptions, 217, 222 catching FileNotFoundException, 227–228  types of, 51–52 while, 51, 152 white space, 52–53  static design, 267 static display, 267 static fields  defined, 269 overview, 267–268 uses of, 268 static initializer  defined, 251, 266 uses of, 240, 269, 274–275  static inner class, 342, 345–347 static keyword, 47, 58, 195 static methods  defined, 267, 269 overview, 58–59, 267–268 uses of, 268  stop method, 569 Stream class, 467 Stream interface, 464, 467–470 stream method, 467 streams  aggregate methods, 468–469 binary streams  classes for reading, 814 defined, 800   reading, 813–820 reading from data input stream, 815–817 reading from file, 817–820 writing, 820–826 writing to file, 823–827  character streams  defined, 800 reading, 801–806 reading from file, 803–806 writing, 807–813 defined, 464, 800 interface, 467–470 mapping methods, 468 overview, 800 parallel, 470–471 sequential, 470 terminal methods, 468–469  String class  documentation page for, 34 in Hello World! program, 47 methods, 378–380 regular expression, 520–521  string data type, 14 string literals, 82 StringBuffer class, 388 StringBuilder class  capacity, 388 creating object, 388 example, 390–391 length, 388 methods, 388–390 overview, 387–388  StringBuilderApp program, 390–391 StringIndexOutOfBoundsException, 381 strings  characters versus, 376 combining, 83 comparing, 149–150, 378 concatenating, 377 converting arrays to, 420–421 converting to numbers, 667–668 converting to from primitive data types, 83–85 declaring, 82 defined, 82 escape sequences, 376  initializing, 82 length of, 380, 388 modifying, 380–381 overview, 82, 376–378 replacing parts of, 386–387 splitting, 384–386 substrings, 382–384 switch statements, 191–192  structure charts  defined, 244 extracting characters, 381–382 Structured Query Language  SQL   column functions, 835–837 common statements, 829 creating database, 829–832 data definition, 829 data manipulation, 829 defined, 827 deleting rows, 840–841 eliminating duplicates, 838–839 excluding rows, 834 narrowing query, 834 overview, 828 pronouncing, 828 querying database, 832–839 select statement, 832–833 selecting data from multiple tables, 837–838 singleton selects, 835 updating data, 855–856 updating rows, 841–843  style sheets, 564–565 subclass  creating, 281–282 defined, 242, 278 inheritance, 266 super keyword, 284–285 this keyword, 284–285  subinterface, 306–307 subSequence method, 391 substrings, 382–384 sum column function, 836 sum method, 469 summaryStatistics method, 469 super keyword, 284–285 superclass, 242, 278  Index      925   superinterface, 306–307 swap method, 534 switch statements  char type cases, 185–186 commission rate example, 184–185 default group, 183 else-if statement versus, 179–182 if statements inside of, 185–186 omitting break statements, 188–191 overview, 183 string type cases, 191–192 voting machine error decoder program, 179–182  symbols, 47 synchronized keyword, 494–495 System class, 13, 64 System Variables list, 25 System.err, 92 System.out, 13, 92 System.out.print, 95 System.out.println, 48, 170, 174, 466,    556, 856  T  \t escape sequence, 79, 376 t jar command option, 359 \\t regular expression, 385 tab  \t  escape sequence, 376 tab-delimited file, 800 tags  HTML, 863 XML, 862–863  -target compiler option, 28 terminal methods, streams, 468–469 ternary operators, 101, 148 Test class, 784 test expression, 164 TestClass program, 270 TestEquality program, 322–323 text editors, 21 text field  creating, 660–663 defined, 660 displaying prompt inside, 662 retrieving value, 662 RolePlayer program, 663–666  926      Java All-in-One For Dummies  TheadPool class, 491 this keyword, 262–264, 284–285 Thread class. See also Runnable interface  Text interface, 874 TEXT_NODE field, 873 TextField class  constructors, 660 methods, 660 overview, 573  TextPad  advantages of, 21 colors in, 37 compiling programs, 40–42 configuring, 36 downloading, 35–36 editing source files in, 36–38 features, 37–38 installing, 35–36 overview, 35 workspaces in, 38  constructors, 478 extending, 478–479 methods, 478  threads  coordinating, 485–489 creating, 476–480 defined, 476 example, 476 interrupting, 497–503 locks, 496–497 main, 476 overview, 475–476 starting, 480  ThrowableBall interface, 307 throwBall method, 307 throws clause, 228 @throws JavaDoc tag, 364 Tick Tock program  with anonymous class, 349–351 with inner class, 343–345 source code, 309–311 with static inner class, 346–347  Ticker class, 311 TicTacToe class, 304 Tic-Tac-Toe example, 292–294   time  birthday calculator, 556–559 calculating, 552–554 creating objects, 542–547 Date-Time API  class listing, 542 Java 8, 539 LocalDate class, 548–550 of method, 545–546 methods, 546 Month enumeration, 545–547 now method, 542–544 parse method, 544–545 ZoneID class, 547, 548  extracting information, 550–551 human time, 540 immutable objects, 552 machine calculation of, 540–541 representation, 540–541  TimeMonitor interface, 488 Timer class, 309, 311 toAbsolutePath method, 792 toArray method  ArrayList class, 426 LinkedList class, 441–442  toBack method, 606 toFront method, 606 ToggleGroup object, 672 tokens, 220 Tomcat  configuring, 723–724 installing, 723–724 starting, 724–725 stopping, 724–725 testing, 725 website, 723 Zip file, 723  File class, 779 JSP expressions, 744 LocalDate class, 554 overriding, 321–322 overview, 319 Path class, 793 StringBuilder class, 390 using, 320  touch interface, JavaFX, 565 TouchEvent class, 584 traditional comments, 56–57 tree views  building tree, 698–701 child node, 697, 699 collapsed node, 698 creating control, 699, 702 defined, 697 elements, 697 expanded node, 698 getting selected node, 702–704 leaf node, 698 nodes, 697 parent node, 697, 699 path, 698 root node, 697 sibling node, 697 Spinoff program, 704–706 value, 699  constructors, 698 methods, 698 overview, 697 TreeView class  constructors, 701 methods, 701 overview, 701  tree_SelectionChanged method, 703–704 TreeItem class  Tool Results pane, Text Pad, 39 toString method  ArrayList class, 430, 465 CharSequence interface, 391 ChoiceBox class, 683 converting arrays to strings, 421–422 defined, 417  Triangle JavaBean class, 759–761 trimToSize method, 390 true, 49 try block, 222 try statement  catching exceptions, 217, 222 catching FileNotFoundException, 227–228  Index      927   tryToChangeNumber method, 209–210 two-dimensional arrays  accessing elements, 403–404 creating, 402–403 initializing, 405 overview, 401–402  txtCount text field, 667 type checking, 13–15 typecasting, overview, 86  U  u jar command option, 359 UML  Unified Modeling Language   defined, 244 diagramming classes with, 243–247 drawing arrows, 246–247 drawing classes, 245–246  unary operators  defined, 101 logical operators, 141 plus and minus, 105–106  unboxing, 87 unchecked exceptions, 215 Unicode, 78 Unicode  UTF  string, 815 Unified Modeling Language  UML   defined, 244 diagramming classes with, 243–247 drawing arrows, 246–247 drawing classes, 245–246  Unix operating system, 540–541 until method, 549 unwrapping, 87 update SQL statement, 829, 841–843, 856 updateBigDecimal method, 859 updateBoolean method, 859 updateDate method, 859 updateDouble method, 859 updateFloat method, 859 updateInt method, 859 updateLong method, 859 updateRow method, 857 updateShort method, 859 updateString method, 859 use SQL statement, 829, 831  928      Java All-in-One For Dummies  user input  check boxes  checked state, 669 creating, 669–670 defined, 668 undefined state, 669  overview, 659 Pizza Order application  layout pane, 674 main window, 674 overview, 673 source code, 675–680 user order confirmation, 674  radio buttons  creating, 672, 673 defined, 671 toggle groups, 673  servlets, 732–735 text field  creating, 660–663 defined, 660 displaying prompt inside, 662 retrieving value, 662 RolePlayer program, 663–666 validating numeric data, 667  validating numeric data, 667–668  UTF  Unicode  string, 815 UTF-16, 815 UTF-8, 815 utils.jar file, 361  V  V format pattern, 555 v jar command option, 359 Validation program, 274 value types, 74 variables  counter, 166–167 declaring  class variables, 67–68 final variables, 72–73 instance variables, 68–69 local variables, 69–70 multiple variables in one statement, 67 overview, 66   initializing  with assigned statements, 71 defined, 70–71 with initializers, 72  scope, 87–89 shadowing, 89–90  VBox layout  constructors, 636 defined, 626 making nodes the same width, 638–639 methods, 636 overview, 635–637 Pizza Order application, 674  Vector class, 687 velocity field, 285   attribute, 715 -verbose compiler option, 28, 29, 30 -version compiler option, 28 @version JavaDoc tag, 364 -version option, 30 vertical flow layout, 639 virtual machine, 8 VirtualMachineError, 295 visibility  defined, 254–255 indicator, 245–246 inheritance, 266 keywords, 269 modules, 369  visitFile method, 795, 797 visitFileFailed method, 795, 797 visual effects, JavaFX, 565 void keyword, in Hello World! program, 47 VoterApp program, 179–182 voting machine error decoder program, 179–182  W  \w regular expression, 510–512 \W regular expression, 510–512 Web server, 716–717 Web Settings tab, Java Control Panel, 718–719 Web Start  creating HML file, 715–716 creating JNLP file, 713–715  defined, 11 exceptions, 718–719 launching application, 717–718 overview, 712 setting application to run, 712–713 uploading files to Web server, 716–717  WEEKS, 554 where clause, 838, 840–841 while loop, 152–153, 461, 806 while statements, 51, 152, 432 white space, 52–53 wildcard character  * , 64 wildcards, 457–458 WindowEvent class, 584 word processors, 476 workspaces, in TextPad, 38 wrapper classes, 79–80 wrapping, 87 write method, 822 writeBoolean method, 821 writeByte method, 821 writeChar method, 821 writeDouble method, 821 WriteFile program, 811–813 writeFloat method, 821 writeInt method, 821 writeLong method, 821 writeMovie method, 812–813, 825–826 write-only property, 758 writeShort method, 822 writeUTF method, 822 -X compiler option, 28  X  x jar command option, 359 -X option, 31 XML  Extensible Markup Language   attributes  defaults, 868 defined, 863–864 types, 867 values, 875–878  child elements, 876–877 declaration, 864  Index      929   XML  Extensible Markup Language   continued   DOM  creating document, 871–872 defined, 868 document tree, 869–870 reading document, 869–872 reading DOM nodes, 872–877  DTD, 865–868 element content, 867 ListMovies program, 877–880 movie.xml file, 864–865 overview, 861–862 processing elements, 874–875 SAX, 868 tags, 862–863  Xor  ^  logical operator, 142, 145–146  y format pattern, 555 Year class, 542, 546 YearMonth class, 542, 546 YEARS, 554 yield method, 478, 498  Y  Z  z format pattern, 555 zero  dividing by, 126–128 floating-point values for, 78  Zip files, 358 ZonedDateTime class, 542, 547 ZoneID class, 547, 548  930      Java All-in-One For Dummies   About the Author  Doug Lowe has been writing computer programming books since the guys who  invented Java were in high school. He’s written books on COBOL, FORTRAN, Visual  Basic,  IBM  mainframe  computers,  midrange  systems,  PCs,  web  programming,  and probably a few he’s long since forgotten about. He’s the author of more than  30 For Dummies books, including Networking For Dummies, 11th Edition; Networking  All-In-One For Dummies, 5th Edition; PowerPoint 2016 For Dummies; and Electron- ics All-In-One For Dummies, 2nd Edition  all published by Wiley . He lives in that  sunny  all-American  city  Fresno,  California,  where  the  motto  is  “Please,  Let  It  Rain!”    Dedication  To my beautiful wife, Kristen Gearhart.  Author’s Acknowledgments  I’d like to thank everyone at Wiley who was involved in the creation of this book,  starting with project editor Elizabeth Kuball, who did a great job of managing all  the editorial work required to put this book together in spite of the fact that the  book was delayed by the long development cycle of Java 9. I’d also like to thank  John Mueller for his excellent and thorough technical review.   Publisher’s Acknowledgments  Executive Editor: Steve Hayes Project Editor: Elizabeth Kuball Copy Editor: Elizabeth Kuball Editorial Assistant: Serena Novosel Sr. Editorial Assistant: Cherie Case  Production Editor: Vasanth Koilraj Brand Consultant: John Mueller Cover Image:   Napat Shutterstock         WILEY END USER LICENSE AGREEMENT  Go to www.wiley.com go eula to access Wiley’s ebook EULA.


@highlight

best quality with: true PDF & interactive a table of contents
Your one-stop guide to programming with JavaIf youve always wanted to program with Java but didnt know where to start, this will be the java-stained reference youll turn to again and again. Fully updated for the JDK 9, this deep reference on the worlds most popular programming language is the perfect starting point for building things with Java—and an invaluable ongoing reference as you continue to deepen your knowledge.

Clocking in at over 900 pages, Java All-in-One For Dummies takes the intimidation out of learning Java and offers clear, step-by-step guidance on how to download and install Java tools work with variables, numbers, expressions, statements, loops, methods, and exceptions create applets, servlets, and JavaServer pages handle and organize data and so much more.

Focuses on the vital information that enables you to get up and running quickly with Java
Provides details on the new features of JDK 9
Shows you how to create simple Swing programs
Includes design tips on layout, buttons, and labels
Everything you need to know to program with Java is included in this practical, easy-to-use guide!