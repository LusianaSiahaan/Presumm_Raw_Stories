Wrox Programmer to Programmer TM  Michael Kay  Michael Kay has been working in the XML ﬁ eld since  1997. He became a member of the XSL Working Group  soon after the publication of XSLT 1.0 and took over as  editor of the XSLT 2.0 speciﬁ cation in early 2001. He is  also a member of the XQuery and XML Schema Working  Groups, and is a joint editor of the XPath 2.0 speciﬁ cation.   He is well known not only through previous editions of this  book, but also as the developer of the open-source Saxon  product, a pioneering implementation of XSLT 2.0,  XPath 2.0, and XQuery 1.0. In 2004 the author  formed his own company, Saxonica, to provide  commercial software and services building  on the success of the Saxon technology.  XSLT 2.0 and  XPath 2.0  4th Edition   Programmer’s Reference  Michael Kay  Updates, source code, and Wrox technical support at www.wrox.com   Programmer to Programmer TM  BROWSE BOOKS  P2P FORUM  FREE NEWSLETTER  ABOUT WROX  Get more Wrox at Wrox.com!  Special Deals Take advantage of special offers  every month  Free Chapter Excerpts Be the ﬁ rst to preview chapters from  the latest Wrox publications  Unlimited Access . . . . . . to over 200 of our books in the  Wrox Reference Library  see more  details online   Forums, Forums, Forums Take an active role in online  discussions with fellow programmers  Meet Wrox Authors! Read running commentaries from authors on their programming experiences  and whatever else they want to talk about  Browse Books  .NET SQL Server Java  XML Visual Basic C C++  Join the community!     Sign up for our free monthly newsletter at     newsletter.wrox.com   XSLT 2.0 and XPath 2.0 Programmer’s Reference  4th Edition  Part I: Foundations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 Chapter 1: XSLT in Context . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 Chapter 2: The XSLT Processing Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41 Chapter 3: Stylesheet Structure. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89 Chapter 4: Stylesheets and Schemas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151 Chapter 5: Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185 Part II: XSLT and XPath Reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225 Chapter 6: XSLT Elements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227 Chapter 7: XPath Fundamentals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521 Chapter 8: XPath: Operators on Items . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 571 Chapter 9: XPath: Path Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 599 Chapter 10: XPath: Sequence Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 633 Chapter 11: XPath: Type Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 653 Chapter 12: XSLT Patterns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 681 Chapter 13: The Function Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 709 Chapter 14: Regular Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 915 Chapter 15: Serialization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 929 Part III: Exploitation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 951 Chapter 16: Extensibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 953 Chapter 17: Stylesheet Design Patterns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 973 Chapter 18: Case Study: XMLSpec . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1001 Chapter 19: Case Study: A Family Tree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1049 Chapter 20: Case Study: Knight’s Tour. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1099 Part IV: Appendices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1115 Appendix A: XPath 2.0 Syntax Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1117 Appendix B: Error Codes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1123 Appendix C: Backward Compatibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1139 Appendix D: Microsoft XSLT Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1147 Appendix E: for Transformation . . . . . . . . . . . . . . . 1163 Appendix F: Saxon . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1195 Appendix G: Altova . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1215 Appendix H: Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1221 Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1233  JAXP: The Java API    XSLT 2.0 and XPath 2.0  Programmer’s Reference  4th Edition  Michael Kay  Wiley Publishing, Inc.   XSLT 2.0 and XPath 2.0 Programmer’s Reference 4th Edition Published by Wiley Publishing, Inc. 10475 Crosspoint Boulevard Indianapolis, IN 46256 www.wiley.com Copyright   2008 by Wiley Publishing, Inc., Indianapolis, Indiana Published simultaneously in Canada  ISBN: 978-0-470-19274-0  Manufactured in the United States of America  10 9 8 7 6 5 4 3 2 1  Library of Congress Cataloging-in-Publication Data is available from the publisher.  No part of this publication may be reproduced, stored in a retrieval system or transmitted in any form or by any means, electronic, mechanical, photocopying, recording, scanning or otherwise, except as permitted under Sections 107 or 108 of the 1976 United States Copyright Act, without either the prior written permission of the Publisher, or authorization through payment of the appropriate per-copy fee to the Copyright Clearance Center, 222 Rosewood Drive, Danvers, MA 01923,  978  750-8400, fax  978  646-8600. Requests to the Publisher for permission should be addressed to the Legal Department, Wiley Publishing, Inc., 10475 Crosspoint Blvd., Indianapolis, IN 46256,  317  572-3447, fax  317  572-4355, or online at http:  www.wiley.com go permissions.  Limit of Liability Disclaimer of Warranty: The publisher and the author make no representations or warranties with respect to the accuracy or completeness of the contents of this work and speciﬁcally disclaim all warranties, including without limitation warranties of ﬁtness for a particular purpose. No warranty may be created or extended by sales or promotional materials. The advice and strategies contained herein may not be suitable for every situation. This work is sold with the understanding that the publisher is not engaged in rendering legal, accounting, or other professional services. If professional assistance is required, the services of a competent professional person should be sought. Neither the publisher nor the author shall be liable for damages arising herefrom. The fact that an organization or Website is referred to in this work as a citation and or a potential source of further information does not mean that the author or the publisher endorses the information the organization or Website may provide or recommendations it may make. Further, readers should be aware that Internet Websites listed in this work may have changed or disappeared between when this work was written and when it is read.  For general information on our other products and services please contact our Customer Care Department within the United States at  800  762-2974, outside the United States at  317  572-3993 or fax  317  572-4002.  Trademarks: Wiley, the Wiley logo, Wrox, the Wrox logo, Wrox Programmer to Programmer, and related trade dress are trademarks or registered trademarks of John Wiley & Sons, Inc. and or its afﬁliates, in the United States and other countries, and may not be used without written permission. All other trademarks are the property of their respective owners. Wiley Publishing, Inc., is not associated with any product or vendor mentioned in this book.  Wiley also publishes its books in a variety of electronic formats. Some content that appears in print may not be available in electronic books.   To Anyone Who Uses This Book To Make the World a Better Place    About the Author  Michael Kay has been working in the XML ﬁeld since 1997; he became a member of the XSL Working Group soon after the publication of XSLT 1.0, and took over as editor of the XSLT 2.0 speciﬁcation in early 2001. He is also a member of the XQuery and XML Schema Working Groups, and is a joint editor of the XPath 2.0 speciﬁcation. He is well known not only through previous editions of this book but also as the developer of the open source Saxon product, a pioneering implementation of XSLT 2.0, XPath 2.0, and XQuery 1.0.  In 2004 the author formed his own company, Saxonica, to provide commercial software and services building on the success of the Saxon technology. Previously, he spent three years with Software AG, working with the developers of the Tamino XML server, an early XQuery implementation. His back- ground is in database technology: after leaving the University of Cambridge with a Ph.D., he worked for many years with the  then  computer manufacturer ICL, developing network, relational, and object- oriented database software products as well as a text search engine, and held the position of ICL Fellow.  Michael lives in Reading, England, with his wife and daughter. His hobbies  reﬂected in his choice of examples  include genealogy and choral singing, and once included chess. Since completing the previous edition he has found time to improve his croquet handicap to 6.    Director of Acquisitions Jim Minatel  Development Editor Maureen Spears  Technical Editor Sam Judson  Production Editor Angela Smith  Copy Editor Foxxe Editorial Services  Editorial Manager Mary Beth Wakeﬁeld  Credits  Production Manager Tim Tate  Vice President and Executive Group Publisher Richard Swadley  Vice President and Executive Publisher Joseph B. Wikert  Project Coordinator, Cover Lynsey Stanford  Proofreader Nancy Carrasco  Indexer Robert Swanson   Acknowledgments  There are two groups of people I must thank: those who contributed to the book, and those who supported me in writing it.  In the ﬁrst group, I am indebted to readers of previous editions who have pointed out my errors, and have told me what they liked and didn’t like. I hope readers of this edition will do the same. Also to the  by now numerous  reviewers and editors engaged ﬁrst by the original Wrox team in the UK, and more recently by their successors in Wiley, who have done so much of the legwork of testing example code and ﬁnding continuity errors, not to mention handling the unseen production processes that turn a heap of word-processed text into a ﬁnished book. Then my colleagues on the working groups, who provided the subject matter for me to write about, and those who taught me how to use the language — if you ﬁnd a programming pearl that you particularly like in this book, the chances are I stole the idea from someone. James Clark in particular, who invented the XSLT language and showed me how it worked.  In the second group, I must once again acknowledge the patience of my family, who sighed resignedly when I suggested the prospect of retreating to my study for half a year to produce a new revision, and the generosity of my past employers who provided the time to get the project off the ground in the ﬁrst place.   Contents  Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xxix List of Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .xxxix  Part I: Foundations  Chapter 1: XSLT in Context  What Is XSLT? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Why Version 2.0? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A Scenario: Transforming Music . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . How Does XSLT Transform XML? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . XSLT and SQL: An Analogy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . XSLT Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A Simple XSLT Stylesheet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . An XSLT 2.0 Stylesheet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . The Place of XSLT in the XML Family . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . XSLT and XSL Formatting Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . XSLT and XPath . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . XSLT and XML Namespaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . XSLT and CSS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . XSLT and XML Schemas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . XSLT and XQuery . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . The History of XSL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Prehistory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . The First XSL Proposal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Saxon . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Beyond XSLT 1.0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Convergence with XQuery . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . The Development of XSLT 2.0 and XPath 2.0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . XSLT 2.0 as a Language . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Use of XML Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . No Side Effects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Rule-Based . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Types Based on XML Schema . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A Two-Language System: XSLT and XPath . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3  3 5 5 7 8 9 10 19 21 22 22 23 24 24 26 26 26 28 30 30 31 32 33 33 34 35 38 39 40   Contents  Chapter 2: The XSLT Processing Model  The XDM Tree Model  XSLT: A System Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A Simpliﬁed Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Trees, Not Documents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Different Output Formats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Multiple Inputs and Outputs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . XML as a Tree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Completing the UML Class Diagram . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Document Order . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Names and Namespaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDs and IDREFs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Characters in the Data Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . What Does the Tree Leave Out?. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . From Textual XML to a Data Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Controlling Serialization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . The Transformation Process . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Invoking a Transformation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Template Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Push Processing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Controlling Which Nodes to Process . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Built-In Template Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Conﬂict Resolution Policy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Error Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Variables and Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Context . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Temporary Documents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  41  41 41 42 43 44 45 45 56 57 58 61 62 64 65 67 67 67 68 74 76 78 78 79 80 80 81 82 82 84 85 88  89  Chapter 3: Stylesheet Structure  90 Changes in XSLT 2.0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90 The Modular Structure of a Stylesheet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98 The   Element . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . The   Processing Instruction . . . . . . . . . . . . . . . . . . . . . . . . . 99 Embedded Stylesheets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102  xii   Contents  Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104 XSLT-Deﬁned Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105 Implementor-Deﬁned Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106 User-Deﬁned Top-Level Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107 Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108 XSLT Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108 Extension Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111 Literal Result Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112 Attribute Value Templates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122 Simpliﬁed Stylesheets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125 Writing Portable Stylesheets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127 Conditional Compilation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127 Version Compatibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128 Extensibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134 Whitespace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141 The Effect of Stripping Whitespace Nodes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146 Whitespace Nodes in the Stylesheet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146 Solving Whitespace Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148  Chapter 4: Stylesheets and Schemas  151  XML Schema: An Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151 Simple Type Deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152 Elements with Attributes and Simple Content . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154 Elements with Mixed Content . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155 Elements with Element-Only Content . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156 Deﬁning a Type Hierarchy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157 Substitution Groups . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158 Declaring Types in XSLT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161 Validating the Source Document . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165 Validating the Result Document . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170 Validating a Temporary Document . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174 Validating Individual Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176 Validating Individual Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179 The default-validation Attribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180 Importing Schemas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180 Using xsi:type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181 Nillability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183  xiii   Contents  Chapter 5: Types  185  What Is a Type System? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185 Changes in 2.0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186 Sequences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187 Atomic Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189 Atomic Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191 The Major Atomic Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193 The Minor Atomic Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206 Derived Numeric Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 210 Derived String Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213 Untyped Atomic Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215 xs:NMTOKENS, xs:IDREFS, and xs:ENTITIES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217 Schema Types and XPath Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217 The Type Matching Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219 Static and Dynamic Type Checking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224  Part II: XSLT and XPath Reference  Chapter 6: XSLT Elements  227  xsl:analyze-string . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230 xsl:apply-imports . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237 xsl:apply-templates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240 xsl:attribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254 xsl:attribute-set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 266 xsl:call-template . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 271 xsl:character-map . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280 xsl:choose . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282 xsl:comment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 285 xsl:copy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 287 xsl:copy-of . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 292 xsl:decimal-format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 298 xsl:document . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 303 xsl:element . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 306 xsl:fallback . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 316 xsl:for-each . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 322 xsl:for-each-group . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 326 xsl:function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 344 xsl:if . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 353  xiv   Contents  xsl:import . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 357 xsl:import-schema . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 368 xsl:include . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 372 xsl:key . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 376 xsl:matching-substring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 386 xsl:message . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 386 xsl:namespace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 390 xsl:namespace-alias . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 394 xsl:next-match . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399 xsl:non-matching-substring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 402 xsl:number . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 403 xsl:otherwise . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 420 xsl:output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 420 xsl:output-character . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 424 xsl:param . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 425 xsl:perform-sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 437 xsl:preserve-space . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 439 xsl:processing-instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 442 xsl:result-document . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 445 xsl:sequence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 452 xsl:sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 455 xsl:strip-space . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 465 xsl:stylesheet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 465 xsl:template . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 483 xsl:text . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 492 xsl:transform . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 495 xsl:value-of . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 495 xsl:variable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 500 xsl:when . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 515 xsl:with-param . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 517 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 519  Chapter 7: XPath Fundamentals  Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 522 Where to Start . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 523 Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 524 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 527 Lexical Constructs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 527 Comments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529 Numeric Literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 530  521  xv   Contents  String Literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 532 Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 534 Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 537 Primary Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 540 Variable References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 540 Usage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 540 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 541 Parenthesized Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 542 Changes in XPath 2.0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 543 Context Item Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 543 Changes in XPath 2.0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 544 Usage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 544 Function Calls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 544 Identifying the Function to be Called . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 545 Converting the Arguments and the Result . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 547 Changes in XPath 2.0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 549 Side Effects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 549 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 550 Conditional Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 551 Changes in XPath 2.0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 552 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 553 The XPath Evaluation Context . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 553 The Static Context . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 554 The Dynamic Context . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 563 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 568  Chapter 8: XPath: Operators on Items  571  Arithmetic Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 571 Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 571 Type Promotion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 572 Changes in XPath 2.0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 573 Effect . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 573 Arithmetic Using Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 574 Examples of Numeric Arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 576 Arithmetic Using Durations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 577 Value Comparisons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 581 Permitted Operand Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 582 Type Checking for Value Comparisons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 586 Examples of Value Comparisons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 587  xvi   Contents  General Comparisons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 588 Changes in XPath 2.0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 588 Rules for General Comparisons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 589 Existential Comparison . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 590 Examples of General Comparisons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 592 Node Comparisons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 593 The «is»Operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 593 The operators «<<» and «<<» . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 594 Changes in XPath 2.0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 594 Boolean Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 594 Shortcut Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 595 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 596 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 596  Chapter 9: XPath: Path Expressions  599  Examples of Path Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 600 Changes in XPath 2.0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 601 Document Order and Duplicates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 602 The Binary « ⁄ » Operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 602 Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 602 Effect . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 603 Examples of the Binary « ⁄ » Operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 604 Associativity of the « ⁄ » Operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 605 Axis Steps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 606 Syntax of Axis Steps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 606 Effect . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 607 Examples of Axis Steps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 608 Axes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 609 Node Tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 613 Name Tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 614 Kind Tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 616 Predicates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 617 Abbreviated Axis Steps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 621 Rooted Path Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 625 Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 625 Examples of Rooted Paths . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 626 ⁄ » Abbreviation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 626 Examples Using « ⁄ ⁄ » . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 627 Comparing « ⁄ ⁄ » with « ⁄ descendant::» . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 628 Combining Sets of Nodes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 628 Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 629  The « ⁄  xvii   Contents  Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 630 Usage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 630 Set Intersection and Difference in XPath 1.0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 631 Sets of Atomic Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 631 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 632  Chapter 10: XPath: Sequence Expressions  633  The Comma Operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 634 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 635 Numeric Ranges: The «to» Operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 636 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 637 Filter Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 638 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 640 The «for» Expression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 640 Mapping a Sequence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 641 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 642 The Context Item in a «for» Expression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 642 Combining Multiple Sequences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 643 Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 644 Simple Mapping Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 644 The «some» and «every» Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 646 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 648 Quantiﬁcation and the «=» Operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 649 Errors in «some» and «every» Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 649 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 651  Chapter 11: XPath: Type Expressions  653  Converting Atomic Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 654 Converting between Primitive Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 656 Converting between Derived Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 664 Sequence Type Descriptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 668 Matching Atomic Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 669 Matching Nodes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 670 Matching Elements and Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 672 The «instance of» Operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 677 The «treat as» Operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 678 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 680  Chapter 12: XSLT Patterns  681  Patterns and Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 681 Changes in XSLT 2.0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 682  xviii   Contents  The Formal Deﬁnition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 683 Applying the Deﬁnition in Practice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 684 An Algorithm for Matching Patterns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 685 Patterns Containing Predicates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 685 An Informal Deﬁnition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 685 Conﬂict Resolution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 686 Matching Parentless Nodes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 688 The Syntax of Patterns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 689 Pattern . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 689 PathPattern . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 690 RelativePathPattern . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 693 PatternStep . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 694 IdKeyPattern . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 704 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 708  Chapter 13: The Function Library  709  A Word about Naming . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 710 Functions by Category . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 710 Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 712 Code Samples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 714 Function Deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 714 abs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 714 adjust-date-to-timezone, adjust-dateTime-to-timezone, adjust-time-to-timezone . . . . . . . . . . 715 avg . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 718 base-uri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 719 boolean . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 721 ceiling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 723 codepoint-equal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 724 codepoints-to-string . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 725 collection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 726 compare . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 727 concat . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 729 contains . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 730 count . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 733 current . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 734 current-date, current-dateTime, current-time . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 738 current-group . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 739 current-grouping-key . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 740 current-Time . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 741 data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 741 dateTime . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 743 day-from-date, day-from-dateTime . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 744  xix   Contents  days-from-duration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 745 deep-equal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 745 default-collation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 748 distinct-values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 749 doc, doc-available . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 750 document . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 754 document-uri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 764 element-available . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 764 empty . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 770 encode-for-uri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 771 ends-with . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 773 error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 774 escape-html-uri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 775 exactly-one . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 777 exists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 778 false . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 779 ﬂoor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 779 format-date, format-dateTime, format-time . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 781 format-number . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 788 format-time . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 792 function-available . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 792 generate-id . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 797 hours-from-dateTime, hours-from-time . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 800 hours-from-duration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 801 id . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 802 idref . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 804 implicit-timezone . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 806 index-of . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 807 in-scope-preﬁxes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 808 insert-before . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 810 iri-to-uri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 811 key . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 812 lang . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 819 last . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 820 local-name . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 824 local-name-from-QName . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 826 lower-case . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 827 matches . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 828 max, min . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 830 min . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 832 minutes-from-dateTime, minutes-from-time . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 832 minutes-from-duration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 832  xx   Contents  minutes-from-time . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 833 month-from-date, month-from-dateTime . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 833 months-from-duration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 834 name . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 835 namespace-uri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 837 namespace-uri-for-preﬁx . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 839 namespace-uri-from-QName . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 841 nilled . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 842 node-name . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 843 normalize-space . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 845 normalize-unicode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 847 not . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 850 number . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 851 one-or-more . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 853 position . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 854 preﬁx-from-QName . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 857 QName . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 858 regex-group . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 860 remove . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 861 replace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 862 resolve-QName . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 864 resolve-uri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 867 reverse . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 869 root . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 870 round . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 870 round-half-to-even . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 872 seconds-from-dateTime, seconds-from-time . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 873 seconds-from-duration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 874 seconds-from-time . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 875 starts-with . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 875 static-base-uri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 876 string . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 877 string-join . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 879 string-length . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 880 string-to-codepoints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 881 subsequence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 882 substring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 883 substring-after . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 885 substring-before . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 887 sum . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 889 system-property . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 890 timezone-from-date, timezone-from-dateTime, timezone-from-time . . . . . . . . . . . . . . . . . . . . . 893  xxi   Contents  tokenize . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 894 trace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 896 translate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 897 true . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 899 type-available . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 899 unordered . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 901 unparsed-entity-public-id, unparsed-entity-uri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 902 unparsed-text, unparsed-text-available . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 904 upper-case . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 910 year-from-date, year-from-dateTime . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 911 years-from-duration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 911 zero-or-one . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 912 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 913  Chapter 14: Regular Expressions  915  Branches and Pieces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 916 Quantiﬁers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 916 Atoms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 917 Subexpressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 918 Back-References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 918 Character Groups . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 919 Character Ranges . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 919 Character Class Escapes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 920 Character Blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 922 Character Categories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 924 Flags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 925 The «i» ﬂag . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 925 The «m» ﬂag . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 926 The «s» ﬂag . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 926 The «x» ﬂag . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 926 Disallowed Constructs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 927 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 927  Chapter 15: Serialization  929  The XML Output Method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 929 The HTML Output Method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 936 The XHTML Output Method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 939 The Text Output Method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 940  xxii   Contents  Using the   declaration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 940 Character Maps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 941 Usage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 942 Choosing Characters to Map . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 942 Limitations of Character Maps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 944 Disable Output Escaping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 945 Reasons to Disable Output Escaping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 945 Why disable-output-escaping Is Deprecated . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 946 Using disable-output-escaping to Wrap HTML in CDATA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 947 Character Maps as a Substitute for disable-output-escaping . . . . . . . . . . . . . . . . . . . . . . . . . 948 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 949  Part III: Exploitation  Chapter 16: Extensibility  What Vendor Extensions Are Allowed? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 954 Extension Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 955 When Are Extension Functions Needed? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 955 When Are Extension Functions Not Needed? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 956 Calling Extension Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 956 What Language Is Best?. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 957 Client-Side Script . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 957 Binding Extension Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 957 XPath Trees and the DOM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 963 Calling External Functions within a Loop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 965 Functions with Uncontrolled Side Effects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 967 Keeping Extensions Portable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 970 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 971  Chapter 17: Stylesheet Design Patterns  973  Fill-in-the-Blanks Stylesheets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 973 Navigational Stylesheets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 976 Rule-Based Stylesheets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 980 Computational Stylesheets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 985 Programming without Assignment Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 985 So Why Are They Called Variables? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 989 Avoiding Assignment Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 989 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1000  953  xxiii   Contents  Chapter 18: Case Study: XMLSpec  1001  Formatting the XML Speciﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1002 Preface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1004 Creating the HTML Outline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1008 Formatting the Document Header . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1012 Creating the Table of Contents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1019 Creating Section Headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1023 Formatting the Text . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1024 Producing Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1028 Making Cross-References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1029 Setting Out the Production Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1033 Overlay Stylesheets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1041 diffspec.xsl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1041 REC-xml.xsl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1044 Stylesheets for Other Speciﬁcations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1044 xslt.xsl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1045 xsltdiff.xsl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1046 funcproto.xsl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1046 xsl-query.xsl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1047 xmlspec.xsl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1047 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1047  Chapter 19: Case Study: A Family Tree  1049  Modeling a Family Tree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1050 The GEDCOM Data Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1050 Creating a Schema for GEDCOM 6.0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1053 The GEDCOM 6.0 Schema . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1054 Creating a Data File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1058 Converting GEDCOM Files to XML . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1059 Converting from GEDCOM 5.5 to 6.0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1063 Displaying the Family Tree Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1072 The Stylesheet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1073 Putting It Together . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1085 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1098  Chapter 20: Case Study: Knight’s Tour  1099  The Problem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1099 The Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1100 Placing the Knight . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1104 Displaying the Final Board . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1105  xxiv   Contents  Finding the Route . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1106 Finding the Possible Moves . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1107 Trying the Possible Moves . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1109 Selecting the Best Move . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1111 Running the Stylesheet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1112 Observations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1112 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1113  Part IV: Appendices  Appendix A: XPath 2.0 Syntax Summary  Whitespace and Comments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1118 Tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1118 Syntax Productions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1119 Operator Precedence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1122  Appendix B: Error Codes  Functions and Operators  FO  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1124 XPath Errors  XP  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1126 XSLT Errors  XT  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1127  Appendix C: Backward Compatibility  Stage 1: Backward-compatibility Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1140 Deprecated Facilities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1140 Error Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1140 Comparing Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1141 Numeric Formats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1141 Other XPath Changes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1142 Serialization Changes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1142 Stage 2: Setting version=‘‘2.0’’ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1142 The First Node Rule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1142 Type Checking of Function Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1143 Comparison Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1143 Arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1143 The Empty Sequence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1143 Error Semantics for «and» and «or» . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1144 Other XSLT Differences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1144 Stage 3: Adding a Schema . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1145 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1145  1117  1123  1139  xxv   Contents  Appendix D: Microsoft XSLT Processors  1147  MSXML . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1147 Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1148 IXMLDOMDocument and IXMLDOMDocument2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1148 IXMLDOMNode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1150 IXMLDOMNodeList . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1151 IXMLDOMParseError . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1151 IXMLDOMSelection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1152 IXSLProcessor. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1152 IXSLTemplate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1153 Putting it Together . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1154 Restrictions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1158 System.Xml . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1158 XPathDocument . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1158 XmlNode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1159 IXPathNavigable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1159 XPathNavigator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1159 XslTransform . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1159 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1161  Appendix E: JAXP: The Java API for Transformation  1163  The JAXP Parser API . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1164 JAXP Support for SAX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1164 JAXP Support for DOM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1166 The JAXP Transformation API . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1169 Examples of JAXP Transformations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1187 Example 1: Transformation Using Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1187 Example 2: Supplying Parameters and Output Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1188 Example 3: Holding Documents in Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1188 Example 4: Using the   Processing Instruction . . . . . . . . . . . . . . . . . . . . . 1189 Example 5: A SAX Pipeline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1190 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1193  Appendix F: Saxon  1195  Using Saxon from the Command Line . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1196 Using Saxon from a Java Application . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1199 Using Saxon via JAXP Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1199 The s9api Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1202 Using Saxon from a .NET Application . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1203 Saxon Tree Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1205  xxvi   Contents  Extensibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1205 Writing Extension Functions in Java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1206 Writing Extension Functions under .NET . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1206 Collations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1207 Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1208 Serialization Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1208 Extension Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1209 Extension Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1209 Extension Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1209 The evaluate   Extension . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1210 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1214  Appendix G: Altova  Running from within XMLSpy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1215 Conformance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1216 Extensions and Extensibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1217 The Command Line Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1217 Using the API . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1218 The COM API . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1218 The Java API . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1219 The .NET API . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1220 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1220  Appendix H: Glossary  Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1233  1215  1221  xxvii    I n t r o d u c t i o n  This book, as the title implies, is primarily a practical reference book for professional XSLT developers. It assumes no previous knowledge of the language, and many developers have used it as their ﬁrst introduction to XSLT; however, it is not structured as a tutorial, and there are other books on XSLT that provide a gentler approach for beginners.  Who This Book Is For  The book does assume a basic knowledge of XML, HTML, and the architecture of the Web, and it is written for experienced programmers. There’s no assumption that you know any particular language such as Java or Visual Basic, just that you recognize the concepts that all programming languages have in common.  I have tried to make the book suitable both for XSLT 1.0 users upgrading to XSLT 2.0, and for newcomers to XSLT. This is easier to do in a reference book, of course, than a tutorial. I have also tried to make the book equally suitable whether you work in the Java or .NET world.  As beﬁts a reference book, a key aim is that the coverage should be comprehensive and authoritative. It is designed to give you all the details, not just an overview of the 20 percent of the language that most people use 80 percent of the time. It’s designed so that you will keep coming back to the book whenever you encounter new and challenging programming tasks, not as a book that you skim quickly and then leave on the shelf. If you like detail, you will enjoy this book; if not, you probably won’t.  But as well as giving the detail, this book aims to explain the concepts, in some depth. It’s therefore a book for people who not only want to use the language but who also want to understand it at a deep level. Many readers have written to me saying that they particularly appreciate these insights into the language, and it’s my sincere hope that after reading it, you will not only be a more productive XSLT programmer, but also a more knowledgeable software engineer.  What This Book Covers  The book aims to tell you everything you need to know about the XSLT 2.0 language. It gives equal weight to the things that are new in XSLT 2.0 and the things that were already present in version 1.0. The book is about the language, not about speciﬁc products. However, there are appendices about Saxon  my own implementation of XSLT 2.0 , about the Altova XSLT 2.0 implementation, and about the Java and Microsoft APIs for controlling XSLT transformations, which will no doubt be upgraded to handle XSLT 2.0 as well as 1.0. A third XSLT 2.0 processor, Gestalt, was released shortly before we went to press, too late for us describe it in any detail. But the experience of XSLT 1.0 is that there has been a very high level of interoperability between different XSLT processors, and if you can use one of them, then you can use them all.  In the previous edition we split XSLT 2.0 and XPath 2.0 into separate volumes. The idea was that some readers might be interested in XPath alone. However, many bought the XSLT 2.0 book without its XPath   Introduction  companion and were left confused as a result; so this time, we’ve brought the material back together. The XPath reference information is in self-contained chapters, so it should still be accessible when you use XPath in contexts other than XSLT.  The book does not cover XSL Formatting Objects, a big subject in its own right. Nor does it cover XML Schemas in any detail. If you want to use these important technologies in conjunction with XSLT, there are other books that do them justice.  How This Book Is Structured  This book contains twenty chapters and eight appendixes  the last of which is a glossary  organized into four parts. The following section outlines what you can ﬁnd in each part, chapter, and appendix.  Part I: Foundations  The ﬁrst part of the book covers essential concepts. I recommend reading these before you start coding. If you ignore this advice, as most people do, then I suggest you read them when you get to that trough of despair when you ﬁnd it impossible to make the language do anything but the most trivial tasks. XSLT is different from other languages, and to make it work for you, you need to understand how it was designed to be used.  Chapter 1: XSLT in Context  This chapter explains how XSLT ﬁts into the big picture: how the language came into being and how it sits alongside other technologies. It also has a few simple coding examples to keep you alert.  Chapter 2: The XSLT Processing Model  This is about the architecture of an XSLT processor: the inputs, the outputs, and the data model. Under- standing the data model is perhaps the most important thing that distinguishes an XSLT expert from an amateur; it may seem like information that you can’t use immediately, but it’s knowledge that will stop you from making a lot of stupid mistakes. Chapter 3: Stylesheet Structure  XSLT development is about writing stylesheets, and this chapter takes a bird’s-eye view of what stylesheets look like. It explains the key concepts of rule-based programming using templates, and explains how to undertake programming-in-the-large by structuring your application using modules and pipelines.  Chapter 4: Stylesheets and Schemas  A key innovation in XSLT 2.0 is that stylesheets can take advantage of knowledge about the structure of your input and output documents, provided in the form of an XML Schema. This chapter provides a quick overview of XML Schema to describe its impact on XSLT development. Not everyone uses schemas, and you can skip this chapter if you fall into that category.  Chapter 5: The Type System  XPath 2.0 and XSLT 2.0 offer strong typing as an alternative to the weak typing approach of the 1.0 languages. This means that you can declare the types of your variables, functions, and parameters, and use this information to get early warning of programming errors. This chapter explains the data types available and the mechanisms for creating user-deﬁned types.  xxx   Introduction  Part II: XSLT and XPath Reference  This section of the book contains reference material, organized in the hope that you can easily ﬁnd what you need when you need it. It’s not designed for sequential reading, though if you’re like me, you might well want to leaf through the pages to discover what’s there.  Chapter 6: XSLT Elements  This monster chapter lists all the XSLT elements you can use in a stylesheet, in alphabetical order, giving detailed rules for the syntax and semantics of each element, advice on usage, and examples. This is probably the part of the book you will use most frequently as you become an expert XSLT user. It’s a ‘‘no stone unturned’’ approach, based on the belief that as a professional developer you need to know what happens when the going gets tough, not just when the wind is in your direction.  Chapter 7: XPath Fundamentals  This chapter explains the basics of XPath: the low-level constructs such as literals, variables, and function calls. It also explains the context rules, which describe how the evaluation of XPath expressions depends on the XSLT processing context in which they appear.  Chapter 8: XPath: Operators on Items  XPath offers the usual range of operators for performing arithmetic, boolean comparison, and the like. However, these don’t always behave exactly as you would expect, so it’s worth reading this chapter to see what’s available and how it differs from the last language that you used.  Chapter 9: XPath: Path Expressions  Path expressions are what make XPath special; they enable you to navigate around the structure of an XML document. This chapter explains the syntax of path expressions, the 13 axes that you can use to locate the nodes that you need, and associated operators such as union, intersection, and difference.  Chapter 10: XPath: Sequence Expressions  Unlike XPath 1.0, in version 2.0 all values are sequences  singletons are just a special case . Some of the most important operators in XPath 2.0 are those that manipulate sequences, notably the «for» expression, which translates one sequence into another by applying a mapping.  Chapter 11: XPath: Type Expressions  The type system was explained in Chapter 5; this chapter explains the operations that you can use to take advantage of types. This includes the «cast» operation which is used to convert values from one type to another. A big part of this chapter is devoted to the detailed rules for how these conversions are done.  Chapter 12: XSLT Patterns  This chapter returns from XPath to a subject that’s speciﬁc to XSLT. Patterns are used to deﬁne template rules, the essence of XSLT’s rule-based programming approach. The reason for explaining them now is that the syntax and semantics of patterns depends strongly on the corresponding rules for XPath expressions.  Chapter 13: The Function Library  XPath 2.0 includes a library of functions that can be called from any XPath expression; XSLT 2.0 extends this with some additional functions that are available only when XPath is used within XSLT. The library  xxxi   Introduction  has grown immensely since XPath 1.0. This chapter provides a single alphabetical reference for all these functions.  Chapter 14: Regular Expressions  Processing of text is an area where XSLT 2.0 and XPath 2.0 are much more powerful than version 1.0, and this is largely through the use of constructs that exploit regular expressions. If you’re familiar with regexes from languages such as Perl, this chapter tells you how XPath regular expressions differ. If you’re new to the subject, it explains it from ﬁrst principles.  Chapter 15: Serialization  Serialization in XSLT means the ability to generate a textual XML document from the tree structure that’s manipulated by a stylesheet. This isn’t part of XSLT processing proper, so  following W3C’s lead  we’ve separated it into its own chapter. You can control serialization from the stylesheet using an   declaration, but many products also allow you to control it directly via an API.  Part III: Exploitation  The ﬁnal section of the book is advice and guidance on how to take advantage of XSLT to write real applications. It’s intended to make you not just a competent XSLT coder, but a competent designer too. The best way of learning is by studying the work of others, so the emphasis here is on practical case studies.  Chapter 16: Extensibility  This chapter describes the ‘‘hooks’’ provided in the XSLT speciﬁcation to allow vendors and users to plug in extra functionality. The way this works will vary from one implementation to another, so we can’t cover all possibilities, but one important aspect that the chapter does cover is how to use such extensions and still keep your code portable.  Chapter 17: Stylesheet Design Patterns  This chapter explores a number of design and coding patterns for XSLT programming, starting with the simplest ‘‘ﬁll-in-the-blanks’’ stylesheet, and extending to the full use of recursive programming in the functional programming style, which is needed to tackle problems of any computational complexity. This provides an opportunity to explain the thinking behind functional programming and the change in mindset needed to take full advantage of this style of development.  Chapter 18: Case Study: XMLSpec  XSLT is often used for rendering documents, so where better to look for a case study than the stylesheets used by the W3 C to render the XML and XSLT speciﬁcations, and others in the same family, for display on the Web? The resulting stylesheets are typical of those you will ﬁnd in any publishing organization that uses XML to develop a series of documents with a compatible look-and-feel.  Chapter 19: Case Study: A Family Tree  Displaying a family tree is another typical XSLT application. This time we’re starting with semi-structured data — a mixture of fairly complex data and narrative text — that can be presented in many different ways for different audiences. We also show how to tackle another typical XSLT problem, conversion of the data into XML from a legacy text-based format. As it happens, this uses nearly all the important  xxxii   Introduction  new XSLT 2.0 features in one short stylesheet. But another aim of this chapter is to show a collection of stylesheets doing different jobs as part of a complete application.  Chapter 20: Case Study: Knight’s Tour  Finding a route around a chessboard where a knight visits every square without ever retracing its steps might sound a fairly esoteric application for XSLT, but it’s a good way of showing how even the most complex of algorithms are within the capabilities of the language. You may not need to tackle this partic- ular problem, but if you want to construct an SVG diagram showing progress against your project plan, then the problems won’t be that dissimilar.  Part IV: Appendices Appendix A: XPath 2.0 Syntax Summary  Collects the XPath grammar rules and operator precedences into one place for ease of reference.  Appendix B: Error Codes  A list of all the error codes deﬁned in the XSLT and XPath language speciﬁcations, with brief explanations to help you understand what’s gone wrong.  Appendix C: Backward Compatibility  The list of things you need to look out for when converting applications from XSLT 1.0.  Appendix D: Microsoft XSLT Processors  Although the two Microsoft XSLT processors don’t yet support XSLT 2.0, we thought many readers would ﬁnd it useful to have a quick summary here of the main objects and methods used in their APIs.  Appendix E: JAXP: The Java API for XML Processing  JAXP is an interface rather than a product. Again, it doesn’t have explicit support yet for XSLT 2.0, but Java programmers will often be using it in XSLT 2.0 projects, so we decided to include an overview of the classes and methods available.  At the time of writing Saxon  developed by the author of this book  provides the most comprehensive implementation of XSLT 2.0 and XPath 2.0, so we decided to cover its interfaces and extensions in some detail.  Altova, the developers of XML Spy, have an XSLT 2.0 processor that can be used either as part of the development environment or as a freestanding component. This appendix gives details of its interfaces.  Appendix F: Saxon  Appendix G: Altova  Appendix H: Glossary  Index  xxxiii   Introduction  What You Need to Use This Book  To use XSLT 2.0, you’ll need an XSLT 2.0 processor: at the time of writing that means Saxon, AltovaXML, or Gestalt, though Gestalt appeared on the scene too late for us to give it much coverage. You can run these products in a number of different ways, which are described as part of the ‘‘Hello World!’’ example in Chapter 1  pages 11–18 .  If in doubt, the simplest way to get started is probably to download Kernow  http:  kernowforsaxon .sourceforge.net  , which has Java SE 6 as a prerequisite. Kernow comes complete with the Saxon XSLT engine. The only other thing you will need is a text editor.  Conventions  To help you get the most from the text and keep track of what’s happening, we’ve used a number of conventions throughout the book.  There are two kinds of code examples in this book: code fragments and worked examples.  Code fragments are incomplete and are not intended to be executed on their own. You can build them into your own stylesheets if you ﬁnd them useful, but you will have to retype the code.  Worked examples are provided in the form of complete stylesheets, accompanied by sample source XML documents to which they can be applied, and an illustration of the output that they are expected to produce. You can download these examples and try them out for yourself. They generally appear in a box like this:  This section gives the XML source data, the input to the transformation. If the ﬁlename is given as example.xml, you will ﬁnd that ﬁle in the archive that you can download from the Wrox website at http:  www.wrox.com , generally in a subdirectory holding all the examples for one chapter.  This section describes the XSLT stylesheet used to achieve the transformation. Again, there will usually be a ﬁlename such as style.xsl, so you can ﬁnd the stylesheet in the Wrox download archive.  A Specimen Example  Source     Stylesheet  <xsl:stylesheet...  xxxiv   Output     This section shows the output when you apply this stylesheet to this source data, either as an XML or HTML listing, or as a screenshot.  Introduction  Occasionally, for reasons of space, we haven’t printed the whole of the source document or the stylesheet in the book, but instead refer you to the website to fetch it.  Boxes like this one hold important, not-to-be forgotten information that is directly relevant to the surrounding text.  Notes, tips, hints, tricks, and asides to the current discussion are offset and placed in italics like this.  As for styles in the text:    We highlight new terms and important words when we introduce them.   We show keyboard strokes like this: Ctrl+A.   We show ﬁlenames, URLs, and code within the text like so: persistence.properties.   We show code within the text as follows: Element names are written as   or   . Function names are written as concat   or current-date  . Other names  for example of attributes or types  are written simply as version or xs:string. Fragments of code other than simple names are offset from the surrounding text by chevrons; for example, «substring $a, 1, 1 =‘X’». Chevrons are also used around individual characters or string val- ues, or when referring to keywords such as «for» and «at» that need to stand out from the text. As a general rule, if a string is enclosed in quotation marks, then the quotes are part of the code example, whereas if it is enclosed in chevrons, the chevrons are there only to separate the code from the surrounding text.    We present code in two different ways:  For blocks of code we usually use gray highlighting.  But for individual lines of code we sometimes omit the highlighting.  Downloading the Code  All of the source code referred to in this book is available for download at http:  www.wrox.com. Once at the site, simply locate the book’s title  either by using the Search box or by using one of the title lists  and click the Download Code link on the book’s detail page to obtain all the source code for the book.  xxxv   Introduction  Errata  Because many books have similar titles, you may ﬁnd it easiest to search by ISBN; this book’s ISBN is 978-0-470-19274-0.  Once you download the code, just decompress it with your favorite compression tool. Alternately, you can go to the main Wrox code download page at http:  www.wrox.com dynamic books download.aspx to see the code available for this book and all other Wrox books.  We make every effort to ensure that there are no errors in the text or in the code. However, no one is per- fect, and mistakes do occur. If you ﬁnd an error in one of our books, such as a spelling mistake or faulty piece of code, we would be very grateful for your feedback. By sending in errata you may save another reader hours of frustration and at the same time you will be helping us provide even higher-quality information.  To ﬁnd the errata page for this book, go to http:  www.wrox.com and locate the title using the Search box or one of the title lists. Then, on the book details page, click the Book Errata link. On this page you can view all errata that have been submitted for this book and posted by Wrox editors. A complete book list, including links to each book’s errata, is also available at www.wrox.com misc-pages booklist.shtml.  If you don’t spot ‘‘your’’ error on the Book Errata page, go to www.wrox.com contact  techsupport.shtml and complete the form there to send us the error you have found. We’ll check the information and, if appropriate, post a message to the book’s errata page and ﬁx the problem in subsequent editions of the book.  p2p.wrox.com  For author and peer discussion, join the P2P forums at p2p.wrox.com. The forums are a Web-based system for you to post messages relating to Wrox books and related technologies and interact with other readers and technology users. The forums offer a subscription feature to e-mail you topics of interest of your choosing when new posts are made to the forums. Wrox authors, editors, other industry experts, and your fellow readers are present on these forums.  At http:  p2p.wrox.com you will ﬁnd a number of different forums that will help you not only as you read this book but also as you develop your own applications. To join the forums, just follow these steps:  1. 2. 3.  4.  Go to p2p.wrox.com and click the Register link. Read the terms of use and click Agree. Complete the required information to join as well as any optional information you wish to provide, and click Submit. You will receive an e-mail with information describing how to verify your account and complete the joining process.  You can read messages in the forums without joining P2P but in order to post your own messages, you must join.  Once you join, you can post new messages and respond to messages other users post. You can read messages at any time on the Web. If you would like to have new messages from a particular forum e-mailed to you, click the Subscribe to this Forum icon by the forum name in the forum listing.  xxxvi   Introduction  Here are some tips for writing a question if you want a good answer:  1. 2.  3.  4.  Choose your subject line carefully. Not just ‘‘XSLT question’’. Don’t use text shorthand. Not everyone has English as their ﬁrst language, but if you take care over writing your question, it’s much more likely that someone will take care over answering it. Show a complete source document, a complete example of your required output, and if you want to know why your code doesn’t work, your complete code — but only after paring the problem down to its essentials. Don’t ask people to debug code that they can’t see. If you tried something and it didn’t work, say exactly what you tried and exactly how it failed  including details of what products you are using .  For more information about how to use the Wrox P2P, be sure to read the P2P FAQs for answers to questions about how the forum software works as well as many common questions speciﬁc to P2P and Wrox books. To read the FAQs, click the FAQ link on any P2P page.  xxxvii    List of Examples  This list includes all the worked examples in the book: that is, the examples consisting of entire stylesheets, for which working code can be downloaded from http:  www.wrox.com . It does not include the many examples that are provided as incomplete snippets.  The purpose of this list is to help you out when you know that you’ve seen an example somewhere that is relevant to your current problem, but you can’t remember where you saw it.  Chapter 1  Description A Hello World Stylesheet  Displaying a Poem  Chapter 2  Description An XML Tree  Push Processing  This stylesheet creates an HTML containing a greeting  such as ‘‘Hello, World!’’  read from the source XML document.  Tabulating Word Frequencies  Given any XML document, this stylesheet produces a list of the words that appear in its text, giving the number of times each word appears, together with its frequency. This illustrates features in XSLT 2.0 for analyzing text using regular expressions, and for grouping based on common values.  This stylesheet shows how to use template rules to render the text of a poem in HTML.  This example shows how an XML document is represented as a tree in the data model.  This stylesheet shows the use of template rules to display a list of books in HTML, using one template rule for each different kind of node.  Controlling the Sequence of Processing  This example shows a reﬁnement of the previous stylesheet in which the select attribute of   is used to control the sequence of different parts of the output.  Page 11  19  35  74  77  Page 46  continued   List of Examples  Description Selecting Nodes Explicitly  This shows a further reﬁnement of the book list stylesheet in which some aspects of the output are generated using   instructions.  Chapter 3  Description Using    Using    Embedded Stylesheets  A Simpliﬁed Stylesheet  This example shows the use of   to split a stylesheet into three modules performing distinct tasks: one to format the current date, one to construct a copyright statement, and one to control the rest of the processing.  This stylesheet extends the previous example, showing how   allows some of the declarations in one module to be overridden in the importing module.  This example shows the use of a stylesheet embedded within the source document that it is designed to display.  This is an example of a simpliﬁed stylesheet module, that is, a stylesheet whose outermost element is a literal result element rather than an   element.  Using An Extension Instruction  This stylesheet uses Saxon’s   element to illustrate how a stylesheet can call extension instructions provided by a vendor or third party.  Chapter 4  Description Validating the Source Document  In this example a stylesheet takes advantage of the fact that the source document can be validated against a schema before the transformation starts.  Validating the Result Document  This stylesheet invokes validation of the result document using the   option of the   instruction.  xl  Page 77  Page 91  95  102  125  139  Page 167  171   List of Examples  Chapter 6  Description Using Modes  The example uses a mode to display a list of characters appearing in a play.  Checking for Cycles in a Graph  This example provides a generic procedure to look for cycles in a graph, and then applies this procedure to a data ﬁle to see if the ID IDREF links are cyclic. It illustrates the use of   to simulate a higher-order function.  Generating an Attribute Conditionally  This example shows the use of   to generate an attribute only when certain conditions are true.  Deciding the Attribute Name at Runtime  This example shows the use of   to generate an attribute whose name is not known until execution time.  Using an Attribute Set for Numbering  This stylesheet shows an unusual way of using attribute sets, to illustrate that the attributes generated by an attribute set do not need to have ﬁxed values.  Using Recursion to Process a Sequence of Nodes  This example illustrates how to use a recursive named template to process a sequence of nodes. It uses this technique to ﬁnd the longest speech in a play.  Using Recursion to Process a Sequence of Strings  This example uses a recursive named template to process a sequence of strings, obtained by splitting a line of text into its constituent words. It uses this technique to ﬁnd phrases of the form ‘‘A and B’’, where A and B are both the names of characters in a play.  Using   for Repeated Output  This stylesheet uses   to generate a standard table heading that appears repeatedly in the HTML output document  a listing of soccer matches .  Converting Attributes to Child Elements  This example illustrates how   can be used to create element nodes whose names and content are taken from the names and values of attributes in the source document.  Showing the Ancestors of a Node  This example stylesheet can be applied to any XML document. For each element it processes all its ancestor elements, in reverse document order  that is, starting with the parent node and ending with the document element , and outputs their names to a comment that shows the position of the current node.  Page 247  251  263  264  270  275  278  294  315  325  continued xli   List of Examples  Description Single-Level Grouping by Value  This stylesheet uses   to group a set of employees according to the department in which they work.  Multilevel Grouping by Value  This example groups employees by department, and groups the departments by location.  Grouping Consecutive Elements by Name  This example shows how the group-adjacent attribute of   can be used to group adjacent elements having the same element name. It applies this technique to the adjacent   and   elements in a Shakespeare play.  Handling Repeating Groups of Adjacent Elements  This takes the previous example and makes the problem more difﬁcult, by removing another layer of markup from the source document, so that it is necessary to infer multiple levels of hierarchic structure from the pattern of leaf elements in the tree.  Handling Flat XHTML Documents  This example shows how to use the group-starting-with attribute of   to process the implicit structure of an XHTML source document, in which an   element is followed by a number of   elements that are logically subordinate to the   element, but actually appear as its siblings.  Calculating Annual Leave  This is a simple illustration of the use of stylesheet functions to structure a computation in a stylesheet. It uses two user-deﬁned functions, a function to calculate the annual leave entitlement of an employee, which in turn calls a function to calculate the employee’s length of service given a starting and ending date.  Looking for Cycles Among Attribute Sets  This example illustrates the use of recursive stylesheet functions to analyze a graph structure. Speciﬁcally, it analyzes an XSLT stylesheet as its source document, to determine whether there are any cyclic dependencies among the attribute set deﬁnitions in the stylesheet.  Formatting a List of Names  This example shows the use of   to produce punctuation between the items in a list, where the punctuation depends on the position of the item within the list.  Page 331  333  336  338  340  347  352  356  xlii   List of Examples  Page 364  Description Precedence of Variables  This example shows how an importing stylesheet module can declare global variables with the same names as variables within the imported module, and how the variables in the importing module take precedence.  Precedence of Template Rules  This example shows how an importing stylesheet module can declare template rules that override template rules within the imported module. It also shows the use of   in an overriding template rule, to invoke the functionality of the template rule that was overridden.  Using   with Named Attribute Sets  This example illustrates the use of   to incorporate declarations  in this case, attribute set declarations  from one stylesheet module into another.  Multivalued non-Unique Keys  This example shows the use of an   deﬁnition in which several elements can have the same key value, and a single element can have multiple key values. Speciﬁcally, this situation arises when books are indexed by the names of their authors.  Generating a Stylesheet using    This example shows the way in which   can be used when writing a stylesheet whose task is to generate  or modify  another XSLT stylesheet.  Identifying Location of Text within a Document  This example is adapted from the stylesheet used to produce the errata for the XSLT and XPath speciﬁcations. It searches the published document for a given phrase, and then identiﬁes all the places where the phrase occurs, using   to generate a description of the location of the text using a phrase such as ‘‘ﬁrst numbered list, second item, third paragraph’’.  Numbering the Lines of a Poem  This stylesheet uses   to selectively number the lines of a poem.  Using   with a Default Value  This is an example of a named template that deﬁnes a default value for an optional template parameter. The stylesheet can be run against any source document, and displays the depth of nesting of the nodes in that document.  365  375  381  398  413  417  432  continued  xliii   List of Examples  Description Tunnel Parameters  This example shows how tunnel parameters can be useful when customizing an existing stylesheet, for reducing the number of rules in the existing stylesheet that need to be modiﬁed. The speciﬁc example shows how to produce a modiﬁed rendition of a Shakespeare play in which the lines for each actor are highlighted.  Creating Multiple Output Files  This stylesheet uses the   instruction to split a source document into multiple result documents. In this case, each stanza of a poem ends up in a separate document.  Sorting on the Result of a Calculation  This example uses   to sort items on a value that does not appear explicitly in either the source or result documents, but is computed.  It produces a sales report for different ﬂavors of jam .  This is an illustration of the classic use of template rules to control the rendition of narrative text, in this case, reviews of classical concerts.  Template Rules  Using Modes  This stylesheet modiﬁes the previous example showing how modes can be used to process the same source data in more than one way, using different template rules. It illustrates this by including at the end of each concert review a summary of the works performed in the concert.  Using a Variable for Context-Sensitive Values  This stylesheet  used to publish a series of opera performances  shows how a variable can be used to hold on to information that depends on the context, for use when the context has changed.  A Multiphase Transformation  An example of a stylesheet that uses variables to capture the result of one phase of processing, so that further processing can be carried out before delivering the ﬁnal result. In this case the ﬁrst phase calculates the results of a soccer tournament, and the second phase displays these results as HTML.  Chapter 12  xliv  Description Using the key   Pattern to Format a Speciﬁc Node  This stylesheet shows how a match pattern for a template rule can use the key   function to apply distinctive formatting to one selected node in the source document.  Page 433  451  463  488  490  508  511  Page 706   List of Examples  Chapter 13  Description Using the current   Function  This stylesheet shows the use of the current   function within an XPath predicate, effectively to do a join: Given a book, it selects other books in the same category.  Using the document   Function to Analyze a Stylesheet  A stylesheet is an XML document, so it can be used as the input to another stylesheet. This makes it very easy to write little tools that manipulate stylesheets. This example shows such a tool, designed to report on the hierarchic structure of the modules that make up a stylesheet.  A Look-Up Table in the Stylesheet  This example uses data in a look-up table to expand abbreviations of book categories. Two techniques are shown: In the ﬁrst example the look-up table is held in the stylesheet, and in the second example it is held in a separate XML document.  Creating Multiple Output Files  The main purpose of this example is to show how the element-available   function can be used to write stylesheets that are portable across different XSLT processors, even though they use facilities that are provided in different ways by different processors.  Testing for xx:node-set   Extensions  This example shows how the function-available   function can be used to write stylesheets that are portable across different XSLT processors, even though they use facilities that are provided in different ways by different processors.  Testing the Availability of a Java Method  This example shows the use of the «use-when» attribute to compile two different versions of a global variable declaration, depending on which version of the Java JDK is in use.  Using generate-id   to Create Links  This stylesheet produces information about holiday resorts as an HTML document; the hyperlinks within the document are generated by calling the generate-id   function to produce unique anchors.  Using Keys as Cross-References  This example uses two source ﬁles: The principal source document is a ﬁle containing a list of books, and the secondary one  accessed using the document   function  contains biographies of authors. The author name held in the ﬁrst ﬁle acts as a cross-reference to the author’s biography in the second ﬁle, rather like a join in SQL.  Using Keys for Grouping  This example shows the use of the XSLT 1.0 Muenchian grouping method to create a list of cities, grouped by country.  Page 736  758  761  767  794  796  798  814  817  continued  xlv   List of Examples  Description Unicode Normalization  This example shows the effect of normalizing the string «garc¸on> ﬁrst to Unicode composed normal form, then to decomposed normal form, and then back.  Processing a Comma-Separated-Values File  This example is a stylesheet that uses the unparsed-text   function to read a comma-separated-values ﬁle, given the URL of the ﬁle as a stylesheet parameter. It outputs an XML representation of this ﬁle, placing the rows in a   element and each value in a   element.  Chapter 15  Description Using a character-map to Comment-out Elements  This illustrates one of the ways of using character maps to achieve special effects during serialization of the result tree: the character map causes special characters in the tree to be replaced by strings representing the start and end of an XML comment.  Chapter 16  Description Using VBScript in an MSXML3 Stylesheet  This example shows a stylesheet that uses a VBScript extension function to convert dimensions in inches to the equivalent in millimeters.  A Java Extension Function to Calculate a Square Root  This example invokes a standard method in the Java class library to compute the square root of a number in the source document.  Calling External Functions within a Loop  This stylesheet calls external Java methods to read a source ﬁle, one line at a time, by means of recursive calls.  A Function with Uncontrolled Side Effects  This example shows what can go wrong with extension functions: Although it is apparently only a minor change to the previous example, it produces completely wrong results because it depends on the order in which instructions are executed.  Page 847  907  Page 943  Page 958  959  965  967  xlvi   List of Examples  Chapter 17  Description A ‘‘Fill-in-the-Blanks’’ Stylesheet  This stylesheet illustrates the ﬁll-in-the-blanks design pattern. It is a simpliﬁed stylesheet that consists essentially of the target HTML page, with   instructions inserted at the points where variable data is to be fetched from the XML source document.  This example shows the use of a navigational stylesheet to produce a very simple sales report.  A Navigational Stylesheet  A Rule-Based Stylesheet  Rule-based stylesheets are often used to process narrative documents, where most of the processing consists in replacing XML tags by HTML tags. This example illustrates this by showing how a Shakespeare play can be rendered in HTML.  Aggregating a List of Numbers  This is an example of the computational design pattern: The stylesheet uses a recursive template to process a whitespace-separated list of numbers. Recursive processing is needed to produce cumulative totals efﬁciently, since none of the standard aggregation functions supports this directly.  Using Interleaved Structures  Lines of verse aren’t neatly nested inside speeches, and speeches aren’t nested inside lines of verse: The two structures are interleaved. The usual solution to this problem is to use the hierarchic XML tagging to represent one of the structures  say the speeches  and to use empty element tags to mark the boundaries in the other structure. This example shows a stylesheet that can convert from one of these representations to the other.  Chapter 18  Description Formatting the XML Speciﬁcation  This entire chapter is devoted to the study of a single ‘‘real-life’’ application, the family of stylesheets used to process the XML speciﬁcation and other related W3 C documents.  Page 974  977  981  993  995  Page 1002  xlvii   List of Examples  Chapter 19  Description Converting GEDCOM Files to XML  This stylesheet converts genealogical data from one version of the GEDCOM standard to a subsequent version. The input is a non-XML format in which the hierarchic structure is indicated by level numbers. The example illustrates the use of new facilities in XSLT 2.0 for reading non-XML ﬁles, matching their contents against regular expressions, and then grouping adjacent lines to create an element hierarchy.  Converting from GEDCOM 5.5 to 6.0  This stylesheet converts the raw XML produced by the previous example to the schema required by the new version of the GEDCOM standard. The solution is schema-aware, using the schema for GEDCOM 6.0 to validate the output as it is written.  Displaying the Family Tree Data  This stylesheet produces an XHTML representation of the information concerning one individual in a GEDCOM 6.0 data ﬁle. The stylesheet is schema-aware, using a schema both to validate the input document and to ensure that the output is valid XHTML.  Publishing Static HTML  This stylesheet incorporates the previous stylesheet, and uses it to create a set of linked XHTML pages displaying all the individuals in the input GEDCOM 6.0 data ﬁle, suitable for publishing on a static web site.  Generating HTML Pages from a Servlet  This stylesheet shows an alternative way of displaying the family tree data: This time, HTML pages are generated on demand, by a transformation invoked from a Java servlet.  Generating HTML Pages Using ASP.NET  This does the same job as the previous example, but using different technology. HTML pages are again generated on demand, this time by an XSLT transformation controlled by C code within an ASP.NET page.  Generating HTML in the Browser  This stylesheet  which is restricted to use XSLT 1.0 facilities because of browser limitations  shows a third way of displaying the same data, this time by means of a transformation performed client side, and controlled by script on the HTML page.  Page 1059  1063  1073  1086  1087  1092  1095  xlviii   List of Examples  Chapter 20  Description Knight’s Tour of the Chessboard  This entire chapter is devoted to the study of a single program, a computational stylesheet that calculates a route for a knight on a chessboard, in which from any starting square, each square on the board is visited exactly once. The stylesheet demonstrates how even quite complex algorithms can be implemented in XSLT by use of recursive functions.  Appendix F  Description Using saxon:evaluate   to Apply Business Rules  Saxon is one of a number of products that offers an extension function to evaluate XPath expressions constructed on the ﬂy or read from a source document. This example shows how this capability can be used to allow business rules to be deﬁned in an XML conﬁguration document separate from the stylesheet logic.  Page 1099  Page 1212  xlix    Part I  Foundations  Chapter 1: XSLT in Context  Chapter 2: The XSLT Processing Model  Chapter 3: Stylesheet Structure  Chapter 4: Stylesheets and Schemas  Chapter 5: Types    1  X S L T  i  n C o n t e x t  XSLT in Context  This chapter is designed to put XSLT in context. It’s about the purpose of XSLT and the task it was designed to perform. It’s about what kind of language it is, how it came to be that way, and how it has changed in version 2.0; and it’s about how XSLT ﬁts in with all the other technologies that you are likely to use in a typical Web-based application  including, of course, XPath, which forms a vital component of XSLT . I won’t be saying very much in this chapter about what an XSLT stylesheet actually looks like or how it works: that will come later, in Chapters 2 and 3.  The chapter starts by describing the task that XSLT is designed to perform — transformation — and why there is the need to transform XML documents. I’ll then present a trivial example of a transformation in order to explain what this means in practice.  Next, I discuss the relationship of XSLT to other standards in the growing XML family, to put its function into context and explain how it complements the other standards.  I’ll describe what kind of language XSLT is, and delve a little into the history of how it came to be like that. If you’re impatient you may want to skip the history and get on with using the language, but sooner or later you will ask ‘‘why on earth did they design it like that?’’ and at that stage I hope you will go back and read about the process by which XSLT came into being.  What Is XSLT?  XSLT  Extensible Stylesheet Language: Transformations  is a language that, according to the very ﬁrst sentence in the speciﬁcation  found at http:  www.w3.org TR xslt20  , is primarily designed for trans- forming one XML document into another. However, XSLT is also capable of transforming XML to HTML and many other text-based formats, so a more general deﬁnition might be as follows:  XSLT is a language for transforming the structure and content of an XML document.  Why should you want to do that? In order to answer this question properly, we ﬁrst need to remind ourselves why XML has proved such a success and generated so much excitement.  XML is a simple, standard way to interchange structured textual data between computer programs. Part of its success comes because it is also readable and writable by humans, using nothing more complicated   XSLT in Context  than a text editor, but this doesn’t alter the fact that it is primarily intended for communication between software systems. As such, XML satisﬁes two compelling requirements:        Separating data from presentation: the need to separate information  such as a weather forecast  from details of the way it is to be presented on a particular device. The early motivation for this arose from the need to deliver information not only to the traditional PC-based Web browser  which itself comes in many ﬂavors  but also to TV sets and handheld devices, not to mention the continuing need to produce print-on-paper. Today, for many information providers an even more important driver is the opportunity to syndicate content to other organizations that can republish it with their own look-and-feel. Transmitting data between applications: the need to transmit information  such as orders and invoices  from one organization to another without investing in one-off software integration projects. As electronic commerce gathers pace, the amount of data exchanged between enter- prises increases daily, and this need becomes ever more urgent.  Of course, these two ways of using XML are not mutually exclusive. An invoice can be presented on the screen as well as being input to a ﬁnancial application package, and weather forecasts can be sum- marized, indexed, and aggregated by the recipient instead of being displayed directly. Another of the key beneﬁts of XML is that it uniﬁes the worlds of documents and data, providing a single way of representing structure regardless of whether the information is intended for human or machine con- sumption. The main point is that, whether the XML data is ultimately used by people or by a software application, it will very rarely be used directly in the form it arrives: it ﬁrst has to be transformed into something else.  In order to communicate with a human reader, this something else might be a document that can be displayed or printed: for example, an HTML ﬁle, a PDF ﬁle, or even audible sound. Converting XML to HTML for display is probably still the most common application of XSLT, and it is the one I will use in most of the examples in this book. Once you have the data in HTML format, it can be displayed on any browser.  In order to transfer data between different applications, we need to be able to transform information from the data model used by one application to the model used by another. To load the data into an application, the required format might be a comma-separated-values ﬁle, a SQL script, an HTTP message, or a sequence of calls on a particular programming interface. Alternatively, it might be another XML ﬁle using a different vocabulary from the original. As XML-based electronic commerce becomes widespread, the role of XSLT in data conversion between applications also becomes ever more important. Just because everyone is using XML does not mean the need for data conversion will disappear.  There will always be multiple standards in use. As I write there is a ﬁerce debate between the protagonists of two different XML representations of ofﬁce documents: the ODF speciﬁcation from the Open Ofﬁce community, and the OOXML speciﬁcation from Microsoft and its friends. However this gets resolved, the prospects of a single XML format for all word processor documents are remote, so there will always be a need to transform between multiple formats.  Even within the domain of a single standard, there is a need to extract information from one kind of document and insert it into another. For example, a PC manufacturer who devises a solution to a cus- tomer problem will need to extract data from the problem reports and insert it into the documents issued to ﬁeld engineers so that they can recognize and ﬁx the problem when other customers hit it. The ﬁeld engineers, of course, are probably working for a different company, not for the original manufacturer. So, linking up enterprises to do e-commerce will increasingly become a case of deﬁning how to extract and combine data from one set of XML documents to generate another set of XML documents, and XSLT is the ideal tool for the job.  4   During the course of this chapter, we will come back to speciﬁc examples of when XSLT should be used to transform XML. For now, I just wanted to establish a feel for the importance and usefulness of transforming XML. If you are already using XSLT, of course, this may be stale news. So let’s take a look now at what XSLT version 2.0 brings to the party.  X S L T  i  n C o n t e x t  Why Version 2.0?  What Is XSLT?  1  XSLT 1.0 came out in November 1999 and was highly successful. It was therefore almost inevitable that work would start on a version 2.0. As we will see later, the process of creating version 2.0 was far from smooth and took rather longer than some people hoped. However, XSLT 2.0 was ﬁnally published as a W3C Recommendation  that is, a ﬁnal speciﬁcation  in January 2007, and user reaction has been very favorable.  It’s tempting to look at version 2.0 and see it as a collection of features bolted on to the language, patches to make up for the weaknesses of version 1.0. As with a new release of any other language or software package, most users will ﬁnd some features here that they have been crying out for, and other additions that appear surplus to requirements.  But I think there is more to version 2.0 than just a bag of goodies; there are some underlying themes that have guided the design and the selection of features. I can identify four main themes:        Integration across the XML standards family: W3C working groups do not work in isolation from each other; they spend a lot of time trying to ensure that their efforts are coordinated. A great deal of what is in XSLT 2.0 is inﬂuenced by a wider agenda of doing what is right for the whole raft of XML standards, not just for XSLT considered in isolation. Extending the scope of applicability: XSLT 1.0 was pretty good at rendering XML documents for display as HTML on screen, and for converting them to XSL Formatting Objects for print publishing. But there are many other transformation tasks for which it proved less suitable. Compared with report writers  even those from the 1980s, let alone modern data visualization tools  its data handling capabilities were very weak. The language was quite good at doing conversions of XML documents if the original markup was well designed, but much weaker at recognizing patterns in the text or markup that represent hidden structure. An important aim of XSLT 2.0 was to increase the range of applications that you can tackle using XSLT.    More robust software engineering: XSLT was always designed to be used both client-side and server-side, but in many ways XSLT 1.0 optimized the language for use in the browser. However, people write large applications in XSLT, containing 100K or more lines of code, and this needs a more rigorous and robust approach to things such as error handling and type checking. Tactical usability improvements: Here we are into the realm of added goodies. The aim here is to achieve productivity beneﬁts, making it easier to do things that are difﬁcult or error-prone in version 1.0. These are probably the features that existing users will immediately recognize as the most beneﬁcial, but in the long term the other themes probably have more strategic signiﬁcance for the future of the language.     Before we discuss XSLT in more detail and have a ﬁrst look at how it works, let’s study a scenario that clearly demonstrates the variety of formats to which we can transform XML, using XSLT.  A Scenario: Transforming Music  As an indication of how far XML has now penetrated, Robin Cover’s index of XML-based application standards at http:  xml.coverpages.org xmlApplications.html today runs to 594 entries.  The last one is entitled Mind Reading Markup Language, but as far as I can tell, all the other entries are serious.   5   XSLT in Context  I’ll follow just one of these 594 links, XML and Music, which takes us to http:  xml.coverpages.org  xmlMusic.html. On this page we ﬁnd a list of no less than 18 standards, proposals, or initiatives that use XML for marking up music.  This diversity is clearly unnecessary, and many of these initiatives are already dead or dying. Even the names of the standards are chaotic: there is a Music Markup Language, a MusicML, a MusicXML, and a MusiXML, all quite unrelated. There are at least three really serious contenders: the Music Encoding Initiative  MEI , the Standard Music Description Language  SMDL , and MusicXML. The MEI derives its inspiration from the Text Encoding Initiative, and has a particular focus on the needs of music scholars  for example, the ability to capture features found in different manuscripts of the same score , while SMDL is related to the HyTime hypermedia standards and takes into account requirements such as the need to synchronize music with video or with a lighting script  it has not been widely implemented, but it has its enthusiasts . MusicXML, by contrast, is primarily focused on the needs of composers and publishers of sheet music.  Given the variety of requirements, it’s unlikely that the number of standards in use will reduce any further. The different notations were invented with different purposes in mind: a markup language used by a publisher for printing sheet music has different requirements from the one designed to let you listen to the music from a browser.  In the ﬁrst edition of this book, back in 2001, I introduced the idea of using XSLT to transform music as a theoretical possibility, something to make my readers think about the range of possibilities open for the language. By the time I published the second edition, PhD students were showing that it could actually be done. Today, MusicXML is a standard part of over 80 software applications including industry leaders such as Sibelius and Finale, and XSLT is routinely used to manipulate the output. The MEI website publishes XSLT stylesheets for converting between MEI and MusicXML in either direction.  maestoso  f  God save our gracious Queen, Long live our noble Queen, God save the Queen!       National Anthem       B-flat-major                         God save our  gra  -  cious Queen,  Long live  our  no  -  ble Queen,  God save the  Queen!  Figure 1-1  6                     1.  2.  How Does XSLT Transform XML?  1  As it happens, MusicXML itself provides two ways of representing a score. In one the top-level subdivision in the XML hierarchy is by instrumental part or voice; in the other the top-level structure is the timeline of the music. XSLT stylesheets are provided to convert between the two formats.  Figure 1-1 shows some of the possibilities. You could use XSLT to:  X S L T  i  n C o n t e x t  Convert music from one representation to another, for example from MEI to SMDL. Convert music from any of these representations into visual music notation, by generating the XML-based vector graphics format SVG. Play the music on a synthesizer, by generating a MIDI  Musical Instrument Digital Interface  ﬁle. Perform a musical transformation, such as transposing the music into a different key or extract- ing parts for different instruments or voices. Extract the lyrics, into HTML or into a text-only XML document. Capture music from non-XML formats and translate it to XML  XSLT 2.0 is especially useful here .  As you can see, XSLT is not just for converting XML documents to HTML.  How Does XSLT Transform XML?  By now you are probably wondering exactly how XSLT goes about processing an XML document in order to convert it into the required output. There are usually two aspects to this process:  The ﬁrst stage is a structural transformation, in which the data is converted from the structure of the incoming XML document to a structure that reﬂects the desired output. The second stage is formatting, in which the new structure is output in the required format such as HTML or PDF.  The second stage covers the ground we discussed in the previous section; the data structure that results from the ﬁrst stage can be output as HTML, as a text ﬁle, or as XML. HTML output allows the informa- tion to be viewed directly in a browser by a human user or be input into any modern word processor. Plain text output allows data to be formatted in the way an existing application can accept, for example comma-separated values or one of the many text-based data interchange formats that were developed before XML arrived on the scene. Finally, XML output allows the data to be supplied to applications that accept XML directly. Typically, this will use a different vocabulary of XML tags from the original document: for example, an XSLT transformation might take the monthly sales ﬁgures as its XML input and produce a histogram as its XML output, using the XML-based SVG standard for vector graphics. Or, you could use an XSLT transformation to generate Voice XML output, for aural rendition of your data.  Information about VoiceXML can be found at http:  www.voicexml.org .  Let’s now delve into the ﬁrst stage, transformation — the stage with which XSLT is primarily concerned and which makes it possible to provide output in all of these formats. This stage might involve selecting data, aggregating and grouping it, sorting it, or performing arithmetic conversions such as changing centimeters to inches.  XSLT is not the only way of processing or transforming XML. For example, you can write applications in Java or C that build a tree-like representation of an XML document  using the W3C-deﬁned Document  7   XSLT in Context  Object Model, or other similar models such as JDOM or XOM . Your program could interrogate this tree structure to ﬁnd the speciﬁc information needed. It would do so by deﬁning a speciﬁc sequence of steps to be followed in order to produce the required output.  So, how is using XSLT to perform transformations on XML better than writing custom applications? Well, the design of XSLT is based on a recognition that these programs are all very similar, and it should therefore be possible to describe what they do using a high-level declarative language rather than writing each program from scratch in Java or C. The required transformation can be expressed as a set of rules. These rules are based on deﬁning what output should be generated when particular patterns occur in the input. The language is declarative in the sense that you describe the transformation you require, rather than providing a sequence of procedural instructions to achieve it. XSLT describes the required transformation and then relies on the XSLT processor to decide the most efﬁcient way to go about it.  XSLT still relies on an XML parser — it might be a DOM parser or a SAX-compliant one, or one of the new breed of ‘‘pull parsers’’ — to convert the XML document into a tree structure. It is the structure of this tree representation of the document that XSLT manipulates, not the document itself. If you are familiar with the DOM, then you will be happy with the idea of treating every item in an XML docu- ment  elements, attributes, processing instructions, and so on  as a node in a tree. With XSLT we have a high-level language that can navigate around a node tree, select speciﬁc nodes, and perform complex manipulations on these nodes.  The XSLT tree model is similar in concept to the DOM, but it is not the same. The full XSLT processing model is discussed in Chapter 2.  The description of XSLT given thus far  a declarative language that can navigate to and select speciﬁc data and then manipulate that data  may strike you as being similar to that of the standard database query language, SQL. Let’s take a closer look at this comparison.  XSLT and SQL: An Analogy  In a relational database, the data consists of a set of tables. By themselves, the tables are not of much use, the data might as well be stored in ﬂat ﬁles in comma-separated values format. The power of a relational database doesn’t come from its data structure; it comes from the language that processes the data, SQL. In the same way, XML on its own just deﬁnes a data structure. It’s a bit richer than the tables of the relational model, but by itself it doesn’t actually do anything very useful. It’s when we get a high-level language expressly designed to manipulate the data structure that we start to ﬁnd we’ve got something interesting on our hands, and for XML data the main language that does that is XSLT.  Superﬁcially, SQL and XSLT are very different languages. But if you look below the surface, they actually have a lot in common. For starters, in order to process speciﬁc data, be it in a relational database or an XML document, the processing language must incorporate a declarative query syntax for selecting the data that needs to be processed. In SQL, that’s the SELECT statement. In XSLT, the equivalent is the XPath expression.  The XPath expression language forms an essential part of XSLT, though it is actually deﬁned in a separate W3C Recommendation  http:  www.w3.org TR xpath  because it can also be used independently of XSLT  the relationship between XPath and XSLT is discussed further on page 22 .  The XPath syntax is designed to retrieve nodes from an XML document, based on a path through the XML document or the context in which the node appears. It allows access to speciﬁc nodes, while pre- serving the hierarchy and structure of the document. XSLT instructions are then used to manipulate the results of these queries, for example by rearranging selected nodes and constructing new nodes.  8   How Does XSLT Transform XML?  1  X S L T  i  n C o n t e x t  There are further similarities between XSLT and SQL:           Both languages augment the basic query facilities with useful additions for performing arith- metic, string manipulation, and comparison operations. Both languages supplement the declarative query syntax with semiprocedural facilities for describing the processing to be carried out, and they also provide hooks to escape into conven- tional programming languages where the algorithms start to get too complex. Both languages have an important property called closure, which means that the output has the same data structure as the input. For SQL, this structure is tables, for XSLT it is trees — the tree representation of XML documents. The closure property is extremely valuable because it means operations performed using the language can be combined end-to-end to deﬁne bigger, more complex operations: you just take the output of one operation and make it the input of the next operation. In SQL you can do this by deﬁning views or subqueries; in XSLT you can do it by passing your data through a series of stylesheets, or by capturing the tree produced by one trans- formation phase in a variable and using that variable as the input of another transformation phase. This last feature is new in XSLT 2.0, though most XSLT 1.0 processors offered a similar capability as a language extension.  In the real world, of course, XSLT and SQL have to coexist. There are many possible relationships, but typically, data is stored in relational databases and transmitted between systems in XML. The two lan- guages don’t ﬁt together as comfortably as one would like, because the data models are so different. But XSLT transformations can play an important role in bridging the divide. All of the major relational database vendors have released extensions that allow XML data to be stored and manipulated directly within what is still nominally a relational database.  Before we look at a simple working example of an XSLT transformation, we should brieﬂy discuss a few of the XSLT processors that are available to effect these transformations.  XSLT Processors  The job of an XSLT processor is to apply an XSLT stylesheet to an XML source document and produce a result document.  With XSLT 1.0, there are quite a few good XSLT processors to choose from, and many of them can be downloaded free of charge  but do read the licensing conditions .  If you’re using Microsoft technology, there is a choice of two products. The most widely used option is MSXML  Google for ‘‘Download MSXML’’ to ﬁnd it — the current version is MSXML 6 . Usually, I’m not Microsoft’s greatest fan, but with this processor it’s generally agreed that they have done an excel- lent job. This product comes as standard with Internet Explorer and is therefore the preferred choice for running transformations in the browser. For the .NET environment, however, Microsoft developed a new processor. This doesn’t have a product name of its own, other than its package name within the .NET framework, which is System.Xml.Xsl. This processor was initially said to be signiﬁcantly slower than the MSXML product, but that seems to be no longer true, and if you’re writing your appli- cation using .NET technologies such as C and ASP.NET, it’s probably the one that you’ll ﬁnd more convenient.  In the Java world, there’s a choice of Xalan-J product. There’s my own Saxon product  version 6.5.5 is the version that supports XSLT 1.0  available from http:  saxon.sf.net , and there’s the Xalan-J product which is bundled with Sun’s Java JDK software from JDK 1.4 onwards. There’s also an Oracle implementation, and a new processor from Intel.  9   XSLT in Context  For C and C++ the most popular processor is the libxslt engine  http:  xmlsoft.org XSLT  .  Most of these products are XSLT interpreters, but there are two well-known XSLT compilers: XSLTC, which is distributed as part of the Xalan-J package mentioned earlier, and Gregor, from Jacek Ambroziak  http:  www.ambrosoft.com gregor.html . At the top end of the market, for those with a large budget, you can also get hardware-accelerated engines from IBM and Intel.  With XSLT 2.0, at the time of writing, the choice is more limited. There are currently three XSLT 2.0 processors available:       My own Saxon product. This is available in two variants, corresponding to the two conformance levels deﬁned in the W3C speciﬁcation: Saxon-B 9.x  http:  saxon.sf.net   is an open-source implementation of a basic XSLT 2.0 processor, and Saxon-SA 9.x  http:  www.saxonica.com   is a commercial implementation of a schema-aware XSLT processor. Both variants are available for both the Java and .NET platforms. You can run most of the examples in this book, using a basic XSLT processor, but Chapter 4 and Chapter 11 focus on the additional capability of XSLT when used with XML Schemas, with examples that will only run with a basic XSLT processor. Saxon as delivered offers a command line interface and a Java or .NET API. A number of toolsets provide graphical user interfaces on top: the simplest is the open-source Kernow product  kernowforsaxon.sourceforge.net ; other options are the comprehensive Stylus Studio devel- opment environment  www.stylusstudio.com  and the oXygen XML editor  www.oxygenxml .com , both of which support step-by-step Saxon debugging. Altova  www.altova.com  have released their own XSLT 2.0 processor, which is available either as a freestanding COM component with a command line interface and Windows API, or built in to the popular XML Spy development environment. As a standalone component the product is free  but not open source , and offers both schema-aware and non-schema-aware process- ing. The level of conformance of the Altova product has been improving with each release, and nearly all the examples in this book run successfully with the 2008 edition of this product. Gestalt is an open-source XSLT 2.0 processor written in the Eiffel language by Colin Adams  http:  sourceforge.net projects gestalt . The product is work in progress, and although the software is under active development, the documentation is a little sketchy and this imple- mentation is unlikely to appeal to you unless you are something of an Eiffel enthusiast. We have not tested the examples in this book against the Gestalt processor.        By reading papers published at research conferences and blog postings by employees, you can make an educated guess that implementations are underway within IBM, Oracle and Microsoft, but none of these companies has announced any ofﬁcial product plans or release dates at the time of writing — and of course, not everything those companies do in their research labs sees the light of day as a product.  I think it’s a little unlikely that there will be quite as many XSLT 2.0 processors as there are for XSLT 1.0  there is bound to be some shakeout in a maturing market , but I’m conﬁdent there will be four or ﬁve, which should be enough.  Meanwhile, you can use Altova or Saxon, and those are the primary vehicles I will be using for all the examples in this book.  A Simple XSLT Stylesheet  We’re now ready to take a look at an example of using XSLT to transform a very simple XML document.  10   How Does XSLT Transform XML?  1  Example: A ‘‘Hello, world!’’ XSLT Stylesheet  Kernighan and Ritchie in their classic The C Programming Language  Prentice-Hall, 1988  originated the idea of presenting a trivial but complete program right at the beginning of the book, and ever since then the Hello world program has been an honored tradition. Of course, a complete description of how this example works is not possible until all the concepts have been deﬁned, and so if you feel I’m not explaining it fully, don’t worry — the explanations will come later.  X S L T  i  n C o n t e x t  Input  What kind of transformation would we like to do? Let’s try transforming the following XML document.       Hello, world!   This document is available as ﬁle hello.xml in the download directory for this chapter. A simple node-tree representation of this document is shown in Figure 1-2.  Document  Node           “Hello world!”   Figure 1-2  There are four nodes in this tree: a document node that represents the document as a whole; an   processing instruction that identiﬁes the stylesheet to be used; the   element; and the text within the   element. The document node in the XSLT model performs the same function as the document node in the DOM model  it was called the root node in XSLT 1.0, but the nomenclature has been brought into line with the DOM . The XML declaration is not visible to the XSLT processor and, therefore, is not included in the tree. I’ve deliberately made it easy by including an   processing instruction in the source XML ﬁle. Many XSLT processors will use this to identify the stylesheet if you don’t specify a different stylesheet to use. The href attribute gives the relative URI of the default stylesheet for this document.  11   XSLT in Context  Output  Our required output is the following HTML, which will simply change the browser title to "Today’s Greeting" and display whatever greeting is in the source XML ﬁle:                  Today’s greeting    Hello, world!   XSLT Stylesheet  Without any more ado, here’s the XSLT stylesheet hello.xsl to effect the transformation. This is an XSLT 1.0 stylesheet, hence the «version = "1.0"» in the   ele- ment.    <xsl:stylesheet  version="1.0" xmlns:xsl="http:  www.w3.org 1999 XSL Transform">   Today’s greeting                                Running the Stylesheet  There are a number of ways you can run this stylesheet, which we’ll look at in the following sections. It may be worth trying several of the different approaches, to ﬁnd out which you are most comfortable with — familiarity with the tools will help you master the examples in the rest of the book, as well as making you a more proﬁcient XSLT developer. Whichever approach you use, the ﬁrst stage is to download the sample code for this book from the Wrox web site  www.wrox.com , as explained in the Introduction. The code is orga- nized by chapter, so you’ll ﬁnd the two ﬁles hello.xml and hello.xsl in the directory ch01. If you’re a serious XSLT developer then your company may well have invested in an XML development environment such as XML Spy, Stylus Studio, or oXygen. All these products  12   How Does XSLT Transform XML?  1  have the capability to run XSLT 2.0 stylesheets: XML Spy uses Altova’s XSLT 2.0 processor  though it can also be conﬁgured to run Saxon , while Stylus Studio and oXygen both use Saxon. We won’t cover the use of these development environments in this book.  Using the Browser  The easiest way to run this example is simply to load the XML ﬁle hello.xml into any recent version of Internet Explorer or Firefox  right-click the ﬁle and select Open With. . . . The browser will recognize the   processing instruction and will use this to fetch the stylesheet and execute it. The result is a display like the one in Figure 1-3.  X S L T  i  n C o n t e x t  Figure 1-3  We can run this example in the browser because it is actually an XSLT 1.0 stylesheet. Most modern browsers support XSLT 1.0 processing in this way, but at the time of writing none yet supports XSLT 2.0.  Using Saxon from Kernow  We’ll be running most of the XSLT 2.0 examples in this book using Saxon, and one of the easiest ways to run Saxon is by using a graphical front-end called Kernow. You can download Kernow from http:  kernowforsaxon.sourceforge.net . It includes the Saxon JAR ﬁles, so the only prerequisite is that Java itself is installed. You will need Java Standard Edition 6 or later, which you can get from http:  java.sun.com .  Saxon itself works with JDK 1.4 or later, the requirement for Java SE 6 comes from Kernow.  To install Kernow, the only thing you need to do is to unzip the download ﬁle into a suitable directory, and if you are running Windows you can then start the product by double-clicking the Run.bat ﬁle. In the dialog box that appears, select the ‘‘Single File’’ tab, and browse to the source and stylesheet ﬁles. Then click Run to run the transformation. The output is as shown in Figure 1-4. Note that this time, the result is shown in terms of raw HTML. If you want to see what the HTML looks like in a browser, you can always save it to a ﬁle and then open the ﬁle in your browser. But Kernow is designed for developers, not for end users, and as a developer you need to see the HTML that you have generated. I wouldn’t advise anyone to do serious XSLT development by testing directly in a browser, because it’s hard to see what’s gone wrong when you make a mistake.  13   XSLT in Context  Figure 1-4  Using Saxon on Java from the Command Line  If you’re a professional software developer then you’re probably not averse to running utili- ties from the command line, which is the natural way to test your stylesheets when you use Saxon ‘‘out of the box.’’ The steps are as follows:  1.  2.  3.  Ensure you have Java installed on your machine. Saxon will work with JDK 1.4 or later. Saxon is pure Java code, and so it will run on any platform that supports Java, but I will usually assume that you are using a Windows machine. Download the Saxon-B processor from http:  sf.net saxon. Choose the most recent version of Saxon-B for Java, and unzip the download ﬁle into a suitable directory, for example c:\saxon. Bring up an MSDOS-style console window  use Start ➪ Run, and type ‘‘cmd’’ .  14   How Does XSLT Transform XML?  1  4. Type the following at the command prompt: java -jar c:\saxon\saxon9.jar -a -s:hello.xml 5.  Admire the HTML displayed on the standard output.  X S L T  i  n C o n t e x t  If you want to view the output using your browser, simply save the command line output as an HTML ﬁle, in the following manner: java -jar c:\saxon\saxon8.jar -a -s:hello.xml -o:hello.html   Using the command prompt in Windows isn’t much fun. If you’re a Unix fan, install Cyg- win. Most editors have the ability invoke a command line processor that is generally much more usable than the one provided by the operating system. I use UltraEdit, but there are many other choices available.   Using Saxon on .NET  The Saxon XSLT processor also runs on the .NET platform. You’ll need to make sure that .NET  either version 1.1 or 2.0  is installed — if it’s not already present on your machine, it’s a free download from Microsoft. Download the latest version of Saxon-B for .NET from http:  sf.net saxon, and unzip the download ﬁle into a directory such as c:\saxon. You can then run it using the command line: c:\saxon\Transform -a -s:hello.xml -o:hello.html  If you want to develop applications with this product, you’ll need to install Saxon in the Global Assembly Cache, but for running from the command line, this isn’t necessary.  Using the Altova XSLT processor  You can obtain the freestanding AltovaXML product from www.altova.com. The current version at the time of writing is AltovaXML 2008. This includes separate XSLT 1.0 and 2.0 processors, and an XQuery engine. The product installs by default into c:\Program Files\Altova\AltovaXML2008. Assuming this directory is on your PATH, you can then run our example transformation with the command line:  AltovaXML -in hello.xml -xslt2 hello.xsl -out hello.html  Using XMLSpy  If you have installed XMLSpy, use File ➪ Open to open the stylesheet ﬁle hello.xsl, then F10  or the XSL Transformation icon  to run a transformation. In the next dialog box, select the source ﬁle hello.xml, and click OK. The output is displayed as shown in Figure 1-5. You can switch between the Text and Browser tabs at the bottom of the output window to see either the generated HTML or the result as it will appear in the browser.  15   XSLT in Context  Figure 1-5  Using Stylus Studio  Stylus Studio uses its own built-in XSLT processor by default. This only supports XSLT 1.0, but that’s ﬁne for this example. First open the stylesheet using File ➪ Open. The next step is to create a scenario  that is a transformation task . Click the ‘‘. . .’’ button next to the ‘‘Create Scenario’’ drop-down box. In the resulting dialog box  shown in Figure 1-6 , deﬁne a name for the scenario  so that next time you run the task you can simply select it from the drop-down  and browse to the source XML ﬁle in the ‘‘Source XML URL’’ box. Then click the green triangle icon  with hover text ‘‘Preview Result’’  to run the transformation. The output appears in a new window, and you can again switch between a source HTML view and a browser view, or an Explorer-style tree view of the result tree if you prefer. If you want to use XSLT 2.0 with Stylus Studio, choose the Processor tab in the Create Sce- nario dialog, and choose the most recent version of Saxon from the list of processors offered  one of the nice features of Stylus is that you can use it to test that your code is portable across a range of different processors . You can then click the Settings . . . button to select from a range of Saxon-speciﬁc options  for example, you can choose whether or not to use schema-aware processing.  These correspond to options that are available on the Saxon com- mand line.  16   How Does XSLT Transform XML?  1  X S L T  i  n C o n t e x t  Figure 1-6  How It Works  If you’ve succeeded in running this example, or even if you just want to get on with reading the book, you’ll want to know how it works. Let’s dissect it.     This is just the standard XML heading. The interesting point is that an XSLT stylesheet is itself an XML document. I’ll have more to say about this later in the chapter. I’ve used iso-8859-1 character encoding  which is the ofﬁcial name for the character set that Microsoft some- times calls ‘‘ANSI’’  because in Western Europe and North America it’s the character set that most text editors support. If you’ve got a text editor that supports UTF-8 or some other character encoding, feel free to use that instead.  <xsl:stylesheet  version="1.0" xmlns:xsl="http:  www.w3.org 1999 XSL Transform">  This is the standard XSLT 1.0 heading. In XML terms it’s an element start tag, and it identiﬁes the document as a stylesheet. The xmlns:xsl attribute is an XML namespace declaration, which indicates that the preﬁx xsl is going to be used for elements deﬁned in the W3C XSLT speciﬁcation. XSLT makes extensive use of XML namespaces, and all the element names  17   XSLT in Context  deﬁned in the standard are preﬁxed with this namespace to avoid any clash with names used in your source document. The version attribute indicates that the stylesheet is designed to work with an XSLT 1.0 processor. Let’s move on.     An   element deﬁnes a template rule to be triggered when a particular part of the source document is being processed. The attribute «match = " "» indicates that this particular rule is triggered right at the start of processing the source document. Here « » is a pattern that identiﬁes the document node of the document: an XML document has a hierarchic structure, and in the same way as Unix uses the special ﬁlename « » to indicate the root of a hierarchic ﬁle store, XPath uses « » to represent the root of the XML content hierarchy.                  Today’s greeting        Once this rule is triggered, the body of the template says what output to generate. Most of the template body here is a sequence of HTML elements and text to be copied into the output ﬁle. There’s one exception: an   element, which we recognize as an XSLT instruction because it uses the namespace preﬁx xsl. This particular instruction copies the textual content of a node in the source document to the output document. The select attribute of the element speciﬁes the node for which the value should be evaluated. The XPath expression «greeting» means ‘‘ﬁnd the set of all   elements that are children of the node that this template rule is currently processing.’’ In this case, this means the   element that’s the outermost element of the source document. The   instruction then extracts the text of this element and copies it to the output at the relevant place — in other words, within the generated   element. All that remains is to ﬁnish what we started.        Why would you want to place today’s greeting in a separate XML ﬁle and display it using a stylesheet? One reason is that you might want to show the greeting in different ways, depending on the context; for example, it might be shown differently on a different device, or the greeting might depend on the time of day. In this case, you could write a different stylesheet to transform the same source document in a different way. This raises the question of how a stylesheet gets selected at runtime. There is no single answer to this question; it depends on the product you are using.  18   How Does XSLT Transform XML?  1  With Saxon, we used the -a option to process the XML document using the stylesheet speciﬁed in its   processing instruction. Instead, we could simply have speciﬁed the stylesheet on the command line:  java -jar c:\saxon\saxon8.jar -s:hello.xml -xsl:hello.xsl -o:hello.html  X S L T  i  n C o n t e x t  Having looked at a very simple XSLT 1.0 stylesheet, let’s now look at a stylesheet that uses features that are new in XSLT 2.0.  An XSLT 2.0 Stylesheet  This stylesheet is very short, but it manages to use four or ﬁve new XSLT 2.0 and XPath 2.0 features within the space of a few lines. I wrote it in response to a user enquiry raised on the xsl-list at http:  www .mulberrytech.com   an excellent place for meeting other XSLT developers with widely varying levels of experience ; so it’s a real problem, not an invention. The XSLT 1.0 solution to this problem is about 60 lines of code.  Example: Tabulating Word Frequencies  The problem is simply stated: given any XML document, produce a list of the words that appear in its text, giving the number of times each word appears, together with its frequency.  Input  Output  Stylesheet  The input can be any XML document. I will use the text of Shakespeare’s Othello as an example; this is provided as othello.xml in the download ﬁles for this book.  The required output is an XML ﬁle that lists words in decreasing order of frequency. If you run the transformation using Kernow, the output appears as shown in Figure 1-7.  Here is the stylesheet that produces this output. You can ﬁnd it in wordcount.xsl.    <xsl:stylesheet  version="2.0" xmlns:xsl="http:  www.w3.org 1999 XSL Transform">           <xsl:for-each-group group-by="." select="  for $w in   text   tokenize ., ’\W+’ [.!=’’] return lower-case $w ">    <word word="{current-grouping-key  }"  frequency="{count current-group   }" >  19   XSLT in Context             Let’s see how this works.  Figure 1-7  The   element introduces the XSLT namespace, as before, and tells us that this stylesheet is designed to be used with an XSLT 2.0 processor. The   element asks for the XML output of the stylesheet to be indented, which makes it much easier for humans to read. There is one   element, as before, which deﬁnes the code to be executed when the document node of the source document is encountered. This generates a   element in the result, and within this it puts the word frequencies.  20   The Place of XSLT in the XML Family  1  X S L T  i  n C o n t e x t  To understand the   instruction, which is new in XSLT 2.0, we ﬁrst need to look at its select attribute. This contains the XPath 2.0 expression for $w in   text   tokenize ., ’\W+’ [.!=’’] return lower-case $w   This ﬁrst selects «  text  », the set of all text nodes in the input tree. It then tokenizes each of these text nodes, that is, it splits it into a sequence of substrings. The tokenizing is done by applying the regular expression «\W+». Regular expressions are new in XPath 2.0 and XSLT 2.0, though they will be very familiar to users of other languages such as Perl. They provide the language with greatly enhanced text handling capability. This par- ticular expression, «\W+», matches any sequence of one-or-more ‘‘non-word’’ characters, a convenient category that includes spaces, punctuation marks, and other separators. So the result of calling the tokenize   function is a sequence of strings containing the words that appear in the text. Because there are text nodes that contain nothing of interest, the result also includes some zero-length tokens, and we ﬁlter these out by applying the predicate «[.! = ’’]» The XPath «for» expression now applies the function lower-case   to each of the strings in this sequence, producing the lower-case equivalent of the word.  Almost everything in this XPath expression is new in XPath 2.0: the lower-case   function, the tokenize   function, the «for» expression, and indeed the ability to manipulate a sequence of strings.  The XSLT stylesheet now takes this sequence of strings and applies the <xsl:for-each- group> instruction to it. This processes the body of the   instruction once for each group of selected items, where a group is identiﬁed as those items that have a common value for a grouping key. In this case the grouping key is written as «group-by="."», which means that the values  the words  are grouped on their own value.  In another application, we might have chosen to group them by their length, or by their initial letter.  So, the body of the instruction is executed once for each distinct word, and the   instruction tells us to sort the groups in descending order of the size of the groups  that is, the number of times each word appears . For each of the groups, we output a   element with two attributes: one attribute is the value we used as the grouping key; the other is the number of items in the group.  Don’t worry if this example seemed a bit bewildering: it uses many concepts that haven’t been explained yet. The purpose was to give you a feeling for some of the new features in XSLT 2.0 and XPath 2.0, which will all be explained in much greater detail elsewhere in this book.  Having dipped our toes brieﬂy into some XSLT code, I’d now like to take a closer look at the relationship between XSLT and XPath and other XML-related technologies.  The Place of XSLT in the XML Family  XSLT is published by the World Wide Web Consortium  W3C  and ﬁts into the XML family of standards, most of which are also developed by W3C. In this section I will try to explain the sometimes-confusing relationship of XSLT to other related standards and speciﬁcations.  21   XSLT in Context  XSLT and XSL Formatting Objects  XSLT started life as part of a bigger language called XSL  Extensible Stylesheet Language . As the name implies, XSL was  and is  intended to deﬁne the formatting and presentation of XML documents for display on screen, on paper, or in the spoken word. As the development of XSL proceeded, it became clear that this was usually a two-stage process: ﬁrst a structural transformation, in which elements are selected, grouped and reordered; and then a formatting process in which the resulting elements are rendered as ink on paper, or pixels on the screen. It was recognized that these two stages were quite independent, so XSL was split into two parts: XSLT for deﬁning transformations; and ‘‘the rest’’ — which is still ofﬁcially called XSL, though most people prefer to call it XSL-FO  XSL Formatting Objects  — for the formatting stage.  XSL-FO is nothing more than another XML vocabulary, in which the objects described are areas of the printed page and their properties. Since this is just another XML vocabulary, XSLT needs no special capabilities to generate this as its output. XSL-FO is outside the scope of this book. It’s a big subject. XSL-FO provides wonderful facilities to achieve high-quality typographical output of your documents. However, for many people translating documents into HTML for presentation by a standard browser is quite good enough, and that can be achieved using XSLT alone, or if necessary, by using XSLT in conjunction with Cascading Style Sheets  CSS or CSS2 , which I shall return to shortly.  It’s best to avoid the term XSL, because it’s used with so many different meanings. It’s the proper name for XSL Formatting Objects, but many people use it to mean XSLT. It’s also used in older Microsoft documents to refer to their obsolete WD-xsl language, which was issued as part of Internet Explorer 4 before XSLT was standardized in 1999.  XSLT and XPath  Halfway through the development of XSLT 1.0, it was recognized that there was a signiﬁcant overlap between the expression syntax in XSLT for selecting parts of a document and the XPointer lan- guage being developed for linking from one document to another. To avoid having two separate but overlapping expression languages, the two committees decided to join forces and deﬁne a single lan- guage, XPath, which would serve both purposes. XPath 1.0 was published on the same day as XSLT 1.0, November 16, 1999.  XPath acts as a sublanguage within an XSLT stylesheet. An XPath expression may be used for numerical calculations or string manipulations, or for testing Boolean conditions, but its most characteristic use  and the one that gives it its name  is to identify parts of the input document to be processed. For example, the following instruction outputs the average price of all the books in the input document:     Here, the   element is an instruction deﬁned in the XSLT standard, which causes a value to be written to the output document. The select attribute contains an XPath expression, which calcu- lates the value to be written: speciﬁcally, the average value of the price attributes on all the   elements.  The avg   function too is new in XPath 2.0.   Following its publication, the XPath speciﬁcation increasingly took on a life of its own, separate from XSLT. Several DOM implementations  including Microsoft’s  allowed you to select nodes within a DOM tree structure, using a method such as selectNodes XPath , and this feature is now included in the current version of the standard, DOM3. Subsets of XPath are used within the XML Schema language and in XForms for deﬁning validation conditions, and bindings of XPath to other languages such as  22   The Place of XSLT in the XML Family  1  Perl are multiplying. Perhaps most important of all, the designers of XQuery decided to make their language a pure superset of XPath. The language has also proved interesting to academics, and a num- ber of papers have been published analyzing its semantics, which provides the basis for optimized implementations.  X S L T  i  n C o n t e x t  XSLT and XML Namespaces  XSLT is designed on the basis that XML namespaces are an essential part of the XML standard. So when the XSLT standard refers to an XML document, it always means an XML document that conforms to the XML Namespaces speciﬁcation, which can be found at http:  www.w3.org TR REC-xml-names.  Namespaces play an important role in XSLT. Their purpose is to allow you to mix tags from two different vocabularies in the same XML document. We’ve already seen how a stylesheet can mix elements from the target vocabulary  for example HTML or XSL-FO  with elements that act as XSLT instructions. Here’s a quick reminder of how namespaces work:              Namespaces are identiﬁed by a Uniform Resource Identiﬁer  URI . This can take a number of forms. One form is the familiar URL, for example http:  www.wrox.com namespace. Another form, not fully standardized but being used in some XML vocabularies, is a URN, for example urn:biztalk-org:biztalk:biztalk_1. The detailed form of the URI doesn’t matter, but it is a good idea to choose one that will be unique. One good way of achieving this is to use the domain name of your own website. But don’t let this confuse you into thinking that there must be something on the website for the URI to point to. The namespace URI is simply a string that you have chosen to be different from other people’s namespace URIs; it doesn’t need to point to anything. The latest version, XML Namespaces 1.1, allows you to use an International Resource Identiﬁer  IRI  rather than a URI. The main difference is that this permits characters from any alphabet  for example, Chinese ; it is no longer conﬁned to ASCII. In practice, most XML parsers have always allowed you to use any characters you like in a namespace URI. Since namespace URIs are often rather long and use special characters such as « », they are not used in full as part of the element and attribute names. Instead, each namespace used in a document can be given a short nickname, and this nickname is used as a preﬁx of the element and attribute names. It doesn’t matter what preﬁx you choose, because the real name of the ele- ment or attribute is determined only by its namespace URI and its local name  the part of the name after the preﬁx . For example, all my examples use the preﬁx xsl to refer to the name- space URI http:  www.w3.org 1999 XSL Transform, but you could equally well use the preﬁx xslt, so long as you use it consistently. For element names, you can also declare a default namespace URI, which is to be associated with unpreﬁxed element names. The default namespace URI, however, does not apply to unpreﬁxed attribute names.  A namespace preﬁx is declared using a special pseudo-attribute within any element start tag, with the form:  xmlns:prefix = "namespace-URI"  This declares a namespace preﬁx, which can be used for the name of that element, for its attributes, and for any element or attribute name contained in that element. The default namespace, which is used for elements having no preﬁx  but not for attributes , is similarly declared using a pseudo-attribute:  xmlns = "namespace-URI"  23   XSLT in Context  XML Namespaces 1.1 became a Recommendation on February 4, 2004, and the XSLT 2.0 speciﬁcation makes provision for XSLT processors to work with this version, though it isn’t required. Apart from the largely cosmetic change from URIs to IRIs mentioned earlier, the main innovation is the ability to undeclare a namespace, using syntax of the form «xmlns:prefix=""». This is particularly intended for applications like SOAP messaging, where an XML payload document is wrapped in an XML envelope for transmission. Without namespace undeclarations, there is a tendency for namespaces used in the SOAP envelope to stick to the payload XML when this is removed from the envelope, which can cause problems — for example, it can invalidate a digital signature attached to the document.  XSLT and CSS  Why are there two stylesheet languages, XSL  that is, XSLT plus XSL Formatting Objects  as well as Cascading Style Sheets  CSS and CSS2 ?  It’s only fair to say that in an ideal world there would be a single language in this role, and that the reason there are two is that no one was able to invent something that achieved the simplicity and economy of CSS for doing simple things, combined with the power of XSL for doing more complex things.  CSS is mainly used for rendering HTML, but it can also be used for rendering XML directly, by deﬁning the display characteristics of each XML element. However, it has serious limitations. It cannot reorder the elements in the source document, it cannot add text or images, it cannot decide which elements should be displayed and which omitted, neither can it calculate totals or averages or sequence numbers. In other words, it can only be used when the structure of the source document is already very close to the ﬁnal display form.  Having said this, CSS is simple to write, and it is very economical in machine resources. It doesn’t reorder the document, and so it doesn’t need to build a tree representation of the document in memory, and it can start displaying the document as soon as the ﬁrst text is received over the network. Perhaps, most important of all, CSS is very simple for HTML authors to write, without any programming skills. In comparison, XSLT is far more powerful, but it also consumes a lot more memory and processor power, as well as training budget.  It’s often appropriate to use both tools together. Use XSLT to create a representation of the document that is close to its ﬁnal form, in that it contains the right text in the right order, and then use CSS to add the ﬁnishing touches, by selecting font sizes, colors, and so on. Typically, you would do the XSLT processing on the server and the CSS processing on the client  in the browser ; so, another advantage of this approach is that you reduce the amount of data sent down the line, which should improve response time for your users and postpone the next expensive bandwidth increase.  XSLT and XML Schemas  One of the biggest changes in XSLT 2.0, and one of the most controversial, is the integration of XSLT with the XML Schema language. XML Schema provides a replacement for DTDs as a way of specifying the structural constraints that apply to a class of documents; unlike DTDs, an XML Schema can regulate the content of the text as well as the nesting of the elements and attributes. Many of the industry vocabu- laries being used to deﬁne XML interchange standards are speciﬁed using XML Schema deﬁnitions. For example, several of the XML vocabularies for describing music, which I alluded to earlier in the chapter, have an XML Schema to deﬁne their rules, and this schema can be used to check the conformance of individual documents to the standard in question.  When you write a stylesheet, you need to make assumptions about the structure of the input docu- ments it is designed to process and the structure of the result documents it is designed to produce. With  24   The Place of XSLT in the XML Family  1  XSLT 1.0, these assumptions were implicit; there was no formal way of stating the assumptions in the stylesheet itself. As a result, if you try applying a stylesheet to the wrong kind of input document, the result will generally be garbage.  The idea of linking XSLT and XML Schema was driven by two main considerations:  X S L T  i  n C o n t e x t        There should, in principle, be software engineering beneﬁts if a program  and a stylesheet is indeed a program  makes explicit assertions about its expected inputs and outputs. These assertions can lead to better and faster detection of errors, often enabling errors to be reported at compile time that otherwise would only be reported the ﬁrst time the stylesheet was applied to some test data that happened to exercise a particular part of the code. The more information that’s available to an XSLT processor at compile time, the more potential it has to generate optimal code, giving faster execution and better use of memory.  So why the controversy? It’s mainly because XML Schema itself is less than universally popular. It’s an extremely complex speciﬁcation that’s very hard to read, and when you discover what it says, it appears to be full of rules that seem artiﬁcial and inconsistent. It manages at the same time to be spec- iﬁed in very formal language, and yet to have a worryingly high number of bugs that have been ﬁxed through published errata. Although there are good books that present XML Schema in a more read- able way, they achieve this by glossing over the complications, which means that the error messages you get when you do something wrong can be extremely obscure. As a result, there has been a sig- niﬁcant amount of support for an alternative schema language, Relax NG, which as it happens was co-developed by the designer of XSLT and XPath, James Clark, and is widely regarded as a much more elegant approach.  The XSL and XQuery Working Groups responded to these concerns by ensuring that support for XML Schema was optional, both for implementors and for users. This has largely silenced the objections.  The signs are that XML Schema is here to stay, whether people like it or not. It has the backing of all the major software vendors such as IBM, Oracle, and Microsoft, and it has been adopted by most of the larger user organizations and industries. And like so many things that the IT world has adopted as standards, it may be imperfect but it does actually work. Meanwhile, to simplify the situation rather cruelly, Relax NG is taking the role of the Apple Mac: the choice of the cognoscenti who judge a design by its intrinsic quality rather than by cold-blooded cost-beneﬁt analysis.  As I’ve already mentioned, W3C is not an organization that likes to let a thousand ﬂowers bloom. It is not a loose umbrella organization in which each working group is free to do its own thing. There are strong processes that ensure the working groups cooperate and strive to reconcile their differences. There is therefore a determination to make all the speciﬁcations work properly together, and the message was that if XML Schema had its problems, then people should work together to get them ﬁxed. XSLT and XML Schema come from the same stable, so they were expected to work together. And now that the specs are ﬁnished and products are out, I think users are starting to discover that they can work together beneﬁcially.  Chapter 4 provides an overview of how stylesheets and schemas are integrated in XSLT 2.0, and Chapter 19 provides a worked example of an application that uses this capability. When I ﬁrst devel- oped this application for the book  which I did at the same time as I developed the underlying support in Saxon , I was pleasantly surprised to see that I really was getting beneﬁts from the integration. At the simplest level, I really liked the immediate feedback you get when a stylesheet generates output that does not conform to the schema for the result document, with error messages that point straight to the offending line in the stylesheet. This makes for a much faster debugging cycle than does the old approach of putting the ﬁnished output ﬁle through a schema validator as a completely separate operation.  25   XSLT in Context  XSLT and XQuery  XQuery is a separate speciﬁcation from W3C, designed to allow data in XML documents to be queried. It can operate on single documents, or on collections containing millions of documents held in an XML database.  Functionally, XQuery offers a subset of the capabilities of XSLT. You could regard it as XSLT without the template rules, and without some of the extra features such as the ability to do grouping, or to format dates and times, or to import modules and selectively override them. It would be a mistake, however, to think that being a smaller language makes XQuery a poor relation. The relative simplicity of XQuery does indeed make it harder to write large and complex applications, but it does bring two signiﬁcant advantages: the language is easier to learn, especially for those coming from a SQL background, and it is easier to optimize, especially when running against gigabytes of data preloaded and preindexed in an XML database.  XQuery has XPath 2.0 as a subset. This makes it very much a member of the same family as XSLT. The two languages have a great deal in common, most importantly their type system. There are no formal facilities in the W3C speciﬁcations that allow XSLT and XQuery to be mixed in a single application, but because the processing models are so closely aligned, many implementations allow one language to be called from the other. Saxon in fact implements both languages as different surface syntaxes for the same underlying processing engine.  There are some applications for which XSLT is deﬁnitely better suited, particularly document publishing. There are others where XQuery is the only sensible choice, notably searching for data in large XML databases. There’s a third class of applications, especially message conversion, where either lan- guage will do the job, and where the choice is largely a matter of personal preference. My advice would be to use XQuery if it’s a very small application and XSLT if it’s bigger, largely because in my experience it’s easier to write XSLT code that’s adaptable to change and reusable in different applications.  The Histor y of XSL  Like most of the XML family of standards, XSLT was developed by the World Wide Web Consortium  W3C , a coalition of companies orchestrated by Tim Berners-Lee, the inventor of the Web. There is an interesting page on the history of XSL, and styling proposals generally, at http:  www.w3.org Style  History .  Writing history is a tricky business. Sharon Adler, the chair of the XSL Working Group, tells me that her recollections of events are very different from the way I describe them. This just goes to show that the documentary record is a very crude snapshot of what people were actually thinking and talking about. Unfortunately, though, it’s all that we’ve got.  Prehistory  26  HTML was originally conceived by Berners-Lee  www.w3.org MarkUp draft-ietf-iiir-html-01.txt  as a set of tags to mark the logical structure of a document; headings, paragraphs, links, quotes, code sections, and the like. Soon, people wanted more control over how the document looked; they wanted to achieve the same control over the appearance of the delivered publication as they had with printing and paper. So, HTML acquired more and more tags and attributes to control presentation; fonts, margins, tables, colors, and all the rest that followed. As it evolved, the documents being published became more and more browser-dependent, and it was seen that the original goals of simplicity and universality were starting to slip away.   The History of XSL  1  X S L T  i  n C o n t e x t  The remedy was widely seen as separation of content from presentation. This was not a new concept; it had been well developed through the 1980s in the development of Standard Generalized Markup Language  SGML .  Just as XML was derived as a greatly simpliﬁed subset of SGML, so XSLT has its origins in an SGML-based standard called DSSSL  Document Style Semantics and Speciﬁcation Language . DSSSL  pro- nounced Dissel  was developed primarily to ﬁll the need for a standard device-independent language to deﬁne the output rendition of SGML documents, particularly for high-quality typographical presen- tation. SGML was around for a long time before DSSSL appeared in the early 1990s, but until then the output side had been handled using proprietary and often extremely expensive tools, geared toward driving equally expensive phototypesetters, so that the technology was really taken up only by the big publishing houses.  Michael Sperberg-McQueen and Robert F. Goldstein presented an inﬂuential paper at the WWW ‘94 conference in Chicago under the title A Manifesto for Adding SGML Intelligence to the World-Wide Web. You can ﬁnd it at http:  tigger.uic.edu ∼cmsmcq htmlmax.html. The authors presented a set of requirements for a stylesheet language, which is as good a statement as any of the aims that the XSL designers were trying to meet. As with other proposals from around that time, the concept of a separate transformation language had not yet appeared, and a great deal of the paper is devoted to the rendition capabilities of the language. There are many formative ideas, however, including the concept of fallback processing to cope with situations where particular features are not available in the current environment.  It is worth quoting some extracts from the paper here:  Ideally, the stylesheet language should be declarative, not procedural, and should allow stylesheets to exploit the structure of SGML documents to the fullest. Styles must be able to vary with the structural location of the element: paragraphs within notes may be formatted differently from paragraphs in the main text. Styles must be able to vary with the attribute values of the element in question: a quotation of type ‘‘display’’ may need to be formatted differently from a quotation of type ‘‘inline’’. . .  At the same time, the language has to be reasonably easy to interpret in a procedural way: implementing the stylesheet language should not become the major challenge in implementing a Web client.  The semantics should be additive: It should be possible for users to create new stylesheets by adding new speciﬁcations to some existing  possibly standard  stylesheet. This should not require copying the entire base stylesheet; instead, the user should be able to store locally just the user’s own changes to the standard stylesheet, and they should be added in at browse time. This is particularly important to support local modiﬁcations of standard DTDs.  Syntactically, the stylesheet language must be very simple, preferably trivial to parse. One obvious possibility: formulate the stylesheet language as an SGML DTD, so that each stylesheet will be an SGML document. Since the browser already knows how to parse SGML, no extra effort will be needed.  We recommend strongly that a subset of DSSSL be used to formulate stylesheets for use on the World Wide Web; with the completion of the standards work on DSSSL, there is no reason for any community to invent their own style-sheet language from scratch. The full DSSSL standard may well be too demanding to implement in its entirety, but even if that proves true, it provides only an argument for deﬁning a subset of DSSSL that must be supported, not an argument for rolling our own. Unlike home-brew speciﬁcations, a subset of a standard comes with an automatically predeﬁned growth path. We expect to work on the formulation of a usable, implementable subset of DSSSL for use in WWW stylesheets, and invite all interested parties to join in the effort.  27   XSLT in Context  In late 1995, a W3C-sponsored workshop on stylesheet languages was held in Paris. In view of the subsequent role of James Clark as editor of the XSLT Recommendation, it is interesting to read the notes of his contribution on the goals of DSSSL, which can be found at http:  www.w3.org Style  951106_Workshop report1.htmlclark.  Here are a few selected paragraphs from these notes:  DSSSL contains both a transformation language and a formatting language. Originally the transforma- tion was needed to make certain kinds of styles possible  such as tables of contents . The query language now takes care of that, but the transformation language survives because it is useful in its own right.  The language is strictly declarative, which is achieved by adopting a functional subset of Scheme. Inter- active stylesheet editors must be possible.  A DSSSL stylesheet very precisely describes a function from SGML to a ﬂow object tree. It allows partial stylesheets to be combined  ‘‘cascaded’’ as in CSS : some rule may override some other rule, based on implicit and explicit priorities, but there is no blending between conﬂicting styles.  James Clark closed his talk with the remark:  Creating a good, extensible style language is hard!  One suspects that the effort of editing the XSLT 1.0 Recommendation didn’t cause him to change his mind.  The First XSL Proposal  Following these early discussions, the W3C set up a formal activity to create a stylesheet language pro- posal. The remit for this group speciﬁed that it should be based on DSSSL.  As an output of this activity came the ﬁrst formal proposal for XSL, dated August 27, 1997. Entitled A Proposal for XSL, it lists 11 authors: James Clark  who works for himself , ﬁve from Microsoft, three from Imso Corporation, one from ArborText, and one  Henry Thompson  from the University of Edinburgh. The document can be found at http:  www.w3.org TR NOTE-XSL.html.  The section describing the purpose of the language is worth reading.  XSL is a stylesheet language designed for the Web community. It provides functionality beyond CSS  e.g. element reordering . We expect that CSS will be used to display simply structured XML documents and XSL will be used where more powerful formatting capabilities are required or for formatting highly structured information such as XML structured data or XML documents that contain structured data.  Web authors create content at three different levels of sophistication given as follows:           markup: relies solely on a declarative syntax script: additionally uses code ‘‘snippets’’ for more complex behaviors program: uses a full programming language  XSL is intended to be accessible to the ‘‘markup’’ level user by providing a declarative solution to most data description and rendering requirements. Less common tasks are accommodated through a graceful escape to a familiar scripting environment. This approach is familiar to the Web publishing community as it is modeled after the HTML JavaScript environment.  28   The powerful capabilities provided by XSL allow:    formatting of source elements based on ancestry descendency, position, and uniqueness the creation of formatting constructs including generated text and graphics the deﬁnition of reusable formatting macros writing-direction independent stylesheets extensible set of formatting objects              The History of XSL  1  X S L T  i  n C o n t e x t  The authors then explained carefully why they had felt it necessary to diverge from DSSSL and described why a separate language from CSS  Cascading Style Sheets  was thought necessary.  They then stated some design principles:                                      XSL should be straightforwardly usable over the Internet. XSL should be expressed in XML syntax. XSL should provide a declarative language to do all common formatting tasks. XSL should provide an ‘‘escape’’ into a scripting language to accommodate more sophisticated formatting tasks and to allow for extensibility and completeness. XSL will be a subset of DSSSL with the proposed amendment.  As XSL was no longer a subset of DSSSL, they cannily proposed amending DSSSL so it would become a superset of XSL.  A mechanical mapping of a CSS stylesheet into an XSL stylesheet should be possible. XSL should be informed by user experience with the FOSI stylesheet language. The number of optional features in XSL should be kept to a minimum. XSL stylesheets should be human-legible and reasonably clear. The XSL design should be prepared quickly. XSL stylesheets shall be easy to create. Terseness in XSL markup is of minimal importance.  As a requirements statement, this doesn’t rank among the best. It doesn’t read like the kind of list you get when you talk to users and ﬁnd out what they need. It’s much more the kind of list that designers write when they know what they want to produce, including a few political concessions to the people who might raise objections. But if you want to understand why XSLT became the language it did, this list is certainly evidence of the thinking.  The language described in this ﬁrst proposal contains many of the key concepts of XSLT as it ﬁnally emerged, but the syntax is virtually unrecognizable. It was already clear that the language should be based on templates that handled nodes in the source document matching a deﬁned pattern, and that the language should be free of side effects, to allow ‘‘progressive rendering and handling of large doc- uments.’’ I’ll explore the signiﬁcance of this requirement in more detail on page 34, and discuss its implications on the way stylesheets are designed in Chapter 17. The basic idea is that if a stylesheet is expressed as a collection of completely independent operations, each of which has no external effect other than generating part of the output from its input  for example, it cannot update global variables , then it becomes possible to generate any part of the output independently if that particular part of the input changes. Whether the XSLT language actually achieves this objective is still an open question.  The ﬁrst Working Draft of XSL  not to be confused with the Proposal  was published on August 18, 1998, and the language started to take shape, gradually converging on  29   XSLT in Context  the ﬁnal form it took in the November 16, 1999 Recommendation through a series of Working Drafts, each of which made radical changes, but kept the original design principles intact.  A Recommendation is the most deﬁnitive of documents produced by the W3C. It’s not technically a standard, because standards can only be published by government-approved standards organizations. But I will often refer to it loosely as ‘‘the standard’’ in this book.  Saxon  At this point it might be a good idea to clarify how I got involved in the story. In 1998 I was working for the British computer manufacturer ICL, a part of Fujitsu. Fujitsu, in Japan, had developed an object database system, later marketed as Jasmine, and I was using this technology to build content manage- ment applications for large publishers. We developed a few successful large applications, but found that it was too complex for people who wanted something in six weeks rather than six months. So I was asked to look at what we could do with XML, which was just appearing on the horizon.  I came to the conclusion that XML looked like a good thing, but that there wasn’t any software. So I developed the very ﬁrst early versions of Saxon to provide a proof-of-concept demonstration. At that stage Saxon was just a Java library, not an XSLT processor, but as the XSL standards developed I found that my own ideas were converging more and more with what the W3C working group was doing, and I started implementing the language as it was being speciﬁed. ICL had decided that its marketing resources were spread thinly over too many products, and so the management took the imaginative decision to make the technology available as open source. Seventeen days after the XSLT 1.0 speciﬁcation was published in November 1999, I announced the ﬁrst conformant implementation. And on the day it was published, I started work on the ﬁrst edition of this book.  When the book was published, the XSL Working Group invited me to join and participate in the devel- opment of XSLT 1.1. Initially, being based in the United Kingdom and with limited time available for the work, my involvement was fairly sporadic. But early in 2001 I changed jobs and joined Software AG, which wanted me to take a full role in the W3C work. The following year James Clark pulled out of the Working Group, and I stepped into his shoes as editor.  The reason I’m explaining this sequence of events is that I hope it will help you to understand the viewpoint from which this book is written. When I wrote the ﬁrst edition I was an outsider, and I felt completely free to criticize the speciﬁcation when I felt it necessary. I have tried to retain an objective approach in the present edition, but as editor of the language spec it is much more difﬁcult to be impar- tial. I’ve tried to keep a balance: it wouldn’t be fair to use the book as a platform to push my views over those of my colleagues of the working group, but at the same time, I’ve made no effort to be defensive about decisions that I would have made differently if they had been left to me.  Software AG continued to support my involvement in the W3C work  on the XQuery group as well as the XSL group , along with the development of Saxon and the writing of this book, through till February 2004, at which point I left to set up my own company, Saxonica.  Beyond XSLT 1.0  30  After XSLT 1.0 was published, the XSL Working Group responsible for the language decided to split the requirements for enhancements into two categories: XSLT 1.1 would standardize a small number of   The History of XSL  1  urgent features that vendors had already found necessary to add to their products as extensions, while XSLT 2.0 would handle the more strategic requirements that needed further research.  A working draft of XSLT 1.1 was published on December 12, 2000. It described three main enhancements to the XSLT 1.0 speciﬁcation: the ability to produce multiple output documents, the ability to use tempo- rary trees to create a multi-pass transformation, and standard bindings to extension functions written in Java or ECMAScript.  X S L T  i  n C o n t e x t  For a number of reasons XSLT 1.1 never got past the working draft stage. This was partly because of controversy surrounding the Java language bindings, but more particularly because it was becoming clearer that XSLT 2.0 would be a fairly radical revision of the language, and the Working Group didn’t want to do anything in 1.1 that would get in the way of achieving the 2.0 goals. There were feelings, for example, that the facility for temporary trees might prejudice the ability to support sequences in 2.0, a fear which as it happens proved largely unfounded.  Convergence with XQuery  By the time work on XSLT 2.0 was starting, the separate XQuery Working Group in W3C had created a draft of its own language.  While the XSL Working Group had identiﬁed the need for a transformation language to support a self- contained part of the formatting process, XQuery originated from the need to search large quantities of XML documents stored in a database.  Work on an XML Query Language had started as early as 1998. A workshop was held in December 1998, and you can ﬁnd all 66 position papers presented at this workshop at http:  www.w3.org  TandS QL QL98 pp.html. It’s interesting to see how the participants saw the relationship with XSL, as it was then known. The Microsoft position paper states the belief that a query language could be developed as an extension of XSLT, but in this it is almost alone. Many of the participants came from a database background, with ideas ﬁrmly rooted in the tradition of SQL and object database languages such as OQL, and to these people, XSL didn’t look remotely like a query language. But in the light of subsequent events, it’s interesting to read the position paper from the XSL Working Group, which states in its summary:  1. 2. 3. 4.  5.  The query language should use XSL patterns as the basis for information retrieval. The query language should use XSL templates as the basis for materializing query results. The query language should be at least as expressive as XSL is, currently. Development of the pattern and transformation languages should remain in the XSL Working Group. A coordination group should ensure either that a single query language satisﬁes all working group requirements or that all W3C query languages share an underlying query model.   Remember that XPath had not yet been identiﬁed as a separate language, and that the expressions that later became XPath were then known as patterns.   This offer to coordinate, and the strong desire to ensure consistency among the different W3C speciﬁca- tions, can be seen as directly leading to the subsequent collaboration between the two working groups to deﬁne XPath 2.0.  The XQuery group started meeting in September 1999. The ﬁrst published requirements document was published the following January  http:  www.w3.org TR 2000 WD-xmlquery-req-20000131 . It  31   XSLT in Context  included a commitment to compatibility with XML Schema, and a rather cautiously worded promise to ‘‘take into consideration the expressibility and search facilities of XPath when formulating its algebra and query syntax.’’ July 2000 saw a revised requirements document that included a selection of queries that the language must be able to express. The ﬁrst externally visible draft of the XQuery language was published in February 2001  see http:  www.w3.org TR 2001 WD-xquery-20010215  , and it was at this stage that the collaboration between the two working groups began in earnest.  The close cooperation between the teams developing the two languages contrasts strangely with the somewhat adversarial position adopted by parts of the user community. XSLT users were quick to point out that XSLT 1.0 satisﬁed every single requirement in the ﬁrst XQuery requirements document, and could solve all the use cases published in the second version in August 2000. At the same time, users on the XQuery side of the fence have often been dismissive about XSLT, complaining about its verbose syntax and sometimes arcane semantics. Even today, when the similarities of the two languages at a deep level are clearly apparent, there is little overlap between their user communities: I ﬁnd that most users of the XQuery engine in Saxon have no XSLT experience. The difference between XSLT and XQuery is in many ways a difference of style rather than substance, but users often feel strongly about style.  The Development of XSLT 2.0 and XPath 2.0  The requirements for XSLT 2.0 and XPath 2.0 were published on February 14, 2001. In the case of the XPath 2.0 requirements, the document was written jointly by the two working groups. You can ﬁnd the documents at the following URLs:  http:  www.w3.org TR 2001 WD-xslt20req-20010214  http:  www.w3.org TR 2001 WD-xpath20req-20010214  Broadly, the requirements fall into three categories:           Features that are obviously missing from the current standards and that would make users’ lives much easier, for example, facilities for grouping related nodes, extra string-handling and numeric functions, and the ability to read text ﬁles as well as XML documents. Changes desired by the XML Query Working Group. The difﬁculty at this stage was that the Query group did not just want additions to the XPath language; they wanted fundamental changes to its semantics. Many members of the XQuery group felt they could not live with some of the arbitrariness of the way XPath handled data types generally, and node-sets in particu- lar, for example the fact that «a = 1» tests whether there is some «a» that equals one, whereas «a − 1 = 0» tests whether the ﬁrst «a» equals one. Features designed to exploit and integrate with XML Schema. The W3C XML Schema speciﬁcation had reached an advanced stage  it became a Candidate Recommendation on October 20, 2000 , and implementations were starting to appear in products. The thinking was that if the schema speciﬁed that a particular element contains a number or a date  for example , then it ought to be possible to use this knowledge when comparing or sorting dates within a stylesheet.  The development of XSLT 2.0, culminating in the Recommendation of January 23, 2007, proved to be a long drawn out process. There were early delays getting agreement with the XQuery group on the details of XPath 2.0. This took a long time ﬁrstly, because of the number of people involved; secondly, because of the very different places where people were coming from  the database community and the docu- ment community have historically been completely isolated from each other, and it took a lot of talking  32   XSLT 2.0 as a Language  1  before people started to understand each others’ positions ; and ﬁnally, because of the sheer technical difﬁculty of ﬁnding a workable design that offered the right balance between backwards compatibility and rigorous, consistent semantics. Later, when the speciﬁcation appeared to be all but ﬁnished, it still took a couple of years to get through the public reviews demanded by the W3C process, which generated thousands of detailed comments.  X S L T  i  n C o n t e x t  But that’s all history now. Let’s look next at the essential characteristics of XSLT 2.0 as a language.  XSLT 2.0 as a Language  What are the most signiﬁcant characteristics of XSLT as a language, which distinguish it from other languages? In this section I shall pick ﬁve of the most striking features: the fact that it is written in XML syntax, the fact that it is a language free of side effects, the fact that processing is described as a set of pattern-matching rules, the fact that it has a type system based on XML Schema, and the fact that it is a two-language system in which one language  XPath  is embedded in another  XSLT .  Use of XML Syntax  As we’ve seen, the use of SGML syntax for stylesheets was proposed as long ago as 1994, and it seems that this idea gradually became the accepted wisdom. It’s difﬁcult to trace exactly what the overriding arguments were, and when you ﬁnd yourself writing something like:                 to express what in other languages would be written as «y = f x ;», then you may ﬁnd yourself won- dering how such a decision came to be made.  The most obvious arguments for expressing XSLT stylesheets in XML are perhaps as follows:                    There is already an XML parser in the browser; so it keeps the footprint small if this can be reused. Everyone had got fed up with the syntactic inconsistencies between HTML XML and CSS and didn’t want the same thing to happen again. The Lisp-like syntax of DSSSL was widely seen as a barrier to its adoption; so it would be better to have a syntax that was already familiar in the target community.    Many existing popular template languages  including simple ASP and JSP pages  are expressed  as an outline of the output document with embedded instructions; so this is a familiar concept. The lexical apparatus is reusable, for example Unicode support, character and entity references, whitespace handling, namespaces. Visual development tools remove the inconvenience of typing lots of angle brackets. It’s often useful to have a stylesheet as the input or output of a transformation; so it’s a beneﬁt if a stylesheet can read and write other stylesheets.  33   XSLT in Context  In my experience, the most pervasive argument is the last one: it’s surprising how often complex appli- cations construct or modify stylesheets on the ﬂy. But like it or not, the XML-based syntax is now an intrinsic feature of the language that has both beneﬁts and drawbacks. It does make the language verbose, but in the end, the number of keystrokes has very little bearing on the ease or difﬁculty of solving particular transformation problems.  In XSLT 2.0, the long-windedness of the language has been reduced considerably by increasing the expressiveness of the non-XML part of the syntax, namely XPath expressions. Many computations that required ﬁve lines of XSLT code in 1.0 can now be expressed in a single XPath expression. Two con- structs in particular led to this simpliﬁcation: the conditional expression  if..then..else  in XPath 2.0; and the ability to deﬁne a function in XSLT  using    that can be called directly from an XPath expression. To take the example discussed earlier, if you replace the template «f» by a user-written function «f», you can replace the ﬁve lines in the example with:     The decision to base the XSLT syntax on XML has proved its worth in several ways that I would not have predicted in advance:           It has proved very easy to extend the syntax. Adding new elements and attributes is trivial; there is no risk of introducing parsing difﬁculties when doing so, and it is easy to manage backwards compatibility.  In contrast, extending XQuery’s non-XML syntax without introducing parsing ambiguities is a highly delicate operation.  The separation of XML parsing from XSLT processing leads to good error reporting and recovery in the compiler. It makes it much easier to report the location of an error with precision and to report many errors in one run of the compiler. This leads to a faster development cycle. It makes it easier to maintain stylistic consistency between different constructs in the language. The discipline of deﬁning the language through elements and attributes creates a constrained vocabulary with which the language designers must work, and these constraints impose a cer- tain consistency of design.  No Side Effects  The idea that XSL should be a declarative language free of side effects appears repeatedly in the early statements about the goals and design principles of the language, but no one ever seems to explain why: what would be the user beneﬁt?  A function or procedure in a programming language is said to have side effects if it makes changes to its environment; for example, if it can update a global variable that another function or procedure can read, or if it can write messages to a log ﬁle, or prompt the user. If functions have side effects, it becomes important to call them the right number of times and in the correct order. Functions that have no side effects  sometimes called pure functions  can be called any number of times and in any order. It doesn’t matter how many times you evaluate the area of a triangle, you will always get the same answer; but if the function to calculate the area has a side effect such as changing the size of the triangle, or if you don’t know whether it has side effects or not, then it becomes important to call it once only.  I expand further on this concept in the section on Computational Stylesheets in Chapter 17, page 985.  34   XSLT 2.0 as a Language  1  X S L T  i  n C o n t e x t  It is possible to ﬁnd hints at the reason why this was considered desirable in the statements that the language should be equally suitable for batch or interactive use, and that it should be capable of pro- gressive rendering. There is a concern that when you download a large XML document, you won’t be able to see anything on your screen until the last byte has been received from the server. Equally, if a small change were made to the XML document, it would be nice to be able to determine the change needed to the screen display, without recalculating the whole thing from scratch. If a language has side effects, then the order of execution of the statements in the language has to be deﬁned, or the ﬁnal result becomes unpredictable. Without side effects, the statements can be executed in any order, which means it is possible, in principle, to process the parts of a stylesheet selectively and independently.  What it means in practice to be free of side effects is that you cannot update the value of a variable. This restriction is something many users ﬁnd very frustrating at ﬁrst, and a big price to pay for these rather remote beneﬁts. But as you get the feel of the language and learn to think about using it the way it was designed to be used, rather than the way you are familiar with from other languages, you will ﬁnd you stop thinking about this as a restriction. In fact, one of the beneﬁts is that it eliminates a whole class of bugs from your code. I shall come back to this subject in Chapter 17, where I outline some of the common design patterns for XSLT stylesheets and, in particular, describe how to use recursive code to handle situations where in the past you would probably have used updateable variables to keep track of the current state.  Rule-Based  The dominant feature of a typical XSLT stylesheet is that it consists of a set of template rules, each of which describes how a particular element type or other construct should be processed. The rules are not arranged in any particular order; they don’t have to match the order of the input or the order of the output, and in fact there are very few clues as to what ordering or nesting of elements the stylesheet author expects to encounter in the source document. It is this that makes XSLT a declarative language, because you specify what output should be produced when particular patterns occur in the input, as distinct from a procedural program where you have to say what tasks to perform in what order.  This rule-based structure is very like CSS, but with the major difference that both the patterns  the description of which nodes a rule applies to , and the actions  the description of what happens when the rule is matched  are much richer in functionality.  Example: Displaying a Poem  Let’s see how we can use the rule-based approach to format a poem. Again, we haven’t introduced all the concepts yet, and so I won’t try to explain every detail of how this works, but it’s useful to see what the template rules actually look like in practice.  Input  Let’s take this poem as our XML source. The source ﬁle is called poem.xml, and the stylesheet is poem.xsl.      Rupert Brooke   1912   Song   35   XSLT in Context   And suddenly the wind comes soft,   And Spring is here again;   And the hawthorn quickens with buds of green   And my heart with buds of pain.    My heart all Winter lay so numb,   The earth so dead and frore,   That I never thought the Spring would come again   Or my heart wake any more.                 But Winter’s broken and earth has woken,   And the small birds cry again;   And the hawthorn hedge puts forth its buds,   And my heart puts forth its pain.         Output  Let’s write a stylesheet such that this document appears in the browser, as shown in Figure 1-8.  Stylesheet  It starts with the standard header.  <xsl:stylesheet  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" version="1.0">  Now we write one template rule for each element type in the source document. The rule for the   element creates the skeleton of the HTML output, deﬁning the ordering of the elements in the output  which doesn’t have to be the same as the input order . The   instruction inserts the value of the selected element at this point in the output. The   instructions cause the selected child elements to be processed, each using its own template rule.                                     36   XSLT 2.0 as a Language  1  X S L T  i  n C o n t e x t  Figure 1-8  In XSLT 2.0 we could replace the four   instructions with one, writ- ten as follows:     This takes advantage of the fact that the type system for the language now supports ordered sequences. The «,» operator performs list concatenation and is used here to form a list containing the  ,  ,  , and   elements in that order. Note that this includes all the   elements, so in general this will be a sequence containing more than four items. The template rules for the  ,  , and   elements are very simple; they take the content of the element  denoted by «select = "."» , and surround it within appropriate HTML tags to deﬁne its display style.                   37   XSLT in Context         By                        The template rule for the   element puts each stanza into an HTML paragraph, and then invokes processing of the lines within the stanza, as deﬁned by the template rule for lines:             The rule for   elements is a little more complex: if the position of the line within the stanza is an even number, it precedes the line with two non-breaking-space characters  &160; . The   instruction tests a boolean condition, which in this case calls the position   function to determine the relative position of the current line. It then outputs the contents of the line, followed by an empty HTML   element to end the line.      &160;&160;         And to ﬁnish off, we close the   element:     Although template rules are a characteristic feature of the XSLT language, we’ll see that this is not the only way of writing a stylesheet. In Chapter 17, I will describe four different design patterns for XSLT stylesheets, only one of which makes extensive use of template rules. In fact, the Hello World stylesheet I presented earlier in this chapter doesn’t make any real use of template rules; it ﬁts into the design pattern I call ﬁll-in-the-blanks, because the stylesheet essentially contains the ﬁxed part of the output with embedded instructions saying where to get the data to put in the variable parts.  Types Based on XML Schema  I have described three characteristics of the XSLT language  the use of XML syntax, the principle of no side-effects, and the rule-based processing model  that were essential features of XSLT 1.0 and that have been retained essentially unchanged in XSLT 2.0. The fourth characteristic is new in XSLT 2.0, and creates a fundamental change in the nature of XSLT as a language. This is the adoption of a type system based on XML Schema.  There are two aspects to the type system of any programming language. The ﬁrst is the set of types that are supported  for example, integers, strings, lists, tuples , together with the mechanisms for creating user-deﬁned types. The second aspect is the rules that the language enforces to ensure type-correctness.  38   XSLT 2.0 as a Language  1  XSLT 1.0 had a very small set of types  integers, booleans, strings, node-sets, and result tree fragments , and the rules it applied were what is often called ‘‘weak typing’’: this means that the processor would always attempt to convert the value supplied in an expression or function call to the type that was required in that context. This makes for a very happy-go-lucky environment: if you supply an integer where a string is expected, or vice versa, nothing will break.  X S L T  i  n C o n t e x t  XSLT 2.0 has changed both aspects of the type system. There is now a much richer set of types available  and this set is user-extensible , and the rules for type checking are stricter.  We will look at the implications of this in greater detail in Chapters 4 and 5.  A Two-Language System: XSLT and XPath  The ﬁnal characteristic of XSLT that I want to explore is its use of XPath as an embedded sublanguage. This is not unlike the way SQL is often embedded in other languages, and it is done for the same reason — it allows XPath to be used in many different contexts.  The fact that XPath was designed to be embedded in other language has some speciﬁc consequences:                    An embedded language does not need to have every conceivable piece of functionality. In the language of computer science, it does not need to be computationally complete. In more practical terms, it can be restricted to being able to access variables but not to declare them, to call func- tions but not to deﬁne them, to navigate around nodes in a tree but not to create new nodes. An embedded language can depend on a context established by the host language in which it is embedded. If an embedded language is to be well integrated with a host language, then they should share information so that the user does not need to declare things twice, once for each language. The information that XPath shares with its host language is called the context. This can be divided into information that’s available at compile time  the static context , and information that’s not available until runtime  the dynamic context . Both aspects of the XPath context are described in Chapter 7 of this book. An embedded language can be called by its host language, but cannot make calls in the other direction. XSLT can invoke XPath, but not the other way around. This means that there is incom- plete composability of expressions when the XSLT language is considered as a whole. However, XPath can invoke XSLTindirectly by means of function calls. Some functionality, notable condi- tional and iteration constructs, are duplicated in XSLT and XPath.  The syntax of XPath has some unusual features, which reﬂect the fact that it amalgamates ideas from a number of different sources. One can identify three different syntactic styles within XPath expressions:  Conventional programming expressions: This allows the same kind of expressions, inﬁx opera- tors, and function calls as many other programming languages; an example is an expression such as «$x + 1 = round $y  mod 3». Such expressions trace their roots via programming languages such as Algol and Fortran back to the notations of elementary mathematics. Path expressions: These perform hierarchic selection of a node within a tree, an example is « a b  c». These expressions can be seen as a generalization of the syntax used by operating systems to identify ﬁles within a hierarchic ﬁlestore. Predicate logic: This includes the «for», «some» and «every» expressions, for example «for $i in   item[@price > 30] return $i @code». These expressions, which are new in XPath 2.0, derive from the tradition of database query languages  SQL, the object database language OQL, and precursors to XQuery , which can be seen as adaptations of the notation of mathe- matical symbolic logic.  39   XSLT in Context  Some other factors that have inﬂuenced the design of the XPath syntax include:           A decision that XPath should have no reserved words. This means that any name that is legal as an XML element name  which includes names such as «and» and «for»  should be legal in a path expression, without any need for escaping. As a result, all names used with some other role, for example function names, variable names, operator names, and keywords such as «for», have to be recognizable by their context. In both the original applications for XPath  that is, XSLT and XPointer , the language was designed to be embedded within the attributes of an XML document. It therefore has no mecha- nisms of its own for character escaping, relying instead on the mechanisms available at the XML level  such as numeric character references and entity references . This also made the designers reluctant to use symbols such as «&&», which would require heavy escaping. This principle has been abandoned in XPath 2.0 with the introduction of the operators « >»; however, these operators are not likely to be used very often. There was originally an expectation that XPath expressions  especially in an XPointer environ- ment  would often be used as fragment identiﬁers in a URI. This usage of XPointer never really took off, but it meant there was a reluctance to use special characters such as «», «%», and «?» that have special signiﬁcance in URIs.  Despite its disparate syntactic roots and its lexical quirks, XPath has managed to integrate these different kinds of expression surprisingly well. In particular, it has retained full composability within itself, so any kind of expression can be nested inside any other.  Summar y  This introductory chapter answered the following questions about XSLT:    What kind of language is it?    How is it used?    Where does it ﬁt into the XML family?   Where does it come from and why was it designed the way it is?  You now know that XSLT is a declarative high-level language designed for transforming the structure of XML documents; that it has two major applications: data conversion and presentation; and that it can be used at a number of different points in the overall application architecture, including at data capture time, at delivery time on the server, and at display time on the browser. You also have some idea why XSLT has developed in the way it has.  Now it’s time to start taking an in-depth look inside the language to see how it does this job. In the next chapter, we look at the way transformation is carried out by treating the input and output as tree structures, and using patterns to match particular nodes in the input tree and deﬁne what nodes should be added to the result tree when the pattern is matched.  40   2  T h e  X S L T  i  P r o c e s s n g M o d e  l  The XSLT Processing Model  This chapter takes a bird’s-eye view of what an XSLT processor does. We start by looking at a system overview: what are the inputs and outputs of the processor?  Then we look in some detail at the data model, in particular the structure of the tree representation of XML documents. An important message here is that XSLT transformations do not operate on XML documents as text; they operate on the abstract tree-like information structure represented by the markup.  Having established the data model, I will describe the processing sequence that occurs when a source document and a stylesheet are brought together. XSLT is not a conventional procedural language; it consists of a collection of template rules deﬁning output that is produced when particular patterns are matched in the input. As seen in Chapter 1, this rule-based processing structure is one of the distinguishing features of the XSLT language.  Finally, we look at the way in which variables and expressions can be used in an XSLT stylesheet, and also look at the various data types available.  XSLT: A System Over view  This section looks at the nature of the transformation process performed by XSLT, concentrating on the inputs and outputs of a transformation.  A Simpliﬁed Overview  The core task of an XSLT processor is to apply a stylesheet to a source document and produce a result document. This is shown in Figure 2-1.  As a ﬁrst approximation we can think of the source document, the stylesheet, and the result document as each being an XML document. XSLT performs a transformation process because the output  the result document  is the same kind of object as the input  the source document . This has immediate beneﬁts: for example, it is possible to do a complex transformation as a series of simple transformations, and it is possible to do transformations in either direction using the same technology.   The XSLT Processing Model  Stylesheet  Source  Document  Figure 2-1  Result  Document  The choice of Rubik’s cube to illustrate the transformation process is not entirely whimsical. The math- ematics of Rubik’s cube relies on group theory, which is where the notion of closure comes from: every operation transforms one instance of a type into another instance of the same type. We’re transforming XML documents rather than cubes, but the principle is the same.  The name stylesheet has stuck for the document that deﬁnes the transformation, despite the fact that XSLT is often used for tasks that have nothing to do with styling. The name reﬂects the reality that a very common kind of transformation performed using XSLT is to deﬁne a display style for the information in the source document, so that the result document contains information from the source document augmented with information controlling the way it is displayed on some output device.  Trees, Not Documents  In practice, we don’t always want the input or output to be XML in its textual form. If we want to produce HTML output  a very common requirement , we want to produce it directly, rather than having an XML document as an intermediate form. When the Firefox browser displays the result of an XSLT transformation, it doesn’t serialize the result to HTML and then parse the textual HTML; rather, it works directly from the result tree as a data structure in memory. Similarly, we might want to take input from a database or  say  an LDAP directory, or an EDI message, or a data ﬁle using comma-separated-values syntax. We don’t want to spend a lot of time converting these into serial XML documents if we can avoid it, nor do we want another raft of converters to install.  Instead, XSLT deﬁnes its operations in terms of a data model  called XDM  in which an XML document is represented as a tree. The tree is an abstract data type. There is no deﬁned application programming interface  API  and no deﬁned data representation, only a conceptual model that deﬁnes the objects in the tree, their properties, and their relationships. The XDM tree is similar in concept to the W3C DOM, except that the Document Object Model  DOM  does have a deﬁned API. Some implementors do indeed use the DOM as their internal tree structure. Others use a data structure that corresponds more closely to the XDM speciﬁcation, while some use optimized internal data structures that are only distantly related to this model. It’s a conceptual model we are describing, not something that necessarily exists in an implementation.  The data model for XSLT trees is shared with the XPath and XQuery speciﬁcations, which ensures that data can be freely exchanged between these three languages  it also means you can take your pick as to what the ‘‘X’’ in ‘‘XDM’’ stands for . With XSLT and XPath, this is of course essential, because XSLT  42   XSLT: A System Overview  always retrieves data from a source document by executing XPath expressions. There is a description of this data model later in this chapter, and full details are in Chapter 4.  Taking the inputs and output of the XSLT processors as trees produces a new diagram  see Figure 2-2 . The formal conformance rules say that an XSLT processor must be able to read a stylesheet and use it to transform a source tree into a result tree. This is the part of the system shown in the oval box. There’s no ofﬁcial requirement to handle the parts of the process shown outside the box, namely the creation of a source tree from a source XML document  known as parsing , or the creation of a result XML document from the result tree  called serialization . In practice, though, most real products are likely to handle these parts as well.  2  T h e  X S L T  i  P r o c e s s n g M o d e  l  Stylesheet  Stylesheet  Tree  Transformation  Process  Source Tree  Parsing  Source  Document  Result Tree  Serialization  Result  Document  Figure 2-2  Different Output Formats  Although the ﬁnal process of converting the result tree to an output document is outside the conformance rules of the XSLT standard, this doesn’t mean that XSLT has nothing to say on the subject.  The main control over this process is the   element. This element deﬁnes four output formats or methods, namely xml, html, xhtml, and text. In each case a result tree is written to a single output ﬁle.    With the xml output method, the output ﬁle is an XML document . We’ll see later that it need  not be a complete XML document; it can also be an XML fragment. The   element allows the stylesheet writer some control over the way in which the XML is written, for example, the character encoding used and the use of CDATA sections.    With the html output method, the output ﬁle is an HTML document, typically HTML 4.0, though  products may support other versions if they wish. With HTML output, the XSLT processor recognizes many of the conventions of HTML and structures the output accordingly. For example, it recognizes elements such as   that have a start tag and no end tag, as well as the special rules for escape characters within a   element. It may also  if it chooses  gen- erate references to built-in entities such as «&eacute;».  43   The XSLT Processing Model           Selecting html as the output method doesn’t in any way automate the process of creating valid HTML, nor does it cause the processor to check that the output is valid HTML  with one exception — it will report the presence of characters that aren’t allowed in HTML . All it does is to tell the serializer to use HTML conventions when turning the nodes in the tree back into markup. The xhtml output method, as one might expect, is a compromise between the xml and html output methods. Generally speaking, it follows the rules of the xml output method, but sticks to the conventions described in the XHTML speciﬁcation that are designed to make the output display properly in browsers that were written to handle HTML. Such conventions include, for example, outputting an empty   element as    with a space before the « » , and outputting an empty   element as   . The text output method is designed to allow output in any other text-based format. For example, the output might be a comma-separated-values ﬁle, a document in Microsoft’s Rich Text Format  RTF , or in Adobe’s Portable Document Format  PDF ; or, it might be an electronic data interchange message, or a script in SQL or JavaScript. It’s entirely up to you.  If the   element is omitted, the processor makes an intelligent guess, choosing HTML if the output starts with an   element in the null namespace, XHTML if it starts with an   element in the XHTML namespace, and XML otherwise.  Implementations may include output methods other than these four, but this is outside the scope of the standard. One mechanism provided by several products is to feed the result tree to a user-supplied document handler. In the case of Java products, this will generally be written to conform to the ContentHandler interface deﬁned as part of the SAX2 API speciﬁcation  which is part of the core class library in Java . Most implementations also provide mechanisms to capture the result as a DOM tree. Remember that if you use the result tree directly in this way, the XSLT processor will not serialize the tree, and therefore nothing you say in the   declaration will have any effect.  So, while the bulk of the XSLT Recommendation describes the transformation process from a source tree to a result tree, there is one section that describes another process, serialization. Because the seria- lization of a document tree as a ﬁle is a process that is relevant not only to XSLT but also to XQuery and potentially other applications in the future, the detail is no longer in the XSLT 2.0 Recommendation, but forms a W3C speciﬁcation in its own right  see http:  www.w3.org TR xslt-xquery-serialization  . For similar reasons, it has a chapter of its own in this book  Chapter 15 . The name serialization is used because it turns a tree structure into a stream of characters or bytes, but it mustn’t be confused with serialization in distributed object systems such as Component Object Model  COM  or Java, which produces a serial ﬁle representation of a COM or Java object. XSLT processors can implement this at their discretion, and it ﬁts into our diagram as shown in Figure 2-3.  Multiple Inputs and Outputs  In real life, the processing model is further complicated because there can be multiple inputs and outputs. Speciﬁcally:     There can be multiple input documents. The stylesheet can use the doc   or document   functions  described in Chapter 13, page 750  to load secondary input documents, based on URI references held in the source document or the stylesheet. Each input document is processed as a tree in its own right, in exactly the same way as the principal input document. It is also possible to supply additional input documents as parameters to the stylesheet, or to read an entire collection of documents using the collection   function.  44   The XDM Tree Model        The stylesheet may also consist of multiple documents. There are two declarations that can be used in the stylesheet,   and  , to load additional stylesheet modules and use them as extensions of the principal module. Splitting a stylesheet in this way allows modularity: in a complex environment different aspects of processing can be described in component stylesheets that can be incorporated into several different parent stylesheets. There is a detailed discussion of how to split a stylesheet into modules in Chapter 3. A single run of the XSLT processor can produce multiple output documents. This allows a single source document to be split into several output ﬁles: for example, the input might contain the text of an entire book, while the output contains one HTML ﬁle for each chapter, all connected using suitable hyperlinks. This capability, which is provided by the   element described in Chapter 6, is new in XSLT 2.0, though many vendors provided similar facilities as extensions to their XSLT 1.0 processors.  2  T h e  X S L T  i  P r o c e s s n g M o d e  l  Stylesheet  Stylesheet  Tree  Serialization  Source Tree  Parsing  Source  Document  Result Tree  Transformation  Process  XML  HTML  XHTML  TEXT  Figure 2-3  The XDM Tree Model  Let’s now look at the tree model used in XSLT and XPath, in a little more detail. It’s deﬁned in the W3C Speciﬁcation XQuery 1.0 and XPath 2.0 Data Model  XDM   http:  www.w3.org TR xpath-datamodel : you can read XDM as standing for either XQuery Data Model or XPath Data Model  or even XML Data Model  as you prefer.  The XDM tree model is similar in many ways to the XML DOM. However, there are a number of differences of terminology and some subtle differences of detail. I’ll point some of these out as we go along.  XML as a Tree  In this section, I will describe the XDM tree model of an XML document, and show how it relates to textual XML ﬁles containing angle brackets.  45   The XSLT Processing Model  This isn’t actually how the XDM speciﬁcation does it: it adopts a more indirect approach, showing how the data model relates to the XML InfoSet  an abstract description of the information content of an XML document , and the Post Schema Validation Infoset  PSVI , which is deﬁned in the XML Schema speciﬁcations to deﬁne the information that becomes available as a result of schema processing. The InfoSet is described in a W3C speciﬁcation at http:  www.w3.org TR xml-infoset . The PSVI is described in the W3C Schema recommendations at http:  www.w3.org TR xmlschema-1 .  At a simple level, the equivalence of the textual representation of an XML document with a tree representation is very straightforward.  Example: An XML Tree  Consider a document like this:      export   vt   Send out  goods  to another country.      Latin        ex   out  of          portare   to carry              We can consider each piece of text as a leaf node, and each element as a containing node, and build an equivalent tree structure, as shown in Figure 2-4. I show the tree after the stripping of all whitespace nodes  in XSLT this can be achieved using the   declaration; in other environments, it may be something you can control from the processor’s API . In this diagram each node is shown with potentially three pieces of information:    In the top cell, the kind of node In the middle cell, the name of the node In the bottom one, its string value        For the document node and for elements, I showed the string value simply as an asterisk; in fact, the string value of these nodes is deﬁned as the concatenation of the string values of all the element and text nodes at the next level of the tree.  46   The XDM Tree Model  element  part-of-speech  element meaning  element etymology  *  element  word  *  text  export  *  text  vt  document  element definition  *  *  *  text  send out goods to another country  element language  *  text  Latin  *  text  ex  element  parts  *  element  element  part *  *  text  part *  *  text  element prefix  element meaning  element word  element meaning  *  text  out  of   portare  to carry  Figure 2-4  It is easy to see how other aspects of the XML document, for example, attributes and processing instructions, can be similarly represented in this tree view by means of additional kinds of nodes.  At the top of every tree, there is a root node  trees in computer science always grow upside down . Usually the root will be a document node, but we will look at other cases later on.  The terminology here has changed since XPath 1.0. What was the root node in XPath 1.0 is now called a document node. In XPath 2.0, it is possible to have element nodes, or indeed any kind of node, that have no parent. Any node that has no parent, whatever kind of node it is, can be considered to be the root of a tree. So the term ‘‘root’’ no longer refers to a particular kind of node, but rather to any node that has no parent, and is therefore at the top of a tree, even if that tree contains just one node.  An XDM document node performs the same function as the document node in the DOM model, in that it doesn’t correspond to any particular part of the textual XML document, but you can regard it as representing the XML document as a whole. The children of the document node are the top-level elements, comments, processing instructions, and so on.  2  T h e  X S L T  i  P r o c e s s n g M o d e  l  47   The XSLT Processing Model  In the XML speciﬁcation the outermost element is described as the ‘‘root or document element.’’ In XDM this element is not the root of the tree  because it has a parent, the document node , and the term ‘‘document element’’ is not normally used, because it is too easily confused with ‘‘document node.’’ I prefer to call it the ‘‘outermost element,’’ because that seems to cause least confusion.  The XDM tree model can represent every well-formed XML document, but it can also represent structures that are not well-formed according to the XML deﬁnition. Speciﬁcally, in well-formed XML, there must be a single outermost element containing all the other elements and text nodes. This element can be preceded and followed by comments and processing instructions, but it cannot be preceded or followed by other elements or text nodes.  XDM does not enforce this constraint — the document node can have any children that an element might have, including multiple elements and text nodes in any order. The document node might also have no children at all. This corresponds to the XML rules for the content of an external general parsed entity, which is a freestanding fragment of XML that can be incorporated into a well-formed document by means of an entity reference. I shall sometimes use the term well balanced to refer to such an entity. This term is not used in the XDM speciﬁcation; rather, I have borrowed it from the largely forgotten XML fragment interchange proposal  http:  www.w3.org TR xml-fragment.html . The essential feature of a well- balanced XML fragment is that every element start tag is balanced by a corresponding element end tag.  Example: Well-balanced XML Fragment  The following example shows an XML fragment that is well balanced but not well formed, as there is no enclosing element:  The  cat   sat  on the  mat .  The corresponding XDM tree is shown in Figure 2-5. In this case it is important to retain whitespace, so spaces are shown using the symbol ♦.  text  the♦  text  ♦  element  text  ♦on♦the♦  text  .  document  *  verb  *  text  sat  element  noun  *  text  mat  element  noun  *  text  cat  Figure 2-5  The string value of the document node in this example is simply:  The cat sat on the mat.  48   2  T h e  X S L T  i  P r o c e s s n g M o d e  l  The XDM Tree Model  In practice the input and output of an XSLT transformation will usually be well-formed documents, but it is very common for temporary trees constructed in the course of processing to have more than one element as a child of the document node.  Nodes in the Tree Model  An XDM tree is made up of nodes. There are seven kinds of node. The different kinds of node correspond fairly directly to the components of the source XML document:  Node Kind Document node  Element node  Text node  Attribute node  Comment node  Processing instruction node  Namespace node  Description The document node is a singular node; there is one for each document. Do not confuse the document node with the document element, which in a well-formed document is the outermost element that contains all others. A document node never has a parent, so it is always the root of a tree.  An element is a part of a document bounded by start and end tags, or represented by a single empty-element tag such as  . Try to avoid referring to elements as tags: elements generally have two tags, a start tag and an end tag.  A text node is a sequence of consecutive characters in a PCDATA part of an element. Text nodes are always made as big as possible: there will never be two adjacent text nodes in the tree, because they will always be merged into one.  This is the theory. Some implementations don’t always follow this rule   An attribute node includes the name and value of an attribute written within an element start tag  or empty element tag . An attribute that was not present in the tag, but which has a default value deﬁned in the DTD or Schema, is also represented as an attribute node on each separate element instance. A namespace declaration  an attribute whose name is «xmlns» or whose name begins with «xmlns:»  is, however, not represented by an attribute node in the tree.  A comment node represents a comment written in the XML source document between the delimiters « »  A processing instruction node represents a processing instruction written in the XML source document between the delimiters « ». The PITarget from the XML source is taken as the node’s name and the rest of the content as its value. Note that the XML declaration   is not a processing instruction, even though it looks like one, and it is not represented by a node in the tree.  A namespace node represents a namespace declaration, except that it is copied to each element that it applies to. So each element node has one namespace node for every namespace declaration that is in scope for the element. The namespace nodes belonging to one element are distinct from those belonging to another element, even when they are derived from the same namespace declaration in the source document.  49   The XSLT Processing Model  There are several possible ways of classifying these nodes. We could distinguish those that can have children  element and document nodes , those that can have a parent  everything except the document node , those that have a name  elements, attributes, namespaces, and processing instructions  or those that have their own textual content  attributes, text, comments, processing instructions, and namespace nodes . Because each of these criteria gives a different possible class hierarchy, the XDM model instead leaves the hierarchy completely ﬂat, and deﬁnes all these characteristics for all nodes. Where a character- istic isn’t applicable to a particular kind of node, XDM generally deﬁnes its value as an empty sequence, though sometimes when you access the property from a real XPath expression what you actually get back is a zero-length string.  So if we show the class hierarchy in UML notation, we get the simple diagram shown in Figure 2-6.  UML  the Uniﬁed Modeling Language  provides a set of diagrammatic conventions for object-oriented analysis and design. For information about UML, see http:  www.uml.org .  Node  Document  Element  Attribute  Text  Comment  Processing Instruction  Namespace  Figure 2-6  This diagram looks superﬁcially similar to the tree we saw earlier, but this time I’m not showing a speciﬁc tree, I’m showing a class hierarchy: the boxes represent classes or types, and the arrow represents an is-a-kind-of relationship; for example a comment is-a-kind-of node. The earlier diagram was just one example of a particular tree, whereas now we are considering the structure of all possible trees.  I’ve already hinted at some of the properties and relationships of these nodes. Let’s look at the properties and relationships in more detail, and then add them to the diagram.  The Name of a Node  In general, a node has a name. Nodes can  and often do  have simple names, but in the general case, node names are qualiﬁed by the namespace they are in.  An element or attribute name as written in a textual XML document is a lexical QName.  QName stands for Qualiﬁed Name.  A lexical QName has two parts: the preﬁx, which is the part of the QName before the «:» as written in the source XML, and the local part, which is the part of the QName after the «:». If there is no colon, the preﬁx is the zero-length string. For example, «xsl:stylesheet» is a lexical QName, with preﬁx «xsl» and local-name «stylesheet».  In XDM, however, a name is represented by an expanded QName. This is an atomic value whose type is xs:QName. The expanded QName has three parts, though there is no explicit syntax for displaying it. The three parts are the preﬁx, the namespace URI, and the local part.  50   The XDM Tree Model  The namespace URI is derived from the preﬁx used in the source document, by ﬁnding the namespace declarations that are in scope where it is used, while the local name is again the part of the lexical QName after the «:». The preﬁx is retained as part of the expanded name, to allow a document to be serialized using the author’s original choice of preﬁxes, but it is not considered to be a signiﬁcant part of the name. So the expanded QName corresponding to the lexical QName «xsl:stylesheet» has namespace URI http:  www.w3.org 1999 XSL Transform  assuming the standard namespace declarations are used , and local part «stylesheet», while also retaining the preﬁx «xsl» for display purposes.  The name of an element or attribute node is accessible, as an xs:QName value, using the node-name   function deﬁned in Chapter 13. The namespace URI and local-name parts of the name are also separately accessible  as strings  using the functions namespace-uri   and local-name  . If you want the original lexical QName, it can be obtained using the name   function.  Document nodes, comments, and text nodes have no name, and for these, the node-name   function returns the empty sequence, which is the XDM equivalent of a null value.  Note that this differs from the DOM, where names such as «comment» are used.   The name of a processing instruction is the PITarget from the source XML: this contains a local name but no namespace URI, as processing instruction names are not subject to namespace rules.  2  T h e  X S L T  i  P r o c e s s n g M o d e  l  The name of a namespace node is, by convention, the namespace preﬁx from the original namespace declaration  without the «xmlns:» part . For example, the namespace declaration «xmlns:acme="http:   acme.com xml"» generates a namespace node with name «acme», while the default namespace declaration «xmlns="http:  acme.com xml"» generates a namespace node whose name is effectively null  represented as an empty sequence . The name of a namespace node, like the name of any other node, is an xs:QName, but the namespace URI part of this xs:QName is always null, while the local-name part holds the namespace preﬁx. The String Value of a Node  Every node has a string value, which is a sequence of Unicode characters. The string value depends on the kind of node, as shown in the table below:  Node Kind Text  Comment  Processing instruction  Attribute  Document or element  String Value The text as it appears in the source XML document, except that the XML parser will have replaced every end-of-line sequence  for example, CRLF as used on Windows platforms  by a single newline  x0A  character.  The text of the comment, minus the delimiters.  The data part of the source processing instruction, not including the whitespace that separates it from the PITarget. For example, given the processing instruction  , the string value is «this».  The string value is the value of the attribute as written, modiﬁed by any whitespace normalization done by the XML parser and schema processor. The detailed rules for whitespace normalization of attributes depend on the attribute type.  The concatenation of the string values of all the element and text children of this node. Or, to look at it another way: the concatenation of all the PCDATA contained in the element  or for the document node, the entire document  after stripping out all markup.  This again differs from the DOM, where the nodeValue property in these cases is null.   Namespace  By convention, the URI of the namespace being declared.  51   The XSLT Processing Model  The string value of a node can be obtained by using the string   function described in Chapter 13. This should not be confused with the xs:string   constructor, which works differently when applied to a node: it extracts the typed value of the node, as described in the next section, and then converts the typed value to a string. This might not give precisely the same result. For example, if the attribute is declared as an xs:boolean, and the actual attribute is written as «ok="1"», then the result of «string @ok » will be the string «1», while the result of «xs:string @ok » will be the string «true».  In XPath 2.0, most operations use the typed value of a node, which is discussed in the next section. The only time the string value is used directly is when you explicitly call the string   function, or one or two other functions such as string-length   or normalize-space  . But the result differs from the typed value only if the node has been validated using a schema.  The Typed Value of a Node  The typed value of a node reﬂects the content of the node as it appears after schema validation. The typed value is available using the data   function described in Chapter 13; it is also obtained implicitly as the result of the process of atomization, described on page 165.  Schema validation only applies to element and attribute nodes, so let’s get the other kinds of nodes out of the way ﬁrst. For every other kind of node, the typed value is the same as the string value, which is deﬁned in the previous section. However, for document nodes, namespace nodes, and text nodes, the value is labeled as xs:untypedAtomic, while for comments and processing instructions it is labeled as xs:string. There is, as one might expect, some tortuous logic behind this apparently arbitrary distinc- tion: labeling a value as xs:untypedAtomic enables the value to be used in contexts where a value other than a string is required, whereas a value labeled as xs:string can only be used where that is the type expected. There are plausible scenarios where one might want to use the content of document nodes, namespace nodes, and text nodes in non-string contexts, but it’s hard to think of similar justiﬁcations for comments and processing instructions.  Let’s return to elements and attributes, which are the cases where the typed value comes into its own.  First of all, if you’re working on a document that has no schema, or that has not been validated against a schema, or if you’re using an XSLT processor that doesn’t support schema processing, then the typed value of an element or attribute is the same as the string value, and is labeled with the type xs: untypedAtomic. This is very close to the situation with XPath 1.0, which didn’t support schema processing at all. It means that when you use an expression that returns an element or attribute node  for example, path expressions like «title» or «@price» , then they take on the type expected by the context where you use them. For example, you can use «@price» as a number by writing «@price * 0.8», or you can use it as a string by writing «substring-after @price, ‘$’ ». The typed value of the attribute, which is simply the string value as written in the source document, will be converted to a number or to a string as required by the context. If the conversion fails, for example, if you try to use the value as an integer when it isn’t a valid integer, then you get a runtime error.  If you have processed the document using a schema, things get more interesting. The situation where the typed value is most useful is where the schema deﬁnes a simple type for the element or attribute  or in the case of elements, a complex type with simple content — which means that the element can have attributes, but it cannot have child elements . As we will see in Chapter 4, simple types in XML Schema allow atomic values or lists of atomic values, but they don’t allow child elements.  52                        The XDM Tree Model  The simple type may be an atomic type, such as xs:integer or xs:date, in which case the typed value will be the result of converting the string value to an xs:integer or xs:date value according to the rules deﬁned by XML Schema. The value must be a valid xs:integer or xs:date, or it wouldn’t have passed schema validation. The schema may also deﬁne the type as being a list; for example, a list of xs:integer or xs:date values. In this case the typed value is a sequence of zero or more atomic values, again following the rules deﬁned in XML Schema. Another possibility is that the schema deﬁnes a union type; for example, it may allow either an xs:integer or an xs:date. The schema validator tries to interpret the value as an xs:integer  if that is the ﬁrst possibility listed , and if that fails, it tries to validate it as an xs:date. The typed value returned by the data   function may then be either an xs:integer or an xs:date value. Lists of a union type are also allowed, so you can get back a sequence containing  say  a mixture of integers and dates.  2  T h e  X S L T  i  P r o c e s s n g M o d e  l  For attributes, all types are simple types, so the above rules cover all the possibilities. For elements, however, there are additional rules to cover non-simple types:  If the schema deﬁnes the element as having mixed content, then the typed value is the same as the string value, labeled as xs:untypedAtomic. Note that the deciding factor is that the schema allows mixed content  a mixture of element and text node children , not that the element in question actually has mixed content: in reality it might have element children, or text children, or both or neither. This is identical to the rule for processing without a schema, which means that in many cases, narrative or document-oriented XML  as opposed to data-oriented XML  will be processed in exactly the same way whether there is a schema or not. Narrative XML is characterized by heavy use of mixed content models. If the schema deﬁnes the element as having empty content  that is, the element is not allowed to have either element nodes or text nodes as children, though it can have attributes , then the typed value is an empty sequence. If the schema deﬁnes the element as having an element-only content model  that is, it can contain element nodes as children but not text nodes , then there is no typed value deﬁned, and attempting to retrieve the typed value causes an error. This error is classiﬁed as a type error, which means it may be detected and reported either at compile time or at evaluation time. The reason that this is an error is that the typed value must always be a sequence of atomic values, and there is really no way of doing justice to the content of a structured element by representing it as such a sequence. The content is not atomic, because it only makes sense when considered in conjunction with the names of the child elements. Element-only content models tend to feature strongly in ‘‘data-oriented’’ XML applications.  The Type Annotation of a Node  As well as having a typed value, a node also has a type annotation. This is a reference to the type deﬁni- tion that was used to validate the node during schema processing. It is not available directly to applica- tions, but it affects the outcome of a number of type-sensitive operations. For example, when you select all attributes of type xs:date by writing the path expression «  attribute *, xs:date »  this is described in Chapter 11 , the system looks at the type annotations of the attributes to see which nodes qualify.  53   The XSLT Processing Model  In the XDM speciﬁcation, the type annotation is modeled as an xs:QName holding the name of the type in the case where the type is a globally declared schema type, or an invented name in the case where it is locally declared  not all types deﬁned in a schema need to be named . It’s reasonable to treat this as polite ﬁction, designed to tie up loose ends in the speciﬁcation in an area where the practical details will inevitably vary from one implementation to another. Any real schema-aware XPath processor will need to have some kind of access to schema information both at compile time and at runtime, but the W3C speciﬁcations have not tried to model exactly what this should look like. In practice, the type annotation on a node is likely to be implemented as some kind of pointer into the metadata representing the cached schema information. But for deﬁning the semantics of constructs like «  attribute *, xs:date », it’s enough to assume that the node contains just the type name.  The type annotation deﬁnes the type of the content of the node, not the type of the node itself. This is an important distinction, and we’ll have more to say about it when we discuss the XPath type system in Chapter 5.  You might imagine that the type annotation is redundant, because the typed value is itself an atomic value, and the atomic value itself has a label identifying its type. Very often, the type annotation of the node will be the same as the label on its typed value. However, this only works for nodes whose typed value is a single atomic value. In cases where the schema type is a list type, or a union type, the type annotation on the node is the name of the list or union type, which is not the same as the type of the individual atomic values making up the typed value. For example, if the schema type of an attribute is xs:IDREFS  which is deﬁned as a list of xs:IDREF values , then the type annotation on the attribute node will be xs:IDREFS, but the items in the typed value will be labeled xs:IDREF. If the typed value is an empty sequence, there will be no items to carry a label, but the containing node can still be annotated as being of type xs:IDREFS. Similarly, if the schema type of an element allows attributes as well as integer content, the typed value will be labeled as xs:integer, while the element node itself will have a type annotation that refers to the name of a complex type in the schema.  There is, however, a strong relationship between the string value, the typed value, and the type annota- tion. In fact, with knowledge of the schema and access to a schema validator, the typed value can always be reconstructed from the string value and the type annotation.  If an element or attribute node has not been validated using a schema processor, then the type annotation will be xs:untypedAtomic in the case of an attribute node, or xs:untyped in the case of an element node.  For document, comment, processing-instruction, and namespace nodes, there is no type annotation  the value of the type annotation is an empty sequence . For text nodes, the type annotation is xs:untypedAtomic  but there is nothing in the language that makes use of this fact .  The Base URI of a Node  A node has a base URI. This should not be confused with its namespace URI. The base URI of a node depends on the URI of the source XML document it was loaded from, or more accurately, the URI of the external entity it was loaded from, since different parts of the same document might come from different XML entities. The base URI is used when evaluating a relative URI reference that occurs as part of the value of this node, for example an href attribute: this is always interpreted relative to the base URI of the node it came from.  It is possible to override this by specifying an explicit base URI using the xml:base attribute. For example, if an element has the attribute «xml:base=".. index.xml"», then the base URI for this element, and for  54   The XDM Tree Model  all its descendants provided they are in the same XML external entity, is the index.xml ﬁle in the parent directory of the ﬁle that would otherwise have provided the base URI.  The base URI is maintained explicitly only for document nodes, element nodes, and processing instruction nodes. For attributes, text nodes, and comments, and for elements and processing instructions without an explicit base URI of their own, the base URI is the same as the URI of its parent node.  For a namespace node the base URI is «  », the empty sequence. The system doesn’t attempt to go to the parent node to ﬁnd its base URI. This is rather a curiosity. The only time you might be interested in the base URI of a namespace node is if you are using the namespace URI as the URI of a real resource, for example a schema. But even then, the base URI will only be needed if this is a relative URI reference. W3C, after ﬁerce debate, decided that a relative namespace URI was deprecated and implementation deﬁned, so the working groups steered clear of deﬁning an interpretation for it.  The fact that text nodes don’t have their own base URI is a little ad hoc, because a text node need not come from the same external entity as its parent element, but it reﬂects the decision that text nodes should be joined up irrespective of entity boundaries.  The base URI of a node in a source document is used almost exclusively for one purpose: to resolve relative URI references when loading additional input documents using the doc   or document   functions, described in Chapter 13. The base URI is accessible using the base-uri   function, which is also described in Chapter 13.  2  T h e  X S L T  i  P r o c e s s n g M o d e  l  The Children of a Node  A node has a sequence of child nodes. This one-to-many relationship is deﬁned for all nodes, but the list will be empty for all nodes other than document nodes and element nodes. So you can ask for the children of an attribute, and you will get an empty sequence returned.  The children of an element are the elements, text nodes, processing instructions, and comments contained textually between its start and end tags, provided that they are not also children of some lower-level element.  The children of the document node are all the elements, text nodes, comments, and processing instruc- tions that aren’t contained in another element. For a well-formed document the children of the root node will be the outermost element plus any comments or processing instructions that come before or after the outermost element.  The attributes of an element are not regarded as children of the element; neither are its namespace nodes.  The Parent of a Node  Every node, except a node at the root of a tree, has a parent. A document node never has a parent. Other kinds of node usually have a parent, but they may also be parentless. The parent relationship is not the exact inverse of the child relationship: speciﬁcally, attribute nodes and namespace nodes have an element node as their parent, but they are not considered to be children of that element. In other cases, however, the relationship is symmetric: elements, text nodes, processing instructions, and comments are always children of their parent node, which will always be either an element or the document node.  Two nodes that are both children of the same parent are referred to as being siblings of each other.  In case you are not a native English speaker, the word ‘‘sibling’’ means ‘‘brother or sister.’’   55   The XSLT Processing Model  The Attributes of a Node  This relationship only exists in a real sense between element nodes and attribute nodes, and this is how it is shown on the diagram at the end of this section. It is a one-to-many relationship: one element has zero or more attributes. The relationship hasAttributes is deﬁned for all nodes, but if you ask for the attributes of any node other than an element, the result will be an empty sequence.  The Namespaces of a Node  This relationship only really exists between element nodes and namespace nodes, and this is how it is shown on the diagram. It is a one-to-many relationship: one element has zero or more namespace nodes. Like the hasAttributes relationship, the relationship hasNamespaces is deﬁned for all nodes, so if you ask for the namespaces of any node other than an element, the result will be an empty sequence.  Note that each namespace node is owned uniquely by one element. If a namespace declaration in the source document has a scope that includes many elements, then a corresponding namespace node will be generated for each one of these elements. These nodes will all have the same name and string value, but they will be distinct nodes for the purposes of counting and using the «is» operator  which tests whether its two operands are references to the same node: see Chapter 8 .  Completing the UML Class Diagram  It’s now possible to draw a more complete UML class diagram, as shown in Figure 2-7. In this version:  Node  Name: QName String Value: String Typed Vaue: Atomic Value* Base URI: URI Type Annotation: QName  hasChildren  PossibleParent  PossibleChild  Document  DocumentURI: URI  Unparsed  Entity  SystemID: URI PublicID: String  hasUnparsedEntities  Element  hasAttributes  hasNamespaces  Text  Processing Instruction  Comment  Namespace  Attribute  Figure 2-7  56   The XDM Tree Model              I brought out PotentialParent and PotentialChild as separate  abstract  classes, to group those nodes that can be parents  document and element nodes  and those nodes that can be children  elements, text nodes, comments, and processing instructions . Abstract classes are shown as shaded boxes on the diagram. Note that elements fall into both categories. This grouping is for illustration only, and in reality the relationships hasChildren, hasAttributes, and hasNamespaces are available for all kinds of node, they just return an empty sequence when the node is not a document or element node. I identiﬁed the hasChildren relationship between an element or document node and its children. I identiﬁed the separate relationships between an element and its attributes, and between an element and its namespace nodes. I identiﬁed the additional class UnparsedEntity. This is not itself a node on the tree. It corresponds to an unparsed entity declaration within the document’s DTD. Unparsed entities are exposed by the functions unparsed-entity-uri   and unparsed-entity-public-id   available in XSLT  see Chapter 13 , but they are second-class citizens, because there is no way to create an unparsed entity in an output document.  2  T h e  X S L T  i  P r o c e s s n g M o d e  l  It’s worth mentioning that XDM never uses null values in the sense that SQL or Java use null values. If a node has no string value, then the value returned is the zero-length string. If a node has no children, then the value returned is the empty sequence, a sequence containing no items.  Let’s look brieﬂy at some of the other features of this model.  Document Order  Nodes within a tree have an ordering, called document order. Where two nodes come from the same tree, their relative position in document order is based on their position in the tree, which in turn is based on the ordering of the underlying constructs in the original textual XML document. For example, an element precedes its children in document order, and sibling nodes are listed in the same order as they appear in the original source document. By convention an element node is followed by its namespace nodes, then its attributes, and then its children, but the ordering of the namespace nodes among themselves, and of the attribute nodes among themselves, is unpredictable.  Where two nodes come from different trees, they still have a document order, but it is not predictable what it will be. In fact, any sequence of nodes can be sorted into document order, whether the nodes come from the same document or different documents, and if you sort the same sequence into document order more than once, you will always get the same result, but in the case of nodes from different documents, you can’t predict which one will come ﬁrst. The spec does say, however, that nodes from different docu- ments will not be interleaved: a node from document A will never come after one node from document B and before another node from document B.  There are a number of XPath expressions that always return nodes in document order. These include all path expressions  any expression using the « » operator , step expressions such as «ancestor::*», and expressions using the operators union  or «» , intersect, and except. If you want to sort a sequence $seq into document order, you can do this with the trivial path expression «$seq .», or by forming a union with the empty sequence: «$seq  ».  XPath 2.0 also includes operators to test whether one node is before or after another in document order: the expressions «$a >$a» both test whether node $a is before $b in document order.  When a node is copied, for example using the XSLT instruction  , the new node has a new position in document order that is quite unrelated to the position of the old node.  57   The XSLT Processing Model  Names and Namespaces  XSLT and XPath are designed very much with the use of XML namespaces in mind, and although many source documents may make little or no use of namespaces, an understanding of the XML Namespaces Recommendation  found in http:  www.w3.org TR xml-names11  is essential.  I’ll start with an overview of how namespaces work, and then get into more detail of how they are represented in the XDM data model.  Namespaces: An Overview  Expanding on the description in Chapter 1  page 23 , here’s a summary of how namespaces work:                       A namespace declaration deﬁnes a namespace preﬁx and a namespace URI. The namespace preﬁx needs to be unique only within a local scope, but the namespace URI is supposed to be unique globally. Globally here really does mean globally — not just unique in the document, but unique across all documents around the planet. To achieve that, the advice is to use a URI based on a domain name that you control, for example, http:  www.mega-utility.com  namespace billing. The W3C speciﬁcations are a little ambivalent about whether the namespace name really must be a valid absolute URI, but this is good practice and some products insist on it. In most of our examples we’ll use URIs beginning with «http:  ». Some people also recommend using a URI that leads human readers to a document on the Web that deﬁnes and documents the namespace, but this isn’t mandatory. The namespace URI does not have to identify any particular resource, and even if it does, XML and XSLT processors won’t go looking for it. Two namespace URIs are considered equal if they contain the same sequence of Unicode characters. This means that the two strings file:   c: this.dtd and file:   c: THIS.DTD are both legal namespace URIs, whether or not there is actually a ﬁle of this name, and they represent different namespaces even though when read as ﬁlenames they might identify the same ﬁle. To emphasize the point: The fact that every XSLT stylesheet uses the namespace URI http:  www.w3.org 1999 XSL Transform doesn’t mean that you need an Internet connection before you can run a transformation. The name is just an elaborate constant, it’s not the address of something that the processor has to go and fetch. A namespace declaration for a non-null preﬁx is written as follows. This associates the namespace preﬁx my-prefix with the namespace URI http:  my.com namespace:     A namespace declaration may also be present for the null preﬁx. This is known as the default namespace. The following declaration makes http:  your.com namespace the default namespace URI:     In the absence of such a declaration, an unpreﬁxed element name is not in any namespace. I will often describe such a name as being in the null namespace, though this is not the ofﬁcially correct terminology. The default namespace applies only to element names, not to attribute names; an unpreﬁxed attribute name is always in the null namespace.  58   The XDM Tree Model     You can undeclare the default namespace like this:           This puts you back in the position you were in at the outermost level of the document: an element name with no preﬁx is in the null namespace. The latest version of the XML Namespaces Recommendation, version 1.1, also allows you to undeclare other namespaces, like this:     This has the effect that the preﬁx becomes unavailable for use within this element. This feature is not widely used, but XDM allows for it. The scope of a namespace declaration is the element on which it appears plus all its children and descendants, excluding any subtree where the same preﬁx is undeclared or redeclared to asso- ciate it with a different URI. This scope deﬁnes where the preﬁx is available for use. Within this scope, any name with the given preﬁx is automatically associated with the given namespace URI.  2  T h e  X S L T  i  P r o c e s s n g M o d e  l  Namespaces in the Data Model  A namespace-qualiﬁed name is referred to as a QName. When a QName appears in a textual XML document, it is written in the form preﬁx:local-part. For example, in the name xsl:template, the preﬁx is «xsl» and the local part is «template». XSLT refers to this form as a lexical QName. The real underlying name, however, is the combination of the namespace URI and the local part. When two names are compared, they are considered equivalent if they have the same namespace URI and the same local part; it is irrelevant whether or not they were written with the same preﬁx. The combination of a namespace URI and a local name is referred to as an expanded QName. An expanded QName also retains the original preﬁx, but this is ‘‘for information only’’: it is never used when names are compared.  An expanded QName is never written directly in XPath, it is purely an internal value manipulated by the system. However, in some APIs and in error messages you might sometimes see expanded QNames written out in the form «{http:  my.com namespace}local-name». This format is sometimes called Clark notation, after James Clark, the editor of the XSLT 1.0 and XPath 1.0 speciﬁcations.  The job of converting element and attribute names from lexical QNames into expanded QNames is done by the XML parser. The namespace URI of the name is found from the innermost element that carries a namespace declaration of the relevant preﬁx. If a name has no preﬁx, then its namespace URI is considered to be the default namespace URI in the case of an element name, or a null URI in the case of an attribute name.  A namespace node represents the binding of a namespace preﬁx to a namespace URI: it uses the node name to hold the preﬁx, and the string value of the node to represent the URI. In many cases, namespace nodes are redundant — you could reconstruct them from other information, such as the expanded names of elements and attributes, or from the namespace nodes on the parent element. In fact, a real implemen- tation might well construct many namespace nodes on the ﬂy in this way. But in some cases namespace nodes hold essential information; the explanation for this appears in the section ‘‘Namespace Sensitive Content’’ on the next page.  For any element, it is possible to determine all the namespace declarations in force for that element, by retrieving the associated namespace nodes. These are all made available as if the namespace  59   The XSLT Processing Model  declarations were repeated on that speciﬁc element. The application cannot determine where the namespace declaration actually occurred in the original document, but if there is a namespace node present for a particular element, then it follows that there was a namespace declaration either on that element or on some containing element.  Namespace undeclarations, for example «xmlns=""», or in XML Namespaces 1.1 «xmlns: ppp=""», are not represented as namespace nodes; rather they result in the absence of a namespace node for the names- pace that has been undeclared. Without the undeclaration, the parser would create a namespace node for that namespace for every element within its scope, whether the element used it or not; the namespace undeclaration stops this happening.  Although the namespace declarations are originally written in the source document in the form of XML attributes, they are not retained as attribute nodes on the tree, and cannot be processed by looking for all the attribute nodes. Similarly, it is not possible to generate a namespace node on the result tree by creating an attribute with a name such as «xmlns:p»: such names are reserved for namespace declarations. In the data model, namespaces and attributes are quite distinct animals. XSLT 2.0 has a special instruction,  , for creating namespace nodes on the rare occasions that you need to do so.  Namespace Sensitive Content  Namespace nodes are needed because of the possibility that elements or attributes will contain namespace-sensitive content. If namespace preﬁxes were only ever used in element and attribute names, it would be possible to reconstruct all the namespace declarations simply by looking at the preﬁxes and URIs held in the expanded QNames of the elements and attributes.  Unfortunately, it is quite common for XML documents to contain references to element or attribute names within the content of the document. The obvious examples of XML documents that use this tech- nique are XSLT stylesheets and XML schemas. When you see a stylesheet containing an attribute such as «select="html:table"», or a schema containing the attribute «type="xs:date"», you are looking at namespace-sensitive content. Similarly, the attribute «xsi:type="xs:short"» appearing in an instance document is using namespaces both in the attribute name and in the attribute content. Stylesheets and schemas are not the only XML documents to use this technique, but they are probably the ones you will encounter most frequently.  In general, the XML parser can’t convert these values from lexical QNames to expanded QNames because it doesn’t know that they are special. XML Schema has tried to address the problem by deﬁning a data type «xs:QName» that declares the content of an element or attribute to be a QName, but this doesn’t solve the whole problem, for a number of reasons:              There can be namespace-sensitive content other than simple QNames; for example, an attribute might contain an XPath expression, which is also namespace sensitive, but there is no schema- deﬁned type for it. There are documents that have no schema. Although knowing the data type means that a schema processor can convert the lexical QName used in the string value of these attributes to the expanded QName used as the typed value, this only works if the schema processor knows the mapping of preﬁxes to namespace URIs. So if you want to be able to construct a tree and then pass it to a schema processor for validation, you need some way of representing the namespace information on the tree before this can work. The deﬁnition of the xs:QName data type says that an unpreﬁxed QName is assumed  like an unpreﬁxed element name  to be in the default namespace. Unfortunately, at least one heavy user  60   The XDM Tree Model  2  T h e  X S L T  i  P r o c e s s n g M o d e  l  of QName-valued attributes, namely the XSLT speciﬁcation, had already decided that an unpreﬁxed QName  like an unpreﬁxed attribute name  should be in the null namespace. This means that if the attribute were deﬁned as an xs:QName, a schema processor would allocate the wrong namespace URI. So you will ﬁnd that in the schema for XSLT 2.0  the schema that can be used to validate XSLT stylesheets , the xs:QName data type isn’t actually used.  So, namespace nodes exist primarily so that namespace preﬁxes appearing in namespace-sensitive content can be handled. Although this might seem a minor requirement, they cause signiﬁcant complications.  The way namespace nodes are represented in the data model hasn’t changed signiﬁcantly between XPath 1.0 and XPath 2.0. What has changed, though, is that namespace nodes are now semi-hidden from the application. To be precise, the only way that you could actually get your hands on a namespace node in XPath 1.0 was by using the namespace axis; and in XPath 2.0, the namespace axis has been depre- cated, which means that some implementations may continue to support it for backward-compatibility reasons, but they aren’t required to. Instead, two functions have been provided, in-scope-prefixes   and namespace-uri-for-prefix  , that provide access to information about the namespaces that are in scope for any element. These functions are described in Chapter 13. The signiﬁcance of this change is that it gives implementations the freedom to maintain namespace information internally in a form that is much more efﬁcient than the formal description of namespace nodes in XDM would imply: remember that the data model is just a model, not a description of a real implementation.  As far as XSLT and XPath are concerned, don’t worry too much about namespace nodes — all you need to know is that there are functions you can call to resolve namespace preﬁxes found in element or attribute content. When you construct new trees, however, understanding what namespace nodes are present on the new tree sometimes becomes more important.  IDs and IDREFs  An ID is a string value that identiﬁes an element node uniquely within a document. If an element has an ID, it becomes easy and  one hopes  efﬁcient to access that element if the ID value is known. Before XML Schemas came along, the ID always appeared as the value of an attribute declared in the DTD as being of type ID. XML Schema has retained this capability, but also allows the content of an element to be used as an ID value. This is done by declaring its type as xs:ID, which is a type derived by restriction from xs:string.  In XDM, every element has at most one ID value and  if the document is valid, which is not necessarily the case  every ID value identiﬁes at most one element.  For example, in an XML dataset containing details of employees, each   element might have a unique ssn attribute giving the employee’s Social Security number. For example:        John Doe  ...        Jane Stagg  ...       61   The XSLT Processing Model  As the ssn attribute is unique, it can be declared in the DTD as an ID attribute using the following declaration:     Alternatively, an ID attribute can be declared in a schema:             ...           More recently, a third way of deﬁning ID attributes has been deﬁned. Simply name the attribute xml:id, and it will automatically be recognized as an ID attribute.  Note, however, that if you validate your documents against a DTD or schema, it is still necessary to declare this as a permitted attribute name.   An ID value is constrained to take the form of an XML NCName. This means, for example, that it must start with a letter, and that it must not contain characters such as « », «:», or space.  Attributes can also be deﬁned as being of type IDREF or IDREFS if they contain ID values used to point to other elements in the document  an IDREF attribute contains one ID value, an IDREFS attribute contains a whitespace-separated list of ID values . XPath provides a function, id    see page 802 , which can be used to locate an element given its ID value. This function is designed so that an IDREF or IDREFS attribute can be used as input to the function, but equally, so can any other string that happens to contain an ID. However, IDREF and IDREFS attributes are treated specially by the idref   function  see page 804 , which follows IDREF links in the opposite direction — given an ID value, it ﬁnds all the nodes of type IDREF or IDREFS that refer to it.  There is a slight complication with the use of ID values, in that XPath is not constrained to process only valid XML documents. If an XML document is well formed  or merely well balanced  but not valid, then values that are supposed to be IDs may be duplicated, and they might not obey the syntactic rules for an XML NCName. Similarly, attributes might be marked as IDREF attributes, but actually contain broken links  values that don’t match the ID of any element in the document . The XDM speciﬁcation says that if an ID value appears more than once, all occurrences except the ﬁrst are ignored. If the ID value contains invalid characters such as spaces, the id   function will fail to ﬁnd the element but will otherwise appear to work correctly. If you use ID values, it’s probably a good idea to use a validating XML parser to prevent this situation occurring.  XSLT offers another more ﬂexible approach to ﬁnding elements  or other nodes  by content, namely keys. With keys you can do anything that IDs achieve, other than enforcing uniqueness. Keys are declared in the stylesheet using the   element, and they can be used to ﬁnd a node by means of the key   function.  Characters in the Data Model  In the XML Information Set deﬁnition  http:  www.w3.org TR xml-infoset , each individual character is distinguished as an object  or information item . This is a useful model conceptually, because it allows one to talk about the properties of a character and the position of a character relative to other characters, but it would be very expensive to represent each character as a separate object in a real tree implementation.  62   The XDM Tree Model  XDM has chosen not to represent characters as nodes. It would be nice if it did, because the XPath syntax could then be extended naturally to do character manipulation within strings, but the designers chose instead to provide a separate set of string-manipulation functions. These functions are described in Chapter 13.  A string  and therefore the string value of a node  is a sequence of zero or more characters. Each character is a Char as deﬁned in the XML standard. Loosely, this is a Unicode character. In XML 1.0 it must be one of the following:  One of the four whitespace characters tab x09, linefeed x0A, carriage return x0D, or space x20. An ordinary 16-bit Unicode character in the range x21 to xD7FF or xE000 to xFFFD. An extended Unicode character in the range x010000 to x10FFFF. In programming languages such as Java, and in ﬁles using UTF-8 or UTF-16 encoding, such a character is represented as a surrogate pair, using two 16-bit codes in the range xD800 to xDFFF. But as far as XPath is con- cerned, it is one character rather than two. This affects functions that count characters in a string or that make use of the position of a character in a string, for example the functions string- length  , substring  , and translate  . Here XPath differs from Java, which normally counts a surrogate pair as two characters.  2  T h e  X S L T  i  P r o c e s s n g M o d e  l  Unicode surrogate pairs are starting to be increasingly used for specialist applications. For example, there is a full range of musical symbols in the range x1D100 to x1D1FF. Although these are unlikely to be used when typesetting printed sheet music, they are very important in texts containing musical criticism. They also have some of the most delightful names in the whole Unicode repertoire: Who can resist a character called Tempus Perfectum cum Prolatione Perfecta? If you’re interested, it looks like a circle with a dot in the middle.  Note that line endings are normalized to a single newline x0A character, regardless of how they appear in the original XML source ﬁle.  XML 1.1 allows additional characters, notably control characters in the range x01 to x1F. XSLT 2.0 and XPath 2.0 processors are not obliged to support XML 1.1, but many are likely to do so eventually. XML 1.1 also recognizes line ending characters used on IBM mainframes and converts these to the standard x0A newline character.  It is not possible in a stylesheet to determine how a character was written in the original XML ﬁle. For example, the following strings are all identical as far as XDM is concerned:                             >  &gt;  &62;  &x3E;  &x003E;   ]]>  The XML parser handles these different character representations. In most implementations, the XSLT processor couldn’t treat these representations differently even if it wanted to, because they all look the same once the XML parser has dealt with them.  63   The XSLT Processing Model  What Does the Tree Leave Out?  The debate in deﬁning a tree model is about what to leave out. What information from the source XML document is signiﬁcant, and what is an insigniﬁcant detail? For example, is it signiﬁcant whether the CDATA notation was used for text? Are entity boundaries signiﬁcant? What about comments?  Many newcomers to XSLT ask questions like ‘‘How can I get the processor to use single quotes around attribute values rather than double quotes?’’ or ‘‘How can I get it to output «&nbsp;» instead of «&160;»?’’ The answer is that you can’t, because these distinctions are considered to be things that the recipient of the document shouldn’t care about, and they were therefore left out of the XDM model.  Generally, the features of an XML document fall into one of three categories: deﬁnitely signiﬁcant, deﬁnitely insigniﬁcant, and debatable. For example, the order of elements is deﬁnitely signiﬁcant, the order of attributes within a start element tag is deﬁnitely insigniﬁcant, but the signiﬁcance of comments is debatable.  The XML standard itself doesn’t deﬁne these distinctions particularly clearly. It deﬁnes certain things that must be reported to the application, and these are certainly signiﬁcant. There are other things that are obviously signiﬁcant  such as the order of elements  about which it says nothing. Equally, there are some things that it clearly states are insigniﬁcant, such as the choice of CR-LF or LF for line endings, but many others about which it stays silent, such as choice of «"» versus «’» to delimit attribute values.  One result of this is that different standards in the XML family have each made their own decisions on these matters, and the XDM speciﬁcation is no exception.  The debate arises partly because there are two kinds of applications. Applications that want only to extract the information content of the document are usually interested only in the core information con- tent. Applications such as XML editing tools tend also to be interested in details of how the XML was written, because when the user makes no change to a section of the document, they want the correspond- ing output document to be as close to the original as possible.  One attempt to deﬁne the information content of an XML document is the W3C InfoSet speciﬁcation  http:  www.w3.org TR xml-infoset  . This takes a fairly liberal view, retaining things such as CDATA section boundaries and external entity references in the model, on the basis that some users might attach importance to these things.  Another attempt appears in the speciﬁcation of Canonical XML  http:  www.w3.org TR xml-c14n . This speciﬁcation approaches the question by deﬁning a transformation that can be applied to any XML document to turn it into canonical form, and if two documents have the same canonical form, they are considered equivalent.  The process of turning a document into canonical form is summarized as follows:  1. 2. 3. 4. 5.  The document is encoded in UTF-8. Line breaks are normalized to x0A. Attribute values are normalized, depending on the attribute type. Character references and parsed entity references are expanded. CDATA sections are replaced with their character content.  64   The XDM Tree Model  The XML declaration and document type declaration  DTD  are removed. Empty element tags     are converted to tag pairs     .  6. 7. 8. Whitespace outside the document element and within tags is normalized. 9. 10. 11. 12. 13.  Attribute value delimiters are set to double quotes. Special characters in attribute values and character content are replaced by character references. Redundant namespace declarations are removed. Default attribute values deﬁned in the DTD are added to each element. Attributes and namespace declarations are sorted into alphabetical order.  2  T h e  X S L T  i  P r o c e s s n g M o d e  l  Canonical form discards some of the original content that the InfoSet retains, for example CDATA sections. However, this speciﬁcation has a gray area too: canonical form may or may not retain comments from the original document.  XDM leans more towards the minimalist view of the Canonical XML speciﬁcation. Figure 2-8 illustrates the resulting classiﬁcation: the central core is information that is retained in canonical form  comments being on the boundary since the spec leaves the question open ; the ‘‘peripheral’’ ring is information that is present in the Infoset but not in canonical XML, while the outer ring represents features of an XML document that are also excluded from the InfoSet. XDM sticks essentially to the Core features  including comments , with a couple of minor additions: XSLT also recognizes unparsed entities, and also makes available the base URI  which is a rather peculiar property, since it can’t actually be determined from the content of the XML document, only from its location .  From Textual XML to a Data Model  I’ve explained the data model so far in this chapter by relating the constructs in XDM  such as element nodes and text nodes  to constructs in a textual XML document. This isn’t actually how the W3C specs deﬁne it. There are two important differences:           The W3C speciﬁcations don’t describe the model in terms of textual XML; they describe it in terms of the XML Infoset, as mentioned in the previous section, together with the PSVI  Post Schema Validation Infoset , which describes an augmented Infoset containing not only the infor- mation in the raw XML but also the additional information that becomes available as a result of schema validation. Although the W3C speciﬁcations describe a mapping from the Infoset and PSVI to XDM, this mapping is non-normative  which is standards-speak for saying that it’s not ofﬁcially part of the standard . Products aren’t required to provide any particular way of constructing the XDM tree from raw XML. This was also true in XSLT 1.0, and it is an issue that has caused some con- troversy, because it means there is no guarantee that two XSLT processors will give the same answer when applied to the same source document. The main reason for putting this mapping outside the conformance boundary of the speciﬁcation is to allow XPath and XSLT to be used in as wide a variety of contexts as possible, for example in environments where the data model is not constructed from textual XML at all, but is rather a view of non-XML information. Unfortunately, this also means that where the data model is con- structed in the conventional way by parsing textual XML ﬁles, different processors are allowed to do it in different ways.  65   The XSLT Processing Model  Excluded  Character encoding  Choice of  line terminator  Order of attributes  CDATA sections  Peripheral  XML version  Unparsed Entities  Choice of quotes for attributes  Character references  Notations  Core  Base URI  Elements     versus    Skipped entities  Processing Instructions  Text  Document  Comments  Namespaces  Attributes  Parsed Entities  Conditional  Sections in DTD  Order of  declarations  in DTD  Redundant namespaces  Document Type  Declaration  Unnormalized  attributes  Whitespace within tags  ELEMENT and  ATTLIST  declarations  Figure 2-8  Examples of the variations that have arisen in this area between different 1.0 processors are:        The standard way of building a data model using Microsoft’s MSXML processor, if all options are set to their default values, causes whitespace-only text nodes to be removed from the model. The standard mapping keeps these nodes present. Microsoft’s decision has some rationale: in many cases the extra whitespace nodes simply get in the way; they make the XPath user’s life more difﬁcult, and they take up space for no useful reason. Unfortunately, there are some cases where the whitespace is actually signiﬁcant, and more importantly, this decision means that it’s not uncommon for an XSLT stylesheet to produce a different result under MSXML than the result produced under every other processor. One XSLT vendor  Fourthought: see www.fourthought.com  decided that it would be a good idea to expand any XInclude directives in the source XML as part of the process of building the data model. There is nothing in the spec to say whether XInclude should be expanded or not, and it’s something that some users might want to happen and other users might not want to happen. So they were entirely within their rights to make this decision. But again, it creates a problem because different processors are no longer compatible.  XDM leaves additional scope for variations between processors. Because the model is designed to sup- port XQuery as well as XSLT, the range of possible usage scenarios is greatly increased. Many XQuery  66                              The Transformation Process  vendors aim to offer implementations capable of searching databases containing hundreds of gigabytes of data, and in such environments performance optimization becomes a paramount requirement. In fact, database products have traditionally treated performance as a more important quality than standards conformance, and there are indications that this culture is present among some of the XQuery vendors. Examples of the kind of variations that may be encountered include the following:  Dropping of whitespace text nodes  again! . Storing only the typed value of elements and attributes, and not the string value. Dropping comments and processing instructions. Dropping unused namespace declarations.  2  T h e  X S L T  i  P r o c e s s n g M o d e  l  It remains to be seen how most vendors will handle these problems. Hopefully, vendors will offer any optimizations as an option that the user can choose, rather than as the default way that source XML is processed when loading the data.  Controlling Serialization  The transformation processor, which generates the result tree, generally gives the user control only over the core information items and properties  including comments  in the output. The output processor or serializer gives a little bit of extra control over how the result tree is converted into a serial XML document. Speciﬁcally, it allows control over the following:  Generation of CDATA sections XML version Character encoding The standalone property in the XML declaration DOCTYPE declaration  Although you get some control over these features during serialization, one thing you can’t do is copy them from the source document unchanged through to the result. The fact that text was in a CDATA section in the input document has no bearing on whether it will be represented in as a CDATA section in the output document. The tree model does not provide any way for this extra information to be retained.  The Transformation Process  I’ve described the essential process performed by XSLT, transformation of a source tree to a result tree under the control of a stylesheet, and looked at the structure of these trees. Now it’s time to look at how the transformation process actually works, which means taking a look inside the stylesheet.  Invoking a Transformation  The actual interface for ﬁring off a transformation is outside the scope of the XSLT speciﬁcation, and it’s done differently by different products. There are also different styles of interface: possibilities include an API that can be invoked by applications, a GUI interface within a development environment, a com- mand line interface, an interface from a pipeline processor such as XProc or a build tool such as ant, as well as the use of an   processing instruction within a source document, which is described in Chapter 3  see page 99 . There’s a common API for Java processors that was initially called  67   The XSLT Processing Model  TrAX, then became part of JAXP, and since JDK 1.4 has been part of the standard Java class library. For browsers, Microsoft and Firefox each have their own API, but there is at least one project  Sarissa, see http:  sarissa.sourceforge.net   that provides a common API that can be used on both these browsers as well as Opera, Safari, and Konqueror.  What the XSLT 2.0 speciﬁcation does do is to describe in abstract terms what information can be passed across this interface when the transformation is started. This includes the following:                    The stylesheet itself : Many products provide separate API calls to compile a stylesheet and then to run it, which saves time if the same stylesheet is being used to transform many source documents. A source document: This can be identiﬁed by any node in the document, which acts as the ini- tial context node for the transformation. This will usually be the document node at the root of the tree, but it doesn’t have to be. In fact, you don’t have to supply an initial context node at all; the stylesheet can then fetch any data it needs from stylesheet parameters or from calls on the document   function. An initial named template: This acts as the entry point to the stylesheet and is needed when you don’t supply an initial context node, but it is also possible to supply both. If an initial named template is identiﬁed, the transformation starts with that template; otherwise, it starts by search- ing for a template rule that matches the initial context node, as described in the next section. An initial mode: Modes are described later in this chapter, on page 78. Normally, the transfor- mation starts in the default  unnamed  mode, but you can choose to start in a different mode if you prefer. When the template rules in a stylesheet use a named mode, it becomes easier to combine two stylesheets into a single multiphase transformation, as described on page 85, and this feature ensures that you can still use the rules for each processing phase independently. Parameters: A stylesheet can deﬁne global parameters using   elements, as discussed on page 425. Interfaces for invoking a transformation will generally provide some kind of mech- anism for setting values for these parameters.  A notable exception is that when you invoke a transformation using the   processing instruction in a source document, there is usually no way of setting parameters.  A base URI for output documents: Many stylesheets will produce a single result document, and this URI effectively deﬁnes where this result document will be written. If the stylesheet produces multiple result documents, then each one is created using an   instruc- tion with an href attribute, and the href attribute, if it is relative, is interpreted as a location relative to this base URI.  Template Rules  As we saw in Chapter 1, most stylesheets will contain a number of template rules. Each template rule is expressed in the stylesheet as an   element with a match attribute. The value of the match attribute is a pattern. The pattern determines which nodes in the source tree the template rule matches.  For example, the pattern « » matches the document node, the pattern «title» matches a   element, and the pattern «chapter title» matches a   element whose parent is a   element.  When you invoke an XSLT processor to apply a particular stylesheet to a particular source document, the ﬁrst thing it does is to read and parse these documents and create internal tree representations of them in memory. Once this preparation is complete, the transformation process can start.  68   The Transformation Process  The ﬁrst step in the transformation process is usually to ﬁnd a template rule that matches the document node of the source tree. If there are several possible candidates, there is a conﬂict resolution policy to choose the best ﬁt  see page 79 for details . If there is no template rule that matches the document node, a built-in template is used. The XSLT processor then evaluates the contents of this template rule.  XSLT 2.0 also allows you to start the transformation by supplying an initial node other than the docu- ment node. As discussed in the previous section, you can even start the transformation without supplying an initial node at all, by providing the name of the ﬁrst template to be evaluated.  Contents of a Template Rule  The content of an   element in the stylesheet is a sequence of elements and text nodes. Comments and processing instructions in the stylesheet are ignored, as are whitespace text nodes, unless they belong to an   element or to one with an appropriate xml:space attribute. This sequence of elements and text nodes is called a sequence constructor, because the result of evaluating it is itself a sequence.  Elements in the sequence constructor can be classiﬁed as either instructions or data, depending on their namespace. Text nodes are always classiﬁed as data. When the sequence constructor is evaluated, the instructions are evaluated, and the result of each instruction is added to the result sequence. The data nodes are copied to the result tree. Elements that are classiﬁed as data are ofﬁcially termed literal result elements.  2  T h e  X S L T  i  P r o c e s s n g M o d e  l  Consider the following template rule:      Started!   Generated from XSLT    ...    The end     The body of this template rule consists of two instructions    and   , a literal result element  the   element , and some text  «The end», preceded and followed by signif- icant whitespace . When this template is evaluated, the instructions are executed according to the rules for each individual instruction, and literal result elements and text nodes are copied  as element nodes and text nodes, respectively  to the result sequence.  It’s simplest to think of this as a sequential process, where evaluating a sequence constructor causes evaluation of each of its components in the order they appear. Actually, because XSLT is largely side- effect-free, they could be executed in a different order, or in parallel. The important thing is that after evaluating this sequence constructor, the result sequence will contain a comment node  produced by the   instruction , an   element node  produced by the   literal result element , and the text node «The end». The order of these items in the result sequence corresponds to the order of the instructions in the stylesheet, although in principle the XSLT processor is free to execute the instructions in any order it likes.    is an exception to the rule that XSLT is side-effect-free. Evaluating an <xsl: message> instruction doesn’t cause anything to be added to the result sequence; it merely causes the side effect of writing a message to some external device  perhaps standard output, or a log ﬁle . If there are  69   The XSLT Processing Model  several   instructions in a sequence constructor, then the order in which the messages appear is not guaranteed.  If I hadn’t included the «...» within the   element, this would be the end of the matter. But when a literal result element such as   is evaluated, its content is treated as a sequence constructor in its own right, and this is evaluated in the same way. It can again contain a mixture of instructions, literal result elements, and text. As we’ll see in the next section, the result sequence produced by this sequence constructor is used to create the nodes that are attributes and children of the new   element.  Sequence Constructors  Sequence constructors play such an important role in the XSLT 2.0 processing model that it’s worth studying them in some detail.  As we have seen, the content of an   element, after any parameter deﬁnitions contained in   elements, is a sequence constructor. In XSLT 1.0, a sequence of instructions was ofﬁcially called a template, though few people used the term correctly. The new name sequence constructor reﬂects a change in the way the processing model is described, and a change in its capability: a sequence of instructions can now be used to produce any sequence of items, not necessarily a sequence of sibling nodes in a tree.  Many other XSLT elements are also deﬁned to have a sequence constructor as their content. For example, the contents of an   or   element follow exactly the same rules as the content of an    ignoring   elements , and these too are sequence constructors. It follows that one sequence constructor may be contained within another. For example, consider the following template rule:         - o - 0 - o -           - o - 0 - o -         Viewed as a tree, using the notation introduced earlier in this chapter, this has the structure shown in Figure 2-9. There are three sequence constructors, indicated by the shaded areas. Within the sequence constructors on this tree, there are four kinds of nodes: text nodes, XSLT instructions  such as   , attributes  test="position  =last  ", not shown , and literal result elements  such as   , which are elements to be written to the result tree.  A sequence constructor is the nearest equivalent in XSLT to a block or compound statement in a block- structured programming language such as C or Java, and like blocks in C or Java, it deﬁnes the scope of any local variables declared within the block.  A sequence constructor is a sequence of sibling nodes in the stylesheet. Comment and processing instruction nodes are allowed, but the XSLT processor ignores them. The nodes of interest are text nodes and element nodes.  70   The Transformation Process  element  xsl:template  *  *  element  xsl:apply-templates  element  xsl:if  *  element  xsl:if *  2  T h e  X S L T  i  P r o c e s s n g M o d e  l  element  text  element  element  text  element  hr  hr  - o - O - o -  hr  hr  - o - O - o -  Figure 2-9  When a sequence constructor is evaluated, the result is, in general, a sequence of items. Many instructions such as  ,  , and   create new nodes; a couple of the new instructions introduced in XSLT 2.0 such as   and   can also return references to existing nodes in a source document. It is also possible for the sequence to contain atomic values: these can be produced using the   and   instructions.  Most likely, the sequence returned by a sequence constructor will be used to build the content of an element node in the result tree. In the example shown in Figure 2-9:        The sequence constructors contained in the   elements always  if they are evaluated at all  produce a sequence of three nodes: two empty   elements and a text node. The sequence constructor contained in the   instruction returns a sequence that is the concatenation of the nodes returned by the ﬁrst   instruction, then the nodes returned by the   instruction, and ﬁnally the nodes returned by the sec- ond   instruction. The result of the template is this sequence of nodes.  Suppose that the template rule in our example is invoked using a construct such as the following:           The   instruction results in the sequence of nodes produced by evaluating the selected template rule. In fact, this instruction can select several   elements, and the template rule is invoked once for each one. The resulting nodes are all concatenated into a single sequence. Because the   instruction is the only instruction in the sequence constructor contained by the   element, the ﬁnal sequence delivered to the   element contains the results of expanding the template rule for each of the selected   elements in the source document.  The   element is a literal result element, which when evaluated constructs a new element node. The name of this node will be  , and the content will be formed from the sequence produced by evaluating the sequence constructor contained within the literal result element in the stylesheet. In our example, this sequence contains elements and text nodes, and these are copied to form the content of the new   element.  71               The XSLT Processing Model  This is by far the most common scenario: instructions are evaluated to produce a sequence of nodes, and the nodes are copied to form the contents of a result tree. However, in XSLT 2.0 it is also possible to process the sequence in other ways. In particular:  A generated sequence can be captured in a variable. For example, the following variable will have a value that is a sequence of element nodes. These elements are not attached to a tree; they have no parent, and they are not siblings of each other:      January   February   March      You can then refer to the third element in this sequence as «$months[3]». But don’t try doing «$months month»; the $months variable holds a sequence of   elements, and the path expression «$months month»  which is short for «$months child::month»  tries to ﬁnd children of these elements that are named  . It won’t ﬁnd any.  This kind of variable is constructed when the «as» attribute is present to deﬁne the required type of the items in the sequence. If the «as» attribute were omitted, the   elements would be added to a temporary document, and the variable $months would refer to the document node of this tree. For more information, see the section ‘‘Temporary Documents’’ on page 85.     A generated sequence can also be returned by a function. Rather than deﬁning the sequence of month elements in a variable, it could equally well be deﬁned in a function.      January   February   March      You could then refer to the third month as «m:months  [3]». Note that user-deﬁned functions must always be in a namespace, to avoid conﬂicts with system-deﬁned functions. There is a subtle difference between using a variable and a function to capture the sequence: the variable will return the same elements every time, whereas the function will create new elements every time you call it. For example, this means that the expression «$months[3] is $months[3]» will be true, while «m:months  [3] is m:months  [3]» will be false.  The «is» operator in XPath 2.0 tests whether the values of the two operands are references to the same node.  In prac- tice, you would want to use a function only if you were supplying parameters, because the data that came back depended on the parameters in some way.  Text nodes appearing within a sequence constructor are copied to the result sequence when the sequence constructor is evaluated. However, text nodes that consist entirely of whitespace will be ignored, unless the xml:space attribute is used on an enclosing element to deﬁne them as signiﬁcant.  Text nodes containing whitespace only are also signiﬁcant if they appear as the content of an   element, but in that case they are not part of a sequence constructor.  For more information on the treatment of whitespace see Chapter 3, page 141.  72   Nested Sequence Constructors  Suppose the template rule actually looks like this:      Started!   Generated from XSLT      My first generated HTML page                The end        The Transformation Process  2  T h e  X S L T  i  P r o c e s s n g M o d e  l  Here the   element contains two child elements,   and  . These are both literal result elements, so they are evaluated by copying them from the stylesheet to the result sequence.  Evaluating the   element in turn causes the sequence constructor within the   element to be evaluated. This sequence constructor contains a single literal result element, the   element, which in turn contains a sequence constructor containing a single text node, whose value is the string «My first generated HTML page».  What happens here  as far as the formal deﬁnition of the processing model is concerned  is a bottom-up process of tree construction. The sequence constructor containing the text node is evaluated to produce a result sequence containing a copy of the text node. The   element is then evaluated to produce a new   element node, which has this text node as its only child.  When the   element is evaluated, things get more interesting because it contains an XSLT instruc- tion, namely  . This particular instruction has critical importance: when written as here, without any attributes, it means ‘‘select all the children of the current node in the source tree, and for each one, ﬁnd the matching template rule in the stylesheet, and evaluate it.’’  What actually happens at this point depends both on what is found in the source document, and on what other template rules are present in the stylesheet. Typically, because we are currently processing the root node of the source document tree, it will have just one child node, namely the document element  the outermost element of the source XML document . Suppose this is a   element. Then the XSLT processor will search the stylesheet looking for a template rule that matches the   element.  The simplest situation is where it ﬁnds just one rule that matches this element, for example one declared as:     If it ﬁnds more than one matching template rule, it has to use its conﬂict resolution policy to choose the best ﬁt. The other possibility is that there is no matching template rule: in this case it invokes the built-in template rule for element nodes, which simply executes  : in other words, it selects the children of this element, and tries to ﬁnd template rules that match these children. There’s also a built-in template rule for text nodes, which copies the text node to the output. If the element has no children,   does nothing.  73   The XSLT Processing Model  Whatever happens, however, the result of evaluating the   instruction is a sequence, usually a sequence of nodes. These nodes are added to the result of the sequence construc- tor contained by the   instruction, and are used to form the children  and potentially also the attributes  of the new   element. The new   and   elements now form a sequence that’s used to make the children of the   element; and because this template rule was the ﬁrst one to be activated, the transformation is now complete and the tree with this   element at the top becomes the ﬁnal result tree of the transformation.  The   element is automatically wrapped in a document node, to complete the process.  Hopefully, you never actually need to analyze what’s going on to this level of detail. The name template was chosen because you can think of the whole process as producing a simple ﬁll-in-the-blanks copy of the elements in the stylesheet as elements in the result tree. In the case of literal result elements and literal text, they are copied across unchanged; in the case of XSLT instructions, some processing is performed to fetch data from a source document for insertion at this point in the result tree.  Push Processing  The simplest way to process a source tree is thus to write a template rule for each kind of node that can be encountered, and for that template rule to produce any output required, as well as to call   to process the children of that node.  Example: Push Processing  This example demonstrates the push processing technique: a rule-based stylesheet in which there is one template rule to process each different kind of node.  Input  The source document, books.xml, is a simple book catalog:           Nigel Rees   Sayings of the Century   8.95         Evelyn Waugh   Sword of Honour   12.99         Herman Melville   Moby Dick   8.99         J. R. R. Tolkien   The Lord of the Rings   22.99         74   The Transformation Process  Stylesheet  Say you want to display this data in the form of a sequentially numbered booklist. The following stylesheet, books.xsl, will do the trick:  <xsl:stylesheet version="2.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform">          A list of books                                                   What’s happening here? There’s no template rule for the document node, so the built-in template gets invoked. This processes all the children of the document node. There’s only one child of the document node, the   element. So the template rule for the   element is evaluated. This creates some standard HTML elements on the result tree, and eventually calls   to cause its own children to be processed. These children are all   elements, so they are all processed by the tem- plate rule whose match pattern is «match="book"». This template rule outputs an HTML   element, and within it a   element, which it ﬁlls by executing the   instruction whose effect is to get the sequence number of the current node  the   element  within its parent element. It then calls   once again to process the children of the   element in the source tree. The children of the   element in the source document are all  ,  , or   elements; so as it happens they all match the template rule whose match pattern is «match="author  title  price"»  you can read «» as ‘‘or’’ . This template rule outputs an HTML   element that it ﬁlls by executing an instruction <xsl:value-of select="." >. This instruction evaluates an XPath expression, and writes its result  a string  as text to the result tree. The expression is «.», which returns the string value of the current node, that is the textual content of the current  ,  , or   element. This template makes no further call on  , so its own children are not processed, and control returns all the way up.  2  T h e  X S L T  i  P r o c e s s n g M o d e  l  75   The XSLT Processing Model  Output        A list of books         1   Nigel Rees   Sayings of the Century   8.95         2   Evelyn Waugh   Sword of Honour   12.99      etc..           This style of processing is called push processing. It is driven by the   instruction, as if the processor is pushing the nodes out of the door, saying ‘‘is anyone interested in dealing with this one?’’  In this description I occasionally talk of instructions writing to the result tree. This is how the process was described in XSLT 1.0, and it accounts for the name push. It’s a convenient way to think about what’s going on. Technically, as we have seen, instructions don’t write to the result tree; they are evalu- ated to produce a sequence  usually a sequence of nodes, but occasionally atomic values  and this sequence is then used by the calling instruction, often to construct the children of a new element. The importance of this model is that in XSLT 2.0, there are some situations in which the result of a sequence constructor is not used directly to build part of a result tree, but can be used in some other way, for example as the result of an XPath function call.  In such situations it is possible for an XPath expression to encounter nodes such as attributes and text nodes that have no parent, because they have not yet been attached to a result tree.  Controlling Which Nodes to Process  Simple push processing works very well when the data in the output is to have the same structure and sequence as the data in the input, and all we want to do is add or remove a few tags or perform other simple editing of values as we go along.  In the previous example, it wouldn’t work so well if the properties of each book were less predictable, for example if some of the books had no price, or if the title and author could appear in either order. In this case the HTML table that we generated wouldn’t be nicely arranged in columns any more, because generating a new cell for each property we encounter is not necessarily the right thing to do.  76   The Transformation Process  In such circumstances, there are two choices:        Be more precise about which nodes to process, rather than just saying process all children of the current node. Be more precise about how to process them, rather than just saying choose the best-ﬁt template rule.  Let’s try the ﬁrst option.  Example: Controlling the Sequence of Processing  We can gain greater control over which nodes are to be processed by changing the   template in books.xsl, as follows:  2  T h e  X S L T  i  P r o c e s s n g M o d e  l                     Instead of selecting all child elements and ﬁnding the appropriate template rule for each one, this now explicitly selects ﬁrst the   child element, then the   child element, and then the   child element. This will still work, and it’s more robust than our previous attempt, but it will still produce a ragged table if there are any   elements without an    say , or with more than one.  The comma operator used in the expression «select="author, title, price"» is new in XPath 2.0. It simply concatenates several sequences  which might be single items, but could also be empty, or contain multiple items  into a single sequence, in the order speciﬁed.  As we want a regular structure in the output and because we know a lot about the structure of the source document, we’d probably be better off in this situation deﬁning all the process- ing in the   template rather than relying on template rules to match each of its child elements.  Example: Selecting Nodes Explicitly  We can gain greater control over how nodes are to be processed by writing the   template rule in the following manner.                               77   The XSLT Processing Model  Some people call this pull processing, because instead of the template pushing nodes out of the door to be picked up by another template, it is pulling the nodes in and handling them itself.  The pattern-matching  or push  style of processing is the most characteristic feature of XSLT, and it works very well in applications where it makes sense to describe the handling of each type of node in the source document independently. However, there are many other techniques available, all of which are equally valuable. From within a template rule that is processing one particular node, the main alternatives if you want access to information in other nodes are as follows:                 Call   to process those nodes using their appropriate template rules. Call   in a particular mode  see later  to process those nodes using the template rules for the relevant mode. Call   to extract the required information from the nodes directly. Call   to perform explicit processing of each of the nodes in turn. Call   to invoke a speciﬁc template by name, rather than relying on pat- tern matching to decide which template to invoke.  Further discussion of the different approaches to writing a stylesheet is included in Chapter 17, Stylesheet Design Patterns.  Modes  Sometimes you want to process the same node in the source tree more than once, in different ways. The classic example is to produce a table of contents. When generating the table of contents, you want to handle all the section headings in one way, and when producing the body of the document, you want to handle them in a different way.  One way around this problem is to use push processing on one of these passes through the data, and pull processing on all the other occasions. However, this could be very constraining. Instead, you can deﬁne different modes of processing, one for each pass through the data. You can name the mode of processing when you call  , and the only template rules that will be considered are those that specify the same mode. For example, if you specify:     Then the selected template rule might be one deﬁned as:    ...    Further details of how to use modes are in Chapter 6, page 242 and a real-life case study showing how to use them to generate a table of contents is in Chapter 18, page 1019.  What happens when   is invoked to process a node, and there is no template rule in the stylesheet that matches that node?  Built-In Template Rules  A built-in template rule is invoked.  78   The Transformation Process  There is a built-in template rule for each kind of node. The built-in rules work as follows.  Built-In Template Rule Call   to process the children of the document node, in the same mode as the calling mode.  Call   to process the children of this element, in the same mode as the calling mode.  Attribute  Copy the attribute value to the result tree, as text — not as an attribute node.  2  T h e  X S L T  i  P r o c e s s n g M o d e  l  Node Kind Document  Element  Text  Comment  Processing instruction  Copy the text to the result tree.  Do nothing.  Do nothing.  Namespace  Do nothing.  The built-in template rules will only be invoked if there is no rule that matches the node anywhere in the stylesheet.  There is no way to override the built-in template for namespace nodes, because there is no pattern that will match a namespace node. If you call   to process namespace nodes, nothing happens. If you want to process all the namespace nodes for an element, use:     Conﬂict Resolution Policy  Conversely, what happens when there is more than one template rule whose pattern matches a particular node? As I mentioned earlier, the conﬂict resolution policy comes into play.  This works as follows:           First the import precedence of each rule is considered. As Chapter 3 will show, one stylesheet may import another, using the   declaration, and this part of the policy basically says that when stylesheet A imports stylesheet B, the rules in A take precedence over the rules in B. Then the priority of each rule is examined. The priority is a numeric value, and the higher the number, the higher the priority. You can either specify the priority explicitly in the priority attribute of the   element or leave the system to allocate a default priority. In this case, the system allocates a priority that is designed to reﬂect whether the pattern is very general or very speciﬁc: for example the pattern «subsection title»  which matches any   element whose parent is a   element  gets higher priority than the pattern «*», which matches any element. System-allocated priorities are always in the range –0.5 to +0.5: user-allocated priorities will normally be 1 or more, but there are no restrictions. For more details see the description of the   element in Chapter 6, page 483. Finally, if there is more than one rule with the same import precedence and priority, the XSLT processor has a choice: it can either report an error, or choose whichever rule appears last in the stylesheet  some processors do both: they give you a warning, and then carry on processing .  79   The XSLT Processing Model  Error Handling  Different processors will behave differently in this situation, which gives you a slight portabil- ity problem to watch out for: it is best to ensure this ambiguity never happens, which you can achieve by setting explicit priorities on your template rules.  There are two kinds of error that can occur during an XSLT transformation: static errors and dynamic errors. Static errors occur while the stylesheet is being compiled, and dynamic errors occur while the transformation is actually running. If you invoke the transformation using a single-shot interface that doesn’t distinguish compilation from execution then you may not notice the difference, but it is there all the same.  XSLT 1.0 was designed to minimize the number of things that could cause runtime errors. This was done largely by deﬁning fallback behavior. For example, if you supplied the string ‘‘Africa’’ as input to an arithmetic operator, you would get the result NaN  not-a-number . This might not be a very useful result, but the thinking was that it was better than producing a pop-up on the browser saying ‘‘Error in stylesheet.’’ For many runtime errors, implementors were in fact given a choice of reporting an error, or taking some deﬁned fallback action.  The thinking in XSLT 2.0 has shifted signiﬁcantly. There are now many more conditions that cause run- time errors, and most of these are not recoverable. There is also no try catch mechanism to trap the errors when they occur: if a runtime error does occur in a stylesheet, it is fatal. In practice this means that you have to design your stylesheet to prevent them from occurring. This means that you have to test whether the input data is valid before using it in an operation that could cause errors if it isn’t. For example, before trying to convert a string to an integer using the xs:integer   constructor function, it is a good idea to test whether the conversion is possible using a construct such as «if  $x castable as xs:integer  then . . .».  Although the language speciﬁcation is very precise about what constitutes an error and what doesn’t, there may well be variations between processors as to whether runtime errors are actually reported in particular circumstances. This is partly because for some errors the choice of reporting the error or taking fallback action is still there, as in XSLT 1.0, and it is also because the order of execution of instructions  or of subexpressions within an XPath expression  is not precisely deﬁned. Suppose you write an expres- sion such as «exists   employee[@retirement-date=current-date  ] »  which ﬁnds out whether any employees are retiring today . One XSLT processor might ﬁnd such an employee, and return true. Another might ﬁnd an employee whose retirement-date attribute is not a date  perhaps it is the string "unknown"  and report a runtime error. Processors are never required to do extra work just to look for runtime errors. In this example, the processor is allowed to stop searching the employees as soon as it ﬁnds one that satisﬁes the required conditions.  What if there are no employees retiring today, and there are some employees whose retirement dates are not valid dates? Does the processor have to raise a runtime error, or can it return false? A straightfor- ward reading of the speciﬁcation suggests that it has to report an error in this case. However, the rules that allow the processor to devise an optimal execution strategy are drawn up so broadly that I think an implementor could argue that returning false was conformant.  Variables and Expressions  The system of data types lies at the core of any language, and the way expressions are used to compute values and assign these to variables is closely tied up with the type system. The XSLT type system inter- acts closely with XML Schema. We’ll look in more detail in Chapter 4 at how stylesheets and schemas  80   Variables and Expressions  interact, and we’ll survey the detailed repertoire of built-in types in Chapter 5. In this section, however, we’ll assume some basic principles about types, and look at the way they are used in variables and expressions. Variables  XSLT allows global variables to be deﬁned, which are available throughout the whole stylesheet, as well as local variables, which are available only within a particular sequence constructor. The name and value of a variable are deﬁned in an   element. For example:  2  T h e  X S L T  i  P r o c e s s n g M o d e  l     This deﬁnes a variable whose name is width and whose value is the number 50. The variable can subse- quently be referenced in an XPath expression as $width. If the   element appears at the top level of the stylesheet  as a child of the   element , then it declares a global vari- able; if it appears within the body of an   or   element, then it deﬁnes a local variable.  The use of variables is superﬁcially very similar to their use in conventional programming and scripting languages. They even have similar scoping rules. However, there is one key difference: once a value has been given to a variable, it cannot be changed. This difference has a profound impact on the way programs are written, so it is discussed in detail in the section Programming without Assignment Statements in Chapter 17, page 985.  The «as» attribute is optional, and deﬁnes the data type of the variable as being an integer. In this example, this doesn’t add much: you can tell that it’s an integer by looking at the value, and so can the XSLT processor. But there are cases where it’s useful to specify the type. The select attribute doesn’t have to be a constant, as it is in the previous example — it might, for example, be a call on a function. The «as» attribute acts both as an assertion about the type of the value  if the value is of the wrong type, you’ll see an error message, either at compile time or at runtime  and also as a request to perform certain limited conversions from the supplied value to the speciﬁed type.  The type conversions that are possible in XSLT can be categorized as strong conversions and weak conversions. In a context like this, only weak conversions are applied. The weak conversions include the following:                 Treating a value of type T as a value of a supertype of T, for example an xs:integer as an xs:decimal, or an xs:ID as an xs:string. Extracting the typed value of a node, in cases where the supplied value is a reference to a node and the required type is atomic. This process is called atomization. The typed value of a node has the type determined by schema validation, for example if the node has been validated as an integer, you can use its value where an integer is expected, but not where  say  an xs:anyURI is expected. If there is no schema, then the typed value is the same as the string value. Numeric promotion of an xs:integer or xs:decimal to an xs:float or xs:double, and of an xs:float to an xs:double. In XML Schema, xs:float is not deﬁned as a subtype of xs:double, but XPath and XSLT behave largely as if it were. Promotion of xs:anyURI values to xs:string. Again, XPath and XSLT behave largely as if xs:anyURI were a subtype of xs:string, even though XML Schema doesn’t deﬁne it that way. Conversion of untyped atomic values  which usually arise as the values of nodes in documents, or parts of documents, that have not been schema-validated  to the required type. This conver- sion uses the rules deﬁned in XML Schema: for example, if the required type is xs:date, then the 81   The XSLT Processing Model  supplied value must have the correct lexical form for an xs:date, as deﬁned in the XML Schema speciﬁcations  that is, YYYY-MM-DD with an optional timezone .  These weak conversions are applied to the values of variables and parameters, and they are also used when converting the arguments supplied in a function call to the types declared in the function signature.  Strong conversions can be achieved by use of constructor functions; for example, you can convert a string to an integer with the function «xs:integer $s ». Generally in XSLT 2.0, strong conversions are not applied automatically; you have to ask for them. Strong conversion is also referred to as casting, and the rules for casting are given in Chapter 11.  In the case of function calls, strong conversions are sometimes applied implicitly if you run the stylesheet in backward-compatible mode. This is described in Chapter 3 on page 128. You can select backward- compatible mode by specifying «version="1.0"» on the   element. However, even in backward-compatible mode strong conversions are not applied to variables and parameters in the stylesheet. This is because in XSLT 1.0 it was not possible to declare the type of a variable or parameter, so there is no requirement here for backward compatibility.  Parameters  Parameters in XSLT are very similar to variables. They are declared with an   element instead of  , and they differ in that the value can be supplied externally. There are three places you can use parameters in a stylesheet:           Stylesheet parameters  also known as global parameters  are supplied when the transformation is invoked, and they can be referenced from anywhere in the stylesheet. They are set from outside the stylesheet  for example, from the command line or from an API — the actual mechanism is implementation deﬁned . Template parameters are deﬁned within an   element, and are available only during the evaluation of that template. They are set by means of   elements within the instruction  for example   or    that invokes the template. These parameters can take different values each time the template is invoked. Function parameters are deﬁned within an   element, and are available only dur- ing the evaluation of that function. Functions are very similar to named templates, except that they are invoked not by means of XSLT instructions but by evaluating a function call within an XPath expression. The parameters to a function are supplied as part of this function call.  As with variables, the expected type of a parameter can be declared using an «as» attribute. Here it’s especially useful to declare the expected type, because you can then fail cleanly if the caller supplies the wrong type of value, rather than crashing or producing wrong answers. It’s also very valuable to the XSLT compiler to know in advance what type of value will be supplied, because it means that it can generate tighter code that doesn’t have to deal with as many runtime possibilities. You don’t have to declare the types of parameters, and if you don’t, then any type of value will be accepted — but I would recommend as good programming practice always to declare the types. I certainly ﬁnd that it catches many of my sillier programming mistakes.  Expressions  82  The syntax of expressions is deﬁned in the XPath 2.0 Recommendation, and is described in detail in Chapters 7 through 11.   Variables and Expressions  XPath expressions are used in a number of contexts in an XSLT stylesheet. They are used as attribute values for many XSLT elements, for example:     In this example $x and $y are references to variables, and the operators «+» and «*» have their usual meanings of addition and multiplication.  Many XPath expressions, like this one, follow a syntax that is similar to other programming languages. The one that stands out, however, and the one that gave XPath its name, is the path expression.  A path expression deﬁnes a navigation path through the document tree. Starting at a deﬁned origin, usually either the current node or the document node, it follows a sequence of steps in deﬁned direc- tions. At each stage the path can branch, so for example you can ﬁnd all the attributes of all the chil- dren of the origin node. The result is always a sequence of nodes in a ﬁxed order  known as docu- ment order  with no duplicates. It might be empty or contain only one node, but it is still treated as a sequence.  The directions of navigation through the tree are called axes. The various axes are deﬁned in detail in Chapter 9. They include the following:  2  T h e  X S L T  i  P r o c e s s n g M o d e  l                                The child axis, which ﬁnds all the children of a node. The attribute axis, which ﬁnds all the attributes of a node. The ancestor axis, which ﬁnds all the ancestors of a node. The following-sibling axis, which ﬁnds the nodes that come after this one and share the same parent. The preceding-sibling axis, which ﬁnds the nodes that come before this one and share the same parent.  As well as specifying the direction of navigation through the tree, each step in a path expression can also qualify which nodes are to be selected. This can be done in several different ways:  By specifying the name of the nodes  completely or partially . By specifying the kind of nodes  for example, elements or processing instructions . By specifying the schema-deﬁned type of the nodes  for example, elements of type person, or attributes of type xs:date . By deﬁning a predicate that the nodes must satisfy — an arbitrary boolean expression. By deﬁning the relative position of the node along the axis: for example, it is possible to select only the immediately preceding sibling.  The syntax of a path expression uses « » as an operator to separate the successive steps. A « » at the start of a path expression indicates that the origin is the document node; otherwise, it is generally the context node  we’ll be looking at the notion of context in the next section . Within each step, the axis is written ﬁrst, separated from the other conditions by the separator «::». However, the child axis is the default, so it may be omitted; and the attribute axis may be abbreviated to «@».  For example:  child::item attribute::category  83   The XSLT Processing Model  is a path expression of two steps; the ﬁrst selects all the child   elements of the current node, and the second selects their category attributes. This can be abbreviated to:  Predicates that the nodes must satisfy are written in square brackets, for example:  item @category  item[@code=‘T’] @category  This selects the category attributes of those child   elements that have a code attribute whose value is «T».  There are many ways of abbreviating path expressions to make them easier to write, but the basic structure remains the same. The full detail appears in Chapter 9.  Context  The way in which XPath expressions are evaluated is to some extent context dependent. For example, the value of the expression $x depends on the current value of the variable x, and the value of the expression «.» depends on which node is currently being processed in the source document.  There are two aspects to the context: the static context, which depends only on where the expression appears in the stylesheet; and the dynamic context, which depends on the state of processing at the time the expression is evaluated.  The static context for an expression includes the following:              The set of namespace declarations in force at the point where the expression is written. This determines the validity and meaning of any namespace preﬁxes used in the expression. As well as deﬁning the namespace preﬁxes that are available, the context also deﬁnes the default namespace that will be used for unqualiﬁed element names appearing in path expressions. The set of variable declarations  that is,   and   elements  in scope at the point where the expression is written. This determines the validity of any variable ref- erences used in the expression. As well as checking at compile time that the variable has been declared, the processor can also make checks on its type; for example, it would be an error to use a variable of type xs:date as an argument to the round   function, and the processor can often detect such errors and report them at compile time. The functions that are available to be called. These always include the core library of functions deﬁned in the XSLT and XPath speciﬁcations, and the constructor functions for built-in atomic types such as xs:date. They also include user-deﬁned functions written using the   declaration, constructor functions for user-deﬁned types in an imported schema  as described in Chapter 4 , vendor-deﬁned extension functions, and user-deﬁned extension functions linked in to the stylesheet using vendor-deﬁned mechanisms. The base URI of the stylesheet element containing the XPath expression. This only affects the result if the expression uses functions such as document   that make explicit use of the base URI.  All of these aspects of the static context for XPath expressions can be controlled from within the stylesheet, and may be different for different XPath expressions. There are other aspects of the XPath context that cannot be controlled using XSLT itself, but where implementors are likely to allow you some control via the API of their individual products. The most important example in this category is the set of URIs that are available for identifying collations  that is, rules for sorting and comparing strings according to the conventions of different languages .  84   2  T h e  X S L T  i  P r o c e s s n g M o d e  l  Variables and Expressions  The dynamic context is set only at stylesheet execution time. It consists of the following:        The current values of all the variables that are in scope for the expression. These may be different each time the expression is evaluated. The focus, which reﬂects the current state of processing in the stylesheet. The focus comprises the following:    The context item. This is the item  often a node in the source tree  that is currently being pro- cessed. An item becomes the context item when it is selected using the <xsl:apply- templates> or   instructions. The context item can also be set by the XPath processor when evaluating a subexpression. The context item can be referenced using the expression «.». In addition, the current   function  deﬁned in Chapter 13  can always be used to reference the item that’s the context item at the XSLT level, ignoring any changes made at the XPath level. The context position. This is an integer  ≥1  that indicates the position of the context item in the sequence of items currently being processed. The context position can be referenced using the position   function. When   or   are used to process a sequence of items, the context position takes the values 1 . . . n as each of the items in the list is processed. Similarly, when a predicate is used within a path expres- sion, the context position is the position of the node being tested within the set of nodes being tested. For example, «child::a[position   !=1]» selects all the child elements named  , except the ﬁrst. The context size. This is an integer  ≥1  that indicates the number of items in the sequence of items currently being processed  that is, the highest value that position   will reach . The context size can be referenced using the last   function. For example, «child::a [position   !=last  ]» selects all the child elements named  , except the last.           The set of documents that can be accessed using the doc   and document   functions is also regarded as being part of the dynamic context. This might include the whole of the Web, or it might be restricted by security policies to the server from which the stylesheet was loaded, or  if, say, the transformation is running on an embedded processor controlling the engine of your car  it might contain no documents at all. Modeling the set of addressable documents as part of the context is a formal device for describing the language semantics  it’s a way of saying that the result of the document   function is deﬁned by the environment in which the stylesheet runs, not by the language speciﬁcation itself , and it turns out to be quite a neat device for distinguishing those aspects of these functions that are deﬁned by the language spec from those that depend on the implementation.  Some system functions that can be used in XPath 2.0 expressions have other dependencies on the stylesheet context; for example, the effect of the key   function depends on the set of   decla- rations in force; but the list given earlier covers all the context information that is directly accessible to user-written expressions.  Temporary Documents  As we described at the beginning of the chapter, a transformation takes a source tree as input  or perhaps more than one source tree  and produces a result tree  or several result trees  as output.  Very often, however, the easiest way to write a complex transformation is to split it into a number of phases, each of which performs one task. Like pipes in Unix, this creates a powerful way of reusing modules of code — on the basis that each module does only one job. For example, if your stylesheet involves selecting input records, sorting them, grouping them, numbering them, and then formatting  85   The XSLT Processing Model  the result as HTML, you could potentially carry out each of these ﬁve steps in a separate transformation phase. One beneﬁt is that if you wanted to change the output from HTML to PDF, the ﬁrst four steps would be completely reusable.  One way of doing this is to write ﬁve separate stylesheets, and couple them together into a processing pipeline. This can be done using the Java JAXP API, described in Appendix D, or by using the new XProc pipeline language being developed by W3C. You can even do it  less efﬁciently  with a shell script or using ant. But often, you want rather closer coupling than this. So the alternative is to write all the phases of the transformation in a single stylesheet, using temporary documents to represent the intermediate results between one phase of processing and the next.  A temporary document is created by using an   element with no «as» attribute, contain- ing a sequence constructor to create the content of the tree. For example:         Michael   Kay   British         In this example, the value of the variable is a document node, which contains the   element as its only child node.  One popular way to use a temporary document is as a lookup table. The following stylesheet fragment uses data held in a temporary document to get the name of the month, given its number held in a variable $mm.      January  February  March   April  May  June   July  August  September   October  November  December     ...     Of course, the sequence constructor does not have to contain constant values as in these two examples; it can also contain instructions such as   and   to build the content of the temporary document dynamically. This is shown in the following example:   att-value   BBB      AAA          CCC      86   This creates the tree illustrated in Figure 2-10. Each box shows a node; the three layers are respectively the node kind, the node name, and the string value of the node. Once again, an asterisk indicates that the string value is the concatenation of the string values of the child nodes.  Variables and Expressions  document  *  text  AAA  element  x *  element  y *  text  CCC  attribute  att  att-value  text  BBB  Figure 2-10  In XSLT 1.0, temporary documents went under the name of result tree fragments. I introduced the term temporary tree in an earlier edition of this book, because I felt that the phrase result tree fragment underval- ued the range of purposes to which these structures can be applied. In fact, result tree fragments in XSLT 1.0 were very limited in their capability because of a quite artiﬁcial restriction that prevented them being accessed using path expressions. Most vendors ended up circumventing this restriction using an exten- sion function generally named xx:node-set  , where xx refers to the vendor’s particular namespace. In XSLT 2.0, the restriction is gone for good, and temporary documents can now be used in exactly the same way as any source document: they can be used as the result tree for one phase of transformation, and the source tree for the next.  The restrictions in XSLT 1.0 were deﬁned by making result tree fragments a separate data type, with a restricted range of operations available. In XSLT 2.0, a temporary document is a tree rooted at a document node just like any other, and is manipulated using variables or expressions that refer to its root node.  In XSLT 2.0 you can also have trees rooted at elements, or even at attributes or text nodes — though in that case there will only be one node in the tree. In fact, you might sometimes prefer to use a sequence of parentless elements rather than a document. But because of the XSLT 1.0 legacy, a temporary document is what you get when you declare an   element with no «as» attribute.   A temporary document does not necessarily correspond to a well-formed XML document, for example the document node can own text nodes directly, and it can have more than one element node among its children. However, it must conform to the same rules as an XML external parsed entity; for example, all the attributes belonging to an element node must have distinct names.  The ability to use temporary documents as intermediate results in a multiphase transformation greatly increases the options available to the stylesheet designer  which is why the xx:node-set   exten- sion function was so popular in XSLT 1.0 . The general structure of such a stylesheet follows the pattern:  2  T h e  X S L T  i  P r o c e s s n g M o d e  l  87   The XSLT Processing Model                             Some people prefer to use local variables for the intermediate results, some use global variables; it makes little difference.  One way that I often use multiphase transformations is to write a preprocessor for some specialized data source, to convert it into the format expected by an existing stylesheet module that renders it into HTML. For example, to create a glossary as an appendix in a document, you may want to write some code that searches the document for terms and their deﬁnitions. Rather than generating HTML directly from this code, you can generate the XML vocabulary used in the rest of the document, and then reuse the existing stylesheet code to render this as phase two of your transformation. This coding style is sometimes referred to as a micro-pipeline.  Because multiphase transformations are often used to keep stylesheets modular, some discipline is required to keep the template rules for each phase separate. I generally do this in two ways:  Keep the rules for each phase of transformation in a separate stylesheet module. Stylesheet modules are discussed in Chapter 3. Use a different mode for each phase of the transformation. Modes were described earlier in this chapter, on page 78.  Summar y  In this chapter we explored the important concepts needed to understand what an XSLT processor does, including the following:  The overall system architecture, in which a stylesheet controls the transformation of a source tree into a result tree. The tree model used in XSLT, the way it relates to the XML standards, and some of the ways it differs from the DOM model. How template rules are used to deﬁne the action to be taken by the XSLT processor when it encounters particular kinds of node in the tree. The way in which expressions, data types, and variables are used in the XSLT language to calcu- late values.  The next chapter looks at the structure of an XSLT stylesheet in more detail.                    88   3  S t y l e s h e e t S t r u c t u r e  Stylesheet Structure  This chapter describes the overall structure of a stylesheet. In the previous chapter we looked at the processing model for XSLT and the data model for its source and result trees. In this chapter we will look in more detail at the different kinds of construct found in a stylesheet such as declarations and instructions, literal result elements, and attribute value templates.  Some of the concepts explained in this chapter are tricky; they are areas that often cause confusion, which is why I have tried to explain them in some detail. However, it’s not necessary to master everything in this chapter before you can write your ﬁrst stylesheet — so use it as a reference, coming back to topics as and when you need to understand them more deeply.  The topics covered in this chapter are as follows:                    Stylesheet modules. We will discuss how a stylesheet program can be made up of one or more stylesheet modules, linked together with   and   elements. The    or   element . This is the outermost element of most stylesheet modules, and it deﬁnes various attributes that control how other constructs in the module behave. The   processing instruction. This links a source document to its associated stylesheet, and allows stylesheets to be embedded directly in the source document whose style they deﬁne. A brief description of the declarations found in the stylesheet, that is, the immediate children of the   or   element. The full speciﬁcations are in Chapter 6. A brief description of each instruction that can be used in a stylesheet. In the previous chapter, I introduced the idea of a sequence constructor as a sequence of instructions that can be evaluated to produce a sequence of items, which will usually be nodes to be written to the result tree. This section provides a list of the instructions that can be used, with a quick summary of the function of each one. Full speciﬁcations of each instruction can be found in Chapter 6. Simpliﬁed stylesheets, in which the   and   elements are omitted, to make an XSLT stylesheet look more like the simple template languages that some users may be familiar with.   Stylesheet Structure  Attribute value templates. These deﬁne variable attributes not only of literal result elements but of certain XSLT elements as well. Facilities allowing the speciﬁcation to be extended, both by vendors and by W3 C itself, without adversely affecting the portability of stylesheets. Handling of whitespace in the source document, in the stylesheet itself, and in the result tree.  Changes in XSLT 2.0  The important concepts in this chapter are largely unchanged from XSLT 1.0. The most signiﬁcant changes are as follows:  There are some terminology changes. Top-level elements are now called declarations. Templates  or template bodies as I called them in previous editions of this book  are now called sequence constructors — most people used the word template incorrectly to refer to an   element, and the new terminology bows to popular usage. Some of the terms previously used in this book but not in the ofﬁcial speciﬁcation are now ofﬁcial  an example is the term stylesheet module . Some new declarations and instructions have been introduced. The concept of backward-compatibility mode has been introduced. This is invoked when a stylesheet speciﬁes «version = "1.0"» and causes certain constructs to be handled in a way that is compatible with XSLT 1.0. The use-when attribute is introduced to allow parts of a stylesheet to be conditionally included or excluded at compile time. In other areas, there has been a general tightening up of the rules. For example, the effect of spec- ifying «xml:space = "preserve"» in a stylesheet is now described much more precisely.                          The Modular Structure of a Stylesheet  In the previous chapter, I described the XSLT processing model, in which a stylesheet deﬁnes the rules by which a source tree is transformed into a result tree.  Stylesheets, like programs in other languages, can become quite long and complex, and so there is a need to allow them to be divided into separate modules. This allows modules to be reused, and to be combined in different ways for different purposes: for example, we might want to use two different stylesheets to display press releases on-screen and on paper, but there might be components that both of these stylesheets share in common. These shared components can go in a separate module that is used in both cases.  We touched on another way of using multiple stylesheet modules in the previous chapter, where each module corresponds to one phase of processing in a multiphase transformation.  One can regard the complete collection of modules as a stylesheet program and refer to its components as stylesheet modules.  One of the stylesheet modules is the principal stylesheet module. This is in effect the main program, the module that is identiﬁed to the stylesheet processor by the use of an   processing instruction in the source document, or whatever command-line parameters or application programming  90   The Modular Structure of a Stylesheet  interface  API  the vendor chooses to provide. The principal stylesheet module may fetch other stylesheet modules, using   and   elements. These may in turn fetch others, and so on.  The following example illustrates a stylesheet written as three modules: a principal module to do the bulk of the work, with two supporting stylesheet modules, one to obtain the current date, and one to construct a copyright statement.  Example: Using    Source  The input document, sample.xml, looks like this:        Michael Kay   XSLT 2.0 Programmer’s Reference       A comprehensive guide to the XSLT 2.0  recommendation published by the World Wide Web Consortium        Stylesheets  The stylesheet uses  . The effect of this stylesheet is to copy the source docu- ment unchanged to the result, except that any   elements are set to the current date, and any   elements are set to a string identifying the copyright owner. There are three modules in this stylesheet program: principal.xsl, date.xsl, and copyright.xsl. The date.xsl module uses the XSLT 2.0 function current-date  ; the other modules will work equally well with XSLT 1.0 or 2.0. When you run the transformation, you only need to name the principal stylesheet module on the command line — the other modules will be fetched automatically. The way this stylesheet is written, all the modules must be in the same directory.  When an XSLT 2.0 processor sees a module that speciﬁes «version = "1.0"», it must either run that module in backward-compatibility mode, or it must reject the stylesheet. The latest versions of Saxon and AltovaXML both support backward-compatibility mode, so this is not a problem. Saxon displays a health warning, required by the W3 C speciﬁcations, which you can safely ignore in this instance.  If you try to run the stylesheet in XMLSpy, it will fail, reporting an error in the date.xsl module. This is because XMLSpy uses «version = "1.0"» as a signal to invoke its XSLT 1.0 processor, but the module date.xsl uses XSLT 2.0 features.  principal.xsl  The ﬁrst module, principal.xsl, contains the main logic of the stylesheet.  3  S t y l e s h e e t S t r u c t u r e  91   Stylesheet Structure    <xsl:stylesheet  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" version="1.0"  >                                                    It starts with two   elements to bring in the other modules. The   element indicates that the output should be in XML format, using the ISO 8859 1 character set  which makes it easy to view with a text editor , and with indentation to show the XML structure. The   element indicates that whitespace nodes in the source document are to be ignored: I’ll have a lot more to say about whitespace handling later in this chapter. Then there are three template rules, one for   elements, one for   elements, and one for everything else. The template rule for   elements outputs the value of the variable named $date. This variable isn’t deﬁned in this stylesheet module, but it is present in the module date.xsl, so it can be accessed from here. The template rule for   elements similarly calls the template named copyright. Again, there is no template of this name in this module, but there is one in the module copyright.xsl, so it can be called from here. Finally, the template rule that matches all other elements  «match = "*"»  has the effect of copying the element unchanged from the source document to the output. The    page 287  and    page 292  instructions are explained in Chapter 6.  date.xsl  The next module, date.xsl, declares a global variable containing today’s date. This calls the current-date   function in the standard XPath 2.0 function library, and the XSLT 2.0 format-date   function, both of which are described in Chapter 13.  92   The Modular Structure of a Stylesheet  3  S t y l e s h e e t S t r u c t u r e  <xsl:stylesheet  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" version="2.0" xmlns:xs="http:  www.w3.org 2001 XMLSchema"  > <xsl:variable name="date" as="xs:string"  select="format-date current-date  , ’[MNn] [D1o], [Y]’ " >     Although this is a rather minimal module, there’s a good reason why you might want to sep- arate this code into its own module: it’s dependent on XSLT 2.0, and you might want to write an alternative version of the function that doesn’t have this dependency. Note that we’ve set «version = "2.0"» on the   element to document this dependency; the other modules in this stylesheet have «version = "1.0"».  Earlier releases of AltovaXML had incomplete support for the format-date   function: the date was output, but not in the requested format. This is ﬁxed in the 2008 release.  copyright.xsl  Finally, the module copyright.xsl contains a named template that outputs a copyright statement. This template is called by the   instruction in the principal stylesheet. The template uses a variable $owner to construct the copyright statement; we’ll see later how this is useful.    <xsl:stylesheet  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" version="1.0">   John Wiley and Sons       Copyright         2007         The reason for separating this stylesheet program into three modules is that the date.xsl and copyright.xsl modules are reusable in other stylesheets. Functionally, the stylesheet would have exactly the same effect if the variable $date and the template named copyright were deﬁned directly in the principal stylesheet module.  93   Stylesheet Structure  Output        Michael Kay   XSLT 2.0 Programmer’s Reference   Copyright   John Wiley and Sons 2007   October 3rd, 2007   A comprehensive guide to the XSLT 2.0 recommendation  published by the World Wide Web Consortium      There is no syntactic difference between a principal stylesheet module and any other module; in fact any module can be used as a principal module.  This means that   and   can be used in any module, not only the principal module. So the stylesheet program is actually a tree of stylesheet modules, with the principal module at its root.  A stylesheet module is generally a complete XML document  the exception, an embedded stylesheet, will be described later on page 102 . The document element  the outermost element of the XML document  is then either an   element or an   element; the two names are synony- mous. The elements immediately subordinate to the   or   element are called declarations. The XSLT-deﬁned declarations are listed on page 105.  The   and   declarations are always children of the   or   element. Usually, declarations can appear in any order, but   is an exception: it must appear before any other declaration. Both elements take an href attribute whose value is a URI. Most commonly, it will be a relative URI, deﬁning the location of the included or imported stylesheet module relative to the parent module. For example,   fetches the module mod1.xsl located in the same directory as the parent module.  The difference between   and   is that conﬂicting deﬁnitions are resolved differently:          effectively does a textual inclusion of the referenced stylesheet module, minus its containing   element, at the point where the   element is written. The included module is treated exactly as if its top-level elements, with their contents, appeared in the parent module in place of the   element itself.   also incorporates the top-level elements from the referenced stylesheet mod- ule, but in this case the declarations in the imported module have lower import precedence than the declarations in the parent module. If there are conﬂicting declarations, the one with higher import precedence will generally win. The detailed rules actually depend on the type of deﬁni- tion, and are given in the speciﬁcation of   on page 357 in Chapter 6. Importing a module is thus rather like deﬁning a subclass, in that the parent module can use some declara- tions unchanged from the imported module, and override others with declarations of its own.  94   The Modular Structure of a Stylesheet  It may not come naturally to think of the importing module as a subclass of the imported module, because in a class hierarchy, the most general classes are near the root of the tree, whereas in the   tree, the most general classes are at the leaves of the tree. Nevertheless, this is how   should be used: general-purpose modules should always be imported into special-purpose modules, not the other way around.  The most common kind of declaration is the deﬁnition of a template rule, using an   element with a match attribute. As we saw in the previous chapter, if there are several template rules that match a particular node in the source tree, the ﬁrst step in deciding which to use is to look at their import precedence, and discard all those with import precedence less than the highest. So a tem- plate rule deﬁned in a particular stylesheet module will automatically take precedence over another matching rule in a module that it imports.  Where one module A imports two others, B and C, as shown in Figure 3-1, then A takes precedence over both B and C, and C also takes precedence over B, assuming that the   element that loads B precedes the   element that loads C.  3  S t y l e s h e e t S t r u c t u r e  B  C  A  import B import C  Figure 3-1  When a stylesheet incorporates another using  , the declarations in the included stylesheet have the same import precedence as those in the parent stylesheet.  Where two declarations have the same import precedence  because they were in the same stylesheet module, or because one was in a module incorporated in the other using   , the rules for resolving conﬂicts depend on the kind of declaration. In some cases, for example declarations of named templates or variables, duplicate declarations with the same name are always reported as an error. In other cases, for example declarations of template rules, the implementor has the choice of reporting an error or choosing the declaration that occurs later in the stylesheet. Some implementors may pass this choice on to the user. The detailed rules are given in Chapter 6 for each kind of declaration, and they are summarized in the section for  , page 357.  Example: Using    This extends the previous   example, showing how to use   to incorporate the declarations in another stylesheet module while overriding some of them.  Source  The input document for this example is sample.xml.  95   Stylesheet Structure  Stylesheet  Recall that the copyright.xsl module used a variable, $owner, to hold the name of the copyright owner. Suppose that we want to use the copyright template, but with a different copyright owner. We can achieve this by writing a revised principal stylesheet as follows  this is called principal2.xsl in the downloadable sample ﬁles . This stylesheet uses   instead of   to incorporate the copyright.xsl module, and it then contains a new declaration of the $owner variable, which will override the declaration in the imported module. Note that the   element must come ﬁrst.    <xsl:stylesheet  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" version="1.0"  >    John Wiley Inc.                                                  Output        Michael Kay   XSLT Programmer’s Reference   Copyright   John Wiley Inc 2007   April 28th, 2007   A comprehensive guide to the XSLT 2.0 recommendation  published by the World Wide Web Consortium      96   3  S t y l e s h e e t S t r u c t u r e  The Modular Structure of a Stylesheet  This example wouldn’t work if you used   rather than  . It would complain that the variable $owner was declared twice. This is because with  , the two declarations have the same import precedence, so neither can override the other.  It is an error for a stylesheet module to import or include itself, directly or indirectly, because doing so would deﬁne an inﬁnite loop.  It isn’t an error, however, for a stylesheet module to be included or imported at more than one place in the stylesheet program. The following isn’t an error.             This may seem rather pointless, but in a highly modular structure it can sometimes happen by accident and be harmless. For example, several of your stylesheet modules might independently reference a com- monly used module such as date.xsl. The effect is simply to load two copies of all the declarations in date.xsl, exactly as if two identical ﬁles with different names had been imported.  If the same module is fetched twice using  , the included declarations will have the same import precedence, which is likely to cause an error. If, for example, the included module deﬁnes a global variable or a named template, duplicate declarations will be reported. In other cases, for example where the ﬁle uses the   element to deﬁne named attribute sets, the duplicate declarations are harmless  the   element is described on page 266, in Chapter 6 . However, if there is a risk of loading the same module twice, it makes sense to use   rather than  .  Note that with both   and  , the href attribute is ﬁxed: it is possible for a stylesheet compiler to assemble all the modules in a stylesheet well before a source document is supplied to actually run the transformation. People often ask for some kind of facility to load stylesheet modules dynamically, based on a decision made while the transformation is running. The simple answer is that you can’t do this: you have to construct the whole stylesheet before you can start running it.  Sometimes, this requirement arises when people try to use   ‘‘the wrong way round.’’ It’s fairly natural to think in terms of writing a general-purpose stylesheet G that imports A in some circumstances  say if the user is French  and imports B in other circumstances  if the user is Spanish . But that’s the wrong way to do it: you should select A or B as the principal stylesheet module, and have both of these import the general-purpose module G. The special-purpose stylesheet module should always import the general-purpose module.  Although you can’t make a runtime decision on what modules to import or include, you can use compile- time conditional logic. For example, you can write:  <xsl:include href = "mod1.xsl"  use-when = "system-property ‘xsl:vendor’  = ‘Altova GmbH’" >.  97   Stylesheet Structure  This allows conditional inclusion of a module based on information that is known at compile time. There is more information on the use-when attribute later in the chapter: see the section ‘‘Writing Portable Stylesheets’’ on page 127.  The   Element  The   element  or  , which is a synonym  is the outermost element of every stylesheet module.  The name   is a conventional name. The ﬁrst part, xsl, is a preﬁx that identiﬁes the namespace to which the element name belongs. Any preﬁx can be used so long as it is mapped, using a namespace declaration, to the URI http:  www.w3.org 1999 XSL Transform. There is also a mandatory version attribute. So the start tag of the   element will usually look like this:  <xsl:stylesheet  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" version="2.0"  >              The   element can also be written as   if you prefer to think of XSLT as doing transformations rather than styling. The two names are completely interchangeable, but I usu- ally use   for familiarity. Everything I say about the   element applies equally to  .  As a general principle, it’s advisable to specify «version = "2.0"» if the stylesheet module uses any facilities from XSLT 2.0 or XPath 2.0, and «version = "1.0"» if it relies only on XSLT 1.0 and XPath 1.0 features. This isn’t purely documentary; as we’ll see later  see page 128 , XSLT processors have some subtle differences in behavior, depending on the setting of this attribute.  If you encounter a stylesheet that uses the namespace URI http:  www.w3.org TR WD-xsl, then the stylesheet is written in a Microsoft dialect based on an early working draft of the XSLT 1.0 standard. There are many differences between this dialect and XSLT 1.0, and even more differences between WD-xsl and XSLT 2.0. Although it has been obsolete for some years, you may still come across it occasionally.  The other attributes that may appear on this element are described under   in Chapter 6, page 465. Speciﬁcally, they are as follows:  id identiﬁes the stylesheet when it appears as an embedded stylesheet within another document. Embedded stylesheets are described in the next section. extension-element-prefixes is a list of namespace preﬁxes that denote elements used for vendor-deﬁned or user-deﬁned extensions to the XSLT language. exclude-result-prefixes is a list of namespaces used in the stylesheet that should not be copied to the result tree unless they are actually needed. I’ll explain how this works in the section Literal Result Elements on page 112. xpath-default-namespace is a namespace URI, which is used as the default namespace for unpreﬁxed element names used in path expressions within the stylesheet, and also for unpre- ﬁxed type names. This attribute is handy when all the elements in your source document are in a particular namespace, because it saves you having to use a namespace preﬁx every time you refer to an element in this namespace. Without this attribute, element names with no preﬁx are assumed to refer to names in the null namespace  neither the default namespace declared using  98   The   Processing Instruction  «xmlns = "uri"» in the stylesheet, nor the default namespace declared in the source document, has any effect on names used in path expressions . default-validation takes one of the values «preserve» or «strip». This attribute is used by a schema-aware processor to determine whether any schema-derived type annotations are retained when elements and attributes are copied. You will ﬁnd more details of how result trees are validated against a schema in Chapter 4. default-collation deﬁnes how strings are to be compared and sorted. There are many different conventions for sorting strings, depending on the language and sometimes on the whims of a publisher. The value of this attribute is simply a URI that acts as a name for the set of conventions to be used; the values you can use for this attribute will vary from one XSLT processor to another. For more details on collations, see   on page 459 in Chapter 6. input-type-annotations takes one of the values «preserve», «strip», or «unspecified». This attribute is used by a schema-aware processor to determine whether any schema-derived type annotations are retained in the input document.  3  S t y l e s h e e t S t r u c t u r e  With the exception of input-type-annotations, these attributes affect only the stylesheet module in which this   element appears; they do not affect what happens in included or imported stylesheet modules.  The   element will often contain further namespace declarations. Many stylesheets are likely to reference the names of types deﬁned in XML Schema, in which case the XML Schema namespace needs to be declared. If the result tree uses a namespace  perhaps XSL-FO or SVG , then that namespace too will often be declared. Also, if the extension-element-prefixes or exclude-result-prefixes attributes are used, then any namespace preﬁxes they mention must be declared by means of a names- pace declaration on the   element. So, if you want to declare «saxon» as an extension element preﬁx, the start tag of the   element might look like this.  <xsl:stylesheet  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" xmlns:xs="http:  www.w3.org 2001 XMLSchema" xmlns:fo="http:  www.w3.org 1999 XSL Format" xmlns:saxon="http:  saxon.sf.net " version="2.0" extension-element-prefixes="saxon" exclude-result-prefixes="xs"           >  Namespace declarations on the   element, and indeed anywhere else in the stylesheet, apply only to the stylesheet module in which they appear. They are not inherited by included or imported modules.  The   Processing Instruction  This processing instruction is not a part of the XSLT or XPath standard; rather it has a short W3 C Recom- mendation all to itself, which you can ﬁnd at http:  www.w3.org TR xml-stylesheet. XSLT mentions it, but only in an example, so there is no implication that an XSLT processor is required to support it. However, many processors do, at least in its most basic form.  99   Stylesheet Structure  The   processing instruction is used within a source XML document to identify the stylesheet that should be used to process it. There can be several   processing instructions present, deﬁning different stylesheets to be used under different circumstances.  This way of controlling a transformation is particularly useful if you want to run the transformation on the client side  that is, in the browser . This is supported by most browsers, including Internet Explorer, Firefox, Safari, and Opera. It means you can simply send an XML ﬁle to the browser, with a processing instruction to identify the stylesheet to be used, and the browser will automatically invoke a transfor- mation and then display the resulting HTML. No special script is needed to control the process, which means the solution is very portable. Unfortunately, at the time of writing, none of the major browsers includes support for client-side transformation using XSLT 2.0.  On the server side, which is where you are more likely to be using XSLT 2.0, it’s less likely that you will want to control the transformation using this processing instruction. It’s much more likely that you will want either to drive the process from the operating system command line or to use an API such as the Microsoft or Java APIs  described in Appendices D and E, respectively . These APIs give you much more control: they allow you to apply different stylesheets to the same documents on different occasions, to set parameters, and to compile a stylesheet once and then use it repeatedly.  So it’s quite likely you can skip this section for now; but for completeness, I think it’s still important to describe this mechanism.  The   processing instruction has an href attribute whose value is the URI of the stylesheet  that is, the principal stylesheet module , and a type attribute that indicates the language in which the stylesheet is written. This doesn’t have to be an XSLT stylesheet; it could be a Cascading Style Sheet  CSS .  There’s considerable confusion about what the correct value of the type attribute should be in the case of XSLT. Until recently there was no registered media type  often called MIME type  for XSLT stylesheets, so Microsoft invented one: text xsl. This has never been made ofﬁcial, and the XSLT 2.0 Recommendation instead registers the name application xslt+xml. However, the use of text xsl is now so widespread that it is unlikely to go away.  Technically, XML processing instructions do not contain attributes; they contain a name  here xml-stylesheet  followed by character data. But in this case the character data is structured as a sequence of name = "value" pairs, like the attributes in an element start tag, and the xml-stylesheet recommendation refers to these pairs as pseudo-attributes.  Following is the full list of pseudo-attributes in the   processing instruction. Attribute Name  Value URI  href  mandatory   type  mandatory   MIME type  Meaning The URI of the stylesheet. This may be an absolute or relative link to the XML document that contains the stylesheet, or it may contain a fragment identiﬁer  for example styleB  used to locate the stylesheet within a larger ﬁle. See the section Embedded Stylesheets on page 102.  Identiﬁes the language in which the stylesheet is written; typically «application xslt+xml» or «text xsl»  see the discussion earlier .  continued  100   The   Processing Instruction  Attribute Name  title  optional   Value String  media  optional   charset  optional   alternate  optional   String  Character encoding  ‘‘yes’’ or ‘‘no’’  Meaning If there are several   processing instructions, each should be given a title to distinguish them. The user can then be allowed to choose which stylesheet is wanted. For example, there may be special stylesheets that produce large print or aural rendition.  Description of the output medium, for example «print», «projection», or «aural». The list of possible values is deﬁned in the HTML 4.0 speciﬁcation. This value can be used to select from the available stylesheets.  This attribute is not useful with XSLT stylesheets, since as XML documents they deﬁne their character encoding themselves.  If «no» is speciﬁed, this is the preferred stylesheet. If «yes» is speciﬁed, it is an alternative stylesheet to be selected at user option.  3  S t y l e s h e e t S t r u c t u r e  As far as I have been able to discover the only attributes that inﬂuence Internet Explorer or Firefox are the media, href, and alternate attributes, and alternate is not very useful, because both browsers choose the «alternate = "no"» stylesheet without giving the user any opportunity to override the choice.  An   processing instruction must appear, if it appears at all, as part of the document prolog, that is, before the start tag of the document element. The href attribute identiﬁes the location of the stylesheet by an absolute or relative URI reference. For example:     According to the W3 C spec, it is possible to have several   processing instructions that match the required criteria. The idea is that, as with CSS, the different stylesheets should be merged. Again, however, the practical reality seems to be different: it appears that Inter- net Explorer uses the ﬁrst stylesheet speciﬁed, and Firefox uses the last.  Because this might be a bug that could be ﬁxed at any time, I would advise against relying on this observation in the design of your application.   It isn’t mandatory to use the   processing instruction, and most products will offer some other way of saying which stylesheet you want to apply to a particular document. It’s mainly useful when you want to apply a stylesheet to an XML document within the browser; specifying this processing instruction means that the browser can apply a default stylesheet to the document, without any extra scripting being needed.  Clearly, one of the reasons for separating the stylesheet from the source XML document is so that the same information can be transformed or presented in different ways depending on the user, their equipment, or the particular mode of access. The various attributes of the <?xml- stylesheet?> processing instruction are designed to deﬁne the rules controlling the selection of an appropriate stylesheet. The mechanism is geared toward stylesheets that are used to display information to users; it has less relevance to the more general use of XSLT for performing data transformations.  101   Stylesheet Structure  Embedded Stylesheets  There is one exception to the rule that the stylesheet module must be an XML document. The principal stylesheet module can be embedded within another XML document, typically the document whose style it is deﬁning.  The ability to embed stylesheets within the source document is best regarded as a carryover from CSS. It can be useful if you have a freestanding document that you want to distribute as a self-contained unit, but in most situations it is better to use an external stylesheet that can be used for many different source documents. I sometimes use an embedded stylesheet when I have a ‘‘one-of-a-kind’’ document such as a diary of events to be displayed on a Web site, as it simpliﬁes things to keep the stylesheet and the data together. Some people like to embed stylesheets to reduce download time, but this can be counterproductive, because it means the browser cannot spot that the stylesheet is already present in its cache.  Not all products support embedded stylesheets. The example below works in Firefox but not in Internet Explorer.  The outermost element of the stylesheet is still an   or   element, but it will no longer be the outermost element of the XML document  that is, the document element . The   element will generally have an id attribute to identify it and will be referenced within its containing document using the   processing instruction, as shown in the following example.  Example: Embedded Stylesheets  This example shows a stylesheet embedded within an XML source document containing a list of books.  Source  The data ﬁle, embedded.xml, containing both source document and stylesheet, is as follows:    <!DOCTYPE books [     ]>          Nigel Rees   Sayings of the Century   8.95         Evelyn Waugh   Sword of Honour   12.99         Herman Melville   102   Embedded Stylesheets  3  S t y l e s h e e t S t r u c t u r e   Moby Dick   8.99         J. R. R. Tolkien   The Lord of the Rings   22.99     <xsl:stylesheet id="style1" version="1.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform">            A list of books                                            You can run this stylesheet either by simply opening it in Firefox or by using Saxon with a command of the form: java -jar c:\saxon\saxon9.jar -a embedded.xml  The -a option tells Saxon to look for an   processing instruction in the supplied source document, and to process the source document using that stylesheet. Saxon doesn’t allow you  when using the command line interface  to specify the criteria for selecting a speciﬁc stylesheet, so if there are several, it uses a composite stylesheet that imports all of them. Saxon will recognize the relative URI «style1» only if it refers to the value of an attribute of type ID. The «id» attribute of the   element therefore needs to be declared as having this type; this is the purpose of the short   entry. This isn’t sufﬁcient to invoke validation of the document  if you do try to invoke validation, by specifying the -v option on the command line, you will get a string of error messages referring to undeclared elements , but it is sufﬁcient to register the attribute type of the «id» attribute.  This example doesn’t work with Saxon on the .NET platform; this is because the Microsoft XML parser on .NET doesn’t notify ID attributes unless you do DTD validation. An alternative is to use the xml:id attribute, which doesn’t depend on a DTD. In the downloaded code, the ﬁle embedded2.xml illustrates this variation.  103   Stylesheet Structure  Output  The output of this embedded stylesheet, when viewed in a Web browser, is shown in Figure 3-2.  Figure 3-2  Note the empty template rule that matches the   element. This is needed because without it the stylesheet will try to process itself along with the rest of the document. The empty template rule ensures that when the   element is matched, no output is generated and its child elements are not processed. You may need to take care to avoid matching other elements in the stylesheet as well. For example, if the stylesheet looks for book titles using an expression such as «  title», this could accidentally match a   literal result element within the embedded stylesheet.  An embedded stylesheet module will generally be used as the principal stylesheet module. The standard doesn’t explicitly say whether or not an embedded stylesheet can be included or imported into another. In practice, the details of what is supported are likely to vary from one product to another; few of the current products have much to say about embedded stylesheets in their documentation.  If namespace declarations occur outside the embedded stylesheet, they will still be in scope within the embedded stylesheet, which may result in extra namespace nodes being copied into the result tree. You can suppress such namespaces, using the exclude-result-prefixes attribute on the   element. If you are using an XML 1.1 parser, another solution would be to undeclare these namespaces  that is, to remove them from the set of namespaces that are in scope  by using a namespace undeclaration of the form «xmlns:prefix = ""».  With XML 1.0, the only namespace that can be undeclared is the default namespace.   Declarations  All elements that are immediate children of the   or   element are called top-level elements. The top-level elements that are deﬁned in the XSLT speciﬁcation, and whose names are in the XSLT namespace, are called declarations. Those that are not deﬁned in the XSLT speciﬁ- cation are called user-deﬁned data elements, and I will consider these in two categories: elements deﬁned by the vendor of the XSLT processor and elements deﬁned by the stylesheet author.  104   Declarations  It is not permitted to have text nodes as immediate children of the   or   element, unless they consist entirely of whitespace characters. Processing instructions and comments may appear, and the XSLT processor will ignore them.  Top-level elements can appear in any order in the stylesheet, except that if there are any   declarations, these must come ﬁrst. In most cases the order in which the elements appear is of no signiﬁ- cance; however, if there are conﬂicting deﬁnitions, the XSLT processor sometimes has the option of either reporting an error or taking whichever deﬁnition comes last. If you want your stylesheet to be portable, you cannot rely on this behavior, and should ensure that conﬂicting declarations don’t arise.  Let’s now examine the three categories of elements that may appear as children of  .  3  S t y l e s h e e t S t r u c t u r e           XSLT-deﬁned declarations Implementor-deﬁned declarations User-deﬁned data elements  XSLT-Deﬁned Declarations  An XSLT-deﬁned declaration must be one of the following:                                 No other XSLT element  that is, no other element with the namespace URI http:  www.w3.org  1999 XSL Transform  may be used as a child of an   element.  The   and   elements are exceptional in that they can be used both as decla- rations  of global variables and parameters  and as instructions within a sequence constructor.  The following table gives a quick introduction to the purpose of each of these declarations. Declaration  Effect Deﬁnes a named set of attribute nodes that can be added to any element in the result tree        Deﬁnes how individual characters in the result tree are to be output by the serializer  continued  105   Stylesheet Structure  Declaration                 Effect Deﬁnes a display format for numbers, used by the format-number   function described in Chapter 13  Deﬁnes a stylesheet function that can be invoked from any XPath expression  Incorporates declarations from another stylesheet module, with lower precedence than the declarations in the importing module  Incorporates declarations from another stylesheet module, with the same precedence as the declarations in the including module  Deﬁnes a key that may be referenced using the key   function  described in Chapter 13  to give fast access to elements if their key values are known     Incorporates deﬁnitions from an XML Schema     Deﬁnes a translation from namespaces used in the stylesheet to namespaces used in the result tree                    Deﬁnes how a result tree should be serialized  Deﬁnes a stylesheet parameter, a value that can be set from outside the stylesheet and accessed from anywhere within it  Deﬁnes a list of elements that contain whitespace text nodes that need to be retained  Deﬁnes a list of elements that contain whitespace text nodes that must be removed  Deﬁnes a template that can be invoked either when speciﬁc nodes are matched, or explicitly by name  Deﬁnes a global variable whose value can be accessed from anywhere in the stylesheet  The meaning of each of these elements is explained in full detail in Chapter 6.  Implementor-Deﬁned Declarations  An implementor-deﬁned declaration must belong to a namespace with a non-null URI, different from the XSLT namespace. This will generally be a namespace deﬁned by the vendor: for example with the Saxon product, the relevant namespace URI is http:  saxon.sf.net . The meaning of elements in this category is entirely at the discretion of the vendor, though the speciﬁcation states a rule that such elements must not be used to change the meaning of any standard XSLT constructs, except to the extent that the behavior is implementation deﬁned. This is a very important caveat, because there are a great many things in XSLT that are implementation deﬁned, and this clause allows vendors to use top-level elements to give the user control over the choices that are exercised. For example, they might be used to control the following:        Binding of extension functions and extension instructions Collations used for sorting  106   Declarations                 Details of result-tree serialization Localization of messages Options applied when building source trees, for example whether or not schema validation is performed Performance trade-offs, for example switches to control optimization or generation of diagnostics Error recovery policy  Note that these top-level elements are not technically extension instructions, so their namespace does not have to be declared in the extension-element-prefixes attribute for them to be effective.  Several vendors supply top-level elements that allow you to deﬁne extension functions that can be invoked from XPath expressions in the stylesheet  for example, Microsoft has an element called   that can be used to deﬁne JavaScript functions to be called during the transformation . Others might use such elements to deﬁne debugging or tracing options. Saxon also provides a top-level element to describe details of collations used for sorting, and another to import functions from an XQuery library module. Such extensions are described in the vendor’s documentation for the particular product.  If the processor doesn’t recognize the namespace used for an implementor-deﬁned declaration, it simply ignores it. This means you can safely mix different vendors’ extensions in the same stylesheet.  3  S t y l e s h e e t S t r u c t u r e  User-Deﬁned Top-Level Elements  A user-deﬁned top-level element must also belong to a namespace with a non-null URI, different from the XSLT namespace, and preferably different from the namespace URI used by any vendor. These elements are ignored by the XSLT processor.  With XSLT 1.0, user-deﬁned top-level elements were useful as a place to put lookup data, error messages, and the like. It is possible to reference these elements from within the stylesheet, by treating the stylesheet as an additional source document, and loading it using the document   function, which is described in Chapter 13. If the ﬁrst argument to this function is an empty string, it is interpreted as a reference to the stylesheet module in which the document   function appears.  So, for example, if the stylesheet contains a user-deﬁned top-level element as follows:      Source document is empty   Invalid date   Sales value is not numeric      then the same stylesheet can contain a named template to display a numbered message as follows:          <xsl:value-of        select="document ’’  * user:data message[@nr=$message-nr]" >  107   Stylesheet Structure  The   element evaluates the XPath expression in its select attribute as a string, and writes the value to the result tree. In this case the XPath expression is a path expression starting with «document ’’ », which selects the root node of the stylesheet module, followed by «*», which selects its ﬁrst child  the   element , followed by «user:data», which selects the   element, followed by «message[@nr = $message-nr]», which selects the   element whose nr attribute is equal to the value of the $message-nr parameter in the stylesheet.  The advantage of this technique is that it gathers all the messages together in one place, for ease of maintenance. The technique can also be readily extended to use different sets of messages, depending on the user’s preferred language.  With XSLT 2.0 this technique is no longer necessary, because it becomes more convenient to deﬁne ﬁxed data as part of a global variable deﬁnition. Instead of writing:      Source document is empty   Invalid date   Sales value is not numeric      you can write:     and instead of:  you can write:  Instructions      Source document is empty   Invalid date   Sales value is not numeric         The XSLT 1.0 technique still works, and you may want to continue using it when you write stylesheets that are to be portable between 1.0 and 2.0 processors.  We saw in the previous chapter that a stylesheet is evaluated by a process that involves identifying tem- plate rules, evaluating the instructions contained in a template rule to produce nodes, and then adding the nodes to a result tree. This section explores in more detail the instructions that can be evaluated to produce nodes in the result tree.  The content of an   declaration, and of various other XSLT elements, is known as a sequence constructor. Element nodes within a sequence constructor are one of three kinds: XSLT instruc- tions, extension elements, and literal result elements. I’ll describe these in the next three sections.  XSLT Instructions  An XSLT instruction is one of the following elements.  108   Instructions  3  S t y l e s h e e t S t r u c t u r e                                                                                No other element in the XSLT namespace may appear directly in a sequence constructor. Other XSLT elements, for example  ,  , and  , are not regarded as instructions, because they cannot appear directly in a sequence constructor — they may appear only in very speciﬁc contexts. The   element is anomalous as it can appear as a child of an   element, but it is constrained to appear before other elements, and is therefore not considered to be part of the sequence constructor. So, it is not classiﬁed as an instruction. The same is true of an   element appearing within   or  .  The following table gives a brief introduction to the effect of each XSLT instruction.  Instruction   Applies a regular expression to a string, causing subsidiary instructions to  Effect  be evaluated for each matching and nonmatching substring.     Searches imported stylesheets for another template rule to apply to the context node.    Selects a sequence of nodes and for each of these nodes identiﬁes the  template rule to be used to process that node, invokes the template rule, and returns the results.     Constructs an attribute node.     Invokes a named template and returns its result.     Chooses one of a number of instructions to evaluate, based on boolean conditions.     Constructs a comment node.  continued  109   Stylesheet Structure  Instruction                          Effect Copies the context node. This is a shallow copy; the content of the new node is determined by the contained instructions.  Returns a deep copy of selected nodes or atomic values.  Constructs a document node.  Constructs an element node.  Deﬁnes fallback behavior to use if a particular instruction is not available.  Invokes the contained instructions once for each item in a sequence of items.  Selects a sequence of items and divides these into groups according to speciﬁed criteria; invokes the contained instructions once for each group of items.  Evaluates the contained instructions if and only if a speciﬁed condition is true.     Outputs a message to a system-deﬁned destination.     Constructs a namespace node.        <xsl:processing- instruction>        Selects another template rule that applies to the context node and invokes it.  Generates a sequence number for the context node and formats it for output.  Constructs a processing instruction node.  Selects a sequence of items and sorts them according to speciﬁed criteria.  Constructs a document node to act as the root of a result tree and optionally serializes it to a speciﬁed output destination.     Produces a sequence of nodes and or atomic values.           Constructs a text node from literal text in the stylesheet, preserving whitespace.  Constructs a text node.  Deﬁnes a local variable whose value can be accessed from other instructions within its scope.  All of these XSLT instructions are explained in full detail in Chapter 6.  If an unknown element in the XSLT namespace is encountered in a sequence constructor, the action taken depends on whether forward-compatible mode is enabled. This is discussed later on page 130.  110   Instructions  Extension Instructions  An extension instruction is an instruction deﬁned by the vendor or the user, as distinct from one deﬁned in the XSLT standard. In both cases, they are recognized as extension elements because they belong to a namespace that is listed in the [xsl:]extension-element-prefixes attribute of this element or of a containing element.  The preﬁx «xsl:» is used on this attribute only when it appears on an element that is not in the XSLT namespace. Most commonly, this attribute — without the «xsl:» preﬁx — appears on the   element itself.   In practice, extension instructions are more likely to be deﬁned by vendors than by users. With XSLT 1.0, several vendors provided extension instructions to direct the stylesheet output to multiple output ﬁles  with XSLT 2.0, this is superseded by a standard facility, the   instruction . The Saxon product also provided the   extension element, which has been superseded by the   instruction in XSLT 2.0. An example of an extension that has not been super- seded by any XSLT 2.0 feature is Saxon’s   element, which returns the result of performing a query on a relational database.  The following example shows an   element that would be treated as a literal result element were it not for the xsl:extension-element-prefixes attribute, which turns it into an extension instruction.  3  S t y l e s h e e t S t r u c t u r e  <acme:instruction  xmlns:acme="http:  acme.co.jp xslt" xsl:extension-element-prefixes="acme" >  The way in which new extension instructions are implemented is not deﬁned in the XSLT speciﬁcation and is likely to vary for each vendor. Not all products allow users to implement their own extension instructions, and with those that do, it may well involve some rather complex system-level programming. In practice, it is usually simpler to escape to user-written code by using extension functions, which are much easier to write. Extension functions are discussed later in this chapter, on page 134.  However, all XSLT processors are required to recognize an extension instruction when they see one, and distinguish it from a literal result element.  What happens if a stylesheet that uses an extension instruction deﬁned in the Xalan product  say  is processed using a different product  say Microsoft’s ? If the processor encounters an extension instruction that it cannot evaluate  typically because it was invented by a different vendor , the action it must take is clearly deﬁned in the XSLT standard: if the stylesheet author has deﬁned an   action, it must evaluate that; otherwise, it must report an error. The one thing it must not do is to treat the extension instruction as a literal result element and copy it to the result tree.  The   instruction allows you to deﬁne how an XSLT processor should deal with exten- sion instructions it does not recognize. It is described in more detail on page 141, and full speciﬁcations are on page 316 in Chapter 6.  Any element found in a sequence constructor that is not an XSLT instruction or an extension instruction is interpreted as a literal result element  for example, the   elements in the example discussed ear- lier . When the sequence constructor is evaluated, the literal result element will be copied to the result sequence.  So in effect there are two kinds of nodes in a sequence constructor: instructions and data. Instructions are obeyed according to the rules of the particular instruction, and data nodes  text nodes and literal result elements  are copied to the result sequence.  111   Stylesheet Structure  Literal Result Elements  Literal result elements play an important role in the structure of a stylesheet, so the next section examines them in more detail.  A literal result element is an element within a sequence constructor in the stylesheet that cannot be interpreted as an instruction, and which is therefore treated as data to be copied to the current output destination.  The notation I’m using here to describe literal result elements will be used extensively in Chapter 6, so it’s worth explaining it.              The Format section explains where the element can appear in the stylesheet; it lists the permitted attributes and their meanings and deﬁnes what child elements can appear in this element, if any. For each attribute it gives the name of the attribute, states whether the attribute is mandatory or optional, gives the permitted values for the attribute, and explains how the attribute is used. It also indicates whether the attribute may be an attribute value template. The Effect section deﬁnes what the element does The Usage section explains how the element is used in practice. The Examples section gives examples of how the element is used. In some cases, especially where an element has several distinct usages, the examples are merged into the Usage section.  A literal result element can have any name, provided it is not in the XSLT namespace and is not in a namespace declared to contain extension instructions.  A literal result element always appears directly within a sequence constructor.  Name  xsl:use-when  optional   xsl:default- collation  optional   xsl:exclude- result-prefixes  optional   Value An XPath expression that can be evaluated at compile time  A URI identifying a collation supplied by the vendor  Whitespace-separated list of namespace preﬁxes  see the following note   Meaning Allows the element to be conditionally excluded from the stylesheet.  Deﬁnes the default collation to be used within this part of the stylesheet.  Each preﬁx in the list must identify a namespace that is in scope at this point in the stylesheet module. The namespace identiﬁed is not to be copied to the result tree.  continued  Format  Position  Attributes  112   Instructions  Name  xsl:extension- element- prefixes  optional   Value Whitespace-separated list of namespace preﬁxes  see the following note   Meaning Each preﬁx in the list must identify a namespace that is in scope at this point in the stylesheet module. Elements that are descendants of this literal result element, and whose names are in one of these identiﬁed namespaces, are treated as extension instructions rather than literal result elements.  «yes» or «no»  Default is «yes»   Indicates whether the constructed element will inherit the namespaces of its parent.  3  S t y l e s h e e t S t r u c t u r e  xsl:inherit- namespaces  optional   xsl:version  optional   xsl:use- attribute-sets  optional   xsl:type  optional   xsl:validation  optional   Number  Whitespace-separated list of QNames identifying named   elements  see the following note   The name of a global type  simple type or complex type , which is either a built-in type such as xs:date, or a type deﬁned in an imported schema  One of the values «strict», «lax», «strip», or «preserve»  Other attributes  optional   Attribute value template  The value «1.0» invokes backward-compatible processing for this element and its descendants  see page 129 . A value greater than 2.0 enables forward-compatible processing  see page 130 .  The attributes deﬁned in the named attribute sets are instantiated and copied as attributes of this literal result element in the constructed sequence.  The constructed element in the result tree will be validated against this type deﬁnition. If it is valid, the element will be annotated with this type; if not, the transformation will fail.  Describes the validation action to be performed. This attribute cannot be combined with the xsl:type attribute. The value «strict» or «lax» causes the processor to look in the available schemas for an element declaration that matches the name of the literal result element, and to validate the constructed element against this declaration. Validation is described in more detail in Chapter 4.  Any XPath expressions occurring between curly braces in the value are evaluated, and the resulting string forms the value of an attribute copied to the result sequence. Attribute Value Templates are described on page 122.  Several of the attributes take the form of whitespace-separated lists. This is simply a list of names  or preﬁxes  in which the various names are separated by any of the XML-deﬁned whitespace characters: tab, carriage return, newline, or space. For example, you could write:     113   Stylesheet Structure  Here the names blue, italic, and centered must match the names of   elements elsewhere in the stylesheet.  Content  Effect  Usage  The content of a literal result element is a sequence constructor. It may thus contain XSLT instructions, extension elements, literal result elements, and or text nodes.  A new element is created, whose expanded name  that is, local name and namespace URI  is the same as the name of the literal result element. In nearly all cases the preﬁx will also be the same. The sequence constructor contained in the literal result element is evaluated, and this sequence is used to form the content of the new element. The new element is then returned as the result of the instruction, to be combined with other items produced by sibling instructions in the stylesheet.  The way attributes and namespaces are handled is described in subsequent sections.  Consider a sequence constructor containing a single literal result element.   Product code   In this case a   element will be written to the result tree with a child text node whose content is «Product code». When the result tree is output to an XML or HTML ﬁle, it will regenerate the text as it appeared in the stylesheet — or something equivalent. There is no guarantee that it will be character-for- character identical, for example the processor may add or remove whitespace within the tags, or it may represent characters using character or entity references.  If the literal result element has content, then the content must be another sequence constructor, and this sequence constructor is itself evaluated; any nodes generated in the result sequence in the course of this process will become children of the element created from the literal result element.  For example, if the sequence constructor is:       then when the   element is evaluated, its content will also be evaluated. The content in this case is a sequence constructor consisting of a single XSLT instruction, and the effect is that this instruction is evaluated to create a text node that will be a child of the   element in the result tree. The instruction   outputs the typed value of the current node in the source tree, converted to a string. So if this value is «$83.99», the result would be as follows:   $83.99   It is tempting to think of this as a sequence of three steps:  The   start tag causes a   start tag to be written to the output.  The   element is evaluated, and the result  «$83.99»  is written to the output. The   end tag causes a   end tag to be written to the output.           114   However, this is not a true picture of what is going on, and it is best not to think about it this way; otherwise, you will start wondering, for example, how to delay writing the end tag until some condition is encountered in the input.  The transformation process writes nodes to the result tree; it does not write tags to a text ﬁle. The    element in the stylesheet causes a    element to be written to the result tree. You cannot write half a node to the tree — the start and end tags are not written as separate operations. The   and   tags are generated only when the result tree is serialized as XML or HTML.  Instructions  3  S t y l e s h e e t S t r u c t u r e  Figure 3-3 helps illustrate this.  Stylesheet    <xsl:value-of select="." >   element  TD  Stylesheet  Tree  element xsl:value-of  attribute select  .  Transformation  Process  Result Tree element  TD  text  $83.00  Result ...   $83.00   ...  Source Tree element  price  text  $83.00  Source ...   $83.00   ...  Figure 3-3  If you do ﬁnd yourself thinking about where you want tags to appear in the output, it is a good idea to draw a sketch showing the required shape of the result tree and then think about how to write the stylesheet to produce the required nodes on the tree. Because the element in the result tree will always be produced by evaluating one sequence constructor in the stylesheet, this amounts to asking ‘‘what condition in the input tree should cause this result element to be generated?’’  115   Stylesheet Structure  For example, suppose you want to generate an HTML table with ﬁve columns, arranging the   elements from the source XML ﬁve to a row. Then the condition in the source XML that causes an output row to be generated is an   element whose position is 1, 6, 11, and so on. The logic can be written:                         The ﬁrst template rule matches   elements that should appear at the start of a new row; it outputs the   element, and ﬁve   elements corresponding to this   and its four following siblings. The second rule matches   elements that should not appear at the start of a new row, and does nothing, because these will already have been processed by the ﬁrst template rule.  In XSLT 2.0 problems like this one can also be solved conveniently using the   instruction, which is described with examples in Chapter 6 on page 326. However, for simple cases like this, the approach shown above works just as well.  Attributes of a Literal Result Element  If the literal result element has attributes, other than the special xsl-preﬁxed ones in the list above, then these attributes too will be copied to the current output destination. So if the sequence constructor contains:       then the output will contain a copy of this whole structure. The outer   element is copied to the result tree as before, and this time its content consists of another literal result element, the   element, which is copied to the result tree as a child of the   element, along with its src attribute. This time both the stylesheet tree and the result tree take the form shown in Figure 3-4.  element  TD  element  IMG  Figure 3-4  attribute  src  picture1.gif  116   If the value of an attribute of a literal result element contains curly braces  «{» and «}» , then it is treated as an attribute value template  discussed further in the next section . The text between the curly braces is treated as an XPath expression, and is evaluated as a string; the attribute written to the result tree contains this string in place of the expression. For example, suppose we apply the following template to the books.xml ﬁle used earlier:  Instructions                        Sayings of the Century   Sword of Honour   Moby Dick   The Lord of the Rings   Because the position   function takes the values 1, 2, 3, and 4, as we move through the set of books, the output will take the following form:  It is also possible to generate attributes for a literal result element by two other mechanisms:        The attribute can be generated by an   instruction. This instruction does not need to be textually within the content of the literal result element in the stylesheet, but attributes generated in the result sequence must appear before any child nodes  elements or children . The reason for this rule is to allow the XSLT processor to avoid building the result tree in mem- ory. Many processors will serialize XML syntax directly to an output ﬁle as the nodes are gener- ated, and the rule that attributes must be generated before child elements or text nodes ensures that this is possible. Technically, it’s not the order in which the instructions are evaluated that matters  that’s up to the implementation ; rather, the rule is that attribute nodes in the result of evaluating a sequence constructor must appear earlier in the sequence than nodes to be used as children. A collection of attributes can be generated by use of a named attribute set. The literal result ele- ment must contain an xsl:use-attribute-sets attribute that names the attribute sets to be incorporated: these names must correspond to   declarations at the top level of the stylesheet. The named attribute sets each contain a sequence of   instructions, and these cause attributes to be added to the generated element as if they were present directly in the content of the literal result element. Named attribute sets are useful to maintain a collection of related attributes such as font name, color, and size, which together deﬁne a style that will be used repeatedly in the output document; they are a direct parallel to the styles found in simpler languages such as CSS.  Attributes are added to the generated element node in a deﬁned order: ﬁrstly, attributes incorporated using xsl:use-attribute-sets, then attributes present on the literal result element itself, and ﬁnally attributes added using   instructions. The signiﬁcance of this sequence is that if two or more attributes with the same name are added, it is the last one that counts. It doesn’t mean that they will necessarily appear in this order when the result tree is serialized.  3  S t y l e s h e e t S t r u c t u r e  117   Stylesheet Structure  Namespaces for a Literal Result Element  The namespace nodes of a literal result element are also copied to the result sequence of the sequence con- structor. This is often the source of some confusion. The literal result element in the stylesheet will have a namespace node for every namespace declaration that is in scope: that is, every «xmlns» or «xmlns:*» attribute on the literal result element itself, or on any of its ancestor elements in the stylesheet. The only exception is that the attribute «xmlns = ""» does not act as a namespace declaration, rather it cancels any earlier declaration for the default namespace.  With XML Namespaces 1.1, it is also possible to cancel declarations of non-default namespaces, using an attribute of the form «xmlns:prefix = ""». This undeclaration, if supported by the XSLT processor, ensures that the literal result element will not have a namespace node for that namespace preﬁx.  In the result tree, the element created from the literal result element is guaranteed to have a namespace node for every namespace node that was present on the literal result element in the stylesheet, except the following:           A namespace node for the XSLT namespace URI http:  www.w3.org 1999 XSL Transform will not be copied. A namespace node for a namespace declared as an extension instruction namespace will not be copied. A namespace is declared as an extension instruction namespace by including its preﬁx in the value of the [xsl:]extension-element-prefixes attribute of the literal result element, or of any enclosing element in the stylesheet.  The attribute must be preﬁxed with the XSLT names- pace if it appears on a literal result element, but must be unpreﬁxed if it appears on an XSLT element.   A namespace node for an excluded namespace will not be copied. A namespace is declared as an excluded namespace by including its preﬁx in the value of the [xsl:]exclude-result- pre- fixes attribute of this literal result element or of any ancestor element in the stylesheet.  Again, the attribute must be in the XSLT namespace when it appears on an element that is not in the XSLT namespace.   These exceptions don’t apply if the name of the element, or the name of one of its attributes, actually uses one of these namespaces. The system will always ensure that the namespaces used for the element and attributes in the result tree are declared, however hard you try to prevent it. If this isn’t what you want, then the chances are you should be generating the element in a different namespace to start with. To achieve this, you might need to use the   instruction instead of using literal result elements.  Consider the following stylesheet:  <xsl:stylesheet xmlns:xsl="http:  www.w3.org 1999 XSL Transform"  version="2.0" xmlns:Date="java:java.util.Date"  >                   118   Instructions  There are three namespaces in scope for the   element, namely the XSLT namespace, the namespace «java:java.util.Date», and the default namespace «urn:acme-com:gregorian». The XSLT namespace is not copied to the result tree, but the other two are. So, the   element added to the result tree is guaranteed to have these two namespaces in scope: «java:java.util.Date», and «urn:acme-com:gregorian».  This stylesheet uses two extension functions «Date:new  » and «Date:toString  ». This means that it will not be portable between different XSLT processors.  If the $today parameter is supplied as the value «2008-03-18», the output would be as follows  regard- less of the source document :  3  S t y l e s h e e t S t r u c t u r e  <date xmlns="urn:acme-com:gregorian"  xmlns:Date="java:java.util.Date">2008-03-18   The ﬁrst namespace declaration is necessary, because it deﬁnes the namespace for the element name  . However, you probably don’t really want the xmlns:Date declaration here. It’s not doing any harm, but it’s not doing any good either. It’s there because the XSLT processor can’t tell that it’s unwanted. If you want this declaration to be omitted, use the xsl:exclude-result-prefixes attribute as follows:  <xsl:stylesheet  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" version="2.0" xmlns:Date="java:java.util.Date"  >                       Alternatively, if your processor supports XML Namespaces 1.1, you can write <date xmlns:Date = "">... .  The fact that an element in the result tree has a namespace node does not necessarily mean that when the result tree is written out as an XML document, the corresponding element will have a namespace declaration for that namespace. The XSLT processor is likely to omit the namespace declaration if it is redundant, in other words, if it duplicates a namespace declaration on a containing element. It can’t be omitted, however, simply on the basis that it is not used. This is because namespace declarations might affect the meaning of the data in the output document in a way that the XSLT processor is unaware of. Applications are perfectly entitled to use namespace declarations to scope identiﬁers and names appearing in attribute values or text.  The xsl:exclude-result-prefixes attribute is used to remove namespace declarations that are unused and unwanted. It can’t be used to remove the declaration of namespace preﬁxes that are actually used in the result tree. And it isn’t used to remove duplicate namespace declarations, as most processors will do that automatically.  119   Stylesheet Structure  Namespace Inheritance  By default, when an element is generated in the result tree, it will automatically acquire copies of the namespace nodes attached to its parent in the result tree. Suppose your stylesheet has the following form:                     This product is brilliant!      The result of applying these two rules to a   element in the source document will generally look like this:      This product is brilliant!      Note that in this serialized output, the namespace «urn:acme-com:product» is in scope for the   element. Suppose, however, that you are using XML Namespaces 1.1, and you want the result tree to be serialized as follows:      This product is brilliant!      To achieve this, you need to do two things. Firstly, you need to ensure when constructing the   element that it doesn’t acquire a namespace node for the «urn:acme-com:product» namespace. Secondly, you need to ensure that the serializer generates the namespace undeclaration «xmlns:p = ""».  The ﬁrst step is achieved by setting the attribute «xsl:inherit-namespaces = "no"» on the   literal result element. This switches off the normal behavior during tree construction, by which a child element automatically inherits the namespaces of its parent element.  The second step is achieved by setting the following declaration in the stylesheet:     In this example, the namespace undeclaration is largely cosmetic. But if the   element were the envelope of a SOAP message, and the   element were the payload of the SOAP message, then the namespace undeclarations could be useful: the effect is that if the recipient of the SOAP message extracts the payload using another XSLT transformation, it will be in precisely its original form, not polluted with any declarations of SOAP namespaces.  For information about SOAP, see http:  www.w3.org TR soap12-part0 .  120   Instructions  Namespace Preﬁxes  When a literal result element is copied to the result tree, the element name and attribute names of the new nodes in the result tree will have the same expanded name  that is, local name and namespace URI  as the corresponding nodes in the stylesheet. Unless there is a conﬂict, the names that are eventually output will also use the namespace preﬁx that was used in the stylesheet.  There are unusual circumstances when the XSLT processor may need to change the preﬁx of an element or attribute. Consider the following contrived example:  3  S t y l e s h e e t S t r u c t u r e      http:  domain-b.com       The generated output in this case will look something like this:  <ns0:output  xmlns:ns0="http:  domain-a.com " xmlns:p="http:  domain-b.com " >  Here the literal result element and its contained   instruction are in conﬂict: they are trying to establish different bindings for the same namespace preﬁx «p». The speciﬁcation is clear that the   instruction wins, so the element acquires an arbitrary preﬁx allocated by the system.  When namespace nodes are copied from the source or stylesheet tree to the result tree, the namespace preﬁx and namespace URI are both copied unchanged. When element or attribute nodes are copied, the expanded name of the element or attribute  that is, its local name and namespace URI  is always preserved, but the namespace preﬁx may occasionally need to be changed. If this happens, however, an extra namespace node will be added to the result tree to associate the new namespace preﬁx with the correct namespace URI.  Namespace Aliasing  In some circumstances, instead of changing the namespace preﬁx when a literal result element is copied to the result tree, it is necessary to change the namespace URI.  The most obvious situation where this arises is when the output document is itself a stylesheet. This isn’t as esoteric a requirement as it may appear — generating a stylesheet can be a very useful technique. For example, if your company changes its house style to use different fonts and colors, you could write an XSLT transformation to convert all your existing stylesheets to the new standard.  When you generate a stylesheet, you will want to generate XSLT elements such as   in the result tree, but you can’t include such elements as literal result elements in the stylesheet, because they would be mistaken for instructions. One approach is to generate these elements using the   instruction instead of literal result elements. But there is another way of doing it: you can include them in the stylesheet with a different namespace and then declare in an   element that the URI should be changed when the literal result element is copied to the result tree.  For more details of this mechanism, see   in Chapter 6, on page 394.  121   Stylesheet Structure  Attribute Value Templates  As we’ve seen, an attribute value template is a special form of parameterized attribute value. There are two ways they can be used:        On a literal result element, an attribute value template provides a way of generating an attribute whose value is computed at runtime rather than always taking the same value, for example <td width = "{$width}">. You could achieve the same effect with the   instruc- tion, but attribute value templates are easier to write and understand. On some XSLT elements, certain attributes can be computed at runtime. For example, when sort- ing, instead of writing «order = "ascending"» or «order = "descending"», you could write «order = "{$order}"» so that the order varies, depending on a runtime parameter.  Note that there are very few attributes where this facility is available. They are listed later in this section.  The term template here has nothing to do with   elements. Attribute value templates simply provide a notation for embedding variable components into an otherwise ﬁxed attribute value.  An attribute value template is a string in which XPath expressions may be embedded within curly braces  «{» and «}» . The XPath expression is evaluated, and in general the result will be a sequence. This sequence is processed using the same rules as for an   instruction, explained in detail on page 254 in Chapter 6: in short, adjacent text nodes are merged, nodes are atomized, atomic values are converted to strings, and the strings are then concatenated, with a single space character inserted as a separator between each string. The resulting concatenated string is substituted into the attribute value in place of the original XPath expression and curly braces.  If backward-compatibility mode is in use  that is, if «version = "1.0"» is speciﬁed , then all strings after the ﬁrst in the sequence are discarded; only the ﬁrst string is included in the output. See the section Version Compatibility on page 128 for details.  For example, suppose you have a set of images representing an alphabet such as the following, and you want to use these to represent the ﬁrst character of a paragraph of text.  fancyA.gif  fancyB.gif  fancyC.gif  fancyD.gif  fancyE.gif  fancy  You could write a template rule to achieve this as follows  ignoring practical details such as how to deal with paragraphs that don’t start with a capital letter . It uses the substring   function, which is described in Chapter 13.               122   A paragraph that starts with the letter A  like this one  will cause the src attribute of the   element to be evaluated as «img src = "fancyA.gif"», so it will be displayed in the browser as shown in Figure 3-5.  Instructions  3  S t y l e s h e e t S t r u c t u r e  Figure 3-5  If you want to include the characters «{» or «}» in an attribute value with their ordinary meaning, they should be doubled as «{{» or «}}». This is sometimes necessary when generating dynamic HTML, and it also happens often with the regex attribute of the   instruction, whose value is a regular expression. However, you should do this only in an attribute that is being interpreted as an attribute value template. In other attributes, curly braces have no special meaning.  Curly brackets can never be nested. You can use them only to include an XPath expression in the text of a stylesheet attribute; they cannot be used within an XPath expression itself. You can always achieve the required effect some other way; for example, instead of:       write:     The concat   function, described in Chapter 13, performs concatenation of strings.  Attribute value templates cannot be used anywhere you like in the stylesheet. They can be used only for those attributes that are speciﬁcally identiﬁed as attribute value templates in the XSLT Recommendation. The following table gives a complete list of all the places you can use attribute value templates. Attributes Interpreted as Attribute Value Templates Element All attributes except those in the XSLT namespace Literal result elements  Extension elements  As deﬁned by the speciﬁcation of each extension element     regex, flags     name, namespace, separator     name, namespace     collation     terminate  continued  123   Element  Attributes Interpreted as Attribute Value Templates  format, lang, letter-value, ordinal, grouping-separator, grouping-size  Stylesheet Structure     name     <xsl:processing- instruction>  name     format, href, method, byte-order-mark, cdata-section-elements, doctype-public, doctype-system, encoding, escape-uri-attributes, include-content-type, indent, media-type, normalization-form, omit-xml-declaration, standalone, undeclare-prefixes, output-version     lang, order, collation, data-type, case-order     separator  In all other contexts, don’t even think of trying to use them because the curly braces will either be ignored or cause an error to be reported. It can be very tempting, if you want to use  , for example, and the name of the template you want to call is in a variable, to want to write:           However, you can’t, because the name attribute  or any other attribute of   for that matter  of   is not in the above list of places where attribute value templates can be used.  Why are attribute value templates rationed so severely? The restrictions are there deliberately to make life easier for the XSLT processor:              Attribute value templates are never allowed for attributes of declarations. This ensures that the values are known before the source document is read, and are constant for each run of the stylesheet. Attribute value templates are never allowed for attributes whose value is an XPath expression or a pattern. This ensures that expressions and patterns can be compiled when the stylesheet is read, and do not need to be re-parsed each time they are evaluated. Attribute value templates are generally not allowed for attributes whose value is the name of another object in the stylesheet, for example a named template or a named attribute set  an exception is the format attribute of   . This ensures that references from one stylesheet object to another can be resolved once and for all when the stylesheet is ﬁrst read. They are allowed, however, for names of nodes being written to the result tree. Attribute value templates are not recognized when attributes such as xml:space, xml:lang, xml:base, or xsi:type are interpreted by the XML parser or schema validator. This also applies to namespace declarations  xmlns and xmlns:prefix . This is because the XML parser reads the value before the XSLT processor gets a chance to expand it. The XSLT processor won’t stop you from using curly braces in such an attribute when it appears on a literal result element, but the chances are that some other software will throw an error before you get that far.  124   Simpliﬁed Stylesheets  When an XPath expression within an attribute value template is evaluated, the context is the same as for any other expression in the stylesheet. The idea of an expression having a context was introduced in Chapter 2, on page 84: it determines the meaning of constructs such as «.», which refers to the context node, and «position  », which refers to the context position. Variables and namespace preﬁxes may be used within the expression only if they are in scope at that point in the stylesheet. The context item, context position, and context size are determined from the sequence being processed in the most recent call of  ,  , or  . Outside such a call  for example, while a global variable is being evaluated , the context item is set to a value supplied by the caller of the stylesheet  generally the document node of the source document , and the context position and size are set to 1  one .  3  S t y l e s h e e t S t r u c t u r e  Simpliﬁed Stylesheets  A simpliﬁed stylesheet uses an abbreviated syntax in which the   element and all the top-level declarations are omitted.  The original purpose of this facility was to allow people with HTML-authoring skills but no program- ming experience to write simple stylesheets with a minimum of training. A simpliﬁed stylesheet has a skeleton that looks like the target document  which is usually HTML, although it doesn’t have to be , and uses XSLT instructions to ﬁll in the variable parts.  A stylesheet module is interpreted as a simpliﬁed stylesheet if the outermost element is not   or  . The outermost element can have any name, provided it is not in the XSLT namespace. It must still contain a declaration of the XSLT namespace, and it must have an xsl:version attribute. For XSLT 2.0 the value should be «1.0» or «2.0»  use «2.0» if your stylesheet depends on features deﬁned in XSLT 2.0, or «1.0» if you also want it to work with XSLT 1.0 processors . When the xsl:version attribute is greater than «2.0», forward-compatible processing mode is enabled. This is discussed later in this chapter on page 130.  Example: A Simpliﬁed Stylesheet  This example shows a stylesheet that takes the form of an HTML skeleton page, with XSLT instructions embedded within it to pull data from the source document. The stylesheet is in the download ﬁle under the ﬁlename simplified.xsl, and can be used together with the data ﬁle books.xml. The complete stylesheet is as follows:  <html xmlns:xsl="http:  www.w3.org 1999 XSL Transform"  xsl:version="2.0">    A list of books      A list of books                     125   Stylesheet Structure                        When you run this against the ﬁle books.xml  which is listed on page 74 in Chapter 2 , the output is a sorted table showing the books  see Figure 3-6 .  Figure 3-6  A simpliﬁed stylesheet is equivalent to a stylesheet in which the outermost element  typically the   element  is wrapped ﬁrst in an   element with «match = " "», and then in an   element. The xsl:version attribute of the outermost element becomes the version attribute of the  . So the expanded form of the above example would be as follows:  <xsl:stylesheet xmlns:xsl="http:  www.w3.org 1999 XSL Transform"  version="2.0">        A list of books      A list of books                                126   Writing Portable Stylesheets  3  S t y l e s h e e t S t r u c t u r e                The signiﬁcance of «match = " "» is that this identiﬁes the template rule as the ﬁrst one to be processed when the stylesheet is activated. As we saw in Chapter 2, processing generally starts at the root node of the source document tree, and whichever template rule matches this root node is the ﬁrst one to be invoked. The match pattern « » matches a document node. In a simpliﬁed stylesheet, this will be the only template rule invoked.  There are many things a simpliﬁed stylesheet cannot do, because it cannot contain any declarations. For example, a simpliﬁed stylesheet can’t include or import another stylesheet, it can’t have global vari- ables or parameters, and it can’t deﬁne keys. But when you need these extra capabilities, you can always ‘‘unsimplify’’ the stylesheet by adding the surrounding   and   ele- ments.  It is possible in theory for a stylesheet to include or import a simpliﬁed stylesheet, which would be expanded exactly as described above — but it would be a rather unusual thing to do.  Writing Por table Stylesheets  In this section we will examine a range of facilities that are included in XSLT to help you write portable stylesheets; that is, stylesheets that can run across different XSLT processors, possibly supporting differ- ent versions of the XSLT language.  We will look at the question of version compatibility; that is, how to write stylesheets that work with both XSLT 1.0 and XSLT 2.0. Then we will look at how to use vendor extensions, without sacriﬁcing portability. But before we do either of these things, I will describe a new feature that has been added to XSLT 2.0 to aid portability, namely the use-when attribute, which allows you to include or exclude stylesheet code conditionally at compile time.  Conditional Compilation  The use-when attribute serves a similar purpose to ifdef in the C language: it allows you to deﬁne conditions under which a section of the stylesheet can be conditionally included or excluded at compile time.  The use-when attribute can be used on any XSLT element. This includes declarations and instructions, and other elements such as   and  . Written as «xsl:use-when», it is also allowed on literal result elements and extension instructions. The value of the attribute is a condition to be evaluated at compile time. If the condition is false, then the element and the subtree rooted at that element are effectively eliminated from the stylesheet, before any further processing takes place: it is as if the element and its content were not there. One consequence is that no XSLT errors will be reported in respect of this element or its descendants.  Here is an example, which deﬁnes two alternative entry points, one for an XSLT 1.0 processor and one for an XSLT 2.0 processor. This assumes that the   element speciﬁes «version = "2.0"». This means that an XSLT 1.0 processor will be running in forward-compatible mode  explained in the  127   Stylesheet Structure  next section  and will therefore ignore attributes such as use-when that it does not understand. An XSLT 1.0 processor will use the ﬁrst template rule as the entry point, because it has higher priority. An XSLT 2.0 processor, however, will behave as if the ﬁrst template rule is not present, and will use the second one, which differs in that it invokes schema validation of the result document.  <xsl:template match=" " priority="2"  use-when="system-property ’xsl:version’ =’1.0’">                       The expression contained in the use-when attribute can be any XPath expression, but it is constrained to have a very restricted evaluation context. This means there is no context item, there are no variables available, and no access to external documents. In practice, this means that the only things the expression can usefully do is to examine the results of functions such as system-property  , element-available  , and function-available  , to see what environment the stylesheet is running in. These three functions are fully described in Chapter 13.  One important reason for the introduction of the use-when attribute was to allow stylesheets that work both on schema-aware and non-schema-aware XSLT processors to be written. For example, you can use the system-property   function in a use-when attribute on the   declaration so that a schema is imported only when using a schema-aware processor. For details of how schemas are imported into a stylesheet, see Chapter 4.  Version Compatibility  Version compatibility is about how to achieve resilience to differences between versions of the XSLT standard.  There are currently two versions of the XSLT Recommendation, versions 1.0 and 2.0  the many interme- diate working drafts don’t count . So compatibility between versions has now become an issue. However, the language designers had the foresight to anticipate that it would become an issue, and made provision even in version 1.0 to allow stylesheets to be written in a portable way.  The stylesheet is required to carry a version number  typically «version = "1.0"» or «version = "2.0"»  as an attribute of the   element. Specifying «version = "1.0"» declares that the stylesheet is designed primarily for use with XSLT 1.0 processors, while specifying «version = "2.0"» indicates that it is designed for XSLT 2.0.  The term backward compatibility refers to the ability of version N of a language to accept programs or data that worked under version N – 1, while forward compatibility refers to the ability of programs that worked under version N to move forward to version N + 1. The two concepts are therefore opposite sides of the same coin. However, the XSLT language speciﬁcation distinguishes carefully between them. As far as an XSLT 2.0 processor is concerned, a stylesheet that speciﬁes «version = "1.0"» is operat- ing in backward-compatible mode, while a stylesheet that speciﬁes «version = "3.0"» is operating in forward-compatible mode.  128   Writing Portable Stylesheets  If you specify «version = "1.0"» in the stylesheet, then you are signaling the fact that the stylesheet was designed to be run under XSLT 1.0, and that in some speciﬁc cases where XSLT 2.0 deﬁnes different behavior from 1.0, the 1.0 behavior should be used. For example, if you supply a sequence of nodes as the value of the select attribute of  , the XSLT 1.0 behavior is to output the ﬁrst value in the sequence and ignore the others; the XSLT 2.0 behavior is to output all the values, space separated.  Specifying «version = "1.0"» does not mean that you cannot use facilities that were newly introduced in XSLT 2.0. It only means that an XSLT 2.0 processor should use the 1.0 behavior in certain speciﬁc cases where there are incompatibilities.  XSLT 2.0 processors are not required to implement backward-compatibility mode. If they don’t provide this feature, they must reject any stylesheet that speciﬁes «version = "1.0"». Some products, such as XMLSpy, use the version number to decide whether to invoke an XSLT 1.0 processor or an XSLT 2.0 processor.  3  S t y l e s h e e t S t r u c t u r e  If you specify «version = "2.0"» in a stylesheet, and then run it under an XSLT 1.0 processor, you are indicating that the stylesheet makes use of facilities that were newly introduced in XSLT 2.0, and that the 1.0 processor should not treat these constructs as an error unless they are actually evaluated. The stylesheet can use various mechanisms to avoid evaluating the constructs that depend on XSLT 2.0 when these features are not available. This only works, of course, because the need for it was anticipated in the XSLT 1.0 speciﬁcation, and even though no details were known of what new features would be introduced in a later version of the language, XSLT 1.0 processors were required to behave in a particular way  called forward-compatibility mode  when the version attribute was set to a value other than «1.0». XSLT 2.0 similarly carries forward these provisions so that when the time comes, stylesheets that take advantage of new features in XSLT 3.0 or beyond will still be able to run under an XSLT 2.0 processor.  If you use facilities deﬁned in XSLT version 1.0 only, but want your stylesheet to run under both XSLT 1.0 and 2.0 processors, then you should specify «version = "1.0"», and every conformant XSLT processor will then handle the stylesheet correctly, provided  a  that you’re not using an XSLT 2.0 processor without support for backward-compatible mode, and  b  that you’re not using one of the few constructs that are incompatible even in backward-compatible mode. There is a list of these in Appendix C, and for the most part they are things that reasonable users would not do.  If you use facilities that are new in XSLT version 2.0, and you don’t need the stylesheet to run under an XSLT 1.0 processor, then it’s best to specify «version = "2.0"». If there are parts of the stylesheet that you haven’t converted from XSLT 1.0, where you want backward-compatible behavior to be invoked, then you can leave those parts in a separate stylesheet module that speciﬁes «version = "1.0"». It’s quite OK to mix versions like this. In fact, XSLT 2.0 allows you to specify the version attribute at any level of granularity, for example on an   element, or even on an element that encloses one small part of a template. If you use it on a literal result element, the attribute should be named xsl:version to distinguish it from user-deﬁned attributes. Bear in mind, however, that XSLT 1.0 processors allow the version attribute to appear only on the   element, or, as xsl:version, on a literal result element: it’s not permitted, for example, on  .  If you use facilities that are new in XSLT version 2.0, but you also want the stylesheet to run under an XSLT 1.0 processor, then you may need to write it in such a way that it deﬁnes fallback behavior to be invoked when running under 1.0. There are various techniques you can use to achieve this. You can use the element-available   function to test whether a particular XSLT instruction is implemented; you can use   to deﬁne what the processor should do if a construct is not available; or you can use the system-property   function  described in Chapter 13  to test which version of XSLT is supported, and execute different code, depending on the result. Whichever technique you use, you need  129   Stylesheet Structure  to ensure that those parts of the stylesheet that use XSLT 2.0 facilities are within the scope of an element that speciﬁes «version = "2.0"», otherwise an XSLT 1.0 processor will reject them at compile time.  The following sections look in more detail at the rules for backward-compatible and forward-compatible behavior.  Forward Compatibility in XSLT 1.0  At present, you are probably more concerned with migration of XSLT 1.0 stylesheets to XSLT 2.0 than with migration from 2.0 to 3.0, so it makes sense to look at the forward-compatibility rules as they were deﬁned in the XSLT 1.0 speciﬁcation. The rules have changed a little in XSLT 2.0 to reﬂect the introduction of the [xsl:]use-when attribute, so if you are reading this perhaps in 2012 and planning the transition to a new version 3.0, most of the advice should still be relevant, but you will be able to achieve most of what you need using [xsl:]use-when instead.  Forward-compatibility mode is invoked, as far as an XSLT 1.0 processor is concerned, by setting the version attribute on the   element to any value other than «1.0»  even, surprisingly, a value lower than «1.0» . For an XSLT 2.0 processor, forward-compatibility mode is invoked by a version attribute greater than «2.0».  This mode has static scope rather than dynamic scope: it affects the instructions in the stylesheet that are textually within the element that carries the relevant version attribute. It only affects the behavior of the compiler; it does not alter the way that any instruction or expression is evaluated at runtime.  In forward-compatible mode, the XSLT processor must assume that the stylesheet is using XSLT facilities deﬁned in a version of the standard that has been published since the software was released. The pro- cessor, of course, won’t know what to do with these constructs, but it must assume that the stylesheet author is using them deliberately. It treats them in much the same way as vendor extensions that it doesn’t understand:           It must report an error for XSLT elements it doesn’t understand only if they are actually evalu- ated, and if there is no child   instruction. It must ignore attributes whose name it doesn’t recognize. One particular consequence of this is that if the stylesheet speciﬁes «version = "2.0"», then an XSLT 1.0 processor will ignore any «use-when» attributes that it ﬁnds on XSLT elements. In XSLT 1.0, there were some additional rules for forward-compatible mode that have been dropped in 2.0:    If an XPath expression uses a function that’s not deﬁned in XPath 1.0, an XSLT 1.0 pro- cessor running in forward-compatible mode must report an error only if the function is actually called. You can avoid this error condition by using function-available   to test whether the function exists before calling it. Similarly if an XPath expression uses syntax that isn’t allowed in XPath 1.0, the processor must report an error only if the expression is actually evaluated. There’s also a provision in XSLT 1.0 that the processor should ignore optional attributes whose value isn’t recognized, for example  . It seems that many XSLT 1.0 processors ignored this rule, so it might be unwise to rely on it.        This behavior occurs only if the   element speciﬁes a version other than «1.0»  or for XSLT 2.0, a value greater than «2.0» . Forward-compatible mode can also be speciﬁed for a portion of a stylesheet by specifying the xsl:version attribute on any literal result element, and in the case of  130   Writing Portable Stylesheets  XSLT 2.0, by specifying the version attribute on any XSLT element. If forward-compatible mode is not enabled, then any use of an XSLT element, attribute, or function that isn’t in the version of XSLT that the processor supports, or any use of XPath syntax that isn’t in the corresponding XPath speciﬁcation, is an error and must be reported, whether it is actually executed or not.  If you specify «version = "1.0"» and then use XSLT 2.0 facilities such as  , then an XSLT 1.0 processor will reject this as an error. An XSLT 2.0 processor, however, will process your stylesheet successfully. An XSLT 2.0 processor when given a stylesheet that speciﬁes «version = "1.0"» is not expected to check that the stylesheet actually conforms to XSLT 1.0.  This is the theory. The rules for forward-compatibility mode were simpliﬁed in XSLT 2.0 after the XSL Working Group discovered that implementation of this feature in 1.0 processors was patchy. Altova’s 1.0 processor, for example, allows unknown functions but rejects unknown attributes; the Saxon XSLT 1.0 implementation accepts both of these but often rejects unknown values for known attributes.  Forward-compatible processing was speciﬁed to allow you to write a stylesheet that exploits facilities in version 2.0 while still behaving sensibly when run with an XSLT processor that supports version 1.0 only, or, at some point in the future, to use facilities in version 3.0 and still behave sensibly with an XSLT 2.0 processor. To achieve this, you can use the system-property   function  described on page 890, in Chapter 13  to discover which version of XSLT the processor implements, or which processor is being used. For example, you could write code such as the following:  3  S t y l e s h e e t S t r u c t u r e  <xsl:if test="system-property ’xsl:version’ =2.0 or  starts-with system-property ’xsl:vendor’ , ’xalan’ ">        Relying on the version number this returns is a rather crude mechanism: there are likely to be pro- cessors around that implement some of the new features in XSLT 2.0 but not yet all of them. Testing which vendor’s processor is in use is therefore handy for portability, especially when vendors have not kept strictly to the conformance rules. Another possibility is to use the element-available   and function-available   functions described later in the chapter: although these are primarily intended to allow you to test whether particular vendor or user-deﬁned extensions are available, they can also be used to test for the availability of speciﬁc XSLT instructions and functions in the core language.  Technically, a processor that implements some of the new XSLT 2.0 features but not all of them doesn’t conform either to XSLT 1.0 or to XSLT 2.0. But because many XSLT processors are developed incremen- tally with new releases every few weeks, you might well ﬁnd products that occupy this no man’s land. A product will presumably return «2.0» as the value of «system-property ‘xsl-version’ » when the vendor is conﬁdent that the product is ‘‘almost’’ conformant: past experience suggests that different vendors will interpret this in different ways.  There was a suggestion that one should ban processors from returning «2.0» unless they are fully conformant with the spec. But there is little point in such a prohibition, because a product that isn’t fully conformant with the spec is by deﬁnition doing things that the spec doesn’t allow.  Backward Compatibility in XSLT 2.0  For an XSLT 2.0 processor, you can invoke backward-compatibility mode by setting the version attribute on the   element  or on any other XSLT element  to the value «1.0». In fact, any value less than «2.0» will do. You can also set the xsl:version attribute on a literal result element in the same way.  131   Stylesheet Structure  Like the switch for forward-compatibility mode, this has static scope: it applies to all instructions and XPath expressions contained within the element where the version attribute is set. Unlike forward- compatibility mode, however, this mode affects the results of evaluating instructions and expressions, rather than being purely a compile-time switch.  XSLT 2.0 processors aren’t obliged to support backward-compatible processing. If they don’t, they must reject any attempt to specify «version = "1.0"» as an error. The reason the facility was made optional was that the language designers expected that the need for it would gradually decline as XSLT 1.0 receded into history. However, some vendors may decide that their customers don’t need the facility at all, as it’s not actually that difﬁcult to change the few constructs in a stylesheet whose behavior is different under XSLT 2.0.  How does backward compatibility actually affect the results of the stylesheet? One thing that it does not do is to say ‘‘process this according to the rules in the XSLT 1.0 speciﬁcation.’’ This wouldn’t work, because the parts of the stylesheet that use 2.0 facilities and the parts that use backward-compatibility mode need to work with the same data model, and the data model used by an XSLT 2.0 processor is the 2.0 data model, not the 1.0 data model. Instead, backward-compatibility mode changes the behavior of a small number of speciﬁc XSLT and XPath constructs, in quite speciﬁc ways.  Here is a checklist of the things that are done differently. The left-hand column indicates the normal XSLT 2.0  or XPath 2.0  behavior, the right-hand column the behavior in backward-compatibility mode.  First, the differences covered by the XSLT 2.0 speciﬁcation are given as follows.  2.0 Behavior When the value selected by the   instruction is a sequence, all the values are output, separated by spaces.  1.0 Behavior When the value selected by the   instruction is a sequence, the ﬁrst value is output, and the rest are ignored.  When the value produced by an expression in an attribute value template is a sequence, all the values are output, separated by spaces.  When the value produced by an expression in an attribute value template is a sequence, the ﬁrst value is output, and the rest are ignored.  When the value returned by the expression in the value attribute of   is a sequence, all the numbers in the sequence are output, according to the format described in the format attribute.  When the value of a sort key is a sequence containing more than one item, a type error is reported.  When the value returned by the expression in the value attribute of   is a sequence, the ﬁrst number in the sequence is output, and the rest are discarded.  When the value of a sort key is a sequence containing more than one item, the ﬁrst item is used as the sort key, and remaining items are ignored.  When   supplies a parameter that’s not deﬁned in the template being called, a static error is reported.  When   supplies a parameter that’s not deﬁned in the template being called, the extra parameter is ignored.  Values used as keys are compared as supplied, for example as numbers or dates.  When keys are used, values are always converted to strings before being compared.  When the ﬁrst element output is an   element in the XHTML namespace, the output method defaults to XHTML.  When the ﬁrst element output is an   element in the XHTML namespace, the output method defaults to XML.  132   Writing Portable Stylesheets  3  S t y l e s h e e t S t r u c t u r e  Backward-compatibility mode also affects the way that XPath expressions in the stylesheet are evaluated. Here are the differences.  2.0 Behavior When a function expects a single node or a single item as an argument, and the supplied value of the argument is a sequence containing more than one item, a type error is reported.  When a function expects a string or a number as an argument, and the supplied value is of the wrong type, a type error is reported.  When one of the operands to an operator such as « = » or « < » is a number, and the other is not, a type error is reported.  When one of the operands of an arithmetic operator such as «+» or «*» is a sequence containing more than one item, a type error is reported.  When the operands of an arithmetic operator such as «+» or «*» have types for which this operator is not deﬁned, a type error is reported.  Arithmetic may be carried out in integer, decimal, ﬂoat or double depending on the operands.  In an expression such as «A and B» or «A or B», the operands may be evaluated in either order.  1.0 Behavior When a function expects a single node or a single item as an argument, and the supplied value of the argument is a sequence containing more than one item, all items except the ﬁrst are ignored.  When a function expects a string or a number as an argument, and the supplied value is of the wrong type, the system converts the supplied value using the string   or number   function as appropriate.  When one of the operands to an operator such as « = » or « < » is a number, and the other is not, the non-numeric operand is converted to a number using the number   function.  When one of the operands of an arithmetic operator such as «+» or «*» is a sequence containing more than one item, all items except the ﬁrst are ignored.  When the operands of an arithmetic operator such as «+» or «*» have types for which this operator is not deﬁned, the supplied operands are converted to numbers using the number   function.  Arithmetic is always carried out in double-precision ﬂoating point.  In an expression such as «A and B» or «A or B», the ﬁrst operand is evaluated ﬁrst, and the other operand is not evaluated if not needed.  My personal preference when moving forward to a new software version or language version is to take the pain of the conversion all at once, and try to make the program or stylesheet look as if it had been written for the new version from the word go. Most of the changes listed above are to reﬂect the fact that XSLT 2.0 and XPath 2.0 no longer use the ‘‘ﬁrst node’’ rule when a sequence is supplied in a context where a singleton is needed. You can always get the effect of selecting the ﬁrst item in the sequence, by using the predicate «[1]». For example, if an XSLT 1.0 stylesheet contains the instruction:     then it should be changed to:     133   Stylesheet Structure  Extensibility  But doing the conversion all at once is a luxury that you can’t always afford. Backward-compatibility mode is there to allow you to spread the cost of making the changes by doing it gradually.                    Bitten by years of experience with proprietary vendor extensions to HTML, the W3 C committee respon- sible for XSLT took great care to allow vendor extensions in a tightly controlled way.  The extensibility mechanisms in XSLT are governed by several unstated design principles:  Namespaces are used to ensure that vendor extensions cannot clash with facilities in the stan- dard  including facilities introduced in future versions , or with extensions deﬁned by a different vendor. It is possible for an XSLT processor to recognize where extensions have been used, including extensions deﬁned by a different vendor, and to fail cleanly if it cannot implement those exten- sions. It is possible for the writer of a stylesheet to test whether particular extensions are available, and to deﬁne fallback behavior if they are not. For example, the stylesheet might be able to achieve the same effect in a different way, or it might make do without some special effect in the output.  The principal extension mechanisms are extension functions and extension instructions. However, it is also possible for vendors to deﬁne other kinds of extensions, or to provide mechanisms for users or third parties to do so. These include the following:  XSLT-deﬁned elements can have additional vendor-deﬁned attributes, provided they use a non-null namespace URI, and that they do not introduce nonconformant behavior for standard elements and attributes. For example, a vendor could add an attribute such as acme:debug to the   element, whose effect is to pause execution when the template is evaluated. But adding an attribute «acme:repeat = "2"» whose effect is to execute the template twice would be against the conformance rules. Vendors can deﬁne additional top-level elements; again provided that they use a non-null namespace URI, and that they do not cause nonconformant behavior for standard elements and attributes. An example of such an element is Microsoft’s   element, for deﬁning external functions in VBScript or JScript. Any processor that doesn’t recognize the namespace URI will ignore such top-level elements. Certain XSLT-deﬁned attributes have an open-ended set of values, where vendors have discre- tion on the range of values to be supported. Examples are the lang attribute of   and  , which provides language-dependent numbering and sorting; the method attribute of  , which deﬁnes how the result tree is output to a ﬁle; and the format attribute of  , which allows the vendor to provide additional numbering sequences beyond those deﬁned in the standard. The list of system properties supplied in the ﬁrst argument of the system-property   function is similarly open-ended.  Extension Functions  Extension functions provide a mechanism for extending the capabilities of XSLT by escaping into another language such as Java or JavaScript. The most usual reasons for doing this are as follows:        To improve performance To exploit system capabilities and services  134   Writing Portable Stylesheets        To reuse code that already exists in another language For convenience, as complex algorithms and computations can sometimes be verbose when writ- ten in XSLT  XSLT 2.0 allows functions to be written using the   declaration in a stylesheet  these are referred to as stylesheet functions, and they are not considered to be extension functions . This facility, together with the increase in the size of the core function library, greatly reduces the need to escape into other programming languages. However, it is still necessary if you need access to external resources or services from within the stylesheet.  The term extension function is used both for functions supplied by the vendor beyond the core functions deﬁned in the XSLT and XPath standards  those described in Chapter 13 of this book , and also for functions written by users and third parties.  The XSLT Recommendation allows extension functions to be called, but does not deﬁne how they are written, or how they should be bound to the stylesheet, or which languages should be supported. This means that it is quite difﬁcult to write extension functions that work with more than one vendor’s XSLT processor, even though in the Java world there are some conventions that several vendors have adopted.  3  S t y l e s h e e t S t r u c t u r e  In December 2000 the XSL Working Group in W3 C published a working draft for XSLT 1.1, which proposed detailed conventions for writing extension functions in Java and JavaScript. These proposals met a rather hostile reception, for a variety of reasons. The working draft was subsequently withdrawn, and the work hasn’t been taken forward. It is still available, if you are interested, at http:  www.w3 .org TR xslt11.  A function name in the XPath expression syntax is a QName, that is, a name with an optional namespace preﬁx. Under XSLT, the default namespace for functions  the namespace that is assumed when the func- tion name has no preﬁx  is always the namespace for the core function library. This function library includes the a repertoire of over a hundred functions deﬁned in the XPath 2.0 speciﬁcations, together with another twenty or so that are available only for use in XSLT. These are all described in Chapter 13 of this book. For example the core function not   can be invoked as follows:     If the function name has a preﬁx, the function can come from a number of other sources, depending on its namespace:           Functions in the XML Schema namespace http:  www.w3.org 2001 XMLSchema  tradition- ally associated with the preﬁx «xs», though «xsd» is also used  are used to construct values of built-in types. For example, the function call «xs:date ‘2004-02-29’ » is used to convert a string to an xs:date value. You can also use such functions to construct values of user-deﬁned types in an imported schema. These are referred to as constructor functions. XSLT vendors will often provide additional functions in their own namespace. For example, Saxon provides a number of functions in the namespace http:  saxon.sf.net . An example is saxon:evaluate  , which allows an XPath expression to be constructed dynamically from a string, and then executed. Third parties may also deﬁne function libraries. Of particular note is the EXSLT library at http:  www.exslt.org . This provides, among other things, a useful library of mathematical functions.  It also provides capabilities such as date and time handling, and regular expression processing, that have largely been overtaken by standard facilities in XSLT 2.0 and XPath 2.0.  This is primarily a library of function speciﬁcations, but implementations of the functions are  135   Stylesheet Structure           available for many popular XSLT processors, either from the XSLT vendor or from some other party. This ensures that you can use these functions in a stylesheet and still retain portability across XSLT processors. Note, however, that implementations of these functions are not gen- erally portable: an implementation of math:sqrt   that’s written for MSXML3 won’t work with Xalan, for example. You can write your own functions in XSLT, using the   declaration. These will be completely portable across XSLT 2.0 implementations, but, of course, they are restricted to things that can be coded in XSLT and XPath. These functions can be in any namespace apart from a small number of reserved namespaces. The namespaces that are reserved are the obvious ones such as the XSLT, XML, and XML Schema namespaces. The   element has an attribute override that can be set to «yes» or «no» to indi- cate whether the stylesheet function should override any vendor-deﬁned function of the same name. This is useful because there might be a portable cross-platform implementation of a func- tion such as math:sqrt   speciﬁed in a third-party library such as EXSLT, as well as a native implementation provided by the XSLT vendor. This attribute allows you to choose which imple- mentation is preferred. Finally, if the XSLT processor allows it, you may be able to write functions in an external pro- gramming language. Microsoft’s XSLT processors, for example, allow you to invoke functions in scripting languages such as JavaScript, and all the Java-based processors such as Xalan-J and Saxon allow you to invoke methods written in Java. Saxon also allows you to call functions writ- ten in XQuery, and when used on the .NET platform it allows access to methods deﬁned in any loadable .NET assembly, regardless of the source language. Other processors will tend to sup- port the native language of the processor: Xalan-C++ allows you to write extension functions in C++  you need to be aware that installing these is lot more complex than in the case of Java , while the 4XSLT processor  http:  4suite.org  focuses on Python, and Gestalt  http:  sf.net projects gestalt  on Eiffel.  The language speciﬁcation says nothing about how extension functions are written, and how they are linked to the stylesheet. The notes that follow are provided to give an indication of the kind of techniques you are likely to encounter.  In the case of Java, several processors have provided a mechanism in which the name of the Java class is contained in the namespace URI of the function, while the name of the method is represented by the local name. This mechanism means that all the information needed to identify and call the function is contained within the function name itself. For example, if you want to call the Java method random   in class java.lang.Math to obtain a random number between 0.0 and 1.0, you can write:  <xsl:variable name="random-number" select="Math:random  "  xmlns:Math="ext:  java.lang.Math" >  Unfortunately, each processor has slightly different rules for forming the namespace URI, as well as different rules for converting function arguments and results between Java classes and the XPath type system, so it won’t always be possible to make such calls portable between XSLT processors. But the example above works with both Saxon and Xalan.  This example calls a static method in Java, but most products also allow you to call Java constructors to return object instances, and then to call instance methods on those objects. To make this possible, the processor needs to extend the XPath type system to allow expressions to return values that are essentially wrappers around external Java objects. The XSLT and XPath speciﬁcations are written to explicitly permit this, though the details are left to the implementation.  136   For example, suppose you want to monitor the amount of free memory that is available, perhaps to diagnose an ‘‘out of memory’’ error in a stylesheet. You could do this by writing:  Writing Portable Stylesheets         Free memory:   <xsl:value-of select="rt:freeMemory rt:getRuntime   "  xmlns:rt="ext:  java.lang.Runtime" >  Again, this example is written to work with both Saxon and Xalan.  There are two extension function calls here: the call on getRuntime   calls a static method in the class java.lang.Runtime, which returns an instance of this class. The call on freeMemory   is an instance method in this class. By convention, instance methods are called by supplying the target instance as an extra ﬁrst parameter in the call.  Another technique that’s used for linking an extension function is to use a declaration in the stylesheet. Microsoft’s processors use this approach to bind JavaScript functions. Here is an example of a simple extension function implemented using this mechanism with Microsoft’s MSXML3 4 processor and an expression that calls it.  3  S t y l e s h e e t S t r u c t u r e  <xsl:stylesheet version="1.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" xmlns:ms="javascript:my-extensions">  <msxsl:script  xmlns:msxsl="urn:schemas-microsoft-com:xslt" language="VBScript" implements-prefix="ms"  > Function ToMillimetres inches   ToMillimetres = inches * 25.4  End Function                   This is not a particularly well-chosen example, because it could easily be coded in XSLT, and it’s gen- erally a good idea to stick to XSLT code unless there is a very good reason not to; but it illustrates how it’s done.  People sometimes get confused about the difference between script in the stylesheet, which is designed to be called as part of the transformation process, and script in the HTML output page, which is designed to be called during the display of the HTML in the browser. When the transformation is being done within the browser, and is perhaps invoked from script in another HTML page, it can be difﬁcult to keep the distinctions clearly in mind. I ﬁnd that it always helps in this environment to create a mock-up of the HTML page that you want to generate, test that it works as expected in the browser, and then start thinking about writing the XSLT code to generate it.  137   Stylesheet Structure  Sometimes you need to change conﬁguration ﬁles or environment variables, or call special methods in the processor’s API to make extension functions available; this is particularly true of products written in C or C++, which are less well suited to dynamic loading and linking.  In XSLT 2.0  this is a change from XSLT 1.0 , it is a static error if the stylesheet contains a call on a function that the compiler cannot locate. If you want to write code that is portable across processors offering different extension functions, you should therefore use the new use-when attribute to ensure that code containing such calls is not compiled unless the function is available. You can test whether a particular extension function is available by using the function-available   function. For example:     <xsl:value-of select="acme:moonshine $x "  use-when="function-available ’acme:moonshine’ " >  <xsl:text use-when="not function-available ’acme:moonshine’  "  >*** Sorry, moonshine is off today ***      Extension functions, because they are written in general-purpose programming languages, can have side effects. For example, they can write to databases, they can ask the user for input, or they can maintain counters. At one time Xalan provided a sample application to implement a counter using extension func- tions, effectively circumventing the restriction that XSLT variables cannot be modiﬁed in situ. Even the simple Math:random   function introduced earlier has side effects, because it returns different results each time it is called. However, extension functions with side effects should be used with great care, because the XSLT speciﬁcation doesn’t say what order things are supposed to happen in. For example, it doesn’t say whether a variable is evaluated when its declaration is ﬁrst encountered, or when its value is ﬁrst used. The more advanced XSLT processors adopt a lazy evaluation strategy in which  for example  variables are not evaluated until they are used. If extension functions with side effects are used to evalu- ate such variables, the results can be very surprising, because the order in which the extension functions are called becomes quite unpredictable. For example, if one function writes to a log ﬁle and another closes this ﬁle, you could ﬁnd that the log ﬁle is closed before it is written to. In fact, if a variable is never used, the extension function contained in its deﬁnition might not be evaluated at all.  Before writing an extension function, there are a number of alternatives you should consider:           Can the function be written in XSLT, using an   element? Is it possible to supply the required information as a stylesheet parameter? Generally this pro- vides a cleaner and more portable solution. Is it possible to get the result by calling the document   function, with a suitable URI? The URI passed to the document   function does not have to identify a static ﬁle; it could also invoke a web service. The Java JAXP API allows you to write a URIResolver class that intercepts the call on the document   function, so the URIResolver can return the results directly without needing to access any external resources. The System.Xml namespace in the Microsoft .NET framework has a similar capability, referred to as an XmlResolver.  Extension Instructions  An extension instruction is an element occurring within a sequence constructor that belongs to a name- space designated as an extension namespace. A namespace is designated as an extension namespace by including its namespace preﬁx in the extension-element-prefixes attribute of the   element, or in the xsl:extension-element-prefixes attribute of the element itself, or of a contain- ing extension element or literal result element. For example, Saxon provides an extension instruction  138   Writing Portable Stylesheets    to perform looping while a condition remains true. There is no standard XSLT construct for this because without side effects, a condition once true can never become false. But when used in conjunction with extension functions,   can be a useful addition.  Example: Using an Extension Instruction  The following stylesheet  sysprops.xsl  uses the   element to display the values of all the Java system properties. It does not use a source document, and can be run in Saxon by using the option -it:main on the command line.  3  S t y l e s h e e t S t r u c t u r e  Stylesheet  The stylesheet calls ﬁve methods in the Java class library:                System.getProperties   to get a Properties object containing all the system properties Properties.propertyNames   to get an Enumeration of the names of the system properties Enumeration.hasMoreElements   to determine whether there are more system properties to come Enumeration.nextElement   to get the next system property Properties.getProperty   to get the value of the system property with a given name. For this method, the Properties object is supplied as the ﬁrst argument, and the name of the required property in the second  <xsl:stylesheet version="2.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform"  >      <system-properties  xmlns:System="ext:  java.lang.System" xmlns:Properties="ext:  java.util.Properties" xmlns:Enumeration="ext:  java.util.Enumeration" xsl:exclude-result-prefixes="System Properties Enumeration">  <xsl:variable name="props"  <xsl:variable name="enum"  select="System:getProperties  " >  <saxon:while test="Enumeration:hasMoreElements $enum "  select="Properties:propertyNames $props " >  xsl:extension-element-prefixes="saxon" xmlns:saxon="http:  saxon.sf.net ">  <xsl:variable name="property-name"  select="Enumeration:nextElement $enum " >  <property name="{$property-name}"  value="{Properties:getProperty $props, $property-name }" >             139   Stylesheet Structure  Note that for this to work, «saxon» must be declared as an extension element preﬁx; otherwise,   would be interpreted as a literal result element and would be copied to the output. I’ve chosen to declare it with the smallest possible scope, to mark the parts of the stylesheet that are non-portable. The xsl:exclude-result-prefixes attribute is not strictly necessary, but it prevents the output being cluttered with unnecessary namespace declarations. Technically, this code is unsafe. Although it appears that the extension functions are read-only, the Enumeration object actually contains information about the current position in a sequence, and the call to nextElement   modiﬁes this information; it is therefore a func- tion call with side effects. In practice you can usually get away with such calls. However, as optimizers become more sophisticated, stylesheets that rely on side effects can sometimes work with one version of an XSLT processor, and fail with the next version. So you should use such constructs only when you have no alternative. A tip: with Saxon, the -TJ option on the command line can be useful for debugging. It gives you diagnostic output showing which Java classes were searched to ﬁnd methods match- ing the extension function calls. Another useful option is -explain, which shows how the optimizer has rearranged the execution plan.  As with extension functions, the term extension instruction covers both nonstandard instructions provided by the vendor and nonstandard instructions implemented by a user or third party. There is no require- ment that an XSLT implementation must allow users to deﬁne new extension instructions, only that it should behave in a particular way when it encounters extension instructions that it cannot process.  Where a product does allow users to implement extension instructions  two products that do so are Saxon and Xalan , the mechanisms and APIs involved are likely to be rather more complex than those for extension functions, and the task is not one to be undertaken lightly. However, extension instructions can offer capabilities that would be very hard to provide with extension functions alone.  If there is an extension instruction in a stylesheet, then all XSLT processors will recognize it as such, but in general some will be able to handle it and others won’t  because it is deﬁned by a different vendor . As with extension functions, the rule is that a processor mustn’t fail merely because an extension instruction is present; it should fail only if an attempt is made to evaluate it.  There are two mechanisms to allow stylesheet authors to test whether a particular extension instruction is available: the element-available   function and the   instruction.  The element-available   function works in a very similar way to function-available  . You can use it in a use-when attribute to include stylesheet code conditionally. In this case, however, you can also do the test at evaluation time if you prefer, because calls to unknown extension instructions don’t generate an error unless then are executed. For example:                140   Whitespace   *** Sorry, moonshine is off today ***         Note that at the time element-available   is called, the preﬁx for the extension element  here «acme»  must have been declared in a namespace declaration, but it does not need to have been designated as an extension element.  The   instruction  which is fully described on page 316, in Chapter 6  provides an alterna- tive way of specifying what should happen when an extension instruction is not available. The following example is equivalent to the previous one.  3  S t y l e s h e e t S t r u c t u r e  <acme:moonshine select="$x"  xmlns:acme="http:  acme.co.jp xslt" xsl:extension-element-prefixes="acme">           *** Sorry, moonshine is off today ***   When an extension instruction is evaluated, and the XSLT processor does not know what to do with it, it should evaluate any child   element. If there are several   children, it should evaluate them all. Only if there is no   element should it report an error. Con- versely, if the XSLT processor can evaluate the instruction, it should ignore any child   element.  The speciﬁcation doesn’t actually say that an extension instruction must allow an   child to be present. There are plenty of XSLT instructions that do not allow   as a child, for example,   and  . However, an extension instruction that didn’t allow   would certainly be against the spirit of the standard.  Vendor-deﬁned or user-deﬁned elements at the top level of the stylesheet are not technically extension instructions, because they don’t appear within a sequence constructor; therefore, the namespace they appear in does not need to be designated as an extension namespace.  Whitespace  Whitespace handling can be a considerable source of confusion. When the output of a stylesheet is HTML, you can get away without worrying too much about it, because except in some very speciﬁc contexts HTML generally treats any sequence of spaces and newlines in the same way as a single space. But with other output formats, getting spaces and newlines where you want them, and avoiding them where you don’t, can be crucial.  There are two issues:        Controlling which whitespace in the source document is signiﬁcant and therefore visible to the stylesheet. Controlling which whitespace in the stylesheet is signiﬁcant, because signiﬁcant whitespace in the stylesheet is likely to get copied to the output.  141   Stylesheet Structure  Whitespace is deﬁned as any sequence of the following four characters.  Unicode Codepoint  Character  Tab  Newline  Carriage Return  Space  x09  x0A  x0D  x20  The deﬁnition in XSLT is exactly the same as in XML itself. Other characters such as non-breaking-space  xA0 , which is familiar to HTML authors as the entity reference «&nbsp;», may use just as little black ink as these four, but they are not included in the deﬁnition.  There are some additional complications about the deﬁnition. Writing a character reference «&x20;» is in many ways exactly the same as hitting the space bar on the keyboard, but in some circumstances it behaves differently. The character reference «&x20;» will be treated as whitespace by the XSLT pro- cessor, but not by the XML parser, so you need to understand which rules are applied at which stage of processing.  The XML standard makes some attempt to distinguish between signiﬁcant and insigniﬁcant whites- pace. Whitespace in elements with element-only content is considered insigniﬁcant, whereas whitespace in elements that allow PCDATA content is signiﬁcant. However, the distinction depends on whether a validating parser is used or not, and in any case, the standard requires both kinds of whitespace to be notiﬁed to the application. XSLT 2.0  unlike 1.0  says that by default, if the source document is validated against a DTD or schema, insigniﬁcant whitespace  that is, whitespace in elements with element-only content  is ignored. In other cases, handling of whitespace can be controlled from the stylesheet  using the   and   declarations, which are fully described in Chapter 6 .  The ﬁrst stages in whitespace handling are the job of the XML parser and are done long before the XSLT processor gets to see the data. Remember that these apply both to source documents and to stylesheets:        End-of-line appearing in the textual content of an element is always normalized to a single new- line «x0A» character. This eliminates the differences between line endings on Unix, Windows, and Macintosh systems. XML 1.1 introduces additional rules to normalize the line endings found on IBM mainframes. The XML parser will normalize attribute values. A tab or newline will always be replaced by a single space, unless it is written as a character reference such as «&x09;» or «&x0A;»; for some types of attribute  anything except type CDATA , a validating XML parser will also remove leading and trailing whitespace, and normalize other sequences of whitespace to a single space character.  This attribute normalization can be signiﬁcant when the attribute in question is an XPath expression in the stylesheet. For example, suppose you want to test whether a string value contains a newline character. You can write this as follows:     142   It’s important to use the character reference «&x0A;» here, rather than a real newline, because a newline character would be converted to a space by the XML parser, and the expression would then actually test whether the supplied string contains a space.  What this means in practice is that if you want to be speciﬁc about whitespace characters, write them as character references; if you just want to use them as separators and padding, use the whitespace characters directly.  The XSLT speciﬁcation assumes that the XML parser will hand over all whitespace text nodes to the XSLT processor. However, the input to the XSLT processor is technically a tree, and the XSLT speciﬁcation claims no control over how this tree is built. If you use Microsoft’s MSXML, or Altova’s XSLT processor, then the default action of the parser while building the tree is to remove whitespace text nodes. If you want the parser to behave the way that the XSLT speciﬁcation expects, you must set conﬁguration options to make this happen; see the vendors’ documentation for details.  Whitespace  3  S t y l e s h e e t S t r u c t u r e  Once the XML parser has done its work, further manipulation of whitespace may be done by the schema processor. This is more likely to affect source documents than stylesheets, because there is little point in putting a stylesheet through a schema processor. For each simple data type, XML Schema deﬁnes whitespace handling  the so-called whitespace facet  as one of three options:           Preserve: All whitespace characters in the value are preserved. This option is used for the data type xs:string. Replace: Each newline, carriage return, and tab character is replaced by a single-space charac- ter. This option is used for the data type xs:normalizedString and types derived from it. Collapse: Leading and trailing whitespace is removed, and any internal sequence of whitespace characters is replaced by a single space. This option is used for all other data types  including those where internal whitespace is not actually allowed .  When source documents are processed using a schema, the XDM rules say that for attributes, and for elements with simple content  that is, elements that can’t have child elements , the typed value of the element or attribute is the value after whitespace normalization has been done according to the XML Schema rules for the particular data type. The string value of an element or attribute may either be the value as originally written or the value obtained by converting the typed value back to a string — implementations are allowed to choose either approach. In the latter case, insigniﬁcant leading and trailing whitespace may be lost. However, the string   function itself is almost the only thing that depends on the string value of a node; most expressions use the typed value.  Finally, the XSLT processor applies some processing of its own. By this time entity and character refer- ences have been expanded, so there is no difference between a space written as a space and one written as «&x20;»:        Adjacent text nodes are merged into a single text node  normalized in the terminology of the DOM . Then, if a text node consists entirely of whitespace, it is removed  or stripped  from the tree if the containing element is listed in an   deﬁnition in the stylesheet. The detailed  143   Stylesheet Structure  rules are more complex than this, and also take into account the presence of the xml:space attribute in the source document; see the   element on page 492 in Chapter 6 for details.  This process never removes whitespace characters that are adjacent to non-whitespace characters. For example, consider the following:      Abelard and Heloise   Some notes towards a family tree   Brenda M Cook     The story of Abelard and Heloise is best recalled nowadays from the stage drama of 1970 and it is perhaps inevitable that Diana Rigg stripping off for Keith Mitchell should be the most enduring image of this historic couple in some people’s minds.        Our textual analysis will focus entirely on the whitespace — the actual content of the piece is best ignored.  There are ﬁve whitespace-only text nodes in this fragment, one before each of the child elements  ,  ,  , and  , and another between the end of the   and the end of the  . The whitespace in these nodes is passed by the XML parser to the XSLT processor, and it is up to the stylesheet whether to take any notice of it or not. Typically, in this situation this whitespace is of no interest and it can be stripped from the tree by specifying <xsl:strip-space elements = "article" >.  The whitespace within the   cannot be removed by the same process. The newline charac- ters at the start and end of the abstract, and at the end of each line, are part of the text passed by the parser to the application, and it is not possible in the stylesheet to declare them as being irrelevant. If the   element is deﬁned in the schema as being of type xs:token  or a type derived from this , then the schema processor will remove the leading and trailing whitespace characters and convert the newlines into single spaces. But if it is of type xs:string, or if no schema processing is done, then all the spaces and newlines will be present in the tree model of the source document. What you can do is to call the normalize-space   function when processing these nodes on the source tree, which will have the same effect as schema processing for a type that speciﬁes the collapse option  that is, it will remove leading and trailing whitespace and replace all other sequences of one or more whitespace characters by a single space . The normalize-space   function is described in Chapter 13.  The processing done by a schema processor for data of type xs:normalizedString is to replace each newline, tab, and carriage return by a single space character. This is not the same as the processing done by the normalize-space   function in XPath. The term normalization, unfortunately, does not have a standard meaning.  So we can see that XSLT makes a very ﬁrm distinction between text nodes that consist of whitespace only, and those that hold something other than whitespace. A whitespace text node can exist only where there is nothing between two pieces of markup other than whitespace characters.  To take another example, consider the following document:      Prudence Flowers   144   Where are the whitespace nodes? Let’s look at it again, this time making the whitespace characters visible.  Whitespace  3  S t y l e s h e e t S t r u c t u r e  The newline and tab between   and   are not adjacent to any non-whitespace characters, so they constitute a whitespace node — so do the characters between   and  , and between   and  . However, most of the whitespace characters within the   element are in the same text node as non-whitespace characters, so they do not con- stitute a whitespace node. To make it even clearer, let’s highlight the whitespace characters in whitespace nodes and show the others as ordinary spaces.   Lloyds Bank     71 Lombard Street London, UK  EC3P 3BS          i → Prudence Flowers i → Lloyds Bank i → i →♦♦♦71 Lombard Streeti →♦♦♦London, UKi →♦♦♦ EC3P 3BS ♦i → i     i → Prudence Flowers i → Lloyds Bank i →   71 Lombard Street London, UK  EC3P 3BS ♦i  → >i    Why is all this relevant? As we’ve seen, the   element allows you to control what happens to whitespace nodes  those shown in the immediately preceding example , but it doesn’t let you do anything special with whitespace characters that appear in ordinary text nodes  those shown as ordinary spaces .  Most of the whitespace nodes in this example are immediate children of the   element, so they could be stripped by writing:     This would leave the remaining whitespace node intact  the one after the end tag of the   element . Whitespace nodes are retained on the source tree unless you ask for them to be stripped, either by using  , or by using some option provided by the XML parser or schema processor during the building of the tree.  145   Stylesheet Structure  The Effect of Stripping Whitespace Nodes  There are two main effects of stripping whitespace nodes, as done in the   element in the earlier example:    When you use   to process all the children of the   element, the whitespace nodes aren’t there, so they don’t get selected, which means they don’t get copied to the result tree. If they had been left on the source tree, then by default they would be copied to the result tree.    When you use   or the position   or count   functions to count nodes, the  whitespace nodes aren’t there, so they aren’t counted. If you had left the whitespace nodes on the tree, then the  ,  , and   elements would be nodes 2, 4, and 6 instead of 1, 2, and 3.  There are cases where it’s important to keep the whitespace nodes. Consider the following.    Edited by  James Clark ♦ jjc@jclark.com     The diamond represents a space character that needs to be preserved, but because it is not adjacent to any other text, it would be eligible for stripping. In fact, whitespace is nearly always signiﬁcant in elements that have mixed content  that is, elements that have both element and text nodes as children . Figure 18-3 on page 1005 shows a live example of what goes wrong when such spaces are stripped.  If you want to strip all the whitespace nodes from the source tree, you can write:     If you want to strip all the whitespace nodes except those within certain named elements, you can write:       If any elements in the document  either the source document or the stylesheet  use the XML-deﬁned attribute «xml:space = "preserve"», this takes precedence over these rules: whitespace nodes in that element, and in all its descendants, will be kept on the tree unless the attribute is canceled on a descendant element by specifying «xml:space = "default"». This allows you to control on a per-instance basis whether whitespace is kept, whereas   controls it at the element-type level.  Whitespace Nodes in the Stylesheet  For the stylesheet itself, whitespace nodes are all stripped, with two exceptions, namely whitespace within an   element, and whitespace controlled by the attribute «xml:space = "preserve"». If you explicitly want to copy a whitespace text node from the stylesheet to the result tree, write it within an   element, like this:     &xA;     The only reason for using «&xA;» here rather than an actual newline is that it’s more clearly visible to the reader; it’s also less likely to be accidentally turned into a newline followed by tabs or spaces. Writing  146   Whitespace  3  S t y l e s h e e t S t r u c t u r e  the whitespace as a character reference doesn’t stop it being treated as whitespace by XSLT, because the character references will have been expanded by the XML parser before the XSLT processor gets to see them.  Another way of coding the previous fragment in XSLT 2.0 is to write:  <xsl:value-of select="address-line[position   = 1 to 2]"  separator="&xA;" >  You can also cause whitespace text nodes in the stylesheet to be retained by using the option «xml:space = "preserve"». Although this is deﬁned in the XML speciﬁcation, its deﬁned effect is to advise the appli- cation that whitespace is signiﬁcant, and XSLT  which is the application in this case  will respect this. In XSLT 1.0, this sometimes caused problems because certain elements, such as   and  , do not allow text nodes as children, even whitespace-only text nodes. Many processors, however, were forgiving on this. XSLT 2.0 has clariﬁed that in situations where text nodes are not allowed, a whitespace-only text node is now stripped, despite the xml:space attribute.  However, an element that must always be empty, such as  , must be completely empty; whitespace-only text nodes are not allowed within these elements.   Despite this clariﬁcation of the rules, I wouldn’t normally recommend using the xml:space attribute in a stylesheet, but if there are large chunks of existing XML that you want to copy into the stylesheet verbatim, the technique can be useful.  Solving Whitespace Problems  There are two typical problems with whitespace in the output: too much of it, or too little.  If you are generating HTML, a bit of extra whitespace usually doesn’t matter, though there are some places where it can slightly distort the layout of your page. With some text formats, however  a classic example is comma-separated values  you need to be very careful to output whitespace in exactly the right places.  If you are getting too much whitespace, there are three possible places it can be coming from:  Too Much Whitespace  The source document The stylesheet Output indentation              First ensure that you set «indent = "no"» on the   element, to eliminate the last of these possibilities.  If the output whitespace is adjacent to text, then it probably comes from the same place as that text.  If this text comes from the stylesheet, use   to control more precisely what is output. For example, the following code outputs a comma between the items in a list, but it also outputs a newline after the comma, because the newline is part of the same text node as the comma:     ,     147   Stylesheet Structure        If you want the comma but not the newline, change this so that the newline is in a text node of its own, and is therefore stripped.      ,      If the text comes from the source document, use normalize-space   to trim leading and trailing spaces from the text before outputting it.  If the offending whitespace is between tags in the output, then it probably comes from whitespace nodes in the source tree that have not been stripped, and the remedy is to add an   element to the stylesheet.  Too Little Whitespace  If you want whitespace in the output and aren’t getting it, use   to generate it at the appro- priate point. For example, the following code will output the lines of a poem in HTML, with each line of the poem being shown on a new line:            This will display perfectly correctly in the browser, but if you want to view the HTML in a text editor, it will be difﬁcult because everything goes on a single line. It would be useful to start a newline after each   element — you can do this as follows:        &xa;      Another trick I have used to achieve this is to exploit the fact that the non-breaking-space character  xA0 , although invisible, is not classiﬁed as whitespace. So you can achieve the required effect by writing:       &xa0;     This works because the newline after the «&xa0;» is now part of a non-whitespace node.  Summar y  148  The purpose of this chapter was to study the overall structure of a stylesheet, before going into the detailed speciﬁcation of each element in Chapter 6. We’ve now covered the following:        How a stylesheet program can be made up of one or more stylesheet modules, linked together with   and   declarations. I described how the concept of import precedence allows one stylesheet to override deﬁnitions in those it imports. The    or    element, which is the outermost element of most stylesheet modules.   Summary                    The   processing instruction, which can be used to link from a source doc- ument to its associated stylesheets, and which allows a stylesheet to be embedded directly in the source document whose style it deﬁnes. The declarations found in the stylesheet, that is, the immediate children of the   or   element, including the ability to have user-deﬁned or vendor-deﬁned elements here. How the   and   elements can be omitted to make an XSLT stylesheet look more like the simple template languages that some users may be familiar with. The idea of a sequence constructor, a structure that occurs throughout a stylesheet, which is a sequence containing text nodes and literal result elements to be copied to the result tree, and instructions and extension elements to be executed. This led naturally to a discussion of literal result elements and of attribute value templates, which are used to deﬁne variable attributes not only of literal result elements but of certain XSLT elements as well. How the W3 C standards committee has tried to ensure that the speciﬁcation can be extended, both by vendors and by W3 C itself, without adversely affecting the portability of stylesheets. You saw how to make a stylesheet work even if it uses proprietary extension functions and extension elements that may not be available in all implementations. How XSLT stylesheets handle whitespace in the source document, in the stylesheet itself and in the result tree.  3  S t y l e s h e e t S t r u c t u r e  The next chapter describes how to use XSLT stylesheets together with an XML Schema for the source and or result documents. If you are not interested in using schemas, you can probably skip that chapter and move straight to Chapter 5, which gives detailed information about the data types available in the XDM model and the ways in which you can use them.  149    4  S t y l e s h e e t s  a n d S c h e m a s  Stylesheets and Schemas  One of the most important innovations in XSLT 2.0 is that stylesheets can take advantage of the schemas you have deﬁned for your input and output documents. This chapter explores how this works.  This feature is an optional part of XSLT 2.0, in two signiﬁcant ways:        Firstly, an XSLT 2.0 processor isn’t required to implement this part of the standard. A proces- sor that offers schema support is called a schema-aware processor; one that does not is referred to as a basic processor. Secondly, even if the XSLT 2.0 processor you are using is a schema-aware processor, you can still process input documents, and produce output documents, for which there is no schema available.  There is no space in this book for a complete description of XML Schema. If you want to start writing schemas, I would recommend you read XML Schema by Eric van der Vlist  O’Reilly & Associates, 2002  or Deﬁnitive XML Schema by Priscilla Walmsley  Prentice Hall, 2002 . XML Schema is a large and compli- cated speciﬁcation, certainly as large as XSLT itself. However, it’s possible that you are not writing your own schemas, but writing stylesheets designed to work with a schema that someone else has already written. If this is the case, I hope you will ﬁnd the short overview of XML Schema in this chapter a useful introduction.  XML Schema: An Over view  The primary purpose of an XML Schema is to enable documents to be validated: they deﬁne a set of rules that XML documents must conform to, and enable documents to be checked against these rules. This means that organizations using XML to exchange invoices and purchase orders can agree on a schema deﬁning the rules for these messages, and both parties can validate the messages against the schema to ensure that they are right. So the schema, in effect, deﬁnes a type of document, and this is why schemas are central to the type system of XSLT.  In fact, the designers of XML Schema were more ambitious than this. They realized that rather than simply giving a ‘‘yes’’ or ‘‘no’’ answer, processing a document against a schema could make the applica- tion’s life easier by attaching labels to the validated document indicating, for each element and attribute in the document, which schema deﬁnitions it was validated against. In the language of XML Schema,   Stylesheets and Schemas  this document with validation labels is called a Post Schema Validation Infoset, or PSVI. The XDM data model used by XSLT and XPath is based on the PSVI, but it only retains a subset of the information in the PSVI; most importantly, the type annotations attached to element and attribute nodes.  We begin by looking at the kinds of types that can be deﬁned in XML Schema, starting with simple types and moving on to progressively more complex types.  Simple Type Deﬁnitions  Let’s suppose that many of your messages refer to part numbers, and that part numbers have a particular format such as ABC12345. You can start by deﬁning this as a type in the schema:                Part number is a simple type because it doesn’t have any internal node structure  that is, it doesn’t contain any elements or attributes . I have deﬁned it by restriction from xs:token, which is one of the built-in types that come for free with XML Schema. I could have chosen to base the type on xs:string, but xs:token is probably better because with xs:string, leading and trailing whitespace is considered signiﬁcant, whereas with xs:token, it gets stripped automatically before the validation takes place. The particular restriction in this case is that the value must match the regular expression given in the   element. This regular expression says that the value must consist of exactly three letters in the range A to Z, followed by exactly ﬁve digits.  Having deﬁned this type, you can now refer to it in deﬁnitions of elements and attributes. For example, you can deﬁne the element:     This allows documents to contain   elements whose content conforms to the rules for the type called part-number. Of course, you can also deﬁne other elements that have the same type, for example:     Note the distinction between the name of an element and its type. Many element declarations in a schema  declarations that deﬁne elements with different names  can refer to the same type deﬁnition, if the rules for validating their content are the same. It’s also permitted, though I won’t go into the detail just yet, to use the same element name at different places within a document with different type deﬁnitions.  You can also use the same type deﬁnition in an attribute, for example:     You can declare variables and parameters in a stylesheet whose values must be elements or attributes of a particular type. Once a document has been validated using this schema, elements that have been validated against the declarations of part and subpart given above, and attributes that have been vali- dated against the declaration named part-nr, will carry the type annotation part-number, and they can be assigned to variables such as:     152   XML Schema: An Overview     The variable part1 is allowed to contain any element node that has the type annotation part-number. If further types have been deﬁned as restricted subtypes of part-number  for example, Boeing-part- number , these can be assigned to the variable too. The «*» indicates that we are not concerned with the name of the element or attribute, but only with its type.  There are actually three varieties of simple types that you can deﬁne in XML Schema: atomic types, list types, and union types. Atomic types are treated specially in the XPath XSLT type system, because values of an atomic type  called, naturally enough, atomic values  can be manipulated as freestanding items, independently of any node. Like integers, booleans, and strings, part numbers as deﬁned above are atomic values, and you can hold a part number or a sequence of part numbers directly in a variable, without creating any node to contain it. For example, the following declaration deﬁnes a variable whose value is a sequence of three part numbers:  4  S t y l e s h e e t s  a n d S c h e m a s  <xsl:variable name="part" as="part-number*"  select="for $p in  ’WZH94623’, ’BYF67253’, ’PRG83692’   return $p cast as part-number" >  Simple types in XML Schema are not the same thing as atomic types in the XPath data model. This is because a simple type can also allow a sequence of values. For example, it is possible to deﬁne the following simple type:                                         There are actually two type deﬁnitions here. The inner type is anonymous, because the   element has no name attribute. It deﬁnes an atomic value, which must be an xs:NCName, and more specif- ically, must be one of the values «red», «orange», «yellow», «green», «blue», «indigo», or «violet». The outer type is a named type  which means it can be referenced from elsewhere in the schema , and it deﬁnes a list type whose individual items must conform to the inner type.  This type therefore allows values such as «red green blue», or «violet yellow» or even «red red red». The values are written in textual XML as a list of color names separated by spaces, but once the document has been through schema validation, the typed value of an element with this type will be a sequence of xs:NCName values.  The term simple type in XML Schema rules out types involving multiple attribute or element nodes, but it does allow composite values consisting of a sequence of atomic values.  153   Stylesheets and Schemas  Elements with Attributes and Simple Content  One thing that might occur quite frequently in an invoice or purchase order is an amount in money: there might be elements such as:         50.00    1890.00   What these two elements have in common is that they have a currency attribute  with a particular range of allowed values  and content that is a decimal number. This is an example of a complex type. I deﬁned part-number as a simple type because it didn’t involve any nodes. The money-amount type is a complex type, because it involves a decimal number and an attribute value. You can deﬁne this type as follows:                                            Here I have deﬁned two new types in the schema, both of which are named. The ﬁrst deﬁnes the type of the currency attribute. I could have used the same name for the attribute and its type, but many people prefer to keep the names of types distinct from those of elements and attributes, to avoid confusing the two. In this case I’ve chosen to deﬁne it  again  as a subtype of xs:token, but this time restricting the value to be one of four particular world currencies. In practice, of course, the list might be much longer. The currency-type is again a simple type, because it’s just a value; it doesn’t deﬁne any nodes.  The second deﬁnition is a complex type, because it deﬁnes two things. It’s the type of an element that has a currency attribute conforming to the deﬁnition of currency-type, and has content  the text between the element start and end tags  that is a decimal number, indicated by the reference to the built-in type xs:decimal. This particular kind of complex type is called a complex type with simple content, which means that elements of this type can have attributes, but they cannot have child elements.  Again, the name of the type is quite distinct from the names of the elements that conform to this type. You can declare the two example elements above in the schema as follows:       But although the type deﬁnition doesn’t constrain the element name, it does constrain the name of the attribute, which must be «currency». If the type deﬁnition deﬁned child elements, it would also constrain these child elements to have particular names.  154   XML Schema: An Overview  In an XSLT 2.0 stylesheet, you can write a template rule for processing elements of this type, which means that all the logic for formatting money amounts can go in one place. For example, you could write:           This would output the example   element as «EUR 1,890.00».  The format-number   function is described in Chapter 13, on page 788 . The beauty of such a template rule is that it is highly reusable; however much the schema is extended to include new elements that hold amounts of money, this rule can be used to display them.  Elements with Mixed Content  The type of an element that can contain child elements is called a complex type with complex content. Such types essentially fall into three categories, called empty content, mixed content, and element-only content. Mixed content allows intermingled text and child elements, and is often found in narrative XML documents, allowing markup such as:   The population of  London  reached   5,572,000  in  1891 , and had risen further to  7,160,000  by  1911 .   4  S t y l e s h e e t s  a n d S c h e m a s  The type of this element could be declared in a schema as:                     In practice, the list of permitted child elements would probably be much longer than this, and a common technique is to deﬁne substitution groups, which allow a list of such elements to be referred to by a single name.  Narrative documents tend to be less constrained than documents holding structured data such as pur- chase orders and invoices, and while schema validation is still very useful, the type annotations generated as a result of validation aren’t generally so important when the time comes to process the data using XSLT; the names of the elements are usually more signiﬁcant than their types. However, there is plenty of potential for using the types, especially if the schema is designed with this in mind.  When schemas are used primarily for validation, the tendency is to think of types in terms of the form that values assume. For example, it is natural to deﬁne the element    as used in the example above  as a type derived from xs:token by restriction, because the names of cities are strings, perhaps consisting of multiple words, in which spaces are not signiﬁcant. Once types start to be used for processing information  which is what you are doing when you use XSLT , it’s also useful to think about what the value actually means. The content of the   element is not just a string of characters, it is the name of a geographical place, a place that has a location on the Earth’s surface, that is in a particular country, and that may ﬁgure in postal addresses. If you have other similar elements such as  ,  , and  , it might be a good idea to deﬁne a single type for all of them. Even if this  155   Stylesheets and Schemas  type doesn’t have any particular purpose for validation, because it doesn’t deﬁne any extra constraints on the content, it can potentially be useful when writing XSLT templates because it groups a number of elements that belong together semantically.  Elements with Element-Only Content  This category covers most of the ‘‘wrapper’’ elements that are found in data-oriented XML. A typical example is the outer   element in a structure such as:         Michael   Howard   Kay      1951-10-11   Hannover      The schema for this might be:                                                          There are a number of ways these deﬁnitions could have been written. In the so-called Russian Doll style, the types would be deﬁned inline within the element declarations, rather than being given separate names of their own. The schema could have been written using more top-level element declarations, for example the   element could have been described at a top level. When you use a schema for validation, these design decisions mainly affect your ability to reuse deﬁnitions later when the schema changes. When you use a schema to describe types that can be referenced in XSLT stylesheets, however, they also affect the ease of writing the stylesheet.  In choosing the representation of the schema shown above, I made a number of implicit assumptions:  156   XML Schema: An Overview              It’s quite likely that there will be other elements with the same structure as  , or with an extension of this structure: perhaps not at the moment, but at some time in the future. Examples of such elements might be   or  . Therefore, it’s worth describing the element and its type separately. Similarly, personal names are likely to appear in a number of different places. Elements with this type won’t always be called  , so it’s a good idea to create a type deﬁnition that can be referenced from any element. Not every element called   will be a personal name, the same tag might also be used  even in the same namespace  for other purposes. If I were conﬁdent that the tag would always be used for personal names, then I would probably have made it the subject of a top-level element decla- ration, rather than deﬁning it inline within the   element. The elements at the leaves of the tree  those with simple types  such as  ,  ,  , and   are probably best deﬁned using local element declarations rather than top-level declarations. Even if they are used in more than one container element, there is relatively little to be gained by pulling the element declarations out to the top level. The important thing is that if any of them have a user-deﬁned type  which isn’t the case in this example , then the user-deﬁned types are deﬁned using top-level   decla- rations. This is what I have done for the id attribute  which is deﬁned as a subtype of xs:ID, forcing values to be unique within any XML document , but I chose not to do the same for the leaf elements.  4  S t y l e s h e e t s  a n d S c h e m a s  XSLT 2.0 allows you to validate elements against either a global element declaration or a global type deﬁnition, so you’ll be able to validate an element provided that either the element declaration or the type deﬁnition is global. If you’re planning to use XQuery with your schema, however, it’s worth bearing in mind that XQuery doesn’t allow validation against a type deﬁnition, so validation is only possible if the element declaration is global. It’s useful to be able to validate individual elements because you can then assign the elements to variables or function parameters that require an element of a particular type. The alternative is to defer validation until a complete document has been constructed.  Deﬁning a Type Hierarchy  Using top-level type deﬁnitions is very handy when you have many different elements using the same type deﬁnitions. I’ve come across an example of this in action when handling ﬁles containing genealogi- cal data. A lot of this data is concerned with recording events: events such as births, baptisms, marriages, deaths, and burials, but also many other miscellaneous events such as a mention in a newspaper, enroll- ment at a school or university, starting a new job, receiving a military honor, and so on. Traditionally, this data is recorded using a ﬁle format called GEDCOM, which predates XML by many years, but can very easily be translated directly into XML and manipulated using XSLT, as we will see in Chapter 19.  The GEDCOM speciﬁcation deﬁnes about 30 kinds of event such as BIRTH, DEATH, and MARRIAGE, and then provides a general catch-all EVENT record for anything else you might want to keep information about. All these records have a common structure: they allow information about the date and place of the event, the sources of information about the event, the participants and witnesses, and so on. In other words, they are all different elements with the same type.  In XSLT 1.0, the only way of referring to elements was by name. This meant that if you wanted to write a template rule to process any kind of event, you had to know all the element names representing events, and write a union expression of the form «BIRTHDEATHMARRIAGE...» to select them. This is tedious to say the least, and it is also inextensible: when new kinds of event are introduced, the stylesheet stops working.  157   Stylesheets and Schemas  XSLT 2.0 introduces the ability to refer to elements by type: you can now write a template that speci- ﬁes «match = "element *, EVENT "», which matches all elements of type EVENT. The «*» indicates that you don’t care what the name of the element is, you are interested only in its type. This is both more convenient and more ﬂexible than listing all the different kinds of event by name.  You can go beyond this, and deﬁne a type hierarchy. In a genealogical database, in addition to recording events in a person’s life, you can also record properties of a person such as their occupation, religion, state of health, or  if you want  their height or eye color. GEDCOM hasn’t modeled these particularly well; it treats them as events, which isn’t a particularly good ﬁt. They have a lot in common with events, in that you want to record the evidence for the information, but they tend to be independent of place and to be applicable over some extended period of a person’s life. So in an ideal world we would probably model these using a separate type called, say, ATTRIBUTE  not to be confused with XML attributes, of course . The things that EVENT and ATTRIBUTE have in common could be deﬁned in a third type from which both of these inherit: let’s call this DETAIL. Then in an XPath expression, I can ﬁnd all the events and all the attributes for a person with the single expression «element *, DETAIL ».  Sometimes you get the chance to write a schema with schema-aware XSLT and XQuery processing in mind. More often, however, you have to work with a schema that already exists, and which was written primarily for validation. In this case, it might not contain any very useful type hierarchies. But there’s another device in XML Schema that allows elements to be referred to generically, namely substitution groups, and we’ll look at what these have to offer in the next section.  Substitution Groups  The type of an element or attribute tells you what can appear inside the content of the element or attribute. Substitution groups, by contrast, classify elements according to where they can appear.  There is a schema for XSLT 2.0 stylesheets published as part of the XSLT Recommendation  see http:   www.w3.org 2007 schema-for-xslt20.xsd . Let’s look at how this schema uses substitution groups.  Firstly, the schema deﬁnes a type that is applicable to any XSLT-deﬁned element, and that simply declares the standard attributes that can appear on any element:         <xs:attribute name="extension-element-prefixes"  type="xsl:prefix-list-or-all" >            There’s a good mix of features used to deﬁne these attributes. Some attributes use built-in types  xs:anyURI , while some use user-deﬁned types deﬁned elsewhere in the schema  xsl:prefixes . The   at the end says that XSLT elements can contain attributes from a different name- space, which are laxly validated  that is, the processor will validate the attribute if and only if a schema deﬁnition is available for it.   Every XSLT element except the   element allows a standard version attribute  the   element is different because its version attribute is deﬁned for a different purpose and has a different type . So the schema deﬁnes another type that adds this attribute:  158   XML Schema: An Overview  4  S t y l e s h e e t s  a n d S c h e m a s                       The XSLT speciﬁcation classiﬁes many XSLT elements as instructions. This is not a structural distinc- tion based on the attributes or content model of these elements  which varies widely , it is a distinction based on the way they are used. In particular, instruction elements are interchangeable in terms of where they may appear in a stylesheet: If you can use one instruction in a particular context, you can use any instruction. This calls for deﬁning a substitution group:  <xs:element name="instruction"  type="xsl:versioned-element-type" abstract="true" >  Note that although the substitution group is deﬁned using an element declaration, it does not deﬁne a real element, because it speciﬁes «abstract = "true"». This means that an actual XSLT stylesheet will never contain an element called  . It is a ﬁctional element that exists only so that others can be substituted for it.  What this declaration does say is that every element in the substitution group for   must be deﬁned with a type that is derived from xsl:versioned-element-type. That is, every XSLT instruction allows the attributes default-collation, exclude-result-prefixes, extension-element- prefixes, use-when, xpath-default-namespace, and version, as well as any namespace-preﬁxed attribute. This is in fact the only thing that XSLT instructions have in common with each other, as far as their permitted content is concerned.  Individual instructions are now deﬁned as members of this substitution group. Here is a simple example, the declaration of the   element:                             This shows that the   element is a member of the substitution group whose head is the abstract   element. It also tells us that the content model of the element  that is, its type  is deﬁned as an extension of the type xsl:sequence-constructor, the extension being to require a test attribute whose value is of type xsl:expression — this is a simple type deﬁned later in the same schema, representing an XPath expression that may appear as the content of this attribute.  The type xsl:sequence-constructor is used for all XSLT elements whose permitted content is a sequence constructor. A sequence constructor is simply a sequence of zero or more XSLT instructions, deﬁned like this:  159   Stylesheets and Schemas           <xs:group ref="xsl:sequence-constructor-group" minOccurs="0"  maxOccurs="unbounded" >                              The ﬁrst deﬁnition says that the xsl:sequence-constructor type extends xsl:versioned-element- type, whose deﬁnition we gave earlier. If it didn’t extend this type, we wouldn’t be allowed to put   in the substitution group of  . It also says that the content of a sequence constructor consists of zero or more elements, each of which must be chosen from those in the group sequence-contructor-group. The second deﬁnition says that every element in sequence-contructor- group is either an    which implicitly allows any element in the substitution group for  , including of course   , or an  .  The   element is not deﬁned as a member of the substitution group because it can be used in two different contexts: either as an instruction or as a top-level declaration in a stylesheet. This is one of the drawbacks of substitution groups: they can’t overlap  this limitation disappears in XML Schema 1.1 . The schema deﬁnes all the elements that can act as declarations in a very similar way, using a substitution group headed by an abstract   element. It’s not possible in XML Schema 1.0 for the same element,  , to appear in both substitution groups, so it has been deﬁned in neither, and needs to be treated as a special case.  If you need to use XSLT to access an XSLT stylesheet  which isn’t as obscure a requirement as it may seem; there are many applications for this , then the classiﬁcation of elements as instructions or declarations can be very useful. For example, you can match all the instructions that have an attribute in the Saxon namespace with the template rule:     assuming that the namespace preﬁx «saxon» has been declared appropriately. Here the expression «schema-element xsl:instruction » selects elements that are either named   or are in the substitution group with   as its head element, and the predicate «[@saxon:*]» is a ﬁlter that selects only those elements that have an attribute in the «saxon» namespace.  The penalty of choosing a real schema for our example is that we have to live with its complications. As we saw earlier, the   element isn’t part of this substitution group. So we might have to extend the query to handle   elements as well. We can do this by writing:  <xsl:template match=  " schema-element xsl:instruction schema-element xsl:variable  [@saxon:*]">  160   Declaring Types in XSLT  A detailed explanation of the syntax used by this match pattern can be found in Chapter 12.  So, to sum up this section, substitution groups are not only a very convenient mechanism for referring to a number of elements that can be substituted for each other in the schema, but they can also provide a handy way of referring to a group of elements in XSLT match patterns. But until XML Schema 1.1 comes along they do have one limitation, which is that elements can only belong directly to one substitution group  or to put it another way, substitution groups must be properly nested; they cannot overlap .  At this point I will ﬁnish the lightning tour of XML Schema. The rest of the chapter builds on this under- standing to show how the types deﬁned in an XML Schema can be used in a stylesheet.  Declaring Types in XSLT  As we saw in Chapter 3, XSLT 2.0 allows you to deﬁne the type of a variable. Similarly, when you write functions or templates, you can declare the type of each parameter, and also the type of the returned value.  Here is an example of a function that takes a string as its parameter and returns an integer as its result:  4  S t y l e s h e e t s  a n d S c h e m a s       <xsl:sequence select="max  string-length upper-case $in  ,  string-length lower-case $in    " >     And here’s a named template that expects either an element node or nothing as its parameter, and returns either a text node or nothing as its result:             You don’t have to include type declarations in the stylesheet: If you leave out the «as» attribute, then as with XSLT 1.0, any type of value will be accepted. However, I think it’s a good software engineering practice always to declare the types as precisely as you can. The type declarations serve two purposes:        The XSLT processor has extra information about the permitted values of the variables or parame- ters, and it can use this information to generate more efﬁcient code. The processor will check  at compile time, and if necessary at runtime  that the values supplied for a variable or parameter match the declared types, and will report an error if not. This can detect many errors in your code, errors that might otherwise have led to the stylesheet produc- ing incorrect output. As a general rule, the sooner an error is detected, the easier it is to ﬁnd the cause and correct it, so deﬁning types in this way leads to faster debugging. I have heard stories of users upgrading their stylesheets from XSLT 1.0 to XSLT 2.0 and ﬁnding that the extra type checking revealed errors that had been causing the stylesheet to produce incorrect output which no one had ever noticed.  These type declarations are written using the «as» attribute of elements such as  ,  ,  , and  . You don’t need to use a schema-aware processor to use the «as» attribute, because many of the types you can declare  including those in the two examples above  are built-in types, rather than types that need to be deﬁned in your schema. For example, if a function parameter is required to be an integer, you can declare it like this:  161   Stylesheets and Schemas     which will work whether or not your XSLT processor is schema-aware, and whether or not your source documents are validated using an XML Schema.  The rules for what you can write in the «as» attribute are deﬁned in XPath 2.0, not in XSLT itself. The construct that appears here is called a sequence type descriptor, and it is explained in detail in Chapter 11. Here are some examples of sequence type descriptors that you can use with any XSLT processor, whether or not it is schema-aware: Construct  xs:integer  xs:integer *  xs:string ?  xs:date  node    node   *  element    attribute   +  document-node    Meaning An atomic value labeled as an integer  A sequence of zero or more integers  Either a string, or an empty sequence  A date  Any node in a tree  Any element node  Any sequence of zero or more nodes, of any kind  Any sequence of one or more attribute nodes  Any document node  xs:anyAtomicType  An atomic value of any type  for example integer, string, and so on   The types that are available in a basic XSLT processor are shown in Figure 4-1, which also shows where they appear in the type hierarchy:  item    node    atomic types   xs:anyAtomicType   document-node    boolean  date  gYear  duration  double  string  dateTime  gYearMonth  anyURI  time  gMonth  float  decimal  QName  hexBinary  base64Binary  gMonthDay  integer  gDay  dayTimeDuration  yearMonthDuration  element    attribute    text    comment    processing- instruction    namespace  Figure 4-1  162   Declaring Types in XSLT  The shaded boxes show abstract types, and the clear boxes represent concrete types. The difference is that a value can never belong to an abstract type unless it also belongs to one of the concrete subtypes of that type.  The most general type here is «item  », which allows any kind of item. The two kinds of items are nodes, shown on the left-hand branch of the type hierarchy, and atomic values, shown on the right-hand branch.  In a sequence type descriptor, any of the item types listed in Figure 4-1 may be followed by one of the occurrence indicators «*», «+», or «?». The occurrence indicator deﬁnes how many items  of the given item type  may appear in the value. They have the following meanings:  Occurrence indicator  *  +  ?  Meaning Zero or more occurrences allowed  One or more occurrences allowed  Zero or one occurrence allowed  4  S t y l e s h e e t s  a n d S c h e m a s  If there is no occurrence indicator, then the value must contain exactly one item of the speciﬁed type.  In a schema-aware processor, this type hierarchy is extended in the following two ways:        Firstly, all the built-in atomic types deﬁned in the XML Schema speciﬁcation become available. These include the additional primitive type xs:NOTATION, and types derived from xs:string and xs:integer, such as xs:normalizedString and xs:nonNegativeInteger. A full list of these types, with explanations of their meanings, is given in Chapter 5. Secondly, user-deﬁned types can be imported from an XML Schema deﬁnition.  To make user-deﬁned types available for use in type declarations in a stylesheet, the schema must ﬁrst be imported into the stylesheet. This can be done with an   declaration, which might take the form:  <xsl:import-schema namespace="http:  acme.org ns"  schema-location="acme.xsd" >  The   declaration is described in more detail later in this chapter  see page 180 . You can import any number of schema documents into a stylesheet, provided that the namespaces do not clash. If you want to refer to types deﬁned in a schema by name, then you must import that schema into the stylesheet using an   declaration. However, you don’t need to import a schema simply because you are using it to validate source or result documents.  The types deﬁned in a schema are either complex types or simple types, and simple types in turn divide into three varieties: union types, list types, and atomic types.  When atomic types are imported from a schema, they can be used in a stylesheet in just the same way as the built-in atomic types. For example, if the schema deﬁnes an atomic type mf:part-number as a subtype of xs:string constrained to conform to a particular pattern, then in the stylesheet you can declare a variable:     which informs the system that the value of the $part variable will always be a part number. The expression in the select attribute must return a valid part number according to these rules, or the trans- formation will fail.  163   Stylesheets and Schemas  Note that to conform to this type, it’s not enough to supply a string that matches the schema-deﬁned pattern. The value must actually be labeled as an mf:part-number. To achieve this, you typically have to convert the value to the required type using a constructor function. For example, you could write:  <xsl:variable name="part" as="mf:part-number"  select="mf:part-number ’BFG94623’ " >  Atomic values can exist independently of any node in a document, which is why you can use an atomic type directly as the type of a value. In contrast, instances of complex types, union types, and list types can exist only as the content of a node in a document. This means that the names of these types can’t be used directly in an «as» attribute deﬁning the type of a variable or parameter. You can use them, however, to qualify a type that describes a node. Examples of such sequence type descriptors are shown in the table below:  Construct  element *, mf:invoice   attribute *, xs:NMTOKENS   document-node element *, mf:invoice    Meaning An element node validated against the complex type mf:invoice deﬁned in an imported schema  An attribute validated against the built-in schema list type xs:NMTOKENS  A document node representing a well-formed XML document whose outermost element has been validated against the complex type mf:invoice deﬁned in an imported schema  Often the structure of an element is deﬁned in the schema not by creating an explicitly named   deﬁnition, but rather by means of an   declaration that contains an unnamed  . Here’s a typical example, taken from the schema for XSLT 2.0 stylesheets:                                   To allow for the fact that many of the types deﬁned in a typical schema are anonymous, there is another form of the element  test that is used to refer to elements conforming to this named element declaration. If you write:     then you are saying that the value of the parameter must be an element that has been validated against the element declaration xsl:apply-imports in this schema. The name of the element passed as the parameter must either be xsl:apply-imports, or must match an element deﬁned in the schema to be a member of the substitution group of xsl:apply-imports.  164   Validating the Source Document  You can similarly refer to top-level attribute declarations in the schema using the syntax «schema- attribute nnn », though this form is not seen very often because it is unusual to ﬁnd top-level attribute declarations in a schema.  Sequence type descriptors can also be used within XPath expressions. The expressions that use them are described in Chapter 11, which also deﬁnes the syntax and semantics in much greater detail than deﬁned here. The operators that use sequence type descriptors are as follows:        «instance of», which tests whether a given value is an instance of a given type. For example, «@dob instance of attribute *, xs:date » returns true if the attribute @dob is labeled with the type annotation xs:date  or a type derived from xs:date , which will be true only if the attribute contains a valid date and has been validated using a schema that declares the type of the attribute as xs:date. «treat as», which asserts that a given value is an instance of a given type, causing a runtime failure if it is not. This operator is useful mainly with XPath processors that do strict static type-checking, which is unlikely to apply in an XSLT environment unless the processor has a diagnostic mode to do this extra level of checking.  4  S t y l e s h e e t s  a n d S c h e m a s  Validating the Source Document  Validation is the process of taking a raw XML document and processing it using an XML Schema. The most obvious output of this process is a success or failure rating: the document is either valid or invalid against the schema. But this is not the only output. Validation also annotates the document, marking each element and attribute node with a label indicating its type. For example, if validation checks that a   element is valid according to the «us-postal-address» type in the schema, then this element will be annotated as having the type «us-postal-address». There are various ways the stylesheet can then use this information:       Many operations on nodes extract the typed value of the nodes. This process is called atomiza- tion, and it is sensitive to the type annotations on the nodes. For example, when you compare two attributes using an expression such as «@discount gt $customer @max-discount», the val- ues that are compared are the typed values of @discount and @max-discount respectively. If the schema deﬁnes these values to be numbers  for example, using the type xs:decimal , then they will be compared numerically, so the value «10.00» will be considered greater than the value «2.50». If the same values were compared as strings, «10.00» would be less than «2.50». Adding type annotations to nodes, through the process of schema validation, enables operations on the values of the nodes to be performed more intelligently. There are many operations that only make sense when applied to a particular kind of data. At the top level, the stylesheet as a whole might be designed to process purchase orders, and will produce garbage if you make the mistake of feeding it with input that’s actually a delivery note. At a more ﬁne-grained level, you might have a stylesheet function or template rule that’s designed to process US postal addresses, and that won’t work properly if you give it a phone number instead. XSLT 2.0 allows you to deﬁne the type of data that you expect your functions and template rules to process, and to deﬁne the type of result that they produce as their output. A schema-aware processor will then automatically check that when the function or template is actually called, the data is of the right type, and if it isn’t, the error will be reported. At times these errors can become frustrating. But remember, every time you get one of these error messages, it tells you about a programming mistake that might otherwise have been much harder to track down. With XSLT 1.0, most programming mistakes don’t give you an error  165   Stylesheets and Schemas  message, they simply give you wrong output  or no output at all , and it can be a tortuous process debugging the stylesheet to ﬁnd out where you went wrong. With XSLT 2.0, if you choose to deﬁne data types for your stylesheet functions and templates, you can get error messages that make it much clearer where the mistake lies.  You don’t request validation of the input document from within the stylesheet. It’s assumed that you will request this as part of the way you invoke the transformation, and details of how you do this will vary from one XSLT processor to another.  With Saxon you can use the -val:strict option on the command line; with Altova you need an xsi:schemaLocation attribute in the source document.  Within your stylesheet, what you can do is to test whether the input has actually been validated. I often write two template rules in the stylesheet as follows:        Source document is not a validated purchase order                 The effect of writing the template rules this way is that if the stylesheet is presented with a document that is not a validated purchase order, it will immediately fail and display an error message, rather than trying to process it and producing garbage output.  Note the carefully chosen phrase a validated purchase order. It’s not enough to supply an XML document that would be deemed valid if you tried to validate it. To pass this test, the document must already have been through a schema processor, and must have passed validation.  If you prefer, you could code the stylesheet to invoke the validation explicitly, by writing the following:                   This deﬁnes a variable to hold a copy of the input document. The «type» attribute on the <xsl:copy- of> instruction asks the XSLT processor to invoke schema validation on the document, and if this succeeds, the element and attribute nodes in the new copy will have type annotations reﬂecting the result of this process. There is no explicit logic here to test whether validation has succeeded. It isn’t needed, because a validation failure will always cause the transformation to be aborted with an error message.  However, I wouldn’t normally recommend this approach. Creating a copy of the input document is likely to be expensive. It’s better to do the validation on the ﬂy while the input document is being parsed in the ﬁrst place.  The value of the «type» attribute in this example, like the type named in the «instance of» expression in the previous example, is a type that’s deﬁned in a schema. Like any other type that’s referred to by name in a stylesheet, it must be deﬁned in a schema that has been imported using the <xsl:import- schema> declaration.  Here’s an example of a complete stylesheet written to process a validated source document.  166   Validating the Source Document  Example: Validating the Source Document  This example shows how a stylesheet can make use of the schema for the source document.  Source  The source document is a poem such as theHill.xml, which starts:  <poem xmlns="http:  poetry.org ns"  xsi:schemaLocation="http:  poetry.org ns poem.xsd" xmlns:xsi="http:  www.w3.org 2001 XMLSchema-instance">  4  S t y l e s h e e t s  a n d S c h e m a s      Rupert Brooke   1887-08-03   1915-04-23      1912   The Hill      Breathless, we flung us on the windy hill,   Laughed in the sun, and kissed the lovely grass.   You said "Through glory and ecstasy we pass;   Wind, sun, and earth remain, and birds sing still,   When we are old, are old...." "And when we die   All’s over that is ours; and life burns on   Through other lovers, other lips" said I,   "Heart of my heart, our heaven is now, is won!"      The xsi:schemaLocation attribute tells the processor where to ﬁnd a schema for this document. This isn’t needed with Saxon, which will validate the document against the schema imported into the stylesheet, provided that validation is requested on the command line. With AltovaXML, the xsi:schemaLocation attribute acts as an implicit request for document validation, and is therefore necessary for this example to work.  The xsi namespace is deﬁned in the XML Schema speciﬁcation and contains four attributes: xsi:schemaLocation, xsi:noNamespaceSchemaLocation, xsi:type, and xsi:nil. The preﬁx xsi is conventional, but the namespace URI must be http:  www.w3.org 2001  XMLSchema-instance.  Schema  The schema for poems is in poem.xsd:    <xs:schema xmlns:xs="http:  www.w3.org 2001 XMLSchema" elementFormDefault="qualified" targetNamespace="http:  poetry.org ns" xmlns:p="http:  poetry.org ns">           167   Stylesheets and Schemas                                                                                       Stylesheet  The following stylesheet is in poem-to-html.xsl. It relies on the source document being validated.    <xsl:stylesheet version="2.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" xmlns:xs="http:  www.w3.org 2001 XMLSchema" xpath-default-namespace="http:  poetry.org ns" exclude-result-prefixes="xs">  <xsl:import-schema namespace="http:  poetry.org ns"  schema-location="poem.xsd" >            Input must be a validated poem   168   Validating the Source Document  4  S t y l e s h e e t s  a n d S c h e m a s                           by        -                                                                          Notice how the template rules in this example are matching nodes by their type. The ﬁrst rule catches unvalidated documents to report an error. The second rule matches the docu- ment node of a poem, while the third matches any element that is typed as a gendate — a user-deﬁned type that can be an xs:date, an xs:gYearMonth, or an xs:gYear. There are three elements in the schema that use this type, but we don’t need to name them in the stylesheet; the rule can be used to format any element of this type, regardless of its name.  Output  This example can be run using Saxon-SA, by using the command  on one line :  java net.sf.saxon.Transform -val:strict -s:theHill.xml i -xsl:poem-to-html.xsl -o:theHill.html  It can also be run using the AltovaXML 2008 processor, with the command:  169   Stylesheets and Schemas  AltovaXML -in theHill.xml -xslt2 poem-to-html.xsl  Figure 4-2 shows what the output looks like in the browser.  Figure 4-2  Try some experiments with this, so that you can see what effect schema-aware process- ing has when you make errors. For example, change the path expression on line 23 from «poem author name» to «poem poet name». Saxon-SA gives you the warning:  Warning: on line 23 of ... code ch04 poem-to-html.xsl:  The complex type of element poem does not allow a child element named poet  When you’re dealing with a complex schema it’s very easy to make this kind of mistake in your path expressions, and allowing the XSLT processor to check your code against the schema can make a big difference to the ease of diagnosing such errors. Note that it’s only a warning, not an error: the expression is actually legal, but Saxon-SA is warning you that it selects nothing. AltovaXML, at the time of writing, doesn’t do this level of checking.  Validating the Result Document  We’ve seen what you can achieve by using knowledge of the schema for the source document. You can also request validation of the output of the transformation. For example, if you have written the stylesheet to generate XHTML, you can ask for it to be validated by writing your ﬁrst template rule as follows:                 170   Validating the Result Document  In this example, there is nothing that says what the expected type of the output is. What «validate = "strict"» means is that the outermost element of the result document  for example,    must correspond to an element declaration that’s present in some schema known to the system, and the system is then required to check that the contents of the element conform to the rules deﬁned in that element declaration.  You could argue that validating the output from within the stylesheet is no different from running the transformation and then putting the output through a schema processor to check that it’s valid. However, once you try developing a stylesheet this way, you will ﬁnd that the experience is very different. If you put the output ﬁle through a freestanding schema processor once the transformation is complete, the schema processor will give you error messages in terms of a position within the result document. You will then have to open the result document in a text editor, ﬁnd out what’s wrong with it, ﬁnd the instruction in the stylesheet that generated the incorrect output, and then correct the stylesheet. Working with a schema processor that’s integrated into your XSLT processor is much more direct: In most cases the error message will tell you directly which instruction in the stylesheet needs to be changed. This makes for a much more rapid development cycle.  4  S t y l e s h e e t s  a n d S c h e m a s  There is another advantage — in many cases it should be possible for a schema-aware XSLT processor to tell you that the output will be invalid before you even try running the stylesheet against a source document. That is, it should be able to report some of your errors at compile time. This gives you an even quicker turnaround in ﬁxing errors, and more importantly, it means that the ability to detect bugs in your code is less dependent on the completeness of your test suite. Stylesheet programming is often done without much regard to the traditional disciplines of software engineering — testing tends to be less than thorough. So anything that reduces the risk of failures once the stylesheet is in live use is to be welcomed.  The following example shows how this works.  Example: Validating the Result Document  This example shows how validation of a result document can be invoked from within the stylesheet.  Source  Stylesheet  The source document is a poem such as theHill.xml, which is listed  in part  on page 167.  The following stylesheet poem-to-xhtml.xsl is designed to format this poem into XHTML, checking as it does so that the output is valid XHTML. It contains a deliberate error: see if you can spot it.  <xsl:stylesheet version="2.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" xpath-default-namespace="http:  poetry.org ns" xmlns="http:  www.w3.org 1999 xhtml">  <xsl:import-schema namespace="http:  www.w3.org 1999 xhtml"  schema-location="http:  www.w3.org 2002 08 xhtml xhtml1-strict.xsd" >  171   Stylesheets and Schemas                     name" >             by  <xsl:value-of select="poem author    <xsl:value-of select="poem author  birth,death "     separator="-" >                                       Note that this stylesheet validates the output, but doesn’t require validating the input. The only reason for this is to demonstrate one feature at a time, and to show that input validation and output validation are quite independent of each other. This stylesheet fetches the XHTML schema from the W3 C web site. That’s not a practical thing to do for something that you run frequently. If you run behind a proxy server then it will probably be cached automatically, but in other cases you may prefer to make a local copy.  Output  When this stylesheet is run using Saxon-SA 9.0, the output is:  Error on line 17 of ... code ch04 poem-to-xhtml.xsl:  XTTE1510: Attribute align is not permitted in the content model of  the complex type of element h1. Failed to compile stylesheet. 1 error detected.  The error message should be clear enough: the align attribute is not permitted in strict XHTML. You could ﬁx it by using the schema for transitional XHTML rather than strict XHTML, or better, by replacing the align attribute with «style = "text-align: center"».  172   Validating the Result Document  Previous releases of Saxon reported this error as a runtime validation error, while still pinpointing the line in the stylesheet where the problem occurred. The XSLT speciﬁca- tion isn’t prescriptive about this: it allows implementations to do the validation either at compile-time or at runtime. AltovaXML reports the error at runtime, like this:  Validation Error Attribute ’align’ is not allowed in element   ...\code\ch04\poem-to-xhtml2.xsl Line 11, Character 4  Like Saxon-SA, it gives a clear message about what is wrong, though it’s not quite so pre- cise in identifying the location in the stylesheet of the offending instruction  line 11 is the   instruction .  4  S t y l e s h e e t s  a n d S c h e m a s  Validation of a result document can be controlled using either the validation attribute or the type attribute of the   element. You can use only one of these: they can’t be mixed. The validation attribute allows four values, whose meanings are explained in the table below.  Attribute value Meaning  strict  lax  preserve  strip  The result document is subjected to strict validation. This means that there must be an element declaration for the outermost element of the result document in some schema, and the structure of the result document must conform to that element declaration.  The result document is subjected to lax validation. This means that the outermost element is validated against a schema if a declaration for that element name can be located; if not, the system assumes the existence of an element declaration that allows any content for that element. The children of the element are also subjected to lax validation, and so on recursively. So any elements in the tree that are declared in a schema must conform to their declaration, but for other elements, there are no constraints.  This option means that no validation is applied at the document level, but if any elements or attributes within the result tree have been constructed using node-level validation  as described in the next section , then the type annotations resulting from that node-level validation will be preserved in the result tree. These node annotations are only relevant, of course, if the result tree is passed to another process that understands them. If the result tree is simply serialized, it makes no difference whether type annotations are preserved or not.  This option means that no validation is applied at the document level, and moreover, if any elements or attributes within the result tree have been constructed using node-level validation  as described in the next section , then the type annotations resulting from that node-level validation will be removed from the result tree. Instead, all elements will be given a type annotation of xs:untyped, and attributes will have the type annotation xs:untypedAtomic.  The other way of requesting validation of the result tree is through the type attribute. If the type attribute is speciﬁed, its value must be a QName, which must match the name of a global type deﬁnition in an  173   Stylesheets and Schemas  imported schema. In practice this will almost invariably be a complex type deﬁnition. The rules to pass validation are as follows:  1.  2.  3.  The result tree must be a well-formed document: That is, it must contain exactly one element node, and no text nodes, among the children of the document node.  In the absence of validation, this rule can be relaxed. For example, it is possible to have a temporary tree in which the docu- ment node has three element nodes as its children.  The document element  that is, the single element node child of the document node  must val- idate against the schema deﬁnition of the speciﬁed type, according to the rules deﬁned in XML Schema. The document must satisfy document-level integrity constraints deﬁned in the schema. This means:    Elements and attributes of type xs:ID must have unique values within the document. Elements and attributes of type xs:IDREF or xs:IDREFS must contain valid references to xs:ID values within the document. Any constraints deﬁned by  ,  , and   declarations in the schema must be satisﬁed.        Document-level validation rules must also be satisﬁed when validation is requested using the option «validate = "strict"» or «validate = "lax"».  The language of the XSLT speciﬁcation that describes these rules is somewhat tortuous. This is because XSLT tries to deﬁne what validation means in terms of the rules in the XML Schema speciﬁcation, which means that there is a need to establish a precise correspondence between the terminologies of the two speciﬁcations. This is made more difﬁcult by the fact that XML Schema is not deﬁned in terms of the XSLT XPath data model, but rather in terms of the XML Infoset and the Post Schema Validation Infoset  PSVI , which is deﬁned in the XML Schema speciﬁcation itself. To make this work, the XSLT speciﬁcation says that when a document is validated, it is ﬁrst serialized, and then re-parsed to create an Infoset. The Infoset is then validated, as deﬁned in XML Schema, to create a PSVI. Finally, this PSVI is converted to a document in the XPath data model using rules deﬁned in the XDM speciﬁcation. However, you should regard this description of the process as a purely formal device to ensure that no ambiguities are introduced between the different speciﬁcations. In practice, an XSLT processor is likely to have a fairly intimate interface with a schema processor, and both are likely to share the same internal data structures.  If you request validation by specifying «validation = "strict"» or «validation = "lax"», this raises the question of where the XSLT processor should look to ﬁnd a schema that contains a suitable element declaration. The speciﬁcation leaves this slightly open. The ﬁrst place a processor will look is among the schemas that were imported into the stylesheet using   declara- tions: see Importing Schemas on page 180. The processor is also allowed  but not required  to use any xsi:schemaLocation or xsi:noNamespaceSchemaLocation attributes that are present in the result docu- ment itself as hints indicating where to locate a suitable schema. My advice, however, would be to make sure that the required schemas are explicitly imported.  Validating a Temporar y Document  In the previous two sections, we have seen how you can validate a source document that is to be processed by the stylesheet, and how you can validate result documents produced as output by the  174   Validating a Temporary Document  stylesheet. It’s also possible to apply validation to temporary documents created and used internally during the course of stylesheet processing.  The most common way to create a temporary document is by using   with no «as» attribute, for example:           The value of this variable will be the document node at the root of a newly constructed temporary tree. The body of the tree in this case is produced by the   instruction.  The example above can be regarded as shorthand for the more detailed construction:  4  S t y l e s h e e t s  a n d S c h e m a s                 This shows more explicitly how the sequence constructor contained in the   element creates a single document node, whose content is populated by the   instruction.  If you expand the variable deﬁnition in this way, you can also use the attributes validation and type on the   instruction to invoke validation of the temporary document. These attributes work exactly the same way on   as they do on  , which produces a ﬁnal result tree.  Another way of creating temporary documents is by copying an existing document node using either of the instructions    which makes a shallow copy  or    which makes a deep copy . These instructions both have validation and type attributes, and when the instructions are used to copy a document node, these attributes work the same way as the corresponding attributes on the   and   instructions.  Because a temporary document exists only locally within your stylesheet, it sometimes makes sense to validate it using a schema that is also local to the stylesheet. To this end, XSLT allows you to write a schema document inline as the content of the   element. For example, if the temporary document has the form:         ...     then the   declaration might be:     <xs:schema targetNamespace="http:  www.acme.com ns local months"  xmlns:m="http:  www.acme.com ns local months">        175      Stylesheets and Schemas                                   For the complete stylesheet, see inline.xsl in the download ﬁles for this chapter. If you use inline schema documents, it’s good practice to use a unique namespace, to ensure that the schema deﬁnitions don’t conﬂict with any other schema deﬁnitions that might be loaded.  Validating Individual Elements  Rather than applying validation at the document level, it is possible to invoke validation of speciﬁc elements as they are constructed. This can be useful in a number of circumstances:              Sometimes you do not have a schema deﬁnition for the result document as a whole, but you do have schema deﬁnitions for individual elements within it. For example, you may be creating a data ﬁle in which the contents of some elements are expected to be valid XHTML. If you are running a transformation whose purpose is to extract parts of the source document, then you may actually know that the result document as a whole is deliberately invalid — the schema for source documents may require the presence of elements or attributes, which you want to exclude from the result document, perhaps for privacy or security reasons. The fact that the result document as a whole has no schema should not stop you from validating those parts that do have one. You may be creating elements in temporary working storage  that is, in variables  that are to be copied or processed before incorporating them into a ﬁnal result document. It can be useful to validate these elements in their own right, to make sure that they have the type annotations that enable them to be used as input to functions and templates that will only work on elements of a particular type. You may have templates or functions that declare their return types using sequence type descrip- tors such as element *, us-postal-address . The only way to generate new content that satisﬁes such a return type is to put it through schema validation.  The usual way of creating a new element node in XSLT is either by using a literal result element or by using the   instruction.  The   instruction has attributes validation and type, which work in a very similar way to the corresponding attributes of   and  ; however, in this case it is only element-level validation that is invoked, not document-level validation.  The same facilities are available with literal result elements. In this case, however, the attributes are named xsl:validation and xsl:type. This is to avoid any possible conﬂict with attributes that you want copied to the result document as attributes of the element you are creating.  176   For example, suppose you want to validate an address. If there is a global element declaration with the name address, you might write:  Validating Individual Elements      39   Lombard Street   London   EC1 3CX      If this matches the schema deﬁnition of the element declaration for address, this will succeed, and the resulting element will be annotated as an address — or more strictly, as an instance of the type associated with the address element, which might be either a named type in the schema, or an anonymous type. In addition, the child elements will also have type annotations based on the way they are deﬁned in the schema, for example the   element might  perhaps  be annotated as type xs:integer. If validation fails, the whole transformation is aborted.  What if there is no global element declaration for the   element  typically because it is deﬁned in the schema as a local element declaration within some larger element ? You can still request validation if the element is deﬁned in the schema to have a named type. For example, if the element is declared as:  4  S t y l e s h e e t s  a n d S c h e m a s     then you can cause it to be validated by writing:      39   Lombard Street   London   EC1 3CX      If neither a top-level element declaration nor a top-level type deﬁnition is available, you can’t invoke validation at this level. The only thing you can do is either:        change the schema so that some of the elements and or types are promoted to be globally deﬁned, or invoke validation at a higher level, where a global element declaration or type deﬁnition is available.  You don’t need to invoke validation at more than one level, and it may be inefﬁcient to do so. Asking for validation of   in the above example will automatically invoke validation of its child elements. If you also invoked validation of the child elements by writing, say:      39  ...  then it’s possible that the system would do the validation twice over. If you’re lucky the optimizer will spot that this is unnecessary, but you could be incurring extra costs for no good reason.  If you ask for validation of a child element, but don’t validate its parent element, then the child element will be checked for correctness, but the type annotation will probably not survive the process of tree construction. For example, suppose you write the following:  177   Stylesheets and Schemas      39   Lombard Street   London   EC1 3CX      Specifying the xsl:type attribute on the   element causes the system to check that the value of the element is numeric, and to construct an element that is annotated as an integer. The result of evaluating the sequence constructor contained in the   element is thus a sequence of four elements, of which the ﬁrst has a type annotation of xs:integer. Evaluating the literal result element   creates a new   element, and forms children of this element from the result of evaluating the contained sequence constructor: The formal model is that the elements in this sequence are copied to form these children. The xsl:validation attribute on the   element determines what happens to the type annotations on these child elements. This defaults to either preserve or strip, depending on the default-validation attribute of the containing    which in turn defaults to strip . If the value is preserve, the type annotation on the child element is preserved, and if the value is strip, then the type annotation on the child element is replaced by xs:untyped.  The type of an element never depends on the types of the items used to form its children. For example, suppose that the variable $i holds an integer value. Then you might suppose that the construct:           would create an element whose type annotation is xs:integer. It doesn’t — the type annotation will be xs:untyped. Atomic values in the sequence produced by evaluating the sequence constructor are always  at least conceptually  converted to strings, and any type annotation in the new element is obtained by validating the resulting string values against the desired type.  This might not seem a very satisfactory design — why discard the type information? The working groups agonized over this question for months. The problem is that there are some cases like this one where retaining the type annotation obviously makes sense; there are many other cases, such as a sequence involving mixed content, where it obviously doesn’t make sense; and there are further cases such as a sequence containing a mixture of integers and dates where it could make sense, but the deﬁnition would be very difﬁcult. Because the working group found it difﬁcult to devise a clear rule that separated the simple cases from the difﬁcult or impossible ones, they eventually decided on this rather blunt rule: everything is reduced to a string before constructing the new node and validating it.  Note that when you use the xsl:type attribute to validate an element, the actual element name can be anything you like. There is no requirement that it should be an element name declared in the schema. It can even be an element name that is declared in the schema, but with a different type  though I can’t see any justiﬁcation for doing something quite so confusing, unless the types are closely related .  All the same considerations apply when creating a new element using the   or   instruction rather than a literal result element. The only difference is that the attributes are now called validation and type instead of xsl:validation and xsl:type.  The value of the type or xsl:type attribute is always a lexical QName, and this must always be the name of a top-level complex type or simple type deﬁned in an imported schema. This isn’t the same as the «as» attribute used in declaring the type of variables or functions. Note the following differences:  178   Validating Individual Attributes           If the «as» attribute is a QName, the QName must identify an atomic type. The «type» attribute is always a QName, and this may be any type deﬁned in an imported schema: complex types are allowed as well as all three varieties of simple type; that is list types, union types, and atomic types. The «as» attribute can include an occurrence indicator  «?», «*», or «+» . The «type» attribute never includes an occurrence indicator. The «as» attribute may deﬁne node kinds, for example «node  », «element  », or «comment  ». Such constructs are never used in the «type» attribute.  This means that to create an element holding a sequence of IDREF values, you write:  <xsl:element name="ref" type="xs:IDREFS"  select="’id001 id002 id003"’ >  whereas to declare a variable holding the same sequence, you write:  4  S t y l e s h e e t s  a n d S c h e m a s  <xsl:variable name="ref" as="xs:IDREF*"  select="xs:IDREF ’id001’ , xs:IDREF ’id002’ , xs:IDREF ’id003’ " >  In the case of  , note that the option «validation = "preserve"» applies to the children  and attributes  of the copied element, but not to the copied element itself. This instruction does a shallow copy, so in general the content of the new element will be completely different from the content of the old one. It doesn’t make sense to keep the type annotation intact if the content is changing, because this could result in the type annotation becoming inconsistent with the actual content.  By contrast, the   instruction does a deep copy. Because the content remains unchanged, it’s safe to keep the type annotation unchanged, and the option «validation = "preserve"» is useful in achieving this.  When you request validation at the element level, the system does not perform any document-level integrity checks. That is, it does not check that ID values are unique, or that IDREF values don’t point into thin air. To invoke this level of validation, you have to do it at the document level. The speciﬁcation as published also says that it does not check identity constraints deﬁned by  ,  , and   deﬁnitions in the schema, but this was a mistake and has been ﬁxed in an erratum.  Validating Individual Attributes  XSLT 2.0 also allows you to request validation at the level of individual attributes. The   instruction, like  , has attributes validation and type, which can be used to validate an attribute node independently of its containing element.  It’s relatively unusual for a schema to contain global attribute declarations, so the options «validation = "strict"» and «validation = "lax"» are unlikely to be very useful at the attribute level. Also, because attributes don’t have children, the options «validation = "strip"» and «validation = "preserve"» both mean the same thing: the new attribute node will be annotated as «xs:untypedAtomic». The most useful option for attributes is to specify «type» to validate the attribute value against a speciﬁc type deﬁnition in the schema. This will always be the name of a simple type, and in many cases it will be the name of a built-in atomic type, for example «type = "xs:date"» or «type = "xs:ID"». But it can also be a list or union type, for example «type = "xs:IDREFS"».  If «xsl:copy» or «xsl:copy-of» is used to create attribute nodes by copying nodes from a source doc- ument, attribute-level validation can be invoked using the validation and type attributes in the same 179   Stylesheets and Schemas  way. Unlike the situation with elements, «preserve = "yes"» on either of these instructions means what it says: the attribute is copied together with its type annotation.  There are special rules in the language speciﬁcation concerning the validation of attributes whose type is xs:QName or xs:NOTATION. Since these types require a namespace context to perform the validation, you can’t validate standalone attributes that have these types. They can only be validated as part of an element that has the appropriate namespaces in scope.  The default-validation Attribute  The default-validation attribute on the   element can take one of the two values «preserve» or «strip», and it deﬁnes the default that is used on any of the instructions <xsl: attribute>,  ,  ,  ,  , and <xsl:result- document> when neither a type nor a validation attribute is speciﬁed explicitly.  You can’t set the default to «strict» or «lax». Allowing the value «strict» would give you problems unless every element and attribute that you create were declared globally in a schema, which would be unusual. Allowing «lax» would be more likely to give acceptable results, but could lead to performance problems through excessive validation.  The default value for the default-validation attribute is «strip». Personally, I would stick with this default. Changing it to «preserve» may lead to rather patchy results in terms of which elements and attributes carry a type annotation, and which are left as untyped. Preserving type annotations makes most sense when you are explicitly copying data from one document to another, and it’s probably best to request it explicitly on the instructions that do the copying.  But there may well be situations I haven’t thought of, and if you ﬁnd yourself using the same value of the validation attribute throughout the stylesheet, then deﬁning a default at the stylesheet module level may turn out to be a useful thing to do.  Impor ting Schemas  The facilities that we’ve been discussing in this chapter work only if schema information is available to the XSLT processor. The primary way that the processor gets this information is through the   declaration, which can be used at the top level of any stylesheet module.  The   declaration is modeled on the   element within the XML Schema speciﬁcation, but with some concessions to the XSLT house style  for example, the schemaLocation attribute in   becomes schema-location in XSLT . Importantly, it adopts the same delib- erate vagueness about exactly where the schema comes from, giving implementations the freedom to implement local schema caches or catalogs.  The most important attribute is the namespace attribute. This gives the target namespace of the schema being imported. If the attribute is omitted, this represents a request for a schema with no target name- space. You should import a schema for each namespace that contains a type deﬁnition, element declaration, or attribute declaration that your stylesheet refers to by name. Importing a schema that in turn imports another schema isn’t good enough: The only names that become available for use in your stylesheet are those in namespaces that you import explicitly. The XSLT processor is given some leeway to implicitly import schemas that aren’t requested explicitly in the stylesheet. This is intended particularly for use in highly controlled environments, such as running a transformation within an XML  180   Using xsi:type  4  S t y l e s h e e t s  a n d S c h e m a s  database engine where the available schemas are all known in advance. But it’s unwise to rely on this if you want your stylesheet to be portable.  The schema-location attribute of   deﬁnes a URI where the schema document can be located. This is described in the speciﬁcation as a hint, which means that if the XSLT processor knows a better place to look, it is free to do so. For example, it might already have a precompiled copy of the schema held in memory. If you don’t supply a schema-location attribute, then the schema import will work only if the XSLT processor already knows where to look. It’s possible, for example, that some XSLT processors might have built-in knowledge of common schemas such as the XHTML schema, so they never need to fetch the XML source. However, if you want your stylesheet to be portable, it’s probably a good idea to specify the schema location.  You don’t need to import schemas into every stylesheet module individually. Importing a schema into one stylesheet module makes its deﬁnitions available in all stylesheet modules.  This is a notable differ- ence from the equivalent facility in XQuery.   What happens if you have two   declarations for the same namespace URI  or, more probably, for the null namespace ? This can easily happen when different stylesheet modules are combined into a single stylesheet. Firstly, the system chooses the one with the highest import precedence, as explained in Chapter 3. If this leaves more than one, then they are all used. The XSLT speciﬁcation explains how conﬂicts are resolved by reference to the XML Schema speciﬁcation: it’s deﬁned to be the same as if you have two   declarations for the same namespace in a schema document. This is rather passing the buck, as it happens, because XML Schema leaves a lot of latitude to implementations in deciding how far they will go in analyzing two different schemas for conﬂicts. It’s best not to do it. Because the processor is perfectly entitled to ignore the schema-location hint, it is also entitled to assume that if it already has a schema for a given namespace loaded, then this is the one that the user wanted.  As with validation, the XSLT speciﬁcation describes the semantics of schema import by means of a rather artiﬁcial device: it describes an imaginary schema document that is assembled to contain   declarations representing each of the   declarations in the stylesheet. The reason for this artiﬁce is that it provides a way of invoking the rules of XML Schema and saying that they apply equally to XSLT, without actually copying the rules and repeating them, which would inevitably lead to inconsistencies. No real implementation is likely to integrate the XSLT processor and the schema processor in the clumsy manner described in the spec.  You don’t need to import a schema merely because it is used to validate source documents. However, I would recommend doing so. If you don’t, this creates the possibility that a source document will contain type annotations that mean nothing to the XSLT processor. There are various ways an XSLT processor can deal with this problem  no less than four possible approaches are described in the speciﬁcation, one of which is to raise an error , but the simplest approach is to avoid the problem by ensuring that all the schemas used in your transformation are explicitly imported.  With AltovaXML 2008, source documents are validated only if they contain an xsi:schemaLocation attrbibute that identiﬁes the schema to be used.  Using xsi:type  I haven’t yet mentioned the use of xsi:type in this chapter  I did mention xsl:type, but that’s a completely different thing, despite the similar name . In fact, the XSLT 2.0 speciﬁcation mentions xsi:type only in notes and examples, which means that it plays no formal role in the XSLT language.  181   Stylesheets and Schemas  The xsi:type attribute is deﬁned in the XML Schema speciﬁcation — the preﬁx xsi is conventional, but the namespace URI must be http:  www.w3.org 2001 XMLSchema-instance.  You can use xsi:type as an attribute on an element within a document that’s being assessed by a schema processor. Its effect is to ask the schema processor to apply a stricter check to the element than it would otherwise. An xsi:type can’t override the constraints deﬁned in the schema, but it can make assertions about the document content that go beyond what the schema requires. For example, if the schema allows a particular element  by means of a union type  to contain either an integer or a QName, then specifying «xsi:type = "xs:QName"» will cause it to be validated as if only a QName were allowed. This can also result in the element node acquiring a more speciﬁc type annotation than would otherwise be the case.  The effect of xsi:type on schema validation applies just as much when the validation is happening under the control of XSLT as it does in freestanding schema processing. If you write an xsi:type attribute to the result tree  which you can do in exactly the same way as you write any other attribute , then the element will be validated against that type deﬁnition.  Although I started by saying that xsi:type and xsl:type were quite different things, this description shows that there are cases where their effects are very similar. For example, writing:   23.44   and:   23.44   can both produce a   element validated and annotated as being of type xs:decimal. However, there are some important differences:           xsl:type  or type  invokes validation as well as specifying the expected type of the element. xsi:type speciﬁes the expected type, but it is ignored unless validation is requested by some other mechanism. The xsi:type attribute is copied to the result document; the xsl:type and type attributes are not. The xsi:type attribute can only be used to specify the type of element nodes. A type attribute  when it is used on the   instruction  can also control the type of attribute nodes.  Nillability  The xsi:nil attribute was deﬁned in XML Schema because there were some people from the relational database tradition who felt that omitting an element or attribute from an XML document was not an adequate way of representing the SQL concept of null values. I have to say I ﬁnd the facility completely unnecessary: null was invented in SQL so that a cell in a table could hold no data, but XML already has perfectly good ways of representing absence of data, namely an absent element or attribute. But xsi:nil exists, and it can’t be uninvented, and you may need to use it if it has been built in to the semantics of the vocabulary for your source or result documents.  As with xsi:type, the xsi:nil attribute is mentioned in the XSLT speciﬁcation only in notes and examples. However, it gets a rather more detailed treatment in the XPath formal semantics, because it has a signiﬁcant effect in complicating the rules for type matching.  182   Summary  You can use xsi:nil on an element only if the schema deﬁnes the element as nillable. If you do set «xsi:nil = "true"» on an element, then the element is valid only if it is empty; moreover, it is allowed to be empty in this case even if the content model for the element would otherwise not permit it to be empty.  The possibility of encountering an xsi:nil potentially plays havoc with the type safety of your stylesheet. If you write a function that is designed to process valid book elements, and every book must have an ISBN, then the function should be allowed to access the ISBN without adding conditional logic to check that it is there. For this reason, a function or variable that accepts nilled elements has to declare that it does so. If a function parameter is declared with the type «as = "element *, book-type "», then passing the element   to this function will cause a type error. If you want to write a function that accepts this element, you must instead write «as = "element *, book-type? "» to show that your function can handle this input.  Apart from this, xsi:nil behaves in XSLT just like any other attribute.  4  S t y l e s h e e t s  a n d S c h e m a s  You do need to be a little careful if you want to put your stylesheets through a schema processor  which you might do, for example, if you store your stylesheets in an XML database . The schema processor attaches a special meaning to attributes such as xsi:nil, xsi:type, and xsi:schemaLocation, even though XSLT does not. It’s therefore best to avoid using these attributes directly on literal result elements. Two possible ways round this problem are:        Generating these attributes using the   instruction instead. Using a namespace alias for the xsi namespace: See the description of the <xsl:namespace- alias> declaration in Chapter 6  page 394 .  Summar y  Firstly, a reminder of something we said at the beginning of the chapter, and haven’t touched on since: schema processing in XSLT 2.0 is optional. Some XSLT 2.0 processors won’t support schema processing at all, and even if you are using a processor that is schema-aware, you can still use it to transform source documents that have no schema into result documents that have no schema.  We started this chapter with a very quick tour of the essentials of XML Schema, describing the main concepts of element and attribute declarations and simple and complex types, and discussing the role that they play in XSLT processing.  There are two main roles for schemas in XSLT, which are strongly related. Firstly, XML Schema provides the type system for XSLT and XPath, and as such, you can deﬁne the types of variables, functions, and templates in terms of types that are either built into XML Schema, or deﬁned as user-deﬁned types in a speciﬁc schema.  Secondly, you can use an XML Schema to validate your source documents, your result documents, or intermediate working data. This not only checks that your data is as you expected it, which helps debug- ging, but also annotates the nodes in the data model, which can be used to steer the way the nodes are processed, for example by deﬁning template rules that match particular types of node.  The mechanism that binds a stylesheet to one or more schemas is the   declaration, and we looked in some detail at the way this works.  In the next chapter we will look more closely at the way types are used in XSLT and XPath processing, including a survey of the built-in types that are available whether or not you use a schema.  183    5  T y p e s  Types  This chapter looks in some detail at the XPath type system; that is, the types of the values that can be manipulated by XPath expressions and XSLT instructions.  XPath is an expression language. Every expression takes one or more values as its inputs, and produces a value as its output. The purpose of this chapter is to explain exactly what these values can be.  Chapter 2 presented the XDM tree model with its seven node kinds — that’s part of the picture, because XPath expressions will often be handling nodes in a tree. The other half of the picture is concerned with atomic values  strings, numbers, booleans, and the like , and it’s these values that we’ll be studying in this chapter.  One of the things an expression language tries to achieve is that wherever you can use a value, you can replace it with an expression that is evaluated to produce that value. So if «2 + 2» is a valid expression, then « 6−4  +  1 + 1 » should also be a valid expression. This property is called composability: expressions can be used anywhere that values are permitted. One of the important features that make a language composable is that the possible results of an expression are the same as the possible inputs. This feature is called closure: every expression produces a result that is in the same space of possible values as the space from which the inputs are drawn.  The role of the data model is to describe this space of possible values, and the role of the type system is to deﬁne the rules for manipulating these values.  What Is a Type System?  Let’s make sure that when we talk about a type system, we’re talking the same language.  Every programming language has some kind of type system. A language manipulates values, and the values are of different types. At the simple level, they might be integers, booleans, and strings. Then the language might support various kinds of composite types; for example, arrays or records or lists. Most modern languages also allow users to deﬁne their own types, on top of the basic types provided ‘‘out of the box’’.  So, types are used to classify the values that can be manipulated by expressions in the language, and the type system deﬁnes the basic types provided by the language as well as the facilities for deﬁning new types by combining and reﬁning existing types.   Types  A type serves two main purposes. Firstly, it deﬁnes a set of permissible values. For example, if you say that a function expects a positive integer as its ﬁrst argument, then the phrase ‘‘positive integer’’ tells you what the valid values for the ﬁrst argument are.  Secondly, a type deﬁnes a set of possible operations. Integers can be added, lists can be concatenated, booleans can be combined using the operators «and», «or», and «not».  Not only does the type tell you whether a particular operation is permitted on a value of that type, it determines how that operation will be performed. So integers, strings, dates, and high school grades can all be sorted into order, but the way they are sorted depends on their type. Operations that are performed in different ways depending on the type of their operands are called polymorphic operations  from Greek words meaning many shapes .  Types are useful in programming languages for a number of reasons:           Types allow errors to be detected, including programming logic errors and data errors. Because a type deﬁnes a set of permissible values, the system can give you an error message when you try to use a value that is not permissible. And because a type deﬁnes a set of allowed operations, the system can also give you an error message if you try to apply an operation to the wrong kind of value. Types allow polymorphic operations to be deﬁned. At a simple level, this allows «A < B» to mean different things depending on whether A and B are numbers or dates or strings. At a more sophisticated level, it allows the kind of inheritance and method overriding which is such a pow- erful tool in object-oriented programming. Types allow optimization. To make expressions in a language such as XPath run as fast as pos- sible, the system does as much work as it can in advance, using information that is available at compile time from analysis of the expression itself and its context. A lot of the reasoning that can be done at this stage is based on analysis of the types of values that the expression will pro- cess. For example, XPath has a very powerful «=» operator, in which the operands can not only be any type of value  such as integers or strings  but can also be sequences. Handling the gen- eral case, where both operands are arbitrary sequences containing items of mixed types, can be very expensive. In most cases the operands are much simpler; for example, two integers or two strings. If the system can work out in advance that the operands will be simple  and it often can , then it can generate much more efﬁcient code and save a lot of work at runtime.  Enough of this introduction to type systems in programming languages: let’s get down to details.  Changes in 2.0  XPath 1.0 only supported three atomic types: boolean, double-precision ﬂoating point, and string. This has been generalized to allow all the types deﬁned in XML Schema.  XPath 1.0 supported node-sets  unordered collections of nodes, with no duplicates . XPath 2.0 generalizes this to support sequences, which are ordered and may contain duplicates, and which may contain atomic values as well as nodes.  The thinking on types has changed considerably between XPath 1.0 and XPath 2.0. In 1.0, there were very few types, and very little type checking. Almost all operations were permitted, and runtime errors were very rare. That sounds good on the surface, but what it actually means is that if you make a mistake, you don’t get an error message — you just get the wrong answer back  or no answer at all, which can be even  186   Sequences  more bewildering . This approach to language design generally goes under the name dynamic typing or weak typing, and it is found most often in scripting languages such as JavaScript and Perl. XPath 2.0 has made a signiﬁcant shift toward the other approach to language design, based on static typing or strong typing, which is more characteristic of compiled languages such as C or Java. It has to be said that not everyone is happy with the change, though there are good reasons for it, essentially the fact that XSLT  and its cousin, XQuery  are starting to be used to tackle much bigger problems where a more robust engineering approach is needed.  Actually, the really innovative thing about XPath 2.0 is that it tries to accommodate multiple approaches to typing within a single language. Because XML itself is used to handle a very wide spectrum of different kinds of document, from the very rigidly structured to the very ﬂexible, XPath 2.0 has been designed to accommodate both very ﬂexible and dynamic approaches, where you have no idea what the data is going to look like in advance, to highly structured queries where the structure of the data is regular and predictable and the expression can be optimized to take advantage of the fact. That’s the theory, anyway; in practice, as one might expect, there are a few wrinkles.  5  T y p e s  Sequences  Sometimes object programming languages introduce their data model with the phrase ‘‘everything is an object’’. In the XPath 2.0 data model, the equivalent statement is that every value is a sequence.  By value, we mean anything that can be the result of an expression or an operand of an expression. In XPath 2.0, the value of every expression is a sequence of zero or more items. Of course XPath, like other languages, can use atomic values such as integers and booleans. But in XPath, an atomic value is just a special case of a sequence: it is a sequence of length one.  The items in a sequence are ordered. This means that the sequence  1, 2, 3  is different from the sequence  2, 3, 1 . The XPath 2.0 data model does not have any direct means of representing unordered collections. Instead, where ordering is unimportant, it makes this part of the deﬁnition of an operator on sequences: for example, the distinct-values  function returns a number of values with no deﬁned ordering, and with duplicates disallowed, but the result is still presented as a sequence. The ordering might sometimes be arbitrary and left to the implementation to determine, but there is always an ordering.  The items in a sequence are always numbered starting at 1. The number of items in a sequence  and there- fore, the number assigned to the last item in the sequence  can be obtained using the count  function.  The functions available in XPath 2.0, such as count  and distinct-values  , are listed in Chapter 13.   Sequences have no properties other than the items they contain. Two sequences that contain the same items are indistinguishable, so there is no concept of a sequence having an identity separate from its contents.  A sequence can be empty. Because two sequences that contain the same items are indistinguishable, there is no difference between one empty sequence and another, and so we often refer to the empty sequence rather than to an empty sequence. An empty sequence, as we shall see, is often used to represent absent data in a similar way to nulls in SQL.  The items in a sequence are either atomic values, or nodes. An atomic value is a value such as an inte- ger, a string, a boolean, or a date. Nodes have already been described in Chapter 2. We will examine atomic values in much greater detail later in this chapter. Most sequences either consist entirely of nodes, or entirely of atomic values, but it’s quite legitimate  and occasionally useful  to have a sequence that consists, say, of two strings, an integer, and three element nodes.  187   Types                    188  The relationships between sequences, items, atomic values and nodes are summarized in the simple UML diagram in Figure 5-1.  Sequence  contains  Item  Atomic Value  Node  Figure 5-1  This shows that:  A sequence contains zero or more items An item is itself a sequence An atomic value is an item A node is an item  Although we talk about a sequence containing nodes, this doesn’t mean that a node can only be in one sequence. Far from it. It might be less confusing if we spoke of the sequence containing references to nodes rather than containing the nodes themselves, or if we used a verb other than ‘‘contains’’ — but sadly, we don’t.  A sequence can only contain individual items; it cannot contain or reference other sequences. This is an aspect of the data model that some people ﬁnd surprising, but there are good reasons for it. The usual explanations given are:  Sequences in the XDM model are designed primarily to represent lists as deﬁned in XML Schema. For example, XML Schema allows the value of an attribute to be a list of integers. These lists cannot be nested, so it wouldn’t make sense to allow nested lists in XDM either. Sequences that contain sequences would allow trees and graphs to be constructed. But these would bear no relationship to the trees used to represent XML documents. In XDM we need a representation of trees that is faithful to XML; we don’t need another kind of tree that bears no relationship to the XML model.  The effect of this rule is that if you need a data structure to hold something more complicated than a simple list of items, it’s best to represent it as an XML document.  This is easy when you are using XSLT or XQuery, which allow you to construct nodes in new trees at any time. It’s less easy in standalone XPath, which is a read-only language.    Atomic Values  The simplest way of writing an XPath expression whose value is a sequence is by using a comma-separated list: for example, «1, 2, 3» represents a list containing three integers. In fact, as we will see in Chapter 10, the comma is a binary operator that concatenates two sequences. Remember that a single integer is a sequence. So «1, 2» concatenates the single-item sequence «1» and the single-item sequence «2» to create the two-item sequence «1, 2». The expression «1, 2, 3» is evaluated as « 1, 2 , 3», and it concatenates the two-item sequence «1, 2» with the one-item sequence «3» to produce the three-item sequence «1, 2, 3». This deﬁnition of comma as an operator means that it is also possible to write sequences such as «$a, $b», which concatenates two arbitrary sequences represented by the variables $a and $b.  Sometimes a list of values separated by commas needs to be enclosed in parentheses to prevent ambiguity, for example when it is used as an argument in a function call. For details, see Chapter 10, page 635.  5  T y p e s  Some of the important XPath operations deﬁned on sequences are:                 «count $S » counts the items in a sequence. «$S, $T» concatenates two sequences. «$S[predicate]» selects those items in a sequence that satisfy some condition. «$S[number]» selects the Nth item in a sequence. «for $item in $SEQ return f $item » applies the function «f»  which can actually be any expression  to every item in the sequence $SEQ, and returns the results as a new sequence.  In list processing languages, this is known as a mapping expression .  We will study these operators in much greater depth later in the book.  Sequences also play an important role in navigating trees, as we shall see. The result of a path expression such as « book chapter section» is a sequence of nodes. All operators that apply to sequences in general  including those listed above  can therefore be used to manipulate sequences of nodes selected using path expressions.  So, there are two kinds of item that can be found in a sequence, namely atomic values and nodes. We’ve already studied nodes in some detail in Chapter 2, so now it’s time to look at atomic values.  Atomic Values  It’s easiest to explain what an atomic value is by example: they are things like integers, ﬂoating-point numbers, booleans, and strings.  Every atomic value has a type  it is either an integer, or a string, or a boolean. . . . Broadly speaking, the types that are available are the 19 primitive types deﬁned in XML Schema, such as xs:double, xs:string, or xs:date, which we will examine in this chapter, and types derived from these.  An atomic value either belongs directly to one of these primitive types, or to a type that is deﬁned by restricting one of these primitive types. This may be a built-in type such as xs:NMTOKEN, which is deﬁned in the XML Schema speciﬁcation itself as a restriction of xs:string, or a type deﬁned in a user-written schema. For example, if you have a schema that deﬁnes mf:part-number as a restriction of xs:string, then you can have atomic values whose type is mf:part-number.  A type deﬁnition determines the set of possible values allowed for items of that type. For example, the type xs:boolean has two possible values, called true and false. For a restricted type, the set of possible  189   Types  values is always a subset of the values allowed for its base type. So a type that is deﬁned by restricting «xs:integer» might allow only the values 1 to 20.  An atomic value carries its type with it as a kind of label. If «PY03672» is an mf:part-number, then because of the way the type is deﬁned, it is also an xs:string. This means it can be used anywhere that an xs:string can be used. However, its label still identiﬁes it as an mf:part-number. Conversely, if you write the string literal «"PY03672"» in an XPath expression, the value will be labeled as an xs:string, and even though it meets all the rules that would make it a valid mf:part-number, you cannot use it in places where an mf:part-number is required, because it has the wrong label. To create a value labeled as an mf:part-number, you need to use the constructor function «mf:part-number "PY03672" ».  So the two properties of an atomic value are the value itself, and the type label. If two atomic values are the same in these two respects, then they are indistinguishable. Atomic values do not have any kind of identity separate from their value and their type; there is only one number 42, and only one string ‘‘Venice’’.  In particular, this means that atomic values are not in any way attached to a particular XML document. Atomic values can be extracted from nodes in an XML document, through a process called atomization, described on page 165; but once extracted, they have no residual connection with the document where they originated. Atomic values can also be derived quite independently of any document; for example, as the result of an arithmetic expression.  The full set of primitive atomic types that are available in XPath  that is, types that are not derived by restriction from another type  has been left slightly open-ended. There is an assumption that by default, the 19 primitive types deﬁned in XML Schema will be available. These are:  xs:boolean  xs:decimal  xs:float  xs:double  xs:string  xs:QName  xs:anyURI  xs:hexBinary  xs:base64Binary  xs:NOTATION  xs:date  xs:dateTime  xs:time  xs:duration  xs:gYear  xs:gYearMonth  xs:gMonth  xs:gMonthDay  xs:gDay  Throughout this book we use the namespace preﬁx xs to refer to the namespace http:  www.w3.org  2001 XMLSchema, which is the namespace in which these types are deﬁned.  However, XPath is designed to be used in a wide variety of different environments, and host languages  that is, speciﬁcations that incorporate XPath as a sublanguage  are allowed to tailor this list, both by omitting types from the list and by adding to it. The host language we are primarily concerned with in this book is XSLT 2.0, and this deﬁnes two conformance levels: a basic XSLT processor supports all the above 19 types with the exception of xs:NOTATION, while a schema-aware XSLT processor recognizes the full list.  190   The type xs:integer is unusual. On the one hand it has a special status in the XPath language  it is one of the few types for which values can be written directly as literals . On the other hand, it is actually not a primitive type, but a type that is derived as a restriction of xs:decimal. This is because the set of all possible xs:integer values is a subset of the set of all possible xs:decimal values.  In fact there are four types for which XPath provides a syntax for deﬁning literal constants:  Atomic Types  Type  xs:string  xs:integer  xs:decimal  xs:double  Example literals "New York", ‘Moscow’, ""  3, 42, 0  93.7, 1.0, 0.0  17.5e6, 1.0e-3, 0e0  5  T y p e s  A number can always be preceded by a plus or minus sign when it appears in an XPath expression, but technically the sign is not part of the numeric literal, it is an arithmetic operator.  Values of type xs:boolean can be represented using the function calls false  and true  , listed in the library of functions described in Chapter 13. Values of any other type can be written using constructor functions, where the name of the function is the same as the name of the type. For example, a constant date can be written as «xs:date "2004-07-31" ».  There is one other type we need to mention in this section: the type xs:untypedAtomic. This type is deﬁned not by XML Schema, but in the XPath speciﬁcations  in working drafts it was also in a different namespace, with the conventional preﬁx xdt, which you may still ﬁnd used in some products . This type is used to label values that have not been validated using any schema, and which therefore do not belong to any schema-deﬁned type. It is also used to label values that have been validated against a schema, in cases where the schema imposes no constraints. The set of possible values for this type is exactly the same as the value space for the xs:string type. The values are not strictly strings, because they have a different label  xs:untypedAtomic is not derived by restricting xs:string . Nevertheless, an xs:untypedAtomic value can be used anywhere that an xs:string can be used. In fact, it can be used anywhere that a value of any atomic type can be used; for example, it can be used where an integer or a boolean or a date is expected. In effect, xs:untypedAtomic is a label applied to values whose type has not been established.  If an xs:untypedAtomic value is used where an integer is expected, then the system tries to convert it to an integer at the time of use. If the actual value is not valid for an integer, then a runtime failure will occur. In this respect xs:untypedAtomic is quite different from xs:string, because if you try to use a string where an integer is expected, you will get a type error regardless whether it could be converted or not.  Atomic Types  We’ve been talking about atomic values and we’ve introduced the 19 primitive atomic types. In this section we’ll look at these types more closely, and we’ll also see what other atomic types are available.  Notice that we’re talking here about atomic types rather than simple types. In XML Schema, we use an   declaration to deﬁne any type other than a complex type; that is, any type that doesn’t permit attributes or child elements. Attributes always have simple types, and elements may have simple  191   Types  types if they don’t allow child elements or attributes. But simple types are not necessarily atomic types, because they allow lists. For example, consider the type deﬁnition  taken from the schema for XSLT 2.0 :           This deﬁnes a simple type whose value allows a list of names  the type xs:NCName deﬁnes a name that follows the XML rules: NCName means no-colon-name . An example of an attribute conforming to this type might be «a = "h1 h2 h3"». This is a simple type, but it is not an atomic type. Atomic types do not allow lists.  XML Schema also allows simple types to be deﬁned as a choice; for example, a simple type might allow either a decimal number, or the string «N A». This is referred to as a union type. Like list types, union types are simple types, but they are not atomic types.  Atomic types come from a number of sources.  As well as the 19 primitive types, the XML Schema speciﬁcation deﬁnes 25 derived types that can be used in any schema; together these are referred to as the built-in types. Like the primitive types, these types are all in the XML Schema namespace http:  www.w3.org 2001 XMLSchema.  There is also a second namespace for schema-deﬁned types, called http:  www.w3.org 2001  XMLSchema-datatypes. Frankly, this namespace is best forgotten. It doesn’t provide anything that you don’t get by using the ordinary XML Schema namespace, and it creates some technical problems because the types in this namespace are not exact synonyms of the types in the ordinary namespace. My advice is, don’t go anywhere near it.  XPath 2.0 adds four more atomic types: xs:dayTimeDuration, xs:yearMonthDuration, xs: anyAtomicType, and xs:untypedAtomic. We’ve already covered xs:untypedAtomic in the previous section. The two duration types are described on page 205, later in this chapter.  The type xs:anyAtomicType is simply an abstract supertype for all the other atomic types. It is used mainly in function signatures, when you want to write a function that can handle atomic values of any type  the min   and max   functions are examples .  In a basic XSLT processor  as distinct from one that is schema-aware , the only built-in derived types that are recognized are xs:integer, xs:dayTimeDuration, xs:yearMonthDuration, xs:anyAtomicType, and xs:untypedAtomic.  In a schema-aware processor, all the built-in types are available, and you can also deﬁne your own atomic types in a schema. As we saw in Chapter 4, a type deﬁned in a schema becomes available for use in a stylesheet when the schema is imported using an   declaration.  Implementors can also add their own atomic types. There are a number of reasons they might want to do this. The most likely reason is to make it easier for XPath expressions to make calls on external functions; for example, functions written in C or Java. The XPath speciﬁcation doesn’t say how this is done, and leaves it to implementors to deﬁne. Another reason implementors might want to add extra types is to support XPath access to some specialized database, for example, an LDAP directory. XPath is deﬁned in terms of a data model with an obvious relationship to XML, but there is no reason why other sources of data cannot be mapped to the data model equally well, and doing this effectively might involve deﬁning some custom types.  I mentioned LDAP because it is a hierarchic database, which provides a particularly good ﬁt to the XPath data model.  Generally, any extra types added by the implementor will have names that are in some implementation-controlled namespace.  192                        Atomic Types  In the sections that follow, I will describe the built-in atomic types in a number of groups. These are my own categories, not anything that comes from the speciﬁcations themselves:  The major atomic types: xs:anyURI, xs:boolean, xs:date, xs:dateTime, xs:decimal, xs:double, xs:integer, xs:QName, xs:string, xs:time, xs:dayTimeDuration, and xs:yearMonthDuration. These are the only atomic types that are directly supported in the XPath library of functions and operators for anything but the most trivial of operations. They are therefore the ones you are likely to be using most of the time. The minor atomic types: These are deﬁned as primitive types in XML Schema, but they are not well supported by XPath, and you are unlikely to use them very often. These are xs:gYear, xs:gYearMonth, xs:gMonth, xs:gMonthDay, xs:gDay, xs:duration, xs:float, xs:hexBinary, xs:base64Binary, and xs:NOTATION. The derived numeric types: These are deﬁned by restriction from the xs:integer type. They all deﬁne integers with a limited range of values, for example, xs:positiveInteger, xs:short, xs:unsignedByte. The derived string types: These are deﬁned by restriction from xs:string. They include types like xs:token and xs:NCName that restrict the syntax of the string and deﬁne the treatment of whitespace. The type xs:untypedAtomic: This represents values whose type is unknown, because the value has not been validated by a schema processor. This is a chameleon type, whose values can be used freely in any context, provided that the value can be converted at runtime to the type that’s expected.  5  T y p e s  There are two ways to use these atomic types:  You can use them in a schema to deﬁne the types of elements and attributes. When you do this, the result of validating an XML document against this schema will be that the elements and attributes acquire a type annotation of the appropriate atomic type, and the typed value of the nodes  which is what you typically get when you use the node as input to an operation such as addition  will be the atomic value of the relevant type. You can manipulate atomic values of these types in your XPath expressions. For example, if you compare two strings, the result is a boolean, that is, a value of type xs:boolean. This value has never been anywhere near an XML document, let alone an XML Schema validator, but it is an xs:boolean all the same.  The Major Atomic Types  This section describes the most important atomic types used in XPath expressions, in alphabetical order. These types are chosen because they are the ones that are supported in the standard library of functions and operators deﬁned in XPath, in particular the functions listed in Chapter 13. They are probably the types you will use 95% of the time.  xs:anyURI  This type is intended to hold URIs, in the widest sense of the term. This includes:           Absolute URIs such as «http:  www.w3.org » Relative URI references such as «.. index.html» URIs with a fragment identiﬁer at the end, separated by a «» character: for example «http:  www.w3.org TR xpath20Introduction» or simply «Introduction»  193   Types     Unescaped URIs such as «file:   My Documents biog.doc». Technically, this is not a URI because it contains a space character. To make it into a URI, the space must be escaped so it appears as «file:   My%20Documents biog.doc». A number of speciﬁcations such as XML Linking explicitly allow a URI to be held in its unescaped form  because it isn’t a real URI until it is escaped, I sometimes refer to it as a wannabe-URI . And although these aren’t real URIs, XML Schema explicitly allows them to appear in an xs:anyURI value.  Most types in XML Schema are rather speciﬁc about exactly what is allowed in the value space of the type  for example, xs:boolean has two values, true and false , and how these values may be written in a source document  the lexical representation: with xs:boolean the values «0», «1», «true», and «false» are permitted . Most types also deﬁne a canonical lexical representation for each value in the value space, which is the representation that will be chosen when a typed value is converted to a string.  For the xs:anyURI type, these deﬁnitions have been fudged. Though the wording makes it clear that the intention is for xs:anyURI items to hold a URI as deﬁned in the relevant internet RFCs  the most recent is http:  www.ietf.org rfc rfc3986 , they stop short of saying that a schema validator is expected to check that the contents actually conform with these rules. There is good reason for this reticence: many commonly used URIs don’t actually conform with the rules in the RFC, and in any case, the rules in the RFC are not always clear.  I have read some books on XML Schema that suggest that in the value space of xs:anyURI, the value is always escaped  as in the example «file:   My%20Documents biog.doc»  and that conversion from the lexical form used in a source document to the value space should therefore cause this escaping to happen. This would mean that when you compare two xs:anyURI values, differences caused by one of them being escaped and the other not don’t matter. This appears to be an incorrect interpretation of the spec. In practice schema processors often allow any string to be used as an xs:anyURI value, and they leave the string unchanged when converting it to its internal representation. This interpretation is endorsed by the draft XML Schema 1.1 speciﬁcation, which clariﬁes the intention.  Although xs:anyURI is a primitive type in XML Schema, the XPath type system treats it almost as if it were a subtype of xs:string. In particular, you can pass an xs:anyURI value to any function or operator that expects a string, and it will be implicitly converted. Many of the functions in the standard library that you might expect to take xs:anyURI arguments  an example is the resolve-URI   function  in fact have a function signature that requires a string to be supplied. The special rule for promotion of xs:anyURI to xs:string ensures that either type is accepted.  Similarly, the promotion rule means that it is possible without formality to compare an xs:anyURI value to a string literal. The only downside of this pragmatic approach is that comparisons between xs:anyURI values are performed using the default collation, which might be quite inappropriate for comparing URIs. But this applies equally to some types derived from xs:string, such as xs:NCName. If you want a strict comparison, you can use the function codepoint-equal   instead of the «eq» or «=» operators.  This is the simplest type deﬁned in XML Schema. It has two values in the value space, referred to as true and false, and each of these has two permitted lexical representations: «1» and «true», «0» and «false».  Although it’s so simple, there are some interesting quirks in the way XML Schema and XPath handle this type.     As far as XML Schema is concerned, the xs:boolean type has no ordering. But in XPath, there is an ordering: false is considered to be less than true. XPath 2.0 has taken this position largely for  xs:boolean  194   Atomic Types     backward compatibility with XPath 1.0, and also because it can actually be useful; for example, a stylesheet might use the expression «age < 18» as a sort key, which will output the adults ﬁrst, then the children. There are two ways of converting a string to a boolean. An XML Schema processor interprets «1» and «true» as true, «0» and «false» as false. This behavior also occurs when you use the xs:boolean   constructor  described in Chapter 11 . But if you use the boolean   function  or fn:boolean   if you want to write it with a namespace preﬁx , as described in Chapter 13, then a zero-length string translates to false, and everything else to true. This is also the result you get if you do an implicit conversion of a string to a boolean by using a string in a context such as «if  S  then A else B», where S is a string. Again, the difference is partly historic: the XPath 1.0 rules were invented before XML Schema came along. But the convention of equating a zero-length string to false also has a long history in weakly typed programming languages, and is very convenient in some recursive algorithms that need to terminate when the argument is a zero-length string.  5  T y p e s  xs:date  The xs:date type represents a date. The lexical representation of the date  that is, the way it appears in a textual XML document  is always the representation deﬁned in the ISO 8601 standard, that is YYYY-MM-DD  for example, «1999-11-16» for November 16, 1999 . This format is chosen because it is unambiguous; the theory is that XML documents should represent information in a neutral form that is independent of how different users might want to see the information formatted.  For formatting dates and times in a user-friendly way, XSLT provides the format-date   function, which is described in Chapter 13. This isn’t available in standalone XPath expressions  or in XQuery .  A rather quirky feature of the xs:date type is that as well as holding the date itself, it can also hold a timezone. This is something that ISO 8601 itself doesn’t allow. The idea is that a date actually represents a period of 24 hours starting at midnight in a particular timezone, and ending at the following midnight in the same timezone. The date November 16, 1999 represents a different period of 24 hours in New York from the period it represents in London, Tokyo, or Los Angeles, so the schema designers came up with the idea of adding a timezone to the date to indicate exactly when the date begins and ends. In the lexical representation, the timezone is added after the date part, for example «1999-11-16-05:00» represents a date in the timezone that is ﬁve hours behind UTC  the timezone used in the Eastern United States during the winter months . The timezone is optional; it is also possible to have a date value with no timezone, in which case the precise beginning and end of the 24-hour period represented by the value are considered to be unknown.  XML Schema doesn’t deﬁne how dates are represented internally in the system, but it does deﬁne a value space for every type. If two different lexical values translate into the same value in the value space, then they are completely equivalent  to the extent that when you copy an element or attribute, the original lexical representation won’t necessarily be retained . For dates  as distinct from times  the XML Schema and XPath speciﬁcations agree that the timezone is part of the value space: that is, «1999-11-16-05:00» represents a different xs:date value from «1999-11-16+01:00». However, «1999-11-16+13:00»  used in Tonga  is equivalent to «1999-11-15-11:00»  used in nearby Samoa , because both dates start at the same instant.  This gives the problem of deciding whether a date that speciﬁes a timezone  for example «1999-11- 16-12:00»  comes before or after a date that doesn’t specify a timezone  for example «1999-11-16»  when you want to perform comparison operations or sorting. If both dates have timezones, the answer is clear enough: the dates are sorted in order of their starting instants. And if neither has a timezone, you  195   Types  can assume that they relate to the same timezone. But if one has a timezone and the other doesn’t, it’s not obvious what the answer should be. XML Schema takes a rather purist view, saying that dates are partially ordered, which means that for some pairs of dates you don’t know which one comes ﬁrst. For an expression language like XPath, partial ordering is a nightmare: the system has to come up with some kind of answer. The answer chosen was that the system environment contains an implicit timezone that can be used as a default, and when dates with no timezone have to be compared or sorted, the system will assume that they refer to this implicit timezone. We look more closely at the implicit timezone when we examine the XPath evaluation context in Chapter 7.  The operations you can perform on a date include:                       Comparing and sorting dates Converting dates to and from strings Extracting the component parts of a date  year, month, day, timezone  Adding a duration to a date  or subtracting a duration  to get another date Determining the difference between two dates, as a duration Converting the value to an xs:dateTime  the result is the starting instant of the date  In XSLT only, formatting a date for human consumption  for example, as «Wednesday 16th November»   Dates held using this type are always supposed to be Gregorian dates, even if they predate the introduc- tion of the Gregorian calendar  which happened at different times in different countries . In principle, historic events are supposed to have their dates adjusted to represent them using the modern calendar.  Negative dates  BC dates  are supported, but they are a minor disaster area in XML Schema. According to XML Schema 1.0, the year zero is not allowed, and the year before 0001 is represented as –0001. However, shortly before XML Schema 1.0 was published, a new edition of ISO 8601 came out that stated that the year before 0001 should be represented as 0000. The draft XML Schema 1.1 speciﬁcation has changed to match this, despite the fact that this affects the meaning of data in existing documents, and the results of queries. In practice, I would advise against using this type for historical dates. For most applications it’s probably better to represent them using their original calendar.  xs:dateTime  The xs:dateTime type represents the combination of a date and time, that is, it represents an instant in time. The lexical representation is again based on ISO 8601, for example it might be «2008-04- 12 T13:05:00Z» to represent ﬁve minutes past one in the afternoon of April 12, 2008, in the timezone Z  Z represents Coordinated Universal Time, abbreviated to UTC, and often still referred to by its older name of Greenwich Mean Time, or GMT .  The seconds part of an xs:dateTime can contain a fractional part. The number of signiﬁcant digits that are retained is implementation-deﬁned, but must be at least three.  As with xs:date, the complications with dates and times are all to do with timezones  if only the world could agree to synchronize its clocks, the problem would disappear . XML Schema takes the view that the value space of xs:dateTime represents instants in time, and that «2008-04-12 T13:05:00Z» and «2008-04-12 T08:05:00-05:00» are the same instant in time  ﬁve past one in London is ﬁve past eight in New York , and are therefore indistinguishable.  The XSLT and XQuery working groups didn’t feel it was acceptable that the original timezone information written in the source XML document should be simply thrown away. It didn’t seem right, for  196   Atomic Types  example, that a transformation that copies a source document containing the value «2008-04- 12 T08:05:00-05:00» should produce the value «2008-04-12 T13:05:00Z» in the result document. Although it’s right to consider the two values as being equal  in the same way that 1 and 01 are equal  it seems that there is some information content in the timezone that the user probably wants to hold on to. So, after much agonizing and debate between the working groups, the XDM model deﬁnes a value space that retains the original timezone as well as the ‘‘instant in time’’. This doesn’t affect the test whether two xs:dateTime values are equal, but it does affect other operations, for example the operation of converting an xs:dateTime value to a string  which will reconstitute the original timezone .  Like xs:date values, xs:dateTime values don’t need to specify a timezone, and XPath adopts the same solution: they are assumed to apply to an implicit timezone taken from the evaluation context.  5  T y p e s  The operations you can perform on an xs:dateTime include:                          Comparing and sorting dateTimes Converting dateTimes to and from strings Extracting the component parts of a dateTime  year, month, day, hour, minutes, seconds, timezone  Adding a duration to a dateTime  or subtracting a duration  to get another dateTime Determining the difference between two dateTimes, as a duration Extracting the date or time part separately Adjusting the timezone: that is, creating an equivalent dateTime with or without a timezone, or with a different timezone  see the adjust-dateTime-to-timezone   function on page 715  In XSLT only, formatting a dateTime for human consumption  for example, as «Wednesday 16th November, 1.30p.m.»   xs:decimal  The xs:decimal type represents numbers that can be accurately expressed in decimal notation. This type is useful for values such as amounts of money, where the actual value space is discrete rather than con- tinuous, and where the rounding errors that arise with binary formats such as xs:double and xs:float are undesirable.  In a user-deﬁned subtype of xs:decimal, the values can be restricted in terms of the total number of allowed digits, and the number of digits allowed after the decimal point. If the built-in type xs:decimal is used without restriction, the number of digits allowed must be at least 18, though it can be greater than this if the implementation chooses. Some implementations may use an unlimited-precision representation  Saxon does, for example .  Any numeric literal written with a decimal point in XPath 2.0  but without using exponential notation  represents an xs:decimal value, for example the literal «3.50». Note that this represents exactly the same xs:decimal value as the literal «3.5»: in general, trailing zeros after the decimal point will be lost when xs:decimal values are manipulated, which can be a bit awkward when you are handling amounts of money. For example, the result of «2.44 + 2.56» is displayed as «5». XSLT has a function format-number   that allows you to control the way values are formatted; for example, you can use a picture of «0.00» to ensure that there are always two digits after the decimal point. But there is no equivalent to this in XPath or XQuery.  XPath 2.0 offers a full range of arithmetic operators and functions on xs:decimal values. These are summarized in the entry for xs:double which follows this entry. The arithmetic operators are described in more detail in Chapter 8, and the functions are listed in Chapter 13. When you apply these operators 197   Types  xs:double  and functions to xs:decimal operands, the result is generally also an xs:decimal. In the case of oper- ators with two operands, you can mix xs:decimal with other numeric types; if the other operand is an xs:float or xs:double, then the xs:decimal is converted to an xs:float or xs:double as appropriate, and the result will also be an xs:float or xs:double.  The main operation that can cause problems is division. The division operator in XPath is div, because « » is reserved for use in path expressions. Division by zero is a fatal error. When you perform a divi- sion that does not have an exact decimal result, for example «10 div 3.0», the precision of the result is implementation-deﬁned. One implementation might give you 3.333333, another might give you 3.333333333333. An implementation could even claim to be conformant if it gave you the answer 3, though it might not prove popular in the marketplace if it did that.  When a decimal number is displayed as a string, it is shown as an integer if there are no signiﬁcant digits after the decimal point. So the result of «2.5 + 2.5» is displayed as «5».  The xs:double type represents double-precision ﬂoating-point numbers. This was the only numeric type supported in XPath 1.0, and it is therefore the default for some operations where backward compatibil- ity is important; in particular, if you apply numeric operations to the value of a node in a schemaless document, the system will try to convert the contents of that node to an xs:double value.  An xs:double is a double-precision  64-bit  ﬂoating-point number, and its behavior is deﬁned to follow the IEEE 754 standard. This standard  IEEE Standard for Binary Floating-Point Arithmetic. ANSI IEEE Std. 754-1985  has been widely implemented by many microprocessors for some years, but it is only through its adoption in the Java language that it has become familiar to high-level language programmers. If you understand how ﬂoating point behaves in Java, the contents of this section will be quite familiar; if not, they may be rather strange.  XPath 2.0 introduces the ability to use scientiﬁc notation for ﬂoating-point numbers, either on input or on output. If you want to enter the number one trillion, you can now write 1.0E12. In fact, if you want to write an xs:double as a literal in an XPath expression, you must write it in scientiﬁc notation: otherwise, it will be treated as an xs:decimal  if it has a decimal point  or as an xs:integer  if not .  On output, that is when you convert an xs:double to a string, scientiﬁc notation is used only if the abso- lute value is smaller than 0.000001, or greater than 1,000,000. This means that most everyday numbers will be formatted in ordinary decimal notation on output. In XSLT, you can control the format of numeric output more precisely by using the format-number   function, which is described in Chapter 13.  In general, I recommend using xs:double for numbers that are on a continuous scale  for example, dis- tances, weights, or temperatures , and using xs:decimal for numbers that represent discrete quantities, such as sums of money. But this is only rough guidance.  IEEE 754 deﬁnes the following range of values for a double-precision number: Value Finite nonzero values  Description These are values of the form s × m × 2e, where s  the sign  is +1 or –1, m  the mantissa  is a positive integer less than 253, ande  the exponent  is an integer between –1075 and 970, inclusive  Positive zero  This is the result of subtracting a number from itself. It can also result from dividing any positive number by inﬁnity, or from dividing a very small number by a very large number of the same sign.  continued  198   Atomic Types  Value Negative zero  Positive inﬁnity  Description This is the result of dividing any negative number by inﬁnity. It can also result from dividing a positive number by minus inﬁnity, or from dividing a very small negative number by a very large positive number, or vice versa.  This is the result of dividing any positive number by zero. It can also result from multiplying two very large numbers with the same sign. Note that division by zero is not an error: it has a well-deﬁned result.  Negative inﬁnity  This is the result of dividing any negative number by zero. It can also result from multiplying two very large numbers with different signs.  NaN  Not a Number. This is the result of attempting to convert a non-numeric string value to a number. It can also be used to mean ‘‘unknown’’ or ‘‘not applicable’’, like the SQL null value.  5  T y p e s  These values cannot all be written directly as XPath constants. However, they can be expressed as the result of expressions, for example:  Value Negative zero  Positive Inﬁnity  Negative Inﬁnity  NaN  XPath expression –0e0  1 div 0e0  –1 div 0e0  number ‘‘NaN’’   Technically, negative numbers cannot be written directly as constants: «-10» is an expression rather than a number, but in practice it can be used anywhere that a numeric constant can be used. The only thing you need to be careful of is that a space may be needed before the unary minus operator if you write an expression such as «$x div -1».  Except for NaN, number values are ordered. Arranged from smallest to largest, they are:                 Negative inﬁnity Negative ﬁnite non-zero values Zero  positive and negative zero are equal to each other  Positive ﬁnite non-zero values Positive inﬁnity  This ordering determines the result of less-than and greater-than comparisons, and in XSLT it determines the result of sorting using   or   with a sort key speciﬁed using  .  NaN is unordered, so the operators « », and «>=» return false if either or both operands are NaN. However, when   is used to sort a sequence of numeric values that includes one or more NaN values, NaN values are collated at the start of the sequence  or at the end if you choose descending order .  199   Types  200  Positive zero and negative zero compare equal. This means that the operators «=», « =» return true, while «!=», «  » return false. However, other operations can distinguish positive and negative zero; for example, «1.0 div $x» has the value positive inﬁnity if $x is positive zero, and negative inﬁnity if $x is negative zero.  The equals operator «=» returns false if either or both operands are NaN, and the not-equals operator «!= » returns true if either or both operands are NaN. Watch out for the apparent contradictions this leads to; for example, «$x = $x» can be false, and «$x < $y» doesn’t necessarily give the same answer as «$y > $x».  The simplest way to test whether a value $x is NaN is:  if  $x!=$x  then ...  If this seems too obscure for your taste, then provided you know that $x is numeric you can write:  if  string $x =’NaN’  then  If you are familiar with null values in SQL, some of this logic might seem familiar, but there are some subtle differences. For example, in SQL the condition «null = null» has the value null, so that «not null = null » is also null, while in XPath «NaN = NaN» is false, so that «not NaN = NaN » is true.  XPath provides a number of operators and functions that act on or return numeric values:                                   The numerical comparison operators «   », and « >= ». Within a stylesheet, you may need to use XML escape conventions to write these, for example, « &lt; » in place of « < ». The numerical equality operators «=» and «!= ». The unary minus operator «-». The multiplicative operators «*», «div», and «mod». The additive operators «+» and «-». The number   function, which can convert from any value to a number. The string   function, which converts a number to a string. The boolean   function, which converts a number to a Boolean. The abs   function returns the absolute value of a number. The functions round  , ceiling  , floor  , and round-half-to-even  , which convert a num- ber to an integer. The aggregate functions sum  , avg  , max  , and min  , which produce a single xs:double value when applied to a sequence of xs:double values.  Operators on numbers behave exactly as speciﬁed by IEEE 754. XPath is not as strict as Java in deﬁning exactly what rounding algorithms should be used for inexact results, and in what sequence operations should be performed. In fact XPath 2.0 is more liberal than XPath 1.0, in that it allows any of the options permitted by IEEE 754 to be chosen. These include, for example, producing an error on overﬂow rather than returning positive or negative inﬁnity.  Many implementations, however, are likely to follow the Java rules. In this case, numeric operators and functions never produce an error. An operation that overﬂows produces positive or negative inﬁnity, an operation that underﬂows produces positive or negative zero, and an operation that has no other sensible   Atomic Types  result produces NaN. All numeric operations and functions with NaN as an operand produce NaN as a result. For example, if you apply the sum   function to a sequence, then if the sequence contains a NaN value, the result of the sum   function will be NaN.  xs:integer  The xs:integer type supports the positive and negative natural numbers. Neither XML Schema nor XPath 2.0 dictate what the maximum value of an integer is. XML Schema has a rule that implementations must support at least 18 decimal digits. But one of the subtypes of xs:integer, namely xs:unsignedLong, supports values in the range 0 to 18,446,744,073,709,551,615. This requires 20 digits, so an implementation that stops at 18 is going to struggle to pass some of the conformance tests.  5  T y p e s  Unlike all the other types that I classify as major types, xs:integer is not a primitive type but a derived type. It is derived by restriction from xs:decimal. This means that every valid xs:integer is also a valid xs:decimal, and anywhere that an xs:decimal can be used, an xs:integer can be substituted. The actual nature of the restriction is that the xs:integer type contains all xs:decimal values that have no signiﬁcant digits after the decimal point.  The xs:integer type follows the pattern of the other numeric types, in that all the arithmetic operators and functions, when applied to an xs:integer argument  or to two xs:integer operands  produce an xs:integer as their result.  The main exception to this is division. XPath 2.0 provides two division operators. The div operator treats integer operands as xs:decimals, and produces an xs:decimal result  so «5 div 2» is 2.5 . The idiv operator  for integer division  produces an xs:integer result, so «5 idiv 2» is 2. Closely related to this is the avg   function: the average of a sequence of xs:integer values is an xs:decimal.  xs:QName  The xs:QName type is a rather specialized type whose values hold XML qualiﬁed names.  An xs:QName has two forms. In its lexical form, it consists of either a simple local name  such as «product»  or a local name qualiﬁed by a namespace preﬁx  such as «mfg:product» . In its expanded form, it holds two signiﬁcant components: a namespace URI  possibly null  and a local name, but it also retains the preﬁx so that the original lexical representation can be reconstituted on output.  There is no direct string representation of the expanded value, though in some interfaces  for example in the Java JAXP interface  expanded QNames are represented in a notation devised by James Clark, of the form «{namespace-uri}local-name»; for example, «{http:  www.mfg.org ns}product».  This type is unusual  and, one might add, a great nuisance  because it is not possible to translate between the lexical form and the internal value space without having additional context information. A schema validator gets this context information from the namespace declarations that surround the element or attribute where the QName appears. For XSLT processors, which have the job of extracting parts of a document and copying them into different places, this dependency on context information causes no end of hassle: it isn’t safe to copy a QName to a new location unless you also copy its context information. This is why the spec devotes so much attention to the arcane matter of namespace nodes. It’s also for this reason that there are restrictions on what you can do with an xs:QName — for example, you can’t have a parentless attribute node of type xs:QName because there would be nowhere to put the namespace bindings.  To reduce the problems associated with xs:QName, the XPath type differs from the XML Schema deﬁnition by maintaining the namespace preﬁx as part of the value. The preﬁx plays no part in comparisons, but  201   Types  it is used when converting the value to a string. This means that xs:QName values, like all other atomic values, can always be converted to a string, which greatly reduces the number of special rules needed to handle tree construction and serialization.  One of the ideas behind deﬁning xs:QName as a primitive type in XML Schema was so that the XML infrastructure would know which parts of the document have dependencies on namespace declarations, and would therefore be able to ensure that the relevant namespace declarations are kept around when data is copied. Unfortunately this doesn’t work, because you can have namespace-sensitive data in a doc- ument without declaring it as an xs:QName. For example, if your document contains XPath expressions  which it will do if it happens to be a stylesheet, but it’s not uncommon to ﬁnd them in other kinds of document as well , then it will necessarily contain namespace-sensitive content that isn’t ﬂagged as such, because an XPath expression is more complex than a simple xs:QName.  What operations does XPath support on xs:QName values?           You can compare two QNames for equality. This sounds trivial, but it is probably the most important reason for using them. The comparison checks both the namespace URI and the local name, and it ignores the preﬁx. Moreover, the proper rules are used for this compari- son; it’s not subject to the uncertainties that arise when comparing strings; for example, whether accents are signiﬁcant and whether lower case compares equal to upper case. For example, the test:  node-name .  = QName "http:  www.mfg.org ns", "product"   is comparing two xs:QName values. This is much more reliable than the test:  name .  = "mfg:product"  which could go wrong for two reasons: it’s dependent on the choice of namespace preﬁx, and it’s doing a string comparison using the default collation, which might compare strings such as «product» and «Product» as equal if that’s the way it’s been set up. There’s more detail on colla- tions in the next section, which discusses the xs:string type. You can convert a QName to a string. This uses the preﬁx held as part of the value, if there is one, or returns an unpreﬁxed name otherwise. You can construct an expanded QName from the namespace URI and local-name using the QName   function shown above, and you can extract these two components using the rather clumsily named functions local-name-from-QName   and namespace-uri-from-QName  .  You can convert a string to a QName, but only if you write it as a string literal. For example, you can write «xs:QName "mfg:product" », which will produce the expanded QName whose local-name is «product», and whose namespace URI is the namespace URI corresponding to the «mfg» preﬁx. The reason for this restriction is to ensure that the conversion can be done at compile time, when the namespace context is known. In XSLT there are plenty of other places where the namespace context has to be retained at runtime, so it would have been no great hardship for implementors to avoid limiting it this way; but the restriction isn’t a great hardship for users either because the QName   function provides the ability to construct any QName dynamically knowing the namespace and local name.  A string value in XPath is any sequence of zero or more characters, where the alphabet of possible char- acters is the same as in XML: essentially the characters deﬁned in Unicode.  xs:string  202   Atomic Types  String values can be written in XPath expressions in the form of a literal, using either single quotes or double quotes, for example «‘John’» or «"Mary"». In theory, the string literal can contain the opposite quote character as part of the value, for example «"John’s"». In practice, certainly in XSLT, XPath expres- sions are written within XML attributes, so the opposite quote character will generally already be in use for the attribute delimiters. For more details, see the section StringLiteral in Chapter 7, page 532.  There is no special null value, as there is in SQL. Where no other value is appropriate, a zero-length string or an empty sequence is used. These are not the same thing: an empty sequence is a sequence containing no items  «count $x » returns 0 , while a zero-length string is a sequence containing a single item, whose type is xs:string and whose value has a string-length of zero  «count $x » returns 1, «string-length $x » returns 0 . However, although zero-length strings and empty sequences aren’t the same thing, most of the functions in the standard library  see Chapter 13  give the same answer when an empty sequence is supplied as when a zero-length string is supplied.  5  T y p e s  The speciﬁcations try always to use the term zero-length string for the value «""», to avoid any possible confusion, but occasionally the terms null string and empty string slip in by mistake.  The actual set of Unicode characters permitted in XML changes between XML 1.0 and XML 1.1. The XPath 2.0 speciﬁcations leave it to the implementor to decide which version of XML to align with.  In XML 1.0, the only ASCII control characters permitted  codes below x20  are the whitespace charac- ters x09, x0A, and x0D  tab, newline, and carriage return . In XML 1.1, all control characters other than x00 are allowed, though you have to write them using XML character references rather than in their native encoding. For example, the BELL character, which in former times was used to ring the bell on a teletype machine, but nowadays is more likely to result in an irritating electronic beep, is represented as «&x07;». The requirement to use this form is because some of these control characters have special meaning in communications protocols that may be used to carry XML documents. The exclusion of the x00 character  sometimes called NUL  is probably a concession to programmers writing XML parsers and related software in C, where this character is treated as a string delimiter. It also has the effect — probably deliberate — that you still can’t use XML directly to convey binary data, you have to encode it as charac- ters. As we will see  on page 208 , XML Schema provides two types to help with this, xs:hexBinary and xs:base64Binary.  Unicode was originally deﬁned so that all characters would ﬁt in two bytes  the highest code point was 65,535 , but it has since outgrown that limit, and now deﬁnes characters using code points up to 1,114,111. In programming languages such as Java, there is poor support for Unicode characters above 65,535, and they appear in the application as a surrogate pair: two char values that have to be processed as a pair.  Java 5 provides library support for higher codepoints, but the basic types char and String have not changed . In XPath, you don’t have to worry about surrogate pairs. Each character, even those above 65,535, is counted as a single character. This affects functions such as string-length  , which counts the number of characters in a string, and substring  , which extracts the characters at particular positions in the string.  Strings may be compared using the «=» and «!=» operators, as well as « », « =». The exact way in which these work is context-dependent. Strings are always compared using a collation, and it is up to the collation to decide, for example, whether the two strings «naive» and «na¨ıve» are equal or not  spot the difference . XPath itself doesn’t deﬁne what the default collation is  and neither does XSLT , it leaves the choice to the user, and the way you select it is going to depend on the conﬁguration options for your particular XSLT processor. If you want more control over the choice of a collation, you can use the compare   function, which is described in detail in Chapter 13  see page 727 .  203   Types  The handling of the «   » operators is not backward compatible with XPath 1.0. In XPath 1.0, these operators, when applied to two strings, attempted to convert both strings to numbers, and compared them numerically. This meant, for example, that «"4" = "4.0"» was false  because they were compared as strings , while «"4" >= "4.0"» was true  because they were compared as numbers . In XPath 2.0, if you want to compare strings as numbers, you must convert them to numbers explicitly, for example by using the number   function.  The library of functions available for handling strings is considerably expanded from XPath 1.0. It includes:  concat   and string-join   to concatenate strings with or without separators contains  , starts-with  , and ends-with   to test whether a string contains a particular substring substring  , substring-before  , and substring-after   to extract part of a string upper-case   and lower-case   to change the case of characters in a string string-length   to ﬁnd the length of a string normalize-space   to remove unwanted leading, trailing, and inner whitespace characters normalize-unicode   to remove differences in the way equivalent Unicode characters are rep- resented  for example, the letter «c¸» with a cedilla can be represented as either one Unicode character or two   Perhaps the most powerful addition to the string-handling capability in XPath 2.0 is the introduction of support for regular expressions, familiar to programmers using languages such as Perl. Regular expres- sions provide a powerful way of matching and manipulating the contents of a string. They are used in three functions:  matches   tests whether a string matches a particular regular expression. For example, «matches "W151TBH", " ˆ [A-Z][0-9]+[A-Z]+$" » returns true.  This regular expression matches any string consisting of one uppercase letter, then one or more digits, and then one or more letters.  replace   replaces the parts of a string that match a given regular expression with a replace- ment string. For example, «replace "W151TBH", " ˆ [A-Z] [0-9]+ [A-Z]+$", "$1" » returns «151». The «$1» in the replacement string supplied as the third argument picks up the characters that were matched by the part of the regular expression written in parentheses. tokenize   splits a string into a sequence of strings, by treating any character sequence that matches the regular expression as a separator. For example, «tokenize "abc 123 x", " " » returns the sequence «"abc", "123", "x"».  All these functions are described in detail in Chapter 13. The syntax of regular expressions is described in Chapter 14.                                The xs:time type represents a time of day, for example, 12:15:00. Like an xs:dateTime, it can represent the fractional number of seconds to an arbitrary precision determined by the implementation  at least three decimal digits are required , and it can optionally include a timezone. A time with a timezone is written, for example, as «12:15:00+01:00» to indicate a timezone one hour ahead of UTC  as used in much of continental Europe during the winter months, and in Britain during the summer .  xs:time  204   Atomic Types  Like xs:date and xs:dateTime values, xs:time values without an explicit timezone are assumed to apply to an implicit timezone taken from the evaluation context.  Operations you can perform on an xs:time include:                       Comparing and sorting times Converting times to and from strings Extracting the component parts of a time  hour, minutes, seconds, timezone  Adding a duration to a time  or subtracting a duration  to get another time Determining the difference between two times, as a duration Combining the time with a date to create an xs:dateTime Adjusting the timezone: that is, creating an equivalent time with or without a timezone, or with a different timezone  see the adjust-time-to-timezone   function on page 715   5  T y p e s  Although timezones are complex enough already, one problem that the XPath model doesn’t tackle is daylight savings time  also known as summer time . If you want to use xs:time values to represent, say, a schedule of ﬂights departing from Logan Airport in Boston, then you probably want to use the value «13:15:00» to mean ‘‘a quarter past one, in Boston’s time zone’’. Specifying this as «13:15:00-05:00» would be incorrect, because for half the year Boston is ﬁve hours behind UTC, and for the other half it is only four hours behind. My recommendation in this situation would be not to store a timezone with the value itself, but to use some other way of representing the information  for example, a timezone attribute on the containing element . Alternatively, it might be better to hold all times internally in UTC  sometimes called Zulu time  and only convert them to a local timezone for display purposes.  A particular problem that is unique to xs:time values is comparison and sorting, because the natural ordering is cyclic. For example, most people would agree that 18:00:00 is before 23:59:00, but is it before 00:00:00? And is 20:00:00-05:00  8 p.m. in New York  before or after 00:30:00Z  half past midnight in London ?  There is no correct answer to this question, but the rule that XPath has adopted is chosen to give the least number of surprises. The rule is to take an arbitrary date  the example used in the spec is 1972-12-31 , and treat both times as representing xs:dateTime values on this date; then compare the resulting xs:dateTime values. So 18:00:00-05:00  6 p.m. in New York  is before 22:00:00-05:00  10 p.m. in New York  because 1972-12-31 T18:00:00-05:00 was earlier than 1972-12-31 T22:00:00-05:00. Less predictably, 20:00:00-05:00  8 p.m. in New York  is after 00:30:00Z  half past midnight in London  because 1972-12-31 T20:00:00-05:00 is the same instant as 1973-01-01 T01:00:00Z, which is well after 1972-12-31 T00:30:00Z.  xs:dayTimeDuration and xs:yearMonthDuration  XML Schema provides a primitive type xs:duration, which we will discuss brieﬂy on page 208. A duration represents a period of time, expressed in years, months, days, hours, minutes, seconds, and fractions of a second.  Durations that mix these different units are difﬁcult to handle because the length of a month is variable. For example, what should be the result of comparing a duration of one month with a duration of 30 days? XML Schema addresses this problem by deﬁning a partial ordering for durations, which means that some durations are clearly longer than others, but for some pairs of durations  like the example just cited , the relative magnitude is undeﬁned.  205   Types  The idea of a partial ordering makes life rather difﬁcult for a language like XPath. Operations like «=» and «<» need to produce a yes-or-no answer, introducing a ‘‘maybe’’ would complicate the language immensely. For this reason, XPath decided to introduce two new duration types, which are deﬁned as subtypes of xs:duration. The xs:dayTimeDuration handles durations expressed in days, hours, minutes, seconds, and fractions of a second, while xs:yearMonthDuration handles durations in years and months. These behave much more cleanly: an xs:dayTimeDuration is just a decimal number of seconds, and an xs:yearMonthDuration is just an integer number of months.  You can manipulate these two duration subtypes using arithmetic operators and functions; for example, you can add and subtract two durations to give another duration, you can multiply or divide a duration by a number to get another duration, and you can divide one duration by another to get the ratio between the two durations as a number  more speciﬁcally, as an xs:double . You can also use functions such as sum   and avg   to get the total or average of a sequence of durations.  I personally prefer to use numbers for most of these operations. There’s no reason why you can’t use an xs:double to represent a duration in seconds, just as you would use one to represent a distance, a weight, a temperature or a voltage. Many calculations in fact become easier when you represent durations as numbers: for example, there is no way to divide a distance by a duration to obtain an average speed, except by converting the duration to a number. Similarly, if you want to work out how much to pay someone who has worked for ﬁve hours at $10 hour, it’s no use multiplying the duration ﬁve hours by 10: the answer will be 2 days and 2 hours, not $50.  To convert a dayTimeDuration to a number of seconds, divide it by xs:dayTimeDuration ‘PT1 S’ . Similarly, to convert a number of seconds to a dayTimeDuration, multiply it by xs:dayTimeDuration  ‘PT1 S’ .  Where the duration types do prove useful is when they are used in conjunction with dates and times. You can add a duration to a date or time to get another date or time, and you can subtract one date or time from another to get a duration.  Durations are written lexically in the notation deﬁned by the ISO 8601 standard. The general form is the letter «P», followed by one or more of the components nY for the years, nM for the months, nD for days, nH for hours,n M for minutes, and nS for seconds. A «T» is used as a separator between the days and the hours. All the values are integers except for the seconds, which may be fractional. Zero components may be omitted  though at least one component must be present , and a negative duration may be written with a leading minus sign. So «P10Y6 M» is 10 years 6 months, while «PT10H30 M» is 10 hours, 30 minutes. XML Schema 1.0 treats the values «P12 M» and «P1Y» as distinct  an enumeration facet that permits one of these forms will not permit the other , but XPath treats them as equal, and will not retain any distinction between the two forms when converting the typed value back to a string value. XML Schema 1.1 follows XPath by normalizing the values.  XPath provides no functions to format durations in a user-friendly output representation. Instead there are six functions years-from-duration  , months-from-duration  , days-from-duration  , hours-from-duration  , minutes-from-duration  , and seconds-from-duration  , which allow the components to be extracted. These will be the components after normalizing the value: for example if the duration is supplied as «P18 M», then extracting the components will give you one year and six months. If the duration is negative, then all the components will be supplied as negative numbers.  The Minor Atomic Types  The previous section covered the major types of XPath 2.0, the ones that are well supported by functions and operators in the language: speciﬁcally, xs:anyURI, xs:boolean, xs:date, xs:dateTime,  206   Atomic Types  xs:decimal, xs:double, xs:integer, xs:QName, xs:string, xs:time, xs:dayTimeDuration, and xs:yearMonthDuration.  In this section I will brieﬂy survey what I call the minor atomic types. These are deﬁned as primitive types in XML Schema, but they are not well supported by XPath, and you are unlikely to use them very often. These are xs:gYear, xs:gYearMonth, xs:gMonth, xs:gMonthDay, xs:gDay, xs:duration, xs:float, xs:hexBinary, xs:base64Binary, and xs:NOTATION.  The Partial Date Types  5  T y p e s  This category refers to the ﬁve types xs:gYear, xs:gYearMonth, xs:gMonth, xs:gMonthDay, and xs:gDay. They essentially represent dates in which one or two of the components are missing.  It has to be said that these types have been treated with a certain amount of derision by commentators. I have heard them referred to as the gHorribleKludge types, or  after the pronunciation of ‘‘gDay’’ , the Strine types. I have rarely seen them used in real applications, and it does seem fairly extraordinary that these types, even if someone ﬁnds them useful, should be considered as primitive types on the same level as string, boolean, and double. For my part, if I want to design an XML database that includes information about the vintage years of my favorite wines, I think I can do it without using the xs:gYear type, let alone an xs:gYear with a timezone.  But for better or worse, they are there — so we might as well describe them and move on.  The lexical representation of these values follows ISO 8601 conventions, using hyphens to represent missing components. ISO 8601 does not allow timezones on these values; this is an extra addition by the XML Schema working group. The allowed formats are shown using examples in the table below.  Type  xs:gYear  xs:gYearMonth  xs:gMonth  xs:gMonthDay  xs:gDay  Without timezone  2008  2008-07  --07  --07-31  ---31  With timezone  2008+08:00  2008-07+08:00  --07+08:00  --07-31+08:00  ---31+08:00  For the xs:gYear and xs:gYearMonth types, an optional leading minus sign is allowed to indicate BC dates.  The format of xs:gMonth values was shown incorrectly in the original XML Schema Recommendation as «--MM--». The error was corrected in a subsequent erratum, but in the meantime it has found its way into many books on XML Schema and a number of software products.  XPath 2.0 allows conversion of these values to and from strings. It allows them to be compared with each other using the «=» and «!= » operators, but they cannot be sorted or compared using «<» and «>». Comparison uses the implicit timezone if the value itself has no timezone. This means that two xs:gYear values are not equal to each other if they are in different timezones.  If you ever come across an application that relies on this, let me know.   XPath 2.0 also allows casting from an xs:dateTime or xs:date to any of these ﬁve types: the relevant components  including the timezone  are extracted, and the other components are discarded. The full rules for casting between different types are given in Chapter 11.  207   Types  Binary Types  XML Schema supports two types for holding binary data  for example, images or sound clips . These are xs:base64Binary and xs:hexBinary. Binary data cannot be held in an XML document directly, so it is always encoded as characters, and these two types support the two most popular encodings.  Base 64 encoding is deﬁned by reference to Internet mail standards in RFC 2045  http:  www.ietf.org  rfc rfc2045 , though the format was originally described in RFC 1421. The basic idea is that the binary stream is split into 24-bit chunks  3 bytes , and each chunk is then considered as four groups of 6 bits. Each 6-bit group is then considered to be the code representing a character in an alphabet of 64 characters, and this character is used to represent the value in the lexical representation. The 64-character alphabet consists of A–Z, a–z, 0–9, «+», and « ». One or more «=» characters may occur at the end to indicate padding to a whole number of 8-bit bytes, and newlines may appear to break up the total sequence  according to the RFC, the maximum line length is 76 characters .  The hexBinary encoding is simpler but less compact: it simply takes each octet of the binary stream, and represents it as two hexadecimal digits.  XPath 2.0 doesn’t offer any very useful functionality for these two types. In particular, it doesn’t provide you with any way to convert the values to or from an actual stream of octets. What you can do is to compare the values for equality, convert them to and from strings, and convert between the two types, in either direction. If you need more than that, Saxon offers some extension functions.  Single-Precision Floating Point  Unlike the other types that I’ve classiﬁed as minor, xs:float is well supported by functions and opera- tors in XPath 2.0; in fact, any operator or function that can be applied to an xs:double can also be applied to an xs:float.  There is no numeric literal for xs:float values. You have to create them using a constructor function, for example «xs:float 3.14159 ».  The real reason I have classiﬁed xs:float as a minor type is that I can’t see any reason why anyone should want to use it. Compressing a ﬂoating-point number into 32 bits made sense in the 1960s, but it makes little sense nowadays, and the loss of precision when performing numeric calculations is far too severe for most applications to justify the space saving. The only justiﬁcation I have heard for including this type in XML Schema is for compatibility with other  older  type systems such as SQL.  In XML Schema, xs:float is not deﬁned as a subtype of xs:double. Its value space is a strict subset of xs:double, but the working group decided to make it a primitive type apparently because of the difﬁ- culty of deﬁning the nature of the restriction, which would have required the invention of new facets. In XPath, however, xs:float can be considered for most practical purposes to be a subtype of xs:double. It won’t pass explicit tests such as «$F instance of xs:double» that it would pass if it were a true subtype, but you can pass an xs:float value to any function or operator that expects an xs:double, and it will be converted automatically  this particular kind of conversion is referred to as numeric promotion .  When you mix xs:float and xs:double in a calculation, the result is xs:double. If you mix xs:float and xs:decimal, however, the result is xs:float.  The xs:duration type is one of the primitive types in XML Schema, but as we’ve already seen, XPath decided to avoid the difﬁculties it posed by introducing the two subtypes xs:yearMonthDuration and  The xs:duration Type  208   Atomic Types  xs:dayTimeDuration. You can still use the xs:duration type in your schema and in your documents, but there is relatively little support for it in XPath. You can compare one xs:duration to test whether it is equal to another, but you can’t apply any ordering tests, and you can’t perform any arithmetic operations. You can extract the components of the duration — it will be normalized so that P18 M is treated as one year six months, and PT36H is treated as one day 12 hours, but months will never be converted to days or vice versa. A few conversions are also allowed: you can convert a string to an xs:duration, and convert an xs:duration to a string. You can also convert an xs:duration to an xs:yearMonthDuration or xs:dayTimeDuration, which is done by removing the components that aren’t applicable to the target type.  5  T y p e s  The xs:NOTATION Type  The xs:NOTATION type is perhaps the weirdest primitive type in the whole armory. It’s provided to give backward compatibility with a rarely used feature in DTDs.  In a DTD you can deﬁne an unparsed entity like this:  <!ENTITY weather-map SYSTEM "weather.jpeg"  PUBLIC "-  MEGACORP  WEATHER " NDATA JPEG>  This example refers to a binary ﬁle weather.jpeg, and the NDATA part tells you that its format is JPEG. The keyword NDATA can be read as ‘‘Non-XML Data’’.  This declaration is only valid if JPEG is the name of a notation deﬁned somewhere in the DTD, for example:       The theory is that the system identiﬁer tells the application what the name JPEG actually means. Unfor- tunately, there is no standardization of the URIs you can use here, so this doesn’t work all that well in practice. I’ve used the registered media type  or MIME type  for JPEG as if it were a URI, but this isn’t universal practice.  Elsewhere in the DTD you can deﬁne an attribute whose value is required to be one of a number of speciﬁed notations, for example:    <!ATTLIST map  format NOTATION  JPEGGIF  "JPEG" src ENTITY REQUIRED  >  This deﬁnes an element,  , whose content is empty, and which has two attributes: a format attribute of type NOTATION, whose value must be JPEG or GIF, with the default being JPEG, and a src attribute, whose value must be the name of an unparsed entity deﬁned in the DTD.  You can’t actually declare unparsed entities in a schema  for that, you need to continue using a DTD , but you can declare attributes whose values must be entity names or notation names. The schema equivalent to the DTD declarations above would be:       209   Types                                Note that you can’t declare an attribute whose type is xs:NOTATION, it must be a subtype of xs:NOTATION that is restricted to a speciﬁc list of allowed values. This all mirrors the rules for use in DTDs, and is all designed to ensure that users whose document types make use of unparsed entities and notations aren’t prevented from taking advantage of XML Schema.  Although notations were added to XML Schema for backward compatibility reasons, the schema work- ing group added an extra feature: they made notation names namespace-aware. In the schema above, the notation name «JPEG» is interpreted as a local name deﬁned within the target namespace of the contain- ing schema. If the target namespace is anything other than the null namespace, then the notation name actually used in the source document  and in the   elements  will need to be qualiﬁed with a namespace preﬁx.  So, how is xs:NOTATION supported in XPath 2.0? The answer is, minimally. There are two things that are allowed:        You can compare two xs:NOTATION values to see if they are equal, or not equal. You can cast an xs:NOTATION value to a string.  Casting a string to a subtype of xs:NOTATION  but not to xs:NOTATION itself  is allowed provided that the string is supplied as a literal, so that the operation can be done at compile time. There is no way of constructing an xs:NOTATION value dynamically within an XPath expression; the only way you can get one is by reading the content of an attribute whose type annotation is xs:NOTATION.  This completes our survey of the ‘‘minor’’ types: that is, the types that are deﬁned in XML Schema as primitive types, but which have fairly specialized applications  to put it politely . The next two sections deal with the two families of derived types that are predeﬁned in XML Schema: the derived numeric types, and the derived string types.  Derived Numeric Types  XML Schema deﬁnes a range of types deﬁned by restriction from xs:integer. They differ in the range of values permitted. The following table summarizes these types, giving the permitted value range for each one.  210   Type  xs:byte  xs:int  xs:long  xs:negativeInteger  xs:nonNegativeInteger  xs:nonPositiveInteger  xs:positiveInteger  xs:short  xs:unsignedByte  xs:unsignedInt  xs:unsignedLong  xs:unsignedShort  The type hierarchy for these types is shown in Figure 5-2.  Minimum  -2147483648  -128  -263  no minimum  no minimum  -32768  0  1  0  0  0  0  integer  Atomic Types  5  T y p e s  Maximum  2147483647  127  263-1  -1  0  32767  255  264-1  65535  no maximum  no maximum  4294967295  nonPositiveInteger  nonNegativeInteger  negativeInteger  positiveInteger  unsignedLong  long  int  unsignedInt  unsignedShort  short  unsignedByte  byte  Figure 5-2  The range of values permitted in an xs:integer is unspeciﬁed. The speciﬁcation says that at least 18 dig- its must be supported, but since the maximum value of an xs:unsignedLong is 18,446,744,073,709,551,615,  211   it is clear that 18 digits is not actually sufﬁcient. Some implementations  Saxon for example  allow arbitrary length integers.  I’m not a great enthusiast for these types. Their ranges are matched to the capacity of bits and bytes in the hardware, rather than to value ranges that actually occur in the real world. If you want to hold a percentage, and its value is an integer in the range 0 to 100, I would recommend deﬁning a type with that speciﬁc range, rather than using an off-the-shelf type such as unsignedByte. This then leaves the question of which type to derive it from. There are 10 types in the above list that you could choose from. My own choice would be to derive it directly from xs:integer, on the grounds that any other choice is arbitrary. However, if you are using a data binding tool that generates Java or C types equivalent to your schema types, then xs:int may work better.  As far as schema validation is concerned, it really doesn’t matter very much what the type hierarchy is: if you deﬁne your percentage type with a minInclusive value of 0 and a maxInclusive value of 100, then the validator will do its work without needing to know what type it is derived from. When it comes to XPath processing, however, the type hierarchy starts to become more signiﬁcant. For example, if a func- tion is deﬁned that accepts arguments of type xs:positiveInteger, then a value of type my:percentage will be accepted if my:percentage is derived by restriction from xs:positiveInteger, but not if my:percentage is derived from xs:int. The fact that every valid percentage is also a valid xs:int doesn’t come into it; the value is substitutable only if the type is deﬁned as a subtype of the required type in the type hierarchy.  In the standard function library, there are a number of functions that return integers, for example count  , position  , and month-from-Date  . There are also a few functions that require an integer as one of the arguments, for example, insert-before  , remove  , and round-half-to-even  . All these functions are described in Chapter 13. In all cases the type that appears in the function signature is xs:integer, rather than one of its subtypes. In many cases a subtype could have been used; for example, count   could have been deﬁned to return an xs:nonNegativeInteger, while position   could have been deﬁned to return xs:positiveInteger. But this wasn’t done, and it’s interesting to see why.  Firstly, consider functions that accept an integer as an argument, such as remove  . Here the integer rep- resents the position of the item to be removed. This could have been deﬁned as an xs:positiveInteger, because the only values that make sense are greater than zero  positions in a sequence are always num- bered from one . But if this were done then the function call «remove $seq, 1 » would give a type error, on the curious grounds that 1 is not an xs:positiveInteger. This is because, when you supply a value in a context where a particular type is required, the type checking rules rely on the label attached to the value, they don’t consider the value itself. The type label attached to the integer literal «1» is xs:integer, and xs:integer is not a subtype of xs:positiveInteger, so the call fails.  Secondly, consider functions that return an integer, such as month-from-date  . Here the result is always in the range 1 to 12. So the result could have been deﬁned as an xs:byte or an xs:integer or an xs:positiveInteger or several other types. Alternatively, a new type, xs:month-value, could have been deﬁned with the speciﬁc range 1 to 12. Deﬁning it as xs:byte would have been helpful to people who want to use the returned value in a call to a function that expects an xs:byte, while deﬁning it as an xs:positiveInteger would have helped people who want to call functions that expect that type. Deﬁn- ing a custom type just for this purpose would have been overkill. It’s not possible to please everyone, so the plain vanilla type xs:integer was chosen to stay neutral.  The fact of the matter is that numeric ranges don’t naturally fall into a hierarchy, and type checking by looking at the labels rather than the actual value doesn’t work particularly well in this situation. Choosing a type such as xs:int may give performance advantages on some systems compared with  Types  212   Atomic Types  xs:long, but they are likely to be miniscule. My advice would be either to deﬁne a type that reﬂects the actual semantics of the value, for example percentage or class-size or grade, or just use the generic type xs:integer. If you write general-purpose functions in XSLT or XQuery, then declare the expected type as xs:integer, and check the validity of the actual value within the code of your function.  Some people advocate deﬁning numeric types for different units of measure; for example, inches or centimeters. If you ﬁnd this useful to document the intended usage, then that’s ﬁne, but don’t expect the type system to do anything clever with the values as a result. It won’t stop you adding an inches value to a centimeters value, for example. My personal preference is to model units of measure as com- plex types, typically using an element whose content is the numeric value, and with a ﬁxed, defaulted attribute to denote the unit of measure. Subtypes are designed to be used where values of the subtype are substitutable for values of the parent type, which means they aren’t appropriate if you want to restrict the operations that are permissible.  5  T y p e s  Derived String Types  As well as types derived from xs:integer, the repertoire of types that come as standard with XML Schema include a family of types derived from xs:string. The type hierarchy is shown in Figure 5-3.  normalizedString  string  token  NCName  NMTOKEN  Name  language  ID  IDREF  ENTITY  Figure 5-3  Most of these types restrict the set of characters that are allowed to appear in the string, but they also have other purposes:        Some affect the way that whitespace within the value is normalized Some such as xs:ID and xs:IDREF trigger special validation rules that apply to the document as a whole  213   Types  The processing of whitespace within an element or attribute value is controlled in XML Schema using the xs:whiteSpace facet on the type. There are three possible values: preserve, replace, and collapse. These work as follows:           preserve leaves the value intact. replace replaces each tab, carriage return, or newline character with a single space. collapse removes leading and trailing whitespace, and replaces any sequence of internal white- space characters by a single space character.  Whitespace here means any of the characters x09, x0A, x0D, and x20, while space means the character x20.   Validation of a source document against a schema only happens after XML parsing is complete, so this level of whitespace processing only comes into play after the XML parser has already done its work. The XML parser replaces any end-of-line sequence  for example, x0Dx0A  by a single newline character  x0A , unless it is written using character references such as «&x0D;», and it also normalizes attribute values using the replace rule above. Specifying preserve in the schema won’t stop the XML parser replacing tabs in an attribute value by spaces, unless you write them as «&x09;».  In practice, you choose the whitespace processing you want not by specifying an explicit xs:whiteSpace facet, but by deriving your type deﬁnition from xs:string if you want preserve, xs:normalizedString if you want replace, and xs:token if you want collapse.  The type xs:token is a notorious misnomer, it actually represents a sequence of tokens separated by whitespace, and the assumption is that it makes no difference which whitespace characters are used as separators.   You can restrict the allowed values for a string using the xs:pattern facet, which provides a regular expression that the value must match. The pattern is applied to the value after whitespace processing has been carried out.  Patterns can also be used for types other than strings, but they are rather blunt instruments. For example, if you try to deﬁne a subtype of xs:decimal with the pattern «[0-9]+\.[0-9]{2}», which states that there must be two digits after the decimal point, then any attempt to cast a value to this type is likely to fail — the system isn’t clever enough to add trailing zeros to the value just because the pattern requires them.  Oddly, XML Schema doesn’t deﬁne a type for strings in which spaces are not allowed, such as part numbers. It’s often handy to deﬁne such a type as a user-deﬁned type, from which many other appli- cation-oriented types can be derived. You can deﬁne it like this:                 This pattern also restricts the value to contain at least one non-space character  a zero-length string is not allowed .  The meaning of each of the types is summarized in the table below. Type  Usage Any sequence of characters, in which whitespace is signiﬁcant.  Any sequence of characters, in which whitespace acts as a separator, but no distinction is made between different whitespace characters.  continued  xs:string  xs:normalized- String  214   Atomic Types  Type  xs:token  xs:language  xs:NMTOKEN  xs:Name  xs:NCName  xs:ID  xs:IDREF  xs:ENTITY  Usage A sequence of tokens separated by whitespace.  A value that follows the rules for the xml:lang attribute in XML.  A sequence of characters classiﬁed as name characters in the XML speciﬁcation. This includes letters, digits, «.», «-», «_», and «:», and a few other special characters.  An NMTOKEN that starts with a character classiﬁed as an initial name character in the XML speciﬁcation. These include letters, «_», and «:».  5  T y p e s  A Name that does not include a «:»  a no-colon-name .  The value of an ID can be any valid NCName, but it is constrained to be unique among all the ID values in a document.  The value of anIDREF can be any valid NCName, but it is constrained to be the same as some ID value somewhere in the same document.  The value of an ENTITY can be any valid NCName, but it is constrained to the same as the name of an unparsed entity deﬁned in the DTD.  XPath 2.0 doesn’t handle any of these types specially; it just treats them as strings. If you try to cast a value to one of these types, it will ﬁrst apply the whitespace rules for that type, and it will then check that the value conforms to the rules for the type.  This means for example, that calling «xs:token $s » has pretty well the same effect as calling «normalize-space $s »; the only difference is that in the ﬁrst case, you end up with a value labeled as an xs:token, and in the second case, it is labeled xs:string.   Confusingly, the normalize-space   function  which is carried forward from XPath 1.0 and is described in Chapter 13 of this book , collapses whitespace, while the xs:normalizedString type in XML Schema replaces whitespace.  The special validation rules for xs:ID, xs:IDREF, and xs:ENTITY are not invoked when you create atomic values of these types, as they only make sense in the context of validating an entire document.  This concludes our tour of the built-in atomic types deﬁned in XML Schema. Before ﬁnishing, we need to look at the special type xs:untypedAtomic, and at the three list types xs:NMTOKENS, xs:IDREFS, and xs:ENTITIES.  Untyped Atomic Values  It might seem perverse to have a type called xs:untypedAtomic, but that’s the way it is. This isn’t a type deﬁned by XML Schema, it is a type used to label data that hasn’t been validated against an XML Schema.  XML is a technology whose unique strength is its ability to handle everything from completely unstruc- tured data, through semi-structured data, to data that has a completely rigid and formal structure. XPath needs to work with XML documents that ﬁt anywhere in this spectrum. Indeed, it’s not unusual to ﬁnd documents where one part is rigidly structured and another is completely free-form.  One way of handling this would be to say that everything that isn’t known to have a speciﬁc type is simply labeled as a string. But to enable more accurate type checking of expressions and queries, the language designers wanted to be more precise than this, and to distinguish data that’s known to be a string because it has been validated against a schema, from data that’s handled as a string because we don’t know any better.  215   The value space of xs:untypedAtomic is the same as that of xs:string; in other words, any sequence of Unicode characters permitted in XML can be held as an xs:untypedAtomic value. So in terms of the values they can represent, there’s no difference between xs:untypedAtomic and xs:string. The difference is in how the values can be used.  xs:untypedAtomic is a chameleon type: it takes its behavior from the context in which it is used. If you use it where a number is expected, it behaves like a number; if you use it where a date is expected, it behaves like a date, and so on. This can cause errors, of course. If the actual value held in the xs:untypedAtomic value isn’t a valid date, then using it as a date will fail.  In XPath 1.0, all data extracted from a source document was untyped in this sense. In some ways this makes life easy for the programmer, it means that you can do things like «@value + 2» without wor- rying about whether @value is a number or a string. But occasionally, this freedom can lead to confu- sion. For example, in XPath 1.0, «boolean @value » tests whether the value attribute exists; «boolean  string @value  » tests whether it exists and is not an empty string, while «boolean number  @value  » tests whether it exists and has a numeric value that is not zero. To make these kind of dis- tinctions, you need to understand the differences between types.  With XPath 2.0, if your source documents have gone through schema validation, the elements and attributes will be annotated with a type. This label tells the system what operations are legitimate on the type, and may also be used to select different ways of implementing the same operation. For example, testing «@A < @B» will give different results depending on whether the attributes A and B have been deﬁned in the schema as strings, numbers, or durations.  Data labeled as xs:untypedAtomic continues to behave as all data did in XPath 1.0; it has no intrinsic type of its own and is converted to whatever the default type is for the context in which it is used. If you supply an xs:untypedAtomic value as an argument to a function call, it is converted  cast  to the type deﬁned in the function signature. If you use it as an operand of an arithmetic operator such as «+» then the system tries to convert it to a number  actually, an xs:double . If you use it as an operand of «=» or «  4» and «@A > ‘4’» may give you different answers  if the attribute value is «10», for example, the ﬁrst test will return true, the second false . If both operands are of type xs:untypedAtomic, then they will be compared using the rules for strings.  One thing that can trip you up if you aren’t using schemas, and are therefore used to most of your data being untyped, is that the result of an operation is never untyped. This means, for example, that you can write «string-length @chap-num », and the value of @chap-num will be treated as an xs:string, which is what the string-length   function requires. You can also write «@chap-num + 1», and «@chap-num» will be treated as a number, which is what the «+» operator requires. But you can’t write «string-length @chap-num + 1 », because the result of «@chap-num + 1» is not untyped, it is an xs:double, and the string-length   function requires an xs:string. You have to do the conversion explicitly, like this: «string-length string @chap-num + 1  ».  Values can be labeled as xs:untypedAtomic even when they come from a document that has been val- idated against a schema, if the validation rules in the schema caused that part of the document to be skipped. It will also happen when an element or attribute declaration in the schema does not deﬁne a type, or when the type is given as xs:anyType, xs:anySimpleType, or xs:anyAtomicType. This situation can arise with documents that are part rigid structure, part free-form.  Although untyped values arise most commonly when you extract the value of an unvalidated node in a source document, you can also construct an untyped value explicitly, in the same way as any other atomic  Types  216   Schema Types and XPath Types  value, by using a constructor function or cast. For example, the function call «xs:untypedAtomic @date » extracts the value of the @date attribute, and returns an untyped value regardless whether the original attribute was labeled as a date, as a string, or as something else. This technique can be useful if you need to process data that might or might not have been validated, or if you want to exploit the chameleon nature of xs:untypedAtomic data by using the value both as a string and as a date.  xs:NMTOKENS, xs:IDREFS, and xs:ENTITIES  This section of the chapter is about atomic types, but it would not be complete without mentioning the three built-in types deﬁned in XML Schema that are not atomic, namely xs:NMTOKENS, xs:IDREFS, and xs:ENTITIES. These all reﬂect attribute types that were deﬁned in DTDs, and are carried forward into XML Schema to make transition from DTDs to schemas as painless as possible.  In the sense of XML Schema, these are list types rather than atomic types. XML Schema distinguishes complex types, which can contain elements and attributes, from simple types which can’t. Simple types can be deﬁned in three ways: directly by restricting an existing simple type, by list, which allows a list of values drawn from a simple type, or by union, which allows a choice of values from two or more different simple types. But when it comes down to actual values, an instance of a simple type is either a single atomic value or a list of atomic values. Single atomic values correspond directly to atomic values in the XPath data model, as described in the previous chapter, while lists of atomic values correspond to sequences.  If an element or attribute is deﬁned in the schema to have a list type such as xs:NMTOKENS, then after validation the element or attribute node will have a type annotation of xs:NMTOKENS. But when an XPath expression reads the content of the element or attribute node  a process called atomization , the result is not a single value of type xs:NMTOKENS, but a sequence of values, each of which is an atomic value labeled as an xs:NMTOKEN.  For example, you can test an attribute to see whether it is of type xs:NMTOKENS like this:  5  T y p e s  if  @A instance of attribute *, xs:NMTOKENS   ...  or you can test its value to see if it is a sequence of xs:NMTOKEN values like this:  if  data @A  instance of xs:NMTOKEN *   ...  What you cannot do is to test the attribute node against the sequence type «xs:NMTOKEN*», or the value contained in the attribute against the list type «xs:NMTOKENS». Both will give you syntax errors if you attempt them. For more information on using the «instance of» operator to test the type of a value, see Chapter 11.  Schema Types and XPath Types  The preceding discussion about list types demonstrates that while the XPath type system is based on XML Schema, the types deﬁned in XML Schema are not exactly the same thing as the types that XPath values can take. This is best illustrated by looking at the two type hierarchies and seeing how they compare. The type hierarchy in XML Schema is shown in Figure 5-4.  This type hierarchy contains all the types that can be used as type annotations on nodes. The boxes that are shown unshaded are concrete types, so they can be used directly; the shaded boxes are abstract types,  217   Types  which can only be used via their subtypes. Some of the abstract types are named, which means you can refer to them in an XPath expression  for example you can write «element *, xs:anySimpleType » which will match any element whose type annotation shows that its type is a simple type . Others are unnamed, which means you cannot refer to them directly.  schema types  xs:anyType   simple types   xs:anySimpleType   union types  list types  atomic types  user-defined union types  user-defined list types  NMTOKENS  IDREFS  ENTITIES  Figure 5-4  complex types  user-defined complex types  user-defined and built-in  derived atomic types  boolean  string  double  anyURI  There is another type hierarchy, which represents the types of XPath items. This type hierarchy is shown in Figure 5-5.  This reﬂects the structure we described at the start of the chapter: every item in an XPath sequence is either a node or an atomic value; there are seven kinds of node, and the atomic types are either the built-in atomic types deﬁned in the XML Schema speciﬁcation, or user-deﬁned atomic types.  Comparing these two diagrams:           Atomic types appear in both. Atomic types can be used either as annotations on nodes, or as the type of a freestanding XPath item. Complex types, list types, and union types appear on the ﬁrst diagram, but not the second. These types can be used as node annotations, but you can never have a freestanding XPath item that belongs directly to one of these types. Node kinds appear on the second diagram only. You can have an item in an XPath sequence that is an element or a comment or a processing instruction, but these types never appear as type annotations on element or attribute nodes.  218   The Type Matching Rules  item    atomic types   xs:anyAtomicType   5  T y p e s  boolean  string  double  anyURI  user-defined and built-in derived atomic types  node    document-node    element    attribute    text    comment    processing-instruction    namespace  Figure 5-5  It’s a little unfortunate that the boxes on both these diagrams are all referred to as types, when we are actually dealing with two different  but overlapping  categories: I call the ﬁrst category schema types and the second category item types. The W3 C speciﬁcation for functions and operators attempts to depict both of these categories on a single type hierarchy diagram, but in my view this is likely to confuse more people than it enlightens. Apart from anything else, when you do this you ﬁnd that xs:anyAtomicType, which appears on both diagrams, has two different supertypes.  Item types and schema types are used in different ways in XPath:        You can test whether an item $V belongs to a particular item type T by writing «$V instance of T». You can test whether a node $N has a type annotation that is a particular schema type S by writing «$N instance of attribute *, S » or «$N instance of element *, S ».  Because atomic types such as xs:integer belong to both categories, they can be used in either of these two ways. But item types such as «comment  » can only be used in the ﬁrst of these roles, while non- atomic schema types such as xs:IDREFS can only be used in the second role.  The Type Matching Rules  The purpose of a type system in a language, as we saw, is to deﬁne which operations are legitimate for which types of value. In this section we will examine the way that XPath deﬁnes these rules.  219   Types  It’s easiest to start with the rules for function calling. XPath expressions can call functions written in XSLT or XQuery, as well as the functions provided in the core function library that comes with the language. Each of these functions has a signature, which deﬁnes the types of each of the arguments expected by the function. The rules described in this section deﬁne whether or not a particular value can be used in a function call, given a particular type used in the function signature. It turns out that the rules are exactly the same as those for binding values to variables in XSLT  the ‘‘weak conversions’’ that we introduced in Chapter 2, page 81 .  For example, the signature of the function remove   is given in Chapter 13 as follows:  Argument sequence  position  Result  Type  item  *  item  *  Meaning The input sequence  xs:integer  The position of the item to be removed  A sequence containing all the items in the input sequence except the item at the speciﬁed position  This shows that the function expects two arguments. The names of the arguments are irrelevant: these names are purely for reference within the documentation, they are not used in an actual function call. The important thing here is the type expected for each argument.  The ﬁrst argument has a type of «item  *». There are two parts to this: the item type and the cardinality. The item type in this case is «item  », which is the most general item type of all, and accepts any node or atomic value. The cardinality is «*», which means that the argument can be a sequence containing zero, one or more items. Taken together, this means that the ﬁrst argument of remove   can be any sequence whatsoever.  The second argument has a type of xs:integer. There is no cardinality speciﬁed, which means that the default cardinality is used: the effect of this is that the sequence supplied as the argument value must contain exactly one item. The item type for this argument is xs:integer, which means that the supplied value must be an atomic value labeled as an xs:integer, or as a subtype of xs:integer  for example, it might be labeled as an xs:positiveInteger . Supplying any other value would lead to a type error, which might be reported either when the expression is compiled or when it is subsequently evaluated.  Actually, the type system is not quite as rigid as this. Instead of supplying an xs:integer for the second argument, you can also supply:        An untyped atomic value, provided that it takes a form that can be converted to an integer A node, provided that the typed value of the node is either an xs:integer, or an untyped atomic value  However, you cannot supply a string  even a string that obviously contains an integer, such as "17" , and you cannot supply a value of a different numeric type, such as xs:decimal or xs:double. You can use an xs:integer where an xs:double is expected, but not the other way around.  When the function call expects an atomic value and the supplied value is a node, the system goes through a process called atomization to extract the typed value of the node. Atomization is applied to the supplied value  a sequence  to produce a derived value  the atomized sequence . The rules are:     Any atomic value in the supplied sequence is added to the atomized sequence unchanged.  220   Static and Dynamic Type Checking        For any node in the supplied sequence, the typed value is extracted, as described in Chapter 2  see page 52 . The typed value is in general a sequence of zero or more atomic values, and the values in this sequence are added to the atomized sequence. If the node has not been validated against a schema, these atomic values will be untyped  they will have the type label xs:untypedAtomic ; if they have been validated, they are likely to have some other type such as xs:integer or xs:date. For some kinds of node, extracting a typed value is not possible: speciﬁcally, this is true for ele- ments that are labeled with a type that has complex element-only content. Supplying such a node where the function expects an atomic value is an error, and the XPath evaluation will fail.  5  T y p e s  The atomized sequence is then checked against the type given in the function signature. The cardinality of the sequence as a whole must match the cardinality constraints given in the function signature, and each item in the sequence must match the item type given.  The detailed syntax for describing the allowed type of each function argument is given in Chapter 11, where it is referred to as a sequence type descriptor. The detailed rules for deciding whether a particular value is allowed as an argument to a function call, and the way it is converted to the required type when necessary, are given in Chapter 7, in the section describing function calls on page 544.  Function calls are not the only place where a value needs to be checked against a required type. We’ve already seen that the same rules apply to XSLT variables and parameters. Many of the XPath operators, such as «+», «-», and «», also have rules saying what type of operands are acceptable. These rules are based on the rules for function calls, but they are slightly different because XPath allows operators to be polymorphic: that is, the same operator can mean different things depending on the types of the arguments supplied. This is not currently allowed for function calls. For each operator, the rules are therefore slightly different, and they are described in this book in the section dealing with each operator. The non-trivial examples are the «=» family of operators and the arithmetic operators, which are all described in Chapter 8.  XQuery chose not to use the function calling rules for variable assignment, but instead applies a stricter criterion. When you write in XQuery «let $x as xs:integer* := my:function 12 », the result of «my:function 12 » must actually be a sequence of integers; no conversions such as atomization, or casting of untyped atomic values, are permitted in this context.  Static and Dynamic Type Checking  As I said in the introduction to this chapter, one of the major purposes of the type system in a program- ming language is to enable programming errors to be detected and corrected. The best time to do this, where possible, is at compile time.  Very often, you will compile and execute an XSLT stylesheet, or an individual XPath expression, as a single indivisible operation. You may therefore feel that there isn’t much difference between detecting an error at compile time and detecting it at runtime. Indeed, if you use XPath expressions from a pro- gramming language such as Java, it’s likely that the XPath expressions won’t be compiled until the Java program is executed, so in a sense all errors become runtime errors. However, there is still a big differ- ence, because an error that’s detected at compile time doesn’t depend on the input data. This means that it will be reported every time you process the XPath expression, which means it can’t remain lurking in the code until some chance condition in the data reveals a latent bug that got through all your tests.  I had a real-life example of this recently. In Chapter 20, there is a stylesheet whose task is to perform a knight’s tour of the chessboard: a tour, starting from a user-speciﬁed square, in which the knight visits  221   Types  every square on the chessboard exactly once. I published an XSLT 1.0 version of this stylesheet in an earlier edition of this book, and I have also written an XQuery 1.0 version, which is published with the Saxon software distribution. Part of the algorithm involves backtracking when the knight gets stuck in a blind alley; however, I never found a way of testing the backtracking, because in every case I tried, the knight got all the way around the board without ever getting stuck. In fact, I said in the book that although I couldn’t prove it, I believed that the backtracking code would never be invoked.  Three years after I ﬁrst wrote the code, one of my readers discovered that if the knight starts on square f1, it gets stuck on move 58 and has to retrace its steps. The same user has since reported that this is the only starting square where this happens. The way he made the discovery was that in the XQuery version of the algorithm, the backtracking code was wrong. I had coded two arguments to a function call the wrong way around, and when the function call was executed, this was detected, because one of the values had the wrong type. So type checking detected the error, but static type checking  that is, compile time checking  could potentially have detected it three years earlier.  But static type checking also has a downside: it makes it much harder to cope with unpredictable data. With strict static type checking, every expression must satisfy the compiler that it can never fail at runtime with a type error. Let’s see what happens if, for example, you have a price attribute whose value is either a decimal number, or the string «N A». You can deﬁne this in XML Schema as follows:                                Now let’s suppose that you want to ﬁnd the average price of those products where the price is known. Your ﬁrst attempt might look like this:  avg  product @price[. != "N A"]    This looks sensible, but under strict static type checking, it will fail to compile. There are two reasons. Firstly, you can’t compare a number with a string, so the expression «. != "N A"» isn’t allowed, on the grounds that the value of «.»  that is, the typed value of the price attribute  might be a number. Secondly, although you and I can tell that all the attributes that get through the ﬁlter in square brackets will be numeric, the compiler isn’t so clever, and will report an error on the grounds that some of the items in the sequence being averaged might be strings rather than numbers.  The ﬁrst of these two errors will be reported even if type checking is delayed until runtime, so in this case the static type checker has done us a service by reporting the error before it happened. The second error is a false alarm. At runtime, all the attribute values being averaged will actually be numeric, so the error of including a string in the sequence will never occur.  This example is designed to illustrate that static type checking is a mixed blessing. It will detect some errors early, but it will also report many false alarms. The more you are dealing with unpredictable or  222   Static and Dynamic Type Checking  semi-structured data, the more frequent the false alarms will become. With highly structured data, static type checking can be a great help in enabling you to write error-free code; but with loosely structured data, it can become a pain in the neck. Because XML is designed to handle such a wide spectrum of different kinds of data, the language designers therefore decided that static type checking should be optional.  Whether you use static or dynamic type checking, the ﬁrst error in our example above will need to be corrected. One way to do this is to force the value of the attribute to be converted to a string before the comparison, like this:  avg product @price[string .  != "N A"]   For the other error  the false alarm  we don’t need to take any further action in the case of a system that only does dynamic type checking. However, if we want the expression also to work with systems that do static type checking, we will need to change it. The simplest approach seems to be:  avg product xs:decimal @price[string .  != "N A"]    The cast to xs:decimal here doesn’t actually do anything at runtime, because the operand will always be an xs:decimal already. But it keeps the static type checker happy, because the system can now tell at compile time that the values input to the avg   function will all be xs:decimal values.  5  T y p e s  Looking back at the example:  avg product @price[. != "N A"]   it might have occurred to you that under XPath 1.0, apart from the fact that the avg   function was not available, this would have worked quite happily, with neither static or dynamic errors. That’s because XPath 1.0 treated all data in source documents as being untyped. You could compare the value of an attribute to a string, and it would treat it as a string, and you could then take an average, and it would treat the same value as a number. You can do the same thing in XPath 2.0, simply by switching off schema processing: if there is no schema, or if you switch off schema processing, then the attributes are going to be treated as xs:untypedAtomic values, and will adapt themselves to whatever operation you want to perform, just as with XPath 1.0. If you like this way of working, there is nothing to stop you carrying on this way. However, you should be aware of the consequences: many programming errors in XPath 1.0 go undetected, or are very difﬁcult to debug, because the system in effect tries to guess what you meant, and it sometimes guesses wrong. For example, if you compare a string to a number using the «=» operator, XPath 1.0 guesses that you wanted a string comparison  so «4 = "04"» is false , while if you compare a string to a number using the « <= » operator, XPath 1.0 guesses that a numeric comparison was intended  so «4 <= "04"» is true . Sooner or later, this is going to trip you up. With a schema-aware XPath 2.0 processor, you have to be explicit about whether you want a string comparison or a numeric comparison, by explicitly converting one of the operands to the type of the other.  The XPath 2.0 Recommendation distinguishes static type checking from dynamic type checking. A prod- uct that offers static type checking is pessimistic: it assumes that if things can go wrong, they will go wrong. For example, if the operand of «+» is known at compile time to be either a string or an integer, the compiler will report a failure, because the pessimistic assumption is that sooner or later, the actual value of the operand will turn out to be a string. Remember that XPath 2.0 can be used in many environments other than XSLT. The XSLT speciﬁcation largely assumes that implementors won’t choose to provide pessimistic static typing, though it’s not entirely ruled out.  223   Types  In XSLT I think you are more likely to encounter a half-way house, which I will call optimistic static type checking. Here, you will only get an error message at compile time if the system knows that an expression cannot possibly succeed. An example of such an expression is:  current-date   = "2004-01-01"  Here the operand on the left will always be an xs:date, and the operand on the right will always be an xs:string. Comparison of a date to a string can never succeed, so even an optimistic type checker can report the error at compile time. To correct the error, you need to write:  current-date   = xs:date "2004-01-01"   It’s worth pointing out that neither static nor dynamic type checking can catch all errors. Going back to my knight’s tour where two parameters to a function call were coded in the wrong order, the error was only caught because the two arguments had different types. If both arguments had had a type of xs:integer, say, the function call would have succeeded, and the query would have gone on to produce garbage output.  A great deal depends in practice on how carefully you specify your types. Specifying the types of function parameters and of variables is done at the XSLT level, and it is this type information that forms the basis of the type checking performed by the XPath processor. If you choose not to specify any types at all, this is rather like declaring every Java variable or function with the generic type Object: you will get no compile time errors but an awful lot of runtime errors. I ﬁnd that it’s good programming discipline always to declare the types of variables and of function arguments. However, it’s generally best to avoid over-constraining them. It can be tempting to declare types such as xs:positiveInteger, rather than xs:integer, if the value will always be positive; but as we’ve seen, this doesn’t just constrain the value to be positive; it means that it actually has to be labeled as an xs:positiveInteger. The value represented by the XPath numeric literal «3» is an xs:integer, but it is not an xs:positiveInteger, because it has the wrong type label. So I tend to steer clear of using such types, because they create too much inconvenience.  Summar y  The type system is probably the most innovative and the most controversial aspect of XPath 2.0, and it is very different in concept from the type system of XPath 1.0. We started this chapter with a brief rationale for introducing a type system based on XML Schema, and we ended the chapter with a discussion of the different forms of type checking that XPath 2.0 processor can apply, and some hints and tips to enable you to choose the right options.  In between, we looked in detail at each of the built-in atomic types deﬁned in the XML Schema speciﬁca- tion. We then saw how the type hierarchy in XML Schema relates to the type hierarchy in the XPath data model: they are strongly related, but they are not the same thing.  We also outlined how the type checking rules operate when calling an XPath function.  We’re now moving into the section of the book that provides detailed reference information for each construct in the XSLT and XPath languages. Until now you may well have been reading the book sequen- tially. The next chapter, however, is a long one — it contains a detailed alphabetical reference of all the XSLT elements you can use in a stylesheet — and I would suggest that rather than reading it from start to ﬁnish, you dip into the sections describing the speciﬁc instructions that you need to understand.  224   Part II  XSLT and XPath Reference  Chapter 6: XSLT Elements  Chapter 7: XPath Fundamentals  Chapter 8: XPath: Operators on Items  Chapter 9: XPath: Path Expressions  Chapter 10: XPath: Sequence Expressions  Chapter 11: XPath: Type Expressions  Chapter 12: XSLT Patterns  Chapter 13: The Function Library  Chapter 14: Regular Expressions  Chapter 15: Serialization    6  X S L T  l  E e m e n t s  XSLT Elements  This chapter provides an alphabetical list of reference entries, one for each of the XSLT elements. Each entry gives:                       A short description of the purpose of the element Changes in 2.0: A quick summary of changes to this element since XSLT 1.0 Format: A pro forma summary of the format, deﬁning where the element may appear in the stylesheet, what its permitted attributes are, and what its content  child elements  may be Effect: A deﬁnition of the formal rules deﬁning how this element behaves Usage: A section giving usage advice on how to exploit this XSLT element Examples: Coding examples of the element, showing the context in which it might be used  where appropriate, the Usage and Examples sections are merged into one  See also: Cross-references to other related constructs  The Format section for each element includes a syntax skeleton designed to provide a quick reminder of the names and types of the attributes and any constraints on the context. The format of this is designed to be intuitive: it only gives a summary of the rules, because you will ﬁnd these in full in the Position, Attributes, andContent sections that follow.  There are a number of specialized terms used in this chapter, and it is worth becoming familiar with them before you get in too deeply. There are fuller explanations in Chapters 2 and 3, and the descriptions in the following table are really intended just as a quick memory-jogger.  For a more comprehensive deﬁnition of terms, refer to the glossary.  Term attribute value template  Description An attribute whose value may contain expressions nested with curly braces, for example «url=".. {$href}"». The term template here has nothing to do with any other kind of template in XSLT. Embedded expressions may only be used in an attribute value  or are only recognized as such  if the attribute is one that is explicitly designated as an attribute value template. Attribute value templates are described in more detail in Chapter 3, page 122.  continued   XSLT Elements  Term document order  expression  Extension instructions  literal result element  pattern  lexical QName  stylesheet  sequence constructor  SequenceType  Description An ordering of the nodes in the source tree that corresponds to the order in which the corresponding items appeared in the source XML document: an element precedes its children, and the children are ordered as they appeared in the source.  Many XSLT elements have attributes whose value is an expression. This always means an XPath expression: a full deﬁnition of XPath Expressions is given in Chapters 7 to 11, and a summary is given in Appendix A. An expression returns a value, which may be any sequence of items  nodes, atomic values, or a mixture of the two . These types are described fully in Chapter 2.  Any element used in a sequence: speciﬁcally, an XSLT instruction, a literal result element, or an extension element. The   element is an instruction, but   isn’t, because   appears in a sequence constructor and   doesn’t. Extension instructions are described in Chapter 3, page 111.  An element in the stylesheet, used in a sequence constructor, which is copied to the output document: for example  if you are generating HTML    or  . Literal result elements are described in Chapter 3, page 112.  Some XSLT elements have attributes whose value must be a pattern. The syntax of patterns is deﬁned in Chapter 12. A pattern is a test that can be applied to nodes to see if they match. For example, the pattern «title» matches all   elements, and the pattern «text  » matches all text nodes.  An XML name, optionally qualiﬁed by a namespace preﬁx. Examples of lexical QNames with no preﬁx are «color» and «date-due». Examples of preﬁxed QNames are «xsl:choose» and «html:table». The adjective lexical is used to distinguish a QName in this form from a value of type xs:QName, which contains a namespace URI and a local name. Where the lexical QName has a preﬁx, this must always match a namespace declaration that is in scope at the place in the stylesheet where the QName is used. For more information on namespaces see Chapter 2, page 58.  In general, references to the stylesheet mean the principal stylesheet module plus all the stylesheet modules incorporated into it using   and   elements. When I want to refer to one of these components individually, I call it a stylesheet module.  A sequence of instructions and literal result elements contained within  that is, that are children of  another XSLT element. Many XSLT elements, such as  ,  , and  , have a sequence constructor as their content.  A number of XSLT elements take an «as» attribute whose value is a SequenceType. This is a sequence type descriptor such as «xs:integer*», or «node  ?», or «element part,* ». The syntax for sequence type descriptors is given in Chapter 11.  template rule  An   element that has a match attribute.  XSLT element  Any of the standard elements in the XSLT namespace listed in this chapter, for example   or  .  228   XSLT Elements  The elements in this chapter are listed alphabetically rather than on functional lines, for ease of reference. This is ﬁne when you know what you are looking for, but if you are using this book as your introduction to XSLT, it does create the problem that related things won’t be found together. And if you try to read sequentially, you’ll start with  , which is not one of the instructions that you are likely to use every day of the week.  So here’s an attempt at some kind of ordering and grouping, to suggest which entries you might look at ﬁrst if you’re new to the subject. The following table includes all the more common elements, but leaves out a few that can only be classiﬁed as ‘‘miscellanous’’.  Grouping Elements deﬁning the structure of the stylesheet  Elements used to deﬁne template rules and functions and control the way they are invoked  Elements used to create nodes  Elements used to deﬁne variables and parameters  Elements used to copy information from the source document to the result Elements used for conditional processing and iteration  Elements to control sorting, searching, and numbering  Elements used to control the output of the stylesheet  6  X S L T  l  E e m e n t s  Elements                                                                                      229   XSLT Elements  xsl:analyze-string  The   instruction is used to process an input string using a regular expression  often abbreviated to regex . It is useful where the source document contains text whose structure is not fully marked up using XML elements and attributes, but has its own internal syntax. For example, the value of an attribute might be a list of numbers separated by commas.  I use the term regex to refer to regular expressions in this section, because it helps to avoid any confusion with XPath expressions.  Changes in 2.0 This instruction is new in XSLT 2.0.  Format  <xsl:analyze-string  select = expression regex = { string } flags? = { string }> <!-- Content:  xsl:matching-substring?,  xsl:non-matching-substring?, xsl:fallback*  -->     Position   is an instruction, and it is always used within a sequence constructor.  Value XPath Expression  Meaning The input string to be analyzed using the regex. A type error occurs if the value of the expression cannot be converted to a string using the standard conversion rules described on page 505.  Attribute value template returning a regular expression, as deﬁned below  The regular expression  regex  used to analyze the string. See warning below regarding curly braces.  Attribute value template returning regex ﬂags, as deﬁned below  Flags controlling how the regex is interpreted. Omitting the attribute is equivalent to supplying a zero-length string  no special ﬂags .  The construct expression  meaning an XPath expression  is deﬁned in Chapter 7.  The syntax of regular expressions permitted in the regex attribute is the same as the syntax accepted by the functions matches  , replace  , and tokenize   in XPath 2.0. This is described fully in Chapter 14, and is summarized below. It is based on the syntax used for regular expressions in XML Schema, with some extensions.  Attributes  Name select mandatory  regex mandatory  ﬂags optional  230   xsl:analyze-string  Warning: The regex attribute is an attribute value template. This makes it possible to construct the regex at runtime, using an XPath expression. For example, the regex can be supplied as a stylesheet parameter. The downside of this is that curly braces within the attribute value must be doubled if they are to be treated as part of the regex, rather than having their special meaning for attribute value templates. For example, to match a sequence of three digits, write «regex="[0-9]{{3}}"».  6  X S L T  l  E e m e n t s  The flags attribute controls how the regex is to be interpreted. Four ﬂags are deﬁned, each denoted by a single letter, and they can be written in any order. Like the regex attribute, flags may be written as an attribute value template. The meaning of the ﬂags is deﬁned in detail in Chapter 14 and is summarized below. Flag i  Meaning Selects case-insensitive mode. In simple terms, this means that «X» and «x» will match each other.  m  s  x  Selects multiline mode. In this mode, the metacharacters «^» and «$» match the beginning and end of each line; otherwise, they match the beginning and end of the entire string.  Selects dot-all mode. In this mode the metacharacter «.» matches any character, whereas normally it matches any character except a newline  x0A .  Allows whitespace to be used as an insigniﬁcant separator within the regex.  Content Either an   element or an   element, or one of each in that order. Followed by zero or more   elements.  An XSLT 2.0 processor will ignore any   instructions; they are allowed so that a stylesheet can specify fallback actions to be taken by an XSLT 1.0 processor when it encounters this element, if it is working in forward-compatible mode.  The elements   and   take no attributes, and their content is in each case a sequence constructor.  Effect The XPath expression given in the select attribute is evaluated and provides the input string to be matched by the regex. A type error occurs if the value of this expression can’t be converted to a string using the standard conversion rules described on page 505.  The regex must not be one that matches a zero-length string. This rules out values such as «regex=""» or «regex="[0-9]*"». The reason for this rule is that languages such as Perl have different ways of handling this situation, none of which are completely satisfactory, and which are sensitive to additional parameters such as limit, which XSLT chose not to provide.  The input string is formed by evaluating the select expression, and the processor then analyzes this string to ﬁnd all substrings that match the regex. The substrings that match the regex are processed using the instructions within the   element, while the intervening substrings are processed using the instructions in the   element. For example,  231   XSLT Elements  if the regex is «[0-9]+», then any consecutive sequence of digits in the input string is passed to the   element, and any consecutive sequence of non-digits is passed to the   element.  Within the   or   element, the substring in question can be referenced as the context item, using the XPath expression «.». It is also possible within the   element to refer to the substrings that matched particular parts of the regex: see Captured Groups below.  Because the instruction changes the context item, it’s often useful to bind a variable to the context node before entering the instruction, so that you can refer to it within the   and   elements. If you forget to do this, a likely consequence is an error message along the lines ‘‘the context item is not a node’’.  Neither a matching substring nor a nonmatching substring will ever be zero-length. This means that if two matching substrings are adjacent to each other in the input string, there will be two consecutive calls on the   element, with no intervening call on the <xsl:non-matching- substring> element.  Omitting either the   element or the   element causes the relevant substring to be discarded  no output is produced in respect of this substring .  In working its way through the input string, the processor always looks for the ﬁrst match that it can ﬁnd. That is, it looks ﬁrst for a match starting at the ﬁrst character of the input string, then for a match starting at the second character, and so on. There are several situations that can result in several candidate matches occurring at the same position  that is, starting with the same character in the input . The rules that apply are:        The quantiﬁers «*» and «+» are greedy: They match as many characters as they can, consistent with the regular expression as a whole succeeding. For example, given the input «Here [1] or there [2]», the regex «\[.*\]» will match the string «[1] or there [2]». The quantiﬁers «*?» and «+?» are non-greedy: They match as few characters as they can, consis- tent with the regular expression as a whole succeeding. For example, given the input «Here [1] or there [2]», the regex «\[.*?\]» will match the strings «[1]» and «[2]».    When there are two alternatives that both match at the same position in the input string, the ﬁrst  alternative is preferred, regardless of its length. For example, given the input «size=5.2», the regular expression «[0-9]+[0-9]*\.[0-9]*» will match «5» rather than «5.2».  Regular Expression Syntax The regular expression syntax accepted in the regex attribute is the same as that accepted by the match  , tokenize  , and replace   functions, and it is fully described in Chapter 14. This section provides a quick summary only; it makes no attempt to deﬁne details such as precedence rules.  The following table summarizes the more important constructs found in a regex. In this summary, capital letters A and B represent arbitrary regular expressions. n and m represent a number  a sequence of digits . a, b, c represent an arbitrary character, which is either a normal character, or one of the metacharacters «.», «\», «?», «*», «+», «{», «}», « », « », «[» or «]» escaped by preceding it with a backslash «\», or one of the symbols «\n», «\r», «\t» representing a newline, carriage return, or tab, respectively.  232   xsl:analyze-string  Construct AB AB  Matches a string S if . . . S matches either A or B.  A?  A*  A+ A{n,m} A{n,} A{n} Q?   A   c  [abc]  [ˆabc]  [a-b] \p{prop} \P{prop} .  \s  \S  \i  \I  \c  \C  \d  \D  \w  \W  ˆ  $  6  X S L T  l  E e m e n t s  The ﬁrst part of S matches A and the rest matches B.  S either matches A or is empty.  S is a sequence of zero or more strings that each match A.  S is a sequence of one or more strings that each match A.  S is a sequence of between n and m strings that each match A.  S is a sequence of n or more strings that each match A.  S is a sequence of exactly n strings that each match A.  Where Q is one of the regular expressions described in the previous six rows: matches the same strings as Q, but using nongreedy matching.  S matches A.  S consists of the single character c.  S consists of one of the characters a, b, or c.  S consists of a single character that is not one of a, b, or c.  S is a character whose Unicode codepoint is in the range a to b.  S is a character that has property prop in the Unicode database.  S is a character that does not have property prop in the Unicode database.  S is any single character  in dot-all mode  or any single character other than a newline  when not in dot-all mode .  S is a single space, tab, newline, or carriage return.  S is a character that does not match \s.  S is a character that can appear at the start of an XML Name.  S is a character that does not match \i.  S is a character that can appear in an XML Name.  S is a character that does not match \c.  S is a character classiﬁed in Unicode as a digit.  S is a character that does not match \d.  S is a character that does not match \W.  S is a character that is classiﬁed in Unicode as a punctuation, separator, or ‘‘other’’ character.  Matches the start of the input string, or the start of a line if in multiline mode.  Matches the end of the input string, or the end of a line if in multiline mode.  233   XSLT Elements  The most useful properties that may be speciﬁed in the «\p» and «\P» constructs are described below; for a full list see Chapter 14.  Meaning All letters. Uppercase letters, for example, A, B, ˇS,  cid:1 . Lowercase letters, for example, a, b, ˜n, λ.  All numbers.  Property L  Lu  Ll  N  P  Z  S  Punctuation  full stop, comma, semicolon, and so on .  Separators  for example, space, newline, no-breaking space, en space, em space .  Symbols  for example, currency symbols, mathematical symbols, dingbats, and musical symbols .  Captured Groups Within the   element, it is possible to refer to the substring that matched the regular expression as «.», because it is provided as the context item. Sometimes, however, it is useful to be able to determine the strings that matched particular parts of the regular expression.  Any subexpression of the regular expression that is enclosed in parentheses causes the string that it matches to be available as a captured group. For example, if the regex « [0-9]+  [A-Z]+  [0-9]+ » is used to match the string «13DEC1987», then the three captured groups will be «13», «DEC», and «1987». If the regular expression were written instead as « [0-9]+  [A-Z]+ [0-9]+  », then the three captured groups would be «13», «DEC1987», and «1987». The subexpression that starts with the nth left parenthesis in the regular expression delivers the nth captured group in the result.  Some parenthesized subexpressions might not match any part of the string. For example, if the regex « [0-9]+  [A-Z]+ » is used to match the string «12», the ﬁrst captured subgroup will be «12» and the second will be empty.  A parenthesized subexpression might also match more than one substring. For example, if the regex « [0-9]+  ,[0-9]+ *» is used to match the string «12,13,14», then the second part in parentheses matches both «,13» and «,14». In this case only the last one is captured. The ﬁrst captured group in this example will be «12», and the second will be «,14».  While the   element is being evaluated, the captured groups found during the regular expression match are available using the regex-group   function. This takes an integer argument, which is the number of the captured group that is required. If there is no corresponding subexpression in the regular expression, or if that subexpression didn’t match anything, the result is a zero-length string.  Usage and Examples Many tasks that require regex processing can be accomplished using the three functions in the core function library  see Chapter 13  that use regular expressions: matches  , replace  , and tokenize  . These are used as follows:  234   xsl:analyze-string  6  X S L T  l  E e m e n t s  Function  matches    replace    tokenize    Purpose Tests whether a string matches a given regular expression  Replaces the parts of a string that match a given regular expression with a different string  Splits a string into a sequence of substrings, by ﬁnding occurrences of a separator that matches a given regular expression  There are many ways to use these functions in an XSLT stylesheet. For example, you might write a template rule that matches customers with a customer number in the form 999-AAAA-99  this might be the only way, for example, that you can recognize customers acquired as a result of a corporate takeover . Write this as:  <xsl:template match="customer[matches cust-nr, ’^[0-9]{3}-[A-Z]{4}-[0-9]{2}$’ ]">  There is no need to double the curly braces in this example. The match attribute of   is not an attribute value template, so curly braces have no special signiﬁcance.  The   instruction is more powerful  but also more complex  than any of these three functions. In particular, none of the three XPath functions can produce new elements or other nodes. The   instruction can do so, which makes it very useful when you want to ﬁnd a non-XML structure in the source text  for example, the comma-separated list of numbers mentioned earlier  and convert it into an XML representation  a sequence of elements, say . This is sometimes called up-conversion.  There are two main ways of using  , which I will describe as single-match and multiple-match applications. I shall give an example of each.  A Single-Match Example In the single-match use of  , a regex is supplied that is designed to match the entire input string. The purpose is to extract and process the various parts of the string using the captured groups. This is all done within the   child element, which is only invoked once. The   element is used only to deﬁne error handling, to deal with the case where the input doesn’t match the expected format.  For example, suppose you want to display a date as 13th March 2008. To achieve this, you need to gen- erate the output «13  th  March 2008»  or rather, text nodes and element nodes corresponding to this serial XML representation . You can achieve the basic date formatting using the format-date   function described in Chapter 13, but to add the markup you need to post-process the output of this function.  Here is the code  for the full stylesheet see single-match.xsl in the download archive :  <xsl:analyze-string  select="format-date current-date  , ’[D1o][MNn][Y]’ " regex="^ [0-9]+  [a-z]+  [A-Z][a-z]+  .* $">     235   XSLT Elements                                    Note that the regex is anchored  it starts with «^» and ends with «$»  to force it to match the whole input string. Unlike regex expressions used in the pattern facet in XML Schema, a regex used in the   instruction is not implicitly anchored.  In this example I chose in the   to output the whole date as returned by format-date  , without any markup. This error might occur, for example, because the stylesheet is being run in a locale that uses an unexpected representation of ordinal numbers. The alternative would be to call   to report an error and perhaps terminate.  A Multiple-Match Example In a multiple-match application, you supply a regular expression that will match the input string repeatedly, breaking it into a sequence of substrings. There are two main ways you can design this:  1. Match the parts of the string that you are interested in. For example, the regex «[0-9]+»  will match any sequence of consecutive digits, and pass it to the   element to be processed. The characters that separate groups of digits are passed to the   element, if there is one  you might choose to ignore them completely . There is a variant of this approach that is useful where there are no separators as such. For example, you might be dealing with a format such as the one used for ISO 8601 durations, which look like this: «P12H30 M10 S», with the requirement to split out the components «12H», «30 M», and «10 S». The regex «[0-9]+[A-Z]» will achieve this, passing each component to the   element in turn.  2. Match the separators between the parts of the string that you are interested in. For example, if  the string uses a comma as a separator, the regex «,\s*» will match any comma followed option- ally by spaces. The ﬁelds that appear between the commas will be passed, one at a time, to the   element, while the separators  if you want to look at them at all  are passed to the   element.  The following example  multiple-match.xsl  blends these techniques. It analyzes an XPath expres- sion and lists all the variable names that it references. The regex chosen is one that matches things you’re interested in  the variable names , but it also uses parentheses to provide access to a captured group from which the leading «$» sign is left out. It’s not an industrial-quality solution to this prob- lem; for example, it doesn’t try to ignore the content of comments and string literals. But it does allow for the fact that a space is permitted between the «$» sign and the variable name. You can extend it to handle these extra challenges if you like.  And if you are really keen, you can extend it to extract the  236   xsl:apply-imports  namespace preﬁx from the variable name, and look up the corresponding namespace URI using the get-namespace-uri-for-prefix   function.                    Note in this example that a «$» sign used to represent itself must be escaped using a backslash, and that we are taking advantage of the rather specialized regex constructs «\i» and «\c» to match an XML name. The output is a sequence of   elements containing the names of the referenced variables.  See Also   on page 386   on page 402 matches   on page 828  Chapter 13  replace   on page 862  Chapter 13  tokenize   on page 894  Chapter 13  regex-group   on page 860  Chapter 13  Regular expression syntax, Chapter 14  xsl:apply-impor ts  The   instruction is used in conjunction with imported stylesheets. A template rule in one stylesheet module can override a template rule in an imported stylesheet module. Sometimes, you want to supplement the functionality of the rule in the imported module, not to replace it entirely.   is provided so that the overriding template rule can invoke the overridden template rule in the imported module.  There is a clear analogy here with object-oriented programming. Writing a stylesheet module that imports another is like writing a subclass, whose methods override the methods of the superclass.   behaves analogously to the super   function in object-oriented programming languages, allowing the functionality of the superclass to be incorporated in the functionality of the subclass.  Changes in 2.0 In XSLT 2.0, the instruction is extended to allow parameters to be passed using enclosed <xsl:with- param> elements.  XSLT 2.0 also introduces a new   instruction, which will often be a more suitable solution in situations where   might have previously been used.  Format           6  X S L T  l  E e m e n t s  237   Position   is an instruction, and it is always used within a sequence constructor.  XSLT Elements  Attributes None.  Content The element may be empty, or it may contain one or more   elements.  Effect   relies on the concept of a current template rule. A template rule becomes the current template rule when it is invoked using  ,  , or  . Using   does not change the current template rule. However, using   makes the current template rule null, until such time as the   terminates, when the previous value is reinstated. The current template rule is also null while global variables and attribute sets are being evaluated.  Closely associated with this is the current mode. When a template rule is invoked using <xsl:apply- templates>, the mode speciﬁed on the   instruction becomes the current mode  if no mode is named, then the default unnamed mode becomes the current mode . The current mode reverts to the default  unnamed  mode when a stylesheet function is called.    searches for a template rule that matches the current node, using the same search rules as  , but considering only those template rules that  a  match the current mode and  b  are deﬁned in a stylesheet module that was imported into the stylesheet module containing the current template rule. For details of import precedence, see   on page 357. If no template rule is found, the built-in template rule is used  see page 243 .  Note that the instruction doesn’t examine all template rules with lower precedence than the current rule. For an example that illustrates this, see Figure 6-4 on page 360. If the current template rule is in module C on that diagram, then   will search for rules in module H, but not in modules B, D, F, or G: although those modules have lower import precedence than C, they were not imported into C.  The speciﬁcation deﬁnes what this means in terms of the import tree. If a stylesheet module A includes another module B using  , then A and B are part of the same stylesheet level. If any mod- ule in stylesheet level L imports a module in stylesheet level M, then M is a child of L in the import tree. The template rules that are considered are those that are deﬁned in a stylesheet level that is a descendent of the stylesheet level containing the current template rule.  It is possible to specify parameters to be supplied to the called template, using   ele- ments contained within the   element. These work in the same way as parameters for   and  ; if the name of the supplied parameter matches the name of an   element within the called template, the parameter will take that value; oth- erwise, it will take the default value supplied in the   element. It is not an error to supply parameters that don’t match any   element in the called template rule, they will simply be ignored. However, if the called template speciﬁes any parameters with «required="yes"», then a runtime error occurs if no value is supplied for that parameter.  238   xsl:apply-imports  Usage and Examples The intended usage pattern behind   is illustrated by the following example.  One stylesheet, a.xsl, contains general-purpose rules for rendering elements. For example, it might contain a general-purpose template rule for displaying dates, given as follows:  A second stylesheet, b.xsl, contains special-purpose rules for rendering elements. For example, you might want it to display dates that occur in a particular context in the same way, but in bold face. It could be written as:                                                               However, this involves duplicating most of the original template rule, which is a bad idea from a main- tenance point of view. So, in b.xsl we could import a.xsl, and write instead:  Note that the facility only allows a template rule to invoke one of lower import precedence, not one of lower priority. The import precedence depends on how the stylesheet module was loaded, as explained under   on page 357. The priority can be speciﬁed individually for each template rule, as explained under   on page 483. The code above will work only if the «timeline date» template rule is in a stylesheet module that directly or indirectly imports the «date» template rule. It will not work, for example, if they are in the same module but deﬁned with different priority. In this respect,  differs from  .  In many situations the same effect can be achieved equally well by giving the general-purpose template rule a name and invoking it from the special-purpose template rule by using    see page 271 . But this approach doesn’t work if you want one rule that overrides or supplements many others. One example I encountered was a developer who had a working stylesheet but wanted to add the rule ‘‘output an HTML   tag for any source element that has an anchor attribute.’’ Rather than  6  X S L T  l  E e m e n t s  239   modifying every rule in the existing stylesheet, this can be achieved by deﬁning a new stylesheet module that imports the original one, and contains the single rule:  There is a more complete example of the use of   in the section for  .  XSLT Elements             See Also   on page 357   on page 399   on page 425   on page 517  xsl:apply-templates  The   instruction deﬁnes a set of nodes to be processed and causes the system to process them by selecting an appropriate template rule for each one.  Changes in 2.0 The mode attribute may now take the value «current» to continue processing in the current mode.  Built-in template rules now pass parameters through unchanged.  Format  <xsl:apply-templates  select? = expression mode? = token>       Position   is an instruction, and it is always used within a sequence constructor.  Attributes  Name select optional  mode optional  240  Value XPath Expression  Meaning The sequence of nodes to be processed. If omitted, all children of the context node are processed.  Lexical QName or «current»  The processing mode. Template rules used to process the selected nodes must have a matching mode. If omitted, the default  unnamed  mode is used. The value «current» indicates that the current mode should be used.  Content Zero or more   elements and zero or more   elements, in any order.   xsl:apply-templates  6  X S L T  l  E e m e n t s  Effect The   element selects a sequence of nodes in the input tree and processes each of them individually by ﬁnding a matching template rule for that node. The sequence of nodes is determined by the select attribute; the order in which they are processed is determined by the   elements  if present ; and the parameters passed to the template rules are determined by the   elements  if present . The behavior is explained in detail in the following sections.  The select Attribute If the select attribute is present, the expression deﬁnes the nodes that will be processed. This must be an XPath expression that returns a sequence of  zero or more  nodes. For example, <xsl:apply- templates select="*" > selects the element nodes that are children of the context node. Writing   would cause a type error, because the value of the expression is a number, not a sequence of nodes.  The expression may select nodes relative to the context node  the node currently being processed , as in the example above. Alternatively, it may make an absolute selection from the root node  for example   , or it may simply select the nodes by reference to a vari- able initialized earlier  for example   .  If the select attribute is omitted, the nodes processed will be the children of the context node: that is, the elements, text nodes, comments, and processing instructions that occur directly within the con- text node. It’s then an error if the context item isn’t a node. Text nodes that consist only of whitespace will be processed along with the others, unless they have been stripped from the tree; for details, see   on page 465. In the XDM tree model  described in Chapter 2  attribute nodes and namespace nodes are not regarded as children of the containing element, so they are not processed: If you want to process attribute nodes, you must include an explicit select attribute; for example,  . However, it is more usual to get the attribute values directly using the   instruction, described on page 495.  For each node in the selected sequence, in turn, one template rule is selected and the sequence constructor contained in its body is evaluated. In general, there may be a different template rule for each selected node. Within this sequence constructor, this node becomes the new context node, so it can be referred to using the XPath expression «.».  The called template can also discover the relative position of this node within the list of nodes selected for processing: speciﬁcally, it can use the position   function to give the position of that node in the list of nodes being processed  the ﬁrst node processed has position  =1, and so on , and the last   function to give the number of nodes in the list being processed. These two functions are described in detail in Chapter 13. They enable the called template to output sequence numbers for the nodes as they are processed, or to take different action for the ﬁrst and the last nodes, or perhaps to use different background colors for odd-numbered and even-numbered nodes.  Sorting If there are no child   instructions, the selected items are processed in the order of the sequence produced by evaluating the select expression. If the select expression is a path expression, the nodes will be in document order. In the normal case where the nodes all come from the same input document this means they will be processed in the order they are encountered in the original source document; for example, an element node is processed before its children. Attribute nodes belonging to the same element, however, may be processed in any order, because the order of attributes in XML is not considered signiﬁcant. If there are nodes from several different documents in the sequence, which can happen when you use the document   function  described in Chapter 13, page 754 , the relative  241   XSLT Elements  order of nodes from different documents is not deﬁned, though it is consistent if the same set of nodes is processed more than once.  The direction of the axis used to select the nodes is irrelevant.  The direction of different axes is described in Chapter 9.  For example, «select="preceding-sibling::*"» will process the preceding siblings of the current node in document order  starting with the ﬁrst sibling  even though the  preceding-sibling axis is in reverse document order. The axis direction affects only the meaning of any positional qualiﬁers used within the select expression. For example, «select="preceding- sibling::*[1]"» will select the ﬁrst preceding sibling element in the direction of the axis, which is the element immediately before the current node, if there is one.  Although most XPath expressions return nodes in document order, not all do so. For example, the expres- sion «title, author, publisher» returns a sequence containing ﬁrst the child title elements, then the child author elements, and then the child publisher elements of the context node, regardless of the order that these nodes appear in the source document. The nodes returned by the XPath expression will be processed in the order of the sequence that is returned, not necessarily in document order.  If there are one or more   instructions as children of the   instruction, the selected nodes are sorted before processing. Each   instruction deﬁnes one sort key. For details of how sorting is controlled, see   on page 455. If there are several sort keys deﬁned, they apply in major-to-minor order. For example, if the ﬁrst   deﬁnes sorting by country and the second by state, the selected nodes will be processed in order of state within country. If two selected nodes have equal sort keys  or if the same node is included more than once in the sequence , they will be processed in the order that they appeared in the original result of the select expression, unless the ﬁrst   element speciﬁes «stable="no"», in which case there are no guarantees.  Choosing a Template Rule For each node to be processed, a template rule is selected. The choice of a template rule is made inde- pendently for each selected node; they may all be processed by the same template rule, or a different template rule may be chosen for each one.  The template rule selected for processing a node will always be either an   element with a match attribute, or a built-in template rule provided by the XSLT processor.  An   element will be used to process a node only if it has a matching mode: That is, the mode attribute of the   element must match the mode attribute of the   element. An   element can deﬁne a list of modes that it matches, or it can specify «all» to indicate that it matches all modes. If the   element has no mode attribute, or if its mode attribute includes the keyword «default», then the template rule matches the default mode, which is the mode that is used when   has no mode attribute. If the mode name contains a namespace preﬁx, it is the namespace URI that must match, not necessarily the preﬁx itself. Alternatively, the   instruction can specify «mode="current"» to continue processing in the current mode. This is useful when the instruction is contained in a template rule that can be invoked in a number of different modes. The concept of the current mode is explained more fully in the section for  .  Note that if the mode attribute is omitted, it makes no difference what mode was originally used to select the template rule containing the   instruction. The mode is not sticky; it reverts to the default mode as soon as   is used with no mode attribute. If you want to continue processing in the current mode, either specify the mode explicitly, or set «mode="current"».  242   xsl:apply-templates  An   element will be used to process a node only if the node matches the pattern deﬁned in the match attribute of the   element.  If there is more than one   element that matches a selected node, one of them is selected based on its import precedence and priority, as detailed under   on page 483.  If there is no   element that matches a selected node, a built-in template rule is used. The action of the built-in template rule depends on the kind of node, as follows:  Node Kind  Action of Built-In Template Rule  Document node Element node  Text node Attribute node  Call apply-templates to process each child of the selected node, using the mode speciﬁed on the call to  . This is done as if the contents of the template were  . The parameters passed in the call of   are passed transparently through the built-in template to the template rules for the child elements.  Copy the string value of the node to the result sequence, as a text node. This is done as if the contents of the template were  .  6  X S L T  l  E e m e n t s  Comment node Processing Instruction Namespace node  No action.  For the document node and for element nodes, the built-in template rule processes the children of the selected node in document order, matching each one against the available template rules as if the template body contained an explicit   element with no select attribute. Unlike the situation with explicit template rules, the mode is sticky; it is carried through automatically to the template rules that are called. So if you execute   for an element that has no matching template rule, the built-in template rule will execute   for each of its children. This process can, of course, recurse to process the grandchildren, and so on.  In XSLT 2.0, the built-in template rules not only pass on the mode they were called with, they also pass on their parameters. This is a change from XSLT 1.0.  Parameters If there are any   elements present as children of the   ele- ment, they deﬁne parameters that are made available to the called template rules. The same parameters are made available to each template rule that is evaluated, even though different template rules may be invoked to process different nodes in the list.  Each   element is evaluated in the same way as an   element, as described on page 500. Speciﬁcally:        If it has a select attribute, this is evaluated as an XPath expression. If there is no select attribute and the   element is empty, the value is a zero-length string, unless there is an «as» attribute, in which case it is an empty sequence.  243   XSLT Elements     Otherwise, the value of the parameter is determined by evaluating the sequence constructor con- tained within the   element. If there is an «as» attribute, this sequence forms the value of the parameter; if not, a temporary document is constructed from this sequence, and the document node is passed as the value of the parameter. Tree-valued variables are described under   on page 500.  If the   element has an «as» attribute, then the value of the parameter must match the type speciﬁed in this attribute, and if necessary the value is converted to this type using the standard conversion rules described on page 505. In theory it is possible for a parameter value to be converted twice, ﬁrst to the type deﬁned on the   element and then to the type deﬁned on the corresponding   element.  It is not deﬁned whether the parameter is evaluated once only or whether it is evaluated repeatedly, once for each node in the sequence. If the value isn’t needed  for example, because the select expression selected no nodes or because none of the nodes matches a template that uses this parameter  then it isn’t deﬁned whether the parameter is evaluated at all. Usually this doesn’t matter, because evaluating the parameter repeatedly will have exactly the same effect each time. But it’s something to watch out for if the parameter is evaluated by calling an extension function that has a side effect, such as reading the next record from a database.  If the name of a child   element matches the name of an   element in the selected template rule, then the value of the   element is assigned to the relevant   variable name.  If the   element speciﬁes «tunnel="yes"», then the parameter is available not only to the immediately called templates, but to templates at any depth in the call stack, provided they declare the parameter with   and a matching name. Tunnel parameters are described more fully on page 429.  If there is a child   element that does not match the name of any   element in the selected template rule, then it is ignored. This is not treated as an error.  If there is an   element in the selected template rule with no matching   element in the   element, then the parameter is given a default value: see   on page 425 for details. This is an error only if the   element speciﬁes «required="yes"».  If the selected template rule is a built-in rule, then any parameters that are supplied are passed on to any template rules called by the built-in rule, in the same way that the mode is passed on. This is a change from XSLT 1.0. For example, consider:                          ...     244   xsl:apply-templates  When a   is contained directly within a  , the parameter $in-section will of course take the value «true» as expected. If there is an intervening element, with no explicit template rule, so that the   is the grandchild of the   element, the   template rule will still be invoked, and the parameter $in-section will still have the value «true». The reason is that the built-in template rule for the intermediate element calls   to process its   children, supplying all the parameters that were supplied when it itself was invoked.  Result The result of evaluating the   instruction is an arbitrary sequence, which may include both nodes and atomic values. This sequence is formed by concatenating the sequences pro- duced by each of the template rules that is invoked. These sequences are concatenated in the order of the selected nodes  after any sorting , so that if the selected nodes after sorting were  A, B, C , and the tem- plate rule for node A generates the sequence T A , then the ﬁnal result sequence is  T A , T B , T C  .  This doesn’t mean that the XSLT processor has to process the nodes sequentially. It can process them in any order it likes, or in parallel, as long as it assembles the results in the right order at the end.  Usually,   is used to produce a sequence of nodes that become siblings in the result tree. This is what happens when  , or any other instruction, is used in the sequence constructor within an element such as an   instruction or a literal result element. But   is not conﬁned to such uses. For example, the following code  which is written to take an XSLT stylesheet as input  uses   to decide in which version of XSLT the current element was ﬁrst introduced:  6  X S L T  l  E e m e n t s                ...        <xsl:template mode="get-version" as="xs:decimal"  match="xsl:analyze-string  xsl:for-each-group   xsl:character-map  xsl:next-match  ...">                 In this example, the result returned by   is a single decimal number.  Note that it’s quite legitimate to use   within the body of a global variable deﬁnition, for example:           245   XSLT Elements  In this situation the context node is taken as the root of the principal source document, so the   processes the children of the root node. If the transformation is invoked without supplying a principal source document, this causes a runtime error. There will also be an error reported if a template rule that is invoked attempts to access the value of the global variable currently being deﬁned: This kind of error is referred to in the speciﬁcation as a circularity.  Usage and Examples First, some simple examples are given below.  Construct     <xsl:apply-templates select="para" >  <xsl:apply-templates  select="  *" mode="toc" >  <xsl:apply-templates select="para"> <xsl:with-param name="indent"  select="$n+4" >    <xsl:apply-templates  select="  book">       Effect Processes all the children of the context node  Processes all the   elements that are children of the context node  Processes every element in the document in mode «toc»  Process all the   elements that are children of the context node, setting the value of the indent parameter in each called template to the value of the variable $n plus 4  Process all the   elements in the document, sorting them in ascending order of their isbn attribute  The following sections give some hints and tips about using  . First, I’ll discuss when to use   and when to use  . Then I’ll explain how to use modes.    versus     is most useful when processing an element that may contain children of a variety of different types in an unpredictable sequence. This is a rule-based design pattern: the deﬁnition of each individual template rule declares which nodes it is interested in, rather than the template rule for the parent node deﬁning in detail how each of its children should be processed. The rule-based approach works particularly well when the document design is likely to evolve over time. As new child elements are added, template rules to process them can also be added, without changing the logic for the parent elements in which they might appear.  This style of processing is sometimes called push processing. It will be familiar if you have used text- processing languages such as awk or Perl, but it may be unfamiliar if you are more used to procedural programming in C++ or Visual Basic.  Where the structure is more regular and predictable, it may be simpler to navigate around the document using  , or by accessing the required data directly using  . This is some- times called pull processing. The   instruction allows you to fetch data from the XML document using an arbitrarily complex XPath expression. In this sense it is similar to a SELECT statement in SQL.  246   xsl:apply-templates  A unique strength of XSLT is the ability to mix these two styles of programming. I’ll discuss both approaches, and their relative merits, in more detail in Chapter 17.  Modes Modes are useful where the same data is to be processed more than once.  A classic example is when building a table of contents. The main body of the output can be produced by processing the nodes in default mode, while the table of contents is produced by processing the same nodes with «mode="TOC"».  The following example does something very similar to this: it displays a scene from a play, adding at the start of the page a list of the characters who appear in this scene:  Example: Using Modes  Source  This example uses a mode to create a list of characters appearing in a scene of a play.  The source ﬁle, scene.xml, contains a scene from a play  speciﬁcally, Act I Scene 1 of Shake- speare’s Othello — marked up in XML by Jon Bosak . It starts like this:  6  X S L T  l  E e m e n t s      SCENE I. Venice. A street.   Enter RODERIGO and IAGO     RODERIGO   Tush! never tell me; I take it much unkindly   That thou, Iago, who hast had my purse   As if the strings were thine, shouldst know of this.        IAGO   ’Sblood, but you will not hear me:   If ever I did dream of such a matter, Abhor me.    etc.    Stylesheet  The stylesheet scene.xsl is designed to display this scene in HTML. This is how it starts:  <xsl:transform  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" version="2.0">  247   XSLT Elements                           Cast: <xsl:apply-templates select="$speakers"  mode="cast-list" >            The template rule shown above matches the   element. It ﬁrst displays the   element  if there is one  using the appropriate template rule. Then it sets up a variable called «speakers» to be a sequence containing all the distinct   elements that appear in the document. This is constructed by grouping all the   elements using the   instruction and then taking the ﬁrst one in each group. The result is a list of the speakers in which each one appears once only. The template rule then calls   to process this set of speakers in mode «cast-list»  a nice side effect is that they will be listed in order of appearance . Finally, it calls   again, this time in the default mode, to process all elements  «*»  except   elements  because the title has already been processed . The stylesheet carries on as follows:        ,       This template rule deﬁnes how the   element should be processed when it is being processed in «cast-list» mode. The sequence constructor has the effect of outputting the speaker’s name, followed by a comma if this is not the last speaker in the list. Finally, the remaining template rules deﬁne how each element should be output, when pro- cessed in default mode. Note that there are two different rules for STAGEDIR, depending on where it appears:                      248                                         xsl:apply-templates  6  X S L T  l  E e m e n t s  There is potentially a simpler solution to this requirement: the cast list can be constructed using the expression «string-join distinct-values   SPEAKER , ’, ’ ». However, using   gives a guarantee that the speakers will be listed in order of ﬁrst appearance, whereas the result order of distinct-values   is undeﬁned.  The precise layout of the HTML depends on which XSLT processor you are using, but apart from layout details it should start like this:   SCENE I. Venice. A street.   Cast: RODERIGO, IAGO, BRABANTIO    Enter RODERIGO and IAGO       RODERIGO   Tush! never tell me; I take it much unkindly  That thou, Iago, who hast had my purse  As if the strings were thine, shouldst know of this.    IAGO   ’Sblood, but you will not hear me:  If ever I did dream of such a matter, Abhor me.   Output               ...        It is sometimes useful to use named modes, even where they are not strictly necessary, to document more clearly the relationship between calling templates and called templates, and to constrain the selection of template rules rather more visibly than can be achieved by relying on template rule priorities. This might  249   XSLT Elements  even improve performance by reducing the number of rules to be considered, though the effect is likely to be marginal.  For example, suppose that a   consists of a number of   elements, and that the ﬁrst   is to be output using a different style from the rest. The orthodox way to achieve this would be as follows:    . . .     . . .     . . .     . . .    This relies on the default priority rules to ensure that the correct template rule is applied to each stanza — as explained in Chapter 12, the default priority for the pattern «stanza[1]» is higher than the default priority for «stanza».  Another way of doing this, perhaps less orthodox but equally effective, is as follows:    . . .     1]" mode="rest" >  . . .     . . .     . . .    Another solution, giving even ﬁner control, would be to use   and <xsl:call- template> to control precisely which template rules are applied to which nodes, avoiding the pattern-matching mechanisms of   altogether.  Which you choose is largely a matter of personal style, and it is very hard to argue that one is better than the other in all cases. However, if you ﬁnd that the match patterns used in deﬁning a template rule are becoming extremely complex and context dependent, then you probably have both a performance and a maintenance problem on your hands, and controlling the selection of template rules in the calling code, by using modes or by calling templates by name, may well be the answer.  Simulating Higher Order Functions In functional programming languages, a very useful programming technique is to write a function that accepts another function as an argument. This is known as a higher order function. For example, you might write a function that does a depth-ﬁrst traversal of a tree and processes each node in the tree using a function that is supplied as an argument. This makes it possible to use one tree-walking routine to achieve many different effects  you might recognize this as the Visitor Pattern .  250   xsl:apply-templates  In XSLT  and XPath , functions are not ﬁrst-class objects, so they cannot be passed as arguments to other functions. The same is true of templates. However, the template-matching capability of   can be used to simulate higher order functions.  This use of   has been developed to a ﬁne art by Dimitre Novatchev in his FXSL library  http:  fxsl.sourceforge.net  , which provides many examples of the technique.  A simple example of a higher order function found in many functional programming languages is the fold function. Given as an argument a function that adds two numbers, fold will ﬁnd the sum of all the numbers in a sequence. Given a function that multiplies two numbers, it will ﬁnd the product of the numbers in the sequence. In fact, fold takes three arguments: the sequence to be processed, the function to process two values, and the initial value. It turns out that the fold function can be used, with suitable arguments, to perform a wide variety of aggregation functions on sequences.  The key to the Novatchev technique is that although you cannot pass a function or template as an argu- ment to another function or template, you can pass a node, and you can use   to trigger execution of a template associated with that node.  Rather than show you how fold works, which you can ﬁnd out on the FXSL Web site, I will use another example that makes greater use of the new capabilities in XSLT 2.0. A common problem is to check whether there are cycles in your data. For example, your data might represent a part explosion, and you want to check that no part is a component of itself, directly or indirectly. Or you might be checking an XSLT stylesheet to check that no attribute set is deﬁned in terms of itself.  There is an example that shows how to do this conventionally, without a higher order function, under   on page 344.  The problem is that there are many ways one can represent a relationship between two nodes in XML, and we don’t want to have to write a new function to check for cycles each time we come across a new way of representing a relationship. So we write a general higher order function that looks for cycles and pass it, as a parameter, a function  actually represented by a node that will trigger a template rule  that knows how a particular relationship is represented.  6  X S L T  l  E e m e n t s  Example: Checking for Cycles in a Graph  This example provides a generic procedure to look for cycles in a graph and then applies this procedure to a data ﬁle to see if the ID IDREF links are cyclic. In essence, the algorithm to check for a cycle is this: given a function links A  that returns the set of nodes to which A is directly linked, the function refers A,B  is true if links A  includes B  that is, if there is a direct reference  or if there is a node C in the result of links A  such that refers C,B  is true  this is an indirect reference via C . This is a recursive def- inition, of course, and it is implemented by a recursive function. Finally, you know that A participates in a cycle if refers A,A  is true. In coding the function, we have to be careful to ensure that the implementation will never go into a loop, remembering that a node reachable from A might participate in a cycle even if A does not  for a simple example, consider a graph in which A refers to X and X refers to itself . To achieve this, we pass an extra parameter indi- cating the route by which a node was reached, and we ignore nodes that were already on the route  we could report a cycle if we ﬁnd them; but we’ve actually written this code to test whether a speciﬁc node participates in a cycle, which isn’t the same thing .  Stylesheet  The stylesheet that searches for cycles in a graph is in cycle.xsl.  251   XSLT Elements  You can implement the refers function like this:                                   <xsl:sequence select="exists $direct intersect $B  or   some $C in  $direct except $route   satisfies graph:refers $links, $C, $B,  $route, $C   " >     When you call this higher order function, you need to supply a node as the $links argu- ment that will always cause a particular template rule to be invoked. Let’s do this for the case where the link is established by virtue of the fact that the ﬁrst node contains an idref attribute whose value matches the id attribute of the node that it references. This is in idref-cycle.xsl:                     And now you can test whether the context node participates in a cycle like this:         Cycle detected!         Let’s look at the details of how this works: The higher order function is implemented using  . It can’t actually take a function or a template as a parameter, so what it takes instead is a node, which uniquely identiﬁes the speciﬁc code to be executed to follow a link. The code to follow a link is implemented as a template rule, and is invoked using  . An element is created     whose sole pur- pose is to trigger the execution of the associated template rule. Note that because of the  252   xsl:apply-templates  «as="element  "» attribute on the   element, the variable holds a single  parentless  element node, not a document node. Unlike conventional template rules that create new nodes, this particular rule returns a refer- ence to a sequence of existing nodes: speciﬁcally, the nodes selected by the select attribute of the   instruction. The result of the   instruction is also captured in a variable with an «as» attribute, which means that the result of the vari- able is the sequence of nodes returned by the template. Without the «as» attribute, the nodes would be copied to make a temporary document, which wouldn’t work, because the XPath intersect operator relies on the nodes in the variable $direct having their original identity  used in the way it is used here, it tests whether $B is one of the nodes in $direct . The important thing about this stylesheet is that the module cycle.xsl is completely general purpose: it has no knowledge of how the links between nodes are represented, and can therefore be used to look for cycles in any graph, however it is implemented.  Source  Two source ﬁles are supplied: acyclic-data.xml and cyclic-data.xml. Here is the one containing a cycle:  6  X S L T  l  E e m e n t s  <!DOCTYPE parts [     ]>                  Output  See Also   on page 322   on page 344   on page 452   on page 455   on page 483   on page 517  Running the stylesheet idref-cycle.xsl against the source ﬁle cyclic-data.xml simply produces an error message saying that the data contains a cycle.  Higher order functions such as this are a powerful programming technique, particularly when handling complex data structures.  253   XSLT Elements  xsl:attribute  The   instruction constructs an attribute node and adds it to the result sequence.  Changes in 2.0 The content of the attribute can be speciﬁed using a select attribute, as an alternative to using a sequence constructor. The separator attribute can be used to format the attribute value when the content is supplied as a sequence.  With a schema-aware XSLT processor, the type and validation attributes can be used to control the type annotation given to the new attribute node.  Format  <xsl:attribute  name = { qname } namespace? = { uri-reference } select? = expression separator? = { string } validation? = "strict"  "lax"  "preserve"  "strip" type? = qname>       Position   may be used either as an instruction within a sequence constructor, or within an   element.  Value Attribute value template returning a lexical QName  Meaning The name of the attribute node to be generated  Attribute value template returning a URI  The namespace URI of the generated attribute node  XPath Expression  Provides the value of the attribute  Attribute value template returning a string  Separator string to be inserted between items when the value is a sequence  «strict», «lax», «preserve», or «skip»  Lexical QName  Indicates whether and how the attribute should be subjected to schema validation  Identiﬁes a type declaration  either a built-in type, or a user-deﬁned type imported from a schema  against which the new element is to be validated  The type and validation attributes are mutually exclusive: if one is present, the other must be absent.  Attributes  Name name mandatory  namespace optional  select optional  separator optional  validation optional  type optional  254   xsl:attribute  Content A sequence constructor, unless the select attribute is present, in which case the content must be empty.  Effect The effect of this instruction is to create a new attribute node and to return this node as the result of the instruction. In the usual case where the sequence constructor containing the   instruction is used to construct the content of an element, the attribute must not be preceded in the result sequence by any node other than a namespace node or another attribute node. The name of the generated attribute node is determined using the name and namespace attributes. The way in which these attributes are used is described below in the section The Name of the Attribute.  The value of the new attribute node may be established either using the select attribute or using the sequence constructor contained in the   instruction. These are mutually exclusive: if the select attribute is present, the   element must be empty. If neither is present, the value of the attribute will be a zero-length string. The way the value of the attribute is established is described in more detail in the section The Value of the Attribute.  6  X S L T  l  E e m e n t s  When a schema-aware XSLT processor is used, the new attribute may be validated to ensure that it conforms to a type deﬁned in a schema. This process results in the new attribute node having a type annotation. The type annotation affects the behavior of subsequent operations on this attribute node even though it is not visible when the result tree is serialized as raw XML. The validation and annotation of the new attribute node are controlled using the type and validation attributes. This is described in the section Validating and Annotating the Attribute.  The Name of the Attribute The name of an attribute node has three parts: the preﬁx, the local name, and the namespace URI. These are controlled using the name and the namespace attributes.  Both the name and the namespace attributes may be given as attribute value templates; that is, they may contain expressions nested within curly braces. One of the main reasons for using the   instruction in preference to attributes on a literal result element  described in the section Literal Result Elements in Chapter 3, page 112  is that   allows the name of the attribute node to be decided at runtime, and this is achieved by using attribute value templates in these two attributes.  The result of expanding the name attribute value template must be a lexical QName; that is, a valid XML name with an optional namespace preﬁx, for example, «code» or «xsi:type». If there is a preﬁx, it must correspond to a namespace declaration that is in scope at this point in the stylesheet, unless there is also a namespace attribute, in which case it is taken as referring to that namespace.  The local part of the name of the created attribute node will always be the same as the local part of the QName supplied as the value of the name attribute.  If the   instruction has a namespace attribute, it is evaluated  expanding the attribute value template if necessary  to determine the namespace URI part of the name of the created attribute node:     If the value is a zero-length string, the attribute will have a null namespace URI. It will therefore be serialized without a preﬁx. Any preﬁx in the value of the name attribute will be ignored.  255   XSLT Elements           Otherwise, the value should be a URI identifying a namespace. This namespace will be used as the namespace URI of the new attribute node. This namespace does not need to be in scope at this point in the stylesheet, in fact it usually won’t be. The system may report an error if the namespace isn’t a valid URI. The namespace URI associated with any preﬁx in the QName obtained from the name attribute will be ignored.  If there is no namespace attribute:  If the supplied QName includes a preﬁx, the preﬁx must be a namespace preﬁx that is in scope at this point in the stylesheet: In other words, there must be an xmlns:prefix declaration either on the   instruction itself or on some containing element. The namespace URI in the output will be that of the namespace associated with this preﬁx in the stylesheet. Otherwise, the attribute will have a null namespace URI. The default namespace is not used.  Where possible, the preﬁx of the attribute name  or the absence of a preﬁx  will be taken from the preﬁx given in the name attribute. However, if it isn’t possible to use this preﬁx, then the namespace ﬁxup process  described on page 310  will allocate a different preﬁx. This arises, for example, if two attributes of the same element use the same preﬁx to refer to different namespaces, or if the attribute is in a namespace but no preﬁx is supplied, or if a reserved preﬁx such as xml or xmlns is used.  Namespace ﬁxup is not performed at the level of an individual attribute node. This is because attributes can only be associated with namespace nodes via their parent element.  If the name attribute provides a name that has no preﬁx, but a namespace attribute is present so that the namespace URI is not null, then the system has no choice but to invent a namespace preﬁx for the attribute. For example, if you write:         200         then the output might be:     The XSLT speciﬁcation explicitly states that you cannot use   to generate namespace declarations by giving an attribute name of «xmlns» or «xmlns:*». In the XPath data model, attributes and namespaces are quite different animals, and you cannot simulate a namespace declaration by creating an attribute node with a special name. Namespace declarations will be added to the output automatically whenever you generate elements or attributes that require them, and if you really need to, you can also force them to be generated using the   instruction.  Using the New Attribute Node The new attribute node, when initially created, has no parent node. Usually, however, the result of the instruction will form part of a sequence that is used to construct the content of a new element node. This will always be the case when the parent of the   instruction is an   or   instruction, or a literal result element, and it will also be the case when the   is contained in an  .  256   Very often the   instruction will be contained directly in the instruction that writes the element; for example:  xsl:attribute   2   but this is not essential, for example you could also do:                     red   green   blue      and then create the attribute from within the «set-border» template. Less commonly, parentless attribute nodes may be created and held in variables, for example:  In this particular case, just to show what is possible, we have created a variable whose value is a sequence of three parentless attributes, each of which has the same attribute name. These attributes could later be added to elements using instructions such as:           Whether the attribute node is added immediately to an element, or whether it is perhaps stored in a variable and added to an element later, at the point where the attribute is attached to an element, it must appear in the sequence before any child nodes  text nodes, elements, comments, or processing instructions  that are being added to the same element node.  This rule is there for the convenience of implementors. It means that the XSLT processor can execute the stylesheet and build the result tree sequentially, if it wishes. If it does so, the attributes for an element will always be evaluated before the children of the element, which means that the processor doesn’t actually need to build the result tree in memory. Instead, each node can be serialized to an XML ﬁle as soon as it is generated. If it weren’t for this rule, the software wouldn’t be able to write the ﬁrst start tag until right at the end, because there would always be a chance of an attribute being added to it.  When a sequence of nodes containing several attribute nodes is used to form the content of an element, and several of the attributes have the same name, the one that is used is the one that appears last in the sequence. This is not an error: in fact, when named attribute sets are used to add attributes to an output element, it is an important mechanism. Named attribute sets are described under   on page 266.  XQuery does this differently. In XQuery 1.0, adding two attributes with the same name to the same element is an error.  6  X S L T  l  E e m e n t s  257   XSLT Elements  The Value of the Attribute The string value of the new attribute node is obtained by evaluating the select attribute or the sequence constructor. The value of the separator attribute, if present, also plays a role.  Whether the select attribute or the sequence constructor is used, it is evaluated to produce a sequence of items, and this sequence of items is processed as follows:  1. 2.  3.  4.  5.  Adjacent text nodes in the sequence are merged, and zero-length text nodes are removed. The sequence is atomized. Atomization is described in Chapter 2  page 81 . This process replaces any nodes in the sequence by their typed values. Every value in the atomized sequence is converted to a string by applying the XPath casting rules. The strings in the resulting sequence are concatenated, with an optional separator between adja- cent strings. If the separator attribute is present, its value is used as the separator  this may be a zero-length string . If the select attribute is used, then the default separator is a single space; otherwise, it is a zero-length string — in other words, there is no separator. The resulting string is used as the value of the new attribute node.  <xsl:attribute name="x" select="1 to 5"  x="1, 2, 3, 4, 5"  The following examples illustrate the effect:  Instruction              separator="," >                        Result  x="1 2 3 4 5"  x="12345"  x="1-2-3-4-5"  x="12345" There is no separator here because adjacent text nodes are merged before separators are added.  In XSLT 1.0, it was an error if evaluating the content of an attribute produced a node other than a text node. Processors were allowed to recover by ignoring such nodes. In XSLT 2.0, any kind of node is allowed and is handled by the atomization process. If your stylesheet contains this error, and your XSLT 1.0 processor chose to ignore it, then it will produce different results under XSLT 2.0.  Validating and Annotating the Attribute This section is relevant only if you are using a schema-aware XSLT processor. With a non-schema-aware processor, you cannot use the type and validation attributes, and the type annotation on the new  258   xsl:attribute  attribute node will always be xs:untypedAtomic, which you can effectively ignore because it imposes no constraints. This will also be the result with a schema-aware processor if you omit these two attributes.  With a schema-aware processor, you can validate the new attribute to ensure that it conforms to relevant deﬁnitions in a schema. If validation fails, a fatal error is reported. If it succeeds, the new attribute node will have a type annotation that reﬂects the validation that was performed. This type annotation will not affect the way the attribute node is serialized, but if you want to do further processing on the attribute, the type annotation may affect the way this works. For example, if you sort a sequence of attributes annotated with type xs:integer, you will get different results than if they are annotated as xs:string.  If you use the type attribute, its value must be a lexical QName that identiﬁes a known type deﬁni- tion. Generally, this means that it must either be a built-in type such as xs:string or xs:dateTime, or it must be the name of a global simple type deﬁned in a schema that has been imported using an   declaration in the stylesheet.  That is, the local part of the QName must match the name attribute of a top-level   element in a schema document whose target namespace matches the namespace URI part of the QName.   6  X S L T  l  E e m e n t s  The XSLT speciﬁcation allows the implementation to provide other ways of accessing type deﬁnitions, perhaps through an API or conﬁguration ﬁle, and it also allows the type deﬁnition to originate from a source other than an XML Schema document, but since it provides no details of how this might work, we won’t explore the possibility further.  The processor validates that the value of the new attribute node conforms to the named type deﬁnition. If it does, the attribute is annotated with the name of this type. If it doesn’t, processing fails.  Validating an attribute using the type attribute places no constraints on the name of the attribute. It doesn’t need to be an attribute name that is deﬁned in any schema, and it doesn’t matter whether or not the attribute name is in a namespace. The validation is concerned with the content of the attribute and not with its name.  In contrast, validation using the validation attribute is driven by the attribute’s name.  For symmetry with other instructions, the validation attribute has four possible values: «preserve», «strip», «strict», and «lax». However, in the case of  , «preserve» and «strip» have exactly the same effect: No validation takes place, and the type annotation on the attribute node will be xs:untypedAtomic. Let’s focus on the other two options.           «validation="strict"» causes the processor to look for an attribute declaration that matches the name of the attribute. That is, it looks for a top-level   whose name attribute matches the local name of the attribute being validated, in a schema document whose target namespace matches the namespace URI of the attribute being validated. If it can’t ﬁnd such a deﬁnition, a fatal error is reported. Otherwise, the value of the attribute node is validated against the schema-deﬁned rules implied by this attribute declaration. Because global attribute declarations are uncommon, this facility has rather limited use. If the attribute declaration in the schema refers to a named type deﬁnition, then on successful validation, the attribute is annotated with this type name. If the attribute declaration contains an inline  and therefore unnamed  type deﬁnition, the XSLT processor invents a name for this implicit type, and uses this invented name as the type annotation. «validation="lax"» behaves in the same way as «validation="strict"», except that no fail- ure occurs if the processor cannot locate a top-level schema deﬁnition for the attribute. Instead of reporting an error, the attribute is annotated as xs:untypedAtomic.  259   XSLT Elements  Note that any type annotation created for the attribute may disappear once the attribute is added to an element, unless the element is itself validated, or is created using the option «validation= "preserve"».  XSLT does not provide any way of requesting validation of an attribute against a local attribute or type deﬁnition in a schema. The way around this is to request validation only when you create an element for which there is a top-level deﬁnition in the schema. This will then implicitly validate the whole subtree contained by that element, including elements and attributes that have local deﬁnitions in the schema.  You’re not allowed to validate an attribute if its type is namespace-sensitive. This applies to the types xs:QName and xs:NOTATION and anything derived from these two. The reason for this restriction is that the validity of these types depends on the namespace context  preﬁxes in the QName or NOTATION must have been declared . This means it doesn’t make sense to validate the attribute until it has been added to an element.  Usage You will sometimes see stylesheets that use the   instruction whenever they need to output an attribute value. However, in XSLT there are several different ways of generating an attribute in the result tree. This section compares the different approaches. It then looks speciﬁcally at the problem of creating an attribute whose value is a QName, such as an «xsi:type» attribute.  Different Ways of Creating Attributes Where an output element is generated using a literal result element, the simplest way to specify attributes is normally to include them as attributes on the literal result element itself. You can do this even when the value is derived from information in the source document, because the value can be generated using an attribute value template, for example:     This concatenates three attributes of the current node in the source tree to create a single attribute in the result tree. Attribute value templates are described in Chapter 3, page 122.  Using   gives you more control than writing the attribute directly using attribute value templates. It is useful where one of the following conditions applies:                    The parent element is output using   or    rather than a literal result element . There is conditional logic to decide whether to output the attribute or not. The name of the attribute is computed at runtime. There is complex logic to calculate the value of the attribute. The attribute is one of a set that can conveniently be grouped together using  . The output attribute belongs to a namespace that is not present in the source document or the stylesheet.  A third way to output attributes is to copy them from the source tree to the result tree by using   or  . This works only if the attribute you want to generate has the same name and same value as an attribute in the source.  260   xsl:attribute    can be used when the context node in the source document is an attribute node. It’s not necessary that the owning element was output using  ; for example, the following code ensures that the width, height, and depth attributes of the source   element are copied to the output   element, but its value and owner attributes are discarded:                           This example uses   to process all the attributes of the   element. Some of these match one template rule, which copies the attribute to the output element, while others match an empty template rule that does nothing.  The same effect could be achieved more easily with  , as follows:  6  X S L T  l  E e m e n t s                 The select expression here selects a sequence containing all the width, height, and depth attributes of the context node, and the   instruction copies this sequence. The «,» operator, described in Chapter 10, concatenates two sequences  or in this case, two nodes  to form a single sequence.  If you want to copy all attributes of the current node to the result tree, the simplest way to achieve this is  . If you want to copy all the attributes except certain particular ones, you can use the XPath 2.0 «except» operator:     Finally, if you want to add a bundle of commonly used attributes to an element, a convenient mech- anism is available in the form of attribute sets. These can be deﬁned using an   declaration, described on page 266.  Creating an Attribute Whose Value Is a QName XML Schema allows an attribute to have a value whose type is xs:QName. A typical example of such an attribute is «xsi:type="xs:decimal"», which happens to be an attribute whose meaning is deﬁned in the XML Schema speciﬁcation itself. But they can also be deﬁned in any other XML vocabulary. In fact, QName-valued elements can also be deﬁned, though I haven’t come across them in practice.  If you are generating an XSLT stylesheet as the output of the transformation, you will often have to gen- erate QNames in the content of attributes; not only attributes like the name attribute of   and  , but any attribute that contains an XPath expression or a pattern. In fact, any attribute that is an attribute value template can potentially contain a QName.  261   XSLT Elements  The tricky thing about these attributes is that they contain a namespace preﬁx, and you need to ensure that the output document contains a namespace declaration that binds this preﬁx to the correct URI.  It turns out that the fact that the attribute is declared in the schema as an xs:QName doesn’t help with this. Firstly, not all these attributes are declared as QNames  some of them contain entire XPath expressions . But even where the type is known to be an xs:QName, you can’t rely on this to ensure that the right namespaces are declared. This is because the process of creating an attribute node for an element in XSLT is typically:  1.  Evaluate the expression that delivers the attribute value; atomize the result of this expression and convert the resulting sequence to a single string. This process loses any type information associ- ated with the values from which the string was constructed. Create an attribute node with this string value.  2. 3. When the attribute is attached to an element, perform namespace ﬁxup on the element.  Namespace ﬁxup is described on page 310. Finally, if required, perform schema validation on the element.  4.  In this process, there is no type annotation associated with the attribute at the time namespace ﬁxup is performed. The namespace nodes need to be in place before validation of the attribute as a QName will succeed, so the only way of constructing them automatically would be to do it during validation, which would require a rewrite of the  already hideously complex  rules deﬁned in XML Schema for validating elements.  The consequence of all this is that when you construct one of these attributes, it is your responsibility ﬁrstly to choose a preﬁx and to output the attribute in its correct lexical form and secondly to ensure that the containing element node has a namespace node that maps this preﬁx to the required namespace URI. The simplest way to be sure of this is by using the   instruction described on page 390.  So to generate the element  93.7 , write:        <xsl:attribute name="xsi:type"  namespace="http:  www.w3.org 2001 XMLSchema-instance" select="’xs:decimal’">  <xsl:namespace name="xs"     select="’http:  www.w3.org 2001 XMLSchema’" >  An alternative to using  , in a case like this where the containing element is generated using a literal result element, is simply to ensure that the literal result element has a namespace node that will be copied to the result tree. This can be achieved by writing:     <xsl:attribute name="xsi:type"  namespace="http:  www.w3.org 2001 XMLSchema-instance" select="’xs:decimal’">        262   xsl:attribute  The cases where   is needed are  a  where the element is produced using   rather than a literal result element and  b  where the namespace preﬁx or URI is not known at compile time.  Note that it’s not a good idea to generate special attributes such as xsi:type by including them directly as attributes on the literal result element. This is because if the stylesheet is ever passed through a schema processor, the schema processor will try to check that the content of the   element in the stylesheet is xs:decimal, and of course it isn’t. You could avoid such problems by using namespace aliasing  see   on page 394 , but in my view generating the attribute using   is easier.  Examples The following example outputs an HTML   element, with a SELECTED attribute included only if the boolean variable $selected is true.  The XML output would be  , but the HTML output method will convert this to  .   6  X S L T  l  E e m e n t s  Example: Generating an Attribute Conditionally  This example shows the use of   in a situation where the attribute is gener- ated only if certain conditions are true in the source data.  Source  The source ﬁle is countries.xml.                         Stylesheet  The stylesheet ﬁle is options.xsl. This is a complete stylesheet using the simpliﬁed stylesheet syntax described in Chapter 3, page 125. It outputs an HTML selection box in which the selected attribute is set for the option marked as «selected="yes"» in the XML source document.  <html xsl:version="1.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform">     Please select a country:     263                  selected   XSLT Elements                Output  The output  shown with the selection box opened  is shown in Figure 6-1.  Figure 6-1  The following example outputs a   element with either a code or reason-code attribute, depending on the variable $schema-version. This kind of logic can be useful in an application that has to handle different versions of the output document schema.  Example: Deciding the Attribute Name at Runtime  This example shows the use of   in a situation where the name of the gen- erated attribute is decided at runtime.  This example uses no source ﬁle; it can be run by specifying main as the name of the initial template.  Source  264   Stylesheet  The stylesheet can be found in the ﬁle conditional.xsl. The stylesheet declares a global parameter «schema-version», which controls the name of the attribute used in the output ﬁle.  xsl:attribute  <xsl:stylesheet version="2.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform">          <xsl:variable name="attname"  select="if  $schema-version lt 3.0   then ’code’ else ’reason-code"’ >     6  X S L T  l  E e m e n t s          Output  With the default value of the parameter «schema-version», the output is:     When run with the parameter «schema-version» set to 2.0, the output is:     In XSLT 1.0, it was often necessary to use   because the value required a calculation. In the following example, the value of the content attribute is a whitespace-separated list of the id attributes of the child   elements of the context node:                                 In XSLT 2.0, the work can often be done at the XPath level. This example can now be written:     265   because when the value of an expression in an attribute value template is given as a sequence, the proces- sor will automatically convert the items in this sequence to strings and concatenate them using a single space as a separator.  The   element is a top-level XSLT declaration used to deﬁne a named set of attribute names and values. The resulting attribute set can be applied as a whole to any output element, providing a way of deﬁning commonly used sets of attributes in a single place.  XSLT Elements  See Also   on page 306   on page 287   on page 292  xsl:attribute-set  Changes in 2.0 None.  Format  <xsl:attribute-set  name = qname use-attribute-sets? = qnames>       Position   is a declaration, so it must always occur as a child of the   element.  Attributes Name name mandatory  Value Lexical QName  Meaning The name of the attribute set  use-attribute-sets optional  Whitespace-separated list of lexical QNames  The names of other attribute sets to be incorporated into this attribute set  Content Zero or more   elements.  Effect Named attribute sets provide a capability similar to named styles in CSS.  The name attribute is mandatory and deﬁnes the name of the attribute set. It must be a lexical QName: a name with or without a namespace preﬁx. If the name uses a preﬁx, it must refer to a namespace declaration that is in scope at this point in the stylesheet, and as usual it is the namespace URI rather than  266   xsl:attribute-set  the preﬁx that is used when matching names. The name does not need to be unique; if there are several attribute sets with the same name, they are effectively merged.  The use-attribute-sets attribute is optional. It is used to build up one attribute set from a number of others. If present, its value must be a whitespace-separated list of tokens each of which is a valid lexical QName that refers to another named attribute set in the stylesheet. For example:  <xsl:attribute-set name="table-cell"  use-attribute-sets="small-font gray-background centered" >      Verdana   6pt         xBBBBBB         center      6  X S L T  l  E e m e n t s  The references must not be circular: if A refers to B, then B must not refer directly or indirectly to A. The order is signiﬁcant: specifying a list of named attribute sets is equivalent to copying the   elements that they contain, in order, to the beginning of the list of   elements contained in this   element.  If several attribute sets have the same name, they are merged. If this merging ﬁnds two attributes with the same name, then the one in the attribute set with higher import precedence will take precedence. Import precedence is discussed under   on page 357. If they both have the same precedence, the one that came later in the stylesheet is used.  The order in which this merging process takes place can affect the outcome. When use-attribute-sets appears on an   or   element, or xsl:use-attribute-sets on a lit- eral result element, it is expanded to create a sequence of attribute nodes. This is essentially done by a recursive process:  1.  2.  3.  To expand an [xsl:]use-attribute-sets attribute, use rule 2 to process each of the attribute set names in the order they are listed. To process an attribute set name, use rule 3 to expand each of the   decla- rations having that name, taking them in increasing order of import precedence, and within each import precedence, in declaration order. For deﬁnitions of import precedence and declaration order, see   on page 357. To expand an   declaration, use rule 1 to expand its use-attribute-sets attribute  if any , then add the attribute nodes generated by evaluating the contained   instructions to the result sequence.  It’s best to illustrate this by an example. Suppose you have the following attribute-set deﬁnition:      percy   queenie   rory      267   XSLT Elements  If there is more than one attribute set named A1 these must be merged ﬁrst  taking import precedence into account , and then the merged contents must be substituted into B.  Then the same process is applied to A2. The referenced attribute sets are expanded in order. The attributes that result from expanding A1 are output before those that result from expanding A2. This means that attributes from A2 take priority over those from A1 if there is a clash, because of the rule that when several attributes have the same name, the last one wins.  In turn, the attribute set B must be fully expanded before it is merged with any other attribute set called B. That is, the processor must replace the references to attribute sets A1 and A2 with an equivalent list of   instructions before it merges this B with other attribute sets of the same name.  When B is expanded, the attributes derived from A1 and A2 will be output before the attributes p, q, and r, so if expanding A1 and A2 generates any attributes called p, q, and r, these will be overwritten by the values speciﬁed within B  percy, queenie, and rory .  Normally when describing the processing model for XSLT instructions, we distinguish between the process of generating a sequence of nodes, and the subsequent process of attaching these nodes to a tree. Eliminating attribute nodes with duplicate names is technically part of the second process. However, attribute sets can only be expanded from instructions that create elements, so the resulting attributes will always be attached to an element. This means we can treat it as if generating the attribute nodes and attaching them to an element are done as a single process.  Duplicate attribute names or attribute set names do not cause an error. If several attributes have the same name, the one that comes last  in the order produced by the merging rules given above  will take precedence.  Usage The most common use of attribute sets is to deﬁne packages of attributes that constitute a display style, for example a collection of attributes for a font or for a table. They are often used when generating XSL-FO.  A named attribute set is used by referring to it in the use-attribute-sets attribute of the   or   element or in the xsl:use-attribute-sets attribute of a literal result element or, of course, in the use-attribute-sets attribute of another  . The ﬁrst three cases all create an element node and have the effect of adding the attributes in the named attribute set to that element node. Any attributes added implicitly from a named attribute set can be overridden by attribute nodes added explicitly by the invoking code.  An attribute set is not simply a textual macro. The attributes contained in the attribute set each have a select attribute or sequence constructor to deﬁne the value, and although this will often return a ﬁxed value, it may also, for example, declare variables or invoke other XSLT instructions such as   and  .  The rules for the scope of variables, described under   on page 500, are the same as anywhere else, and are deﬁned by the position of the deﬁnitions in the source stylesheet document. This means that the only way to parameterize the values of attributes in a named attribute set is by reference to global variables and parameters: There is no other way of passing parameters to an attribute set.  268   xsl:attribute-set  However, the value of the generated attributes may depend on the context in the source document. The context is not changed when the attribute set is used, so the context item  «.»  as well as the context position and size are exactly the same as in the calling instruction.  Examples The following example deﬁnes an attribute set designed for generated HTML   elements:      1   3   0   100%      This attribute set can be used when generating an output element, as follows:     6  X S L T  l  E e m e n t s  This produces the following output:   ...       ...       ...      The output now becomes:   ...         Alternatively it is possible to use the attribute set while overriding some of its deﬁnitions and adding others, for example:        If this combination of attributes is also used repeatedly, it could be deﬁned as an attribute set in its own right, as:      2   cols      Then this new attribute set could also be invoked by name from a literal result element, an   instruction, or an   instruction.  The next example shows that the values of the attributes in an attribute set need not be constants.  269   XSLT Elements  Example: Using an Attribute Set for Numbering  This is a rather untypical example, designed to show that attribute sets are more powerful than you might imagine. Suppose you want to copy an XML ﬁle containing a poem, but with the   elements in the poem output in the form   within the stanza.  Source  The source ﬁle poem.xml has the following structure  I’m only showing the ﬁrst stanza :       Rupert Brooke   1912   Song     And suddenly the wind comes soft,   And Spring is here again;   And the hawthorn quickens with buds of green   And my heart with buds of pain.       Stylesheet  The stylesheet number-lines.xsl copies everything unchanged except the   elements, which are copied with a named attribute set:  <xsl:transform  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" version="2.0">                                               270   xsl:call-template  The output  again showing only the ﬁrst stanza  looks like this:  Output      Rupert Brooke   1912   Song      And suddenly the wind comes soft,   And Spring is here again;   And the hawthorn quickens with   And my heart with buds of pain.   buds of green         6  X S L T  l  E e m e n t s  See Also   on page 306   on page 287 Literal Result Elements in Chapter 3, page 112  xsl:call-template  The   instruction is used to invoke a named template. Its effect is analogous to a procedure call or subroutine call in other programming languages.  Changes in 2.0 There are no syntactic changes to this instruction in XSLT 2.0. However, using the   instruction in the called template  see page 452  now allows the result of the   instruction to be any sequence, not only a sequence of nodes.  In many cases where it was appropriate to use   in XSLT 1.0, it may be more appropriate in 2.0 to call a stylesheet function deﬁned using  , which is described on page 344.  Many problems that required recursive use of   to process a string can be solved more conveniently in XSLT 2.0 by using the   instruction  see page 230 , and many problems that used recursion to process a sequence of nodes can now be tackled more easily by using  , described on page 326.  It is now a compile-time error to supply a parameter that the called template does not declare; in XSLT 1.0, such a parameter was silently ignored. To preserve backward compatibility, this rule is not enforced when the stylesheet speciﬁes «version="1.0"».  271   XSLT Elements  Format  <xsl:call-template  name = qname>       Attributes Name name mandatory  Content Zero or more   elements.  Position   is an instruction; it is always used within a sequence constructor.  Value Lexical QName  Meaning The name of the template to be called  Effect The sections below describe the rules for the template name, the rules for supplying parameters to the called template, and the way the context is affected.  The Template Name The mandatory name attribute must be a lexical QName, and it must match the name attribute of an   element in the stylesheet. If the name has a namespace preﬁx, the names are compared using the corresponding namespace URI in the usual way. It is an error if there is no   element with a matching name.  If there is more than one   in the stylesheet with a matching name, they must have different import precedence, and the one with highest import precedence is used. For information about import precedence, see   on page 357.  The name of the template to be called must be written explicitly in the name attribute. There is no way of writing this name as a variable or an expression to be evaluated at runtime. If you want to make a runtime decision on which of several named templates to call, the only way to achieve this is to write an   instruction. Alternatively, there is a technique for using template rules as if they were higher order functions; this is described under Simulating Higher Order Functions on page 250.  Parameters If the name of a child   element matches the name of an   element in the called  , then the   element is evaluated  in the same way as an   element , and the value is assigned to the relevant   variable name within that named template.  If the   element speciﬁes «tunnel="yes"», then the parameter is available not only in the immediately called template but to templates at any depth in the call stack, provided they declare the parameter with   and a matching name. Tunnel parameters are described  272   xsl:call-template  more fully on page 429. In XSLT 2.0 a compile-time error is reported if there is a child   element that isn’t a tunnel parameter and that doesn’t match the name of any   element in the selected  . However, if the   instruction is in a part of the stylesheet that speciﬁes «[xsl:]version="1.0"», the extra parameter is ignored as it was in XSLT 1.0.  If there is an   element in the selected   with no matching <xsl:with- param> element in the   element, then the   variable is given a default value. But if the   element speciﬁes «required="yes"», this is a compile-time error. See   on page 425 for details.  Context The selected   is evaluated with no change to the context: it uses the same context item, context position, and context size as the calling template. There is also no change to the current template rule  a concept that is used only by  , described on page 237, and  , described on page 399 . The current mode is also unchanged.  6  X S L T  l  E e m e n t s  Usage and Examples The   element is similar to a subroutine call in conventional programming lan- guages, and the parameters behave in the same way as conventional call-by-value parameters. It is useful wherever there is common logic to be called from different places in the stylesheet.  Using the Result The result of an   instruction is the sequence returned by the sequence construc- tor inside the template that is called. Usually, this consists of nodes that are immediately added to the result tree. However, you can also capture the result by calling   from within an   element, in which case the result of the called template becomes the value of the variable.  For example, the following template outputs the supplied string enclosed in parentheses:             This may be called as follows:                 If the value of the credit attribute is «120.00», the resulting value of the variable «$credit-in- paren» will be the string « 120.00 ».  If you omitted the «as="xs:string"» from the   element, the result would not be a string, but a temporary tree consisting of a document node that owns a single text node, and the contents of that text node would be « 120.00 »; but for all practical purposes the value could still be used as if it were a string. One difference is that you won’t get such good type checking: For example, if you try to use the variable $credit-in-paren as deﬁned above in a context where a number is required, this will  273   XSLT Elements  be reported as an error, quite possibly at compile time. But if you leave off the «as» attribute, you will probably not get an error at all, just a wrong answer: The system will treat the value of the variable as NaN  not a number .  Changing the Context Item If you want to use   to process an item that is not the context item, the easiest way to achieve this is to nest the   inside an   instruction. An alternative, however, is to give the target template a distinctive mode name and call it using <xsl:apply- templates> with the speciﬁed mode.  For example, suppose you have written a template that returns the depth of the current node  the number of ancestors it has . The template has been given a unique name and an identical mode name:           Now, suppose you want to obtain the depth of a node other than the context node — let’s say the depth of the next node in document order, which need not be on the same level as the context node. You can call this template in either of two ways.  Using  :                 or using   with a special mode:           In both cases the variable $next-depth will, on return, hold a value, which is the depth in the tree of the node following the context node. If the context item is not a node, a runtime error will occur. Because the   element has an «as» attribute, the result is of type xs:integer. Without the «as» attribute, the result would be a temporary document containing a single text node, whose value is the string representation of this integer. For details, see   on page 500.  Recursion: Processing a List of Values Named templates are sometimes used to process a list of values. As XSLT has no updateable variables like a conventional programming language, it also has no conventional for or while loop, because these constructs can only terminate if there is a control variable whose value is changing.  In XSLT 2.0 most processing of sequences can be done iteratively, using the XSLT   instruction or the XPath 2.0 «for» expression; for example:  sum for $i in   item return $i price * $i quantity   274   xsl:call-template  or more simply:  sum   item  price * quantity    When things get difﬁcult, it is possible to use functions such as tokenize   or distinct-values   to deﬁne the sequence that needs to be processed, and to use instructions such as   and   to do the processing. In XSLT 1.0 it was often necessary to write recursive templates to perform such calculations.  Recursion is still needed in XSLT 2.0 to handle more complex algorithms, particularly those that navi- gate a hierarchy or a graph, but it will often be done more conveniently using XPath function calls and stylesheet functions written using   rather than using  . Nev- ertheless, recursive use of   still has a role to play, so I will present a couple of examples.  The typical logic used to process a sequence using recursion is illustrated by the following pseudocode:  6  X S L T  l  E e m e n t s  function process-sequence sequence L  {  if  not-empty L   {  process first L  ; process-sequence remainder L  ;  }  }  That is, the function does nothing if the sequence is empty; otherwise, it processes the ﬁrst item in the sequence and then calls itself to process the sequence containing all items except the ﬁrst. The net effect is that each item in the sequence will be processed and the function will then exit. This particular approach to writing recursive algorithms is often known as head-tail recursion.  There are two main kinds of sequence that this logic is applied to: sequences of nodes, and strings containing separator characters. I will show one example of each kind; more complex examples can be found in Chapters 17 and 20.  Example: Using Recursion to Process a Sequence of Nodes  Here’s an example for processing a sequence of nodes. XPath 2.0 provides min   and max   functions for ﬁnding the minimum and maximum of a set of atomic values, but it doesn’t provide a way of processing a set of nodes and returning the one whose value for some expression is least or greatest. This can be done by computing the value of the expression for each of the nodes, passing these values into the min   or max   function and then searching the nodes to see which of them had this value, but this approach is rather inefﬁcient because it involves visiting each node and calculating the expression twice. So we’ll do it ourselves, using a recursive scan of the nodes, in a single pass. The speciﬁc task we will tackle is to look for the longest speech in a scene of a play. Conceptually it’s trivial: the maximum value of a set of numbers is either the ﬁrst number or the maximum of the set of the numbers after the ﬁrst, whichever is larger. We use XPath predicates for manipulating the node sequences: in particular, «[1]» to ﬁnd the ﬁrst node in the sequence, and «[position  ! = 1]» to ﬁnd the remainder.  275   XSLT Elements  Source  The source ﬁle scene.xml is the scene of a play. It starts like this:      SCENE I. Venice. A street.   Enter RODERIGO and IAGO      RODERIGO   Tush! never tell me; I take it much unkindly   That thou, Iago, who hast had my purse   As if the strings were thine, shouldst know of this.        IAGO   ’Sblood, but you will not hear me:   If ever I did dream of such a matter, Abhor me.    etc.    Stylesheet  The stylesheet longest-speech.xsl is shown below. It starts by deﬁning a named template «max». This template takes a node sequence called «list» as its parameter. The ﬁrst thing it does is to test whether this node sequence is nonempty  <xsl:when test= "$list"> . If it isn’t, it gets the number of   element children of the ﬁrst node in the list into a variable «$first». Then the template calls itself recursively, passing all nodes except the ﬁrst as the parameter, to determine the maximum value for the rest of the list. It then returns either the ﬁrst value or the maximum for the rest of the list, whichever is greater. Finally, if the supplied list was empty, it returns zero. The template rule for the root node of the source document simply calls the «longest-speech» template, passing the list of all   elements as a parameter.  <xsl:transform  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" xmlns:xs="http:  www.w3.org 2001 XMLSchema" exclude-result-prefixes="xs" version="2.0"  >           <xsl:variable name="first" select="count $list[1] LINE "  as="xs:integer" >        <xsl:with-param name="list"  276   xsl:call-template  6  X S L T  l  E e m e n t s  select="$list[position  !=1]" >                                                         Output  The output gives the text of the longest speech in this scene. It starts like this:        IAGO   O, sir, content you;   I follow him to serve my turn upon him:   We cannot all be masters, nor all masters   Cannot be truly follow’d. You shall mark   Many a duteous and knee-crooking knave,   That, doting on his own obsequious bondage,   Wears out his time, much like his master’s ass,   For nought but provender, and when he’s old, cashier’d:   Whip me such honest knaves...  Our version of AltovaXML 2008 gave the wrong answer on this stylesheet. Altova tell us there’s a ﬁx in the next release.  Note that this is taking advantage of several new features of XSLT 2.0. The template uses   to return a reference to an existing node, rather than creating a copy of the node using  . It also declares the type of the parameters expected by the template, and the type of the result, which is useful documentation, and provides information that the XSLT processor can use for gen- erating optimized code. I also found that while I was developing the stylesheet, many of my errors were trapped by the type checking. Note that the form «as="element SPEECH "» can be used even when there is no schema. The example could have been rewritten to make much heavier use of XSLT 2.0 features;  277   XSLT Elements  for example, it could have been written using   rather than  , and the   instruction could have been replaced by an XPath 2.0 «if» expression. The result would have occupied fewer lines of code, but it would not necessarily have been any more readable or more efﬁcient.  There is another solution to this problem that may be more appropriate depending on the circumstances. This involves sorting the node-set, and taking the ﬁrst or last element. It goes like this:                         In principle, the recursive solution should be faster, because it only looks at each node once, whereas sorting all the values requires more work than is strictly necessary to ﬁnd the largest. In practice, though, it rather depends on how efﬁciently recursion is implemented in the particular processor.  Another case where recursion has traditionally been useful is processing of a list presented in the form of a string containing a list of tokens. In XSLT 2.0, most such problems can be tackled much more conve- niently using the XPath 2.0 tokenize   function, which breaks a string into a sequence by using regular expressions, or by using the   instruction described on page 230. But although these functions are excellent at breaking a string into a sequence of substrings, they don’t by themselves provide any ability to process the resulting sequence in a nonlinear way. Sometimes recursion is still the best way of tackling such problems.  Example: Using Recursion to Process a Sequence of Strings  Suppose that you want to ﬁnd all the lines within a play that contain the phrase «A and B», where A and B are both names of characters in the play.  Source  Stylesheet  There is only one line in the whole of Othello that meets these criteria. So you will need to run the stylesheet against the full play, othello.xml.  The stylesheet naming-lines.xsl starts by declaring a global variable whose value is the set of names of the characters in the play, with duplicates removed and case normalized for efﬁciency:  <xsl:transform  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" xmlns:xs="http:  www.w3.org 2001 XMLSchema" xmlns:local="local-functions.uri" exclude-result-prefixes="xs local" version="2.0"  >  278   xsl:call-template  6  X S L T  l  E e m e n t s  <xsl:variable name="speakers" as="xs:string*"  select="for $w in distinct-values   SPEAKER  return upper-case $w " >  We’ll write a function that splits a line into its words. This was hard work in XSLT 1.0, but it is now much easier.            The next step is a function that tests whether a given word is the name of a character in the play:             This way of doing case-independent matching isn’t really recommended, it’s better to use a collation designed for the purpose, but it works with this data. Note that we are relying on the ‘‘existential’’ properties of the «=» operator: that is, the fact that it compares the word on the left with every string in the $speakers sequence. Now I’ll write a named template that processes a sequence of words, and looks for the phrase «A and B» where A and B are both the names of characters.          <xsl:if test="local:is-character $words[1]  and lower-case $words[2]  = ‘and’ and local:is-character $words[3] ">                <xsl:with-param name="words"  select="$words[position   gt 1]" >           Then comes the ‘‘main program,’’ the template rule that matches the root node. This simply calls the named template for each   element in the document, which causes   elements to be output for all matching sequences:           279   XSLT Elements                      Output  The output is simply:        Othello and Desdemona      See Also   on page 240   on page 344   on page 425   on page 483   on page 517  xsl:character-map  The   element is a top-level XSLT declaration used to provide detailed control over the way individual characters are serialized. A character map is used only when the result of the transformation is serialized, and when the   declaration that controls the serialization references the character map.  Changes in 2.0 Character maps are a new feature in XSLT 2.0, designed as a replacement for disable-output- escaping, which is now deprecated.  Format  <xsl:character-map  name = qname use-character-maps? = qnames>       Position   is a top-level declaration, so it must always occur as a child of the   element.  280   xsl:character-map  Attributes Name name mandatory  Value Lexical QName  Meaning The name of this character map  6  X S L T  l  E e m e n t s  use-character-maps optional  Whitespace-separated list of lexical QNames  The names of other character maps to be incorporated into this character map  Content Zero or more   elements.  Effect The «name» attribute is mandatory, and deﬁnes the name of the character map. It must be a lexical QName: a name with or without a namespace preﬁx. If the name uses a preﬁx, it must refer to a name- space declaration that is in scope at this point in the stylesheet, and as usual it is the namespace URI rather than the preﬁx that is used when matching names. If several character maps in the stylesheet have the same name, then the one with highest import precedence is used; an error is reported if this rule does not identify a character map uniquely. Import precedence is explained on page 359.  The character map contains zero or more   elements. Each <xsl:output- character> element deﬁnes a mapping between a single Unicode character and a string that is used to represent that character in the serialized output. For example, the element:     indicates that the nonbreaking space character  Unicode codepoint 160  is to be represented on output by the string «&nbsp;». This illustrates one of the possible uses of character maps, which is to render speciﬁc characters using XML or HTML entity references.  The use-character-maps attribute is optional. It is used to build up one character map from a number of others. If present, its value must be a whitespace-separated list of tokens, each of which is a valid QName that refers to another named character map in the stylesheet. For example:                      ...                 281   XSLT Elements  ...     <xsl:character-map name="latin-1-entities"  use-character-maps="NBSP  latin-1-symbols latin-1-accented-characters" >  This example creates a composite character map called latin-1-entities that is effectively the union of three underlying character maps. The effect in this case is as if all the   elements in the three underlying character maps were actually present as children of the composite character map.  The rules for merging character maps are as follows. Firstly, there must be no circularities  a char- acter map must not reference itself, directly or indirectly . The expanded content of a character map can then be deﬁned  recursively  as the concatenation of the expanded content of each of the character maps referenced in its use-character-maps attribute, in the order in which they are named, followed by the   elements that are directly contained in the   element, in the order that they appear in the stylesheet. If the expanded content of a character map contains two mappings for the same Unicode character, then the one that comes last in this sequence is the one that is used.  Usage and Examples Character maps have no effect on the XSLT transformation proper; they only affect the way that the result tree is serialized. If the result tree is used in some way other than passing it to a serializer  for example, if it is input to another transformation in a pipeline , then character maps have no effect.  For advice on using character maps as part of the serialization process, and worked examples, see Chapter 15 Serialization.  See Also   on page 420   on page 424 Character Maps in Chapter 15, page 941  xsl:choose  The   instruction deﬁnes a choice between a number of alternatives.  If there are two alternatives it performs the equivalent of if-then-else in other languages; if there are more than two, it performs the equivalent of a switch or select statement.  Changes in 2.0 There are no changes to the syntax of   in XSLT 2.0. However, by using   instructions within the   or   branch, it is now possible to use   in cases where the required result is an atomic value, or a reference to an existing node. In XSLT 1.0, the result always consisted of newly constructed nodes.  282   6  X S L T  l  E e m e n t s  In many situations where   was used in XSLT 1.0, it is now possible to use an XPath condi- tional expression  if-then-else  instead, which can sometimes make the code much more compact.  xsl:choose  Format           Position   is an instruction; it is always used within a sequence constructor.  Attributes None.  Content One or more   elements.  Optionally, an   element, which must come last if it is present at all.  Effect The   element is evaluated as follows:           The ﬁrst   element whose test expression is true is selected. Subsequent   elements are ignored whether or not their test expression is true. The test expression is evalu- ated to obtain its effective boolean value; the rules for this are given under  , on page 354. If none of the   elements has a test expression that is true, the   element is selected. If there is no   element, no element is selected, and the   element therefore has no effect  it returns an empty sequence . The selected child element  if any  is executed by evaluating its sequence constructor in the current context. So the effect is as if the relevant sequence constructor appeared in place of the   instruction.  The test expression in   elements after the selected one is not evaluated.  Usage The   instruction is useful where there is a choice of two or more alternative courses of action. It thus performs the functions of both the if-then-else and switch or Select Case constructs found in other programming languages.  Using   with a single   instruction and no   is permitted and means exactly the same as  . Some people suggest writing every   instruction this way, to save rewriting it later when you discover that you want an else branch after all.  When   is used within the body of an    or   or <xsl:with- param>  element, the effect is a conditional assignment: the relevant variable is assigned a different value depending on the conditions.  283   XSLT Elements  Examples The following example returns the name of a state in the USA based on a two-letter abbreviation for the state. If the abbreviation is not that of a recognized state, it outputs the abbreviation itself.      Arizona   California   Washington DC  ......         An alternative way of coding such an expression is to use template rules, perhaps in a particular mode:   Arizona   California   Washington DC   The following example declares a variable called width and initializes its value to the width attribute of the current node, if there is one, or to 100 otherwise.                               You might be tempted to write this as follows:                             This is legal XSLT, but it does not achieve the required effect. This is because both the variables called «width» have a scope that is bounded by the containing element, so they are inaccessible outside the   instruction.  Everyone has personal preferences when coding. I tend to prefer constructs that are more compact than  . I would usually write the above example as:     284   xsl:comment  See Also   on page 515   on page 420   on page 353  xsl:comment  The   instruction is used to write a comment node to the result sequence.  Changes in 2.0 A select attribute is added in XSLT 2.0, allowing the content of the comment to be deﬁned by an XPath expression rather than by a sequence constructor. It’s no longer an error to include two adjacent hyphens in the value of a comment — the processor will insert a space to make it legal XML.  6  X S L T  l  E e m e n t s  Format  <xsl:comment  select? = expression>       Position   is an instruction; it is always used within a sequence constructor.  Value XPath Expression  Meaning Deﬁnes the string value of this comment node  The select attribute and the sequence constructor are mutually exclusive; if one is present, the other must be absent.  Attributes Name select optional  Content A sequence constructor.  Effect The value of the comment is produced by evaluating either the select attribute or the sequence con- structor. If neither is present, the comment will be empty.  The value is computed in the same way as for    see page 254 , except that the separator between adjacent values is always a single space. The resulting string forms the string value of the new comment node.  If the comment includes a hyphen that is immediately followed either by a second hyphen or by the end of the comment, a single space will be added after the offending hyphen to ensure that the comment follows the XML rules.  285   XSLT Elements  In XML or HTML output, the comment will appear as:     Usage In theory, a comment has no meaning to the software that processes the output document — it is intended only for human readers. Comments are therefore useful to record when and how the document was generated, or perhaps to explain the meaning of the tags.  Comments can be particularly useful for debugging the stylesheet. If each   in the stylesheet starts with an   instruction, you will ﬁnd it much easier to trace back from the output to your stylesheet.  Comments in HTML output are used for some special markup conventions, for example surrounding Dynamic HTML scripts. The purpose of the comment here is to ensure that browsers that don’t under- stand the script will skip over it rather than display it as text. An example is shown below.  Examples Three examples follow.  Example 1: Showing the Date and Time of Transformation The following example generates a comment showing the date and time at which the output ﬁle was generated, and identifying the XSLT processor that was used:       Generated on:   <xsl:value-of select="format-dateTime   current-dateTime  , ’[D] [MNn] [Y] at [H]:[m]:[s]’ " >    using       version         Typical output might be:     Example 2: Generating Commented-Out JavaScript The following example outputs a piece of client-side JavaScript to an HTML output ﬁle:        function bk n  {  }  parent.frames[’content’].location="chap" + n + ".1.html";  286   xsl:copy  6  X S L T  l  E e m e n t s          The output will look like this:     function bk n  {  <!--  }    -->   parent.frames[’content’].location="chap" + n + ".1.html";  The comment cannot be written as a comment in the stylesheet, of course, because then the XSLT proces- sor would ignore it entirely. Comments in the stylesheet are not copied to the output destination.  Example 3: Generating Comments Containing Markup Sometimes you want to generate comments that contain markup, for example:           It’s not possible to do this by creating a result tree that contains an element node as a child of a com- ment node, because comment nodes can’t have children. This leaves two possibilities: either create the serialized representation of the element ‘‘by hand’’, as a string, or trick the serializer into generating the comment delimiters by using character maps. The ﬁrst approach looks like this:   [if lt IE 6]&gt;  &lt;![endif]   &lt;link rel="stylesheet" type="text css" href="IE5style.css"  &gt;  The alternative solution uses a character map:             where the two entities if-lt-IE6 and endif are deﬁned in the DTD to map to arbitrary private-use-area characters, followed by:   &if-lt-IE6;       &endif;   xsl:copy  The   instruction copies the context item in the source document to the result sequence. This is a shallow copy; it does not copy the children, descendants, or attributes of the context node, only the context node itself and  if it is an element  its namespaces. For a deep copy, you need to use  , see page 292.  287   XSLT Elements  Changes in 2.0 New attributes copy-namespaces and inherit-namespaces have been added, to allow ﬁner control over whether namespace nodes for an element should be copied or not.  New attributes validation and type have been added to control whether and how a copied node is validated against a schema.  Format  <xsl:copy  copy-namespaces? = "yes"  "no" inherit-namespaces? = "yes"  "no" use-attribute-sets? = qnames validation? = "strict"  "lax"  "preserve"  "strip" type? = qname>       Position   is an instruction. It is always used within a sequence constructor.  Attributes Name copy-namespaces optional  inherit-namespaces optional  use-attribute-sets optional  validation optional  type optional  Value «yes» or «no».  Default is «yes» .  «yes» or «no».  Default is «yes» .  Whitespace-separated list of lexical QNames  «strict», «lax», «preserve», or «skip»  Lexical QName  Meaning Indicates whether the namespace nodes of an element should be copied.  Indicates whether the children of a copied element will inherit its namespaces.  The names of attribute sets to be applied to a copied element.  Indicates whether and how the copied nodes should be subjected to schema validation, or whether existing type annotations should be retained or removed.  Identiﬁes a type declaration  either a built-in type, or a user-deﬁned type imported from a schema  against which copied nodes are to be validated.  Content An optional sequence constructor, which is used only if the item being copied is a document node or an element.  288   xsl:copy  Effect The action depends on the kind of context item, as follows: Item kind atomic value  Action Adds the atomic value to the result sequence.  Atomic values have no identity, so there is no distinction between the original value and a copy of the value.   document  element  text  attribute  6  X S L T  l  E e m e n t s  A new document node is added to the result sequence. The sequence constructor is evaluated to provide the content for the document node. This works in the same way as the content of an   instruction, as described on page 303. The attributes copy-namespaces, inherit-namespaces, and use-attribute-sets are ignored. The type and validation attributes have the same effect as with  .  An element node is added to the result sequence, as if by a call on  . This will have the same name as the context node. The local name and namespace URI are guaranteed to be the same as the original, and the preﬁx will be the same unless there is a conﬂict. The namespace nodes associated with the current element node are copied to the new element, unless «copy-namespaces="no"» is speciﬁed. The namespace nodes are also copied to the new children of the element, unless «inherit-namespaces="no"» is speciﬁed. The use-attribute-sets attribute and the contained sequence constructor are then evaluated to create the attributes and children of the new element in the same way as for  . Namespace ﬁxup is applied to the new element, to ensure that it has all the namespace nodes it needs, in the same way as for the   instruction. With a schema-aware processor, the new element may be validated and may acquire a type annotation; this depends on the values of the type and validation attributes, and works exactly as for   described on page 306. Note the surprising consequence that «validation="preserve"» does not cause the type annotation of the original element to be retained: This is not feasible, because the content of the element is not being copied.  A new text node is added to the result sequence, with the same string value as the context node. The attributes of the   instruction and the sequence constructor are ignored.  A new attribute node is added to the result sequence, as if by a call on  . This will have the same name and value as the context node. The attributes copy-namespaces, inherit-namespaces, and use-attribute-sets are ignored. The local name, namespace URI, and string value of the output attribute are guaranteed to be the same as the original, and the preﬁx will be the same unless there is a conﬂict  for example, if two attributes added to the same element use the same preﬁx to refer to different namespace URIs . With a schema-aware processor, the new attribute may be validated and may acquire a type annotation: This depends on the values of the type and validation attributes, and works exactly as for   described on page 292.  processing instruction  A processing instruction node is added to the result sequence, with the same name and value  target and data in XML terminology  as the context node. The attributes of the   instruction and the sequence constructor are ignored.  continued  289   XSLT Elements  Item kind comment  namespace  Action A comment node is added to the result sequence, with the same content as the context node. The attributes of the   instruction and the sequence constructor are ignored.  The namespace node is copied to the result sequence. The new namespace node will have the same name and value  that is, the same namespace preﬁx and URI  as the original. The attributes of the   instruction and the sequence constructor are ignored.  Usage The main use of   is when doing an XML-to-XML transformation in which parts of the doc- ument are to remain unchanged. It is also useful when the source XML document contains XHTML fragments within it; for example, if the simple HTML formatting elements such as   and   are used within textual data in the source and are to be copied unchanged to an HTML output document.  Although   does a shallow copy, it is easy to construct a deep copy by applying it recursively. The typical manner of use is to write a template rule that effectively calls itself:                 This is sometimes referred to as the identity template. This template rule matches any node except a name- space or document node. This is because «@*» matches any attribute node, and «node  », which is short for «child::node  », matches any node that is allowed to be the child of something  that is, an element node, text node, comment, or processing instruction . Once this template rule is applied to a node, it copies that node, and if it is an element node, it applies itself to its attributes and child nodes — on the assumption that there is no other template rule with mode="copy" that has a higher priority.An easier way of doing a deep copy is to use  . However, the recursive use of   allows modiﬁcations to be made to the tree while it is being copied, by adding further template rules. For example, if you want to copy the whole document except for the subtree rooted at a   element, you can achieve this with a stylesheet that contains the identity template as above, together with the rule:     which does nothing when a   element is found. Because it does nothing, nothing is written to the result tree, so the   element is effectively deleted. There are many variations on this theme — whenever you want to copy most of the input document to the result, but making a few changes as you go, you can do it by writing a stylesheet that uses the identity template for elements that are to be copied unchanged, supplemented by more speciﬁc templates that match the nodes you want to handle specially.  A variant of the identity template is often used which copies attributes unconditionally rather than apply- ing templates to them. Here it is:           290   xsl:copy  6  X S L T  l  E e m e n t s           Examples The following template rule is useful if the source document contains HTML-like tables that are to be copied directly to the output, without change to the structure.                   The effect is that all of these elements are copied to the output destination, along with their attributes, but their child elements are processed using whatever template rule is appropriate, which might be the same one in the case of a child element that is part of the table model, or it might be a different template for some other element.  The following template rule matches any elements in the source document that are in the SVG name- space, and copies them unchanged to the output, along with their attributes. The SVG namespace node itself will also be included automatically in the output tree.  SVG stands for Scalable Vector Graphics, which is an XML-based standard for representing diagrams.   <xsl:template match="svg:*"  xmlns:svg="http:  www.w3.org 2000 svg">                This example uses «copy-namespaces="no"» to avoid copying the namespace nodes attached to the SVG elements. It is safe to do this because SVG elements and attributes do not include data that depends on in-scope namespaces. The namespaces used in the element and attribute names will automatically acquire namespace nodes as a result of the namespace ﬁxup process described on page 310. Getting rid of extraneous namespace nodes in this way can be useful. For example, if the SVG document is embedded in an XHTML document, and the purpose of the copy operation is to make it into a freestanding SVG document, then the default value «copy-namespaces="yes"» would mean that the freestanding SVG document would contain an unwanted reference to the XHTML namespace.  The option «inherit-namespaces="no"» is useful only when generating XML 1.1 output. XML 1.1 allows namespace undeclarations of the form «xmlns:p=""», which can be useful to indicate that a namespace used in the envelope of a message  for example, a SOAP envelope  is not required in the body of the message. The serializer will generate such a namespace undeclaration on a child element if two conditions are satisiﬁed: ﬁrstly, there must be a namespace node on the parent element that is not present on the child, and secondly the serialization parameters «version="1.1"» and «undeclare-prefixes="yes"» must both be set. To meet the ﬁrst requirement, you need to specify «inherit-namespaces="no"» when generating the parent element.  291   XSLT Elements  See Also   immediately following.  xsl:copy-of  The main purpose of the   instruction is to copy a sequence of nodes to the result sequence. This is a deep copy — when a node is copied, its descendants are also copied.  Changes in 2.0 A new copy-namespaces attribute is introduced: This gives you control over whether or not the unused namespaces of an element should be copied.  Two new attributes validation and type are available to control whether and how the copied nodes are validated against a schema.  Format  <xsl:copy-of  select = expression copy-namespaces? = "yes"  "no" validation? = "strict"  "lax"  "preserve"  "strip" type? = qname  >  Position   is an instruction. It is always used within a sequence constructor.  Attributes Name select mandatory  validation optional  type optional  Value XPath Expression  Meaning The sequence of nodes or atomic values to be copied to the output destination  copy-namespaces optional  «yes» or «no». Default is «yes»  Indicates whether the namespace nodes of an element should be copied  «strict», «lax», «preserve», or «skip»  Lexical QName  Indicates whether and how the copied nodes should be subjected to schema validation, or whether existing type annotations should be retained or removed  Identiﬁes a type declaration  either a built-in type, or a user-deﬁned type imported from a schema  against which copied nodes are to be validated  The type and validation attributes are mutually exclusive: if one is present, the other must be absent. These attributes are available only with a schema-aware processor.  Content None; the element is always empty.  292   xsl:copy-of  Effect The result of evaluating the select expression can be any sequence, containing nodes, atomic values, or a mixture of the two. Each of the items is copied to the result sequence, as follows:  6  X S L T  l  E e m e n t s                    If the item is an atomic value, it is copied directly to the result sequence. So the instruction   has exactly the same effect as the instruction  . If the item is a text node, comment, processing instruction, or namespace node, then it is copied in exactly the same way as with the   instruction. The new node has the same name and string value as the original, but it has a new identity. For example, generate-id   applied to the new node will give a different result from generate-id   applied to the original. If the item is an attribute node, then it is copied to create a new attribute node. The new attribute node has the same name and string value as the original, but has a new identity. The type anno- tation on the new attribute node depends on the values of the type and validation attributes. These work in the same way as for   as described on page 254, except for the value «validation="preserve"», which causes the type annotation to be copied from the existing node. If the item is an element node, then it is copied to create a new element node. This is a deep copy: All the attributes and children of the element node are also copied. The namespace nodes of this element, and of any descendant elements, are copied unless the copy-namespaces attribute is present with the value «no». The base URIs of copied element nodes are unchanged  which means that any relative URIs in the content of these nodes retain their original meaning . The type annotation of the new element node depends on the values of the type and validation attributes. If the type attribute is speciﬁed, or if validation is set to «strip», «strict», or «lax», then the effect is exactly as if new content were being constructed from scratch: Existing type annotations are discarded, and the copied content is revalidated to con- struct type annotations. In the case of «validation="preserve"», the existing type annotations are copied over to the new nodes. If the item is a document node, then it is copied to create a new document node. This is a deep copy: All the children of the document node are also copied. All copied nodes below this doc- ument node retain the name, string value, base URIs, and type annotations of their respective originals. If «validation="preserve"» is speciﬁed, then existing type annotations are copied unchanged; in other cases, document-level validation may occur to create new type annotations. This follows the rules for the   instruction, which means that it includes checks on ID IDREF constraints as well as  ,  , and  .  Usage and Examples There are two principal uses for  : it can be used when copying data to and from a tem- porary tree, and it can be used for copying a subtree unchanged from the input document to the output.  Copying Nodes to and from Temporary Trees One use of   in conjunction with temporary trees arises when you want to write the same collection of nodes to the output in more than one place. This might arise, for example, with page headers and footers. The construct allows you to assemble the required output fragment as the value of a variable and then copy it to the ﬁnal output destination as often as required.  293   XSLT Elements  Example: Using for Repeated Output  This example constructs a table heading in a variable and then copies it repeatedly each time a new table is created.  Source  The source ﬁle soccer.xml holds details of a number of soccer matches played during the World Cup ﬁnals in 1998.          1998-06-10   Brazil   Scotland                             1998-06-10   Morocco   Norway    1998-06-16   Scotland   Norway    1998-06-16   Brazil   Morocco    1998-06-23   Brazil   Norway    1998-06-23   Scotland   Morocco        Stylesheet  The stylesheet is in the ﬁle soccer.xsl. It constructs an HTML table heading as a global tree-valued variable, and then uses   every time it wants to output this heading. In this particular case the head- ing is ﬁxed, but it could contain data from the source document, as long as the heading is the same each time it is output. If it contained calculated values, there would be a possible performance beneﬁt by coding it this way rather than regenerating the heading each time.  294   xsl:copy-of  6  X S L T  l  E e m e n t s  <xsl:stylesheet version="2.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform">          Date     Home Team     Away Team     Result                 Matches in Group                  <xsl:value-of  select="format-date date, ’[D] [MNn,1-3] [Y]’ " >            <xsl:value-of  select="team[1] @score, ’-’, team[2] @score" separator="" >                    Figure 6-2  295   XSLT Elements  Output   Apologies to soccer fans who know that all these matches were played in France, on neither team’s home territory. It’s only an example!  See Figure 6-2.  Deep Copy The other use for   is that it provides a simple way of copying an entire subtree of the input document directly to the output. As   does a deep copy, this is simpler than using  , although it can only be used when the whole subtree is to be copied without change. For example, an XML document deﬁning a product description might have an element called   whose content is pure XHTML. You could copy this to the output HTML document with a template rule such as:                 Unlike the examples using  , there is no recursive application of template rules here: each child node of the   element is copied to the output destination in a single operation, along with all its children.  The most common example of this technique is using   to copy all the attributes of the current element. You can also use this selectively. To copy speciﬁc attributes use the following code:     Copying all the attributes with speciﬁc exceptions is also straightforward using the new «except» oper- ator in XPath 2.0:     Using   only works if you want an exact copy of the subtree. If you want to change anything, for example removing some nodes or changing the namespace URI of the element names, you will need to walk the tree using a modiﬁed identity template as described under   on page 287.  Copying Namespace Nodes The copy-namespaces attribute provides a choice as to whether the namespace nodes in a tree are copied or not. By default, all the namespaces are copied.  If namespaces are used only in the names of elements and attributes, then there is no need to copy name- space nodes. In the new tree, all the necessary namespace nodes will be created by virtue of the names- pace ﬁxup process, which is described under   on page 306 but applies equally to elements constructed using   or  . Copying unwanted namespace nodes generally does no harm, but they are unnecessary and can clutter the result document, and in some cases they can cause DTD-based validation to fail.  296   xsl:copy-of  The real problem arises when namespace preﬁxes are used in the values of attributes or text nodes. This happens, for example, if the document is an XSLT stylesheet containing XPath expressions, if it is an XML Schema, if it uses «xsi:type» attributes that identify schema-deﬁned types  the value of this attribute is a QName, and therefore contains a namespace preﬁx , or if it uses any other XML vocabulary that contains references to the names of elements or attributes within the document con- tent. Since the XSLT processor cannot know that these references exist, and since the references depend on the existence of namespace nodes to resolve namespace preﬁxes to a URI, it is unsafe to shed the namespace nodes.  There are some cases where losing namespace nodes is very desirable. For example, if an XML document is wrapped in a SOAP envelope and then subsequently removed from the envelope, the round trip can easily cause the SOAP namespaces deﬁned for use in the envelope to stick to the content when it is extracted using  . Under these circumstances, using «copy-namespaces="no"» can be useful to remove unwanted namespaces from the result. But it is only safe to use this option if you know that there are no namespace preﬁxes in the content of text nodes and attribute nodes.  6  X S L T  l  E e m e n t s  Copying Type Annotations The validation attribute of the   instruction gives you four options on how to handle type annotations:              The «strip» option removes all type annotations from the element and attribute nodes being copied, leaving them only with the generic type annotations xs:untyped and xs:untypedAtomic, respectively. The main advantage of doing this is that you know exactly where you stand. This is the default, unless overridden using the default-validation attribute of the   element, and it means that the behavior will be the same whether or not the processor is schema-aware. Sometimes the «strip» option is needed because the existing type annotations do not make sense in a new context. For example, you might be copying a price-range attribute from an ele- ment in which the name is constrained to be a sequence of two numbers, to an element in which any string is allowed. Retaining the type annotation would cause spurious effects, or errors, if the attribute in its new context is then used for comparisons or sorting. The «preserve» option leaves all the type annotations intact. One might expect that this would be the default, but the value «strip» was chosen for consistency with other instructions. Gen- erally speaking, if the source nodes have been validated and annotated, this will often be the option that makes most sense on  .  This option works because the validity of an element or attribute depends only on its content  that is, on its attributes, its descendant elements, and their attributes . Cross-validation con- straints such as ID IDREF constraints are not taken into account by the XPath type system. This means that if the source data has a particular type annotation, you can take it on trust that the data is valid against that type, and if you copy the whole subtree, then the new nodes will still be valid against these types. The «strict» and «lax» options discard all existing type annotations, and then invoke the schema processor to validate the copied nodes. The same happens when you use the type attribute instead of the validation attribute. The way that validation works is exactly as described for the   instruction in the case of element nodes  see page 312 , or the   instruction in the case of attribute nodes  see page 258 , or the   instruction in the case of document nodes  see page 304 . For other nodes and atomic values the validation and type attributes are ignored.  297   XSLT Elements  There may be cases where the existing nodes had a speciﬁc type annotation, but where revalidating the copied subtree either fails, or produces a different type annotation from the original. This is because the validation context may be different. If the subtree was originally validated as part of some larger tree, then it is possible that local element and attribute declarations were used on that occasion, whereas top-level element and attribute declarations are used this time. The top-level declarations may be either more or less permissive than the local declarations.  See Also   on page 287   on page 500  xsl:decimal-format  The   element is used to deﬁne the characters and symbols used when converting numbers into strings using the format-number   function.  Note that   applies only to the format-number   function. It has no effect on the way   formats numbers for display, nor on the default number-to-string conversion used by the string   function, nor on the format used when   is used to output a number as a string.  Changes in 2.0 The speciﬁcation of the format-number   function, which uses the   declaration, is substantially rewritten in XSLT 2.0, though users should notice few changes except in a few corner cases. The   declaration itself is unchanged.  Import precedence now applies to decimal formats in a similar way as to other declarations.  Format  <xsl:decimal-format  name? = qname decimal-separator? = char grouping-separator? = char infinity? = string minus-sign? = char NaN? = string percent? = char per-mille? = char zero-digit? = char digit? = char pattern-separator? = char  >  Position   is a top-level declaration. It may appear any number of times in a stylesheet, but only as an immediate child of the   element.  298   xsl:decimal-format  Value Lexical QName The name of this decimal format. If omitted, the attributes  Meaning  deﬁne the default decimal format.  6  X S L T  l  E e m e n t s  Character to be used to separate the integer and the fraction part of a number. Default is «.»  x2E .  Character used to separate groups of digits. Default is «,»  x2C .  String used to represent the numeric value inﬁnity. Default value is «Infinity».  Character used as the default minus sign. Default is «-»  x2D .  String used to represent the numeric value NaN  not a number . Default value is «NaN».  Character used to represent a percentage sign. Default value is «%»  x25 .  Character used to represent a per-mille  per-thousand  sign. Default value is «‰»  x2030 .  Character used in a format pattern to indicate a place where a leading or trailing zero digit is required, even if it is not signiﬁcant. Default value is «0»  x30 . This character must be one that is classiﬁed in the Unicode database as a digit character, with the numeric value zero.  Character used in a format pattern to indicate a place where a digit will appear, provided it is a signiﬁcant digit. Default value is «»  x23 .  Character used in a format pattern to separate the subpattern for positive numbers from the subpattern for negative numbers. Default value is «;»  x3B .  Attributes Name name optional  decimal-separator optional  grouping-separator optional  inﬁnity optional  minus-sign optional  NaN optional  percent optional  per-mille optional  zero-digit optional  Character  Character  String  Character  String  Character  Character  Character  digit optional  Character  pattern-separator optional  Character  Content None; the element is always empty.  Effect If a name attribute is supplied, the   element deﬁnes a named decimal format; otherwise, it deﬁnes attributes of the default decimal format. A named decimal format is used by the format-number   function when it is called with three arguments  the third argument is the name of a decimal format ; the default decimal format is used when the format-number   function is called without a third argument.  It is possible to have more than one   element for the default decimal format, or more than one for a decimal format with a given name. The effective value of a given attribute  such as zero-digit  is taken from the declaration with the highest import precedence that speciﬁes a value for  299   XSLT Elements  the required attribute. It is an error if this selects more than one declaration, unless the values speciﬁed are the same.  The   element does not directly deﬁne the display format of a number. Rather it deﬁnes the characters and strings used to represent different logical symbols. Some of these logical symbols occur in the picture string used as an argument to the format-number   function, some of them occur in the ﬁnal output number itself, and some are used in both. The actual display format of a number depends both on the picture string and on the choice of decimal format symbols.  For example, if there is an   element as follows:  <xsl:decimal-format name="european"  decimal-separator="," grouping-separator="."  >  format-number 1234.5, ’.0,00’, ’european’   then the function call:  will produce the output:  1.234,50  The use of the «.» and «,» characters in both the picture string and the output display is determined by the named   element, but the number of digits displayed, and the use of leading and trailing zeros, is determined solely by the picture string.  The structure of a picture string is deﬁned in the description of the format-number   function in Chapter 13, page 788. The syntax of the picture string uses a number of special symbols: the actual characters used for these symbols are deﬁned in the relevant   element. These symbols are:  The   element also deﬁnes characters and strings that are used, when required, in the actual output value. Some of these are the same as characters used in the picture string, others are different. These characters and strings are:  decimal-separator  grouping-separator  percent  per-mille  zero-digit  digit  pattern-separator  decimal-separator  grouping-separator  infinity  minus-sign  NaN  percent  per-mille  zero-digit  300   xsl:decimal-format  For example, if the   element deﬁnes the inﬁnity string as «***», then the output of «format-number 1e0 div 0, $format » will be «***», regardless of the picture string.  Usage The   element is used in conjunction with the format-number   function to out- put numeric information. It is designed primarily to provide localization of the format for display to human readers, but it can also be useful when you need to produce an output data ﬁle using, for example, a ﬁxed number of leading zeroes. It is typically used for numbers in the source data or computed from the source data, whereas the   element, which has its own formatting capabilities, is generally used to generate sequence numbers.  Each   element deﬁnes a style of localized numbering, catering for the variations that occur in different countries and languages, and for other local preferences such as the convention in the accountancy profession whereby parentheses are used to indicate negative numbers.  6  X S L T  l  E e m e n t s  Examples The tables in the following examples illustrate some of the effects achievable using the <xsl:decimal- format> element in conjunction with a different picture string.  Example 1: Comma as a Decimal Separator This decimal format is used in many Western European countries; it uses a comma as a decimal point and a period  full stop  as a thousands separator, the reverse of the custom in Britain and North America.  The left-hand column shows the number as it would be written in XSLT. The middle column shows the picture string supplied as the second argument to the format-number   function. The right-hand column shows the string value returned by the format-number   function.  The patterns used in this example use the following symbols:                    «.», which I have deﬁned as my thousands separator «,», which I have deﬁned as my decimal point «», which is a position where a digit can occur, but where the digit is omitted if it is an insigniﬁ- cant zero «0», which is a position where a digit will always occur, even if it is an insigniﬁcant zero «%», which indicates that the number should be expressed as a percentage «;», which separates the subpicture used for positive numbers from the subpicture used for negative numbers     Number  1234.5  123.456  1000000  Picture String  .0,00  .0,00  .0,00  Result  1.234,50  123,46  1.000.000,00  continued 301   Result  59,00  Infinity  1234,0  1234,5  0,0004  25%  74%  100%  4200%   3,12   3,12CR  Result  XSLT Elements  Number −59 1e0 div 0  1234  1234.5  .00035  0.25  0.736  1  42 −3.12 −3.12  Number  12345  Picture String  .0,00  .0,00  0,0  0,0  0,0  00%  00%  00%  00%  ,00; ,00   ,00;,00CR  Format pattern    x0660   Example 2: Non-Western Digits This example shows how digits other than the Western digits 0–9 can be used. I will use the Indic Arabic digits  that is, the digits used in many Arabic countries, as distinct from the so-called Arabic digits used in the West :     The digits will be output in the output XML or HTML ﬁle in the usual order  most signiﬁcant digit ﬁrst . Displaying the number correctly when it appears as part of text that runs from right to left is the job of the browser or other display software, and you shouldn’t worry about it at the XSLT level.  Example 3: NaN and Inﬁnity This example shows how the exceptional numeric values NaN and Inﬁnity can be shown, for example in a statistical table.     Number  number ‘a’   1e0 div 0  -1e0 div 0  Format pattern  any  any  any  Result  Not Applicable  Out of Range  -Out of Range  See Also format-number   function in Chapter 13, page 788   on page 403  302   6  X S L T  l  E e m e n t s  xsl:document  xsl:document  The   instruction creates a document node and adds it to the result sequence. The most likely reason for using it is to perform document-level validation on a temporary tree.  Changes in 2.0 This instruction is new in XSLT 2.0. It should not be confused with the   instruction described in the abandoned XSLT 1.1 working draft, which was the precursor to the <xsl:result- document> instruction in XSLT 2.0. The document created by   is a temporary document that becomes available for further processing within the stylesheet; the document created by   is a ﬁnal output from the transformation.  Format  <xsl:document  validation? = "strict"  "lax"  "preserve"  "strip" type? = qname>       Position   is used as an instruction within a sequence constructor.  Attributes Name validation optional  type optional  Value «strict», «lax», «preserve», or «skip»  Lexical QName  Meaning Indicates whether and how the document should be subjected to schema validation  Identiﬁes a type declaration  either a built-in type, or a user-deﬁned type imported from a schema  against which the outermost element of the new document is to be validated  The type and validation attributes are mutually exclusive: if one is present, the other must be absent. These attributes are available only with a schema-aware XSLT processor.  Content A sequence constructor.  Effect The following sections describe ﬁrstly how the content of the document node is constructed and secondly how document-level validation works.  The Content of the Document The   instruction creates a new document node. The content of the document is con- structed by evaluating the sequence constructor within the   element.  The child nodes of the new document node are constructed in a process that is very similar to that used for constructing the content of an element node, described under   on page 306. There  303   XSLT Elements  are differences, however, because unlike an element node, a document node cannot have attribute or namespace nodes.  Although the XML speciﬁcation requires a well-formed document to contain exactly one element node, optionally preceded or followed by comments and processing instructions, this restriction is not carried forward into the XDM data model. In XDM, a document node can contain any sequence of elements, text nodes, comments, and processing instructions  including an empty sequence  as its children. In fact, a document node can have any content that is allowed for an element node, except for the namespaces and attributes.  The process of forming the content of the document node is described below.  The ﬁrst stage is to evaluate the sequence constructor contained in the   instruction  or in any other instruction that is being used to create a new document node, for example,  ,  ,  , or   . The sequence constructor is a sequence of instructions, and as its name implies, the result of evaluating these instructions is a sequence of items. Usually these values will all be newly constructed nodes but the sequence might also contain atomic values and or references to existing nodes.  The way that the instructions in the sequence constructor are evaluated is described in the rules for each instruction; the items produced by each instruction are concatenated together  in the order in which the instructions appear in the stylesheet  to produce the ﬁnal result sequence.  The second stage of the process is to use the result sequence delivered by evaluating the sequence con- structor to create the content of the new document node. This process works as follows:  1.  2.  3.  4.  If there are any atomic values in the sequence, they are converted to strings using the XPath casting rules. Any sequence of adjacent strings is converted to a single text node, using a single space as a separator between adjacent strings. If there is a document node in the sequence, then it is replaced in the sequence by its children  this may produce an arbitrary sequence of elements, text nodes, comments, and processing instructions . Adjacent text nodes within the sequence are combined into a single text node, without any space separator. Zero-length text nodes are removed completely.  It is an error if the resulting sequence contains an attribute or namespace node.  Finally, the nodes in the sequence are attached to the new document node as its children. Ofﬁcially, this involves making a deep copy of each node: This is because nodes in the data model are immutable, so you cannot change the parent of an existing node. In practice, making a copy at this stage is very rarely necessary, because in most cases the node being attached has only just been created and will never be used independently of its new parent. The only case where it is necessary is where the result sequence contains references to existing nodes, which can be produced using the   instruction:           Even in this case, creating new nodes can be avoided if the result tree is to be immediately serialized.  304   xsl:document  6  X S L T  l  E e m e n t s  Validating and Annotating the Document The validation and type attributes control whether and how the new document is validated. They are available only if you are using a schema-aware processor. As usual, validation has two effects: it triggers a failure if the result document is invalid according to the schema, and it creates type annotations on the nodes in the tree.  The validation attribute has the same four values as on other elements: «strip», «preserve», «strict», and «lax». If the validation attribute is not speciﬁed, then the default is provided by the default- validation attribute on the   element, which in turn defaults to «strip».              «strip» removes all type annotations, replacing them with xs:untyped for elements and xs:untypedAtomic for attributes. «preserve» leaves the type annotations as they are, determined by the validation and type attributes on the instructions that created individual elements and attributes. «strict» and «lax» ﬁrstly check that the tree represents a well-formed XML document, that is, that the children of the document node comprise exactly one element node, no text nodes, and any number of comments and processing instructions. If not, a failure is reported. Then the top-level element node  the document element  is validated against the schema deﬁnitions, with the difference being that «lax» validates an element only if a schema deﬁnition for that element can be found, while «strict» fails if no declaration of this element can be found. Validation of a document node works in the same way as validation of individual elements but with one important exception: ID IDREF constraints deﬁned in the schema are checked when validation is done at the document level but not when it is done at element level. This involves checking that xs:ID values are unique and that xs:IDREF and xs:IDREFS values reference an ID value somewhere in the document.  The «type» attribute gives the required type of the document element  not the document node . For example, if «type="mf:invoiceType"» is speciﬁed, then the single element child of the document node is validated against the schema type «mf:invoiceType».  Usage and Examples The most likely reason for using   is to invoke validation of a temporary tree.  It is possible to perform element-level validation of the document element in a tree without using  , for example by writing:                 However, this does not perform document-level validation: it doesn’t check the ID and IDREF con- straints deﬁned in the schema, for example. To perform these extra checks, it is necessary to write the   instruction explicitly:              305   There are certain other situations where   might be needed. For example, this is the only way of producing a sequence containing several new document nodes. It is also necessary if you want the value of a variable, or the default value of a parameter, to be a document node, and you also want to use the «as» attribute of   or   to deﬁne the type of the variable, for example «as="document element *, mf:invoiceType  "».  XSLT Elements           See Also   on page 445   on page 386  xsl:element  The   instruction is used to create an element node and write it to the result sequence. It provides an alternative to using a literal result element and is useful especially when the element name or namespace is to be calculated at runtime.  Changes in 2.0 Two new attributes validation and type are available, to control whether and how the copied nodes are validated against a schema.  Format  <xsl:element  name = { qname } namespace? = { uri-reference} use-attribute-sets? = qnames inherit-namespaces? = "yes"  "no" validation? = "strict"  "lax"  "preserve"  "strip" type? = qname>       Position   is used as an instruction within a sequence constructor.  Attributes  Name name mandatory  namespace optional  306  Value Attribute value template returning a lexical QName  Attribute value template returning a URI  Meaning The name of the element to be generated.  The namespace URI of the generated element.  continued   xsl:element  Name use-attribute-sets optional  Value Whitespace-separated list of lexical QNames  Meaning List of named attribute sets containing attributes to be added to this output element.  inherit-namespaces optional  «yes» or «no».  Default is «yes» .  Indicates whether the namespaces of the constructed element will be inherited by its children.  validation optional  «strict», «lax», «preserve», or «skip»  type optional  Lexical QName  Indicates whether and how the element should be subjected to schema validation, or whether existing type annotations on attributes and child elements should be retained or removed.  Identiﬁes a type declaration  either a built-in type, or a user-deﬁned type imported from a schema  against which the new element is to be validated.  6  X S L T  l  E e m e n t s  The type and validation attributes are mutually exclusive: if one is present, the other must be absent. These attributes are available only with a schema-aware XSLT processor.  Content A sequence constructor.  Effect The effect of this instruction is to create a new element node, and to return this node as the result of the instruction.  The name of the generated element node is determined using the name and namespace attributes. The way in which these attributes are used is described below in the section The Name of the Element.  The sequence constructor contained in the   instruction, together with the use-attribute-sets attribute, is used to form the content of the new element: that is, its namespaces, attributes, and child nodes. The way this works is described in the section The Content of the Element.  When a schema-aware XSLT processor is used, the new element  and its contained elements and attributes  may be validated to ensure that they conform to a type deﬁned in a schema. This process results in the new element node having a type annotation. The type annotation affects the behavior of subsequent operations on this element node even though it is not visible when the result tree is serialized as raw XML. The validation and annotation of the new element node are controlled using the type and validation attributes. This is described in the section Validating and Annotating the Element.  The XSLT speciﬁcation is written in terms instructions returning a value, which in this case is an element node. Sometimes it is convenient to think in terms of the start tag of the   element pro- ducing a start tag in the output XML ﬁle and the end tag of the   element producing the corresponding end tag, with the intervening sequence constructor producing the contents of the output element. However, this is a dangerous simpliﬁcation, because writing the start tag and end tag are not separate operations that can be individually controlled, they are two things that happen together as a consequence of the   instruction being evaluated. This is explained in more detail in the section Literal Result Elements in Chapter 3, page 112.  307   XSLT Elements  The Name of the Element The name of an element node has three parts: the preﬁx, the local name and the namespace URI. These are controlled using the name and the namespace attributes.  Both the name and the namespace attributes may be given as attribute value templates; that is, they may contain expressions nested within curly braces. One of the main reasons for using the   instruction in preference to a literal result element  described in the section Literal Result Elements in Chapter 3, page 112  is that   allows the name of the element to be decided at runtime, and this is achieved by using attribute value templates in these two attributes.  The result of expanding the name attribute value template must be a lexical QName; that is, a valid XML name with an optional namespace preﬁx, for example, «table» or «fo:block». If there is a preﬁx, it must correspond to a namespace declaration that is in scope at this point in the stylesheet, unless there is also a namespace attribute, in which case it is taken as referring to that namespace.  The local part of the name of the created element node will always be the same as the local part of the QName supplied as the value of the name attribute.  If the   instruction has a namespace attribute, it is evaluated  expanding the attribute value template if necessary  to determine the namespace URI part of the name of the created element node:  If the value is a zero-length string, the element will have a null namespace URI. Otherwise, the value should be a URI identifying a namespace. This namespace does not need to be in scope at this point in the stylesheet, in fact it usually won’t be. The processor may report an error if the value is not a legal URI.  If there is no namespace attribute:  If the supplied QName includes a preﬁx, the preﬁx must be a namespace preﬁx that is in scope at this point in the stylesheet. In other words, there must be an «xmlns:prefix="uri"» declara- tion either on the   instruction itself or on some containing element. The name- space URI in the output will be that of the namespace associated with this preﬁx in the stylesheet. Otherwise, the default namespace is used. This is the namespace declared, in some contain- ing element in the stylesheet, with an «xmlns="uri"» declaration. If there is no default name- space declaration in scope, then the element will have a null namespace URI. Note that this is one of the few places in XSLT where the default namespace is used to expand a QName having no pre- ﬁx; in nearly all other cases, a null namespace URI is used. The reason is to ensure that the behav- ior is consistent with that of an element name used in the start tag of a literal result element.              The preﬁx part of the name of the new element node will normally be the same as the preﬁx part of the lexical QName supplied as the value of the name attribute  if that name has no preﬁx, then the new element node will have no preﬁx . In rare cases, however, the system may need to choose a different preﬁx to prevent conﬂicts: for example, if an attribute of the element uses the same preﬁx to refer to a different namespace.  The Content of the Element The attributes, namespaces, and child nodes of the new element node are constructed in what is concep- tually a four-stage process, though in practice most implementations are likely to collapse the four stages into one.  308   xsl:element  The ﬁrst stage is to evaluate the sequence constructor contained in the   instruction. The sequence constructor is a sequence of instructions, and as its name implies, the result of evaluating these instructions is a sequence of items. Usually these values will all be newly constructed nodes but the sequence might also contain atomic values and or references to existing nodes.  The way that the instructions in the sequence constructor are evaluated is described in the rules for each instruction; the items produced by each instruction are concatenated together  in the order in which the instructions appear in the stylesheet  to produce the ﬁnal result sequence.  The instructions in a sequence constructor can be evaluated in any order, or in parallel, but their results must be assembled in the correct order on completion.  If the use-attribute-sets attribute is present it must be a whitespace-separated list of lexical QNames that identify named   declarations in the stylesheet. The   instructions within these named attribute sets are evaluated, and the resulting sequence of attribute nodes is added to the start of the result sequence. For more details, see   on page 266.  The second stage of the process is to use the result sequence delivered by evaluating the sequence con- structor  and the use-attribute-sets attribute if present  to create the content of the new element node. This process works as follows:  6  X S L T  l  E e m e n t s  1.  2.  3.  4.  5.  6.  If there are any atomic values in the sequence, they are converted to strings using the XPath cast- ing rules. Any sequence of adjacent strings is converted to a single text node, using a single space as a sep- arator between adjacent strings. This allows list-valued content to be constructed, for example where the schema for the result document requires the content of an element to be a sequence of integers. If there is a document node in the sequence, then it is replaced in the sequence by its children  document nodes in the data model are not constrained to represent well-formed XML docu- ments, so this may produce an arbitrary sequence of elements, text nodes, comments, and processing instructions . Adjacent text nodes within the sequence are combined into a single text node, without any space separator, and zero-length text nodes are removed. Duplicate attribute nodes are removed. If several attributes in the sequence have the same name, all but the last are discarded. Duplicate namespace nodes are removed. If several namespace nodes in the sequence have the same name and string-value  that is, they bind the same namespace preﬁx to the same name- space URI , then all but one of them are discarded. It makes no difference which one is kept.  It is an error if the resulting sequence contains an attribute or namespace that is preceded by a node that is not an attribute or namespace node.  The reason for this rule is to allow the implementation the ﬂexibility to generate the output as an XML ﬁle, without having to build the result tree in memory ﬁrst. If attributes could be added at any time, the whole result tree would need to be kept in memory.  It’s also an error if there are conﬂicting namespace nodes at this point, that is, two namespace nodes that bind the same preﬁx to different namespace URIs, or a namespace node that declares a default namespace when the element itself is not in any namespace.  309   XSLT Elements  In the third stage of the process, the attribute nodes in the sequence are attached to the new element as its attributes, the namespace nodes are attached as its namespaces, and the other nodes are attached as its children. Ofﬁcially, this involves making a deep copy of each node: this is because nodes in the data model are immutable, so you cannot change the parent of an existing node. In practice, making a copy at this stage is very rarely necessary, because in most cases the node being attached has only just been created and will never be used independently of its new parent. The only case where it is necessary is where the result sequence contains references to existing nodes, which can be produced using the   instruction:           In this situation, the result is exactly the same as if   had been used instead of  .  When an element node appears in the result sequence and is copied to form a child of the newly constructed element, it also acquires copies of all the parent element’s namespaces. Futhermore, these percolate down to all descendant elements, unless there’s already a namespace present with a conﬂicting deﬁnition. This process is called namespace inheritance, and is discussed further on page 311. The process can be suppressed by setting «inherit-namespaces="no"» on the parent element.  The fourth and ﬁnal stage of the process is called namespace ﬁxup. Conceptually, this is done after all the nodes produced by the sequence constructor have been added to the new element. In practice all the information needed to do namespace ﬁxup is available once all the attributes and namespaces have been added, and a processor that serializes the result tree ‘‘on the ﬂy’’ is likely to perform this operation at that stage, so that the start tag of the serialized element can be output as early as possible. Namespace ﬁxup is described in the next section.  Namespace Fixup Namespace ﬁxup is applied to any element node as soon as its content has been constructed, whether the node is created using the   instruction or using another mechanism such as a literal result element,  , or  . The process ensures that the new element node will automat- ically contain all the namespace nodes it needs to bind unique namespace preﬁxes to the namespaces used in the element name itself and on the names of all its attributes.  The namespace ﬁxup process can do two things: it can add namespace nodes to the tree and it can change the preﬁxes allocated to element and attribute nodes. The speciﬁcation isn’t completely prescrip- tive, but it makes it fairly clear that the ﬁxup process is expected to make the minimal changes necessary to ensure that all the consistency rules deﬁned in XDM are satisﬁed. Typically, this will involve the following steps:  1.  2.  Examine the preﬁxes used on the element node and its attributes, and check that they are consis- tent with each other and with the element’s existing namespace nodes. If there are any conﬂicts, allocate different preﬁxes to some or all of the nodes. Note that existing namespace nodes will never be changed by this process  this is because there might be namespace-sensitive content that relies on these namespaces . For every preﬁx used on the element node or on one of its attributes, ensure that there is a name- space node that binds this preﬁx to the relevant namespace URI. This will only involve adding namespace nodes, never modifying or deleting them.  310   xsl:element  This process is described in conceptual terms and the real implementation might be very different. For example, a processor might not actually store real namespace nodes in respect of the namespaces used on the element and attribute names, but instead might create them only when they are actually referenced.  The processor does not attempt to create namespace nodes in respect of namespace-sensitive content appearing in element or attribute nodes. For example, if you write the attribute «xsi:type= "xs:integer"», namespace ﬁxup will ensure that there is a namespace node for the «xsi» namespace, but not for the «xs» namespace. There are a number of reasons for this: one is that the processor often has no way of knowing that the content is namespace-sensitive, because it’s not declared as such in a schema. Another is that namespace ﬁxup happens before schema validation, because schema validation will fail if the right namespace bindings don’t already exist. So in such cases it’s your responsibility, when creating namespace-sensitive content, to ensure that the namespaces are declared. This can always be achieved using the   instruction, described on page 390.  Namespace ﬁxup also ensures that every element has a namespace node that maps the preﬁx «xml» to the namespace URI http:  www.w3.org XML 1998 namespace. At any rate, this is what the speciﬁcation says. In practice, implementations probably won’t store a real node for this namespace; instead, they will simply behave as if it always existed.  6  X S L T  l  E e m e n t s  Namespace Inheritance It’s worth observing one thing that namespace ﬁxup doesn’t do. When you create an element   as a child of  , namespace ﬁxup does not try to give the   element a copy of every namespace node that is present for the   element. This is controlled instead by the [xsl:]inherit-namespaces attribute of the instruction that creates the   element.  XML Namespaces 1.1 introduces the ability to undeclare namespaces. It was always possible under XML Namespaces 1.0 to write:           which has the effect that the http:  one.com ns namespace is in scope for   but not for  . This is represented in the data model by the fact that the   element has a namespace node that maps the empty preﬁx to the namespace URI http:  one.com ns, while the   element has no such namespace node. With XML Namespaces 1.1 it becomes possible to do the same thing with a nondefault namespace. You can now write:           Again, this is represented in the data model by the fact that the   element has a namespace node that maps the preﬁx one to the namespace URI http:  one.com ns, while the   element has no such namespace node. However, if the above code appears in your stylesheet rather than your source document, then the   element will acquire a copy of the namespace node «xmlns:one="http:  one .com ns"» as part of the process of element construction. This is because, by default, when an element is attached as a child to a new parent, it  and its descendants  acquire copies of all the namespace nodes  311   XSLT Elements  that are present on the new parent, unless they actually bind the same preﬁx to a different namespace. This process is called namespace inheritance. If you want to disable this, you need to write:           You’ll only really notice the difference if you put this structure in a variable and then use an instruction such as  . If namespace nodes are inherited, the result will be:     But if namespace nodes are not inherited, the result will be:  When you serialize the   element as an XML 1.0 document, it’s not possible to represent the absence of the namespace, so the result will be the same either way, namely:                           If you want a faithful representation of the tree, showing that the namespace is not in scope for the   element, you will need to serialize the result as an XML 1.1 document; moreover, you will have to explicitly say that you want to take advantage of this XML 1.1 feature by specifying the serialization parameter «undeclare-prefixes="yes"». If you do this, the output will be:  For more details of serialization options, see   on page 420, and Chapter 15.  Validating and Annotating the Element This section is relevant only if you are using a schema-aware XSLT processor. With a non-schema-aware processor, you cannot use the type and validation attributes, and the type annotation on the new element will always be xs:untyped, which you can effectively ignore because it imposes no constraints.  With a schema-aware processor, you can validate the new element to ensure that it conforms with rele- vant deﬁnitions in a schema. If validation fails, a fatal error is reported. If it succeeds, the new element will have a type annotation that reﬂects the validation that was performed. This type annotation will not affect the way the element node is serialized, but if you want to do further processing on the element, the type annotation may affect the way this works. For example, if you sort a sequence of elements annotated with type xs:integer, you will get different results than if they are annotated as xs:string.  If you use the type attribute, the value of the attribute must be a lexical QName that identiﬁes a known type deﬁnition. Generally, this means that it must either be a built-in type such as xs:string or  312   xsl:element  6  X S L T  l  E e m e n t s  xs:dateTime, or it must be the name of a global simple or complex type deﬁned in a schema that has been imported using an   declaration in the stylesheet.  That is, the local part of the QName must match the name attribute of a top-level   or   element in a schema document whose target namespace matches the namespace URI part of the QName.   The XSLT speciﬁcation allows the implementation to provide other ways of accessing type deﬁnitions, perhaps through an API or a conﬁguration ﬁle, and it also allows the type deﬁnition to originate from a source other than an XML Schema, but since it provides no details of how this might work, we won’t explore the possibility further here.  The processor validates that the constructed element conforms to the named type deﬁnition. If it does, the element is annotated with the name of this type. If it doesn’t, processing fails.  Validating an element is a recursive process, which also involves validating all its attributes and child elements. So these contained elements and attributes may also acquire a different type annotation.  In general, it’s likely that some of the contained elements and attributes will be validated against anony- mous type deﬁnitions in the schema, that is, types deﬁned inline as part of another type deﬁnition  or element or attribute declaration , rather than named global types. In this case, the XSLT processor invents a name for each such type deﬁnition and uses this invented name as the type annotation. The invented name is not visible to the application, though it might appear in diagnostics, but it is used during subse- quent processing whenever there is a need to check that the element or attribute conforms to a particular type.  In practice, of course, the invented ‘‘name’’ might not really be a name at all, but a pointer to some data structure containing the type deﬁnition.   There is potentially a lot of redundant processing if you validate every element that you add to the result tree, because elements at the bottom level of the tree will be validated repeatedly each time an ancestor element is validated. It’s up to the XSLT processor to handle this sensibly; one approach that it might use is to mark the element as needing validation, but to defer the actual validation until it really needs to be done.  Validating the element may also have other effects; in particular, it may cause default values for ele- ments and attributes within the element’s content to be expanded. Default values can be deﬁned in the schema using   or  . So the element after validation may contain element and attribute values that were not put there explicitly by the stylesheet.  Validating an element using the type attribute places no constraints on the name of the element. It does not need to be an element name that is deﬁned in any schema. The validation is concerned with the content of the element  including, of course, the names of its attributes and children  and not with its name.  In contrast, validation using the validation attribute is driven by the element’s name.  There are two options for the validation attribute that cause schema validation to happen and two options that cause it not to happen. Let’s take the last two ﬁrst:     «validation="preserve"» means that the new element will have a type annotation of xs:anyType, and the attributes and elements in its content will have their original type annotation. During the  formal  process of copying nodes from the sequence produced by evaluating the sequence constructor, the nodes are copied with their type annotations intact.  313            XSLT Elements  «validation="strip"» means that the new element will have a type annotation of xs:untyped, and in this case the attributes and elements in its content  at any depth  will have their type annotation changed to xs:untypedAtomic or xs:untyped, respectively.  The type annotations are changed in the course of copying the nodes; the original nodes are, of course, unchanged .  The difference between xs:anyType and xs:untyped is rather subtle, and most applications won’t notice the difference. However, the XSLT processor knows when it sees an xs:untyped element that all its descendants will also be xs:untyped, and this makes certain optimizations possible.  The other two options are «strict» and «lax»:  «validation="strict"» causes the processor to look in the schema for an element declaration that matches the name of the element. That is, it looks for a top-level   whose name attribute matches the local name of the element being validated, in a schema document whose target namespace matches the namespace URI of the element being validated. If it can’t ﬁnd such a deﬁnition, a fatal error is reported. Otherwise, the content of the element is validated against the schema-deﬁned rules implied by this element declaration.  If the element declaration in the schema refers to a named type deﬁnition, then on successful validation, the element is annotated with this type name. If the element declaration contains an inline  and therefore unnamed  type deﬁnition, the XSLT processor invents a name for this implicit type, and uses this invented name as the type annotation, just as in the case described earlier for the type attribute.  If the element declaration requires it, then strict validation of an element proceeds recursively through the content of the element. It is possible, however, that the element declaration is liberal. It may, for example, deﬁne the permitted contents of the element using  , with pro- cessContents set to «lax» or «skip». In this case, validation follows the schema rules. If «skip» is speciﬁed, for example, the relevant subtree is not validated. All nodes in such a subtree will be annotated as if «validation="strip"» were speciﬁed.  If an «xsi:type» attribute appears in the data being validated, then the system takes account of it according to the rules in the XML Schema speciﬁcation. Elements validated against such an attribute will end up with this type as their type annotation. «validation="lax"» behaves in the same way as «validation="strict"», except that no fail- ure occurs if the processor cannot locate a top-level schema declaration for the element. Instead of reporting an error, the element is annotated as xs:anyType, and validation continues recur- sively  again, in lax mode  with its attributes and child elements. Once an element is found that does have a schema deﬁnition, however, it is validated strictly against that deﬁnition, and if val- idation fails, a fatal error is reported.  I said that the processor looks in the schema for an appropriate element declaration, but where does it ﬁnd the schema? It knows the namespace of the element name at this stage, so if a schema for this target namespace has been imported using    see page 368 , then there is no problem. Otherwise, the speciﬁcation leaves things rather open. It recognizes that some processors are likely to have some kind of catalog or repository that enables the schema for a given namespace to be found without difﬁculty, and it allows this to happen where the implementation supports it. You can also create an xsi:schemaLocation attribute node on the element being validated, to provide guidance on where a schema document might be found. In other cases, the implementation is allowed to report an error.  314   xsl:element  If neither the type nor validation attribute is present, then the system behaves as if the validation attribute were present and had the value given by the default-validation attribute of the containing   element. If no default is speciﬁed at that level, the effect is the same as «valida- tion="strip"».  XSLT does not provide any way to request validation of an element against a local element or type deﬁnition in a schema. The way around this is to request validation only when you create an element for which there is a top-level deﬁnition in the schema. This will then implicitly validate the whole subtree contained by that element, including elements that have local deﬁnitions in the schema. Alternatively, many locally declared elements make use of a globally deﬁned type, and you can then use the type attribute to validate against the type deﬁnition.  Usage and Examples In most cases, elements in a result tree can be generated either using literal result elements in the stylesheet, or by copying a node from the source document using  .  The only situations where   is absolutely needed are therefore where the element name in the result document is not ﬁxed and is not the same as an element in the source document.  Using   rather than a literal result element can also be useful where different namespaces are in use. It allows the namespace URI of the generated element to be speciﬁed explicitly, rather than being referenced via a preﬁx. This means the namespace does not have to be present in the stylesheet itself, thus giving greater control over exactly which elements the namespace declarations are attached to. With a literal result element, all in-scope namespaces from the stylesheet are copied to the result document unless you exclude them using [xsl:]exclude-result-prefixes; this does not happen for  .  Example: Converting Attributes to Child Elements  This example illustrates how   can be used to create element nodes whose names and content are taken from the names and values of attributes in the source document.  Source  The source document book.xml contains a single   element with several attributes:  6  X S L T  l  E e m e n t s    <book title="Object-oriented Languages"  author="Michel Beaudouin-Lafon" translator="Jack Howlett" publisher="Chapman &amp; Hall" isbn="0 412 55800 9" date="1994" >  Stylesheet  The stylesheet atts-to-elements.xsl handles the book element by processing each of the attributes in turn  the expression «@*» selects all the attribute nodes . For each one, it outputs an element whose name is the same as the attribute name and whose content is the same as the attribute value.  315   XSLT Elements  The stylesheet is as follows:  <xsl:transform  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" version="2.0"  >                                This selects all the attributes of the   element  using the expression «@*» , and for each one, it generates an element whose name is the same as the name of that attribute, and whose content is the value of that attribute.  Output  The XML output  on my system  is shown below. The stylesheet isn’t guaranteed to pro- duce exactly this output, because the order of attributes is undeﬁned. This means that the   loop might process the attributes in any order, so the order of child ele- ments in the output is also unpredictable. With Saxon, it actually depends on which XML parser you are using.         Michel Beaudouin-Lafon   1994   0 412 55800 9   Chapman &amp; Hall   Object-oriented Languages   Jack Howlett   See Also   on page 254   on page 287  xsl:fallback  316  The   instruction is used to deﬁne processing that should occur if no implementation of its parent instruction is available.   xsl:fallback     Position   is an instruction. It is generally used within a sequence constructor. However, some new XSLT 2.0 instructions   ,    allow an   element as a child even though they do not contain a sequence constructor. This is to allow fallback behavior to be deﬁned for use when these instructions are encountered by an XSLT 1.0 processor.  6  X S L T  l  E e m e n t s  Changes in 2.0 None.  Format        Attributes None.  Content A sequence constructor.  Effect There are two circumstances where   can be useful:              In a stylesheet that uses XSLT features deﬁned in version 2.0, to indicate what should happen if the stylesheet is used with an XSLT 1.0 processor. For example, the XSLT 2.0 speciﬁcation introduces the new instruction  . If you want to use the <xsl:result- document> instruction in a stylesheet, and also want to specify what an XSLT 1.0 processor that doesn’t understand this instruction should do, you can deﬁne the required behavior using  . XSLT 1.0 was carefully designed with extensibility in mind, so every XSLT 1.0 processor should implement this fallback behavior correctly even though the new XSLT 2.0 instructions were not deﬁned at the time the processor was written. In a stylesheet that uses extension elements provided by a vendor, by the user, or by a third party, to indicate what should happen if the stylesheet is used with an XSLT processor that does not support these extensions.  If the   instruction is encountered in a sequence constructor that the processor can eval- uate normally, it is ignored, along with its contents.  An instruction  as distinct from a literal result element  is an element that occurs in a sequence constructor and is either:  in the XSLT namespace, or in a namespace designated as an extension namespace by its inclusion in the [xsl:]extension- element-prefixes attribute of the element itself or a containing element. This attribute must be in the XSLT namespace if its parent element is not in the XSLT namespace, and vice versa.  317   XSLT Elements  If an instruction is recognized by the XSLT processor, it is evaluated. The standard doesn’t deﬁne exactly what ‘‘recognized by the XSLT processor’’ means. Typically, it means that either the instruction is a vendor-speciﬁc extension implemented by that vendor, or it is a user-deﬁned extension that has been installed or conﬁgured according to the instructions given by the vendor. It is also quite permissible for one vendor, say Oracle, to recognize extensions deﬁned by another vendor, say Microsoft.  If an instruction is not recognized by the XSLT processor, the action taken by an XSLT 2.0 processor is as follows:        For an element in the XSLT namespace, if the effective version is «2.0» or less, an error is reported. If the effective version is higher than «2.0», fallback processing is invoked. For an extension element, fallback processing is invoked.  Similarly, an XSLT 1.0 processor invokes fallback processing when it sees an instruction in the XSLT namespace if the effective version is «2.0»  or indeed, any value other than «1.0» .  The effective version is the value of the [xsl:]version attribute on the nearest enclosing element that has such an attribute  the attribute must be in the XSLT namespace if the element is not in the XSLT namespace, and vice versa . The value is a decimal number  for example «2.3», «10.852», or «17» , and it is compared numerically. The idea is that a stylesheet, or a portion of a stylesheet, that uses facilities deﬁned in some future XSLT version, 2.1  say , should be given an effective version of «2.1».  Note that while XSLT 2.0 allows the version attribute to appear on any element in the XSLT namespace, XSLT 1.0 allowed it only on the   element. This means that if you want an XSLT 1.0 processor to invoke fallback behavior on a stylesheet that uses XSLT 2.0 features, you must either specify «version="2.0"» on the   element, or specify «xsl:version="2.0"» on a containing literal result element. In practice, it is a good idea to put the templates and other declarations that depend on XSLT 2.0 in a separate stylesheet module, and label that module with «version="2.0"» on the   element.  Fallback processing means that if the unknown instruction has an   child element, the   instruction is evaluated; otherwise, an error is reported. If there is more than one   instruction, they are all evaluated.    is concerned only with fallback behavior for instructions within sequence constructors. Top-level declarations that the implementation doesn’t recognize are simply ignored, as are unrecognized elements in another context  for example, an unrecognized child of an   or <xsl:call- template> instruction .  Note that both the [xsl:]version attribute and the [xsl:]extension-element-prefixes attribute apply only within the stylesheet module in which they occur: they do not apply to stylesheet modules incorporated using   or  .  Usage The   mechanism allows a stylesheet to be written that behaves sensibly with XSLT processors that handle different versions of XSLT. This is motivated by the experience of Web develop- ers with HTML, and especially by the difﬁculty of writing Web pages that work correctly on different browsers. The design aimed to cater for a world in which some browsers would include an XSLT 2.0 processor and others would provide an XSLT 1.0 processor; in this situation, it would become necessary to write stylesheets that would work with either.  318   xsl:fallback  Similarly, it is very likely that each vendor of an XSLT processor  or each browser vendor  will add some bells and whistles of their own — indeed, this has already happened with XSLT 1.0. For server-side stylesheet processing you might be prepared to use such proprietary extensions and thus lock yourself into the products of one vendor, but more likely, you want to keep your stylesheets portable. The   mechanism allows you to do this by deﬁning within any proprietary extension element what the XSLT processor should do if it doesn’t understand it. This might be, for example:           Do nothing, if the behavior is inessential, such as keeping statistics. Invoke an alternative implementation that achieves the same effect. Output fallback text to the user explaining that a particular facility cannot be offered and sug- gesting how they should upgrade.  An alternative way of deﬁning fallback behavior when facilities are not available is to use the element- available   function, perhaps within an [xsl:]use-when attribute, and thus to avoid compiling or executing the relevant parts of a stylesheet. This function is described in Chapter 13, page 764. The two mechanisms have overlapping functionality, so use whichever you ﬁnd most convenient.  6  X S L T  l  E e m e n t s  Examples The two examples that follow illustrate the principal use cases for  : creating stylesheets that are forward compatible across XSLT versions, and creating stylesheets that use vendor extensions while maintaining portability. The third example is not actually an example of   at all: it shows another method of achieving fallback behavior when   won’t do the job.  Example 1: XSLT Forward Compatibility The following example shows a stylesheet  copy-to-output.xsl  written to exploit a hypothetical new XSLT feature in version 6.1 of the standard that inserts a document identiﬁed by URI straight into the result tree. The stylesheet is written so that if this feature is not available, the same effect is achieved using existing facilities.                             Example 2: Vendor Portability Writing a stylesheet that uses vendor extensions but is still portable is not particularly easy, but the mech- anisms are there to achieve it, especially in the case where several vendors provide similar extensions but in slightly different ways.  For example, several XSLT 1.0 processors  certainly xt, Saxon 6, and Xalan  provide a feature to generate multiple output ﬁles from a single stylesheet. With XSLT 2.0 this popular facility has made it into the XSLT standard, but before that happened, each product had to invent its own syntax. If you want to  319   XSLT Elements  write a stylesheet that uses the XSLT 2.0 facility when it is available, but with fallback implementations for these three products, you should in principle be able to do it like this  multidoc.xsl :    <a href="preface.html" xsl:version="2.0"  xmlns:saxon6="http:  icl.com saxon" xmlns:xt="http:  www.jclark.com xt" xmlns:xalan="http:  xml.apache.org xalan redirect" xsl:extension-element-prefixes="saxon6 xt xalan">                                              Preface     This would work if all three 1.0 processors implemented the full XSLT 1.0 speciﬁcation. Unfortunately, xt doesn’t support forward-compatible processing and doesn’t recognize  , so in practice the only way we could get this to work with xt was to use different overlay stylesheet modules for different processors. You’ll ﬁnd this solution in the subdirectory ch06 fallback xt.  Hopefully, this little nightmare will disappear once XSLT 2.0 is widely implemented. However, by then the vendors, no doubt, will have thought of other good ideas to include as nonstandard extensions.  Example 3: Temporary Trees This example doesn’t actually use  ; it’s an example of where the same effect needs to be achieved by different means.  One of the most important new features introduced in XSLT 2.0 is the ability to process a tree-valued vari- able as a document in its own right, using facilities such as XPath path expressions and  . The following code, which is perfectly legal in XSLT 2.0, will be ﬂagged as an error by a conforming XSLT 1.0 processor. The message will be something like ‘‘cannot convert result tree fragment to node-set’’:              . . .    320   xsl:fallback  The change to make this legal in XSLT 2.0 involves no new instructions, so it isn’t possible to write an   instruction to deﬁne what an XSLT 1.0 processor should do with this code: There’s no suitable instruction to contain it. The only way of deﬁning fallback behavior in this case is to test the XSLT version using the system-property   function. The following stylesheet  lookup.xsl  will work with both XSLT 1.0 and XSLT 2.0. This accesses a lookup table deﬁned as a global variable in the stylesheet. With a 2.0 processor, it accesses the variable containing the lookup table directly. With a 1.0 processor, it does it by using the «document ’’ » construct to read the stylesheet as a secondary input document.  The code prevents an XSLT 2.0 processor executing the 1.0 code by means of the use-when attribute, which a 1.0 processor will ignore in forward-compatibility mode. The same technique can’t be used to prevent a 1.0 processor executing the 2.0 code, so this uses a runtime check instead.  6  X S L T  l  E e m e n t s  <xsl:stylesheet version="2.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform">                  <xsl:variable name="lookup-table-1.0"  select="document ’’  * xsl:variable[@name=’us-states’]" >     <xsl:value-of select="$lookup-table-1.0 state[@abbr=$state] @name"  use-when="false  " >                In theory, an XSLT 1.0 processor could legitimately reject the above stylesheet at compile time, regardless of whether it speciﬁes «version="1.0"» or «version="2.0"», but fortunately the XSLT 1.0 processors that I’ve tried accept it without quibble.  In this example I used the standard document   function to provide fallback processing that works with all XSLT 1.0 processors. In more complex examples, the fallback processing might need to use vendor extensions such as Microsoft’s msxml:node-set   extension function. In this situation different fallback mechanisms would be needed for different processors.  See Also Extensibility in Chapter 3, page 134 Literal Result Elements in Chapter 3, page 112 element-available   function in Chapter 7, page 764 system-property   function in Chapter 7, page 890 use-when attribute described under  , page 478  321   XSLT Elements  xsl:for-each  The   instruction selects a sequence of items using an XPath expression and performs the same processing for each item in the sequence.  Changes in 2.0 There are no changes to the syntax of this instruction in XSLT 2.0. However, the ability to process sequences of atomic values as well as sequences of nodes greatly increases its power.  Format  <xsl:for-each  select = sequence-expression>       Position   is an instruction, which is always used within a sequence constructor.  Attributes Name select mandatory  Value XPath Expression  Meaning The sequence of items to be processed  Content Zero or more   elements, followed by a sequence constructor.  Effect The effect of the   instruction is to evaluate the sequence constructor that it contains once for each item in the selected sequence of items. The following sections describe how this is done.  The select Attribute The select attribute is mandatory. The expression deﬁnes the items that will be processed. This may be any XPath expression, because every XPath expression returns a sequence. It is quite legitimate, and occasionally useful, to select a single item or an empty sequence.  The expression will often be a path expression, which may select nodes relative to the context node  the node currently being processed . Alternatively, it may make an absolute selection from the root node, or it may simply select the nodes by reference to a variable initialized earlier. By referencing a tree-valued variable, or by using the document   function  described in Chapter 13, page 754 , it may also select the root node of another XML document.  The   instruction can also be used to process a sequence of atomic values. The following example causes ﬁve empty   elements to be output:       The sequence constructor contained within the   element is evaluated once for each item in the select sequence. Within this sequence constructor, the context item is the item being processed  322   xsl:for-each   one of the selected items ; the position   function gives the position of that item in order of processing  the ﬁrst item processed has position  =1, and so on , and the last   function gives the number of items being processed.  Although there is a deﬁned order of processing, each item in the sequence is processed independently of the others; there is no way that the processing of one item can inﬂuence the way other items are processed. This also means that you can’t break out of the loop. Think of the items as being pro- cessed in parallel. If you need the processing of an item to depend in some way on previous items, there are two ways you can achieve this: you can look at earlier items in the input sequence  for example by using the preceding-sibling axis , or you can abandon use of  , and use recursion instead.  A common mistake is to forget that   changes the context item. For example, the following code will probably produce no output:  6  X S L T  l  E e m e n t s  Why? Because within the   element, the context node is a   element, so the   instruction is trying to display another   element that is a child of the ﬁrst one. What the author probably intended was:                        Sorting If there are no child   instructions, the selected items are processed in the order of the sequence produced by evaluating the select expression. If the select expression is a path expression, the nodes will be in document order. In the normal case where the nodes all come from the same input document, this means they will be processed in the order they are encountered in the original source document: for example, an element node is processed before its children. Attribute nodes belonging to the same element, however, may be processed in any order, because the order of attributes in XML is not considered signiﬁcant. If there are nodes from several different documents in the sequence, which can happen when you use the doc   or document   functions  described in Chapter 13 , the relative order of nodes from different documents is not deﬁned, though it is consistent if the same set of nodes is processed more than once.  The direction of the axis used to select the nodes is irrelevant.  The direction of different axes is described in Chapter 9.  For example, «select="preceding-sibling::*"» will process the preceding sib- lings of the context node in document order  starting with the ﬁrst sibling  even though the preceding- sibling axis is in reverse document order. The axis direction affects only the meaning of any positional qualiﬁers used within the select expression. So «select="preceding-sibling::*[1]"» will select the ﬁrst preceding sibling element in the direction of the axis, which is the element immediately before the context node, if there is one.  Although most XPath expressions return nodes in document order, not all do so. For example, the expres- sion «title, author, publisher» returns a sequence containing ﬁrst the child title elements, then the child author elements, and then the child publisher elements of the context node, regardless of the order that these nodes appear in the source document. The items returned by the XPath expression will be processed in the order of the sequence that is returned, not necessarily in document order.  323   XSLT Elements  If there are one or more   instructions as children of the   instruction, the items are sorted before processing. Each   instruction deﬁnes one component of the sort key. If the sort key contains several components, they apply in major-to-minor order. For example, if the ﬁrst   deﬁnes sorting by country and the second by state, then the nodes will be processed in order of state within country. If two items have equal sort keys  or if the same item is included more than once in the sequence , they will be processed in the order that they appeared in the original result of the select expression, unless the ﬁrst   element speciﬁes «stable="no"», in which case there are no guarantees. For a more complete speciﬁcation of how sorting works, see   on page 455.  If you want to process the items in the reverse of their original order, specify:     Alternatively, call the reverse   function. The following instruction will process the preceding siblings of the context node in reverse document order  that is, starting with the sibling closest to the context node and working backward .     Usage and Examples The main purpose of   is to iterate over a sequence of items. It can also be used, however, simply to change the context item. These two styles of use are illustrated in the following sections.  Iterating over a Sequence of Nodes The most common use of   is to iterate over a sequence of nodes. As such it provides an alternative to  . Which you use is largely a matter of personal style; arguably    push processing  ties the stylesheet less strongly to the detailed structure of the source document and makes it easier to write a stylesheet that can accommodate some ﬂexibility in the structures that will be encountered, while    pull processing  makes the logic clearer to the reader. It may even improve performance because it bypasses the need to identify template rules by pattern matching, though the effect is likely to be very small.  The following example processes all the attributes of the current element node, writing them out as elements to the result tree. This example is presented in greater detail under   on page 315.           <xsl:element name="{local-name  }"  namespace="{namespace-uri  }">                 The next example is a general one that can be applied to any XML document.  324   xsl:for-each  Example: Showing the Ancestors of a Node  The following example stylesheet can be applied to any XML document. For each element it processes all its ancestor elements, in reverse document order  that is, starting with the parent node and ending with the document element , and outputs their names in a comment that shows the position of the current node.  This stylesheet can be applied to any source document.  Source  Stylesheet  This stylesheet is in the ﬁle nesting.xsl.  <xsl:transform xmlns:xsl="http:  www.w3.org 1999 XSL Transform"  6  X S L T  l  E e m e n t s           within      version="2.0"  >                    Output  An example of the output this might produce is:        Number, the   Danzig  5.95  3  Language of Science  Changing the Context Item Another use of   is simply to change the context item. The need for this is reduced in XSLT 2.0, but it is still convenient on occasions. In XSLT 1.0, if you wanted to use the key   function  described in Chapter 13, page 812  to locate nodes in some ancillary document, it was necessary ﬁrst to establish some node in that document  typically the root  as the context node, because the key   function will only ﬁnd nodes in the same document as the context node.  325   XSLT Elements  For example, you might write:                 The effect is to assign to the variable the value of the name attribute of the ﬁrst element whose county-code key matches the value of the $code variable.  In XSLT 2.0 this particular example becomes simpler, because the key   function now accepts a third argument identifying the document to be searched. You can now write:  <xsl:variable name="county"  select="key ’county-code’, $code, document ’county-code.xml’   @name" >  But there are other cases where the technique is still useful; for example, if you need to call a named template that is designed to operate on the context node.  In a stylesheet that handles multiple input documents, it is always a good idea to declare a global variable:     Then you can always return to the original source document by writing:     ...     See Also   on page 240   on page 455 document   function in Chapter 13, page 754 key   function in Chapter 13, page 812  xsl:for-each-group  Changes in 2.0 This instruction is new in XSLT 2.0.  Format  <xsl:for-each-group  select = expression group-by? = expression group-adjacent? = expression  326  The   instruction selects a set of items, arranges the items into groups based on common values or other criteria, and then processes each group in turn.   xsl:for-each-group  group-starting-with? = pattern group-ending-with? = pattern collation? = { uri } >       Position   is an instruction, which is always used within a sequence constructor.  Attributes Name select mandatory  group-by optional  group-adjacent optional  group-starting-with optional  group-ending-with optional  collation optional  Value XPath Expression  Meaning The sequence of items to be grouped, known as the population.  XPath Expression Grouping key. Items with common values for the  grouping key are to be allocated to the same group.  XPath Expression Grouping key. Items with common values for the  Pattern  Pattern  grouping key are to be allocated to the same group if they are adjacent in the population.  A new group will be started for each item in the population that matches this pattern.  A new group will be started following an item that matches this pattern.  Collation URI  Identiﬁes a collation used to compare strings for equality when comparing group key values.  6  X S L T  l  E e m e n t s  The attributes group-by, group-adjacent, group-starting-with, and group-ending-with are mutually exclusive. Exactly one of these four attributes must be present.  Content Zero or more   elements, followed by a sequence constructor.  Effect Grouping takes as input a sequence of items  usually nodes  and organizes these items into groups. It then processes each of the groups in turn.  The effect of the   instruction is summarized as follows:        The expression in the select attribute is evaluated. This can return any sequence  of nodes or atomic values . This sequence is known as the population, and the order of the items in the sequence is called population order. Each item in the population is allocated to zero or more groups. The way this is done depends on which of the four attributes group-by, group-adjacent, group-starting-with, and group- ending-with is speciﬁed and is described in detail below. When group-by is used, an item may have more than one grouping key and may therefore be allocated to any number of groups  327   XSLT Elements               zero or more . In all other cases, each item in the population is allocated to exactly one group.  For the beneﬁt of mathematicians, the groups are then said to partition the population.  The initial item of each group is identiﬁed. This is the item in the group that is ﬁrst in population order, as deﬁned above. If one or more sort keys have been deﬁned using   elements within the   element, these sort keys are used to determine the process- ing order of the groups. Otherwise, the groups are processed in order of ﬁrst appearance, that is, based on the position of their initial items in population order. There is a special rule covering what happens if an item is allocated to two groups and is the initial item in both of them. This can only happen if the item had several values for its grouping key, and the order of ﬁrst appearance then relates to the order of these grouping keys in the result of the group-by expression. If the expression was «group-by="author"», and the value of this expression for the node in question was the sequence « "Gilbert", "Sullivan" », then the group for author Gilbert would be processed before the group for author Sullivan. The sequence constructor contained in the   element is evaluated once for each group. Within the sequence constructor, the function current-group   may be called to obtain the items that are members of this group  in population order , and if the groups were deﬁned using group-by or group-adjacent, then the function current-grouping- key   may be called to obtain the value of the grouping key that characterizes this group of items. The sequences that result from evaluating the sequence constructor once for each group are concatenated  in processing order  to form the ﬁnal result of the   instruction.  If the population is empty, then the number of groups will be zero. No group is ever empty. Whether the population contains nodes or atomic values, no attempt is made to remove duplicates. This means that if the same node appears twice in the population, it will generally appear twice in each group that it is allocated to.  The following sections describe the effect of each of the four attributes group-by, group-adjacent, group-starting-with, and group-ending-with in turn.  group-by The most common way of using   is to group items based on common values for a grouping key, which is achieved using the group-by attribute.  The group-by attribute is an XPath expression, which is evaluated once for each item in the population. It is evaluated with this item as the context item, with the position of this item in the population as the context position, and with the size of the population as the context size.  The value of the group-by expression is in general a sequence. This sequence is ﬁrst atomized  as described in Chapter 2, page 81 , and duplicate values are then removed from the atomic sequence that results. For each distinct value that remains in the sequence, the item is allocated to a group identiﬁed by this value. The total number of groups is equal to the number of distinct values present in the grouping keys for all items in the population.  Duplicate nodes are not removed from the population, but duplicate grouping keys calculated for a single node are removed. So if the authors of a book are J. Smith and P. Smith, and your grouping key is «author surname», then when you process the group for Smith, this book will be processed once, not twice.  328   xsl:for-each-group  Grouping keys are compared based on their type. For example, numbers are compared as numbers, and dates are compared as dates. Two grouping keys are considered equal based on the rules of the XPath «eq» operator, which is explained in Chapter 8 on page 582. Strings are compared using the collation speciﬁed in the collation attribute if present  for more details on collations, see under   on page 455 . Two NaN  not-a-number  values are considered equal to each other even though they are not equal when compared using «eq». If two values cannot be compared  because they are of noncomparable types; for example, xs:date and xs:integer , then they are considered not equal, which means the items end up in different groups.  If the group-by expression for any item in the population evaluates to an empty sequence, then the item will not be allocated to any groups, which means it will not be processed at all.  group-adjacent When the group-adjacent attribute is used to deﬁne the grouping criteria, items are assigned to groups on the following basis:  6  X S L T  l  E e m e n t s        The ﬁrst item in the population starts a new group. Subsequent items in the population are allocated to the same group as the previous item in the population if and only if they share the same value for the grouping key deﬁned by the group-adjacent attribute; otherwise, they are allocated to a new group.  The group-adjacent expression is evaluated once for each item in the population. During this evaluation, the context item is this item, the context position is the position of this item in population order, and the context size is the size of the population. The value that results from evaluating the group-adjacent expression is atomized  see page 81 . Unlike the group-by attribute, the result of evaluating the group- adjacent expression, after atomization, must be a single value. A type error is reported if the value is an empty sequence, or if it is a sequence containing more than one atomic value.  Values of the grouping key are compared in the same way as for the group-by attribute. This means, for example, that strings are compared using the collation deﬁned in the collation attribute if speciﬁed, and that NaN values compare equal.  There are two main reasons for using group-adjacent in preference to group-by:  Firstly, when there is a genuine requirement not to group items with the same grouping key unless they are adjacent. For example, a sequence of temperature readings might be presented so that the only readings actually shown are those that differ from the previous reading. This can be achieved by grouping adjacent readings and only displaying the ﬁrst reading in each group. Secondly, when it is known that the items with common grouping keys will always be adjacent in the population. In this case using group-adjacent might give the same result as group-by, but might be more efﬁcient because the XSLT processor can perform the grouping in a single pass through the data.  group-starting-with The group-starting-with attribute is an XSLT pattern  not an expression . Patterns are described in Chapter 12. Patterns apply only to nodes, so this attribute must be used only when the population con- sists entirely of nodes. The nodes in the population are assigned to groups on the following basis:  The ﬁrst node in the population starts a new group. Subsequent nodes in the population start a new group if they match the pattern, and are assigned to the same group as the previous node otherwise.              329   XSLT Elements  The result is that the initial node in each group  the one that comes ﬁrst in population order  will always match the pattern, with the possible exception of the ﬁrst group, which may contain no node that matches the pattern.  The group-starting-with attribute is useful where the population consists of a repeating group of nodes whose ﬁrst member can be readily identiﬁed: for example, a   element followed by a sequence of   elements, then another  , and so on. In this case the grouping can easily be deﬁned using «group-starting-with="header"».  group-ending-with This attribute behaves in a very similar way to group-starting-with, except that the pattern identiﬁes the last item in a group instead of the ﬁrst. The nodes in the population are assigned to groups on the following basis:        The ﬁrst node in the population starts a new group. Subsequent nodes in the population start a new group if the previous node in the population matches the pattern, and they are assigned to the same group as the previous node otherwise.  The most common use case for this option is where input records contain a continuation marker of some kind. For example, the population might consist of elements that have the attribute «continued="yes"» or «continued="no"». A group can then be deﬁned using the criterion «group-ending-with= "*[@continued="no"]"».  Sorting the Groups If there are any   elements as children of the  , these affect the order in which the groups are processed. They do not affect the order of the items within each group, nor which item in a group is considered to be the initial item.  The select expression in an   element calculates a sort key that affects the group as a whole, but it is always evaluated with respect to the initial item in the group. The initial item in a group is the item within the group that was ﬁrst in population order. The select expression is evaluated with this item as the context item, with the position of this item relative to the initial items of other groups as the context position, and with the number of groups as the context size.  If any of the attributes of the   elements are attribute value templates, then the XPath expres- sions in these attribute value templates are evaluated with the same context item, position, and size as the select expression of the containing   element.  If there are no   elements, or in cases where the initial items in two groups have the same values for their sort keys, the groups are processed in order of ﬁrst appearance; that is, if the initial item of group G appeared in the population before the initial item of group H, then group G is processed before group H.  ‘‘Processed before’’ does not refer to the actual order of execution; the system can process the groups in any order, or in parallel. What it means is that the results of processing group G appear in the ﬁnal result sequence ahead of the results of processing group H.  In practice, if the groups are sorted at all then they are nearly always sorted by the value of the grouping key: group the addresses in each city, sorting the groups by city. This can be conveniently coded as:        330   xsl:for-each-group              The functions current-group   and current-grouping-key   are described on page 739 in Chapter 13.  An   element within   is used to sort the groups. To sort the items within each group, use an   element within the inner  , or write:     The   instruction is described on page 437.  You can also use the   instruction to sort the population before grouping starts.  Usage and Examples The following sections give a number of examples of how   can be used to solve grouping problems. They are organized according to the four ways of deﬁning the grouping criteria: group-by, group-adjacent, group-starting-with, and group-ending-with.  Using group-by This is by far the most common kind of grouping. We’ll start with a simple case.  6  X S L T  l  E e m e n t s  Example: Single-Level Grouping by Value  This example groups a set of employees according to the department in which they work.  We’ll start with the following simple data ﬁle  staff.xml :             Source        Output  The requirement is to output an HTML document in which the staff are listed by department:   sales department   John Jones   Maria Gomez   personnel department   Barbara Jenkins   331   XSLT Elements   Wesley Thomas   transport department   Cormac O’Donovan   Stylesheet  This output is simple to achieve. The full stylesheet is in group-by-dept.xsl:              department                    A number of variations are possible on this theme. To sort the deparments, use an   element within the  . To sort the employees within each department, use an   element within the  . The solution then becomes  sorted-depts.xsl :                department                       This general design pattern, where   is used at the outer level to iterate over the groups, and an inner   is used to iterate over the items within a group, is typical. But there are a number of useful variations:           The inner loop is sometimes better done using <xsl:apply-templates select="current- group  " >, especially if the group includes elements of different types. Sometimes the entire inner loop can be written as <xsl:copy-of select="current- group  " >, especially when generating XML output. Sometimes the requirement is not to display the items in each group, but to calculate some aggre- gate function for these items: for example to list for each department, the name of the depart- ment, the number of employees, and the maximum salary. In this case, the inner loop might not be explicit. The number of employees in the group is easily computed as «count current- group   ». Our sample data doesn’t show salary, but if this was available as an extra attribute on the   element, then you could easily calculate the maximum salary as «max current-group   @salary ».  332   xsl:for-each-group        If the requirement is to eliminate duplicates rather than to group all the items  in our example, to output a list of departments , then the inner loop can be omitted entirely. But in this case it may be simpler to use the distinct-values   function described on page 749. If you need to number the groups, or test whether you are processing the last group, then within the   element you can use position   and last   in the usual way. At this level, the context item is the initial item of the group being processed, and position   and last   refer to the position of this item in a list that contains the initial item of each group, in processing order.  The example above was expressed as a grouping problem  ‘‘list the employees grouped by department’’ , so it is easy to see that   can be used in the solution. Sometimes grouping prob- lems are not so easy to recognize. This might be the case if the example above were expressed as ‘‘for each department, list the name of the department and the number of employees.’’  Example: Multilevel Grouping by Value  6  X S L T  l  E e m e n t s  Sometimes there is a need to do multilevel grouping. For example, you might want to group the employees by department, and the departments by location. Assume that the   element now has a location attribute as well as a department attribute. It doesn’t really matter whether departments can span locations, the code will work either way.  Source  The data is now like this  staff-locations.xml :     <employee name="John Jones"  department="sales" location="New York" >  <employee name="Barbara Jenkins" department="personnel" location="Los Angeles" >  <employee name="Cormac O’Donovan"  department="transport" location="New York" >  <employee name="Wesley Thomas"  department="personnel" location="Los Angeles" >  <employee name="Maria Gomez" department="sales" location="Seattle" >     Output  You might want the output presented like this:  Location: Los Angeles  Department: Personnel  Barbara Jenkins Wesley Thomas  Location: New York  Department: Sales  John Jones  333   XSLT Elements  Department: Transport  Cormac O’Donovan  Location: Seattle  Department: Sales  Maria Gomez  Stylesheet  Assume that the indentation is achieved using CSS styles, so you can concentrate on getting the structure of the information right. To do this multilevel grouping, just use two levels of   elements  multi-level.xsl :              Location                 Location                 Location                     A similar requirement is where there is a composite grouping key  ‘‘group employees that have the same department and the same location’’ . There are two ways of handling this. You can either treat it as a single level of grouping, using the concatenation of the two values as the grouping key, or you can treat it as two nested groupings in which the outer level does nothing  composite.xsl :        . . .        The two techniques are not completely identical. For example, with a single-level group- ing using a concatenated key, the value of position   while processing a department will run continuously from 1 up to the total number of groups, but with a two-level grouping, position   will start again at 1 for each location.  334   xsl:for-each-group  The group-by option also allows an item to belong to more than one group. Suppose that an employee can work for several departments, and that the department attribute is extended to be a whitespace- separated list of department names. If you are using a schema-aware processor that annotates this attribute as belonging to a list-valued type, then all the examples we have written above will handle this situation without change. When you write «group-by="@department"», the value of the expres- sion is atomized, and if the type is a list-valued type, this will return the sequence of atomic values contained in the attribute. The item with this grouping key is then allocated to one group for each depart- ment. I was careful to output the department name by referring to <xsl:value-of select="current- grouping-key  " >; if I had written   the output would have been rather confusing, because instead of listing the name of the single department to which all the employees in this group belong, the code would list all the deparments to which the ﬁrst employee in the group belongs.  Using group-adjacent The group-adjacent option attaches signiﬁcance not only to the value of the grouping key but also to the order of items in the population. So it shouldn’t be a surprise to ﬁnd that many of its applications come with document-oriented XML, where order is typically much more signicant than with data-oriented XML. However, I’ve also seen it used with great effect to analyze time-sequence data.  Here’s a simple but common example: given a   consisting of   elements and   elements, you want to convert the   elements into   elements, and the   elements into   elements, with a   element wrapped around a sequence of consecutive bullets. You can do this as follows:  6  X S L T  l  E e m e n t s        <xsl:for-each-group select="*"              group-adjacent="if  self::bullet  then 0 else position  ">  The grouping condition ensures that adjacent   elements go in a group together, while each   element goes in a group by itself  calling position   ensures each   element gets a unique grouping key — you could also have used generate-id   . We are only interested in the rule that processes the ﬁrst bullet:                 This template rule processes the group of adjacent bullets by outputting the necessary   element to the result tree, and inside this it creates the elements that represent each individual bullet, by calling another template rule  in a different mode  to process each one. The full stylesheet is in bullets.xsl, a sample source ﬁle in bullets.xml.  Now look at a more complex example, involving the formatting of a Shakespeare play. You can download the text of all Shakespeare’s plays, marked up in XML by Jon Bosak, at http:  metalab.unc.edu bosak  xml eg shaks200.zip.  335   XSLT Elements  Example: Grouping Consecutive Elements by Name  This example shows how to tackle a problem in which the content of an element  in this case, a    consists of a number of   elements followed by a number of   elements.  Source  You can run this example on any of the Shakespeare plays. For convenience, the download directory contains the ﬁle ado-scene1.xml, containing the ﬁrst scene from Much Ado About Nothing. In this markup, a   element consists of a sequence of   elements interleaved with stage directions. A   contains one or more   elements indicating who is speaking, and one or more   elements indicating what they are saying. So in Hamlet you have speeches like this:     HAMLET   My fate cries out,   And makes each petty artery in this body   As hardy as the Nemean lion’s nerve.   Still am I call’d. Unhand me, gentlemen.   By heaven, I’ll make a ghost of him that lets me!   I say, away! Go on; I’ll follow thee.     and also speeches with multiple speakers:     ROSENCRANTZ   GUILDENSTERN   We’ll wait upon you.     There are very few occasions where Shakespeare allows two characters to speak together for more than a single line  the witches’ speech in Macbeth is tagged as  ALL  , but here is an example from Timon of Athens:     PHRYNIA   TIMANDRA   Well, more gold: what then?   Believe’t, that we’ll do any thing for gold.     Suppose that you want to output each speech as a row in a table, with the speakers listed in one column and the text in the other. It should look like this  you wouldn’t normally make the table cells visible in this way, but it helps to be able to see the structure :  Output  336   xsl:for-each-group  PHRYNIA TIMANDRA  More counsel with more money, bounteous Timon.  TIMON  More whore, more mischief ﬁrst; I have given you earnest.  ALCIBIADES  Strike up the drum towards Athens! Farewell, Timon: If I thrive well, I’ll visit thee again.  TIMON  If I hope well, I’ll never see thee more.  Stylesheet  So what does the stylesheet look like? The content of a   element consists of two groups: a group containing consecutive   elements and a group containing consecutive   elements. So you could try to write it like this:  6  X S L T  l  E e m e n t s                                      Here we are using the name of an element as its grouping key. But I omitted one complication. Within the sequence of   elements, there can also be a   representing a stage direction, thus:     TIMON   Long live so, and so die.   Exit APEMANTUS   I am quit.   More things like men! Eat, Timon, and abhor them.     When this happens you would want to output it, in its proper place, in italics:  TIMON  Long live so, and so die.  Exit APEMANTUS  I am quit.  More things like men! Eat, Timon, and abhor them.  What does this do to the stylesheet?  337   XSLT Elements  The second group, the one that comprises the right-hand column of the table, no longer shares a common element name. What you can do, however, is allocate   elements to one group, and anything else to a different group.       <xsl:for-each-group select="*"  group-adjacent="if  self::SPEAKER  then 0 else 1">                             The fact that you output the content of the   and   elements using <xsl:apply- templates> means that you don’t have to change the body of this rule to handle   elements as well; all you need to do is add a template rule with «match="SPEECH STAGEDIR"» to handle them.  To complete the stylesheet, you need to add template rules for the individual elements such as  . These are straightforward, so I will not list them here. You can ﬁnd the complete stylesheet in speech.xsl.  You could actually have used a boolean grouping key, «group-adjacent="boolean  self:: SPEAKER "», but that would be a little obscure for my taste.  All these examples so far would work equally well using group-by rather than group-adjacent, because there are no nonadjacent items that would have been put in the same group if you had used group-by. But it’s still worth using group-adjacent, if only because it’s likely to be more efﬁcient — the system knows that it doesn’t need to do any sorting or hashing, it just has to compare adjacent items.  Example: Handling Repeating Groups of Adjacent Elements  This example is a slightly more difﬁcult variant of the previous example, in which the   elements have been omitted from the input markup.  Source  If the Shakespeare markup had been done by someone less capable than Jon Bosak, the   elements might have been left out. You would then see a structure like this:   PHRYNIA   TIMANDRA   More counsel with more money, bounteous Timon.   TIMON   More whore, more mischief first; I have given you earnest.   ALCIBIADES   Strike up the drum towards Athens! Farewell, Timon:   If I thrive well, I’ll visit thee again.   338   xsl:for-each-group  I have modiﬁed the markup of this  very long  scene from Timon of Athens and included it as timon-scene.xml.  The required output is the same as in the previous example: that is, a table, in which each row represents one speech, with the names of the speakers in one column and the lines spoken in the other.  Output  Stylesheet  There are various ways of handling such a structure, none of them particularly easy. One approach is to do the grouping bottom-up: First, you put a group of consecutive speak- ers in a   element and a group of consecutive lines and stage directions in a   element, then you process the sequence of alternating   and   elements. Here’s the logic, which is expanded into a full stylesheet in the download ﬁle alternate-groups.xsl:          <xsl:for-each-group select="*"  group-adjacent="if  self::SPEAKER   then ’SPEAKERS’ else ’LINES’">                <xsl:for-each-group select="$sequence"  group-starting-with="SPEAKERS">                      6  X S L T  l  E e m e n t s                      This does the grouping in two phases. The ﬁrst phase creates a sequence of alternating ele- ments named   and  , which you constructed by choosing these as your grouping keys. This sequence is held in a variable. The second phase uses group-starting- with to recognize a group consisting of a   element followed by a   element. All that remains is to process each group, which of course consists of a   element holding one or more   elements, followed by a   element holding one or more   and   elements.  339   XSLT Elements  If I had presented an example query ‘‘ﬁnd all the speeches in Shakespeare involving two or more speakers and containing two or more lines,’’ and had presented the solution as «collection  ’shakes.xml’    SPEECH[SPEAKER[2] and LINES[2]]», you would probably have found the example rather implausible. But if you want to know how I found the Timon of Athens quote, you have your answer.  This stylesheet produced incorrect output when we tried it with AltovaXML 2008. It works correctly with Saxon and Gestalt.  Using group-starting-with Like group-adjacent, the group-starting-with option selects groups of items that are adjacent in the population, and it therefore tends to be used with document-oriented XML. The difference is that with this option, there doesn’t have to be any value that the adjacent nodes have in common: All that you need is a pattern that matches the ﬁrst node in each group.  I could have used this technique for the previous Shakespeare example. In fact, given a scene consisting of alternating sequences of   elements and   elements, with no   elements to mark the boundaries, I could have reconstructed the   elements by writing:       <xsl:for-each-group select="*" group-starting-with=  "SPEAKER[not preceding-sibling::*[1] [self::SPEAKER] ]">                   Here the pattern that marks out the ﬁrst element in a new group is that it is a   element whose immediately preceding sibling element  if it has one  is not another   element.  A common use for group-starting-with is the implicit hierarchies one sees in XHTML. We will explore this in the next example.  Example: Handling Flat XHTML Documents  This example shows how to create a hierarchy to represent the underlying structure of an XHTML document in which headings and paragraphs are all represented as sibling elements.  A typical XHTML document looks like this  flat.xml :  Source         Title   We need to understand how hierarchies can be flat.   Subtitle   Let’s get to the point.   340   xsl:for-each-group   The second paragraph in a section often says very little.   But the third gets to the heart of the matter.   Subtitle   To conclude, we are dealing with a flat hierarchy.   This fragment consists of a   element with eight child elements, all at the same level of the tree. Very often, if you want to process this text, you will need to understand the hierarchic structure even though it is not explicit in the markup. For example, you may want to number the last paragraph as «1.2.1».  To manipulate this data, you need to transform it into a structure like the one below that reﬂects the true hierarchy:       Title    We need to understand how hierarchies can be flat.    Subtitle    Let’s get to the point.   The second paragraph in a section often says very little.   But the third gets to the heart of the matter.       Subtitle    To conclude, we are dealing with a flat hierarchy.   6  X S L T  l  E e m e n t s        Output           Stylesheet  The group-starting-with option is ideal for this purpose, because the   and   elements are easy to match. Here is the code  unflatten.xsl :                             <xsl:for-each-group select="current-group   except ."     group-starting-with="h2">          341   XSLT Elements          <xsl:for-each-group select="current-group   except ."     group-starting-with="h3">                                   I’ve shown this down to three levels; it should be obvious how it can be extended. When an   element is matched, it is processed as part of a group that starts with an   element and then contains a number of   and   elements interleaved. The template rule ﬁrst outputs the contents of the   element as a heading and then splits the contents of this group  excluding the ﬁrst   element, which is of no further interest  into subgroups. The ﬁrst subgroup will typically start with an ordinary   element, and all subsequent subgroups will start with an   element. Call   to process the ﬁrst element in the subgroup, and this ﬁres off either the «match = "p"» template  for the ﬁrst group  or the «match = "h2"» template  for others . The «match = "p"» template simply copies the group of   elements to the result tree, while the «match = "h2"» template starts yet another level of grouping based on the   elements, and so on. If you wanted to be clever you could handle the  ,  ,  , . . . ,  elements with a single generic rule. This could be done by writing the template rule as:       <xsl:variable name="next"  select="translate $this, ’12345678’, ’23456789’ " >        <xsl:for-each-group select="current-group   except ."     group-starting-with="*[name  =$next]">           Using group-ending-with The group-ending-with option complements group-starting-with by matching the last item in a group instead of the ﬁrst. This requirement is far less common, but it does arise. The classical example for it is where a large document has been broken up, for transmission reasons, into small arbitrary chunks,  342   xsl:for-each-group  and the last chunk carries some distinguishing characteristic such as the absence of an attribute saying «continued="yes"». To reconstitute the documents from the sequence of chunks, group-ending-with is the answer:                     I have also found group-ending-with useful on occasions when writing an up-conversion to XML from formats such as Excel spreadsheets, where the last line of a group can be detected by the presence of a word such as TOTAL or SUBTOTAL in a particular column.  Arranging Data in Tables Arranging data in tables is a common requirement when generating HTML pages, and the <xsl:for- each-group> instruction can help with this in a number of ways. I will not present any detailed worked examples here, just a checklist of techniques. However, the examples are expanded in the download ﬁles: see towns.xml, towns-by-rows.xsl, and towns-by-columns.xsl.  If you need to arrange data in rows, like this:  Andover  Egham  Ironbridge  Basingstoke  Farnham  Jarrow  Crawley  Guildford  Kingston  Dorking  Horsham  Leatherhead  the simplest approach is this, where «$cols» is the number of columns required:  <xsl:for-each-group select="town"  group-adjacent=" position  -1  idiv $cols">  6  X S L T  l  E e m e n t s                       If the data needs to be sorted ﬁrst, use the   instruction. For example:                <xsl:for-each-group select="$sorted-towns"  . . .     group-adjacent=" position  -1  idiv $cols">  343   XSLT Elements  The   instruction is described on page 437.  If you need to generate empty table cells to ﬁll up the last row, one convenient way is to add them to the sequence before you start:  <xsl:variable name="gaps"  select=" count towns  idiv $cols *$cols + $cols - count towns " >  <xsl:variable name="padding" select="  if  $gaps = $cols  then    else for $i in 1 to $gaps return ’&nbsp;’" >       . . .     If you want to arrange the data in columns, like this:  Andover  Basingstoke  Crawley  Dorking  Egham  Farnham  Guildford  Horsham  Ironbridge  Jarrow  Kingston  Leatherhead  then it is probably simplest to use group-by. The grouping key  the things that the towns in a particular row have in common  is the value of «position   mod 3» where 3 is the number of rows, which you can calculate as «count $cells  idiv $cols» :  group-by="position   mod  last   idiv $cols ">  <xsl:for-each-group select="$cells"                       See Also   on page 437   on page 455 Collations on page 459 current-group   function on page 739 current-grouping-key   function on page 740 distinct-values   function on page 749  xsl:function  Changes in 2.0 This element is new in XSLT 2.0.  344  The   declaration deﬁnes a stylesheet function that can be invoked using a function call from any XPath expression.   xsl:function  Format  <xsl:function  name = qname as? = sequence-type override? = "yes"  "no">       Position   is a top-level declaration, which means that it always appears as a child of the   element.  Attributes Name name mandatory  as optional  override optional  Value Lexical QName The name of the function.  Meaning  SequenceType  The type of the value returned when this function is evaluated. A type error is reported if the result does not match this type.  «yes» or «no»  Indicates whether this function overrides any vendor-supplied function of the same name.  6  X S L T  l  E e m e n t s  The construct SequenceType is described in Chapter 11.  Content Zero or more   elements, followed by a sequence constructor.  Effect User-written stylesheet functions can be called from XPath expressions in the same way as system- provided functions. The function deﬁned by this   element is added to the static con- text for every XPath expression in the stylesheet, which means that the function will be invoked when evaluating a function call in an XPath expression that has a matching name and number of arguments  arity .  When a stylesheet function is called from an XPath expression, the parameters supplied in the func- tion call are evaluated and bound to the variables deﬁned in the   elements, the sequence constructor contained in the   element is evaluated, and the result of this evaluation is returned as the result of the XPath function call.  The name of the function is given as a lexical QName in the name attribute. This name must have a namespace preﬁx: This is to ensure that the name does not clash with the names of functions in the standard function library. The XSLT 2.0 speciﬁcation deﬁnes several namespaces  all starting with «http:  www.w3.org »  that are reserved — that is, they cannot be used for the names of user-deﬁned functions, variables, or other stylesheet objects.  The stylesheet is allowed to contain two functions of the same name if they have different arity.  345   XSLT Elements  It is an error to have two functions in the stylesheet with the same name, arity, and import precedence, unless there is another with higher import precedence. When a function call in an XPath expression is evaluated, the function with highest import precedence is chosen.  The parameters to a function  which are deﬁned using   elements as children to the   element  are mandatory parameters; it is not possible to use the required attribute to specify that a parameter is optional, or to specify a default value. The parameters are interpreted positionally: the ﬁrst argument in the function call binds to the ﬁrst   element, the second argument binds to the second  , and so on.  The values supplied as arguments to the function in the XPath function call are converted to the types deﬁned by «as» attributes on the corresponding   elements if required, using the stan- dard conversion rules described on page 505. If this conversion fails, a type error is reported. If an   element has no «as» attribute, then any value of any type is acceptable, and no checking or conversion takes place. This is equivalent to specifying «as="item  *"».  On entry to the function, the context item, position, and size are undeﬁned. It is therefore an error to use the expression «.», or any relative path expression, or the functions position   and last  . Even a path expression beginning with « » is not allowed, because such path expressions select from the root of the tree containing the context node. This means that all information needed by the function must either be passed explicitly as a parameter or be available in a global variable. Path expressions such as «$par a b c» can be used to navigate from nodes that are supplied as parameters to other nodes in the same tree.  Other values in the dynamic context, such as the current template, current mode, current group, and current grouping key, are also either undeﬁned or empty on entry to a stylesheet function.  The result of the function is obtained by evaluating the sequence constructor. This result may be a sequence consisting of nodes  either newly constructed nodes or references to existing nodes  or atomic values or both. If there is an «as» attribute on the   element, then the result of evaluat- ing the sequence constructor is converted, if necessary, to the speciﬁed type. Once again, the standard conversion rules deﬁned on page 505 are used. A type error is reported if this conversion fails. If the   element has no «as» attribute, then a result of any type may be returned, and no checking or conversion takes place.  The override Attribute The override attribute controls what happens if a user-written function and a vendor-supplied function have the same name.        «override="yes"» means that the user-written function wins. This is the default. This value maximizes portability: the same implementation of the function will be used on all XSLT processors. «override="no"» means that the vendor-supplied function wins. This setting is useful when the stylesheet function has been written as a fallback implementation of the function, for use in environments where no vendor-supplied implementation exists. For example, at http:  www.exslt.org  there is a deﬁnition of a mathematical function library, including the function math:sqrt  , which evaluates the square root of its argument. This function is likely to be available with a number of XSLT processors, but not all. By supplying an XSLT implemen- tation of this function, and specifying «override="no"», the stylesheet author can ensure that a call to math:sqrt   will execute on any XSLT processor, and will take advantage of the vendor’s native implementation when available.  346   xsl:function  You can ﬁnd a square root function implemented in XSLT on Dimitre Novatchev’s FXSL site at http:  fxsl.sourceforge.net . It’s faster than you might think. Nor is it a purely academic exercise. XSLT can be used to create graphical renditions of your data in SVG format, and this will often require such computations.  Usage and Examples In this section I will ﬁrst outline a few ways in which stylesheet functions can be used. I will then look more speciﬁcally at the differences between stylesheet functions and named templates. Then I will discuss the use of recursive functions, which provide an extremely powerful programming tool.  Example: Calculating Annual Leave  Stylesheet functions can be used in many different ways. Here is a simple function, which can be applied to an   element to calculate the employee’s annual leave entitlement in days. In turn it calls another function, which calculates the duration in months between two dates. The full stylesheet is in annual-leave.xsl  6  X S L T  l  E e m e n t s  This example uses two very simple source documents employees.xml and departments.xml, both governed by a schema employees.xsd. The stylesheet is schema-aware. This means that to run it using AltovaXML 2008, you will need to modify the outermost element of the two source documents by adding the attributes:  xmlns:xsi="http:  www.w3.org 2001 XMLSchema-instance" xsi:schemaLocation="http:  ns.megacorp.com hr employee.xsd"  Source  Stylesheet  <xsl:function name="pers:annual-leave" as="xs:integer"  xpath-default-namespace="http:  ns.megacorp.com hr">    <xsl:variable name="service"  as="xs:yearMonthDuration"  select="pers:monthDifference   current-date  , $emp date-of-joining " >                                   347   XSLT Elements         <xsl:variable name="m"  select=" year-from-date $arg1  - year-from-date $arg2  *12  +  month-from-date $arg1  - month-from-date $arg2  " >        This function can now be called from any XPath expression. For example, you can process all the employees with more than 16 days’ annual leave by writing:     Or you could process the employees sorted according to the number of days they are entitled to:           This function could be packaged in a library module with other similar functions, allowing reuse of the code, and allowing the algorithms to be changed in one place rather than hav- ing them scattered around many different stylesheets. For calculating properties of nodes, functions are much more ﬂexible than named templates because of the way they can be called.  In the previous edition of this book, which was based on drafts of the XSLT 2.0 Recommenda- tion, I was able to make use of a system function subtract-dates-yielding-yearMonth Duration, thus avoiding the need to write the pers:monthDifference function myself. This function was dropped from the ﬁnal speciﬁcation, not because of its unwieldy name, but because no-one could quite agree on the speciﬁcation: how many months are there, for example, between Feb 29, 2008 and Jan 31, 2008? In my version of the function, the answer is 1.  As well as encapsulating properties of elements, functions can be used to encapsulate relationships. For example, the following function determines the responsible line manager for an employee:  <xsl:function name="pers:line-manager" as="schema-element pers:employee "  xpath-default-namespace="http:  ns.megacorp.com hr">    <xsl:variable name="mgr-nr"  select="doc ’departments.xml’    departments  department[@dept-nr = $emp department]  manager-nr" >  <xsl:sequence select="doc ’employees.xml’    key ’emp’, $mgr-nr " >     348   xsl:function  Users of this function do not need to know how the relationship between employees and their line manager is actually represented in the XML source documents, only that the information is obtain- able. This function can then be used in a path expression, rather like a virtual axis:      Manager:         In these examples I have declared the types of the parameters and the result by reference to types deﬁned in a schema. This helps to document what the function is intended for, and it ensures that you will get an error message  rather than garbage output  if you call the function with incorrect parameters, for example a department rather than an employee element.  I have used the xpath-default-namespace attribute, which can be used on any XSLT element to deﬁne the namespace that is used for unpreﬁxed element and type names occurring in XPath expressions. For details of this attribute, see the entry for   on page 465.  I also chose to put the functions in the same namespace as the elements that they operate on. This is not the only approach possible, but to my mind it establishes clearly that there is a close relationship between the types  such as pers:employee  and the functions designed to operate on those types — the functions act like methods on a class.  6  X S L T  l  E e m e n t s  Functions versus Named Templates XSLT offers two very similar constructs: named templates and stylesheet functions. This section discusses the differences between them and suggests when they might be used.  The main difference between named templates and stylesheet functions is the way they are called. Tem- plates are called from the XSLT level using the   instruction, while stylesheet functions are called from XPath expressions using a function call. Another difference is that when a tem- plate is called, the caller’s context is retained, which is not the case for a function call. The content model for the   and   elements is identical, and there is no difference in the way they are evaluated to produce a result, or in the kinds of result they can return. If you need to invoke the same functionality from both the XSLT and the XPath levels, it is very easy to deﬁne a named template as a wrapper for a stylesheet function:               or to deﬁne a stylesheet function as a wrapper for a named template:                        349   XSLT Elements  My own preference is to use stylesheet functions when I want to compute a value or to select exist- ing nodes, and to use a named template when I want to construct new nodes. This reﬂects the fact that, in general, the role of XSLT instructions is to construct nodes in the result tree, while the role of XPath expressions is to select nodes in the source tree and compute values derived from their content. It’s dangerous to speculate about performance of products in general terms, but it seems to me quite likely that XPath engines will be optimized for navigating around source trees, while XSLT engines will be optimized for constructing result trees, and this difference may be reﬂected in the way the two call mechanisms work.  The fact that stylesheet functions do not have access to the context item may seem at ﬁrst to be an inconve- nience. But I think that the fact that all parameters to the function are explicit greatly helps programming discipline, and produces code that is easier to maintain. It also makes life much easier for the optimizer, which brings another beneﬁt in terms of faster execution.  Functions with side effects can cause some surprises at the XPath level, and creating a new node is a kind of a side effect. For example, one might expect that the result of the expression:  my:f $x  is my:f $x   is always true. But if the function my:f   creates a new node, this is not the case. It is no longer a pure fun- ction, because it returns different results on different invocations. An optimizer has to recognize this pos- sibility when rearranging such an expression: it must make sure that the function is actually called twice.  Another example of this effect is the  admittedly rather perverse  expression:  count   a .. my:f .    Normally when evaluating a path expression, the processor can ﬁrst ﬁnd all the nodes that the path expression locates, then sort them into document order and eliminate duplicates. But with the expression above, if «my:f  » creates new nodes then the result of the ﬁnal count   depends critically on how many times the function «my:f  » is called, and the correct answer is that it must be called exactly once for each distinct parent of an   element in the source document.  This is the kind of expression that is used to sort out the sheep from the goats when doing XPath con- formance testing, and you’ll ﬁnd lots of cases like this in the W3C test suites for XSLT and XQuery. In practice, however, the issues rarely arise in real applications.  Recursion Stylesheet functions can be recursive: they can call themselves either directly or indirectly. Because XSLT is a functional programming language without side effects  at any rate, without updateable variables , recursion plays a key role in writing algorithms of any complexity.  In XSLT 1.0, such algorithms were written using recursive named templates. Apart from being rather long-winded, this had the drawback that it was difﬁcult to return certain kinds of result: templates in XSLT 1.0 could only return results by constructing new nodes. In XSLT 2.0 both templates and functions offer much more ﬂexibility in the types of result they can return, and stylesheet functions offer additional ﬂexibility in the way they can be called  for example, they can be called from within a predicate used in a match pattern .  As it happens, many of the simple problems where recursion was needed in XSLT 1.0 can now be solved in other ways, because XPath 2.0 offers a wider range of aggregation functions, and functions such as  350   6  X S L T  l  E e m e n t s  tokenize   to break up a string into its parts. But there are still cases where recursion is needed, and even when it isn’t, many people ﬁnd the recursive solution more elegant than an iterative solution using   or the XPath «for» expression.  Here is a function that extracts the part of a string after the last « » character:  xsl:function       <xsl:sequence select="  if  contains $in, ’ ’  then str:suffix substring-after $in, ’ ’   else $in" >     Note how all the logic is contained in a single XPath expression. I could have used   to express the same logic, but with this kind of function I personally ﬁnd it clearer to write the whole algo- rithm at the XPath level.  The function result is returned using an   instruction. It sometimes feels a little strange to use   when the value being computed is a single integer or string, but in the XDM model a single value is the same as a sequence of length 1, so it’s worth getting used to the idea that everything is a sequence. When returning an atomic value, one could just as easily use  , but I prefer   because it works in all cases; when you are returning nodes, you don’t want to copy them unnecessarily. You might also be tempted to use  , and in this case it would work, but the semantics aren’t quite what we want:   would convert the selected string into a text node, which would then be atomized back to a string by virtue of the function’s declared return type. Even if the optimizer can sort this out, it’s making unnecessary work.  Another observation about this function is that it is tail-recursive. This means that after calling itself, the function does nothing else before it returns to its caller. This property is important because tail-recursive functions can be optimized to save memory. Sometimes a problem with recursion is that if you recurse too deeply, say to 1000 levels or so, the system runs out of stack space and terminates with a fatal error. A good XSLT processor can optimize a tail-recursive function so that this doesn’t happen. Basically the trick is that instead of making the recursive call and then unwinding the stack when it regains control, the function can unwind the stack ﬁrst, and then make the recursive call. This is because the stack frame isn’t needed once the recursive call returns.  I mentioned earlier that many functions can now be implemented easily without using recursion, and this one is no exception. It could also be written using regular expressions:             But this is a matter of personal style. It’s a good idea to have more than one tool in your kitbag, and recursion is the most powerful one available.  One kind of problem where you will need recursion is when you need to analyze a graph  that is, a network of related objects . The next example shows the technique.  351   XSLT Elements  Example: Looking for Cycles among Attribute Sets  This example examines a stylesheet module  we’ll stick to a single module for simplicity  and determines whether it contains any cycles among its attribute set deﬁnitions. Also to keep it simple, I’ll assume that attribute sets have simple names and ignore the complications caused by namespace preﬁxes.  Source  Output  Stylesheet  The source document is any stylesheet module. But the example is only interesting if you run it on a stylesheet module that contains attribute sets that are  incorrectly  deﬁned in terms of themselves. I’ve included such a sample as cyclic-stylesheet.xsl. This example requires a schema-aware processor and assumes that the source document is validated against the schema for XSLT 2.0 stylesheets, which is included in the download as schema-for-xslt20.xsd.  The AltovaXML 2008 schema processor, unfortunately, rejects this schema as invalid.  The stylesheet will report the name of any attribute set that is deﬁned directly or indirectly in terms of itself.  This stylesheet is available as find-cycles.xsl. We’ll start with a function that returns the attribute sets that are directly referenced from a given attribute set:       <xsl:sequence select="$in .. xsl:attribute-set  [@name=$in @use-attribute-sets]" >     This returns any attribute-set in the containing document whose name attribute is equal to any of these strings. Notice what’s going on: The schema for XSLT stylesheets tells us that the use-attribute-sets attribute is a sequence of strings. The «=» operator causes this attribute to be atomized, which returns the typed value of the attribute, namely this sequence of strings; it then returns true if any of the strings in this sequence is equal to the other operand. This will only work if the input document has been validated against its schema. Now observe that an attribute set A references another attribute set B if either cyc:direct A  includes B, or there is an attribute set in cyc:direct A  that references B. This suggests the recursive function:         <xsl:sequence select="  352   xsl:if  6  X S L T  l  E e m e n t s   cyc:direct $A  intersect $B  or  some $X in cyc:direct $A  satisfies cyc:references $X, $B  " >     Unfortunately, this doesn’t quite work: if we apply it to a node that doesn’t participate in a cycle, but which references a node that does, then we’ll go into an inﬁnite loop. To pro- tect against this we need to remember the route by which a node was reached and avoid processing it if it is reached again. The corrected function is:             <xsl:sequence select="exists $direct intersect $B  or   some $C in  $direct except $route   satisfies cyc:references $C, $B,  $route, $C   " >     Now, ﬁnally, you can discover whether there are any cycles, that is, any attribute sets that reference themselves directly or indirectly:  <xsl:value-of select="some $X in  * xsl:attribute-set  satisfies cyc:references $X, $X,    " >  This function isn’t tail-recursive. The recursive call is inside a loop  the «some» expression . However, this is unlikely to matter in this case, because the chains of references from one attribute set to another are likely to be short. An interesting observation about this function is that it is written entirely using constructs that are new in XSLT 2.0 and XPath 2.0: stylesheet functions, type checking based on schema- deﬁned types, atomization of a list-valued attribute, the   instruction that allows XSLT instructions to return values other than nodes, the XPath intersect and except operators, and the XPath some..satisfies expression.  For a more generalized function that looks for cycles in any source data ﬁle, regardless how the relation- ships are represented, see the section Simulating Higher Order Functions under   on page 240.  See Also   on page 483  xsl:if  The   instruction encloses a sequence constructor that will be evaluated only if a speciﬁed condition is true. If the condition is true, it returns the result of this evaluation; otherwise, it returns the empty sequence.  353     is analogous to the if statement found in many programming languages.  test = expression>       Position   is an instruction. It is always used within a sequence constructor.  Value XPath Expression  Meaning The boolean condition to be tested  XSLT Elements  Changes in 2.0 None.  Format  <xsl:if  Attributes Name test mandatory  Content A sequence constructor.  Effect The test expression is evaluated. If the effective boolean value of the result is true, the contained sequence constructor is evaluated; otherwise, no action is taken  an empty sequence is returned .  Any XPath expression may be evaluated to obtain an effective boolean value. In brief, the rules are:                    If the value is an empty sequence, then the result is false. If the value is a sequence whose ﬁrst item is a node, then the result is true. If the value is a singleton xs:boolean value, the result is that value. If the argument is a singleton numeric value, the result is false if the argument is NaN or zero; otherwise it is true. If the argument is a singleton instance of xs:string, xs:anyURI, or xs:untypedAtomic, the result is false if the string is zero length; otherwise, it is true. In all other cases, the result is an error.  These rules are the same as XPath itself uses in boolean contexts; for example, in «if» expressions and for the operands of the «and» and «or» operators. They are also the same as the rules used by the boolean   function, and they are designed to be fully compatible with XPath 1.0. Note that the effective boolean value of a sequence can be evaluated without looking beyond the second item in the sequence, which makes the rules very efﬁcient.  Usage The   instruction is useful where an action is to be performed conditionally. It performs the functions of the if-then construct found in other programming languages. If there are two or more  354   xsl:if  6  X S L T  l  E e m e n t s  alternative actions  the equivalent of an if-then-else, switch, or Select Case in other languages , use   instead.  One common use of   is to test for error conditions. In this case it is often used with  .  Try to avoid using   as the entire content of a template rule. It’s better to use a predicate instead, because this gives the processor more scope for optimization. For example:                   can be rewritten as:                 Of course, it’s always possible that the processor will perform this optimization anyway, but you can’t rely on it.   Examples The following example outputs an   element after processing the last of a sequence of   elements:                     The following example reports an error if the percent attribute of the current element is not a number between 0 and 100. The expression returns true if:              the percent attribute does not exist, the value cannot be interpreted as a number  so that «number @percent » is NaN , the numeric value is less than zero, or the numeric value is greater than 100.  <xsl:if test="not @percent  or   string number @percent  =’NaN’  or  number @percent  lt 0  or  number @percent  gt 100 ">  percent attribute must be a number between 0 and 100           355   XSLT Elements  The next example shows the use of   in the context of a complete stylesheet.  Example: Formatting a List of Names  This example formats a list of names, using   to produce punctuation that depends on the position of each name in the list.  The source ﬁle authors.xml contains a single   element with a list of authors:  Source     Stylesheet        Design Patterns   Erich Gamma   Richard Helm   Ralph Johnson   John Vlissides   The stylesheet authors.xsl processes the list of authors, adding punctuation depending on the position of each author in the list:  <xsl:transform  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" version="2.0">          by       ,    and    by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides          Output  Design Patterns  See Also   on page 282  356   xsl:import  xsl:impor t    is a top-level element used to import the contents of one stylesheet module into another. The declarations in the importing stylesheet module have a higher import precedence than those in the imported module, which usually means that they will be used in preference, but the detailed rules vary for each type of declaration.  Changes in 2.0 There are no changes to the syntax of this instruction in XSLT 2.0. The rules for the href attribute have been reformulated to reﬂect current practice with XSLT 1.0: In effect, the way in which the URI is deref- erenced to obtain a stylesheet module is now largely implementation deﬁned. This allows for options such as catalogs or user-speciﬁed URI resolvers, as well as implementations that cache or precompile stylesheet modules.  6  X S L T  l  E e m e n t s  Format  <xsl:import  href = uri-reference  >  Position   is a top-level element, which means that it must appear as a child of the   element. Within an   element, the   child elements must come before any other children.  Attributes Name href mandatory  Value URI  Meaning The URI of the stylesheet to be imported  Like all other XSLT elements, the   declaration may also have a «use-when» attribute. This is described in Chapter 3  see page 127 .  Content None; the element is always empty.  Effect The   declaration loads the stylesheet module identiﬁed in its href attribute. First, we’ll look at how this module is located and then at the question of import precedence, which determines how the declarations in the imported module are used.  Locating the Stylesheet Module The URI contained in the href attribute may be an absolute URI or a relative URI reference. If relative, it is interpreted relative to the base URI of the XML document or external entity containing the   element. For example, if a ﬁle main.xsl contains the element   then the system will, by default, look for date.xsl in the same directory as main.xsl. You can change this behavior by using the xml:base attribute, as described in Chapter 2 on page 54. This allows you to specify a different base URI for resolving the relative reference.  357   XSLT Elements  The URI, once resolved, must identify an XML document that is a valid XSLT stylesheet module. The declarations in the imported stylesheet are logically inserted into the importing stylesheet at the point where the   element appears. However:           Imported declarations have lower import precedence than the declarations that appear directly in the importing stylesheet, or are incorporated into it using  . This is explained in more detail below. Imported elements retain their base URI, so anything that involves resolving a relative URI ref- erence is done relative to the original URI of the imported stylesheet. This includes, for example, expansion of further   elements, or use of URIs as arguments to the document   function.    When a namespace preﬁx is used  typically within a QName, but it also applies to freestanding  preﬁxes such as those in the xsl:exclude-result-prefixes attribute of a literal result ele- ment , it is interpreted using only the namespace declarations in the original stylesheet module in which the QName occurred. An imported stylesheet module does not inherit namespace decla- rations from the module that imports it. This includes QNames constructed at execution time as the result of evaluating an expression; for example, an expression used within an attribute value template for the name or namespace attribute of  . The values of the version, extension-element-prefixes, exclude-result-prefixes, and xpath-default-namespace attributes that apply to an element in the imported stylesheet, as well as xml:lang and xml:space, are those that were deﬁned in the   element of their own stylesheet module, not those on the   element of the importing module.  The imported stylesheet module may use the simpliﬁed stylesheet syntax described in Chapter 3. This allows an entire module to be deﬁned as the content of an element such as  . It is then treated as if it were a stylesheet module containing a single template, whose match pattern is « » and whose content is the literal result element.  The imported stylesheet module may contain   declarations to include further stylesheet modules, or   statements to import them. A stylesheet module must not directly or indi- rectly import itself.  It is not an error to import the same stylesheet module more than once, either directly or indirectly, but it is not usually a useful thing to do. The effect is that the same deﬁnitions or templates will be present with several different import precedences. The situation is exactly the same as if two stylesheet modules with different names but identical contents had been imported.  The href attribute must be a ﬁxed value — it isn’t possible to compute its value at runtime. This is because the ﬁrst thing an XSLT processor does, long before any source document is available, is to assemble the stylesheet from all its constituent modules and compile it into some internal representation. However, there is a new facility in XSLT 2.0 that allows stylesheets to be tailored to different environ- ments. The «use-when» attribute is allowed on    and indeed on any other XSLT element  to deﬁne a compile-time condition deﬁning whether this element should be included or ignored. For example, you can write:  <xsl:import href="altova-rules.xsl"  <xsl:import href="gestalt-rules.xsl"  use-when="system-property ’xsl:product-name’  = ’Altova XSLT Engine’" >  use-when="system-property ’xsl:product-name’  = ’Gestalt’" >  358   xsl:import  <xsl:import href="saxon-rules.xsl"  use-when="system-property ’xsl:product-name’  = ’SAXON’" >  to import different modules depending on whether you are running Saxon, Gestalt, or AltovaXML.  See product-switch.xsl in the downloaded code for a full version of the stylesheet .  If you use a relative URI reference in the href attribute, and the system can’t resolve it, check that the base URI of the main stylesheet module is known. If you’re using the JAXP API for invoking a transformation, a common mistake occurs when you supply the main stylesheet as a StreamSource object. If you do this, you need to call the setSystemId   method to ensure that the system knows where the input stream comes from. Similar problems often arise on the Microsoft platform if you supply the stylesheet in the form of a DOM Document.  Determining the Import Precedence Each stylesheet module that is imported has an import precedence. The rules are:        The precedence of a module that is imported is always lower than the precedence of the module importing it. If one module imports several others, then the one it imports ﬁrst has lower precedence than the next, and so on.  This means that in the structure shown in Figure 6-3, the highest precedence module is A followed by C, F, B, E, and ﬁnally D. The numbers on the diagram illustrate this. The absolute values have no signiﬁcance, it is only the relative order of import precedence that matters.  6  X S L T  l  E e m e n t s  1  2  4  D  E  F  3  B  import D import E  5  C  import F  6  A  import B import C  Figure 6-3  If one stylesheet module incorporates another using   rather than  , it has the same import precedence as the module that includes it  see Figure 6-4 .  Here J is included in E, so it has the same import precedence as E, and similarly E has the same import precedence as C.  359   XSLT Elements  6  A  import B import C  3  B  2  D  import D  import F include G  5  C  5  E  include E  import H include J  1  2  4  5  F  G  H  J  Figure 6-4  The import precedence of a stylesheet module applies to all the declarations in that module, so for example the   elements in module E have a higher import precedence than those in G.  As   statements must occur before any other declarations in a stylesheet module, the effect of these rules is that if each   statement were to be replaced by the content of the mod- ule it imports, the declarations in the resulting combined stylesheet would be in increasing order of import precedence. This makes life rather easier for implementors. However, it does not mean that   is a straightforward textual substitution process, because there is still a need to distin- guish cases where two objects  for example template rules  have the same import precedence because they came originally from the same stylesheet or from stylesheets that were included rather than imported.  The XSLT 2.0 speciﬁcation introduces the concept of a stylesheet layer, which is a group of stylesheet modules that have the same import precedence because they refer to each other using   rather than  . In the example above modules D and G are in the same layer; C, E, and J are in the same layer, and each of the other modules is in a layer of its own. Within a stylesheet layer the speciﬁcation describes the concept of declaration order, which is the order that the declarations  top-level elements  would appear in if included stylesheets were expanded at the point of the   statement. The stylesheet layers  rather than modules  are considered to form a tree, with   elements acting as the links from a parent to a child in the tree.  The stylesheet tree for the example above is shown in Figure 6-5.  The concepts of stylesheet levels, declaration order, and the stylesheet tree have been used to tighten up the speciﬁcation of how instructions such as   work. For example, an   instruction in module J can invoke a template in module H, because H is in a stylesheet layer that is a descendant of the layer that J is in.  360   xsl:import  6  X S L T  l  E e m e n t s  import D  import F include G  2 D  E  import H include J  3  B  C  include E  5  1  4  F  G  H  J  6  A  import B import C  Figure 6-5  Effect of Import Precedence The import precedence of a declaration affects its standing relative to other declarations of the same type, and may be used to resolve conﬂicts. The effect is as shown in the table below for each kind of declaration. Element type     Rules If there are two attribute sets with the same expanded name, they are merged. If there is an attribute that is present in both, then the one from the attribute set with higher import precedence wins. If there are two or more values for an attribute that have the same precedence, and this is the highest precedence, the XSLT processor chooses the one that was speciﬁed last  for a more precise deﬁnition of what ‘‘last’’ means, see   on page 266 .  If there are several   declarations with the same name, then the one with highest import precedence wins. It is an error if this leaves no clear winner.  All the   elements in the stylesheet that share the same name are effectively merged. For each attribute, if the value is explicitly present on more than one   element, then the one with highest import precedence wins. It is an error if there is no clear winner.  If there are several   declarations with the same name and arity  number of arguments , then the one with highest import precedence wins. It is an error if this leaves no clear winner.  continued 361              If there are several   declarations for the same target  XSLT Elements  Element type          <xsl:namespace- alias>       <xsl:preserve- space>          362  Rules No conﬂicts arise; the import precedence of these elements is immaterial, except in determining the import precedence of the referenced stylesheet module.  namespace  or for no target namespace  then the one with highest import precedence wins. If this leaves more than one, then the rules are deﬁned by reference to the XML Schema speciﬁcations, which give implementations a great deal of latitude. All the key deﬁnitions are used, regardless of their import precedence. See   on page 376 for details. If several aliases for the same stylesheet preﬁx are deﬁned, the one with the highest import precedence is used. It is an error if there is no clear winner. All the   elements in the stylesheet that share the same name are effectively merged. In the case of the cdata-section-elements and use-character-maps attributes, the values from all the   elements are merged. For all the other attributes, if the value is explicitly present on more than one   element, then the one with highest import precedence wins. It is an error if there is no clear winner. If there is more than one   or   element that matches a particular element name in the source document, then the one with highest import precedence is used. If this still leaves several that match, each one is assigned a priority, using the same rules as for the match pattern in  . Speciﬁcally, an explicit QName has higher priority than the form «prefix:*», which in turn has higher priority than «*». The one with highest priority is then used. It is an error if this leaves more than one match, unless they all give the same answer. When selecting a template rule for use with  , ﬁrstly all the template rules with a matching mode are taken. Of these, all those with a match pattern that matches the selected node are considered. If this leaves more than one, only those with the highest import precedence are considered. If this still leaves more than one, the one with highest priority is chosen: The rules for deciding the priority are given under   on page 483. It is an error if this still doesn’t identify a clear winner. The XSLT processor has the choice of reporting the error or choosing the template rule that was speciﬁed last.  In practice, several processors output a warning message .  In the case of named templates, if there are several   declarations with the same name attribute, then the one with highest import precedence wins. It is an error if this leaves no clear winner. If there are several global   or   declarations with the same name, then the one with highest import precedence wins. It is an error if this leaves no clear winner.   xsl:import  Usage The rules for   are so pervasive that one would imagine the facility is central to the use of XSLT, rather in the way inheritance is central to writing in Java. In practice, many stylesheets never need to use  , but you will almost certainly need it once you start to develop a family of stylesheets to handle a wide range of source document types.  Like inheritance in object-oriented languages,   is designed to allow the creation of a library or reusable components, only in this case, the components are modules of stylesheets. And the mecha- nism works in a very similar way to inheritance. For example, you might have a stylesheet that simply deﬁnes your corporate color scheme, as a set of global variables deﬁning color names. Another stylesheet might be deﬁned to produce the basic framesets for your site, referring to these color names to supply the background detail. Now if you want to use this general structure but to vary some detail, for example to modify one of the colors because it clashes with an image you are displaying on a particular page, you can deﬁne a stylesheet for this particular page that does nothing apart from redeﬁning that one color. This is illustrated in Figure 6-6.  6  X S L T  l  E e m e n t s  General Purpose Stylesheet  A  B  General Purpose Stylesheet  General Purpose Stylesheet  C  Corporate  Color  Definitions  Special Purpose Stylesheet  Z  Figure 6-6  Suppose the stylesheet module for corporate color deﬁnitions looks like this:  <xsl:stylesheet xmlns:xsl="http:  www.w3.org 1999 XSL Transform"  xmlns:color="http:  acme.co.nz colors" version="2.0">           Now all the general-purpose stylesheets could   these deﬁnitions  without the need to   them unless they are being modiﬁed . This makes it easier to maintain the corporate brand image, because things are deﬁned in one place only.  363   XSLT Elements  However, there are cases where you would want to depart from the general rule, and you can do so quite easily. If a particular document needs to use stylesheet C, but needs to vary the colors used, you can deﬁne stylesheet Z for it, as follows:  <xsl:stylesheet xmlns:xsl="http:  www.w3.org 1999 XSL Transform"  xmlns:color="http:  acme.co.nz colors" version="1.0">         In fact, this might be the entire stylesheet. In common English, style Z is the same as style C but with a different shade of lilac. Note that all the references to variable «color:lilac» are interpreted as ref- erences to the deﬁnition in Z, even if the references occur in the same stylesheet module as a different deﬁnition of «color:lilac».  As a general principle, to incorporate standard content into a stylesheet without change, use  . If there are declarations you want to override, use  .  Examples The ﬁrst example is designed to show the effect of   on variables.  Example 1: Precedence of Variables  This example demonstrates the precedence of global variables when the principal stylesheet module and an imported module declare variables with the same name.  This example can be run with any source XML ﬁle.  Source  Stylesheet  The principal stylesheet module is variables.xsl.    <xsl:stylesheet version="2.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" xmlns:acme="http:  acme.com xslt" exclude-result-prefixes="acme">                      The imported stylesheet module is boilerplate.xsl.  364   xsl:import    <xsl:stylesheet version="2.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" xmlns:co="http:  acme.com xslt"> <xsl:variable name="co:company-name"  select="’Acme Widgets Incorporated’" >  <xsl:variable name="co:copyright"  select="concat ’Copyright   ’, $co:company-name " >     Output  The output of this stylesheet will be:     Copyright   Acme Widgets Limited   6  X S L T  l  E e m e n t s  This is because in the variable declaration of «$co:copyright», the reference to variable «$co:company-name» matches the declaration of this variable in the principal stylesheet, because this has higher import precedence than the declaration in boilerplate.xsl. The fact that different namespace preﬁxes are used in the two stylesheets is, of course, irrel- evant: The preﬁx «acme» in the principal stylesheet maps to the same namespace URI as the preﬁx «co» in boilerplate.xsl, so the names are considered equivalent. This example explicitly speciﬁes encoding = "iso-8859-1" for both the stylesheet modules and the output. Most of my examples only use ASCII characters, and since the default char- acter encoding UTF-8 is a superset of ASCII, this works ﬁne. This time, though, I’ve used the copyright symbol « », which is not an ASCII character, so it’s important to specify the character encoding that my text editor uses, which is iso-8859-1. The second example shows the effect of   on template rules.  Example 2: Precedence of Template Rules  In this example I shall deﬁne a complete stylesheet standard-style.xsl to display poems in HTML, and then override one of its rules in an importing stylesheet. The ﬁles required are all in the subdirectory import in the download ﬁle for this chapter.  Source  This example works with the poem that we used in Chapter 1. In the download ﬁle it’s available as poem.xml. It starts like this:       Rupert Brooke   1912   365   XSLT Elements   Song     And suddenly the wind comes soft,   And Spring is here again;   And the hawthorn quickens with buds of green   And my heart with buds of pain.    etc.    Stylesheet A  Here is standard-style.xsl:  <xsl:stylesheet version="2.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform">                                               by                                    When you run this stylesheet, the output starts like this  indented for clarity :     Song    by Rupert Brooke   Output A             366   xsl:import   Song      And suddenly the wind comes soft,  And Spring is here again;  And the hawthorn quickens with buds of green  And my heart with buds of pain.      Stylesheet B  Now we want to create a variant of this in which the lines of the poem are numbered. This will act as the principal stylesheet when you want this form of output. Here it is in numbered-style.xsl:  <xsl:stylesheet version="2.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform">        &xa0;&xa0;         Note the use of the character reference «&xa0;» to output a nonbreaking space. In HTML this is normally done by writing «&nbsp;» . You can use this entity reference in the stylesheet if you like  it’s simply a symbolic name for the Unicode character XA0 , but only if you declare it as an entity in the DTD. It’s usually simpler just to use the numeric character reference.  Output B  This time the output starts like this. Again, the precise format depends on the processor  for example, some processors may output «&xa0;», or «&160;» instead of «&nbsp;» , but it should look the same when displayed in the browser:  6  X S L T  l  E e m e n t s        Song         by Rupert Brooke   Song     001&nbsp;&nbsp; And suddenly the wind comes soft,  002&nbsp;&nbsp; And Spring is here again;  003&nbsp;&nbsp; And the hawthorn quickens with buds of green  004&nbsp;&nbsp; And my heart with buds of pain.      367   XSLT Elements  All the template rules deﬁned in standard-style.xsl are used as normal, except where the current node matches the pattern «line». In this situation there are two possible templates that match the node, so the one with higher import precedence is chosen. This is the one in the importing stylesheet module, namely numbered-style.xsl. As a result, the lines of the poem are output with a preceding line number, calculated using the   instruction, which is described on page 403. The use of   means that once the line number has been output, the line is displayed in the normal way, using the template rule from the standard-style.xsl stylesheet.  This use of   to customize the presentation produced by a stylesheet is very common. The rules in the importing stylesheet, which vary the standard presentation, are sometimes referred to as a customization layer. Another term used is stylesheet overlay. Sometimes the customization layer corresponds directly to an additional module in the schema or DTD: For example, if the schema that you use for press releases is an extended version of the schema used for general company documents, then you will want to write a customization layer over the general-purpose stylesheet to handle the additional features found in press releases.    is a top-level declaration used to identify a schema containing deﬁnitions of types that are referred to in the stylesheet. This declaration is available only in a schema-aware processor.  See Also   on page 372   on page 237  xsl:impor t-schema  Changes in 2.0 This element is new in XSLT 2.0.  Format  <xsl:import-schema  namespace? = uri-reference schema-location? = uri-reference>       If the   contains an inline schema    element , then the schema-location attribute must be omitted.  Position   is a top-level declaration, which means that it must appear as a child of the   element. There are no constraints on its ordering relative to other declarations in the stylesheet.  368   Attributes Name namespace optional  schema-location optional  xsl:import-schema  Value Meaning URI  The namespace URI of the schema to be imported  URI  A URI identifying the location of the schema to be imported  6  X S L T  l  E e m e n t s  Content The   element may contain an inline schema document, represented by an   element  whose content in turn is as deﬁned in the XML Schema speciﬁcation .  Effect If the stylesheet contains references to user-deﬁned types, then the namespace in which these types are deﬁned must be imported using an   declaration. The same applies to user-deﬁned element and attribute declarations.  Importing a schema makes the schema deﬁnitions available throughout the stylesheet, not only in the module where they are imported.  This differs from XQuery 1.0, where different modules may import different schemas.   As with  , the   declaration states an intention to use schema com- ponents in a particular namespace, and it optionally gives a ‘‘hint’’ to the processor to indicate where deﬁnitions of those schema components may be found. You should explicitly import a schema document for every namespace that contains a deﬁnition that you want to refer to in the stylesheet. Importing a schema does not implicitly import other namespaces that are referenced from that schema using  .  The XSLT speciﬁcation deﬁnes the way that schema import works in terms of the way that the XML Schema speciﬁcation deﬁnes  . This leaves a great deal of discretion to the implementation. It is quite likely that an XSLT processor will want to cache schemas somewhere in a compiled form, to avoid analyzing them afresh every time a stylesheet is processed; many systems may also use catalogs or data dictionaries of some kind so that a local copy of a schema can be accessed rather than retrieving it over the Internet. The exact way in which the ‘‘hint’’ in the schema-location attribute is used is therefore very open-ended.  Although the terminology differs, this is not actually any different from the way the href attribute in   and   is handled. Reﬂecting common practice established with XSLT 1.0, the XSLT speciﬁcation now recognizes that implementations can provide URI resolvers or catalogs to interpret these URIs, and that it is therefore impossible to be completely prescriptive about their interpretation.  Using an inline schema document is exactly the same as putting the schema in a separate XML document and referencing it in the schema-location attribute. It’s convenient to have the schema inline, however, if it contains deﬁnitions that are used only within this stylesheet, perhaps to deﬁne the structure of some working data or some constraints on a particular function parameter. If an   declaration contains an inline schema document, then the schema-location attribute must be omitted. You can also omit the namespace attribute  if you don’t, then it must match the targetNamespace of the inline schema .  369   XSLT Elements  In other cases, omitting the namespace attribute indicates that you want to import a schema that has no target namespace  that is, a schema for elements that are in no namespace . The namespace attribute should not be set to a zero-length string, since this is not a valid namespace URI.  If the schema-location attribute is omitted, and if there is no inline schema document, then it is assumed that the implementation will be able to locate a schema from knowledge of the target namespace alone.  It’s not technically an error if no schema for the requested namespace can be found. But in practice this will usually trigger an error because the stylesheet will then contain references to schema deﬁnitions that haven’t been imported.  It is a fatal error, however, if a schema can be found and it isn’t valid according to the XML Schema speciﬁcations.  If there are multiple   declarations for the same target namespace  or for the ‘‘null namespace’’ , then the one with highest import precedence is used. Import precedence is explained under   on page 357. If this leaves more than one, then the behavior is deﬁned by reference to the XML Schema speciﬁcation: it’s deﬁned to be the same as when a schema document contains more than one   element for the same namespace. In practice, the schema speciﬁcation leaves a lot of discretion to implementations on how to handle this. Some implementations may load multiple schema modules and check them for consistency; others  including Saxon  simply take the ﬁrst one and assume that the others are equivalent.  Consistency rules for schemas extend beyond the question of multiple imports from a single stylesheet. The schema that’s imported into the stylesheet must be consistent with the schema used to validate the source document. Since many systems will allow compiled schemas to be cached, probably sharing the cache between many different stylesheets, there is likely to be a more global consistency requirement. In general, it’s probably not possible to have two different versions of the same schema  or to put it another way, two different schemas with the same target namespace, or with no target namespace  in use at the same time. Use of   can potentially cause problems if you use the base deﬁnitions to compile the stylesheet and then use a redeﬁned version to validate the source document. The details, however, are left to the implementation.  If a processor that is not schema-aware encounters an   declaration, it will report an error. If you want to write stylesheets that work with both schema-aware and non-schema-aware pro- cessors, you can achieve this by attaching the attribute «use-when="system-property  ’xsl:schema-aware’ =’yes’ "» to any element that should be ignored by a non-schema-aware pro- cessor  that is, the   declaration itself, and any element that uses a «type» or «validation» attribute, or references a schema-deﬁned type . Of course, you will also have to provide an alternative element for use in this case.  Usage It’s not necessary to import every schema that has been used to validate an input document. You only need to import the schema if there is code in the stylesheet that actually references the names whose meaning is deﬁned in the schema.  The places where such references may occur are as follows:     In the type attribute of  ,  ,  ,  ,  ,  , and the xsl:type attribute of literal result ele- ments. This is always a QName identifying a top-level type deﬁnition, and unless it is one of the built-in types such as xs:integer, the schema in which the type is deﬁned must be imported.  370   xsl:import-schema              In the «as» attribute of  ,  ,  ,  , and  . The value of this attribute is a description of an XPath type and is expressed using the SequenceType syntax deﬁned in Chapter 11. If the SequenceType refer- ences the name of an atomic type, this will be a QName identifying either a built-in type such as xs:date, or a top-level simple type deﬁnition in a schema. If the latter is the case, the schema must be imported. If the SequenceType uses the constructs «element N, T » or «attribute  N, T » then the rules are slightly more complicated, and are described below. In an XPath expression anywhere in the stylesheet that uses a SequenceType. This construct is used in expressions such as «$x instance of T» or «$x treat as T». The rules here are the same as for a SequenceType appearing in an «as» attribute, as described in the previous item. In an XPath expression that uses a constructor function for a user-deﬁned atomic type  for example «mf:part-number ’PXW5792’ »  or a cast to a user-deﬁned atomic type  for example «’PXW5792’ cast as mf:part-number» . In both these cases, the type name must be the name of a top-level simple type deﬁnition, and the schema containing this type deﬁnition must be imported. If you use the option «validation="strict"» or «validation="lax"», then you may be required to import the schema used to perform this validation, even if there are no explicit ref- erences in the stylesheet to the names deﬁned in this schema. The XSLT speciﬁcation leaves it open to the implementation to use other mechanisms to locate a schema at runtime to perform this validation, but if you import the schema explicitly, then you avoid any dependence on such mechanisms.  6  X S L T  l  E e m e n t s  When the construct «schema-element N » or «schema-attribute N » is used in a SequenceType, then N must be the name of a global element or attribute declaration deﬁned in an imported schema. Similarly, when the constructs «element N, T » or «attribute N, T » are used, then T must be the name of a simple or complex type deﬁned in an imported schema, unless it is the name of a built-in type. But in these constructs the name N does not need to be present in the schema; this allows reference to local elements and attributes provided that they have a global type deﬁnition.  For example, if you create an element like this:           you will later be able to match this using:     even though there is no imported schema deﬁning the element name «temp».  Examples This example imports the schema for namespace «http:  ns.megacorp.com hr» from the location «http:  schema.megacorp.com hr schema.xsd»:  <xsl:import-schema  namespace = "http:  ns.megacorp.com hr" schema-location = "http:  schema.megacorp.com hr schema.xsd" >  371   XSLT Elements  The following example imports a no-namespace schema from the ﬁle «schema.xsd» in the same directory as the stylesheet:  <xsl:import-schema  schema-location = "schema.xsd" >  The following example imports the schema that deﬁnes the structure of XSLT stylesheets.  This import would be useful only in a stylesheet that is designed to process XSLT stylesheets as its input and or result documents. .  <xsl:import-schema  namespace = "http:  www.w3.org 1999 XSL Transform" schema-location="http:  www.w3.org 2007 schema-for-xslt20.xsd" >  The following example deﬁnes a union type for use locally within the stylesheet. This type allows either an xs:date, an xs:time, or an xs:dateTime:                       This type might be used in the signature of a function that applies default formatting to the value, as follows:                                         xsl:include  372  The full stylesheet is in ﬁle inline.xsl. Unfortunately it’s not possible to use the union type directly as a parameter to the function  «as="local:dateOrTime"»  — although the meaning is intuitive, union types cannot appear directly in a SequenceType, only as a type annotation on element or attribute nodes.    is a top-level element used to include the contents of one stylesheet module within another. The deﬁnitions in the included stylesheet module have the same import precedence as those in the including module, so the effect is as if these deﬁnitions were textually included at the point in the including module where the   element appears.   6  X S L T  l  E e m e n t s  xsl:include  Changes in 2.0 There are no changes to the syntax of this instruction in XSLT 2.0. The rules for the href attribute have been reformulated to reﬂect current practice with XSLT 1.0: In effect, the way in which the URI is deref- erenced to obtain a stylesheet module is now largely implementation deﬁned. This allows for options such as catalogs or user-speciﬁed URI resolvers, as well as implementations that cache or precompile stylesheet modules.  Format  <xsl:include  href = uri-reference  >  Position   is a top-level declaration, which means that it must appear as a child of the   element. There are no constraints on its ordering relative to other declarations in the stylesheet.  Attributes Name href mandatory  Value URI  Meaning The URI of the stylesheet to be included  Like all other XSLT elements, the   declaration may also have a «use-when» attribute. This is described in Chapter 3  see page 127 . This can be used in the same way as on  : see the example on page 358.  Content None; the element is always empty.  Effect The URI contained in the href attribute may be an absolute URI or a relative URI reference. If rela- tive, it is interpreted relative to the base URI of the XML document or external entity containing the   element. For example, if a ﬁle main.xsl contains the element <xsl:include href= "date.xsl" >, then by default the system will look for date.xsl in the same directory as main.xsl. You can change this behavior by using the xml:base attribute to specify a base URI explicitly, as described in Chapter 2 on page 54.  The URI  once resolved  must identify an XML document that is a valid XSLT stylesheet. The top-level elements of this stylesheet are logically inserted into the including stylesheet module at the point where the   element appears. However:     These elements retain their base URI, so anything that involves resolving a relative URI refer- ence is done relative to the original URI of the included stylesheet. This rule applies, for example, when expanding further   and   elements, or when using relative URIs as arguments to the document   function.    When a namespace preﬁx is used  typically within a QName, but it also applies to freestanding  preﬁxes such as those in the xsl:exclude-result-prefixes attribute of a literal result ele- ment , it is interpreted using only the namespace declarations in the original stylesheet module  373   XSLT Elements     in which the QName occurred. An included stylesheet module does not inherit namespace declarations from the module that includes it. This even applies to QNames constructed at exe- cution time as the result of evaluating an expression, for example an expression used within an attribute value template for the name or namespace attribute of  . The values of the version, extension-element-prefixes, exclude-result-prefixes, and xpath-default-namespace attributes that apply to an element in the included stylesheet mod- ule, as well as xml:lang, xml:base, and xml:space, are those that were deﬁned on their own   element, not those on the   element of the including stylesheet module.  The included stylesheet module may use the simpliﬁed stylesheet syntax, described in Chapter 3. This allows an entire stylesheet module to be deﬁned as the content of an element such as  . It is then treated as if it were a module containing a single template, whose match pattern is « » and whose content is the literal result element.  The included stylesheet module may contain   statements to include further stylesheets, or   statements to import them. A stylesheet must not directly or indirectly include itself.  It is not an error to include the same stylesheet module more than once, either directly or indirectly, but it is not a useful thing to do. It may well cause errors due to the presence of duplicate declarations; in fact, if the module contains deﬁnitions of global variables or named templates and is included more than once at the same import precedence, such errors are inevitable.  Usage and Examples   provides a simple textual inclusion facility analogous to the include directive in C. It provides a way of writing a stylesheet in a modular way so that commonly used deﬁnitions can be held in a library and used wherever they are needed.  If you are handling a wide range of different document types, the chances are they will have some elements in common, which are to be processed in the same way regardless of where they occur. For example, these might include standard deﬁnitions of toolbars, backgrounds, and navigation buttons to appear on your Web pages, as well as standard styles applied to data elements such as product names, e-mail contact addresses, or dates.  To incorporate such standard content into a stylesheet without change, use  . If there are deﬁnitions you want to override, use  .    is a compile-time facility; it is used to assemble the complete stylesheet before you start executing it. People sometimes ask how to include other stylesheets conditionally at runtime, based on conditions found in the source document. The answer is simple: you can’t. It would be like writ- ing a program in Visual Basic that modiﬁes itself as it executes. If you do want different sets of rules to be active at different times, consider using modes, or consider inverting the logic, so that instead of having an all-purpose stylesheet that tries to include different sets of rules on different occasions, you make your principal stylesheet module the one that is most closely tailored to the circumstances, and use   to import the all-purpose rules into it, at a lower import precedence than the specialized rules.  It can make a difference where in your stylesheet the   statement is placed. There are some kinds of objects — notably, template rules — where if there is no other way of deciding which one to use, the XSLT processor has the option of giving priority to the one that occurs last in the stylesheet. This isn’t something you can easily take advantage of, because in all these cases the processor also has the option  374   xsl:include  of reporting an error. As a general principle, it’s probably best to place   statements near the beginning of the ﬁle, because then if there are any accidental overlaps in the deﬁnitions, the ones in your principal stylesheet will either override those included from elsewhere, or be reported as errors.  Example: Using   with Named Attribute Sets  This example shows the use of   to incorporate declarations  in this case of a named attribute set  from one stylesheet module into another.  Source  Stylesheet  This example can be used with any source document, or with none, if you start execution with the named template main.  Consider a principal stylesheet picture.xsl that includes a stylesheet attributes.xsl, as follows:  6  X S L T  l  E e m e n t s  <xsl:stylesheet version="2.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform">           red           This includes the module attributes.xsl:  <xsl:stylesheet version="2.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform">      blue   100        The named attribute set in the included stylesheet is used exactly as if it were deﬁned in the principal stylesheet, at the point where the   statement appears.  Output  The resulting output is:     This is because attributes generated using   override those generated by using a named attribute set; it has nothing to do with the fact that the attribute set came from an included stylesheet.  375   XSLT Elements  See Also   on page 357  xsl:key  The   element is a top-level declaration used to declare a named key, for use with the key   function in expressions and patterns.  Changes in 2.0 The restrictions on using global variables in the match and use attributes have been eased.  It is now possible to deﬁne keys of any type  for example numbers or dates  and to a specify a collation to be used when deciding whether two string-valued keys match.  The key values for a node can now be evaluated using a sequence constructor contained in the   element, as an alternative to using the use attribute. This allows the evaluation to invoke templates or other XSLT constructs such as  .  Format  <xsl:key  name = qname match = pattern use? = expression collation? = uri>       Position   is a top-level declaration, which means that it must be a child of the   element. It may appear any number of times in a stylesheet.  Value Lexical QName  Meaning The name of the key  Pattern  Deﬁnes the nodes to which this key is applicable  XPath Expression  The expression used to determine the value of the key for each of these nodes  URI  The name of a collation used to compare string-valued keys  The syntax for a Pattern is deﬁned in Chapter 12.  The use attribute and the sequence constructor are mutually exclusive: if the use attribute is present, the element must be empty, and if it is absent, then there must be a nonempty sequence constructor.  Attributes Name name mandatory  match mandatory  use optional  collation optional  376   xsl:key  Content A sequence constructor. This is used as an alternative to the use attribute to determine the value of the key.  Effect The name attribute speciﬁes the name of the key. It must be a valid lexical QName; if it contains a name- space preﬁx, the preﬁx must identify a namespace declaration that is in scope on the   element. The effective name of the key is the expanded name, consisting of the namespace URI and the local part of the name.  The match attribute speciﬁes the nodes to which the key applies. The value is a Pattern, as described in Chapter 12. If a node doesn’t match the pattern, then it will have no values for the named key. If a node does match the pattern, then the node will have zero or more values for the named key, as determined by the use attribute or the contained sequence constructor.  6  X S L T  l  E e m e n t s  The simplest case is where each node has one key value, and the key values are unique. For example, consider the following source document:             In the stylesheet you can deﬁne a key for the registration number of these vehicles, as follows:     The use attribute  or in its absense, the contained sequence constructor  speciﬁes an expression used to determine the value or values of the key. This expression doesn’t have to select an attribute, like «@reg» in the example above. For example, it could select a child element. It could also be a computed value, such as «count * »  the number of child elements that the node has . If the value is a sequence, the system creates an index entry for each item in the sequence, and the node can be found using any one of these values.  If the use expression returns nodes, the nodes will be atomized. The resulting values can be of any atomic type, or a mixture of different atomic types. When you use the key   function to search for a node, the value you supply is compared with the indexed values according to the rules of the XPath «eq» operator. Generally, this means you must supply a value of the right type: for example, if the indexed value is an integer, and you search for a string, then you won’t ﬁnd anything. However, the usual type conversions occur automatically: numbers such as integers and doubles can be compared with each other, and xs:untypedAtomic values can be compared to strings.  In backward-compatibility mode  when the stylesheet speciﬁes «version="1.0"» , both the values returned by the use expression and the values supplied to the key   function are converted to strings and are compared as strings. This means you won’t get a match between different representations of the same number, such as «1» and «001», but you will get a match between the number «1» and the string «"1"».  The collation attribute identiﬁes a collation that will be used when the key value is a string. If no collation is speciﬁed, a default collation is used  this will usually be the Unicode Codepoint Collation,  377   XSLT Elements  described below . Collations are discussed under   on page 459. You need to decide whether you want to use a weak collation, in which strings such as «ASCII» and «ascii» are considered equiva- lent, or a strong collation, in which they are considered to be different. You might also need to consider what language should be used to deﬁne the matching rules. One of the options, which might be the best choice when you are comparing strings such as part numbers, is to use the Unicode Codepoint Collation, which considers two strings to be equal only if they use the same Unicode characters, as identiﬁed by their codepoint values. You can request this using the collation URI:  http:  www.w3.org 2005 xpath-functions collation codepoint  XSLT 2.0 allows the pattern in the match attribute, and the expression in the use attribute, to reference global variables and to use the key   function to access other keys. But the deﬁnitions must not be cir- cular; for example, if a key K makes use of the global variable V, then the value of V must not depend in any way on the key K.  There is no rule that stops two nodes having the same key value. For example, declaring a key for vehi- cle registration numbers in the example above does not mean that each registration number must be different. So a node can have more than one key value, and a key value can refer to more than one node.  To complicate things a bit further, there can be more than one   declaration in the stylesheet with the same name. The set of indexed values for the key is then the union of the sets produced by each   declaration independently. The import precedence of the key declarations makes no differ- ence. All the   declarations with a given name must have the same values for the collation attribute, if present.  A key can be used to select nodes in any document, not just the principal source document. This includes a temporary document constructed within the stylesheet.  The effect of calling «key K, V, R », where K is a key name, V is a value, and R is a node, is to select every node N that satisﬁes all the following conditions:           The node N must be in the subtree rooted at R, that is, it must have R on its ancestor- or-self axis. The node N must match the pattern deﬁned in the match attribute of an   deﬁnition named K. One of the values in the sequence V must be equal to one of the values in the sequence obtained by evaluating the use attribute  or sequence constructor  of that key deﬁnition, with N as the context node. Values are compared using the XPath «eq» operator, with the speciﬁed collation.  If there are several nodes that satisfy these conditions, they are returned in document order, with duplicates eliminated.  If the third argument R is omitted, its effective value is « », which means that the function searches the whole of the document containing the context node.  Usage and Examples Declaring a key has two effects: it simpliﬁes the code you need to write to ﬁnd the nodes with given values, and it is likely to make access faster.  The performance effect, of course, depends entirely on the implementation. It would be quite legitimate for an implementation to conduct a full search of the document each time the key   function was called.  378   xsl:key  In practice, however, most implementations are likely to build an index or hash table, so there will be a one-time cost in building the index  for each document , but after this, access to nodes whose key value is known should be very fast.  The   element is usually used to index elements, but in principle it can be used to index any kind of node except namespace nodes.  Keys versus IDs An alternative to using keys is to use XML-deﬁned IDs. If you have attributes deﬁned in a DTD or schema as being of type ID, you can ﬁnd an element with a particular ID value using the id   function described in Chapter 13.  Why would you prefer to use keys, rather than relying on ID values? Keys have many advantages:                    ID values must be simple attributes of the elements they identify, they cannot be anything more complex. ID values must be unique. You cannot have two different sets of ID values in the same document, for example ISBNs and acquisition numbers; if you do, you have to be sure they will not clash with each other. ID values must take the form of XML names, for example they cannot contain characters such as « » and «+». ID values are not recognized in a source document unless it is parsed with a validating XML parser or schema processor that reports attribute types to the XSLT processor. XML parsers are not required to behave in this way, so it is easy to end up with conﬁguration problems that result in IDs not being recognized. Recognizing ID attributes in temporary trees is particularly troublesome, as it requires the tem- porary tree to be validated.  6  X S L T  l  E e m e n t s  Using a Simple Key The detailed rules for keys seem complicated, but most practical applications of keys are very simple. Consider the following key deﬁnition:     This deﬁnes a key whose name is «product-code», and which can be used to ﬁnd   elements given the value of their code attribute. If a product has no code attribute, it won’t be possible to ﬁnd it using this key.  To ﬁnd the product with code value «ABC-456», you can write, for example:     Note that you could just as well choose to index the attribute nodes:     To ﬁnd the relevant product you would then write:     379   XSLT Elements  I’ve used   here as an example. This will select all the   elements in the current document that have code «ABC-456»  I never said it had to be a unique identiﬁer  and apply the matching template to each one in turn, processing them in document order, as usual. I could equally have used any other instruction that uses an XPath expression; for example, I could have assigned the node set to a variable, or used it in an   element.  The second argument to the key function should normally be a value of the same type as the use expres- sion in the   declaration. It won’t usually be a literal, as in my example, but is more likely to be a value obtained from somewhere else in the source document, or perhaps supplied as a parameter to the stylesheet. It may well have been passed as one of the parameters in the URL used to select this stylesheet in the ﬁrst place; for example, a Web page might display a list of available products such as the one in Figure 6-7.  Figure 6-7  Clicking the Buy Now! button might cause a URL such as the following to be sent to the server:  http:  www.naxos-breakfasts.com servlet buy?product="TK0372&quantity="1"  You then write a servlet  or an ASP.NET page if you prefer  on your Web server that extracts the query parameters code and quantity and ﬁres off your favorite XSLT processor specifying products.xml as the source document, show-product.xsl as the stylesheet, and «TK0372» and «1» as the values to be supplied for the global stylesheet parameter called prod-code and quantity. Your stylesheet might then look like the one that follows.                     There is no product with this code               380   xsl:key  Multivalued Keys A key can be multivalued, in that a single node can have several values, each of which can be used to ﬁnd the node independently. For example, a book may have several authors, and each author’s name can be used as a key value. This could be deﬁned as follows:     The use expression, «author name», selects more than one node, so the typed value of each of its nodes  that is, the name of each author of the book  is used as one of the values in the set of node-value pairs that makes up the key.  In this particular example, as well as one book having several authors, each author may have written several books, so when you use an XPath expression such as:     you will be selecting all the books in which Agatha Christie was one of the authors. What if you want to ﬁnd all the books in which Alex Homer and David Sussman are joint authors? You can do this using the intersect operator provided in XPath 2.0:  6  X S L T  l  E e m e n t s  <xsl:variable name="set1"  <xsl:variable name="set2"  select="key ’book-author’, ’Alex Homer’ " >  select="key ’book-author’, ’David Sussman’ " >  <xsl:variable name="result"  select="$set1 intersect $set2" >  You can also supply a sequence of several values as the second argument to the key   function. For example, you might write:       The result of the select expression in the   instruction is the set of all books in which one of the authors is either Agatha Christie or a co-author of Agatha Christie. This is because $ac is the set of all books in which Agatha Christie is an author, so «$ac author name» is the set of all authors of these books, and using this set of named authors as the value of the key produces the set of books in which any of them is an author.  Example: Multivalued Nonunique Keys  This example shows how a node can have several values for one key, and a given key value can identify more than one node. It uses author name as a key to locate   elements.  Source  The source ﬁle is booklist.xml:        Design Patterns   Erich Gamma   381   XSLT Elements   Richard Helm   Ralph Johnson   John Vlissides    Pattern Hatching   John Vlissides    Building Applications Frameworks   Mohamed Fayad   Douglas C. Schmidt   Ralph Johnson    Implementing Applications Frameworks   Mohamed Fayad   Douglas C. Schmidt   Ralph Johnson                       Stylesheet  The stylesheet is author-key.xsl. It declares the key and then simply copies the   elements that match the author name supplied as a parameter. You can run this stylesheet in Saxon with a call such as  all on one line : java -jar c:\saxon\saxon9.jar -s:booklist.xml -xsl:author-key.xsli  author="Ralph Johnson"  or in Altova  note the nested quotes :  AltovaXML -in booklist.xml -xslt2 author-key.xsli  -param author="’John Vlissides’"  or in Gestalt:  gestalt author-key.xsl booklist.xml author="John Vlissides"  Note that parameters containing spaces have to be written in quotes on the command line. In Altova, two pairs of quotes are needed, because the value supplied for the parameter is an XPath expression rather than a string.  <xsl:transform  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" version="2.0"  >        382           Output  With the parameter set to the value «John Vlissides», the output is as follows:        Design Patterns   Erich Gamma   Richard Helm   Ralph Johnson   John Vlissides            Pattern Hatching   John Vlissides   xsl:key  6  X S L T  l  E e m e n t s   In Altova, the result will not be indented, because the Altova processor discards whitespace text nodes from the input.   Multiple Named Keys There is nothing to stop you from deﬁning several keys for the same nodes. For example:       This allows you to ﬁnd a book if either the author or the ISBN is known.  However, it’s worth thinking twice before doing this. Assuming the XSLT processor implements the key by building an index or hash table, rather than by searching the whole document each time, you have to weigh the cost of building the index against the cost of ﬁnding the information by a search. If your transformation only needs to ﬁnd a single book using its ISBN number, it might be simpler and faster to write:     and not use a key at all. Some products  Saxon-SA for example  will even decide for themselves whether to build an index to speed up such an expression.  Multiple Deﬁnitions for the Same Key It’s also possible to have several   declarations with the same name. For example:         383   XSLT Elements  Now you can use the key   function in an expression such as:     The set of nodes this returns will be either   elements or   elements or a mixture of the two; the only thing you know for certain is that each one will be either a book with Ringo Starr as one of the authors, or a CD with Ringo Starr listed either as the composer or as a performer.  If the use expression were the same in each case, you could simplify this. For example to ﬁnd books and CDs with a particular publisher, you could write:     This example uses the union pattern «book  CD», which matches all   elements and all   elements. Union patterns are described on page 690 in Chapter 12.  The different deﬁnitions do not all need to be in the same stylesheet module; all the key deﬁnitions in included and imported stylesheets are merged together regardless of their import precedence.  Composite Keys Despite all the functionality we’ve been discussing, one thing that isn’t available directly is support for composite or multi-part keys, that is, ﬁnding an employee using both the last name and ﬁrst name in combination.  The simplest way to do this is by string concatenation. Deﬁne the key like this:     and search for it like this:  key ’k’, concat $first, ’’, $last    I chose «» here as a character that is unlikely to appear in the firstname or lastname values.  Using Keys for Grouping In XSLT 2.0, the new   instruction  described on page 326  provides facilities for grouping nodes with common values for a grouping key, or for eliminating nodes with duplicate values for a grouping key. In XSLT 1.0, this was a much more difﬁcult problem to solve, and you may well encounter XSLT 1.0 stylesheets that use the workaround for this problem known as Muenchian grouping, named after its inventor, Steve Muench of Oracle.  It shouldn’t be necessary to use Muenchian grouping any more in XSLT 2.0. However, since it is widely used and you may have the job of converting stylesheets that use it, or of writing stylesheets that work under both XSLT 2.0 and XSLT 1.0, it’s worth understanding how it works.  Say you want to group a list of employees according to their location. Typically, you want two nested loops, in pseudocode:              384   xsl:key  6  X S L T  l  E e m e n t s   details               Muenchian grouping uses a key to identify the distinct locations and then to identify all the employees at a given location. The key is deﬁned like this:     To ﬁnd the distinct locations, scan all the employee elements, and select only those that are the ﬁrst one in their location. In XSLT 2.0 you would write:     The «is» operator wasn’t available in XPath 1.0, so this had to be written as:  <xsl:for-each select=  "  employee[generate-id .  = generate-id key ’k’, location [1] ]">  The inner loop, which selects all the employees at the same location, is achieved by writing:     so the ﬁnal code becomes:  <xsl:for-each select=  "  employee[generate-id .  = generate-id key ’k’, location [1] ]">                         In XSLT 2.0 this can be rewritten much more readably as:  <xsl:for-each-group select="  employee" group-by="location"                         See Also key   function in Chapter 7, page 812   on page 326  385   The   element is used within an   instruction to indicate the processing that should be applied to substrings of the input string that match the supplied regular expression.  XSLT Elements  xsl:matching-substring  Changes in 2.0 This element is new in XSLT 2.0.  Format           Attributes None.  Content A sequence constructor.  Usage and Examples See   on page 230.  See Also   on page 230   on page 402  xsl:message  Position   can only appear as a child of an   element, and it may not appear more than once.  Effect The sequence constructor contained in the   element is evaluated once for each substring of the input string that matches the regular expression. The result of evaluating the sequence constructor is added to the result of the containing   instruction.  The   instruction outputs a message, and optionally terminates execution of the stylesheet.  Changes in 2.0 The terminate attribute may now be speciﬁed as an attribute value template.  The select attribute is new in XSLT 2.0.  386   xsl:message  Format  <xsl:message  select? = expression terminate? = { "yes"  "no"} >       6  X S L T  l  E e m e n t s  Position   is an instruction. It is always used as part of a sequence constructor.  Attributes Name select optional  Value XPath Expression  Meaning The expression is evaluated to produce the content of the message.  terminate optional  Attribute value template returning «yes» or «no»  The value «yes» indicates that processing is terminated after the message is output. The default is «no».  Content A sequence constructor. There is no requirement that this should only generate text nodes; it can produce any XML fragment. What happens to any markup, however, is not deﬁned in the standard.  This means that writing   could cause an error, on the grounds that you are trying to output an attribute node when there is no element to attach it to. It’s safer to atomize the attribute node explicitly by calling data   or string  .  Unlike other elements that allow a select attribute and a sequence constructor, in this case they are not mutually exclusive. The results of evaluating the select expression and the results of evaluating the sequence constructor are concatenated to form a single sequence.  Effect The   instruction behaves in a similar way to   described on page 445; it uses the contained sequence constructor  in this case, with the results of evaluating any select expression added at the front  to construct a new document node, sends the constructed docu- ment to an implementation-deﬁned destination, and returns an empty sequence.  Unlike  , the   element provides no direct control over the desti- nation or format of the result. The intention is that it should be used to produce progress messages, errors and warnings, which are secondary to the purpose of the transformation.  If the terminate attribute is omitted, the value «no» is assumed.  The contents of the constructed document  which will often be a simple text node  are output where the user can be expected to see them. The XSLT speciﬁcation does not actually say where it goes; this is implementation-dependent, and it might be determined by conﬁguration options. The speciﬁcation suggests an alert box on the screen and a log ﬁle as two possible destinations.  If the terminate attribute has the value «yes», execution of the stylesheet is abandoned immediately. In this situation  as indeed after any runtime error  the content of any output ﬁles is undeﬁned.  387   XSLT Elements  Usage The   instruction is generally used to report error conditions detected by the stylesheet logic. An example might be where an element such as   is expected to have a numeric value, but is found to have a nonnumeric value:    With «terminate="no"»  the default , the stylesheet can report the error and continue  processing.    With «terminate="yes"», the stylesheet can report the error and quit.  Before using   in a production environment, check what happens to the messages and whether they can be redirected. You need to be particularly clear about whether your messages are intended to be read by the source document author, the stylesheet author, or the end user: this will affect the way in which you write the text of the message.  The output produced by   can be unpredictable, because the sequence of execution of a stylesheet is not deﬁned in the standard. For example, some products  including Saxon  defer evaluation of a variable until the variable is ﬁrst used, which means that the order in which different variables are evaluated is difﬁcult to predict. If evaluation of a variable triggers execution of  , the order of the messages may be surprising. Certainly, it can vary from one XSLT processor to another.  A common use of   is to generate diagnostic output so you can work out why your stylesheet isn’t behaving as expected. This works well with products that have a fairly predictable sequence of execution, but it can be rather bewildering with a processor that does things in a differ- ent order from the one you would expect. Placing diagnostics as comments into the result tree  using    is probably a more ﬂexible solution. Some products, of course, have vendor-deﬁned debugging aids built-in, or available from third parties.  The Microsoft MSXML parser ignores  , so the message is not reported anywhere. If «terminate="yes"» is speciﬁed, it generates an error, which can be handled through the script on the HTML page that invoked the transformation.  Examples The following example issues a message and quits if the value of the   element is non-numeric:         Sales value is not numeric         Unfortunately, there is no mechanism deﬁned in the XSLT standard that allows the location of the error in the source document to be included in the message. In this example, validation against a schema would probably give better diagnostics.  388   The following example extends this by allowing several such errors to be reported in a single run, termi- nating the run only after all errors have been reported. It works by assigning a global variable to the set of nodes in error:  xsl:message  <xsl:variable name="bad-sales"        select="  sales[not . castable as xs:decimal ]" >   Sales value    is not numeric        ...                  Processing abandoned   6  X S L T  l  E e m e n t s  Localized Messages XSLT is designed very much with internationalization in mind, and no doubt the requirement to localize message text was discussed by the working group. They clearly decided that no special facilities were needed and instead included a detailed example in the XSLT 1.0 speciﬁcation showing how the message text can be localized  output in the user’s native language . The example is worth repeating because it shows a general technique.  Messages for a particular language are stored in a ﬁle whose name identiﬁes the language, for example German messages might be stored in messages de.xml. The message ﬁle might have the structure:         Angefangen   Bitte warten!   Fertig   A stylesheet that wishes to produce messages in the appropriate local language will need a parameter to identify this language. The stylesheet can then get access to the messages ﬁle for the appropriate language, and read the messages from there:         <xsl:variable name="message-file"  <xsl:variable name="message-text"  select="concat ’messages ’, $language, ’.xml’ " >  select="document $message-file  messages" >  389      The same technique can, of course, be used for producing localized text to include in the output of the transformation.  XSLT Elements           See Also   on page 445  xsl:namespace  The   instruction constructs a namespace node that is written to the result sequence. Constructing namespace nodes in this way is not a frequent requirement, but there are situations where it is the only way of getting a required namespace declaration in the output.  Changes in 2.0 This instruction is new in XSLT 2.0.  Format  <xsl:namespace  name = { string } select? = expression       Position   is an instruction. It is always used as part of a sequence constructor.  Attributes Name name mandatory  select optional  Value Attribute value template returning an NCName or a zero-length string  XPath Expression  Meaning The name of the namespace node  which represents the namespace preﬁx   Expression to compute the string value of the namespace node  which represents the namespace URI   Content If the select attribute is present, the element must be empty. Otherwise, it must contain a nonempty sequence constructor.  Effect The name attribute determines the name of the namespace node. This corresponds to the namespace preﬁx. If the value of the name attribute is a zero-length string, the namespace node deﬁnes the default  390   xsl:namespace  namespace. Otherwise, the name must be an NCName  a valid XML name containing no colon . The name attribute can be written as an attribute value template, allowing the name to be computed dynamically.  The string value of the namespace node, which represents the namespace URI, is established using either the select attribute or the contained sequence constructor. For consistency, this instruction uses the results of evaluating the select attribute or sequence constructor in the same way as other instructions such as   and  . This means that the result may be a sequence. Adjacent text nodes are merged, the sequence is atomized, each item in the atomized sequence is converted to a string, and the resulting strings are concatenated, with an intervening space used as a separator in the case where the select attribute is used. Normally, however, the result of the select attribute should be a single string.  A zero-length string cannot be used as a namespace URI, so a runtime error occurs if the result of the computation just described is a zero-length string.  Note that a namespace node is not the same thing as a namespace declaration. An element has a name- space node for every namespace that is in scope. A namespace undeclaration, such as «xmlns=""» in XML Namespace 1.0, or «xmlns:z=""», which is allowed by XML Namespaces 1.1, is not represented by a namespace node. Rather, it is represented in the data model by the absence of a namespace node.  6  X S L T  l  E e m e n t s  Usage and Examples Although namespace declarations are a special kind of attribute in the surface XML syntax, they are rep- resented quite differently in the XDM data model. This means that you cannot produce name- space declarations in the result document by using  , or by any other mechanism that produces attribute nodes.  The namespace declarations produced by the serializer are derived from the namespace nodes that are present in the result tree. However, there isn’t a one-to-one mapping between namespace nodes and namespace declarations. An element in the result tree has a namespace node for every namespace preﬁx that is in scope for this element  even if it’s also in scope for the element’s parent .  In the vast majority of cases, the namespace nodes needed in a result tree are created automatically.  For namespaces used in the names of elements and attributes, this is guaranteed by the namespace ﬁxup process described under   on page 310. This procedure is invoked whenever an element is created in a result tree, whether by  , a literal result element, or by   or  . It is the namespace ﬁxup procedure that makes the ﬁnal decision on what preﬁxes to use for these names.  Creating  or not creating  a namespace node will never change the name of an element or attribute. If you are outputting an element with local name   in no namespace, and you want it to be in namespace http:  garden-furniture.com ns, then you need to change the instruction that creates the element node. If you get the element names right  remembering that an element name includes the namespace URI as well as the local part , then the namespace nodes will usually look after themselves.  The only difﬁculties arise therefore when you need namespaces to be declared in the result document that are not used in element and attribute names. I’ve come across three reasons for doing this:  1.  You want the namespace to be declared once on an outer element of the document, whereas in the normal course of events it would be declared many times on inner elements. This is essen- tially cosmetic, but it can make a signiﬁcant difference to the readability  and the size  of your  391   XSLT Elements  2.  3.  output. In some cases this kind of declaration is necessary to make the output valid against a DTD, or simply against a written speciﬁcation — the Locale Data Markup Language, for example, requires the element   to declare the namespace in which its children appear. Your document uses namespace preﬁxes in the content  as distinct from in the names  of ele- ments and attributes. This is the most common case and we’ll devote the rest of the section to it. The deﬁnition of the result document type uses namespace declarations as some kind of marker, where the mere presence of the namespace declaration carries information, whether or not the preﬁx that’s being declared is ever used. This is a pretty weird way of using namespaces, but there’s no law against it. In the case I saw, it was done because adding namespace declarations to a document can be done without changing the schema.  In the rest of this section we’ll focus on the use of QNames in element and attribute content.  An example is if you want to output the following:   23.50   Your document must then contain a namespace declaration that binds the namespace preﬁx «xs» to the namespace URI «http:  www.w3.org 2001 XMLSchema». The serializer will only produce such a declaration if it encounters a namespace node in the result tree that binds this preﬁx to this URI.  Here is one convenient way to output the above element:     <xsl:namespace name="xs"        select="’http:  www.w3.org 2001 XMLSchema’" >  Note that there is no need to use   to produce a namespace declaration that binds the preﬁx «xsi» to the namespace http:  www.w3.org 2001 XMLSchema-instance. Because this namespace is used in an attribute name, the namespace ﬁxup process will ensure that it is declared. In fact, it would be declared in this case even without namespace ﬁxup, because the rules for a literal result element ensure that all namespaces that are in scope for the literal result element in the stylesheet are copied to the result document, and the «xsi» namespace must be in scope here, or the stylesheet fragment would not be valid.  In fact there are ﬁve different ways that an element in the result tree can acquire namespace nodes:    When an element is copied from a source tree using an   or    instruction, its namespace nodes are also copied, unless this is suppressed by writing «copy-namespaces="no"».    When a literal result element is processed, all the namespace nodes that are in scope for this  element in the stylesheet are copied to the result tree, unless this is suppressed using the [xsl:]exclude-result-prefixes attribute on some containing element. This attribute is described in the entry for   on page 471. Namespace nodes for namespaces used in element and attribute names are automatically created by the namespace ﬁxup process.       When an element is created in the result tree as a child of another element, whether by using   ,  ,  , or a literal result element, then unless the  392   xsl:namespace  parent element was created using the option «[xsl:]inherit-namespaces="no"»,the child ele- ment inherits  acquires a copy of  all the namespace nodes on its new parent element, provided they don’t conﬂict with its existing namespace nodes. Namespace nodes can be created manually using the   instruction.     So the   instruction is needed only if none of the other mechanisms creates the required namespace declaration.  The namespace ﬁxup process does not automatically create namespace nodes in respect of elements or attributes that have QName-valued content, even when there is a schema that describes the content as a QName. The reason for this is to allow namespace ﬁxup and schema validation to operate as separate processes. Suppose that the schema deﬁnes the type of attribute start as being an xs:QName, and that you want to create the attribute «start="my:root"». Schema validation takes the string value of this attribute as input, checks that the namespace preﬁx «my» is declared, and generates ﬁrstly the typed value of this attribute  a QName consisting of the local name «root» and the namespace URI corresponding to preﬁx «my» , and secondly the type annotation of the attribute as an xs:QName. So the namespace node has to be created before schema validation takes place. This means it cannot be done by an automatic namespace ﬁxup process, because at the time namespace ﬁxup takes place, the attribute node has no type annotation, so you don’t yet know that it’s an xs:QName.  6  X S L T  l  E e m e n t s  If you write a stylesheet that produces an XSLT stylesheet as its output, then it becomes very important to get the right namespace declarations into the output, because XSLT makes heavy use of attributes that contain namespace preﬁxes: they arise both in attributes such as the name attribute of  ,  , and  , and wherever the stylesheet contains XPath expressions. It’s worth remarking that there is nothing in the schema for XSLT stylesheets that marks these attributes out as special. Even the name attributes that appear to have QName-valued content do not actually have a type of xs:QName. This is because although their lexical space is the same as xs:QName, they follow the convention ‘‘no preﬁx means no namespace’’, whereas the rule for the xs:QName type is ‘‘no preﬁx means default namespace’’. So these attributes are simply strings, which means it is the application that must choose a namespace preﬁx and then create a namespace node to bind this to the correct namespace URI.  The   instruction adds a namespace node to the result sequence produced by the sequence constructor that it is part of. Normally, this result sequence will immediately be used to create the content of an element node. In this case, the attribute and namespace nodes in the sequence need to come before any other nodes. It doesn’t matter what order the attributes and namespace nodes are in relative to each other. It is an error if there are two namespace nodes that bind the same namespace preﬁx to different URIs; this could happen if you create a namespace node manually using   that clashes with one that is copied automatically from a source document by an   or   instruction, or from the stylesheet by a literal result element. This is only really likely to happen in the case of the default namespace. It is permissible to create a default namespace node using  , but it’s probably not a good idea.  Namespace ﬁxup happens after all the namespace nodes from this result sequence have been constructed, and it is constrained to generate preﬁxes that don’t clash with these namespace nodes. If you have created a namespace node for the default namespace  that is, the empty preﬁx , then the system will have a problem if the element node itself is in the null namespace, because an element in the null namespace has to use the empty preﬁx, and it will no longer be available. This can cause a runtime failure.  See Also   on page 254   on page 306  393   XSLT Elements  xsl:namespace-alias  The   element allows a namespace used in the stylesheet to be mapped to a different namespace used in the output. It is most commonly used when writing transformations that produce an XSLT stylesheet as their output.  Changes in 2.0 The rules for generating namespace preﬁxes have been made stricter. The ‘‘null namespace’’ is now treated in the same way as a real namespace  many XSLT 1.0 products did this, but the speciﬁcation wasn’t clear .  Format  <xsl:namespace-alias  stylesheet-prefix = prefix  "default" result-prefix = prefix  "default" >  Position   is a top-level declaration, which means it must be a child of the   element. It may be repeated any number of times in a stylesheet.  Attributes Name stylesheet-preﬁx mandatory  result-preﬁx mandatory  Value NCName or «default»  NCName or «default»  Meaning A namespace preﬁx used in the stylesheet  The preﬁx of the corresponding namespace to be used in the output  Content None. The   element is always empty.  Effect The   element affects the treatment of namespaces on literal result elements.  Normally, when an element node is output by processing a literal result element, the output element name will have the same local part, the same preﬁx, and the same namespace URI as those of the literal result element itself. The same applies to the attributes of the literal result element. The namespace nodes on the literal result element must be copied unchanged to the result tree, using the same preﬁx and namespace URI.  The XSLT speciﬁcation states that when processing a literal result element, all the namespaces that are in scope for the element in the stylesheet, with certain deﬁned exceptions, will also be present in the output, even if they aren’t used. Redundant namespace nodes can be suppressed by using the xsl:exclude-result-prefixes attribute. For more details on this, see the section Literal Result Elements, on page 112 in Chapter 3.   394   xsl:namespace-alias  Suppose you want the output document to be an XSLT stylesheet. Then you need to create elements such as   that are in the XSLT namespace. However, you can’t use   as a literal result element, because by deﬁnition, if an element uses the XSLT namespace, it is treated as an XSLT element.  The answer is to use a different namespace on the literal result element in the stylesheet, and include an   declaration to cause this to be mapped to the XSLT namespace when the literal result element is output. So your literal result element might be  , and you could use an   element to indicate that the stylesheet preﬁx «out» should be mapped to the result preﬁx «xsl».  The   element declares that one namespace URI, the stylesheet URI, should be replaced by a different URI, the result URI, when literal result elements are output. The namespace URIs are not given directly, but are referred to by using preﬁxes that are bound to these namespace URIs as a result of namespace declarations that are currently in force. Either one of the namespace URIs may be the default namespace URI, which is referred to using the pseudopreﬁx «default». If there is no default namespace deﬁned, «default» denotes the ‘‘null namespace URI’’, which for this purpose is treated as if it were an ordinary namespace.  6  X S L T  l  E e m e n t s  The   element describes the mapping in terms of preﬁxes, but it is primarily the namespace URI of the elements and attributes that it affects, rather than their preﬁxes. However, the way that the rules are drawn up means that in most cases  certainly when the same namespaces are in scope for the   instruction and for the literal result element itself  the element in the result document will end up using the preﬁx deﬁned in the result-prefix attribute  or no preﬁx, if this is speciﬁed as «default» .  The substitution of one namespace URI for another affects the names of literal result elements themselves, and the names of all attributes of literal result elements. It also affects the URIs of namespace nodes copied into the result tree from a literal result element. It does not affect elements cre- ated using  , attributes created using  , or nodes copied using  .  There was often confusion among XSLT 1.0 users about what namespaces they should expect to ﬁnd declared in the result document, and different processors handled this differently. In XSLT 2.0, the rules have been clariﬁed. Namespaces ﬁnd their way from the stylesheet into the result document whenever a literal result element is evaluated. XSLT 2.0 states clearly that if the literal result element has a namespace node with the URI associated with the stylesheet-prefix of an   instruction, it is not copied to the result tree as it normally would be; if it has a namespace node with the URI asso- ciated with the result-prefix of an   instruction, then this namespace node is copied, even if the URI is one such as http:  www.w3.org 1999 XSL Transform that would normally not be copied. These rules are designed to produce the result that most users would expect: a literal result element   will produce an element in the result tree that will normally be serial- ized as  ; the «xsl» namespace will be declared in the result document, and the «out» namespace will not be declared.  If there are several   elements that specify the same stylesheet-prefix, the one with highest import precedence is used; a compile-time error is reported if there is more than one at the highest import precedence.  395   XSLT Elements  The aliasing of namespace URIs applies at the point when a literal result element in the stylesheet is eval- uated to create an element node in a result sequence. It applies whether or not this element is written to a ﬁnal result tree. This means that if you examine a temporary document into which literal result elements have been copied, the corresponding elements and attributes will use the namespace URI associated with the result preﬁx, not the stylesheet preﬁx.  Aliasing of namespaces happens before the namespace ﬁxup process described under   on page 310.  Usage and Examples The main justiﬁcation for this facility is to enable stylesheets to be written that generate stylesheets as output. This is not as improbable a scenario as it sounds; there are many possible reasons for using such applications  sometimes referred to as meta-stylesheets , including the following:                 There are many proprietary template languages currently in use. Translating these templates into XSLT stylesheets creates an attractive migration route, and there is no reason why these translators should not be written in XSLT. There may be a continuing need for a template language, which is less complex and powerful than XSLT, for use by nonprogrammers. Again, these simple templates can easily be translated into XSLT stylesheets. There are some parts of an XSLT stylesheet that cannot easily be parameterized. For example, it is not possible to construct an XPath expression programmatically and then execute it  XSLT is not a reﬂexive language . The requirement to do this arises when visual tools are developed to deﬁne queries and reports interactively. One way of implementing such tools is to construct a customized stylesheet from a generic stylesheet, and again this is a transformation that can be assisted by using XSLT. You might have developed a large number of stylesheets that all have some common character- istic; for example, they might all generate HTML that uses the   tag. As the   tag is deprecated, you now want to modify these stylesheets to use <div style="text-align: center">. Why not write an XSLT transformation to convert them? There are tools that make it possible to generate XSLT stylesheets from a schema  see for example Schematron at http:  xml.ascc.net resource schematron  . Because both the schema and the stylesheet are XML documents, this is an XML-to-XML transformation, so it should be possi- ble to write it in XSLT.  In fact, having gone through all the trouble of deﬁning XSLT stylesheets as well-formed XML documents, it would be very surprising if it were impossible to manipulate them using XSLT itself.  However, it is possible to create stylesheets as output without recourse to  : just avoid using literal result elements, and use instructions such as <xsl:element name = "xsl:template"> instead. I personally ﬁnd this approach less confusing, although the stylesheet ends up being more verbose.  There may be other situations where   is useful. The XSLT speciﬁcation men- tions one, the need to avoid using namespace URIs that have recognized security implications in the area of digital signatures. Another might arise if stylesheets and other documents are held in a conﬁguration management system; there might be a need to ensure that namespaces recognized by the conﬁguration management system, for example to describe the authorship and change history of a document, are not used directly in the stylesheet.  396   6  X S L T  l  E e m e n t s  xsl:namespace-alias  Aliasing the XML Namespace It’s possible to deﬁne an alias for the xml namespace. For example, the following stylesheet  xml-space.xsl :  <xsl:transform  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" version="2.0" xmlns:axml="alias">         text         produces the following output:     text   This is useful because it gets an «xml:space="preserve"» attribute into the result document without affecting the way that whitespace is handled in the stylesheet.  Choice of Preﬁxes in the Result Document XSLT 2.0 has clariﬁed the rules deﬁning what preﬁxes are used in the result. This can be important; for example, if the target stylesheet contains an expression such as «system-property "xslt:version" », then this will only work if the preﬁx xslt has been declared. Follow through exactly what happens when you write the stylesheet:  <xsl:stylesheet version="2.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" xmlns:oxsl="http:  localhost old.uri">                This transformation executes just one instruction: the   literal result element. Name- space aliasing causes this to generate an element with preﬁx xsl, local name stylesheet, and name- space URI http:  www.w3.org 1999 XSL Transform. The literal result element has two namespace nodes, representing the preﬁx bindings «xmlns:xsl="http:  www.w3.org 1999 XSL Transform"» and «xmlns:oxsl="http:  localhost old.uri"»  we will ignore the namespace node for the «xml» namespace . The ﬁrst of these is copied to the result tree, because it matches the result-prefix, despite the fact that it would normally be an excluded namespace. The second namespace node is not copied, because its namespace URI  «http:  localhost old.uri»  is the one referred to by the stylesheet- prefix attribute. So the namespace node in the result tree will map the preﬁx «xsl» to the namespace URI «http:  www.w3.org 1999 XSL Transform».  Namespace ﬁxup is then applied, but this doesn’t need to do anything, because all the required preﬁxes are already declared.  397   XSLT Elements  When the time comes to serialize this result tree, namespace nodes are used to generate namespace declarations. So the output  ignoring the XML declaration  should be this:     XSLT 2.0  unlike 1.0  really doesn’t give the implementation any latitude to generate anything else in this situation. In 1.0, there was a general rule that the serializer could add any namespace declarations it chose, and by implication that it could give elements and attributes any preﬁx that it chose. In 2.0, the namespace ﬁxup process is only allowed to add namespaces if they are actually needed to make the tree consistent, and in this case, they aren’t.  Example of    The following example generates an XSLT stylesheet consisting of a single global variable declaration, whose name and default value are supplied as parameters. Although this is a trivial stylesheet, it could be useful when incorporated into another more useful stylesheet using   or  . This example is available in the code download as alias.xsl.  Source  No source document is required. You can run this with Saxon using the command: java -jar c:\saxon\saxon9.jar -it:main -xsl:alias.xsl  The «-it» option on the command line causes the transformation to start at the template named «main».  Stylesheet  <xsl:stylesheet version="2.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" xmlns:oxsl="http:  www.w3.org local-alias">   v      <xsl:namespace-alias  stylesheet-prefix="oxsl" result-prefix="xsl" >                       398   6  X S L T  l  E e m e n t s  xsl:next-match  Output  If you default the values of the parameters «variable-name» and «default-value», the output is as follows.    <xsl:stylesheet xmlns:xsl="http:  www.w3.org 1999 XSL Transform"  version="1.0">        See Also Literal Result Elements in Chapter 3, on page 112.  xsl:next-match  The   instruction allows more than one template rule to be applied to the same node in a source document. When   selects a node, it ﬁnds the best match template rule to process this node. Within this template rule, you can use the   instruction to invoke the next-best matching rule, and so on.  Changes in 2.0 This instruction is new in XSLT 2.0. It was introduced as an improved alternative to <xsl:apply- imports>, though that instruction remains available for backward-compatibility reasons.     Position   is an instruction, and is always used within a sequence constructor.  Format        Attributes None.  Content The element may be empty, or it may contain one or more   and or   elements. An XSLT 2.0 processor will ignore the   instructions; they are allowed so that fallback behavior can be deﬁned for use when the stylesheet is processed using an XSLT 1.0 processor. For details, see   on page 316.  Effect   relies on the concept of a current template rule. A template rule becomes the current template rule when it is invoked using  ,  , or  399   XSLT Elements   . Using   does not change the current template rule. However, using   makes the current template rule null, until such time as the   terminates, when the previous value is reinstated. The current template rule is also null while global variables and attribute sets are being evaluated.  Closely associated with this is the current mode. When a template rule is invoked using <xsl:apply- templates>, the mode speciﬁed on the   instruction becomes the current mode  if no mode is named, then the default unnamed mode becomes the current mode . The current mode reverts to the default  unnamed  mode when a stylesheet function is called.    searches for a template rule that matches the current node, using the same search rules as  , but considering only those template rules that  a  match the current mode, and  b  have lower import precedence or priority than the current template rule. For details of import precedence, see   on page 359. If no template rule is found, the built-in template rule is used  see page 243 .  There is a clear analogy here with object-oriented programming. Writing a template rule that overrides another is like writing a method that overrides a method deﬁned on the superclass.   behaves analogously to the super   function in object-oriented programming languages, allowing the new template rule to reﬁne the behavior of the original template rule, rather than replacing it completely.  Within the stylesheet as a whole, there are potentially several template rules that match the context node. The rules for the   instruction deﬁne an ordering of these rules: They are considered ﬁrst in decreasing order of import precedence, then within each import precedence in decreasing order of priority, and ﬁnally within each priority, by the order of the declarations in the stylesheet  it is actually an error to have two rules with the same priority, but the processor is allowed to ignore this error and select whichever comes last in the stylesheet . At the end of the list is the built-in template rule for the particular kind of node. What   does is choose the template rule that comes next in this pecking order, after the current template rule.  It is possible to specify parameters to be supplied to the called template, using   ele- ments contained within the   element. These work in the same way as parameters for   and  ; if the name of the supplied parameter matches the name of an   element within the called template, the parameter will take this value; oth- erwise, it will take the default value supplied in the   element. It is not an error to supply parameters that don’t match any   element in the called template rule, they will simply be ignored. However, if the called template speciﬁes a parameter with «required="yes"», then a runtime error occurs if no value is supplied for this parameter.  The effect of the   instruction is very similar to  . The main difference is that with  , the only template rules that can be invoked are those in imported stylesheet modules. By contrast,   can invoke other template rules of lower priority in the same stylesheet module and can also invoke template rules that have lower import precedence because they were imported into the parent stylesheet module earlier than the current template rule. Looking at Figure 6-4 on page 360, if the current template rule is in module C, then   will only consider template rules in module H, whereas   will also consider lower-priority rules in modules C, E, and J, as well as all rules in modules B, D, F, and G.  There is a special rule for the case where a template uses a union pattern and the two branches have different implicit priority, for example  . This is treated as if it were two separate template rules, which means that when you call  , the same template can be invoked more than once.  400   xsl:next-match  Usage and Examples The intended usage pattern for   is illustrated by the following example.  One template rule might contain a general-purpose rule for formatting headings, as follows:                   Another set of template rules contains speciﬁc rules for particular levels of headings:                                   These template rules each invoke the ﬁrst rule using  , which avoids duplicating the common code in the template rule for each level of heading, and makes it easier to deﬁne changes later.  In this example I have made the priorities explicit, but in fact the default priorities could have been used. I always prefer to use explicit priorities when several rules match the same nodes, because it makes it clear to someone reading the stylesheet what your intentions were when you wrote it.  On this occasion there are three specialized rules, each invoking one generalized rule. But there are other problems where the structure can be inverted, so that the general rule invokes the special rule. For example, suppose you want to use a special color to render any inline text element that has the attribute «highlight="yes"». You might use a set of template rules like this:                                 and then process the highlight attribute in a higher priority template rule:             6  X S L T  l  E e m e n t s  401   XSLT Elements  Unlike  , where invoking multiple template rules is possible only by deﬁning mul- tiple stylesheet modules,   allows several rules to be deﬁned within a single module, which is often preferable because it makes the logic more clear.  Note that both   and   impose the constraint that the two  or more  template rules that match a node in the source tree work on the source node completely indepen- dently of each other. Neither rule can see or modify the nodes that the other rule has written to the result tree. This also means that  as the examples above show  the second rule can only create nodes that are children or siblings of the nodes created by the ﬁrst rule; it cannot create parent nodes.  In some situations, therefore, other solutions might work better. In particular, another design pattern  sometimes called a micropipeline  is to use a multipass transformation whereby one template rule creates a temporary tree, which it then processes using a second template rule  perhaps in a different mode . The code tends to look like this:                               This design pattern does not require use of   or  . One thing to watch out for when using this pattern is that the template rule for processing the   element might be expecting it to be part of a larger document; for example, it might expect its IDREF attributes to reference elements in the same tree. This won’t be the case when you copy a   element into a temporary tree.  See Also   on page 237   on page 316   on page 425   on page 517  xsl:non-matching-substring  The   element is used within an   instruction to indicate the processing that should be applied to substrings of the input string that appear between the substrings that match the supplied regular expression.  Changes in 2.0 This element is new in XSLT 2.0.  Format           402   Position   can only appear as a child of an   element, and it must not appear more than once.  xsl:number  Attributes None.  Content A sequence constructor.  Effect The sequence constructor contained in the   element is evaluated once for each nonempty substring of the input string that appears between two substrings that match the reg- ular expression. The result of evaluating the sequence constructor is added to the result of the containing   instruction.  If there is no   element, or if its sequence constructor is empty, then non-matching substrings are discarded.  6  X S L T  l  E e m e n t s  Usage and Examples See   on page 230.  See Also   on page 230   on page 386  xsl:number  The   element performs two functions. It can be used to allocate a sequential number to the current node, and it can be used to format a number for output. These functions are often performed together, but they can also be done separately.  Note that the facilities for number formatting in the   element are quite separate from those offered by the format-number   function and the   element.  Changes in 2.0 The select attribute has been added: This allows a node other than the context node to be numbered.  XSLT 2.0 deﬁnes error conditions that must be reported when incompatible attributes are used  for example, level and value cannot appear together . In XSLT 1.0, redundant attributes were silently ignored. XSLT 2.0 also deﬁnes the result of the instruction more precisely in corner cases, for example when there is no node that matches the from pattern.  New options have been added in XSLT 2.0 for formatting numbers as words  so you can output «Chapter Three»  and as ordinal numbers  so you can output «Fit the First» or «3rd Act» .  403   XSLT Elements  Format  <xsl:number  value? = expression select? = expression level? = "single"  "multiple"  "any" count? = pattern from? = pattern format? = { string } lang? = { nmtoken } letter-value? = { "alphabetic"  "traditional"} ordinal? = { string } grouping-separator? = { char } grouping-size? = { number }   >  Position   is an instruction. It is always used within a sequence constructor.  Meaning A user-supplied number to be formatted  instead of using a node sequence number .  Selects the node whose sequence number is to be output  by default, the instruction numbers the context node .  Controls the way in which a sequence number is allocated based on the position of the node in the tree.  Determines which nodes are counted to determine a sequence number.  Determines a cut-off point, a point in the document from which sequence numbering starts afresh.  Determines the output format of the number.  Indicates a language whose conventions for number formatting should be used.  Value XPath Expression  XPath Expression  «single», «multiple» or «any»  Pattern  Pattern  Attribute value template returning a format string, as deﬁned below  Attribute value template returning a language code, as deﬁned in XML for the xml:lang attribute  Attribute value template returning «alphabetic» or «traditional»  letter-value optional  Distinguishes between different numbering schemes used with the same language.  continued  Attributes  Name value optional  select optional  level optional  count optional  from optional  format optional  lang optional  404   xsl:number  Meaning If the attribute is present and is not a zero-length string, it indicates that ordinal numbering is required. For English, a suitable value is «yes»; for inﬂected languages, it indicates the required ending; for example, «-o» or «-a» in Italian.  A character to be used to separate groups of digits  for example, a comma as a thousand separator .  The number of digits in each group, indicating where the grouping-separator should be inserted.  6  X S L T  l  E e m e n t s  Name ordinal optional  Value Attribute value template returning a string  grouping-separator optional  Attribute value template returning a single character  grouping-size optional  Attribute value template returning a number  For the syntax of a pattern, see Chapter 12.  Content None, the element is always empty.  Effect The   instruction performs four tasks:  1.  2. 3. 4.  Determines a sequence number. This is actually a sequence of integers  to allow section numbers such as 1.16.2 ; since it is not necessarily a number in the XPath sense, the speciﬁcation refers to it as the place marker. Analyzes the format string into a sequence of format tokens. Formats each part of the place marker using the appropriate format token. Returns the resulting string as a text node.  These steps are considered individually in the following sections.  Determining a Sequence Number If the value attribute is speciﬁed, the place marker is obtained by evaluating the expression in the value attribute and converting it to a sequence of integers. This is done by atomizing the sequence, calling the number   function for each value, applying the round   function and then casting to an integer.  This rather cumbersome procedure is chosen largely for backward-compatibility reasons.  If backward-compatibility mode is in effect  that is, if the version attribute on the   element or on some other enclosing element is «1.0» , then all items in the sequence after the ﬁrst are discarded. This is to emulate the behavior of XSLT 1.0.  If the value attribute is speciﬁed, the level, count, and from attributes must not be speciﬁed.  It is a fatal error if the sequence is empty, or if any value in the sequence can’t be converted to an inte- ger, or produces an integer less than zero.  In backward-compatibility mode, however, the processor  405   XSLT Elements  outputs «NaN» instead of reporting the error.  The   element is designed for handling the natural numbers that arise from counting nodes, so if you want to handle other cases, it’s better to use the format-number   function described in Chapter 13, on page 788.  If no value attribute is speciﬁed,   determines a place marker based on the position of a node in a source document. When the select attribute is present, the node to be numbered is determined by evaluating the expression contained in this attribute; a type error is reported if the result is anything other than a single node. If the select attribute is omitted, the instruction operates on the context node. In this case, an error is reported if the context item is not a node. Either way, we will refer to this node as the start node.  The rules for determining the place marker  always a sequence of non-negative integers  depend on the value of the level, count, and from attributes. If any of these attributes is omitted, the default is as follows:  Attribute level  count  Default value  «single»  A pattern that matches nodes of the same kind as the start node, and with the same name as the start node if it has a name. As always, names with namespace preﬁxes are matched using the relevant namespace URI rather than the preﬁx.  from  A pattern that matches the root node of the tree containing the selected node.  If the level attribute is «single» or «any» the place marker will normally contain a single integer; if it is «multiple» then it may contain several integers  for example «3.6.1» . It is also possible for the list to be empty.  The place marker is determined as follows:  Rules This is designed for numbering peer nodes at the same level in the structure, for example the bullets in a list of bullets. First establish a target node. If the start node matches the count pattern, the target node is the start node  this is the normal case . Otherwise, the target node is the innermost ancestor of the start node that matches the count pattern. If there is no such node, the place marker is an empty sequence. Now establish a boundary node. If the from pattern is defaulted, this is the root of the tree  this is by far the most common case: the from attribute is rarely used with «level="single"» . Otherwise, the boundary node is the start node if it matches the from pattern, or else it is the innermost ancestor of the start node that matches the from pattern. If none of these nodes matches the pattern, then the boundary node is the root of the tree. If the boundary node is the target node, or is an ancestor of the target node, the place marker is the number of preceding siblings of the target node that match the count pattern plus one. For example, if the target node has six preceding siblings that match the count pattern, then the sequence number is 7. If no target node is found, or if the boundary node is not an ancestor-or-self of the target node, the place marker is an empty sequence.  continued  level single  406   xsl:number  level any  multiple  Rules This is designed for numbering nodes that can appear at any level of the structure, for example the footnotes or equations in a chapter of a book. As a special case, if the start node is a document node, the place marker is an empty sequence. First form the set of countable nodes. This contains all nodes that match the count pattern and that can be reached from the start node using either the preceding axis or the ancestor-or-self axis. Now identify the boundary node. This is the last node  in document order  that matches the from pattern and that can be reached from the start node using either the preceding axis or the ancestor-or-self axis. If the from pattern was not speciﬁed, or if none of these nodes matches, use the root node of the tree. Exclude from the set of countable nodes all those that are before the boundary node in document order. If there are no countable nodes, the place marker is an empty sequence; otherwise, it is a single integer, equal to the number of countable nodes.  This is designed to produce a composite sequence number that reﬂects the hierarchic position of a node; for example, «2.17.1». First, form the set of countable nodes. This contains all nodes that match the count pattern and that can be reached from the start node using the ancestor-or-self axis. The boundary node is the same as with «level="single"». For each countable node  taking them in document order, that is, outermost ﬁrst  that has the boundary node on its ancestor-or-self axis, count how many preceding siblings it has that also match the count pattern and add one for the node itself. The resulting sequence of integers makes up the composite place marker. It is possible for this sequence to be empty.  6  X S L T  l  E e m e n t s  These rules appear complex but in practice most common cases are quite straightforward, as the examples given later in this section demonstrate.  Analyzing the Format String Once the place marker has been determined, the next stage is to format it into a string.  The place marker, as you have seen, is a list of zero or more positive integers.  The formatting is controlled primarily using the format string supplied in the format attribute. If this is omitted, the default value is «1». The format string consists of a sequence of alternating formatting tokens and punctuation tokens. Any sequence of consecutive alphanumeric characters is taken as a for- matting token, any other sequence is taken as a punctuation token. For example, if the format attribute is «1  a  », this is broken up into a formatting token «1», a punctuation token «  », a formatting token «a», and a punctuation token «  ». The term alphanumeric is based on Unicode character categories, and it is deﬁned to include letters and digits from any language  this means you can’t decorate a number with characters such as «a» and «  » that are classiﬁed as alphanumeric .  ◦  The punctuation token that precedes the ﬁrst formatting token, if any, is called the preﬁx. The one that follows the last formatting token, if any, is called the sufﬁx. The other punctuation tokens are referred to as separators.  In the most common case the place marker is a single number. In this situation, the output string consists of the preﬁx, followed by the result of formatting the number using the ﬁrst formatting token, and then the sufﬁx. So if the place marker is «42» and the format attribute is «[1]», then the ﬁnal output is «[42]».  Where the place marker is a list of numbers, the rules are a little more complex but still have intu- itive results; for example, if the list of numbers is «3, 1, 6» and the format attribute is «1.1 a », then  407   XSLT Elements  the ﬁnal output is «3.1 f »  because «f» is the sixth letter in the alphabet . The detailed rules are as follows:                          The preﬁx always appears at the start of the output string. The nth formatting token is used to format the nth number in the list where possible, using the rules in the following section. If there are more numbers in the list than formatting tokens, then the excess numbers are format- ted using the last formatting token. For example, if the list is «3,1,2,5» and the format attribute is «A.1», then the output will be «C.1.2.5». If there are no formatting tokens, then a formatting token of «1» is used. If there are more formatting tokens than numbers in the list, the excess formatting tokens are ignored. The ﬁrst number, after formatting, is added to the output string immediately after the preﬁx. Each subsequent number is preceded in the output by the separator that precedes the formatting token used to format this number, if there is one, or by «.» if there is no preceding separator. The sufﬁx is added to the end of the output string.  Note that if the place marker is an empty sequence, the result will consist of the preﬁx and sufﬁx only. For example, if the format string is «[1]», an empty sequence will be formatted as «[]». The most likely reason for an empty sequence is that no nodes matched the count pattern.  If there is no formatting token, then the same string is used for the preﬁx and the sufﬁx. So if the format string is «$», then the number 20 will be formatted as «$20$».  Formatting the Numbers This section describes how a single number is formatted using a single formatting token to construct a string that will form part of the ﬁnal output string.  The XSLT speciﬁcation deﬁnes this process only partially. There are some deﬁnitive rules, some guidance for the implementor, and many other cases that are left unspeciﬁed.  The deﬁnitive cases are listed in the table below. Output sequence Formatting token 1, 2, 3, 4, . . . 1  other Unicode digits  01, 02, 03, . . . , 10, 11, 12, . . . More generally, if the format token is «1» preceded by n zeros, the output numbers will be in decimal notation with a minimum of n + 1 digits.  The above two rules also apply to any other Unicode digits equivalent to 0 and 1, for example Thai or Tamil digits. The number is output using the same family of digits as is used in the formatting token.  a, b, c, d, . . . , x, y, z, aa, ab, ac, . . . .  A, B, C, D, . . . , X, Y, Z, AA, AB, AC, . . . .  continued  01  a  A  408   xsl:number  6  X S L T  l  E e m e n t s  Formatting token i  Output sequence i, ii, iii, iv, . . . , x, xi, xii, xiii, xiv, . . .  I  w  W  Ww  I, II, III, IV, . . . , X, XI, XII, XIII, XIV, . . .  one, two, three, . . . ten, eleven  in the chosen language   ONE, TWO, THREE, . . . TEN, ELEVEN  in the chosen language   One, Two, Three, . . . Ten, Eleven  in the chosen language   The speciﬁcation doesn’t deﬁne these sequences in detail, for example it doesn’t say whether ‘‘twenty-one’’ is hyphenated, or specify how to represent numbers above 1000 in Roman numerals  the Romans themselves had various conventions, such as putting horizontal lines above the letters, or boxes around them — effects that would be difﬁcult to achieve in XML output . The speciﬁcation does say, however, that if the number is too large to be formatted as requested, it should be output as if the formatting token were «1».  In the table above, the sequences are shown starting at one. However, many of the sequences also allow the number zero to be formatted. Zero will never appear in a place marker generated by counting nodes, but it can appear when the number is supplied using the «value» attribute.  The attributes grouping-separator and grouping-size can be used to control the separation of groups of digits. For example, setting «grouping-separator=""»  a single space  and «grouping-size="2"» would cause the number 12345 to be output as «1 23 45». The groups will always be formed by counting digits from the right-hand side. If either of these attributes is speciﬁed, the other should also be speciﬁed.  The ordinal attribute allows you to request ordinal numbers rather than cardinal numbers. For example, with a formatting token of «1» and language set  explicitly or by default  to «en»  English , the value «ordinal="yes"» would produce «1st, 2nd, 3rd, 4th». With the formatting token «Ww», it would produce «First, Second, Third, Fourth». For languages other than English, the correct form of an ordinal number often depends on the noun it is qualifying. In the case of languages where this is sim- ply done by changing the ending, the speciﬁcation says that the value of the ordinal attribute should be the required ending, for example «ordinal="-e"» or «ordinal="-er"» in German. For other languages with more complicated rules, it’s left to the implementor to sort out what to do. For formatting tokens that aren’t included in the table above, the XSLT speciﬁcation is not prescriptive. It indicates that any for- matting token may be used to indicate a sequence starting with this token, provided the implementation supports such a sequence; if the implementation does not support such a sequence, it may format the number using the formatting token «1». So, for example, if an implementation supports the numbering sequence «α, β, γ , δ», you can invoke this sequence with a formatting token of «α».  In case the formatting token does not identify a numbering sequence unambiguously, two attributes are provided to give greater control:        The lang attribute is intended to indicate the target language: for example, the sequence starting with a Cyrillic capital letter «A»  x0410 in Unicode  might be different for Russian  «lang="ru"»  and for Bulgarian  «lang="bg"» . The language code is intended to take the same form as the xml:lang attribute deﬁned in the XML speciﬁcation. The most obvious case where this changes the output is for the formatting tokens such as «w». For example, if «lang="de"», the output for «w» would become «eins, zwei, drei».  409   XSLT Elements     The letter-value attribute is intended for languages such as Hebrew that have several possible sequences starting with the same token  see http:  www.i18nguy.com unicode  hebrew-numbers.html . The two permitted values are «alphabetic» and «traditional».  The detailed effect of these attributes is left entirely to the implementor, so you can’t expect different products necessarily to behave in the same way. There has been a great deal of discussion on Internet mailing lists about the exact details of certain numbering sequences. With those sequences such as Roman numerals and Hebrew numbering that have a long history, practices have certainly varied at different times and places, so there is no single answer.  All the attributes controlling formatting are attribute value templates, so they can be parameterized using expressions enclosed in curly braces. This is mainly useful if you want to select the values from a localization ﬁle based on the preferred language of the current user. To achieve this, you can use the same techniques as described for localizing messages: see   on page 389.  Outputting the Number The ﬁnal action of   is to write the generated string to the current result sequence, as a text node.  The reason it is a text node rather than a string is historical: In XSLT 1.0, instructions always produced nodes. Changing it to a string in XSLT 2.0 would under some circumstances have caused it to be sepa- rated from adjacent values by a space character, producing a backward-compatibility problem. In practice, text nodes and strings are usually interchangeable.  If you want to do something else with the number  perhaps to write it as an attribute or to copy it to every page heading , you can save it as the value of a variable, as follows:           Writing the value to a variable also allows you to perform further manipulation. For example, if you want to use the traditional numbering sequence for footnotes  *, †, ‡, §, ¶  , you cannot do this directly in   because these characters are punctuation symbols rather than alphanumerics. What you can do, however, is use conventional decimal numbering and then convert, for example:                   The translate   function replaces characters in its second argument by the corresponding character in the third argument: It is described in Chapter 13. In practice it might be safer to use character refer- ences for these special characters to avoid them being mangled by a text editor that doesn’t understand Unicode.  I have dodged a tricky question here, which is that if you want footnote numbers to start at 1 on each page, you can’t allocate them until you have paginated the document. Some kinds of numbering are really the domain of XSL Formatting rather than XSL Transformations.  410   6  X S L T  l  E e m e n t s  xsl:number  Usage and Examples Although the rules for   are very general and sometimes complex, most common cases are quite straightforward.  The general rules allow for numbering any kind of node, but in practice the   instruction is almost invariably used for numbering elements. So in this section, I’ll assume that the selected node is an element.  level = ‘‘single’’ This option  the default  is used to number sibling elements.  The simplest way of using   is without any attributes:     If the current element is the eighth   element owned by its parent element, say, this will write the text value «8» to the current output destination. Technically, the processor is counting all the elements that match the pattern in the count attribute, and the default for the count attribute in this case is a pattern that matches   elements.  For this simple kind of numbering, it is often better to use the position   function, particularly if there are many nodes to be numbered. This is because with a typical implementation, each node that is numbered using   will result in the preceding siblings being counted, which will take an increasingly long time as the number of siblings increases. With the position   function, it is much more likely that the system already knows the position and doesn’t have to do any special walking around the tree and pattern matching. Of course, this is only possible where «position  » and   produce the same answer, which will happen when the sequence of nodes being pro- cessed using   or   consists of all the sibling elements of a particular element type.  Another option for numbering is to use the count   function, for example «count preceding- sibling::item +1». This is often simpler if you want to use the number for further processing, rather than formatting it for output.  The count attribute of   can be used in two ways.  Firstly, it is useful if there are several different kinds of sibling elements that you want to count. There is an example of this in the entry for   on page 433, where we want to number the scenes, prologue and epilogue of a play in a single sequence.  The example actually uses «level="any"», but it applies equally well to «level="single"» :           The number is then used to construct a hyperlink:           411   XSLT Elements  Without the count attribute, the PROLOGUE would be numbered 1, the ﬁrst SCENE would also be numbered 1, and so would the EPILOGUE.  Another use of the count attribute is to specify that it is not the context node that should be counted, but an ancestor node. For example, in the template rule for a   element, you can use   to determine the number of the section that the title belongs to, by writing:  This usage is less common, and with XSLT 2.0 the select attribute gives more ﬂexibility, because its value is an expression rather than a pattern. The above example can be written as:        . . .          . . .    The select attribute is particularly handy when you want to construct a cross-reference to a node other than the context node. For example, if your document contains anchors with tags such as <bookmark name="biog" >, and references to these anchors of the form  , then your stylesheet might expand a reference as follows:            See section               . . .    The from attribute is rarely needed with «level="single"». In fact, it’s difﬁcult to construct an example that isn’t completely artiﬁcial.  If you want numbering to start at a value other than 1, or perhaps to proceed in increments other than 1, you can capture the result of   in a variable and manipulate it using XPath expressions. For example, the following template rule numbers the items in a list starting at an offset passed in as a parameter:              . . .    412   xsl:number  Example: Identifying Location of Text within a Document  This example is adapted from the stylesheet used to produce the errata for the XSLT 2.0 and XPath 2.0 speciﬁcations. It searches the XSLT 2.0 speciﬁcation for a given phrase  supplied as a the value of parameter $phrase  and outputs an HTML document listing all the places where the phrase occurs, with hyperlinks to the containing sections, and a description of the location of the text in terms such as ‘‘ﬁrst numbered list, second item, third paragraph’’.  This stylesheet takes no principal input. Execution starts with the template named main, and the code reads the XHTML version of the XSLT 2.0 speciﬁcation directly from the Web.  Source  Stylesheet  6  X S L T  l  E e m e n t s  This stylesheet is xslt-search.xsl.    <xsl:stylesheet version="2.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" xmlns:xs="http:  www.w3.org 2001 XMLSchema" xmlns:f="http:  www.wrox.com xslt-errata" xpath-default-namespace="http:  www.w3.org 1999 xhtml">  <xsl:param name="spec" as="document-node  "  select="doc ’http:  www.w3.org TR xslt20’ " >    The main template searches the document for text nodes containing the required phrase. For each match, it ﬁnds the containing section in the speciﬁcation and outputs a hyperlink to that section. Then it calls the f:location   function  which is the part we are interested in  to show the location of the text within the section:                 XSLT 2.0 Specification Search    XSLT 2.0 Specification Search  <xsl:variable        name="matches" select="$spec  text  [contains .,$phrase ]" >   Matches for " "     <xsl:variable  name="div" select="ancestor::div[ h1h2h3h4  a][1]" >        <a href="http:  www.w3.org TR xslt20{$div  h1h2h3h4    a @id}">    413   XSLT Elements     See  :              No matches found                  The function f:location   does nothing for an element that is the only child of its par- ent. If the subsection is a direct child of the containing section, it outputs its position using  . If it is more deeply nested, it ﬁrst makes a recursive call to display the posi- tion of its parent element, then appends its own position, again by calling  . The format used is «w», which displays the position in words, and this is followed by a friendly name of the type of element  for example,   becomes ‘‘paragraph’’  so with «ordinal="yes"» we get a string such as «first table, second row, third column, second paragraph».            <xsl:when test="count $subsection .. *  = 1     or $subsection[self::spanself::a]">                <xsl:apply-templates select="$subsection"  mode="user-element-name" >                           ,         <xsl:apply-templates select="$subsection"  mode="user-element-name" >  Note the use of an   element to concatenate several text nodes into a single text node that can be converted to a string, as required by the function signature.  414   xsl:number  The stylesheet ﬁnishes with a list of template rules that convert the names of elements into user-friendly terms:            paragraph  <xsl:template match="ul" mode="user-element-name" >bulleted list  <xsl:template match="ol" mode="user-element-name" >numbered list  ... etc ...     Output  This output is produced by supplying ’’formatted result’’ as the search phrase. The   output is ‘‘ﬁrst bulleted list, third list item’’. See Figure 6-8, where the relevant text is highlighted.  6  X S L T  l  E e m e n t s  Figure 6-8  level = ‘‘any’’ This option is useful when numbering objects within a document that have a numbering sequence of their own, independent of their position within the hierarchic structure. Examples are ﬁgures and illustrations, tables, equations, footnotes, and actions from a meeting.  The count attribute can usually be defaulted. For example, to number quotations within a document, you can write a template rule such as:         415   XSLT Elements                     Again, the count attribute is useful when several different element types are included in the same numbering sequence, for example there might be a single sequence that includes both diagrams and photographs.  Note that each evaluation of   is quite independent of any previous evaluations. The result depends only on the relative position of the selected element in the source document, and not on how many times the   element has been evaluated. So there is no guarantee that the numbers in the output document will be consecutive. In fact, if the output order is different from the input order then the numbers deﬁnitely won’t be consecutive. If you want to number things based on their posi- tion in the output document, you can often achieve this by using the position   function. If this isn’t adequate, the alternative is to perform a second pass, to add the sequence numbers. You can do this by writing the result of the ﬁrst pass to a variable. The following example extracts all the   elements from a document, sorts them alphabetically, and numbers them in their output sequence. The variable glossary is used to hold the temporary results. Note that if you want to use   for the numbering, this needs to be a tree rather than a ﬂat sequence of parentless elements, because   always numbers nodes in terms of their position in a tree.  Imagine a source document that contains glossary deﬁnitions scattered throughout the document, in the form:         XML   Extensible Markup Language   The relevant template looks like this:                                                     In this example, however, the numbers could have been generated equally well on the ﬁrst pass using the position   function.  416   xsl:number  The from attribute is useful for indicating where numbering should restart:                 The above code would number footnotes consecutively within a chapter, starting again at 1 for each chapter.  Example: Numbering the Lines of a Poem  The following example numbers the lines of a poem, showing the number to the right of every fourth line. Assume the input structure contains a   element, a   ele- ment, and a   element: The lines are to be numbered within the poem as a whole, not within each stanza.  6  X S L T  l  E e m e n t s  Source  Stylesheet  This stylesheet can be used with the source ﬁle theHill.xml, shown in Chapter 4 on page 167.  This stylesheet is poem.xsl. It uses   to get the number of every line but dis- plays it only every fourth line, using the «mod» operator to get the remainder when the line number is divided by 4  or some other number supplied as a parameter .  <xsl:stylesheet version="2.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" xmlns:xs="http:  www.w3.org 2001 XMLSchema" xpath-default-namespace="http:  poetry.org ns">                                                            417   XSLT Elements                                 Output  See Figure 6-9  Figure 6-9  level = ‘‘multiple’’ This option is typically used to produce the hierarchic sequence numbers often found in technical or legal documents; for example, 1.12.3, or A2 iii .  Note that an alternative way to produce such numbers is to use several calls on   with «level="single"» and different count attributes, for example:   .        418   xsl:number  Another technique, which might be marginally faster, is to evaluate the chapter number once and pass it as a parameter to the template handling the section, and then pass both the chapter number and section number  or their concatenation  as parameters to the template handling each clause.  However, using «level="multiple"» is convenient, and in some cases — particularly with recursive structures, where   elements are contained within   elements — may be the only way of achieving the required effect.  The count attribute deﬁnes which ancestor elements should be included. Usually, this is expressed as a union pattern, as in the example below:     <xsl:number  format="1.1.1. " level="multiple" count="chapter  section  clause" >        The effect of the rules is that a composite sequence number will be formed containing one component number for each ancestor  or the element itself  that is a  ,  , or  . If the structure is regular, so that chapters, sections, and clauses are neatly nested, each clause will be output preceded by a number such as 1.13.5, where 1 is the chapter number, 13 is the number of the section within the chapter, and 5 is the number of the clause within the section.  If the structure isn’t regular, for example if there are sections that don’t belong to a chapter, if there are clauses that have sections as siblings at the same level, or if there are sections nested within other sections, then the effects can be surprising, but a careful reading of the rules should explain what’s going on.  A problem that sometimes occurs is that the numbering is context-sensitive. For example, within Chapter 1, clauses are numbered 1.2.3, but in Appendix A, they are numbered A.2.3. It’s possible to achieve this effect by exploiting the fact that the format pattern is an attribute value template; for example, you could write:  6  X S L T  l  E e m e n t s     <xsl:variable name="format"  select="if  ancestor::chapter   then ’1.1.1 ’ else ’A.1.1 ’" >  <xsl:number  format="{$format}" level="multiple" count="appendix  chapter  section  clause" >        This assumes that   elements are within a wrapper such as  , while   elements are similarly wrapped by  . If this isn’t the case, for example, if the ﬁrst   element has four   elements as its preceding siblings, then the ﬁrst appendix will be numbered E. To solve this you will need to use two different   instructions for the two cases.  See Also count   function in Chapter 13 on page 733 position   function in Chapter 13 on page 854  419   XSLT Elements  format-number   function, in Chapter 7 on page 788   on page 298  xsl:otherwise  The   element is used within an   instruction to indicate the action that should be taken when none of the   conditions is satisﬁed.     Position   can appear only as a child of an   element. If it is present at all, it must be the last child of the   element, and it must not appear more than once.  Effect The sequence constructor of the   element is evaluated if  and only if  none of the   elements in the containing   element evaluates to true. If there is no   element, then in this situation the   produces no output.  Changes in 2.0 None.  Format        Attributes None.  Content A sequence constructor.  Usage and Examples See   on page 282.  See Also   on page 282   on page 515  xsl:output  The   element is a top-level declaration used to control the format of the serialized result document. An XSLT stylesheet is processed conceptually in two stages: the ﬁrst stage is to build a result tree, and the second is to write out the result tree to a serial output ﬁle. The   element controls this second stage, which is often referred to as serialization. Serialization is described more fully in Chapter 15.  This second stage of processing, to serialize the tree as an output document, is not a mandatory require- ment for an XSLT processor; the standard allows the processor to make the tree available in some other  420   xsl:output  way; for example via the DOM API. A processor that does not write the tree to an output ﬁle is allowed to ignore this element. Processors that do provide serialization may also allow the deﬁnitions in this ele- ment to be overridden by parameters set in the API when the processor is invoked. See Appendix E for details of the JAXP API.  Changes in 2.0 An   declaration may be given a name, allowing a named output format to be deﬁned that can be referenced in an   instruction.  An output method has been deﬁned for XHTML.  Several new serialization parameters have been added: byte-order-mark, escape-uri-attributes, include-content-type, normalization-form, undeclare-prefixes, and use-character-maps.  The speciﬁcation has become more prescriptive: in XSLT 1.0, implementations had more freedom to apply their own interpretation.  6  X S L T  l  E e m e n t s  Format  <xsl:output  name? = qname method? = "xml"  "html"  "xhtml"  "text"  qname-but-not-ncname byte-order-mark? = "yes"  "no" cdata-section-elements? = qnames doctype-public? = string doctype-system? = string encoding? = string escape-uri-attributes? = "yes"  "no" include-content-type? = "yes"  "no" indent? = "yes"  "no" media-type? = string normalization-form? = "yes"  "no" omit-xml-declaration? = "yes"  "no" standalone? = "yes"  "no"  "omit" undeclare-prefixes? = "yes"  "no" use-character-maps? = qnames version? = nmtoken  >  Position   is a declaration, which means it must be a child of the   element. It may appear any number of times in a stylesheet.  Attributes Name name optional  method optional  Value Lexical QName  «xml», «html», «xhtml», «text» or Lexical QName  Meaning Deﬁnes a name for this output format, so that it can be referenced in an   instruction.  Deﬁnes the required output format.  continued 421   XSLT Elements  Name byte-order-mark optional  Value «yes» or «no»  Meaning Indicates whether a byte order mark should be written at the start of the output ﬁle.  cdata-section-elements optional  Whitespace-separated list of lexical QNames  Names those elements whose text content is to be output in the form of CDATA sections.  doctype-public optional  doctype-system optional  encoding optional  string  string  string  escape-uri-attributes optional  «yes» or «no»  include-content-type optional  «yes» or «no»  indent optional  media-type optional  normalization-form optional  omit-xml-declaration optional  standalone optional  «yes» or «no»  string  «NFC», «NFD», «NFKC», «NFKD», «fully-normalized», «none», or NMTOKEN  «yes» or «no»  «yes», «no», or «omit»  undeclare-preﬁxes optional  «yes» or «no»  use-character-maps optional  Whitespace-separated list of lexical QNames  Indicates the public identiﬁer to be used in the DOCTYPE declaration in the output ﬁle.  Indicates the system identiﬁer to be used in the DOCTYPE declaration in the output ﬁle.  Deﬁnes the character encoding.  Indicates whether URI-valued attributes in HTML and XHTML should be %HH encoded.  Indicates whether a   element should be added to the output to indicate the content type and encoding.  Indicates whether the output should be indented to indicate its hierarchic structure.  Indicates the media-type  often called MIME type  to be associated with the output ﬁle.  Indicates whether and how the Unicode characters in the serialized document should be normalized.  Indicates whether an XML declaration is to be included in the output.  Indicates that a standalone declaration is to be included in the output, and gives its value.  Indicates whether  with XML 1.1 output  namespaces should be undeclared using «xmlns:p=""» when they go out of scope.  A list of the names of   elements that are to be used for character mapping.  NMTOKEN  Deﬁnes the version of the output format.  version optional  422  Content None, the element is always empty.   xsl:output  6  X S L T  l  E e m e n t s  Effect A stylesheet can contain several output format deﬁnitions. This is useful if the stylesheet produces multi- ple result documents or if it produces different kinds of output on different occasions. One of the output format deﬁnitions can be unnamed, and the others are named using a QName in the same way as other stylesheet objects.  An output deﬁnition can be split over several   elements. All the   ele- ments with the same name  as speciﬁed in the name attribute  constitute one output deﬁnition. In this case the attributes deﬁned in these multiple elements are in effect combined into a single conceptual   element as follows:  For the cdata-section-elements attribute, the lists of QNames supplied on the separate   elements are merged — if an element name is present in any of the lists, it will be treated as a CDATA section element. For the use-character-maps attribute, the lists of QNames on the separate   ele- ments are concatenated. They are taken in order of the import precedence of the   declarations on which they appear, or where two declarations have the same import precedence, in declaration order. For all other attributes, an   element that speciﬁes a value for the attribute takes precedence over one that leaves it defaulted. If several   elements specify a value for the attribute, the one with highest import precedence is used. It is an error if this leaves more than one value, unless they are all equal.  The concept of import precedence is explained under   on page 359.  The method attribute controls the format of the output, and this in turn affects the detailed meaning and the default values of the other attributes.  Four output methods are deﬁned in the speciﬁcation: «xml», «html», «xhtml», and «text». Alternatively, the output method may be given as a QName, which must include a non-null preﬁx that identiﬁes a namespace that is currently in scope. This option is provided for vendor or user extensions, and the meaning is not deﬁned in the standard. A vendor-deﬁned output method can attach its own interpre- tations to the meanings of the other attributes on the   element, and it can also deﬁne additional attributes on the   element, provided they are in a namespace.  If the method attribute is omitted, the output will be in XML format, unless the result tree is recognizably HTML or XHTML. The result tree is recognized as HTML if:  The root node has at least one element child, and The ﬁrst element child of the root node is named  , in any combination of upper and lower case, and has a null namespace URI, and There are no text nodes before the   element, other than, optionally, a text node contain- ing whitespace only.  The result tree is recognized as XHTML if:  The root node has at least one element child, and The ﬁrst element child of the root node is named  , in lower case, and has the namespace URI http:  www.w3.org 1999 xhtml, and                          423   XSLT Elements        There are no text nodes before the   element, other than, optionally, a text node contain- ing whitespace only, and Backward-compatibility mode is not in effect  speciﬁcally, if the version attribute of the   element in the principal stylesheet module is «2.0» or greater .  Examples The following example requests XML output using iso-8859-1 encoding. The output will be indented for readability, and the contents of the   element, because it is expected to contain many special characters, will be output as a CDATA section. The output ﬁle will reference the DTD booklist.dtd; note that it is entirely the user’s responsibility to ensure that the output of the stylesheet actually conforms to this DTD, and, indeed, that it is a well-formed XML document.  The following example might be used if the output of the stylesheet is a comma-separated-values ﬁle using US ASCII characters only:  <xsl:output  method="xml" indent="yes" encoding="iso-8859-1" cdata-section-elements="script" doctype-system="booklist.dtd"  >  <xsl:output  method="text" encoding="us-ascii"  >  See Also   on page 280   on page 445 Serialization, Chapter 15  xsl:output-character  Changes in 2.0 The element is new in XSLT 2.0.  Format  <xsl:output-character  character = char string = string  >  424  The   element allows a character in the result tree to be mapped to a speciﬁc string used to represent this character in the serialized output.  Position   only appears as a child of the   element.   xsl:param  Attributes Name character mandatory  string mandatory  Value Character  String  Meaning A single XML character; the character that is to be replaced during serialization.  Any string; the string that is to replace the character during serialization.  Content None. The   element is always empty.  Effect The   element deﬁnes a mapping for a single character within a character map. The way character maps work is described in the entry for the   element on page 280, and in Chapter 15.  The character to be replaced, and the string that is to replace it, must consist entirely of valid XML char- acters; otherwise, it would not be possible to represent them in the stylesheet. Any special characters must be escaped in the usual way. For example, if you want the ampersand character to be mapped to the string «&ampersand;», write:     6  X S L T  l  E e m e n t s  See Also   on page 280 Serialization, Chapter 15  xsl:param  The   element is used either at the top level, to describe a global parameter, or immediately within an   or   element, to describe a local parameter to a template or function. It speciﬁes a name for the parameter and a default value, which is used if the caller supplies no value for the parameter.  Changes in 2.0 An «as» attribute has been added to deﬁne the required type of the parameter.  A required attribute has been added to indicate whether the parameter is mandatory or optional.  A tunnel attribute has been added to support the new facility of tunnel parameters.  Format Different subsets of the format are applicable to stylesheet parameters, template parameters, and function parameters.  425   XSLT Elements  Format for Stylesheet Parameters  <xsl:param  name = qname select? = expression as? = sequence-type required? = "yes"  "no"       Format for Template Parameters  <xsl:param  name = qname select? = expression as? = sequence-type required? = "yes"  "no" tunnel? = "yes"  "no">       Format for Function Parameters  <xsl:param  name = qname as? = sequence-type     Position   may appear as a top-level declaration  a child of the   element , or as an immediate child element of   or  . The three kinds of parameters are known as stylesheet parameters, template parameters, and function parameters. In the case of template parameters and function parameters,   elements must come before any other child elements.  Value Lexical QName  Meaning The name of the parameter  XPath Expression  The default value of the parameter if no explicit value is supplied by the caller  Sequence Type  The required type of the parameter value  «yes» or «no»  Indicates whether the parameter is optional or mandatory  «yes» or «no»  Indicates whether the parameter is a tunnel parameter  The SequenceType construct is described in Chapter 4, on page 159, and more fully in Chapter 11, on page 668.  Attributes Name name mandatory  select optional  as optional  required optional  tunnel optional  426   xsl:param  Content An optional sequence constructor. If a select attribute is present, the element must be empty. For func- tion parameters, the element must always be empty.  Effect An   element at the top level of the stylesheet declares a global parameter; an   element appearing as a child of an   element declares a local parameter for that template, and an   element appearing as a child of an   element declares a local parameter for that function.  The   element deﬁnes the name of the parameter, and a default value. The default value is used only if no other value is explicitly supplied by the caller. Default values can be supplied for stylesheet parameters and template parameters, but not for function parameters, which must always be supplied in the function call.  6  X S L T  l  E e m e n t s  An explicit value can be supplied for a template parameter by using the   element when the template is invoked using  ,  ,  , or  .  For function parameters, values are supplied in the function call. The syntax of function calls is deﬁned in Chapter 7. Function calls pass parameters positionally rather than by name; the nth argument in the function call is evaluated to provide the value for the nth   element in the function deﬁnition.  The way in which explicit values are supplied for stylesheet parameters is implementation-deﬁned  for example, they may be deﬁned on the command line or through environment variables, or they may be supplied via a vendor-deﬁned API . Microsoft APIs are described in Appendix D, and Java APIs in Appendix E.  The Type of the Parameter The required type of the parameter can be speciﬁed using the «as» attribute. For example, «as="xs:integer"» indicates that a single integer is expected, «as="xs:string*"» indicates that a sequence of strings is expected, and «as="element  +"» indicates that the required type is a sequence of one or more element nodes. With a schema-aware processor it is also possible to supply schema-deﬁned types, for example «as="abc:vehicle-registration"» indicates that the parameter must be an atomic value conforming to the user-deﬁned atomic type abc:vehicle-registration, while «as="schema-element EVENT "» indicates that it must be an element node validated as being either an EVENT element or an element in the substitution group of EVENT.  If the «as» attribute is omitted, then the supplied value may be of any type.  The value that is actually supplied by the caller must be suitable for the required type. The value is converted if necessary using the standard conversion rules described on page 505, and it is a fatal error if this conversion fails. Because the ability to specify a type on   is new in XSLT 2.0, the 1.0 compatibility rules are never used even if the stylesheet version is set to «1.0». In summary, this means that the only conversions allowed are:        Atomization  that is, extraction of the typed values of nodes, when the required type is an atomic value or a sequence of atomic values  Numeric promotion; for example, conversion of xs:integer to xs:double  427   XSLT Elements        Promotion of xs:anyURI to xs:string Casting of xs:untypedAtomic values  which normally arise as a result of atomizing a node in a document that has not been schema-validated   If the supplied parameter is the wrong type, then the error may be detected either at compile time or at runtime. With stylesheet parameters, however, the supplied value isn’t known until runtime, so this is when the error will occur.  The «as» attribute on   also serves a second purpose. Like the «as» attribute on  , it is used when the   element has a contained sequence constructor to distinguish whether the default value is the sequence obtained by evaluating the sequence constructor, or the result of building a temporary document using this sequence to provide the content. For example:   Madrid   declares a parameter whose default value is a temporary tree consisting of a document node, which owns a text node whose string value is «Madrid»; while:   Madrid   declares a parameter whose required type is a single string, and whose default value is the string «Madrid». If you really need to say that the required type is a document node, and to supply a temporary document as the default value, then you can write it like this:      Madrid      The Default Value of the Parameter In the case of stylesheet parameters and template parameters, if no value for the parameter is supplied by the caller, a default value is used. The default value of the parameter may be given either by the XPath expression in the select attribute, or by the contents of the contained sequence constructor. If there is a select attribute, the   element must be empty.  The value is calculated in exactly the same way as the value of a variable in  , and the rules are as given on page 503. Note that the default value need not be a constant; it can be computed in terms of the values of other parameters appearing earlier in the list and can also depend on information such as the context item and context size.  If there is no select attribute and the sequence constructor is empty, the default value of the parameter is a zero-length string, unless there is an «as» attribute, in which case the default value is an empty sequence. If the type given in the «as» attribute does not allow an empty sequence, then the parameter is mandatory.  If the required attribute has the value «yes», then the parameter is mandatory. In this case, it makes no sense to supply a default value, so the select attribute must be omitted and the element must be empty. Failing to supply a value for a mandatory parameter is a compile-time error in the case of  , but a runtime error in all other cases.  The Name of the Parameter The name of the parameter is deﬁned by the QName given in the name attribute. Normally, this will be a simple name  such as «num» or «list-of-names» , but it may be a name qualiﬁed with a preﬁx; for example «my:value». If it has a preﬁx, the preﬁx must correspond to a namespace that is in scope at  428   xsl:param  that point in the stylesheet. As usual it is the namespace URI rather than the preﬁx that matters, so two variables «my:value» and «your:value» have the same name if the preﬁxes «my» and «your» refer to the same namespace URI. If the name has no preﬁx then it has a null namespace URI — it does not use the default namespace URI.  Parameter names are referenced in exactly the same way as variables, by preﬁxing the name with a dollar sign  for example, «$num»  and all the rules for uniqueness and scope of names are exactly as if the   element was replaced by an   element. The only difference between parameters and variables is the way they acquire an initial value.  Tunnel Parameters Tunnel parameters are a new facility in XSLT 2.0. If a tunnel parameter is passed to a template when it is called, then it is automatically passed on to any further templates called from this template. For example, if template A creates a tunnel parameter and passes it on a call to template B, then when B calls C and C calls D, the tunnel parameter will be passed transparently through all these calls and will be accessible to template D, even if B and C were quite unaware of the parameter.  This feature is very useful when you are customizing a stylesheet. Suppose that D is a template rule that formats equation numbers in Roman numerals, and you want to use Greek letters instead. You can write a customization layer  an importing stylesheet  that overrides D with a template rule of your own. But suppose you want D sometimes to use Greek letters and sometimes Roman numerals, how do you pass it this information? Global variables only solve the problem if the choice is constant for all invocations of D during the course of a transformation. Adding parameters to every template en route from your top-level A template to the D template would require overriding lots of template rules in the base stylesheet, which you want to change as little as possible. So the answer is that you write a customized version of the A template that sets a tunnel parameter, and a customized version of D that reads the tunnel parameter, and the intermediate templates B and C don’t need to be changed.  The theory behind tunnel parameters is the concept of dynamically scoped variables in functional pro- gramming languages such as Lisp.  A tunnel parameter always starts life in an   element. This may be on any kind of tem- plate call that allows parameter passing: speciﬁcally,  ,  ,  , and  . For example:  6  X S L T  l  E e m e n t s                         I’ve put the parameter name in a namespace here, to minimize the risk that it will clash with a parameter added by someone else.  This tunnel parameter will be passed silently up the call stack, through all calls of <xsl:apply- templates>,  ,  , and  , until it reaches a template that is interested in it. This template can declare its interest by including the parameter declaration:     429   XSLT Elements  and can then use the parameter value in the normal way, by referring to it as «$mq:format-greek» within an XPath expression.  Tunnel parameters are not passed through XPath function calls, so if the stylesheet evaluates an XPath expression which calls a stylesheet function, which in turn calls  , then the tunnel parameters will not be accessible in this call. Similarly, they are not available when an attribute set is expanded.  At the point where the parameter enters the tunnel  the   element , it must have a name that differs from all the other sibling   elements, whether these are tunnel parameters or not. Similarly, when it emerges from the tunnel  the   element , it must have a name that differs from other   elements in that template. But where it is being silently passed through intermediate templates, name clashes don’t matter: silently passed tunnel parameters are in effect in a different symbol space from explicit parameters.  Tunnel parameters can be of any type. They can be optional or required parameters, and if optional, the receiving template can declare a default value. Reading the tunnel parameter in this way isn’t destruc- tive; it will still be passed on to further templates. Specifying a required type or a default value doesn’t change the value that is passed on; for example, if the original value is a node, and the receiving template declares it as a string, then the node will be atomized for the purposes of the receiving template, but the value that’s passed on will still be a node, unless a new   element is used to change the value.  Usage The different kinds of parameters  stylesheet parameters, template parameters, and tunnel parameters  can be used in different ways. These are discussed in the following sections.  Using Stylesheet Parameters Stylesheet parameters can be used in various ways to control the actions performed by the transforma- tion. For example, they are particularly useful for selecting which part of the source document to process. A common scenario is that the XSLT processor will be running within a Web server. The user request will be accepted by an application: perhaps a Java Server Page, a Java servlet, or an ASP or PHP page. The request parameters will be read, and the stylesheet processing will be kicked off using an API deﬁned by each vendor. Generally, this API will provide some way of passing the parameters that came from the HTTP request into the stylesheet as the initial values of global   elements.  If the stylesheet is running interactively in the browser, it will typically be invoked using a JavaScript API, which again will accept data from the user and pass it to the stylesheet in the form of parameter values.  If the API supports it, a global parameter may take a value of any type: not just a string, number, or boolean, but also a node or sequence of nodes. In some cases the API allows the parameter to be supplied in the form of an XPath expression, which is evaluated to generate the actual parameter value. Because the value can contain nodes, this provides another way of supplying secondary source documents for use by the stylesheet, as an alternative to the document   function. Many products allow such a parameter to be supplied as a DOM Document object.  Where a stylesheet needs to get system-dependent information  for example, the name of the user, or the operating system version number , it is often much easier to pass the information as a stylesheet parameter rather than writing extension functions to deliver the information on request.  430   xsl:param  6  X S L T  l  E e m e n t s  Wherever you deﬁne a global variable, ask yourself whether it would be better to make it a stylesheet parameter instead. The default value of a stylesheet parameter can be used in exactly the same way as a global variable; the only difference is that you have added the ability for the user to change the value from outside. Also, remember that when one stylesheet module imports another, the importing module can override an   in the imported module with an  , or vice versa.  The new facilities in XSLT 2.0 to declare a stylesheet parameter with «required="yes"», and to declare its required type, make stylesheet parameters a lot more robust than they were. There are still a few loopholes, however — there is no rule that prevents an importing module redeﬁning a parameter by changing its type in arbitrary ways, or changing the setting to «required="no"».  Using Template Parameters Template parameters are used more often with   than with <xsl:apply- templates>, though they are available to both, and in XSLT 2.0 they can also be used with   and  . The actual value of the parameter is set by the caller using an   element. Parameters are often needed by the recursive algorithms used in XSLT to handle lists of items: there are examples of such algorithms under   on page 271. In XSLT 2.0, however, it is often more convenient to implement such algorithms using  .  Declaring the expected type of a parameter, using the «as» attribute, is optional, but I would always recommend it. It provides useful documentation for anyone who has to debug the stylesheet later, as well as trapping errors when the caller provides incorrect parameter values. My experience is that it catches many coding errors that would otherwise have led to incorrect output being generated. In addition, the information is very useful to the XSLT processor itself, as it enables optimized code to be produced. For example, a test such as   is very much simpler if it is known in advance that $p will always be an integer, than if the processor has to deal with the possibility of it being a node, a sequence of nodes, a sequence of doubles, or perhaps an untypedAtomic value.  Using Tunnel Parameters Tunnel parameters provide a halfway house between global variables and local template parameters, combining the advantages of both and removing many of the problems of both. Compared with global variables, their great advantage is that their value can change in the course of the transformation. This doesn’t mean that they introduce side effects, because only the caller of a template can set the value, not the callee. Compared with local parameters, their great advantage is that you don’t have to change every template in the stylesheet to pass the values through.  I found a good use case for tunnel parameters in the stylesheet used to generate the XSLT working draft. The XML master version of this document includes entries describing each error condition that can arise. This is used both to generate inline descriptions of the errors in the document body and to generate a summary of errors in an appendix. Much of the code to handle the two cases is the same, but a few details differ; for example, the way that hyperlinks are generated. Traditionally, this problem is tack- led using modes; however, even with the XSLT 2.0 ability to write a single template rule that works in more than one mode, using modes means that the intermediate template rules need to be aware of the fact that they can be invoked under two different circumstances. They shouldn’t need to know this: only the code that produces different results in the two cases should need to know that there are two possible cases. A tunnel parameter indicating which phase of processing is active solves the problem neatly.  431   XSLT Elements  Examples This section presents two examples showing the use of   to deﬁne template parameters. The ﬁrst is a very simple demonstration of how parameters work with  . The second is a more complicated example, making use of tunnel parameters.  Example: Using   with a Default Value  This example shows a simple named template that deﬁnes a parameter and gives it a default value. Source  This stylesheet works with any XML source ﬁle.  Stylesheet  The stylesheet is call.xsl. It contains a named template that outputs the depth of a node  deﬁned as the number of ancestors . The node may be supplied as a parameter; if it is not supplied, the parameter defaults to the current node. The stylesheet includes a template rule for the document node that invokes this named template, defaulting the parameter, to display the name and depth of every element in the source document.  <xsl:transform  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" version="2.0"  >                 ;          If the stylesheet is run using itself as the source document, the output is as follows:       Output  xsl:transform -- 1; xsl:output -- 2;  432   xsl:param  6  X S L T  l  E e m e n t s  xsl:template -- 2; xsl:for-each -- 3; xsl:value-of -- 4; xsl:call-template -- 4; xsl:template -- 2; xsl:param -- 3; xsl:value-of -- 3;  Example: Tunnel Parameters  Realistic examples using tunnel parameters tend to involve customization of rather com- plex stylesheets, such as the DocBook stylesheet suite  http:  docbook.sourceforge.net   used for producing many technical manuals. Unfortunately, explaining such an example would take a full chapter of this book. So we’ll make do with a simpler case. Suppose that you start with the stylesheet play.xsl, which is designed to generate a set of linked HTML ﬁles containing the text of one of Shakespeare’s plays as marked up by Jon Bosak. I won’t present this stylesheet in full, because it’s pretty standard, and most of it isn’t relevant to the example: you can ﬁnd it in the download ﬁles for this book. The challenge now is to customize this stylesheet so that instead of producing a single rendition of the play, it produces a script for each of the characters appearing in the play, with the lines spoken by the character highlighted. I have done this by producing another stylesheet module, scripts.xsl, which overrides selected template rules from the original.  This stylesheet can be applied to any of the Shakespeare plays available from http:  metalab.unc.edu bosak xml eg shaks200.zip. The examples use othello.xml, which is included in the download ﬁles for this book.  Source  Output  The existing stylesheet, play.xsl, produces a set of HTML ﬁles: one ﬁle called play.html, which acts as a cover sheet and index, and one ﬁle for each scene in the play, with names such as sceneN.html. You can run it with a command like this: java -jar c:\saxon\saxon9.jar othello.xml play.xsl dir=c: temp othello  The ﬁrst page of the output, in the ﬁle play.html, is shown in Figure 6-10. In the customized presentation, we want to create an index page that looks like the one shown in Figure 6-11. This presents an index showing all the speaking parts in the play. Clicking on one of the names brings up a modiﬁed version of the front page shown before, in which the titles of the scenes are shown as active links if the character appears in these scenes, or as plain text otherwise. The actual text of the scene should also be modiﬁed so that the speaker’s lines are highlighted.  433   XSLT Elements  Figure 6-10  Figure 6-11  434   xsl:param  Stylesheet  The base stylesheet play.xsl is unmodiﬁed  it is one that has been included in the Saxon distribution for a while, to illustrate how a stylesheet can create multiple output ﬁles . The customization layer is in the ﬁle scripts.xsl. This starts by importing play.xsl. It then contains a template rule providing the new control logic:  6  X S L T  l  E e m e n t s                                                                                       This template creates the index page. It calls the distinct-values   function to get a list of speakers appearing in the play, and for each one, it ﬁrstly outputs a hyperlink to a play.html ﬁle in a subdirectory named after the speaker and then calls   to process the   element, which is the outermost element in the source ﬁle. Crucially, it supplies the name of the speaker as a tunnel parameter to this template. There are three template rules in the play.xsl stylesheet that need to be modiﬁed: these are the template for the   element  because the play.html ﬁle now has to be placed in a subdirectory , the template for the   element  which must now generate pages only for those scenes in which the selected speaker appears , and the template for the   element  to highlight the lines spoken by the selected speaker . Each of these contains a  435   XSLT Elements  declaration of the tunnel parameter in an   element. Here is the modiﬁed tem- plate for the   element:                                   <xsl:result-document format="scene" href=  "file:   {$dir} {encode-for-uri $speaker, true   } scene{$NR}.html">                                                              The modiﬁcations here, apart from the addition of the   to declare the tunnel parameter, are the addition of the   to generate the scene page conditionally, and the choice of ﬁle name produced by  . The template rule for the   element becomes:             436   xsl:perform-sort                           The changes from the original are addition of the   declaring the tunnel param- eter, and the addition of the   instruction that outputs an attribute changing the background color if the selected speaker participates in this    a   can have more than one  , the equality test succeeds if any of them match . The key point about this example is that the original stylesheet has been customized and reused without changing it in any way. Without tunnel parameters, this would have required many more of its template rules to be changed, merely to pass the extra parameter through.  6  X S L T  l  E e m e n t s  See Also   on page 240   on page 271   on page 500   on page 517  xsl:perform-sor t  Changes in 2.0 This instruction is new in XSLT 2.0  Format  <xsl:perform-sort  The   instruction is used to sort a sequence. If you want to process the items in a sequence in sorted order, you can achieve this by adding   elements to an   or   instruction. If you just want to sort the sequence, without processing the items individually, this can be done using  .  select? = {expression}       Position   is an instruction, and may be used anywhere within a sequence constructor.  437   XSLT Elements  Attributes Name select optional  Value XPath Expression  Meaning Returns the input sequence to be sorted.  Content The   instruction always contains one or more   elements to specify the sort order.  In addition, it may contain a sequence constructor. This is an alternative to the select attribute: if the select attribute is present, then the   element must contain only   elements. It can also contain   elements to deﬁne what an XSLT 1.0 processor should do when it encounters this instruction in forward-compatible mode.  Effect The instruction forms an initial sequence by evaluating the expression in the select attribute or the contained sequence constructor, whichever is present. It then sorts this initial sequence to produce a sorted sequence, according to the rules for  , which are given on page 458. The result of the   instruction is the sorted sequence.  Usage and Examples The   instruction is useful when you want to create a sorted sequence in a variable, or as the result of a function. If you want to process items in sorted order you can achieve this using   or  , but these instructions do not deliver the sorted sequence directly as a value in its own right.  For example, you could deﬁne a global variable containing the speakers in a play, sorted alphabetically, by writing:                 The following function returns the earliest and latest date in a sequence of events, as a sequence of two   elements with date attributes:                           438   xsl:preserve-space  See Also   on page 240   on page 322   on page 455  xsl:preser ve-space  The   element, along with  , is used to control the way in which whitespace nodes in the source document are handled.  Changes in 2.0 The syntax of a NameTest has been extended to allow the format «*:NCName», which matches all elements with a given local name, in any namespace.  6  X S L T  l  E e m e n t s  Format  <xsl:preserve-space  elements = tokens  >  Position   is a top-level declaration, which means that it must be a child of the   element. There are no constraints on its ordering relative to other declarations.  Attributes Name elements mandatory  Value Whitespace-separated list of NameTests  Meaning Deﬁnes the elements in the source document whose whitespace-only text nodes are to be preserved  The NameTest construct is deﬁned in XPath, and is described in Chapter 9 on page 614.  Content None, the element is always empty.  Effect This declaration, together with  , deﬁnes the way that whitespace-only text nodes in the source document are handled. Unless contradicted by an   element,   indicates that whitespace-only text nodes occurring as children of a speciﬁed element are to be retained in the source tree.  Preserving whitespace-only text nodes is the default action, so this element only needs to be used where it is necessary to contradict an   element. More speciﬁcally, a whitespace text node is stripped only if  a  it matches a NameTest speciﬁed in an   element, and  b  it does not match a NameTest in an overriding   element.  439   XSLT Elements  The concept of whitespace-only text nodes is explained in Chapter 3  see page 144 . A whitespace-only text node is a text node whose text consists entirely of a sequence of whitespace characters, these being space, tab, carriage return, and linefeed  x20, x09, x0D, and x0A . The   element has no effect on whitespace contained in text nodes that also contain non-whitespace characters; such whitespace is always preserved and is part of the value of the text node.  This declaration also affects the handling of whitespace-only text nodes in any document loaded using functions such as document  , doc  , or collection  . It does not affect the handling of whitespace-only text nodes in the stylesheet, or in documents returned as the result of extension functions or passed to the stylesheet as the value of a stylesheet parameter. Also, the element does not affect anything that happens to the source document before the XSLT processor gets to see it, so if you create the source tree using an XML parser that strips whitespace nodes  as Microsoft’s MSXML3 does, by default , then specifying   in the stylesheet will not get these nodes back — they are already gone.  Although an XML 1.1 parser will recognize the characters «x85» and «x2028» as representing line end- ings, the XSLT processor will not treat these characters as whitespace. It doesn’t need to, because the XML parser will have converted them into regular newline characters.  Before a node is classiﬁed as a whitespace-only text node, the tree is normalized by concatenating all adjacent text nodes. This includes the merging of text that originated in different XML entities, and also text written within CDATA sections.  A whitespace-only text node may either be stripped or preserved. If it is stripped, it is removed from the tree. This means it will never be matched, it will never be copied to the output, and it will never be counted when nodes are numbered. If it is preserved, it is retained on the tree in its original form, subject only to the end-of-line normalization performed by the XML parser.  The elements attribute of   must contain a whitespace-separated list of NameTests. The form of a NameTest is deﬁned in the XPath expression language; see Chapter 9, page 614. Each form of NameTest has an associated priority. The different forms of NameTest and their meanings are:  Syntax  QName  Examples  title svg:width  NCName«:*»  svg:*  «*:»NCName  *:address  Meaning Matches the full element name, including its namespace URI  Matches all elements in the namespace whose URI corresponds to the given preﬁx  Matches all elements with a given local-name, regardless of their namespace  «*»  *  Matches all elements  Priority 0  –0.25  –0.25  –0.5  The priority is used when conﬂicts arise. For example, if the stylesheet speciﬁes:       then whitespace-only text nodes appearing within a   or   will be preserved. Even though these elements match both the   and the  , the NameTest in the latter has higher priority  0 as compared to –0.5 .  440   xsl:preserve-space  If there is an   element that matches the parent element, and also an   element that matches, then the decision depends on the import precedence and priority of the respective rules. Taking into consideration all the   and   elements that match the parent element of the whitespace-only text node, the XSLT processor takes the one with highest import precedence  as deﬁned in the rules for   on page 359 . If there is more than one element with this import precedence, it takes the one with highest priority, as deﬁned in the table above. If there is still more than one, and they are different  one preserve, one strip , the processor may either report an error, or choose the one that comes last in declaration order.  In deciding whether to strip or preserve a whitespace-only text node, only its immediate parent element is considered in the above rules. The rules for its other ancestors make no difference. The element itself, of course, is never removed from the tree: the stripping process will only remove text nodes.  Regardless of the   and   declarations, if an individual ele- ment has the XML-deﬁned attribute «xml:space="preserve"», then all descendant text nodes are preserved, unless this is cancelled by «xml:space="default"». If an   doesn’t seem to be having any effect, one possible reason is that the element type in question is declared in the DTD to have an xml:space attribute with a default value of «preserve». There is no way of overriding this in the stylesheet.  6  X S L T  l  E e m e n t s  The   and   declarations in the stylesheet are also ignored for a whitespace text node that forms the content of an element deﬁned in the schema to have simple content. This is because changing the content of such an element could make it invalid. For example, if the schema deﬁnes the type as having  , then a value consisting of a single space is valid, but the element becomes invalid if the space is removed.  Usage For many categories of source document, especially those used to represent data structures, whitespace- only text nodes are never signiﬁcant, so it is useful to specify:     which will remove them all from the tree. There are two main advantages in stripping these unwanted nodes:    When   is used with a default select attribute, all child nodes will be processed. If whitespace-only text nodes are not stripped, they too will be processed, probably leading to the whitespace being copied to the output destination.    When the position   function is used to determine the position of an element relative to its sib- lings, the whitespace-only text nodes are included in the count. This often leads to the signiﬁcant nodes being numbered 2, 4, 6, 8, . . . .  Generally speaking, it is a good idea to strip whitespace-only text nodes belonging to elements that have element content, that is, elements declared in the DTD as containing child elements but no PCDATA, or declared in a schema to have a complex type with «mixed="no"».  By contrast, stripping whitespace-only text nodes from elements with mixed content  elements declared in the DTD or schema to contain both child elements and PCDATA  is often a bad idea. For example, consider the element below:   He went to  Balliol College   Oxford  to read  Greats    441   XSLT Elements  The space between the   element and the   element is a whitespace-only text node, and it should be preserved, because otherwise when the tags are removed by an application that’s only inter- ested in the text, the words «College» and «Oxford» will run together.  It’s worth noting that many XSLT processors do not physically remove whitespace text nodes from the tree; they only behave as if they did. Whether the nodes are physically removed or whether the processor creates a view of the tree in which these nodes are invisible, whitespace stripping can incur a signiﬁcant cost. However, if whitespace is stripped while the tree is being built from serial XML input, the perfor- mance arguments are reversed: it then becomes cheaper to remove the whitespace nodes than to preserve them. Generally, if whitespace is insigniﬁcant, then it’s best to get rid of it as early as possible.  Examples To strip whitespace nodes from all elements of the source tree:     To strip whitespace nodes from selected elements:     To strip whitespace nodes from all elements except the   element:       To strip whitespace nodes from all elements except those in the namespace with URI http:  mednet.org text:    <xsl:preserve-space elements="mednet:*"  xmlns:mednet="http:  mednet.org text"  >  See Also   on page 465  xsl:processing-instruction  The   instruction is used to write a processing instruction node to the result sequence.  Changes in 2.0 A select attribute has been added. Any leading spaces in the value of the processing instruction are now discarded.  Format  <xsl:processing-instruction  name = { NCName } select? = expression>  442   xsl:processing-instruction        Position   is an instruction. It is always used as part of a sequence constructor.  Attributes Name name mandatory  select optional  Value Attribute value template returning an NCName  Meaning The name  target  of the generated processing instruction  XPath Expression  Used to compute the string value  the data part  of the generated processing instruction  6  X S L T  l  E e m e n t s  Content If the select attribute is present, the element must be empty. If the select attribute is absent, the element may contain a sequence constructor.  Effect The name of the generated processing instruction  in XML terms, the PITarget  is determined by the name attribute. This may be expressed as an attribute value template. The name must be valid as a PITarget as deﬁned in the XML speciﬁcation, and XSLT imposes the additional rule that it must be a valid NCName, as deﬁned in the XML Namespaces Recommendation. This means it must be an XML Name that doesn’t contain a colon  to make it an NCName  and that isn’t the name «xml» in any mixture of upper and lower case  to make it a PITarget .  The speciﬁcation is quite explicit that   cannot be used to generate an XML declaration at the start of the output ﬁle. The XML declaration looks like a processing instruction, but technically it isn’t one, and the ban on using the name «xml» makes this quite explicit. The XML declaration in the output ﬁle is generated automatically by the serializer and can be controlled using the   element.  The string value of the processing instruction  which corresponds to the data part of a processing instruc- tion in XML terms  is generated using either the select attribute or the contained sequence constructor. If neither is present, the string value of the processing instruction node will be a zero-length string.  The space that separates the PITarget from the data is produced automatically when a processing instruction node is serialized. It is not present in the tree model.  The sequence produced by evaluating the select attribute or the contained sequence constructor is converted to a string in the same way as for    see page 258 , except that  a  the sep- arator between adjacent values is always a single space, and  b  any leading whitespace in the value is discarded. The resulting string forms the string value of the new processing instruction.  If the resulting string contains the characters «?>», then a space is inserted between the characters to prevent it terminating the processing instruction.  The data part of a processing instruction cannot contain character references such as «&x20A4;», so an error occurs at serialization time if there are characters that can’t be represented directly in the chosen  443   XSLT Elements  character encoding of the output ﬁle. Some processing instructions may accept data that looks like a char- acter reference, but this is an application-level convention, not something deﬁned in the XML standard, so the XSLT processor will never generate such a reference automatically.  Usage Use this instruction when you want to output a processing instruction.  Processing instructions are not widely used in most XML applications, so you will probably not need to use this instruction very often. They are used even less in HTML, though HTML 4.0 does recommend that any vendor-speciﬁc extensions should be implemented this way. In HTML the terminator for a processing instruction is «>» rather than «?>», and this difference is handled automatically during serialization by the HTML output method; see Chapter 15.  Note that you cannot generate a processing instruction in the output by writing a processing instruction in the stylesheet. Processing instructions in the stylesheet are ignored completely. You can, however, use   or   to copy processing instructions from the source tree to the result tree.  Examples The following example outputs an   processing instruction at the start of the output ﬁle:      href="housestyle.css" type="text css"      The generated output is:     Writing an XSLT stylesheet that produces an XML document that itself refers to a CSS stylesheet isn’t such a crazy thing to do as it might seem. It often makes sense to do the ﬁrst stage of processing of an XML ﬁle on the server, and the second stage in the browser. The ﬁrst stage will extract the data that users want to see — and remove any information they are not allowed to see. The second stage applies the detailed rules for output formatting. The second stage can often be done just as easily with CSS as with XSLT, because anything CSS can’t cope with, such as adding or reordering textual content, can be done in the ﬁrst stage with XSLT.  One point to watch out for in generating an   processing instruction, and which might well apply to other processing instructions, is the use of pseudo-attributes and pseudo-character and -entity references. The text «href="housestyle.css"» in the above example is designed to look like an XML attribute, but it is not actually an XML attribute; it is purely part of the processing instruction data. It is parsed by the application, not by the XML parser. As it is not a true XML attribute, you cannot generate it as an attribute node using the   instruction; rather, it is generated as text.  The rules for the   processing instruction are deﬁned in a short W3 C Recom- mendation called Associating Style Sheets with XML Documents, available at http:  www.w3.org TR  xml-stylesheet. In addition to deﬁning the data part of this processing instruction in the form of pseudo-attributes, the rules also allow the use of numeric character references such as «&x20A4;» and predeﬁned entity references such as «&gt;» and «&amp;». Again, these are not true character references and entity references that the XML parser will recognize, and as a result they will not be generated by the  444   6  X S L T  l  E e m e n t s  xsl:result-document  XSLT processor either. If you want to include «&x20A4;» as part of the data of the processing instruction, you can write, for example:      href="housestyle.css" type="text css"    title="A title containing &amp;x20A4;"       Another way of generating this processing instruction, which might be more suitable if the contents are highly variable, is to write a general template that takes the required information as a parameter. This parameter might be supplied in the form of an element:      housestyle.css   text css   a title      and the processing instruction might be generated by the template:       <xsl:processing-instruction name="{$pi-data @name}"  select="for $att in $pi-data * return     concat name $att , ’=&quot;’, string $att , ’&quot;’ " >  This does not attempt to deal with the problems that arise if there are special characters in the data that need to be escaped. Note that the space that is needed between pseudo-attributes is generated automati- cally, because each pseudo-attribute is produced as one item in the result of the select attribute.  xsl:result-document  The   instruction is used to create a new result tree, and optionally to specify how the result tree should be serialized. The facility allows a transformation to produce multiple result documents, so you can write a stylesheet that splits a large XML ﬁle into smaller XML ﬁles, or into multiple HTML ﬁles, perhaps connected to each other by hyperlinks.  Changes in 2.0 This instruction is new in XSLT 2.0. Many XSLT 1.0 processors provided a similar capability as a propri- etary extension, but there are likely to be differences in the detail. The abandoned working draft of XSLT 1.1 used the name   for a similar instruction, and it was implemented under this name in some products.  Format  <xsl:result-document format? = { qname } href? = { uri-reference } validation? = "strict"  "lax"  "preserve"  "strip" type? = qname method? = { "xml"  "html"  "xhtml"  "text"  qname-but-not-ncname }  445   XSLT Elements  byte-order-mark? = { "yes"  "no" } cdata-section-elements? = { qnames } doctype-public? = { string } doctype-system? = { string } encoding? = { string } escape-uri-attributes? = { "yes"  "no" } include-content-type? = { "yes"  "no" } indent? = { "yes"  "no" } media-type? = { string } normalization-form? = {"NFC""NFD""NFKC""NFKD""fully-normalized"nmtoken} omit-xml-declaration? = { "yes"  "no" } standalone? = { "yes"  "no"  "omit" } undeclare-prefixes? = { "yes"  "no" } use-character-maps? = qnames output-version? = { nmtoken }  >        Position   is an instruction, which means it may occur anywhere in a sequence constructor.  Attributes  Name format optional  href optional  validation optional  type optional  method optional  446  Value Attribute value template returning a lexical QName  Attribute value template returning a relative or absolute URI  Meaning Deﬁnes the required output format.  Deﬁnes the location where the output document will be written after serialization.  «strict», «lax», «preserve», or «strip»  Deﬁnes the validation to be applied to the result tree.  Deﬁnes the schema type against which the document element should be validated.  Deﬁnes the serialization method to be used.  Lexical QName  Attribute value template returning «xml», «html», «xhtml», «text», or a preﬁxed lexical QName  Attribute value template returning a whitespace-separated list of lexical QNames  cdata-section-elements optional  Names those elements whose text content is to be output in the form of CDATA sections.  doctype-public optional  Attribute value template returning a string  Indicates the public identiﬁer to be used in the DOCTYPE declaration in the output ﬁle.  continued   xsl:result-document  Name doctype-system optional  encoding optional  Value Attribute value template returning a string  Attribute value template returning a string  escape-uri-attributes optional  Attribute value template returning «yes» or «no»  include-content-type optional  Attribute value template returning «yes» or «no»  Meaning Indicates the system identiﬁer to be used in the DOCTYPE declaration in the output ﬁle.  Deﬁnes the character encoding.  Indicates whether URI-valued attributes in HTML and XHTML should be percent-encoded.  Indicates whether a   element should be added to the output to indicate the content type and encoding.  indent optional  media-type optional  normalization-form optional  Attribute value template returning «yes» or «no»  Indicates whether the output should be indented to indicate its hierarchic structure.  Attribute value template returning a string  Indicates the media-type  often called MIME type  to be associated with the output ﬁle.  Indicates whether and how the Unicode characters in the serialized document should be normalized.  6  X S L T  l  E e m e n t s  Attribute value template returning «NFC», «NFD», «NFKC», «NFKD», «fully-normalized», «none», or an implementation-deﬁned name in the form of an NMTOKEN.  omit-xml-declaration optional  Attribute value template returning «yes» or «no»  Indicates whether an XML declaration is to be included in the output.  standalone optional  Attribute value template returning «yes», «no», or «omit»  Indicates whether a standalone declaration is to be included in the output, and gives its value.  undeclare-preﬁxes optional  Attribute value template returning «yes» or «no»  use-character-maps optional  Whitespace-separated list of lexical QNames  output-version optional  Attribute value template returning an NMTOKEN  Indicates whether  with XML 1.1 output  namespaces should be undeclared using «xmlns:p=""» when they go out of scope.  A list of the names of   elements that are to be used for character mapping.  Deﬁnes the version of the output format  corresponds to the version attribute of   .  Content The content of the   element is a sequence constructor.  The   element may contain an   element. If it does, the   element deﬁnes the action that an XSLT 1.0 processor will take when it encounters  447   XSLT Elements  the   instruction. Note that the fallback processing only applies if the stylesheet is executing in forward-compatible mode, which will be the case if you set «version="2.0"» on the   element.  Effect When the   instruction is evaluated, a new document node is created, in the same way as for the   instruction. The sequence constructor contained in the   is evaluated to produce a sequence of items, and this sequence is used to form the content of the document node as described under   in the section The Content of the Document on page 303. The tree rooted at this document node is referred to as a ﬁnal result tree.  Validation of the result tree also follows the same rules as  : See Validating and Annotating the Document on page 305. Note that although the validation process  if requested  conceptually creates a result tree in which the elements and attributes are annotated with types, these type annotations will never be seen if the result tree is immediately serialized. But a very useful processing model is to run a series of transformations in a pipeline, where the output of one stylesheet provides the input to the next. The pipeline might also include non-XSLT applications. The new XProc speciﬁcation from W3 C  www.w3.org TR XProc  is designed to standardize the way such pipelines are written.  The difference between   and   is that   adds the new document node to the result sequence, making it available for further processing by the stylesheet, while   outputs the new document as a ﬁnal result of the transformation.  What actually happens to a ﬁnal result tree is to some degree system-dependent, and it is likely that vendors will provide a degree of control over this through the processor API.  Often, the result tree will be serialized  perhaps as XML or HTML  and written to a ﬁle on disk. The location of the ﬁle on disk is controlled using the href attribute, and the format in which it is seri- alized is controlled using the format attribute, supplemented by the serialization attributes  method, byte-order-mark, cdata-section-elements, doctype-public, doctype-system, encoding, escape-uri-attributes, include-content-type, indent, media-type, normalization-form, omit-xml-declaration, standalone, undeclare-prefixes, use-character-maps, and output-version .  If the format attribute is present then its value must be a lexical QName, which must match the name attribute of an   declaration in the stylesheet. The result tree will then be serialized as speciﬁed by that   declaration, except that any serialization attributes provided on the   override the corresponding attributes in the   declaration. All of the serialization attributes except use-character-maps are attribute value templates, which means that their values may be calculated at runtime, perhaps based on a stylesheet parameter or on data in the source document. If there is no format attribute, then the result tree  assuming it is serial- ized at all  will be serialized as speciﬁed by the unnamed   declaration if there is one, or the default serialization rules if not, except that again any serialization attributes provided on the   override the corresponding attributes in the   declaration. The effect of the serialization attributes is fully described in Chapter 15.  The way in which the href attribute is used is deliberately left a little vague in the speciﬁcation, because the details are likely to be implementation-dependent. Its value is a relative or absolute URI. Details of the URI schemes that may be speciﬁed are left entirely to the implementation. The speciﬁcation is also written in such a way that the URI can be interpreted as referring either to the result tree itself or to its serialized  448   xsl:result-document  representation. The important thing that the speciﬁcation says is that it is safe to use relative URIs as links from one output document to another: if you create one result document with «href="chap1.html"» and another with «href="chap2.html"», then the content of the ﬁrst document can include an element such as  next chapter  and expect the link to work, whether the result trees are actually serialized or not. The speciﬁcation achieves this by saying that any relative URI used in the href attribute of an   element is interpreted relative to a Base Output URI, which in effect is supplied in the API that invokes the transformation.  We are used to thinking of URIs rather like ﬁlenames: as addresses of documents found somewhere on the disk. In fact, URIs are intended to be used as unique names for any kind of resource, hence their use for identifying namespaces and collations. Using URIs to identify ﬁnal result trees  which might exist only as a data structure in memory  is no different. Implementations are expected to provide some kind of mechanism in their API to allow the application to process the result tree, given its URI.  One way this might be done is to allow the application, when the transformation is complete, to use a method call such as getResultDocument URI  to get a reference to the result tree with a given URI, perhaps returned in the form of a DOM document.  Another possible mechanism is for the application to supply a resolver or listener object, which is notiﬁed whenever a result tree is created. This is the technique Saxon uses: if a user-written OutputURIResolver has been registered, then it is handed the result tree and the URI, and has free rein in deciding what to do with it.  6  X S L T  l  E e m e n t s  The speciﬁcation of   is complicated by the fact that it is an instruction that has side effects. The instruction does not return a result  technically, it returns an empty sequence, which means it doesn’t affect the result of evaluating the sequence constructor that it is part of . In a pure func- tional language, side effects are always problematical — though, of course, the only purpose of running any program is to change something in the environment in which it is run. Normally, if a compiler knows that a particular construct will return a particular result, then it can generate code that short cuts the eval- uation of this construct. But it would destroy the purpose of   if it did nothing, just because the compiler already knows what result it will return.  To take an example of how this is a problem in practice, suppose that the stylesheet deﬁned a variable as follows:                  Now suppose that this variable is never referenced, or is referenced only as «$dummy[1]». Is the result document produced, or not? Normally, an XSLT optimizer will avoid evaluating variables or parts of variables that aren’t used, but this strategy causes problems if the evaluation of a variable has a side effect.  The way that the XSLT speciﬁcation has dealt with this problem is essentially to say that you can only use   when the sequence constructor you are evaluating is destined to form the content of a ﬁnal result tree. When the stylesheet starts executing, this condition is true for the sequence constructor contained in the ﬁrst template to be evaluated, and it remains true except when you evaluate  449   XSLT Elements    or similar elements such as  ,  , and  . You also can’t use   while evaluating the result of a stylesheet function deﬁned using  , or while computing the content of  ,  ,  ,  ,  ,  , or  . This restriction is a runtime rule rather than a compile-time rule; for example, you can use <xsl:result- document> within   if the template is called from within  , but not if it’s called from within  .  XSLT processors are allowed to evaluate instructions in any order. This means that you can’t reliably predict the order in which ﬁnal result trees get written. There is a rule preventing a stylesheet from writing two different result trees with the same URI, because if overwriting were allowed, the results would be nondeterministic. There is also a rule saying that it’s an error to attempt to write a result tree and then read it back again using the document   function: this would be a sneaky way of exploiting side effects and making your stylesheet dependent on the order of execution. In practice, pro- cessors may have difﬁculty detecting this error, and you might get away with it, especially if you use different spellings of the URI, for example by writing to file:   c: temp.xml and then reading from FILE:   c: temp.xml.  The fact that order of execution is unpredictable has another consequence: if a transformation doesn’t run to completion, because a runtime error occurred  or perhaps because   was used with «terminate="yes"» , then it’s unpredictable as to whether a particular ﬁnal result tree was output before the termination. In practice most processors only exploit the freedom to change the order of execution when evaluating variables or functions, so you are unlikely to run into this problem in practice.  Usage There are two main reasons for using  . One reason is to generate multiple output ﬁles; the other is to exercise control over the validation or serialization of the principal output ﬁle.  Generating multiple output ﬁles is very common in publishing applications. The product documentation for Saxon, for example, consists of around 450 HTML ﬁles, which are generated by a single transforma- tion from 20 input XML ﬁles. Sometimes it’s better to do the transformation in two stages: First, split a large XML document into several small XML documents, and then convert each of these into HTML independently.  One common approach is to generate one principal output ﬁle and a whole family of secondary output ﬁles. The principal output ﬁle can then serve as an index. Usually a key part of the process will be the generation of hyperlinks that allow the user to navigate within the document family. This means you will need some mechanism for generating the ﬁlenames of the output ﬁles. Exactly how you do this depends on what’s available in your input: one approach is to use the generate-id   function, which allocates a unique identiﬁer to every node in your input documents.  Examples The   instruction is often used to break up large documents into manageable chunks. In the section for   on page 433, there is an example of a stylesheet that breaks up one of Shakespeare’s plays to produce a cover page together with one page per scene. But here we’ll illustrate the principle with a much smaller document.  450   6  X S L T  l  E e m e n t s  xsl:result-document  Example: Creating Multiple Output Files  This example takes a poem as input, and outputs each stanza to a separate ﬁle. A more realistic example would be to split a book into its chapters, but I wanted to keep the ﬁles small. Source  The source ﬁle is poem.xml. It starts:     Rupert Brooke   1912   Song     And suddenly the wind comes soft,   And Spring is here again;   And the hawthorn quickens with buds of green   And my heart with buds of pain.       My heart all Winter lay so numb,   The earth so dead and frore,  ...  Stylesheet  The stylesheet is split.xsl. We want to start a new output document for each stanza, so we use the <xsl:result- document> instruction in the template rule for the   element. Its effect is to switch all output produced by its sequence constructor to a different output ﬁle. In fact, it’s very similar to the effect of an   element that creates a tree, except that the tree, instead of being a temporary tree, is serialized directly to an output ﬁle of its own:    <xsl:stylesheet xmlns:xsl="http:  www.w3.org 1999 XSL Transform"     version="2.0">                  <xsl:variable name="file"                  select="concat ’verse’, position  , ’.xml’ " >  451   XSLT Elements  To run this example under Saxon, you need to make sure that an output ﬁle is supplied for the principal output document. This determines the base output URI, and the other output documents will be written to locations that are relative to this base URI. For example: java -jar c:\saxon\saxon9.jar -t -o:c:\temp\index.xmli -s:poem.xml -xsl:split.xsl This will write the index document to c:\temp\index.xml, and the verses to ﬁles such as c:\temp\verse2.xml. The -t option is useful because it tells you exactly where the ﬁles have been written.  Output  The principal output ﬁle contains the skeletal poem below  indented for legibility :        Song   Rupert Brooke   1912            Three further output ﬁles verse1.xml, verse2.xml, and verse3.xml are created in the same directory as the principal output ﬁle. Here is verse1.xml:        And suddenly the wind comes soft,   And Spring is here again;   And the hawthorn quickens with buds of green   And my heart with buds of pain.      For another version of this example, which uses the element-available   function to test whether the   instruction is implemented and takes fallback action if not, see the entry for element-available   on page 764 in Chapter 13.  See Also   on page 420  xsl:sequence  452  The   instruction is used to deliver an arbitrary sequence, which may contain atomic values, nodes, or a combination of the two. It is the only XSLT instruction  with the exception of    that can return references to existing nodes, as distinct from newly constructed nodes. Its most common use is to return the result of a stylesheet function.   Despite its name,   is often used to return a single item.  xsl:sequence  Changes in 2.0 This instruction is new in XSLT 2.0.  Format  <xsl:sequence  select = {expression}  * -->     6  X S L T  l  E e m e n t s  Position   is an instruction, and may be used anywhere within a sequence constructor. It is often used within  , to deﬁne the value that the function returns.  Attributes Name select mandatory  Value XPath Expression  Meaning Computes the value that the   instruction will return.  Content The only content permitted is  . Any contained   instructions will be ignored by an XSLT 2.0 processor but can be used to deﬁne fallback action for an XSLT 1.0 processor.  Effect The XPath expression contained in the select attribute is evaluated, and its result is returned unchanged as the result of the   instruction.  Usage and Examples This innocent-looking instruction introduced in XSLT 2.0 has far-reaching effects on the capability of the XSLT language, because it means that XSLT instructions and sequence constructors  and hence functions and templates  become capable of returning any value allowed by the XPath data model. Without it, XSLT instructions could only be used to create new nodes in a result tree, but with it, they can also return atomic values and references to existing nodes.  To take an example, suppose you want to set a variable whose value is the numeric value of the price attribute of the context node, minus the value of the discount attribute if present. In XSLT 1.0 you might have written:                   453   XSLT Elements             This works, but the problem is that the result is not a number, but a document node  in XSLT 1.0 termi- nology, a result tree fragment  containing a text node that holds a string representation of the number. Not only is this an inefﬁcient way of representing a number, it has also lost the type information, which means that if you use the value in operations that are type-sensitive, such as comparison or sorting, you might get an unexpected answer.  In XSLT 2.0, using the   instruction, you can rewrite this as:                              Within the   and   branches, we now use   rather than  , to avoid creating a text node that we don’t need. Look at the example carefully:              The ﬁrst   instruction contains an XPath arithmetic expression. If the source document has a schema, this assumes that the type of @price and @discount is numeric  typically, xs:decimal , and the result of the subtraction will be the same numeric type. If there is no schema, the nodes will be untyped, and the fact that they are used in an arithmetic expres- sion will force the content of the attribute to be converted to an xs:double, which means that the result of the subtraction will also be an xs:double. The «as» attribute on the   element ensures that whatever the numeric type of the result, it will be converted to an xs:double. The second   instruction simply returns the attribute node @price itself. The «as» attribute on the   element causes the attribute node to be atomized, which extracts its typed value. If there is a schema, the node must be annotated with a numeric type for the conversion to xs:double to succeed. If there is no schema, then the untyped value of the attribute is converted to xs:double by casting. The «as="xs:double"» on the   element ensures that a type error will be reported  typically at runtime  if there is no @price attribute, or if the content of the @price or @discount attribute is not numeric. Unlike the number   function, conversion to xs:double gives an error  rather than NaN  if the input is non-numeric. The ﬁrst   instruction could be replaced by   without any change in the meaning. When the select attribute returns atomic values,   and   have exactly the same effect. If the second   instruction were replaced by  , however, the effect would be subtly different.   would create a copy of the attribute node, which is quite unnecessary in this case.  454   xsl:sort  6  X S L T  l  E e m e n t s    Without the «as="xs:double"» on the   element, all our efforts to return a  numeric value rather than a temporary tree would be wasted; when   has no «select» or «as» attribute, it automatically builds a temporary tree whose content is derived from the value returned by its contained sequence constructor.  It is possible to rewrite this whole construct as:  <xsl:variable name="discounted-price" as="xs:double"  select="if  @discount   then @price - @discount else @price" >  or if you really like brevity, as:  <xsl:variable name="discounted-price" as="xs:double"  select="@price -  @discount, 0 [1]" >  This illustrates that when you are calculating values, you often have a choice as to whether to do the work at the XPath level or at the XSLT level. My own preference with simple expressions such as this is to use the XPath approach, unless there is a need to use facilities that are only available at the XSLT level, such as the ability to create new nodes, or the more powerful instructions available in XSLT such as  ,  , or  .  By far the most common use of   is the evaluation of the result of a stylesheet function, and there are examples of this under   on page 344.  The   instruction also enables template rules to return atomic values, or references to existing nodes. An example of the possibilities this opens up is shown in the section Simulating Higher Order Functions on page 250, which shows a generalized function for ﬁnding cycles in any XML data source, regardless of how the relationships are represented.  See Also   on page 344   on page 292   on page 433  xsl:sor t  The   element is used to deﬁne a component of a sort key. It is used within an  ,  ,  , or   instruc- tion to deﬁne the order in which this instruction processes its data.  Changes in 2.0 The   element may now be used within   and   as well as within   and  .  The value of the sort key may be calculated using an enclosed sequence constructor, as an alternative to using the select attribute.  455   XSLT Elements  In XSLT 1.0,   was always used to sort a set of nodes. In 2.0 it is generalized so that it can sort any sequence.  A collation attribute has been added to allow the collating sequence for strings to be speciﬁed by means of a URI, and a stable attribute has been added to control how duplicates are handled.  Sorting is now sensitive to the types of the items being sorted. For example, if the sort key values are numeric, they will be compared as numbers rather than as strings.  Format  <xsl:sort  select? = expression lang? = { nmtoken } order? = { "ascending"  "descending"} collation? = { uri } case-order? = { "upper-first"  "lower-first"} data-type? = { "text"  "number"  qname-but-not-ncname} > stable? = { "yes"  "no"}       Position   is always a child of  ,  ,  , or  . Any number of sort keys may be speciﬁed, in major-to-minor order.  When used in  ,  , or  , any   elements must appear before the sequence constructor of the containing element.  When used in  , the   elements can come before or after any   elements.  Attributes  Name select optional  order optional  case-order optional  lang optional  data-type optional  456  Value XPath Expression  Meaning Deﬁnes the sort key. The default is «.», the context item itself.  Attribute value template returning «ascending» or «descending»  Deﬁnes whether the nodes are processed in ascending or descending order of this key. The default is «ascending».  Attribute value template returning «upper-first» or «lower-first»  Deﬁnes whether upper-case letters are to be collated before or after lower-case letters. The default is language-dependent.  Attribute value template returning a language code  Deﬁnes the language whose collating conventions are to be used. The default depends on the processing environment.  Attribute value template returning «text», «number» or Lexical QName  Deﬁnes whether the values are to be collated alphabetically or numerically, or using a user-deﬁned type. The default is «text».  continued   6  X S L T  l  E e m e n t s  Name collation optional  stable optional  Value Attribute value template returning collation URI  Attribute value template returning «yes» or «no»  xsl:sort  Meaning The collation URI identiﬁes how strings are to be compared with each other.  This attribute is allowed only on the ﬁrst   element; if set to «no», it indicates that there is no requirement to retain the original order of items that have equal values for all the sort keys.  Except for select, all these attributes can be written as attribute value templates. The context item, context position, and context size for evaluating these attribute value templates are the same as the context for evaluating the select attribute of the containing instruction  that is  ,  ,  , or   .  Content The element may contain a sequence constructor. This is used to compute the sort key value, as an alter- native to using the select attribute. The two are mutually exclusive: if the select attribute is present, the element must be empty, and if it is not empty, the select attribute must be omitted. If neither is present, the default is «select="."».  Effect The list of   elements appearing for example within an   or   element determines the order in which the selected items are processed. The items are sorted ﬁrst by the ﬁrst sort key; any group of items that have duplicate values for the ﬁrst sort key are then sorted by the second sort key, and so on.  It’s useful to start by establishing some clear terminology. There is a tendency to use the phrase sort key with several different meanings, often in the same sentence, so to avoid confusion I’ll try to stick to the more precise terms that are used in the XSLT speciﬁcation itself.                 A collection of   elements, which together deﬁne all the criteria for performing a sort, is called a sort key speciﬁcation. A single   element within the sort key speciﬁcation is called a sort key component. Often, of course, there will only be one component in a sort key speciﬁcation. The result of evaluating a sort key component for one of the items to be sorted is called a sort key value.  So if you are sorting by last name and then ﬁrst name, the sort key speciﬁcation is ‘‘last name, then ﬁrst name;’’ the sort key components are ‘‘last name’’ and ‘‘ﬁrst name,’’ and the sort key values are strings such as "Kay" and "Michael".  It’s also useful to be clear about how we describe the sorting process:  The sequence that provides the input to the sort operation is called the initial sequence. In XSLT 1.0 the initial sequence was always a set of nodes in document order, but in 2.0 it can be any sequence of items  nodes or atomic values  in any order. The sequence that is produced as the output of the sort operation is called  naturally enough  the sorted sequence.  457   XSLT Elements  The overall rules for the sorting operation are fairly intuitive, but it’s worth stating them for completeness:                    Given two items A and B in the initial sequence, their relative positions in the sorted sequence are determined by evaluating all their sort key values, one for each component in the sort key speciﬁcation. The relative positions of A and B depend on the ﬁrst pair of sort key values that is different for A and B; the second pair of sort key values needs to be considered only if the ﬁrst sort key val- ues for the two items are equal, and so on. For example, if you are sorting by last name and then ﬁrst name, the system will only need to consider the ﬁrst name for two individuals who have the same last name. I will explain later exactly what it means for one sort key value to be considered equal to another. Considering only this pair of sort key values, A comes before B in the sorted sequence if A’s value for this sort key component is less than B’s value, unless «order="descending"» is spec- iﬁed for this sort key component, in which case it comes after B. I will explain later what it means for one sort key value to be less than another. If all the sort key values for A and B are the same, then A and B appear in the sorted sequence in the same relative positions that they had in the initial sequence  the technical term for this is that the sort is stable . However, if «stable="no"» is speciﬁed on the ﬁrst   element, this requirement is waived, and the system can return duplicates in any order.  The sort key value for each item in the initial sequence is established by evaluating the expression given in the select attribute, or by evaluating the contained sequence constructor. This is evaluated for each item, with this item as the context item, with its position in the initial sequence as the context position, and with the number of items in the initial sequence as the context size.  This means that if you want to process a sequence in reverse order, you can specify a sort key as:     You can also achieve other crafty effects: try, for example, sorting by «position   mod 3». This can be useful if you need to arrange data vertically in a table.  This just leaves the question of how the system decides whether one sort key value is equal to or less than another. The basic rule is that the result is decided using the XPath «eq» and «lt» operators. These are essentially the same as the «=» and «<» operators, except that they only compare a single atomic value to another single atomic value, and perform no type conversions other than numeric promotion  which means, for example, that if one operand is an integer and the other is a double, the integer will be converted to a double in order to perform the comparison .  There are several caveats to this general rule:  The «lt» operator may raise an error when comparing values of different types  such as a num- ber and a date  or when comparing two values of the same type for which no ordering relation is deﬁned  for example, instances of the type xs:QName . This is treated as a fatal error. The   element has an attribute data-type. This is only there for backward compati- bility with XSLT 1.0, but you can still use it. If the value of the attribute is «text», then the sort key values are converted to strings  using the string   function  before being compared. If the value is «number», then they are converted to numbers using the number   function. The attribute also allows the value to be a preﬁxed QName, but the meaning of this depends entirely  458   xsl:sort  on the implementation. The feature was probably added to XSLT 1.0 to anticipate the use of schema-deﬁned type names such as xs:date, and the implementation may allow this usage, but it’s not deﬁned in the standard. Instead, if you want to convert the sort key values to a particular type to do the comparison, you can achieve this using a cast or constructor function within the select attribute; for example, «select="xs:date @date-of-birth "». Another option that has been retained for backward compatibility with XSLT 1.0 is the ability to supply a sequence of values as the result of the select attribute, rather than a single value. If the   element is in backward-compatibility mode  that is, if it’s in the scope of an [xsl:]version attribute whose value is «1.0» , then all items in the sort key value after the ﬁrst are ignored. Otherise, supplying a sequence of more than one item as the sort key value will cause an error. It is possible that evaluating a sort key value will return the empty sequence. XSLT speciﬁes that for sorting purposes, the empty sequence is considered to be equal to itself and less than any other value. Another possibility is that when evaluating a numeric sort key value, the value will be the special value NaN  not a number . This would happen, for example, if you specify «select=" number @price "» and the element has no price attribute, or a price attribute whose value is «$10.00»  the «$» sign will cause the conversion to a number to fail . For sorting purposes, NaN is considered equal to itself, and less than any other numeric value  but greater than an empty sequence . This is different from the results of using the XPath comparison operators, where «eq» returns false if both operands are NaN. Last but not least, if the two values are strings, then they are compared using a collation. Colla- tions are a broad subject so we will devote a separate section to them.  6  X S L T  l  E e m e n t s              The order attribute speciﬁes whether the order is ascending or descending. Descending order will pro- duce the opposite result of ascending order. This means, for example, that NaN values will appear last rather than ﬁrst, and also that the effect of the case-order attribute is reversed: If you specify «case-order="upper-first"» with «order="descending"», then drall will come before Drall.  The ﬁnal sorted order of the items determines the sequence in which they are processed by the containing  ,   , or   instruction, or the order in which they are returned by the containing   instruction. While the sorted sequence is being processed, the value of position  will reﬂect the position of the current item in the sorted sequence.  Collations When the sort key values to be compared are strings, they are compared using a collation. A collation is essentially a mechanism for deciding whether two strings such as «polish» and «Polish» are considered equal, and if not, which of them should come ﬁrst.  Choosing the right collation depends on the data that you are sorting, and on the expectations of the users. These expectations vary by country  in Germany, in most modern publications, «¨a» is sorted along with «a», but in Sweden, it is sorted after «z»  and also vary according to the application. Telephone directories, dictionaries, gazetteers, and back-of-book indexes each have their own rules.  XSLT 2.0 and XPath 2.0 share similar mechanisms for dealing with collations, because they are needed not only in sorting but also in deﬁning what operators such as «eq» mean, and in functions such as distinct-values  . The assumption behind the design is that many computing environments  for example the Windows operating system, the Java virtual machine, or the Oracle database platform   459   XSLT Elements  already include extensive mechanisms for deﬁning and customizing collations, and that XSLT proces- sors will be written to take advantage of these. As a result, sorting order will not be identical between different implementations.  The basic model is that a collation  a set of rules for determining string ordering  is identiﬁed by a URI. Like a namespace URI, this is an abstract identiﬁer, not necessarily the location of a document some- where on the Web. The form of the URI, and its meaning, is entirely up to the implementation. There is a proposal  RFC 4790  for IANA  the Internet Assigned Numbers Authority  to set up a register of collation names, but even if this comes to fruition, it will still be up to the implementation to decide whether to support these registered collations or not. Until such time, the best you can do to achieve interoperability is pass the collation URI to the stylesheet as a parameter; the API can then sort out the logic for choosing different collations according to which processor you are using.  The Unicode consortium has published an algorithm for collating strings called the Unicode Collation Algorithm  see http:  www.unicode.org unicode reports tr10 index.html . Although the XSLT speciﬁcation refers to this document, it doesn’t say that implementations have to support it. In practice, many of the facilities available in platforms such as Windows and Java are closely based on this algo- rithm. The Unicode Collation Algorithm is not itself a collation, because it can be parameterized. Rather, it is a framework for deﬁning a collation with the particular properties that you are looking for.  You can specify the URI of the collation to be used in the collation attribute of the   element. This is an attribute value template, so you can write   to use a collation that has been passed to the stylesheet as a parameter.  There is one collation URI that every implementation is required to support, called the Unicode codepoint collation  not to be confused with the Unicode Collation Algorithm mentioned earlier . This is selected using the URI  http:  www.w3.org 2005 xpath-functions collation codepoint  Under the codepoint collation, strings are simply compared using the numeric code values of the char- acters in the string: if two characters have the same Unicode codepoint they are equal, and if one has a numerically lower Unicode codepoint, then it comes ﬁrst. This isn’t a very sophisticated or user-friendly algorithm, but it has the advantage of being fast. If you are sorting strings that use a limited alphabet, for example part numbers, then it is probably perfectly adequate.  Codepoint collation is subtly different from string comparisons in languages such as Java. Java represents Greek Zero Sign  x1018A  as a surrogate pair  xD800, xDD8A , and therefore sorts it before Wavy Overline  xFE4B . In XSLT, Wavy Overline comes ﬁrst because its codepoint is lower.  If you specify a collation that the implementation doesn’t recognize, then it raises an error. However, the word ‘‘recognize’’ is deliberately vague. An implementation could choose to recognize every possible collation URI that you might throw at it, and never raise this error at all. More probably, an implementa- tion might decide to use parameterized URIs  for example, allowing a component such as «language=fr» to select the target language , and it’s then an implementation decision whether to ‘‘recognize’’ a URI that contains invalid or missing parameters.  If you don’t specify the collation attribute on  , you can provide a hint as to what kind of collation you want by specifying the lang and or case-order attributes. These are retained from XSLT 1.0, which didn’t support explicit collation URIs, but they are still available for use in 2.0.  460   xsl:sort  6  X S L T  l  E e m e n t s        The lang attribute speciﬁes the language whose collation rules are to be used  this might be the language of the data, or the language of the target user . Its value is speciﬁed in the same way as the standard xml:lang attribute deﬁned in the XML speciﬁcation, for example «lang="en-US"» refers to U.S. English and «lang="fr-CA"» refers to Canadian French. Knowing the language doesn’t help you decide whether upper-case or lower-case letters should come ﬁrst  every dictionary in the world has its own rules on this , so XSLT makes this a sepa- rate attribute, case-order. Generally, case order will be used only to decide the ordering of two words that compare equal if case is ignored. For example, in German, where an initial upper-case letter can change the meaning of a word, some dictionaries list the adjective drall  meaning plump or buxom  before the unrelated noun Drall  a swerve, twist, or bias , while others reverse the order. Specifying «case-order="lower-first"» would place drall immediately before Drall, while «case-order="upper-first"» would have Drall immediately followed by drall.  If you say nothing at all about the collation you want, then the default is implementation-deﬁned. For XPath operators and functions, the default is always the Unicode codepoint collation, but this is not necessarily the default for  .  Usage In this section we’ll consider two speciﬁc aspects of sorting that tend to be troublesome. The ﬁrst is the choice of a collation, and the second is how to achieve dynamic sorting — that is, sorting on a key chosen by the user at runtime, perhaps by clicking on a column heading.  Using Collations XSLT is designed to be capable of handling serious professional publishing applications, and clearly this requires some fairly powerful sorting capabilities. In practice, however, the most demanding applications almost invariably have domain-speciﬁc collating rules; for instance, the rules for sorting personal names in a telephone directory are unlikely to work well for geographical names in a gazetteer. This is why the working groups decided to make the speciﬁcation so open-ended in its support for collations.  Collations based on the Unicode collation algorithm  UCA  generally assign each character in the sort key value a set of weights. The primary weight distinguishes characters that are fundamentally different: «A» is different from «B». The secondary weight distinguishes secondary differences; for example, the distinction between «A» and «¨A». The tertiary weight is used to represent the difference between upper and lower case, for example «A» and «a». The way that weights are used varies a little in non-Latin scripts, but the principles are similar.  Rather than looking at each character separately, the Unicode collation algorithm compares two strings as a whole. First, it looks to see if there are two characters whose primary weights differ; if so, the ﬁrst such character determines the ordering. If all the primary weights are the same, it looks at the sec- ondary weights, and it only considers the tertiary weights if all the secondary weights are the same. This means for example that in French, «attache» sorts before «attach´e», which in turn sorts before «attachement». The acute accent is taken into account when comparing «attache» with «attach´e», because there is no primary difference between the strings, but it is ignored when comparing «attach´e» with «attachement», because in this case there is a primary difference.  The strength of a collation determines what kind of differences it takes into account. For comparing equal- ity between strings, it is often appropriate to use a collation with weak strength; for example, a collation  461   XSLT Elements  with primary strength will treat «attache» as equal to «attach´e».  In French this is not necessarily the right thing to do, as these two words have completely different meanings, but it would be appropriate if there is a high possibility that accents have been omitted from one of the strings.  When sorting, however, it is almost always best to use a collation with high strength, which will take secondary, and if necessary tertiary, differences into account when there are no primary differences.  Sometimes it is better, rather than deﬁning two separate sort key components, to concatenate the sort key values into a single sort key component. For example, if you deﬁne a single sort key component as:     this might give better results than:       This is because in the second case above, a tertiary difference in the last name is considered more signiﬁcant than a primary difference in the ﬁrst name: so «MacMillan Tricia» will be sorted before «Macmillan Harold». When the sort key values are concatenated, the difference between «MacMillan» and «Macmillan» is only taken into account when the ﬁrst names are the same.  To reproduce the order of entries found in a UK phone book, you would need a collation that interleaves the Macdonalds and McDonalds, but this is beyond the scope of the UCA.   Dynamic Sort Keys The select attribute contains an expression which is evaluated for each item in the initial sequence, with that item as the context item, to give the value that determines the item’s position in the sequence. There’s no direct way of specifying that you want to use different sort keys on different occasions. I’ve seen people try to write things like:    . . .        hoping that if $sort-key is set to «TITLE», the elements will be sorted by title, and that if $sort-key is set to «AUTHOR», they will be sorted by author. This doesn’t work: the variable $sort-key has the same value for every   element, so the books will always be output in unsorted order. In this case, where the sort key is always a child element of the elements being sorted, you can achieve the required effect by writing:     Another way of making the sort conditional is to use a conditional expression as the sort key. This is much easier in XSLT 2.0 with the introduction of conditional expressions in XPath:  <xsl:sort select="if  $sort-key = ’title’  then title  else if  $sort-key = ’author’  then author else if  $sort-key = ’isbn’  then isbn else publisher">  If the computation of the sort key is really complicated, you can do it in a sequence constructor rather than in the select attribute. This can even invoke templates or build temporary trees — there are no limits.  462   xsl:sort  There are two other solutions to this problem that are worth mentioning, although both have their disadvantages:  One is to generate or modify the stylesheet before compiling it, so that it includes the actual sort key required. This technique is popular when transformations are executed in the browser, typ- ically under the control of JavaScript code in the HTML page. The stylesheet is then typically loaded from the server and parsed into a DOM document, which can be modiﬁed in situ before the transformation starts. The disadvantage is that this means recompiling the stylesheet each time it is run: this would probably be an unacceptable overhead if the transformation is running server-side within a Web server. Another is to use an extension function that permits the evaluation of XPath expressions that have been constructed dynamically, as strings. Such a function, dyn:evaluate  , is deﬁned in the third-party function library at http:  www.exslt.org , and is available in this or a similar form with a number of XSLT processors including Saxon and Xalan.  6  X S L T  l  E e m e n t s  Examples I’ll start with a couple of simple examples and then show a full working example that you can download and try yourself.  Example 1: Process all the   children of the current node, sorting them by the value of the isbn attribute:           Example 2: Output the contents of all the   elements in the document, in alphabetical order, including each distinct city once only:                               If «select="."» were omitted from the   element, the effect would be the same, because this is the default, but I prefer to include it for clarity.  Example: Sorting on the Result of a Calculation  This example outputs a list of products, sorted by the total sales of each product, in descend- ing order.  Source  This is the ﬁle products.xml:          463   XSLT Elements                              Stylesheet  products.xsl is a complete stylesheet written using the simpliﬁed stylesheet syntax, in which the entire stylesheet module is written as a single literal result element. Simpliﬁed stylesheets are described in Chapter 3, on page 125. The   element sorts the selected nodes  all the   elements  in descend- ing order of the numerical total of the sales attribute over all their   child elements. The total is calculated using the sum   function  described on page 889  and displayed using the format-number   function  page 788 .  <products xsl:version="2.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform">       <product name="{@name}"  sales="{format-number sum region @sales , ’$0.00’ }" >       For this to work correctly under XSLT 1.0, you need to add «data-type="number"» to the   element. This is not needed with XSLT 2.0 because the type is recognized auto- matically.  Output  I have added line breaks for readability:               See Also   on page 240   on page 322  464   xsl:stylesheet    on page 326   on page 437  xsl:strip-space  The   declaration, along with  , is used to control the way in which whitespace nodes in the source document are handled. The   declaration identiﬁes elements in which whitespace-only text nodes are considered insigniﬁcant, so they can be removed from the source tree.  Changes in 2.0 The syntax of a NameTest has been extended to allow the format «*:NCName», which matches all elements with a given local name, in any namespace.  6  X S L T  l  E e m e n t s  Format  <xsl:strip-space  elements = tokens  >  Position   is a top-level declaration, which means it is always a child of the   element. There are no constraints on where it appears relative to other declarations.  Attributes Name elements mandatory  Value Whitespace-separated list of NameTests  Meaning Deﬁnes elements in the source document whose whitespace-only text nodes are to be removed  The construct NameTest is deﬁned in XPath, and is described in Chapter 9, on page 614.  Content None, the element is always empty.  Effect, Usage, and Examples See   on page 439. The two elements   and   are closely related, so I have presented the rules and usage guidance in one place.  See Also   on page 439   on page 492 xsl:stylesheet  The   element is the outermost element of a stylesheet. The synonym   can be used as an alternative.  465   XSLT Elements  Changes in 2.0 A number of new attributes have been added: xpath-default-namespace, default-collation, default-validation, input-type-annotation, and use-when. Several of these attributes, although usu- ally used on the   element and described here for convenience, can actually be used on any XSLT element in the stylesheet.  Format  <xsl:stylesheet  id? = id default-collation? = uri-list default-validation? = "preserve"  "strip" exclude-result-prefixes? = tokens extension-element-prefixes? = tokens input-type-annotations? = "preserve"  "strip"  "unspecified" use-when? = expression version = number xpath-default-namespace? = uri       Position    or its synonym,    appears as the outermost element of every stylesheet module, except one that uses the simpliﬁed–stylesheet syntax described on page 125, in Chapter 3. It is used both on a principal stylesheet module and on one that is imported or included into another module.  As described in Chapter 3, a stylesheet can be embedded in another XML document. In this case the   element still forms the root of the stylesheet module, but it is no longer the outermost element of an XML document.  Namespace Declarations There will always be at least one namespace declaration on the   element, typically:  xmlns:xsl="http:  www.w3.org 1999 XSL Transform"  This deﬁnes the XSLT Namespace, which is necessary to identify the document as an XSLT stylesheet. The URI part must be written exactly as shown. The preﬁx «xsl» is conventional and is used in all XSLT documentation, including this book and the standard itself, but you could choose a different preﬁx if you wanted; for example, «XSLT». You would then have to name the element   instead of  .  You can also make this the default namespace by using the following declaration:  xmlns="http:  www.w3.org 1999 XSL Transform"  In this case the element name will simply be  , and other XSLT elements will similarly be unpreﬁxed; for example,   rather than  . Although this works, it is not generally recommended, because the default namespace is then not available for literal result elements. The technique that works best is to reserve the default namespace for literal result elements that you want to go in the default namespace of the output document.  466   xsl:stylesheet  You may come across a stylesheet that uses the namespace declaration: xmlns:xsl="http:  www.w3.org TR WD-xsl"  This is not an XSLT stylesheet at all, but one written in WD-xsl, the working-draft dialect of XSL that Microsoft shipped in 1998 with Internet Explorer 5. This is a very different language, and is not described in this book.  Many stylesheets also need to declare the XML Schema namespace, typically as:  xmlns:xs="http:  www.w3.org 2001 XMLSchema"  This is needed to declare the types of variables or parameters, or to use conversions to types such as xs:integer and xs:date.  6  X S L T  l  E e m e n t s  Attributes  Name id optional  default-collation optional  default-validation optional  Value XML Name  Meaning An identiﬁer used to identify the   element when it is embedded in another XML document.  Whitespace-separated list of URIs  Deﬁnes the default collation to be used for XPath functions and operators.  «preserve» or «strip» Deﬁnes the validation applied to new element and attribute nodes when the instruction that creates them does not have an [xsl:]validation or [xsl:]type attribute. The detault is «strip».  exclude-result-preﬁxes optional  Whitespace-separated list of NCNames  Deﬁnes any namespaces used in this stylesheet that should not be copied to the output destination, unless they are actually used in the result document.  extension-element-preﬁxes optional  Whitespace-separated list of NCNames  Deﬁnes any namespaces used in this stylesheet to identify extension elements.  input-type-annotations optional  «preserve», «strip», or «unspecified»  Deﬁnes how type annotations on input documents should be handled.  use-when optional  XPath expression, restricted to use information available at compile time  Deﬁnes a condition that must be true if the contents of this stylesheet module are to be included in the stylesheet. It must be possible to evaluate the condition statically, which means it will often consist of a test on the value of the system-property   function.  continued  467   XSLT Elements  Name version mandatory  Value Number  xpath-default-namespace optional  Namespace URI  Meaning Deﬁnes the version of XSLT required by this stylesheet. Use «2.0» for a stylesheet that requires XSLT 2.0 features, or «1.0» if you want the stylesheet to be portable between XSLT 1.0 and XSLT 2.0 processors.  Deﬁnes the namespace URI that is assumed for unpreﬁxed element names and type names occurring in XPath expressions, patterns, and certain other constructs such as the SequenceType in an as attribute.  The attributes default-collation, exclude-result-prefixes, extension-element-prefixes, version, use-when, and xpath-default-namespace can be speciﬁed on any element in the XSLT names- pace. They can also be used on literal result elements, though in this case the attribute must be in the XSLT namespace, to distinguish it from user-deﬁned attributes that are to be copied to the result tree. Collectively these attributes are referred to by names such as [xsl:]version, since they are sometimes namespace-preﬁxed.  These attributes are described here because they are usually used on the   element. They are not included in the proforma of other XSLT elements in order to save space.  The [xsl:]use-when attribute is more likely to appear on elements in a stylesheet other than the   or   element. This attribute allows you to specify a compile-time conditional expression, and the element on which it appears will be included in the compiled stylesheet only if this condition is true. If the attribute is present on the   or   element and takes the value false, the effect is as if the stylesheet module contained no top-level declarations. This attribute is described on page 127.  In the case of default-collation, version and xpath-default-namespace, the effective value of the attribute for a particular instruction in the stylesheet is the value on the nearest enclosing element, or the instruction itself, that has a value for this attribute. In the case of extension-element-prefixes and exclude-result-prefixes, the values are cumulative — a namespace is an extension namespace or excluded namespace if it is listed as such on some enclosing instruction.  In practice the most useful place to specify these attributes is often on the   or   declarations, in which case they apply to the body of a template or function.  The sections below  starting with The id Attribute  consider each of the attributes in turn, describing ﬁrst the formal rules for the attribute, then advice on usage and examples where appropriate.  Content The   element may contain XSLT elements referred to as top-level declarations. These elements are:         468   xsl:stylesheet  6  X S L T  l  E e m e n t s                           If there are any   elements, they must come before other top-level declarations.  The   element may also contain other elements provided they use a non-null name- space URI that is different from the XSLT namespace URI. If the namespace URI is recognized by the XSLT processor, it may interpret such elements in any way the vendor chooses, provided that the correct functioning of the stylesheet is not affected. If it does not recognize these elements, it should ignore them.  The id Attribute This attribute allows an   element to be referenced when it is contained within another XML document.  Effect The precise usage is not deﬁned in the standard, but the expectation is that this id attribute will allow an embedded stylesheet to be referenced in an   processing instruction. An example is given in Chapter 3 on page 102. The speciﬁcation points out that for this to work, it may be necessary for the id attribute to be declared in a DTD or schema as having the attribute type ID. However, not all XSLT processors impose this restriction.  Usage If the XSLT processor you are using supports embedding of stylesheets within the source document that they are to transform, then the typical layout will be like this:      <!DOCTYPE data [     ]>   ... ...  <xsl:stylesheet id="style" version="2.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform"  >             469   XSLT Elements  Note that when this structure is used, the stylesheet will be presented with the entire source document, including a copy of itself. The stylesheet therefore needs to be written to handle its own elements in an appropriate way, hence the empty template rule that matches all elements in the XSLT namespace.  XSLT 2.0 deﬁnes the media type  MIME type  «application xslt+xml» for XSLT stylesheet modules, but the unofﬁcial usage «text xsl» is much more widely supported in today’s products.  The default-collation Attribute This attribute can be used at the   level to deﬁne the default collation used for all XPath expressions within the stylesheet module. It does not affect included or imported modules. The attribute can also appear on any other XSLT element  or, preﬁxed as xsl:default-collation, on a literal result element  to deﬁne a default with more local scope.  Effect Collations are discussed under   on page 459. However, collations are used not only when sorting but also whenever strings are compared. The default collation is used by operators such as «eq», «lt», «=», or «<», and by functions such as min  , max  , distinct-values  , and index-of   whenever no other collation is speciﬁed. As well as deﬁning the collation used by these XPath operators and functions, the [xsl:]default-collation attribute also affects XSLT elements such   and  . One place that is not affected by this attribute, curiously, is   itself.  Usage To allow interoperability, the attribute can be speciﬁed as a list of collation URIs, separated by white- space. The processor will use as the default collation the ﬁrst URI that it recognizes. This means that if you want to write a stylesheet that works under processors produced by Microsoft, IBM, and Oracle, and if each of these vendors supports different ﬂavors of collation URI, then you can list your preferred collation for each of these vendors, and the product will pick the one that it understands. If the processor doesn’t recognize any of the URIs, then it reports an error. You can avoid this error by including the Unicode codepoint collation, http:  www.w3.org 2005 xpath-functions collation codepoint, as the last URI in the list.  It’s permitted to use a relative URI, in which case it is resolved against the base URI of the element where it appears. This option is only likely to be useful in the case of a vendor who implements collation URIs as references to real documents, perhaps an XML document that contains a machine-readable speciﬁcation of the collation rules.  The default-validation Attribute Like most of the attributes on the   element, the default-validation attribute applies to everything that is textually within the stylesheet module. Unlike others, it can’t be overridden with a different declaration on an inner element in the stylesheet.  I don’t think there’s any good reason for this restriction; it was put there simply to avoid adding unnecessary complexity .  Effect This attribute applies to every instruction in the stylesheet that is allowed to take a validation or type attribute, provided neither of these attributes is actually present. It also affects literal result elements, which are allowed to take an xsl:type or xsl:validation attribute, in the same way. The effect is to supply a default value for the [xsl:]validation attribute on these instructions or literal result elements.  The possible values of the attribute are «preserve» and «strip», the default being «strip».  At one time the values «strict» and «lax» were also allowed, which explains the name of the attribute, but  470   xsl:stylesheet  experience showed that these options were not useful.  The meanings of these values are explained under each instruction that takes a validation attribute, and vary slightly from one instruction to another, depending on whether it is dealing with single nodes or multiple nodes, elements or attributes.  Usage This attribute affects every literal result element, and every  ,  ,   and   instruction within the stylesheet module, unless it has its own validation or type attribute.  Since the default is «validation="strip"», the only real question to consider is when to use «validation="preserve"». Given a schema-aware processor, and a stylesheet whose main job is to copy a selection of the nodes from the source document across to the result document with as few changes as possible, for further transformation by another stylesheet later on in the pipeline, it makes sense to preserve all the existing type annotations. However, check the speciﬁcation of the individual instruc- tions.   probably doesn’t do what you imagine. Since   can completely change the content of an element, the type annotation on the element being copied is no longer reliable, so it isn’t retained, even with this option. When a subtree is copied in its entirety, with no changes  typically using   , it makes sense to retain type annotations. As soon as any changes are made, the result can only contain type annotations if you put it through schema validation.  6  X S L T  l  E e m e n t s  The exclude-result-preﬁxes Attribute This attribute deﬁnes a set of namespaces that are not to be copied into the result tree.  The XSLT processor is required to produce a correct tree that conforms with the XDM data model  as described on page 45, in Chapter 2  and with the XML Namespaces rules, so you will never ﬁnd your- self with an output ﬁle using namespace preﬁxes that have not been declared. However, you can easily ﬁnd yourself with a ﬁle containing unnecessary and unwanted namespace declarations; for example, declarations of namespaces that occur on nodes in your source document but are not used in the out- put document, or namespaces for extension functions that are used only in the stylesheet. These extra namespace declarations usually don’t matter, because they don’t affect the meaning of the output ﬁle, but they can clutter it up. They can also affect validation if you are trying to create a result document that conforms to a particular DTD. So this attribute is provided to help you get rid of them.  Effect The XSLT speciﬁcation requires that when a literal result element in the stylesheet is evaluated, the element is copied into the result tree along with all its namespace nodes, except for the XSLT name- space and any namespace that deﬁnes extension instructions. An element has a namespace node for every namespace that is in scope, including namespaces deﬁned on ancestor elements as well as on the element itself, so the namespaces copied over include not only the namespaces deﬁned on the literal result ele- ment, and those that are actually used on the literal result element, but even those that are merely available for use.  Very often, of course, one literal result element will be a child or descendant of another, and the name- space nodes on the child element will include copies of all the namespace nodes on the parent element. For example, consider the stylesheet below:  <xsl:stylesheet version="1.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" >     471   XSLT Elements        Once upon a time ...              This is represented by the tree shown in Figure 6-12, using the same notation as previously seen in Chapters 2 and 3. Although there are only two namespace declarations, these are propagated to all the descendant elements, so for example the   element has two namespace nodes even though there are no namespace declarations on the element.  It also has a namespace node for the «xml» namespace, which is not shown in Figure 6-12.   namespace  http:  ... Transform  namespace  http:  ... Transform  namespace  xsl  xsl  xsl  xsl  namespace  namespace  acme  namespace  acme  http:  ... Transform  http:  acme.com xslt  http:  ... Transform  http:  acme.com xslt  *  *  *  *  *  document  element  xsl:stylesheet  element  xsl:template  element  acme:document  element  acme:chapter  text  Once upon a time  Figure 6-12  472   The speciﬁcation says that each literal result element is copied with all its namespace nodes  but exclud- ing the XSLT namespace , so the result tree will resemble Figure 6-13  again, the «xml» namespace nodes are omitted .  xsl:stylesheet  namespace  acme  http:  acme.com xslt  namespace  acme  http:  acme.com xslt  6  X S L T  l  E e m e n t s  document  element  acme:document  element  acme:chapter  *  *  *  text  Once upon a time  Figure 6-13  Both elements,   and  , have a namespace node for the «acme» namespace. However, this doesn’t mean that the namespace declaration will be repeated unneces- sarily in the output ﬁle: we’re talking here about the abstract tree that is created, not the ﬁnal serial- ized XML ﬁle. Avoiding duplicate namespace declarations is entirely the job of the XSLT serializer, and most serializers will produce the following output, shown indented for clarity:        Once upon a time ...        What exclude-result-preﬁxes Does The exclude-result-prefixes attribute isn’t present to get rid of duplicate declarations, it’s present to get rid of declarations that aren’t wanted at all, which is a different matter entirely. For example suppose the stylesheet were like this:  <xsl:stylesheet version="1.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" xmlns:var="http:  another.org xslt"   >     473   XSLT Elements           Once upon a time ...              Then although the sequence constructor has not changed, the   and   elements each now have an extra namespace node, and this will be copied to the output ﬁle even though it is unused, resulting in the output:  <acme:document xmlns:acme="http:  acme.com xslt"  xmlns:var="http:  another.org xslt">     Once upon a time ...        Why can’t the XSLT processor simply include all the namespaces that are actually used in element and attribute names, and omit the rest? The reason is that many XML applications, like XSLT itself, will use the namespace mechanism to create unique values within their own data. For example, namespace preﬁxes might be used in attribute values as well as attribute names. The XSLT processor can’t distinguish these from ordinary values, so it has to play safe.  So if there are namespaces you don’t want in the output tree, you can specify them in the exclude- result-prefixes attribute of the   element. The attribute is a list of namespace preﬁxes, separated by whitespace, and with the option to exclude the default namespace under the pseu- dopreﬁx «default». If you want more precise control  though it is rarely needed , you can also specify [xsl:]exclude-result-prefixes on any element in the stylesheet, remembering that the attribute must be preﬁxed when it appears on a literal result element, and unpreﬁxed when it appears on an XSLT element. It affects all literal result elements that are textually within its scope.  The preﬁx, as always, is simply a way of referring to the associated namespace URI: it is the namespace URI that is really being excluded, not the preﬁx itself. So if the same namespace URI is declared again with a different preﬁx, it is still an excluded namespace.  What exclude-result-preﬁxes Doesn’t Do The [xsl:]exclude-result-prefixes attribute applies only to namespace nodes copied from the stylesheet using literal result elements. It does not affect namespace nodes copied from the source doc- ument using   or  ; these can be suppressed by using the copy-namespaces attribute on the instruction itself.  Like the other attributes on the   element, the exclude-result-prefixes attribute applies only to elements actually within the stylesheet module, not to those brought in using   or  .  What happens if you try to exclude a namespace that is actually needed because it is used in the result tree? The XSLT processor is obliged to generate output that conforms to the Namespaces Recommenda- tion, so it will ignore the request to exclude this namespace. Or more accurately, the evaluation of the literal result element will not cause the namespace node to be copied, but the namespace ﬁxup process  474   xsl:stylesheet  that comes into play when the element has been constructed will then generate namespace nodes for any namespaces that were missing. Namespace ﬁxup is described under   on page 310.  Using exclude-result-prefixes will never move an element or attribute into a different namespace. People sometimes see an element such as   in the output, and ask how to get rid of the «xmlns=""». The answer is: look at the code that’s generating the   element, and change it to put the element in the proper namespace. If the   element is in the same namespace as its parent, then the serializer won’t need to generate the «xmlns=""» declaration.  Usage The simplest way to decide which namespace preﬁxes to list here is by trial and error. Run the stylesheet, and if the output document contains namespace declarations that clearly serve no useful purpose, add them to the exclude-result-prefixes attribute and run the stylesheet again.  The XSLT namespace itself and namespaces used for extension elements will be excluded automatically. However, the stylesheet is also likely to contain references to the schema namespace, which you may not want in your result document. It will also contain any namespace you have used for deﬁning your local stylesheet functions, which you almost certainly don’t want in the result document.  6  X S L T  l  E e m e n t s  A common cause of unwanted namespace declarations ﬁnding their way into the result document is where your stylesheet needs to refer to namespaces used in the source document; for example, in a template match pattern, but where none of these elements is copied into the destination document.  For example:  <xsl:stylesheet  version="2.0" xmlns:xsl="http:  www.w3.org 1999 XSL Transform" xmlns:po="http:  accounting.org xslt" exclude-result-prefixes="po"  >      ...         Here the «po» namespace would be copied into the result document if it weren’t for the exclude- result-prefixes attribute, because it is in scope when the literal result element   is evaluated.  As with the other   attributes, you don’t have to apply the exclusion to the whole stylesheet if you don’t want to, you can also apply it to any part of the stylesheet by using the xsl:exclude-result-prefixes attribute on any literal result element. It’s probably a good idea in prac- tice to keep the declaration of a namespace and the directive that excludes it from the result document together in one place.  The extension-element-preﬁxes Attribute This attribute identiﬁes a set of namespaces used for extension instructions. Extension instructions may be deﬁned by an implementor, a user, or a third party. An example is the   instruction in  475   XSLT Elements  Saxon, which allows data to be fetched from a relational database. They can be used anywhere an instruc- tion can be used, that is, within a sequence constructor. If an element is found in a sequence constructor that is not in the XSLT namespace, then it must either be an extension instruction or a literal result ele- ment. If its namespace is the same as a namespace identiﬁed in the [xsl:]extension-element-prefixes attribute of the containing   element, of some other containing element, or of the ele- ment itself, then it will be treated as an extension instruction; otherwise, it will be treated as a literal result element.  Effect The value of the attribute is a whitespace-separated list of preﬁxes; each of these preﬁxes must identify a namespace declaration present on the containing element. The default namespace  the namespace declared using the xmlns attribute  may be designated as an extension element namespace by using the pseudopreﬁx «default».  The scope of the extension-element-prefixes attribute is the stylesheet module. It does not affect included or imported modules.  If a namespace is designated as an extension element namespace, then every XSLT processor will recog- nize that these elements are extension instructions. However, some XSLT processors may be unable to evaluate them. For example, if the namespace http:  saxon.sf.net  is designated as an exten- sion namespace, then both Saxon and AltovaXML will recognize that these elements are extensions, but the likelihood is that Saxon will know how to handle them and AltovaXML won’t. If the proces- sor knows how to evaluate the instruction, it does so; otherwise, it looks to see if the element contains an   instruction. If it does, the   instruction is evaluated; otherwise, an error is reported.  It is necessary to designate a namespace as an extension element namespace only to distinguish extension instructions from literal result elements. At the top level of the stylesheet, there is no risk of confu- sion. Any implementation can deﬁne its own top-level elements, using its own namespace, and other implementations will simply ignore these elements, treating them as data. So the extension- element-prefixes attribute is not needed to identify top-level elements used as vendor or user exten- sions. For example, you can use   as a top-level declaration, and processors other than Microsoft MSXML will probably ignore it  though there is nothing that says they have to .  Usage This attribute should be set to a list of all the preﬁxes you are using for extension instructions in your stylesheet. The most common cases are either to omit it entirely or to include a single preﬁx for the namespace used by the vendor of your chosen XSLT processor for their own proprietary extensions. There will always be a namespace declaration for this namespace on the   element as well.  For example, if you are using Saxon:  <xsl:stylesheet  version="2.0" xmlns:xsl="http:  www.w3.org 1999 XSL Transform" xmlns:saxon="http:  saxon.sf.net " extension-element-prefixes="saxon" >  476   xsl:stylesheet  Don’t include the vendor’s preﬁx unless you are actually using their proprietary extensions in the stylesheet. You don’t need to include this attribute to use proprietary top-level elements such as  , or to use extension functions: You need it only if you want to use vendor-deﬁned instructions within a sequence constructor, where they would otherwise be assumed to be literal result elements. An example of such an instruction in Saxon is  , which allows you to generate a DTD for the result document.  If your usage of vendor extensions is highly localized within the stylesheet, it is better to identify them using the xsl:extension-element-prefixes attribute of the extension element itself, or of a literal result element that surrounds the sequence constructor where the extensions are actually used. This aids porta- bility and makes it easier to see which parts of the stylesheet are standard and which parts use proprietary extensions.  If you want to use extensions supplied by several different vendors, you can list them all in this attribute. An XSLT processor from one vendor won’t object to ﬁnding another vendor’s namespace in the list; it will only object if it is actually asked to evaluate a proprietary instruction that it doesn’t understand, and even then if there is an   child element that deﬁnes the fallback behavior, it will carry on calmly executing that in place of the unrecognized instruction.  6  X S L T  l  E e m e n t s  Although extension elements supplied by XSLT product vendors are likely to be the most common case, it’s also possible in principle to install third-party extensions or to write your own  however, the APIs for doing so will be different for each vendor . So everything we’ve said about the vendor’s extensions applies equally to your own extensions and those acquired from a third party.  For more information about the extensions provided by various vendors in their products, see the docu- mentation for the relevant product.  An inventive way of using the extension-element-prefixes attribute is to ﬂag elements that you want to reserve for debugging or annotation. For example, if you include the following element within a sequence constructor anywhere in the stylesheet, then the normal action will be to output an element to the result tree, showing the current values of the variables $var1 and $var2.       When you no longer need to use this debugging instruction, you can disable it simply by declaring «debug» as an extension element preﬁx. This time the   action will be taken, because the processor doesn’t recognize the extension instruction.  The input-type-annotations Attribute This attribute allows a processor to specify that it wants to treat input documents as untyped even if they have been schema-validated.  Effect Specifying «input-type-annotations="strip"» causes all type annotations on input documents to be removed before any further processing. The term input documents here means the principal input document and any documents read using the functions doc  , document  , or collection  . The effect of stripping type annotations is that elements become marked as xs:untyped, and attributes as xs:untypedAtomic. The nilled ﬂag on every element is set to false, but the ﬂags that mark a node as an ID or IDREF are unaffected.  477   XSLT Elements  Unlike the other attributes, input-type-annotations does affect included and imported modules. The reason for the difference is that it takes effect at runtime, not at compile time. The rule is that if any module speciﬁes «strip», then annotations will be stripped, unless there is also a module that speciﬁes «preserve» in which case an error is reported. The value «unspecified» means what it says: it’s the same as not including the attribute at all.  This attribute is a bit of an oddity because in other cases, it is left to the API to control what happens to the input document before a transformation starts. Although you can ask for type annotations to be removed from the input document, you can’t ask for them to be added  by invoking validation  unless you’re prepared to make a copy of the document.  Usage In theory, the time to use this attribute is when  a  your stylesheet is relying on nodes being untyped  this might be the case, for example, if it wants to manipulate dates as strings using regular expressions , and  b  there is a possibility that it will be presented with typed input.  I haven’t come across the need for this with Saxon, because the input will only be typed if you explic- itly request it. But it might be handy when you want your stylesheet to work with other processors. AltovaXML validates the input document if it contains an xsi:schemaLocation attribute, which is some- thing that the processing application may not be able to control.  The use-when Attribute This attribute may be speciﬁed on any element in the stylesheet  if speciﬁed on a literal result element, it is named «xsl:use-when»  and its value is an XPath expression. Although the full XPath syntax is allowed, the context for evaluation of the expression is severely restricted, which means that the expression cannot refer to anything in the source document or the stylesheet. In practice this means it is restricted to testing the results of functions such as system-property  , function-available  , and element-available  .  Effect The expression is evaluated at compile time, and if its effective boolean value is false, the element on which it appears is effectively excluded from the stylesheet module at compile time. If the attribute is used on the   or   element itself, the effect is slightly different: the element itself is not excluded  because this would make the stylesheet invalid ; instead, all the top-level declarations are excluded, so the stylesheet module becomes empty. This is only useful, of course, for an included or imported module.  The use-when attribute is discussed more fully in Chapter 3, page 127.  Usage This attribute is provided to allow you to write stylesheets that are portable across different XSLT proces- sors. For example, you can specify «use-when="system-property ’xsl:is-schema- aware’ =’yes’"» to mark a section of stylesheet code that should be ignored by a processor that is not schema- aware, or you can test the «xsl:vendor» system property to include sections of code that are speciﬁc to particular XSLT implementations. You can also use the function-available   function to condition- ally include or exclude sections of code based on whether a particular extension function is available in the implementation you are running on.  There are more examples of the use of this attribute in Chapter 3  see page 127 . It can be used on any XSLT element, both declarations  notably  ,  , and  478   xsl:stylesheet    , and instructions. Just remember that the expression cannot access the source document, and it cannot access any variables: it is designed only to test properties of the environment in which the stylesheet is compiled. Check the documentation of system-property   in your cho- sen implementation to see whether it gives you access to environment variables set at the operating system level.  The version Attribute The version attribute deﬁnes the version of the XSLT speciﬁcation that the stylesheet is relying on. At present there are two published versions of the XSLT Recommendation, namely versions 1.0 and 2.0, so this attribute should take one of these two values.  Effect The version attribute may be used to switch the XSLT processor into forward- or backward-compatibility mode. The rules are different for an XSLT 1.0 processor and a 2.0 processor, as shown in the table below.  6  X S L T  l  E e m e n t s  version less than 1.0  between 1.0 and 2.0  greater than 2.0  1.0  2.0        XSLT 1.0 Processor forward-compatible mode  1.0 mode  forward-compatible mode  forward-compatible mode  forward-compatible mode  XSLT 2.0 Processor backward-compatible mode  backward-compatible mode  backward-compatible mode  2.0 mode  forward-compatible mode  Forward-compatible mode and backward-compatible mode are explained in Chapter 3. In essence:  Forward-compatible mode means that the stylesheet doesn’t fail if it contains constructs deﬁned in a later version of the speciﬁcation, provided that it avoids executing those constructs  for example, by using   . Backward-compatible mode, which applies only to 2.0, means that certain constructs behave in a different way to retain compatibility with 1.0. Most notably, using a sequence of items where a single item is expected does not cause an error, it causes all items after the ﬁrst to be ignored.  The version attribute applies to the entire stylesheet module, except any parts contained within an XSLT element that has a version attribute, or a literal result element that has an xsl:version attribute. Its scope is the stylesheet module, not the full stylesheet tree constructed by applying   and   elements.  Note that in XSLT 1.0, the version attribute was allowed only on the   element, and xsl:version was allowed on literal result elements. In XSLT 2.0 this has been relaxed, so version can be speciﬁed on any element in the XSLT namespace. If your stylesheet is likely to be executed by an XSLT 1.0 processor, it is best to use it only in the places where it was allowed in XSLT 1.0.  Some products  XMLSpy is an example  use the version attribute to decide which processor to invoke. So if your stylesheet speciﬁes «version="1.0"», it will run with a real XSLT 1.0 processor, not with a 2.0 processor in backward-compatibility mode. This means it will fail if it tries to use any 2.0 constructs.  479   XSLT Elements  Usage If your stylesheet only uses features from XSLT 1.0, it is probably best to specify «version="1.0"» on the   element. Then it will work with any XSLT processor that conforms to XSLT 1.0 or a later version of the standard.  It will fail, however, on an XSLT 2.0 processor that doesn’t support backward-compatibility mode. If such processors become common, this advice may need to change.   If the stylesheet uses 2.0 features, you should specify «version="2.0"» on the   element. An XSLT 2.0 processor that encounters a stylesheet with «version="1.0"» at the start of the principal stylesheet module is supposed to give you a warning about possible incompatibilities and then process the stylesheet as if it were a 2.0 stylesheet, but with backward-compatibility mode switched on.  This doesn’t guarantee 100% compatibility, but it’s pretty close.   If your stylesheet says «version="1.0"» this won’t stop you from using XSLT 2.0 features; an XSLT 2.0 processor isn’t expected to look at every construct you use and decide whether it would have been allowed in XSLT 1.0. But for certain speciﬁc features, it causes XSLT 2.0 and XPath 2.0 to behave differ- ently. The main examples of this is the ‘‘ﬁrst item’’ rule mentioned earlier, where XSLT 1.0 takes the ﬁrst item of a sequence and ignores the rest. This is most commonly encountered with the   instruction, described on page 495. Other differences are more rariﬁed, for example «10 div 0» gives you Inﬁnity in backward-compatibility mode, but throws an error in 2.0 mode.  XSLT 2.0 allows you to put the version attribute on any element in the stylesheet, and at ﬁrst sight a nice idea would be to ﬂag any template rule that uses XSLT 2.0 features by labeling it with the attribute «version="2.0"». Unfortunately, however, XSLT 1.0 doesn’t allow the version attribute to appear on the   element, so if you want your stylesheet to still work with 1.0, this won’t work. A better idea is probably to put all the template rules that depend on XSLT 2.0 in a separate module, and label this module with «version="2.0"» at the   level. Of course, you will still need to provide 1.0 fallback behavior whenever you use a 2.0 construct.  The xpath-default-namespace Attribute A common source of bewilderment for XSLT 1.0 users is when they see a source document that looks like this:   Some text here   and they try to match this with a template rule like this:     or perhaps to output the value with an expression like this:     and nothing happens. Only with experience do you learn to look near the top of the document for a tell-tale default namespace declaration:     480   6  X S L T  l  E e m e n t s  Sometimes the default namespace declaration is even more carefully hidden, being placed as a default attribute value in the DTD. The XHTML speciﬁcation is an example that uses this infuriating technique: hiding in its DTD is the snippet:  xsl:stylesheet    <!ATTLIST html  %i18n; id ID IMPLIED xmlns %URI; FIXED ’http:  www.w3.org 1999 xhtml’  >  which has the effect that every element you use in a document that invokes this DTD, an element writ- ten as   perhaps, is actually in the namespace «http:  www.w3.org 1999 xhtml» although you probably didn’t know it.  When you write «match="br"» or «select="br"» in your stylesheet, you are asking for   elements in the null namespace, and you will not match   elements in any non-null namespace. To match elements in the namespace «http:  www.w3.org 1999 xhtml», you ﬁrst have to declare this namespace in your stylesheet  with a speciﬁc preﬁx :  <xsl:stylesheet . . .  xmlns:xhtml="http:  www.w3.org 1999 xhtml">  and then use this preﬁx whenever you refer to elements in this namespace: «match="xhtml:br"» and «select="xhtml:br"».  Effect XSLT 2.0 hasn’t found any way of eliminating the frustration of not realizing that the source elements were actually in a namespace, but it has eliminated the tedium of adding all the preﬁxes to your patterns and XPath expressions once you’ve realized what the problem is. You can now declare the namespace as being the default namespace for elements in XPath expressions by writing:  <xsl:stylesheet . . .  xpath-default-namespace="http:  www.w3.org 1999 xhtml">  and the names used in expressions and patterns can then remain unpreﬁxed.  As with other attributes on the   element, this attribute can also be speciﬁed on other elements in the stylesheet, including literal result elements  as xsl:xpath-default-namespace . This allows you to deﬁne a different default XPath namespace in different regions of the stylesheet, which is useful if the stylesheet is processing different source documents.  But it might be simpler in this case to split the stylesheet into different modules.  The attribute affects everything that is textually within its scope, and doesn’t extend to included or imported modules.  The value is a namespace URI rather than a preﬁx, which means that the stylesheet doesn’t actually need to declare this namespace. This is convenient because it means the namespace won’t be automatically copied into the result document. You can also set it to a zero-length string to restore the default setting, which is that unpreﬁxed names are assumed to refer to elements that are in no namespace.  481   XSLT Elements  The XPath default namespace affects unpreﬁxed names appearing in the following contexts:                    Element names  but not attribute names  appearing in path expressions: That is, an NCName used as a NameTest in an AxisStep, when the axis is one that selects elements. Element names used similarly in patterns. Element names and type names  but not attribute names  used in the SequenceType syntax for deﬁning types, whether the SequenceType syntax is used within an XPath expression, or on its own within an «as» attribute in the stylesheet. Type names used in an XPath cast expression, for example «"MF00325Z" cast as part-number». Type names used in a «type» attribute in the stylesheet. Element names used in   and  .  Note that although the namespace applies to unpreﬁxed names appearing in a cast expression, it does not apply to the names of functions, including constructor functions such as «part-number  "MF00325Z" » where the function name is based on the name of a user-deﬁned type in a schema. With constructor functions the namespace must always be given explicitly; an unpreﬁxed function name can only be used for functions in the core library  that is, standard XSLT and XPath functions .  This means that if you import a schema with no target namespace, you cannot use constructor func- tions to create instances of the atomic types deﬁned in that schema. Instead, you must use the more long-winded cast syntax.  In fact, this is the main reason that the cast syntax has been retained in the XPath language.   The XPath 2.0 speciﬁcation refers to a concept called the default function namespace, which is the namespace in which unpreﬁxed function names are located. Although XPath allows this to be deﬁned as part of the evaluation context, XSLT does not pass this capability on to the user. When XPath expres- sions are used in XSLT stylesheets, the default function namespace is always the standard namespace http:  www.w3.org 2005 xpath-functions. This means that calls on standard functions such as position  and last   never need to be preﬁxed in XSLT, though you can use a preﬁx that is bound to the standard namespace if you really want to.  Usage I would recommend always using this attribute when your source documents use a default namespace declaration; the value should be the namespace URI of this default namespace declaration. Specifying an xpath-default-namespace will not stop existing code working that uses explicit preﬁxes to refer to names in this namespace.  One thing to watch out for is that if your stylesheet creates and uses temporary documents, the chances are that these don’t use namespaces. Specifying an xpath-default-namespace makes it impossible to refer to names that are in the null namespace, for example elements in such a temporary document  you can’t bind a namespace preﬁx to the null namespace, unfortunately . In this situation you can override the xpath-default-namespace in the relevant region of your stylesheet by writing «xpath-default-namespace=""».  If your stylesheet processes multiple source documents of different types, similar considerations apply. In this case it might be clearer to use explicit namespace preﬁxes for everything.  See Also   on page 495  482   xsl:template  xsl:template  The   element deﬁnes a template for producing output. It may be invoked either by matching nodes against a pattern, or explicitly by name.  Changes in 2.0 It is now possible to deﬁne a template rule that matches in multiple modes.  The new «as» attribute allows the type of the result to be deﬁned. Moreover, the new   instruction means that a template can now return atomic values and references to existing nodes; it is no longer limited to constructing new nodes.  The syntax for patterns has been extended so that a template rule can now match nodes according to their schema-deﬁned type. The match pattern may also now contain references to global variables or parameters.  Nonsensical combinations of attributes are now considered to be errors; for example, specifying priority or mode when there is no match attribute. In XSLT 1.0, such attributes were ignored.  6  X S L T  l  E e m e n t s  Format  <xsl:template  match? = pattern name? = qname priority? = number mode? = tokens as? = sequence-type>       Position   is a declaration, which means that it always appears as a child of the   element.  Attributes  Name match optional  name optional  priority optional  Value Pattern  Lexical QName  Number  Meaning A pattern that determines which nodes are eligible to be processed by this template. If this attribute is absent, there must be a name attribute.  The name of the template. If this attribute is absent, there must be a match attribute.  A number  positive or negative, integer or decimal  that denotes the priority of this template and is used when several templates match the same node.  continued  483   XSLT Elements  Name mode optional  as optional  Value Whitespace-separated list of mode names, or «all»  SequenceType  Meaning The mode or modes to which this template rule applies. When   is used to process a set of nodes, the only templates considered are those with a matching mode.  The type of the sequence produced when this template is evaluated. A type error is reported if the result does not match this type.  The construct Pattern is deﬁned in Chapter 12, while SequenceType is deﬁned in Chapter 11.  The mode and priority attributes must not be speciﬁed unless the match attribute is also speciﬁed.  Content Zero or more   elements, followed by a sequence constructor.  Effect There must be either a match attribute or a name attribute, or both.           If there is a match attribute, the   element deﬁnes a template rule that can be invoked using the   instruction. If there is a name attribute, the   element deﬁnes a named template that can be invoked using the   instruction. If both attributes are present, the template can be invoked in either of these ways.  The match Attribute The match attribute is a Pattern, as deﬁned in Chapter 12. The pattern is used to deﬁne which nodes this template rule applies to.  When   is used to process a selected set of nodes, each node is processed using the best-ﬁt template rule for this node, as described under   on page 240.  A template is only considered a candidate if the node matches the pattern supplied in the match attribute and if the value of the mode attribute matches the mode attribute of the   instruc- tion  as described on page 242 .  If more than one template rule meets these criteria, they are ﬁrst considered in order of import precedence  as described under   on page 359 , and only templates with the highest import precedence are considered further.  If there is still more than one template rule  in other words, if two template rules that both match the node have the same import precedence , they are next considered in order of priority. The prior- ity is either given by the value of the priority attribute, described below, or is a default priority that depends on the match pattern. The rules for determining the default priority of any pattern are given in Chapter 12, on page 686.  If this leaves one pattern with a numerically higher priority than all the others, this one is chosen. If there are several with the same priority, which is higher than all the others, the XSLT processor has the  484   xsl:template  choice of reporting an error or choosing from the remaining templates the one that appears last in the stylesheet. Several processors in practice report a warning, which you can ignore if you wish. In my experience, however, this condition often indicates that the stylesheet author has overlooked something.  XSLT 2.0 allows the pattern to contain a reference to a global variable or parameter. This allows a pattern such as «match="part[@number=$param]"», which means that the same pattern will match different nodes on different runs of the stylesheet. But there are rules to prevent circular deﬁnitions: evaluating the variable must not invoke an   instruction, either directly or indirectly.  There are special rules concerning the handling of errors that occur when matching a node against a pattern. Theoretically, when you execute an   instruction, the processor could evaluate every pattern against the selected nodes. This means that failures can occur if a pattern is inap- propriate to the type of node: for example the pattern «B[.=3]» would give a type error when matching an element containing a date. The speciﬁcation allows the processor to ignore this error and simply treat the pattern as not matching that particular node. This causes few problems in practice, but it creates the danger that real errors go unnoticed. It’s best to keep patterns simple enough that runtime errors cannot occur while evaluating them.  6  X S L T  l  E e m e n t s  The name Attribute The name attribute is a lexical QName; that is, a name optionally qualiﬁed with a namespace preﬁx. If there is a preﬁx, it must correspond to a namespace declaration that is in scope on this element  which means it must be deﬁned either on this element itself or on the   element . If there is no preﬁx, the namespace URI is null; the default namespace is not used.  This name is used when the template is invoked using  . The name attribute of the   element must match the name attribute of the   element. Two names match if they have the same local part and the same namespace URI, but the preﬁx can be different.  If there is more than one named template in the stylesheet with the same name, the one with higher import precedence is used; for details, see   on page 359. It is an error to have two templates in the stylesheet with the same name and the same import precedence, unless there is another one with the same name and a higher import precedence. This is an error even if the template is never called.  The priority Attribute The priority attribute is a number, for example «17», «0.5», or «-3»: more speciﬁcally, an xs:decimal as deﬁned in XML Schema, which allows an optional leading sign.  The priority attribute is used to decide which template to invoke when   is called and there are several possible candidates. For each node selected by the   instruction, a template rule is chosen using the following procedure:        First select all the templates that have a match attribute. From these, select all the templates that match the mode that is used on the call of <xsl:apply- templates>. An   instruction uses either a speciﬁc mode  identiﬁed by a QName  or the default mode  which is unnamed  or it can specify «current», in which case it uses whatever mode is the current mode at the time. An   element can spec- ify a list of modes that it matches  which can include «default» to indicate that it matches the default mode , or it can specify «all» to indicate that it matches all modes; if it has no mode attribute, then it matches only the default mode.  485   XSLT Elements           From these, select all those whose pattern matches the selected node. If there is more than one, select those that have the highest import precedence. If there is still more than one, select those that have the numerically highest priority.  If there are several matching templates left, and they all have the same import precedence and priority, the XSLT processor can either choose the one that occurs last in declaration order or report an error. Import precedence and declaration order are described under   on page 359.  If there are no templates that match the selected node, the built-in template for the relevant node kind is used. Built-in templates are described under   on page 243.  The rules for determining the default priority for a pattern are given in Chapter 12, on page 686.  Although the default priorities are carefully chosen, they do not guarantee that a highly selective pattern will always have higher priority than a less selective pattern. For example, the patterns «section para» and «section para[1]» both have priority +0.5. Similarly, the patterns «attribute *, xs:integer » and «attribute *, xs:decimal » have the same priority, even though the nodes that match the ﬁrst pattern are a subset of those that match the second. Choosing your own priorities is therefore a more reliable approach.  The mode Attribute If the   element has no mode attribute, then it applies only to the default  unnamed  mode, and it will be invoked only in response to an   instruction that uses the default mode. An   instruction uses the default mode if it has no mode attribute, if its mode attribute has the value «default», or if its mode attribute has the value «current» and the current mode is the default mode. The concept of the current mode is explained on page 238.  If the mode attribute is present and has the value «all», then the template is applicable to all modes.  The mode attribute may also contain a list of modes to which the template is applicable. Each mode is written either as a lexical QName  the actual mode name  or as the token «default» to indicate that the template is applicable to the default mode.  Mode names are compared using the usual rules for QNames — they match if the local name and namespace URI both match.  The mode speciﬁed on the   template is not automatically propagated to any   elements within its body. Although it is common practice to process an entire subtree in a single mode, and therefore for a template to continue using the mode it was called in, this is not the default behavior except in the case of built-in templates. However, the current mode can be propagated by explicitly calling  .  If you have a mode attribute on a template and there is no   element with a matching mode anywhere in the stylesheet, this is not an error, though it means the template will never be selected by any   call  it could however be invoked from the calling application if an initial mode is speciﬁed . This can be a handy way of commenting out a template rule.  Evaluating a Template Once an   element is selected for processing, the following occurs:     If it was called using  , the context node, context position, and con- text size are set up as required.  486   xsl:template              A new stack frame is allocated, to hold a new instance of each local variable deﬁned within the template. All parameters listed in   elements contained within the   ele- ment are evaluated. These   elements must come before any instructions in the content of the template. For each parameter, if a value was supplied by the caller  using an   element with matching name , this value is assigned to the parameter. If necessary, the supplied values are converted to the required type speciﬁed in the «as» attribute, using the standard conversion rules described on page 505. If the supplied value has the wrong type, an error is reported. If no value was supplied by the caller, then if the   ele- ment speciﬁes «required="yes"» an error is reported; otherwise, the default value of the parameter is evaluated. This process is explained in more detail under   on page 425. The sequence constructor is evaluated. This means that the child instructions of the   element are evaluated to produce a result sequence. XSLT instructions and extension elements are processed using their individual rules; literal result elements and text nodes are written to the result sequence. The result of evaluating the sequence constructor is checked against the type given in the «as» attribute of the   element, if any. If necessary, the value is converted to the required type using the standard conversion rules given on page 505. If the value has the wrong type, a fatal error is reported.  6  X S L T  l  E e m e n t s  When processing of the sequence constructor is complete, the stack frame containing its local variables is discarded, control returns to the calling template, and the context item, position, and size revert to their previous values. The value produced by evaluating the sequence constructor becomes the return value of the calling  ,  ,  , or   instruction.  If the calling instruction was  , the value is combined with the values delivered by the template rules for other selected nodes.   The implementation, of course, is free to do things in a different order if it has the same effect. Some products use lazy evaluation, where the parameters are only evaluated when they are ﬁrst used. Some products also use tail-call optimization, where a recursive template call is deferred until after the stack has been unwound; this reduces the risk of running out of stack space when calls are deeply nested. Such optimizations may show up if you use extension functions that have side effects, or if you use   to trace the sequence of execution.  Usage and Examples We will look ﬁrst at using template rules, and then I will give some advice on the use of modes. For examples of the use of named templates, see   on page 271.  Using Template Rules A template rule is an   element with a match attribute, which can therefore be invoked using the   instruction.  This rule-based approach to processing is the characteristic way of writing XSLT stylesheets, though it is by no means the only way. Its biggest advantage is that the output for each element type can be deﬁned independently of the context that the element appears in, which makes it very easy to reuse element types in different contexts or to add new element types to an existing document deﬁnition without rewriting the stylesheet templates for all the possible containing elements. A classic example of this approach to  487   XSLT Elements  processing arises when converting semantic markup in a document to rendition markup, as the following example demonstrates.  Example: Template Rules  This example shows a typical use of template rules to handle narrative text with a free-form structure.  The source ﬁle is review.xml. This text contains the review of a concert performance, using both structured  data  and narrative  document  markup. Omitting some of the detail, it reads:   Wigmore Hall   London   2007-03-27   Carducci String Quartet    Back at the  Wigmore Hall  on <date iso=  "2007-03-27">27 March  another fine group, the  Carducci Quartet , was joined by pianist  Nicola Eimer  for a programme of  Mozart ,  Ravel   and  Schumann . Following the current fashion for the chamber versions of  Mozart  concertos, the players opened with a lively and shapely performance of his  A major Concerto K414 . ....   Tim Homfray   The Strad   June 2007   Source                         Stylesheet  The stylesheet ﬁle is review.xsl. This stylesheet resists the temptation to use varied fonts for the names of composers and artists, but merely uses italics for names of musical works:  <xsl:stylesheet version="2.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform">       488      body {         font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 10pt; font-style:normal; color: 3D5B96; line-height: 14pt;  xsl:template  6  X S L T  l  E e m e n t s  <xsl:value-of select="artist, venue, format-date date, ’[D] [MNn,3] [Y]’ "  }v                          separator=" - " >                                                        Note the use of CSS to achieve the styling, and the use of a priority attribute on the tem- plate for «match="para work"» to ensure that it is selected in preference to the template for «match="para *"». In fact, the template for «match="para *"»  which handles all children of   other than    does exactly what the built-in template would do — it outputs the text without any markup — but it does no harm to make it explicit.  Output  If the generated HTML is displayed in a browser, it will look like Figure 6-14.  489   XSLT Elements  Figure 6-14  This stylesheet demonstrates a mixture of rigidly structured data processed using   instructions, sometimes called pull processing, and narrative markup processed using <xsl:apply- templates> instructions, referred to as push processing. The great advantage of the push approach is that the rules are written making no assumptions about the way the markup tags are nested in the source document. It is very easy to add new rules for new tags and to reuse rules if an existing tag is used in a new context.  Where the nesting of elements is more rigid, this very ﬂexible rule-based style of processing has fewer beneﬁts, so the pull programming style using   in conjunction with conventional ﬂow-of-control constructs such as  ,  , and   is often used. For further discussion of the different design approaches, see Chapter 17.  Using Modes The classic reason for using modes is to enable the same content to be processed more than once in different ways; for example, the ﬁrst pass through the document might generate the table of contents, the second pass the actual text, and the third pass an index.  Example: Using modes  The source document is a concert review in the same format as in the previous example. This time, however, the requirement is to produce at the end of the review a list of works mentioned in the text.  The source ﬁle is review.xml. See previous example.  Source  Stylesheet  The stylesheet ﬁle is review + index.xsl. This stylesheet extends the previous one using  . After outputting the text as before, it now creates a table listing the works mentioned in the text. Note the use of an empty template rule with «match="text  "» to ensure that when the text is processed  490   xsl:template  with «mode="index"», nothing is output. The only output comes from the template rule that matches   elements.  <xsl:stylesheet version="2.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform">           Index of Works      Composer  Title    Opus            6  X S L T  l  E e m e n t s                               Output  The output is as shown in Figure 6-15.  Figure 6-15  491   XSLT Elements  See Also   on page 240   on page 237   on page 271 generate-id   function in Chapter 7, on page 797  xsl:text  Changes in 2.0 None.  Format  <xsl:text  The   instruction is used within a sequence constructor to output literal text to the result sequence. The main purpose of wrapping an   element around literal text is to control the output of whitespace.  disable-output-escaping? = "yes"  "no">       Position   is an instruction. It is always used as part of a sequence constructor.  Attributes Name disable-output-escaping optional, deprecated  Value «yes» or «no»  Meaning The value «yes» indicates that special characters in the output  such as «<»  should be output as is, rather than using an XML escape form such as «&lt;». The default value is «no».  Content A text node. The element may also be empty. It must not contain other elements such as  .  Effect Text appearing within a sequence constructor in the stylesheet is copied to the result sequence  in the form of a new text node , whether it is enclosed by   or not. The only direct effect of enclos- ing text in an   element is that the handling of whitespace is different. A whitespace node appearing in the stylesheet  that is, a text node that consists only of whitespace  is copied to the result tree only if :        it appears within an   element, or an enclosing element has the attribute «xml:space="preserve"», and this is not overridden by an inner enclosing element specifying «xml:space="default"»  492   xsl:text  The disable-output-escaping attribute controls whether special characters such as «<» should be escaped  that is, converted to a character reference or entity reference such as «&lt;»  if they appear in the text. The default value is «no». This attribute is deprecated but is retained for backward compatibility with XSLT 1.0; for further information, see page 945 in Chapter 15.  Usage There are two main reasons for using  , which are to control the output of whitespace, and to disable the escaping of special characters by the serializer. The disable-output-escaping attribute is deprecated in XSLT 2.0, but there are still cases where it is useful; for details, see Chapter 15. The following section describes the more orthodox use of   to control whitespace.  Whitespace Control The most obvious case where   is useful is to force output of whitespace. An example is given in the XSLT speciﬁcation. If you write:  6  X S L T  l  E e m e n t s       the space between the ﬁrst name and the last name will be lost, because it is part of a node that contains whitespace only  a single space character . To force a space to appear between the ﬁrst name and the last name, write:           The arrangement on three lines here is purely for readability, but it does not affect the output, because the newline characters are now in whitespace-only nodes that will not be output.  If you ﬁnd this long-winded, another way of achieving the same effect is to write:     The other aspect of the problem is to prevent the output of unwanted whitespace. Fortunately in HTML output extra whitespace usually doesn’t matter, because the browser will ignore it. For XML or text output, however, avoiding unwanted whitespace can be important.  If you are suffering from excess whitespace in your output, the ﬁrst thing to establish is whether it comes from the source document or from the stylesheet. If the whitespace is adjacent to text copied from the source document, then it probably comes from the source document, but if it is adjacent to text that appears in the stylesheet, then this is the most likely source. Check also that the unwanted whitespace isn’t coming from the serializer, by setting  .  If the unwanted whitespace comes from the source document, consider using   to remove nodes consisting entirely of whitespace, or the normalize-space   function to remove leading and trailing spaces around visible text.  The   element can be used to suppress unwanted whitespace that originates in the stylesheet. For example, consider the following template:     [   ]     493   XSLT Elements  The intention here is to output a stage direction enclosed in square brackets. But the text nodes containing the opening and closing square brackets also contain a newline character and several spaces, which will be written to the output destination along with the brackets themselves. To prevent this behavior, the simplest way is to wrap an   element around the text you want to output, thus:      [       ]      A variation on this, which works equally well, is to delimit the text with empty   elements:      [   ]      The effect of this is that the extra newlines and spaces now belong to whitespace-only nodes, which are stripped from the stylesheet and ignored.  Examples Here are two simple examples using   to control the output of whitespace:  1.  Output ﬁrst-name and last-name, separated by a space:           Another way to achieve the same effect is to use the concat   function:     2.  Output a comma-separated list of values:        ,   ,   ,           The purpose of the empty   elements is to split the comma and the following new- line character into separate text nodes; this ensures that the newline character becomes part of a whitespace-only node and is therefore not copied to the output. The ﬁnal   element ensures that a newline is written at the end of each record.  Another way to achieve this is with the separator attribute of  :     494   xsl:value-of  See Also   on page 280   on this page  xsl:transform  This is a synonym of  , described on page 465. The two element names may be used interchangeably.  Why is it useful to have two names for the same thing? Probably because it’s the easiest way for a stan- dards committee to keep all its members happy. More seriously, the existence of these two names is indicative of the fact that some people see XSLT as being primarily a language for transforming trees, while others see its main role as deﬁning presentation styles. Take your pick.  6  X S L T  l  E e m e n t s  Format  <xsl:transform  id? = id default-collation? = uri-list default-validation? = "preserve"  "strip" exclude-result-prefixes? = tokens extension-element-prefixes? = tokens input-type-annotations? = "preserve"  "strip"  "unspecified" use-when? = expression version = number xpath-default-namespace? = uri        See Also   on page 465  xsl:value-of  The   instruction constructs a text node, and writes it to the result sequence.  Changes in 2.0 In XSLT 2.0 the value to be output can be obtained by evaluating a contained sequence constructor as an alternative to using the select attribute.  A separator attribute has been added, allowing a sequence of values to be output separated by spaces, commas, or any other convenient string.  Format  <xsl:value-of  select? = expression separator? = { string} disable-output-escaping? = "yes"  "no">  495   XSLT Elements       Position   is an instruction. It is always used as part of a sequence constructor.  Attributes Name select optional  separator optional  disable-output-escaping optional, deprecated  Value XPath Expression  Meaning The value to be output.  Attribute value template returning a string  «yes» or «no»  A string to be used to separate adjacent items in the output.  The value «yes» indicates that special characters in the output  such as «<»  should be output as is, rather than using an XML escape form such as «&lt;». The default value is «no».  Content If the select attribute is present, the element must be empty. Otherwise, it may contain a sequence constructor.  Effect The most common use of   is to select a node, and output the value of that node as a string. For example,   outputs the string value of the dept attribute of the context node. In the general case, however, the rules are more complicated.  The select expression or the contained sequence-constructor is evaluated. Adjacent text nodes in the resulting sequence are merged, and zero-length text nodes are removed. The sequence is then atomized, which causes any nodes in the sequence to be replaced by their typed values.  If the atomized sequence is empty, the result of the   instruction is a text node containing a zero-length string. Text nodes are allowed to be zero-length so long as they have no parent. But if you try to use a zero-length text node to form the content of an element, the text node disappears in the process.  If the atomized sequence contains a single value, this is converted to a string  by applying the XPath 2.0 casting rules . A new text node is constructed with this string as its value, and the text node is returned as the result of the   instruction  which usually means it will be written to a result tree . If the sequence contains more than one item, then the effect depends on whether backward-compatibility mode is enabled. This depends on the nearest version or xsl:version attribute found on a contain- ing element, known as the effective version. If the effective version is less than «2.0», then backward- compatibility mode is in force. However, if there is a separator attribute, then the instruction behaves according to the XSLT 2.0 rules regardless of the effective version.  Under the backward-compatibility rules, any item after the ﬁrst in the sequence is discarded, and the instruction behaves as if the sequence only contained one item.  496   6  X S L T  l  E e m e n t s  xsl:value-of  Under the 2.0 rules, each value in the atomized sequence is converted to a string by applying the XPath casting rules, and these strings are concatenated, with the chosen separator inserted between adjacent strings. A new text node is constructed that contains this string as its value, and the text node is returned as the result of the instruction. The default separator  under the 2.0 rules  is a single space when the select attribute is used, or a zero-length string when a sequence constructor is used. This means that        1 2 3 4 5   will output:  but:        will output:   [12345]    [ ]   The deprecated disable-output-escaping attribute has the same effect as it has with  . Special characters such as «<» in the string value of the select expression will be escaped just as if they occurred in literal text, and the disable-output-escaping attribute can be used to suppress this in the same way. For details, see Chapter 15 on page 945.  Usage The   element is the most common way of writing text to a result tree.  Because the instruction is so common, it is often used unthinkingly when other constructs might be more appropriate. For example, it is very common to encounter code such as:           when it would be much more appropriate to write:     The difference is that the ﬁrst variable creates a new temporary tree containing a document node and a text node, with the text node being a copy of data selected from the input document; the second variable is simply a reference to the selected node in the source. So the second construct is not only shorter and more readable, it is also likely to be much more efﬁcient. The optimizer can’t simply treat the two constructs as equivalent, because they are not. For example, if «a b c d» selects nothing, then «empty $x » will return false in the ﬁrst case, true in the second.  Similarly, when a function returns a string result, people sometimes write code like this:             497   XSLT Elements  Here «upper-case $p » returns a string. The   instruction creates a text node with this string as its value. Because the function is declared to return xs:string, the text node is then atomized to extract the original string. The system would have to do a lot less work if these mul- tiple conversions were avoided, which can be achieved simply by replacing   with  .  Nevertheless, the   instruction has a useful role to play. If you really do want to create a text node — in particular, if you are creating the content of an element — then   is the right way to do it.  The following example shows the correct use of   to create the content of new element nodes:                               The new XSLT 2.0 option to use the sequence constructor to obtain the value, rather than the select attribute, is provided mainly to make   compatible with other instructions such as   and  . But there are some cases where it can be very useful. Consider the following:                         Without the outer   element, the body of this function would create three text nodes, and this would cause a type error, because a sequence of three text nodes cannot be converted to the declared return type of the function, xs:string. The effect of the outer   instruction is to concatenate the three text nodes into one, and a single text node can be converted to a string, so the function succeeds. In effect, the   instruction is doing the same thing at the XSLT level as the concat   function does at the XPath level.  Avoiding Surprises There are two situations in which   might not give the result you expect.  The ﬁrst should be less common with XSLT 2.0 than it was with 1.0, but it will still happen in stylesheets that specify «version="1.0"» and thus invoke backward-compatibility mode. The surprise is that only the ﬁrst item in a sequence is actually output. For example, if the context node is a   element and you specify  , only the ﬁrst author  in document order  will actually  498   xsl:value-of  be output. This changes when you specify «version="2.0"»: all the authors are now output, using a single space as the default separator.  Of course, if you have become accustomed to the 1.0 behavior, then the surprise might be the other way around. If your stylesheet speciﬁes  , then when you change it to say «version="2.0"», the output will contain all the following sibling paragraphs rather than just the ﬁrst. You can easily correct this by changing it to <xsl:value-of select="following- sibling::para[1]" >.  The second situation that sometimes causes surprise is typiﬁed by the question ‘‘Why have all the tags disappeared?’’ If you use   to output an element such as a   element that contains complex or mixed content, then it will extract the value of this element as a string. If there are nested elements, for example elements marked up by tags such as   or  , then these are lost in the course of converting to a string. If you want these tags to appear in the output, then use   to copy the element, not  .  This situation may also change in XSLT 2.0 if you use a schema-aware processor. If the select expression selects an element, and the element is described in the schema as having complex element-only content, then atomization will raise a runtime error. For example if the source document contains the element:  6  X S L T  l  E e m e n t s         XSLT 2.0 Programmer’s Reference   Michael Kay   Wiley   then with a processor that is not schema-aware  or an XSLT 1.0 processor , the instruction <xsl:value-of select="book" > will produce the output:  XSLT 2.0 Programmer’s ReferenceMichael KayWiley  But with a schema-aware processor, assuming the schema declaration is:                         the result will be a runtime error. If you want to concatenate the text nodes within the   element, then you can still do so, by writing  , but it’s not something that atomization will do automatically for you. This is because, for data-oriented XML, it doesn’t usually make sense.  With mixed content, however  where text and marked-up elements can be freely mixed in the content , it does make sense to extract the textual content without the markup, and   will do this whether or not there is a schema. Mixed content is described in the schema using <xs:complexType mixed="true">.  499   XSLT Elements  Examples The table below shows some common ways in which   is used.  Instruction  <xsl:value-of  select="." >  <xsl:value-of  select="title" >  <xsl:value-of  select="sum @* " >  Effect Create a text node containing the string value of the context item.  Create a text node containing the string values of the child   elements of the context node, space separated.  In 1.0 mode, discard all but the ﬁrst  .   Create a text node containing the sum of the values of the attributes of the current node, converted to a string. If there is any non-numeric attribute, the result will be NaN or, if a schema is in use, a type error.  <xsl:value-of  select="$x" >  Create a text node containing the value of variable $x, after converting it to a string.  See Also   on page 292   on page 492  xsl:variable  The   element is used to declare a local or global variable in a stylesheet, and to give it a value.  Changes in 2.0 A new attribute, «as», has been introduced. This allows the type of the variable to be declared; it also determines whether an   element containing a sequence constructor will use the value of the sequence to construct a temporary document or will simply set the value of the variable to be this sequence.  Format  <xsl:variable  name = qname select? = expression as? = sequence-type>       Position The   element may appear either as a top-level declaration  that is, as a child of the   element , or as an instruction within a sequence constructor.  500   Attributes Name name mandatory  select optional  as optional  xsl:variable  Value Lexical QName  Meaning The name of the variable.  Expression  SequenceType  An expression that is evaluated to give the value of the variable. If omitted, the value is determined from the contents of the   element.  Declares the type of the variable. A type error occurs if the value of the expression cannot be converted to this type using the standard type conversions deﬁned below  page 505 . In addition, the presence of this attribute on an   element with nonempty content indicates that the result of evaluating the contained sequence constructor is to be used directly as the value of the variable, rather than being used to construct a temporary document.  6  X S L T  l  E e m e n t s  The SequenceType construct is described in Chapter 11.  Content An optional sequence constructor. If a select attribute is present, the   element must be empty.  Effect An   element may appear either at the top level of the stylesheet  in which case it declares a global variable  or as an instruction within a sequence constructor  in which case it declares a local variable .  The Name of the Variable The name of the variable is deﬁned by a lexical QName. Normally, this will be a simple name such as «city» or «total-sales», but it may be a name qualiﬁed with a preﬁx, for example «my:value». If it has a preﬁx, the preﬁx must correspond to a namespace that is in scope at that point in the stylesheet. Two variables, «my:value» and «your:value», have matching names if the preﬁxes «my» and «your» refer to the same namespace URI. If the name has no preﬁx, it has a null namespace URI — it does not use the default namespace URI.  The scope of a global variable is the entire stylesheet, including any stylesheets that are included or imported. A global variable may even be referenced before it is declared. The only constraint is that circular deﬁnitions are not allowed; if variable x is deﬁned in terms of y, then y may not be deﬁned directly or indirectly in terms of x.  The scope of a local variable is block-structured; it may be referenced in any following sibling element or in a descendant of a following sibling. This is illustrated in Figure 6-16.  501   XSLT Elements  Figure 6-16  The diagram shows, for a variable X, the elements that may contain a reference to X; the shaded elements may refer to X, and the unshaded elements may not. Speciﬁcally, a local variable may be referenced in any following sibling element, or in a descendant of a following sibling. It cannot be referenced within its own descendants, and it goes out of scope when the end tag for its parent element is encountered. Unlike global variables, a forward reference to a local variable is not allowed. If you think of XSLT instructions as being like the statements in a block-structured language such as C, Java, or JavaScript, and the enclosing element as being like a block enclosed in these languages by curly braces, the scope rules will seem very familiar.  Two global variables may have the same name only if they have different import precedence; in other words, if one of them was in an imported stylesheet  for further details, see   on page 357 . In this case, the deﬁnition with higher import precedence wins. Note that the higher precedence deﬁnition applies everywhere, even within the imported stylesheet that contains the lower precedence deﬁnition. This means it is not a good idea to rely on precedence to resolve accidental name clashes between independently developed modules, it’s better to use namespaces.  XSLT 1.0 did not allow a local variable to be deﬁned with the same name as another local variable already in scope. This restriction was there as a way of detecting user errors. The restriction has gone in XSLT 2.0, although there is still a warning in the speciﬁcation advising that this isn’t good practice. In fact, not all XSLT 1.0 processors actually enforced this rule. If a variable reference is used when two or more variables with the matching name are in scope, then the reference is taken to refer to the one whose scope is smallest.  This principle extends to variables declared within an XPath expression. To take an extreme example, it is legal to write:                  The output of the template will be «A + B + C + D + ».  These rules on uniqueness and scope of names apply equally to parameters declared using  ; the   instruction is effectively just another way of declaring a variable.  502   6  X S L T  l  E e m e n t s  xsl:variable  The Value of the Variable The value of the variable may be given either by the XPath expression in the select attribute, or by the contents of the contained sequence constructor. If there is a select attribute, the   element must be empty. If there is no select attribute and the sequence constructor is empty, the value of the variable is a zero-length string, unless there is an as attribute, in which case the value is an empty sequence  assuming that the as attribute permits an empty sequence .  Figure 6-17 summarizes the different ways of specifying the value. The numbers in brackets refer to the numbered paragraphs below that explain the option in more detail.  absent  select attribute  as  attribute  present  select attribute  absent  Return a zero-length string  absent  content  present  content  absent  content  present  content  present  absent  present  absent  present  absent  present  Evaluate the content constructor and use it to build a temporary document  Evaluate the select expression and  return its value  Return an empty sequence, provided the as attribute allows empty sequence  Evaluate the content constructor and  return its value, checking its type  against the as attribute  5   Evaluate the select expression and return its value, checking its type  against the as attribute  6    1     2    3   Error   4   Error  Figure 6-17  1.  2.  The following example declares a parameter whose default value is a zero-length string:     Again, this option is not useful for variables, but it can be useful with  , which follows exactly the same rules. If a sequence constructor is used with no as attribute, a temporary document is constructed. This is done by creating a new document node and using the value of the result sequence to form the children of the document node. The detailed rules for constructing the content of the document node are the same as those for the   instruction and are given on page 303. The value of the variable will be the document node at the root of the tree. For example:        Germany   503   XSLT Elements   France   United Kingdom   United States        3.  4.  5.  6.  Here the value of the variable is a document node, whose only child is a   element, which in turn has four   elements as its children. Temporary documents are described in more detail on page 510. If the select attribute is provided without an as attribute, the effect is the same as if «as="item  *"» were speciﬁed: no type checking or conversion takes place, and the value may be of any type. For example:     Here the value of the select attribute is again of type xs:double, but for a different reason: it was written as a double literal, and no conversion has taken place. The following example declares a parameter whose default value is an empty sequence:     This option is not very useful for variables, but it can be useful with  , which follows exactly the same rules. If a sequence constructor is used with an «as» attribute, the instructions in the sequence construc- tor are evaluated. The result sequence is checked against the type speciﬁed in the «as» attribute and is converted if necessary using the standard conversion rules described on page 505. An error is reported if the conversion is not possible. The processor may report this as a compile-time error if it can tell at compile time that the value of the expression will never be convertible to the required type. For example:          Here the sequence constructor returns a single text node. The contents of this text node are con- verted to an integer, which becomes the value of the variable. If the select attribute is provided, its value must be an XPath expression. This expression is eval- uated. The value is checked against the type speciﬁed in the «as» attribute and, if necessary, is converted to this type using the standard conversion rules described on page 505. An error occurs if this conversion is not possible. Otherwise, the error will be reported at runtime. For example:     Here the value of the select expression is of type xs:decimal, but the ﬁnal value of the variable is an xs:double, because the «as» attribute forces a conversion.  Note that if an expression is used to assign a literal string value to a variable, the string literal must be enclosed in quotes, and these quotes are additional to the quotes used around the XML attribute.  504   xsl:variable  6  X S L T  l  E e m e n t s  So to assign the string value «London» to the variable named «city», you can write either of the following:       You can also write:   London   A common mistake is to write:       This sets the value of «$city» to a sequence containing all the element children of the context node that have element name  . This will probably be an empty sequence. If you get into the habit of using the «as» attribute,  in this case «as="xs:string"» , the compiler will tell you about this mistake. A schema-aware processor might also warn you that there is no   element deﬁned in the schema. But in other cases, you won’t get any error message, because it’s a perfectly valid thing to write; it will just cause your stylesheet to produce the wrong output.  You won’t be alone if you make this mistake; there’s an example of it in the original XSLT 1.0 speciﬁca- tion, which had to be ﬁxed in a subsequent erratum.  You don’t need the extra quotes if you want the value to be a number:     Standard Conversion Rules This section provides the detailed conversion rules used when converting the supplied value of a variable  the result of evaluating its select attribute or its sequence constructor  to the type required by the «as» attribute. The same conversion rules are used under a number of other circumstances, such as when values are supplied for stylesheet parameters. They are the same as the function conversion rules deﬁned in XPath 2.0, which deﬁne what happens when the supplied arguments in a function call differ from the declared types of the parameters, with the exception that the rules described here never use XPath 1.0 backward-compatibility mode. The reason for this is that they are always invoked in contexts where backward compatibility issues do not arise.  The rules take as input a supplied value and a required type, and they produce as output a result value. The required type has two parts: the required item type  for example, integer or element  and the required cardinality. The required cardinality may be exactly-one  when there is no occurrence indicator in the SequenceType as written  or zero-or-one, zero-or-more, or one-or-more, corresponding to the occurrence indicators «?», «*», and «+».  Instead of returning a result value, the rules may also result in a type error, if the supplied value cannot be converted to the required type.  505   XSLT Elements  The rules are as follows:  1.  2.  3.  4.  5.  If the supplied value is an instance of the required type, return it unchanged as the result value. This includes the case where the supplied value belongs to a subtype of the required type. If the required item type is an atomic type, the supplied value is atomized. Atomization causes each node in the supplied sequence to be replaced by its typed value, while leaving any atomic values in the sequence unchanged. Note that the typed value of a node can be a sequence of zero or more atomic values. Elements declared in the schema to have element-only content have no typed value, so this operation can result in an error. Any item in the atomized sequence that is of type xs:untypedAtomic is cast to the required item type. Such items are most likely to arise as the result of atomizing a node in a schema-less doc- ument. This means, for example, that an attribute such as @date-of-birth will be acceptable where the required type is xs:date, provided that either  a  the attribute is annotated as an xs:date as a result of schema validation, or  b  the attribute is unvalidated and its textual form is acceptable as an xs:date. If the required item type is a numeric type  one of xs:double, xs:float, xs:decimal, or xs:integer, or a type derived from these by restricting the range of values , then any numeric value in the atomized sequence is promoted to the required numeric type where possible. An integer can be promoted to any other numeric type, a decimal can be promoted to xs:float or xs:double, and an xs:float can be converted to an xs:double. However, other conversions are not possible; for example if the required item type is xs:integer but the supplied value is xs:double, a type error will be reported. If the required item type is xs:string and the supplied value is of type xs:anyURI, then the URI is converted to a string  XDM effectively treats xs:anyURI as a subtype of xs:string, even though XML Schema does not deﬁne it that way .  If, after these conversions, the sequence conforms to the required type, then it is returned as the result value. If not, the system reports a type error. Type errors may be reported at runtime, but if the system can tell in advance that the expression will return a value of the wrong type, then they can also be reported at compile time.  These rules are not as liberal as the rules that were used in XPath 1.0 for type conversions, where, for example, a boolean could be supplied when a string was expected, and it would be treated as the string "true" or "false". Because the type system in XSLT 2.0 is so much richer, you have to get used to the idea of thinking about what type of value you are handling, and of doing any necessary conversions yourself, using explicit casts or calls on constructor functions.  Usage Variables are useful, as in any programming language, to avoid calculating the same result more than once.  Global variables are useful for deﬁning constants, such as a color value, that will be used in many places throughout the stylesheet. They can also be used to extract values from the principal source document.  Unlike variables in many programming languages, XSLT variables cannot be updated. Once they are given an initial value, they retain this value until they go out of scope. This feature has a profound effect on the programming style used when a stylesheet needs to do calculations. The subject of programming without assignment statements is discussed in detail in Chapter 17.  506   xsl:variable  Examples Most XSLT variables fall into one of the three categories:           Variables used to avoid repeating a common expression in more than one place. This might be simply to make the code more readable or to ensure that you only have to make a change in one place if the value changes or perhaps because it gives a performance beneﬁt. Variables used to capture context-sensitive information, allowing the variable to be used after the context has changed. Variables holding intermediate results, allowing a transformation to be carried out as a series of separate steps.  In each case the variable might be local or global. I’ll show some examples of each kind.  Convenience Variables Consider this example, which calculates the number of goals scored by, and against, a soccer team.  6  X S L T  l  E e m e n t s  <xsl:variable name="for"  <xsl:variable name="against"  select="sum $matches team[.=$this] @score " >  select="sum $matches[team=$this] team @score  - $for" >  . . .          This uses two rather complex expressions to construct the variables «for» and «against», which calcu- late the number of goals scored by, and against, the team identiﬁed by the variable «$team». It would be quite possible in this case to avoid using the variable «against». The expression that calculates its value could equally be written at the point where the variable is used, in the second   instruc- tion. The same is true of the «for» variable, though this time the expression would need to be written twice, in both places where the variable is used, and this might give a performance penalty. However, these variables are really being used only for clarity; it would be quite possible to write the stylesheet without them.  This is true because nothing can change between the variables being deﬁned and being used. The source document can’t change, and the values of the variables $this and $matches can’t change. The context  for example the current position in the source document  can change, but in this example  a  it doesn’t, and  b  the expressions don’t depend on the context anyway.  I call these convenience variables because you could get by without them if you had to  though there might be a performance hit . They can be used either as global variables or as local variables. Creating global convenience variables that refer to sets of nodes in the source document is often a useful programming technique; for example:     These act rather like views in an SQL database.  Variables to Capture Context-Sensitive Values These variables are most often useful in conjunction with  , which changes the context item. Consider the following example.  507   XSLT Elements  Example: Using a Variable for Context-Sensitive Values  This example shows how a variable can be used to hold on to information that depends on the context, for use when the context has changed.  Source  The source ﬁle is opera.xml. It contains a list of operas and details of their composers.           The Magic Flute   Mozart   1791               Don Giovanni   Mozart   1787    Ernani   Verdi   1843    Rigoletto   Verdi   1850              Tosca   Puccini   1897         Wolfgang Amadeus Mozart   1756   1791         Guiseppe Verdi   1813   1901         Giacomo Puccini   1858   1924         508   xsl:variable  Stylesheet  The stylesheet is the ﬁle opera.xsl. This is a complete stylesheet: It uses the simpliﬁed stylesheet syntax described on page 125, in Chapter 3. The stylesheet contains two nested   loops. In the outer loop, it sets a vari- able «c» to the context node  the current composer . In the expression controlling the inner loop, this variable is used. It would not be correct to use «.» in place of «$c», because the   element is no longer the context node. In this example it would be possible to use the current   function here  this function is described on page 734, in Chapter 13 , but there are other cases where a variable is necessary.  <html  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" xsl:version="2.0">       Programme      <xsl:value-of  select="concat fullname, ’  ’, born, ’-’, died, ’ ’ " >             6  X S L T  l  E e m e n t s              Output  See Figure 6-18.  Figure 6-18  509   XSLT Elements  One case where context variables are very useful is when handling multiple source documents.  In any stylesheet that handles multiple source documents, it is useful to include a global variable that refers to the document node of the principal source document, thus:     This means it is always possible to refer to the source document by using this variable. Without this, when the context node is in a secondary document, there is no way of accessing data from the principal document.  For example, the expression «  item» refers to all   elements in the same document as the context node. If you actually want all   elements in the principal source document, then  provided you have included the global variable declaration above  you can use the expression «$root  item».  If there is a document referenced from the stylesheet, for example to hold look-up data such as messages or tax rates, it is also useful to deﬁne this in a global variable, for example:     Variables to Hold Intermediate Results When a complex transformation task is undertaken, it is often useful to split it into a sequence of steps. The output of one step can be held in a variable, which is then used as the input to the next step.  Any kind of value can be used as an intermediate result, but most commonly it will either be a sequence of items, or a temporary document.  The value of a variable will be a temporary document  or a result tree fragment as it was known in XSLT 1.0  if it is deﬁned using the content of the   element rather than the select attribute, and if there is no as attribute.  Variables evaluated using a sequence constructor are useful when you use   or   to calculate a value that you then want to manipulate further. If such a value is complex, it will generally take the form of a temporary document. Such documents are needed whenever you require working data that is too complex to hold in a simple sequence. With XSLT 2.0, it is possible to perform any operation on a temporary document that you can perform on the principal source document, or on a document loaded using the document   function. This greatly increases their usefulness. There are two main categories:     Intermediate results of a multiphase transformation.  It’s often useful to break up a transformation into a sequence of steps  often referred to as a pipeline , to simplify the logic. A temporary tree can be used as the output of the ﬁrst phase and the input to the next.    Working data passed as a parameter through template or function calls.  For example, if you need to create a data structure such as a list of keyword value pairs, and pass this as a parameter to a function or template, then the best way to construct this data struc- ture is as a tree.  The next example shows a multiphase transformation.  510   xsl:variable  Example: A Multiphase Transformation  This example performs a transformation in two phases. The ﬁrst phase starts with a list containing the results of a series of soccer matches, and computes a league table showing the standing of the various teams. The second phase renders this league table in HTML. These are quite separate operations and it’s best to keep them separate. In fact, we’ll keep them completely separate by using different stylesheet modules and different modes.  Source  The source document is soccer.xml. It contains the results of individual matches. Here are the ﬁrst few:  6  X S L T  l  E e m e n t s       10-Jun-98   Brazil   Scotland       10-Jun-98   Morocco   Norway       16-Jun-98   Scotland   Norway    . . .    Stylesheet  The ﬁrst phase of the transformation calculates a league table. This is in module league.xsl, shown below:  <xsl:transform  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" version="2.0"  >                   <xsl:variable name="won"  select="count $matches[team[.=$this] @score gt  team[.!=$this] @score] " >  511   XSLT Elements  <xsl:variable name="lost"  select="count $matches[team[.=$this] @score lt  team[.!=$this] @score] " >  <xsl:variable name="drawn"  select="count $matches[team[.=$this] @score eq  team[.!=$this] @score] " >  <xsl:variable name="for"  select="sum $matches team[.=current  ] @score " >  <xsl:variable name="against"  select="sum $matches[team=current  ] team @score  - $for" >  <team name="{ . }" played="{$played}" won="{$won}" drawn="{$drawn}"  lost="{$lost}" for="{$for}" against="{$against}" >             Since we’re talking about usage of   here, it’s worth drawing attention to the way this example uses variables. There are a couple of global variables to deﬁne the list of teams and the list of matches. The stylesheet only contains one template, so these variables could equally well have been local, but making them global reﬂects the fact that they are potentially reusable. Within the template, the variable $this is set to the context item so that it can be used within predicates, where the context item will have changed. Then the computation is done entirely within a sequence of local variable declarations. This is a very characteristic programming style. Finally, the template outputs one   element for each team, with attributes indicating the number of matches won and lost, the goals scored, and so on. The second stylesheet show-league.xsl renders the league table into HTML. It’s quite straightforward:  <xsl:transform  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" version="2.0"  >              Note the variable here to capture the result of the ﬁrst phase of processing. The value of this variable will be a document node containing the   element created by the previous stylesheet.         League Table    512   xsl:variable  6  X S L T  l  E e m e n t s      League Table           Team   Played   Won   Lost   Drawn   For   Against                                                                Output  The output of the stylesheet is shown in Figure 6-19.  Figure 6-19  513   XSLT Elements  Avoiding Trivial Documents There is a tendency to create temporary documents when they aren’t needed. One often sees constructs like this:           This ﬁrst calculates a number  the result of the count   function . It then converts this number to a string, wraps the string into a text node, creates a document node with the text node as its only child, and sets the value of the variable to be this document node. The chances are that the variable will then be used in an expression such as «$played>5», in which a number is required: so the system has to atomize the document node, extract its string value by reading all its text node descendants, and then convert the resulting string to a number. You can save yourself two lines of code, and the system a lot of unnecessary work, by writing instead:     Here the value of the variable is a number. No need to create the temporary document, and no need to atomize it later to extract the value.  I call this kind of variable a trivial document. A trivial document behaves almost exactly like an untypedAtomic value. Here is a slightly more complicated example:                 0         In XSLT 2.0 it is almost always possible to avoid this kind of construct and the overheads that go with it. Write this instead as:  <xsl:variable name="width" as="xs:integer"  select="if  @width  then @width else 0" >  Or more concisely:     There are several beneﬁts in declaring the type. Firstly, it’s good documentation for anyone reading the stylesheet. Secondly, it causes the system to do some error checking for you: if the width isn’t an integer, you’’ll get an appropriate error message. Finally, it’s likely to be more efﬁcient. A document node is a very heavyweight object compared with an integer.  The important change here was adding the «as» attribute to declare the type. It’s this that eliminates the need to create the document node. You can retain the use of   in the body of the   if you prefer, writing it as:  514   xsl:when  6  X S L T  l  E e m e n t s                               In this example above I have substituted   for  . In fact, either instruc- tion would work. But using   creates a text node, only to extract its value and convert this to an integer, which is unnecessarily inefﬁcient.  Beginners sometimes try to write this as:                         This won’t work, because when you get to the end tag of the   element, both variable declarations will have gone out of scope!  See Also   on page 425  xsl:when  Changes in 2.0 None.  Format  <xsl:when  The   element always appears as a child of  . It deﬁnes a condition to be tested and the action to be performed if the condition is true.  test = expression>       Position   is always a child element of  . There must be at least one   element within an   element.  515   XSLT Elements  Attributes Name test mandatory  Content A sequence constructor.  Value XPath Expression  Meaning The boolean condition to be tested  Effect The   element is evaluated as follows:           The ﬁrst   element whose test expression has an effective boolean value of true is selected; subsequent   elements are ignored regardless of the value of their test expression. If none of the   elements has a test expression that is true, the   element is selected. If there is no   instruction, no element is selected. The sequence constructor contained in the selected child element  if any  is evaluated in the cur- rent context: that is, the effect is as if the relevant sequence constructor appeared in place of the   instruction.  Any XPath expression may be evaluated to obtain an effective boolean value. The rules are given in the section for   on page 353.  The test expression in a   element after the selected one is not evaluated. This means it is safe to write code such as this:                                 The conversion to an integer will not be attempted, and cannot therefore cause a failure, if the condition in the ﬁrst   is true.  Usage and Examples See   on page 282  See Also   on page 282   on page 420   on page 353  516   xsl:with-param  xsl:with-param  The   element is used to set the values of parameters when calling a template, either when using   or when using  . It can also be used with   and with  .  Changes in 2.0 The   element can now be used as a child of   or  .  The as and tunnel attributes have been added.  When used with  , XSLT 2.0 deﬁnes compile-time errors if there is mismatch between the parameters supplied in the call and the parameters declared for the target   element.  6  X S L T  l  E e m e n t s  Format  <xsl:with-param  name = qname select? = expression as? = sequence-type tunnel? = "yes"  "no">       Position   is always a child of  ,  ,  , or  .  Attributes Name name mandatory  select optional  as optional  tunnel optional  Value Lexical QName  Meaning The name of the parameter.  XPath Expression  The value of the parameter to be supplied to the called template.  SequenceType  Deﬁnes the type of the value.  «yes» or «no»  Indicates whether this is a tunnel parameter.  Content An optional sequence constructor. If a select attribute is present, the   element must be empty.  Effect The   element assigns a value to a parameter. The value of the parameter can be used within the called template.  517   XSLT Elements  The value of the parameter is established in exactly the same way as for the   element. That is, the value is obtained by evaluating the select expression if present, or the contained sequence constructor if not.  Except for tunnel parameters  those where «tunnel="yes"» is speciﬁed , the parameter value is available only to the immediately called template. If the called template has an   element whose name matches that of the   element, then the value assigned to the   ele- ment is available within the template. If the called template has no such parameter, the value is ignored, except when using  , when this is an error. In the case of  , the parameter value is available in each of the templates that is called  one per selected node . The param- eter is effectively evaluated once only — it will have the same value for each of these templates.  The name of the parameter is deﬁned by a lexical QName. Normally, this will be a simple name such as «city» or «total-sales», but it may be a name qualiﬁed with a preﬁx, for example «my:value». If it has a preﬁx, the preﬁx must correspond to a namespace that is in scope at that point in the stylesheet. The true name of the parameter is determined not by the preﬁx but by the namespace URI; so the name «my:value» will match a parameter declared as «your:value» if the preﬁxes «my» and «your» refer to the same namespace. If the name has no preﬁx, it has a null namespace URI — it does not use the default namespace.  It is an error for two sibling   elements to have the same name, after namespace preﬁxes are replaced with namespace URIs. In other words, you can’t supply two values for the same parameter. This applies even if one is a tunnel parameter and the other is not.  The   element does not actually declare a variable, so there is no problem if the name is the same as that of a variable that is currently in scope. In fact, it is quite normal to pass a parameter in the form:     This is used to ensure that the variable «$current-user» in the called template has the same value as the variable «$current-user» in the calling template.  If the «as» attribute is present, then the supplied value of the parameter is converted to the speciﬁed type using the same rules as for  . There is no requirement that this type must be identical to the declared type of the corresponding  : For example the   might specify «as="xs:byte"» when the   speciﬁes «as="xs:integer"». This means that potentially two conversions may take place, from the type of the supplied value as calculated by the select expression, to the type declared in the «as» attribute of  , to the type declared in the «as» attribute of the corresponding  . In each case the standard conversion rules are used, as described in the entry for   on page 505.  The option «tunnel="yes"» allows the parameter to be set up as a tunnel parameter. Tunnel parameters are described in the entry for   on page 429, with a worked example on page 433.  Usage and Examples Parameters to templates take on considerable signiﬁcance in XSLT because variables cannot be updated. This means that many tasks that in conventional programming languages are done by updating variables in a loop are done instead in XSLT using recursive calls and parameters. The consequences of this are explained in Chapter 17, and there are some detailed examples of the technique in Chapters 19 and 20.  Examples of recursive calls are also included in this chapter under   on page 274.  518   Summary  See Also   on page 237   on page 240   on page 271   on page 425  Summar y  This was a long chapter, but I hope you agree that every page was worth it! We have examined all of the XSLT elements in detail and have provided working examples to bolster your understanding of how they are used.  Many of the XSLT instructions described in this chapter contain embedded XPath expressions to compute their input. The next four chapters present a detailed description of the syntax and semantics of XPath expressions.  6  X S L T  l  E e m e n t s  519    7  X P a t h  F u n d a m e n t a s  l  XPath Fundamentals  This chapter deﬁnes some fundamental features of the XPath language. The ﬁrst half of the chapter describes the basic syntactic and lexical conventions of the language, and the second half describes the important notion of context: this establishes the way in which XPath expressions interact with the envi- ronment in which they are used, which for our purposes primarily means the containing XSLT stylesheet.  The complete grammar of the language is summarized in Appendix A, and for convenience I have split the constructs of the language across ﬁve chapters, as follows:  Chapter 7  Scope Notation used for describing the grammar  Overall structure of the language  Lexical rules  including comments and whitespace handling   Literals  Variable references  Parenthesized subexpressions  Context item expression «.»  Function calls  Conditional expressions: «if»  8  Arithmetic operators: «+», «-», . . .  Value comparison operators: «eq», «lt», . . .  General comparison operators: «=», «<», . . .  Node identity and ordering operators: «is», « >»  Boolean operators: «and», «or»  continued   XPath Fundamentals  Chapter 9  Scope Path expressions: « », «  »  Steps and axes  Union, intersect, and except operators  Sequence concatenation operator: «,»  Numeric range operator: «to»  Filter expressions «a[b]»  Mapping expressions: «for»  Quantiﬁed expressions: «some» and «every»  SequenceType production  10  11  «instance of»  «castable as»  «cast as»  «treat as»  As with other programming languages, the syntax is deﬁned in a set of production rules. Each rule deﬁnes the structure of a particular construct as a set of choices, sequences, or repetitions.  I took the formal production rules directly from the XPath speciﬁcation document  http:  www.w3.org  TR xpath20 , but reordered them for ease of explanation, and I made minor changes to the typography and to some of the production names for ease of reading. I also pulled in those rules from the XML and XML Namespaces standards that the XPath syntax references. I’ve tried to do this in a way that leaves the original rule clearly recognizable, so you can relate it to the original speciﬁcation if you need to. However, I have tried in this book to include all the information you need from the XPath speciﬁcation, so this should only be necessary if you need to see the precise wording of the standard.  Notation  The XPath speciﬁcation, by and large, uses the same syntax notation as the rest of the family of XML speciﬁcations. This is often referred to as extended BNF, though the number of variations you ﬁnd on the BNF theme can be a little bewildering. I have stuck fairly closely to the notation used in the XPath 2.0 speciﬁcation, though I have allowed myself a little typographic license in the hope that this adds clarity.  As in the rest of the book, I used French quotation marks «thus»  also known as chevrons or guillemets  to surround pieces of XPath text that you write: I chose this convention partly because these marks stand out more clearly, but more importantly to distinguish these quotation marks unambiguously from quotation marks that are actually part of the expression. So if I say, for example, that literals can be enclosed either in «"» or «’» marks, then it’s clear that you don’t actually write the chevrons. XPath syntax doesn’t use chevrons with any special meaning  though like any other Unicode character, you can use them in string literals and comments , so you can be sure that any chevron you see is not to be included in the expression.  522   Where to Start  The notations used in production rules are as follows:  Construct  «abc»  Meaning The literal characters abc  A construct that matches the production rule named xyz  xyz  PQ  P?  P*  P+   P   A choice of P or Q  Either P, or nothing  Zero or more repetitions of P  One or more repetitions of P  A subexpression  [i-n]  One of the characters in the range «i» to «n» inclusive  The production rules in XPath implicitly deﬁne the precedence of the different operators. For example, the rule for OrExpr deﬁnes it as a sequence of AndExpr operands separated by «or» operators. This is a convenient way of deﬁning that the «and» operator binds more tightly than «or». The precedence order of all the operators is summarized in Appendix A.  One consequence of this style of deﬁnition is that the simplest OrExpr consists of a single AndExpr with no «or» operator present at all. This leads to all sorts of surprises. For example, because of the way the grammar is written, «3» is not just an IntegerLiteral, it is also a FilterExpr, a RelativePathExpr, a MultiplicativeExpr, a TreatExpr, and quite a few other things besides. This means that I can’t use the term OrExpr when I want to refer speciﬁcally to an expression that uses an «or» operator. Instead, I’ll refer to this as ‘‘an «or» expression.’’ This distinction works quite well in most cases, and if there’s any risk of confusion, then I’ll try to spell out exactly what construct I’m talking about.  Although the production rules in XPath deﬁne the operator precedence, they do not impose any type checking. This follows the practice of most modern language speciﬁcations, where rules for type checking are regarded as being enforced in a second phase of processing, after the raw parsing of the syntax. It would be hard to deﬁne all the type checking rules in the grammar, because many of them operate at a distance. Since the type-checking rules can’t all be deﬁned in the grammar, the language designers decided to go to the other extreme, and deﬁne none of them in the grammar.  This means that the grammar allows many kinds of expression that are completely nonsensical, such as «3‘bread’»  where «» is the set union operator . It’s left to the type-checking rules to throw this out: the rules for the «» operator say that its operands must be of type «node  *», that is, sequences of nodes. Think of an analogy with English — there are sentences that are perfectly correct grammatically but still nonsense: ‘‘An easy apple only trumpets yesterday.’’  Where to Star t  Some people prefer to present the syntax of a language bottom-up, starting with the simplest constructs such as numbers and names, while others prefer to start at the top, with a construct like Program or Expression.  7  X P a t h  F u n d a m e n t a s  l  523   XPath Fundamentals  What I’ve chosen to do is to start at the top, with the section Expressions, which is really just an opportu- nity to provide an overview of the grammar, and then work bottom-up, starting with the basic building blocks of the language in this chapter and progressing through the other operators in the next four chapters. Each of these chapters describes a reasonably self-contained set of expressions that you can write in XPath. There’s no obviously logical order to these, but I decided to present the simpler opera- tors and expressions ﬁrst, to make life as easy as possible if you decide to read the chapters sequentially. This also corresponds broadly with the order in which material is presented in the XPath speciﬁcation itself.  If you want to ﬁnd where in the book a particular construct is described, you might ﬁnd the syntax summary in Appendix A helpful.  Many languages distinguish the lexical rules, which deﬁne the format of basic tokens such as names, numbers, and operators, from the syntactic rules, which deﬁne how these tokens are combined to form expressions and other higher-level constructs. The XPath speciﬁcation includes both syntactic and lexical production rules, but they are not quite as cleanly separated as in some languages. The main distinc- tion between the two kinds of rule is that whitespace can be freely used between lexical tokens but not within a lexical token. I will try to distinguish carefully between syntax rules and lexical rules as we come across them in the grammar. The main difference is that when something is described as a syn- tax rule you can use whitespace and comments freely between the symbols, which is not the case for a lexical rule.  Expressions  The top-level construct in XPath  the entry point to the list of productions  is called Expr. This is described with the following syntax:  Expression  Syntax  Expr  ExprSingle  «,» ExprSingle *  ExprSingle  ForExpr   QuantifiedExpr   IfExpr   OrExpr  These rules indicate that an Expr is a list of ExprSingle expressions separated by commas, and an ExprSingle is either a ForExpr, a QuantifiedExpr, an IfExpr, or an OrExpr.  Here are some examples of the constructs mentioned in these rules:  524   Expressions  Construct  Example  1 to 3, 5, 7, 11, 13  any of the examples below  for $i in 1 to 10 return $i * $i  QuantifiedExpr  some $i in   item satisfies exists $i *   if  exists @price   then @price else 0  @price > 3 or @cost < 2  Expr  ExprSingle  ForExpr  IfExpr  OrExpr  7  X P a t h  F u n d a m e n t a s  l  I’ll cover the «,» operator  which concatenates two sequences , together with the ForExpr and the QuantifiedExpr in Chapter 10, which is all about expressions on sequences. The IfExpr  which allows you to write conditional «if..then..else» expressions  is covered in this chapter, on page 551, and the OrExpr, which allows you to use the boolean «or» operator, and provides the entry point to most of the rest of the XPath syntax, is described in Chapter 8.  The ExprSingle construct has a special role in the grammar. Because the «,» symbol is overloaded  it’s used both as an operator for concatenating two lists and also as a syntactic delimiter in constructs such as a function call , there are places where you might expect the grammar to allow any Expr to appear but where, in fact, only an ExprSingle is allowed. This means that if you want to use a «,» operator in such contexts, you have to enclose the expression in parentheses.  The constructs IfExpr, ForExpr, and QuantifiedExpr are syntactically unusual in the XPath grammar because they start with keywords and contain multiple subexpressions. In a conventional language, they would probably be called statements rather than expressions. Nevertheless, they are true expressions, in the sense that they can be evaluated to produce a result, and they can appear anywhere in the grammar where an expression is required.  The OrExpr starts a list of productions that contains all the conventional expressions of the language, as follows:  Expression  OrExpr  AndExpr  Syntax  AndExpr   «or» AndExpr  *  ComparisonExpr   «and» ComparisonExpr  *  ComparisonExpr  RangeExpr     ValueComp  GeneralComp  NodeComp  RangeExpr  ?  RangeExpr  AdditiveExpr  AdditiveExpr   «to» AdditiveExpr  ? MultiplicativeExpr    «+»  «−»  MultiplicativeExpr  *  continued  525   XPath Fundamentals  Expression  Syntax  MultiplicativeExpr  UnionExpr    «*»  «div»  «idiv»  «mod»  UnionExpr  *  UnionExpr  IntersectExceptExpr     «union»  «»  IntersectExceptExpr  *  IntersectExceptExpr  InstanceOfExpr     «intersect»  «except»  InstanceOfExpr  *  InstanceofExpr  TreatExpr    «instance» «of» SequenceType  ?  TreatExpr  CastableExpr    «treat» «as» SequenceType  ?  CastableExpr  CastExpr    «castable» «as» SingleType  ?  CastExpr  UnaryExpr  UnaryExpr    «cast» «as» SingleType  ?  «−»  «+» * PathExpr  These expressions all have a similar form: each deﬁnes an expression in terms of expression in the row below combined with particular inﬁx or preﬁx operators. These operators are all described in the fol- lowing chapters, according to the role that they play.  At the level of PathExpr, the syntax starts to become rather more specialized again, which shouldn’t be surprising because path expressions are the characteristic feature of the XPath language that gives it its special ﬂavor. Chapter 9 is devoted to path expressions, where you will ﬁnd the full syntax.  Below the level of path expressions, the most primitive expressions in the language are referred to as primary expressions. At that level we will pick up the story again in this chapter, on page 539.  As explained in Chapter 1, XPath is a read-only expression language. It’s a general principle of XPath that expression evaluation is free of side effects: evaluating an expression isn’t going to change the values of any variables, write information to log ﬁles, or prompt the user for their credit card number. Therefore evaluating the same expression more than once, in the same context, shouldn’t make any difference to the answer or to the ﬁnal output, and equally it shouldn’t make any difference in which order expres- sions are evaluated. As a result, the XSLT and XPath speciﬁcations generally say nothing about order of evaluation.  The only way side effects can occur from evaluating an expression is if the expression calls user-written  or vendor-written  extension functions, because the XPath speciﬁcation doesn’t constrain what an exten- sion function can do. Equally, it makes no guarantees about when, and in what order, extension functions are called.  526   Lexical Constructs  Examples  Examples of expressions occur throughout this book. Here is a selection, brought together to indicate the variety of constructs that fall under this heading. Like many of the examples of XPath expressions in this section of the book, these have been collected together into XSLT stylesheets, complete with sample data, so that you can see for yourself how they work and experiment with your own changes. You’ll ﬁnd these particular examples in a ﬁle called ch07 expressions.xsl in the download for this book. Make a note of what else is available in the downloads, because I won’t always be mentioning the ﬁle names explicitly.  Expression  $x +  $y * 2     book    magazine  substring-before  author, ‘ ’   chapter and verse  Description Returns the result of multiplying $y by two and adding the value of $x.  Returns a sequence of nodes containing all of the   and   elements in the same document as the context node.  This could also be written, perhaps more efﬁciently, as «   bookmagazine ».   Finds the value of the ﬁrst   child of the context node and returns that part of the value that precedes the ﬁrst space character.  Returns the xs:boolean value true if the context node has a child   element and also a child   element.  7  X P a t h  F u n d a m e n t a s  l  93.7  Returns the decimal value 93.7.  sum   product   price * qty   Returns the result of multiplying the values of   and   for every   element in the document, and summing the results.  avg    product [position   le 5]  price   Returns the average   of the ﬁrst ﬁve   elements in the document.  Lexical Constructs  An XPath 2.0 expression is written as a sequence of Unicode characters. Every character that’s available in XML 1.0 can be used in an XPath expression, and possibly characters that are available in XML 1.1 as well, though that’s been left up to the implementation to decide.  XPath itself isn’t concerned with how these characters are encoded. XPath expressions will often be embedded in other languages such as XSLT, or they may be constructed as runtime character strings using a programming language such as Java or JavaScript. Any escape conventions local to the host language will be applied before the XPath parser gets to see the expression, and the syntax described in the XPath Recommendation  and in the XPath chapters of this book  is the syntax after such escapes have been expanded. For example:    When XPath expressions are written in an XSLT stylesheet, the escaping conventions of XML  apply. This means, for example, that a «<» character must be escaped as «&lt;» and an amper- sand as «&amp;». Since XPath expressions are invariably written inside an attribute value in the  527   XPath Fundamentals  stylesheet, the delimiting quotation marks of the attribute value  usually «"», but you can choose «’» if you prefer  must also be escaped, typically as «&quot;» or «&apos;», respectively. It’s also worth remembering that the XML parser normalizes whitespace in an attribute value, so if you want to write an expression that tests whether some element in your source document contains a tab character, you should write this as  . As far as XPath is concerned, an XPath expression can contain a tab character inside a string literal  and indeed, that’s what it sees in this example , but to get the tab character past the XML parser, you need to escape it. Similarly, when XPath expressions are written within character strings in a host language such as Java, you will need to use the escaping conventions of that language: for example, a backslash needs to be written as «\\» and a quotation mark as «\"».  XPath is an unusual language in that it has no reserved words. Unembellished names in an XPath expres- sion, such as «table» and «author», refer to elements or attributes in the source document that have these names. Since there are no restrictions on what you can call the elements in your source document  other than the characters that can be used , XPath has been designed so there are no restrictions on the names that can appear in the XPath expression. The result is that other names  for example, the names of variables and functions, as well as language keywords  have to be either embellished in some way, or recognized by the context in which they appear. There are several ways the grammar achieves this:  Names of variables are always preceded by a «$» sign, for example «$x»  whitespace is allowed between the «$» and the «x», though it is rarely used in practice . Names of functions are always followed by a left parenthesis; for example, «not ». Again, whitespace is allowed before the « ». Some syntactic keywords use the same convention. For example, «if» in a conditional expression is always followed by « », and node tests such as «element  » are also written with parentheses.  This node test matches any element node; if you leave out the parentheses, then it matches only elements that have the name «element».  Some operators, such as «and», «or», and «div», are written as keywords, but they are recog- nized as keywords only if they appear in a context where an operator is expected. The language is carefully arranged so that there is no ambiguity, and you can happily write constructs such as «and or or» to test whether there is an element called   or an element called   in your source document. Some operator names consist of doubled keywords, such as «instance» «of» or «castable» «as». These are recognized only if they appear as a pair. You can use whatever whitespace and comments you wish between the keywords. The keywords «for», «some», and «every», which introduce expressions described in Chapter 10, are recognized by virtue of the fact that they are always followed by a «$» sign  which in turn introduces the name of a variable .                    As with most languages, the ﬁrst stage in processing an XPath expression is lexical analysis, also known as tokenizing. The ﬁrst stage of identifying the tokens is done fairly mechanically, and does not depend in any way on the syntactic context. At each stage, the longest sequence of characters that could comprise a single token is read. There are a few places where this can lead to surprises; for example, «x+1» is read as three tokens, whereas «x -1» is read as a single token. This is because XML names can contain a «-» character but not a «+» character. To ensure that «x -1» is read as a subtraction rather than as a single name, you need a space before the «-» for example «x -1». You also need to be careful with the humble «.» character, which can appear in several different roles in XPath: as a decimal point within a number,  528   Lexical Constructs  as a separator character within a name, and as a symbol in its own right, representing the context item. So, for example if you write «$a is .»  which tests whether variable $a refers to the context node , then you need a space between the «is» and the «.».  Once the text has been split into tokens, the tokens are classiﬁed. It is at this stage that the decision is made whether a name such as «div» is being used as an element name in a path expression, as a function name, as a variable name, or as an operator or keyword. As we have seen, the decision on how to classify a token may depend on the tokens that precede and follow it. It’s likely that many parsers will also group together compound symbols such as «cast» «as» at this stage, though the details of how this is done are left entirely to the implementation.  The following sections present the basic lexical constructs found within an XPath expression.  Comments  Comments may appear in an XPath expression anywhere that whitespace may appear. Comments begin with « :» and end with «: », which feels slightly comical until you get used to it. But it means that comments are quite distinctive visually, and they read well because they look parenthetical.  7  X P a t h  F u n d a m e n t a s  l  Here is an example of a comment within an XPath expression:  if  string @x   then  : attribute x exists and is non-empty :  @x else "none"  Was it really necessary for XPath to invent a completely new syntax for comments? Well, none of the obvious candidates would work. The C Java convention is heavily reliant on symbols such as « » and «*», which are already overloaded in XPath. The SQL convention of «--» doesn’t work because it’s perfectly legal to have two adjacent hyphens in an XML name. The XML syntax of   doesn’t work in an expression that’s embedded in an XML attribute in a stylesheet. Because of XML attribute normalization, anything that attaches signiﬁcance to line endings is ruled out. Curly braces were tried at one stage, but they are easily confused with the delimiters for attribute value templates in XSLT, or the equivalent embedded expressions in XQuery  and they were a new invention anyway . So smileys it is. . ..  XPath 2.0 comments can be nested. This allows you to comment out a section of code even if it already contains comments. So, for example, the following expression is legal, and evaluates to 3:  3  : + if  number @x    then  : attribute x exists and is non-zero :  @x else 0  :   Symbol  Comment  To achieve this, the production rules for comments are given as follows:  Lexical Rules  « :»  CommentContents  Comment * «: »  CommentContents  Char  529   XPath Fundamentals  Changes in XPath 2.0  Numeric Literals  The way this rule works is that within a comment, you can have a sequence of things, each of which is either a character or a comment. Since the system always looks for the longest matching construct, if it sees « :» within a comment then it will interpret this as the start of a nested comment, rather than as two ordinary characters.  XPath 1.0 provided no way of writing comments within an expression. The facility has become necessary because with the introduction of conditional expressions, «for» expressions, and the like, XPath 2.0 expressions can be much longer and more complex.  Numeric literals represent constant numbers. There are three types of number that can be written as constants within an XPath 2.0 expression; these correspond to the types xs:integer, xs:decimal, and xs:double. The type of the value is inferred from the way it is written. The rules are shown in the table below.  Symbol  Lexical Rules  IntegerLiteral  Digit+  DecimalLiteral   «.» Digit+    Digit+«.» Digit*   DoubleLiteral  Digit  That is to say:    «.» Digit+    Digit+ «.» Digit* ?    «e»  «E»   «+»  «−» ? Digit+ [0-9]           A sequence of one or more digits, with no decimal point or «e» or «E», is interpreted as an inte- ger literal. For example, «0», «23», and «0034» are all integer literals. A sequence of one or more digits, with a decimal point among the digits or at the beginning or end, is interpreted as a decimal literal. Examples are «1.50», «.001», and «3.». A literal in scientiﬁc notation  or to be pedantic, in Fortran notation  is interpreted as an xs:double value. It starts with the mantissa, which may take the same form as either an integer or a decimal literal, followed by the letter «E» in upper or lower case  there is no distinc- tion between the two, though upper case «E» is always used on output , followed by an expo- nent expressed as an integer, optionally preceded by a plus or minus sign. Examples are «0e0», «0.314159e+001», and «1.E-6».  The production rule for Digit is written as a regular expression and means that Digit is a sequence of one or more characters, each in the range 0 to 9. The square brackets do not mean that the construct is optional, as in some other syntax notations; rather they indicate a range of characters.  You may be wondering why a leading minus sign is not allowed at the front of a numeric literal. The answer is that it is allowed, but it’s not part of the literal, so it’s not included in these rules. You can write «-1», but this is technically not a numeric literal; it is an arithmetic expression using a unary minus operator. This operator is described in Chapter 8.  530   Lexical Constructs  The actual value of the literal is deﬁned in a way that guarantees consistency with the interpretation of values of type xs:integer, xs:decimal, or xs:double by XML Schema. These rules aren’t as clear-cut as you might imagine; for example, if you specify a decimal value with more decimal places than your implementation supports, the processor has the option of either rounding the value  in any way it chooses  or reporting an error.  There’s a signiﬁcant change in this area from XPath 1.0, where all numeric values were treated as double-precision ﬂoating point. In XPath 1.0, the literal «1.5» represented an xs:double; in XPath 2.0, it is an xs:decimal. This can affect the precision of numerical calculations. The chances are that the only applications that will notice the change are those that are numerically fairly sophisticated  for example, an XSLT stylesheet that does trigonometrical calculations to produce SVG output . If you have such an application, it may be worth replacing any literals of the form «1.5» by «1.5e0» when you migrate to XPath 2.0.  It’s worth mentioning here that the rules for output of numbers are not the same as the rules for input. When a number is converted to a string, the results are determined by the casting rules given in Chapter 11. To summarize these:           An xs:integer value is output as an integer, for example, «42» or «-315» An xs:decimal value with no fractional part is output as if it were an integer, with no decimal point. If it has a fractional part, it is output with at least one digit before and after the decimal point, and no other insigniﬁcant leading or trailing zeros. Examples of xs:decimal output are «42», «-315», «18.6», «-0.0015». An xs:double or xs:float value that’s within the range 1e-6 to 1e+6  one millionth to one mil- lion, positive or negative  is output in the same way as a decimal. Outside this range, exponential notation is used, with one signiﬁcant digit before the decimal point. Examples of xs:double out- put are «42», «-315», «18.6», «-0.0015», «1.003e-12», «-8.752943e13».  These rules have the effect that you often don’t need to know whether the numbers you are dealing with are integers, decimals, or doubles. For example, if @width is an attribute in a schema-less document whose value is «width="17"», then the value of «string @width+1 » is «18»; you never need to know that the result of the addition was actually an xs:double  the rules for arithmetic involving mixed types are in Chapter 8 .  If you want more control over the formatting of numeric output, XSLT has a function format-number  , which offers detailed control. There’s nothing comparable in XPath itself, but you can get rid of surplus decimal digits by using the round-half-to-even   function described in Chapter 13.  7  X P a t h  F u n d a m e n t a s  l  Examples  Expression  86  3.14159  1.0E-6  Description The xs:integer value eighty-six  An xs:decimal value representing π to ﬁve decimal places  The xs:double value one-millionth  531   XPath 1.0 supported the lexical forms now used for integer literals and decimal literals, but interpreted the values as double-precision ﬂoating point. There was no support in XPath 1.0 for scientiﬁc notation.  XPath Fundamentals  Changes in XPath 2.0  String Literals  A StringLiteral represents a constant string.  Symbol  Lexical Rules  StringLiteral   «"»  [ ˆ "] * «"» +   «’»  [ ˆ ’] * «’» +  Unless you are familiar with regular expressions you may ﬁnd this production rule difﬁcult to read. The original in the XPath Recommendation is even more cryptic, and I have replaced it with a form that I ﬁnd simpler to explain.  What it is saying is actually quite simple; a StringLiteral is either a sequence of any characters other than double quotes, enclosed between double quotes, or a sequence of any characters other than single quotes, enclosed between single quotes. For example, «"John"», or «‘Jane’», or «"don’t"» or «‘I said "go"!’».  In both cases you can put several of these sequences together end to end  the «+» sign indicates repeti- tion . This has the effect of doubling the delimiting quote character, which provides an escaping mecha- nism, allowing you to use the delimiter within the string. For example, you can write «‘O‘‘Connor’» to represent the string «O’Connor».  A StringLiteral is a lexical token. Whitespace within a StringLiteral is allowed and is signiﬁcant  whitespace characters are part of the value .  If you are using XPath expressions within an XSLT stylesheet, or any other XML document, then there are two special considerations to bear in mind. Firstly, within an XML attribute delimited by «"» signs, any «"» sign needs to be written as «&quot;», while if «’» signs are used as the attribute delimiter, any «’» characters in the value must appear as «&apos;». Secondly, some care is needed when using tab, carriage-return, and newline characters within a literal, because the XML parser is required to replace these by space characters before the XPath expression parser ever gets to see them, as part of the process of attribute value normalization. You can use character references such as «&x9;», «&xA;», and «&xD;» to prevent this happening. However, character references such as this are recognized only if the XPath expression is preprocessed by an XML parser. They are not recognized when the expression is written as a string in a Java or C program.  The following examples assume XPath is being used in a freestanding environment with no need to escape special characters:  Examples  532   Lexical Constructs  Expression  "John’s"  ‘"’  Description The string «John’s»  ‘O’‘Reilly’  The string «O’Reilly»  A string consisting of a single character, the double quotation mark  The following examples assume that XPath expressions are contained in an attribute within an XML document; for example, an XSLT stylesheet:  XSLT Attribute  select="‘John’‘s’"  select="‘&quot;’"  Description The string «John’s». The character used as the string delimiter can be escaped by doubling it.  A string consisting of a single character, the double quotation mark. The character used as the XML attribute delimiter can be escaped by using an XML entity or character reference.  select="‘Don’‘t say &quot;yes&quot;’"  The string «Don’t say "yes"». This combines the two escaping techniques from the previous examples.  7  X P a t h  F u n d a m e n t a s  l  Changes in XPath 2.0  The ability to include the string-delimiter character within the string by doubling it is new in XPath 2.0. The convention has been adopted from SQL and has the advantage of being backward-compatible with XPath 1.0.  Handling the two kinds of quotation marks in XPath expressions written within stylesheets can be tricky, even with the new escape convention introduced in XPath 2.0. You can often circumvent the problems  and produce clearer code  by using variables. For example, instead of writing:     XSLT Usage  ...     write instead:     Don’t say "yes"        ...     Within XML text nodes, apostrophes and quotation marks can be written literally without escaping — there is no need to use the entity references «&apos;» and «&quot;».  533   XPath Fundamentals  I ﬁnd it quite useful to have two global variables available in a stylesheet, as follows:   ’   "   This makes it possible to use the variables «$apos» and «$quot» to construct strings using the concat   function, for example:     Names are used within an XPath expression to refer to elements and attributes in a source document, and to refer to objects such as variables, functions, and types.  Lexical Rules   Prefix «:»  ? LocalPart  NCName  NCName   Letter  «_»    NCNameChar  *  Letter  Digit  «.»  «-»  «_»  CombiningChar  Extender  The productions QName and NCName are actually deﬁned in the XML Namespaces Recommendation, not in XPath itself. This ensures that any name that can be used for an element or attribute in a source document can also be used in an XPath expression. These are lexical rules, rather than syntax rules, which means that no whitespace is allowed between the symbols.  Informally, an NCName starts with a letter or underscore, and continues with zero or more NCNameChars, which may be letters, digits, or the three punctuation characters dot, hyphen, and underscore. The «Letter» and «Digit» categories include a wide variety of characters and ideographs in non-Latin scripts as well as accented Latin letters, while the «CombiningChar» and «Extender» categories cover accents and diacritics in many different languages.  The rules for Letter, Digit, CombiningChar, and Extender are given in the XML speciﬁcation. The deﬁnitions are in the form of long lists of Unicode characters, and little would be gained by repeating them here. The basic principle is that if a name is valid in XML, then it is also valid in XPath.  In nearly all contexts, the kind of name that is allowed in XPath is a QName. This means a lexical QName as deﬁned in the XML Namespaces Recommendation, which either takes the form «prefix:local-name», where both the preﬁx and the local-name are NCNames  no-colon names , or the simpler form «local-name» in which the preﬁx is omitted. If a preﬁx is present, then it must always be one that has been declared in the static namespace context for the XPath expression, as described later in this chapter. If no preﬁx is present, then the interpretation depends on what kind of name it is. If it is used where an element name is expected, then it is taken to refer to the default namespace for elements, which is also deﬁned in the static context of the expression. If it is used where an attribute name is expected, then the local-name is assumed to be a name that is not in any namespace.  Names  Expression  QName  Prefix  LocalPart  NCName  NCNameChar  534   As in XML, names are case-sensitive, and names are only considered to match when they consist of exactly the same sequence of characters  or more strictly, the same Unicode code-points . This is true even when the Unicode standards describe characters as equivalent; for example, different ways of writing accented letters.  Lexical Constructs  The following are examples of valid NCNames:  Examples  alpha  A   cid:2  ℵ  _system-id  iso-8859-1  billing.address  Straßen¨uberf¨uhrung  E  A  _ . . . _ --- _ . . . _  XSLT Usage  I have seen an example of an XML document that used «_» on its own as an element name, but it is not something I would recommend.  QNames are also used in XSLT stylesheets in a number of other contexts, outside the scope of XPath expressions. They are used both to refer to elements in the source document  for example, in   and    and to name and refer to objects within the stylesheet itself, including variables, templates, modes, and attribute sets.  There are also some situations where QNames can be constructed dynamically as a result of evaluating an expression. They are used, for example, in   and   to generate names in the result document, and in the key   and format-number   functions to refer to objects  keys and decimal-formats, respectively  deﬁned in the stylesheet. QNames constructed at runtime are never used to match names in the source document, and they are never used to match template names, variable names, mode names, or attribute set names in the stylesheet; these references must all be ﬁxed names.  Whether the QName is written statically in the stylesheet, or whether it is constructed dynamically, if the name has a preﬁx then the preﬁx must be declared by a namespace declaration on some surrounding element in the stylesheet module. For example:     Here the namespace is declared on the actual element that uses the preﬁx, but it could equally be any ancestor element.  7  X P a t h  F u n d a m e n t a s  l  535   XPath Fundamentals  The actual element in the source document does not need to have the tag «math:formula», it can use any preﬁx it likes  or even the default namespace  provided that in the source document the element name is in the namespace URI «http:  math.org ».  If the QName does not have a preﬁx, then the rules are more complicated, and there are three possibilities:              In the case of a name used as the name of a literal result element in the stylesheet, or in a small number of other places, the namespace that’s used is the one declared using a default namespace declaration in the stylesheet, in the form «xmlns = "some.uri"». If there is no such declaration, the name is assumed to be in no namespace. In the case of a name used as an element name or type name in an XPath expression, or in certain other contexts such as:   an XSLT pattern the elements attribute of   or   the as attribute of elements such as   and   the type attribute of instructions such as             the name is assumed to be in the namespace declared using the xpath-default-namespace attribute on the   element. This can also be overridden on any other element in the stylesheet. If there’s no such declaration, the name is assumed to be in no namespace. A name is being ‘‘used as an element name’’ if it appears in an axis step  see Chapter 9  whose axis is anything other than the attribute or namespace axis. Some names appearing in the SequenceType production used to describe types also fall into this category. Names used to refer to attribute and namespace nodes, as well as the names of variables, func- tions, and stylesheet objects such as modes, keys, and named templates, are always considered to be in no namespace when they are unpreﬁxed.  The reasoning behind these rules is that names of elements in the stylesheet use the standard XML default namespace «xmlns=" "»; names of elements in the source document use the special default xpath-default-namespace, and names of objects other than elements never use a default namespace.  A QName with no preﬁx appearing in an XPath expression never uses the default namespace deﬁned in the source document.  It’s a common mistake to forget this. Your source document starts as follows:     and your stylesheet starts:    <xsl:stylesheet xmlns:xsl="http:  www.w3.org 1999 XSL Transform"  xmlns="http:  www.w3.org 1999 xhtml" version="2.0">     Why doesn’t the template rule for «match="html"» ﬁre when the   element is encountered? The answer is that the default namespace  declared with «xmlns=". . ."»  applies to unpreﬁxed QNames in the source document, but it doesn’t apply to unpreﬁxed QNames appearing in expressions and match patterns in the stylesheet. You either need to write:  536   Lexical Constructs  7  X P a t h  F u n d a m e n t a s  l    <xsl:stylesheet xmlns:xsl="http:  www.w3.org 1999 XSL Transform"  xmlns:xhtml="http:  www.w3.org 1999 xhtml" version="2.0">     or you need to deﬁne an xpath-default-namespace:    <xsl:stylesheet xmlns:xsl="http:  www.w3.org 1999 XSL Transform"  xpath-default-namespace="http:  www.w3.org 1999 xhtml" version="2.0">     What’s worse, your source document might actually not start with:     but rather with:       Here it’s not obvious that the   element is actually in a namespace. But it is, because hidden away inside the DTD is the sneaky little deﬁnition:    <!ATTLIST html  %i18n; id xmlns  >  ID %URI;  IMPLIED FIXED ’http:  www.w3.org 1999 xhtml’  which has the effect of adding the namespace declaration «xmlns="http:  www.w3.org 1999  xhtml"» to the   element whether you asked for it or not. This means that a bare «match="html"» in your stylesheet won’t match this element; you need to match the namespace as well.  Operators  There is no hard-and-fast rule about exactly what constitutes an operator in the XPath language; but this is a good place to provide a general overview of the different kinds of operator.  We can classify as ﬁrst-order operators all the operators that take one or more expressions as their operands, and produce a result that is obtained by evaluating the operands, and combining the val- ues of the operands in some way. The ﬁrst-order operators are listed in the table below, in precedence order. Operators listed on the same row of the table have the same precedence.  Operator  ,  or  Effect Sequence concatenation  Boolean disjunction  A or B   continued  537   XPath Fundamentals  Operator  and  eq ne lt le gt ge  = !=   >=   >  to + − * div idiv mod   union  Effect Boolean conjunction  A and B   Ordering comparison between single values  Ordering comparison between sequences  Ordering identity comparison between nodes  Constructs a sequence of consecutive integers  Addition, subtraction  Multiplication, division, modulus  Union of two sequences considered as sets of nodes  intersect except  Intersection and difference of sequences considered as sets of nodes  Some of these operators are written as symbols, some as words. Where words are used, they are not reserved words: they are recognized as operators by virtue of where they appear in an expression. This means that it is quite legitimate to write an expression such as «div div div» in which the ﬁrst and ﬁnal words represent names of elements in the source document, and the middle word is a «div» operator.  The symbols «*» and « » double as operators and as expressions in their own right. In an operator context, «*» means multiplication, but in an expression context, it selects all the child elements of the context node. If the context node is the element   2  , then the expression «***» eval- uates to «4». In fact, «*» also has a third role, as an occurrence indicator after a type name, as in «xs:integer*».  As operators are tokens, they may always be preceded and followed by whitespace, and must not include any embedded whitespace. In some cases it is necessary to precede or follow an operator by whitespace to ensure it is recognized. This applies not only to the named operators  such as «and» and «or»  but also to the minus sign «–», which could be mistaken for a hyphen if written with no preceding space.  The numeric comparison operators are written here as XPath sees them; when they appear in an XSLT stylesheet, the special characters « » should be written «&lt;» and «&gt;», respectively.  The second group of operators can be classiﬁed as type operators. These take two operands, one of which is a value, the other a type. The operators in this category are:              instance of  cast as  castable as  treat as  538  Again, none of these words are reserved in any way. All these operators, together with the syntax for describing a type, are fully described in Chapter 11.  The ﬁnal group of operators are best described as higher-order operators. These are characterized by the fact that they don’t simply evaluate their operands and combine the resulting values: each has its own   Primary Expressions  rules for how the different subexpressions contribute to the ﬁnal result. These operators have custom syntax that doesn’t always look like a conventional operator at all. They are shown in the following table.  Expression  for $x in E1 return E2  Meaning Evaluates E2 once for every value in E1, concatenating the resulting sequences.  some $x in E1 satisfies E2  Returns true if E2 is true for any item in E1.  every $x in E1 satisfies E2  Returns true if E2 is true for every item in E1.  if  E1  then E2 else E3  Evaluates E2 or E3 depending on the value of E1.  E1   E2  E1 [ E2 ]  Evaluates E2 once for every value in E1, returning a sequence of nodes in document order.  Returns those items in the sequence E1 for which E2 evaluates to true.  This concludes our survey of the lexical constructs in an XPath expression. We will now look at the basic syntactic building blocks, which are referred to as primary expressions.  7  X P a t h  F u n d a m e n t a s  l  Primar y Expressions  Primary expressions are the most basic kinds of expression in XPath, and ultimately, all XPath expres- sions are constructed by combining primary expressions using various operators. The following sections in this chapter describe each kind of primary expression. These are described by the syntax:  Expression  PrimaryExpr  Literal  NumericLiteral  Syntax  Literal  VariableReference  ParenthesizedExpr  ContextItemExpr  FunctionCall  NumericLiteral  StringLiteral  IntegerLiteral  DecimalLiteral  DoubleLiteral  We have already covered numeric and string literals earlier in the chapter. The rest of the chapter there- fore concentrates on the four other kinds of primary expressions: variable references, parenthesized expressions, the context item expression, and function calls.  The only real thing that these different kinds of PrimaryExpr have in common is the context in which they can be used.  According to the syntax rules, any PrimaryExpr can be followed by a predicate to form a FilterExpr, so for example «17[1]» and «‘Berlin’[3]» are both legal. And in fact, in XPath 2.0 these expres- sions are not only syntactically legal, they also make sense semantically: a single item such as «17» or  539   «‘Berlin’» is a sequence of length one, and applying a predicate to it can return either that item or an empty sequence. Filter expressions are described in Chapter 8.  XPath Fundamentals  Examples Expression  ‘Columbus’  23.5  $var  Description A NumericLiteral is a PrimaryExpr  A StringLiteral is a PrimaryExpr  A VariableReference is a PrimaryExpr  contains @name, ‘’   A FunctionCall is a PrimaryExpr   position   + 1   A parenthesized expression is a PrimaryExpr  The notable omission from the list of primary expressions is AxisStep: an axis step such as «child::node  » is not a PrimaryExpr, even though it contains no other expressions. This ensures that an expression such as «para[1]» is unambiguously a PathExpr, with the predicate «[1]» taken as part of the Step, rather than it being a FilterExpr consisting of a PrimaryExpr «para» followed by a Predicate «[1]». It is possible to turn an AxisStep into a PrimaryExpr by putting it in parentheses, so « para [1]» is a FilterExpr. In this case the meaning is the same, but this will not always be the case.  Variable References  A VariableReference is a reference to a variable. The variable may be declared in an enclosing «for», «some», or «every» expression, as described in Chapter 10, or it may be deﬁned outside the XPath expres- sion. In the case of XSLT, this means that it may be declared in an   or   element in the stylesheet.  Expression  VariableReference  Syntax  «$» QName  The use of a «$» sign is necessary to distinguish a variable reference from a reference to an element in the source document: «para» selects a child   element in the source, while «$para» is a reference to a variable.  Whitespace is allowed between the $ sign and the QName, though it is rarely used  it was not permitted in XPath 1.0 .  The QName must match the name of a variable that is in scope at the point where the expression con- taining the variable name appears. A variable can be declared either within a containing «for», «some», or «every» expression, or  in XSLT  in an   or   element; note that if the name contains a namespace preﬁx, it is the namespace URI that must match, not necessarily the preﬁx. The XPath expression must be within the scope of this   or   element — the scope rules are given in Chapter 6 on page 502.  Usage  540   Variable References  The value of the variable reference is whatever value has been assigned to it by the matching «for», «some», or «every» expression, or  with XSLT  the matching   or   dec- laration. The value may be of any type: any sequence containing nodes, atomic values, or a mixture of both.  A variable reference can be used anywhere in an XPath expression where a value is required. It cannot be used to represent concepts of the language other than values; for example, you can’t use a variable in place of a name, a node type, or an axis. Nor can you use a variable to hold an entire expression.  A common misunderstanding about variables is to write a path expression such as:  thinking that if the value of $property is the string ”title”, then this is equivalent to writing:   booklist book $property   booklist book title  You can do this sort of thing in a shell scripting language, where variables work by textual substitution: in that kind of language the content of a variable can hold any part of an expression. But in XPath, variables hold values, not pieces of an expression. The actual meaning of the above expression is:  7  X P a t h  F u n d a m e n t a s  l   booklist book "title"  which will return the string ”title” once for each book element.  The way to achieve the desired effect is to write:   booklist book *[local-name   eq $property]  Some processors  including Saxon  offer an evaluate   extension function, which allows you to construct an XPath expression at runtime, from a string which might be held in a variable. But this capability is not present in the standard.  It’s relatively unusual to see variables whose name includes a namespace preﬁx. It can be useful, though, if you want to write a general-purpose reusable library module in XSLT or XQuery; you can then deﬁne global variables to hold constants visible to users of the library, and putting these in a speciﬁc namespace will help to ensure that there are no naming conﬂicts. In fact, XQuery requires that global variables exported from a module are declared in the namespace associated with that module.  Examples  $lowest-common-denominator  $my-ns-prefix:param1  $x  $ALPHA  $  cid:2   $  : you can have a comment here :  x  541   XPath Fundamentals  Parenthesized Expressions  A ParenthesizedExpr either consists of an expression enclosed in parentheses, or it consists of an empty pair of parentheses, used to represent the empty sequence.  Expression  ParenthesizedExpr  Syntax  « » Expr? « »  When the contained Expr is present, parentheses have the same effect in XPath as in most other lan- guages; they change the order of evaluation, so that the enclosed expression is evaluated ﬁrst, regardless of the normal operator precedence.  Parentheses are sometimes needed around an expression that uses the «,» operator  which denotes list concatenation , to avoid the «,» being interpreted as a separator between the arguments in a function call or the clauses of a «for» expression. For example, to ﬁnd the maximum of two numbers $i and $j, you need to write «max  $i, $j  », to make it clear that the function is being called with one argument  a sequence  and not with two. The «,» operator is described in detail in Chapter 10. Because «,» has the lowest precedence of any operator, it is generally necessary to use parentheses with it. However, if it is used at the top level of an XPath expression, the parentheses are not needed. For example, one can write in XSLT:     to process the four selected elements in the order indicated.  If there is no contained expression, that is, if the ParenthesizedExpr is written as «  », then its value is the empty sequence. For example, the expression «$a union   » returns the union of the sequence $a and the empty sequence; this has the effect of returning all the nodes in $a, in document order and with duplicates removed. The «union» operator  which can also be written «»  is described in Chapter 9.  One special case where the meaning of parentheses may not be immediately apparent is in conjunction with predicates. Predicates are used to ﬁlter the items in a sequence; for example, «$seq[.>= 0]» selects all the items in the sequence $seq whose value is greater than zero. As explained in Chapter 9, the mean- ing of a predicate is subtly different when it appears as part of an axis step. The result of this distinction is that:        «ancestor::node  [1]» selects the innermost ancestor of the context node  that is, its parent  « ancestor::node   [1]» selects the outermost ancestor of the context node  that is, the root of the tree .  For a more complete explanation of this distinction, see the sections on Axis Steps in Chapter 9 and Filter Expressions in Chapter 10.  Another rather specialized use for parentheses is to remove syntactic ambiguities when using the « » symbol as an expression referring to the document node at the root of the current tree. When « » is followed by a name, or by the symbol «*», then it is assumed to be the start of a rooted path expression.  542   Context Item Expressions  This means that if you want to follow « » with a named operator, you need to enclose it in parentheses, for example:  if      instance of document schema-element mf:invoice    then ...  or  if      intersect $nodes  then ...  Another way of disambiguating « » in such expressions is to write it as « .».  Changes in XPath 2.0  The syntax «  » to represent an empty sequence, and the use of the «,» operator to perform sequence concatenation, are new in XPath 2.0.  Because a Step in a path expression is now a general expression  see Chapter 9 , it becomes possible in XPath 2.0 to use parentheses in a path expression such as «book  chapterappendix  title».  7  X P a t h  F u n d a m e n t a s  l  Context Item Expressions  The ContextItemExpr is simply the expression «.»:  Expression  Syntax  ContextItemExpr  «.»  The context item may either be a node or an atomic value, or its value may be undeﬁned. If the value is undeﬁned, then evaluating the expression «.» causes an error.  At the outermost level of an XPath expression, the value of the context item is established by the calling environment. For example, in XSLT it is determined by the innermost   or <xsl:apply- templates> iteration. Where XPath expressions are evaluated from a host language such as Java or C, the calling API often provides the application with a way to set the initial context item.  Internally within an XPath expression, there are two constructs that change the context item. Within a predicate P of an expression such as «$SEQ[P]», the predicate is evaluated for each item in $SEQ in turn, with that item as the context item, and on the right-hand side of the « » operator, in a path expression such as «E1 E2», the context item for evaluating E2 is set to each item in E1 in turn.  The value of the context item is not changed in the body of a «for» expression  described in Chapter 10 . It is therefore wrong to write something like:  sum for $x in   item return . @price * . @qty   Instead, you need to write:  sum for $x in   item return $x @price * $x @qty   543   XPath Fundamentals  Changes in XPath 2.0  In XPath 1.0, the «.» symbol was an abbreviation for the Step «self::node  ». This restricted its value to being a reference to a node  never an atomic value , and it also imposed certain other restrictions; for example, it was not possible to apply a predicate to «.». In XPath 2.0 you can use constructs such as «.[*]» which returns the context item only if it is a node that has a child element.  In XPath 1.0, «.» was never undeﬁned — it always had a value, and the value was always a single node. In XPath 2.0, there are many situations in which it can be undeﬁned; for example, it is undeﬁned on entry to a function body written in XSLT or XQuery.  Usage  The two places where «.» is commonly used are:    With the operator «  » in a relative path expression such as «.  A», which  loosely speaking      selects all the descendant   elements of the context node. The «.» is necessary here because if the expression started with «  », it would select all descendants of the root node. On its own, to perform operations on the value of the context item. This usually arises in expres- sions such as «.=3» or «string-length . » where we want to test the value of the context node, or in the XSLT instruction  , which outputs the atomized value of the context item to the result tree.  Some people also like to use «.» for clarity at the start of a relative path expression such as «. TITLE», but in fact this is precisely equivalent to «TITLE» on its own.  In XPath 2.0, if you want to remove duplicates from a sequence of nodes $seq, and sort them into docu- ment order, you can write «$seq .», or equivalently, «. $seq». The sorting and deduplication is part of the deﬁned behavior of the « » operator.  Function Calls  A FunctionCall invokes a function. This may be one of the system-deﬁned functions described in Chapter 13, or it may be a vendor- or user-supplied function.  Each built-in or user-deﬁned atomic type also has a corresponding constructor function available for constructing values of that type  for example, «xs:date ‘2008-02-29’ » constructs a date .  There may also be additional functions described in a host language in which XPath is embedded — for example, the XForms standard deﬁnes a number of additional XPath functions. Some of these duplicate functionality that is now in the standard XPath 2.0 library, but others deﬁne functionality speciﬁc to the XForms environment; for example, the instance   function, which provides access to an XML document that holds the data collected using an interactive form.  Expression  FunctionCall  Syntax  QName « »   ExprSingle  «,» ExprSingle *  ? « »  continued  544   Function Calls  Expression  ExprSingle  Syntax  ForExpr  QuantifiedExpr  IfExpr  OrExpr  The syntax of a function call consists of the function name, which is in general a QName, followed by the list of zero or more supplied arguments, in the usual way.  Each argument must be an ExprSingle. This basically means any XPath expression, as long as it does not contain a top-level «,» operator. If you want to supply a list of values separated by commas as a single argument, you must enclose it in parentheses. Note the difference between:  concat "A", " nice", " cup", " of", " tea"   which calls the concat   function with ﬁve separate arguments, each one a single string, and:  string-join  "A", "nice", "cup", "of", "tea" , " "   which calls the string-join   function with two arguments, the ﬁrst one being a sequence of ﬁve strings, and the second a string containing a single space character. These two function calls are both legal, and as it happens they both have the same effect. Both the functions are described in Chapter 13. The concat   function is exceptional in that it allows an arbitrary number of arguments to be supplied.  The arguments themselves can be expressions such as « », «.», or «@*», which may look a bit strange at ﬁrst encounter. For example, the function call «exists  * » returns true if the context node is in a tree whose root is a document node that has an element node as a child.  7  X P a t h  F u n d a m e n t a s  l  Identifying the Function to Be Called  The set of functions that is available for calling is deﬁned in the static context for the XPath expression, as described later in this chapter. This means that it is known at compile time whether a particular func- tion name is valid or not. You can therefore expect a compile time error if you call a function that does not exist.  The function name is a QName. Like other QNames, it is written as a lexical QName  with an optional preﬁx and a local name, separated by a colon , and this lexical QName is expanded using the namespace declarations that are in scope for the XPath expression. So the expanded name of the function consists of a namespace URI and a local-name. The XPath static context includes a default namespace URI for function names, which will usually be quite separate from the default namespace URI for other kinds of name. Throughout this book I have assumed that the default namespace URI for functions will be http:  www.w3.org 2005 xpath-functions, which contains the standard library of functions listed in Chapter 13. When this is the case, functions such as count   and exists   may be called with unpreﬁxed names. XSLT requires that this is always the default namespace for function names, though other XPath environments may deﬁne a different default. You will often see function calls like count   written with a preﬁx as fn:count  , but this is never necessary in XSLT.  545   XPath Fundamentals  The function name is recognized in the XPath syntax by virtue of the fact that it is followed by a left parenthesis. This means that certain unpreﬁxed names used as keywords in the language are not avail- able for use as function names, speciﬁcally attribute  , comment  , document-node  , element  , empty-sequence  , if  , item  , node  , processing-instruction  , schema-attribute  , schema- element  , text  , type  , and typeswitch  . The name typeswitch   is not actually used as a key- word in XPath but is reserved for compatibility with XQuery.  The set of functions that are available for calling will generally include the following:                       The core library of XPath functions described in Chapter 13. Additional functions deﬁned by the host language in which XPath is embedded, for example, the XSLT functions which are also described in Chapter 13. Constructor functions corresponding to the built-in atomic types in XML Schema, for example, xs:date   and xs:float  . For details of these functions, see Chapter 11. Constructor functions corresponding to user-deﬁned atomic types in any imported schema. These are also described in Chapter 11. Additional functions made available by the vendor of the XPath processor. These should be in a namespace controlled by that vendor. An example is the function saxon:evaluate   offered by the Saxon product. For details, see the documentation supplied by the vendor. User-written functions, written in XSLT or XQuery. User-written functions  known as extension functions in XSLT, external functions in XQuery  written in an unrelated programming language, such as Java, C, or JavaScript. The mechanisms for linking to such functions, and for converting values between the XPath data types and those of the target language, have been left to implementors to deﬁne.  It is not possible to write functions in XPath itself. For this, you need XSLT 2.0, XQuery 1.0, or potentially some other language that supports the capability. XPath only provides the ability to call such functions, not to deﬁne them.  A number of useful third-party function libraries have become available for XSLT 1.0 processors  see for example http:  www.exslt.org and http:  fxsl.sf.net  , and the same is starting to happen for XSLT 2.0 and XQuery 1.0. An example is Priscilla Walmsley’s library at http:  www.functx.com, which is available in both XSLT and XQuery versions.  Functions, at least in theory, are uniquely identiﬁed by their expanded QName  that is, namespace URI and local name  and their arity — that is, the number of arguments. The idea is that the static context contains a list of functions that are available to be called, and it cannot contain two functions with the same name and the same arity. There is no overloading of functions, so you can’t have two functions with the same name and the same number of arguments, distinguished only by the types of the arguments.  Products that allow you to call Java methods are quite likely to provide some kind of overloading in prac- tice, if one can extrapolate from what XSLT 1.0 processors do. The speciﬁcation leaves enough latitude to allow this: all aspects of external calls are essentially implementation-deﬁned. Conceptually, a product can satisfy the letter of the law by claiming that for each possible Java method name and number of argu- ments, there is a single function in the static context, and it is this notional function that decides which of several Java methods to call, based on the types of the arguments supplied.  546   Function Calls  Converting the Arguments and the Result  At compile time, every function in the static context has a known signature deﬁning the types of the arguments and the type of the result. For example, consider a function that calculates the total sales of a product  the actual logic isn’t important .  Here is the XSLT 2.0 implementation:             And here is the equivalent in XQuery 1.0:  declare function mf:product-sales  $product as schema-element mf:product    as xs:decimal {  sum $product  sale[@product-code eq $product code]   };  In both cases, we have deﬁned the function name as mf:product-sales  we’ll assume that the name- spaces have been declared properly , and we have deﬁned it to take a single argument, which is an element conforming to the schema-deﬁned element declaration mf:product. This means the element will be either a valid mf:product or a member of its substitution group; the detailed meaning of the syntax «schema-element mf:product » is given in Chapter 11. The return type of the function is declared to be an xs:decimal.  There’s no formal link between the namespaces used for functions and the namespaces used for elements, attributes, and schema-deﬁned types. But with functions which, like this one, are very speciﬁc to a par- ticular element type, I think it’s a useful convention to put the function in the same namespace as the element type.  7  X P a t h  F u n d a m e n t a s  l  An XPath expression that invokes this function might look like this:    mf:product[mf:product-sales .  gt 100000]  This expression returns a sequence containing all the   elements that have total sales in excess of 100,000.  In this example, the required type of the argument was a single node, and the result type of the function was a single atomic value. It is also possible, of course, for functions to take sequences as their arguments, or to return sequences as their result. In general, the required type of an argument has two parts: the required cardinality and the required item type. The required cardinality is shown by an occurrence indicator after the type and may be one of:  Occurrence Indicator   none   *  +  ?  Meaning Exactly one item  Any number of items  One or more items  Either one item, or none  547   XPath Fundamentals  The required item type deﬁnes a type that each item in the supplied value must conform to. This may be a very generic type, such as «node  », or a very speciﬁc type, such as «element mf:product » or «xs:unsignedByte». If no required type is speciﬁed for an argument, the implicit default is «item  *». This allows any sequence of items, in other words any value at all.  The XPath processor is required to check that the arguments supplied in the function call are of the right type, and it can also apply a very limited number of conversions to make them the right type. These rules are referred to as the function conversion rules. The rules are as follows:  1.  2.  3.  4.  5.  First, at compile time, the name of the function and the number of arguments are used to locate the signature of the function to be called. An error occurs if no suitable function can be located. Once the signature has been located, the processor may do some compile-time checking of argu- ments, but the only guarantee is that each argument in the function call will be checked against the declared type of the corresponding parameter in the signature at runtime, using the rules below. Each supplied argument is evaluated, to produce a value. This in general is a sequence that may contain atomic values, nodes, or a mixture of the two.  Note, however, that the processor isn’t obliged to evaluate an argument that isn’t used — this means that errors may go undetected.  If the required item type is xs:anyAtomicType or a subtype of this  that is, if the function expects atomic values for this argument, rather than nodes , then the following steps are carried out:    The supplied sequence is atomized. Atomization replaces each node in the supplied sequence by its typed value  which may itself be a sequence  and leaves any atomic values in the sequence unchanged. If any of the values in the atomized sequence are of type xs:untypedAtomic  which will normally be the case when the values are extracted from elements and attributes that have not been validated against any schema , then the system attempts to convert them to the required type by casting. The rules showing what casts are possible are given in Chapter 11, but they essentially follow the rules deﬁned in XML Schema — if the required type is xs:date, for example, then the xs:untypedAtomic value must have the form of a valid lexical xs:date value. If the cast isn’t possible, the error is fatal. If the required type is a numeric type  xs:double, xs:float, xs:decimal, or a type derived from any of these by restricting the allowed set of values , and if the supplied value is also numeric, then type promotion is attempted. For example, it is acceptable to supply an xs:integer value where an xs:double is expected. Numeric type promotion is described in detail in Chapter 8, because it plays an important role for arithmetic operators. If the required type is xs:string and the supplied value is an instance of xs:anyURI, the URI is converted to a string. In effect, XPath treats xs:anyURI as a subtype of xs:string even though XML Schema does not deﬁne it that way.           At this stage, a ﬁnal check is made that the argument value is now a valid instance of the required type. For this to be true, each item in the sequence must be an instance of the required item type, and the number of items in the sequence must match the required cardinality. The detailed rules are the same as those for the «instance of» operator, which is described in Chapter 11. If the value doesn’t conform as required, a type error is reported. If all is well, the function is called, and the result of the function call expression  as you would expect  is the value returned by the function, which will always conform to the type given in the function signature.  548   Function Calls  Changes in XPath 2.0  The rules given in the previous section impose much stricter type checking than XPath 1.0, which always attempted to convert the supplied arguments to the required type. XPath 2.0 effectively retains this behavior in two cases: ﬁrstly, when the value you supply is a node in a document that has not been schema-validated, and secondly, when you run in backward-compatibility mode, which in XSLT is activated by setting «version="1.0"» in the   element..  So there are cases where function calls would have succeeded in XPath 1.0, but will fail under 2.0. An example is an expression such as «string-length position   =2». The argument to the string-length   function must be of type xs:string, but the result returned by the position   func- tion is of type xs:integer. XPath 1.0 would cheerfully convert the integer to a string, but XPath 2.0 is stricter — if you intend a conversion to take place, you must invoke it explicitly, for example by calling the string   function.  Backward-compatibility mode changes the function calling rules by adding an extra rule before rule 3 in the list above. This rule is in two parts:        If the required cardinality of the parameter is zero or one  that is, if the parameter doesn’t per- mit a sequence of more than one item , then all items in the supplied value after the ﬁrst are discarded. If the required item type is a string or number type, then the supplied value is converted to a string or number using the string   or number   function as appropriate.  7  X P a t h  F u n d a m e n t a s  l  These rules apply only where the required type of the parameter ﬁts into the XPath 1.0 type system. For example, if the required type is xs:date, no extra conversions are performed. More speciﬁcally, the ﬁrst rule  which discards all but the ﬁrst item in a sequence  applies only where the required item type is «item  », «node  », xs:string, or a numeric type such as xs:double. The second rule applies only if the required item type is xs:string or a numeric type.  Although the XPath 1.0 type system also included a boolean data type, there is no special treatment of xs:boolean in the backward-compatibility rules. That’s because the only XPath 1.0 function that actually expected a boolean argument was the not   function, and this function in XPath 2.0 has been deﬁned in a way that is fully backward compatible.  XPath 1.0 never deﬁned any rules for calling external user-deﬁned functions, so backward compatibility in that area is entirely a matter for implementors.  Side Effects  None of the standard functions have side effects; they don’t change the values of variables, they don’t produce any output, and they don’t change any settings in the browser or the operating system. They don’t even create any new nodes, though both XSLT and XQuery allow you to write functions that can be called from XPath to create new nodes.  There is nothing to stop an extension function from having side effects; for example, an extension function could print a message or increment a counter, or even do something more radical such as modify the source document or the stylesheet itself. However, extension functions with side effects are likely to be rather unpredictable, since there is nothing to say in which order things happen. For example, you can’t assume that global variables in XSLT are evaluated in any particular order or that they are evaluated only once, and a global variable that is never accessed might never be evaluated at all.  549   XPath Fundamentals  Functions can have side effects even if you think of them as read-only. You might imagine that if you write an extension function ext:read   that reads a line of input from the console, then the expression « ext:read  , ext:read   » will read two lines, and return them in order. You could be in for a sur- prise. The system might read two lines, and return them out of order; or it might read a single line, and return two copies of it. This happens because calling the ext:read   function has the side effect of chang- ing the current reading position in a ﬁle connection. Implementations might try to be more helpful than this, but you can’t rely on it.  The closest that the standard library comes to a function with side effects is the trace   function, which is supposed to produce diagnostic output. Like other functions in the standard library, this is described in Chapter 13. However, the speciﬁcation gives so much latitude in terms of the way this is implemented that it would be quite legitimate for an implementation to do nothing when it encounters this function call. You might well ﬁnd that with an optimizing processor, the output produced by multiple calls on the trace   function bears very little relationship to the expected order of execution.  The formal semantics of the language does try to deal with functions that create new nodes in a sanitary way. XPath itself, when conﬁned to the standard function library, is a read-only language, but both XSLT and XQuery do allow functions that create and return new nodes. For example, in XSLT:           or in XQuery:     };  declare function f:make   as element   {  These functions create all sorts of complexities in the language semantics: for example, it is no longer possible to take a function call out of a loop and execute it once only. It also means that the expres- sion «f:make   is f:make  » is false. Frankly, in XSLT stylesheets I would advise against writing such functions — I think it’s good coding practice in XSLT to use XSLT instructions and templates when creat- ing nodes in the result tree, and to use XPath expressions and functions when reading information from the source tree. XQuery doesn’t have this distinction between instructions and expressions, so the same function mechanism has to serve both purposes. But you need to use it with care.  Examples  These examples are in the ﬁle function-calls.xsl, but you will probably need to edit the ﬁle before running it, as it uses an extension function that is available only in James Clark’s xt processor.  Expression  true    Description A call on a standard function that always returns the xs:boolean value true.  string-length $x  A call on a standard function that expects a string, and returns the number of  characters it contains. The actual value supplied can be a node, provided its type is either xs:string or xs:untypedAtomic. If $x is a non-string value, such as an xs:anyURI, a type error occurs, unless you are running in backward-compatibility mode.  continued  550   Conditional Expressions  Expression  count *   xt:intersection  $x,$y   Description A call on a standard function that evaluates the path expression «*»  which returns all element children of the context node  and returns a number indicating how many nodes there are in this sequence.  A call on an extension function. It is identiﬁed as an extension function by the presence of a preﬁx «xt:», which must correspond to a namespace declaration that is in scope. The rules for locating an implementation of this extension function are implementor-deﬁned.  Conditional Expressions  A conditional expression corresponds to the «if..then..else» construct found in almost every pro- gramming language. A condition is evaluated, and based on the result, the expression returns the result of evaluating either the «then» or the «else» branch.  Expression  IfExpr  Syntax  «if» « » Expr « » «then» ExprSingle «else» ExprSingle  7  X P a t h  F u n d a m e n t a s  l  The «else» branch is constrained to be an ExprSingle  an expression containing no top-level comma  because a trailing comma would be ambiguous when the expression appears, for example, as an argu- ment in a function call. The «then» branch is constrained to be an ExprSingle purely for symmetry. Any expression can be used as the condition, and although it would be unusual for this expression to use the «,» operator, there is no reason to disallow it.  Note that both branches  the «then» and the «else»  must be present. It’s quite common to write «else   » to return nothing  an empty sequence  when the condition is false, but you have to write this explicitly.  The expression used as the condition to be tested  inside the parentheses  is evaluated to give its effective boolean value. Unusually, XPath 2.0 doesn’t apply strict type checking to this expression, rather it deﬁnes a set of rules allowing a wide range of values to be converted to the xs:boolean values true or false. The rules are the same as for the boolean   function described on page 721, in summary:                    If the condition is an empty sequence, its effective boolean value is false. If the condition is a sequence whose ﬁrst item is a node, its effective boolean value is true. If the condition is a singleton xs:boolean value, the result is this value. If the condition is a singleton numeric value, the result is false if the argument is NaN or zero; otherwise, it is true. If the condition is a singleton instance of xs:string, xs:anyURI, or xs:untypedAtomic, the result is false if the string is zero length; otherwise, it is true. In all other cases, an error is reported.  There is no atomization applied to any nodes in the sequence. This means that if the value includes one or more nodes, the result is true, regardless of the contents of the node. Even if «@married» is an attribute whose typed value is the xs:boolean value false, the result of the expression «if  @married  then "yes"  551   XPath Fundamentals  else "no"» is the string «yes». If you want to test the contents of the node, rather than testing for its existence, use the data   function to atomize it explicitly, or write the test in the form «if  @married = true    then ..».  Note that the effective boolean value of a sequence doesn’t simply test whether the sequence is empty, because of the special cases for a singleton sequence. If you want to test whether a sequence is empty, use the empty   or exists   functions described in Chapter 13.  These rules for forming the effective boolean value are consistent with the rules used in other XPath contexts where a true false value is required. These include:              The operands of «and» and «or»  see Chapter 8  The argument of the functions boolean   and not    see Chapter 13  The expression used as a predicate within square brackets in an axis step or ﬁlter expression, so long as the value is not numeric  see Chapters 9 and 10  The expression in the «satisfies» clause of «some» and «every» expressions  see Chapter 10   The same rules are also used in XSLT 2.0, in evaluating the   and   instructions.  A signiﬁcant feature of these rules is that the processor can determine the effective boolean value of any sequence without looking further than the second item in the sequence. This makes the algorithm very efﬁcient.  However, the rules are not the same as the rules in XML Schema for converting a string to an xs:boolean value. In XML Schema, the valid lexical representations of the xs:boolean value false are «0» and «false», while the valid lexical representations of true are «1» and «true». The XML Schema rules are used in XPath 2.0 in the following circumstances:        By the expression «$S cast as xs:boolean» By the xs:boolean   constructor function  note the difference from the boolean   function in the core library, sometimes written as fn:boolean   to emphasize the difference     When an xs:untypedAtomic value is implicitly converted to an xs:boolean value in the course  of a function call, where one of the function arguments has a required type of xs:boolean  Conditional expressions are one of the few places in the XPath language where you get a guarantee that an expression will or will not be evaluated. Speciﬁcally, if the condition is true then the «else» branch will not be evaluated, while if it is false, the «then» branch will not be evaluated. This means you can safely use expressions that could otherwise cause errors, for example:  if  $cols ne 0  then  count $items  idiv $cols  else     I personally prefer putting in the explicit test «$cols ne 0» rather than writing «if  $cols ..» and relying on the fact that zero is treated as false.  Changes in XPath 2.0  Conditional expressions are new in XPath 2.0. In the context of an XSLT stylesheet, they often make it possible to replace a cumbersome   instruction. For example, the following:  552   7  X P a t h  F u n d a m e n t a s  l  The XPath Evaluation Context         white   red        can now be replaced with:  <xsl:variable name="color"  select="if  $day eq ’Sunday’  then ’white’ else ’red’" >  The rules for calculating the effective boolean value of an expression have been carefully chosen to be compatible with the rules for converting strings, numbers, or node-sets to booleans in XPath 1.0, while at the same time generalizing them to handle an arbitrary sequence. If they seem arbitrary, blame history.  Examples Expression  if  @x  then @x else 0  if  $area sales  then avg $area sales @value  else number ‘NaN’   if  normalize-space .   then string .  else     Description Returns the attribute node @x if it exists, or the xs:integer value zero otherwise.  This can also be expressed as « @x,0 [1]».   Returns the average sales value for the selected area if there were any sales, or the not-a-number value NaN otherwise.  Returns the context item converted to a string if it contains any non-whitespace characters; otherwise, returns the empty sequence. This relies on the fact that normalize-space   returns a zero-length string  which is treated as false  if all the characters in the string are whitespace.  The XPath Evaluation Context  XPath was designed as an expression language that could be embedded in other languages. The ﬁrst such language was XSLT, but it was always envisaged that this would only be one of many host lan- guages. Subsequent experience has shown that this did indeed happen: XPath  sometimes in the form of a restricted subset  has been used not only within XSLT and XPointer but also within a variety of pro- gramming languages such as Java and Perl, and also as a sublanguage for expressing constraints within XForms and XML Schema.  To make XPath suitable for this role as a sublanguage, there needs to be a clear interface between XPath and the host language. This interface speciﬁes what information is provided by the host environment to the XPath environment, and the sum total of this information is referred to as the evaluation context.  The evaluation context can be split into two halves: information that is available at compile time  while the XPath expression is being parsed and checked for static errors  and information that is available only at runtime. These two parts are called the static context and the dynamic context, and they are described in the next two sections of this chapter.  553   XPath Fundamentals  An XPath host language such as XSLT should always specify how the static and dynamic context for XPath expressions are set up. Some aspects of the context may be under user control, some may have ﬁxed values, and other parts may be completely implementation deﬁned. This will vary from one host language to another. As far as XPath is concerned, it doesn’t matter whether the information is ﬁxed in the host language speciﬁcation or whether it is provided by the vendor or by the user: the information is there somehow, and it is available for use.  As I describe each part of the evaluation context in the following sections, I will explain both how things work when you use XPath from XSLT, and the more general rules that apply in other environments.  The Static Context  The static context contains information that’s needed while performing the analysis or compilation phase on an XPath expression.  In many environments, XPath is a ”load and go” technology: you submit an expression as a string, and it is compiled and executed straight away. In this case, the distinction between the static context and the dynamic context isn’t all that important. In other environments, however, there is a distinction. XSLT stylesheets are often compiled once and then executed many times, and the XPath expressions within the stylesheet will typically be compiled when the stylesheet is compiled  usually not into machine code, but into some intermediate form that a runtime interpreter can later process . So it’s worth making the distinction between the two phases even if they are often combined.  The various parts of the static context are described in the sections that follow.  XPath 1.0 Compatibility Mode  We’ve generally referred to this as backward-compatibility mode, which is what XSLT calls it. This value is a boolean: compatibility mode is either on or off. Compatibility mode will be switched on when users want the effect of an XPath expression to be as close as possible to the effect that the same expression would have had under XPath 1.0.  In XSLT, compatibility mode for XPath expressions in a stylesheet is switched on by setting the «version» attribute to «1.0», either on the   element or on an inner element in the stylesheet if it is required only for certain expressions and not for others. If the stylesheet speciﬁes «version="2.0"», then 1.0 compatibility mode will be off.  XPath processors  and XSLT processors  are not obliged to offer XPath 1.0 compatibility mode. It’s seen as a transition aid rather than as a permanent feature of the language.  Setting XPath 1.0 compatibility mode does not mean that everything in the language is 100% backward compatible, though it gets close. Appendix C contains a list of the incompatibilities that remain; most of them are corner cases that few users are likely to encounter, but one or two are more signiﬁcant.  So what exactly changes if you set 1.0 compatibility mode? The following rules are applied only when in this mode:    We have already seen, earlier in this chapter  page 549 , how the function calling rules are affected.  In summary, a supplied sequence may be truncated to its ﬁrst value, and arguments of any type may be converted to strings or numbers if that is what the function expects. Similar rules apply to arithmetic operators such as «+» and «div». These are described in Chapter 8. They are treated in the same way as a function that expects two xs:double     554   The XPath Evaluation Context     arguments — the supplied operands are converted to xs:double using the number   function, and the arithmetic is performed in double-precision ﬂoating point. In an expression using one of the operators «=», «!=», if one of the operands is numeric, then the other operand is converted to an xs:double value by applying the number   function. If the operator is one of « », «>=», then both operands are converted to xs:double values. There are also special rules when one of the arguments is an xs:boolean value.  What lies behind these rules is that XPath 1.0 was a weakly typed language, in which the arguments of function calls and operators were implicitly converted to the required type. XPath 2.0 has a much richer type system, in which such implicit conversion would often give unexpected results. So with XPath 2.0, you have to do the conversions you want explicitly. But this creates a backward-compatibility problem. The rules given above are designed to minimize this problem by catering for all the cases that could actually arise with a 1.0 expression. The reason that strings and numbers are treated differently from other types is that they are the only atomic types that were supported in XPath 1.0 — except for booleans. And in the case of booleans, weak typing continues to apply in XPath 2.0: every value can be converted to a boolean when it is used in a context such as the condition of an «if» expression, by taking its effective boolean value. The rules for this are described on page 551.  The following table illustrates some expressions whose results differ when running in backward- compatibility mode.  7  X P a t h  F u n d a m e n t a s  l  XPath 1.0 Compatibility Mode On true  NaN  false  Off type error  type error  type error  true  numeric comparison   false  string comparison   Expression  contains 3.14, "."   "apple"+"pear"  "apple"< 3  @a < "42" where @a has the untyped value "7"  In-Scope Namespaces  Many XPath expressions contain preﬁxed QNames. The names of elements and attributes can be pre- ﬁxed, as can the names of variables, functions, and types. A preﬁx in such a name means nothing by itself: to know what type the name «xs:integer» refers to, you have to know what namespace URI is bound to the preﬁx «xs». It isn’t possible to deﬁne the binding of a preﬁx to a namespace URI within the XPath expression itself, so instead it has to be part of the context. It’s part of the static context so that the XPath processor can work out at compile time what all names appearing in the expression are actually referring to.  This part of the static context is modeled as a set of  preﬁx, URI  pairs. No preﬁx may appear more than once. It’s an error if the XPath expression contains a QName whose preﬁx isn’t present in this list.  In XSLT, because a stylesheet is an XML document, the in-scope namespaces for an XPath expres- sion are deﬁned by writing namespace declarations such as «xmlns:xs="http:  www.w3.org 2001  XMLSchema"» in a containing element  often, but not necessarily, the   element . The namespace preﬁxes you can use within an XPath expression are precisely those that you could use in an element name or attribute name appearing in the same place in the stylesheet.  555   XPath Fundamentals  Each stylesheet module has its own static context, so a global variable declared in one module as:     might be referenced in another module as:     For other host languages, a different way of establishing the namespace context might be used. XQuery, for example has its own syntax for declaring namespaces, as does XPointer. In XQuery some namespaces  such as the XML Schema namespace  are hardwired, and others can be declared in the query prolog using syntax such as:  declare namespace saxon = "http:  saxon.sf.net ";  In XPointer the syntax is:  xmlns xs=http:  www.w3.org 2001 XMLSchema   When XPath is used from a programming language such as Java, there will generally be some method in the API that allows a namespace to be declared. In some APIs it is possible to declare namespaces implicitly by nominating a node in a source document, indicating that all the namespaces that are in scope for that node should be considered to be in scope for the XPath expression.  Default Namespaces  When a QName that has no namespace preﬁx is used, default namespaces come into play.  In XPath 1.0, the rule was simple: no preﬁx means no namespace. That is, unpreﬁxed names always referred to objects whose namespace URI was null. In XPath 2.0 there is more ﬂexibility. The static context potentially contains two defaults, for use with different kinds of names:        The default namespace for elements and types, as the name implies, is used to qualify any name within the XPath expression that is recognized as an element name or a type name. In path expressions, it is always possible to distinguish element names by means of the axis on which they appear: if the axis is the attribute or namespace axis, then unpreﬁxed names are considered to be in no namespace, whereas on any other axis, the namespace URI for an unpreﬁxed name is taken from this default. The default is also used for element names appearing in a test such as «element invoice, * », and for the names of types, in constructs such as «attribute  *, part-number ». In XSLT 2.0, the default namespace for elements and types can be set or unset using the [xsl:]xpath-default-namespace attribute on any element in the stylesheet. This is described on page 480. The default namespace for functions is used to qualify unpreﬁxed names used in function calls, for example «f  ». In XSLT this is always the standard namespace http:  www.w3.org 2005  xpath-functions, which contains the functions listed in Chapter 13. Other host languages or APIs might deﬁne a different default.  For other kinds of name, for example attribute names and variable names, there is no default namespace. For these names, no preﬁx always means no namespace.  556   The XPath Evaluation Context  In-Scope Schema Deﬁnitions  This part of the static context represents the schema information that is available at the time an XPath expression is compiled. Technically, it consists of:           A set of named top-level type deﬁnitions  simple and complex types  A set of named top-level element declarations A set of named top-level attribute declarations  Type deﬁnitions, element declarations, and attribute declarations are referred to collectively as schema components  there is apparently a good reason why types are ”deﬁned”, whereas elements and attributes are ”declared”, but the explanation I was given was pretty tortuous .  The speciﬁcations don’t say exactly what information can be extracted from these deﬁnitions; this is left to the implementation to sort out. In theory XPath itself, because it doesn’t actually validate elements against the schema, doesn’t need to know very much about them at all. All it needs to be able to do is to look at the type annotation on a node and decide whether the node is or is not an instance of a given type in the schema, which it can do by knowing the names of the types and the type hierarchy. In practice of course, XPath implementations can use a lot more information than this for optimization purposes.  7  X P a t h  F u n d a m e n t a s  l  XPath itself isn’t concerned with where these deﬁnitions come from. It’s the job of the host language to decide which types are made available in the context. In practice there’s a minimum set of types that must be available, because the XPath functions and operators need them: this set corresponds roughly to the set of types that a basic XSLT processor will make available, but it’s XSLT that deﬁnes this set, not XPath itself.  In XSLT, the schema components provided in the static context include:           Some or all of the built-in types of XML Schema. In the case of a schema-aware processor, this includes all the built-in types, but in the case of a basic  non-schema-aware  processor it is a smaller subset  see page 548 . Schema components from schemas imported using the   declaration in the stylesheet. This declaration can only be used if the XSLT processor is schema-aware. Other implementation-deﬁned types needed to support vendor extensions; for example, the ability to call external Java methods.  For example, if you want to reference components from the OpenGIS schema for geographical coordinate systems, you might write in your stylesheet:  <xsl:import-schema namespace="http:  www.opengis.net gml" schema-location=  "http:  schemas.opengis.net gml 3.1.1 base coordinateSystems.xsd" >  You will probably want to bind a preﬁx to this namespace:     You can then use XPath expressions that reference components in this schema, for example:     557   XPath Fundamentals  A different host language, however, could make schema components available in a different way entirely. There is no obligation on the host language to put this under user control.  An XPath expression cannot make explicit reference to types  for example, in an «instance of» expres- sion, described in Chapter 11  unless those types are present in the static context. This also applies to element declarations named in a «schema-element N » test, and to attribute declarations named in a «schema-attribute N » test.  These constructs are all deﬁned in Chapter 11.  Elements and attributes that are named in the ordinary way within a path expression, however, do not need to have a declaration present in the static context.  The set of schema components that are present in the static context may be a subset of those available at runtime. This is an issue that caused the working groups a great deal of grief: what happens if the XPath expression calls the doc   function to load a document, and that document is validated using a schema  perhaps the schema named in its xsi:schemaLocation attribute  that wasn’t supplied as part of the static context for the XPath expression? The problem arises when you write an XPath expression such as «doc ‘abc.xml’  a b instance of xs:integer». To evaluate this, the XPath processor needs to look at the type annotation on the   element and determine whether this type is a subtype of xs:integer. How is it supposed to know?  In fact, it’s not just expressions like this that need the type information. A simple comparison such as «if  doc ‘abc.xml’  a b=$x  then . . .» uses the typed value of the   element, and to determine how to do the comparison, the processor needs to know the type.  The answer the working group came up with is to invoke magic  or, in the phrase that was used at the time, a ”winged horse” . The practical reality is that in many cases the XPath processor will have a fairly intimate relationship with the XML parser and or the XML schema validator. In such cases, the XPath processor probably has access to all the schema information that was used when validating the document. It would be very difﬁcult to formalize all this information as part of the evaluation context, so all that the speciﬁcation says is that if such information is available, the XPath processor can use it to evaluate expressions like this. If the information isn’t available, then the document must be rejected.  There are very many different scenarios for how documents are parsed, validated, and queried. In a typical XSLT environment, the parsing and validation usually happen just before the transformation starts. In an XML database, however, parsing and validation happen when the document is loaded into the database, which may be months or years before the query is executed. The XPath speciﬁcation tries to cope with this variety of different usage scenarios, but in doing so, it inevitably leaves some aspects of the language implementation-deﬁned.  You can avoid these problems by explicitly importing all the schemas that are used to validate documents used by your XPath expressions.  In-Scope Variables  The static context for an XPath expression includes a list of the variables that can be referenced. The information available at this time includes the name of the variable and its type, but not the actual value. It’s up to the host language how these variables are declared: in XSLT, for example, they are declared using   and   elements in the stylesheet. The scoping rules are also deﬁned by the host language; for example, XSLT speciﬁes that global variables are available to any XPath expres- sion anywhere in the stylesheet  in any module , while local variables are available only within XPath  558   The XPath Evaluation Context  expressions contained in an attribute of an element that is a following-sibling of the variable declaration, or a descendant of a following-sibling. So the stylesheet parameter:     adds a variable with name «start» and type «xs:integer?» to the static context of every XPath expres- sion in the stylesheet.  The name of a variable is a QName: that is, it contains a namespace URI and a local name. In practice, it’s quite unusual to put variables in a namespace, but it is permitted. It’s more common to see this with XQuery, which associates namespaces with modules, so that variables exported by a module will carry the namespace of that module.  It is an error for the XPath expression to refer to variables that aren’t present in the static context. In a system that does static type checking, it’s also a static error to use a variable in a way that is inconsistent with its type. In systems that do dynamic type checking  which will usually be the case for XSLT , such errors are reported only if they occur when the XPath expression is evaluated.  This aspect of the static context differs from all the other aspects in that it can vary for different parts of a single XPath expression. The static context for a nested subexpression may include variables declared in containing «for», «some», or «every» expressions, as well as the variables made available by the host language. The XPath expressions that declare new variables are all listed in Chapter 8.  7  X P a t h  F u n d a m e n t a s  l  In-Scope Functions  The static context for an XPath expression also includes a list of the functions that can be called from within the expression. Each function is identiﬁed uniquely by its name  a QName, containing a name- space URI and local name  together with its arity, which is an integer indicating how many parameters the function has. Two functions with the same name but different numbers of parameters are regarded as being completely distinct functions.  The information that’s needed about each function at compile time, apart from the name and arity, is the function signature. The function signature deﬁnes the type of each of the function’s parameters, as well as the type of its result. This information enables the XPath processor to decide at compile time whether a function call is legitimate: it can check, ﬁrstly, that a function with the right name and number of arguments actually exists, and secondly,  if the processor does static type checking  that the arguments are each of the correct type. Even when the processor doesn’t do static type checking, the signature is useful for optimization, because it enables the processor to generate code to convert the supplied values to the required type.  Like other aspects of the static context, the way in which the in-scope functions are populated is deﬁned by the host language. In most host languages, the function library is likely to include at least:        The functions deﬁned in the core library; that is, the functions listed in Chapter 13 of this book. A constructor function corresponding to each atomic type in the in-scope schema deﬁnitions. These functions are used to construct an instance of the corresponding atomic type; for example, the function «xs:date ‘2004-06-01’ » can be used to construct a date.  However, if a host language wanted to restrict the function library, it could choose to do so. For example, a host language might choose to support the whole function library with the exception of the doc   and collection   functions.  559   XPath Fundamentals  In XSLT, the in-scope functions include the two categories above, together with:           A number of standard functions deﬁned within the XSLT speciﬁcation; for example, format-number  , format-date  , and generate-id  . These are described along with the XPath functions in Chapter 13. User-deﬁned functions written in the stylesheet using the   declaration. Extension functions; for example, functions written as Java methods. The way in which extension functions are made available in the static context depends on the implementation. For example, XSLT processors written in Java generally provide an implicit binding to Java methods, in which the namespace URI of the function identiﬁes a Java class name, and the local name identiﬁes the method name within a class. In such cases the set of in-scope functions for the XPath processor effectively includes every public method in every class on the Java classpath. Other XSLT pro- cessors require an explicit binding of extension functions in the stylesheet, for example, through a vendor-deﬁned declaration such as  . In these cases, the functions added to the static context are those that are explicitly declared.  Extension functions are fully described in Chapter 16 .  In principle, it’s a static error if the XPath expression contains a call on a function that isn’t present in the static context. However, this rule doesn’t apply when XSLT backward-compability mode is in effect. This is to allow you to write conditional code that calls different extension functions depending on which XSLT processor you are using. Under these circumstances, the error won’t actually be reported until the function call is executed at runtime.  As we saw above, function names contain a namespace URI and a local name. In an actual function call, the function name is written using an optional namespace preﬁx and a local name. If the preﬁx is absent, then the function is assumed to belong to the default namespace for functions, which we described earlier in this chapter on page 556. Usually  and always in XSLT , the default namespace for functions will be the namespace for the core function library, that is, http:  www.w3.org 2005 xpath-functions. The XPath speciﬁcation allows any namespace URI to be chosen as the default, but the host language doesn’t have to pass this ﬂexibility on to the user.  If there is a default namespace for functions  and as we’ve seen, there usually will be , then it becomes impossible to refer to functions that aren’t in any namespace, because there is no way of associating a namespace preﬁx with names in the null namespace. The practical consequence of this is that if you import a schema with no target namespace, you will not be able to call constructor functions for the atomic types deﬁned in that schema. Instead, you will have to use the more verbose «cast as» syntax, which is described in Chapter 9. For example, if you have an atomic type called «percentage», you will have to write «98 cast as percentage» rather than «percentage 98 ».  Although constructor functions are named after atomic types, they use the default namespace for func- tions, not the default namespace for elements and types. For example, if the default namespace for elements and types is «http:  ns.acme.com », and there is an atomic type «part-number» deﬁned in the schema for this namespace, then you will be able to refer to the type without using a preﬁx; for example, «"AXZ98532" cast as part-number». But when you use the constructor function, the default namespace for functions applies, so you will typically need to use a namespace preﬁx, in this case: «acme:part-number "AXZ98532" ».  560   The XPath Evaluation Context  Collations  7  X P a t h  F u n d a m e n t a s  l  The static context for XPath expressions includes a set of collations, one of which is marked as the default collation. A collation is essentially a set of rules for comparing and sorting strings. One collation might decide that «pass» and «Paβ» are equal, another that they are distinct.  As far as XPath is concerned, collations are deﬁned outside the system, and a collation is treated as a black box. The XPath processor knows which collations exist  because they are listed in the static context , but it doesn’t know anything about their characteristics, beyond the fact that it can use the collation to compare two strings.  Collations are identiﬁed by URIs. These are like namespace URIs, in that they don’t necessarily identify real resources on the Web: they are just globally unique names, ensuring that collations deﬁned by one vendor can’t be confused with those deﬁned by a different vendor. There is only one collation whose name has been standardized, namely:  http:  www.w3.org 2005 xpath-functions collation codepoint  This collation, called the Unicode Codepoint Collation, compares strings character by character, using the numeric values assigned to each character in the Unicode standard. So, for example, «"Z" < "a"» is true when using this collation, because the numeric code for «Z» is 90, and the code for «a» is 97.  As with other aspects of the static context, it’s up to the host language to say what collations are available and how they are deﬁned. In this area, however, XSLT as a host language has nothing to say: it leaves it entirely up to the implementation. Many implementations are likely to devise a scheme whereby URIs identify collations provided by the programming language environment, by a database system, or by the operating system.  In Java, for example, you can deﬁne a collator by creating an object of class java.text.Collator. You can obtain a collator for a particular Locale, which will give you the basic rules for a language  for example, «¨a» collates after «z» in Swedish, but not in German . You can then parameterize the collator: for example you can set its strength, which determines whether or not it ignores accents and case, and you can control whether it applies Unicode normalization to the characters before comparison: this process recognizes that there are alternative ways of coding the same character in Unicode, either as combined characters  one codepoint representing lower-case-c-with-cedilla  or as separate characters  separate codepoints for the «c» and the cedilla . Saxon allows you to specify a collation URI that speciﬁes these parameters explicitly, for example the URI:  http:  saxon.sf.net collation?lang=de;strength=secondary;  requests a collation suitable for German  «lang=de»  in which secondary differences between characters  in practice this means case  are considered signiﬁcant, but tertiary differences  in practice, accents  are not. So «"A"="a"» is false but «"a"="¨a"» is true. However, this way of constructing a collation URI is peculiar to Saxon, and other products will have their own conventions.  If you want to write XPath expressions that are portable between products, it’s a good idea to assign your chosen collation URI to a variable in the host language, and to reference it using the variable within the XPath expression itself.  561   XPath Fundamentals  The default collation is the one that’s used in simple comparisons, such as «@a = "potato"». It’s worth thinking carefully about your choice of default collation. Generally speaking, if you’re searching for text then you want to cast the net wide, which means you want a weak collation  one that treats «A» and «¨a» as equal . But if you’re sorting, you want to make ﬁne distinctions, which means you need a strong collation. Sorting algorithms look ﬁrst for primary differences between words  «a» versus «b» , then for secondary differences  «a» versus «A»  and then for tertiary differences  «a» versus «¨a» . So you will usually want the sort algorithm to take all these differences into account.  Having said this, it’s worth noting that XPath doesn’t actually do sorting. If you want to sort data, you need XSLT or XQuery. XPath provides many functions for comparing strings, including comparing whether one string is less than another, but it can’t actually sort a collection of strings into order.  It’s also interesting to note that although XPath deﬁnes the set of collations as part of the static context, there’s nothing in the XPath language deﬁnition that uses this information at compile time. Collations are used only at runtime, and requesting a collation that doesn’t exist is deﬁned as a dynamic error rather than a static error. The reason collations are in the static context is a carryover from XQuery. XQuery deﬁnes sorting of sequences using an «order by» clause in which the collation must be known at compile time. The reason for this restriction is that XQuery systems running on large databases need to make compile-time decisions about which indexes can be used to access the data, and this can only be done by comparing the sort order requested in the query against the collation that was used when constructing the index.  Base URI  When an XPath expression calls the doc   function to load a document, the argument is a URI identifying the document. This may either be an absolute URI  for example, «http:  www.w3.org TR doc.xml»  or a relative URI such as «index.xml». If it is a relative URI, the question arises, what is it relative to? And the answer is: it is relative to the base URI deﬁned in the static context.  Where XPath expressions are contained within an XML document, as happens with XSLT, it’s fairly obvious what the base URI should be: it’s essentially the URI of the document containing the XPath expression.  This isn’t a completely clear-cut concept, because a document might be reachable by more than one URI. The thinking comes from the way URLs are used in a Web browser, where any relative URL in an HTML page is interpreted relative to the URL that was used to fetch the page that it contains. Generalizing this model has proved a fairly tortuous business.   Where XPath expressions arise in other contexts, for example, if they are generated on the ﬂy within a C++ program, it’s far less clear what the base URI should be. So XPath delegates the problem: the base URI is whatever the host language says it is. The context dependency is made explicit by identifying the base URI as part of the static context, and as far as XPath is concerned, the problem disappears.  It’s again worth noting that there is nothing in the XPath language semantics that causes the base URI to have any effect at compile time. It is used only at runtime, and then only when certain functions are used  including not only doc   but also collection   and static-base-uri   . The reason it’s deﬁned as part of the static context is the expectation that it will be a property of the document containing the text of the XPath expression.  Statically Known Documents and Collections  Later in the chapter  see page 567  we’ll be looking at how the available documents and collections form part of the dynamic context of an XPath expression. Normally, one might expect that nothing is known at compile time about the documents that the query might access when the time comes to execute it.  562   The XPath Evaluation Context  However, this isn’t always the case, especially in a database environment. This information in the static context acknowledges that in some environments, an XPath expression might be compiled speciﬁcally to execute against a particular source document or collection of source documents and that the system might be able to use this knowledge at the time it compiles the expression.  This is especially the case in a system that does static type checking. One of the difﬁculties with static type checking arises when the XPath expression contains a construct such as:  doc "invoice.xml"  invoice line-item[value > 10.00]  To perform strict static type checking on this expression, the system needs to know what the data type of «value» is. If «value» were a date, for example, then the expression would be in error  you can’t compare a date with a number , and the type checker would have to report this. But how can we know what the type of «value» is, if we don’t know in advance what type of document «invoice.xml» is?  The speciﬁcation makes provision for some documents and or collections to be recognized by the system at compile time. For example, you might compile an XPath expression against a particular database, and you might know that all the documents in that database, or in some part of that database, have been validated against a particular schema. This knowledge might allow the system to know that the example expression above is type-safe. Without this knowledge, to get this query past a system that does static type checking you would need to change it to:  7  X P a t h  F u n d a m e n t a s  l  doc "invoice.xml"  invoice line-item  [ value treat as xs:decimal  > 10.00]  This is obviously very inconvenient. It’s no surprise that most of the vendors who are planning to imple- ment static type checking in their products are running in a database environment, where the schemas are all known in advance.  This discussion probably affects XQuery much more than it does XPath. Most vendors of XML databases are using XQuery rather than XPath as the query language  though some offered XPath as a stop-gap . There’s nothing intrinsic to the argument, however, that makes it only relevant to XQuery, and that’s why this information is also part of the static context in XPath.  The Dynamic Context  We’ve now ﬁnished our tour of the static context, which contains all the information available at compile time about the environment in which an XPath expression will run. We’ll now look at the information that’s available at execution time.  In principle, all the information that was available in the static context remains available to the XPath pro- cessor when evaluating the query. The dynamic context supplements this with additional information. In practice, however, the XPath processor is free to discard information that it will not need at runtime. For example, it doesn’t need to know the names of variables at runtime, it only needs to know where the values of the variables will be held.  The following sections look at the different parts of the dynamic context in turn.  The Focus  The focus is a collective term used to describe three important pieces of information in the dynamic context: the context item, the context position, and the context size.  563   XPath Fundamentals  The most important of these is the context item. Consider the simple path expression «@code». This selects an attribute named «code». But an attribute of what? This expression only makes sense if the context item identiﬁes an element node. The expression then selects the «code» attribute of that element. When an XPath expression like this is embedded in some host language, it is the job of the host language to deﬁne how the context item is initialized.  The term context node is often used to mean ”the context item, assuming it is a node”. Very often the context item will be a node, but it can also be an atomic value such as a string or a number.  In an XSLT template rule, for example, the context node is the node that was matched by the template rule. So if you write:           then the XPath expression «@code» is evaluated with the matched   element as the context node.  To see the effect of the context position and size, it’s probably easiest to look at an   instruction; for example:        ,       The XPath expression «.», used in the   instruction, simply selects the context item. The instruction then writes a text node containing the value of this item converted to a string.  The function position   returns the value of the context position, and the function last   returns the value of the context size. In an   instruction, each item in the selected sequence  here, each   element  is processed in turn. While each item is being processed, it becomes the context item, and its position in the sequence of items being processed becomes the context position. Positions are always numbered starting at one. The context size is the number of items in the sequence, which of course is the same for each of the items. So the test  ,   outputs a comma after every item except the last.  XSLT also initializes the context position and size when a sequence of nodes is processed using  .  In other host languages, for example, in APIs for invoking XPath, it’s quite common that there is no provision for setting the context position and size, only the context item. There is no obligation on the host language to provide this capability. It can choose always to set the context position and size to one, or to leave them undeﬁned  in which case it’s an error to use the functions position   or last   .  The context item will very often be a node, but in principle it can be any kind of item, that is, a node or an atomic value. In XSLT 2.0, for example, you can use the   instruction to process a sequence of strings, and within such an instruction the context item will be a string. If you then use a path expression that relies on the context item being a node  for example, a path expression such as «@code» , it will fail with an error.  564   The XPath Evaluation Context  The focus is initialized by the host language on entry to an XPath expression, but the focus can change when evaluating a subexpression. There are two constructs in XPath that change the focus: the path expression «A B», and the ﬁlter expression «S[P]». Path expressions are described in full detail in Chapter 9 of this book, and ﬁlter expressions in Chapter 10. Let’s take the ﬁlter expressions ﬁrst.  In fact there are two very similar constructs of the form S[P] that use predicates in square brackets, and we’ll explain the difference between them in Chapters 9 and 10. For the purpose of this discussion, there is no distinction — they both handle the focus in the same way.  In this construct, «S» is a sequence  that is, it’s some expression whose value is a sequence — and as every expression evaluates to a sequence, this actually means it can be any expression whatsoever . «P» is a predicate, which ﬁlters the sequence by selecting only those items that match a given condition. So if we write «author[@surname="Smith"]» we are selecting those   elements that have a «surname» attribute whose value is «Smith».  Within the predicate, just as within an   instruction in XSLT, the context item is the item from the sequence that’s being tested; the context position is the position of that item in the sequence being ﬁltered  counting from one ; and the context size is the number of items in the sequence. This means, for example, that you can select the ﬁrst half of the sequence by writing:  7  X P a t h  F u n d a m e n t a s  l  $sequence[position   * 2 <= last  ]  There is a special rule for predicates, namely that if the value of the predicate is a number N, then it is treated as a shorthand for the condition «[position  =N]», which selects the Nth item in the sequence.  For path expressions of the form «A B», the rules are the same as the rules for predicates. The expres- sion B is evaluated once for each node in the sequence produced by evaluating A, and while B is being evaluated, that node is the context item, the position of that node in the sequence is the context position, and the number of items in the sequence is the context size. However, it’s very hard to construct a useful path expression that actually uses position   or last   on the right-hand side of the « » operator. Using them inside a predicate such as «A B[last  ]» doesn’t count, of course, because the focus changes again once you’re inside the predicate.  It’s also important to be aware that certain expressions don’t change the focus. Speciﬁcally, the focus is not changed within a «for», «some», or «every» expression  these expressions are described in Chapter 10 . So the expression:  «every $i in   item satisfies @price lt 100 »  is incorrect  at any rate, it doesn’t do what you probably intended , because the context item doesn’t change within this expression, which means that the relative path expression «@price» is not evaluated relative to each item in turn. The way you should write this is:  «every $i in   item satisfies $i @price lt 100 »  It’s easy to forget that a path expression such as «  item» requires a context node. This expression selects nodes starting from the document node at the root of the tree containing the context node. So when the context item changes, if it selects a node in a different document, then the result of «  item» changes too. This also means  which can come as a surprise  that when the context item isn’t a node, an expression  565   XPath Fundamentals  such as «  item» gives you an error. For example, this means you can’t write:  «tokenize sentence, "\s+" [not . =   stopword ]»  because by the time you’re in the predicate, the context item is one of the strings produced by the tokenize   function, which means there is no context node, and therefore no root for «  stopword» to select from. The solution to this problem is to assign the result of the expression «  stopword»  or perhaps the root node from which it navigates  to a variable.  Variable Values  The dynamic context of an XPath expression also holds the values of all the variables that are deﬁned in the static context. Each of these variables must have a value by the time the expression is evaluated, it is not possible for a variable to be ”null” or ”uninitialized”. The closest thing to a null value is the value «  », the empty sequence.  The value of each variable will always conform to its declared type. If the type of the variable is «xs:decimal», for example, the value can be an instance of «xs:decimal» or an instance of «xs:integer»  which is a subtype of «xs:decimal» , but it cannot be an «xs:string» or an «xs:float».  The way that the variable acquires its value is up to the host language. In many languages there will not be a meaningful distinction between declaring a variable  in the static context  and giving it a value  in the dynamic context . In XSLT there is no distinction in the case of  , but there is in the case of  . In the example on page 559, we showed a stylesheet parameter declared as:     The value supplied to this parameter when the stylesheet is invoked becomes part of the dynamic context for every XPath expression in the stylesheet. If no value is supplied, the dynamic context contains the default value, which in this case is the empty sequence, «  ».  Function Implementations  For every function deﬁned in the static context of the expression, there must be an implementation avail- able so that the function can be called and can return a result.  I don’t think this is saying anything very profound, so I will move on. It does make the point that although the signatures of the in-scope functions must be known when the XPath expression is compiled, there is scope for substituting different implementations of the function at runtime.  Current dateTime  The speciﬁcation tries to ensure that all the information that an XPath expression can depend on is included formally as part of the context. An XPath expression that uses the functions current-date  , current-time  , or current-dateTime   depends on the current date and time, so this is modeled as part of the dynamic context.  XPath is designed on the basis that functions are always pure functions, and a characteristic feature of a pure function is that when you call it repeatedly, it returns the same result each time. The current date and time in the dynamic context are therefore deﬁned not to change during the execution of an XPath expression. In fact, in XSLT, they are deﬁned not to change during the execution of an entire stylesheet. This means that the functions are not useful for applications such as performance instrumentation; they are intended rather for recording the approximate time at which a stylesheet or query was executed, and for use in business logic calculations such as displaying a date three days from today.  566   The XPath Evaluation Context  Implicit Timezone  XML Schema allows values to be speciﬁed without a timezone, for example, as «2008-01-31 T22:00:00». This can be interpreted as meaning that the timezone is unknown, but this interpretation makes life very complicated when dates and times are compared with each other: it means, for example, that «2008-01-31» is deﬁnitely earlier than «2008-02-05», but it’s uncertain whether «2008-01-31» is earlier than «2008-02-01», because if the ﬁrst date is used in a part of the world whose timezone is «-12:00», it refers to the same period of 24 hours as the second date in a place whose timezone is «+12:00». Such uncertainty causes havoc with query languages, and so XPath took a different approach. Instead of inter- preting the absence of a timezone as meaning that the timezone is unknown, it interprets it as meaning that an implicit timezone should be assumed. Where possible, this will be the timezone in the place where the user is located, or failing that, the timezone in the place where the computer is located. How- ever, XPath doesn’t worry itself with how the implicit timezone is set up: it simply says that there is one, leaves it to the host environment to initialize it, and goes on to specify how it is used when performing operations on dates and times.  Some host languages might choose to specify how the implicit timezone is initialized: in Java, for example, it could have a deﬁned relationship to the current locale. XSLT, however, chooses to pass the buck to the implementation. It’s likely that many implementations will use the timezone setting from the computer on which the XSLT processor is running, which may or may not give useful results.  7  X P a t h  F u n d a m e n t a s  l  The implicit timezone is used behind the scenes by a number of operators that manipulate dates and times, but it is also available explicitly to the XPath user through the function implicit-timezone  , which is included in Chapter 13.  Available Documents and Collections  One of the aims in deﬁning the evaluation context for XPath is to list all the things in the environment that can affect the result of an XPath expression. Two of the most environment-dependent constructs in the language are the doc   function  and its XSLT precursor, document   , which loads a document using a URI, and the collection   function, which similarly identiﬁes a collection of documents using a URI.  In the XSLT 1.0 speciﬁcation there was a fairly detailed description of how the document   function was supposed to work. It described in some detail the process of URI resolution, the way in which the URI was dereferenced to fetch a resource from the Web, the requirement for this resource to contain well-formed XML, and the way that the media type of the resource affected the interpretation of any fragment identiﬁer in the URI.  But at the same time, the speciﬁcation said that the input to the XSLT processor was a tree, following the rules in the data model, and that nothing in the speciﬁcation should constrain the way in which the tree was constructed.  There’s clearly a tension between these two deﬁnitions, and this revealed itself, during the life of the speciﬁcation, in some practical problems. Notoriously, the Microsoft XSLT processor took the second statement at face value, and stripped spaces from the source document by default, which meant that it often produced different results from other XSLT processors. Another XSLT processor decided to expand XInclude directives in the source document by default. Both of these decisions were entirely conformant according to the speciﬁcation, and yet they led to practical interoperability problems.  Even more extreme effects can be achieved by exploiting the URIResolver interface in the Java JAXP API  which Microsoft has emulated in the System.Xml framework classes under the name XmlResolver . This allows the user to nominate a routine that will intercept all requests for a URI from the doc   func- tion, and take over the job of delivering a document in response to the request. This means, for example, 567   XPath Fundamentals  that you can call the doc   function with the URI «special:  prime 100» and return a document con- taining the ﬁrst 100 prime numbers, constructed algorithmically. This mechanism is undoubtedly useful, but it rather makes a mockery of any detailed description in the language speciﬁcation of how the doc   function is supposed to work.  Rather than try and tighten up the specs to force interoperability, the working groups decided that this was a place where allowing implementations some freedom was actually in users’ best interests. The way that this is reﬂected in the spec may seem a little confusing. It simply says that the dynamic context of an XPath expression provides a mapping from URIs onto document nodes. The easiest way to read this is by thinking of the mapping as being an external function rather like the Java URIResolver: if you give it a URI, it comes back with a document node. This function might go out to the Web, retrieve an XML document, parse it, validate it, and turn it into a tree in the data model. Or, it might return a document node that represents a virtual document, which is actually a collection of data in a relational database. Or, it might construct an XML document containing the ﬁrst 100 prime numbers. Quite simply, any- thing goes.  So you can’t be sure that the same call on the doc   function will produce the same results on two differ- ent implementations. The hope is that market forces will ensure that most products support the obvious mappings from URIs to documents, even though these mappings are no longer mandatory, and might not be provided by XPath processors designed to operate in specialized environments.  As well as the doc   function which returns a document node corresponding to a URI, XPath 2.0 also provides the collection   function which returns a collection of documents  actually, a sequence . While there is a great deal of precedent and user expectation for the way in which URIs will map to individual documents, there is very little precedent for the concept of a document collection identiﬁed by URI, and it’s likely therefore that different processors will interpret this concept in very different ways. There is a tendency, however, for good ideas to be copied from one implementation to another, so perhaps conventions will start to appear. However, the concept of collections is really intended as an abstraction of an XML database, or part of an XML database, and since the system architecture of different XML databases is highly variable, there might well remain radical differences in the way that the concept of a collection is realized.  As with other aspects of the context, the host language gets a say in the matter. For example, a host language could say that the set of available documents and collections is always empty, and thus con- strain XPath expressions to operate on a single document, or on documents accessible through variables. Indeed, the current draft of XML Schema 1.1, which uses XPath expressions to deﬁne assertions, does just this. But in the case of XSLT, little more is said on the subject. The only thing that XSLT adds is a speciﬁcation of the document   function, which continues to be available in XSLT and is now deﬁned in terms of the simpler XPath 2.0 doc   function.  Summar y  XPath expressions are used in XSLT to select data from the source document and to manipulate it to generate data to place in the result document. XPath expressions play the same role for XML as the SQL SELECT statement plays for relational databases — they allow us to select speciﬁc parts of the docu- ment for transformation, so that we can achieve the required output. Their use is not restricted to XSLT stylesheets — they can also be used with XPointers to deﬁne hyperlinks between documents, and many DOM implementations allow XPath expressions to be used to ﬁnd nodes within the DOM.  This chapter provided an introduction to the basic constructs in XPath expression: an overview of the grammar and the lexical rules, and explanation of some of the basic constructs such as literals, variable references, function calls, and conditional expressions.  568   Summary  In this chapter we also described all the contents of the XPath evaluation context, including both the static and the dynamic context. The context is important because it establishes the interface between XPath and a host language such as XSLT, and it identiﬁes all the external information that may affect the result of an XPath expression.  The next four chapters explore the XPath language in more depth. Chapter 8 looks at the basic operators for arithmetic, boolean comparisons, and testing identity and ordering of nodes. Chapter 9 describes path expressions and the operations for combining sets of nodes to form their union, intersection, or difference. Chapter 10 examines expressions on sequences, notably the «for» expression, which provides a general mapping capability to construct one sequence by applying an expression to each item of an input sequence. Then, Chapter 11 discusses operations on types.  After a return to XSLT to describe match patterns in Chapter 12, Chapter 13 provides a catalog of all the functions in the core library, and Chapter 14 gives the syntax for regular expressions, which are used in three of these functions.  7  X P a t h  F u n d a m e n t a s  l  569    XPath: Operators on Items  This chapter deﬁnes the simple operators available for use in XPath expressions. This is inevitably a rather arbitrary category, but these operators seem to have enough in common to justify putting them together in one chapter. All these operators return single items  as distinct from sequences  — in fact, all of them except the arithmetic operators in the ﬁrst section return a boolean result.  More speciﬁcally, this chapter describes the following families of operators:                 Arithmetic operators, «+», «-», «*», «div», and «mod» Value comparison operators «eq», «ne», «lt», «le», «gt», «ge» General comparison operators «=», «!=», « », «>=» Node comparison operators « >» Boolean operators «and» and «or»  8  X P a t h :  O p e r a t o r s  o n  I t e m s  Many of these operators behave in much the same way as similar operators in other languages. There are some surprises, though, because of the way XPath handles sequences, and because of the way it mixes typed and untyped data. So don’t skip this chapter just because you imagine that everything about these operators can be guessed.  Arithmetic Operators  These operators are normally used to perform calculations on numbers, which may be of any of the numeric types: xs:integer, xs:decimal, xs:float, or xs:double. They are also overloaded to perform calculations on dates and durations.  Note that this section only describes arithmetic operators built in to the XPath syntax. These opera- tors are complemented by a range of arithmetic functions in the standard function library, described in Chapter 13. The functions in this library include abs  , ceiling  , floor  , round  , round-half-to-even  , sum  , max  , min  , and avg  .  Syntax  The syntax of expressions using the arithmetic operators is deﬁned by the following syntax productions in the XPath grammar.   XPath: Operators on Items  Expression  AdditiveExpr  Syntax  MultiplicativeExpr   «+» «-»  MultiplicativeExpr  *  MultiplicativeExpr  UnionExpr   «*» «div»  «idiv»  «mod»  UnionExpr  *  UnaryExpr   «-»  «+» * PathExpr  The priority of operators is indicated by the grammar. Unary «+» and «-» have a higher priority  bind more tightly  that the multiplicative operators «*», «div», «idiv», and «mod», which in turn have higher priority than the binary forms of «+» and «-». In between union operators and unary operators, there is a long list of operators with intermediate priority, such as «intersect» and «cast as». A full list of operator priorities, showing how these operators relate to others, is given in Appendix A.  There are two division operators: «div» for exact division, and «idiv» for integer division. The precise rules for these are described below. The «mod» operator gives the remainder when one number is divided by another. The reason that the « » symbol isn’t used for division is that this would conﬂict with its use in path expressions, which are described in Chapter 9.  When using the minus operator, take care that it does not get confused with a hyphen within a name. If it immediately follows a name, use a space to separate it. Note that «price-discount»  without spaces  is a single hyphenated name, whereas «price − discount»  with spaces  performs a subtraction. If in doubt, use spaces to separate an operator from the surrounding tokens: it never does any harm.  If there are several operators with the same priority, they are evaluated from left to right. For example «5-2-2» means « 5-2 -2», which evaluates to «1».  Type Promotion  There are special rules for arithmetic operators to determine the type of the result of the expression, based on the types of the operands.  If the operands have the same type, then in general the result is the same type as the operands. So, for example, the sum of two xs:integer values is an xs:integer, while the result of multiplying two xs:double values is an xs:double. The exception to this rule is the «div» operator, when the operands are xs:integer values: in this case, the result is an xs:decimal. For example, the result of «5 div 2» is the xs:decimal value «2.5».  The phrase ‘‘the same type’’ in this rule means the underlying numeric type: one of xs:integer, xs:decimal, xs:float, or xs:double. If you add two xs:short values, the result will be an xs:integer, not an xs:short.  At any rate, it’s not guaranteed to be an xs:short; the only requirement on the implementation is that the result must be an xs:integer, and returning an xs:short would satisfy that requirement, as long as the result of the operation is in the range of values that xs:short can handle.   If you use these operators to combine two values that are of different types, type promotion kicks in. This deﬁnes a pecking order among the four numeric types: xs:double wins over xs:float, xs:float over xs:decimal, and xs:decimal over xs:integer. If you mix two types, then the loser in this pecking order is ﬁrst converted to the type of the winner, and the result has the same type as the winner. So, for example, the result of the expression «2.5 + 1» is the xs:decimal value «3.5», because «2.5» is an xs:decimal and «1» is an xs:integer, and xs:decimal is higher in the pecking order.  572   Arithmetic Operators  Changes in XPath 2.0  The main change affecting arithmetic operators is the increased range of data types they can handle. In XPath 1.0, all numbers were handled as double-precision ﬂoating point, and the operators were not overloaded to handle any other data types.  In XPath 1.0, the arguments supplied to the function were automatically converted to numbers, using the rules for the number   function  which is described in Chapter 13 . This means, for example, that the result of «1 + true  » would be 2  true   converts to 1 , and the result of «"apple"+"pear"» would be NaN  any non-numeric string converts to the special not-a-number value NaN, and adding two NaNs gives NaN . These conversions are still carried out in XPath 2.0 if you run with backward compatibility enabled, which is what happens in an XSLT stylesheet that speciﬁes «version = "1.0"». The main advantage of this behavior is that you never get a runtime error  only NaN results , and if this is important to you, you can achieve the same effect in XPath 2.0 by using the number   function explicitly, even without backward compatibility enabled.  The «idiv» operator is new in XPath 2.0. It does integer division and is particularly useful when calcu- lating how many rows and columns you need for a table; for example, if you have $N items to arrange in three columns, then the number of rows needed is « $N + 2  idiv 3». Although the result is always an integer, the operands don’t have to be integers: for example, the result of «3.6 idiv 1.5» is «2». Another handy use of this operator is to convert any number $x to an integer by writing «$x idiv 1».  Unary plus has been added to the language largely so that any value accepted as the lexical value of a number by XML Schema is also accepted as a valid constant value in an XPath expression. XML Schema accepts «+1.0» as a legal representation of a number, so XPath 2.0 accepts it too.  8  X P a t h :  O p e r a t o r s o n  I t e m s  The relative precedence of the union operator «» and unary minus has changed since XPath 1.0. In 1.0, the expression «-@price@cost» was interpreted as «- @price@cost », whereas it now means « -@price    @cost ». Usually this will give a type error on the grounds that the operands of «» must be nodes, but in the case where there is no @price attribute and @cost has the value 12, the expression will return -12 in XPath 1.0 but + 12 in XPath 2.0.  Effect  The detailed rules for these operators are as follows. The rules are given here on the assumption that the special rules for XPath 1.0 backward compatibility are not in force; the changes that apply under backward-compatibility mode are described later.  1.  2.  3.  The operands are atomized, as described on page 220 in Chapter 5. This means that nodes are replaced by their typed values; for example, if one of the operands is the attribute node «@price», then the typed value of this attribute is extracted. If, after atomization, either operand is an empty sequence, then the result of the operation is also an empty sequence. For example, if the context node has no price attribute, then the result of «@price * 0.8» is the empty sequence, «  ». If either operand after atomization is a sequence of more than one item, a type error is raised. For example, if you write the expression «price * 0.8» and the context node has more than one child element called  , a type error ensues. The signiﬁcance of it being a type error is that it may be reported either at compile time or at runtime, as discussed in the section on Static and Dynamic Type Checking in Chapter 5  page 221 .  573   XPath: Operators on Items  4.  5.  6.  If either operand is an xs:untypedAtomic value, then it is converted  using the casting rules  to an xs:double. This situation will normally occur when the operand as written is a node in a schema-less document. For example, suppose the expression is «@price * 0.8», and there is no schema, and the price attribute in the source document is written as «price = "129.99"». Then the attribute value will be converted to the xs:double value 1.2999e2, and the result of the mul- tiplication will also be an xs:double. Note the difference with numeric literals, described on page 530 in Chapter 7 — in the case of a value contained in an untyped node, it is always converted to an xs:double when used as an operand of «*», regardless of whether it is written in exponential notation or not. The conversion to an xs:double uses the casting rules  described in Chapter 11 , not the rules of the number   function. This means that if the value isn’t a valid number, the expression will fail with a runtime error, rather than returning the value NaN. If the operands are now of an acceptable type for the operator, the calculation is carried out. In the case of numeric operands, all combinations of numeric values are acceptable, and the values are ﬁrst promoted to a common type as described in the section Type Promotion above. The only other kinds of operands that are acceptable are certain combinations of dates, times, and dura- tions, which are described in the section Arithmetic using Durations below. The calculation may succeed or fail  the most obvious example of a failure is division by zero ; if it fails, a runtime error is reported. If the operands are of the wrong type, then a type error is raised. For example, this will happen if one of the operands is an xs:boolean or xs:string value.  There are two differences to these rules when backward compatibility is in force. Firstly, in step 3, instead of reporting an error when there is more than one item in the sequence, all items except the ﬁrst are discarded. Secondly, after step 4, any operand of type xs:untypedAtomic, xs:string, xs:boolean, xs:decimal  including xs:integer , or xs:float is converted to an xs:double value, using the number   function. This means that the result will also be of type xs:double. If the value of an operand can’t be converted, the answer comes out as NaN rather than an error. This rule is written in such a way that arithmetic on dates, times, and durations is unaffected by backward-compatibility mode — it follows the normal 2.0 rules.  This section describes some of the corner cases that can arise when doing numeric arithmetic.  Arithmetic Using Numbers  Integer Arithmetic  With integer operands, there are few surprises.        Division by zero is a fatal error. This can arise with any of the operators «div», «idiv», or «mod». The language spec doesn’t deﬁne the maximum size of an integer, though it does say it must be at least 18 decimal digits, which should be enough for most purposes. Every conforming implementation is required to provide an option to detect integer overﬂow and report it as a fatal error. It’s also permissible to provide a mode where arithmetic wraps around  as it does in many programming languages like Java and C . If both options are available, the spec doesn’t say which should be the default. The thinking is that some users will want to pay the cost of the runtime error detection, whereas others will prefer raw speed.  574   Arithmetic Operators  The result of dividing two integers using the «div» operator is an xs:decimal value, but the spec doesn’t say what the precision of the result should be. For example, if you write «10 div 3», then one system might produce the answer «3.333», while another produces «3.3333333333333333».  The «mod» operator, which gives the remainder from an integer division, can be confusing when negative numbers are involved. I ﬁnd the following rules of thumb helpful:        The result is positive if the ﬁrst operand is positive, negative if it is negative.  The result depends only on the absolute value of the second operand, not on its sign.  It’s also useful to think of the «mod» operator in conjunction with «idiv». Thus:  Expression 20 mod 3  20 mod –3  –20 mod 3  –20 mod –3  Result 2  2  –2  –2  Expression 20 idiv 3  20 idiv –3  –20 idiv 3  –20 idiv –3  In all cases  except where $y is zero  the result of « $x idiv $y *$y +  $x mod $y » is $x.  Decimal Arithmetic  Decimal arithmetic is useful because it avoids the rounding errors that arise with ﬂoating-point calcula- tions. This is particularly true when handling values that are discrete rather than continuous, of which the most obvious example is money.  Again, the language spec doesn’t deﬁne the maximum precision that can be held in an xs:decimal value. This is more likely to be a problem with xs:decimal than with xs:integer, and it means that different products are likely to give different answers to the same calculation  though hopefully, only a little bit different! .  The main problem is with division. Even systems that support indeﬁnite-precision xs:decimal values  as Saxon does, for example  have to make a decision as to how many digits to retain in the result of «10 div 3», and the spec offers no clues.  As with integer arithmetic, division by zero is a fatal error.  The rules for handling overﬂow are subtly different from the rules for integers. In the case of xs:decimal, overﬂow  that is, calculation of a result that is too big for the system to handle, whatever this limit might be  must be reported as an error. So unlike the situation with integers, there is no prospect of the system giving you a spurious result by wrapping around.  Arithmetic with xs:decimal values can also cause underﬂow. This happens when the result of a compu- tation is smaller than the smallest value that can be recorded, but greater than zero. Equally, of course, it could be a very small negative number. For example, if you multiply 0.00000001 by itself, and the system can only handle 10 decimal places after the decimal point, you will get an underﬂow. The rule in this case is that the result returned must be the xs:decimal value 0.0.  Result 6  –6  –6  6  8  X P a t h :  O p e r a t o r s  o n  I t e m s  575   XPath: Operators on Items  Floating-Point Arithmetic  Floating-point arithmetic  whether using single precision xs:float, or double-precision xs:double  is deﬁned by the rules of the IEEE 754 speciﬁcation. These rules were summarized in Chapter 5.  The XPath 1.0 speciﬁcation tied the deﬁnition of ﬂoating-point arithmetic pretty closely to the same rules as were adopted in Java. But in fact, the IEEE 754 speciﬁcation offers a number of options, and XPath 2.0 gives implementors a bit more freedom to select which options to provide. In particular, the speciﬁcation allows for errors to be raised on overﬂow or underﬂow conditions, whereas the XPath 1.0 proﬁle always returned positive or negative inﬁnity in the overﬂow case, and positive or negative zero for underﬂow. So in corner cases, the behavior may not be exactly the same as with XPath 1.0, and not quite so consistent across different processors.  The unary minus operator is deﬁned to change the sign of the operand. This is subtly different from subtracting the operand from zero, because it means that «-0e0» represents negative zero rather than positive zero. There’s very little difference between the two: about the only way of telling them apart is by a test such as «1 div $x > 0», which returns true if $x is positive zero  the division gives positive inﬁnity , but false if $x is negative zero. For practical purposes, the distinction between the two values is rarely important, and it is lost once you write the results away to an XML document. Its only signiﬁcance is that it preserves a useful difference in the intermediate results of complex calculations.  Floating-point arithmetic can always give you rounding errors, because there are values that can be written accurately in decimal notation that can’t be expressed accurately in binary. So, for example, the result of the expression «1.0E-3 * 1.0E-4» might not be displayed as «1.0E-7» as you would expect, but as «1.0000000000000001E-7». You can round it to the number of decimal places required using the round-half-to-even   function, or in XSLT, by using the format-number   function. Both are described in Chapter 13.  Examples of Numeric Arithmetic  Expression  $X + 1  last  -1  @margin*2  Description The result of adding 1 to the value of the variable $X.  One less than the position of the last node in the context list.  Twice the value of the margin attribute of the context node. This will work only if the margin attribute either has a numeric type, or is untyped and has a value that can be interpreted as a number.  ceiling count  item  div 3   One-third of the number of child   elements of the context node, rounded upwards.  Useful if you are arranging the items in three columns .  $seq[position   <= last   idiv 2]  Selects the ﬁrst half of the items in the sequence $seq, rounded down. For example, if there are 11 items in the sequence, it selects the ﬁrst ﬁve.  item[position   mod 2 = 0]  Selects the even-numbered child   elements of the context node.  Again, this can be useful if you are arranging items in a table .  count $list  mod 5 + 1  The number of items in the sequence $list modulo 5, plus one. The result will be a number in the range 1 to 5.  continued  576   8  X P a t h :  O p e r a t o r s  o n  I t e m s  Expression  -@credit  +@credit  1---1  Arithmetic Operators  Description The negated numeric value of the credit attribute of the context element node. If the context node has no credit attribute, or if its value is not numeric, the result of the expression is «  »  the empty sequence , unless backward-compatibility mode is set, in which case it is NaN  not a number .  The plus sign here is not a no-op; it forces conversion of the attribute node to a number. It also tells the compiler that the result will be a number, which can be useful when doing static typing and optimization.  A not very useful but perfectly legal way of writing the value zero. The ﬁrst minus sign is a binary subtraction operator; the next two are unary minus signs.  Arithmetic Using Durations  As well as being used for conventional arithmetic with numbers, the arithmetic operators are used to perform certain operations on dates, times, and durations. Not all combinations make sense; for example, it’s sensible to add 3 days to a date, but it isn’t sensible to add two dates.  There’s a table in the XPath 2.0 speciﬁcation that lists all the combinations of operators and operands that are permitted, and the number that involve dates, times, and durations is alarmingly large. But appearances are deceptive: on closer examination, it turns out that these are all permutations on a small number of themes. The number of permutations is large because it involves:           Three date time types: xs:date, xs:dateTime, and xs:time Two duration types: xs:yearMonthDuration and xs:dayTimeDuration Symmetric operations, for example  duration + date  as well as  date + duration   In fact, all the options boil down to ﬁve basic categories:  Expression  date time +- duration  duration +- duration  duration *div number  date time – date time  duration div duration  Meaning Returns a date time that is a given duration after or before the supplied date time. For example, 2008-12-31 plus three days is 2009-01-03.  Adds or subtracts two durations to give another duration. For example, one hour plus two hours is three hours.  Multiplies a duration by a numeric factor, or divides it by a numeric factor, to give another duration. For example, one month times 3 is three months.  Determines the interval between two dates times, as a duration. For example, 2009-01-03 minus 2008-12-31 is three days.  Determines the ratio between two durations, as a number. For example PT12H divided by PT10 M is 72.  577   XPath: Operators on Items  In each of these cases the following rules hold:           If the operator is «+» or «*»  but not if it is «-» or «div»  then the operands may be written in either order. Subtracting a positive duration is the same as adding a negative duration  a negative duration is written, for example, as «-P3D» to represent minus three days . The duration must be either an xs:dayTimeDuration or an xs:yearMonthDuration. The ﬁrst kind is equivalent to an exact number of seconds, the second to an exact number of months. The primitive type xs:duration can’t be used for arithmetic, because the variation in the length of a month creates too many uncertainties.    Multiplying a duration by a number such as 0.5 is the same as dividing it by 2.0.  The following sections examine each of the four cases in a bit more detail.  Date Time Plus Duration  This section covers the following combinations of operands:  Operand 1  xs:date  xs:date  xs:dateTime  xs:dateTime  xs:time  Operand 2  xs:yearMonthDuration  xs:dayTimeDuration  xs:yearMonthDuration  xs:dayTimeDuration  xs:dayTimeDuration  Result  xs:date  xs:date  xs:dateTime  xs:dateTime  xs:time  The allowed operators are «+» and «-». If the operator is «+», then the operands may appear in either order; if it is «-», then the date time must be the ﬁrst operand and the duration the second. Subtracting a positive duration has the same effect as adding a negative duration, and vice versa.  The decision to allow arithmetic using the two subtypes xs:yearMonthDuration and xs:dayTimeDuration, while not allowing it using the parent type xs:duration, is slightly perverse, since any xs:duration value can be decomposed into an xs:yearMonthDuration and an xs:dayTimeDuration. But by now, you should be used to the idea that the handling of durations in XML Schema and XPath has a few rough edges.  Let’s start by seeing how to add an xs:dayTimeDuration to an xs:dateTime. This is reasonably straight- forward. An xs:dayTimeDuration represents an exact number of seconds. When you add this to an xs:dateTime you get the value that represents the instant in time that is this number of seconds later  or earlier, if the duration is negative  than the original, in the same timezone.  The algorithm ignores the leap seconds that can be inserted arbitrarily into the calendar to handle variations in the earth’s speed of rotation.   If you’re adding an xs:dayTimeDuration to an xs:date, rather than to an xs:dateTime, you can get the right answer by considering the xs:dateTime at 00:00:00 on the date in question and then ignoring the time part of the result.  If you’re adding the duration to an xs:time, the result is taken modulo 24 hours. For example, 03:00:00 plus P1D is 03:00:00, and 03:00:00 plus PT36H is 15:00:00.  578   Arithmetic Operators  If you’re adding an xs:yearMonthDuration to an xs:date, the rules are slightly more complicated. What is 31st January plus one month? The answer given by the speciﬁcation is that it is 28th February, or 29th February if it’s a leap year.  Adding an xs:yearMonthDuration to an xs:dateTime is the same as adding it to the date part of the xs:dateTime, and returning the time portion unchanged. Adding an xs:yearMonthDuration to an xs:time is not allowed, because it would always return the value unchanged.  Duration Plus Duration  You can only add or subtract two durations of the same type. The allowed combinations of operands are:  Operand 1  Operand 2  Result  xs:yearMonthDuration  xs:yearMonthDuration  xs:yearMonthDuration  xs:dayTimeDuration  xs:dayTimeDuration  xs:dayTimeDuration  The operator can be either «+» or «-».  The rules are reasonably obvious  at any rate, they appear to be obvious to the writer of the speciﬁca- tion, which simply says that the result is the sum or difference of the two durations . Remember that an xs:yearMonthDuration is equivalent to an xs:integer number of months, and an xs:dayTimeDuration is equivalent to an xs:decimal number of seconds. The addition and subtraction of two durations, whether they are positive or negative in sign, thus reduces to simple arithmetic on numbers.  For example, subtracting PT6H  6 hours  from P1D  one day  gives PT18H  18 hours .  Only binary «+» and «-» can be used with durations: the unary «+» and «-» operators, for no particularly good reason, are constrained to work only with numbers. The easiest way to turn a positive duration into an equivalent negative duration is to multiply it by «-1», as described in the next section.  8  X P a t h :  O p e r a t o r s  o n  I t e m s  Duration Times Number  Operand 1  xs:yearMonthDuration  An xs:dayTimeDuration or xs:yearMonthDuration can be multiplied or divided by a number, to give another duration of the same type. The operand combinations are:  Result  xs:yearMonthDuration  xs:dayTimeDuration  xs:dayTimeDuration  Operand 2  xs:double xs:float xs:decimal  xs:double xs:float xs:decimal  The operator can be «*»  multiply  or «div»  divide . If the operator is «*», the operands can appear in either order; if it is «div», then the numeric operand must be the second operand.  The effect of the operation is equivalent to converting the duration to a number of months or seconds, performing a numeric multiplication or division, and then converting the result back to a duration.  579   XPath: Operators on Items  Date Time Minus Date Time  The problem of comparing dates and times is illustrated nicely by the following letter published in The Times of London, which we will return to later:  This week the wives of two of my nephews have given birth to sons. The ﬁrst was born at 12.11 am on July 10 in Melbourne; the second arrived at 9.40 pm on July 9 in London. I am confused as to which is the older.  John Wayman, Sudbury, Suffolk. 13 July 2007   The subtraction operator «-» can be used to subtract date time values to give a duration, provided the operands match one of the rows in the following table: Operand 2 Operand 1  Result  xs:date  xs:dateTime  xs:time  xs:date  xs:dateTime  xs:time  xs:dayTimeDuration  xs:dayTimeDuration  xs:dayTimeDuration  If the ﬁrst operand represents an instant in time later than the second operand, then the result will be a positive duration; if it represents an earlier instant in time, then the result will be a negative duration.  If the date time was supplied without a timezone, then it is assumed to represent a date time in the implicit timezone deﬁned by the evaluation context  see Chapter 7 .  For operands of type xs:dateTime, the result is the duration corresponding to the number of seconds that separate the two instants in time, taking timezone into account. For example, the difference between the ages of John Wayman’s two great-nephews is  xs:dateTime ’2007-07-09T21:40:00+01:00’  -  xs:dateTime ’2007-07-10T00:11:00+10:00’   which makes the British child 6 hours and 29 minutes younger than his Australian cousin, despite having an earlier date on his birth certiﬁcate.  For operands of type xs:date, the result is the difference between the starting instants of the two dates. Since the dates can be in different timezones, the result is not necessarily an integer number of days.  For operands of type xs:time, the values are assumed to represent two times occurring on the same date. If the times are in the same timezone  or both in no timezone , this gives results that are reasonably intuitive — except that 01:00:00 minus 22:00:00 is not 3 hours, but –21 hours. With different timezones, the answers can be quite surprising. For example the difference between 22:00:00-05:00  10 p.m in New York  and 01:00:00Z  1 a.m in London  is the same as the difference between 2008-01-01 T22:00:00-05:00 and 2008-01-01 T01:00:00Z, namely 26 hours.  A working draft of the XPath 2.0 speciﬁcation included functions to compute the difference between two dates in months. These functions were dropped because of difﬁculties in deﬁning exactly what they should return. What’s the difference in months, for example, between 29 Feb 2008 and 31 Jan 2008?  Duration Divided by Duration  It is possible to divide an xs:dayTimeDuration by another xs:dayTimeDuration, or an xs:yearMonthDuration by another xs:yearMonthDuration, to obtain an xs:double. The division operator must be «div»  «idiv» is not supported . The result is equivalent to converting both the dura- tions into a number of months or seconds and performing a numeric division.  580   Value Comparisons  Here are some examples:  Expression  xs:dayTimeDuration "P10D"  div xs:dayTimeDuration "PT6H"   xs:dayTimeDuration "-P1D"  div xs:dayTimeDuration "PT1S"   xs:yearMonthDuration "P1M"  div xs:yearMonthDuration "P1Y"   0.083333333. . .  Result 40  –86400  This operation provides the easiest way to convert a duration into a number of months, days, or seconds. To convert an xs:dayTimeDuration to seconds, for example, just divide it by xs:dayTimeDuration "PT1S" . This is useful when you need to perform calculations that are not directly supported by the operations available on durations. Examples include:  Dividing a distance by a duration to obtain an average speed.    Multiplying the number of hours worked by the hourly rate to obtain the amount of  money due. Determining the day of the week for a given date.  The following code illustrates how to display the day of the week, supplied in the variable $date:   "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"  [1 +   $date - xs:date "1901-01-06"   div xs:dayTimeDuration "P1D"  mod 7 ]  In XSLT 2.0, however, you can display the day of the week using the format-date   function, described in Chapter 13.  8  X P a t h :  O p e r a t o r s  o n  I t e m s  Value Comparisons  XPath 2.0 has introduced a completely new set of operators for comparing single atomic values. These are shown in the table below.  Meaning  equals  not equals  less than  less than or equal to  greater than  greater than or equal to  These were introduced primarily because they have much cleaner and more predictable behavior than the XPath 1.0 operators «=», «!=», « », and «>=». The XPath 1.0 operators are still available, and they are described later in this chapter under the heading General Comparisons on page 588.  581        eq  ne  lt  le  gt  ge  Operator   XPath: Operators on Items  The real driver for introducing these new operators was not really the requirements of XSLT users, but the needs of XQuery, which is a superset of XPath 2.0. XQuery needs to be able to search large databases, and if you want to search a terabyte of data then you need to take advantages of indexes. This means you need to be able to rearrange the query as written by the user into a form that can take advantage of the indexes known to be available, and this rewriting of an expression into a different form is only possible if the operators have very clean mathematical properties. For example, a very useful property that makes rearranging expressions possible is called transitivity, which means that if «A=B» and «B=C» are both true, then you know that «A=C» will also be true. Unfortunately, this isn’t the case for the «=» operator in XPath 1.0. For example, in XPath 1.0, «1=true  » and «true  ="true"» are both true, but «1="true"» is false.  But although these operators were introduced speciﬁcally to enable XQuery optimization, I think it’s a good idea to get into the habit of using them for most routine comparisons. You probably won’t see any very visible performance beneﬁt for the average XSLT stylesheet, but you may ﬁnd that you make fewer errors because the behavior of the operators is simpler and more predictable. As a bonus, it’s easier to write «le» than «&lt;=».  In the XPath syntax, the two kinds of comparison operator, as well as the three operators «is», « >», which we will meet later in this chapter  see page 594 , are presented like this:  Expression  Syntax  ComparisonExpr  RangeExpr    ValueComp  GeneralComp NodeComp   RangeExpr  ?  ValueComp  GeneralComp  NodeComp  «eq»  «ne»  «lt»  «le»  «gt»  «ge»  «=»  «!=»  « »  «>=»  «is»  « >»  This means that all 15 operators listed here have the same priority. For all these operators the result of the expression is always an xs:boolean value. The reference to RangeExpr in the syntax can be ignored for now: it just refers to the next kind of expression in operator precedence order, which happens to be the range expression  of the form «1 to 10»  described in Chapter 10.  The biggest difference between the value comparison operators and the general comparison operators described on page 588 is that the value comparison operators always compare two atomic values with each other, whereas the general comparison operators can be used to compare sequences.  Permitted Operand Types  The detailed effect of the comparison depends on the types of the two operands. These must be compati- ble with each other. There are some data types that can be compared using the «eq» and «ne» operators but not the «lt», «le», «gt», or «ge» operators. An example is xs:QName — you can test whether two xs:QName values are equal to each other but not whether one is less than the other.  The permitted operand types for value comparisons are summarized in the two tables that follow. Both operands must have the same type  as deﬁned by a row in the table . Comparing two values whose types don’t match  for example comparing an integer to a string  doesn’t give you a result of false; it is a type error. This means the error may be reported either at compile time or at runtime, as discussed in Chapter 3.  As we’ll see later, xs:untypedAtomic values are treated as strings.   The ﬁrst table is for «eq» and «ne», and shows for each data type how the comparison is done.  582   Value Comparisons  xs:boolean  Two xs:boolean values are equal if they are both true, or both false.  Data type xs:string or xs:anyURI  numeric  xs:dateTime  xs:date  xs:time  Deﬁnition of eq An anyURI value is treated as a string. The two strings are compared using the default collation established in the static context for the expression. Collations are described in detail on page 459. In consequence, the results may be quite different in different environments, for example, in one context the strings «Strasse» and «Straße» may be equal; in another context, they may be unequal.  Any two numeric values can be compared  xs:integer, xs:decimal, xs:float, or xs:double . If they are of different types, one value is ﬁrst promoted to the type of the other in the same way as for arithmetic operators  see page 571 . They are then tested for numeric equality  this means, for example, that «1.00» and «01» will compare as equal . There are a couple of special cases with ﬂoating point numbers: positive and negative zero are considered equal to each other, but NaN  not a number  is not equal to any other number; in fact, it is not even equal to itself.  Two xs:dateTime values are equal if they represent the same instant in time. This means that if both include a timezone, they are adjusted so that they are in the same timezone  conventionally UTC, but any timezone would do . Although the XPath data model retains the original timezone attached to the value, it plays no part in the comparison: the two xs:dateTime values «2008-01-01 T02:00:00Z» and «2007-12-31 T21:00:00-05:00»  2 a.m. in London and 9 p.m. the previous day in New York  are considered equal. If either or both of the values have no timezone, they are considered to represent times in the implicit timezone deﬁned by the XPath evaluation context, as described in Chapter 7. If implicit timezones are set depending on the locale or preferences of the individual user, this means that two xs:dateTime values that appear equal for one user might appear not equal for another — but this can only happen in the situation where one of the values has an explicit timezone and the other does not.  In most cases it is likely that xs:date values will be stored without a timezone, in which case the test whether two dates are equal is straightforward. If a date does have a timezone, then it is a signiﬁcant part of the value. Dates are equal if their starting instants are simultaneous, which will normally happen only if they have the same timezone  the exception occurs near the International Date Line — today’s date in timezone −12:00 compares equal with tomorrow’s date in timezone +12:00 . If one date has a timezone and the other does not, the implicit timezone is used in the comparison in the same way as for xs:dateTime values. This happens whenever you compare the result of current-date   with a simple date such as «2008-01-01» — the implicit timezone is used for the simple date, and this is always the same as the timezone used by the current-date   function.  Values of type xs:time are considered to represent times on the same day, and are then compared in the same way as xs:dateTime values. This means, for example, that «02:00:00Z» and «21:00:00-05:00»  2 a.m. in London and 9 p.m. in New York  are considered not equal — they are 24 hours apart.  8  X P a t h :  O p e r a t o r s  o n  I t e m s  continued  583   XPath: Operators on Items  Data type  xs:gYear xs:gYearMonth xs:gMonth xs:gMonthDay xs:gDay  xs:QName  xs:base64Binary xs:hexBinary  xs:NOTATION  xs:duration  Deﬁnition of eq Values of these types are comparable only with other values of the same type. Since all of these types allow an optional timezone, they follow the same rules as xs:date. In fact, one way of deﬁning equality is by converting the values to xs:date values by supplying arbitrary values for the missing components and then comparing the resulting dates.  Two xs:QName values are equal if they have the same namespace URI  or if both have no namespace URI  and if they have the same local name. Both the URI and the local name are compared in terms of Unicode codepoints, no collation is used. The preﬁx part, if any, is ignored.  Although these two types share the same value space, it is not possible to compare one with the other directly: you have to cast the value ﬁrst. For each of the types, values are equal if they consist of the same sequence of octets.  The value space of xs:NOTATION is the same as the value space of xs:QName and xs:NOTATION values are compared in the same way as xs:QName values. However, you cannot compare an xs:QName to an xs:NOTATION.  An xs:duration value is considered to comprise an integer number of months plus a decimal number of seconds. Two durations are considered equal if the months parts are equal and the seconds parts are equal. This means, for example, that PT1H equals PT60M. It also means that the zero-length xs:yearMonthDuration is equal to the zero-length xs:dayTimeDuration.  The «ne» operator is the exact inverse of «eq»: if an «eq» comparison raises an error, then «ne» also raises an error; if «eq» returns true, then «ne» returns false, and if «eq» returns false, then «ne» returns true. This applies even for peculiar cases like NaN: if the value of $x is NaN, then «$x eq $x» is false, while «$x ne $x» is true. Another reassuring feature of these operators is that if «$a eq $b» is true, then «$b eq $a» is also true.  It’s worth mentioning these things because as we’ll see later in the chapter, when it comes to the «=» and «!=» operators it’s best not to make any assumptions .  The other four operators in this group, «lt», «le», «gt», and «ge», work only for data types that are ordered. The data types that have an ordering, and the way the ordering works, are deﬁned in the table below. Data type xs:string or xs:anyURI  Deﬁnition of ordering An xs:anyURI value is treated as a string. The ordering of strings is determined by a collation, in the same way as equality comparison. These operators use the default collation established in the XPath evaluation context, as described in Chapter 7. There’s a tension between equality comparison and ordering comparisons: for testing equality, you often want a weak collation; for example, one that compares «yes» and «YES» as equal. But for ordering, you often want to put the strings in some kind of order, even if it’s fairly arbitrary, so you want «yes» either to be less than «YES», or greater than it  that is, you want a strong collation . If you want to use different collations for different operations, you can achieve this by using the compare   function described in Chapter 13, but for the «eq» and «lt» family of operators, you have to choose a single collation that may be a compromise.  continued  584   Data type Numeric  xs:boolean  xs:dateTime  xs:date  xs:time  xs:gYear xs:gYearMonth xs:gMonth xs:gMonthDay xs:gDay xs:QName xs:base64Binary xs:hexBinary xs:NOTATION  xs:duration  Value Comparisons  Deﬁnition of ordering Any two numeric values can be compared  xs:integer, xs:decimal, xs:float, or xs:double . If they are of different types, one value is ﬁrst promoted to the type of the other in the same way as arithmetic operators  see page 571 . They are then tested for numeric order  this means, for example, that «10» is greater than «2» . The value false is considered, quite arbitrarily, to be less than true. One xs:dateTime value is considered less than another if it represents an earlier instant in time. As with equality testing, the two values are adjusted to a common timezone using the implicit timezone from the evaluation context if the value does not have its own timezone. The effect is, for example, that «2008-01-01 T01:00:00Z» is less than «2007-12-31 T23:00:00-05:00». In XML Schema, xs:date values are described as being partially ordered. This means that for some pairs of dates, one of them is clearly earlier than the other, but for other pairs  in particular, a pair of dates in which one has a timezone and the other does not  it’s impossible to decide. Putting such a rule into a query language would have been impossibly complex, so instead the decision is made by interpreting all dates without a timezone as being in the implicit timezone deﬁned by the evaluation context. The rule is that one date is less than another if it starts earlier than the other one starts, even if the two dates overlap: for example, «2008-01-01+10:00» is less than «2008-01-01Z» because the New Year starts earlier in Sydney than it does in London. Values of type xs:time present a particular problem for ordering, because the values are cyclic. Converting both values to the UTC timezone would produce some strange results; for example, it would make «18:00:00-05:00» greater than «20:00:00-05:00», because the equivalent UTC times are «23:00:00Z» and «01:00:00Z», respectively. So instead, the two times are considered to be on the same date  it doesn’t matter what date you choose  and are expanded to xs:dateTime values by using that date. They are then compared in the same way as xs:dateTime values. This doesn’t remove all anomalies, but it does make the results reasonably intuitive whenever the two times are in the same timezone. These types have no ordering deﬁned. Using any of the operators «lt», «le», «gt», «ge» with values of these types is a type error. There’s no particular reason for this restriction — in most of these cases it would have been quite possible to deﬁne a useful ordering — but the working groups decided it wasn’t needed.  8  X P a t h :  O p e r a t o r s  o n  I t e m s  xs:duration values themselves are not considered to be ordered, so the operators «lt», «le», «gt», and «ge» are not available. This removes the problem of deciding whether 30 days is less than, equal to, or greater than one month. The two XPath subtypes of xs:duration, namely xs:yearMonth- Duration and xs:dayTimeDuration, are much more well behaved. The effect of comparing them is the same as converting the value to a number of months, or a number of seconds, and comparing the two numbers. This means, for example, that «PT36H»  36 hours  is greater than «P1D»  one day .  585   XPath: Operators on Items  In nearly all cases the four operators have the obvious relationship to each other; for example, if «$a lt $b» is true, then «$a le $b» is also true, as is «$b gt $a». The one exception is the xs:double  and xs:float  value NaN. If NaN appears as either operand of any of these four operators, or as both operands, then the result is always false.  Type Checking for Value Comparisons  The operands in a value comparison are processed according to the following rules. These rules apply to all six operators. Note that there are no special backward-compatibility rules here, because these operators were not available in XPath 1.0.  1.  2.  3. 4.  5.  6.  Each of the operands is atomized, as described on page 220 in Chapter 5. This means that when you supply a node as the argument, the typed value of the node is extracted. If either operand  after atomizing  is a sequence containing more than one value, then a type error occurs. If either operand  after atomizing  is an empty sequence, the result is an empty sequence. If either of the operands  after atomizing  is of type xs:untypedAtomic  which will generally be the case if the value has been extracted from an element or attribute in a schema-less docu- ment , then it is converted to a string  a value of type xs:string . This is true even if the other operand is a number. If the two values are not comparable then a type error occurs. This can happen because their types are incompatible with each other  for example one is an xs:string and the other an xs:decimal , or it can happen because both values belong to a type for which ordering is not deﬁned, such as xs:QName. Otherwise, the values are compared according to the ordering rules for their data type, as described in the table in the previous section.  There are a couple of controversial decisions reﬂected in these rules.  The ﬁrst is that either operand is allowed to be an empty sequence. The speciﬁcation vacillated on this question in early drafts.  The main argument in favor of allowing an empty sequence is that the empty sequence should behave like a null value in SQL — any operator or function that has «  » as an argument should return «  » as a result. This also makes it easier to handle optional elements and attributes. This principle has not been followed systematically throughout the language, but it is followed by most of the operators. At one stage the language design also included SQL-like three-valued logic, but this was dropped, largely because it was incompatible with XPath 1.0. In most cases, XPath 1.0 and now also XPath 2.0 treat absent data in almost exactly the same way as SQL, but without relying on three-valued logic. For example, in an expression such as «  item[@code eq 3]», items that have no code attribute will not be selected. Equally, if you write «  item[@code ne 3]», items that have no code attribute will not be selected.  In both cases, the value of the predicate is an empty sequence, and the effective boolean value of an empty sequence is false . But unlike SQL, the XPath expression «  item[not @code=3 ]» does select items with no code attribute. The SQL rule that «not null » returns «null» has no parallel in XPath.  The argument in favor of disallowing an empty sequence was to maximize the freedom of the opti- mizer to rearrange predicates, so as to make use of indexes. Although the current rules do not compro- mise transitivity, they do make other rewrites impossible; for example, the expressions «A ne B» and «not A eq B » are no longer equivalent.  586   8  X P a t h :  O p e r a t o r s  o n  I t e m s  Value Comparisons  The other controversial decision is that xs:untypedAtomic values are converted to strings regardless of the type of the other operand. Taking again the example «@code eq 3», this means you will get a type error if the source document has no schema, because you can’t compare a string to a number. This rule was introduced in order to make equality transitive. For example, suppose @code is an untyped attribute whose string value is «4.00». Then «@code eq "4.0"» and «@code eq 4.0e0» would both be true  one is a string comparison and the other a numeric comparison , and since «4.0 eq 4.0e0» is true, transitivity would then require that the string comparison «"4.0" eq "4.0e0"» is also true. This clearly isn’t feasible; as strings, these values are not the same thing.  Despite all the efforts to make the eq operator transitive, it turns out that in corner cases, it isn’t. This problem arises because of the numeric promotion rules. Given three numbers xs:float ’1.0’ , xs:decimal ’1.0000000000100000000001’ , xs:double ’1.00000000001’ , the ﬂoat and the double are both equal to the decimal, but they are not equal to each other. This turns out to create quite a problem for operations that rely on transitivity, notably the distinct-values   function and the   instruction.  Examples of Value Comparisons  Expression  $x eq 2  count $x  gt 2  @x eq "yes"  @retirement-date ge current-date    Description This is true if $x is a sequence of exactly one item, and that item is an instance of xs:double, xs:float, or xs:decimal  or a type derived from these by restriction  that is numerically equal to 2. It is also true if the single item in $x is a node whose typed value is one of these numeric types and is numerically equal to 2. The result is false if the item in $x is a different numeric value, and it is effectively false if $x is empty. If $x contains more than one item, or contains a non-numeric value, or if it is an untyped node, the result is an error.  This is true if the number of items in the sequence $x is 3 or more, and it is false otherwise. No type error can occur in this case, because the value returned by the count   function will always be an integer, and count   accepts any type of value as its argument.  This is true if the context node has an attribute named x, and the type of that attribute is either xs:string or xs:untypedAtomic or a type derived from xs:string by restriction, and the value of the attribute compares equal to the string «yes» under the rules of the default collation  which is context-dependent . If the attribute doesn’t exist, then the effective value is false. If the attribute has a different type, the result is a type error.  This is true if the context node has an attribute named retirement-date, and the type of that attribute is xs:date or a user-deﬁned type deﬁned as a restriction of xs:date, and the value of the attribute is the same as or after the current date. In the unlikely event that the retirement-date attribute has a timezone associated with it, this will be taken into account in the comparison; if not, the implicit timezone is used, which will always be the same as the timezone used in the result of the current-date   function. If the retirement-date attribute does not exist the effective result is false. If the attribute has any type other than xs:date, including the case where it has type xs:untypedAtomic, a type error occurs.  587   XPath: Operators on Items  General Comparisons  The term general comparisons is used for expressions involving the six operators «=», «!=», «<», «<=», «>», and «>=». These operators are retained and generalized from XPath 1.0. As we shall see, they are considerably more powerful than their counterparts used in value comparisons, but this also means that they may be rather more expensive, and they can also lead to a few surprises — they don’t always give the answer you expect.  The syntax for these operators has already been given, because they are combined into the same production rules as the simpler operators «eq», «ne», «lt», «le», «gt», and «ge», which are given on page 582.  General comparisons are more powerful than value comparisons in two ways:        General comparisons allow either or both operands to be sequences  of zero, one, or many items , whereas value comparisons require the operands to be single items. General comparisons are more ﬂexible in the way they handle untyped atomic values  that is, data from schema-less documents . In particular, the way an untyped value is handled depends on the type of the value that it is being compared with.  In addition, general comparisons have special rules for use when backward-compatibility mode is selected  in XSLT, this applies when the version attribute is set to «1.0» .  Remember that if you are embedding your XPath expressions in an XML document — for example, an XSLT stylesheet or an XML Schema — then the «<» character must be escaped as «&lt;». Many people also like to escape «>» as «&gt;», though this is not strictly necessary.  Changes in XPath 2.0  Despite the special rules for handling backward-compatibility mode, the general comparison operators are probably the area where incompatibilities between XPath 1.0 and XPath 2.0 are most likely to be encountered. This is mainly because of the generalization of the data model to handle sequences, and also because of the increased range of data types. XPath 1.0 only supported four data types  string, number, boolean, and node-set . Given two operands, and allowing for symmetry, there were therefore 10 possible combinations of operand types, and each of these was described separately. Because there was little consistency to the XPath 1.0 rules, generalizing them to handle a much richer set of data types proved difﬁcult.  The incompatibility that you are most likely to hit is when comparing strings, or untyped nodes. In XPath 1.0, an equality comparison  «=»  between two nodes  all nodes were untyped in those days  treated both values as strings, while an ordering comparison  «<»  treated them as numbers. This led to oddities such as the fact that «"2"="2.0"» was false, while «"2" ="2.0"» were both true. This has been swept away in XPath 2.0; if you compare two strings, or untyped values, using any of these operators, then they are compared as strings, using the default collation deﬁned in the XPath evaluation context. So if you have an expression such as «@discount < @max-discount», and the element in question is  , then XPath 1.0 would return true, while XPath 2.0 returns false. The solution is to make sure that if you want a numeric comparison, you force it by converting the values explicitly to numbers, for example, by using the number   function  which is described in Chapter 13 .   Note that this problem only occurs if both values are strings. It’s much more common to see expres- sions in which one value is a string and the other is a number; for example, «@price>10.00», and these continue to work as before.   588   General Comparisons  Another incompatibility occurs when comparing a sequence of nodes to a boolean value. In XPath 1.0, «$node-set=true  » was true if the node-set was nonempty. In XPath 2.0, a sequence compares equal to true    if, after atomization, it contains an item that is equal to true   . This is a pretty radical change in meaning, but fortunately this kind of expression occurs very rarely in practice.  In both the above cases, the XPath 1.0 behavior is retained when you run in backward-compatibility mode. The new behavior occurs only when you change the version attribute in your stylesheet to say «version="2.0"».  Rules for General Comparisons  I will present the rules ﬁrst and then discuss their consequences.  1.  2.  3.  4.  5.  8  X P a t h :  O p e r a t o r s o n  I t e m s  In backward-compatibility mode, if one of the operands is a singleton boolean value, then the other operand is replaced by its effective boolean value. The comparison then proceeds by apply- ing the rest of the rules, although both operands are now singletons. This rather strange rule made more sense in XPath 1.0, and it is therefore retained in compatibility mode, but it very rarely affects the outcome. For the rules on effective boolean value, see the description of the boolean   function on page 721. Each of the operands is atomized. This means that if the operand starts out as a sequence of nodes, the process turns it into a sequence of atomic values. There may be more atomic values than nodes  if some of the nodes are deﬁned in the schema to contain a list , or fewer  if some of them contain empty lists . The original operand may contain atomic values as well as nodes, and the atomization process leaves these atomic values alone. The remaining rules are applied to compare each pair of items from the two sequences, taking one value in the pair from the ﬁrst sequence and the other value from the second sequence. This means that if one sequence contains four items, and the other contains ﬁve, then each item in the ﬁrst sequence must be compared with each item in the second, giving 20 comparisons to be done in total. If any of these comparisons is true, the result of the general comparison is true. If they are all false, the result is false. If any of the comparisons fails with an error, the general comparison as a whole fails. However, it’s not deﬁned in what order the comparisons are done, so if there’s a pair of items for which the comparison is true, and another pair for which it raises an error, then the ﬁnal result might be either true or an error. Considering each pair of items from the two sequences in turn, if one item of the pair is an xs:untypedAtomic value  typically, a value extracted from a node in a schema-less document , then it is converted to a more speciﬁc type. If both items in the pair are xs:untypedAtomic val- ues, then they are both converted to xs:string values. If only one item is an xs:untypedAtomic value, then it is converted to the type of the other item. There is a special rule when the second item is numeric: in this situation the xs:untypedAtomic value is always converted to an xs:double value. This caters for a situation such as comparing the untyped value «2.1» with the xs:integer value «2»; it would be unreasonable to convert the value «2.1» to an integer before doing the comparison. There is now a further rule that comes into play only when backward-compatibility mode is enabled. This is that if one of the items in the pair is numeric, and the other is not, then the non-numeric item is converted to an xs:double using the number   function. If the value isn’t numeric, this returns NaN, and the comparison will be false. But a comparison such as «"23"=23» is allowed, and will succeed, under the backward compatibility rules. In pure XPath 2.0 mode, comparison of a string to a number is not allowed; you have to convert one of the operands explicitly to the type of the other, to make it clear whether a string comparison or a numeric comparison is intended.  589   XPath: Operators on Items  6.  Finally, after any conversions deﬁned in steps 4 and 5, the two items are compared using the rules for the corresponding value comparison operator: that is, one of «eq», «ne», «lt», «le», «gt», and «ge», depending on whether the original operator was «=», «!=», « », or «>=». If the result of this comparison is true, then no further work is needed, and the result of the whole general comparison expression is true. If the result is false, however, the process moves on to the next pair of values.  Fortunately, it’s quite rare in practice for both operands to be sequences of more than one item. This case can get very expensive, though there are plenty of ways an XPath processor can avoid actually doing M × N comparisons. It’s made more complicated by the fact that the conversion rules apply separately to each pair of items. This means that if you have the comparison «@a =  12, "pineapple" », where the node «@a» is untyped, then the untyped value has to be converted to a number to be compared with the number 12, and to a string to be compared with the string "pineapple". In the general case, it isn’t possible to do all the conversions upfront, before starting the pairwise comparison.  The more type information you can supply at compile time, the more likely it is that the XPath processor will actually know in advance that it doesn’t have to deal with these complications, because they can’t actually arise. For example, if you are writing a function in XSLT that has a parameter $p, and the function contains the test «if  $p=3  then ...», then declaring the parameter as an xs:integer  if that’s what it is  can make a world of difference — if you don’t declare its type, then the processor is going to have to assume the worst, which is that it might be an arbitrary mixture of typed nodes, untyped nodes, integers, strings, dates, and anything else the caller of the function cares to throw at it. But if you declare it as an xs:integer then the compiler can quietly replace the complex «=» operator with the much simpler and presumably faster «eq» operator. Alternatively, if you know that $p will be an integer, you can write the expression using the «eq» operator directly.  Existential Comparison  The peculiar property of these operators, namely that A = B is true if there is an item in A that is equal to an item in B, is sometimes called existential semantics — the operator is testing for the existence of a matching pair of items. This section explores the consequences of this rule..  Where a sequence $N is compared with a string "Mary", the test «$N="Mary"» is effectively a shorthand for ‘‘if there is an item $n in $N such that $n eq "Mary"’’. Similarly, the test «$N!="Mary"» is effectively a shorthand for ‘‘if there is an item $n in $N such that $n ne ’Mary’’’. If $N contains two items, whose values are ‘‘Mary’’ and ‘‘John’’, then «$N=’Mary’» and «$N!=’Mary’» will both be true, because there is an item that is equal to ’Mary’ and another that is not. If $N is an empty sequence, then «$N=’Mary’» and «$N!=’Mary’» will both be false, because there is no item that is equal to ’Mary’, but there is also no item that is not equal to ’Mary’.  Note that when the operand is a sequence of nodes, we are only concerned with the nodes that are members of the sequence in their own right. The children of these nodes are not members of the sequence. So if $N is the element:      Mary   John      590   General Comparisons  then «$N="Mary"» will not return true. In this case $N is a singleton sequence. Its only item is the   element, and that element is not equal to "Mary". In fact, with a schema-aware processor this comparison might well throw an error, on the grounds that the   node cannot be atomized. To perform an existential comparison for this example, you should write «$N person="Mary"». In this expression, $N person is a sequence of two   nodes, and one of them is equal to "Mary".  So, these examples show some of the surprises in store:           You can’t assume that «$X=$X» is true. It usually will be, but if «$X» is an empty sequence, it will be false, because there is no item in the ﬁrst sequence that is equal to an item from the second. You can’t assume that «$X!=3» means the same as «not $X=3 ». When «$X» is a sequence, the ﬁrst expression is true if any item in the sequence is not equal to 3, while the sec- ond is true if no item in the sequence is equal to 3. Generally speaking, it is best to steer clear of the «!=» operator unless you know exactly what you are doing. Use «not x=y » instead; it is more likely to match the intuitive meaning. You can’t assume that if «$X=$Y and $Y=$Z», then «$X=$Z». Again, sequences are the culprit. Two sequences are considered equal if there is a value that both have in common, so « 2,3 = 3,4 » is true, and « 3,4 = 4,5 » is true, but « 2,3 = 4,5 » is false.  In this strange Orwellian world where some values seem to be more equal than others, the one consola- tion is that «$X=$Y» always means the same as «$Y=$X».  Although «!=» is often best avoided, it can be useful to test whether all items in a sequence have the same value. For example, writing   tests whether there is any node in the sequence «$documents  version» whose numeric value is not 1.0. However, it is probably less confusing to write the above test as:  8  X P a t h :  O p e r a t o r s  o n  I t e m s  <xsl:if test="every $d in $documents  version  satisfies $d eq 1.0">  The «some» and «every» expressions are described in Chapter 10.  It is important to remember that an equality test compares the typed values of the nodes, not their iden- tity. For example, «..= » might seem to be a natural way of testing whether the parent of the context node is the root of the tree. In fact this test will also return true if the parent node is the outermost ele- ment, because in a well-formed  and schema-less  tree the typed value of the outermost element is the same as the typed value of the document node. Not only is the test wrong, it could also be very expensive: the value of the root contains all the text in the document, so you might be constructing two strings each a million characters long and then comparing them. XPath 2.0 provides an operator for comparing nodes by identity: you can write this test as «.. is  ». The «is» operator is described under Node Comparisons on page 593.  The rules for comparing two sequences using «=» apply equally when comparing two sequences using an operator such as «<»: the comparison in this case is true if there is some value in the ﬁrst sequence that is less than some value in the second sequence, under the rules for the «lt» operator. If all the values in the two sequences have the same data type, then the result actually follows the rules in the following table, where max   and min   represent the maximum and minimum numeric values of items in the sequence, ignoring any NaN values.  591   XPath: Operators on Items  Expression  M<N  M<=N  M>N  M>=N  Result True when min M  < max N   True when min M  <= max N   True when max M  > min N   True when max M  >= min N   Examples of General Comparisons  Expression  @width=3  Description Tests whether the width attribute of the context node, after converting to a number, has the numeric value 3. If there is no width attribute, the result will be false.  If the width attribute exists and is typed as numeric, the result will be true if and only if the numeric value is equal to 3. If the width attribute exists and is untyped, the result will be true if the width attribute can be converted to a number equal to 3; for example, if it is «3» or «3.00». If the width attribute is deﬁned in the schema as a list-valued attribute, then the result is true if any of the values in this list is equal to 3.  @width= 10, 20, 30  Tests whether the width attribute has the value 10, 20, or 30.  If the attribute is untyped, it is compared as a number. If the attribute is deﬁned in the schema as being list-valued, then the comparison is true if any item in the list is equal to 10, 20, or 30.  @width !=$x  If there is no width attribute the result will be false.  If the attribute width is untyped, then if the variable $x holds a numeric value, a numeric comparison is performed; if it holds a string value, a string comparison is performed. The result will be true if the values are different.  If the attribute width is typed, then an error will occur if the type is incompatible with the type of $x.  If $x holds a sequence, the result will be true if there is any item in the sequence whose typed value is not equal to the width attribute, using string comparison; it will be false if the sequence is empty. If the schema-deﬁned type of the width attribute is a list type, then the comparison is performed with each item in that list considered individually.  count * >10  Returns true if the context node has more than ten element children.  sum SALES <10000  Returns true if the sum of the numeric values of the   children of the context node is less than 10,000.  position  < last   div 2  Returns true if the context position is less than half the context size, that is, if the position of this node is less than half way down the list of nodes being processed.  not   @temp<=0.0   Returns true if all values of the temp attribute in the document are numeric, and greater than zero.  592   8  X P a t h :  O p e r a t o r s  o n  I t e m s  Node Comparisons  Node Comparisons  This section describes the three operators « >», which are used to compare nodes. The «is» operator tests whether the two operands evaluate to the same node; the operators « >» test whether one node is before or after another in document order.  The syntax has already been covered under Value Comparisons on page 581: these operators are deﬁned by the same production rule that deﬁnes the value comparison operators  the «eq» family  and the general comparison operators  «=» and friends .  For all three operators, each operand must be either a single node or an empty sequence. If either operand is an empty sequence, the result is an empty sequence  which will be treated as false if it is used in a boolean test such as a predicate . If either operand is a sequence containing more than one item, or an item other than a node, then a type error is reported.  The «is» Operator  The «is» operator tests whether both operands evaluate to the same node. The nodes must be identical; it’s not enough to have the same name or the same value, they must actually be the same node.  Terminology here can get messy. If two nodes are identical, then they are one node, not two. Better perhaps to say that two values are references to the same node  but that’s not the language of the W3 C specs . Identity causes other problems: it doesn’t ﬁt well into a language that in most other respects is purely functional. For example, if you write a function f   in XSLT or XQuery that creates and returns a new element node, then the expression «f   is f  » returns false, because each time f   is called, it creates a node with distinct identity. This breaks the rule that applies to all other XPath function calls, namely that calling the same function repeatedly with the same arguments and the same evaluation context always returns the same result.  Here’s an example of how the «is» operator can be used. Sometimes you have a sequence of elements such as:              and you need to select all the   elements that follow a particular   element, up to the next   element.  I have shown all the elements as empty because we’re not interested in their content for this example.  Let’s suppose that the variable $H identiﬁes the   element where you want to start. The expression «$H following-sibling::p» selects all the   elements after the start element, but it doesn’t stop when it reaches the next  . You want to select only the   elements whose immediately preceding   element is $H. Here is the expression to do this:  $H following-sibling::p[preceding-sibling::H1[1] is $H]  Another way of solving this problem would be to write:  $H following-sibling::p except $H following-sibling::H1 following-sibling::p  but I think the solution using the «is» operator is likely to be more efﬁcient.  The «except» operator is described in Chapter 9, on page 628.   In XSLT 2.0, problems like this can also be tackled using the construct <xsl:for-each-group group-starting-with="H1">. See Chapter 6, page 340.  593   XPath: Operators on Items  The operators « >»  The operators « >» test whether one node is before or after another in document order. For example, «$A << $B» is true if and only if $A precedes $B in document order. The concept of document order is described in Chapter 2, on page 57.  There is no requirement that the two nodes should be in the same document. Document order is deﬁned as an ordering of all the nodes encountered, across all documents. If nodes are in different documents, then you can’t predict which one will be ﬁrst in document order, but although the answer is arbitrary, it will be consistent within a single run.  Consider again the problem given in the previous section, where the input has the form:              Another way of ﬁnding all the   elements that follow an   element identiﬁed by the variable $H is:  $H following-sibling::p[not $H following-sibling::H1[1] << . ]  This selects those   elements that are before the next   element. Note the careful construction of the predicate, which is designed to work even when $H does not have a «following-sibling::H1». It works because when one of the operands of «<<» is an empty sequence, the result of the comparison is an empty sequence, which is treated as false. If the expression were written:  $H following-sibling::p[$H following-sibling::H1[1] >> .]  then it would not select any   elements after the last   element.  Changes in XPath 2.0  These three operators are new in XPath 2.0.  In XPath 1.0 the only way to test whether two variables $A and $B referred to the same node was to write something like «count $A$B  = 1». This relies on the fact that the union operator «» removes duplicate nodes. If you see this construct when upgrading existing code to XPath 2.0, using the «is» operator will almost certainly be more efﬁcient.  In an XSLT 1.0 stylesheet, nodes could also be compared for identity using the expression «generate-id  $A  = generate-id $B ». Again the «is» operator is more direct and more likely to be efﬁcient.  Boolean Expressions  This section concludes the chapter with a description of the operators «and» and «or».  There is no «not» operator in XPath, it’s provided as a function instead, and is described in Chapter 13, on page 850.  Expression  Syntax  OrExpr  AndExpr  594  AndExpr   «or» AndExpr  *  ComparisonExpr   «and» ComparisonExpr  *   8  X P a t h :  O p e r a t o r s  o n  I t e m s  Boolean Expressions  The syntax shows that the «and» operator binds more tightly than «or», so that «A and B or C and D» means « A and B  or  C and D ». Personally, I prefer to use parentheses to avoid any doubt.  The fact that an AndExpr is deﬁned in terms of a ComparisonExpr just means that the family of operators including «=» and «eq» are next in precedence order after «and». These operators were described earlier in this chapter.  An «or» expression returns true if either of its operands is true, while an «and» expression returns true if both of its operands are true.  The operands of «and» and «or» are converted to xs:boolean values by taking their effective boolean value. This applies the same rules as for the conditional  «if»  expression described in Chapter 7, and the boolean   function, described in Chapter 13. For example, a string is false if it is zero-length, and a sequence is false if it is empty.  Shortcut Semantics  XPath 1.0 deﬁned that the right-hand operand of «and» or «or» wasn’t evaluated if the result could be established by evaluating the ﬁrst operand  that is, if the ﬁrst operand was false in the case of «and», or true in the case of «or» . The reason for this rule was to give clearly deﬁned behavior in the event of errors occurring. In XPath 2.0, the language designers have decided to sacriﬁce some of this predictability in favor of giving the implementation maximum freedom to rearrange expressions so that indexes can be used. For example, suppose you write an expression like this, to select all the male employees who are retiring today:    employee[@sex=’M’ and @retirement-date=current-date  ]  The XPath 1.0 rules say that you can’t look at the retirement date until you’ve established that the employee is male. But if you have a hundred thousand employees, and they are indexed on their date of retirement, then the most efﬁcient strategy would be to use the index, ﬁnd the employees who are retiring today, and then select those among them who are male. The reason the rules were changed in XPath 2.0 is to allow systems to use this more efﬁcient strategy.  Suppose you know that for female employees only  for some reason  the value of the retirement-date attribute might not be a date at all, but the string value «standard». A schema can be deﬁned using a union type that allows the value to hold either a date, or this special value. The XPath 1.0 rules guaranteed that you would never look at the retirement-date attribute of female employees while evaluating the expression, which would mean that you can never get the error that occurs when comparing the string «standard» to a date. The XPath 2.0 rules don’t give you this guarantee. To protect yourself against the failure, you could write:    employee[if  @sex=’M’   then @retirement-date = current-date   else false  ]  Unlike the «and» and «or» operators, the «if» expression does give you a guarantee: if the condition is false, the «then» branch will not be executed. Similarly, if the condition is true, the «else» branch will not be executed.  Another situation where these rules matter is if one branch contains a call on an external function that has side effects. Writing such functions is something that’s been left very much implementation-deﬁned, but many XPath implementations will allow calls to external routines, and once they allow that, it’s  595   XPath: Operators on Items  impossible to prevent such functions having arbitrary side effects. If you want to prevent a subexpression being evaluated because it has side effects, the only reliable way to ensure this is with an «if» expression; don’t rely on «and» and «or».  Note that there are no null values in XPath, as there are for example in SQL, and there is therefore no need for three-valued logic to handle unknown or absent data. Instead, you may need to test explicitly for absent values, as shown in some of the examples below.  Description Returns true if the value of variable $x is greater than 3 and less than 8.  Returns true if the context node has both a name and an address attribute.  Both the operands are sequences of nodes, which are converted to the xs:boolean true if they contain at least one node, and to false if they are empty .  Returns true if the context node has both a name and an address attribute and if neither is a zero-length string.  Both the operands are strings, which are converted to the xs:boolean true if their length is non-zero. If an attribute is absent, the sequence will be empty, and its string value will therefore be the empty string .  A trivial AndExpr consisting of a single function call.  Returns true if the variable $x has the value 5 or 10. This could also be written as «$x =  5, 10 ».  Returns true if the context node has a name attribute, an id attribute, or both.  not @id  or @id=""  Returns true if the context node has no id attribute or if it has an id attribute and the value is an empty string.  Selects the   elements that are either the ﬁrst or the last  or the only    children of their parent node.  Examples Expression  $x>3 and $x<8  @name and @address  string @name  and string @address   true    $x=5 or $x=10  @name or @id    para[ position  =1 or position  =last  ]  Summar y  596  This chapter described the following groups of XPath operators:                 Arithmetic operators, «+», «-», «*», «div», and «mod» Value comparison operators «eq», «ne», «lt», «le», «gt», «ge» General comparison operators «=», «!=», « », «>=» Node comparison operators « >» Boolean operators «and» and «or».   Summary  Many of these operators behave in a way that is likely to be familiar from other languages, though there are differences because of the different data model, in particular, the fact that everything in XPath is a sequence.  The next chapter describes the most distinctive feature of the XPath language, namely path expressions. Unlike the operators in this chapter, these are quite unique to XPath.  Looking further ahead, Chapter 10 is devoted to operations used to process sequences. The tour of the language syntax ﬁnishes in Chapter 11, which describes operations on types. Chapter 12 returns speciﬁ- cally to XSLT with a description of match patterns, which use a subset of the XPath syntax. The standard functions available in XPath and XSLT are described in Chapter 13.  8  X P a t h :  O p e r a t o r s  o n  I t e m s  597    XPath: Path Expressions  This chapter deﬁnes the syntax and meaning of path expressions. Path expressions are the most distinctive feature of the XPath language, the construct that gives the language its name. The chapter also describes other constructs in the language that are closely associated with path expressions, in particular steps and axes and the «union», «intersect», and «except» operators.  Path expressions are used to select nodes in a tree, by means of a series of steps. Each step takes as its starting point a node, and from this starting point, selects other nodes.  Each step is deﬁned in terms of:  9  X P a t h :  P a t h  E x p r e s s o n s  i           An axis, which deﬁnes the relationship to be followed in the tree  for example, it can select child nodes, ancestor nodes, or attributes  A node test, which deﬁnes what kind of nodes are required, and can also specify the name or schema-deﬁned type of the nodes Zero or more predicates, which provide the ability to ﬁlter the nodes according to arbitrary selection criteria  Because they are closely associated with processing the results of path expressions, this chapter also describes the operators used to combine two sets of nodes by taking their union, intersection, or difference.  Although I’ve chosen Path Expressions as the title for this chapter, the term is actually a slippery one. Because of the way W3 C deﬁnes the XPath grammar, all sorts of unlikely constructs such as «2» or «count $x » are technically path expressions. The things I will actually cover in this chapter are:        The binary « » operator as applied to nodes. This is used in expressions like «$chap title». There’s another use of the « » operator that applies to atomic values, in what I call a simple mapping expression, and I will cover that in Chapter 10. Axis steps, for example «ancestor::x» or «following-sibling::y[1]» , including abbreviated axis steps such as «x»  short for «child::x»  and «@y»  short for «attribute::y» . Axis steps are expressions in their own right, but they are often used before or after the « » operator. Variants on the « » operator that can be used to write abbreviated path expressions, notably « » as a freestanding expression, « » at the start of a path expression, and the «  » pseudo-operator.   What I call the Venn operators: union, intersect, and except. These are often used to combine     the results of several path expressions, or to form a step of a path expression.   XPath: Path Expressions  Examples of Path Expressions  Before describing the different kinds of path expression in more detail, it may be helpful to look at some examples.  book author first-name  Expression  para  @title  para[@id]  para @id   * para  $sections body  $sections[3] body  $sections .   contract clause[3]  subclause[2]  Description Selects all the   element children of the context node.  Selects all the title attributes of the context node. The result will either be empty or contain a single attribute node.  Selects the   elements that are children of the   elements that are children of the   elements that are children of the context node.  Selects all the   element children of the context node that have an id attribute.  Selects the id attributes of all the   element children of the context node. This differs from the previous example in that the result is a sequence of attribute nodes rather than a sequence of element nodes.  Selects all the   element children of the containing document element  that is, of the outermost element of the document containing the context node . The «*» is a wildcard that selects all elements on the chosen axis.  Selects all   element children of nodes in the sequence identiﬁed by the variable $sections. A type error occurs if $sections contains an item that isn’t a node. The results will be in document order even if the original sequence $sections isn’t in document order.  Selects all   element children of the third node in the sequence identiﬁed by the variable $sections.  Selects all the nodes that are present in the value of the variable $sections, but with duplicates removed, and sorted into document order. The only effect of the « .» in this case is to force the reordering and deduplication.  Selects the second   of the third   of the   that is the document element. If the document element is not a  , or if any of the other components are missing, it produces an empty sequence.    figure  Selects all the   elements in the document.  city[not @name =  preceding-sibling:: city @name ]  Selects all the child   elements of the context node that do not have a name attribute that is the same as the name attribute of a preceding   element with the same parent. It thus selects a set of child   elements with unique names.  continued  600   Expression  * name    Changes in XPath 2.0  Description Selects the names of the children of the context node. The path expressions given above all select nodes in a tree. However, the « » operator can also be used as a simple mapping operator to compute atomic values for each node in a sequence; this example returns a sequence of strings, each being the name of a child element of the context node. I refer to this kind of expression as a simple mapping expression, and because this chapter is all about expressions that operate on nodes, I will cover simple mapping expressions in Chapter 10.  9  X P a t h :  P a t h  E x p r e s s o n s  i  The PathExpr construct is probably the most complex construct in the XPath language. The actual pro- duction rules are quite complicated and hard to follow, but they are there to make path expressions easy to write, especially if you are familiar with Unix-style path names for directories and ﬁles. Most of the syntactic complications arise from the range of abbreviations that are permitted, so we will cover the basic constructs and operators ﬁrst, and introduce the syntactic abbreviations later.  Changes in XPath 2.0  In XPath 2.0, the syntax of path expressions has been generalized so that any expression can be used as a step in a path. For example, «doc ‘a.xml’  id ‘Z123’ » is now a valid path expression. This makes « » behave in a similar way to other binary operators. An expression used on the left-hand side of the « » operator can be any expression that returns a sequence of nodes; the expression used on the right of « »  in effect, the last step in a simple mapping expression  can also return atomic values.  In XPath 1.0, path expressions were deﬁned to return a node-set, that is, a set of nodes with no duplicates, in no particular order. XSLT 1.0, however, always processed the resulting nodes in document order. The XPath 2.0 data model does not support node-sets as such, but by redeﬁning path expressions to return a sequence of nodes in document order with no duplicates, the result is effectively the same.  There are new facilities in XPath 2.0 to select nodes according to their schema-deﬁned type, rather than selecting them only by name. These facilities are described in detail in Chapter 11.  The constructs «.» and «..» can now be followed by predicates.  The axes are unchanged from XPath 1.0, with one exception: the namespace axis has been deprecated. This means that XPath 2.0 implementations may or may not make this axis available. All the information that was available by using the namespace axis in XPath 1.0  that is, the ability to ﬁnd all the namespaces declared for any given element  can now be obtained through two new functions: in-scope-prefixes   and namespace-uri-for-prefix  . These functions are described in Chapter 13. The reason for replac- ing the namespace axis with these functions is to allow implementations more ﬂexibility to implement namespaces efﬁciently. Modeling the information using namespace nodes imposed burdens on the implementation that offered no real beneﬁt to users; for example, the ability to do union and intersection operations on sets of namespace nodes, and the ability to get back from a namespace node to its parent element.  It is now possible to select nodes with a given local-name, regardless of their namespace. This is done using the syntax «*:local-name», which mirrors the syntax «prefix:*» that is used to select all nodes in a given namespace, regardless of their local-name.  The operators «except» and «intersect» are new in XPath 2.0, and the keyword «union» has been introduced as a synonym for «». The alternative spelling «union» has been added because it is familiar  601   XPath: Path Expressions  from SQL, and because the operator «» can get rather lost visually when it is used to combine the results of two complex «for» expressions. This applies especially to XQuery, where the operator may often be used to combine the results of two FLWOR expressions that might each be a dozen lines long  FLWOR expressions are XQuery’s equivalent to the SELECT statement of SQL . Document Order and Duplicates  There are three kinds of expression in XPath 2.0 whose result is always guaranteed to be a sequence of nodes in document order, with no duplicates. They are all covered in this chapter. Speciﬁcally, they are:           Any expression using the unary or binary path operator « », or the pseudo-operator «  », unless the expression on the right-hand-side of the operator returns atomic values rather than nodes Any axis step  even an axis step like «preceding-sibling::*» that uses a reverse axis delivers its results in forwards document order  Any expression using one of the binary operators «union», «intersect», and «except».  The elimination of duplicates is always based on node identity, not value.  Many simple path expressions naturally return results in document order anyway and would never select duplicates. In these cases, the system doesn’t have to do any extra work to satisfy this rule. For example, any path expression that does downward selection using the child axis will naturally retrieve the nodes in document order. But it’s easy to come up with path expressions that don’t have this property; for example, «following-sibling::* ..» selects the parents of all the following siblings, and of course they all have the same parent, so after eliminating duplicates this expression returns at most a single node.  Generally, the automatic sort into document order is a choice that avoids surprises, especially when processing loosely structured text: if an expression selects a number of text nodes in a document, then document order is the order that is most likely to retain the meaning. The only situation that can some- times be confusing is when you write an expression such as «$sorted-employees name» where the sequence in $sorted-employees has been carefully sorted into some logical order  for example, sorting employees by length of service . You can’t do this kind of sorting in XPath alone, but it’s easily done in XSLT or XQuery. In this situation, the « » operator destroys the ordering and gives you the names of the employees in document order. The solution in this case is to use a «for» expression instead of a path expression, as described in Chapter 10.  There is no speciﬁc function in XPath to take an existing sequence and reorder it in document order, but you can achieve this easily by writing the dummy path expression «$seq .», or if you prefer, by taking the union with an empty sequence: «$seq  ».  The Binar y «  » Operator  Informally, we could say that a path expression is a sequence of steps separated by « » or «  ». This is reﬂected in the syntax rule:  Syntax  Expression  RelativePathExpr  StepExpr  602  Syntax  StepExpr    « »  «  »  StepExpr  *  AxisStep  FilterExpr   The Binary «  » Operator  We will come back to the pseudo-operator «  » later in the the chapter; for the moment, we will discuss the meaning of « ». Moreover, we will conﬁne ourselves for the moment to the case where the expres- sion on the right hand side of « » selects nodes  we will see in Chapter 10 that the operator can also be overloaded to select atomic values . Understanding this operator is the key to understanding path expressions.  An arithmetic expression such as «A+B+C» can be decomposed into the form « A+B +C », and deﬁned in terms of a binary «+» operator that takes two operands. Similarly, a path expression of the form «A B C» can be decomposed into « A B  C », which means that the result of a path expression is deﬁned entirely in terms of the meaning of the binary « » operator. There is a difference, however: The « » operator is a higher-order operator, because the expression used as its right-hand operand is evaluated repeatedly, once for every item in the sequence selected by the ﬁrst operand.  Effect  So what exactly does the « » operator do?  I will explain this in terms of an expression «E1 E2», where E1 and E2 are arbitrary expressions. This expression is evaluated as follows:              E1 is evaluated to produce a sequence of nodes; let’s call this S1. If the result of E1 contains an atomic value, a type error is reported. For each node in S1, the expression E2 is evaluated. The context for evaluating E2 has this node from S1 as the context node. It also has the position of this node in the sequence S1 as the context position, and the number of nodes in S1 as the context size, but in practice it’s very rare to write an expression on the right-hand side of « » that depends on the context position or size. Each time E2 is evaluated, it produces a sequence which must either consist entirely of nodes, or entirely of atomic values  if it doesn’t, a type error is reported . For the moment, we’re only inter- ested in the case where it delivers nodes; the other case is described in Chapter 10  page 644 . All the nodes produced when E2 has been evaluated once for every node in S1 are bundled together into a single sequence. Duplicate nodes are then removed, and the remaining nodes are sorted into document order. The resulting sequence of nodes forms the result of the path expression «E1 E2».  The most common kind of expression to use on the right hand side of « » is an axis step. We’ll describe axis steps in detail later in this chapter, on page 606. The syntax also allows a FilterExpr, which in effect means any expression, except that if it contains operators that bind less tightly than « »  an obvious example is «»  then it must be written in parentheses.  Let’s look at a simple example where both operands are axis steps: the expression «child::book  attribute::isbn».  I’m deliberately using the verbose syntax here, the abbreviated form is «book @isbn».  So E1 in this example is the expression «child::book», which selects all the elements that are children of the context node and have the name «book». It’s possible that the context node doesn’t have any   children, of course, in which case this will give you an empty sequence, and when that happens, the result of «E1 E2» is also an empty sequence. But let’s suppose it selects three books. For each one of these   elements, the E2 expression  in our case «attribute::isbn»  is evaluated, with that   as the context node. The step expression «attribute::isbn» selects the attribute node whose name is isbn and whose parent node is the context node. So assuming that each   element actually has an isbn attribute, the ﬁnal result contains three attribute nodes, one for each of the three books. In this case there won’t be any duplicate nodes to get rid of, and the ﬁnal result will be the sequence of three attribute nodes in document order.  603  9  X P a t h :  P a t h  E x p r e s s o n s  i   XPath: Path Expressions  As we’ve already noted, in XPath 2.0 « » is a regular operator in the sense that there are no syntactic restrictions on its operands, but it is a little unusual because it evaluates the expression on the right repeatedly. Operators and functions that work like this are often called higher-order operators, and if you’ve used functional programming languages before, you will recognize « » as behaving like a map or apply operator in such languages; it maps the sequence that’s the result of the ﬁrst expression by applying the second expression to each item in that sequence.  Another interesting thing about the « » operator is that there’s very little point using an expression on the right-hand side if its result doesn’t depend in some way on the context node. However, there is no rule that enforces this as a constraint. You can write an expression such as «$N $M» if you like, as long as $N is a sequence of nodes. If you follow through the rules given above, you’ll see that the result contains all the nodes in $M, in document order, except in the case where $N is empty, in which case the ﬁnal result is empty. During the design stage, some reviewers wanted to disallow such expressions. But on the whole, it’s not a good principle in language design to disallow things just because they aren’t useful. On that basis, you would stop people writing «$X+0», or «$X*1». There’s even a case that makes sense: «. $M» selects all the nodes in $M, in document order and with duplicates removed.  Don’t make the mistake of thinking that if $n holds the string "title", say, then «. $n» means the same as «. title». Variables in XPath represent values, not parts of an expression. To select the child elements whose name is in $n, use «*[name  =$n]».  Examples of the Binary « » Operator  The following examples illustrate that although axis steps are often used as operands of « », any kind of expression is legal:  Expression  descendant::para @style  section[1] clause[3]  chapter section para   sentence  doc ‘a.xml’  id ‘Z123’   Description In this example both operands are axis steps. The ﬁrst step selects the descendants of the context node that are   elements; the second step uses the abbreviated syntax «@style», which is short for «attribute::style», and selects the style attributes of these elements.  In this example each of the operands includes a positional predicate. The ﬁrst step selects the ﬁrst   element that is a child of the context node, the second Step selects the third   element that is a child of the selected  .  This path expression selects every   element that is a child of a   element that is a child of a   element that is a child of a   element that is a child of the context node. The expression can be decomposed into a nested set of expressions each of which uses a binary « » operator: «  chapter section  para  sentence».  This example illustrates that the operands of the « » operator do not have to be AxisStep expressions. This example selects the document with a particular relative URI, and using the resulting document node as the context node, then selects the element with a particular ID value.  continued  604   Expression  book  chapterappendix   $chap title  . title  The Binary «  » Operator  Description This is another example that uses an operand that is not an AxisStep. For each selected   element, it evaluates the expression « chapterappendix », which selects all the child   and   elements of the book, in document order.  Using a variable reference on the left-hand side of « » is very common in «for» expressions, which we will examine in Chapter 10. A typical example is «for $chap in   chapter return string-length $chap title ». This kind of construct is even more common in XQuery.  This expression means exactly the same as «title» on its own: it selects the children of the context node that are named  . Some people feel that the leading «. » adds clarity: it makes it clear to the reader that the expression depends on the context node, and distinguishes it more clearly from a variable reference «$title».  Associativity of the « » Operator  In the vast majority of cases the « » operator is associative, which means that « A B  C» returns the same result as «A  B C ». For those with insatiable curiosity, there are only three situations that I know of where this is not the case:           The expression is not associative if one of the steps creates new nodes. There is no expression in XPath itself that creates new nodes, but an XPath expression can contain a call to a function writ- ten in XSLT that creates such nodes. In XQuery, steps in a path expression can even construct nodes directly, for example, you can write «   @q». If we use the XQuery syntax for illustration, we can see that «$A ..  » eliminates duplicate nodes in the result of «$A ..», and therefore the number of   elements in the result is equal to the number of distinct nodes that are parents of nodes in $A. But the expression «$A  ..   » creates one   element for every node in $A that has a parent. So the number of   elements returned in the two cases is different. The expression is not associative if one of the steps uses the position   or last   functions. For example, consider the expression «A remove $S, position   ». The remove   function, described in Chapter 13, returns the sequence of items supplied in its ﬁrst argument, except for the item whose position is given in the second argument. This means that if A contains exactly one node, then the result is all the nodes in $S except the ﬁrst. But if A contains two nodes, then the result is the union of «remove $S, 1 » and «remove $S, 2 », which  think about it care- fully  contains all the nodes in $S. Now if we extend this to the expression «A B remove $S, position   » we can see that the result should contain all the nodes in $S except when «A B» contains exactly one node, because the expression should be evaluated as « A B  remove $S, position   ». But if it were written the other way, as «A  B remove $S, position  », the ﬁrst node in $S would be dropped only if every A has exactly one B child. Finally, « » is not associative when one step selects nodes and another selects atomic values. For example, « A ..  name  » selects one node  the parent of all the A children, that is, the node you started from  and then selects its name. However, «A  .. name   » repeats the name of the parent node as many times as there are «A» nodes.  605  9  X P a t h :  P a t h  E x p r e s s o n s  i   XPath: Path Expressions  Axis Steps  These examples are fairly pathological, but you might like to try them out on your chosen XPath processor to see how well it handles them. There may well be much simpler path expressions in which « » is not associative, but I haven’t discovered them yet!  This section discusses the expressions called axis steps. Axis steps are often used as operands of the « » operator in a path expression, which is how they got their name  a path consists of many steps . But an axis step is an expression in its own right, and it can be used on its own without any need for a « » operator. We’ve also seen that XPath 2.0 allows the operands of « » to be any kind of expression, they are no longer constrained to be axis steps. So the « » operator and axis steps have become quite decoupled in the semantics of the language. However, they are so often used together that it makes sense to retain the term path expression to describe any expression that uses either a « » operator or an axis step or both.  An axis step selects a set of nodes that are related in some way to the context node: for example, the children, the parent, or the following siblings of the context node. The relationship in question is called an axis. An axis is essentially a one-to-many relationship between nodes. If you prefer, you can think of it as a function which takes a single node as input, and produces a sequence of related nodes  for example, the children, the attributes, or the ancestors of that node  as output. Because axes are used so frequently and could be said to be the core feature of the XPath language, we don’t use the standard function call syntax, but the underlying theory can be expressed in purely functional terms.  An axis step has three parts: the axis, the node test, and the predicates. The axis and the predicates can be defaulted, but the node test is always present. These three parts are discussed in more detail in the sections that follow: axes on page 609, node tests on page 613, and predicates on page 617. In this section, we’ll start with an overview.  A step is based on a particular axis, and it can also choose to ﬁlter the nodes that are present on the axis. There are two kinds of ﬁlter that can be used, alone or in combination:        A node test allows nodes to be selected according to the kind of node, the name and namespace of the node, and  as we shall see in Chapter 11  the type annotation of the node, as determined by schema validation. The step can also include general-purpose predicates, which can specify an arbitrary boolean condition that a node must satisfy, or can select nodes at particular positions in the sequence returned by the axis.  The next section gives the syntax of axis steps.  Syntax of Axis Steps  Expression  Syntax  AxisStep   ForwardStep  ReverseStep  PredicateList  PredicateList  Predicate *  Predicate  «[» Expr «]»  ForwardStep   ForwardAxis NodeTest   AbbrevForwardStep  606  continued   Effect  Axis Steps  Expression  Syntax  ReverseStep   ReverseAxis NodeTest   AbbreReverseStep  ForwardAxis  «child ::»  «descendant ::»  «attribute ::»  «self ::»  «descendant-or-self ::»  «following-sibling ::»  «following ::»  «namespace ::»  ReverseAxis  «parent ::»  «ancestor ::»  «preceding-sibling ::»  «preceding ::»  «ancestor-or-self ::»   The split between forward and reverse axes in this grammar is cosmetic. It’s presented this way because there are semantic distinctions in the way predicates are evaluated in the two cases, and it’s nice when semantic distinctions can be related clearly to syntactic distinctions.  The abbreviations for steps will be covered later  see page 621 . For the moment, we’ll concentrate on the unabbreviated syntax in which the axis names are spelt out in full.  A step can be used to follow any axis and to ﬁnd any kind of node.  Each axis returns a set of nodes relative to a speciﬁc origin node, for example, its previous siblings or its ancestors. The axis step returns a subset of the nodes on this axis, selected by the kind of node, the name of the node, the schema-deﬁned type of the node, and the predicate expressions.  The NodeTest supplies any restrictions on the node kind, name, and type of the selected nodes, while the predicate expressions provide arbitrary boolean conditions that the nodes must satisfy, or positional ﬁlters that constrain their relative position.  The result of an axis step is always a sequence of nodes  possibly an empty sequence  with no duplicates, in document order. This is true even if the axis is one of the reverse axes, such as preceding-sibling, that selects nodes that are before the context node in document order.  For example, the step «ancestor::node  », given any starting node, ﬁnds all the ancestors of that node. When the step is used in a path expression such as «$n ancestor::node  », it returns a sequence con- taining all the ancestors of all the nodes in $n. The sequence will be in document order, which means that the outermost ancestor  the root of the tree  will appear ﬁrst in the result.  To understand the meaning of positional predicates in the step  for example «[3]»  it is often useful to think of an axis as retrieving nodes in a particular order, but the formal deﬁnition doesn’t require this. Instead these predicates are deﬁned in terms of a number assigned to each node. For a forward axis  as shown in the syntax above , the nodes are numbered to show their relative position in document order, while for a reverse axis, they are numbered in reverse document order. The effect of positional predicates  such as «booklist book[3]»  is to select those nodes whose number matches the value of the predicate. This means that if the axis is a forward axis, the positional predicate «[3]» will return the node that is third in document order; if it is a reverse axis, the same predicate will return the node that is third in reverse document order.  So the evaluation of the axis step, for a given context node, proceeds as follows:  1. 2.  All the nodes on the selected axis are found, starting at the context node. Those that satisfy the node test  that is, those of the required node kind, name, and type  are selected.  607  9  X P a t h :  P a t h E x p r e s s o n s  i   XPath: Path Expressions  3.  4.  5.  The remaining nodes are numbered from 1 to N in document order if the axis is a forward axis, or in reverse document order if it is a reverse axis. The ﬁrst  leftmost  predicate is applied to each node in turn. When evaluating the predicate, the context node  that is, the result of the «.» expression  is that node, the context position  the result of the position   function  is the number assigned to the node in stage 3, and the context size  the result of the last   function  is the largest number allocated in stage 3. A numeric pred- icate such as «[2]» or «[last  -1]» is interpreted as a shorthand for «[position   = 2]» or «[position   = last  -1]», respectively. The node is selected if the predicate is true, and it is discarded if the predicate is false. Stages 3 and 4 are repeated for any further predicates. For each predicate, the nodes that survive to this stage are renumbered 1 to N, in document order for a forwards axis, or reverse document order for a reverse axis.  Examples of Axis Steps  attribute::title  Selects attributes of the context node named title.  text  [starts-with .,‘The’ ] Selects every text node that is a child of the context node and whose  Expression  child::title  title  @title  ancestor::xyz:*  *[@width]  *[@code][position   < 10]  *[position   < 10][@code]  self::*[not @code = preceding-sibling:: * @code ]  namespace::*  self::item  Description Selects child elements of the context node named  .  Short form of «child::title».  Short form of «attribute::title».  Selects ancestor elements of the context node whose names are in the namespace with preﬁx «xyz».  Selects all child elements of the context node that have a width attribute.  text content starts with the characters «The».  Selects the ﬁrst nine child elements of the context node that have a code attribute.  Selects from the ﬁrst nine child elements of the context node those that have a code attribute.  Selects the current element node provided that it does not have a code attribute with the same value as the code attribute of any preceding sibling element.  Selects all the namespace nodes that are in scope for the context node. If the context node is not an element, the result will be empty.  Selects the context node if it is an   element, or an empty sequence otherwise. This is usually used in a predicate, for example «*[not self::item ]» selects all the children of the context node except those that are   elements. This relies on the rules for effective boolean value, whereby an empty sequence is treated as false. continued  608   Axis Steps  Description Selects all comment nodes that are children of the context node.  Short for «attribute::comment  », this selects all comment nodes on the attribute axis. The attribute axis can only contain attribute nodes, so this will always return an empty sequence; nevertheless it is a legal step.  An axis is a path through the document tree, starting at a particular node  which I’ll call the origin  and following a particular relationship between nodes. There are 13 axes deﬁned in XPath, as follows:  Expression  comment    @comment    Axes                                         ancestor ancestor-or-self attribute child descendant descendant-or-self following following-sibling namespace parent preceding preceding-sibling self  This section explains the meaning of each of the axes, giving both a textual deﬁnition and a diagram.  The diagram shows the origin node in dark shading, while the nodes on the axis are numbered in the sequence they appear on the axis. The diagram does not show attribute and namespace nodes.  Description ancestor Selects all the nodes that are ancestors of the origin node. The ﬁrst node on the axis is the parent of the origin node, the second is its grandparent, and so on; the last node on the axis is the root of the tree.  Diagram  2  1  9  X P a t h :  P a t h  E x p r e s s o n s  i  continued  609   XPath: Path Expressions  Description  Diagram  ancestor-or-self Selects the same nodes as the ancestor axis, but starting with the origin node rather than with its parent.  3  2  1  attribute If the origin node is an element, this axis selects all its attribute nodes. Otherwise, it selects nothing  an empty sequence . The result is in document order; however, document order for attributes is arbitrary and unpredictable. The attributes won’t necessarily be in the order in which they appeared in the original lexical XML, and the order may vary from one XSLT processor to another. Note also that namespace declarations are not treated as attribute nodes and will never be selected by the attribute axis.  child Selects all the children of the origin node, in document order. For any node except a document node or element node, this selects nothing. Note that the children of an element node do not include its attributes or namespace nodes, only the text nodes, element nodes, processing instructions, and comments that make up its content.  1  2  descendant Selects all the children of the origin node, and their children, and so on recursively. The resulting nodes are in document order. If the origin is an element, this effectively means that the descendant axis contains all the text nodes, element nodes, comments and processing instructions that appear in the original source document between that element’s start and end tags, in their original sequence.  610  1  2  3  4  5  6  continued   Description  Diagram  descendant-or-self This is the same as the descendant axis, except that the ﬁrst node selected is the origin node itself.  following This selects all the nodes that appear after the origin node in document order, excluding the descendants of the origin node. If the origin is an element node, for example, this effectively means that it contains all the text nodes, element nodes, comments and processing instructions in the document that start after the end tag of the origin element. The following axis will never contain attribute or namespace nodes.  following-sibling This selects all the nodes that follow the origin node in document order, and that are children of the same parent node. If the origin is a document node, an attribute node, or a namespace node, then the following-sibling axis will always be empty.  Axis Steps  1  2  3  4  5  6  7  9  X P a t h :  P a t h  E x p r e s s o n s  i  1  4  2  3  1  2  namespace If the origin node is an element, this axis selects all the namespace nodes that are in scope for that element; otherwise, it is empty. The order of the namespace nodes is undeﬁned. The namespace nodes correspond to namespace declarations  xmlns="x" or xmlns:y="z"  on the element itself or on one of its ancestor elements, but excluding any namespace declaration that cannot be used on this element because it is masked by another declaration of the same namespace preﬁx, or because it is undeclared  XML 1.1 only . For more information about namespace nodes see Chapter 2.  continued  611   XPath: Path Expressions  Description  Diagram  parent This axis selects a single node, the parent of the origin node. If the origin node is a document node, or any other node that happens to be the root of a tree, then the parent axis is empty.  1  preceding This selects all the nodes that appear before the origin node, excluding the ancestors of the origin node. If the origin is an element node, this effectively means that it contains all the text nodes, element nodes, comments and processing instructions in the document that ﬁnish before the start tag of the origin element. The preceding axis will never contain attribute or namespace nodes.  preceding-sibling This selects all the nodes that precede the origin node, and that are children of the same parent node. If the origin is a document node, an attribute node, or a namespace node, then the preceding-sibling axis will always be empty.  2  1  3  1  self This selects a single node, the origin node itself. This axis will never be empty. The self axis is generally used with a node test as a way of testing whether the context node conforms to that node test: for example, the ﬁlter expression «$nodes[self::para]» selects items in $nodes that are   elements. This could equally be written «$nodes self::para».  1  612   Axis Steps  Node Tests  An axis step always includes a node test. This tests whether a node satisﬁes speciﬁed constraints on the kind of node or the name of the node. Syntax Expression  NodeTest  NameTest  KindTest  A NodeTest is either a NameTest or a KindTest. A NameTest selects nodes by name, while a KindTest allows selection based on the kind of node  for example, elements, text nodes, or comments  and also  in the case of elements and attributes  its schema-deﬁned type.  Specifying a NameTest implicitly causes selection of a particular kind of node: attributes for the attribute axis, namespaces for the namespace axis, and elements in all other cases.  Usage  A NodeTest is used in an AxisStep to specify the name and or kind of the nodes to be selected by the Step.  In general, you specify either the name of the nodes or their kind. If you specify a NameTest, this implicitly selects nodes of the principal node kind for the axis used in the AxisStep. For the attribute axis, this selects attribute nodes; for the namespace axis, it selects namespace nodes, and for all other axes, it selects element nodes.  Specifying node   as the KindTest selects all nodes on the axis. You must specify node   if you want the AxisStep to select nodes of more than one kind.  Specifying processing-instruction   or comment   or text   as the KindTest selects nodes of the speciﬁed kind. It doesn’t make sense to specify any of these on the attribute or namespace axes, because they can’t occur there. These nodes are unnamed, except for processing instructions, which is why there is an option in this single case to specify both the node kind and the node name required.  9  X P a t h :  P a t h  E x p r e s s o n s  i  Examples of Node Tests  Expression  TITLE  news:article  Description This NameTest selects all   elements, unless it is used with the attribute axis  in the form «attribute::TITLE» or «@TITLE» , when it selects the TITLE attribute, or with the namespace axis  as «namespace::TITLE» , when it selects the namespace node whose preﬁx is TITLE.  This NameTest selects all nodes with local name «article» within the «news» namespace. These may be attribute nodes or element nodes, depending on the axis. There must be an enclosing element in the style sheet that declares the «news» preﬁx, by having an attribute of the form: «xmlns:news = "urn:newsml:iptc.org:20001006: NewsMLv1.0:1"». The node in the source document must have a name that uses this namespace URI, but it does not need to use the same preﬁx.  continued  613   XPath: Path Expressions  Expression  MathML:*  *  text    processing- instruction    Description This NameTest selects all nodes whose names are in the MathML namespace. These may be attribute nodes or element nodes, depending on the axis. There must be an enclosing element in the stylesheet that declares this preﬁx, by having an attribute of the form: «xmlns:MathML = "http:  www.w3.org 1998 Math MathML"».  This NameTest selects all elements, unless it is used with the attribute axis  in the form «attribute::*» or «@*»  when it selects all attributes, or with the namespace axis  as «namespace::*» , when it selects all namespaces.  This NodeTest selects all text nodes on the relevant axis.  This NodeTest selects all processing instructions on the relevant axis. Note that the XML declaration at the start of the document is not a processing instruction, even though it looks like one.  processing- instruction  ‘ckpt’   This NodeTest selects all processing instructions with the name  or PITarget as the XML speciﬁcation calls it  «ckpt»: for example, the processing instruction  .  node    This NodeTest selects all nodes on the relevant axis.  Name Tests  As we have seen, a NodeTest is either a NameTest or a KindTest. This section describes NameTests. A NameTest is either a name, or a generic name speciﬁed using wildcards.  Expression  Syntax  NameTest  Wildcard  QName  Wildcard  «*»  NCName«:*»  «*:»NCName  Note that a NameTest cannot contain embedded whitespace.  In general, a NameTest will match some names and will not match others.  The NameTest «*» matches any name.  But when used as an expression on its own, «*» is short for «child::*», which selects all child elements of the context node. The fact that the result is restricted to element nodes only is because «*», when used in an AxisStep, selects only nodes of the principal node kind for the axis, and for all axes except the attribute and namespace axes, the principal node kind is element nodes.   A surprising effect of this rule is that you can’t write:    to copy all attributes of an element except the title attribute. Why? Because the  Syntax  Usage  614   Axis Steps  principal node kind for the self axis is element nodes, so if the context node is an attribute named title, «self::title» won’t select it. Instead, write:     The NameTest «xyz:*» matches any name whose namespace is the one currently bound to the name- space preﬁx «xyz». The name being tested doesn’t need to use the same preﬁx, so long as it refers to the same namespace URI.  A NameTest of the form «*:code» matches any node whose local-name is code, regardless of its namespace  it will match names in any namespace, as well as names that are in no namespace .  The NameTest «xyz:code» matches any name whose namespace is the one currently bound to the name- space preﬁx «xyz» and whose local part is «code». Again, the name being tested doesn’t need to use the same preﬁx, provided it refers to the same namespace URI.  The interpretation of a NameTest such as «code»  with no namespace preﬁx  depends on the context:        If it is used with any axis other than the attribute or namespace axes, then it selects elements whose name is in the namespace identiﬁed in the XPath context  see Chapter 7  as the default namespace for element and type names. In XSLT, this is established using the [xsl:]xpath- default-namespace attribute, typically on the   element. It is not affected by a default namespace declaration of the form «xmlns="some.uri"». If it is used with the attribute or namespace axis, then it selects nodes whose namespace URI is null.  9  X P a t h :  P a t h  E x p r e s s o n s  i  If your source document uses a default namespace declaration such as «xmlns = "some.uri"», then a   element in the source document will not be selected by an XPath expression such as «  code», even if the stylesheet contains the same namespace declaration «xmlns="some.uri"». This is because in the XPath expression, the default namespace is ignored. You will either need to specify an explicit namespace declaration such as «xmlns:x="some.uri"» and refer to the element as «  x:item», or to declare an xpath-default-namespace in the stylesheet.  Note that if a default namespace for elements has been set up, then the only way to select those elements whose namespace URI is null is to include a predicate that tests the result of the namespace- uri   function.  Examples of Name Tests  Expression Description  *  xt:*  Matches any name. If «*» is used on its own, it represents the step «child::*», which selects all child elements of the context node, regardless of their name. Matches any name in the namespace bound to the preﬁx «xt». If «xt:*» is used on its own, it represents the step «child::xt:*», which selects all child elements of the context node that are in the namespace bound to the preﬁx «xt».  continued  615   XPath: Path Expressions  Expression Description title  Matches a node whose local name is name «title» and whose namespace URI is null, unless a default namespace for elements has been established in the context  and then, only when the axis is not the attribute or namespace axis .  wrox:title Matches the name that has local part «title» and whose namespace is the namespace  currently bound to the preﬁx «wrox». Matches any name whose local part is «title», whether or not it is in a namespace.  *:title  Kind Tests  As we have seen, a NodeTest is either a NameTest or a KindTest. NameTests were described in the pre- vious section; this section describes KindTests. A KindTest represents a constraint on the kind of nodes that are selected by an AxisStep. Expression  Syntax  KindTest  DocumentTest  ElementTest  AttributeTest  PITest  CommentTest  TextTest  AnyKindTest  PITest  «processing-instruction» « »  NCName  StringLiteral ? « »  DocumentTest  «document-node» « » ElementTest? « »  CommentTest  «comment» « » « »  TextTest  «text» « » « »  AnyKindTest  «node» « » « »  The constructs ElementTest and AttributeTest are used primarily to test the schema-deﬁned type of a node. These constructs are explained together with other type-related constructs on page 672 in Chapter 11.  Note that the names «comment», «text», and so on cannot be used as function names, but apart from this, they are not reserved words. It is quite possible to have elements or attributes called «text» or «node» in your source XML document, and therefore you can use «text» or «node» as ordinary names in XPath. This is why the names are ﬂagged in a KindTest by the following parentheses, for example, «text  ». The syntax rules are written so that the keyword and the following left parenthesis are treated as a compound symbol by the XPath parser, which in effect means that the parser does a look-ahead for the « » before deciding whether a keyword such as «text» is to be interpreted as a NameTest or as a KindTest.  There are three ways you can select processing instructions. The simple test is «processing- instruction  », which selects any processing instruction node regardless of its name. If you want to select processing instructions named «xml-stylesheet», say, then you can write either «processing- instruction "xml-stylesheet" » or «processing-instruction xml-stylesheet ». The two are equivalent: the syntax with quotes is retained for compatibility with XPath 1.0, while the syntax with- out quotes is introduced for symmetry with the «element . . . » and «attribute . . . » tests described in Chapter 11.  A KindTest can be used within an AxisStep to restrict the Step to return nodes of a particular kind. The keywords «comment», «text», and «processing-instruction» are self-explanatory: they restrict the  Usage  616   Axis Steps  selection to nodes of that particular kind. The keyword «node» selects nodes of any kind and is useful because an AxisStep has to include some kind of NodeTest, so if you want all the nodes on the axis, you can specify node  . For example, if you want all child nodes, specify «child::node  ». Remem- ber that although «node  » as a NodeTest selects any kind of node, «node  » as an AxisStep means «child::node  » and therefore selects only children of the context node. If you want to select attributes as well, write «@*node  ».  If you want to select all elements, you can use the KindTest element  , and if you want to select all attributes, you can use attribute  . However, it is more usual in these cases simply to use the NodeTest «*». Specifying «*» selects the nodes of the principal node kind for the selected axis, which will always be elements in the case of an axis that can contain elements, and attributes in the case of an axis that can contain attributes. The KindTests element   and attribute   are generally used with parameters that specify the schema-deﬁned type of the required elements or attributes, as described in Chapter 11.  Similarly, the KindTest document-node   can be used without parameters to select all document nodes. But you won’t see this used much in practice, because the document node can be selected using the simpler syntax « », discussed later in this chapter on page 623. With parameters, the document-node   KindTest can be used to test for the document node containing an element of a particular schema-deﬁned type — again, this is described in Chapter 11.  There is no speciﬁc KindTest for namespace nodes. But all the nodes on the namespace axis are names- pace nodes, so the expressions «namespace::*» and «namespace::node  » both work ﬁne, provided that your implementation supports use of the namespace axis.  Examples of Kind Tests  These examples show some different KindTests, used in the context of a containing path expression.  Expression  parent::node      comment    child::text    @comment    Description Selects the parent of the context node, whether this is an element node or the root node. This differs from «parent::*», which selects the parent node only if it is an element. The expression «parent::node  » is usually abbreviated to «..».  Selects all comment nodes in the document.  Selects all text node children of the context node. This is usually abbreviated to «text  ».  A strange but legal way of getting an empty node-set: it looks for all comment nodes on the attribute axis, and of course ﬁnds none.  self::attribute title  Selects the context node if it is an attribute named «title».  Predicates  We saw earlier that a step has three parts: an axis, a NodeTest  which is either a NameTest or a KindTest , and optionally a list of predicates. We’ve examined the ﬁrst two parts in the preceding sections; now it’s time to look at predicates.  A predicate is a qualifying expression used to select a subset of the nodes in a sequence. The predicate may be any XPath expression, and it is written in square brackets.  9  X P a t h :  P a t h  E x p r e s s o n s  i  617   XPath: Path Expressions  Expression  PredicateList  Predicate  Syntax  Predicate *  «[» Expr «]»  There are two very similar constructs in XPath that use predicates. They can be used in an AxisStep, to qualify the nodes selected by the axis, and they can be used in a FilterExpr, to ﬁlter any sequence. We will talk about the more general ﬁlter expressions in Chapter 10 and concentrate here on the use of predicates with an AxisStep. The meaning of the two cases is very similar, and it’s easy to use them without always being aware of the difference.  For example:  Expression  para[position   > 1]  $para[position   > 1]  Description Here the predicate «[position   > 1]» is being applied to the AxisStep «para», which is short for «. child::para». It selects all the   element children of the context node except the ﬁrst. Because the expression is an AxisStep, the results are guaranteed to be in document order and to contain no duplicates.  Here the predicate «[position   > 1]» is being applied to the value of the variable-reference «$para». The expression selects all items in the sequence except the ﬁrst. The result does not have to be in document order  it can contain atomic values as well as nodes, so document order would not make sense , and it can contain duplicates. The items in the result are returned in their original order.  In both cases the effect of a predicate is to select a subset of the items in a sequence. There’s a signiﬁcant difference when a predicate is used with a path expression of more than one step. For example:  Expression  chapter para[1]   chapter para [1]  Description Here the predicate «[1]» is being applied to the Step «para», which is short for «. child::para». It selects the ﬁrst child   element of each child   element of the context node.  This is a FilterStep where the predicate «[1]» is being applied to the sequence of nodes selected by the path expression «chapter para». The expression selects a single   element, the ﬁrst child   of a   that is a child of the context node.  In effect, the predicate operator «[]» has higher precedence  it binds more tightly  than the path operator « ».  Another distinction between the two cases is that in the case of a FilterExpr, the items are always considered in their original order when evaluating the predicate. In the case of an AxisStep, the nodes are considered in the order of the relevant axis. This is explained in more detail below.  A predicate may be either a boolean expression or a numeric expression. These are not distinguishable syntactically; for example, the predicate «[$p]» could be either. The distinction is only made at runtime.  That’s the ofﬁcial rule, anyway. If an optimizer can work out in advance whether the value is numeric  618   Axis Steps  or boolean, then it will. It’s a good idea to declare the types of your variables and parameters, which will make the optimizer’s job easier.   The following table shows some examples of boolean predicates:  Expression  section[@title = ‘Introduction’]  section[title]  title[substring- before .,‘:’ ]  Description Here the predicate is a conventional boolean expression. This example selects every child   element that has a title attribute with the value «Introduction».  The predicate is true if the relevant section has at least one child   element.  The PredicateExpr evaluates to true if the string-value of the title has one or more characters before its ﬁrst colon: that is, if the substring-before   function returns a nonempty string.  book[not author = preceding-sibling:: author ]  The PredicateExpr here is true if the author of the book is not the same as the author of some preceding book within the same parent element. The effect of this expression is to select the ﬁrst book by each author.  If the value of the predicate is a number  that is, if its type label is xs:decimal, xs:integer, xs:float, or xs:double, or some subtype of these , it is treated as a numeric predicate. If it is of any other type, it is converted to an xs:boolean value using the effective boolean value rules described in Chapter 7  these are the same as the rules for the boolean   function . So for example, the predicate «[@sequence- number]» is true if the context node has a sequence-number attribute, and is false otherwise. The actual numeric value of the attribute sequence-number is immaterial: the value of «@sequence-number» is a sequence of nodes, so it is treated as «[boolean @sequence-number ]». If you want to use the sequence number attribute as a numeric predicate, write «[number @sequence-number ]». Or, if you prefer brevity, write «[+@sequence-number]».  A numeric predicate «[P]» is simply a shorthand for the boolean predicate «[position   = P]», so you could also achieve the required effect by writing «[position   = @sequence-number]».  Note that the rules for recognizing a predicate as a number are very strict. For example, a string written as «"20"» is not considered to be a number: it’s the type label on the value that matters, not the format of the value itself. Equally, the XSLT variable declared in the example below is not a number, it is the document node at the root of a temporary tree  see the   topic in Chapter 6 :   3   If you want to use this value as a predicate, either write it so the value of the variable is a number:      but don’t write «select = "‘3’"», because that would make it a string  or force it to a number in the predicate. Any of the following will work:  9  X P a t h :  P a t h  E x p r e s s o n s  i         619   XPath: Path Expressions  As explained in Chapter 7, every expression is evaluated with a particular focus. The focus for evaluating the predicate is not the same as the focus for the expression that it forms part of. The predicate is applied separately to each node selected by the axis, and each time it is evaluated:           The context item  the item selected by «.»  is the node to which the predicate is being applied. The context position  the result of the position   function  is the number assigned to that node within the sequence of nodes. The context size  the result of the last   function  is the number of nodes in the sequence.  As we saw earlier the number assigned to a node selected by an AxisStep depends on the direction of the axis used in that AxisStep. Some axes  child, descendant, descendant-or-self, following, following- sibling  are forward axes, so the position   function numbers the nodes in document order. Other axes  ancestor, ancestor-or-self, preceding, preceding-sibling  are reverse axes, so position   numbers them in reverse document order. The self and parent axes return a single node, so the order is irrelevant. The ordering of nodes on the attribute and namespace axes is undeﬁned, so positional predicates on these axes don’t make much sense, though they are permitted.  The following table shows some examples of positional predicates.  Expression  para[1]  para[last  ]  Description Selects the ﬁrst   child element of the context node.  Selects the last   child element of the context node.  para[position  ! = 1] Selects all   child elements of the context node, other than the ﬁrst.  para[position   = 1 to 5]  Selects the ﬁrst ﬁve   elements. This works because the «=» operator returns true if the left-hand operand  position    contains a value that is equal to one of the items in the right-hand operand  1 to 5 , which is true if position   is in the range 1 to 5.  para[last  -1]  Returns the last but one   child of the context node.  para[3.2]  Returns an empty sequence. The value 3.2 is treated as a numeric predicate. The value of position   will never be equal to 3.2, so no elements are selected.  para[position  ]  Selects all child   elements. The predicate expands to «[position  = position  ]», which is always true.  para[position  -1]  Returns an empty sequence. The predicate expands to «[position   = position  -1]», which is always false.  para[number @nr ]  Returns every child   element that has a nr attribute whose numeric value is equal to the position of the   element in the sequence. This rather perverse example illustrates that specifying a numeric predicate gives no guarantee that at most one node will be selected.  An AxisStep can contain a sequence of zero or more predicates. Specifying two separate predicates is not the same thing as combining the two predicates into one with an «and» operator. The reason is that the context for the second predicate is different from the context for the ﬁrst. Speciﬁcally, in the second predicate, the context position  the value of the position   function  and the context size  the value of  620   Axis Steps  the last   function  consider only those nodes that successfully passed through the previous predicate. What this means in practice is shown in the examples below: Expression  Description The ﬁrst book that was written by P. D. James.  book[author = "P. D. James"][1]  book[1][author = "P. D. James"]  The ﬁrst book, provided that it was written by P. D. James.  book[position   = 1 and author = "P. D. James"]  The ﬁrst book, provided that it was written by P. D. James. This is the same as the previous example, because in that example the second predicate is not dependant on the context position.  Abbreviated Axis Steps  Logically, an axis step has three parts, which we have examined in the previous sections: the axis, the node test, and the predicates. However, the most commonly used axis steps can be written in an abbreviated notation, and in this section we will look at these abbreviations.  In XPath 1.0, the expression «.» was considered to be an abbreviation for the step «self::node  ». In XPath 2.0 this is no longer the case, because «.» can also be used when the context item is an atomic value rather than a node. For this reason, «.» is now classiﬁed as a primary expression in its own right, and was therefore covered with the other kinds of primary expression in Chapter 7.  9  X P a t h :  P a t h  E x p r e s s o n s  i  Syntax  Expression  Syntax  AbbrevForwardStep  «@»? NodeTest  AbbrevReverseStep  «..»  This syntax describes three abbreviations for axis steps: the defaulted child axis, the use of «@» to repre- sent the attribute axis, and the use of «..» to represent the parent axis. We will consider these in the next three sections; we will then examine the freestanding « » expression and see that it can be treated as an abbreviation for a more complex expression involving axis steps.  Note that because of the way these constructs are used in the deﬁnition of an axis step, any of them can be followed by predicates in square brackets. Defaulting the Axis Name in a Step  A full step is written in the form:  axis-name :: NodeTest Predicates?  Since the most common axis is the child axis, it is possible to omit the «child::» part and write the step in the abbreviated form:  NodeTest Predicates?  For example, the path expression «employee name first-name» consists of three steps, each of which has been abbreviated in this way. It is short for «child::employee child::name  child::first-name».  621   XPath: Path Expressions  Most people writing XPath expressions use this abbreviation all the time without really thinking about it. In fact, it’s rare to see «child::» spelled out explicitly. But I do sometimes like to write the full form to alert the reader to what’s going on. For example, the expression «record[*]» selects all   elements that have one or more child elements. I sometimes write this as «record[child::*]» so that anyone reading the code can see more clearly what it means. The full syntax for the expression, of course, is «child::record[child::*]», and you could spell it out even more explicitly by writing «child::record[exists child::* ]».  The exists   function is in Chapter 13 .  There’s one exception to the general rule that if you don’t specify an axis, you get the child axis. This is when you use a NodeTest of the form «attribute . . . » or «schema-attribute . . . ». This kind of NodeTest is used when testing the schema-deﬁned type of an attribute node; it is described in detail in Chapter 11. Because the NodeTest makes it clear that you are looking for attributes rather than child elements, the system in this case chooses the attribute axis as the default. This avoids your having to write «attribute::attribute * » or «@attribute X », both of which read rather oddly, though they are both legal and logical.  The «@» Abbreviation  When the «@» sign appears in front of a NodeTest, it indicates that you are selecting nodes using the attribute axis. It is short for «attribute::».  What this means in practice is that in a path expression «A @B», B is referring to an attribute of A, while in the path expression «A B», B is referring to a child element of A.  Again, this abbreviation is ubiquitous among XPath developers, and it’s rare to see «attribute::» writ- ten out in full. In fact, the «@» in front of an attribute name has become so familiar that people often think of it as being almost part of the name. I’m probably not the only one who has found myself typing   in an XML document  which, of course, will be thrown out by an XML parser .  Take care when using the «self::» axis. You can write «self::title» to test whether the context node is a   element, but you can’t write «self::@title» to test whether it is a title attribute. This is because «@» is short for «attribute::», and «self::attribute::title» doesn’t make sense: you can either look on the self axis or the attribute axis, but not both at once. Write «self::attribute title » instead.  Examples  Expression  @category  @xml:space  @*  @xsl:*  622  Description Abbreviation for «attribute::category».  Abbreviation for «attribute::xml:space».  Abbreviation for «attribute::*»  selects all attributes of the context node .  Abbreviation for «attribute::xsl:*»  selects all attributes in the namespace bound to the preﬁx xsl .   Axis Steps  The «..» Abbreviation  The construct «..» appearing as an abbreviated step is short for «parent::node  ». As such, it selects the parent of the context node. If the context node has no parent  that is, if it is the root of a tree , then it selects an empty sequence.  This notation is found most commonly at the start of a relative path expression. For example, «.. @name» selects the name attribute of the parent of the context node. It is possible to use «..» anywhere in a path expression, though the need rarely arises. For example, «  title ..» selects all elements in the doc- ument that have a child element called  . The same result could be achieved, perhaps more naturally, by writing «  *[title]».  Document nodes never have a parent, so « ..» is always an empty sequence. In XPath 1.0, there was no direct way of representing an empty sequence, and so you may see this notation used when an empty sequence is needed, perhaps as the default value of a parameter in an XSLT template rule. In XPath 2.0 it’s more natural to write this as «  ». Indeed, an XPath 2.0 processor that implements the static typing feature  see Chapter 3  may well give you an error if you write « ..», kindly pointing out to you that it will never select anything.  Writing «not .. » is a simple way of testing whether the context node is the root.  As explained in Chapter 2, the element containing an attribute is considered to be the parent of the attribute, even though the attribute is not a child of the element. Unlike biological relationships, in XPath the parent and child relationships are not the inverse of each other. This allows you to use an expression such as «idref ‘abc’  ..» to select the elements that have an IDREF attribute with the value «abc»  the idref   function is described in Chapter 13; it is one of the few constructs that make it natural to select an attribute node without going via its parent element.   In XPath 1.0 the expression «..» could not be followed by a predicate: you could not write <xsl:if test = "..[@color = ‘black’]">. This was probably an oversight by the language designers, and the restriction has been lifted in XPath 2.0. As you would expect, this expression tests whether the parent element node has a color attribute whose value is «black».  9  X P a t h :  P a t h  E x p r e s s o n s  i  ExamplesinContext  Expression  exists ..   The Root Expression « »  Effect Tests whether the context node has a parent  in other words, whether it is the root of a tree .  .. @name  Selects the name attribute of the parent of the context node.  I’ve invented the term root expression to refer to the expression « », when used on its own  that is, when used as an expression, rather than as an operator . This doesn’t actually have a name in the XPath syntax, and I feel it’s important enough to give it one.  The meaning of this expression is: the node that is the root of the tree containing the context node, provided that this is a document node.  The symbol « » is unusual because it is used both as an operator and as an expression in its own right. This can lead to some syntactic ambiguities; for example, the expression «  union  *» looks as if it is  623   XPath: Path Expressions  trying to ﬁnd the union of the two node sequences « » and « *», but actually it is an absolute path expression whose ﬁrst step is «child::union»  «union» is a legitimate element name  and whose second step is «child::*». If « » is followed by something that could be a legitimate step in a path expression, then that’s the interpretation that’s chosen. Adding whitespace after the « » doesn’t make any difference. What you need to do if you want the other interpretation is to put the « » in parentheses, thus: «    union  *».  This ambiguity was actually present, and unremarked upon, in XPath 1.0, though, it arose less frequently because there weren’t many operators in XPath 1.0 that could sensibly be applied to « » as an operand. The «» operator does not cause any ambiguities because it cannot be confused with an element name.  I’ve classiﬁed the root expression as an abbreviated axis step because for most purposes it can be regarded as equivalent to the expression «ancestor-or-self::document-node  ». However, there’s a signiﬁcant difference: if the context item doesn’t have an ancestor that is a document node, you get a runtime error rather than an empty sequence as the result.  Technically, therefore, the expression « » is deﬁned in the language speciﬁcation as being equivalent to:  root self::node    treat as document-node    This means that it selects the same node as the root   function described in Chapter 13, when given the context node «self::node  » as an argument, but raises an error if this node isn’t a document node  the «treat as» expression is covered in Chapter 11 .  Various errors can arise if you use the « » expression inappropriately:           It’s an error if there is no context item. This happens, for example, at the outer level of an XSLT function body. It’s an error if there is a context item but the context item isn’t a node. This can easily happen in XSLT within the   instruction, which always sets the context item to a string, or it can happen if you are using the   instruction to process a result of a function such as tokenize   or distinct-values  , which both return a sequence of atomic values. It’s an error if the context item is in a tree whose root is something other than a document node. In XPath 1.0, every tree had a document node at its root, in fact, it was called a root node rather than a document node because there was no distinction. But the XPath 2.0 data model allows you to have orphaned trees with no document node. Commonly these will have an element as their root. They can also have other kinds of node as the root; for example, an attribute or text node, but in this case the tree can only contain one node.  The language could have been designed so that « » was a synonym of the axis step «ancestor-or- self::node  [last  ]», which selects the root of the tree whatever kind of node it is. The designers decided not to do this to avoid the surprises that can otherwise occur if you ﬁnd yourself at a different kind of node from the one you were expecting. This decision also has the advantage that the type of the expression « » is known more precisely: it always returns a document node, which means that it is always safe to use it in contexts  such as a call to a user-deﬁned function  where a document node is the required type.  Although I have classiﬁed the root expression as an abbreviated axis step, it’s unusual to use it explicitly as an operand of the « » operator. Unusual, but not illegal. You will usually need to put it in parentheses if you try it; for example, «$x    » selects the document node at the root of the tree containing the node  624   Rooted Path Expressions  $x. A unary « » operator appearing in an expression such as « book chap title» can be seen as an abbreviation for «    book chap title», so the root expression is being used as an implicit axis step whenever you write a path expression starting with « ». Which forms the subject of the next section. . ..  Rooted Path Expressions  I will use the term rooted path expression to mean a path expression that starts with « » or «  ». In XPath 1.0 these were called absolute path expressions; there is no speciﬁc name for them in the 2.0 speciﬁcation, but I have avoided the word absolute because it conceals the fact that the value of these expressions does, in fact, depend on the context node.  The full syntax for path expressions is shown below. We already saw the production RelativePathExpr at the beginning of this chapter.  Syntax  Expression  Syntax  PathExpr   « » RelativePathExpr?    «  » RelativePathExpr   RelativePathExpr  RelativePathExpr  StepExpr    « »  «  »  StepExpr  *  This production indicates that there are four forms a path expression can take, namely:              « »  a root expression, already discussed on page 623  « » RelativePathExpr the subject of this section  «  » RelativePathExpr  discussed later on page 626  RelativePathExpr  a sequence of steps separated by the binary « » operator, which we examined at the start of this chapter   A rooted path represents a path starting at the root node of the tree that contains the context node.  The syntax « A B C» is familiar to anyone who has used Unix ﬁlenames, though it is not actually very logical. I ﬁnd it helpful to think of the « » at the start of a rooted path expression as being a unary version of the binary « » operator. This means that a rooted path « X» can be considered as an abbreviation for the expression «    X», in the same way as «-3» is an abbreviation for « 0 -3». That is, the « » is really just a binary operator with a defaulted ﬁrst operand. The implicit ﬁrst operand in this case is the node selected by the root expression « ». After this expansion, a rooted path behaves in exactly the same way as a relative path, which was described at the start of this chapter.  A consequence of these rules is that a rooted path such as « X» will throw an error in all the cases where the root expression « » throws an error. Speciﬁcally:           It’s an error if there is no context item. It’s an error if there is a context item but the context item isn’t a node. It’s an error if the context item is in a tree whose root is something other than a document node.  There’s a good reason for the restriction that a rooted path expression can only be used to select within a tree that’s rooted at a document node. If it were allowed to start from any kind of node, there would be  625  9  X P a t h :  P a t h  E x p r e s s o n s  i   XPath: Path Expressions  some strange surprises. For example, if the root of the tree were an element node named  , then the expression « A» would not select that element. This expression is an abbreviation for «    child::A», so it would select all elements named A that are children of the root element, but not the root element itself. Rather than allow such surprises to occur, the working group decided to make this an error. If you want to select relative to the root of a non-document tree, you can always do this with a relative path expression whose ﬁrst step is a call to the root   function, described in Chapter 13. For example, you can select all the A elements in a tree, even an A element that is the root of the tree, with the expression «root .  descendant-or-self::A».  If you want to start from the root of a different document than the one containing the context node, the simplest approach is to write a path expression whose ﬁrst component is a variable reference identifying the root of the tree you want to make your selection from. This happens frequently in XSLT. If you are writing a stylesheet that loads several source documents using the doc   function, there is no direct way of selecting the root of the principal source document when the context node is in a different one. To solve this problem, it is useful to include in your stylesheet a global variable declaration of the form  . You can then refer to the root of the principal document at any time as «$input», and you can select other nodes in this tree with relative path expressions of the form «$input A B».  Examples of Rooted Paths  Expression   price-list  Description Selects the document element within the current document, provided its name is  .  Current document here and in the other examples means the tree containing the context node, assuming that the tree is rooted at a document node .   *  Selects the document element within the current document, whatever its name.   child::node   Selects all nodes that are immediate children of the document root, that is, the  document element plus any comments or processing instructions that come before or after the document element.  However, note that the   at the start of a document is not a processing instruction; in fact, it is not a node at all and is not accessible using XPath .  Selects all element nodes with names in the namespace associated with the «xsl:» namespace preﬁx that are immediate children of the document element.  If applied to an XSLT stylesheet, this would select all the top-level XSLT declarations .   * xsl:*    figure  This path expression selects all the   elements in the current document.  The «   » Abbreviation  Colloquially, «  » in a path expression means ‘‘ﬁnd all descendants’’. More formally, whether it appears at the start of a path expression or as a binary operator, it is equivalent to writing « descendant-or- self::node   ».  I refer to «  » as a pseudo-operator because its semantics are described by means of a textual expan- sion into a different expression; this differs from a proper operator whose effect is described in terms of evaluating the operands and combining the results.  The expression «  A» is often used to select all   elements in the document.  626   The «   » Abbreviation  How does this work? The expression «  » is equivalent to the rooted path « descendant-or- self::node   child::A», which in turn  as we saw in the previous section  expands to «     descendant-or-self::node   child::A ». This selects all   elements whose parent is either the document node or a descendant of the document node, looking as always within the tree that contains the context node. Since every element has a parent that meets these criteria, it selects all   elements. Similarly, «  @B» means « descendant-or-self::node   attribute::B», which selects all B attributes in the current document.  In most cases «  A» gives the same answer as « descendant::A», but the signiﬁcance of the formal expansion becomes apparent when positional predicates are involved. The expression «  para[1]» expands to « descendant-or-self::node   child::para[1]», which selects every   element that is the ﬁrst child of its parent. This isn’t the same as « descendant::para[1]», which selects the ﬁrst   element in the entire document.  The «  » abbreviation can also be used as an inﬁx operator anywhere that « » can appear. For example, «.  A» selects all   elements that are descendants of the context node. Again, the ofﬁcial meaning is «. descendant-or-self::node   child::A». The «. » in this expanded expression is redundant: people often write path expressions such as «. A B», but the «. » in most cases is pure noise. But with «  », the leading «.» becomes necessary to indicate that you want to start the selection at the context node, not at the root document node.  Expressions using «  » can be expensive to evaluate, because the XPath processor will often have to search the whole document to ﬁnd the selected nodes. If you can specify a more restricted search, it is generally a good idea to do so — for example, if you know that all the   elements are children of the document element, then specifying « * book» will generally be much more efﬁcient than writing «  book». Of course, actual performance characteristics of different products may vary. In some XML database products, elements are indexed in such a way that «  book» becomes very fast.  9  X P a t h :  P a t h  E x p r e s s o n s  i  Examples Using «  »  Expression    figure  Description Selects all   elements in the document.    book[@category = ‘fiction’]  Selects all   elements in the document that have a category attribute with the value «fiction».    * *  Selects all element nodes that have an element as a parent, in other words all elements except those that are immediate children of the root node. Here «*» is a NameTest that matches any element.    book title  Selects all   elements that have a   element as their parent.  chapter  footnote  Selects all   elements that are descendants of a   element that itself is a child of the context node.  .  footnote  Selects all   elements that are descendants of the context node.  doc ‘lookup.xml’    entry  Selects all   elements within the document identiﬁed by the relative URI lookup.xml. The doc   function is described in Chapter 13, page 750.  $winners  * @name  Selects the name attribute of all elements that are descendants of a node that belongs to the node-set identiﬁed by the variable $winners.  continued  627   XPath: Path Expressions  Expression .  ..  Description This strange but perfectly legal expression combines «  », which ﬁnds the descendants of a node, and «..», which ﬁnds its parent. The effect is to ﬁnd all nodes that are the parent of a descendant of the context node, plus the parent of the context node itself.  chapter  footnote  Selects all   elements that are descendants of a   element that itself is a child of the context node.  Comparing «  » with « descendant::»  Consider the two expressions «$chapters  diagram[1]» and «$chapters descendant:: diagram[1]»:  «$chapters  diagram[1]» means «$chapters descendant-or-self::node   child::diagram[1]», that is, every   element that is the ﬁrst   child of its parent element and that is a descendant of a node in $chapters.  «$chapters descendant::diagram[1]» means the ﬁrst   element  taking them in document order  that is a descendant of a node in $chapters. Another way of writing this is « $chapters   diagram [1]».  To see the difference, consider the following source document:                               With this document, if the variable $chapters contains only the outer   element, «$chapters   diagram[1]» will select diagrams 12, 14, and 15, while both «$chapters  descendant::diagram[1]» and « $chapters  diagram [1]» will select diagram 12 only.  Combining Sets of Nodes  Until now this chapter has been all about path expressions. This section describes operators that com- bine two sets of nodes. Although these aren’t technically path expressions, they are invariably used in conjunction with path expressions, so it’s useful to deal with them at the same time. The operators are:           Union, written «union» or «», which includes a node in the result if it is present in either of the two supplied sets, eliminating any duplicates. Intersection, written «intersect», which includes a node in the result if it is in both the two sets. Difference, written «except», which includes a node in the result if it is in the ﬁrst set and is not in the second.  628   Combining Sets of Nodes  These are sometimes called set operators, but the word ’’set’’ is so overloaded that I prefer the term Venn operators, after the nineteenth-century English mathematician who popularized the diagrams used to explain them.  The XDM data model does not actually support sets  that is, collections with no intrinsic order and with duplicates disallowed . Instead, sets of nodes are simulated using sequences. The actual type of the operands for the union, intersect and except operators is «node  *», which allows any sequence of nodes. This is also the type of the result. But semantically, these operators ignore any duplicates in the input sequence, and they ignore the order of the nodes in the input sequence. The result sequence will never contain any duplicates, and the results will always be in document order. The effect of the three operators is illustrated in Figure 9-1.  A  B  A  B  A  B  A union B  A intersect B  A except B  Figure 9-1  As with path expressions, when we talk about duplicate nodes in this section, we are always talking about multiple references to the same node, that is, we are concerned with node identity, not with the values contained in the nodes. Unfortunately, XDM talks about sequences containing nodes, when it really means that sequences contain references to nodes. I personally feel uncomfortable talking about a sequence containing two nodes that have the same identity, or containing the same node more than once: I ﬁnd it much more natural to talk about a sequence containing two references to the same node.  Users often questioned whether the node-sets of XPath 1.0 were true sets, given that  in XSLT at any rate  the nodes were always processed in document order. The answer is that they were indeed true sets, because it was not possible to have distinct collections such as  A, B ,  B, A , and  A, B, B, A . There was only one collection in the XPath 1.0 model that could contain the nodes A and B, and the fact that the nodes were always processed in a canonical order doesn’t change this.  In XPath 2.0, it is possible to have distinct sequences such as  A, B ,  B, A , and  A, B, B, A . However, the operators described in this section treat these sequences as if they were identical. So these operators are using sequences to simulate node-sets, and I shall therefore use the term node-sets to describe these values.  Syntax  Expression  UnionExpr  Syntax  IntersectExceptExpr    «union»  «»   IntersectExceptExpr  *  IntersectExceptExpr PathExpr    «intersect»  «except»  PathExpr  *  This syntax shows that the «union» operator  which has «» as a synonym  binds less tightly than the «intersect» and «except» operators. So the expression «A union B intersect C» means «A union  B  9  X P a t h :  P a t h  E x p r e s s o n s  i  629   XPath: Path Expressions  intersect C ». As always, there is no shame in adding extra parentheses if you’re not sure about the rules  or even if you are .  Both operands to the union, intersect, and except operators must be sequences of zero or more nodes. A type error will occur if this isn’t the case. The input sequences don’t have to be in any particular order, and they are allowed to contain duplicates; the original order and the duplicates will have no effect on the result.  Examples  Expression  * figure  * table  Description Returns a node-set containing all the grandchildren of the context node that are   or   elements. This can also be written «*  figuretable ».  book[not @publisher ]  book[@publisher = ‘Wrox’]  Returns all the   children of the context node that either have no publisher attribute or that have a publisher attribute equal to ”Wrox”. Note that the same result could be achieved, perhaps more efﬁciently, by using the «or» operator in the predicate.   ...  title  Returns all the   elements that are immediate children of either the context node or the parent of the context node.  sum  bookmagazine   @sales   Returns the total of the sales attribute values for all the   and   children of the context node.     *    @*  [. = ‘nimbus2000’]  Returns a node-set containing all the element and attribute nodes in the document whose string value is «nimbus2000».  following::para intersect $chap  *  Returns all   nodes that are after the context node in document order, provided that they are descendants of the node in variable $chap.  key ‘a’, ‘Gilbert’  intersect key ‘a’, ‘Sullivan’   The XSLT key   function selects nodes using a deﬁned index. This expression selects nodes that are indexed both under «Gilbert» and under «Sullivan».  exists . intersect $arg   Returns true if the context node is included in the sequence $arg.  @* except @note  Selects all the attributes of the context node except the note attribute.  The «intersect» operator is also useful for testing whether one node is a member of a given set of nodes. For example, the following expression tests whether node $N is a descendant of node $A:  if  $N intersect $A descendant::node    then ...  This works because if $N is among the descendants of $A, the intersection will contain $N, and the effective boolean value of a sequence containing one node is true. If $N is not among the descendants of $A, the intersection will be empty, and the effective boolean value of an empty sequence is false.  Usage  630   Combining Sets of Nodes  The «except» operator is useful when there is a need to process all the child elements of a node, or all its attributes, except for certain speciﬁc exclusions. For example, the XSLT instruction:     copies all the attributes of the context node to the result document except for the last-changed attribute  if there is one .  Set Intersection and Difference in XPath 1.0  XPath 1.0 provided no equivalent to the «intersect» and «except» operators. In XPath 1.0, if you want to form the intersection between two node-sets $p and $q, the following rather tortuous expression achieves it:  $p [ count  .  $q   = count  $q   ]  This selects the nodes in $p that are also in $q. They must be in $q, because their union with $q has the same number of nodes as $q itself.  Similarly, the following XPath 1.0 expression ﬁnds the nodes that are in $p and not in $q:  $p [ count  .  $q   != count  $q   ]  If you see these constructs when you are upgrading XPath 1.0 code, you can conﬁdently replace them with the XPath 2.0 constructs:  9  X P a t h :  P a t h  E x p r e s s o n s  i  $p intersect $q $p except $q  which are not only a lot easier to understand, but will probably be much more efﬁcient as well.  Some XSLT 1.0 processors also provided extension functions to implement set intersection and differ- ence; for example, the functions deﬁned in the EXSLT library  http:  www.exslt.org . These have been superseded by the new operators.  Sets of Atomic Values  The operators union, intersect, and except work only on sets of nodes. There are no equivalent opera- tors in XPath 2.0 to handle sets of atomic values. However, it’s easy to achieve the same effect for yourself, as follows: Operator Union  distinct-values $A, $B   Expression  Intersect  Except  distinct-values $A[. = $B]   distinct-values $A[not . = $B ]   631   XPath: Path Expressions  Summar y  XPath expressions are used to select data from the source document and to manipulate it to generate data to place in the result document. Path expressions play the same role for XML as the SQL SELECT statement plays for relational databases — they allow us to select speciﬁc parts of the document for transformation, so that we can achieve the required output.  This chapter has provided a full description of the meaning of path expressions, the « » operator as it applies to nodes, steps, axes, node tests, and predicates, and it also covered the other operations deﬁned on sequences of nodes, namely the union, intersect, and except operators.  The next chapter will describe constructs in the XPath language that operate on any kind of sequence, whether it contains nodes, atomic values, or a mixture of the two.  632   XPath: Sequence  Expressions  One of the most notable innovations in XPath 2.0 is the ability to construct and manipulate sequences. This chapter is devoted to an explanation of the constructs in the language that help achieve this.  Sequences can consist either of nodes, or of atomic values, or of a mixture of the two. Sequences con- taining nodes only are a generalization of the node-sets offered by XPath 1.0. In the previous chapter we looked at the XPath 2.0 operators for manipulating sets of nodes, in particular, path expressions, and the operators «union», «intersect», and «except».  In this chapter we look at constructs that can manipulate any sequence, whether it contains nodes, atomic values, or both. Speciﬁcally, the chapter covers the following constructs:  10  X P a t h :  S e q u e n c e  E x p r e s s o n s  i              Sequence concatenation operator: «,» Numeric range operator: «to» Filter expressions: «a[b]»    Mapping expressions: «for»    Simple mapping expressions: « » applied to atomic values Quantiﬁed expressions: «some» and «every»  First, some general remarks about sequences.  Sequences  unlike nodes  do not have any concept of identity. Given two values that are both sequences, you can ask  in various ways  whether they have the same contents, but you cannot ask whether they are the same sequence.  Sequences are immutable. This is part of what it means for a language to be free of side effects. You can write expressions that take sequences as input and produce new sequences as output, but you can never modify an existing sequence in place.  Sequences cannot be nested. If you want to construct trees, build them as XML trees using nodes rather than atomic values.   XPath: Sequence Expressions  A single item is a sequence of length one, so any operation that applies to sequences also applies to single items.  Sequences do not have any kind of type label that is separate from the type labels attached to the items in the sequence. As we will see in Chapter 11, you can ask whether a sequence is an instance of a par- ticular sequence type, but the question can be answered simply by looking at the number of items in the sequence, and at the type labels attached to each item. It follows that there is no such thing as  say  an ‘‘empty sequence of integers’’ as distinct from an ‘‘empty sequence of strings’’. If the sequence has no items in it, then it also carries no type label. This has some real practical consequences, for example, the sum   function, when applied to an expression that can only ever return a sequence of xs:duration values, will return the integer 0  not the zero-length duration  when the sequence is empty, because there is no way at runtime of knowing that if the sequence hadn’t been empty, its items would have been durations.  Functions and operators that attach position numbers to the items in a sequence always identify the ﬁrst item as number 1  one , not zero.  Although programming with a base of zero tends to be more convenient, Joe Public has not yet been educated into thinking of the ﬁrst paragraph in a chapter as paragraph zero, and the numbering convention was chosen with this in mind.   This chapter covers the language constructs that handle general sequences, but there are also a number of useful functions available for manipulating sequences, and these are described in Chapter 13. Rele- vant functions include: count  , deep-equal  , distinct-values  , empty  , exists  , index-of  , insert-before  , remove  , subsequence  , and unordered  .  The Comma Operator  The comma operator can be used to construct a sequence by concatenating items or sequences. We already saw the syntax in Chapter 7, because it appears right at the top level of the XPath grammar: Expression  Syntax  Expr  ExprSingle  ExprSingle  «,» ExprSingle *  ForExpr  QuantifiedExpr  IfExpr  OrExpr  Although the production rule ExprSingle lists four speciﬁc kinds of expression that can appear as an operand of the «,» operator, these actually cover any XPath expression whatsoever, provided it does not contain a top-level «,».  Because the «,» symbol also has other uses in XPath  for example, it is used to separate the arguments in a function call, and also to separate clauses in «for», «some», and «every» expressions, which we will meet later in this chapter , there are many places in the grammar where use of a general Expr is restricted, and only an ExprSingle is allowed. In fact, the only places where a general Expr  one that contains a top-level comma  is allowed are:     As the top-level XPath expression   Within a parenthesized expression   Within the parentheses of an «if» expression   Within square brackets as a predicate  634   The Comma Operator  Neither of the last two is remotely useful, so in practice the rule is: if you want to use the comma operator to construct a list, then either it must be at the outermost level of the XPath expression or it must be written in parentheses.  For example, the max  function expects a single argument, which is a sequence. If you want to ﬁnd the maximum of three values $a, $b, and $c, you can write:  max  $a, $b, $c    The outer parentheses are part of the function call syntax; the inner parentheses are needed because the expression «max $a, $b, $c » would be a function call with three parameters rather than one, which would be an error.  XPath does not use the JavaScript convention whereby a function call with three separate parameters is the same as a function call whose single parameter is a sequence containing three items.  The operands of the «,» operator can be any two sequences. Of course, a single item is itself a sequence, so the operands can also be single items. Either of the sequences can be empty, in which case the result of the expression is the value of the other operand.  The comma operator is often used to construct a list, as in:  if  $status =  ’current’, ’pending’, ’deleted’, ’closed’   then ...  which tests whether the variable $status has one of the given four values  recall from Chapter 8 that the «=» operator compares each item in the sequence on the left with each item in the sequence on the right, and returns true if any of these pairs match . In this construct, you probably aren’t thinking of «,» as being a binary operator that combines two operands to produce a result, but that’s technically what it is. The expression «A,B,C,D» technically means «   A,B ,C ,D », but because list concatenation is associative, you don’t need to think of it this way.  The order of the items in the two sequences is retained in the result. This is true even if the operands are nodes: there is no sorting into document order. This means that in XSLT you can use a construct such as:     to process the selected elements in a speciﬁed order, regardless of the order in which they appear in the source document. This example is not necessarily processing exactly three elements: there might, for example, be ﬁve authors and no abstract. Because the path expression «author» selects the ﬁve authors in document order, they will be processed in this order, but they will be processed after the   element whether they precede or follow the title in the source document.  10  X P a t h :  S e q u e n c e  E x p r e s s o n s  i  Examples  Here are some examples of expressions that make use of the «,» operator to construct sequences. Expression max  $net, $gross    Effect Selects whichever of $net and $gross is larger, comparing them according to their actual type  and using the default collation if they are strings .  for $i in  1 to 4, 8, 13  return $seq[$i]  Selects the items at positions 1, 2, 3, 4, 8, and 13 of the sequence $seq. For the meaning of the «to» operator, see the next section.  continued 635   XPath: Sequence Expressions  Expression string-join  @a, @b, @c , "-"   Effect Creates a string containing the values of the attributes @a, @b, and @c of the context node  in that order , separated by hyphens.   @code,"N A" [1]  Returns the code attribute of the context node if it has such an attribute, or the string «N A» otherwise. This expression makes use of the fact that when the code attribute is absent, the value of @code is an empty sequence, and concatenating an empty sequence with another sequence returns the other sequence  in this case the singleton string «N A»  unchanged. The predicate in square brackets makes this a ﬁlter expression: ﬁlter expressions are described later in this chapter, on page 637.  Returns a sequence containing the  ,  , and   children of a   element, in document order. Although the «,» operator retains the order as speciﬁed, the « » operator causes the nodes to be sorted into document order. So in this case the «,» operator is exactly equivalent to the union operator «».  book  author, title, isbn   <xsl:value-of select = "first, middle, last" >  This XSLT instruction outputs the values of the child elements  ,  , and    not necessarily exactly one of each , in that order, space-separated.  Numeric Ranges: The «to» Operator  A range expression has the syntax:  Expression  RangeExpr  Syntax  AdditiveExpr   «to» AdditiveExpr  ?  The effect is to return a sequence of consecutive integers in ascending order. For example, the expression «1 to 5» returns the sequence «1,2,3,4,5».  The operands do not have to be constants, of course. A common idiom is to use an expression such as «1 to count $seq » to return the position number of each item in the sequence $seq. If the second operand is less than the ﬁrst  which it will be in this example if $seq is an empty sequence , then the range expression returns an empty sequence. If the second operand is equal to the ﬁrst, the expression returns a single integer, equal to the value of the ﬁrst operand.  The two operands must both evaluate to single integers. You can use an untyped value provided it is capable of being converted to an integer; for example, you can write «1 to @width» if width is an attribute in a schema-less document containing the value «34». However, you can’t use a decimal or a double value without converting it explicitly to an integer. If you write «1 to @width + 1», you will get a type error, because the value of «@width + 1» is the double value 35.0e0. Instead, write «1 to xs:integer @width  + 1» or «1 to 1 + @width idiv 1».  If either operand is an empty sequence, the result is an empty sequence. For example, this would happen if you ran any of the examples above when the context node did not have a width attribute. Supplying a sequence that contains more than one item, however, is an error.  636   Numeric Ranges: The «to» Operator  If you want a sequence of integers in reverse order, you can use the reverse   function described in Chapter 13. For example, «reverse 1 to 5 » gives you the sequence «5,4,3,2,1». In an earlier draft of the speciﬁcation you could achieve this by writing «5 to 1», but the rules were changed because this caused anomalies for the common usage «1 to count $seq » in the case where $seq is empty.  Although the semantics of this operator are expressed in terms of constructing a sequence, a respectable implementation will evaluate the sequence lazily, which means that when you write «1 to 1000000» it won’t actually allocate space in memory to hold a million integers. Depending on how you actually use the range expression, in most cases an implementation will be able to iterate over the values without laying them out end-to-end as a list in memory.  Here are some examples of expressions that make use of the «to» operator to construct sequences.  Examples  Expression  for $n in 1 to 10 return $seq[$n]  $seq[position   = 1 to 10]  Effect Returns the ﬁrst 10 items of the sequence $seq. The «for» expression is described later in this chapter, on page 640.  Returns the ﬁrst 10 items of the sequence $seq. This achieves the same effect as the previous example, but this time using a ﬁlter expression alone. It works because the «=» operator compares each item in the ﬁrst operand  there is only one, the value of position    with each item in the second operand  that is, each of the integers 1 to 10  and returns true if any of them matches. It’s reasonable to expect that XPath processors will optimize this construct so that this doesn’t actually involve 10 separate comparisons for each item in the sequence.  Note that you can’t simply write «$seq[1 to 10]». If the predicate isn’t a single number, it is evaluated as a boolean, and attempting to get the effective boolean value of a sequence of numbers is an error.  Returns a string containing $N space characters.  10  X P a t h :  S e q u e n c e  E x p r e s s o n s  i  Returns a sequence that contains pairs of corresponding values from the two input sequences $S and $T. For example, if $S is the sequence  "a","b","c"  and $T is the sequence  "x","y","z" , the result will be the sequence  "ax","by","cz" .  This XSLT example shows how to output a sequence of ﬁve empty   elements.  637  for $i in 1 to 5 return $i*2  Returns the sequence «2, 4, 6, 8, 10».  string-join  for $i in 1 to $N return " "," "   for $i in 1 to count $S  return concat $S[$i], $T[$i]   <xsl:for-each  select = "1 to 5">        XPath: Sequence Expressions  Filter Expressions  A ﬁlter expression is used to apply one or more Predicates to a sequence, selecting those items in the sequence that satisfy some condition.  Expression  FilterExpr  Predicate  Syntax  PrimaryExpr Predicate*  «[» Expr «]»  A FilterExpr consists of a PrimaryExpr whose value is a sequence, followed by zero or more Predicates that select a subset of the items in the sequence. Each predicate consists of an expression enclosed in square brackets, for example «[@name = ‘London’]» or «[position   = 1]».  Since in XPath 2.0 every value is a sequence, it is possible to apply predicates to any value whatsoever. For example, the expression «concat $n, " error", "s"[$n!=1] » outputs a string such as ‘‘0 errors’’, ‘‘1 error’’, or ‘‘5 errors’’. In the case where $n is 1, the third argument to concat   is an empty sequence, which contributes nothing to the output.  Recall from Chapter 7 that a PrimaryExpr is a literal, a variable reference, «.», a function call, or a paren- thesized expression. This means that if you want to ﬁlter the result of any expression other than the ﬁrst four in this list, you will have to write it in parentheses.  Each predicate is applied to the sequence in turn; only those items in the sequence for which the predicate is true pass through to the next stage. The ﬁnal result consists of those items in the original sequence that satisfy each of the predicates, retaining their original order.  A predicate may be either a numeric predicate  for example «[1]» or «[last  -1]» , or a boolean predi- cate  for example «[count *  gt 5]» or «[@name and @address]» . If the value of the expression is a single number, it is treated as a numeric predicate; otherwise, it is converted, if necessary, to an xs:boolean and is treated as a boolean predicate. The conversion is done using the rules for computing the effective boolean value, which are the same rules as are used for the condition in an «if» expression  described in Chapter 7 on page 551  or for the operand of the boolean   function  described in Chapter 13 on page 721 , except that if the value is a single number — which might be an integer, decimal, ﬂoat, or double — then the predicate is treated as a numeric predicate rather than a boolean predicate.  If the value of the predicate contains nodes, there is no automatic atomization of the nodes  that is, the values of the nodes are not extracted . In fact, if the value of the predicate contains one or more nodes, then its effective boolean value is always true. This means, for example, that «person[@isMarried]» selects any   element that has an isMarried attribute, irrespective of the value of that attribute. If you want to test the value of the attribute, you can atomize it explicity using the data   function, or you can use a comparison such as «person[@isMarried = true  ]».  But beware, if backward-compatibility mode is switched on, then «person[@isMarried = true  ]» means the same as «person[@isMarried]» .  A numeric predicate whose value is N is equivalent to the boolean predicate «[position   eq N]». So, for example, the numeric predicate «[1]» means «[position   eq 1]», and the numeric predicate «[last  ]» means «[position   eq last  ]».  It’s important to remember that this implicit testing of position   happens only when the predicate expression actually evaluates to a single number. For example, «$paras[1 or last  ]» does not mean «$paras[position   = 1 or position   = last  ]», because the result of evaluating «1 or last  » is a boolean, not a number  and as it happens, it will always be true . Similarly, «book[.. @book-nr]» does  638   Filter Expressions  not mean «book[position   = .. @book-nr]», because the result of «.. @book-nr» is a node, not a number.  A neat way to force the node to be atomized in such cases is to use the unary «+» operator: write «book[+.. @book-nr]».  A consequence of the rule is that if the predicate is a number that is not equal to an integer, the result will be an empty sequence. For example, «$S[last   div 2]» will select nothing when the value of last   is an odd number. If you want to select a single item close to the middle of the sequence, use «$S[last   idiv 2]», because the idiv operator always returns an integer.  In nearly all practical cases, a numeric predicate selects either a single item from the sequence or no items at all. But this is not part of the deﬁnition. To give a counter-example, «$x[count * ]» selects every node whose position is the same as the number of children it has.  As discussed in Chapter 7, every XPath expression is evaluated in some context. For an expression used as a predicate, the context is different from the context of the containing expression. While evaluating each predicate, the context is established as follows:           The context item  the item referenced as «.»  is the item being tested. The context position  the value of the position  function  is the position of that item within the sequence of items surviving from the previous stage. The context size  the value of the last   function  is the number of items surviving from the pre- vious stage.  To see how this works, consider the ﬁlter expression «$headings[self::h1][last  ]». This starts with the sequence of nodes that is the value of the variable «$headings»  if this sequence contains items that are not nodes, then evaluating the predicate «self::h1» will raise an error . The ﬁrst predicate is «[self::h1]». This is applied to each node in «$headings» in turn. While it is being applied, the context node is that particular node. The expression «self::h1» is a path expression consisting of a single AxisStep: it selects a sequence of nodes. If the context node is an   element this sequence will contain a single node — the context node. Otherwise, the sequence will be empty. When this value is converted to a boolean, it will be true if it contains a node, and false if it is empty. So the ﬁrst predicate is actually ﬁltering through those nodes in «$headings» that are   elements.  The second predicate is now applied to each node in this sequence of   elements. In each case the predicate «[last  ]» returns the same value: a number indicating how many   elements there are in the sequence. As this is a numeric predicate, a node passes the test when «[position   = last  ]», that is, when the position of the node in the sequence  taken in its original order  is equal to the number of nodes in the sequence. So the meaning of «$headings[self::h1][last  ]» is ‘‘the last   element in the sequence $headings.’’  Note that this isn’t the same as «$headings[last  ][self::h1]», which means ‘‘the last item in $head- ings, provided that it is an   element.’’  The operation of a Predicate in a FilterExpr is very similar to the application of a Predicate in an AxisStep  which we studied in Chapter 9, on page 618 , and although they are not directly related in the XPath grammar rules, you can often use predicates without being fully aware of which of these two constructs you are using. For example, «$para[1]» is a FilterExpr, while «para[1]» is an AxisStep. The main differences to watch out for are, ﬁrstly, that in a path expression the predicates apply only to the most recent Step  for example, in «book author[1]» the «[1]» means the ﬁrst author within each book , and secondly, that in a ﬁlter expression the items are always considered in the order of the supplied  639  10  X P a t h :  S e q u e n c e  E x p r e s s o n s  i   XPath: Sequence Expressions  sequence, whereas in an AxisStep they can be in forward or reverse document order, depending on the direction of the axis.  Examples Expression  $paragraphs[23]  key ‘empname’, ‘John Smith’ [@loc = ‘Sydney’]     @href doc .   [pricelist][1]     section  subsection  [title = ‘Introduction’]  Selects all   and   elements that have a child   element with the content «Introduction».  Description Selects the 23rd item in the sequence that is the value of variable $paragraphs, taking them in the order of that sequence. If there is no 23rd item, the expression returns an empty sequence.  Assuming that the key «empname» has been deﬁned in the containing stylesheet to select employees by name, this selects all employees named John Smith who are located in Sydney. The key   function is available only in XSLT.  This ﬁrst selects all documents referenced by URLs contained in href attributes anywhere in the source document, by applying the doc   function to the value of each of these attributes. The « » operator causes any duplicates to be removed, as described in Chapter 9. From this set of documents it selects those whose outermost element is named  , and from these it selects the ﬁrst. The order of nodes that are in different documents is not deﬁned, so if there are several price lists referenced, it is unpredictable which will be selected.  Where a predicate is used as part of a FilterExpr  as distinct from an AxisStep , the items are considered in their original sequence for the purpose of evaluating the position   function within the predicate. There are some cases where the order of the sequence is not predictable, but it is still possible to use positional predicates. For example, the result of the distinct-values   function is in an undeﬁned order, but you can still write «distinct-values $in [1]» to obtain one item in the sequence, chosen arbitrarily.  The «for» Expression  The «for» expression is one of the most powerful new features in XPath 2.0 and is closely related to the extension to the data model to handle sequences. Its effect is to apply an expression to every item in an input sequence and to return the concatenated results of these expressions.  The syntax also allows several sequences to be provided as input, in which case the effect is to apply an expression to every combination of values taken one from each sequence.  Expression  Syntax  ForExpr  VarName  QName  «for» «$» VarName «in» ExprSingle   «,» «$» VarName «in» ExprSingle *  «return» ExprSingle  640   The «for» Expression  An ExprSingle is any XPath expression that does not contain a top-level «,» operator. If you want to use an expression containing a «,» operator, write it in parentheses. For example, the expression «for $i in  1,5,10  return $i + 1» returns the sequence «2,6,11».  We’ll look ﬁrst at «for» expressions that operate on a single sequence and then move on to the more general case where there are multiple input sequences.  Mapping a Sequence  When used with a single sequence, the «for» expression applies the expression in the «return» clause to each item in the input sequence. The relevant item in the input sequence is accessed not as the context item but as the value of the variable declared in the «for» clause.  These variables are referred to as range variables, to distinguish them from variables supplied from outside the XPath expression, such as variables declared in an XSLT stylesheet. The term comes originally from the branch of mathematical logic called predicate calculus.  In most cases the expression in the «return» clause will depend in some way on the range variable. In other words, the «return» value is a function of the range variable, which means we can rewrite the «for» expression in the abstract form:  for $x in $SEQ return F $x   where «F $x » represents any expression that depends on $x  it doesn’t have to depend on $x, but it usually will .  What this does is to evaluate the expression «F $x » once for each item in the input sequence $SEQ and then to concatenate the results, respecting the original order of the items in $SEQ.  In the simplest case, the return expression «F $x » returns one item each time it is called. This is illustrated in Figure 10-1, where the function «F $x » in this example is actually the expression «string-length $x ».  10  X P a t h :  S e q u e n c e  E x p r e s s o n s  i  red  blue  green  3  4  5  Figure 10-1  We say that the expression «for $x in $SEQ return string-length $x » maps the sequence «"red", "blue","green"» to the sequence «3,4,5».  In this case, the number of items in the result will be the same as the number of items in the input sequence.  However, the return expression isn’t constrained to return a single item; it can return any sequence of zero or more items. For example, you could write:  for $s in  "red", "blue", "green"  return string-to-codepoints $s   641   XPath: Sequence Expressions  The function string-to-codepoints  , which is part of the standard library deﬁned in Chapter 13, returns for a given string, the Unicode code values of the characters that make up the string. For example, «string-to-codepoints "red" » returns the sequence «114, 101, 100». The result of the above expres- sion is a sequence of 12 integers, as illustrated in Figure 10-2.  red  blue  green  114  101 100  98  108  117  101  103  114  101  101  110  Figure 10-2  Examples Expression  for $i in 1 to 5 return $i*$i  for $i in 0 to 4 return 1 to $i  The integers are returned in the order shown, because unlike a path expression, there is nothing in the rules for a «for» expression that causes the result sequence to be sorted into document order. Indeed, document order is not a meaningful concept when we are dealing with atomic values rather than nodes.  Description Returns the sequence «1,4,9,16,25». This example is a one-to-one mapping.  Returns the sequence «1,1,2,1,2,3,1,2,3,4». This example is a one-to-many mapping. Note that for the ﬁrst item in the input sequence  0 , the mapping function returns an empty sequence, so this item contributes nothing to the result.  The Context Item in a «for» Expression  A common mistake is to forget that «for» expressions don’t set the context node. The following example is wrong  it’s not an error, but it doesn’t do what the writer probably intended :   :wrong:  sum for $i in item return @price * @qty   The correct way of writing this is:   :correct:  sum for $i in item return $i @price * $i @qty   Generally speaking, there is usually something amiss if the range variable is not used in the «return» expression. However, there are exceptions to this rule. For example, it’s quite reasonable to write:  string-join for $i in 1 to $n return "-", ""   which returns a string containing $n hyphens.  642   It’s also often  but not invariably  a sign of trouble if the value of the return expression depends on the context item. But it’s not actually an error: the context item inside the return expression is exactly the same as the context item for the «for» expression as a whole. So it’s legal to write an expression such as:  The «for» Expression  chapter  for $i in 1 to 10 return section[$i]   which returns the ﬁrst 10 sections of each chapter. Combining Multiple Sequences  The «for» expression allows multiple input sequences to be deﬁned, each with its own range variable. For example, you can write:  The simplest way to think about this is as a nested loop. You can regard the «,» as a shorthand for writing the keywords «return for», so the above expression is equivalent to:  for $c in   customer,  $o in $c orders, $ol in $o line  return $ol cost  for $c in   customer return  for $o in $c orders return  for $ol in $o line return $ol cost  Note that each of the range variables can be referenced in the expression that deﬁnes the input sequence for the next range variable.  In the example above, each iteration is rather like a step in a path expression; it selects nodes starting from the node selected in the containing loop. But it doesn’t have to be this way. For example, you could equally write an expression such as:  for $c in doc ’customers.xml’   customer,  $p in doc ’products.xml’   product [$c orders product-code = $p code] return $c line cost  It’s still true that this is equivalent to a nested-loop expression:  for $c in doc ’customers.xml’   customer return  for $p in doc ’products.xml’   product [$c orders product-code = $p code] return $c line cost  The other way to think about this, particularly if you are familiar with SQL, is as a relational join. The system isn’t actually obliged to evaluate the «for» expression using nested loops  this applies whether you write it in the abbreviated form using multiple range variables separated with commas, or whether you use the expanded form shown above . Instead, the optimizer can use any of the mech- anisms developed over the years in relational database technology to evaluate the join more rapidly. There’s no guarantee that it will do so, so you need to use potentially expensive constructs like this with some care.  643  10  X P a t h :  S e q u e n c e  E x p r e s s o n s  i   XPath: Sequence Expressions  One of the differences between the open-source Saxon-B product and its commercial cousin Saxon-SA, is that Saxon-SA optimizes joins. Both products will try to move subexpressions out of a loop if they don’t depend on the range variable. So the expression «doc ‘products.xml’   product» will probably only be evaluated once, and the expression «$c orders product-code» will only be evaluated once for each customer. But after this, Saxon-B will compare every product code in the customer ﬁle with every product code in the product ﬁle, while Saxon-SA will create an index  in effect, doing a hash join . The bigger the data ﬁle, the more of a difference this makes.  In XSLT, you can ‘‘hand-optimize’’ a join by using keys: see the description of the   declara- tion in Chapter 6  page 376 .  Example  Expression  count  for $i in 1 to 8,  $j in 1 to 8 return f:square $i, $j    Description Assuming that «f:square row, column » returns an integer identifying the piece that occupies a square on a chessboard, or an empty sequence if the square is unoccupied, this expression returns all the pieces on the board.  Simple Mapping Expressions  You may have noticed that there are some strong similarities between «for» expressions and path expres- sions. The expression:  for $c in chapter return $c section  returns exactly the same result as the path expression:  chapter section  However, there are some signiﬁcant differences between «for» expressions and path expressions:           In a path expression, both the input sequence and the step expression are required to return nodes exclusively. A «for» expression can work on any sequence, whether it contains nodes or atomic values or both, and it can also return any sequence. Path expressions always sort the resulting nodes into document order, and eliminate duplicates. A «for» expression returns the result sequence in the order that reﬂects the order of the input items. In a path expression, the context item for evaluating a step is set to each item in the input sequence in turn. In a «for» expression, the range variable fulﬁls this function. The context item is not changed. Nor are the context position and size  position   and last    available to test the position of the item in the input sequence.  Simple mapping expressions use the convenient syntax of path expressions  that is, the « » operator , but they work on atomic values rather than nodes. Speciﬁcally, the expression on the right-hand side of « » must return a sequence that consists entirely of atomic values. For example, the expression «* name  » returns a sequence of strings — the names of the child elements of the context node. There is no sorting  644   Simple Mapping Expressions  into document order here, because document order doesn’t mean anything for atomic values. The result is exactly the same as the expression «for $x in * return name $x », just with a more compact syntax.  Here are some other examples of simple mapping expressions at work:  Expression  sum order  @price*@quantity    string-join   ancestor::* name  , ‘ ’   avg product number   substring-after @price, ‘$’     Description Returns the result of calculating @price times @quantity for each child   and summing the results.  Returns a string such as «book chapter section para» giving the names of the ancestors of the context node, separated by « » characters.  Returns the result of taking the @price attributes of all the child   elements, stripping off the leading «$» sign, converting to a number, and then averaging.  In most cases the system will be able to distinguish a path expression from a simple mapping expression by the way it is written. In some cases, however — for example, if the expression calls a user-written function whose return type is not declared — the two cases can’t be distinguished until runtime. The initial processing in both cases is the same: for each item in the sequence returned by the ﬁrst expression, evaluate the second expression and concatenate the results. The rule is then:           If all the items in the result are nodes, we have a path expression. Duplicate nodes are elimi- nated, and those that remain are sorted into document order. If all the items in the result are atomic values, we have a simple mapping expression, and we are done. If there’s a mixture of nodes and atomic values, an error is reported.  A simple mapping expression always maps from nodes to atomic values. You can’t have atomic values on the left-hand side of the « » operator. For example, you can’t write «avg * name   string-length   » to get the average length of the names of the child elements. Only the last step in the path can return atomic values, so you have to write this as «avg * string-length name    ». Why the restriction? Possibly because some people didn’t like the consequence that the value of «1 10» would be 10.  The following table compares simple mapping expressions with «for» expressions and path expressions:  10  X P a t h :  S e q u e n c e  E x p r e s s o n s  i  For Expression  Path Expression  Simple Mapping Expression  for $x in E1 return E2 E1 E2  E1 E2  nodes or atomic values nodes  atomic values  Iterates using:  range variable  context item  context item  yes  no  Feature Syntax  Returns items of type:  no  Results are in document order with duplicates eliminated?  645   XPath: Sequence Expressions  The «some» and «ever y» Expressions  These expressions are used to test whether some item in a sequence satisﬁes a condition, or whether all values in a sequence satisfy a condition.  The syntax is:  Expression  Syntax  QuantifiedExpr   «some»  «every»  «$» VarName «in» ExprSingle   «,» «$» VarName «in» ExprSingle *  «satisfies» ExprSingle  VarName  QName  The name quantiﬁed expression comes from the mathematics on which these expressions are based: the «some» expression is known in formal logic as an existential quantiﬁer, while the «every» expression is known as a universal quantiﬁer.  As with the «for» expression, these two expressions bind a range variable to every item in a sequence in turn, and evaluate an expression  the «satisfies» expression  for each of these items. Instead of returning the results, however, a quanitiﬁed expression evaluates the effective boolean value of the «satisfies» expression. In the case of «some», it returns true if at least one of these values is true, while in the case of «every», it returns true if all of the values are true. The range variables can be referenced anywhere in the expression following the «satisfies» keyword, and the expression following the «in» keyword can use all variables declared in previous clauses of the expression  but not the variable ranging over that expression itself .  For example:  some $p in   price satisfies $p > 10000  is true if there is a   element in the document whose typed value is a number greater than 10,000, while:  every $p in   price satisfies $p > 10000  is true if every   element in the document has a typed value greater than 10,000.  The result of the expression  unless some error occurs  is always a single xs:boolean value.  The «satisfies» expression is evaluated to return a boolean value. This evaluation returns the effective boolean value of the expression, using the same rules as for the boolean   function and the condition in an «if» expression. For example, if the result of the expression is a string, the effective boolean value is true if the string is not zero-length. The expression will almost invariably reference each one of the range variables, although the results are still well deﬁned if it doesn’t.  As with «for» expressions, «some» and «every» expressions do not change the context item. This means that the following is wrong  it’s not an error, but it doesn’t produce the intended answer :   :wrong:  some $i in   item satisfies price > 200  646   The «some» and «every» Expressions  It should be written instead:   :correct:  some $i in   item satisfies $i price > 200  Note that if the input sequence is empty, the «some» expression will always be false, while the «every» expression will always be true. This may not be intuitive to everyone, but it is logical — the «every» expression is true if there are no counter-examples; for example, it’s true that every unicorn has one horn, because there are no unicorns that don’t have one horn. Equally, and this is where the surprise comes, it is also true that every unicorn has two horns.  You can exploit this. I was experimenting recently with the new feature in XML Schema 1.1 to write XPath assertions in a schema, and I wanted to express the rule ‘‘if this element has a   child which itself has a   child, then the   in turn must have a   child’’. I found I could write this as:  every $r in simpleContent restriction satisfies $r simpleType  If there isn’t a «simpleContent restriction», this assertion is automatically true.  It is always possible to rewrite an «every» expression as a «some» expression, and vice versa. The expression:  every $s in $S satisfies C  is equivalent to:  and of course:  is equivalent to:  not some $s in $S satisfies not C    some $s in $S satisfies C  some $s in $S satisfies $s C  exists $S[C]   as:  as:  if    item[price*quantity > 1000]  ...  not every $s in $S satisfies not C    Alternatively, if there is only a single range variable, you can usually rewrite the expression:  which some people prefer, as it is more concise. If the sequence $S consists of nodes, you can also leave out the call on the exists   function; for example, you can rewrite:  if  some $i in   item satisfies $i price * $i quantity > 1000  ...  10  X P a t h :  S e q u e n c e  E x p r e s s o n s  i  647   XPath: Sequence Expressions  The difference is a matter of taste. The «some» expression, however, is more powerful than a simple predicate because  like the «for» expression  it can handle joins, using multiple range variables.  The XPath 2.0 speciﬁcation describes the semantics of the «some» and «every» expressions in a rather complicated way, using a concept of ‘‘tuples of variable bindings’’. This happened because the XPath 2.0 speciﬁcation is generated by subsetting XQuery 1.0, whose core construct, the FLWOR expression, makes use of this concept already. It would have been possible to specify «some» and «every» in a much simpler way for XPath users. In fact, the expression:  some $s in $S, $t in $T, $u in $U satisfies CONDITION  has exactly the same effect as the expression:  exists for $s in $S, $t in $T, $u in $U return boolean CONDITION [.]   while the expression:  every $s in $S, $t in $T, $u in $U satisfies CONDITION  has exactly the same effect as the expression:  empty for $s in $S, $t in $T, $u in $U return not CONDITION [.]   The rather unusual predicate «[.]» selects all the items in a sequence whose effective boolean value is true. In the ﬁrst case, the result is true if the result of the «for» expression contains at least one value that is true, while in the second case, the result is true if the result of the «for» expression contains no value that is false.   The functions exists   and empty   are described in Chapter 13. The exists   function returns true if the supplied sequence contains one or more items, while empty   returns true if the sequence contains no items.   Examples Expression  some $i in   item satisfies $i price gt 200  Description Returns true if the current document contains an   element with a   child whose typed value exceeds 200.  some $n in 1 to count $S -1 satisfies $S[$n] eq $S[$n + 1]  Returns true if there are two adjacent values in the input sequence $S that are equal.  every $p in   person satisfies $p @dob castable as xs:date  Returns true if every   element in the current document has a dob attribute that represents a valid date, according to the XML Schema format YYYY-MM-DD.  some $k in   keyword,  $p in   para  satisfies contains $p, $k   every $d in   termdef @id satisfies  some $r in   termref satisfies $d eq $r @def  Returns true if there is at least one <keyword< in the document that is present in at least one  element of the document.  Returns true if every   element with an id attribute is referenced by at least one   element with a matching def attribute.  648   The «some» and «every» Expressions  Quantiﬁcation and the «=» Operator  An alternative to using the «some» expression  and sometimes also the «every» expression  is to rely on the implicit semantics of the «=» operator, and other operators in the same family, when they are used to compare sequences. As we saw in Chapter 8, these operators can be used to compare two sequences, and return true if any pair of items  one from each sequence  satisﬁes the equality condition.  For example, the expression:    book[author="Kay"]  means the same as:  Similarly, the expression:    book[some $a in author satisfies $a eq "Kay"]    book[author= "Kay", "Tennison", "Carlisle" ]  means the same as:    book[some $a in author,  $s in  "Kay", "Tennison", "Carlisle"   satisfies $a eq $s]  It’s a matter of personal style which one you choose in these cases. However, if the operator is something more complex than straight equality — for example, if you are comparing the two values using the compare   function with a non-default collation — then the only way to achieve the effect within XPath is to use a «some» or «every» expression.  Errors in «some» and «every» Expressions  Dynamic  runtime  errors can occur in «some» and «every» expressions just as in any other kind of XPath expression, and the rules are the same. But for these expressions the rules have some interesting consequences that are worth exploring.  Let’s summarize the rules here:           If a dynamic error occurs when evaluating the «satisfies» expression, then the «some» or «every» expression as a whole fails with an error. As soon as the system ﬁnds an item in the sequence for which the «satisfies» expression is true  in the case of «some»  or false  in the case of «every» , it can stop the evaluation. It doesn’t need to look any further. This means that it might not notice errors that would be found if it carried on to the bitter end. The system can process the input sequence in any order that it likes. This means that if there is one item for which evaluating the «satisfies» expression returns true, and another for which it raises an error, then you can’t tell whether the «some» expression will return true or raise the error.  Some systems might deliberately choose to exploit these rules by evaluating the error cases last  or pre- tending to do so  so as to minimize the chance of the expression failing, but you can’t rely on this.  10  X P a t h :  S e q u e n c e  E x p r e s s o n s  i  649   XPath: Sequence Expressions  What does this mean in practice? Suppose you have an attribute deﬁned in the schema as follows:                                                       Or to put it more simply, the attribute’s typed value is a list of atomic values, each of which is either a decimal number or the string value «n a». For example, the attribute might be written «readings = "12.2 -8.4 5.6 n a 13.1"».  Now suppose you want to test whether the set of readings includes a negative value. You could write:  if  some $a in data @readings  satisfies $a lt 0  then ...  The chances are you will get away with this. Most processors will probably evaluate the condition «$a lt 0» against each value in turn, ﬁnd that the condition is true for the second item in the list, and return true. However, a processor that decided to evaluate the items in reverse order would encounter the value «n a», compare this with zero, and hit a type error: you can’t compare a string with a number. So one processor will give you the answer true, while another gives you an error.  You can protect yourself against this error by writing the expression as:  if  some $a in data @readings [. instance of xs:decimal]  satisfies $a lt 0   then ...  Or in this case, you can mask the error by writing:  if  some $a in data @readings  satisfies number $a  lt 0  then ...  This works because «number ‘n a’ » returns NaN  not-a-number , and «NaN lt 0» returns false.  650   Summary  Summar y  This chapter covered all the various kinds of expressions in the XPath language that are designed to manipulate general sequences, speciﬁcally:                    The «,» operator, which appends two sequences The «to» operator, which forms a sequence of ascending integers Filter expressions, which are used to ﬁnd those items in a sequence that satisfy some predicate The «for» expression, which applies an expression to every item in a sequence and returns the results, as a new sequence Simple mapping expressions, which apply the « » operator to atomic values The «some» and «every» expressions, which test whether a condition is true for some value  or every value  in an input sequence, returning a boolean result  Don’t forget that these are not the only constructs available for manipulating sequences. For sequences of nodes, path expressions can be used, as well as the «union», «intersect», and «except» operators, as discussed in Chapter 9. And in Chapter 13 you will ﬁnd descriptions of all the functions in the standard XPath library, including many functions that are useful for operating on sequences, for example, count  , deep-equal  , distinct-values  , empty  , exists  , index-of  , insert-before  , remove  , sub- sequence  , and unordered  .  The next chapter deals with operations involving types: operations that convert a value of one type into a value of another type, and operations that test the type of a value.  10  X P a t h :  S e q u e n c e  E x p r e s s o n s  i  651    11  X P a t h :  T y p e  E x p r e s s o n s  i  XPath: Type Expressions  This chapter is concerned with XPath expressions that involve types. This includes operations to convert a value of one type to a value of another type  which is called casting , and operations to test whether a value belongs to a particular type.  The type system for XPath was fully explained in Chapter 5. Recall in particular that there are two sepa- rate but related sets of types we are concerned with:        Every value in XPath  that is, the result of every expression  is an instance of a sequence type. This reﬂects the fact that every XPath value is a sequence. A sequence type in general deﬁnes an item type that each of the items in the sequence must conform to, and a cardinality that constrains the number of items in the sequence. The items may be either nodes or atomic values, so item types divide into those that permit nodes and those that permit atomic values. There are also two special item types, the type item  , which permits anything, and the type empty-sequence  , which permits nothing. Every element and attribute node conforms to a type deﬁnition contained in a schema, or a built-in type deﬁnition that is implicit in every schema. To distinguish these clearly from sequence types, I will refer to these types as schema types. A schema type may be either a sim- ple type or  for elements only  a complex type. A simple type may be either a list type, a union type, or an atomic type. A type deﬁnition constrains the contents of a node  that is, the value of an attribute, or the attributes and children of an element ; it does not constrain the name of the node.  We need to use careful language to avoid confusing these two views of the type system. When we have an XPath value that is a node, we will speak of the node being an instance of a sequence type — for example, every element is an instance of the sequence type element  . At the same time, the node is annotated with a schema type — for example, an element node may be annotated as an mf:invoice  which will be the name of a complex type deﬁned in some schema .  These two sets of types  sequence types and schema types  overlap: in particular, atomic types such as xs:integer belong to both sets. However, list types, union types, and complex types are never used as item types or sequence types; they are used only to annotate nodes. Equally, item types such as comment   are only used in sequence types; they are never used to annotate nodes. This idea is illustrated in Figure 11-1.  The ﬁrst part of this chapter is concerned with conversion of values from one type to another. These types are always atomic types; no conversions are deﬁned for any types other than atomic types. The process of   XPath: Type Expressions  atomization, which extracts the typed value of a node, could be regarded as a conversion, but we won’t treat it as such for our present purposes.  Item types  Schema types  list  node  atomic  union  complex  Figure 11-1  Atomic types can be referred to by the name given to them in the schema. A schema can deﬁne anony- mous atomic types, but because these have no name, they can’t be referenced in an XPath expression. Named atomic types are always deﬁned by a top-level   element in a schema  more speciﬁcally, by an   element that is a child of either an   element or an   element , and these elements always have a name attribute.  The ﬁnal part of this chapter deals with two operators  «instance of» and «treat as»  that take as their ‘‘operands’’ an arbitrary XPath value  that is, a sequence , and a sequence type.  I’ve written ‘‘operands’’ in quotes, because a true operand is always a value, and in the XPath view of the world, types are not values . These two constructs require a special syntax for describing sequence types. For example, «attribute *, xs:date ?» describes a sequence type whose item type matches any attribute node annotated as an xs:date, and whose cardinality allows the sequence to contain zero or one values. I will refer to such a construct as a sequence type descriptor, because the construct seems to need a name, and the XPath speciﬁcation doesn’t give it one.  Conver ting Atomic Values  The operation of converting an atomic value of one type into an atomic value of another type is called casting.  The word casting is used with the meaning that it has in SQL, which is subtly different from the usage in many other programming languages. In Java, casts perform a dual role: casting an Object is more like the «treat as» operator described later in this chapter, which doesn’t actually change the value from one type to another. But casts in Java are also used for conversions among the primitive types, which is analagous to casting in XPath.  As well as an operator to perform a cast, XPath also provides a second operator to test whether a cast is possible. This has been provided because there is no way of recovering from the error that occurs when a cast fails  if, for example, you convert a string to a date and the string does not contain a valid date . Instead of attempting the cast and then dealing with the error when it fails, XPath encourages you ﬁrst to test whether it will succeed and then to perform the conversion only if this is the case. So if $p is a user-supplied parameter that is supposed to contain a valid date, you can write:  if  $p castable as xs:date  then xs:date $p  else     The syntax for the «cast as» and «castable as» operators is shown below. Both operators are written as compound tokens.  654   Converting Atomic Values  Expression  CastableExpr  CastExpr  SingleType  AtomicType  Syntax  CastExpr  «castable» «as» SingleType ?  UnaryExpr  «cast» «as» SingleType ?  AtomicType «?»?  QName  11  X P a t h :  T y p e  E x p r e s s o n s  i  The rule for SingleType is confusing at ﬁrst sight. It means that the AtomicType may optionally be followed by a question mark.  In all these cases, the AtomicType must correspond to the name of an atomic type  that is, a simple type that is not a list type or a union type  that is present in the static context for the XPath expression. Most commonly, this will be one of the built-in types such as xs:integer or xs:date, but it can also be a user-deﬁned type. The type name is written as a QName, and its namespace preﬁx must therefore have been declared to reference the targetNamespace of the schema in which the type is deﬁned. If the name has no preﬁx, the default namespace for elements is used; in XSLT, this will be the null namespace, unless the xpath-default-namespace attribute has been set to identify a different namespace.  The concept of the static context was described in Chapter 7. An atomic type will be present in the static context either if it is a built-in type such as xs:date, or if it is deﬁned in a schema that has been explicitly imported using the   declaration in XSLT, or its equivalent in a different XPath host language.  A question mark after the type name means that an empty sequence is allowed as the value. For example, the expression «@A cast as xs:integer» will fail if the attribute A does not exist, but the expression «@A cast as xs:integer?» will succeed, returning an empty sequence.  The «castable as» expression returns true if the corresponding «cast as» expression would succeed, and false if the corresponding «cast as» expression would fail. For example, the string «2009-02-29» is not a valid date, so the expression «"2009-02-29" castable as xs:date» returns false.  Both the «cast as» and «castable as» operators perform atomization on the supplied value. This means that if the supplied value is a node, its typed value is ﬁrst extracted. If the operand  after atomization  is a sequence of more than one item, then a type error occurs in the case of «cast as», or the value false is returned in the case of «castable as».  There is a shorthand for a «cast as» expression, which is to use a constructor function. For example, the expression «@A cast as xs:integer?» can be rewritten as a function call, «xs:integer @A ». There is a constructor function available for every built-in atomic type, and for every named atomic type in an imported schema, and its effect is identical to using the «cast as» expression with the «?» option  that is, if an empty sequence is supplied to a constructor function, it returns an empty sequence . The only cases where you need to use the full «cast as» expression are:    When you want to indicate that an empty sequence is not allowed.   When the type name is deﬁned in a schema with no target namespace  unless the default func-  tion namespace is the null namespace, which would be unusual, and cannot arise in XSLT . When your type names are unpreﬁxed, you have to use the more verbose «cast as» syntax.  The sections that follow describe all the rules for converting a supplied value to a target type. We’ll start by considering the rules for converting from a primitive type to another primitive type and then go on to consider how derived types are handled.  655   XPath: Type Expressions  Converting between Primitive Types  The type conversions described in this section start with an atomic value that is labeled with a primitive type. For these purposes we consider a primitive type to be either one of the primitive types deﬁned in Part 2 of the XML Schema speciﬁcation, or the XPath-deﬁned atomic type xs:untypedAtomic.. Although in XPath the types xs:integer, xs:dayTimeDuration and xs:yearMonthDuration are sometimes treated as primitive, in this chapter we will treat them as derived types, which is what they actually are.  For reasons of space, few examples of conversions are given in this chapter. However, in the download ﬁles for this book there is a stylesheet, cast.xsl, which exercises all the conversions between primitive types. It requires a schema-aware XSLT processor.  We couldn’t get this stylesheet to run with our version of AltovaXML 2008.  The following table lists for each source type, the permitted destination types. The detailed rules for these conversions are then given in the subsequent sections, which for ease of reference are arranged alphabetically according to the type of the source value for the conversion.  Source Type Permitted Result Types  anyURI  anyURI, string, untypedAtomic  base64Binary base64Binary, hexBinary, string, untypedAtomic  boolean, decimal, double, float, string, untypedAtomic  date, dateTime, gDay, gMonth, gMonthDay, gYear, gYearMonth, string, untypedAtomic  date, dateTime, gDay, gMonth, gMonthDay, gYear, gYearMonth, string, time, untypedAtomic  boolean  date  dateTime  decimal  double  float  gDay  gMonth  boolean, decimal, double, float, string, untypedAtomic  boolean, decimal, double, float, string, untypedAtomic  duration  duration, string, untypedAtomic  boolean, decimal, double, float, string, untypedAtomic  gDay, string, untypedAtomic  gMonth, string, untypedAtomic  gMonthDay  gMonthDay, string, untypedAtomic  gYear  gYear, string, untypedAtomic  gYearMonth  gYearMonth, string, untypedAtomic  hexBinary  base64Binary, hexBinary, string, untypedAtomic  NOTATION  NOTATION, string, untypedAtomic  QName, string, untypedAtomic  QName  string  anyURI, base64Binary, boolean, date, dateTime, decimal, double, duration, float, gDay, gMonth, gMonthDay, gYear, gYearMonth, hexBinary, NOTATION  note 1 , QName  note 2 , string, time, untypedAtomic  continued  656   Converting Atomic Values  Source Type  time  untypedAtomic  Permitted Result Types time, string, untypedAtomic  anyURI, base64Binary, boolean, date, dateTime, decimal, double, duration, float, gDay, gMonth, gMonthDay, gYear, gYearMonth, hexBinary, string, time, untypedAtomic  Note 1: Casting from a string to xs:NOTATION itself is not allowed, because xs:NOTATION is an abstract type. Casting to a user-deﬁned subtype of xs:NOTATION is permitted, but only if the string is written as a string literal.  Note 2: Casting from a string to xs:QName is allowed only if the string is written as a string literal. This means that the cast can always be done at compile time, which avoids problems in deciding the appropriate namespace context to use for the conversion.  Converting from anyURI  Destination Type Rules  anyURI  string  The value is returned unchanged.  The value is returned as a string containing exactly the same characters as the supplied anyURI value. No percent-encoding or -decoding of special characters is performed.  untypedAtomic  Returns the same result as converting to a string, but the result is labeled as untypedAtomic.  Converting from base64Binary  Destination Type Rules  base64Binary  The value is returned unchanged.  hexBinary  string  A hexBinary value is constructed containing the same octets as the original base64Binary value.  The canonical lexical representation of the base64Binary value is returned, as a string. This representation is deﬁned in Part 2 of the XML Schema speciﬁcation  be sure to read the latest version, the original has been corrected . It outputs the value with no whitespace.  untypedAtomic  Returns the same result as converting to a string, but the result is labeled as untypedAtomic.  11  X P a t h :  T y p e  E x p r e s s o n s  i  Converting from boolean  Destination Type Rules  boolean  decimal  The value is returned unchanged.  true is converted to 1.0, false to 0.0.  continued  657   XPath: Type Expressions  Destination Type Rules  Converting from date  Destination Type Rules  double  float  string  true is converted to 1.0e0, false to 0.0e0.  true is converted to xs:float 1.0e0 , false to xs:float 0.0e0 .  Returns the string "true" or "false".  untypedAtomic  Returns the same result as converting to a string, but the result is labeled as untypedAtomic.  date  dateTime  gDay  gMonth  gMonthDay  gYear  gYearMonth  string  The value is returned unchanged.  Returns the dateTime representing the instant in time at which the relevant date starts. The timezone  or the absence of a timezone  is retained unchanged. For example, the date 2008-04-04 becomes the dateTime 2008-04-04 T00:00:00.  Returns a gDay value containing the same day component and timezone  or absence of a timezone  as the original date.  Returns a gMonth value containing the same month component and timezone  or absence of a timezone  as the original date.  Returns a gMonthDay value containing the same month and day components and timezone  or absence of a timezone  as the original date.  Returns a gYear value containing the same year component and timezone  or absence of a timezone  as the original date.  Returns a gYearMonth value containing the same year and month components and timezone  or absence of a timezone  as the original date.  Returns the canonical lexical representation of the date, retaining the original timezone. For example, a date with no timezone might be converted to the string «2008-06-19», while a date in the Paciﬁc timezone might become «2008-06-19-08:00». The timezone is represented as «±hh:mm», except for UTC which is represented by the single letter «Z».  untypedAtomic  Returns the same result as converting to a string, but the result is labeled as untypedAtomic.  Converting from dateTime  Destination Type Rules  date  dateTime  gDay  658  The date component of the dateTime value is returned, including the original timezone  or absence of a timezone .  The value is returned unchanged.  Returns a gDay value containing the same day component and timezone  or absence of a timezone  as the original localized dateTime.  continued   Converting Atomic Values  Destination Type Rules  gMonth  gMonthDay  gYear  gYearMonth  string  Returns a gMonth value containing the same month component and timezone  or absence of a timezone  as the original localized dateTime.  Returns a gMonthDay value containing the same month and day components and timezone  or absence of a timezone  as the original localized dateTime.  Returns a gYear value containing the same year component and timezone  or absence of a timezone  as the original localized dateTime.  Returns a gYearMonth value containing the same year and month components and timezone  or absence of a timezone  as the original localized dateTime.  Returns the lexical representation of the dateTime, retaining the original timezone. The timezone is represented as «±hh:mm», except for UTC, which is represented by the single letter «Z». This is not the same as the canonical lexical representation deﬁned in XML Schema, which always normalizes the timezone to UTC.  time  Returns the time component of the original localized dateTime, retaining its timezone.  untypedAtomic  Returns the same result as converting to a string, but the result is labeled as untypedAtomic.  Converting from decimal  Destination Type Rules  boolean  decimal  double  float  string  The value 0.0 is converted to false, and any other value is converted to true.  The value is returned unchanged.  The result is the closest double value to the supplied decimal. This may involve some loss of precision, because decimal values cannot usually be represented exactly in binary. The detailed rules are deﬁned by saying that the result is equivalent to converting the decimal to a string and then converting the string to a double. If the value exceeds the largest possible double value this is treated as a numeric overﬂow, which gives three options: raising an error, returning Inﬁnity, or returning the largest non-inﬁnite double value.  As with conversion from decimal to double, the rules are deﬁned by saying that the decimal is converted to a string, and the string is then converted to a float. The same considerations apply.  If the decimal represents a whole number  whether or not it is actually an instance of xs:integer , then it is represented on output as a string of decimal digits with no trailing zero and no decimal point. There is no truncation or rounding of signiﬁcant digits, but insigniﬁcant leading or trailing zeroes are omitted. However, if the absolute value is less than one, a zero digit is included before the decimal point. The string starts with a «-» sign if the value is negative, but it never contains a «+» sign.  untypedAtomic  Returns the same result as converting to a string, but the result is labeled as untypedAtomic.  659  11  X P a t h :  T y p e  E x p r e s s o n s  i   XPath: Type Expressions  Converting from double  Destination Type Rules  boolean  decimal  double  float  string  The values positive zero, negative zero, and NaN are converted to false, and any other value is converted to true. The result is the decimal value, within the range of decimal values that the implementation can handle, whose value is numerically closest to the value of the supplied double; if two values are equally close, the value is rounded toward zero. The range and precision of the decimal type is left to the implementor’s discretion, so results may vary from one system to another. If the double is too large to be represented as a decimal, or if it is inﬁnity or NaN, an error occurs. The value is returned unchanged.  The special values NaN and inﬁnity are converted to their float equivalents. Otherwise, binary digits are removed from the least signiﬁcant end of the value to make the value ﬁt within the precision supported by the float type. If the exponent is larger than the largest exponent allowed by a float, the result is positive or negative inﬁnity. If the exponent is smaller than the smallest exponent allowed by a float, the result is positive or negative zero. If the value is NaN  not-a-number , it is output as the string «NaN». Positive and negative inﬁnity are represented as «INF» and «-INF». Numbers whose absolute value is greater than or equal to 1.0e–6, and less than 1.0e+6, are represented in conventional decimal notation; for example, «17.523» or «42»  never «42.0» . Numbers outside this range are output in ‘‘scientiﬁc’’ notation, in a form such as «1.56003E-5». There are constraints on the precise form of this value; for example, it includes no plus sign and no insigniﬁcant leading or trailing zeros except adjacent to the decimal point, and the «E» must be a capital «E». Apart from these constraints, the system can choose any string that preserves the original value when converted back to a double. If you want a more user-friendly representation of the number, XSLT allows you to control the formatting using the format-number   function. Outside the XSLT environment, you can trim unwanted digits using the function round-half-to-even  , which is described in Chapter 13. Returns the same result as converting to a string, but the result is labeled as untypedAtomic.  untypedAtomic  Converting from duration  Destination Type Rules  duration  string  The value is returned unchanged.  The duration is output in a normalized form in which the number of months will be less than 12, the number of hours less than 24, the number of minutes and seconds less than 60. Zero-valued components are omitted. A zero-length duration is output as «PT0S», unless it is an instance of xs:yearMonthDuration, in which case it is output as «P0 M». Returns the same result as converting to a string, but the result is labeled as untypedAtomic.  untypedAtomic  660   Converting Atomic Values  Converting from ﬂoat  Destination Type  boolean  decimal  double  float  string  Rules The values positive zero, negative zero, and NaN are converted to false, and any other value is converted to true.  The result is the decimal value, within the range of decimal values that the implementation can handle, whose value is numerically closest to the value of the supplied ﬂoat; if two values are equally close, the value is rounded toward zero. Overﬂow is handled in the same way as for double-to-decimal conversion: See page 660.  The value space for float is a strict subset of that for double, so it is possible to convert every ﬂoat value to a double without loss. The speciﬁcation achieves this by stating that the conversion returns the double that has the same exponent and mantissa as the supplied float, with zero, NaN and inﬁnity being treated specially.  The value is returned unchanged.  The rules are the same as those for double-to-string conversion: see page 660.  untypedAtomic  Returns the same result as converting to a string, but the result is labeled as untypedAtomic.  Converting from gDay  Destination Type  Rules The value is returned unchanged.  gDay  string  The output will be in the form ---DD, followed by a timezone if the value includes one, formatted as for xs:date.  untypedAtomic  Returns the same result as converting to a string, but the result is labeled as untypedAtomic.  Converting from gMonth  Destination Type  gMonth  string  Rules The value is returned unchanged.  The output will be in the form --MM, followed by a timezone if the value includes one, formatted as for xs:date.  There was an error in the XML Schema Recommendation, corrected in later editions, which gave the format as --MM-- .  untypedAtomic  Returns the same result as converting to a string, but the result is labeled as untypedAtomic.  11  X P a t h :  T y p e  E x p r e s s o n s  i  661   XPath: Type Expressions  Converting from gMonthDay  Destination Type Rules  gMonthDay  String  The value is returned unchanged.  The output will be in the form --MM-DD, followed by a timezone if the value includes one, formatted as for xs:date.  untypedAtomic  Returns the same result as converting to a string, but the result is labeled as untypedAtomic.  Converting from gYear  Destination Type Rules  gYear  string  The value is returned unchanged.  The output will be in the form YYYY, followed by a timezone if the value includes one, formatted as for xs:date. Negative years are preceded by «-».  untypedAtomic  Returns the same result as converting to a string, but the result is labeled as untypedAtomic.  Converting from gYearMonth  Destination Type Rules  gYearMonth  string  The value is returned unchanged.  The output will be in the form YYYY-MM, followed by a timezone if the value includes one, formatted as for xs:date. Negative years are preceded by «-».  untypedAtomic  Returns the same result as converting to a string, but the result is labeled as untypedAtomic.  Converting from hexBinary  Destination Type Rules  base64Binary  A base64Binary value is constructed containing the same octets  bytes  as the original hexBinary value.  hexBinary  string  The value is returned unchanged.  The canonical lexical representation of the hexBinary value is returned, as a string. This representation uses two hexadecimal digits to represent each octet in the value. The digits used are 0–9 and A–F  uppercase .  untypedAtomic  Returns the same result as converting to a string, but the result is labeled as untypedAtomic.  662   Converting Atomic Values  Converting from NOTATION  Destination Type Rules  NOTATION  string  Casting to xs:NOTATION itself is not permitted, because xs:NOTATION is an abstract type. When casting to a type derived from xs:NOTATION, the value is returned unchanged, provided that it meets the rules for the subtype.  If the value contains a preﬁx, the result is in the form «prefix:localName»; otherwise, the result is the local name.  untypedAtomic  Returns the same result as converting to a string, but the result is labeled as untypedAtomic.  QName  string  The value is returned unchanged.  If the value contains a preﬁx, the result is in the form «prefix:localName»; otherwise, the result is the local name.  untypedAtomic  Returns the same result as converting to a string, but the result is labeled as untypedAtomic.  11  X P a t h :  T y p e  E x p r e s s o n s  i  The string is converted to the destination type using the same rules as are applied during schema validation of an element or attribute declared with this type.  Firstly, whitespace is normalized or collapsed as determined by the whiteSpace facet of the target type.  Except for the trivial conversion from string to string, this means that leading and trailing whitespace is removed . Then the resulting value is tested to check that it is a valid lexical representation for the speciﬁed atomic type, and the corresponding value of that type is returned.  The rules are reﬁned in the case of the date and time types to allow the timezone information to be retained  in XML Schema, these are lost during the process of validation .  Conversion to xs:NOTATION itself is not allowed, because xs:NOTATION is an abstract type. Conversion to a type derived from xs:NOTATION follows the same rules as conversion to a QName — the value must be supplied as a string literal. continued  663  Converting from QName  Destination Type Rules  Converting from string  Destination Type Rules  anyURI base64Binary boolean date dateTime decimal double duration float gDay gMonth gMonthDay gYear gYearMonth hexBinary string time  NOTATION   XPath: Type Expressions  Destination Type Rules  QName  Casting from a string to a QName is allowed only if the value is supplied as a string literal. The namespace context is taken from the static context of the XPath expression. If the QName contains no preﬁx, then the default namespace for elements and types is used  in XSLT, this is the namespace declared using the xpath-default-namespace attribute .  untypedAtomic  The returned value contains the same characters as the original string, but the result is labeled as untypedAtomic.  Converting from time  Destination Type Rules  string  Returns the canonical lexical representation of the time, retaining the original timezone. For example, the value might be output as «13:20:05.012+01:00». The timezone is represented as «±hh:mm», except for UTC, which is represented by the single letter «Z».  time  The value is returned unchanged.  untypedAtomic  Returns the same result as converting to a string, but the result is labeled as untypedAtomic.  Converting from untypedAtomic  The rules for conversion from an untypedAtomic value to any other type are exactly the same as the rules for converting from an equivalent string. See page 663.  Converting between Derived Types  The previous section listed all the permitted conversions between primitive atomic types. Now we need to consider what happens if the supplied value belongs to a derived type, or if the destination type is a derived type. Note that we are still only concerned with atomic types. The destination type of a cast cannot be a list or union type. It may however be a type that is derived by restriction. This includes both built-in derived types such as xs:integer, xs:short, and xs:Name, and also user-deﬁned derived types, provided that they are named types in a schema that has been imported in the static context of the XPath expression.  The case where the supplied value belongs to a derived type is easy. As always, the principle of substi- tutability holds: a value of a subtype may always be used as input to an operation that accepts values belonging to its supertype. This means that conversion from a derived type to its base type is always suc- cessful. However, there is one minor caveat. In the tables in the previous section, conversion of a value to its own primitive type is always described with the rule ‘‘The value is returned unchanged.’’ However, if the source value belongs to a subtype of the primitive type  that is, a type derived by restriction from the primitive type , this rule should be amended to read ‘‘The value is returned unchanged, but with the type label set to the destination type’’. For example, if you cast the value xs:short 2  to the type xs:decimal, the type label on the result will be xs:decimal. In fact, it is always a rule for casting operations that the type label on the result value is the type that you were casting to.  664   Converting Atomic Values  For the second case, casting to a derived type, there are a number of different rules that come into play, and we will consider them in the following sections.           If the supplied value is of type xs:string or xs:untypedAtomic, then casting is designed to follow the same rules as schema validation. This is described in the next section: Casting from xs:string to a Derived Type. The general rule when casting from types other than xs:string or xs:untypedAtomic is the ‘‘up, across, down’’ rule. This is described in Casting Non-string Values to a Derived Type on page 666. There are some special rules that apply when casting to one of the three built-in derived types xs:integer, xs:dayTimeDuration, and xs:yearMonthDuration. These are described in the sections Casting to an xs:integer on page 667, and Casting to xs:yearMonthDuration and xs:dayTimeDuration on page 668.  Certain derived schema types, notably xs:ID, xs:IDREF, xs:NOTATION, and xs:ENTITY have associated constraints that a schema validator will check at the level of the document as a whole: for example xs:ID values must be unique, xs:IDREF values must match an xs:ID somewhere in the document, xs:NOTATION and xs:ENTITY values must refer to a notation or entity declared in the DTD. These rules are not enforced when casting, because there is no containing document to provide context.  Casting from xs:string to a Derived Type  This section describes what happens when the source value of a cast is an instance of xs:string or a type derived from xs:string, or when it is an instance of xs:untypedAtomic, and when the target type is a derived type. This includes the case where the target type is itself a subtype of xs:string.  Casting from xs:string to another primitive type was described on page 663 .  The design is intended to imitate what happens when a string making up the content of an element or attribute in raw lexical XML is put through schema validation, when the type deﬁned for the element or attribute is the same as the atomic type used as the target of the cast operation.  The stages are as follows:  The supplied value is converted to an instance of xs:string. This always succeeds.  1. 2. Whitespace normalization is applied, as deﬁned by the whiteSpace facet for the target type. This takes one of the values preserve, replace, or collapse. If the value is replace, then any occur- rence of the characters tab  x09 , newline  x0A , or carriage return  x0D  is replaced by a single space character. If the value is collapse, then whitespace is processed using the rules of the normalize-space   function described on page 845. Most types, including most subtypes of xs:string, have a whiteSpace facet of collapse. The xs:string type itself uses the value preserve, and the built-in type xs:normalizedString  despite its name  uses replace. The lexical value obtained after whitespace normalization is checked against the pattern facets of the target type  which include the pattern facets of its supertypes . The cast fails if the string does not match these regular expressions. Note that multiple patterns speciﬁed in the same sim- ple type deﬁnition are alternatives  the string must match one of the patterns , while patterns on different levels are cumulative  the string must match them all . The value is then converted to the primitive supertype of the target type, using the rules for converting a string to another primitive type given on page 663.  3.  4.  11  X P a t h :  T y p e  E x p r e s s o n s  i  665   XPath: Type Expressions  5.  6.  The resulting value is checked to ensure that it is in the value space of the derived target type, that is, to ensure that it conforms to all the other facets deﬁned on that type. Finally, the result is constructed by taking the value determined in step 4 and attaching the name of the target type as the type label.  Converting Non-string Values to a Derived Type  This section describes the rules for casting any value other than an xs:string or xs:untypedAtomic to a derived type, including a type derived from xs:string. There are some exceptions to these rules when the target type is xs:integer, xs:dayTimeDuration, or xs:yearMonthDuration; these are covered in subsequent sections.  The general rule is ‘‘go up, then across, then down’’. For example, if you are converting from a subtype of xs:decimal to a subtype of xs:string, you ﬁrst convert the supplied value up to an xs:decimal, then you convert the xs:decimal across to an xs:string, and then you convert the xs:string down to the ﬁnal destination type. Of course, any of the three stages in this journey may be omitted where it isn’t needed. See Figure 11-2, which shows casting from xs:long to xs:token.  xs:anyAtomicType  xs:decimal  xs:string  xs:boolean  xs:integer  xs:normalizedString  xs:long  xs:token  Figure 11-2  The last leg of this journey, the down part, now needs to be explained.  The rule here is  in general  that the value is not changed, but it is validated against the restrictions that apply to the subtype. These restrictions are deﬁned by facets in the schema deﬁnition of the type. If the value satisﬁes the facets, then the cast succeeds and the result has the same value as the source, but with a new type label. If the value does not satisfy the facets, then the cast fails. For example, the expression «xs:positiveInteger -5 » will cause an error, because the value -5 does not satisfy the minInclusive facet for the type  which says that the lowest permitted value is zero .  666   Converting Atomic Values  There is a slight complication with the pattern facet. This facet deﬁnes a regular expression that the value must conform to. The pattern facet, unlike all the others, is applied to the lexical value rather than the internal value. To check whether a value conforms to the pattern facet, the system must ﬁrst convert the value to a string. This is bad news if the pattern facet has been used to constrain input XML documents to use a form other than the canonical representation; for example, to constrain an xs:boolean attribute to the values «0» and «1». The conversion to a string will produce the value «true» or «false» and will therefore fail the pattern validation. Generally speaking, using the pattern facet with types other than string  or string-like types such as xs:anyURI  is best avoided.  The actual string that is checked against the pattern facet is as follows:    When converting from xs:string or xs:untypedAtomic, the value being converted.    In other cases, a lexical representation of the result of converting the value to the primitive base type of the target type, where the primitive types are considered to include xs:integer, xs:dayTimeDuration, and xs:yearMonthDuration. The lexical representation chosen is gener- ally the same as the result of casting the value to xs:string using the rules in this chapter, except in cases where XML Schema deﬁnes a canonical lexical representation that is different from the result of XPath casting. This affects the following cases:             For xs:decimal, a whole number is represented as  say  «12.0» rather than «12». For xs:double and xs:float, the value is always in exponential notation with a single non-zero digit before the decimal point; for example, «1.2E1» rather than «12». For xs:time and xs:dateTime, the value  if it has a timezone  is adjusted to UTC, so «12:00:00-05:00» is represented as «17:00:00Z». For xs:date, the timezone is adjusted to be in the range -11:59 to +12:00, adding or sub- tracting a day as necessary.  Suppose, for example, that the schema deﬁnes a my:utcTime type as a restriction of xs:time, with  . This constrains the value to end with «Z». The cast «my:utcTime  "12:00:00+01:00" » will therefore fail. However, «my:utcTime xs:time "12:00:00+01:00"  » will succeed. The cast to xs:time succeeds because the value is a valid time, and the cast to my:utcTime succeeds because the canonical lexical representation of the value is «11:00:00Z», which matches the pattern, despite the fact that the actual value is not in UTC. As I said before, the best advice one can give is to avoid this area.  11  X P a t h :  T y p e  E x p r e s s o n s  i  Casting to an xs:integer  Generally, casting to a derived type fails if the facets of the derived type are not satisﬁed. The type xs:integer is derived by restriction from xs:decimal, with a facet indicating that there must not be a fractional part. Normally, this would mean that casting 12.3 to an xs:integer would fail.  However, there is a special rule for casting numeric values to integers, or to subtypes derived from xs:integer. The value is ﬁrst cast to the primitive type, xs:decimal, in the usual way, and then the value is truncated toward zero. This means that «xs:integer 10 div 3 » is 3, and «xs:integer  3.5 - 8.7 » is -5.  This special rule does not apply when casting from a string to an integer. In this case xs:integer is treated like any other derived type, which means that a cast such as «xs:integer "2.5" » will fail.  667   XPath: Type Expressions  Casting to xs:yearMonthDuration and xs:dayTimeDuration  When an xs:duration is cast to an xs:yearMonthDuration or to an xs:dayTimeDuration, the compo- nents of the supplied value that are not applicable to the target type are discarded. This ensures that the cast will always succeed. For example, if the supplied value is xs:duration ’P1Y1D’   one year and a day, a duration found in insurance policies and fairy tales , casting to xs:yearMonthDuration produces P1Y, while casting to xs:dayTimeDuration produces P1D.  This rule applies only when the supplied value is an instance of xs:duration or one of its subtypes  either one of the built-in subtypes, or a user-deﬁned subtype . It does not apply, for example, when casting from xs:string. Furthermore, it applies only to these built-in duration subtypes, and any user-deﬁned types derived from them. It does not apply to a user-deﬁned type derived directly from xs:duration, even one whose deﬁnition is identical to that of the built-in type.  Sequence Type Descriptors  The operators described in the previous section work only on atomic types, which can always be refer- enced by a simple QName  unless they are anonymous types, in which case they can’t be referenced at all . Later in this chapter, we will be deﬁning two important operators «instance of» and «treat as». These can be applied to any sequence type  that is, any type in the XPath type system . Sequence types cannot always be represented by a simple name; instead, XPath deﬁnes a syntactic construct for describing these types. The production rule for this is called SequenceType. I ﬁnd it useful to have a name for the actual description of a type written according to this syntax, so I’ve coined the name sequence type descriptor for this.  Sequence type descriptors are used in XPath itself only in expressions involving these two operators «instance of» and «treat as». However, they are used much more widely in XSLT, notably to declare the types of variables, functions, and parameters in the «as» attribute of  ,  ,  ,  , and other similar places. They also arise in XQuery.  The syntax is quite complicated, so we’ll take it in stages, explaining the semantics as we go along.  Syntax   ItemType OccurrenceIndicator?   «empty-sequence» « » « »  OccurrenceIndicator  «?»  «*»  «+»  AtomicType  KindTest  «item» « » « »  Expression  SequenceType  ItemType  AtomicType  KindTest  QName  DocumentTest  ElementTest  AttributeTest  PITest  CommentTest  TextTest  AnyKindTest  The ﬁrst rule tells us that a sequence type descriptor is either an ItemType followed optionally by an OccurrenceIndicator, or it is the compound symbol «empty-sequence  ».  668   Sequence Type Descriptors  The «empty-sequence  » construct is used very rarely in practice. The only value that conforms to this type is the empty sequence. This is why no occurrence indicator is allowed in this case. The only practical example I have seen where «empty-sequence  » is useful is in an XQuery «typeswitch» expression. You can use it in XPath, but «$x instance of empty-sequence  » means the same as «empty $x », so it’s not a vital feature. It’s really there only for completeness, so that every type used in expressing the formal semantics of the language is also accessible to users of the language.  Apart from «empty-sequence  », every other sequence type descriptor consists of an ItemType fol- lowed optionally by an OccurrenceIndicator. The ItemType deﬁnes what kind of items can appear in a sequence, and the OccurrenceIndicator says how many of them are allowed. The three occurrence indicators  which in computer science theory are often called Kleene operators  will be familiar from their use in regular expressions and DTDs. They are:  Occurrence Indicator  *  +  ?  Meaning Zero or more occurrences allowed  One or more occurrences allowed  Zero or one occurrence allowed  If no OccurrenceIndicator is present, then a sequence will only conform to the type if it contains exactly one item.  The rest of the syntax provides different ways of expressing an ItemType.  First of all, the compound symbol «item  » allows any kind of item, that is, any atomic value, or any node.  As with other compound symbols, you can use spaces before, between, or after the parentheses, but it’s usually written without spaces so that’s how I shall do it here.  You can combine «item  » with an occurrence indicator, so «item  » matches a single item, «item  ?» matches a sequence that is either empty or contains a single item, «item  +» matches any non-empty sequence, and «item  *» matches any sequence whatsoever.  Every other way of writing the ItemType matches either atomic values, or nodes, but not both.  11  X P a t h :  T y p e  E x p r e s s o n s  i  Matching Atomic Values  Matching atomic values is easy, because atomic types have names.  You can have anonymous atomic types in a schema, but there is no way to refer to them in a sequence type descriptor . If you use a QName as the ItemType, then it must be the name of a type that is known in the static context of the XPath expression, as described in Chapter 7, and this type must be an atomic type. In XSLT 2.0 this means it must either be one of the built-in types such as xs:integer, or a user-deﬁned atomic type in a schema that has been imported using the   declaration.  The XSLT 2.0 speciﬁcation deﬁnes a minimum set of atomic types that every processor  even one that does not support schema import  must provide, namely:  xs:anyAtomicType, xs:anyURI, xs:base64Binary, xs:boolean, xs:date, xs:dateTime, xs:dayTimeDuration, xs:decimal, xs:double, xs:duration, xs:float, xs:gDay, xs:gDayMonth, xs:gMonth, xs:gMonthDay, xs:gYear, xs:gYearMonth, xs:hexBinary, xs:integer, xs:QName, xs:string, xs:time, xs:untypedAtomic, xs:yearMonthDuration  669   XPath: Type Expressions  This set was chosen because it is sufﬁcient to allow all the functions in the core function library  that is, the functions listed in Chapter 13  to be used. Schema-aware processors, however, will support the full set of built-in types deﬁned in XML Schema as well as user-deﬁned types declared using   declarations in an imported schema.  Most of these types were described fully in Chapter 5, but two are worth a special mention.        xs:untypedAtomic is the type of the atomic value that results from atomizing a node that has not been annotated  as a result of schema validation  with any more speciﬁc type. It is possi- ble to create an xs:untypedAtomic value by casting  and it is sometimes convenient to do so , but the most common way of getting these values is by atomizing an unvalidated node. xs:anyAtomicType is a supertype for all atomic types. Used as an item type, this will match any atomic value  for example, a string, an integer, or a boolean , and will not match a node. It’s an abstract type, so something that is an instance of xs:anyAtomicType will always be an instance of some other more speciﬁc type in addition.  The name is rather poorly chosen, I feel. One might expect the instances of this type to be types, just as in Java the instances of Class are classes. But the name follows the tradition set by xs:anyType and xs:anySimpleType.   Note that the QName must be the name of an atomic type, not merely a simple type. Simple types, in the XML schema classiﬁcation, also include list types and union types. Atomic values contained in an XPath sequence always belong to an atomic type, not a list or union type, and a sequence type descriptor is therefore constrained to use atomic types. This rules out types such as xs:NMTOKENS, xs:IDREFS, and xs:ENTITIES, which are list types, as well as xs:anyType, which is a complex type.  Matching Nodes  All other sorts of ItemType are used to match nodes. These all come under the umbrella of the KindTest construct.  I’ll dispose of the simple kinds of node ﬁrst, and then move on to elements and attributes, which is where the real complexity comes.  Expression  KindTest  Syntax  AnyKindTest  DocumentTest  ElementTest  AttributeTest  CommentTest  TextTest  PITest  AnyKindTest  «node» « » « »  DocumentTest  «document-node» « » ElementTest? « »  CommentTest  «comment» « » « »  TextTest  PITest  «text» « » « »  «processing-instruction» « »  NCName  StringLiteral ? « »  If you’re reading the book sequentially, you may have a sense of d´ej`a vu about these rules. We met them before in Chapter 9, on page 616, where they appear as part of the syntax for a NodeTest in a path expression. Conveniently, the syntax for testing the type of a node in an «instance of» or «treat as»  670   Sequence Type Descriptors  expression is exactly the same as the syntax for saying what kinds of node you want to select in a step of a path expression. What’s more, because the syntax of XSLT match patterns is deﬁned in terms of path expressions, you can use the same constructs when deﬁning an XSLT template rule.  The construct «node  » is the most general item type here: it matches any item that is a node.  Note, however, that if you use «node  » on its own as a step in a path expression or as an XSLT match pattern, it is short for «child::node  » and will only match nodes that are found on the child axis. The only nodes that can be found on the child axis are elements, text nodes, comments, and processing instructions.  The constructs «comment  » and «text  » are straightforward: they match comment nodes and text nodes, respectively.  For matching document nodes, you can write the test «document-node  », which matches any docu- ment node, or you can be more speciﬁc. If you include an ElementTest within the parentheses, then this ItemType will only match a document node that satisﬁes the following two conditions:        The document node must be the root of a tree that corresponds to a well-formed XML document. Speciﬁcally this means that the document node must have exactly one element node, and no text nodes, among its children. It is allowed to have comments and processing instructions before or after the element node. The element node that is a child of this document node must match the ElementTest given within the parentheses. The syntax for ElementTest is given in the next section.  This construct allows you to test what can be loosely called the ‘‘document type’’, for example, you can test whether an input document returned by the doc   function is an invoice, by writing:  if  doc "inv.xml"  instance of document-node schema-element mf:invoice    ...  This construct tests whether the document node is labeled as an invoice, as the result of previous vali- dation. If the document has not been validated, the result will be false, whether or not validation would succeed if attempted. The way you control whether doc   invokes validation depends on the XSLT pro- cessor you are using. With Saxon, you can control it using the options -val:lax or -val:strict on the command line, or on a per-document basis using parameters appended to the URI. With AltovaXML, the document will be validated if it has an xsi:schemaLocation attribute.  Because the same syntax is used in XSLT patterns  described in the next chapter , you can also use it in template rules:     The «processing-instruction  » construct can also be written with empty parentheses, in which case it will match any processing instruction. As an alternative, you can provide a name within the paren- theses, in which case it will only match processing instructions with that name. For compatibility with XPath 1.0, the name can optionally be written in quotes, as a string literal. This means you can match an   processing instruction using either of the constructs:  processing-instruction xml-stylesheet  processing-instruction "xml-stylesheet"   11  X P a t h :  T y p e  E x p r e s s o n s  i  671   XPath: Type Expressions  The two forms are precisely equivalent, except that using an invalid name is an error in the ﬁrst case but not the second  you just won’t select anything .  Matching Elements and Attributes  The syntax for matching elements and attributes is more complex, because it allows you to take advan- tage of the type information attached to these nodes as a result of schema validation. The type annotation of an element or attribute node may be any type deﬁned in an XML Schema, or a built-in type. In the case of attributes, it must be a simple type, for elements it can be either a simple or a complex type. All simple types are allowed, including list types and union types. However, although any type deﬁned in a schema can appear as a node annotation, the only types you can refer to directly are those that:        have a name  that is, they are not anonymous types, which means they must be deﬁned in top-level type deﬁnitions in the schema , and are declared in a schema that has been imported in the static context of the XPath expression. In XSLT this is achieved using the   declaration.  Here’s the basic syntax for element and attribute tests  it is organized slightly differently from the ofﬁcial W3 C grammar :  Expression  ElementTest  AttributeTest  BasicElementTest  BasicAttributeTest  Syntax  BasicElementTest  SchemaElementTest  BasicAttributeTest  SchemaAttributeTest  «element» « »   ElementNameOrWildCard  «,» TypeName «?»? ?  ? « »  «attribute» « »   AttribNameOrWildcard  «,» TypeName ?  ? « »  ElementNameOrWildcard  ElementName  «*»  AttribNameOrWildcard  AttributeName  «*»  ElementName  AttributeName  TypeName  QName  QName  QName  We will come back to the SchemaElementTest and SchemaAttributeTest later. The meaning of this syntax doesn’t leap out from the page, so it’s best to explain it by listing all the possible cases. The general form is «element  NAME, TYPE », where NAME deﬁnes conditions on the name of the element, and TYPE deﬁnes conditions on its type annotation.  672   Sequence Type Descriptors  Here are the rules for matching elements:  Matches Any element node.  Any element node.  Test  element    element *   element N   element *,T   Any element node whose name is N. In a path expression this is equivalent to just writing the element name N on its own, but in contexts where a SequenceType is required, it provides a way of saying that a value must be an element with a particular name, whether or not this name is deﬁned in any schema.  Any element node whose type annotation shows it to be valid according to the rules of schema type T. The type T can be a simple type or a complex type, but it must be a named type that is deﬁned in an imported schema  this allows a built-in type, of course . If the element has the attribute «xsi:nil = "true"», then it matches only if the type name T in the sequence type descriptor is followed by a question mark.  element N,T   Any element node whose name is N and that is annotated as an instance of schema type T. This combines the previous two options into a single condition.  The rules for matching attributes are very similar, but they are simpler because attributes cannot be marked as nillable: Test  attribute    Matches Any attribute node.  attribute *   Any attribute node.  attribute N   Any attribute node whose name is N.  attribute *,T   Any attribute node whose type annotation shows it to be valid according to the rules of schema type T. The type T must always be a named simple type that is deﬁned in an imported schema  this allows a built-in type, of course .  attribute N,T   Any attribute node whose name is N and that is annotated as an instance of the schema type T.  11  X P a t h :  T y p e  E x p r e s s o n s  i  Using Global Element and Attribute Declarations  The basic element and attribute tests described in the previous section allow you to test an element or attribute node according to its name and its type annotation, provided that the type annotation is a named simple or complex type in the schema. It’s very common, however, to ﬁnd that elements are declared in a schema using global element declarations and with an anonymous type: to take an example from the schema for XSLT 2.0 stylesheets:              673   XPath: Type Expressions                       The syntax «element E, T » doesn’t work in this case, because the type is anonymous. Instead, the construct «schema-element S » can be used. This matches any element that has been validated against the global element declaration named «S» in the schema. It’s not necessary that the name of the element should be «S»; it can also be an element in the substitution group of «S».  The ofﬁcial rule for «schema-element S » is that the element must satisfy two conditions: its element name must be present in the substitution group of S, and its type annotation must be either the type of S or one of its subtypes. There is a slight loophole in that this will match an element that was actually validated against a local element declaration that just happened to match the name and type of something in the substitution group. This loophole does little harm and was left in because preventing it would require additional information to be retained in the data model, namely an extra annotation indicating the element declaration that was used to validate an element.  It’s much less common to encounter global attribute declarations, but they are also supported in the same way, for symmetry.  The full syntax for this form of ElementTest and AttributeTest is shown below.  Expression  Syntax  SchemaElementTest  «schema-element» « » ElementName « »  SchemaAttributeTest  «schema-attribute» « » AttributeName « »  Examples  Let’s try to put these different forms into context by seeing how they can be used with a real schema. I’ll use as my example the schema for XSLT 2.0 stylesheets, which is published in an appendix of the XSLT 2.0 speciﬁcation at http:  www.w3.org TR xslt20. This example is therefore relevant if you are using XPath expressions to access an XSLT 2.0 stylesheet  which is not as esoteric a requirement as you might think , and it also assumes that the XSLT 2.0 stylesheet has been validated against this schema.  The schema starts with a couple of complex type deﬁnitions like this:                             674   Sequence Type Descriptors              Every element in the XSLT namespace has a type that is derived ultimately from «generic-element- type», and most of them are also derived from «versioned-element-type». If we want to use a sequence type descriptor  perhaps to declare a variable or a function argument in XSLT  that accepts any element in the XSLT namespace that is valid against this schema, we could declare this as:     If we wanted to exclude those elements that don’t allow a version attribute  there is only one,  , which in fact does allow a version attribute, but deﬁnes it differently , then we could write the sequence type descriptor as:     The schema goes on to provide two abstract element declarations, like this:        These are declared as abstract because you can’t actually include an element in a stylesheet whose name is   or  . The reason these two element declarations exist is so that they can act as the heads of substitution groups. This greatly simpliﬁes the deﬁnition of other types. For example, there are many places in XSLT where you can use a construct called a sequence constructor. A sequence constructor is a sequence of elements in the stylesheet that may include variable deﬁnitions, instructions, and literal result elements, and its format is deﬁned in the schema like this:  11  X P a t h :  T y p e  E x p r e s s o n s  i  Elements that allow a sequence constructor as their content, such as   and  , make use of a complex type deﬁnition that refers to this structure:                             <xs:group ref="xsl:sequence-constructor-group"  minOccurs="0" maxOccurs="unbounded" >           The abstract element   was introduced for convenience in deﬁning the schema, but it is equally convenient for describing types in XPath, because we can now write:  schema-element xsl:instruction   675   XPath: Type Expressions  to match any element that is an XSLT instruction: that is, an element that is in the substitution group of  . An example of such an element is  , which as we have already seen is deﬁned like this:                                   The schema for XSLT 2.0 stylesheets does not include any global attribute declarations, so you will never see a sequence type descriptor of the form «schema-attribute xsl:xxxx ». This is fairly typical: attributes are most commonly declared either as part of the element declaration to which they belong, or in constructs such as xs:attributeGroup. For example, the set of «xsl:» preﬁxed attributes that can appear on literal result elements is deﬁned in the schema for XSLT 2.0 in an attribute group:     <xs:attribute name="extension-element-prefixes" form="qualified"  <xs:attribute name="exclude-result-prefixes" form="qualified"  <xs:attribute name="xpath-default-namespace" form="qualified"  type="xsl:prefixes" >  type="xsl:prefixes" >  type="xs:anyURI" >  <xs:attribute name="use-attribute-sets" form="qualified"  type="xsl:QNames" default="" >  <xs:attribute name="version" form="qualified"  <xs:attribute name="type" form="qualified"  type="xs:decimal" >  type="xsl:QName" >  <xs:attribute name="validation" form="qualified"  type="xsl:validation-type" >     This means that even these attributes  which are unusual because their names are in the target namespace of the schema  are not declared globally and therefore not available for use in sequence type descriptors. It would be possible to change the schema to the following form  selecting just three of the attributes for brevity :                      and you could then use «schema-attribute xsl:version » as a sequence type descriptor.  676   The «instance of» Operator  Much more common, I think, is to use the form «attribute *, T » which matches attributes that have a particular type annotation. For example, many attributes in XSLT have the type xsl:QName. An example is the name attribute of  , allowing you to write, for example, <xsl:function name="math:sqrt">. This type is a variant of the built-in type xs:QName. It has the same lexical form as an xs:QName but is not derived from it because the validation rules are subtly different: in XML Schema, an xs:QName with no preﬁx is assumed to be in the default namespace, but in XSLT, an xsl:QName with no preﬁx is assumed to be in no namespace.  If you wanted to write a stylesheet to process all the attributes of type xsl:QName, perhaps to standardize the namespace preﬁxes that are used, you could deﬁne an XSLT template rule of the form:     . . .     There is no way of writing a sequence type descriptor that matches a local element or attribute deﬁnition in a schema. In many cases local element and attributes in a schema are deﬁned by reference to a global type, and in this case you can use the syntax «element E, T » or «attribute A, T ». With this syntax, the name E or A can be any element or attribute name you choose; it doesn’t have to be the name of a global element or attribute deﬁned in the schema.  We’ve now ﬁnished our survey of the SequenceType syntax, and the next two sections describe the two XPath constructs  «instance of» and «treat as»  in which this syntax is used.  The «instance of» Operator  The «instance of» operator is used to test whether a given value conforms to a particular type. Unlike Java, the two words must be separated by whitespace.  Expression  InstanceOfExpr  Syntax  TreatExpr   «instance» «of» SequenceType   ?  As usual, the fact that the ﬁrst operand is listed as a TreatExpr is simply a way of indicating the operator priorities; these are summarized in Appendix A.  The «instance of» expression always returns a boolean result. The ﬁrst operand is evaluated, and if it conforms to the speciﬁed sequence type  as deﬁned by the rules in the previous section  the answer is true; otherwise, it is false.  It’s important to remember, whether you are testing atomic values or nodes, that the «instance of» operator is testing whether the value has a label that identiﬁes it as a member of the speciﬁed type. It isn’t testing whether the value would be a valid member of that type if the label were changed. For example:  5 instance of xs:positiveInteger  returns false  surprisingly , because although 5 satisﬁes all the conditions for a positive integer, it is not labeled as such: the type label for a numeric literal of this kind is simply xs:integer. Similarly, given an element  13.50  as the context item, the expression:  price instance of element *, xs:decimal   11  X P a t h :  T y p e  E x p r e s s o n s  i  677   XPath: Type Expressions  will return false unless the element has actually been validated and given a type annotation of xs:decimal, or some type derived from xs:decimal. The fact that validation against this type would succeed is not enough; the validation must actually have been done, so that the required type annotation is present on the node.  The «instance of» operator does not atomize its operand, so an expression such as «@code instance of xs:decimal» is always going to return false. You need either to atomize the value explicitly, by writing «data @code  instance of xs:decimal», or to test the type annotation of the node, by writing «@code instance of attribute *, xs:decimal ».  If an element or attribute is list-valued, then the type annotation on the node may be a list type, for example, «attribute *, xs:IDREFS ». But when you extract the typed value of this node using the data   function, the result is a sequence of xs:IDREF values, which you can test using the sequence type descriptor «xs:IDREF*». You cannot write «data @x  instance of xs:IDREFS», because xs:IDREFS is not an atomic type.  Similarly, when the schema deﬁnes an element or attribute as having a union type, then the type annota- tion on the node will be the union type, but the atomic values that result from atomization will belong to one or another of the members of the union type.  The «instance of» expression tests the dynamic type of a value, that is, the actual type of the value after the operand expression has been evaluated. This may or may not be the same as the static type of the operand expression. The static type of an expression will always be a supertype of the dynamic type of any possible value of the expression  or the same type, of course .  Here are some examples of «instance of» expressions used in context: Expression  Effect Selects the items in $seq that are nodes, discarding any that are atomic values.  Tests whether the sequence $seq contains at least one node.  This has exactly the same effect as the previous example. If a sequence is not an instance of «xs:anyAtomicType*», then it must contain at least one node.  This tests whether $p is a non-empty sequence. The result is the same as calling «exists $p ».  The «treat as» Operator  The «treat as» operator can be regarded as an assertion; the programmer is asserting that at runtime, the value of an expression will conform to a given type. If the assertion turns out to be wrong, evaluation of the expression will fail with a runtime error.  This is the syntax: Expression  TreatExpr  678  Syntax  CastableExpr   «treat» «as» SequenceType  ?  $seq[. instance of node  ]  if  some $s in $seq  satisfies $s instance of node     then ...  if  not $seq instance of xs:anyAtomicType*    then ...  $p instance of item   +   The «treat as» Operator  The «treat as» operator is extremely important if you are using an XPath processor that does strict static type checking  or if you want to write code that is portable between processors that do such checking and those that don’t . However, if you want to write robust code, there is no harm in using «treat as» to make explicit any assumptions you are making about types even in a system that does all its type checking dynamically, which will generally be the case when XPath is used within XSLT stylesheets.  Suppose that you are using a schema that deﬁnes a union type, an attribute quantity, say, whose value can be either an integer or one of the two strings «out-of-stock» or «unknown». It might look reasonable to write:  if  @quantity = "out-of-stock"   else if  @quantity = "unknown"   then -2  then -1  else @quantity + 2  Unfortunately, it’s not as easy as that. The three places where @quantity is used all do atomization, which will produce either a string or an integer, but at compile time it’s not known which. The «=» comparison in the condition of the «if» will fail if the value turns out to be an integer, because you can’t compare an integer to a string. The «+» operator would similarly fail if the value turned out to be a string. You and I can see that this will never happen, but the XPath processor is not so clever. All it knows at compile time is that the value might be either an integer or a string.  A processor that does strict static typing will throw this out with compile time errors, because it detects that the code is unsafe  meaning, it could throw type errors at runtime . How do you get round this?  Firstly, you could try rewriting the expression like this:  if  data @quantity  instance of xs:string  then  if  @quantity = "out-of-stock"   then -2  else if  @quantity = "unknown"   then -1  else error    else @quantity + 2  For a system that does dynamic type checking, this is good enough. It avoids the error that would other- wise occur at runtime when you try to compare an integer to a string.  But unfortunately this still won’t persuade a static type checker that all is well, because it can’t follow through the logic of this code to work out that when you take one path, the value of @quantity must be a string, and when you take a different path, it must be an integer. So you need to use «treat as», like this:  if  data @quantity  instance of xs:string  then  if   data @quantity  treat as xs:string  = "out-of-stock"   else if   data @quantity  treat as xs:string  = "unknown"    then -2  then -1  else error    else  data @quantity  treat as xs:integer  + 2  This code will work both on systems that do strict static typing, and on those that don’t. The «treat as» operator is essentially telling the system that you know what the runtime type is going to be, and you want any checking to be deferred until runtime, because you’re conﬁdent that your code is correct.  679  11  X P a t h :  T y p e  E x p r e s s o n s  i   XPath: Type Expressions  I rather suspect that few XPath 2.0 implementations will decide to implement strict static typing, so this might all turn out to be slightly irrelevant. The enthusiasm among implementors for strict static typing is far stronger in XQuery circles, where the need for optimization is so much greater. XQuery has an additional construct, the «typeswitch» expression, which makes code like that shown above much less painful to write.  There is another workaround to this problem, which is add type conversions which you know are unnec- essary, but which placate the type checker. So you could write the above expression instead as:  if  string @quantity  = "out-of-stock"   else if  string @quantity  = "unknown"   then -2  then -1  else xs:integer @quantity  + 2  Summar y  This chapter provided details of all the type-related constructs and expressions in the XPath 2.0 language.  At the beginning of the chapter we described the «cast» and «castable» operators, and constructor functions, which are used to convert an atomic value of one type to an atomic value of a different type. We provided detailed tables showing all the type conversions that are allowed by the language.  Then, moving beyond atomic types, we examined the syntax for describing sequence types. This syntax is used only in two places in XPath, the «instance of» and «treat as» expressions, but XQuery and XSLT users will use the same syntax much more widely, for example, whenever the types of variables or functions are declared.  Finally, we explained how these two expressions, «instance of» and «treat as», actually work.  We’ve now ﬁnished our tour of the XPath language syntax. The next chapter returns to XSLT with an explanation of the syntax used in match patterns, which is based on XPath syntax but is not actually part of the XPath language. Then in Chapter 13 we will look at the built-in function library — this chapter provides an alphabetical listing of all the functions in this library, including all the functions provided by every conformant XPath 2.0 processor, together with some additional functions available when XPath is used within an XSLT stylesheet.  680   XSLT Patterns  A pattern is used in XSLT to deﬁne a condition that a node must satisfy in order to be selected. The most common use of patterns is in the match attribute of  , where the pattern says which nodes the template rule applies to. For example, <xsl:template match ="abstract" introduces a template rule that matches every   element. This chapter deﬁnes the syntax and meaning of XSLT patterns.  Patterns  sometimes called match patterns  are used in just six places in an XSLT stylesheet:              In the match attribute of  , to deﬁne the nodes in a source document to which a template applies In the match attribute of  , to deﬁne the nodes in a source document to which a key deﬁnition applies In the count and from attributes of  , to deﬁne which nodes are counted when generating numbers In the group-starting-with and group-ending-with attributes of  , to identify a node that acts as the initial or ﬁnal node in a group of related nodes  12  X S L T  P a t t e r n s  Patterns and Expressions  Most of the patterns found in stylesheets are simple and intuitive. For example:  Pattern  title  Meaning Matches any   element  chapter title  Matches any   element whose parent is a   element  speech[speaker = "Hamlet"]  Matches any   element that has a child   element whose value is «Hamlet»  section para[1] Matches any   element that is the ﬁrst   child of a    element  The rules for the more complex patterns, however, are quite technical — so I’m afraid some of the expla- nations in this chapter are not going to be easy reading.   XSLT Patterns  Patterns are deﬁned in terms of the name, type, and content of a node, and its position relative to other nodes in the tree. To understand how patterns work, you therefore need to understand the tree model  described in Chapter 2  and the different kinds of node.  Patterns look very similar to XPath expressions, and it turns out that they are closely related. However, patterns and expressions are not quite the same thing. In terms of its syntax, every pattern is a valid XPath expression, but not every XPath expression is a valid pattern. It wouldn’t make any sense to use the expression «2+2» as a pattern, for example — which nodes would it match?  Expressions are deﬁned in the XPath 2.0 Recommendation, which allows them to be used in contexts other than XSLT stylesheets. For example, XPath expressions are used in the XPointer speciﬁcation to deﬁne hyperlinks between documents, and they are used in some Document Object Model  DOM  implementations as a way for applications to navigate around the DOM data structure. XML Schema 1.1 will allow XPath expressions to be used in a schema to deﬁne assertions. Patterns are local to the XSLT Recommendation, and they are found only in stylesheets, though the draft XProc pipeline language also uses them.  It would have been quite possible for XSLT to deﬁne both the syntax and the meaning of patterns quite independently of the XPath rules for expressions, but this would risk unnecessary inconsistency. What the XSLT language designers chose to do instead was to deﬁne the syntax of patterns in such a way that every pattern was sure to be a valid expression, and then to deﬁne the formal meaning of the pattern in terms of the meaning of the expression.  Look at the simplest pattern in the earlier examples, «title». If «title» is used as an expression, it’s an abbreviation for «. child::title», and it means ‘‘select all the   children of the context node.’’ How do we get from that to a deﬁnition of the pattern «title» as something that matches all   elements?  The next section The Formal Deﬁnition gives the formal deﬁnition of patterns in terms of expressions. In practice, it’s easier to think of most patterns as following their own rules — rather like the intuitive examples listed earlier — and referring to the formal deﬁnition only to resolve difﬁcult cases. So I’ll follow the formal explanation with an informal deﬁnition that’s not only more intuitive, but also closer to the way most implementations are likely to work.  When patterns are used in template rules, we need to consider what happens if the same node is matched by more than one pattern. This situation is discussed in the section Conﬂict Resolution on page 686 in this chapter.  A new feature of the XPath 2.0 data model is that it is possible to create nodes in a tree whose root node is not a document node. Such trees cause additional complications for the semantics of pattern matching. The section Matching Parentless Nodes on page 688 explains how these nodes are handled.  The bulk of the chapter is then devoted to an explanation of the syntax of patterns, and the usage of each syntactic construct that can appear in a pattern.  Changes in XSLT 2.0  The syntax of patterns is probably the area of the speciﬁcation that has changed least between XSLT 1.0 and XSLT 2.0. However, because many capabilities of patterns are picked up implicitly by virtue of the way they are deﬁned in terms of expressions, they beneﬁt automatically from many of the new features in XPath 2.0.  682   The Formal Deﬁnition  The most notable facility this introduces is the ability to match nodes according to their schema-deﬁned type. For example, you can match all date-valued attributes with the pattern «match="attribute *, xs:date "», and you can match all elements in the substitution group of the event element with the pattern «match = "schema-element event "».  There are also some changes in the semantics of patterns, designed to cope with the complications intro- duced by parentless element and attribute nodes.  In XSLT 1.0 there were three restrictions on the content of a predicate used in a pattern. All three restric- tions have been removed in XSLT 2.0.    When a pattern was used in the match attribute of   or  , the predicate  was not allowed to contain any references to variables. This was to prevent circular deﬁnitions. XSLT 2.0 allows variable references, provided that they do not introduce a circular deﬁnition. For the same reasons, when a pattern was used in the match attribute of   or  , XSLT 1.0 did not allow the predicate to use the key  function. Again, this rule has been replaced with a more permissive rule that says you can use the key  function provided it doesn’t introduce a circularity. In XSLT 1.0, patterns were not allowed to use the current   function  described on page 734 in Chapter 13  within a predicate. XSLT 2.0 allows this and deﬁnes that, within a pattern, current   refers to the node that is being tested against the pattern.        The Formal Deﬁnition  The XSLT speciﬁcation deﬁnes the way patterns are evaluated in terms of the XPath expression that is equivalent to the pattern. We’ve already seen that every pattern is a valid XPath expression. In fact, the rules are written so that the only XPath expressions that can be used as patterns are those that return a sequence of nodes. The idea is that you should be able to decide whether a node matches a pattern by seeing whether the node is in the sequence returned by the corresponding expression.  This then raises the question of context. The result of the XPath expression «title» is all the   children of the context node. Does that include the particular   element we are trying to match, or not? It obviously depends on the context. Because we want the pattern «title» to match every   element, we could express the rule by saying that the node we are testing  let’s call it N  matches the pattern «title» if we can ﬁnd a node  A, say  anywhere in the document, which has the property that when we take A as the context node and evaluate the expression «title» the node N will be selected as part of the result. In this example, we don’t have to look very far to ﬁnd node A: in fact, only as far as the parent node of N.  So the reason that a   element matches the pattern «title» is that it has a parent node, which when used as the context node for the expression «. child::title» returns a sequence that includes that   element. The pattern might be intuitive but, as you can see, the formal explanation is starting to get quite complex.  In an early draft of the XSLT 1.0 speciﬁcation, the rules allowed almost any path expression to be used as a pattern. For example, you could deﬁne a pattern «ancestor::*[3]», which would match any node that was the great grandparent of some other node in the document. It turned out that this level of generality was neither needed nor possible to implement efﬁciently, and so a further restriction was imposed, that the only axes you could use in a pattern were the child and attribute axes  the various axes were  12  X S L T  P a t t e r n s  683   XSLT Patterns  explained in Chapter 9 . A consequence of this is that the only place where the XSLT processor has to look for node A  the one to use as a context node for evaluating the expression  is among the ancestors of the node being matched  N , including N itself.  This brings us to the formal deﬁnition of the meaning of a pattern. For the moment let’s ignore the complications caused by parentless nodes; I return to these later on page 688.  The node $N matches a pattern PAT if $N is a member of the sequence selected by the expression «root $N    PAT ».  The way this rule is expressed has changed since XSLT 1.0, but the effect is the same. It has become possible to simplify the rule as a result of the generalization of path expressions that has happened in XPath 2.0. In XPath 1.0, XPath expressions such as «   ab » or «    a » were not allowed, so this rule would have made many patterns illegal.  Let’s see what this rule means. We start with a node $N that we want to test against the pattern. First we ﬁnd the root node of the tree containing $N. Then we look for all the descendant-or-self nodes of this root node, which means all the nodes in the tree except for attributes and namespaces. For each one of these nodes, we evaluate the pattern as if it were an XPath expression, using that node as the context node. If the result includes the original node $N, we have a match.  Applying the Deﬁnition in Practice  Let’s see how this rule works by testing it against some common cases:                    If the pattern is «title» then a node matches the pattern if the node is included in the result of the expression «root .    title » which is the same as «  title». This expression selects all   elements in the document, so a node matches the pattern if and only if it is a   element. If the pattern is «chapterappendix» then a node matches the pattern if it is selected by the expression «root .    chapterappendix » This expression is equivalent to «  chapter    appendix» and matches all   and   elements in the document. If the pattern is « » then a node matches if it is selected by the expression «root .      » This rather strange XPath expression selects the root node of every descendant of the root node, and then eliminates duplicates: so it is actually equivalent to the expression « » which selects the root node only.  There are complications if the root node is not a document node, for example if it is a parentless element. I will cover these complications later in the chapter: see page 688.  If the pattern is «chapter title», then a node matches if it is selected by the expression «root .    chapter title », which selects all   elements that are children of   elements. If the pattern is «para[1]», then a node matches if it is selected by the expression «root .     para[1] », which selects any   element that is the ﬁrst   child of its parent. If the pattern is «id ’S123’ », then a node matches if it is selected by the expression «root .    id ’S123’  », which is equivalent to the expression «id ’S123’ » and selects the element with an ID value of «S123».  684   An Informal Deﬁnition  An Algorithm for Matching Patterns  This means there is a theoretical algorithm for testing whether a given node N matches a pattern P, as follows: for each node, starting from N and working through its ancestors up to the root node, evaluate P as an XPath expression with that node as the context node. If the result is a sequence of nodes containing N, the pattern matches; otherwise, keep trying until you get to the root.  XSLT processors don’t usually use this algorithm, it’s there only as a way of stating the formal rules. The processor will usually be able to ﬁnd a faster way of doing the test — which is just as well, since pattern matching would otherwise be prohibitively expensive.  Although the formal rules usually give the answer you would expect intuitively, there can be surprises. For example, you might expect the pattern «node  » to match any node; but it doesn’t. The equivalent expression, «   node   » is short for «root .  descendant-or-self::node   child:: node  », and the only nodes that this can select are nodes that are children of something. Because document nodes, attribute nodes, and namespace nodes are never children of another node  see the description of the tree model on page 45 in Chapter 2 , they will never be matched by the pattern «node  ».  Patterns Containing Predicates  The formal equivalence of patterns and expressions becomes critical when considering the meaning of predicates  conditions in square brackets , especially predicates that explicitly or implicitly use the position  and last  functions.  For example, the pattern «para[1]» corresponds to the expression «root .    para [position   = 1] ». This expression takes all the   children of the context node, and then ﬁlters this sequence to remove all but the ﬁrst  in document order . So the pattern «para[1]» matches any   ele- ment that is the ﬁrst   child of its parent. Similarly, the pattern «*[1][self::para]» matches any element that is the ﬁrst child of its parent and that is also a   element, while «para[last  ! = 1]» matches any   element that is a child of an element with two or more   children.  12  X S L T  P a t t e r n s  An Informal Deﬁnition  Because they are written in terms of expressions, the formal rules for a pattern such as «book  para», encourage you to think of the pattern as being evaluated from left to right, which means ﬁnding a   element and searching for all its   descendants to see if one of them is the one you are looking for.  An alternative way of looking at the meaning of this expression, and the way in which most XSLT pro- cessors are likely to implement the pattern-matching algorithm, is to start from the right. The actual logic for testing a node against the pattern «book  para» is likely to be along the lines:           Test whether this is a   element. If not, then it doesn’t match. Test whether there is a   ancestor. If not, then it doesn’t match. Otherwise, it matches.  If there are predicates, these can be tested en route, for example to evaluate the pattern «speech [speaker = ’Hamlet’]», the logic is likely to be the following:     Test whether this is a   element. If not, then it doesn’t match.  685   XSLT Patterns        Test whether this element has a   child whose typed value is «Hamlet» If not, then it doesn’t match. Otherwise, it matches.  Most patterns can thus be tested by looking only at the node itself and possibly its ancestors, its attributes, and its children. The patterns that are likely to be the most expensive to test are those that involve looking further aﬁeld. For example, consider the pattern «para[last  -1]», which matches any   element that is the last but one   child of its parent. Most XSLT processors, unless they have an exceptionally good optimizer, are going to test whether a particular   element matches this pattern by counting how many children the parent element has, counting how many preceding   siblings the test   has, and comparing the two numbers. Doing this for every   element that is processed could get a little expensive, especially if there are hundreds of them with the same parent. With the patterns «para[1]» or «para[last  ]» you’ve a slightly better chance that the processor will ﬁgure out a quicker way of doing the test, but it would be unwise to rely on it.  If you write a stylesheet with a lot of template rules, then the time taken to ﬁnd the particular rule to apply to a given node can make a signiﬁcant difference. The exact way in which different XSLT processors do the matching may vary, but one thing you can be sure of is that patterns containing complex predicates will add to the cost.  Conﬂict Resolution  When a pattern is used in the deﬁnition of a template rule, it is possible that several patterns may match the same node. There are rules for resolving this conﬂict, which are described in the section Choosing a Template Rule in the entry for   in Chapter 6, page 242. One of the factors these rules take into account is the default priority of the pattern, which is determined from the way it is written. The default priority is decided according to the following rules. A numerically higher value indicates a higher priority. Note that some of the priorities are fractional, and some are negative.  If the pattern is a union of two or more patterns  «P1P2» , then the processor treats it as if there were two completely separate template rules speciﬁed, one for P1 and one for P2, and it calculates the default priority of P1 and P2 independently, using the rules in the table.  If the pattern starts with an axis speciﬁer  «child::», «attribute::» or «@» , this does not affect the priority. Pattern Syntax  Default Priority  document-node schema-element QName   document-node element QName, QName   schema-element QName  element QName, QName  schema-attribute QName  attribute QName, QName   QName document-node element QName   document-node element *, QName    686  +0.25  0.0  continued   Pattern Syntax  element QName  element *, QName  attribute QName  attribute *, QName  processing-instruction Literal  processing-instruction NCName   NCName:* *:NCName    document-node   document-node element    document-node element *   * element   element *  attribute   attribute *  text   comment   processing-instruction   node    Otherwise  Conﬂict Resolution  Default Priority  –0.25  −0.5  +0.5  12  X S L T  P a t t e r n s  These default priorities are carefully chosen to reﬂect the selectivity of the pattern:           The patterns «node  » and «text  » and «*» are not very selective at all; they match any node of the right node kind, so they have a low priority of -0.5. Patterns of the form «abc:*» or «@xyz.*» are more selective; they will match element or attribute nodes belonging to a particular namespace only, so they have a higher priority than the previous category. Patterns such as «*:abc» are also placed in this category, because they are less speciﬁc than a pattern that fully speciﬁes the node name but more speciﬁc than one that speciﬁes only the kind of node. Patterns such as «title» or «@isbn» are the ones most commonly encountered; their default priority of 0.0 reﬂects the fact that in terms of selectivity, they are typical. Other patterns that specify the kind of node as well as its name fall into the same group. Patterns that specify the schema type of the node without specifying its name; for example, «element *, pers:employee » are placed at the same level because they might be more or less speciﬁc than a pattern specifying the node name. Patterns that specify both the node name and its schema type, for example «attribute @code, mf:part-number », are more speciﬁc than those that specify only the name or the type, so they get a priority of +0.25. Patterns that provide a more speciﬁc context, for example «book[@isbn]» or «chapter  title» or «para[1]», have a higher priority, so they will be chosen in preference to templates whose patterns are respectively «book», «title» or «para». Note, however, that this category can also include patterns that turn out not to be very selective at all; for example, «  node  ». All these values are chosen to leave you free to allocate your own priorities as natural numbers, for example «1» «2» «3», and such templates will always be chosen ahead of those with a system- allocated default priority.        687   XSLT Patterns  You may ﬁnd that stylesheets are easier to understand and less error prone if you avoid relying on default priorities, and use explicit priorities whenever you have more than one template rule that can match the same node.  Although the default priorities are carefully chosen, they do not guarantee that a highly selective pat- tern will always have higher priority than a less selective pattern. For example, the patterns «sec- tion para» and «section para[1]» both have priority +0.5. Similarly, the patterns «attribute *, xs:integer » and «attribute *, xs:decimal » have the same priority, even though the nodes that match the ﬁrst pattern are a subset of those that match the second. Choosing your own priorities is therefore a more reliable approach.  A complete description of the conﬂict resolution rules, including the role played by the default priority of the pattern, is described under   on page 242 in Chapter 6.  Matching Parentless Nodes  In XSLT 1.0, every node belonged to a tree with a document node at its root. In fact, because the root was always the same kind of node, this kind of node was known as a root node rather than a document node. This has changed in XSLT 2.0: you can now have elements, or even attributes and text nodes, that have no parent. For example, if you write:      2   5   9      then the value of the variable $seq is a sequence of three element nodes. These element nodes have no parent, and they are therefore not siblings of each other. The XPath expression «$seq e» will not select anything, because none of the three nodes in $seq has a child element whose name is «e». If you want to select the «e» element, you should write «$seq[self::e]»  or, if you prefer, «$seq self::e» .  A tree may thus be rooted at an element node rather than a document node, and this affects the rules for pattern matching. Two consequences of parentless elements complicate the rules.  The ﬁrst consequence has to do with error handling. In XPath, using an expression such as « » or «  book» is an error if the context item is in a tree whose root is not a document node. The same applies to the id   and key  functions. This could mean that if you wrote <xsl:apply-templates select = "$seq" >, where $seq is a sequence of parentless elements, then as soon as the system tried to match it against a template rule specifying  , a runtime error would occur. This would happen, of course, only if the processor took the naive approach of matching every node against every pattern in the stylesheet, and even then only if it took the formal approach of evaluating the equiv- alent XPath expression. In practice, neither the user nor the implementor would be very happy if this was deﬁned to be an error, so the speciﬁcation includes a  very ad hoc  rule saying that the system never attempts to match a parentless node against a pattern starting with « » or key  or id  , and therefore never hits this error condition.  More generally, runtime errors can also occur when evaluating a predicate in a pattern. For example, matching the pattern «  book[@price div 0 = 0]» could cause a runtime error  division by zero . The spec is open ended about these; it makes it clear that whether or not a particular error is ever reported will depend on the order in which the processor chooses to test the different patterns, and even then, on its evaluation strategy for a particular pattern. It also allows processors to ignore such errors, simply behaving as if the pattern does not match.  688   The Syntax of Patterns  The other problem that occurs with parentless nodes is that using the deﬁnition as we have it so far, the pattern «match = "ex"» means «match = "child::e"» and would match an   element only if it is a child of something. The working group decided that this would be just too confusing, and resolved that the pattern «e» should match every   element whether or not it has a parent. Similarly, «chapter   para» should match every   whose parent is a  , whether or not the   has a parent.  The way that the formal deﬁnition of patterns has been bent to meet this requirement is somewhat tor- tuous. It is done by introducing two new axes, child-or-top, and attribute-or-top, and using these axes in the ﬁrst step of a RelativePathPattern in place of the usual child and attribute axes. The child-or-top axis selects the children of the context node, unless the context node is a parentless ele- ment, text node, comment, or processing instruction, in which case it selects the parentless context node itself. Similarly, the attribute-or-top axis selects the context node itself if it is a parentless attribute node. Given these two extra axes, the equivalence between patterns and XPath expressions continues to hold.  These axes, of course, are purely notional. You can’t use them explicitly either in an XPath expression or in a pattern.   Note that this reﬁnement does not apply to patterns starting with « ». The pattern «  book», which in XSLT 1.0 matched exactly the same nodes as the pattern «book», now has a slightly different meaning: it selects only   elements that are descendants of a document node. It will not select a parentless   element, or a   element in a tree whose root is a parentless element. This, incidentally, means that «match = "  book"» is quite likely to be less efﬁcient than «match = "book"» because the system now has to check what kind of node is at the root of the tree.  The Syntax of Patterns  The rest of this chapter gives the detailed syntax rules for patterns.  The indented hierarchy that follows shows the overall structure of the rules. Constructs marked with the symbol § are deﬁned in the XPath grammar, speciﬁcally in Chapter 7.  12  X S L T  P a t t e r n s  Pattern  PathPattern  RelativePathPattern  PatternStep  PatternAxis NodeTest Predicates  Expr §  IdKeyPattern Literal § VariableReference §  The rules are presented in top-down order, starting with the Pattern construct itself.  The production rules use the same syntax notation that is used to deﬁne the syntax of XPath expres- sions as described in Chapter 7. The entry for each construct deﬁnes the syntax using a BNF notation, it describes the meaning of the construct in a section headed Effect and then includes sections relating to the Usage of the construct, followed by Examples. The BNF uses chevrons to enclose literal symbols but is otherwise conventional: alternatives are indicated using «», repetition by «*», and optional constructs by «?»  689   XSLT Patterns  Pattern  Syntax  Effect  Usage  Examples  This is the top-level construct for the XSLT Pattern syntax. A pattern deﬁnes a condition that is either true or false for any given node in a document. The syntax for a Pattern is a subset of the syntax for a UnionExpr  and therefore for an Expr  in the XPath expression syntax.  Expression  Syntax  Pattern  PathPattern  Pattern «» PathPattern  A Pattern is either a PathPattern or a sequence of PathPatterns separated by the union operator «». The syntax of a PathPattern is given in the next section.  A node matches a Pattern if it matches any of the PathPatterns contained in the Pattern.  Although «» is technically a union operator, it is simpler to read it as «or» — a node matches the pattern «AB» if it matches either A or B or both. In patterns, the «» operator can be used only at the top level. XPath 2.0 allows expressions such as « chapappendix  title», but this is not a valid pattern. The required effect can be achieved by writing «chap titleappendix title» or, if you prefer, «title[parent::chapparent:: appendix]».  Construct  TITLE  Meaning «TITLE» is a PathPattern, so it is also a Pattern.  prefacechapter appendix  A node matches this pattern if it is a   element, a   element, or an   element.   *  A node matches this pattern if it is either a document node or an element node.  A PathPattern states conditions that a node must satisfy based on its name, its node kind, its position relative to other nodes, and or its ID and key values. This construct is a subset of the PathExpr construct in the XPath grammar.  PathPattern  Syntax  Expression  Syntax  PathPattern  690  RelativePathPattern  « » RelativePathPattern?  «  » RelativePathPattern  IdKeyPattern   « »«  » RelativePathPattern  ?   The Syntax of Patterns  This production rule is the way the syntax is deﬁned in the XSLT speciﬁcation. However, the follow- ing equivalent production rule may be easier to understand, and it corresponds more closely with the description in the Usage section discussed later. Expression  PathPattern  Syntax « » RelativePathPattern  « » RelativePathPattern  «  » RelativePathPattern  IdKeyPattern IdKeyPattern « » RelativePathPattern IdKeyPattern «  »RelativePathPattern  The syntax of a RelativePathPattern  page 693  and that of an IdKeyPattern  page 704  are described later. Effect  The syntax rule reproduced earlier from the XSLT speciﬁcation can be better understood by listing the seven different kinds of PathPattern, as follows: Construct  « »  RelativePathPattern  « » RelativePathPattern  Meaning Matches a document node. Matches a node that can appear anywhere in the document. Example: «book chapter title» matches any   element whose parent is a   element that is a child of a   element. Matches a node via a deﬁned path from a document node. Example: « book title» matches a   element that is a child of a   element whose parent is a document node.  12  X S L T  P a t t e r n s  «  » RelativePathPattern Matches a node that can appear anywhere in the document. The  IdKeyPattern  IdKeyPattern « » RelativePathPattern  IdKeyPattern «  » RelativePathPattern  inclusion of the leading «  » rules out nodes in trees that don’t have a document node at their root. It also affects the default priority of a template rule that uses this pattern. The default priority of a pattern comes into play when two template rules match the same node: for details, see the description of   in Chapter 6, page 483. Example: «  title» matches any   element within a tree that is rooted at a document node. Matches a node with a given ID attribute or key value. For example, «id ’A001’ » matches an element with an ID attribute whose value is «A001». Matches a pattern deﬁned relative to the children of a node with a given ID attribute or key value. For example, «id ’A001’  title» matches the   child of an element with an ID attribute whose value is «A001». Matches a pattern deﬁned relative to the descendants of a node with a given ID attribute or key value. For example, «id ’A001’   title» matches any   element that is a descendant of an element with an ID attribute whose value is «A001».  691   XSLT Patterns  Usage  The pattern « » matches any document node. This means that if you have several trees  which will be the case in a stylesheet that uses the document   or doc   functions described in Chapter 13 , the pattern « » will match the document nodes of each one. This makes it difﬁcult to write different template rules to match the document nodes of different trees. There are a few ways around this problem:           If your documents are of different types  that is, if they use different schemas, or different top- level elements in the same schema , then you can distinguish them using a pattern such as «document-node schema-element invoice  » or «document-node schema-element  purchase-order  » These constructs are described on page 700 later in the chapter. You can use different modes to process each tree  see the section Modes on page 247 in Chapter 6 . You can start the processing of secondary documents at the element node immediately below the root. A pattern such as « item» will match an item element that is an immediate child of the document node. This kind of pattern is often useful when your stylesheet is dealing with multiple source documents, because it allows you to distinguish them by the name of the document element.  The pattern « @width» is legal but meaningless; it would match a width attribute of the document node, but as the document node cannot have attributes, there is no such node.  To match every   element, use the pattern «para» in preference to «  para» The latter will work  except in non-document trees , but its default priority is different, and it may be less efﬁcient. For the other kinds of PathPattern, see RelativePathPattern  on this page  and IdKeyPattern  page 704  discussed later.  Examples  Construct      *   booklist    book  book  element *, mfg:invoice   692  Meaning Matches a document node.  Matches the outermost element node in a document  the document element . In the case of a tree that is not well formed  see page 48 in Chapter 2 , it matches any element whose parent is a document node.  Matches any   element whose parent is a document node.  Matches any   element that has a document node as an ancestor.  Matches any   element.  Matches any element annotated as conforming to the schema-deﬁned type mfg:invoice.  attribute *, xs:date  Matches any attribute annotated as an xs:date, including subtypes of  xs:date.  id ’figure-1’   Matches an element with an ID attribute having the value ’figure-1’.  id ’figure-1’   *  Matches any descendant element of an element with an ID attribute having the value ’figure-1’.  key ’empnr’, ’624381’   @dob  Matches the dob attribute of an element having a value ’624381’ for the key named empnr.   The Syntax of Patterns  RelativePathPattern  A RelativePathPattern consists of a PatternStep deﬁning conditions that a node must satisfy, option- ally preceded by a RelativePathPattern that a parent or ancestor node must satisfy  the syntax puts it the other way around, but the effect is the same, and it’s easier to think of it from right to left . The syntax for a RelativePathPattern is a subset of the syntax for a RelativePathExpr in the XPath Expression language.  Syntax  Expression  Syntax  RelativePathPattern  PatternStep PatternStep « » RelativePathPattern  PatternStep «  » RelativePathPattern  A RelativePathPattern is thus a sequence of one or more PatternSteps separated by either of the operators « »  is-parent-of  or «  »  is-ancestor-of .  The syntax of a PatternStep is described on the next page.  Effect  Because in practice patterns are likely to be evaluated from right to left, it’s easier to explain the semantics if we rearrange the syntax, as follows.  Expression  RelativePathPattern  Syntax PatternStep  RelativePathPattern « » PatternStep  RelativePathPattern «  » PatternStep  12  X S L T  P a t t e r n s  With the ﬁrst form, PatternStep, a node matches the pattern if it satisﬁes the conditions  node name, node kind, and predicates  deﬁned in the PatternStep. The simplest and most common form of PatternStep is simply an element name, for example «title».  With the second form, RelativePathPattern « » PatternStep, a node matches the pattern if it satisﬁes the conditions  node name, node kind, and predicates  deﬁned in the PatternStep, and if its parent node matches the RelativePathPattern. This RelativePathPattern may in turn include conditions that the parent node’s parent or ancestor nodes must satisfy.  With the third form, RelativePathPattern «  » PatternStep, a node matches the pattern if it satisﬁes the conditions  node name, node kind, and predicates  deﬁned in the PatternStep, and if it has an ances- tor that matches the RelativePathPattern. This RelativePathPattern may in turn include conditions that the ancestor node’s parent or ancestor nodes must satisfy.  Usage  Notice that although there is an equivalence between RelativePathPattern in the pattern language and RelativePathExpr in the expression language, the meaning of a RelativePathPattern is most easily explained by examining the PatternSteps from right to left, starting at the node being tested and work- ing up through its ancestors, if necessary; this is despite the fact that the meaning of a RelativePathExpr  693   XSLT Patterns  is explained by considering the Steps from left to right, starting at the context node. It’s likely that most implementations will adopt a strategy similar to the algorithm as I’ve explained it here.  Generally speaking, there is no point in making patterns any more selective than is necessary. For example, if a   element always appears as a child of  , then there is no point in specifying the pattern as «table row» — you might just as well use the simpler pattern «row».  In theory, everything you can do in a RelativePathPattern could be done in a single PatternStep, because the pattern «A B» means exactly the same as «B[parent::A]» and the pattern «A  B» means exactly the same as «B[ancestor::A]». However, where several steps are present, the form using « » and «  » operators is a lot easier to read.  Examples  Construct  title  section title  chapter  footnote  chapter[1]  footnote  PatternStep  Meaning This is a PatternStep, and therefore the simplest form of RelativePathPattern. It selects any   element.  This is a RelativePathPattern consisting of two PatternSteps joined by the « »  is-parent-of  operator. It matches a   element whose parent is a   element.  This is a RelativePathPattern consisting of two PatternSteps joined by the «  »  is-ancestor-of  operator. It matches a   element that is a descendant of a   element.    element that is a descendant of a   element that is a child of a   element.  This pattern matches every   element in the ﬁrst chapter  more strictly, in a   that is the ﬁrst child   of its parent .  chapter section  footnote A more complex RelativePathPattern that matches any  A PatternStep deﬁnes conditions that an individual node must satisfy: typically some combination of the node name, node kind, schema type, and a set of boolean or numeric predicates. The syntax for a PatternStep is a subset of the syntax for an AxisStep in the XPath expression language.  Expression  Syntax  PatternStep  PatternAxis  PatternAxis? NodeTest Predicates «child» «::»  «attribute» «::»  «@»  Syntax  694  continued   The Syntax of Patterns  Expression  NodeTest  NameTest  Syntax NameTest  KindTest QName  «*»  NCName «:*»  «*:» NCName  Predicates   «[» Expr «]» *  The syntax of KindTest is given later on page 697. The constructs QName, NCName, and Expr are all deﬁned in the XPath 2.0 grammar, and are described in Chapter 7.  To describe the effect of a PatternStep we’ll look at each of its components separately: ﬁrst the Pattern- Axis, then the two kinds of NodeTest, that is, NameTests and KindTests, and ﬁnally the Predicates.  Effect  ThePatternAxis  The PatternAxis may take the form «attribute::»  abbreviated «@»  or «child::»  abbreviated to nothing: «»  In general, if no PatternAxis is speciﬁed, the child axis is assumed; the only exception is that when the NodeTest is an AttributeTest  for example, «attribute * »  the attribute axis is assumed.  In the formal rules for evaluating a pattern, the steps in a RelativePathPattern are evaluated from left to right, and the choice of axis determines whether this step looks at the children or the attributes of the nodes found in the previous step.  Looking at it informally, it is simplest to think of the axis speciﬁer as simply a way of saying what kind of node is required.  12  X S L T  P a t t e r n s              If the child axis is used and the NodeTest is a NameTest  for example, «title», «*», or «svg:*»   then we are looking for an element node. If the child axis is used and the NodeTest is a KindTest  for example, «comment  » or «text  » , then we are looking for that kind of node. If the NodeTest is «node  », then we are looking for any node on the child axis: speciﬁcally, elements, text nodes, comments, or process- ing instructions. Note that the pattern «node  », which is short for «child::node  », will not match document nodes, attributes, or namespace nodes, because these nodes never appear as the child of another node. If the attribute axis is used and the NodeTest is a NameTest  for example, «@title», «@*», or «@svg:*» , then we are looking for an attribute node. If the attribute axis is used and the NodeTest is a KindTest  for example, «@schema-attribute  xml:space » , then we are looking for nodes on the attribute axis. Of course, the only nodes found on the attribute axis are attribute nodes. The patterns «@comment  » and «@text  » are not illegal, but they are pointless, because the attribute axis cannot contain comments or text nodes. However, the NodeTest «@node  » looks for any node on the attribute axis, so it is equiv- alent to «@*».  If the PatternStep is the ﬁrst PatternStep in a top-level RelativePathPattern, then it matches parent- less nodes as if they had a parent. For example, the PatternStep «child::title» or «title» will match  695   XSLT Patterns  TheNameTest  a   element that has no parent node, and the PatternStep «schema-attribute  xml:space » will match an xml:space attribute that has no parent element.  The only two axes that are available directly in a pattern are the child and attribute axes. However, testing for the presence of related nodes on a different axis can be done in the predicate of the PatternStep. Any expression can be used in the predicate, and so all axes are available. For example:  caption[preceding-sibling::*[1][self::figure]]  matches a   element whose immediately preceding sibling element is a   element.  A NameTest such as «*» or «prefix:*» is purely testing the name of the node. This works whether or not there is a schema. There are four forms:              A lexical QName such as «title» or «mfg:invoice» must match both the local name and the namespace URI of the node. If the QName has a preﬁx, then it is expanded using the namespace declarations on surrounding elements in the stylesheet; if not, the XPath default namespace is used. The XPath default namespace can be set using the [xsl:]xpath-default- namespace attribute, which is described in the entry for   in Chapter 6, page 480. The NameTest «*» matches any node of the principal node kind for the axis. The NameTest «prefix:*» matches any node whose name is in a particular name- space. There must be a declaration for this namespace  of the form «xmlns:prefix = "uri"»  on some enclosing element in the style-sheet module, and the namespace is the one with the corre- sponding URI. The NameTest «*:local-name» matches any node with the speciﬁed local name, regardless of its namespace. This includes nodes whose name is not in any namespace.  In all these cases, a NameTest matches nodes only of the principal node kind for the selected axis. This means that if the PatternAxis is «@» or «attribute::», the NameTest selects attribute nodes with the given name; otherwise, it matches element nodes only.  Patterns that match nodes by name are extremely common and work well with many kinds of document. If you ﬁnd yourself writing a pattern with many alternatives, for example:  match="b  i  u  sub  sup  s"  then  if you are using a schema-aware processor  it may be worth asking yourself what these ele- ments have in common. One possibility is that they are all members of the same substitution group deﬁned in the schema: in this case, you may be able to replace the pattern with one such as «match = "schema-element inline "». Another possibility is that the elements all have the same internal struc- ture. In this case they are likely to conform to the same type deﬁnition in the schema, so you can replace the list of elements by a pattern of the form «match = "element *, inline-type "».  If the list includes most of the members of a substitution group, or most elements conforming to a given type, then you could consider excluding the unwanted ones with a predicate, for example: «match = "schema-element inline [not self::schema-element span  ]"». Alternatively, if the pattern is being used to deﬁne a template rule, simply deﬁne another template rule with higher priority to catch the exceptions.  696   The Syntax of Patterns  A pattern of the form «prefix:*», which matches all the elements  or attributes  in a particular name- space, is often useful if all that you want to do is exclude such elements from the result tree. An empty template rule takes the form:     This example causes all subtrees rooted at an element in the namespace http:  www.w3.org 2000 svg to be excluded from the result.  This is the namespace for the W3 C Scalable Vector Graphics speciﬁcation: see http:  www.w3.org TR SVG11  .  «*:local-name» patterns are new in XSLT 2.0. They should be used with care, because in principle the names in one namespace bear no relationship to names in a different namespace; for example, the «xsl:sequence» element in the XSLT namespace is quite unrelated to the «xs:sequence» element in the XML Schema namespace. However, there are cases where you might need to write a stylesheet that handles several namespaces that are variants of each other, in which many of the elements are common to more than one namespace. This can occur when matching  X HTML, which may or may not use the XHTML namespace, or when matching RSS, which also exists in both namespace and no-namespace variants.  Whereas a NameTest is designed to match nodes primarily by their name, a KindTest matches spe- ciﬁc kinds of nodes. In the case of element and attribute nodes, it also allows matching against the type annotation attached to the node as a consequence of schema validation.  The syntax of a KindTest, copied from the XPath speciﬁcation, is as follows:  12  X S L T  P a t t e r n s  TheKindTest  Expression  KindTest  Syntax  DocumentTest ElementTest AttributeTest TextTest PITest CommentTest AnyKindTest  DocumentTest  «document-node» « » ElementTest? « »  ElementTest  BasicElementTest  BasicElementTest  SchemaElementTest  «element» « »   ElementNameOrWildCard  «,» TypeName «?»? ?  ? « »  SchemaElementTest  «schema-element» « » QName « »  AttributeTest  BasicAttributeTest  SchemaAttributeTest  continued  697   XSLT Patterns  Expression  Syntax  BasicAttributeTest  «attribute» « »  AttributeNameOrWildcard  «,» TypeName ?  ? « »  SchemaAttributeTest  «schema-attribute» « » QName « »  TextTest  PITest  CommentTest  AnyKindTest  NodeName  TypeName  «text» « » « »  «processing-instruction» « »  NCName StringLiteral ? « »  «comment» « » « »  «node» « » « »  QName «*»  QName  A KindTest is used to deﬁne the kind of node that is required and, optionally, information about its schema-deﬁned type.  Let’s take the simple cases ﬁrst:  «text  » matches any text node. «comment  » matches any comment node. «node  » matches any node whatsoever  but remember that on its own, it means «child:: node  », which searches only for nodes that are children of something . «processing-instruction  » matches any processing instruction node. «processing-instruction NCName » matches any processing instruction node with the given name  the name of a processing instruction is referred to in the XML Speciﬁcation as the PITarget . For compatibility with XPath 1.0, the NCName may be written in quotes as a StringLiteral. «document-node  » matches any document node. «element  » matches any element node. This can also be written as «element * ». «attribute  » matches any attribute node. This can also be written as «attribute * ».  Now things start to get more complicated, because the other kinds of KindTest are concerned with testing for speciﬁc types of node as deﬁned in a schema. In general, you will use these KindTests only to match nodes in documents that have been validated against a schema.  KindTestsforElementNodes  Let’s look ﬁrst at the options for matching element nodes:  «element QName » matches any element node whose name is the given QName. As a pattern, this is exactly the same as writing the QName on its own.  The reason for providing this syntax is that a KindTest is allowed in contexts other than patterns; for example, in the «as» attribute of an   element.                              698                  The Syntax of Patterns  «schema-element QName » is used to test for an element that matches a top-level element dec- laration in the schema identiﬁed by the given QName. It’s an error to use this form unless you have imported a schema containing this top-level element declaration. For example, if you write «schema-element mfg:invoice », then the schema for the «mfg» namespace must have been imported, and must include a top-level element declaration of the form «xs:element name="invoice"».  The element is considered to match if two conditions are satisﬁed:    Its name is either the same as the QName, or the name of an element deﬁned in the schema to be a member of the substitution group with the named element as its head. The type of the element node, identiﬁed from its type annotation, matches the type deﬁned for this element declaration in the schema. This rule is there because a schema can allow the same name to be used in different contexts with different type deﬁnitions.     «element *, QName » is used to test for an element whose type annotation indicates that it has been successfully validated against the schema-deﬁned type deﬁnition identiﬁed by the QName. The QName can identify a built-in type such as «xs:dateTime», or a type  which may be a simple type or a complex type  that is the subject of a named type deﬁni- tion in an imported schema. The test will match any element that has a type annotation that refers to the named type, or a type derived from the named type by restriction or by extension.  If the element includes the attribute «xsi:nil = "true"», then it will match this KindTest only if the QName is followed by the symbol «?». This extra test is necessary because without it, the sys- tem would not be able to make any assumptions about the contents of the element, since xsi:nil essentially allows an element to have no content even when the schema would otherwise require it. The KindTest «element QName, QName » tests both the name of the node and its type: the name must match the ﬁrst QName, or the name of one of the elements in its substitution group, and the type annotation must match the second QName  which must be the name of a top-level type deﬁ- nition in an imported schema . Again, if the element includes the attribute «xsi:nil = "true"», then it will match this KindTest only if the second QName is followed by the symbol «?».  12  X S L T  P a t t e r n s  KindTestsforAttributeNodes  KindTests for attribute nodes follow the same format as those for element nodes, with minor variations. The same options are available, though in practice they are likely to be used rather differently. In par- ticular, global attribute declarations are not used very often in XML Schema, and matching against the names of a top-level simple type deﬁnition is probably a more likely scenario.  «attribute QName » matches any attribute whose name matches the given QName: as a pattern, this means exactly the same as @QName or attribute::QName. «schema-attribute QName » is used to test for an attribute that matches a top-level attribute declaration in the schema identiﬁed by the given QName. It’s an error to use this form unless you have imported a schema containing this top-level attribute declaration. The attribute is consid- ered to match if two conditions are satisﬁed:    Its name is the same as the QName. The type of the attribute node, identiﬁed from its type annotation, matches the type deﬁned for this attribute declaration in the schema.     699   XSLT Patterns        «attribute *, QName » is used to test for an attribute whose type annotation indicates that it has been successfully validated against the schema-deﬁned simple type deﬁnition identiﬁed by the QName. The QName can identify a built-in type such as «xs:dateTime», or a type  it will always be a simple type  that is the subject of a named type deﬁnition in an imported schema. The test will match any attribute that has a type annotation that refers to the named type, or a type derived from the named type by restriction. For example, the KindTest «attribute *, xs:date » matches any attribute whose type  as established by schema validation  is xs:date. The KindTest «attribute QName, QName » is essentially a combination of «attribute  QName » and «attribute *, QName ». This tests both the name of the node and its type: the name must match the ﬁrst QName, and the type annotation must match the second QName  which must be the name of a top-level simple type deﬁnition in an imported schema .  KindTestsforDocumentNodes  The document-node   KindTest can take an argument that is an element   or schema-element   KindTest; it then matches any document node that has the speciﬁed kind of element as its only ele- ment child. For this KindTest to work, the document must be a well-formed document in the sense that the document node has exactly one element node as a child, and no text node children, and the element node must have been validated against a schema. Here are two examples:  Construct document-node  schema-element  mfg:invoice    document-node  element *, fin:movement    UsingKindTests  Meaning Matches the document node at the root of a well-formed document whose outermost element has been validated against the top-level element declaration named «invoice» in the schema for the namespace associated with the preﬁx «mfg», or an element in the substitution group headed by the «invoice» element. This schema must have been imported into the stylesheet.  Matches the document node at the root of a well-formed document whose outermost element has the type annotation «fin:movement», or a type derived from this by restriction or extension. The schema for the namespace associated with the preﬁx «fin» must have been imported into the stylesheet.  The simple KindTests comment  , processing-instruction  , and text   are used whenever you want to match one of these kinds of node. These are used comparatively rarely. For example, it’s unusual to deﬁne a template rule that matches text nodes: usually a stylesheet will either copy text nodes unchanged, or suppress them from the output, and the choice is usually controlled from the template rule for the containing element node.  The default template rule for comment nodes causes them to be discarded; if you want to copy comment nodes to the output, you can achieve this by adding the template rule.       However, this will work only if the template rule used to process the containing element issues the instruction   to process all its children.  The [schema-]element  and [schema-]attribute   KindTests are most useful when you a process- ing a source document that has been validated against a schema, especially when the schema is fairly  700   The Syntax of Patterns  complex. It allows you to deﬁne a generic rule for a whole class of elements or attributes. There are a number of ways such a class can be identiﬁed, and the approach you use will depend on the design of your schema:  Identifying the elements or attributes by type, using the syntax «element *, QName » or «attribute *, QName » is useful for processing elements and attributes that have simple con- tent. For example, if all elements containing monetary amounts are identiﬁed as being of type «money», then you can deﬁne a template rule with the pattern «match = "element *, money "» that contains the formatting logic for values of this type. This will also work if the schema deﬁnes subtypes derived by restricting the money type; for example, a subtype that restricts the values to be positive sums of money.    Where the schema deﬁnes many elements that share the same complex type, the syntax  «element *, QName » can again be useful to deﬁne generic logic that applies to all elements of this type. For example, a schema for retail banking might deﬁne a generic type «movement» that represents all movements of money from one account to another. A template rule declared with «match = "element *, QName "» will match all elements declared with this type, or with a type derived from it. You need to be aware that in choosing a template rule, the system takes no account of the type hierarchy in the schema. If direct-debit is deﬁned as a subtype of movement, this does not mean that the template rule deﬁned with «match = "element *, direct-debit "» takes priority over the rule with «match = "element *, movement "» You need to allocate explicit priorities in the stylesheet to make sure that the right rule is invoked. If subtypes have been deﬁned by extending the base type, then it can often be useful to invoke processing of the extensions by using the   instruction, described in Chapter 6. The template rule for the base type can process all the contents that are common to all instances of the type, while the template rule for an extended type needs to process only those contents that are included in the extension. Sometimes substitution groups are used to deﬁne a collection of similar elements. Whereas types identify elements or attributes with common content, substitution groups identify elements that are interchangeable in terms of where they can appear in a document. But XML Schema also imposes a rule that an element in a substitution group must have a content model that is either a restriction or an extension of the content model of the substitution group head. This means that the elements in a substitution group will generally have some content in common, for example all elements in the substitution group of   might have attributes time and place. In this case a pattern such as «schema-element event » can be used to process this common content. Patterns that match all elements in a substitution group can also be useful in contexts other than  . For example, suppose a genealogy database allows a   ele- ment to contain any number of   elements among its children, and that elements such as  ,  ,  , and   are deﬁned as elements within the substitution group for  . In this case, if you want to number the events for a particular person you can use  .  12  X S L T  P a t t e r n s                 Predicates  The form of a Predicate is deﬁned in the XPath expression language: it is any expression enclosed in square brackets. For example «[speaker=’Hamlet’]», or «[@width> 100]» or «[*]», or «[1]». A PatternStep may include any number of predicates. These are additive — a node must satisfy all the predicates if it is to match.  701   XSLT Patterns  There are two kinds of predicate: those that depend on the node’s position relative to its siblings, and those that don’t. A positional predicate is one whose value is a number, or one that uses the functions position  or last  ; all others are nonpositional. For example, the predicates «[1]», «[position   !=1]», and «[last  -1]» are all positional predicates, whereas «[@name = ’Tokyo’]» and «[*]» are nonpositional.  For a nonpositional predicate, its meaning is that the PatternStep matches a node only if the effective boolean value of the predicate is true. The concept of effective boolean value is deﬁned in XPath, and is summarized in the entry for   on page 353 in Chapter 6. For example, the predicate «[@security = ’secret’]» is true when the node has a security attribute whose value is ’secret’, so any PatternStep that uses this predicate will fail if the node has no security attribute or if the security attribute has any value other than ’secret’.  For a positional predicate, the meaning of the predicate can be deduced from the formal rules given at the start of this chapter. However, it is easier to understand their meaning by using informal rules. A numeric predicate such as «[1]» or «[last  -1]» is equivalent to the boolean predicate «[position   = 1]» or «[position   = last  -1]». So to evaluate a positional predicate, we need to know what position   and last   are.  The use of positional predicates with the attribute axis doesn’t make much sense, because the order of attributes is undeﬁned  though I did see one stylesheet that was using «@*[1]» to match the ﬁrst attribute, and «@*» — which has lower priority — to match the others, which is perfectly legitimate so long as you realize that it’s unpredictable which of the attributes will be the ﬁrst . In the following description, I’ll assume that you’re using the child axis.  If there is only one predicate in the PatternStep, or if this predicate is the ﬁrst, then:        last   is the number of siblings of the node being tested that satisfy the NodeTest  including the node itself . For example, if we are testing a   element against the pattern «para [last   = 1]», then last   is the number of   elements that are children of the parent of the   element being tested. This pattern will match any   element that is the only   child of its parent. position   is the position of the node being tested among these siblings, taking them in document order and counting from one. So «para[1]», which means «para[position   = 1]», will match any   element that is the ﬁrst   child of its parent element, in document order.  Note that it is the position of the node relative to its siblings that counts, not the position in the sequence you are processing the nodes. For example, suppose you want to process all the   elements in a document, in alphabetical order. You can write:           Then suppose you have the following two template rules:    . . .     . . .    702   The ﬁrst template rule will be used for any   that is the ﬁrst   child of its parent. Not, as you might expect, the ﬁrst   in alphabetical order, nor even the ﬁrst   element in the document. If you want to apply different processing to the   that is ﬁrst in alphabetical order, the way to do it is as follows:  The Syntax of Patterns                . . .  . . .          This is because the context position within the body of the template rule is the position of the node in the list of nodes being processed, whereas the result for deciding whether a node matches a pattern is the same regardless of the processing context.  If there are several predicates in the PatternStep, then position  and last  in predicates after the ﬁrst apply to the nodes that survived the previous predicates. So «speech[speaker= ’Hamlet’] [1]» matches a   element that is the ﬁrst   element among its siblings, counting only those   elements in which one of the  s is Hamlet.  The position  and last  functions relate to children of the same parent even when the «  » operator is used. For example, «chapter  footnote[1]» matches any footnote element that is a descendant of a   element and that is the ﬁrst footnote child of its parent. There is no simple way to write a pattern that matches the ﬁrst footnote element in a  , because the relevant expression « chapter  footnote [1]» is not a valid pattern.  Why not? No good reason, it’s just that the spec doesn’t allow it.   12  X S L T  P a t t e r n s  If you do need to write a template rule for the ﬁrst   element in a  , the cleanest solution is probably to write your own function. You can invoke this in a predicate within the pattern, for example «match="footnote[test:position-in-chapter .  = 1]"». The deﬁnition of the function might look like this.             Examples  Construct  child::title  title  attribute::title  The following table provides some examples of PatternSteps.  Meaning Matches elements named  .  Short form of «child::title».  Matches attributes named  .  continued  703   XSLT Patterns  Construct  @title  *[@width]  text  [starts-with .,’The’ ]  p[@code][position   lt 10]  p[position   lt 10][@code]  *[not @code = preceding- sibling::* @code ]  comment    @comment    IdKeyPattern  Meaning Short form of «attribute::title».  Matches an element node that has an attribute named width.  Matches a text node whose text content starts with the characters «The».  Matches a   element that is among the ﬁrst nine   elements of its parent that have a code attribute.  Matches a   element that is among the ﬁrst nine   elements of its parent and that has a code attribute.  Matches an element node provided that it does not have a code attribute with the same value as the code attribute of any preceding sibling element.  Matches any comment node.  Matches comment nodes that are found on the attribute axis of their parent node. Because the attribute axis contains attribute nodes only, this condition can never be satisﬁed; nevertheless, it is a legal PatternStep.  This construct allows a pattern to be matched only if the node being tested  or one of its ancestors  has a speciﬁed ID attribute or key value.  This construct is a subset of the FunctionCall construct in an Expression, described in Chapter 7. The only function calls that can be used in a pattern  except within predicates  are the id   and key   functions, and these can be used only with arguments that are literals or variable references.  The id  function is an XPath function, while the key  function is exclusive to XSLT. Both are described in Chapter 13.  Syntax  Expression  Syntax  IdKeyPattern  «id» « » Value « » «key» « » StringLiteral «,» Value « »  Value  LiteralVariableReference  For both the id  and key  functions, the required value of the ID or key can be speciﬁed as either a literal or a variable reference  in the form «$» QName . For the id  function, the only kind of literal that makes sense is a string literal  for example, «"E-102"» . For the key function, numeric literals also make sense if the key values are numeric. It is not possible to supply literals for other data types such as xs:date values.  704   The Syntax of Patterns  With the key  function, the ﬁrst argument is the name of the key. This must be speciﬁed as a string literal, and it must match the name of a key deﬁned in the stylesheet.  Usage  This facility provides an equivalent to the ability in Cascading Style Sheets  CSS  to deﬁne a style for a speciﬁc node in the source document. Here are some ways it can be used:        If for a particular source document you want to use a general-purpose stylesheet, but want to override its behavior for certain selected nodes, you can write a stylesheet that imports the general-purpose one and then write the overriding rules in the form of templates that match spe- ciﬁc identiﬁed elements in the source document. Sometimes the source document is generated dynamically from a database. Perhaps there is something in the source document you want to highlight, say the search term that was used to locate this record. You could ﬂag this item while generating the source document by giving it a special ID attribute value known to the stylesheet.  In practice, this construct isn’t as useful as it might seem. Even though XSLT 2.0 has made it a lot more ﬂexible by allowing the value to be speciﬁed as a variable  which in general is likely to be a stylesheet parameter , this form of pattern still achieves nothing that can’t be achieved just as easily with a predicate, and it is unlikely to be any more efﬁcient.  For example, if   elements are keyed on their ISBN property, which is implemented as a child element, then the following declarations are equivalent:  Using a direct pattern match:  Using a key deﬁnition:          Of course, there may be a performance difference between the two, but this depends on how the XSLT processor is implemented. There is certainly no intrinsic reason why the predicate should be less efﬁcient.  Examples  id ’figure1’   Matches a node with an ID attribute equal to the string ’figure1’. An attribute is an ID attribute if it is deﬁned in the Document Type Deﬁnition  DTD  or schema as having type ID  the name of the attribute is irrelevant .  key ’empnr’,$  pers   Matches a node having a value of $pers for the key named «empnr», where $pers is typically a stylesheet parameter.  The following example shows how this feature can be used in a stylesheet.  12  X S L T  P a t t e r n s  705   XSLT Patterns  Example: Using the key   Pattern to Format a Speciﬁc Node  This example shows how to use the key  pattern to format one selected node differently from the others. The selected node will be speciﬁed by a stylesheet parameter.  Source  The source document, itinerary.xml, is a tour itinerary.     Arrive in Cairo   Visit the Pyramids at Gaza   Archaelogical Museum at Cairo   Flight to Luxor; coach to Aswan   Visit Temple at Philae and Aswan High Dam   Cruise to Edfu   Cruise to Luxor; visit Temple at Karnak   Valley of the Kings   Return flight from Luxor     Stylesheet  Let’s start with a straightforward stylesheet, itinerary.xsl, to display this itinerary.    <xsl:stylesheet version="2.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform">            Itinerary                         Day              Now let’s specialize this by importing it into another stylesheet, today.xsl, which displays the activities for a selected day in red.    <xsl:stylesheet version="2.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" xmlns:xs="http:  www.w3.org 2001 XMLSchema"  706   The Syntax of Patterns  exclude-result-prefixes="xs">                     To run this stylesheet using Saxon, enter the command line:  java net.sf.saxon.Transform -t itinerary.xml today.xsl highlight-day=5  The resulting output is as follows, when the $highlight-day parameter is set to 5:     Itinerary   Output                 Day 1   Arrive in Cairo   Day 2   Visit the Pyramids at Gaza   Day 3   Archaelogical Museum at Cairo   Day 4   Flight to Luxor; coach to Aswan   Day 5      Visit Temple at Philae and Aswan High Dam     Day 6   Cruise to Edfu   Day 7   Cruise to Luxor; visit Temple at Karnak   Day 8   Valley of the Kings   Day 9   Return flight from Luxor            While this example shows one way of using this feature, I have to admit that it’s not very con- vincing. You could achieve the same effect by writing the relevant pattern as  cid:1 day[@number = 5] cid:2 , without the need to introduce a key at all.  12  X S L T  P a t t e r n s  707   XSLT Patterns  Summar y  This chapter described the syntax and meanings of patterns, whose main use in an XSLT stylesheet is to deﬁne which template rules apply to which nodes in the source document, but which are also used in the  ,  , and   elements.  Patterns, although their syntax is a subset of that for XPath expressions, are evaluated in a different way from expressions, though we saw that the formal rules express the meaning of a pattern in terms of the corresponding expression.  The next chapter describes the library of standard functions that can be used within XPath expressions in a stylesheet.  708   The Function Librar y  This chapter describes all the standard functions included in the XSLT 2.0 and XPath 2.0 speciﬁcations for use in XPath expressions. Most of these functions are deﬁned in the W3 C speciﬁcation XPath 2.0 and XQuery 1.0 Functions and Operators, and these should be available in all XPath 2.0 implementations. Others, marked as XSLT-only, are deﬁned in the XSLT 2.0 speciﬁcation, and are available only in XPath expressions used within an XSLT stylesheet.  For each function, I give its name, a brief description of its purpose, a list of the arguments it expects and the value it returns, the formal rules deﬁning what the function does, and ﬁnally usage advice and examples.  These are not the only functions you can call from an XPath expression:              So-called constructor functions are available, corresponding to built-in and user-deﬁned atomic types. For example, there is a function called xs:float   to create values of type xs:float, xs:date   to create values of type xs:date, and so on. These functions are also available for user-deﬁned atomic types. They are described in Chapter 11. User-deﬁned functions can be created using the XSLT   declaration; these functions are available for calling from XPath expressions in the stylesheet. Vendor-deﬁned functions may be available. These will be in a namespace controlled by the vendor of the particular product. It may be possible to call functions written in external languages such as Java, JavaScript, or C. See Chapter 16 for details.    When XPath is used within another host language, additional functions may be deﬁned. For  example, the XForms speciﬁcation uses XPath and deﬁnes a number of XForms-speciﬁc functions for use in that environment.  The syntax of a function call is described in Chapter 7. This deﬁnes where a function call can be used in an expression, and where it can’t. You can use a function call anywhere that an expression or value can be used, provided that the type of value it returns is appropriate to the context where it used.  Unlike XPath 1.0, this includes the ability to use a function call as a step in a path expression.  Within a function call, the values supplied as arguments can be any XPath expression, subject only to the rules on types  for example, some functions require an argument that is a sequence of nodes . So a function call such as «count .. », though it looks strange, is perfectly legal: «..» is a valid XPath expression that returns the parent of the context node  it’s described in Chapter 9, on page 623 .  13  T h e  F u n c t i o n  i  L b r a r y   The Function Library  I’ve arranged the functions in alphabetical order  combining the XPath-deﬁned and XSLT-deﬁned func- tions into a single sequence , so you can ﬁnd a function quickly if you know what you’re looking for. However, in case you only know the general area you are interested in, you may ﬁnd the classiﬁcation that follows in the section Functions by Category useful. This is followed by a section called Notation, which describes the notation used for function speciﬁcations in this chapter. The rest of the chapter is taken up with the functions themselves, in alphabetical order.  A Word about Naming  Function names such as current-dateTime   seem very strange when you ﬁrst come across them. Why the mixture of camelCasing and hyphenation? The reason they arise is that XPath 1.0 decided to use hyphenated lower-case names for all functions, while XML Schema decided to use camelCase for the names of built-in types. Wherever the XPath 2.0 function library uses a schema-deﬁned type name as part of a function name, it therefore uses the camelCase type name as a single word within the hyphenated function name.  So it may be madness, but there is method in it!  Throughout this book, I write these function names without a namespace preﬁx. In fact the functions are deﬁned to be within the namespace http:  www.w3.org 2005 xpath-functions, which is often referred to using the namespace preﬁx «fn».  Earlier drafts of the speciﬁcation used different namespaces, which you may still encounter . In XSLT this is the default namespace for function names, so you will never need to write them with a namespace preﬁx. I have therefore omitted the preﬁx when referring to the names in this book. In the W3 C speciﬁcations, however, you will often see the functions referred to by names such as fn:position   or fn:count  .  Functions by Categor y  Any attempt to classify functions is bound to be arbitrary, but I’ll attempt it anyway. A few functions appear in more than one category. The number after each function is a page reference to the entry where the function is described. Functions marked † are available in XSLT only  that is, they are not available when executing freestanding XPath expressions or in XQuery .  Boolean Functions boolean   721, false   779, not   850, true   899.  Numeric Functions abs   714, avg   718, ceiling   723, floor   779, †format-number   788, max   830, min   830, number  851, round   870, round-half-to-even   872, sum   889.  String Functions codepoints-to-string   725, compare   727, concat   729, contains   730, ends-with   773, lower-case   827, matches   828, normalize-space   845, normalize-unicode   847, replace   862, starts-with   875, string   877, string-join   879, string-length   880, string-to-codepoints   881, substring   883, substring-after   885, substring- before   887, tokenize   894, upper-case   910.  710   Functions by Category  Date and Time Functions adjust-date-to-timezone   715, adjust-dateTime-to-timezone   715, adjust-time-to-timezone   715, current-date   738, current-dateTime   738, current-time   738, day-from-date   744, day-from-dateTime   744, †format-date   781, †format-dateTime   781, †format-time   781, hours-from-dateTime   800, hours-from-time   800, implicit-timezone   806, minutes-from- dateTime   832, minutes-from-time   832, month-from-date   833, month-from-dateTime   833, seconds-from-dateTime   873, seconds-from-time   873, timezone-from-date   893, timezone-from-dateTime   893, timezone-from-time   893, year-from-date   911, year-from-dateTime   911.  Duration Functions days-from-duration   745, hours-from-duration   801, minutes-from-duration   832, months-from-duration   834, seconds-from-duration   874, years-from-duration   911.  Aggregation Functions avg   718, count   733, max   830, min   830, sum   889.  13  T h e  F u n c t i o n  i  L b r a r y  Functions on URIs base-uri   719, collection   726, doc   750, doc-available   750, document-uri   764, encode-for-uri   771, escape-html-uri   775, iri-to-uri   811, resolve-uri   867, static-base-uri   876, †unparsed-text   904, †unparsed-text-available   904.  Functions on QNames local-name-from-QName  826, namespace-uri-from-QName  841, node-name   843, prefix-from-QName   857, QName   858, resolve-QName   864.  Functions on Sequences count   733, deep-equal   745, distinct-values   749, empty   770, exists   778, index-of   807, insert-before   810, remove   861, subsequence   882, unordered   901.  Functions That Return Properties of Nodes base-uri   719, data   741, document-uri   764, †generate-id   797, in-scope-prefixes   808, lang   819, local-name   824, name   835, namespace-uri   837, namespace-uri-for-prefix   839, nilled   842, node-name   843, root   870, string   877, †unparsed-entity-public-id   902, †unparsed-entity-uri   902.  Functions That Find Nodes collection   726, doc   750, †document   754, id   802, idref   804, †key   812, root   870.  Functions That Return Context Information base-uri   719, collection   726, †current   734, current-date   738, current-dateTime   738, †current-group   739, †current-grouping-key   740, current-time   738, default-collation   748, doc   750, implicit-timezone   806, last   820, position   854, †regex-group   860.  711   The Function Library  Diagnostic Functions error   774, trace   896.  Functions That Return Information about the XSLT Environment †element-available   764, †function-available   792, †system-property  890, †type-available  899  Functions That Assert a Static Type exactly-one   777, one-or-more   853, zero-or-one   912.  Notation  For each function  or for a closely related group of functions  there is an alphabetical entry in this chapter containing the following information:  The name of the function A summary of the purpose of the function, often with a quick example Changes in 2.0. In cases where a function was present in XSLT 1.0 or XPath 1.0, the entry for the function in this chapter contains a section that describes any changes in behavior introduced in the 2.0 version of the specs. If there are no changes, this section will say so. In cases where the function is new in XPath 2.0 or XSLT 2.0, this section is omitted. The function signature, described below A section entitled Effect, which describes in fairly formal terms what the function does    Where appropriate, a section entitled Usage, which give advice on how to make best use of  the function A set of simple examples showing the function in action Cross-references to other related information in this book                       Technically, a function in XPath is identiﬁed by its name and arity  number of arguments . This means that there is no formal relationship between the function substring   with two arguments and the function substring   with three arguments. However, the standard function library has been designed so that in cases like this where there are two functions with different arity, the functions in practice have a close relationship, and it is generally easier to think of them as representing one function with one or more of the arguments being optional. So this is how I have presented them.  The signatures of functions are deﬁned with a table like the one that follows:  Argument input  start  length  optional   Result  712  Type  xs:string?  xs:double  xs:double  Meaning The containing string  The position in the containing string of . . .  The number of characters to be included . . .  xs:string  The required substring . . .   Notation  The ﬁrst column here gives a conventional name for the argument  or ‘‘Result’’ to label the row that describes the result of the function . Arguments to XPath functions are supplied by position, not by name, so the name given here is arbitrary; it is provided only to allow the argument to be referred to within the descriptive text. The text ‘‘ optional ’’ after the name of an argument indicates that this argument does not need to be supplied; in this case, this means that there is one version of the function with two arguments, and another version with three.  The second column gives the required type of the argument. The notation is that of the SequenceType syntax in XPath, introduced in Chapter 11. This consists of an item type followed optionally by an occur- rence indicator  «?», «*», or «+» . The item type is either the name of a built-in atomic type such as xs:integer or xs:string, or one of the following:  Item type  item    node    element    xs:anyAtomicType  Numeric  Meaning Any item  either a node or an atomic value   Any node  Any element node  Any atomic value  An xs:double, xs:float, xs:decimal, or xs:integer  The occurrence indicator, if it is present, is either «?» to indicate that the supplied argument can contain zero or one items of the speciﬁed item type, or «*» to indicate that it can be a sequence of zero or more items of the speciﬁed item type.  The occurrence indicator «+», meaning one or more, is not used in any of the standard functions.   Note the difference between an argument that is optional, and an argument that has an occurrence indica- tor of «?». When the argument is optional, it can be omitted from the function call. When the occurrence indicator is «?», the value must be supplied, but the empty sequence «  » is an acceptable value for the argument.  Many functions follow the convention of allowing an empty sequence for the ﬁrst argument, or for subsequent arguments that play a similar role to the ﬁrst argument, and returning an empty sequence if any of these arguments is an empty sequence. This is designed to make these functions easier to use in predicates. However, this is only a convention, and it is not followed universally. Most of the string functions instead treat an empty sequence the same way as a zero-length string.  When these functions are called, the supplied arguments are converted to the required type in the standard way deﬁned by the XPath 2.0 function calling mechanism. The details of this depend on whether XPath 1.0 backward compatibility is activated or not. In XSLT this depends on the value of the [xsl:]version attribute in the stylesheet, as follows:  13  T h e  F u n c t i o n L b r a r y  i     In 2.0 mode, the standard conversion rules apply. These rules appear in Chapter 6 on page 505, under the heading Converting the Arguments and the Result. They permit only the following kinds of conversion:    Atomization of nodes to extract their numeric values Promotion of numeric values to a different numeric type; for example, xs:integer to xs:double Promotion of xs:anyURI values to xs:string        713   The Function Library        Casting of a value of type xs:untypedAtomic to the required type. Such values generally arise by extracting the content of a node that has not been schema-validated. The rules for casting from xs:untypedAtomic values to values of other types are essentially the rules deﬁned in XML Schema for conversion from the lexical space of the type to the value space: more details are given in Chapter 11  see Converting from string on page 663 .     In 1.0 mode, two additional conversions are allowed:    If the required type is xs:string or xs:double  perhaps with an occurrence indicator of «?» , then the ﬁrst value in the supplied sequence is converted to the required type using the string   or number   function as appropriate, and other values in the sequence are discarded. If the required type is node   or item    perhaps with an occurrence indicator of «?» , then if the supplied value contains more than one item, all items except the ﬁrst are ignored.  The effect of these rules is that even though the function signature might give the expected type of an argument as xs:string, say, the value you supply can be a node containing a string, or a node whose value is untyped  because it has not been validated using a schema , or an xs:anyURI value. With 1.0 compatibility mode on, you can also supply values of other types; for example, an xs:integer or an xs:date; but when compatibility mode is off, you will need to convert such values to an xs:string yourself, which you can achieve most simply by calling the string   function.  Code Samples  Most of the examples for this chapter are single XPath expressions. In the download ﬁle for this book, these code snippets are gathered into stylesheets, which in turn are organized according to the name of the function they exercise. In many cases the examples use no source document, in which case the stylesheet generally has a single template named main, which should be used as the entry point. In other cases the source document is generally named source.xml, and it should be used as the principal input to the stylesheet. Any stylesheets that require a schema-aware processor have names of the form xxx-sa.xsl.  Function Deﬁnitions  The remainder of this chapter gives the deﬁnitions of all the functions, in alphabetical order.  abs The abs   function returns the absolute value of a number. For example, «abs -3 » returns 3.  Signature Argument input  Result  Type  Numeric?  Numeric?  Meaning The supplied number.  The absolute value of the supplied number. The result has the same type as the input.  Effect If the supplied number is positive, then it is returned unchanged. If it is negative, then the result is «-$input» .  714   adjust-date-to-timezone  Negative zero and negative inﬁnity become positive zero and positive inﬁnity. Positive zero, positive inﬁnity, and NaN are returned unchanged. If the argument is an empty sequence, the result is an empty sequence.  The result has the same primitive numeric type as the input. For example, if the input value is an xs:integer, the result will be an xs:integer, and if the input is an xs:double, the result will be an xs:double.  Primitive here means one of the four types xs:double, xs:float, xs:decimal, and xs:integer. Clearly, if the input is an xs:negativeInteger, the result cannot also be an xs:negativeInteger — it will actually be an xs:integer. If the input is an xs:positiveInteger, you have a guarantee that the result will be an xs:integer, but this doesn’t prevent the system returning something that is actually a subtype of xs:integer — for example, it would be legitimate to return the original xs:positiveInteger unchanged.  Examples Expression  abs 2   abs -2   abs -3.7   abs -1.0e-7   abs number ’NaN’    adjust-date-to-timezone, adjust-dateTime-to-timezone, adjust-time-to-timezone This entry describes a collection of three closely related functions. These functions have the effect of returning a date, time, or dateTime based on a supplied date, time, or dateTime, modiﬁed by adding, removing, or altering the timezone component of the value.  Signature Argument Type input  xs:date?, xs:dateTime?, or xs:time?  timezone  optional   Result  xs:dayTimeDuration?  xs:date?, xs:dateTime?, or xs:time?  Meaning The date, time, or dateTime value whose timezone is to be adjusted. The type of this value must correspond to the name of the function invoked. For example, in the case of adjust-time-to-timezone   it must be an xs:time value.  Speciﬁes the new timezone value. If this argument is omitted, the effect is the same as setting it to the result of the function implicit-timezone  .  The adjusted date, dateTime, or time value.  Effect If the input is an empty sequence, the result is an empty sequence.  715  Result  2  2  3.7  1.0e-7  NaN  13  T h e  F u n c t i o n  i  L b r a r y   The Function Library  If there is no timezone argument  that is, if the function is called with a single argument , the effect is the same as calling the function with a second argument of «implicit-timezone  ». This adjusts the value to the timezone supplied in the dynamic context, which ideally will be the timezone where the user is located.  If the timezone argument is supplied, and is not an empty sequence, then it must be a duration between −50400 seconds and +50400 seconds, that is ±14 hours. To specify a timezone one hour ahead of UTC, write «xs:dayTimeDuration "PT1H" ».  These functions can be used to remove a timezone from a value that has a timezone, to add a timezone to a value that lacks a timezone, or to return the value that is equivalent to the supplied value, but in a different timezone. These effects are summarized in the table below.  Existing timezone Absent  timezone argument is    returns the input value unchanged  timezone argument is not    result has the same components as input, with the addition of the speciﬁed timezone  Present  result is the localized value of the input, with the timezone removed  result represents the same instant as the input value, but in a different timezone  The only complex case here is the one in the bottom-right cell of the table, where the supplied value already has a timezone and this is to be replaced with a new timezone. The effect varies slightly depend- ing on which if the three functions is used:           For an xs:dateTime, the result is an xs:dateTime that represents the same instant in time as the input value, but in the new timezone. For an xs:time, the result is an xs:time that represents the time in the new timezone that is simultaneous with the time provided as the input value. For an xs:date, the date is converted to an xs:dateTime representing 00:00:00 on the speciﬁed date; the requested adjustment is applied to this xs:dateTime value, and the result is the date part of the adjusted xs:dateTime.  Examples Assume that $CET is set to the timezone value +01:00, represented by the xs:dayTimeDuration PT1H. Assume that $EST is set to the timezone value -05:00, represented by the xs:dayTimeDuration -PT5H. Assume also that the implicit timezone is the timezone value -08:00, represented by the xs:dayTimeDuration -PT8H.  Here are some examples using xs:time values:  Expression  adjust-time-to-timezone  xs:time "15:00:00+01:00" , $EST   adjust-time-to-timezone  xs:time "15:00:00" , $EST   adjust-time-to-timezone  xs:time "15:00:00+01:00"    adjust-time-to-timezone  xs:time "15:00:00+01:00" ,      adjust-time-to-timezone  xs:time "15:00:00" ,      Result  09:00:00-05:00  15:00:00-05:00  06:00:00-08:00  15:00:00  15:00:00  716   The corresponding examples using xs:dateTime values are: Expression adjust-dateTime-to-timezone  xs:dateTime "2008-03-01T15:00:00+01:00" , $EST   adjust-dateTime-to-timezone   xs: dateTime "2008-03-01T15:00:00" , $EST   adjust-dateTime-to-timezone   xs: dateTime "2008-03-01T15:00:00+01:00"    adjust-dateTime-to-timezone   xs:dateTime "2008-03-01T15:00:00+01:00" ,      adjust-dateTime-to-timezone   xs: dateTime "2008-03-01T15:00:00" ,      adjust-date-to-timezone  Result  2008-03-01T09:00:00-05:00  2008-03-01T15:00:00-05:00  2008-03-01T06:00:00-08:00  2008-03-01T15:00:00  2008-03-01T15:00:00  Adjusting the timezone component of a date is a less intuitive operation, but is still well deﬁned: Expression  Result  adjust-date-to-timezone  xs:date "2008-03-01+01:00" , $EST   2008-02-29-05:00  adjust-date-to-timezone  xs:date "2008-03-01" , $EST   adjust-date-to-timezone  xs:date "2008-03-01+01:00"    adjust-date-to-timezone  xs:date "2008-03-01+01:00" ,      adjust-date-to-timezone  xs:date "2008-03-01" ,      2008-03-01-05:00  2008-02-29-08:00  2008-03-01  2008-03-01  Usage Values of types xs:dateTime, xs:time, and xs:date   either have a timezone component, or have no timezone. If they have a timezone component, it is useful to think in terms of two properties of the value, which we can call the local value and the absolute value. For example suppose you call current-time   and the implicit timezone is the timezone for Germany, +01:00. The value returned might be 14:54:06+ 01:00. The absolute value of this is the equivalent time in UTC  or ‘‘Zulu time’’, popularly Greenwich Mean Time or GMT . This is 13:54:06. The local value is the time in its original timezone, 14:54:06. Converting the value to a string always gives you the local value: 14:54:06+01:00. Getting the compo- nents of the value also returns a component of the local value: hours-from-time   applied to this value returns 14. But comparisons between two values, or calculations such as adding a duration, use the absolute value.  You can in effect freeze a value in its current timezone by calling adjust-X-to-timezone   with an empty sequence «  » as the second argument. Applied to this value, the result will be the time 14:54:06, with no timezone component. Calling hours-from-time   on this value will still return 14.  You can also determine the equivalent time in a different timezone by calling adjust-X-to-timezone   specifying the new timezone. If the input value is 14:54:06+01:00, and the new timezone is +00:00, the result will be a time value whose absolute value and local value are both 13:54:06. When you convert this to a string, the value is «13:54:06Z», and when you call hours-from-time  , the result is «13». Similarly, if you adjust this value to the timezone −05:00  New York time , the absolute value will still be 13:54:06, but the local value will be 08:54:06.  13  T h e  F u n c t i o n  i  L b r a r y  717   The Function Library  If you have a value with no timezone component, you can set a timezone, either by supplying the required timezone in the second argument or by omitting the second argument, which sets the time- zone to the implicit timezone taken from the evaluation context. When you do this, the local value of the result will be the same as the timezoneless input value. For example, if the input is 14:54:06, and you set the timezone to− 08:00, then the local value of the result will be 14:54:06, which means that its absolute value will be 22:54:06. When you convert the result to a string, the result will be «14:54:06-08:00», and when you extract the hours component, the result will be «14».  The functions work slightly differently for the three types:           For xs:dateTime, an adjustment to the time may also cause the date to change. For example, if the input time is 2008:02:29T22:00:00Z, then adjusting the timezone to +10:00 will produce the local value 2008:03:01T08:00:00+10:00. For xs:time, all adjustments are made modulo 24 hours. For xs:date, the value is treated as if it were an xs:dateTimerepresenting 00:00:00 on the speci- ﬁed date. The adjustment is made to this xs:dateTime, and the time component is then removed. For example, if the input date is 2004:03:31+00:00, then adjusting the timezone to −05:00 will return the date 2004:02:29−05:00. This involves an inevitable loss of information. You can read the semantics of the function as being ‘‘tell me what the date is in a place in timezone X, at the time when the day represented by a given date has just started in timezone Y’’.  See Also implicit-timezone   on page 806  avg The avg   function returns the average of a sequence of numbers or durations.  Signature Argument sequence  Type  xs:anyAtomicType*  Result  xs:anyAtomicType?  Meaning The input sequence. Any untyped atomic values in the input are converted to xs:double values. The resulting sequence must consist entirely of numbers, or entirely of durations of the same kind.  The average of the values in the input sequence. This will be a value of the same primitive type as the values in the input sequence. If the input values are xs:integer values, the result will be an xs:decimal.  Effect If the input sequence is empty, the result is an empty sequence. This is not an error, even though a literal interpretation of the rules would involve dividing by zero.  In all other cases the result is the same as «sum $sequence  div count $sequence ». Note that $sequence here is the atomized sequence generated by the function calling mechanism. If the sequence supplied in the call was a sequence of nodes, the number of atomic values is not necessarily the same as the number of nodes. For example, if «avg @a » is called to process a single attribute that is deﬁned in the schema to contain a list of integers, then it will return the average of these integers.  718   base-uri  The sequence of operations is as follows:  1.  2.  3.  4.  5.  6.  The sequence supplied in the argument is atomized  this is a standard action of the function calling rules when the required type only allows atomic values . Any untyped atomic values in the resulting sequence  typically, values extracted from nodes in a schemaless document  are converted to xs:double values. If this conversion fails, a runtime error is reported. If the sequence now contains any NaN  not-a-number  values, the result of the avg   function is NaN. If the values are all numeric, they are summed according to the rules for the numeric «+» opera- tor, which means that the result will depend on the types that are present in the sequence. If there is at least one xs:double, the sum will be an xs:double; otherwise, if there is an xs:float it will be an xs:float, otherwise xs:decimal or xs:integer. If the values are all durations, they are similarly summed according to the rules of the «+» oper- ator. In consequence, it is not possible to mix the two duration types, xs:dayTimeDuration and xs:yearMonthDuration. Finally, the total is divided by the number of items using the «div» operator. In the case of a numeric total, this means that the average will be the same numeric type as the sum, unless the sum is an xs:integer in which case the average will be an xs:decimal. If the items are durations, the result will be a duration of the same type as the items.  The processor is allowed to use a different algorithm which might behave differently in the event of arithmetic overﬂow.  13  T h e  F u n c t i o n  i  L b r a r y  Result      xs:decimal ’2.2’   xs:float ’3.3333333’   xs:decimal ’2.0’   xs:dayTimeDuration  ’PT18H’   Examples Expression  avg  1.0, 2.6, 3.0    avg      avg  1, xs:float ’3.5’ , 5.5    avg  1, 2, 3    avg  xs:dayTimeDuration ’P1D’ ,  xs:dayTimeDuration  ’PT12H’     See Also count   on page 733 max   on page 830 min   on page 830 sum   on page 889  base-uri The base-uri   function returns the base URI of a speciﬁc node in a document.  719   The Function Library  Signature Argument input-node  optional   Result  Type  node  ?  Meaning The node whose base URI is required  xs:string  The base URI of the node speciﬁed in the ﬁrst argument, or the context node if there are no arguments  Effect When the function is called with no arguments, the effect is the same as supplying the argument «.» — that is, it returns the base URI of the context node. If there is no context node, an error is reported.  When the ﬁrst argument is present, the function returns the base URI of the input node supplied. This is a property of the node, deﬁned in the data model. If the node was created by parsing raw XML, then the base URI is typically the URI of the resource containing the raw XML used to create the node. If the input XML used external entities, or if it was assembled from multiple source documents using XInclude, then the base URI will identify the original external entity or source document. The base URI of a node may also be altered by using the xml:base attribute in the XML. This attribute is deﬁned in the W3 C Recommendation XML Base  www.w3.org TR XMLBase .  The base URI of a node is typically used when resolving a relative URI contained in the value of that node. By deﬁnition, relative URIs refer to ﬁles  or to be more general, resources  relative to the base URI of the ﬁle containing the relative URI.  When nodes are not created directly by parsing raw XML, the concept of base URI is not so clear-cut. XSLT deﬁnes that a node in a temporary tree derives its base URI from the base URI of the stylesheet.  If the ﬁrst argument is supplied, but its value is an empty sequence, the function returns an empty sequence. An empty sequence is also returned if the function is applied to a node that does not have a base URI  for example, a parentless attribute or text node , or if the base URI of the node is unknown.  Usage and Examples The base-uri   function is useful mainly in conjunction with resolve-uri  : it gives you a base URI against which a relative URI can be resolved. For example, if you want to locate the document identiﬁed by a relative URI held in an href attribute in a source document, the following code should be used:  doc resolve-uri @href, base-uri .     Where input documents are assembled from multiple external entities, the base-uri   function can also be useful for diagnostics, to report where an error or anomaly was found during processing. In one data cleansing application, I was able to create a report in which such anomalies were grouped according to the base URI of the element where they occured, and then sorted according to the document order of those elements, thus simplifying the job of manually correcting the errors.  See Also doc   on page 750 document  on page 754 resolve-uri   on page 867 static-base-uri   on page 876  720   boolean  boolean The boolean   function calculates the effective boolean value of the supplied argument.  Changes in 2.0 The function has been generalized in XPath 2.0, so it accommodates a wider range of possible arguments.  Signature Argument value  Type  item  *  Meaning The value whose effective boolean value is required  Result  xs:boolean  The effective boolean value of the argument  Effect Many XPath 2.0 values have an effective boolean value. The boolean   function is used to calculate the effective boolean value explicitly, but it is also calculated implicitly in a number of contexts where a boolean value is required: see the Usage section below. The rules are as follows:                    If the argument is an empty sequence, then the effective boolean value is false. If the argument is a sequence whose ﬁrst item is a node, then the effective boolean value is true. If the argument is a singleton xs:boolean value, the result is the value of the argument. If the argument is a singleton numeric value, the result is false if the argument is NaN or zero; otherwise, it is true. If the argument is a singleton instance of xs:string, xs:anyURI, or xs:untypedAtomic, the result is false if the string is zero length; otherwise, it is true. In all other cases, the function reports an error.  Examples Assume the source document:             boolean   emp[@age=21]   boolean   emp[@age=53]   boolean number $John @age    boolean number $Mary @age    boolean count $John *    with the variable $John bound to the ﬁrst   element, and $Mary bound to the second. Expression  13  T h e  F u n c t i o n  i  L b r a r y  Result  false  true  true  false  false  continued  721   The Function Library  Expression  boolean string $John @surname    boolean string $John @name    boolean "true"   boolean "false"   Result  false  true  true  true  Usage In most cases conversion to an xs:boolean occurs automatically when the context requires it; it is only necessary to call the boolean   function explicitly in order to force a conversion. For example, these rules are invoked automatically when an expression is used as the condition in an «if» expression, in the «satisfies» clause of the «some» and «every» expressions, and for the operands of «and» and «or». They are also invoked in XSLT stylesheets for expressions used in   and   instructions.  The detailed rules for establishing the effective boolean value may appear somewhat arbitrary. They were deﬁned this way in large measure for backward compatibility with XPath 1.0, which allowed sequences of nodes but did not allow sequences of strings, booleans, or numbers. The rules will probably come naturally if you are familiar with weakly typed languages such as Perl or Python, but there are a few traps to beware of. For example, if you convert the boolean value false to a string, you get the string "false", but the effective boolean value of this string is true.  The boolean   function does not always return the same result as the xs:boolean   constructor. xs:boolean    like «cast as xs:boolean»  follows the rules in XML Schema that deﬁne the lexical rep- resentations of the xs:boolean type. This treats the strings "1" and "true" as true, and "0" and "false" as false; anything else is an error.  XSLT Examples The following example prints a message if the source document contains a   element and no  , or if it contains a   and no  .      Document must contain headers and footers, or neither      The conversion of the two node sequences «  header»  true if there are any   elements in the document  and «  footer»  true if there are any   elements  needs to be explicit here, because we want to do a boolean comparison, not a comparison of two node sequences.  The following example sets a variable to the xs:boolean value true or false, depending on whether the document contains footnotes. In this case the explicit conversion is probably not necessary, since it could be done later when the variable is used, but it is probably more efﬁcient to retain only an xs:boolean value in the variable rather than retaining the full set of footnote nodes. An intelligent XSLT processor will recognize that the expression «  footnote» occurs in a context where a boolean is required, and scan the document only until the ﬁrst footnote is found, rather than retrieving all of them.  In this example, however, using the function exists   would achieve the same effect.      722   ceiling  See Also exists   on page 778 false   on page 779 true   on page 899  ceiling The ceiling  function rounds a supplied number up to the nearest whole number. For example, the expression «ceiling 33.9 » returns 34.  Changes in 2.0 The function has been generalized to work on all numeric types.  Signature Argument value  Result  Type  Numeric  Numeric  Meaning The supplied value.  The result of rounding $value up to the next highest integer. The result has the same primitive type as the supplied value.  Effect If the number is an xs:integer, or is equal to an xs:integer, then it is returned unchanged.  Otherwise, it is rounded up to the next highest whole number. If the supplied value is an xs:decimal, the result will be an xs:decimal, if it is an xs:double, the result will be an xs:double, and if it is an xs:float, the result will be an xs:float.  The xs:double and xs:float types in XPath support special values such as inﬁnity, negative zero and NaN  not-a-number , which are described on page 199 in Chapter 5. If the argument is NaN, the result will be NaN. Similarly, when the argument is positive or negative inﬁnity, the function will return the value of the argument unchanged.  If the argument value is an xs:double or xs:float greater than -1.0 but less than zero it will be rounded up to negative zero. For most practical purposes, negative zero and positive zero are indistinguishable, but dividing a number by negative zero produces negative inﬁnity, while dividing by positive zero produces positive inﬁnity.  13  T h e  F u n c t i o n  i  L b r a r y  Examples Expression  ceiling 1.0   ceiling 1.6   ceiling 17 div 3   ceiling -3.0   ceiling -8.2e0   ceiling number ’xxx’    ceiling -0.5e0   Result xs:decimal 1.0, displayed as «1»  xs:decimal 2.0, displayed as «2»  xs:decimal 6.0, displayed as «6» xs:decimal −3.0, displayed as «-3» xs:double −8.0e0, displayed as «-8» xs:double NaN, displayed as «NaN» xs:double −0.0e0, displayed as «-0»  723   The Function Library  Usage One situation where this function is useful is when calculating the size of a table. If you have a sequence $ns and you want to arrange the values in three columns, then the number of rows needed is: «ceiling count $ns  div 3 ».  Although the result is numerically equal to an integer, it does not necessarily have the type xs:integer. You can force it to an integer by using the xs:integer   constructor function, for example, «xs:integer ceiling count $ns  div 3  ».  See Also floor   on page 779 round   on page 870 «idiv» operator on page 574 in Chapter 8  codepoint-equal The codepoint-equal   function compares two strings character by character: the strings are equal if they contain the same sequence of characters, regardless of the default collation in force.  Signature Argument value-1  value-2  Result  Type  xs:string?  xs:string?  xs:boolean?  Meaning The ﬁrst string to be compared  The second string to be compared  true if the two strings contain the same characters  Effect The function compares the two strings character by character, and returns true only if the strings are identical in terms of Unicode codepoints.  If either value-1 or value-2 is an empty sequence, the result is an empty sequence. This is an exception to the usual rule that string-handling functions treat an empty sequence as a zero-length string.  If the default collation is the Unicode codepoint collation, the result is exactly the same as comparing the strings using the XPath eq operator. The difference is that this function does not depend on how the default collation has been set up in the context. It is therefore useful when comparing strings such as ﬁlenames or purchase order numbers, where use of natural-language collations is inappropriate.  Although the function signature requires the arguments to be strings, the function calling rules ensure that it will also accept xs:anyURI values. In fact, it is particularly appropriate for comparing URIs and was added to the function library for that reason.  Examples Expression  codepoint-equal "http:  www.w3.org ", "http:  www.w3.org "   codepoint-equal "http:  www.w3.org ", "HTTP:  www.w3.org "   codepoint-equal "", ""   codepoint-equal   , "banana"   724  Result  true  false  true       codepoints-to-string  See Also compare   on page 727 eq operator in Chapter 8 on page 582  codepoints-to-string The codepoints-to-string   function takes as input a sequence of integers representing the Uni- code codepoint values of the characters in a string, and returns the corresponding string. For example, «codepoints-to-string  65,66,67  » returns the string "ABC".  Signature Argument codepoints  Type  xs:integer*  Meaning The sequence of codepoints. These must represent characters that are valid in XML 1.0 or XML 1.1, depending on the version that the processor supports.  Result  xs:string  The string consisting of characters with the given codepoint values.  Effect The function returns a string whose characters correspond to the Unicode codepoints in the supplied sequence.  A character whose codepoint is above xFFFF must be supplied as a single integer value, not as two code values forming a surrogate pair.  13  If the supplied sequence is empty, the result will be a zero-length string.  A common case, of course, is where the sequence of codepoints contains a single integer, in which case the resulting string will be of length one.  Integers that do not represent valid codepoints cause a runtime error. This includes the case of codepoints that are valid in Unicode, but not in XML  for example the integer zero .  T h e  F u n c t i o n  i  L b r a r y  Examples Expression  codepoints-to-string  65, 83, 67, 73, 73    codepoints-to-string 48 to 57   "0123456789"  Result  "ASCII"  codepoints-to-string      codepoints-to-string 64+$n   The zero-length string  ""   The nth letter of the English alphabet  Usage There are two main ways of using this function: as a way of constructing a string algorithmically, and as a complement to the function string-to-codepoints  .  As an example of the ﬁrst kind of application, suppose you need to construct the hexadecimal representa- tion of an integer. This might make use of an expression to return a single hex digit representing a value in the range 0–15. Here is a possible way of writing this expression:  codepoints-to-string if  $d<10  then  48+$d  else  87+$d    725   The Function Library  Personally, I prefer to code this as:  substring "0123456789abcdef", $d+1, 1   As an example of the second kind of application, suppose that you want to reverse the order of the characters in a string. One way of doing this is:  codepoints-to-string reverse string-to-codepoints $s     In this example, the two functions string-to-codepoints   and codepoints-to-string   are being used simply as a way of breaking the string into a sequence of characters, and reassembling the characters into a string; the fact that the characters are represented by Unicode codepoints has no relevance.  See Also string-to-codepoints   on page 881  collection The collection   function returns a sequence of documents, or more generally a sequence of nodes, identiﬁed by a URI. The way in which a URI can be used to locate a collection of documents is entirely implementation-deﬁned.  Signature Argument Type uri  optional   Meaning  xs:string? A URI that identiﬁes a collection of documents, or nodes within  documents. If the argument is omitted, or is supplied as an empty sequence, the function returns the default collection of documents, established as part of the context by the calling application.  Result  node  *  The sequence of documents, or nodes within documents, identiﬁed by the URI.  Effect This function is speciﬁed in very abstract terms, and it’s likely that its detailed behavior will vary consid- erably from one implementation to the next.  Many XML databases have the concept of a collection as a container for documents, and the containers generally have a name, which can be mapped into some kind of URI. Beyond that, there are many varia- tions; for example, some systems might allow collections to be nested hierarchically, some systems might use a collection to store all the documents that are validated against one particular schema, and so on. Some implementations map the concept of a collection onto a simple directory containing the documents  perhaps with a ﬁlter applied to the document names , or onto an XML catalog ﬁle that holds a list of the documents within the collection.  All that the spec really says about this function is that the supplied URI argument is resolved against the base URI from the static context, and the resulting absolute URI is used to identify a collection of documents; the result is a sequence containing the document nodes of these documents. In fact it isn’t constrained to return document nodes, there might be collections that return other kinds of nodes.  The speciﬁcation also says that the function is stable, which means that if you call it twice in the same expression  or, in the case of XSLT, in the same transformation , then you get the same answer back each time. In other words, a collection at least gives the appearance of being immutable for the duration of a query or transformation.  726   compare  There’s one other provision: if you call the document-uri   function on a document that was returned as part of the collection, then this will either return nothing, or it will return a URI that can be used as input to the doc   function to retrieve the original document. This rule gives you a useful guarantee if you want to follow hyperlinks between different documents in the collection.  Beyond this, it’s not really possible to say what the collection   function does, without going into the details of individual implementations. The following table gives a summary of its behavior in the main XSLT 2.0 implementations available at the time of writing:  Product Altova  Gestalt  Saxon  Action If the URI identiﬁes a catalog ﬁle  see below , then the ﬁles listed in the catalog are loaded and returned as the result of the collection   function. Alternatively the argument may specify a directory and or a ﬁlename pattern. For example, collection "*.xml"  selects all ﬁles with extension ".xml" in the same directory as the stylesheet.  Gestalt allows you to supply a URI that references a directory, for example «file:   c: input-dir ». The collection that is returned contains a document node for each well-formed XML ﬁle in that directory.  Saxon allows you to set up your own CollectionURIResolver, which can interpret the collection URI any way it likes. By default, it provides two options: the collection URI can resolve to a catalog ﬁle  see below , which lists the documents to be loaded; or it can be a URI referring to a directory, in which case all the XML ﬁles in that directory are loaded. It is also possible to specify query parameters in the URI that deﬁne a ﬁlename pattern that restricts the ﬁles selected, together with details such as whether the directory contents are scanned recursively, whether parsing errors are fatal, and whether schema or DTD validation is to be attempted. Further details at http:  www.saxonica.com documentation sourcedocs collections.html.  The format of the catalog ﬁle used by Saxon and Altova is not deﬁned in any standard, but it is similar for both products. Here is an example:  13  T h e  F u n c t i o n  i  L b r a r y                 See Also doc   on page 750  Saxon also allows an attribute «stable="no"» on the   element to override the normal requirement for the collection to be immutable. It can save the processor a lot of work  and memory  to omit this check.  compare The compare   function is used to compare two strings, and to decide whether they are equal, or if not, which one sorts before the other.  For example, under most collations «compare "ALPHA", "BETA" » returns -1.  727   The Function Library  Signature Argument value-1  value-2  collation  optional   Result  Type  xs:string?  Meaning The ﬁrst string to be compared  xs:string?  The second string to be compared  xs:string  xs:integer?  A URI identifying the collation to be used to perform the comparison −1 if value-1 is considered less than value-2 , zero if they are considered equal, +1 if value-1 is considered greater than value-2  Effect If either value-1 or value-2 is an empty sequence, the result is an empty sequence.  If value-1 is less than value-2, the function returns -1; if they are equal, it returns 0; and if value-1 is greater than value-2, it returns +1. The string comparison is done using the supplied collation if speciﬁed; if the collation argument is omitted, the comparison is done using the default collation. For more information on collations, see the section Collations in Chapter 6, page 459.  Examples These examples assume the availability of two collation URIs: $strong, which considers ﬁrst the character value, then accents, then case  with upper case ﬁrst ; and $weak, which considers only the character value.  Expression  compare "espace", "espacer"   compare "espace", "espac´e", $strong   compare "espace", "Espac´e", $strong   compare "espace", "espac´e", $weak   compare "espacer", "espac´e", $strong   -1  -1  -1  0  +1  Result  Explanation The shorter string comes ﬁrst.  The unaccented string comes ﬁrst.  Accent differences are more signiﬁcant than case differences.  Accents make no difference.  The base characters are examined before the accents.  Usage Often compare   is followed by a three-way branch. Because XPath has no switch or case expression, it is best to assign the result of the function to a variable to avoid doing the comparison twice. For example, in XSLT:         ...     ...     ...       Or, in XQuery 1.0:  let $c := compare A, B  return  if  $c = -1  then ...  728   concat  In pure XPath 2.0, you can do this rather awkwardly with a «for» expression:  else if  $c = 0  then ... else ...  for $c in compare A, B  return  if  $c = -1  then ... else if  $c = 0  then ... else ...  See Also Collations on page 459 in Chapter 6 Value Comparisons on page 581 in Chapter 8  concat The concat   function takes two or more arguments. Each of the arguments is converted to a string, and the resulting strings are joined together end-to-end.  For example, the expression «concat ’Jane’, ’ ’, ’Brown’ » returns the string «Jane Brown».  Changes in 2.0 None.  Signature This function is unique in that it can take any number of arguments  two or more . Argument value  repeated   Meaning A string to be included in the result  xs:anyAtomicType  Type  Result  xs:string  The result of concatenating each of the arguments in turn  Effect Each of the supplied strings is appended to the result string, in the order they appear.  Any argument that is an empty sequence is ignored. If all the arguments are empty sequences, the result is a zero-length string.  Note that all the arguments will automatically be cast to strings.  13  T h e  F u n c t i o n  i  L b r a r y  Examples Expression  concat "a", "b", "c"   Result The string «abc»  concat "chap", 3   The string «chap3»  concat "a",   ,   , "b"   The string «ab»  concat "a",  "b", "c"    In 1.0 mode: the string «ab»  when a sequence is converted to a string in backward-compatibility mode, all items after the ﬁrst are discarded . In 2.0 mode: error. The argument must be a single string, not a sequence of strings. Use the string-join   function instead.  729   The Function Library  Usage in XSLT The concat   function is often a convenient alternative to using multiple   elements to construct an output string. For example, the following expression creates a text node containing a concatenation of three strings:     This is equivalent to:                  Note the need for the outer   instruction — without this, the result would be a sequence of three text nodes rather than a single text node.  However, with XSLT 2.0 it is even simpler to write:     Another situation where concat   is useful is in deﬁning a key, including look-up keys    , sort keys    , and grouping keys    . XSLT keys cannot be multipart values, but you can get round this restriction by concatenating the parts of the key with an appropriate separator. For example:  <xsl:key name="full-name" match="person"  use="concat first-name, ’ ’, last-name " >  This key can then be used to retrieve the person  or persons  with a given name using an expression such as:   ...   See Also contains   in the following section string-join   on page 879 substring   on page 883  contains The contains  function tests whether one string contains another as a substring. For example, the expression «contains ’Santorini’,’ant’ » returns true.  Changes in 2.0 An optional collation argument has been added.  Signature  Argument input  test  730  Type  xs:string?  xs:string?  Meaning The containing string  The test string  continued   contains  Argument collation  optional   Result  Type  xs:string  xs:boolean  Meaning The collation to be used  true if the containing string has a substring that is equal to the test string, otherwise false  Effect If the Unicode codepoint collation is used  this is the default , then the result is true if the ﬁrst string  input  contains a consecutive sequence of characters where each character has the same Unicode value as the corresponding character of the second string  test .  If test is zero-length, the result is always true.  If input is zero-length, the result is false except when test is also zero-length.  If either of the ﬁrst two arguments is an empty sequence, the effect is the same as if it were a zero-length string.  If no collation is speciﬁed, then the default collation from the static context is used. When a colla- tion is used, it is used to break both of the strings into a sequence of collation units, and the function returns true if the collation units generated for test form a subsequence of the collation units generated for input.  Because this function compares substrings, rather than just performing an equality match or ordering on two strings as a whole, it imposes particular constraints on the way the collation works — it only makes sense to use a collation that considers the string character by character. For a function such as compare  , it would be quite viable to use a collation that sorts «January» before «February», or «5 Oak Street» before «10 Maple Drive». But a collation that does this isn’t also going to be able to look for substrings of characters in a meaningful way.  This doesn’t mean that each character must be considered in isolation. The collation can still consider characters in groups, as with the traditional rule in Spanish that «ch» collates as if it were a single char- acter following «c», and «ll» as a single letter after «l». But where characters are grouped in this way, it is likely to affect the way substrings are matched, as we will see.  13  T h e  F u n c t i o n  i  L b r a r y  The XPath speciﬁcation isn’t completely prescriptive about how substring matching using a collation should work, and there are several possible approaches that an implementation could use. I’ll describe the way the Saxon processor does it, which makes heavy use of the collation support in Java: other Java-based processors are therefore quite likely to be similar.  Firstly, let’s look at a case where Java treats one character as two collation units. With a primary strength collation for German, the string «Straße» generates a sequence of seven collation units, which are exactly the same as the collation units generated for the string «strasse». This means that «contains  "Straße", $t » returns true when $t is any one of «ß», «aß», «ße», «ss», «as», «ass», or «se»  among others . Few surprises here.  Java also allows a collation to perform decomposition of combined characters. For example, the charac- ter «c¸» can be decomposed into two characters, the letter «c» and a nonspacing cedilla. The advantage of doing this is that Unicode allows two ways of representing a word such as «garc¸on», using either six codepoints or seven, and normalizing the text so it only uses one of these forms gives better results when matching strings. For collating, Java chooses to use the decomposed form in which the accents are represented separately.  For more information on normalization, see the entry for the normalize- unicode   function on page 847.   731   The Function Library  Under such a collation, the string «garc¸on» is represented as seven collation units, the same as the collation units for the string «garc,on», in which the cedilla is represented by a separate nonspacing character. The effect of this is that the result of «contains "garc¸on", $t » is true when $t is any of «c¸», «rc¸ », or «c¸ o», and also when it is «c» or «rc», but not  and here’s the surprise  when it is «co».  I’ve written «garc,on» to illustrate that the «c» and the cedilla are two separate Unicode codepoints. But of course the cedilla is actually a nonspacing character, so in real life this string of seven codepoints would appear on the page as «garc¸on».  Java could instead have standardized on the composed form of the character, but the accent-blind matching would then not work: «contains "garc¸on", "c" » would be false.  Now let’s look at a case where a pair of characters represents a single collation unit. Here we turn back to Spanish, where in older publications «ch» collates after «c» and «ll» collates after «l». We can set this up in Java by deﬁning a RuleBaseCollator using a rule that deﬁnes «c < ch < d» and «l < ll < m».  Modern Spanish practice follows the English collating rules, so I had to set up these rules myself.   When you do this, you ﬁnd that «contains "chello", $t » returns true if $t is «ch» or «che» or «ello», but is false if it is «c» or «h» or «l» or «hello». What is happening is that because «ch» and «ll» are being treated as single characters for collation purposes, they are also treated as single characters for the purpose of substring matching.  These rules for substring matching using a collation apply not only to the contains   function, but also to ends-with  , starts-with  , substring-before  , and substring-after  .  Examples These examples assume that the default collation is the Unicode codepoint collation, which compares strings codepoint by codepoint.  Result  true  false  true  true  false  Usage The contains   function is useful mainly for very simple matching; for example, testing whether a string contains a space. For more complex matching of strings, the matches   function is available in XPath 2.0 with full support for regular expressions.  Expression  contains "Shakespeare", "spear"   contains "", "a"   contains "Shakespeare", ""   contains "", ""   contains   , "a"   See Also ends-with   on page 773 matches   on page 828 starts-with   on page 875 substring   on page 883 substring-after   on page 885 substring-before   on page 887  732   count  count The count   function takes a sequence as its argument, and returns the number of items in the sequence. For example, the expression «count  4,5,6  » returns 3.  Changes in 2.0 The function is generalized in XPath 2.0 so that it can return the number of items in any sequence.  Signature Argument sequence  Result  Type  item  *  xs:integer  Meaning The sequence whose items are to be counted  The number of items in the supplied sequence  Effect The count   function takes any sequence as its argument, and returns the number of items present in the sequence.  If the sequence contains nodes, each node counts as one item. The function does not count the number of atomic values contained in the node’s typed value, and it does not count the children or descendants of the node.  Examples Consider the source document:             and assume that this has been validated using a schema that deﬁnes the colors attribute as a sequence of strings.  Expression  count   obs   count   obs @colors   count data   obs @colors    count   @*   count   obs @date   count  5 to 10    Usage Avoid using count   to test whether a sequence of nodes is empty; for example, by writing:  if  count book[author=’Hemingway’]  != 0  then . . .  13  T h e  F u n c t i o n  i  L b r a r y  Result  2  2  5  4  0  6  733   The Function Library  This can be better expressed as:  if  book[author=’Hemingway’]  then . . .  or, if you prefer:  if  exists book[author=’Hemingway’]   then . . .  A good processor will optimize the ﬁrst expression so as to avoid counting all the books  it can stop counting books and take the then path as soon as it ﬁnds the ﬁrst one that matches , but it’s always best to avoid relying on such optimizations if you can.  The count   function is a useful way of ﬁnding the position of a node within a source document. In XSLT it can provide an effective alternative to using  , and in non-XSLT environments, it may be the only way of doing numbering. For example, if the context node is a   element, then «count preceding-sibling::bullet +1» returns the number of this   within the sequence of   elements. The advantages of using count   over  , apart from the fact that it’s available in non-XSLT environments, are that it is rather more ﬂexible in deﬁning what you want to count, and it can be used directly in expressions. However,   gives a simple way of obtaining the sequence number, formatting it, and inserting it in the result tree in a single operation; it may also in some cases be easier for the processor to optimize.  Avoid using count   where last   would do the job just as well. This situation arises in XSLT when you are processing a sequence of nodes using   or  ; the number of nodes in that sequence is then available from the last   function. For example, it is probably inefﬁcient to write:      Book   of       . . .     Instead, write:    . . .     because — unless the XSLT processor is rather clever — it will have to reevaluate the expression «.. book[author=’Hemingway’]» each time round the loop.      Book   of     An alternative is to assign the sequence of nodes to a variable, so it is only evaluated once. See Also sum   on page 889 last   on page 820 current This function is available in XSLT only.  734   The current   function returns a single item, the item that is the context item at the point in the stylesheet where the XPath expression containing this function call is called.  Changes in 2.0 The function has been generalized so that it may return any item  a node or an atomic value , not only a node. The function may now be used within an XSLT pattern.  current  Signature There are no arguments.  Result  Type  item    Meaning The item that is the context item at the outermost level of the XPath expression containing the function call  Effect At any point in the processing of a stylesheet, there is generally a context item. The XPath expression «.», if it is used as a standalone expression within a stylesheet, will always select the context item and will return the same result as the expression current  . Within an XPath expression, the context item may change; for example, within a predicate, the context item is the item being tested using the predicate. The result of the current   function, however, is the same wherever it is used within an expression. This makes it useful within predicates, as a way of referring to the item that would have been the context item at the outermost level.  This is best explained by example. The following example processes all   elements that have a code attribute whose value is the same as the code attribute of the element that is the context item at the point where the instruction is evaluated.     Another way of writing this would be:  13  T h e  F u n c t i o n L b r a r y  i     and in fact this substitution is completely general; any complete XPath expression that references the current   function could be replaced by one in which a variable is bound to the value of «.» at the outermost level of the expression, and the call on current   is replaced by a reference to that variable.  The context item in a stylesheet is established as follows:    When evaluating a global variable, the context item is the initial context item, supplied by the calling application  it may be undeﬁned if no initial context item has been supplied . Usually, this will be the document node of the main input document.    When   is used to process a selected set of nodes, each selected node in  turn becomes the context item. So when a template rule is invoked, the context item is always the node that caused that template rule to be selected. On return from  , the context item reverts to its previous value.    When   is used to process a selected sequence of items, each selected item in turn becomes the context item. When the   loop completes, the context item reverts to its previous value.  735   The Function Library    When a stylesheet function is called from within an XPath expression, the context item is unde-        ﬁned. This means that any attempt to reference «.» or current   will raise an error. The   and   instructions also change the context item; for details, see the description of these instructions in Chapter 6. All other instructions, including   and  , leave the context item unchanged.  When the current   function is used in a pattern, it refers to the node that is being matched against the pattern. For example, the pattern «part[ancestor::* @code !=current   @code]» matches all part elements that have an ancestor with a code attribute that differs from the code attribute on the element itself.  Usage The reason the current   function is provided is to allow you to determine the XSLT context item when it is different from the XPath context item — speciﬁcally, inside a predicate. The XPath context item can always be determined using the expression «.».  The most common situation where current   is useful is when you want to follow a cross-reference from the context node to some other node. For example, the expression «  department[deptNr=current    @dept]» ﬁnds a   element referenced from the dept attribute of the context item  which might be an   element .  Example The following example shows the use of current   in a predicate.  Example: current    This example lists the books in a catalog; in the description of each book, it also lists other books in the same category.  Source  The source document is booklist.xml.        Number, the Language of Science   Danzig              The Young Visiters   Daisy Ashford    When We Were Very Young   A. A. Milne      736   current      Design Patterns   Erich Gamma   Richard Helm   Ralph Johnson   John Vlissides        Stylesheet  The stylesheet is list-books.xsl. It processes all the books in an   loop, and for each one it displays the title and the ﬁrst author. Then it looks for other books in the same category. Here it uses the predicate «[. @category=current   @category]», which is true if the category attribute of the context element is the same as the category attribute of the current element. The context element is the one being tested; the element returned by current   is the one whose entry is being displayed. It also tests that these two elements are distinct elements, using the condition «not . is current   ». In this case, you could also get away with writing «.!=current  », which tests whether the two nodes have a different string value, but it can be a more expensive test, and it doesn’t mean quite the same thing.  <xsl:transform  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" version="2.0" xmlns:book="books.uri" exclude-result-prefixes="book"  >                Category: <xsl:value-of  select="$categories category [@code=current   @category] @desc" >                             The output of the transformation is as follows.  Output         Number, the Language of Science   13  T h e  F u n c t i o n  i  L b r a r y  737   The Function Library   Category: Science   The Young Visiters   Category: Children’s Fiction   When We Were Very Young   Category: Children’s Fiction   Design Patterns   Category: Computing         current-date, current-dateTime, current-time These three functions are used to obtain the current date, the current time, or both.  Signature These functions take no arguments.  Type  Result  xs:date, xs:dateTime, or xs:time  Meaning The current date, dateTime, or time  Effect The current date and time forms part of the runtime context of an XPath expression. It will normally be taken from the system clock.  The resulting value will always have an explicit timezone component. The timezone will be taken from the implicit timezone provided by the evaluation context. In practice, this means it will probably be derived from the system default timezone for the machine on which the XSLT processor is running, or from the proﬁle of the particular user.  In XSLT 2.0 it is deﬁned that multiple calls on current-dateTime   and the other two functions will return the same result every time they are called within a single transformation. This means you can’t call the function at the beginning and the end of the transformation to measure the elapsed time. The reason for this rule is that XSLT is rather purist about being a strictly functional language, and in a strictly functional language, calling the same function twice with the same arguments always returns the same result. This property makes life much simpler for optimizers.  In XQuery 1.0, the same rule applies to multiple calls within a single query.  Examples Expression  current-date    Possible Result An xs:date, say 2008-06-02Z  current-dateTime    An xs:dateTime, say 2008-06-02T12:35:02-05:00  current-time    An xs:time, say 12:35:02Z  738   current-group  Usage Standalone XPath 2.0 does not provide any facilities for formatting the date and time for display. You can do this in XSLT 2.0 using the functions format-date  , format-dateTime  , and format-time  .  See Also adjust-date time-to-timezone   functions described on page 738 format-date time dateTime   on page 781 X-from-date time dateTime   functions described in their alphabetical position in this chapter, where X is one of year, month, day, hours, minutes, seconds, or timezone.  The current-group   function returns the set of items making up the group that is currently being processed using the   instruction.  current-group This function is available in XSLT only.  Signature There are no arguments.  Type  item  *  Result  Meaning A sequence of items, speciﬁcally the sequence that is being processed in the current iteration of an   instruction  Effect When the stylesheet starts executing, there is no current group; the current-group   function then returns an empty sequence.  The   instruction, described in Chapter 6, page 326, takes as input a sequence of items  called the population  and a grouping expression or pattern. It allocates each item in the popula- tion to zero or more groups of items, and then processes each group in turn. While it is processing each group, the current-group   function returns the sequence of items that participate in that group.  The current-group   function does not need to be called textually within the   instruction. Its scope is dynamic, and the current group remains available in called templates unless another nested   instruction is evaluated. On completion of an <xsl:for-each- group> instruction, it reverts to its previous value.  The current-group   function can also be called while evaluating the sort key in an   ele- ment contained within the   instruction. This affects the order in which groups are processed. In this context, current-group   refers to the group whose sort key is being calculated. For example, to sort groups in order of decreasing size, write <xsl:sort select="count current- group   " order="descending" >.  On entry to a stylesheet function, the current group is an empty sequence.  Usage and Examples See   on page 326 in Chapter 6  13  T h e  F u n c t i o n  i  L b r a r y  739   The Function Library  See Also   on page 326 in Chapter 6 current-grouping-key   in the following section  current-grouping-key This function is available in XSLT only.  Signature There are no arguments.  Type  Result  xs:anyAtomicType?  The current-grouping-key   function returns the value of the grouping key that deﬁnes the group currently being processed using the   instruction. The grouping key is the value of the expression in the group-by or group-adjacent attribute. When grouping is done using patterns, there is no current grouping key.  Meaning This is the value of the group-by or group-adjacent expression that is shared by all the items in the current group.  The return type indicates that the grouping key can be of any atomic type; for example, xs:string, xs:decimal, or xs:date.  When there is no current group, the function returns an empty sequence.  Effect When the stylesheet starts executing, there is no current grouping key; the current-grouping-key   function then returns an empty sequence.  The   instruction, described in Chapter 6, page 326, takes as input a sequence of items called the population and a grouping expression or pattern. If the grouping criteria are deﬁned using the group-by or group-adjacent attributes, then while each group is being processed, the current-grouping-key   function returns the grouping key value that characterizes that group.  If the grouping criteria are deﬁned using the group-starting-with or group-ending-with attributes of  , the current grouping key is an empty sequence.  The current-grouping-key   function does not need to be called textually within the <xsl:for-each- group> instruction. Its scope is dynamic, and the current grouping key remains available in called tem- plates unless another nested   instruction is evaluated. On completion of an   instruction, it reverts to its previous value.  The current-grouping-key   function can also be called while evaluating the sort key in an   element contained within the   instruction. This affects the order in which groups are processed. In this context, current-grouping-key   refers to the group whose sort key is being calculated. For example, to sort groups in descending order of their grouping key, write <xsl:sort select="current-grouping-key  " order="descending" >.  On entry to a stylesheet function, the current grouping key is an empty sequence.  740   data  Usage and Examples The following example groups a set of books by the name of the author. For each author, a section head- ing is displayed giving the name of the author, followed by a list of the books written by this author. The authors are sorted by name. A book that has several authors will be listed more than once.                 See Also current-group   on page 739  , page 326 in Chapter 6  current-time See current-date   on page 738  13  T h e  F u n c t i o n  i  L b r a r y  data The data   function returns the atomized value of a sequence. This means that any nodes in the input sequence are replaced by their typed values.  Signature Argument sequence  Result  Type  item  *  Meaning The input sequence  xs:anyAtomicType*  A sequence based on the input sequence, in which all nodes have been replaced by their typed values  Effect Atomization is a process that is invoked implicitly when a sequence containing nodes is used in a context where atomic values are expected. For example, if you write «@a+42», the attribute node represented by the expression «@a» is atomized to obtain a number, which is then added to 42. The data   function invokes atomization explicitly, and is used either in a context where implicit atomization does not occur  for example, the argument to the count   function is not atomized , or in cases where you want to make it clear to the reader what is going on.  Atomization applies the following process to each item in the input sequence. The results are concate- nated together retaining the original sequence order:        If the input sequence contains an atomic value, the atomic value is added to the result sequence unchanged. If the input sequence contains a node, the typed value of the node is added to the result sequence.  The typed value of a node depends on its type annotation. In the absence of a schema, or when the type annotation is xs:untypedAtomic or xs:untyped, the typed value is the same as the string value, but the  741   The Function Library  resulting atomic value remains an xs:untypedAtomic value rather than a string, which allows it to be used in contexts  for example, as an operand of «+»  where a string would not be allowed.  If the node is annotated with some other type annotation, which generally will happen only as a result of schema validation, the typed value reﬂects the type deﬁnition in the schema:        If the schema type is a simple type, the result is, in general, a sequence of zero or more atomic values. For example, if the type is xs:NMTOKENS, the result is a sequence of atomic values of type xs:NMTOKEN. If the type is a user-deﬁned type deﬁned as a list of xs:unsignedInteger values, then the typed value is a sequence of atomic values of type xs:unsignedInteger. If the schema type is a union type allowing a choice of xs:integer or xs:string, then the typed value will be either an xs:integer or an xs:string. If the schema type is a complex type  which implies that the node is an element , there are four cases to consider:    The type may be a complex type with simple content. This means that the type allows attributes but does not allow child elements. In this case the element content is processed exactly as for a simple type, as described above. The attributes are ignored. The type may allow mixed content  deﬁned using «mixed="true"» on the type deﬁnition in the schema . In this case the typed value is the same as the string value, which is the con- catenation of all the text node descendants of the element. For example, the typed value of the element  H 2 O  is the string «H2O». The result is labeled as an untyped atomic value. The type may deﬁne that the element is always empty. In this case, the typed value is an empty sequence. If the type allows element content only, then atomizing the element is an error. A system that does static type checking may report this as a compile-time error; otherwise, it will be reported at runtime. You can avoid this error by using the string value of the element instead of its typed value; for example, by writing «string $emp » instead of «data $emp ».           Examples Suppose that the variable $x is bound to the following element, which has been validated using a schema that deﬁnes the content model of   as zero or more   elements, and the content model of the   element to contain a number attribute of type xs:integer and a colors attribute whose type is xs:NMTOKENS.             Expression  data $x row @number   Result   1, 2   data $x row @colors    "red", "green", "yellow", "purple"   data $x   Error. An element with element-only content does not have a typed value.  data $x row       742   dateTime  Note that the above examples could equally well be written in the style «$x row @number data . ».  Usage Atomization is normally carried out automatically when an operation that expects atomic values is applied to a sequence. For example, if the argument to the sum   function is a set of nodes, then the typed values of those nodes will be extracted and totaled.  The data   function is provided so that atomization can be done explicitly in situations where it is not automatic. For example, the count   function does not automatically atomize its argument: it counts the nodes in the sequence, not the atomic values that result from atomization. The result is not the same, because if an element or attribute is declared in the schema to have a type such as list-of-integers, then atomizing the element or attribute may produce zero, one, or more atomic values.  Similarly, when testing the value of an element or attribute whose type is xs:boolean, be careful to make sure that the value is atomized: write «if  data @married  ...» rather than «if @married ...». This is because the value of «@married» is a sequence of zero or one attribute nodes, and the effective boolean value of a sequence of nodes  which is what the «if» expression tests  is true if there is at least one node in the sequence, regardless of its contents. If the attribute exists and has the value «married="false"», the test «if @married ...» will return true. Another way of forcing atomization is to write this as «if  @married=true   ...».  See Also The Type Matching Rules on page 219 in Chapter 5  dateTime This function constructs an xs:dateTime value from a supplied xs:date and xs:time.  Signature Argument date  time  Result  Type  xs:date?  xs:time?  xs:dateTime?  Meaning A supplied date  A supplied time  The xs:dateTime formed by combining the supplied date and time  13  T h e  F u n c t i o n  i  L b r a r y  Effect If either of the arguments is an empty sequence, the result is an empty sequence.  Otherwise, the result is formed by combining the supplied date and time.  If neither of the arguments includes a timezone, the result will not include a timezone. If one of the arguments includes a timezone and the other does not, or if both include the same timezone, the result will have this timezone. If the two arguments both contain timezones and they are different, then an error occurs.  Note that the time value «24:00:00» is considered to represent exactly the same value as «00:00:00»  that is, midnight , and this is treated as the start of the day rather than the end.  743   The Function Library  Examples Expression  dateTime xs:date ’2008-01-01’ , xs:time ’12:00:00’    dateTime xs:date ’2008-01-01’ , xs:time ’12:00:00Z’    dateTime xs:date ’2008-01-01Z’ , xs:time ’12:00:00Z’    dateTime xs:date ’2008-01-01+02:00’ , xs:time ’12:00:00Z’    dateTime xs:date ’2008-01-01+02:00’ , xs:time ’24:00:00’    See Also current-date  , -dateTime  , -time   on page 738 format-date  , -dateTime  , -time  on page 781  Result  2008-01-01T12:00:00  2008-01-01T12:00:00Z  2008-01-01T12:00:00Z  Error  different timezones   2008-01-01T00:00:00+02:00  day-from-date, day-from-dateTime These two functions extract the day-of-the-month component from an xs:date or xs:dateTime value. For example, on Christmas Day «day-from-date current-date   » returns 25.  Signature Argument input  Type xs:date? or xs:dateTime?  Meaning The value from which a component is to be extracted. The type of the supplied argument must correspond to the type implied by the function name.  Result  xs:integer?  The day, in the range 1-31.  Effect The function returns the day component of the supplied xs:date or xs:dateTime. The value is used in its local timezone  not normalized to UTC . If the argument is an empty sequence, the result is an empty sequence.  day-from-date xs:date "2008-02-28"    day-from-dateTime xs:dateTime "2008-02-28T13:00:00"    day-from-date xs:date "2008-07-31+01:00"    day-from-dateTime xs:dateTime "2008-07-31T23:00:00-05:00"    Result  28  28  31  31  Examples Expression  744   deep-equal  See Also current-date  , -dateTime  , -time   on page 738 format-date  , -dateTime  , -time   on page 781 month-from-date  , -dateTime   on page 833 year-from-date  , -dateTime   on page 911  days-from-duration This function extracts the value of the days component from a normalized xs:duration value.  Signature Argument input  Type  xs:duration?  Meaning The duration whose days component is to be extracted. If an empty sequence is supplied, an empty sequence is returned.  Result  xs:integer?  The days component.  Effect The function returns the days component of the supplied xs:duration. The duration value is ﬁrst nor- malized so that the number of hours is less than 24, the number of minutes is less than 60, and so on. However, there is never any conversion of days to months or vice versa. The result will be negative if the duration is negative.  Examples Expression  days-from-duration xs:duration "P5DT12H"    days-from-duration xs:dayTimeDuration "PT72H"    days-from-duration xs:dayTimeDuration "-P1D"    days-from-duration xs:yearMonthDuration "P1 M"    See Also hours-from-duration on page 801 minutes-from-duration on page 832 seconds-from-duration on page 874  deep-equal The deep-equal   function performs a deep comparison between two sequences:        The items in corresponding positions in each sequence must be deep-equal to each other. If the items are nodes, they are compared by examining their children and attributes recursively.  13  T h e  F u n c t i o n  i  L b r a r y  Result  5  3  0  -1  745   The Function Library  Signature Argument sequence-1  sequence-2  collation  optional   Result  Effect This function may be used to compare:  Type  item  *  item  *  Meaning The ﬁrst operand of the comparison  The second operand of the comparison  xs:string  The collation to be used for comparing strings  at any depth   xs:boolean  True if the sequences are deep-equal; otherwise, false        Two nodes, to see whether the subtrees rooted at those nodes have identical content at every level Two sequences, to see whether the items they contain are pairwise deep-equal  The function is therefore deﬁned to operate on sequences, though in many cases it will be used to compare two singleton element or document nodes.  At the top level, two sequences are deep-equal if they have the same number of items, and if each item in the ﬁrst sequence is deep-equal to the item in the corresponding position of the other sequence. A consequence of this rule is that an empty sequence is deep-equal to another empty sequence.  Where the item in a sequence is an atomic value, the corresponding item in the other sequence must also be an atomic value, and they must compare as equal using the «eq» operator, using the speciﬁed collation if they are strings, URIs, or untyped atomic values. If two items in corresponding positions are not comparable  for example, if one is an integer and the other is a string, or if one is a date and the other is an element node , then the function returns false; it does not report an error. Nodes are not atomized. NaN is considered to be equal to itself.  If two items in corresponding positions are nodes, then to be deep-equal they must satisfy a number of conditions:                    They must be the same kind of node  for example, both elements or both text nodes . They must have the same name, that is, the same namespace URI and the same local name, or they must both be unnamed nodes such as text nodes. In the case of document nodes, and element nodes whose type allows one or more element children, the sequences of children for the two nodes must be deep-equal to each other, after discarding any comments and processing instructions. In the case of element nodes, there must be a one-to-one correspondence between the attributes of the two elements  same attribute name, and typed values that are deep-equal . In the case of attribute nodes and element nodes whose type does not allow element children, the typed values must be deep-equal to each other. In the case of text nodes, comments, processing instructions, and namespace nodes, they must have the same string value, compared using the selected collation. Note however that comments, processing instructions, and namespace nodes are only taken into account if they occur directly  746   deep-equal  as items in the sequences supplied as arguments to the deep-equal   function. When they occur within the content of an element node, they are not considered.  Nodes can be deep-equal even if they differ in certain respects:    When comparing elements, the namespace nodes of the elements do not need to be the same,  and contained comments and processing instructions are not taken into consideration.  The fact that the namespace nodes can be different also means that one element can pass validation while the other fails validation, if they happen to contain xs:QName values in their content.  Type annotations are not taken into account; for example, two attributes can be equal if one is annotated as an xs:decimal with value 3.0, and the other is annotated as xs:integer with value 3. The order of attributes within an element can vary.  But the order of attribute nodes in the top-level sequence is signiﬁcant.  The base URI can vary.             When comparing document nodes, the document URI is ignored, as are unparsed entities.  Surprisingly, however, whitespace text nodes are taken into account even within an element that has an element-only content model. Furthermore, although comments and processing instructions appearing as children of an element are not compared directly, their presence can affect the result because they split a text node into two: so  123 456  and  123456  are not deep-equal.  Examples Expression  deep-equal  1,2,3 ,  1,2,3    deep-equal  1,2,3 ,  3,2,1    deep-equal  1,2 ,  1.0, 2.0    deep-equal   ,      Result  true  false  true  true  13  T h e  F u n c t i o n  i  L b r a r y  In the following examples, assume that $doc refers to the following document:                       Expression  and assume that $weak refers to a collation under which «c» and «C» compare as equal. Then:  deep-equal $doc e[1], $doc e[2]   deep-equal $doc e[1], $doc e[3], $weak   deep-equal $doc e[1] @*, $doc e[2] @*, $weak   Result  false  true  Undeﬁned  the result depends on the order of attribute nodes, which is unpredictable   747   The Function Library  Usage The deep-equal   function represents one particular way of deciding whether two nodes or sequences are equal to each other. In practice there are probably two common ways it is likely to be used:        To compare two sequences of atomic values: the result is true if the two sequences are the same length, and the sequences are pairwise equal to each other. To compare two element or document nodes to see if they have the same content at every level of the hierarchy.  Note that comparing two element nodes using the «=» or «eq» operators fails if the elements are deﬁned in the schema to have a complex type, unless this is a complex type allowing mixed content, in which case the elements are compared by comparing their string values.  The deﬁnition of deep equality for nodes is one that will suit some tastes and not others. For example, it treats comments and processing instructions within an element as insigniﬁcant, but whitespace between elements as signiﬁcant. It also treats the order of child elements  but not attributes  as signiﬁcant. If you don’t like this deﬁnition, the answer is simple: deﬁne your own function, and use that instead.  Saxon provides a function saxon:deep-equal   which is modeled on the standard deep-equal   function, but provides an extra argument allowing user control over the way in which the comparison is performed. Details are at http:  www.saxonica.com documentation extensions functions  deepequal.html.  default-collation The default-collation   function returns the URI of the default collation, that is, the collation that is used when no collation is explicitly speciﬁed in a function such as compare  .  Signature This function takes no arguments.  Result  Type  xs:string  Meaning The URI of the default collation from the runtime context  Usage The default-collation   function is useful when you want to assign a collation conditionally, for example:  compare $x, $y, if  $param-uri  then $param-uri else default-collation     When you call a function that expects a collation, you can always omit the argument to request the default collation, but you cannot supply a value such as an empty sequence or a zero-length string: if the argument is present, then it must be a valid collation.  See Also compare   on page 727 deep-equal   on page 745 distinct-values   on page 749 index-of   on page 807  748   distinct-values  max   on page 830 min   on page 830 Value Comparisons on page 581 in Chapter 8  distinct-values The distinct-values   function eliminates duplicate values from a sequence.  For example, «distinct-values  3, 5, 3, 6  » might return « 5, 6, 3 ».  Signature Argument sequence  collation  optional   Result  Type  xs:anyAtomicType*  xs:string  Meaning The input sequence  The collation to be used when comparing values that are strings  xs:anyAtomicType*  The input sequence, with duplicate values removed  Effect If a sequence containing nodes is supplied as the argument, the nodes are ﬁrst atomized as part of the standard function calling rules.  An untyped atomic value in the sequence is treated as a string.  If two or more values in the sequence are equal to each other  according to the rules of the «eq» operator, using the speciﬁed collation when comparing strings , then only one of them is included in the result sequence. It is not deﬁned which of them will be retained  for example, if the input sequence contains the xs:integer 3 and the xs:decimal 3.0, then it is unpredictable which of these two values will be present in the result . In addition, the order of the values in the result sequence is undeﬁned.  If the sequence contains two values that are not comparable using the «eq» operator  for example, an integer and a string , then these values are treated as distinct; no error is reported.  For the purpose of this function, NaN is considered equal to itself, and distinct from any other value.  Examples Assume that the default collation is case-blind, that is, that it treats the strings «A» and «a» as equal. The table below gives one possible result for each expression; a particular XPath processor might return some permutation of this result, or might include different items from a set that are equal to each other  such as «A» and «a» .  13  T h e  F u n c t i o n  i  L b r a r y  Expression  distinct-values  1, 2, 3, 3.5, 2.0, 1.0    distinct-values  "A", "B", "C", "a", "b", "c"    distinct-values  xs:time "12:20:02Z" , xs:time "13:20:02+01:00"     Possible Result  3.5, 2.0, 1, 3  "B", "c", "a"  xs:time "13:20:02+01:00"   distinct-values  1, "a", current-date      "a", 1, 2008-05-08Z  749   The Function Library  Usage The distinct-values   function provides the only direct way of eliminating duplicate values in XPath 2.0 and in XQuery 1.0. In XSLT 2.0, however, richer functionality is available in the form of the   instruction.  If you apply the function to a sequence of nodes, the result will be the distinct values present in those nodes, not the nodes themselves. To process the nodes, you will have to ﬁnd the nodes having each value. The typical logic is the following, which returns a sequence of integers representing the number of employees in each department:  for $x in distinct-values   employee @dept   return count   employee[@dept = $x]   In practice the processing of the result will probably be done in XSLT, XQuery, or some other host lan- guage, because it will usually involve generating nodes in the output, which XPath cannot do on its own.  Having found the distinct values that appear in a sequence, it is possible to determine the positions of each of these values using the index-of   function. For example, if you are using XQuery, then you can sort the distinct values in order of their ﬁrst appearance in the sequence by writing:  Alternatively, you could sort them in order of their frequency of occurrence by writing:   : XQUERY 1.0 EXAMPLE :   for $d in distinct-values $sequence  order by index-of $sequence, $d [1] return $d   : XQUERY 1.0 EXAMPLE :   for $d in distinct-values $sequence  order by count index-of $sequence, $d   return $d  See Also index-of   on page 807   in Chapter 6 on page 326  XPath 2.0 has no sorting capability, so this operation can only be done in the host language. In XSLT, it is usually more convenient to use the   instruction.  doc, doc-available The doc   function retrieves an external XML document by means of a URI, and returns the document node at the root of the tree representation of that XML document. Its companion function doc-available   determines whether an equivalent call on the doc   function would succeed in locating a document.  Changes in 2.0 These functions are new in XPath 2.0. The doc   function is a simpliﬁed version of the document   function that was provided in XSLT 1.0 and which remains available in XSLT 2.0  see page 754 . When combined with functions such as resolve-uri   and base-uri  , the doc   function provides most of the capability of the XSLT 2.0 document   function, but with a much simpler interface.  750   doc, doc-available  Signatures  The doc   function  Argument uri  Result  The doc-available   function  Argument uri  Result  Type  xs:string?  xs:boolean  Type  xs:string?  Meaning The URI of the document to be loaded  document-node  ?  The document node of the document identiﬁed by this URI  Meaning The URI of the document to be loaded  True if a call on the doc   function with the same argument would succeed; false if it would fail  Effect The doc   function gives XPath a window on the outside world, by allowing it to retrieve documents identiﬁed by a URI. Potentially this makes any XML document anywhere on the Web available for processing.  However, because the doc   function is an interface between the XPath processor and the world outside, many aspects of its behavior depend on the implementation, or on the way that the implementation is conﬁgured. XPath 2.0 is expected to be used in a great variety of environments  for example, some XPath processors might only work with XML documents that have been preloaded into a purpose-designed database  and the spec therefore gives a great deal of freedom to implementors. In fact, the formal speciﬁcation of this function simply says that the evaluation context for processing an XPath expres- sion provides a mapping of URIs to document nodes; if you specify a URI for which a mapping exists, then you get back the corresponding document node, and if you specify a URI for which no mapping exists, you get an error.  13  T h e  F u n c t i o n  i  L b r a r y  The term mapping here is deliberately abstract. It actually allows the implementation to do anything it likes to get from the URI you specify to the tree that comes back. Many implementations will allow users to control the process, either by implementing user hooks like the URIResolver in Java’s JAXP interface and the XmlResolver in .NET, or by setting options in conﬁguration ﬁles or command line parameters.  Before the URI is used, it is ﬁrst resolved into an absolute URI. You can resolve the URI yourself using the resolve-uri   function, in which case you have a free choice of the base URI to use, but if you pass a relative URI to the doc   function then it will always be resolved against the base URI from the static context of the XPath expression. In XSLT 2.0 this generally means the URI of the containing stylesheet module; in XQuery it means the base URI given in the query prolog. If the relative URI was read from a source document, then it should normally be resolved against the base URI of the document from where it was read, but this is left to the application to do.  One rule that the implementation must enforce is that if you call doc   twice with the same absolute URI, you get the same document node back each time. In XSLT, this rule applies for the duration of a transformation, not just for a single XPath expression evaluation.  751   The Function Library  What is likely to happen in a typical implementation is this:                             The URI  once resolved into an absolute URI  is checked against a list of documents that are already loaded. If the URI is in the list, the same document node is returned again. Otherwise, the absolute URI is used to identify and fetch an XML document, for example, by using the file or http URI schemes. The XML document is parsed, and optionally validated using a DTD validator or schema processor. A tree representation of the document is built in memory, and the document node at the root of this tree is returned as the result of the function.  Many processors are likely to allow users to control aspects of this process, including:  Locating the physical resource containing the source XML  if indeed it is source XML . Mecha- nisms such as catalogs or user hooks  like the JAXP URIResolver  might be used to provide an indirection between the URI and the location of the resource. Selecting an XML parser, and setting options to determine whether it performs DTD and or schema validation. Setting options that deﬁne whether XInclude directives in the source document are expanded, and whether any information in the source document  such as insigniﬁcant whitespace, comments, processing-instructions, or unused namespaces  is to be excluded from the tree representation. Setting tuning options; for example, parameters that control space time tradeoffs in the way the tree is built. Setting error-handling options; for example, whether a parsing error is to be treated as fatal, or whether an empty sequence  or perhaps a fallback document  should be returned in such cases.  If a schema is used to validate the document, then it must be compatible with any schema that was used when compiling the XPath expression. Here again, the detailed rules have been left to the implementa- tion. The processor may require that the input document is validated against a schema that was known at compile time, or it may allow validation using a different schema, provided that the tree that comes back contains enough information to allow the type deﬁnitions to be located at runtime. The processor is supposed to ensure that there is no version incompatibility between the compile time and runtime schemas, but it wouldn’t be surprising to come across a processor that simply passes this responsibility back to the user.  The doc-available   function works exactly the same way as the doc   function, except that instead of returning a document node when a document can be loaded and throwing an error when it can’t, doc-available   returns true in the ﬁrst case and false in the second. In the absence of any try catch capability either in XSLT or XPath, this allows you to test for errors before they occur, so that processing can continue when the required document does not exist or has invalid content.  Usage and Examples There are three main ways an XPath expression can access nodes in input documents.           The input document  or a node within it  can be supplied as the context node. A node can be included in the value of a variable available in the context. The XPath expression can invoke the doc   function  or the collection   function  to access the document by URI.  752   doc, doc-available  Which of these three approaches is used is a matter of application convenience, and may be inﬂuenced by the facilities available in the host language or the processor API for conﬁguring the behavior of the different options.  The following example shows an expression that uses a look-up table in an external document. The look-up table might have the form shown below and be held in a document called «countries.xml»:             ...  A query that uses this table to display the number of employees located in each country might look like this:  for $c in doc "countries.xml"  country return  concat $c @name, ": ",  count   employee[location country = $c @code]       string-join   "&x0a;"   This will return a string of the form:  Andorra: 0 United Arab Emirates: 12 Afghanistan: 1 Antigua and Barbuda: 25 ...  If you want to process a document if and only if it actually exists, you can use logic of the form     You should be aware of a few points:              It’s reasonable to expect that the document will actually be read and parsed only once If the document can’t be read, or if it exists but can’t be parsed as XML or validated, then you won’t get any explanation as to why. If the URI is invalid, or if a runtime error occurs in computing the value of the URI, then doc-available   will throw an error rather than returning false. To avoid this failure  for example, when reading the URI from an input document , add the test «if  $uri castable as xs:anyURI ...». Once a document URI has been reported as unavailable, it remains unavailable for the rest of the transformation. In theory at least, you can’t use doc-available   repeatedly to see whether the document has been created yet, and you can’t use it to test for the existence of ﬁles created during the transformation by the   instruction.  See Also base-uri   on page 719 collection   on page 726  13  T h e  F u n c t i o n  i  L b r a r y  753   The Function Library  document-uri   on page 764 resolve-uri   on page 867 document   in the next entry  document This function is available in XSLT only.  The document   function ﬁnds an external XML document by resolving a URI reference, parses the XML into a tree structure, and returns its root node. It may also be used to ﬁnd a set of external documents, and it may be used to ﬁnd a node other than the root by using a fragment identiﬁer in the URI.  For example, the expression «document ’data.xml’ » looks for the ﬁle data.xml in the same directory as the stylesheet, parses it, and returns the root node of the resulting tree.  Changes in 2.0 This function is retained largely for backward compatibility with XSLT 1.0; a simpliﬁed version is now available in XPath 2.0 as the doc   function described on page 750.  The speciﬁcation of the function has been generalized to allow the ﬁrst argument to be an arbitrary sequence of URIs, and it has also become less prescriptive, to allow greater freedom to conﬁgure the way in which the URI is interpreted and the way in which the retrieved documents are parsed.  Signature Argument href  base  optional   Type  item  *  node    Result  node  *  Meaning A sequence, which may contain values of type xs:string or xs:anyURI, or nodes containing such values. These URIs are used to locate the documents to be loaded.  If the argument is present, it must be a node. The base URI of this node is used for resolving any relative URIs found in the ﬁrst argument.  A sequence of nodes, in document order. In the common case where a single URI is speciﬁed, and this URI contains no fragment identiﬁer, the result will normally be a single document node.  Effect In brief, the document   function locates an XML document, using a URI. The resulting XML document is parsed and a tree is constructed. On completion, the result of the document   function is the document node of the new document.  If a sequence of URIs is provided, rather than a single URI, then the result is a sequence of document nodes. If a URI contains a fragment identiﬁer, then the result may be an element node rather than a document node. The details are described in the following sections.  I will describe the effect of the function by considering the different ways of determining a base URI to use for resolving relative URIs. However, ﬁrst a word about URIs and URLs, which are terms I use rather freely throughout this section.  754   document  Resolving the URI The XSLT speciﬁcation always uses the term URI: Uniform Resource Identiﬁer. The concept of a URI is a generalization of the URLs  Uniform Resource Locators  that are widely used on the Web today and displayed on every cornﬂakes packet. The URI extends the URL mechanism, which is based on the established Domain Name System  with its hierarchic names such as www.ibm.com and www.cam.ac.uk , to allow other global naming and numbering schemes, including established ones such as ISBN book numbers and international telephone numbers. While URIs are a nice idea, the only ones that really enable you to retrieve resources on the Web are the familiar URLs. This is why the terms URI and URL seem to be used rather interchangeably in this section and indeed throughout the book. If you read carefully, though, you’ll see that I’ve tried to use both terms correctly.  The way URIs are used to locate XML documents, and the way these XML documents are parsed to create a tree representation, are not deﬁned in detail. In fact, the XSLT document   function deﬁnes this process in terms of the XPath doc   function, and the XPath doc   function essentially says that it’s a piece of magic performed by the context of the XPath expression, not by the XPath processor itself. This reﬂects the reality that when you are using an application programming interface  API  such as the Java JAXP interface or the System.Xml.Xsl class in Microsoft’s .NET, you can supply your own code that maps URIs to document nodes in any way you like.  The relevant class is called URIResolver in JAXP, XmlResolver in .NET.  This might not even involve any parsing of a real XML ﬁle; for example, the URIResolver might actually retrieve data from a relational database, and return an XML document that encapsulates the results of the query.  There’s an expectation, though, that most XSLT processors — unless running in some kind of secure environment — will allow you to specify a URL  typically one that starts «http:» or «file:»  that can be dereferenced in the usual way to locate a source XML document, which is then parsed. The details of how it is parsed, for example whether schema or Document Type Deﬁnition  DTD  validation is attempted and whether XInclude processing is performed, are likely to depend on conﬁguration settings  perhaps options on the command line, or properties set via the processor’s API . The language speciﬁcation leaves this open-ended.  A URI used as input to the document   function should generally identify an XML document. If the URI is invalid, or if it doesn’t identify any resource, or if that resource is not an XML document, the speciﬁcation leaves it up to the implementation to decide what to do: it can either report the error, or ignore that particular URI. Implementations may go beyond this; for example, if the URI identiﬁes an HTML document, they may attempt to convert the HTML to XML — this is all outside the scope of the W3 C speciﬁcations.  A URI can be relative rather than absolute. A typical example of a relative URI is data.xml. Such a URI is resolved  converted to an absolute, globally unique URI  by interpreting it as relative to some base URI. By default, a relative URI that appears in the text of an XML document is interpreted relative to the URI of the document  or more precisely, the XML entity  that contains it, which in the case of the document   function is usually either the source document or the stylesheet. So if the relative URI data.xml appears in the source document, the system will try to ﬁnd the ﬁle in the same directory as the source document, while if it appears in the stylesheet, the system will look in the directory containing the stylesheet. The base URI of a node in an XML document can be changed using the xml:base attribute, and this will be taken into account. In addition, the document   function provides a second argument so that the base URI can be speciﬁed explicitly, if required.  The actual rule is that the href argument may be a sequence of nodes or atomic values. In the case of a node in this sequence, the node may contain a URI  or indeed, a sequence of URIs , and if such a URI is  13  T h e  F u n c t i o n  i  L b r a r y  755   The Function Library  relative then it is expanded against the base URI of the node from which it came. In the case of an atomic value in the sequence, this must be an xs:string or xs:anyURI value, and it is expanded using the base URI of the stylesheet.  The expansion of relative URIs exploits the fact that in the XPath data model, described on page 45 in Chapter 2, every node has a base URI.  Don’t confuse this with the namespace URI, which is quite unrelated.  By default, the base URI of a node in the source document or the stylesheet will be the URI of the XML document or entity from which the node was constructed. In some cases, for example when the input comes from a Document Object Model  DOM  document or from a relational database, it may be difﬁcult for the processor to determine the base URI  the concept does not exist in the DOM standard . What happens in this situation is implementation-deﬁned. Microsoft, whose MSXML3 processor is built around its DOM implementation, has extended its DOM so it retains knowledge of the URI from which the document was loaded.  With XSLT 2.0, you can override the default rules for establishing the base URI of a node by using the xml:base attribute of an element. This attribute is deﬁned in a W3 C Recommendation called XML Base  http:  www.w3.org TR xmlbase  ; it is intended to fulﬁll the same function as the   element in HTML. If an element has an xml:base attribute, the value of the attribute must be a URI, and this URI deﬁnes the base URI for the element itself and for all descendants of the element node, unless overridden by another xml:base attribute.  The URI speciﬁed in xml:base may itself be a relative URI, in which case it is resolved relative to the base URI of the parent of the element containing the xml:base attribute  that is, the URI that would have been the base URI of the element if it hadn’t had an xml:base attribute .  With XSLT 2.0, it is also possible that the node used to establish the base URI for the document   function will be a node in a temporary tree created as the value of a variable. Normally, the base URI for such a node will be the base URI of the    or  , or    element that deﬁnes the temporary tree. But if an element in the stylesheet has an xml:base attribute, that deﬁnes the base URI in the same way as for a source document.  If several calls on the document   function use the same URI  after expansion of a relative URI into an absolute URI , then the same document node is returned each time. You can tell that it’s the same node because the «is» operator returns true: «document ’a.xml’  is document ’a.xml’ » will always be true. If you use a different URI in two calls, then you may or may not get the same document node back: «document ’a.xml’  is document ’A.XML’ » might be either true or false.  A fragment identiﬁer identiﬁes a part of a resource: for example, in the URL http:  www.wrox.com  booklistapril2008, the fragment identiﬁer is april2008. In principle, a fragment identiﬁer allows the URI to reference a node or set of nodes other than the root node of the target document; for example, the fragment identiﬁer could be an XPointer expression containing a complex expression to select nodes within the target document. In practice though, this is all implementation deﬁned. The interpretation of a fragment identiﬁer depends on the media type  often called MIME type  of the returned docu- ment. Implementations are not required to support any particular media types  which means they are not required to support fragment identiﬁers at all . Many products support a simple fragment identi- ﬁer consisting of a name that must be the value of an ID attribute in the target document, and support for XPointer fragment identiﬁers is likely to become increasingly common now that a usable XPointer speciﬁcation has ﬁnally been ratiﬁed.  Parsing the Document Once the URI has been resolved against a base URI, the next steps are to fetch the XML document found at that URI, and then to parse it into a tree representation. The speciﬁcation says very little about these  756   document  processes, which allows the implementation considerable freedom to conﬁgure what kind of URLs are acceptable, and how the parsing is done. It is not even required that the resource starts life as XML: an implementation could quite legitimately return a document node that represents an HTML document, or the results of a database query. If the URL does refer to an XML ﬁle, there are still variations allowed in how it is parsed; for example, whether DTD or schema validation takes place, and whether XInclude ref- erences are expanded. A vendor might provide additional options such as the ability to strip comments, processing instructions, and unreferenced namespaces. You need to check the documentation for your product to see how such factors can be controlled.  The speciﬁcation does say that whitespace-only nodes are stripped following the same rules as for the source document, based on the   and   declarations in force. This is true even if the document happens to be a stylesheet.  URIs Held in Nodes For a simple case such as «document @href », the result is a single node, namely the root node of the document referenced by the href attribute of the context node.  More generally, the argument may be a sequence of nodes, each of which contains a sequence of URIs. The result is then the sequence obtained by processing each of these in turn. For example, «document    @href » returns the sequence of documents located by dereferencing the URIs in all the href attributes in the original context document. The result is returned in document order of the returned nodes  a somewhat academic concept since they will usually be different documents . The result is not necessarily in the order of the href attributes, and duplicates will be eliminated.  If any of the nodes contains a relative URI, it will be resolved relative to the base URI of that node. The base URI of a node is established using the rules given on page 45. In fact, each node in the supplied sequence could potentially have a different base URI.  This all sounds terribly complicated, but all it really means is that if the source document contains the link «data.xml», then the system will look for the ﬁle data.xml in the same directory as the source document.  These rules also cover the case where the argument is a reference to a variable containing a temporary tree, for example:  13  T h e  F u n c t i o n  i  L b r a r y   index.xml    . . .    In this case relative URI «index.xml» is resolved relative to the base URI of the   element in the stylesheet, which is generally the URI of the stylesheet module itself.  Usage: document   Applied to Nodes A common use of the document   function is to access a document referenced from the source document, typically in an attribute such as href. For example, a book catalog might include links to reviews of each book, in a format such as:     <review date="1999-12-28" publication="New York Times"  text="reviews NYT 19991228 rev3.xml" >  757   The Function Library  <review date="2000-01-06" publication="Washington Post"  text="reviews WPost 20000106 rev12.xml" >     If you want to incorporate the text of these reviews in your output document, you can achieve this using the document   function. For example:         Review in             As the argument @text is a node, the result will be the root node of the document whose URI is the value of the text attribute, interpreted relative to the base URI of the   element, which  unless it comes from an external XML entity or is affected by an xml:base attribute on some ancestor node  will be the same as the URI of the source document itself.  Note that in processing the review document, exactly the same template rules are used as we used for the source document itself. There is no concept of particular template rules being tied to particular doc- ument types. If the review document uses the same element tags as the book catalog, but with different meanings, this can potentially create problems. There are two possible ways round this:     Namespaces: use a different namespace for the book catalog and for the review documents.    Modes: use a different mode to process nodes in the review document, so that the    instruction in the example would become:     You might ﬁnd that even if the element names are distinct, the use of modes is a good discipline for maintaining readability of your stylesheet. For more detail on modes, see    page 240  and    page 483  in Chapter 6.  Another useful approach, which helps to keep your stylesheet modular, is to include the templates for processing the review document in a separate stylesheet incorporated using  .  Example: Using the document   Function to Analyze a Stylesheet  A stylesheet is an XML document, so it can be used as the input to another stylesheet. This makes it very easy to write little tools that manipulate stylesheets. This example shows such a tool, designed to report on the hierarchic structure of the modules that make up a stylesheet. This example uses the document   function to examine a stylesheet and see which stylesheet modules it incorporates using   or  . The modules referenced by   or   are fetched and processed recursively.  The source is any stylesheet, preferably one that uses   or  . A ﬁle dummy.xsl is provided in the code download for the book for you to use as a sample.  Source  758   document  Stylesheet  The stylesheet list-includes.xsl uses the document   function to access the document referenced in the href attribute of   or  . It then applies the same template rules to this document, recursively. Note that the root template is applied only to the initial source document, to create the HTML skeleton page.  <xsl:transform  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" version="1.0"  >                Stylesheet Module Structure                                 <xsl:apply-templates  select="$module * xsl:include  $module * xsl:import" >             Output  The output for the dummy.xsl stylesheet is as shown in Figure 13-1.  Figure 13-1  13  T h e  F u n c t i o n  i  L b r a r y  759   The Function Library  URIs as Atomic Values As an alternative to supplying a URI that is held in the content of a node, the ﬁrst argument may supply a URI as an atomic string. For convenience, the function accepts both xs:string and xs:anyURI types, as well as untyped atomic values.  Untyped atomic values are unlikely to arise in practice, since they normally arise only from atomizing a node in a schemaless document, and if you supply a node as an argument to the document   function, then the rules that apply are those in the previous section, URIs Held in Nodes.   The ﬁrst argument may be evaluated to produce a single atomic value containing a URI or a sequence of them. It is even possible to mix atomic values and nodes in the input sequence; nodes are processed as described in the previous section, and atomic values as described here.  The most common case is a URL hard-coded in the stylesheet, for example «document  ’tax- rates.xml’ ».  Another common case is «document ’’ », which refers to the stylesheet itself. This construct was often used with XSLT 1.0, where it provided a convenient way to maintain look-up tables in the stylesheet itself. It is likely to be less common with XSLT 2.0, since the ability to hold a temporary tree in a global variable is usually much more convenient. The URI may be supplied as an xs:string, an xs:anyURI, or an untyped atomic value, and in each case is converted to a string.  XSLT 1.0 also allowed it to be supplied as a boolean or an integer, which creates a theoretical backward incompatibility — but since converting a boolean or number is unlikely to yield a useful URL, the point is rather academic.   The string is treated as a URI reference; that is, a URI optionally followed by a fragment identiﬁer sepa- rated from the URI proper by a «» character. If it is a relative URI, it is treated as being relative to the base URI of the stylesheet element that contains the expression in which the function call was encoun- tered. This will normally be the URI of the principal stylesheet document, but it may be different if   or   was used, or if pieces of the stylesheet are contained in external XML entities, or if the base URI of any relevant element in the stylesheet has been set explicitly by using the xml:base attribute.  Again, all this really means is that relative URLs are handled just like relative URLs in HTML. If you write «document ’tax-rates.xml’ » in a particular stylesheet module, then the system looks for the ﬁle tax-rates.xml in the same directory as that stylesheet module.  If the string is an empty string, then the document referenced by the base URI is used. The XSLT speciﬁcation states that «document "" » will return the root node of the stylesheet. Strictly speaking, however, this is true only if the base URI of the XSL element containing the call to the document   func- tion is the same as the system identiﬁer of the stylesheet module. If the base URI is different, perhaps because the stylesheet has been built up from a number of external entities, or because the xml:base attribute has been used, the object loaded by «document "" » will not necessarily be the current stylesheet module; in fact, it might not be a well-formed document at all, in which case an error will be reported.  If the call is contained in a stylesheet brought in using   or  , it returns the root node of the included or imported stylesheet, not that of the principal stylesheet document.  Usage: document   Applied to Atomic Values With XSLT 1.0, this form of the document   function was very useful for handling data used by the stylesheet for reference information; for example, look-up tables to expand abbreviations, message ﬁles in different languages, or the text of the message of the day, to be displayed to users on the login screen.  760   document  Such data can either be in the stylesheet itself  referenced as «document "" »  or be in a separate ﬁle held in the same directory as the stylesheet  referenced as «document "messages.xml" »  or a related directory  for example «document ".. data messages.xml" ».  With XSLT 2.0, it is no longer necessary to use a secondary document for these purposes, because the data can be held in a tree-valued variable in the stylesheet and accessed directly. However, it may in some cases be more convenient to maintain the data in a separate ﬁle  for example, it makes it easier to generate the data periodically from a database , and in any case you may still want to write stylesheets that work with XSLT 1.0 processors, especially if you want the transformation to happen client-side. So I’ll show the XSLT 1.0 technique ﬁrst and then show how the same problem can be tackled in XSLT 2.0.  XSLT allows data such as look-up tables to appear within any top-level stylesheet element, provided it belongs to a non-default namespace.  Example: A Look-Up Table in the Stylesheet  This example uses data in a look-up table to expand abbreviations of book categories. Two techniques are shown: in the ﬁrst example the look-up table is held in the stylesheet; in the second example it is held in a separate XML document.  13  T h e  F u n c t i o n  i  L b r a r y  Source  This is the booklist.xml ﬁle we saw earlier:   Number, the Language of Science   Danzig                        The Young Visiters   Daisy Ashford    When We Were Very Young   A. A. Milne    Design Patterns   Erich Gamma   Richard Helm   Ralph Johnson   John Vlissides        Stylesheet  The stylesheet is list-categories.xsl. It processes each of the   elements in the source ﬁle and, for each one, ﬁnds the   element in the stylesheet whose code attribute matches the category attribute of the  . Note the use of current   to  761   The Function Library  refer to the current book; it would be wrong to use «.» here, because «.» refers to the context node, which is the   element being tested.  <xsl:transform  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" version="1.0" xmlns:book="http:  ns.wrox.com books.uri" exclude-result-prefixes="book"  >                Category: <xsl:value-of  select="document "  * book:category [@code=current   @category] @desc" >                       The output of this stylesheet is as follows:  Output         Number, the Language of Science   Category: Science   The Young Visiters   Category: Children’s Fiction   When We Were Very Young   Category: Children’s Fiction   Design Patterns   Category: Computing         XSLT 2.0 Stylesheet  Now, let’s modify this stylesheet to take advantage of XSLT 2.0 facilities. It’s renamed list-categories2-0.xsl. It isn’t a big change; the lines that are different are shown with a shaded background.  <xsl:transform  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" version="2.0"  762   document  select="$categories[@code=current   @category] @desc" >  >                 Category: <xsl:value-of                             Supplying an Explicit Base URI This section discusses what happens when the second argument to the document   function is supplied. In this instance, instead of using the containing node or the stylesheet as the base for resolving a relative reference, the base URI of the node supplied as the second argument is used. In other words, if a node in href contains a relative reference such as «data.xml», the system will look for the ﬁle data.xml in the directory containing the XML document from which the node in $base was derived.  The value of the second argument must be a single node. For example, the call «document  @href,   » will use the root node of the source document as the base URI, even if the element containing the href attribute was found in an external entity with a different URI.  This option is not one that you will need to use very often, but it is there for completeness. If you want to interpret a link relative to the stylesheet, you can write, for example:  13  T h e  F u n c t i o n  i  L b r a r y  document @href, document ""    This works because the second argument returns the root node of the stylesheet, which is then used as the base URI for the relative reference contained in the href attribute.  With the extended function library that XPath 2.0 makes available, an alternative is to resolve the relative reference yourself by calling the resolve-uri   function, which is described on page 867. This allows you to resolve against any base URI, which does not have to be the base URI of any particular node. I have used this in a situation where the base URI for resolving references was passed as a parameter to the stylesheet.  See Also id   on page 802 key   on page 812 resolve-uri   on page 867  763   The Function Library  Signature Argument input  Type  node  ?  document-uri The document-uri   function returns a URI associated with a document node.  Meaning The document node whose URI is required. If the node is not a document node, or if an empty sequence is supplied, the empty sequence is returned.  Result  xs:string?  The URI of the document node.  Effect The URI that is returned is always an absolute URI, and it has the property that if you passed it as an argument to the doc   function, you would get the input node back.  If no absolute URI is known for the supplied document node, the empty sequence is returned.  Usage This function is provided to allow a reference to a particular document to be constructed, either in the result document of an XSLT transformation, or simply in error messages. It is particularly useful where the transformation is processing a large batch of similar input documents, accessed perhaps using the collection   function, or perhaps supplied as a parameter to the transformation or query in a global variable.  To take an XSLT example, you might be producing a result document that acts as an index to a collection of input documents. This might include code such as:                       See Also base-uri   on page 719 collection   on page 726 doc   on page 750  element-available This function is available in XSLT only.  This function is used to test whether a particular XSLT instruction or extension element is available for use.  For example, the expression «element-available ’xsl:text’ » returns true.  764   element-available  Changes in 2.0 None.  Signature Argument name  Type  xs:string  Meaning The name of the element being tested. The string must take the form of a lexical QName.  Result  xs:boolean  true if the named element is available for use as an instruction, false otherwise.  Effect The ﬁrst argument must take the form of a lexical QName: that is, an XML name with an optional name- space preﬁx that corresponds to a namespace declaration that is in scope at the point in the stylesheet where the element-available   function is called.  If this namespace declaration identiﬁes the XSLT namespace http:  www.w3.org 1999 XSL Transform, then the function returns true if the name is the name of an XSLT-deﬁned instruction, and false otherwise.  The instructions deﬁned in XSLT 1.0 were as follows.                                                        In the XSLT 2.0 speciﬁcation, several new instructions have been added to this list.  13  T h e  F u n c t i o n  i  L b r a r y  765   The Function Library  Instructions are XSLT elements that can appear directly within a sequence constructor. Top-level XSLT declarations such as   and   are not instructions, so in theory they should return false  but don’t rely on it: at least one popular processor, Microsoft MSXML3, returns true for all XSLT elements . Similarly, elements such as  ,  ,  ,  , and   are not instructions, because they can appear only in speciﬁc contexts and not anywhere in a sequence constructor.  If the preﬁx of the QName identiﬁes any namespace other than the XSLT namespace, then the function returns true if and only if the XSLT processor has an implementation available for the named instruction: that is, if this element can be used as an extension instruction in a sequence constructor, rather than being treated simply as a literal result element.  Note that the result of the element-available   function does not depend on whether the namespace has been designated as an extension namespace by using the [xsl:]extension-element-prefixes attribute. If the XSLT processor has an implementation of the instruction available, the function should return true whether or not it is currently in a designated extension namespace.  If the QName has no preﬁx, the default namespace  declared using «xmlns="some.uri"»  is used. This is one of the few cases where this happens, and the reason is that the name is always an element name: the default namespace applies only to elements.  However, if the QName expands to a name with a null namespace URI, the result of the function will always be false. This is because both XSLT instructions and extension elements will always have a non-null namespace URI.  In principle, you can construct the value of the argument as a runtime expression, rather than supplying it as a string literal. I can’t think of any possible reason why it might be useful to do this, but implementors have to allow for the possibility.  Usage and Examples There are two ways to use this function: it can be used to test for XSLT elements introduced in a later version of XSLT, and it can be used to test for the presence of vendor or third-party extensions.  Testing for Features Available in Later XSLT Versions This function was introduced in XSLT 1.0, but it becomes useful only now that version 2.0 of the speciﬁ- cation is available. As we’ve seen, the XSLT 2.0 speciﬁcation introduces several new instructions. If you want to use an instruction such as   that became available only in a particular version of XSLT, then you can test to see whether it is available with your chosen XSLT processor before using it. If it is not available, you can either use   or the use-when attribute to avoid executing it, or use the   mechanism to cope with its absence.  So why was the function speciﬁed as part of version 1.0? The answer is obvious when you think about it: you want to write a stylesheet that uses version 2.0 features, so you call element-available   in order to fail gracefully if you’re running with an XSLT processor that supports version 1.0 features only. However, this will work only if the version 1.0 XSLT processor supports the element-available   function, which is why it was speciﬁed from the start. This is an unusually thoughtful piece of forward planning: the XSLT designers didn’t want to get into the same kind of forward-compatibility problems that have bedeviled HTML. Of course, it still means that if you want your stylesheet to run with XSLT processors that support different levels of the language, you will have to write and test conditional code in your stylesheet, but at least the capability is there.  766   element-available  In principle, you can test whether a version 1.0 instruction is available on the basis that there may be subset implementations around; unfortunately, this will work only if the subset implementation includes the element-available   function, which is not guaranteed; it tends to be one of the things that implementors leave till last.  It’s tempting to use the use-when attribute to mask XSLT 2.0 code from XSLT 1.0 processors. This doesn’t work, unfortunately, as use-when is a 2.0 facility, and 1.0 processors won’t recognize it.  Note that if you write a stylesheet that uses features deﬁned in XSLT version 2.0, and if you want to run it with an XSLT 1.0 processor, then you must specify «version="2.0"» on the   element, or «xsl:version="2.0"» on some literal result element, even if you write an   test using element-available   to avoid executing the relevant code. If you specify «version="1.0"», then any use of new XSLT 2.0 elements is ﬂagged as an error even if the code is never executed.  Here is an example that tests to see whether the new XSLT 2.0 facility to produce multiple output doc- uments is available by testing element-available ’xsl:result-document’ . If it isn’t available, you can use an alternative approach; for example, you can use the proprietary syntax for this functionality offered by your chosen XSLT 1.0 processor.  Example: Creating Multiple Output Files  This example takes a poem as input, and outputs each stanza to a separate ﬁle. A more realistic example would be to split a book into its chapters, but I wanted to keep the ﬁles small. The example is written to work with Saxon version 6.x  which implements XSLT 1.0  and also with any processor that conforms to the XSLT 2.0 speciﬁcation.  Source  The source ﬁle is poem.xml. It starts:     Rupert Brooke   1912   Song     And suddenly the wind comes soft,   And Spring is here again;   And the hawthorn quickens with buds of green   And my heart with buds of pain.       My heart all Winter lay so numb,   The earth so dead and frore,  . . .  Stylesheet  The stylesheet is in ﬁle split.xsl. The part to look at is the   instruction, where each branch calls element-available   to test whether a particular instruction is available, before calling that instruction.  13  T h e  F u n c t i o n  i  L b r a r y  767   The Function Library  Note that «saxon» is deﬁned as an extension element preﬁx, so the   element is recognized as an instruction. The   element speciﬁes «version="2.0"» so that an XSLT 1.0 processor will not reject   as an error.    <xsl:stylesheet xmlns:xsl="http:  www.w3.org 1999 XSL Transform"  version="2.0">                        <xsl:variable name="file"  select="concat ’verse’, string position   , ’.xml’ " >                    <xsl:when test="element-available ’saxon:output’ "  xmlns:saxon="http:  icl.com saxon">  <saxon:output file="{$file}"  xsl:extension-element-prefixes="saxon">     <xsl:message terminate="yes"  >Cannot write to multiple output files                     Output  Provided the stylesheet is run with one of the processors that support the required capabil- ity, the principal output ﬁle will contain the following skeletal poem  new lines added for legibility .       Song   Rupert Brooke   1912     768   element-available         Three further output ﬁles verse1.xml, verse2.xml, and verse3.xml are created in the same directory as this outline. Here is verse1.xml:       And suddenly the wind comes soft,   And Spring is here again;   And the hawthorn quickens with buds of green   And my heart with buds of pain.     To run this using Saxon 9.x  which implements XSLT 2.0 , use a command line of the form: java -jar c:\MyJava\saxon9.jar -t -o:c:\temp\outline.xml poem.xml split.xsl With this command line, the output ﬁles will all be written to the directory c:\temp. The   instruction in Saxon 6.x works slightly differently: it will write the ﬁles verseN.xml to the current directory, not necessarily to the directory containing the outline.xml ﬁle.  13  T h e  F u n c t i o n  i  L b r a r y  Note that in this stylesheet, all the information needed to evaluate the   conditions is available at compile time. A good XSLT processor will generate code only for the path that is actually going to be executed.  You can’t use element-available   to test whether the XSLT 2.0 element   is available, because this is a declaration rather than an instruction, and a conformant XSLT 2.0 processor should therefore return false  the same result as an XSLT 1.0 processor . If you use this element in an XSLT 1.0 stylesheet, an error will be reported if you specify «version="1.0"» on the   element, but if you specify «version="2.0"», then an XSLT 1.0 processor will ignore the   element, under the rules for forward-compatible processing. Instead you can test whether the XSLT processor you are using is schema-aware using the system-property   function  described on page 890 in this chapter  together with the use-when attribute described in the entry for   in Chapter 6.  Testing for Vendor Extensions The previous example also demonstrates a second way of using the function, namely to test for vendor or third-party extensions. If you know that a particular extension instruction is present in some implemen- tations and not others, you can use the element-available   test to see whether it is present, and again use either   or   to handle the situation when it isn’t. The example split.xsl used this technique to test whether the   instruction was available.  An alternative to using the element-available   function is to use the   mechanism described in Chapter 3, page 141. An   element allows you to deﬁne what processing should occur if its containing instruction isn’t available. The two mechanisms are essentially equivalent. A possible limitation of   is that it can only be used within an element that permits element  769   children: it could not be used, for example, within   as currently deﬁned. However, all the new instructions in XSLT 2.0 have been designed so that   can be used as a child element.  The Function Library  See Also function-available   on page 792 system-property   on page 890 type-available   on page 899   in Chapter 6, page 316  empty The empty   function returns true if and only if the argument is an empty sequence.  For example, the expression «empty   a » returns true if the context document contains no   elements.  Signature Argument sequence  Result  Type  item  *  Meaning The input sequence  xs:boolean  true if the input sequence is empty, otherwise false  Effect The function returns true if and only if the supplied sequence is empty.   See also  .   Examples Assume the source document:  Expression  empty  para   empty  para a   empty  para a @style   empty  para b   empty  para a[2]   Result  false  false  false  true  true  Usage Note that empty   is used only to test whether the number of items in a sequence is zero. As the examples above illustrate, it is not used to test whether a node is empty, in the sense of an element that has no children, or an attribute whose string value is a zero-length string.  To test whether an element $E has no element or text node children  or comments or processing instructions , you can write «if  empty $E node    ...».  770   encode-for-uri  To test whether the string value of a node $N is the zero-length string, you can write «if  string $N  eq ""  ...».  Remember also that a test on any value in the condition of an «if» expression is done by taking the effective boolean value of the expression, as deﬁned under the boolean   function on page 721. For example, if the expression is a path expression then the condition is true if the path expression selects one or more nodes; if it is a string, then the condition is true if the string is not zero-length. So, for example:  if  not *   then X else Y  has the same effect as:  if  empty *   then X else Y  and similarly, if @a refers to a list-valued attribute, then:  if  normalize-space @a   then X else Y  if  empty data @a    then Y else X  is equivalent to:  See Also boolean   on page 721 exists   on page 778 not   on page 850  encode-for-uri The encode-for-uri   function is used to apply percent-encoding to special characters in a string when the string is intended to be used as part of a URI.  For example, «concat ’http:  www.wikipedia.org ’, encode-for-uri ’Gerhard Schr¨oder’  » returns «http:  www.wikipedia.org Gerhard%20Schr%C3%B6der».  Signature Argument value  Result  Type  xs:string  xs:string  Meaning The input string, to which percent-encoding is to be applied  The percent-encoded string  Effect The result string is formed from the input string by escaping special characters according to the rules deﬁned in RFC 3986,  http:  www.ietf.org rfc rfc3986.txt . Special characters are escaped by ﬁrst encoding them in UTF-8, then representing each byte of the UTF-8 encoding in the form %HH where HH represents the byte as two hexadecimal digits. The digits A–F are always in upper case.  All characters are escaped except the following:        A-Z a-z 0-9 hyphen «-», underscore «_», period «.», and tilde «∼»  13  T h e  F u n c t i o n  i  L b r a r y  771   The Function Library  Examples Expression  encode-for-uri "simple.xml"   encode-for-uri "my doc.xml"   encode-for-uri "f+o.pdf"   encode-for-uri "Gr¨uße.html"   Result  "simple.xml"  "my%20doc.xml"  "f%2Bo.pdf"  "Gr%C3%BC%C3%9Fe.html"  Usage This function is designed for use by applications that need to construct URIs.  The rules for URIs  given in RFC3986, http:  www.ietf.org rfc rfc3986.txt  make it clear that a string in which special characters have not been escaped is not a valid URI. In many contexts where URIs are required, both in XPath functions such as the doc   function and in places such as the href attribute of the   element in HTML, the URI should in theory be fully escaped according to these rules. In practice, software is very often tolerant and accepts unescaped URIs, but applications shouldn’t rely on this.  The rules for escaping special characters  ofﬁcially called percent-encoding  are rather peculiar. To escape a character, it is ﬁrst encoded in UTF-8, which in general represents a character as one or more octets  bytes . Each of these bytes is then substituted into the string using the notation «%HH», where HH is the value of the byte in hexadecimal. For example, the space character is represented as «%20», and the euro symbol as «%E2%82%AC». Although RFC 3986 allows the hexadecimal digits «A-F» to be in either upper or lower case, the encode-for-uri   function mandates upper case, to ensure that escaped URIs can be compared as strings.  Historically, the same algorithm has been used to escape URLs and URIs using character encodings other than UTF-8. However, in most environments where XPath is used UTF-8 is the recommended encoding for URIs, and this is therefore the only encoding that the encode-for-uri   function supports.  Which characters need to be escaped? The answer to this depends on context. Essentially, characters fall into three categories: those that can be used freely anywhere in a URI, those that cannot be used anywhere and must always be escaped, and those that have a special meaning in a URI and must be escaped if they are to be used without this special meaning. This function escapes everything except the ﬁrst category  referred to in the RFC as unreserved characters .  Because this function applies escaping to characters that have special meaning in a URI, such as « » and «:», it should never be used to escape a URI as a whole, only to escape the strings that make up the components of a URI while it is being constructed. In theory, this is always the right way to con- struct a URI: each of its components should be escaped individually  for example, the URI scheme, the authority, the path components, the query parameters, and the fragment identiﬁer , and the components should then be assembled by adding the appropriate delimiters. This is the only way of ensuring, for example, that an «=» sign is escaped if it appears as an ordinary character in a path component, but not if it appears between a keyword and a value in the query part.  But often in practice the unescaped URI  if I may call it that — technically, if it isn’t escaped then it isn’t a URI  arrives in one piece and escaping needs to be applied to the whole string. In this case an alternative approach is to use the iri-to-uri   function described on page 811, or, if the URI appears in the context of an HTML document, the escape-html-uri   function described on page 775.  772   ends-with  See Also escape-html-uri   on page 775 iri-to-uri   on page 811 escape-uri-attributes serialization option in  : Chapter 15 page 938  ends-with The ends-with   function tests whether one string ends with another string. For example, the expression «ends-with ’17 cm’, ’cm’ » returns true.  Signature Argument input  test  collation  optional   Result  Type  xs:string?  xs:string?  xs:string  Meaning The containing string  The test string  A collation URI  xs:string?  True if the input string ends with the test string; otherwise, false  Effect If the Unicode codepoint collation is used  this is the default , then the system tests to see whether the last N characters of the input string match the characters in the test string  where N is the length of the test string . If so, the result is true; otherwise, it is false. Characters match if they have the same Unicode value.  If the test string is zero-length, the result is always true. If the input string is zero-length, the result is true only if the test string is also zero-length. If the test string is longer than the input, the result is always false.  If either the input or the test argument is an empty sequence, it is treated in the same way as a zero-length string.  13  T h e  F u n c t i o n  i  L b r a r y  If no collation is speciﬁed, then the default collation from the static context is used. If a collation is used, this collation is used to test whether the strings match. See the description of the contains   function on page 730 for an account of how substring matching works with a collation.  Examples These examples assume that the default collation is the Unicode codepoint collation, which compares strings codepoint by codepoint. Expression  Result  ends-with "a.xml", ".xml"   ends-with "a.xml", ".xsl"   ends-with "a.xml", ""   ends-with "", ""   ends-with   ,      true  false  true  true  true  773   The Function Library  Usage The ends-with   function is useful when the content of text values, or attributes, has some internal structure. For example, the following code can be used to strip an unwanted « » at the end of an href attribute:  doc if  ends-with @href, ’ ’   then substring @href, 1, string-length @href -1  else @href   Many string manipulations that can be done using ends-with    but not those that rely on collations  can also be achieved using the matches   function, which allows regular expressions to be used. The above example could also be coded using replace  :  doc replace @href, ’ $’, ’’    See Also contains   on page 730 matches   on page 828 starts-with   on page 875 string-length   on page 880 substring   on page 883  error The error   function can be called when the application detects an error condition; it causes evaluation of the XPath expression as a whole to fail. In XSLT, this will cause the entire transformation to fail.  Signature Argument code  optional   description  optional   object  optional   Result  Type  xs:QName?  Meaning An error code  xs:string  A description of the error  item  ?  A value associated with the error  None  This function does not return a result; it always raises an error  The error   function in fact has four signatures:  error    error code               error code, description   error code, description, object   The code argument can be an empty sequence if the description is present, but not otherwise.  Effect The error   function always reports an error, it never returns a result.  774   escape-html-uri  Calling the error   function causes the XPath expression as a whole to fail, since XPath provides no try catch mechanism for catching errors.  Under XSLT, calling the error function causes the whole transformation to fail: the effect is the same as  .  The various arguments can be used to provide information about the error. The exact way in which this information is used depends on the implementation.  Error codes are deﬁned as QNames. The error codes deﬁned by the system  such as XPTY0004 for the type error that occurs when calling a function with incorrect arguments  are technically local names associated with the namespace http:  www.w3.org 2005 xqt-errors. User-deﬁned error codes should be in a user-owned namespace. There is an assumption that a calling application will have access to these error codes, either as a QName, or as a URI with a fragment identiﬁer  for example http:  www.w3.org 2005  xqt-errorsXPTY0004 . However, the details depend on the API design.  Examples Expression  error    error xs:QName  "docbook: invalid-page-ref"    error   , "Invalid parameter value"   Result Causes termination, with no explanation  Causes termination, with an error code «invalid-page-ref» in the namespace associated with the «docbook» preﬁx  Causes termination, with a speciﬁed message, but no speciﬁed error code  Usage The error   function is useful when the application encounters a condition that it is not designed to handle, for example, invalid arguments passed to a function.  Every runtime error deﬁned by the XSLT and XPath suite of speciﬁcations itself has a short code, such as FORG0001. These codes  which are listed in Appendix B  are all to be regarded as the local part of a QName, whose namespace URI is http:  www.w3.org 2005 xqt-errors. The speciﬁcation suggests that this code might be made available to applications via the API of the XPath processor, though there is nothing prescriptive about this. It makes sense for vendor-deﬁned and user-deﬁned error codes to ﬁt into the same scheme of things by using xs:QName values as error values, with an explicit namespace. An implementation that allows error messages to be localized will typically provide some way of using the xs:QName as a code to look up a message in a ﬁle of message texts appropriate to the user’s language.  This error-handling scheme is ﬁne for product-quality applications that need to be delivered to a large number of users, localized to different languages, and so on. If you’re just writing a simple stylesheet that’s going to be used once and thrown away, it’s all rather over the top. In this case, you can just pass a message that says what’s gone wrong in the form of a string.  13  T h e  F u n c t i o n  i  L b r a r y  See Also trace   on page 896   in Chapter 6 on page 386 Error codes: Appendix B  escape-html-uri The escape-html-uri   function applies the URI escaping conventions deﬁned in the HTML 4.0 speciﬁcation to an input string.  775   The Function Library  For example, «escape-html-uri ’http:  www.wikipedia.org Gerhard Schr¨oder’ » returns «http:  www.wikipedia.org Gerhard Schr%C3%B6der».  Signature Argument value  Type  xs:string?  Meaning The input string, to which URI escaping is to be applied. An empty sequence is treated as a zero-length string.  Result  xs:string  The URI in its escaped form, as a string.  Effect The result string is formed from the input string by escaping non-ASCII characters according to the rules deﬁned in the HTML 4.0 speciﬁcation. Non-ASCII characters are escaped by ﬁrst encoding them in UTF-8, then representing each byte of the UTF-8 encoding in the form %HH where HH represents the byte as two hexadecimal digits. The digits A–F are always in upper case.  The term ‘‘non-ASCII’’ here means any Unicode character outside the codepoint range x20 to x7E inclu- sive. Note in particular that a space character is not escaped.  Examples Expression  Result  escape-html-uri  "http:  mhk.me.uk ˜index.html"   "http:  mhk.me.uk ˜index.html"  escape-html-uri "my doc.xml"   escape-html-uri "Gr¨uße.html"   "my doc.xml"  "Gr%C3%BC%C3%9Fe.html"  Usage This function is designed for use by applications that generate HTML.  By default, when the HTML or XHTML serialization methods are used  see Chapter 15 , all attributes that are deﬁned in the HTML XHTML speciﬁcation as containing URIs will be escaped by the serial- izer, using the rules deﬁned for this function. In principle, therefore, the necessary escaping is done automatically.  There are two situations where escaping sometimes needs to be done manually, that is, by means of explicit calls on this function:    When the output contains URIs in attributes that are not deﬁned as URI attributes in the HTML and XHTML speciﬁcations. This can arise because there are many extensions of HTML in pop- ular use, and because XHTML allows embedding of other XML vocabularies such as SVG and MathML that may themselves make use of URIs.    When the automatic action of the serializer has been disabled by setting the serialization prop-  erty «escape-uri-attributes» to the value «no». This is sometimes necessary to prevent unwanted escaping, especially of URI attributes that are interpreted locally within the browser. Although the HTML speciﬁcation states that all URI attributes should be escaped, the reality is that in today’s browsers this can sometimes cause problems; for example, when a ‘‘URI’’ is actually JavaScript code, or when a fragment identiﬁer in a hyperlink contains a same-document reference to an anchor whose name contains non-ASCII characters. If automatic URI escaping  776   in the serializer is causing such problems, it can be switched off, and the stylesheet can then perform manual escaping of selected URIs using the escape-html-uri   function.  exactly-one  See Also encode-for-uri  on page 771 iri-to-uri   on page 811 escape-uri-attributes option in  : Chapter 15  exactly-one The exactly-one   function returns its argument unchanged, provided that it is a sequence containing exactly one item. In other cases, it reports an error.  Signature Argument value  Type  item  *  Meaning The input value. Although the function signature says that any sequence of items is allowed, a runtime error will occur if the number of items is not exactly one.  Result  item    The same as the supplied value, after checking to ensure that it contains a single item.  Effect The exactly-one   function returns its argument unchanged, provided that it is a sequence containing exactly one item. In other cases, it reports an error.  This function is useful with XPath processors that perform pessimistic static type checking, as described in Chapter 5. As such, it is unlikely to be needed in XSLT. Calling this function acts as a promise by the programmer that the argument will be a sequence containing exactly one item. This allows the expression to be used in contexts that require a single value  for example, the operands of the «is» operator  when the processor might otherwise have reported a static type error. The XPath expression is still type-safe, because the check that the sequence does indeed contain a single item will be done at runtime, just as it would with a processor that does not enforce static type checking.  13  T h e  F u n c t i o n  i  L b r a r y  Examples Assume the source document:     with a schema that deﬁnes the separator attribute to be optional.  Expression  string-join  "a", "b", "c" ,  list @separator   string-join  "a", "b", "c" , exactly-one   list @separator    Result Succeeds unless the processor is doing static type checking, in which case it gives a compile-time error because the second argument of string-join   must not be an empty sequence.  Succeeds whether the processor is doing static type checking or not, because the check that the typed value of @separator contains a single item is deferred until runtime.  777   The Function Library  Usage This function is never needed unless you are using a processor that does static type checking.  However, you may still ﬁnd it useful as a way of inserting runtime checks into your XPath expressions, and documenting the assumptions you are making about the input data.  See Also one-or-more   on page 853 zero-or-one   on page 912 «treat as» expression on page 678 in Chapter 11  exists The exists   function returns true if and only if a supplied sequence contains at least one item.  Signature Argument sequence  Result  Type  item  *  Meaning The input sequence  xs:boolean  true if the input sequence is non-empty; otherwise, false  Effect The function returns true if and only if the supplied sequence contains at least one item.   See also  .   Examples Assume the source document:  Expression  exists  para   exists  para a   exists  para a @style   exists  para b   exists  para a[2]   Result  true  true  true  false  false  Usage This function is largely cosmetic: when testing to see if nodes exist, some people prefer to write an expres- sion such as «author[exists child::element   ]» over the more cryptic «author[*]». But they have the same meaning.  Writing exists   explicitly is good practice when you are testing to see whether a sequence of atomic values  rather than nodes  is non-empty. This is because the effective boolean value of an atomic sequence is false not only when the sequence is empty, but also when it contains a single numeric zero, zero-length string, or boolean false value.  778   Writing «exists X » is precisely equivalent to writing «not empty X  ».  ﬂoor  false This function returns the boolean value false.  See Also boolean   on page 721 empty   on page 770 not   on page 850  Changes in 2.0 None.  Signature There are no arguments.  Result  Type  xs:boolean  Meaning The xs:boolean value false  Usage There are no boolean constants available in XPath expressions, so the functions true   and false   can be used where a constant boolean value is required.  The most common usage is when passing an argument to a function that expects a boolean value.  XSLT Example The following code calls a named template, setting the parameter «verbose» to false:           13  T h e  F u n c t i o n  i  L b r a r y  See Also true   on page 899  ﬂoor The floor   function returns the largest integer value that is less than or equal to the numeric value of the argument. The result has the same type as the supplied value. For example, if the supplied value is an xs:double, then the result is returned as an xs:double.  For example, the expression «floor 11.3 » returns 11.0  this is displayed as ‘‘11’’, but it is actually a decimal value .  Changes in 2.0 The function has been generalized to work with all numeric types.  779   The Function Library  Signature Argument value  Result  Type  Numeric?  Numeric?  Meaning The supplied number. If an empty sequence is supplied, an empty sequence is returned.  The result of rounding down the supplied number to the integer below. The result has the same type as the supplied value.  Effect If the number is an xs:integer, or is equal to an xs:integer, then it is returned unchanged.  Otherwise, it is rounded down to the next lowest whole number. If the supplied value is an xs:decimal, the result will be an xs:decimal, if it is an xs:double, the result will be an xs:double, and if it is an xs:float, the result will be an xs:float. In the case of negative numbers, the rounding is away from zero.  The xs:double and xs:float types in XPath support special values such as inﬁnity, negative zero and NaN  not-a-number , which are described on page 199 in Chapter 5.  If the argument is NaN  not-a-number , the result will be NaN. Similarly, when the argument is positive or negative inﬁnity, the function will return the value of the argument unchanged.  Result xs:decimal 1.0, displayed as «1»  xs:double 1.0e0, displayed as «1»  xs:decimal 5.0, displayed as «5» xs:decimal −3.0, displayed as «-3» xs:double −9.0e0, displayed as «-9» xs:double NaN  Usage Like round   and ceiling  , this function is useful when calculating sizes of HTML tables.  Two alternatives you may want to consider are:        Using the xs:integer   constructor function. This differs from floor   in that it always truncates  rounds toward zero ; also, it returns an actual integer, rather than returning a value of the same type as the argument. Using the expression «$x idiv 1». This produces the same result as the xs:integer   constructor function, but saves you from having to declare the XML Schema namespace.  Examples Expression  floor 1.0   floor 1.6e0   floor 17 div 3   floor -3.0   floor -8.2e0   floor number ’NaN’    See Also ceiling   on page 723 round   on page 870  780   format-date, format-dateTime, format-time  Converting to an xs:integer in Chapter 9, page 667 The «idiv» operator, under Arithmetic Operators in Chapter 8, page 574  format-date, format-dateTime, format-time These three functions are available in XSLT only.  The three functions format-date  , format-dateTime  , and format-time  return a formatted repre- sentation of a date and or time, as a string. For example, «format-date current-date  , ’[MNn] [D], [Y]’ » might return the string «December 31, 2009».  Signature Argument Type value  xs:date? xs:dateTime? xs:time?  xs:string?  xs:string?  xs:string?  language  optional   calendar  optional   country  optional   Result  Meaning The date, dateTime, or time to be formatted. The type of value is determined by the name of the function.  picture  xs:string  A picture string identifying the components to be output and the format in which they are output.  A string following the same rules as the xml:lang attribute in XML, to indicate the language to be used for formatting the date time. For example, «en» indicates English, «de» German, and «es» Spanish.  A string giving a code for the calendar to be used for formatting the date time.  A code identifying the country associated with the date time, for example the country in which the dated event took place.  13  T h e  F u n c t i o n  i  L b r a r y  xs:string?  The formatted date time.  The last three arguments are optional, but they must either all be supplied or all be omitted. That is, the function must be called either with two arguments or with ﬁve. Calling it with two arguments is equivalent to supplying an empty sequence «  » for each of the last three arguments; an empty sequence for any of these arguments invokes the default value.  Effect If the value argument is an empty sequence, then the result is an empty sequence.  The Picture Argument The picture argument consists of a string containing so-called variable markers enclosed in square brackets. Characters outside the square brackets are literal characters to be copied to the result; variable markers within the square brackets indicate components of the date and time to be added to the output string, and the format in which they are to be displayed.  If square brackets are needed as literal characters in the result they should be doubled.  For example, if the picture is given as «[D1] [M1] [Y1,4]» then the date 1 February 2008 will be dis- played as «1 2 2008».  781   The Function Library  Each variable marker consists of a component speciﬁer identifying which component of the date or time is to be displayed; an optional formatting token; an optional presentation modiﬁer; and ﬁnally, an optional width modiﬁer, preceded by a comma if it is present.  The components of the date and time are identiﬁed by the following letters:  Letter Component Y  Year  Month of year  Day of month  Day of year  Day of week  Week of year  Default Format Four digits  Numeric 1–12  Numeric 1–31  Numeric 1–366  Week of month  Numeric 1–5  Hour  24 hours   Numeric 00–23  Hour  12 hours   Numeric 1–12  Name of day  language dependent   Numeric 1–53  A.M. or P.M.  Alphabetic  language dependent   Minutes in hour  Numeric 00–59  Seconds in minute Numeric 00–59  Timezone  Fractional seconds Numeric, one decimal place Numeric, for example +08:00 GMT+n Name of calendar, for example «Old Style»  Timezone  Calendar  Era  Text or abbreviation describing the baseline from which the year is calculated, for example A.D. or the name of a monarch  The formatting token consists of one or more additional letters or digits. The value can be either a formatting token recognized by the   instruction  see page 403 in Chapter 6 , or one of the values «N» «n», or «Nn» indicating that the component is to be output by name. Ignoring values such as «a» and «A» that are unlikely to be useful, at least in English, this leaves the following as examples of the possibilities. Character 1  Resulting Format Decimal numeric format with no leading zeroes: 1, 2, 3, . . .  Example 1, 2, 3  Decimal format, two digits: 01, 02, 03, . . .  01, 02, 03  Other Unicode digit  Decimal numeric format, using the set of Unicode digits in which the given digit represents the value one.  Lower-case Roman numerals.  i, ii, iii, iv  continued  M  D  d  F  W  w  H  h  P  m  s  f  Z  z  C  E  01  i  782   format-date, format-dateTime, format-time  Example I, II, III, IV  MONDAY, TUESDAY  monday, tuesday  Monday, Tuesday  ONE, TWO, THREE  one, two, three  One, Two, Three  Character I  Resulting Format Upper-case Roman numerals.  Name of component, in upper case.  N  n  Nn  W  w  Ww  t  o  Name of component, in lower case.  Name of component, in title case.  Number expressed in upper case words.  Number expressed in lower case words.  Number expressed in title case words.  Indicates so-called traditional numbering. The meaning of this depends on the language; it is intended to produce the same effect as «letter-value="traditional"» in  . The requirement most often cited is for Hebrew numbering.  Indicates ordinal numbering. For example, «1o» gives 1st, 2nd, 3rd . . . , while «wo» gives first, second, third, and «Wwo» gives First, Second, Third. All these examples are of course language dependent: the language is controlled using the language argument.  13  T h e  F u n c t i o n  i  L b r a r y  Not all combinations of these make sense, but the speciﬁcation leaves it very open to implementations how to interpret combinations other than the obvious ones. The golden rule for this function is that so long as the syntax of the picture is correct, it is never supposed to raise an error — if the processor doesn’t understand the format that you asked for, it should output the date in some fallback format.  The width modiﬁer, if present, indicates how many digits or letters should be included in the result. It takes the form «,m» or «,m-n», where m is a number giving the minimum width, or «*» to indicate no minimum, and n is the maximum width, or «*» to indicate no maximum. If n is omitted, it is assumed to be equal to m.  Specifying leading zeros in the formatting token is regarded as a shorthand for the width modiﬁer: for example, «01» is a shorthand for «1,2-2». For most numeric ﬁelds, the width speciﬁed controls whether leading zeroes are output: if the minimum width is 2, then the value 8 will be output as 08. The year ﬁeld is treated specially: a maximum width of 2 indicates that the century should be omitted. The fractional seconds are also handled differently: the minimum and maximum width indicate the minimum and maximum number of decimal places to be output.  For named ﬁelds, such as the name of the month and the day of the week, the width modiﬁer controls the choice of abbreviations. For example, specifying «3-3» requests abbreviations that are exactly three characters long. The speciﬁcation doesn’t say exactly how the abbreviations should be chosen; some systems might use a dictionary of abbreviated forms  for example JLY for July , while others might use simple truncation of the full name. Names should be padded to the minimum length if they are shorter.  It’s an error to request output of a ﬁeld that isn’t applicable to the type of input value; for example, component «H» for a date, or «Y» for a time.  It’s alright, however, to ask for the timezone to be displayed when the value contains no timezone: the relevant component will simply be omitted.   783   The Function Library  The Language Argument The language argument deﬁnes the language to be used for those parts of the output date that are lan- guage dependent. The most obvious examples are the names of the days of the week and the months of the year: for example, if the value is «en» then a date might be output as «Sunday 13 December 1987», while with «de»  the code for German  the same date would be «Sonntag 13 Dezember 1987». The choice of language is also likely to affect the way the ordinal numbers are represented  «4th» in English, «4.» in German, and «4´eme» in French , and the choice of words or abbreviations equivalent to the English «p.m.» and «A.D.».  Since the variety of calendars and numbering schemes that implementations might support is completely open ended, it’s quite possible that the language attribute might be used in other ways than these, for example to decide between «IV» and «IIII» as the representation of the number 4 in Roman numerals.  Implementations are not required to support any particular languages, and the set of languages that are supported is likely to depend on the choice of calendar.  The Calendar Argument The World Wide Web Consortium takes its name very seriously, and bends over backward to ensure that it caters to every society on the planet. While most of the Western world, and much of the Eastern world, now uses the Gregorian calendar ﬁrst introduced in the sixteenth century, there are many other calendars still in use. The XSLT speciﬁcation deﬁnes the following codes that you can use to represent different calendars. Code AD  Calendar Anno Domini  Christian Era   Anno Hegirae  Muhammedan Era   Mauludi Era  solar years since Mohammed’s birth   Anno Mundi  Jewish Calendar   Anno Persici  Aji Saka Era  Java   Buddhist Era  Cooch Behar Era  Common Era  Chinese Lunar Era  Chula Sakarat Era  Ethiopian Era  Fasli Era  ISO 8601 calendar  Japanese Calendar  Khalsa Era  Sikh calendar   continued  AH  AME  AM  AP  AS  BE  CB  CE  CL  CS  EE  FE  ISO  JE  KE  784   format-date, format-dateTime, format-time  Code KY  ME  MS  NS  OS  RS  SE  SH  SS  TE  VE  VS  Calendar Kali Yuga  Malabar Era  Monarchic Solar Era  Nepal Samwat Era  Old Style  Julian Calendar   Rattanakosin  Bangkok  Era  Saka Era  Mohammedan Solar Era  Iran   Saka Samvat  Tripurabda Era  Vikrama Era  Vikrama Samvat Era  This looks like a pretty impressive list, but before you get too excited that your favorite calendar is in the list, you should be aware that there is no requirement for implementations to support all these. And even if a calendar is supported, there are snags that you need to be aware of.  The date-formatting functions assume that the date and or time will be represented using the types deﬁned in XML Schema, which are based on the ISO 8601 speciﬁcation. This doesn’t mean that you have to be using a schema to take advantage of them, because you can always construct an instance of one of these types using a call to a constructor function; for example, «xs:date "1999-11-16" ». It does mean, however, that you have to ensure that your dates and times are in ISO format before you can use these functions. If your XML documents contain dates in nonstandard formats such as «16 NOV 99» or «11 16 1999», then you are going to have to convert them ﬁrst to the ISO format. And the same is true if your dates are in a different calendar.  13  T h e  F u n c t i o n L b r a r y  i  A very common use of these functions is simply to output the current date; for example, {«format- dateTime current-dateTime  , . . . » . In this case you don’t have to worry about whether the supplied date is in the correct ISO format and calendar: it always will be.  If the calendar argument selects a calendar other than the Gregorian calendar, then the date is translated into that calendar before extracting the relevant component. Not all calendars include concepts directly equivalent to months and weeks  for example, some calendars use lunar months , but most have concepts that are sufﬁciently similar for this to work. In practice, the handling of non-Gregorian calendars is likely to vary depending on your implementation and is only very loosely described in the XSLT speciﬁcation.  The numbering of days of the week and weeks of the year may vary from one country or language to another. If you want predictable results, select the «ISO» calendar in the calendar argument. The results will then follow the rules in ISO 8601:     Days of the week are numbered from 1  Monday  to 7  Sunday .    Weeks of the year are numbered so that week 1 is the Monday-to-Sunday week that includes the  ﬁrst Thursday of the year. The days before week 1 fall in week 52 or 53 of the previous year.  785   The Function Library     ISO 8601 does not deﬁne a numbering for weeks within a month. You will have to see what your implementation returns.  It’s important to understand the distinction in XML Schema between the value space of a type and the lexical space. The value space for xs:date simply contains one data point for every day in the history of the world, past, present, and future  within limits, but they need not concern us . It’s not meaningful to ask whether these data points are represented as integers or strings or to ask what format they are in — or to get to the point, it’s not meaningful to ask what calendar they are in. There is a data point representing the day when the Great Fire of London started, and you can represent this data point using any calendar you like. So the value space of dates in XML Schema is calendar neutral.  The same is not true of the lexical space. The lexical representation of dates in XML Schema uses the Gregorian calendar. In fact, it uses the Gregorian calendar even to represent dates that occurred long before the Gregorian calendar was invented: this is referred to as the proleptic Gregorian calendar  ISO 8601 calls it ‘‘prolaptic,’’ but that appears to be an error . This simply projects the Gregorian calendar backward in time. This is really no different from our use of ‘‘B.C.’’ dates: we are using a representation of dates that is unrelated to the way those same dates were represented in contemporary records.  This means that if you want to use a non-Gregorian calendar, you have to be very careful. For example, if you are storing a historical document that records that the Great Fire of London broke out on September 2, 1666, then if you want to represent this correctly using the xs:date type you need to know how to convert it into a Gregorian date. In fact, the correct lexical representation of this date is «1666-09-12», as there was then a 10-day difference between the Julian and Gregorian calendars.  Although the Gregorian calendar was introduced in 1585, Britain has always been slow to pick up European ideas, and did not adopt it until 1752.   If you now want to format this date using the Julian calendar, you can do so by specifying «OS» in the calendar argument. This will produce the correct output  «Sunday 2nd Sept 1666»  only if you rep- resented the date correctly in the value space. If you were careless, and created the date by writing «xs:date "1666-09-02" », then the formatted output will be «Thursday 23rd Aug 1666».  I suspect what this means in practice is that if you need to use non-Gregorian calendars, the support provided in XSLT 2.0 may not actually be sufﬁcient for your needs; it allows you to convert dates from the Gregorian calendar to a different calendar, but does not provide a conversion in the reverse direction. There are software utilities available to do that, which could be integrated as extension functions, but if you use them then you may well ﬁnd that they also offer date formatting capability that is better than that offered by your XSLT processor.  If you ask for a date to be formatted using a calendar that hasn’t been implemented, the system will output the date using a calendar of its own choosing  you can be fairly certain this will be the Gregorian calendar  but adding to the output a tag indicating that it is a different calendar from the one that was requested.  The inclusion of «ISO» as a calendar name in this list has a special purpose. Sometimes, you want to format the date not in order to present the information to a human reader, but to pass information to other software. The format-date   function, for example, is the only way available in standard XSLT of ﬁnding out the day of the week or the week number in the year. If you want to determine whether a given date is a Sunday, then it would be unfortunate if you had to test the result against a language-dependent string. If you choose ISO as the calendar, then you can do this test as:  <xsl:variable name="is-Sunday" as="xs:boolean"  select="format-date current-date  , ’F1’,   , ’ISO’,     = ’7’" >  786   format-date, format-dateTime, format-time  This is because the ISO 8601 standard speciﬁes numeric representations of the days of the week from Monday  1  to Sunday  7 . Similarly, you can get the ISO week number by writing:     ISO week numbers  which in some countries are widely used in project planning and similar applica- tions  are chosen so that week 1 is the Monday-to-Sunday week that includes 4th January. Week 1 may thus start before or after 1st January, but always starts on a Monday.  The Country Argument The country argument allows you to indicate the country associated with the date and time being for- matted. For example, if the date and time refer to the death of Erasmus, which took place on July 12, 1536 in Basel, Switzerland, then you can set the country argument to «ch», which is the ISO country code for Switzerland. The system can use this information to assist in converting Gregorian dates to a date in the chosen calendar, since with many non-Gregorian calendars, different variants of the calendar were in use in different places at different times. For example, although in the old Julian calendar the day and the month were synchronized across much of Europe, New Year’s day varied in different countries, so the year number might be different from one country to another.  In some cases, such as the Islamic calendar, the start of a day is tied to sunrise or sunset, so accurate conversion of a date into another calendar requires not only knowledge of the time of day, but also knowledge of where the event took place.  More prosaicly, the country code might be used to determine the abbreviated names of timezones. Names such as EST and PST are recognized in the US, but not necessarily in other English-speaking countries. It’s probably not a good idea to ask for time zone names, however. The xs:dateTime type simply doesn’t have this information. Within a limited range of dates and countries, the system might be able to work out that the time zone displacement -04:00 refers to US Eastern Daylight Time; but this doesn’t work if the time is supplied without a date, if the country is unknown, or if the date is in the future  as many US citizens discovered in 2007, the dates for daylight savings time changes are set by governments as they see ﬁt .  The value of the country argument is expected to be an ISO country code, but the use that the system makes of the information is entirely implementation deﬁned. You can always supply an empty sequence as the value of this argument.  13  T h e  F u n c t i o n  i  L b r a r y  Usage and Examples Here are some examples showing how the date 2008-11-03 might be formatted using various values of the picture argument, assuming the use of the English language and the Gregorian calendar.  Picture  [D] [M] [Y]  [M] [D] [Y]  [MNn] [Do], [Y] [E]  [Y]-[M,2]-[D,2]  [MN] [YI]  [Y][[week [W]:[FNn]]]  Output 3 11 2008  11 3 2008  2003-11-08  November 3rd, 2008 A.D  NOVEMBER MMVIII  2008[week 45:Monday]  787   The Function Library  The following examples show how the time 09:30:02.26-05:00 might be formatted, under the same assumptions. It is possible, of course, to output date and time components at the same time, using a single picture. Picture  [H01].[m01]  [h].[m01] [P]  [H01]:[m01]:[s01].[f001] [ZN]  Output 09.30  9.30 A.M  09:30:02.260 EST  See Also day-from-date  , day-from-dateTime   on page 744 month-from-date  , month-from-dateTime   on page 833 year-from-date  , year-from-dateTime   on page 911 hours-from-time  , hours-from-dateTime   on page 800 minutes-from-time  , minutes-from-dateTime   on page 832 seconds-from-time  , seconds-from-dateTime   on page 873 timezone-from-date  , timezone-from-dateTime, timezone-from-time   on page 893  format-number This function is available in XSLT only.  The format-number   function is used to convert numbers into strings for display to a human user. It is also useful when converting to legacy formats that require a number to occupy a ﬁxed number of character positions. The format of the result is controlled using the   declaration in an XSLT stylesheet.  For example, the expression «format-number 12.5, ’$0.00’ » returns the string «$12.50».  Changes in 2.0 In XSLT 1.0, the effect of the function was deﬁned by reference to the Java JDK 1.1 speciﬁcations. This cre- ated problems because the JDK 1.1 description left many details underspeciﬁed, and later versions of the JDK not only clariﬁed the speciﬁcation, but also added new features. It was therefore decided in XSLT 2.0 to provide a freestanding deﬁnition of this function. This is largely compatible with the old JDK 1.1 spec- iﬁcation, but the rules are now much more precise, and in corner cases they will not necessarily give the same results as implementations based on the JDK, let alone non-Java implementations. For example, the JDK 1.1 speciﬁcation did not say how rounding was done. The actual JDK 1.1 implementation used the rule of rounding a ﬁnal 5 to the nearest even number, and this is the rule that XSLT 2.0 has adopted, but XSLT 1.0 processors might well do rounding differently.  Signature  Argument value  picture  Type  Numeric?  xs:string  788  Meaning The number to be formatted  A picture string identifying the way in which the number is to be formatted  continued   format-number  Argument format  optional   Type  xs:string  Meaning A string in the form of a lexical QName, that identiﬁes an   declaration in the stylesheet, giving further information about the required formatting options  Result  xs:string?  The formatted number  Effect The function returns a string value; this is the result of formatting the given value using the format picture supplied in picture, while applying the rules deﬁned in the decimal format named in format if present, or using the default decimal format otherwise.  The decimal-format Name The format argument, if it is present, must take the form of a lexical QName; that is, an XML name optionally preﬁxed with a namespace preﬁx that corresponds to a namespace declaration that is in scope at the point in the stylesheet where the format-number   function is called. There must be an   element in the stylesheet with the same expanded name, using the namespace URIs rather than preﬁxes in the comparison.  If the format argument is omitted, the default decimal format is used. A default decimal format can be established for a stylesheet by including an   element with no name. If there is no unnamed   element in the stylesheet, the system uses a built-in default format, which is the same as specifying an   with no attributes.  The Picture String The structure of the picture string is as follows. Here, and in the text that follows, I will use the default characters for each role: for example «;» as the pattern separator, «.» as the decimal point, «0» as the zero digit, «» as the optional digit placemarker, and so on. Remember, though, that you can change the characters that are used in each of these roles using the   declaration.  13  T h e  F u n c t i o n  i  L b r a r y  Construct  picture  subpicture  prefix  suffix  integer  fraction  Content  subpicture  «;»subpicture ?  prefix? integer  «.»fraction ? suffix?  Any characters except special characters  Any characters except special characters  «»* «0»*  but also allowing «,» to appear   «0»* «»*  but also allowing «,» to appear   The ﬁrst subpicture is used for formatting positive numbers. The second  optional  subpicture is used for negative numbers. If only one subpicture is speciﬁed, then the subpicture used for negative numbers is the same as the positive subpicture, but with a minus sign added before the preﬁx. The actual character used for the minus sign depends on the   declaration.  The preﬁx and sufﬁx are just literal characters that are output at the start and end of the number. The only real reason to use them, other than simple convenience, is when they are different for positive and  789   The Function Library  negative numbers. For example, you can use this mechanism to implement the accounting convention of displaying negative numbers in parentheses.  If the preﬁx or sufﬁx includes a «%» sign, the percent sign will be displayed in the place where it appears in the preﬁx or sufﬁx, and the number will be multiplied by 100. Similarly, you can also use a per-mille sign «‰» in which case the number will be multipled by 1000.  If the number is one of the special values positive or negative inﬁnity or NaN, then it is displayed using the representation deﬁned in the   declaration. The positive subpicture  including its preﬁx and sufﬁx  is used for displaying positive zero and positive inﬁnity, while the negative subpic- ture  perhaps with a different preﬁx and sufﬁx  is used for negative zero and negative inﬁnity. No preﬁx and sufﬁx are used when NaN is formatted.  The special characters used are as follows.  Special Character Default Value Meaning  zero-digit  digit  decimal-point  minus-sign  percent-sign  per-mille  «0»  «»  «.»  «;»  «-»  «%»  «‰»  A digit will always appear at this point in the result string  A digit will appear at this point in the result string unless it is a redundant leading or trailing zero  Separates the integer and the fraction part of the number  Minus sign  Multiplies the number by 100 and shows it as a percentage  Multiplies by 1000 and shows it as per mille  grouping-separator  «,»  Separates groups of digits  pattern-separator  Separates the positive and negative subpictures  The original JDK 1.1 implementation had the feature  I use the term politely  that if there was an explicit negative subpicture, it served to specify the negative preﬁx and sufﬁx only; the number of digits, group- ing separators, and other characteristics were all taken from the positive subpicture, and any speciﬁcation to the contrary in the negative subpicture was ignored. This curiosity was not actually documented in the JDK 1.1 speciﬁcation, though it was retained  and documented  in JDK 1.2. Since XSLT 1.0 referred explicitly to the JDK 1.1 speciﬁcation  but not to the JDK 1.1 implementation , it’s likely that some XSLT 1.0 processors share this behavior and others do not. XSLT 2.0 does away with it: all aspects of formatting for a negative number depend on the negative subpicture alone.  In the fractional part of the number, a «0» means you will get a digit in that position whatever its value, while a «» means you will get a digit only if it is non-zero. You will never get more digits displayed than there are «0» and «» signs. For example, «.00» displays a minimum of two and a maximum of four digits after the decimal point. If there are more signiﬁcant digits in the number than you have asked to be displayed, then the number is rounded. It is rounded to the nearest value that can be displayed, and if it is midway between two such values, it is rounded to the one whose last digit is even. For example, with a picture of «0.00», the value 0.125 is shown as «0.12», while 0.875 is shown as «0.88». This is different from the rounding rule that many of us were taught at school, which always rounds 0.5 upward, but it is preferred by many statisticians and accountants because it means that numbers are equally likely to be rounded up or down, which avoids introducing bias. If you prefer a different rounding rule, you can always round the number yourself before formatting it.  790   format-number  If no digits are displayed to the right of the decimal point, then the decimal point itself will not be displayed.  In the integer part of the picture, that is, on the left of the decimal point if there is one, the rules are different, because the value will never be truncated: if you don’t deﬁne enough digit positions to accom- modate the number, the system will display the full integer part of the value anyway. There will always be at least as many digits as there are «0» digits in the picture, but it makes little difference how many «» signs appear to the left of the decimal separator: their only real function is to space out any grouping separator characters.  The format-number   function doesn’t provide any direct way of space-padding the number so that numbers can be vertically aligned in a column. With HTML output this is best achieved using the CSS property «text-align:right». With text output, the simplest way to achieve this effect is to format the number, use the string-length   function to determine the length of the result, and then add the requisite number of spaces to the front.  The grouping separator  «,» by default  is commonly used for thousands, but in some countries for ten thousands. You can specify grouping separators either at regular intervals or at irregular intervals, and they can appear in either the integer part or the fractional part of the number. For example, if you write «,0.00», then you will get a grouping separator every three digits to the left of the decimal point, while if you specify «,,,0.00», then you will get separators at the speciﬁed positions only. The rule is that if all your explicit grouping separators are regularly spaced, then the system will add implicit grouping separators when it extends the picture on the left, but if the explicit separators are at irregular intervals, then no implicit separators will be added.  If the picture string is invalid, then the implementation is required to report an error.  Usage Note that this facility for formatting numbers is completely separate from the facilities available through the   element. There is some overlapping functionality, but the syntax of the pictures is quite unrelated. The format-number   function formats a single number, which need not be an integer.   is primarily designed to format a list of positive integers. For formatting a single positive integer, either facility can be used.  Examples The following example shows the result of format-number   using the default decimal format. Examples with non-default decimal formats are shown under the   element in Chapter 6, page 298. Number  Picture String  Result  13  T h e  F u n c t i o n  i  L b r a r y  1234.5  123.456  1000000  -59  1 div 0.0e0  1234  ,0.00  ,0.00  ,0.00  ,0.00  ,0.00  0.0  1,000,000.00  1,234.50  123.46  -59.00  Infinity  1234.0  continued  791   The Function Library  Number  1234.5  .00025  .00035  0.25  0.736  1  -42  -3.12  -3.12  Picture String  0.0  0.0  0.0  00%  00%  00%  00%  .00; .00   .00;.00CR  See Also   page 298 in Chapter 6   page 403 in Chapter 6  format-time See format-date   on page 781  function-available This function is available in XSLT only.  Result  1234.5  0.0002  0.0004  25%  74%  100%  -4200%   3.12   3.12CR  You can call function-available   to test whether a particular function is available for use. It can be used to test the availability both of standard system functions and of user-written functions, including both XSLT stylesheet functions and extension functions.  For example, the expression «function-available ’concat’ » returns true.  Changes in 2.0 An optional second argument has been added, giving the arity of the required function.  In XSLT 2.0, except when running in backward-compatibility mode, it is a static error if an XPath expression contains a call on a function that is not available. Therefore, the way in which function- available   is used needs to change: instead of calling it using a normal runtime conditional instruction    or   , it should be called in a compile-time conditional expression, using the [xsl:]use-when attribute.  Signature Argument name  arity  optional   Result  792  Type  xs:string  Meaning The name of the function being tested. The string must take the form of a lexical QName.  xs:integer The arity  number of arguments  of the function being tested.  xs:boolean  true if the named function is available to be called, false otherwise.   function-available  Effect The ﬁrst argument must take the form of a lexical QName: that is, an XML name, with an optional names- pace preﬁx that corresponds to a namespace declaration that is in scope at the point in the stylesheet where the function-available   function is called.  If there is no preﬁx, or if the namespace URI is the standard function namespace http:  www.w3.org  2005 xpath-functions, the call tests whether there is a system function with the speciﬁed name. The system functions are those deﬁned in the XPath and XSLT Recommendations; vendors are not allowed to supply additional functions in this namespace, nor are they allowed to omit any. So an XSLT processor that conforms to XSLT version 2.0 will return true if the name is one of the function names in this chapter  for example «current» , «position» , or «regex-group» . This means you can test whether a new XPath 2.0 or XSLT 2.0 function is supported in your XSLT processor by writing, for example:  use-when="function-available ’matches’ " use-when="function-available ’regex-group’ "  If the QName includes a non-null namespace  other than the standard function namespace , the XSLT pro- cessor returns true if there is a stylesheet function, constructor function, or extension function available with the given name. In general, if function-available   returns false, then you are safe in assuming that a call on the function would fail, and if it returns true, then there will be some way of calling the function successfully.  If the second argument to the function is supplied, then function-available   returns true only if there is a function available with the speciﬁed name and the speciﬁed number of arguments. When the second argument is omitted, the result is true if there is some function with the required name, regardless of the number of arguments.  There is no way of ﬁnding out at runtime what the types of the arguments should be, which means that knowing a function is available is not enough to ensure that any given call on the function will be successful.  The functions that are considered to be available are those in the static context of the XPath expression containing the call on function-available  . If function-available   is evaluated from the use-when attribute, this includes core XPath and XSLT functions, constructor functions for built-in types, and extension functions. If function-available   is evaluated during stylesheet execution, it also includes stylesheet functions  deﬁned using    and constructor functions for types imported from a schema.  13  T h e  F u n c t i o n  i  L b r a r y  Usage There are two ways of using function-available  : it can be used to achieve backward compatibility when using standard functions deﬁned after version 1.0 of the speciﬁcation, and it can be used to test for the presence of vendor or third-party extensions.  The ability to test for the existence of stylesheet functions is not particularly useful, especially as this cannot be done within a use-when attribute  it will always return false, because stylesheet functions are not present in the static context for evaluating use-when .  Testing for the Existence of System-Deﬁned Functions The ability to test whether a particular system-deﬁned function is available was not especially useful with version 1.0 of the speciﬁcation. It was designed to come into its own when later versions of the speciﬁcation were published. If you want to use a function that is newly deﬁned in version 2.0, then you can test to see whether it is available with a particular XSLT processor, before using it. If it is not  793   The Function Library  available, you can use   to avoid executing it. Provided that you enable forward-compatible mode by setting the version attribute on the   element to "2.0", a conformant XSLT 1.0 processor should not object to the presence of an expression in your stylesheet that calls an unknown function, unless the expression is actually executed.  For example, the function current-date   becomes available in XPath 2.0. You can test for its existence by writing:     For a fuller example, see the end of this section.  In theory, you could test whether a function such as current-date   is available by calling «system- property ’xsl-version’ » and testing whether the result is equal to «2.0». But the reality is that there will be processors that have implemented some of the XPath 2.0 functions but not yet all of them. A processor isn’t supposed to return «2.0» as the value of «system-property ’xsl:version’ » unless it is a fully conformant XSLT 2.0 processor; but if it isn’t a fully conformant processor, then by deﬁnition you can’t be sure whether it follows the rules. So it’s better to use the ﬁner-grained check offered by function-available  .  Testing for Vendor or Third-Party Extensions The second way of using function-available   is to test for vendor or third-party extensions. If you know that a particular extension function is present in some implementations and not others, you can use the function-available   test to see whether it is present, and use the new use-when attribute to handle the situation when it isn’t.  The use-when attribute provides a way of conditionally including or excluding parts of a stylesheet at compile time, based on a compile-time condition. There are more details of this feature on page 127 in Chapter 3. The compile-time condition is an XPath expression, restricted to operate with a very limited context, which means that it can only access information known at compile time. It cannot, for example, access a source document, or refer to variables. But the context does include the set of extension functions that are available. This is illustrated in the example that follows.  Example 1: Testing for xx:node-set   Extensions  The XSLT 2.0 working draft allows you to use a temporary tree  the value constructed when an   element is not empty  in any context where a node can be used. This feature was not available in XSLT 1.0, which handled temporary trees as a distinct type, known as a result tree fragment. Many vendors ﬁlled the gap by allowing a temporary tree to be converted to a node-set using an extension function  for example, xt:node-set   or msxml:node-set   . If you want to write a stylesheet that is as portable as possible, you need to write code that discovers which of these facilities is available.  Stylesheet  The following stylesheet  node-set-available.xsl  contains a named template that takes a temporary tree as a parameter and calls   to process its root node in a particular mode. When running with an XSLT 2.0 processor, it does this simply by passing the tree to   directly; in other cases, it tries to determine whether one of the proprietary node-set   extension functions is available, and uses that.  794   function-available  <xsl:stylesheet  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" version="2.0">  <xsl:template name="process-tree-fragment"  xmlns:msxml="urn:schemas-microsoft-com:xslt" xmlns:xt="http:  www.jclark.com xt" xmlns:saxon6=" http:  icl.com saxon">          <xsl:apply-templates mode="process-fragment"  select="$fragment" >             <xsl:apply-templates mode="process-fragment’  select="msxml:node-set $fragment " >       <xsl:apply-templates mode="process-fragment"  select="xt:node-set $fragment " >       <xsl:apply-templates mode="process-fragment"  select="saxon6:node-set $fragment " >     Cannot convert result tree fragment to node-set                         This named template can be called as follows, to process all the nodes in the result tree fragment.           The logic here is slightly tortuous. You need to look at it in two different ways: as an XSLT 1.0 stylesheet, and as a 2.0 stylesheet. As a 1.0 stylesheet, the outer   takes the   branch, because the processor version is 1.0. The use-when attribute on the   element is ignored: the XSLT 1.0 processor will be operating in forward-compatible mode, because the stylesheet speciﬁes «version="2.0"», and in forward-compatible mode, unknown attributes on XSLT elements are ignored. The 1.0 processor then takes one of the branches  13  T h e  F u n c t i o n  i  L b r a r y  795   The Function Library  of the inner  , depending on which of the xx:node-set   extension functions is available. As an XSLT 2.0 stylesheet, the outer   takes the   branch. It com- pletely ignores the   branch, by virtue of the use-when condition. The use-when condition is necessary, because an XSLT 2.0 processor would otherwise report a static  compile time  error when it sees an XPath expression that calls an unknown func- tion such as saxon6:node-set  , even though the function is not actually evaluated at runtime. When this example is run with an XSLT 2.0 processor, it doesn’t actually invoke the function- available   function — which arguably makes it a poor choice of example for this section. The next example attempts to remedy this.  The next example is similar — but this time, instead of looking for a vendor-supplied extension function, we will be looking for a user-supplied function implemented as a Java method.  Example 2: Testing Availability of a Java Method  In this example, we’ll assume that the stylesheet  charset-available.xsl  is always going to run under a particular XSLT 2.0 processor, but that it might run under different Java VMs. We’ll suppose the existence of an XSLT 2.0 processor that can run under both JDK 1.3 and JDK 1.4, and we’ll suppose that we want to use the Java method «Charset.isSupported  » in the java.nio.charset package, which was new in JDK 1.4. Under JDK 1.3, we’ll behave as if the extension function returned false.  Stylesheet  We achieve this by writing two versions of a variable declaration. Only one of them is com- piled, based on the value of the use-when attribute.     <xsl:variable name=’charset-ok’  as=’xs:boolean’ select=’Charset:isSupported "EUC-JP" ’ xmlns:Charset=’java:java.nio.charset.Charset’ use-when=’function-available "Charset:isSupported", 1 ’ >  <xsl:variable name=’charset-ok’  as=’xs:boolean’ select=’false  ’ xmlns:Charset=’java:java.nio.charset.Charset’ use-when=’not function-available "Charset:isSupported", 1  ’ >  encoding="{if  $charset-ok  then ’EUC-JP’ else ’UTF-8’}">  <xsl:result-document           796   generate-id  See Also element-available   on page 764  generate-id This function is available in XSLT only.  Changes in 2.0 None.  Signature Argument node  optional   The generate-id   function generates a string, in the form of an XML Name, that uniquely identiﬁes a node. The result is guaranteed to be different for every node that participates in a given transformation.  For example, the expression «generate-id .. » might return the string «N015732» when using one XSLT processor, and «b23a1c79» when using another.  Type  node  ?  Meaning The input node. If the argument is omitted, the context node is used. If an empty sequence is supplied, the zero-length string is returned.  Result  xs:string  A string value that uniquely identiﬁes the node. This will consist only of ASCII alphanumeric characters, and the ﬁrst character will be alphabetic. This makes the identiﬁer suitable for use in many contexts, for example as an ID value in an XML document or an HTML anchor.  Effect If the node argument is omitted, it defaults to «.», the context item. A type error occurs if this is not a node.  If the node argument is an empty sequence, the function returns a zero-length string.  The function returns an arbitrary string. Within a given transformation, the function will always return the same string for the same node, and it will always return different strings for different nodes: in other words, «generate-id $A =generate-id $B » is true if and only if «$A is $B» is true, and this includes the case where the nodes are in different documents.  The generated identiﬁers are unique within a single execution of the stylesheet. If the same stylesheet is used several times, with the same or different source documents, the function may generate the same identiﬁers in each run but is under no obligation to do so.  Usage and Examples In XSLT 1.0, the generate-id   function was often used to determine whether two expressions repre- sented the same node, that is, to compare nodes by identity. XPath 2.0 offers the «is» operator for this purpose, so this usage can be expected to dwindle.  The main intended purpose of the generate-id   function is to create hyperlinks in the output docu- ment. For example, it can be used to generate ID and IDREF attributes in an output XML document, or   and   pairs in an output HTML document.  13  T h e  F u n c t i o n  i  L b r a r y  797   The Function Library  Example: Using generate-id   to Create Links  This example takes as input a ﬁle resorts.xml containing details of a collection of holiday resorts, each of which includes a list of hotels.  Source         Amsterdam   A wordy description of Amsterdam      Grand Hotel   5    . . .     Less Grand Hotel   2    . . .                  Central Hotel   5    . . .          Peripheral Hotel   2    . . .     Bruges   An eloquent description of Bruges              Stylesheet  The stylesheet resorts.xsl constructs an output HTML page in which the hotels are listed ﬁrst, followed by information about the resorts. Each hotel entry contains a hyperlink to the relevant resort details. The links for the resorts are generated using generate-id   applied to the   element. This is a complete stylesheet that uses the Simpliﬁed Stylesheet syntax introduced on page 125, in Chapter 3.        Hotels     798   generate-id           Address:     Stars:     Resort:            Resorts                            Output  Notice how generate-id   is used twice, once to generate the identiﬁer of the resort, the next time to generate a link from the hotel.  The following output was obtained using Saxon. I have added some extra indentation to show the structure. A different product will generate different identiﬁers in the   ele- ments, but the links will work just as well.         Hotels    Grand Hotel    Address: . . .    Stars: 5   Resort:  Amsterdam     Central Hotel    Address: . . .    Stars: 5   Resort:  Bruges     Less Grand Hotel   Address: . . .     Stars: 2   Resort:  Amsterdam     Peripheral Hotel   Address: . . .    Stars: 2   Resort:  Bruges     Resorts     Amsterdam     A wordy description of Amsterdam     Bruges     An eloquent description of Bruges         13  T h e  F u n c t i o n  i  L b r a r y  799   The Function Library  There is no inverse function to generate-id  : speciﬁcally, there is no direct way to ﬁnd a node if its generated id is known, other than the potentially inefﬁcient:    node  [generate-id  =$X]  If you need to do this, however, you can set up a key deﬁnition as follows.     Then ﬁnd the element with a given id value using the expression:  key ’gid-key’, $X   It is important to appreciate that the generated identiﬁers bear no resemblance to any ID attribute values in the source document, so the nodes cannot be found using the id   function.  Also, the ID values generated in one run of the processor may be different from those generated in a subsequent run. You need to bear this in mind if you are using the ID values as hyperlinks. If the transformation is likely to be run more than once, then it isn’t safe to reference these ID values from another document, or even to save them as a bookmark in a browser.  See Also id   on page 802 key   on page 812 «is» operator in Chapter 8 on page 593  hours-from-dateTime, hours-from-time These two functions extract the hour component from an xs:dateTime or xs:time value. For example, at noon local time both these functions return 12.  Signature Argument input  Type xs:dateTime? or xs:time?  Meaning The value from which the hour component is to be extracted. The type of the supplied argument must correspond to the type implied by the function name.  Result  xs:integer  The hour, in the range 0 to 23  midnight is represented as 0 .  Effect The function returns the hour component of the supplied xs:dateTime or xs:time. The value is from the time as expressed in its local timezone  not normalized to UTC . This means that if the time  or dateTime  has a timezone, the value is the time in that timezone; if it has no timezone, it is the value as written.  If an empty sequence is supplied, an empty sequence is returned.  800   hours-from-duration  Examples Expression  hours-from-time xs:time "12:35:03.142"    hours-from-dateTime xs:dateTime "2008-02-28T13:55:30"    hours-from-time xs:time "23:59:59+01:00"    hours-from-dateTime xs:dateTime "2008-07-31T22:10:00-05:00"    hours-from-dateTime xs:dateTime "2008-07-31T24:00:00"    See Also current-date  , -dateTime  , -time   on page 738 format-date  , -dateTime  , -time   on page 781 minutes-from-dateTime  , -time   on page 832 seconds-from-dateTime  , -time   on page 873  hours-from-duration This function extracts the value of the hours component from a normalized xs:duration value.  Signature Argument input  Type xs:duration?  Result  xs:integer?  Meaning The value from which the component is to be extracted. If an empty sequence is supplied, an empty sequence is returned. The hours component, in the range −23 to +23.  Effect The function returns the hours component of the supplied xs:duration. The duration value is ﬁrst normalized so that the number of hours is less than 24, the number of minutes is less than 60, and so on. The result will be negative if the duration is negative. The result will therefore be in the range −23 to +23.  13  T h e  F u n c t i o n  i  L b r a r y  Examples Expression  hours-from-duration xs:dayTimeDuration "P5DT12H30 M"    hours-from-duration xs:dayTimeDuration "PT72H"    hours-from-duration xs:duration "-PT36H15 M"    hours-from-duration xs:yearMonthDuration "P12 M"    Result  12  13  23  22  0  Result  12  0  0  -12  801   The Function Library  See Also days-from-duration   on page 745 minutes-from-duration   on page 832 seconds-from-duration   on page 874  id The id   function returns a sequence containing all the elements in a given document with given ID attribute values.  For example, if the code attribute is deﬁned as an ID attribute, then the expression «id ’A321-780’ » might return the single element  .  Changes in 2.0 A second optional argument has been added, to deﬁne which document is to be searched. The semantics of the function have been redeﬁned in terms of the XPath 2.0 type system.  Signature Argument values  node  optional   Result  Type  xs:string*  node    element  *  Meaning Speciﬁes the required ID values  Identiﬁes the document to be searched  A sequence of nodes, in document order, containing the nodes with the required ID values  Effect The function is designed to make it easy to ﬁnd all the elements referenced in an element or attribute of type xs:IDREF or xs:IDREFS, but there is no requirement that it should be used this way. The rules are deﬁned so that the supplied argument can be any of the following:                 A string containing an ID value A string containing a space-separated list of ID values A node containing an ID value A node containing a space-separated list of ID values A sequence of any of the above  Any nodes in the sequence are atomized as part of the function calling mechanism. The resulting strings are then tokenized by splitting their contents on whitespace boundaries. Each token is used as a candidate ID value. If there is a node in the selected document that has an ID attribute or ID content equal to this candidate ID value then this node is included in the result of the function.  The rules for this function say that the nodes that are selected must have the is-id property. There are various ways a node might acquire this property:    With a schema-aware processor, an element or attribute acquires the is-id property if it is  declared as having type xs:ID, or a type derived by restriction from xs:ID, or a complex type  802   with simple content where the simple content is xs:ID or derived from xs:ID.  There’s some ambiguity about list or union types constructed from xs:ID.  If the input document has a DTD, an attribute declared in the DTD as having type ID will nor- mally acquire the is-id property. However this isn’t 100% reliable; it may depend on how the XML parser has been conﬁgured, and some parsers don’t report this information at all An attribute named xml:id will always have the is-id property.        By contrast, it is not necessary for the candidate IDs to be declared as type IDREF or IDREFS, though the function is designed to produce the expected result when they are, that is, it ﬁnds the nodes referenced by the IDREF or IDREFS values in the argument sequence.  It is not an error if there is no element with an ID equal to one of the candidate ID values. In this situation, there will simply be no node in the resulting sequence corresponding to this value. In the simplest case, where there is only one candidate ID value supplied, the resulting sequence will be empty if the ID is not present.  The second argument, if supplied, identiﬁes the document to be searched. This does not have to be the document node, it can be any node within the target document. This argument defaults to the context node. Whether the argument is explicit or implicit, it must be a node in a tree whose root is a document node. If the argument is omitted, then a runtime error is reported if the context item is undeﬁned, or if it is not a node. The nodes in the supplied values argument will often come from the same document, but this is not required.  IDs and Validation ID values only really work properly if the source document is valid  in the XML sense: meaning, loosely, that it obeys the rules in its own DTD or Schema . However, XPath is designed to allow invalid doc- uments as well as valid ones to be processed. One possible kind of validity error is that ID values are not unique within the document. This is explicitly covered in the speciﬁcation: the ﬁrst node with that ID value is located. Other validity errors may also be present, for example an ID attribute may contain embedded spaces. In this case it will not be retrieved.  When no schema is used, a non-validating XML parser isn’t required to read attribute deﬁnitions from an external DTD. In this situation the XSLT processor will assume there are no ID attributes present, and the id   function will always return an empty result. If this appears to be happening, check what options are available for conﬁguring the XML parser, or try a different parser. Most good parsers will report the attribute type, even though it isn’t absolutely required by the XML standard.  13  T h e  F u n c t i o n  i  L b r a r y  XML Schema introduces the ability for elements as well as attributes to be used as IDs, and the func- tion supports this. There’s a slight oddity, however. If the source document has an element of the form  ... , where nr is an ID attribute, then id ’e12345’  will return the   element. However, if the source is   e12345 .... , where nr is of type xs:ID, then id ’e12345’  will return the   element, not the  .  Usage and Examples The id   function provides an efﬁcient means of locating nodes given the value of an ID attribute.  In a sense it is a convenience function, because if the attribute named id is always an ID attribute, then the expression:  id ’B1234’   id  803   The Function Library  is equivalent to the path expression:    *[@id=’B1234’]  However, the chances are that in most implementations, the id   function will be much more efﬁcient than the straightforward path expression with a predicate, because the processor is likely to build an index rather than doing a sequential search.  In XSLT it is also possible to use key   in place of id  . The main advantage of the id   function over using key   is that it handles a whitespace-separated list of IDs in one go. The key   function cannot do this, because there is nothing to stop a key value containing a space.  The id   function when used with a single argument locates elements in the same document as the context node. XPath 2.0 provides two ways to locate elements in a different document. You can either use the id   function on the right-hand side of the « » operator, for example «doc "lookup.xml"   id $param », or you can supply a second argument, like this: «id $param, doc "lookup.xml"  ».  Where the source document includes an IDREFS attribute, it is possible to locate all the referenced ele- ments at once. For example, if the   element has an attribute authors which is an IDREFS attribute containing a whitespace-separated list of author ids, the relevant   elements can be retrieved and processed using a construct such as:  string-join id @authors  surname , ’, ’   See Also key   on page 812 idref   in the following section  idref The idref   function performs the inverse operation to the id   function: it locates all the nodes in a document that contain IDREF or IDREFS values referencing a given ID value.  Signature Argument target  Type  xs:string*  node  optional   Result  node    node  *  Meaning A sequence of ID values. The function ﬁnds all element and attribute nodes of type IDREF or IDREFS that contain a reference to at least one of the ID values in this argument.  Identiﬁes the document to be searched.  The element and attribute nodes that were found, in document order, without duplicates.  Effect If the idrefs argument is supplied as a node, or a sequence of nodes, then the values of the nodes are automatically atomized by the function calling mechanism. The argument can thus be supplied as any of the following:           A string containing an ID value A node containing an ID value A sequence of either of the above  804   idref  The function locates element and attribute nodes that have the is-idref property and that contain an ID value equal to one of the supplied strings. Note that when an attribute node is matched, it is the attribute node that is returned by the function, not the containing element.  In a schema-aware processor, both elements and attributes can have the is-idref property: they will be given this property if they have a content type that is either xs:IDREF or xs:IDREFS, or a type derived from these types. In a non-schema-aware processor, only attribute values can be recognized as IDREF or IDREFS attributes, and they are recognized as a consequence of validation using a DTD.  It is not an error if there is no node that references one of the target ID values  or even if there is no node that has this ID value . In this situation, there will simply be no node in the resulting sequence corresponding to this value. In the simplest case, where there is only one candidate ID value supplied, the resulting sequence will be empty if the document contains no reference to this ID value.  If the second argument is supplied, the nodes that are returned will come from the same document as the node supplied in this argument. This must be a node in a tree whose root is a document node. The default for this argument is the context node: a runtime error is then reported if the context item is undeﬁned or if it is not a node. The nodes in the supplied target argument will often come from the same document, but this is not required.  IDs and Validation ID and IDREF values only really work properly if the source document is valid  in the XML sense: mean- ing, loosely, that it obeys the rules in its own DTD or Schema . However, XPath is designed to allow invalid documents as well as valid ones to be processed. One possible kind of validity error is that an attribute of type IDREF or IDREFS may contain a value that is not a legal ID value. This situation is not an error as far as XPath is concerned; it just means that this function will never retrieve that node.  When no schema is used, a non-validating XML parser isn’t required to read attribute deﬁnitions from an external DTD. In this situation the XSLT processor will assume there are no IDREF or IDREFS attributes present, and the idref   function will always return an empty result. If this appears to be happening, check what options are available for conﬁguring the XML parser, or try a different parser. Most good parsers will report the attribute type, even though it isn’t absolutely required by the XML standard.  Example Consider the following data, representing part of a family tree  idref source.xml :  13  T h e  F u n c t i o n  i  L b r a r y                         Given a   element as the context node, and assuming that the ref attributes have type xs:IDREF, it is possible to ﬁnd the children of a person as:  idref @id   parent::fatherparent::mother  parent::person  Note the need to check the names of the parent and grandparent elements. Without this check, one would ﬁnd relatives other than the children, for example the spouse. This is because an IDREF in XML doesn’t 805   The Function Library  capture any information about which relationship is being modeled; that is implicit in the context in which the IDREF appears.  Sorry about the confusion here between family trees and XML trees. A family tree is of course not a tree at all in the computer science sense, because people  unlike nodes  have two parents. This means that the parent-child relationship in the family tree cannot be represented by a parent-child relationship in the XML tree; instead, it is represented here by an ID IDREF relationship. Of course, it could have been modeled in either direction, or redundantly in both directions, but the representation chosen above works well because it is in relational third normal form.  See Also id   on page 802  implicit-timezone The implicit-timezone   function returns the value of the implicit timezone from the runtime con- text. The implicit timezone is used when comparing dates, times, and dateTimes that have no explicit timezone.  Signature This function takes no arguments.  Type  Result  xs:dayTimeDuration  Meaning The value of the implicit timezone  Effect Timezones are represented as values of type xs:dayTimeDuration, in the range -PT14H to +PT14H. This function simply returns the value of the implicit timezone from the runtime XPath context. The way that the value is initialized is determined by the implementation; it might be set using an API, or it might simply be taken from the system clock. The idea is that the implicit timezone should be the timezone in which the user is located, but when users are scattered around the world it is not always possible to achieve this.  There are a number of operators and functions that make use of the implicit timezone. The most obvious is when comparing an xs:dateTime that has a timezone to one that does not; in this case, the xs:dateTime without an explicit timezone is assumed to represent a time in the implicit timezone. This means that an expression such as:  if  current-time   gt xs:time ’12:00:00’   then . . .  can be read as ‘‘if the current time in the user’s timezone is after midday. . . .’’  The result of the current-time   function will always be in the implicit timezone.   In the world of XML Schema types, timezone simply means a time shift from UTC. Don’t confuse it with a geographical concept which is sometimes also called timezone; for example, the Eastern time area of the United States. The US Eastern time area has different displacements from UTC at different times of the year. Knowing that the timezone is −05:00 doesn’t tell you that you’re in the US Eastern time area; you might be in the US Central time area in summer, or in Peru at any time of year.  806   index-of  Example If the system is correctly conﬁgured for a user situated in New York, with no daylight savings time in operation, the function implicit-timezone   will return «–PT05:00».  See Also adjust-date time dateTime-to-timezone   family of functions on page 715 current-date time dateTime   family of functions on page 738 timezone-from-date time dateTime   family of functions on page 893  index-of The index-of   function returns a sequence of integers indicating the positions within a particular sequence where items equal to a speciﬁed value occur.  For example, «index-of  "a","b","c" , "b" » returns 2.  Signature Argument sequence  value  Result  Type xs:anyAtomicType* The sequence to be searched  Meaning  xs:anyAtomicType The value to be found  13  T h e  F u n c t i o n  i  L b r a r y  collation  optional   xs:string  The collation to be used when comparing strings  xs:integer*  A list containing the positions within the supplied sequence where items that are equal to the speciﬁed value have been found  Effect If either the sequence or the value is supplied as a node, the nodes are atomized  to extract their values  as part of the function calling rules. This function therefore operates on a sequence of atomic values. It ﬁnds all the items in the atomized sequence that compare as equal to the supplied value under the rules of the «eq» operator, using the speciﬁed collation when comparing strings, or the default collation if none is speciﬁed. It then returns the positions of these items in ascending numeric order, using the usual convention of numbering positions starting at 1.  This means that if a sequence of nodes is supplied, and the nodes are list-valued  for example, a node whose type is xs:NMTOKENS , then the positions returned are the positions in the atomized sequence, which may not be the same as the positions of the nodes in the original sequence.  Untyped atomic values are compared as strings. Values that cannot be compared are treated as not equal. This means that if you search for an integer in a sequence of strings, the result is an empty sequence, not an error.  If no matching items are found, the result is an empty sequence.  Another way of writing this function, assuming that the default collation is used and that the values have already been atomized, would be:  for $i in 1 to count $sequence  return  if  $sequence[$i] eq $value  then $i else     807   The Function Library  Examples Consider the source document:             and assume that this has been validated using a schema that deﬁnes the colors attribute as a sequence of strings.  Expression  index-of   @colors, "red"   index-of   @colors, "green"   index-of   @colors, "pink"   index-of   @colors, 23   Result   2, 3   1          You can take advantage of the fact that index-of   throws no error when comparing values that can never be equal. For example, if you have a list-of-union type that allows a sequence containing a mixture of strings and dates, testing «$sequence=current-date  » could throw an error if one of the items in the sequence is a string rather than a date. Rewriting the expression as «exists index-of $sequence, current-date    » solves the problem.  in-scope-preﬁxes The in-scope-prefixes   function returns a sequence of strings, representing all the namespace preﬁxes that are in scope for a given element.  Changes in 2.0 This function is new in XPath 2.0. It is provided as a replacement for the namespace axis, which is now deprecated.  Signature Argument element  Result  Type  element    xs:string*  Meaning The element whose in-scope namespaces are to be returned  The preﬁxes of the in-scope namespaces  Effect In the XPath data model, the namespaces that apply to a particular element are modeled as a set of namespace nodes: the name of the namespace node represents a namespace preﬁx, and the string value of the namespace node represents the namespace URI.  In XPath 1.0 it was possible to ﬁnd the namespace nodes for a given element using the namespace axis. In XPath 2.0 the namespace axis has been deprecated. This was done because many implementations did not physically represent namespaces as nodes in memory, for efﬁciency reasons, and presenting the information as ‘‘virtual nodes’’ could be expensive, because of the overhead that nodes carry to maintain  808   in-scope-preﬁxes  information about their identity, their parentage, their base URI, and so on. XPath 2.0 has therefore pro- vided a new mechanism to allow applications to obtain the namespace information when it is needed.  The in-scope-prefixes   function returns all the preﬁxes of the in-scope namespaces for an element, or to express it in terms of the data model, the names of all the namespace nodes for that element. The order in which the names appear is unpredictable. The list will always include the name «xml», since the XML namespace is in scope for every element. If there is a default namespace in force for the element, the list will also include the zero-length string to represent the default namespace. Any string in the result other than the zero-length string will be returned as an instance of xs:NCName.  The namespace URIs corresponding to each of these preﬁxes can be determined using the function namespace-uri-for-prefix   described on page 839.  Examples Consider the source document below. Note that this includes a namespace undeclaration for the «soap» namespace, as permitted by XML Namespaces 1.1:    <soap:Envelope     xmlns:soap="http:  schemas.xmlsoap.org soap envelope " xmlns:xs="http:  www.w3.org 2001 XMLSchema">  <echoString xmlns="http:  example.com soapdemo"  xmlns:xsi="http:  www.w3.org 2001 XMLSchema-instance" xmlns:soap="">   Hello            Expression  in-scope-prefixes  soap:Envelope   Result  "xs", "soap", "xml"   in any order   in-scope-prefixes   *:inputString    "xs", "", "xsi", "xml"   in any order   Usage Like the namespace axis that it replaces, this function is unlikely to be needed every day of the week. It is generally needed only when dealing with documents that use namespace preﬁxes as part of the content of elements and attributes  and not only in forming the names of elements and attributes . I have also seen situations where it is necessary simply to detect whether a particular namespace is declared, regardless whether or not it is actually used. For example, you might want to ﬁnd all your stylesheets that declare the namespace http:  icl.com saxon because you have decided to migrate from Saxon 6.5  which uses this namespace  to Saxon 9.x  which does not . You could ﬁnd these using the query:  collection "stylesheets" [  *["http:  icl.com saxon" =  for $p in in-scope-prefixes .  return namespace-uri-for-prefix $p, . ]]  13  T h e  F u n c t i o n  i  L b r a r y  See Also namespace-uri-for-prefix   on page 839 resolve-QName   on page 864  809   The Function Library  insert-before The insert-before   function returns a sequence constructed by inserting an item, or a sequence of items, at a given position within another sequence.  For example, «insert-before  "a","b","c" , 2, "X" » returns « "a", "X", "b", "c" ».  Signature Argument sequence-1  position  sequence-2  Result  Type  item  *  xs:integer  item  *  item  *  Meaning The original sequence  The position in the original sequence where the new items are to be inserted  The items that are to be inserted  The constructed sequence  Effect Remember that sequences are immutable: despite its name, this function doesn’t modify the supplied sequence; it constructs a new sequence containing items copied from the two input sequences.  The returned sequence consists of all items in sequence-1 whose position is less than the speciﬁed position, followed by all items in sequence-2, followed by all remaining items in sequence-1. Posi- tions, as always, are numbered starting at one. It’s not an error if position is outside the actual range of positions in the sequence.  In other words, the result is the same as the value of the expression:  $sequence-1[position   lt $position], $sequence-2, $sequence-1[position   ge $position]  Examples Expression  insert-before 1 to 5, 4,  99, 100    insert-before 1 to 5, 0, 99   insert-before 1 to 5, 10, 99   Result   1, 2, 3, 99, 100, 4, 5    99, 1, 2, 3, 4, 5    1, 2, 3, 4, 5, 99   Usage Although functions are provided to insert items into and remove items from a sequence, there is no function to replace the item at a given position $p. To achieve this, you can write:  insert-before remove $seq, $p , $p, $new-item   or perhaps more simply:  $seq[position   lt $position], $new-item, $seq[position   gt $position]  810   iri-to-uri  See Also remove   on page 861 «,» operator on page 634 in Chapter 10  iri-to-uri iri-to-uri   converts an IRI  Internationalized Resource Identiﬁer  into a URI by percent-encoding special characters according to the rules of RFC 3986 and RFC 3987.  For example, «iri-to-uri ’http:  www.wikipedia.org Gerhard Schr¨oder’ » returns «http:  www.wikipedia.org Gerhard%20Schr%C3%B6der».  Signature Argument value  Type  xs:string?  Meaning The input string, to which URI escaping is to be applied. An empty sequence is treated as a zero-length string.  Result  xs:string  The URI in its escaped form, as a string.  Effect As the name of the function suggests, its purpose is to take an IRI as input and produce a valid URI by escaping those characters that are allowed in an IRI but not in a URI. For completeness, it also escapes those characters that are not allowed in an IRI.  An IRI is essentially a URI in which non-ASCII characters are permitted; for example, the string «http:  www.m¨unchen.de » is a valid IRI, but it is not a valid URI. Applying this function would convert this IRI to «http:  www.m%C3%BCnchen.de ».  Whether this is actually a useful thing to do is a separate matter — current browsers accept this IRI with the «¨u», but reject it after percent-encoding.   The result string is formed from the input string by escaping special characters according to the rules deﬁned in RFC 3986. Special characters are escaped by ﬁrst encoding them in UTF-8, then representing each byte of the UTF-8 encoding in the form %HH, where HH represents the byte as two hexadecimal digits. The digits A–F are always in upper case.  The characters that are considered ‘‘special’’ in this deﬁnition are characters outside the range x21 to x7E, together with « », «"», «{», «}», «», «\», «^», and «‘». Note that this includes the space character, which will be encoded as %20.  13  T h e  F u n c t i o n  i  L b r a r y  If a «%» character occurs in the input string, it will not be escaped as «%25».  iri-to-uri "http:  w3.org simple.xml"   "http:  w3.org simple.xml"  Examples Expression  iri-to-uri "simple.xml"   iri-to-uri "my doc.xml"   iri-to-uri "Gr¨uße.html"   iri-to-uri "100% Java.html"   Result  "simple.xml"  "my%20doc.xml"  "Gr%C3%BC%C3%9Fe.html"  "100%%20Java.html"  811   The Function Library  Usage Although IRIs  Internationalized Resource Identiﬁers  are not very often mentioned, an increasing number of interfaces and protocols actually accept them even though they may still use the term URI. Technically, a URI does not allow non-ASCII characters. This function allows you to bridge from an environment where IRIs are allowed  whether ofﬁcially or unofﬁcially  to a world where they are not recognized.  The handling of percent signs can cause problems, because two different IRIs, for example «My Documents» and «My%20Documents», will be converted to the same URI, which means that the conversion cannot be accurately reversed. If you know that any percent signs in the input string genuinely represent a percent character rather than signalling an escape sequence, then it is a good idea to convert them to «%25» before calling this function. This can be done by calling «replace $in, ’%’, ’%25’ ».  See Also escape-uri-attributes serialization option on page 938 in Chapter 15. encode-for-uri   on page 771 escape-html-uri   on page 775  key This function is available in XSLT only.  The key   function is used to ﬁnd the nodes with a given value for a named key. It is used in conjunction with the   element described on page 376 in Chapter 6.  For example, if there is a key deﬁnition:     then the expression «key ’vreg’, ’N498PAA’ » might return the single element  .  Changes in 2.0 The key value can now be of any type and is compared according to the rules for that type. The key deﬁnitions in   can also now specify a collation to be used for comparing strings.  An optional third argument has been added to identify the document to be searched.  Signature  Argument name  Type  xs:string  value  xs:anyAtomicType*  812  Meaning Speciﬁes the name of the key. The value of the string must be a lexical QName that identiﬁes a key declared using an   element in the stylesheet.  Speciﬁes the required value of the key, in a way that depends on the type. See below.  continued   Argument top  optional   Result  Type  node    node  *  Meaning Identiﬁes the tree to be searched. If this argument is omitted, the document containing the context node is searched.  The nodes with the required key values, returned without duplicates, and in document order.  Effect The ﬁrst argument must take the form of a lexical QName, that is, an XML name optionally preﬁxed with a namespace preﬁx that corresponds to a namespace declaration that is in scope at the point in the stylesheet where the key   function is called. If there is no namespace preﬁx, the relevant namespace URI is null; the default namespace is not used. There must be an   element in the stylesheet with the same expanded QName, using the namespace URIs rather than preﬁxes in the comparison. If there is more than one   element with this name, they are all used: a node is considered to match the key if it matches any of the key deﬁnitions with this name.  The second argument is a sequence of atomic values  usually a single atomic value, but this is treated as a sequence of length one . If the value actually supplied in the function call includes nodes, the nodes are atomized to create a sequence of atomic values. The result of the key   function contains every node in the same document as the context node that has at least one key value that is equal to one of the values supplied in this sequence.  The key values can be of any type. The values of the keys as indexed using   will be compared with the keys supplied in the key   function, using the rules of the XPath «eq» operator without any special type conversion; this means, for example, that if the indexed value is the xs:integer value 23, it will not be retrieved by the call «key ’k’, ’23’ », because the integer 23 and the string ’23’ do not compare as equal. Untyped atomic values  values extracted from unvalidated nodes  are treated as strings and can only be compared with strings. If a collation is speciﬁed in the   declaration, it will be used when comparing strings; otherwise, the default collation will be used.  The optional top argument identiﬁes the tree to be searched. The value can be any node, not necessarily a document node. The default value is the document node of the tree containing the context node. The function searches the subtree rooted at this node, so you can either search a whole document, or a subtree rooted at a particular element  this differs from the id   and idref   functions . A node will be selected by the function only if it has top as an ancestor-or-self node. When the third argument is omitted, it’s an error if there is no context item, or if the context item isn’t a node. It’s also an error to search in a tree that doesn’t have a document node as its root  this rule is for the convenience of implementors, to allow indexes to be maintained at the level of a document .  13  T h e  F u n c t i o n  i  L b r a r y  Usage and Examples The key   function is provided to make associative access to nodes  ﬁnding the nodes given their content  more convenient and more efﬁcient. Efﬁciency of course depends entirely on the implementation, but it is likely that most implementations will use some kind of index or hash-table data structure to make the key   function faster than the equivalent path expression using predicates to select the required value.  Another use for keys is that they provide an efﬁcient way of grouping related nodes together. This usage is needed far less under XSLT 2.0, because of the introduction of the   instruction, but it is still worth your while to understand it.  We will examine these two ways of using keys in turn.  key  813   The Function Library  Using Keys to Find Nodes by Value To locate the   elements having J. B. Priestley as the content of one of their   child ele- ments, you could write:     However, it is probably more efﬁcient, if this is done frequently in the stylesheet, to deﬁne the author name as a key.    . . .    The key   function normally locates elements in the same document as the context node. When you need to locate elements in a different document, you can identify this in the third argument, for example:     The key value is usually supplied as a string, or as an expression that returns a string. In XSLT 2.0 it can also be a value of another atomic type; for example, you can use a number or a date as a key. It does not have to be a single value; you can supply a sequence of strings  or numbers or dates, if that is how the key is deﬁned , and the function will return all the nodes that match any one of the values.  Keys are particularly useful for following cross-references. If you supply the key value as a node, or a sequence of nodes, then the values held in those nodes will be used as the key values. The next example explores this in more detail.  Example: Using Keys as Cross-References  This example uses two source ﬁles: the principal source document is a ﬁle containing a list of books, and the secondary one  accessed using the document   function  contains biographies of authors. The author name held in the ﬁrst ﬁle acts as a cross-reference to the author’s biography in the second ﬁle, rather like a join in SQL.  Source  The principal source document is an abbreviated version of the booklist.xml ﬁle:             The Young Visiters   Daisy Ashford    When We Were Very Young   A. A. Milne        The secondary source document, authors.xml, reads like this. I’ve included only two authors to keep it short, but the key   function would really come into its own if there were hundreds of entries.  814        1852   1956   Alan Alexander Milne, educated at Westminster School and Trinity Col- lege Cambridge, became a prolific author of plays, novels, poetry, short stories, and essays, all of which have been overshadowed by his children’s books.        1881   1972   Daisy Ashford  Mrs George Norman  wrote The Young Visiters, a small comic masterpiece, while still a young child in Lewes. It was found in a drawer in 1919 and sent to Chatto and Windus, who published it in the same year with an introduction by J. M. Barrie, who had first insisted on meeting the author in order to check that she was genuine.        Stylesheet  The stylesheet is in the ﬁle author-biogs.xsl. It declares a key to match   elements by their name attribute. This is intended for use with the authors.xml ﬁle, though there is nothing in the key deﬁnition to say so. Note the use of a global variable to reference the secondary source ﬁle. It would be possible to use the document   function each time the ﬁle is accessed, and any XSLT processor worthy of the name would actually read and parse the ﬁle only once, but using a variable in my view makes it easier to see what is going on. The actual call on the key   function is in the path expression «$biogs key ’biog’, $name ». The purpose of the ﬁrst step, $biogs, is to switch the context node to the authors.xml document, because the key   function  when used with two arguments  always looks in the document containing the context node. The expression could equally have been written «key ’biog’, name, $biogs ».  13  T h e  F u n c t i o n  i  L b r a r y  <xsl:transform xmlns:xsl="http:  www.w3.org 1999 XSL Transform"  version="2.0"  >                         Author s                key  815   The Function Library     <xsl:variable name="auth"  select="$biogs key ’biog’, $name " >                              Output        The output obtained if you run this stylesheet with the subset of the booklist.xml ﬁle shown earlier is as follows.   The Young Visiters   Author   Daisy Ashford   1881 - 1972   Daisy Ashford  Mrs George Norman  wrote The Young Visiters, a small comic masterpiece, while still a young child in Lewes. It was found in a drawer in 1919 and sent to Chatto and Windus, who published it in the same year with an introduction by J. M. Barrie, who had first insisted on meeting the author in order to check that she was genuine.     When We Were Very Young   Author   A. A. Milne   1852 - 1956    Alan Alexander Milne, educated at Westminster School and Trinity College Cambridge, became a prolific author of plays, novels, poetry, short stories, and essays, all of which have been overshadowed by his chil- dren’s books.       Using Keys for Grouping Because keys provide an efﬁcient way of retrieving all the nodes that share a common value, they are useful when you need to group nodes with common values in the output.  This technique is sometimes called the Muenchian grouping method, after Steve Muench of Oracle who introduced it. In XSLT 1.0, it was the only way of performing grouping efﬁciently. In XSLT 2.0, the   construct will usually provide a more convenient solution; however, you will still encounter the Muenchian method used in old stylesheets, and there is no reason why you should not continue to use it.  816   To solve any grouping problem, you need two nested loops. The outer loop selects one node to act as a representative of each group, typically the ﬁrst node in document order that is a member of the group. The processing associated with this node outputs information about the group as a whole, typically the common value used to group the nodes together, perhaps with counts or subtotals calculated over the members of the group, plus any necessary formatting. The inner loop then processes each member of the group in turn.  With the Muenchian method, a key is deﬁned on the common value that determines group membership. For example, if all the cities in a country compose one group, then the key deﬁnition will be as follows.     The outer loop selects one city for each country. The way of doing this is to select all the cities, and then ﬁlter out those that are not the ﬁrst in their country. You can tell that a city is the ﬁrst one for its country by comparing it with the ﬁrst node in the sequence returned by the key   function for that country.     The «is» operator is new in XPath 2.0. In an XSLT 1.0 stylesheet, the equivalent expression would apply generate-id   to both operands, and compare the results using the «=» operator.  Within this loop the code can output any heading it needs, such as the name of the country. It can then start an inner loop to process all the cities in this country, which it can ﬁnd by using the key once again.     The following shows a complete example of this technique.  Example: Using Keys for Grouping  This example creates a list of cities, grouped by country.  Source     The source cities.xml is a list of cities.                        Stylesheet  The stylesheet citygroups.xsl is as follows:  key  13  T h e  F u n c t i o n  i  L b r a r y  817   The Function Library  <xsl:transform  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" version="2.0"  >                                      Output  Viewed in a browser, the output is as shown in Figure 13-2.  Figure 13-2  818   lang  See Also   on page 376 in Chapter 6 id   on page 802  lang The lang   function tests whether the language of a given node, as deﬁned by the xml:lang attribute, corresponds to the language supplied as an argument.  For example, if the context node is the element    indicating Canadian French , then the expression «lang ’fr’ » would return true.  Changes in 2.0 An optional second argument has been added to allow nodes other than the context node to be tested.  Signature Argument language  node  optional   Result  Type  xs:string  node    xs:boolean  Meaning The language being tested  The node being tested. If omitted, the context node is tested.  true if the language of the selected node is the same as, or a sublanguage of, the language being tested.  Effect The function tests the node identiﬁed by the second argument if present, or the context node if it is omitted. When the second argument is absent, a runtime error occurs if there is no context item, or if the context item is not a node.  The language of the selected node is determined by the value of its xml:lang attribute, or if it has no such attribute, by the value of the xml:lang attribute on its nearest ancestor node that does have such an attribute. If there is no xml:lang attribute on any of these nodes, the lang   function returns false.  The xml:lang attribute is one of the small number of attributes that are given a predeﬁned meaning in the XML speciﬁcation  in fact, you could argue that it is the only thing in the XML speciﬁcation that has anything to say about what the contents of the document might mean to its readers . The value of the attribute is a language identiﬁer as deﬁned in RFC 3066; this takes one of the following four forms:        A two- or three-letter language code deﬁned in the international standard ISO 639. For example, English is «en» and French is «fr». This can be given in either upper case or lower case, though lower case is usual. A language code as above, followed by one or more subcodes: each subcode is preceded by a hyphen «-». For example, US English is ‘‘en-US’’; Canadian French is ‘‘fr-CA’’. The ﬁrst subcode, if present, must be either a two-letter country code from the international standard ISO 3166 or a subcode for the language registered with IANA  Internet Assigned Numbers Authority . The ISO 3166 country codes are generally the same as Internet top-level domains; for example, ‘‘DE’’ for Germany or ‘‘CZ’’ for the Czech Republic, but with the notable excep- tion of the United Kingdom, whose ISO 3166 code  for some reason  is ‘‘GB’’ rather than ‘‘UK’’. These codes are generally written in upper case. The meaning of any subcodes after the ﬁrst is  13  T h e  F u n c t i o n L b r a r y  i  819   The Function Library  generally not deﬁned  though a few have been registered with IANA , but they must contain ASCII letters  a–z, A–Z  only. A language code registered with IANA  see http:  www.isi.edu in-notes iana assign- ments languages  , preﬁxed ‘‘i-’’, for example, ‘‘i-Navajo’’. A user-deﬁned language code, preﬁxed ‘‘x-’’, for example, ‘‘x-Java’’ if the element contains a Java program.  The xml:lang attribute deﬁnes the language of all text contained within the element it appears on, unless it is overridden by another xml:lang attribute in an inner element. So if a document is written in English but contains quotations in German, the xml:lang language code on the document element might say «xml:lang="en"», while an element containing a quotation speciﬁes «xml:lang="de"».  The lang   function allows you to test whether the language for the context node is the one you are expecting. For example «lang ’en’ » returns true if the language is English, while «lang  ’jp’ » returns true if it is Japanese.  Speciﬁcally, the rules are as follows:  If the value of xml:lang for the selected node is equal to the string supplied in the argument, ignoring differences of case, the function returns true. If the leading part of the value of xml:lang for the selected node, up to some hyphen «-», is equal to the string supplied in the argument, again ignoring differences of case, the function returns true. Otherwise, the function returns false.                 Examples Expression  boolean   *[lang ’de’ ]    * msg[@code=$p][lang ’fr’ ]  Result true   if the document contains any elements marked as being in German  The   element with a required code value that is marked as being in French  Usage This function provides a convenient way of testing the language used in a source document. Assuming that the source document has been properly marked up using the xml:lang attribute as deﬁned in the XML speciﬁcation, the lang   function allows you to do language-dependent processing of the data.  The lang   function only allows you to test whether the language is one of the languages you are expecting; if you want to ﬁnd out the actual language, you will need to read the xml:lang attribute directly. You can ﬁnd the relevant attribute using the expression « ancestor-or-self::*  @xml:lang [last  ]».  last The last   function returns the value of the context size. When processing a sequence of items, if the items are numbered from one, last   gives the number assigned to the last item in the sequence.  820   last  Changes in 2.0 None.  Signature This function takes no arguments.  Type  Result  xs:integer  Meaning A number, the value of the context size. As the name implies, this is context dependent.  Effect The XPath speciﬁcation deﬁnes the value of the last   function in terms of the context size.  The context size is part of the focus, which is described in the spec as having three components: the context item, the context position, and the context size. However, it may be easier to think of the focus as being a bit like an Iterator object in a language such as Java. Behind the iterator is a list of items that are processed individually  though not necessarily in any particular order . The context item, position, and size can be thought of as three methods provided by this iterator object: the context position is a number that ranges from 1 to the size of the list, the context item is the item found at the context position, and the context size is the number of items in the list.  When a top-level XPath expression is evaluated  that is, an XPath expression that is not part of another expression , the context size is set by the host language. In XSLT, it is set from the XSLT context. For example:    When a global   declaration is being evaluated, or in certain other contexts such  as evaluating the use expression in  , or evaluating the initial template that matches the root node, it is normally set to 1  one .    When   is called to process a sequence of nodes, the context size is the  number of nodes selected in the call of  .    When   is called to process a sequence of items, the context size is the number of  items selected in the call of  .  13  T h e  F u n c t i o n L b r a r y  i  This means that within an   iteration, the test   succeeds when the last item in the sequence is being processed.  Many APIs that enable XPath expressions to be executed from languages like Java or JavaScript allow the caller to set the context item, but not the context position or size. In such cases, the context position and size on entry to the XPath expression will normally both be one.  Within an XPath expression, the context size changes within a predicate and on the right-hand side of the « » operator.        In a predicate, last   refers to the number of items in the sequence that is being ﬁltered using the predicate. For example, «$seq[last  ]» selects the last item in a sequence  this is short for «$seq[position  =last  ]» , while «$seq[ceiling last   div 2 ]» selects the item at the midway position of the list  the fourth item in a list of eight, the ﬁfth item in a list of nine . It’s less common to ﬁnd last   being used on the right-hand side of a « » operator. It refers to the number of items in the sequence selected by the left-hand operand of the « ». I can’t ﬁnd a  821   The Function Library  very plausible way of using this, but it can be done. For example, «$a  if  last  =2  then . else    » returns all items from $a if there are exactly two items, and in all other cases returns nothing. But there are simpler ways of writing this!  Usage When last   is used within a predicate in a ﬁlter expression, the focus refers to the sequence of items being ﬁltered. If the ﬁlter is used within a step of a path expression, then the context size is the number of nodes selected by the current step of the expression, after applying any previous ﬁlters. For example, suppose the source document is as follows:                         Then:              The expression «countries country[last  ]» returns the   element for Nigeria. The expression «countries country[@continent=’Europe’][last  ]» returns the   element for Poland. The expression «countries country[@continent=’Europe’][last  -1]» returns the   element for Italy. The expression «countries country[@continent=’Africa’] [position   !=last  ]» returns the   elements for Egypt and Libya.  An easy mistake is to think that last   returns a boolean value. You can use last   in a predicate to match the last node, for example «para[last  ]». This is a shorthand for the predicate «[position  =last  ]» , because in a predicate, a numeric value X is equivalent to a test for the condition « position  =X». However, this doesn’t extend to other contexts, for example if you write:  if  last    then ...  then the numeric value of the last   function is simply converted to a boolean as if the boolean   function were used. The result will always be true, because last   can never be zero.  Usage in XSLT The last   function can be called in XSLT as a freestanding XPath expression, or in simple tests such as  . This kind of usage is frequent in XSLT, because XSLT makes heavy use of the focus. To understand the effect of calling last  , you need to know how different XSLT instructions set the focus.  When last   is used as a top-level expression within an    and not within <xsl: for-each> , it returns the number of nodes selected by the relevant   select  822   expression. This is because   sets the focus to refer to the sequence of nodes selected by the select expression, after sorting them into the order in which they are processed.  For example, the following code can be used to number all the ﬁgures in a document. The last   function prints the number of ﬁgure elements in the document.    . . .         Figure           The «version="2.0"» setting is used to ensure that   displays the whole sequence in its select attribute, not just the ﬁrst item.   Similarly, when last   is used as a top-level expression within  , it returns the number of items selected by the relevant   select expression. Again, this is because   sets the focus to refer to the sequence of items selected by the select expression, after sorting into the correct order.  If the last   function is used within the select expression of an   element, then it refers to the number of items being sorted. For example, specifying the following sort key:     will sort the nodes A, B, C, D, E, F, G, H into the sequence A, D, G, B, E, H, C, F, which might be useful if you want to arrange them in a table with three columns.  The last   function can be used as a qualiﬁer in a pattern when the last child of a given element is to be treated differently from the others. For example:  13  T h e  F u n c t i o n  i  L b r a r y                           However, this may not perform well on all processors, because in principle each   element needs to be tested to see if it is the last one, which may involve looking at all the children of the parent of the   element. Some processors may optimize this construct, but it’s best not to assume it will  in Saxon, as it happens, «match="p[last  ]"» is quite efﬁcient, but «match="p[last  -1]"» is rather expensive .  Using   will often achieve the same effect more economically:              last  823   The Function Library              However, note that these two examples are not strictly equivalent. If the   elements are processed by a call on   with no   speciﬁcation, they will have the same effect; but if a sort key is speciﬁed, then the second template will output an   element after the last   element in the order of the output, whereas the ﬁrst will output the   element after the last   element in document order.  See Also count   on page 733 position   on page 854   in Chapter 6, page 403  local-name The local-name   function returns the local part of the name of a node, that is, the part of the name after the colon if there is one, or the full name otherwise.  For example, if the context node is an element named   then the expression «local-name  » returns «title»; for an element named  , it returns «schema».  Changes in 2.0 Under XPath 2.0 it is an error to supply a sequence containing more than one node, except when running in backward-compatibility mode.  Signature Argument node  optional   Type  node  ?  Meaning Identiﬁes the node whose local name is required. If the argument is an empty sequence, the function returns a zero-length string. If the argument is omitted, the target node is the context node. It is then an error if there is no context item, or if the context item is not a node  Result  xs:string  A string value: the local part of the name of the target node.  Effect The local name of a node depends on the kind of node, as follows: Node kind document  Local name None, a zero-length string is returned  element  attribute  text  The element name, after any colon  The attribute name, after any colon  None, a zero-length string is returned  824  continued   Node kind processing instruction The target used in the processing instruction to identify the application for  Local name  which it is intended  None, a zero-length string is returned  The namespace preﬁx; or the zero-length string if this is the default namespace     comment  namespace  Examples Consider the source document:  Expression  local-name     local-name  *   local-name  * @*[.=’high’]   local-name  * @*[.=’A23’]   local-name  Result  ""  "doc"  "security"  "id"  Usage This function can be useful if you need to test the local name without also testing the namespace URI. For example, if you want to select both   and   elements, you could do this by writing:  However, XPath 2.0 allows you to achieve this more directly by writing:  *[local-name  =’title’]  *:title  In some ways this can be seen as a misuse of the XML Namespaces facility. The names in one namespace are supposed to bear no relation to the names in another, so any similarity between the names   and   is a pure coincidence.  In practice, this isn’t always true. What often happens is that one namespace is adapted from another. For example, the US Post Ofﬁce might devise a schema  and associated namespace  for representing US names and addresses, and the Canadian Post Ofﬁce might then create a variant of this, with a different namespace URI, for Canadian names and addresses. The two schemas will have many elements in com- mon, and it’s quite reasonable to try to write a stylesheet that can handle either. If you want to write template rules that match on both a   and a  , there are two ways of doing it:  13  T h e  F u n c t i o n  i  L b r a r y  Either list both possibilities:     or match on the local name only:     825   The Function Library  or equivalently:     It’s not a good idea to use this construct simply to avoid the hassle of declaring the namespace preﬁx. Your code will almost certainly be less efﬁcient, and it runs the risk of producing incorrect results because it can match elements in namespaces you weren’t expecting.  XSLT Example The following stylesheet fragment outputs an HTML table listing the attributes of the current element, sorted ﬁrst by namespace and then by local name:                                         See Also name   on page 835 namespace-uri   on page 837  local-name-from-QName The function local-name-from-QName   returns the local-name part of an xs:QName value.  Signature Argument Type value  xs:QName?  Meaning The xs:QName value whose local-name part is required. If the supplied value is an empty sequence, an empty sequence is returned.  Result  xs:NCName? The local-name part of the xs:QName.  Effect Given an expanded QName  that is, an instance of type xs:QName , this function returns the local-name part of the value.  The result is an xs:NCName. This is a type derived by restriction from xs:string, so the return value can be used anywhere that a string can be used. In a basic XSLT processor, which does not recognize the xs:NCName type directly, the value can still be used as a string.  826   Examples Expression  local-name-from-QName QName ’http:  mhk.me.uk some.uri’, ’my:invoice’    "invoice"  local-name-from-QName node-name @xml:space    The second example assumes that the context node has an attribute called xml:space.  lower-case  Result  "space"  See Also QName   on page 858 namespace-uri-from-QName   on page 841  lower-case The lower-case   function converts upper-case characters in a string to lower case.  For example, «lower-case "McAndrew" » returns "mcandrew".  Signature Argument value  Result  Type  xs:string?  xs:string  Meaning The string to be converted  The string with upper-case letters converted to lower case.  Effect For those whose only language is English, the matter of converting characters between upper case and lower case is straightforward: there is a direct one-to-one mapping between the 26 upper-case letters A–Z and the 26 lower-case letters a–z. In other languages, the relationship is not always so simple. In many Oriental scripts there is no concept of case at all. Even with Western languages there are many complications. To take a few examples:              The upper-case equivalent of the German «ß» character is the character pair «SS». In most languages, the lower-case equivalent of «I» is «i», but in Turkish, it is «ι»  known as ‘‘dotless I’’ . Some characters have multiple lower-case forms, depending on context; for example, the lower-case version of the Greek « cid:2 »  sigma  is «σ » or « » depending on where in the word it appears. Some accented characters exist in both upper-case and lower-case forms, but the upper-case form is usually written without accents when it appears in running text.  Fortunately, the Unicode consortium has deﬁned a mapping from upper-case to lower-case charac- ters, and the XPath speciﬁcation refers to this mapping. An outline of the principles can be found in Unicode Technical Report 21  http:  www.unicode.org unicode reports tr21  . This material has been merged into Unicode 4.0, but in my view the original technical report is easier to read. The actual  13  T h e  F u n c t i o n  i  L b r a r y  827   The Function Library  character mappings can be extracted from the database of Unicode characters found on the Unicode Web site.  The effect of the function is as follows:        If the input is an empty sequence, the result is the zero-length string. Otherwise, every character in the input string is replaced by its corresponding lower-case character  or sequence of characters  if there is one, or it is included unchanged in the result string if it does not.  The function does not implement case mappings that Unicode deﬁnes as being locale-sensitive  such as the Turkish dotless I . A good implementation will support the mappings that are context- sensitive  such as the choice between the two lower-case sigma characters , but it would be unwise to rely on it.  Examples Expression  lower-case "Sunday"   lower-case "2+2"   lower-case "C´ESAR"   lower-case "E cid:4  cid:4 A cid:2 "   Result  "sunday"  "2+2"  "c´esar"  "ελλα "  Usage With simple ASCII keywords, it’s safe to use the lower-case   or upper-case   functions to do a case-blind comparison, for example:  if  lower-case $param  = "yes"  then ...  With a more extensive alphabet, it’s better to use a speciﬁc collation for this purpose. The reason is that converting two strings to lower case for comparison doesn’t always work  «STRASSE» will be mapped to «strasse», while «Straße» will be mapped to «straße» . Converting both to upper case is better, though there are still a few problems that can crop up.  So it’s best to use this function only if you genuinely need to convert a string to lower case, not just in order to perform comparisons.  Note also that the «i» ﬂag can be used to achieve case-blind matching in regular expressions used by the matches  , replace  , and tokenize   functions.  See Also translate   on page 897 upper-case   on page 910  828  matches The matches   function tests whether a supplied string matches a regular expression.   matches  Signature Argument Type input  xs:string?  Meaning The string to be tested against the regular expression. If an empty sequence is supplied, it is treated as a zero-length string.  regex  ﬂags  optional   xs:string  The regular expression.  xs:string  One or more letters indicating options on how the matching is to be performed. If this argument is omitted, the effect is the same as supplying a zero-length string, which defaults all the option settings.  Result  xs:boolean?  True if the input string matches the regular expression, false if not.  Effect Regular expressions provide a powerful pattern-matching capability for strings.  The syntax of regular expressions supported by this function is described in Chapter 14. The syntax is based on the regular expression syntax deﬁned for the pattern facet in XML Schema, which, in turn, is based on the established conventions used in languages such as Perl. The meaning of the flags argument is also described in Chapter 14, on page 925.  Note that whereas the pattern facet in XML Schema uses a match that is implicitly anchored to the ends of the string, this function does not. A pattern speciﬁed in XML Schema must match the entire string to be successful; the regex speciﬁed in this function only needs to match some substring. For example, «[0-9]+» will match a string if it contains as a substring a «» character followed by one or more digits. If you want to test whether the entire string takes the form of a «» character followed by one or more digits, use the regex «^[0-9]+$».  If the regular expression or the ﬂags argument does not conform to the speciﬁed syntax, a fatal error is reported at runtime  or at compile time, if it can be detected then .  Examples Assume that $e is the following element:   A grand little lad was young Albert All dressed in his best, quite a swell With a stick with an horse’s head handle The finest that Woolworth’s could sell.   Expression  matches $e, "grand"   matches $e, "^The finest", "m"   matches $e, " ^.*$ *", "m"   matches $e, "Albert.*Woolworth’s", "s"   matches $e, "woolworth’s", "i"   13  T h e  F u n c t i o n  i  L b r a r y  Result  true  true  true  true  true  continued  829   The Function Library  Expression  matches "banana", "^ .a +$"  matches "23 May 2008", "^[0-9]+\s[A-Z][a-z]+\s[0-9]+$"  matches "", "a*"   In XSLT, the fourth example might be written:  Result  true  true  true   . . .   Note the use of two apostrophes to represent a single apostrophe within a string literal.  Usage The matches   function provides a powerful alternative to the contains  , starts-with  , and ends-with   functions. It might be more expensive, but this is only likely to make a difference if searching a large amount of text, or when using an unusually complex regular expression.  See Also Regular Expression Syntax, Chapter 14 contains   on page 730 ends-with   on page 773 replace   on page 862 starts-with   on page 875 tokenize   on page 894  max, min The max   and min   functions returns the maximum or minimum value in a sequence. The input sequence may contain any items that can be compared using the «lt» and «gt» operators.  Type  xs:anyAtomicType*  Meaning The input sequence  xs:string  Collation used for comparing strings  xs:anyAtomicType?  The maximum minimum value found in the input sequence  Effect If the sequence supplied in the function call contains nodes, then the nodes will automatically be atom- ized  to extract their typed values  as part of the function call mechanism.  Any untyped atomic values in the atomized sequence  which will typically result from atomizing a node in a schema-less document  are converted to xs:double values. A runtime error is reported if there are values that cannot be converted. If there are NaN  not-a-number  values in the sequence, which might happen if you do the conversion to numbers yourself using the number   function, then the result of the function is NaN. If the input sequence is empty, the result is an empty sequence.  Signature Argument sequence  collation  optional   Result  830   max, min  If the sequence contains numeric values of different types, then they are all converted to the least common type. This means that if the sequence contains an xs:double, all the values will be converted to xs:double; otherwise, if it contains an xs:float, all the values will be converted to xs:float. Simi- larly, if the sequence contains a mixture of xs:string and xs:anyURI values, then the xs:anyURI values will be converted to xs:string.  In the resulting sequence, all the values must be comparable using the «lt» operator. This rules out values of types such as xs:QName and xs:hexBinary for which no ordering is deﬁned, and it rules out sequences that mix values such as integers and strings. The max   function then returns a value that is greater than or equal to every other value in the sequence, while the min   function returns a value that is less than or equal to every other value in the sequence. This will always be a value after any conversion: for example «max  10, 1.5e0  » is the xs:double value 10e0.  If there are two values that both satisfy this condition  for example two xs:dateTime values in different timezones  then it is not predictable which of them will be returned.  If the collation argument is supplied, then it is used when comparing strings. If the sequence contains strings and no collation is supplied, then the default collation is used.  Examples Expression  max 2   max      max  10, 20, xs:float –5 , 13    max  "a", "x", "b"    Result 20 as an xs:float value  "x"  assuming a typical collation   2      13  T h e  F u n c t i o n  i  L b r a r y  min  xs:dayTimeDuration ’PT10 S’ , xs:dayTimeDuration ’PT1 M’     PT10 S as an xs:dayTimeDuration  min  xs:date ’2000-01-01’ , current-date      2000-01-01 as an xs:date  Usage Note that max   and min   return an atomic value. If you supply a sequence of nodes, the nodes are atomized, and the highest  or lowest  atomic value is returned. If you actually want to know which node contained the highest or lowest value, you will have to search for it, using a predicate. For example:  $nodes[size=max $nodes size ]  Because of this limitation, it may sometimes be better to use the technique of sorting the nodes and selecting the ﬁrst or last. For example:                   A common usage is to ﬁnd the larger or smaller of two values. Remember in this case that you need to construct a sequence containing the two values: «max  0, $amount-due  ». If you forget the second pair  831   of parentheses, you are calling the two-argument form of the function, which is likely to result in the rather cryptic message ‘‘Unknown collation’’.  The Function Library  min See max   on page 830  minutes-from-dateTime, minutes-from-time The two functions minutes-from-dateTime   and minutes-from-time   extract the minutes component from an xs:date or xs:dateTime value. For example, at 16:30 local time both these functions return 30.  Type xs:time or xs:dateTime?  Meaning The value from which the minutes component is to be extracted. The type of the supplied argument must correspond to the type implied by the function name.  Result  xs:integer  The minutes component, in the range 0 to 59.  Effect The function returns the minutes component of the supplied xs:time or xs:dateTime. The value is from the time as expressed in its local timezone  which will be the same as the minutes component of the time in UTC except in the case where the timezone offset is not a multiple of one hour .  Signature Argument input  Examples Expression  minutes-from-time xs:time "12:35:03.142"    minutes-from-dateTime xs:dateTime "2008-02-28T13:55:30"    minutes-from-time xs:time "00:30:02+01:00"    minutes-from-dateTime xs:dateTime "2008-07-31T03:10:00+08:30"    See Also current-date  , -dateTime  , -time   on page 738 format-date  , -dateTime  , -time  on page 781 day-from-date  , -dateTime   on page 744 year-from-date  , -dateTime   on page 911  minutes-from-duration This function extracts the value of the minutes component from a normalized xs:duration value.  Result  35  55  30  10  832   month-from-date, month-from-dateTime  Signature Argument input  Type  xs:duration?  Result  xs:integer?  Meaning The value from which the component is to be extracted. If an empty sequence is supplied, an empty sequence is returned. The minutes component, in the range −59 to +59.  Effect The function returns the minutes component of the supplied xs:duration. The duration value is ﬁrst normalized so that the number of hours is less than 24, the number of minutes is less than 60, and so on. The result will be negative if the duration is negative.  Examples Expression  minutes-from-duration xs:dayTimeDuration "PT12H20 M"    minutes-from-duration xs:duration "PT210 S"    minutes-from-duration xs:duration "-PT75 M"    minutes-from-duration xs:yearMonthDuration "P1Y"    See Also days-from-duration   on page 745 hours-from-duration   on page 801 seconds-from-duration   on page 874  minutes-from-time See minutes-from-dateTime   on page 832.  month-from-date, month-from-dateTime These two functions extract the month component from an xs:date or xs:dateTime value. For example, on Christmas Day «month-from-date current-date   » returns 12.  Signature Argument input  Type xs:date? or xs:dateTime?  Meaning The value whose month component is to be extracted. The type of the supplied argument must correspond to the type implied by the function name. If an empty sequence is supplied, an empty sequence is returned.  Result  xs:integer?  The month, in the range 1  January  to 12  December .  Result  20  3  0  -15  13  T h e  F u n c t i o n  i  L b r a r y  833   The Function Library  Effect The function returns the month component of the supplied xs:date or xs:dateTime. The value is used in its local timezone  not normalized to UTC .  Examples Expression  month-from-date xs:date "2008-02-28"    month-from-dateTime xs:dateTime "2008-02-28T13:00:00"    month-from-date xs:date "2008-07-31+01:00"    month-from-dateTime xs:dateTime "2008-07-31T23:00:00-05:00"    Result  2  2  7  7  See Also current-date  , -dateTime  , -time   on page 738 format-date  , -dateTime  , -time   on page 781 day-from-date  , -dateTime   on page 744 year-from-date  , -dateTime   on page 911  months-from-duration This function extracts the value of the months component from a normalized xs:duration value.  Signature Argument input  Type  xs:duration?  Result  xs:integer?  Meaning The value from which the component is to be extracted. If an empty sequence is supplied, an empty sequence is returned. The months component, in the range −11 to +11.  Effect The function returns the months component of the supplied xs:duration. The duration value is ﬁrst normalized so that the number of months is less than 12. The result will be negative if the duration is negative.  Examples Expression  months-from-duration xs:yearMonthDuration ’P1Y3 M’    months-from-duration xs:yearMonthDuration ’P15 M’    months-from-duration xs:duration ’-P1Y3 M’    months-from-duration xs:dayTimeDuration ’P365D’    834  Result  3  3  0  -3   name  See Also years-from-duration on page 911  name The name   function returns a string in the form of a lexical QName that represents the name of a node. For example, if the context node is an element named  , then the expression «name  » will return the string «ms:schema».  Changes in 2.0 Under XPath 2.0 it is an error to supply a sequence containing more than one node, unless running in backward-compatibility mode.  The data model now retains the namespace preﬁx, so the preﬁx returned by this function is more predictable.  Signature Argument node  optional   Type  node  ?  Meaning Identiﬁes the node whose name is required. If the argument is an empty sequence, the function returns a zero-length string. If the argument is omitted, the target node is the context node. It is then an error if there is no context item, or if the context item is not a node.  Result  xs:string  A string value: a QName representing the name of the target node.  Effect The name of a node depends on the kind of node, as follows:  Node kind document  element  attribute  text  comment  namespace  Name None, a zero-length string is returned.  The element name  a lexical QName , as it appears in the source XML.  The attribute name  a lexical QName , as it appears in the source XML.  None, a zero-length string is returned.  processing instruction  The target used in the processing instruction to identify the application for which it is intended.  None, a zero-length string is returned.  The namespace preﬁx; or the zero-length string if this is the default namespace.  This is not preﬁxed with «xmlns:».   Except for element and attribute nodes, name   returns the same value as local-name  .  For elements and attributes, the name   function is the only XPath construct whose result depends directly on the namespace preﬁxes used in the node name, as distinct from the local name and the names- pace URI.  835  13  T h e  F u n c t i o n  i  L b r a r y   The Function Library  Where the node is an element or attribute from a source document, the QName returned will normally use the same preﬁx as appeared in the original XML source. However, it is good practice not to rely on a particular preﬁx being used, because originators of XML documents generally assume that they have a free choice of namespace preﬁxes, and any preprocessing applied to the document before the transformation starts could change the preﬁxes. When the node was constructed during the course of the transformation, for example by an   or   instruction, the XSLT language speciﬁcation in most cases mandates the preﬁx that will be used. There are a few cases, however, where the system may need to choose a different preﬁx in order to avoid conﬂicts, and in these cases the result of the name   function becomes unpredictable.  Usage The name   function is useful when you want to display the element name, perhaps in an error message, because the form it takes is the same as the way in which users will generally write the element name.  So, for example, you could use name   in the output of the diagnostic trace   function:  for $e in child::* return  trace string . , concat "contents of element ", name      You can also use the name   function to test the name of a node against a string, for example, «doc:title[name .. =’doc:section’]». However, it’s best to avoid this if you can:        Firstly, this fails if the document uses a different preﬁx to refer to the namespace. There’s nothing here to tell the system to treat «doc:section» as a QName, so if the writer of a particular doc- ument chose to use the preﬁx «DOC» instead of «doc» for this namespace, the test would fail, even though the names are equivalent. Secondly, there is usually a better way of doing it: this particular example can be written as «doc:title[parent::doc:section]». In fact, in most cases where you want to test whether a node has a particular name, you can do it using a predicate of this form. The «self» axis is particularly useful. For example, to test whether the current node is a figure element, write «if  self::figure  then ...». This doesn’t work for attribute nodes  because the principal node kind of the self axis is element nodes; see Name Tests in Chapter 9, page 614 . Instead you can write «if  self::attribute figure   then...».  One common requirement is to sort data on the value of a sort key that is supplied as a runtime parameter  this might be because the user has asked interactively for a table to be sorted on a particular column . XSLT does not allow the expression that deﬁnes the sort criteria to be completely dynamic. But very often the possible sort keys are all element children of the elements that represent the rows being sorted. In this situation it is possible to deﬁne the sort key like this:        If you are using namespaces it is safer to do such tests using the node-name   function, which gives you an xs:QName as its result: an xs:QName represents an expanded name  namespace URI plus local name  and is not sensitive to the choice of preﬁx. Alternatively, use the namespace-uri   and local-name   functions to test the two components of the expanded name separately.  If you want to select all attributes except the description attribute, you can write:  @*[name   != ’description’]  836   namespace-uri  This is namespace-safe, because an unpreﬁxed attribute name always represents a name in no namespace. But in XPath 2.0, I prefer:  @* except @description  In XSLT, avoid using name   to generate a name in the result document, for example, by writing  . The problem is that any preﬁx in name   is interpreted in the light of namespace declarations appearing in the stylesheet, not namespace declarations in the original source document. The correct tool for this job is  . There are cases where   won’t do the job; for example, you may want to use the name of an attribute in the input document to generate the name of an element in the output document. In this case, use local-name   and namespace-uri   separately, for example:          text    Examples Consider the source document:     Expression  name     name  *   name  * @*[.=’high’]   name  * @*[.=’A23’]   name   comment     name    text   [1]   name   processing-instruction     name   namespace::my   See Also local-name   on page 824 namespace-uri   in the following section node-name   on page 843  Result  ""  "my:doc"  "security"  "xml:id"  ""  ""  "action"  "my"  13  T h e  F u n c t i o n  i  L b r a r y  namespace-uri The namespace-uri   function returns a string that represents the URI of the namespace in the expanded name of a node. Typically, this will be a URI used in a namespace declaration, that is, the value of an xmlns or xmlns:* attribute in the source XML.  For example, if you apply this function to the outermost element of an XSLT stylesheet by writing the expression «namespace-uri doc ’’  * », the result will be the string «http:  www.w3.org 1999  XSL Transform».  837   The Function Library  Signature Argument node  optional   Type  node  ?  Changes in 2.0 The result is an xs:anyURI value rather than a string. This makes very little difference in practice.  Meaning Identiﬁes the node whose namespace URI is required. If the argument is an empty sequence, the function returns a zero-length string. If the argument is omitted, the target node is the context node. It is then an error if there is no context item, or if the context item is not a node.  Result  xs:anyURI  The namespace URI of the expanded name of the target node.  Effect The namespace URI of a node depends on the kind of node, as follows:  Node kind document  element  attribute  Namespace URI None, a zero-length URI is returned.  If the element name as given in the source XML contained a colon, the value will be the URI from the namespace declaration corresponding to the element’s preﬁx. Otherwise, the value will be the URI of the default namespace. If this is null, the result will be a zero-length URI.  If the attribute name as given in the source XML contained a colon, the value will be the URI from the namespace declaration corresponding to the attribute’s preﬁx. Otherwise, the result will be a zero-length URI.  text  None, a zero-length URI is returned.  processing instruction  None, a zero-length URI is returned.  comment  namespace  None, a zero-length URI is returned.  None, a zero-length URI is returned.  Except for element and attribute nodes, namespace-uri   returns an empty string.  The result of the function is an xs:anyURI value rather than an xs:string. However, the type promotion rules ensure that an xs:anyURI can be used almost anywhere that an xs:string is allowed. There are one or two exceptions, for example the casting rules are different, but unless you choose strings such as «true» and «false» as namespace URIs and then attempt to cast them to xs:boolean the differences are unlikely to be noticed.  Examples Consider the source document:     838   namespace-uri-for-preﬁx  Expression  namespace-uri     namespace-uri  *   namespace-uri  * @security   namespace-uri  * namespace::my   "http:  ibm.com ebiz"  Result  ""  ""  ""  namespace-uri  * @xml:id   "http:  www.w3.org XML 1998 namespace"  Usage Let’s start with some situations where you don’t need this function.  If you want to test whether the context node belongs to a particular namespace, the best way to achieve this is using a NameTest of the form «prefix:*». For example, to test  in XSLT  whether the current element belongs to the «http:  ibm.com ebiz» namespace, write:     If you want to ﬁnd the namespace URI corresponding to a given preﬁx the best solution is to use name- space nodes. You might need to do this if namespace preﬁxes are used in attribute values: the XSLT standard itself uses this technique in attributes such as extension-element-prefixes, and there is no reason why other XML document types should not do the same. If you have an attribute «@value», which you know takes the form of a namespace-qualiﬁed name  a QName , you can get the associated namespace URI using the expression:  namespace-uri-for-prefix substring-before @value, ’:’ , .   The namespace-uri   function, by contrast, is useful in display contexts, where you just want to display the namespace URI of the current node, and also if you want to do more elaborate tests. For example, you may know that there is a whole family of namespaces whose URIs all begin with urn:schemas.biztalk, and you may want to test whether a particular element is in any one of these. You can achieve this by writing:  13  T h e  F u n c t i o n  i  L b r a r y  if  starts-with namespace-uri  , ’urn:schemas.biztalk’   then ...  See Also local-name   on page 824 name   on page 835  namespace-uri-for-preﬁx The function namespace-uri-for-prefix   returns the namespace URI corresponding to a given namespace preﬁx in the in-scope namespaces of a particular element node.  Changes in 2.0 This function is new in XPath 2.0. Together with in-scope-prefixes  , it provides a replacement for the namespace axis, which is deprecated in XPath 2.0.  839   The Function Library  Signature Argument Type preﬁx  Meaning  xs:string? The namespace preﬁx whose corresponding namespace URI is required,  or the zero-length string to get the default namespace URI. If the argument is an empty sequence, it is treated as a zero-length string.  element  element    The element node to be examined to ﬁnd an in-scope namespace declaration for this preﬁx.  Result  xs:anyURI? The namespace URI corresponding to the given preﬁx.  Effect The in-scope namespaces for an element are represented in the data model as namespace nodes, and the behavior of this function is therefore described in terms of a search of the namespace nodes.  This function searches the namespace nodes of the given element. If it ﬁnds a namespace node whose name matches the given preﬁx, then it returns the string value of this namespace node, as an xs:anyURI value. If it doesn’t ﬁnd one, then it returns the empty sequence.  Example The following example shows the in-scope namespace URIs for every element in a source document.  Source  Note that this includes a namespace undeclaration for the «soap» namespace, as permitted by XML Namespaces 1.1.    <soap:Envelope  xmlns:soap="http:  schemas.xmlsoap.org soap envelope " xmlns:xs="http:  www.w3.org 2001 XMLSchema">     <echoString xmlns="http:  example.com soapdemo"  xmlns:xsi="http:  www.w3.org 2001 XMLSchema-instance" xmlns:soap="">   Hello            Stylesheet     <element name="{name  }"        840  namespaces="{for $n in in-scope-prefixes .   return namespace-uri-for-prefix $n, . }" >   namespace-uri-from-QName  Output   Reformatted for legibility.  Note the absence of the SOAP namespace from the inner elements.  <element name="soap:Envelope"  <element name="soap:Body"  namespaces="http:  www.w3.org XML 1998 namespace  http:  schemas.xmlsoap.org soap envelope  http:  www.w3.org 2001 XMLSchema" >  namespaces="http:  www.w3.org XML 1998 namespace  http:  schemas.xmlsoap.org soap envelope  http:  www.w3.org 2001 XMLSchema" >  <element name="echoString"  namespaces="http:  www.w3.org XML 1998 namespace  http:  www.w3.org 2001 XMLSchema http:  www.w3.org 2001 XMLSchema-instance http:  example.com soapdemo" >  <element name="inputString"  namespaces="http:  www.w3.org XML 1998 namespace  http:  www.w3.org 2001 XMLSchema http:  www.w3.org 2001 XMLSchema-instance http:  example.com soapdemo" >  Usage This function is often used in conjunction with in-scope-prefixes  , which ﬁnds the preﬁxes of all the in-scope namespaces for an element as a sequence of strings.  Note that if the requirement is to resolve a lexical QName to obtain an xs:QName value, the resolve-QName   function provides an easier way of doing this.  13  T h e  F u n c t i o n  i  L b r a r y  See Also in-scope-prefixes   on page 808 resolve-QName   on page 804  Signature Argument value  Type  xs:QName?  namespace-uri-from-QName The function namespace-uri-from-QName   returns the namespace URI part of an xs:QName value.  Meaning The xs:QName value whose namespace URI part is required. If the supplied value is an empty sequence, an empty sequence is returned.  Result  xs:anyURI?  The namespace URI part of the xs:QName.  841   The Function Library  Effect Given an expanded QName  that is, an instance of type xs:QName , this function returns the namespace URI part of the value. If the xs:QName is in no namespace, it returns a zero-length URI.  Examples Expression  Result  namespace-uri-from-QName QName  ’http:  mhk.me.uk some.uri’,’invoice’    "http:  mhk.me.uk some.uri"  namespace-uri-from-QName  node-name @xml:space    "http:  www.w3.org XML 1998 namespace"  The second example assumes that the context node has an attribute called xml:space.  See Also QName   on page 858 local-name-from-QName   on page 826  nilled The nilled   function returns true if applied to an element that  a  speciﬁes «xsi:nil="true"», and  b  has been successfully validated against a schema.  Signature Argument input  Result  Type  node  ?  Meaning The node being tested  xs:boolean?  True for an element that has the nilled property  Effect If the input is an element node that has the attribute «xsi:nil="true"» and that has been subjected to schema validation, the function returns true.  If the input is an element node that does not have an «xsl:nil» attribute, or that has the value «xsi:nil="false"», or if it is an element node that has not been assessed against a schema, the function returns false.  The function returns the empty sequence if it is applied to a node other than an element, or if the argu- ment is an empty sequence.  Examples Assume the context node is the following element:        Samuel   842    W   Johnson      and that it is validated against the following schema:  <xs:schema xmlns:xs="http:  www.w3.org 2001 XMLSchema"  xmlns:xsi="http:  www.w3.org 2001 XMLSchema-instance">                                        Expression  nilled title   nilled first   nilled middle   nilled last   Usage The xsi:nil attribute is an explicit way of saying that a value is absent. Although its meaning is entirely up to the application, the intended purpose is to distinguish unknown data  a person’s title is unknown  from data known to be empty  a person is known to have no middle name . When an element that has xsi:nil set to true is validated, it is given the nilled property in the data model, and this function allows this property to be tested. For most practical purposes, using the nilled   function achieves the same as testing the xsi:nil attribute directly, so long as you are sure that the element has been validated.  The nilled property is present in the data model primarily to support the rules for type matching: a nilled element will not match a type of the form «element N, T », but it will match «element N, T? ». These rules are given in Chapter 11, in the section Matching Elements and Attributes on page 672. This function is provided to allow direct access to this property.  node-name The node-name   function returns a value of type xs:QName containing the expanded name of a node, that is, the namespace URI and local name.  node-name  Result  true  false  false  false  13  T h e  F u n c t i o n  i  L b r a r y  843   The Function Library  Signature Argument input  Type  node  ?  Meaning The node whose name is required  Result  xs:QName?  The name of the node if it has a name, or an empty sequence if it has no name  Effect If the node is an element or attribute, then the function returns an xs:QName whose components are the namespace URI, local name, and preﬁx of this node. If the node is not in a namespace, then the namespace URI component of the xs:QName will be absent  the function namespace-uri-from-QName   will return the empty sequence .  If the node is a processing instruction, the function returns an xs:QName whose local name is the name of the processing instruction, and whose namespace URI and preﬁx are absent.  If the node is a text node, comment, or document node, or if an empty sequence is supplied, then the function returns an empty sequence.  If the node is a namespace node, then the function returns an xs:QName whose local name represents the namespace preﬁx and whose namespace URI and preﬁx are absent; except when the namespace node represents the default namespace, in which case the function returns an empty sequence.  Examples It’s difﬁcult to illustrate function calls that return xs:QName values, because displaying an xs:QName as a string loses information about the namespace URI. In these examples I’ll display the value in so-called Clark notation  after James Clark, the editor of the XSLT 1.0 and XPath 1.0 speciﬁcations , which uses the format «{uri}local-name». Assume the following source document:  <soap:Envelope xmlns:soap="http:  schemas.xmlsoap.org soap envelope "  xmlns:xs="http:  www.w3.org 2001 XMLSchema">     <echoString xmlns="http:  example.com soapdemo"  xmlns:xsi="http:  www.w3.org 2001 XMLSchema-instance" xmlns:soap="">   Hello            Expression  node-name  *   node-name  * * *   node-name   @*:type   Result  in Clark notation  {http:  schemas.xmlsoap.org soap envelope }Envelope {http:  example.com soapdemo}echoString {http:  www.w3.org 2001 XMLSchema-instance}type  Usage To access the components of the xs:QName returned by the node-name   function, you can use the func- tions local-name-from-QName   and namespace-uri-from-QName  . Alternatively, if you don’t like  844   long function names, you can use the local-name   and namespace-uri   functions to get these two components directly from the node itself.  normalize-space  See Also local-name-from-QName   on page 826 namespace-uri-from-QName   on page 841 local-name   on page 824 name   on page 835 namespace-uri   on page 837  normalize-space The normalize-space   function removes leading and trailing whitespace from a string, and replaces internal sequences of whitespace with a single space character.  For example, the expression «normalize-space ’x&x9;y’ » returns the string «x y».  Changes in 2.0 None.  Signature Argument Type value  optional   Result  xs:string  Meaning  xs:string? The input string. If the argument is omitted, it defaults to string . . If an empty sequence is supplied, the function returns a zero-length string.  A string obtained by removing leading and trailing whitespace from the input string, and replacing internal sequences of whitespace by a single space character.  Effect When the function is called with no arguments, the argument defaults to the result of applying the string   function to the context item; an error is reported if there is no context item.  Whitespace is deﬁned, as in the XML speciﬁcation, as a sequence of space, tab, newline, and carriage return characters  x9, xA, xD, and x20 .  13  T h e  F u n c t i o n  i  L b r a r y  normalize-space " the quick &x9; brown fox "   "the quick brown fox"  Examples Expression  normalize-space " "   normalize-space "piano"   normalize-space      Result  ""  ""  "piano"  Usage It is often a good idea to apply the normalize-space   function to any string read from the source document before testing its contents, as many users will assume that leading and trailing whitespace has no signiﬁcance and that within the string, multiple spaces or tabs are equivalent to a single space.  845   The Function Library  Don’t imagine that the XSLT   declaration does this for you. The only thing it does is to remove text nodes that contain whitespace only.  Using normalize-space   shouldn’t be necessary when accessing structured information in a schema- validated document. The schema should specify for each type  in the xs:whiteSpace facet  how whitespace is to be treated, and this will normally ensure that redundant whitespace is removed automatically when nodes are atomized. Note that the action of the normalize-space   function is equivalent to the option   in XML Schema. This removes whitespace more vigorously than the schema type xs:normalizedString, which uses the option    this doesn’t replace runs of spaces with a single space, it only replaces individual newlines, carriage returns or tabs with single space characters.   However, if you access the string value of an element with a mixed content type  typically by calling the string   function explicitly, or by accessing the text nodes of an element explicitly , then schema-deﬁned whitespace normalization will not be applied, so using normalize-space   is a good idea.  The normalize-space   function can be particularly useful when processing a whitespace-separated list of values. Such lists are used in some document designs. With a schema processor, the system can deliver the value as a sequence of strings, but in the absence of a schema you have to tokenize the sequence yourself. You can call normalize-space   to ensure that there is a single space between each string, and it is then possible to use substring-before   to get the next token. To make this easier still, I usually add a space at the end of the string after normalization, so that every token is followed by a single space.  One situation where it isn’t safe to use normalize-space   is where you are processing mixed element content containing character-level formatting attributes. For example, if you process the nodes that result from the element:   Some  very  traditional HTML   then the spaces after «Some» and before «traditional» are signiﬁcant, even though they appear respec- tively at the end and the beginning of a text node.  XSLT Example The following key declaration indexes the titles of books with whitespace normalized:     This may then be used to locate books by title as follows:     The effect is that it will be possible, without knowing how many spaces and newlines there are, to retrieve a book appearing in the source document as:         Object Oriented Languages -  Basic Principles and Programming Techniques   See Also concat   on page 729 substring-after   on page 885 substring-before   on page 887  846   normalize-unicode  normalize-unicode The normalize-unicode   function returns a canonical representation of a string in which different ways of representing the same Unicode character have been reduced to a common representation. This makes it possible to compare two strings accurately.  Signature  Argument input  normalization-form  optional   Type xs:string? The string to be normalized. If an empty sequence is  Meaning  supplied, the function returns a zero-length string.  xs:string  The normalization algorithm to be used.  Result  xs:string  The result of normalizing the string.  Effect The function applies a Unicode normalization algorithm to the input string, and returns the normal- ized string as its result. If the normalization-form argument is omitted, the default is NFC. The only normalization form that all implementations must support is NFC. Other normalization forms can be requested  including but not limited to «NFC», «NFD», «NFKC», «NFKD», «FULLY-NORMALIZED»  using the normalization-form argument; a runtime error is reported if the requested normalization form is not supported by the implementation. For the meanings of these normalization forms, see the Usage section below.  Example: Unicode Normalization  This example shows the effect of normalizing the string «garc¸on» ﬁrst to NFC, then to NFD, and then back to NFC. Note that 231  xE7  is the Unicode codepoint for lower-case C with cedilla, while 807  x0327  is the codepoint for a combining cedilla.  13  T h e  F u n c t i o n  i  L b r a r y  Stylesheet                           Output   103 97 114 231 111 110   103 97 114 231 111 110   103 97 114 99 807 111 110   103 97 114 231 111 110   847   The Function Library  The value supplied for the normalization-form argument is converted to upper case, and leading and trailing spaces are removed.  Usage The subject of character normalization has a long, tortured history. There have always been two interest groups concerned with character encoding: those primarily interested in data processing have favored ﬁxed-length encodings of each character, with composite characters treated as a single unit, while those more concerned with publishing and printing have favored variable-length encodings in which the separate parts of a composite character  for example, a base letter and a diacritical mark  were encoded separately. Inevitably, the only way both communities could be satisﬁed was by a standard that allowed both, and that is exactly what Unicode does. The letter «˚A» for example  which is widely used in Swedish  can be encoded either using the single codepoint x00 C5  called LATIN CAPITAL A WITH RING ABOVE  or by the two codepoints x0041  LATIN CAPITAL LETTER A  followed by x030A  COMBINING RING ABOVE . To make matters even worse, there is also a separate code x212B  ANGSTROM SIGN , which is visually indistinguishable from the letter «˚A» but has a separate code because it is considered to have its own meaning.  This means that unless special precautions are taken, when you search for text containing the character «˚A», you will not ﬁnd it unless you choose the same representation as is used in the text you are searching. This applies not only to the textual content, but also to the markup: all three representations of this character are acceptable in XML names, and if you use one representation in the source XML, and a different representation in a path expression, then they won’t match.  Unicode normalization is an algorithm that can be applied to Unicode strings to remove these arbitrary differences.  The W3 C Working Draft Character Model for the World Wide Web 1.0: Normalization  http:  www.w3.org  TR charmod-norm  , speciﬁes that documents on the Web should be subject to ‘‘early normalization’’: that is, they should be normalized at the time they are created, and it advocates the use of a particular normalization algorithm called NFC  further details below . If everyone followed this advice, there would be no need for a normalize-unicode   function in XPath. But unfortunately, there is little chance of this happening.  The normalization algorithms have been published in Unicode Technical Report 15  http:  www.unicode.org unicode reports tr15 . There are several, notably normalization forms C, D, KC, and KD, and ‘‘fully normalized’’.  Why have one standard when you can have ﬁve?  The default used by the normalize-unicode   function is NFC  normalization form C , but the other forms can be requested using the second parameter to the function, provided that the implementation supports them — they aren’t mandatory.  Normalization forms C and KC replace decomposed characters by composed characters; in our example using «˚A», they choose the single-codepoint representation x00 C5 in preference to the two-codepoint representation x0041x030A. Normalization forms D and KD prefer the decomposed representation, that is x0041x030A.  As a general rule, most software that produces Unicode text  for example, text editors  will produce NFC output most of the time. This is useful, and explains why you don’t hear of many people having real-world XPath expressions that fail because of normalization issues. But it’s certainly a possibility, and one of the concerns is that it is also a security risk — using the ‘‘wrong’’ representation of characters could be a way of getting round validation software.  848   normalize-unicode  The K variants  NFKC and NFKD  differ from NFC and NFD in that they normalize further; speciﬁcally, they normalize away distinctions between ‘‘compatibility variants’’ of characters. These compatibility variants exist because Unicode was created as the union of many different preexisting character sets. The designers had to make the decision whether two characters in different character sets were really representations of the same character. The problem in merging two characters into one is that it would lose information when data is converted into Unicode and then back again — the original data stream could not necessarily be reconstituted. So Unicode adopted the approach of allowing multiple represen- tations of a character as compatibility variants. The distinction between the letter «˚A» and the ˚Angstrom symbol is an example of this phenomenon; normalization forms NFKC and NFKD eliminate the distinc- tion between these two characters. Another example is the distinction between the two characters «f» «i» and the single character «fi»  really just a graphical visualization of the two separate characters, but recognized as a single character for the beneﬁt of typesetting applications . Another one  and here the ‘‘loss of information’’ argument starts to become signiﬁcant  is the distinction between the superscript digits «2» and «3» and the ordinary digits «2» and «3».  When you take a substring of a normalized string, the substring will always be normalized, and this is true for all the normalization forms discussed here. Splitting a string between a letter «c» and a non-spacing cedilla that follows it may not produce a very meaningful result, but the result is normalized, in the sense that the normalization algorithm will not change it. However, concatenating two normalized strings is not guaranteed to produce a normalized string. This is true whether you choose a composed form  NFC  or a decomposed form  NFD :    With NFC, concatenating a string that ends with letter «c» and a string that starts with a  non-spacing cedilla produces a string that is not in normalized form NFC.    With NFD, concatenating a string that ends with a non-spacing modiﬁer and a string that  starts with a non-spacing modiﬁer may produce a string that is not in normalized form NFD, because this normalization form requires multiple non-spacing modiﬁers applying to the same letter to be in a standard order.  This means that the concat   function, and other XPath functions that concatenate strings such as string-join  , as well as node construction instructions in XSLT and XQuery, are not guaranteed to produce normalized output even if they are given normalized input. Another place where string con- catenation occurs implicitly is in forming the string value of an element with mixed content. The W3 C policy of early normalization means that this problem should be corrected as soon as possible. One way of doing this is to call the normalize-unicode   function on the results of the string concatenation; another is to do the normalization at the time the result of a transformation or query is serialized  see the normaliation-form option of  , described in Chapter 15 .  The term fully-normalized refers to an additional normalization format deﬁned by W3 C  see Character Model for the World Wide Web: Normalization, http:  www.w3.org TR charmod-norm  . A string is deﬁned to be fully normalized if it is in NFC and if it doesn’t start with a combining character. The signiﬁcance of this is that if you concatenate two fully normalized strings the result is guaranteed to be fully normalized as well. The speciﬁcation isn’t very explicit about how you get a string into fully-normalized form, but the idea is apparently that if it starts with a combining character, you add a space in front of it.  13  T h e  F u n c t i o n  i  L b r a r y  See Also Serialization, Chapter 15  849   The Function Library  not The not   function returns true if the effective boolean value of the argument is false, and vice versa.  For example, the expression «not 2+2=4 » returns false.  Changes in 2.0 This function has been generalized to accept a wider range of types.  Signature Argument value  Type  item  *  Meaning The input value  Result  xs:boolean  true if the effective boolean value of the argument is false, otherwise false  Effect In effect, the argument is converted to a boolean using the rules of the boolean   function, and the return value is then true if this is false, false if it is true.  The rules for determining the effective boolean value are described under the boolean   function on page 721. If the value is one that does not have an effective boolean value  for example, a sequence of three integers , then an error is reported.  Examples Expression  not *   not normalize-space @a    not author="Kay"   Result true if the context node has no child elements  true if attribute @a is absent, is zero-length, or consists entirely of whitespace  true if the context node does not have an author child element whose typed value is "Kay"  Usage Note that writing «not $A=2 » is not the same thing as writing «$A!=2». The difference arises when $A is a sequence: «not $A=2 » will be true if $A does not contain an item that is equal to 2, while «$A!=2» is true only if A does contain an item that is not equal to 2. For example, if $A is an empty sequence, «not $A=2 » will be true, while «$A!=2» will be false.  It is easy to forget this when testing attribute values; for example, the following two examples behave the same way if the attribute go is present  they output «go» if the value is anything other than «no» , but they behave differently if the attribute is absent  the second one outputs «go», but the ﬁrst one outputs nothing .  1: if  @go!=’no’  then "go" else "" 2: if  not @go=’no’   then "go" else ""  When used with sequences, the comparison operators such as «=» and «!=» are subject to an implicit if there exists qualiﬁer: «$X=$Y» is true if there exists an item x in $X and an item y in $Y such that x eq y. If you  850   want to achieve an if all qualiﬁer, for example, if all nodes in $N have a size attribute equal to 0, then you can achieve this by negating both the condition and the expression as a whole: «not $N @size!=0 ». But in XPath 2.0, it is probably clearer to write this out explicitly:  number  if  every $s in $N @size satisfies $s eq 0  . . .  XSLT Examples The following test succeeds if the context node has no children:     The following test succeeds if the context node has no parent  that is, if it is a root node :     The following   statement processes all the child elements of the context node except the   elements:     The following test succeeds if the string-value of the context node is zero-length  assuming that the context item is a node :     The following test succeeds if the name attribute of the context node is absent or is a zero-length string:     The following test succeeds if the name attribute of the ﬁrst node in node-set $ns is different from the name attribute of each subsequent node in the node-set  we assume that this attribute is present on all nodes in the node-set :     13  T h e  F u n c t i o n  i  L b r a r y  See Also boolean   on page 721 false   on page 779 true   on page 899  number The number   function converts its argument to a value of type xs:double.  For example, the expression «number ’ -17.3’ » returns the xs:double value –17.3e0.  Changes in 2.0 A leading «+» sign is allowed in the number, and exponential notation is permitted, to align the rules with XML Schema.  851   The Function Library  Signature Argument value  optional   Type  item  ?  Meaning The value to be converted. If the argument is omitted, the context item is used. If an empty sequence is supplied, the result is NaN.  Result  xs:double  A double-precision ﬂoating-point number: the result of converting the given value. If the argument cannot be converted to a number, the function returns NaN  not-a-number .  Effect The conversion rules used are the same as the rules for casting to an xs:double  and therefore, the same as the xs:double   constructor function , with the exception that if the value is not convertible to a number, the result is NaN  not-a-number  rather than an error.  If the value supplied is a node, then the node is ﬁrst atomized in the usual way.  The only atomic types that can be converted to a number are booleans, strings, and other numbers. The conversion is as follows: Supplied type  Conversion rules false becomes zero; true becomes one.  The rules are the same as the rules for writing an xs:double value in XML Schema.  xs:integer, xs:decimal, xs:float  The result is the same as converting the value to a string, and then converting the resulting string back to an xs:double.  Result xs:double 12.3e0, displayed as "12.3"  xs:double 12.3e0, displayed as "12.3"  xs:double 1.0e0, displayed as "1"  xs:double NaN  xs:double NaN  Usage In XPath 1.0, conversion to a number was generally implicit so it was rarely necessary to use the number   function explicitly. This remains the case if XPath 1.0 backward-compatibility mode is used. When this mode is not enabled, however, type errors will be reported when strings or booleans are supplied in contexts where a number is expected; for example, as operands to numeric operators such as «+». You still get implicit conversion when you supply an untyped node as the operand  for example, «@code+1» is okay , but not when the value is explicitly typed. For example, if the date-of-birth attribute is an untyped string in the format of an ISO 8601 date, the following is an error under XPath 2.0 rules:  substring @date-of-birth, 1, 4  < 1970  852  xs:boolean  xs:string  Examples Expression  number 12.3   number "12.3"   number true     number "xyz"   number ""    one-or-more  This is because substring   returns a string, and you cannot compare a string to a number. Instead, write:  number substring @date-of-birth, 1, 4   < 1970  There is one important situation where conversion needs to be explicit: this is in a predicate. The mean- ing of a predicate depends on the type of the value, in particular, a numeric predicate is interpreted as a comparison with the context position. If the value is not numeric, it is converted to a boolean.  So for example, if a value held in an attribute or in a temporary tree is to be used as a numeric predicate, you should convert it explicitly to a number, thus:  $sales-figures[number @month ]  To test whether a value  for example, in an attribute  is numeric, use number   to convert it to a number and test the result against NaN  not-a-number . The most direct way to do this is:  if  string number @value  =’NaN’  then ...  Alternatively, use the «castable as» operator described in on page 655 in Chapter 11.  See Also boolean   on page 721 string   on page 877 cast expression in Chapter 11 on page 655  13  T h e  F u n c t i o n  i  L b r a r y  one-or-more The one-or-more   function returns its argument unchanged, provided that it is a sequence containing one or more items. If the input is an empty sequence, it reports an error.  Signature Argument value  Type  item  *  Result  item    Meaning The input value. Although the function signature says that any sequence of items is allowed, a runtime error will occur if the number of items is zero.  The same as the supplied value, after checking to ensure that it is not an empty sequence.  Effect The one-or-more   function returns its argument unchanged, provided that it is a sequence containing at least one item. If an empty sequence is supplied, it reports an error.  This function is useful with XPath processors that perform static type checking, as described in Chapter 5. Calling this function acts as a promise by the programmer that the argument will be a sequence containing at least one item. This allows the expression to be used in contexts that require a single value  for example, a call to a function that has a parameter with the required type «item  +»  when the pro- cessor might otherwise have reported a static type error. The XPath expression is still type-safe, because the check that the sequence does indeed contain at least one item will be done at runtime, just as it would with a processor that does not enforce static type checking.  853   The Function Library  Examples Expression  one-or-more 1   one-or-more  1,2,3    one-or-more      Result  1  1,2,3  Error  Usage As it happens, functions in the core library do not generally have a required type such as «item  +», even in cases like min  , max   and avg   where there is no meaningful result that can be returned for an empty sequence. This is because the designers decided that rather than reporting an error for these functions when the argument is an empty sequence, it made more sense to return an empty sequence as the result. However, if you do want to make a runtime check that a sequence is not empty before calling a function such as avg  , then calling one-or-more   is a simple way to do the check.  See Also exactly-one   on page 777 zero-or-one   on page 912 «treat as» expression on page 678 in Chapter 11  position The position   function returns the value of the context position. When processing a list of items, position   gives the number assigned to the current item in the list, with the ﬁrst item being numbered as 1.  Changes in 2.0 None.  Signature This function takes no arguments.  Type  Result  xs:integer  Meaning A number, the value of the context position. As the name implies, this is context-dependent.  Effect The XPath speciﬁcation deﬁnes the value of the position   function in terms of the context position.  The context position is part of the focus, which is described in the spec as having three components: the context item, the context position, and the context size. However, it may be easier to think of the focus as being a bit like an Iterator object in a language such as Java. Behind the iterator is a list of items that are processed individually  though not necessarily in any particular order . The context item, position, and size can be thought of as three methods provided by this iterator object: the context position is a number  854   position  that ranges from 1 to the size of the list, the context item is the item found at the context position, and the context size is the number of items in the list.  When a top-level XPath expression is evaluated  that is, an XPath expression that is not part of another expression , the context position is set by the host language. In XSLT, it is set from the XSLT context. For example:    When a global   declaration is being evaluated, or in certain other contexts such  as evaluating the use expression in  , or evaluating the initial template that matches the root node, it is normally set to 1  one .    When   or   is called to process a sequence of nodes, the nodes are numbered 1 to N in their sorted order, and while each node is being processed the context position is the number assigned to that node.  There is no implication that node 1 is processed before node 2, incidentally.   This means that within an   iteration, the test   succeeds when the last item in the sequence is being processed.  Many APIs that enable XPath expressions to be executed from languages like Java or JavaScript allow the caller to set the context item, but not the context position or size. In such cases, the context position and size on entry to the XPath expression will both be one.  Within an XPath expression, the context size changes within a predicate and on the right-hand side of the « » operator.        In a predicate, position   refers to the position of the item that is being ﬁltered using the predi- cate within the sequence of items being ﬁltered. For example, «$seq[position  !=1]» selects all items except the ﬁrst in a sequence, because the ﬁrst item is the only one for which the predicate is false. It’s less common to ﬁnd position   being used on the right-hand-side of a « » operator. It refers to the position of the context item in the sequence selected by the left-hand operand of the « ». So «$x position  » is another way of writing «1 to count $x ». A more interesting example is:  13  T h e  F u n c t i o n  i  L b r a r y  <xsl:value-of select="$sequence  if  position   mod 10 = 0   then concat ., ’&xa;’   else string .  " >  which outputs the items in $sequence with a newline after every 10 items.  Remember that the focus is not changed within a «for» expression. If you need to know within the body of a «for» expression what the position of the item being processed is, you need to rewrite it. Instead of doing:  for $s in $sequence return EXPR  write:  for $i in 1 to count $sequence ,  $s in $sequence[$i]  return EXPR  You can then use $i within EXPR to refer to the position of $s within the sequence.  855   The Function Library  Usage in XSLT The position   function is often used as a complete XPath expression within an XSLT stylesheet. The function has particular signiﬁcance in XSLT because it gives the position of the item currently being pro- cessed by an   instruction  as well as other instructions such as   and   . The two main uses of the position   function in XSLT are to display the current position, and to test the current position.  Displaying the Current Position In this role the position   function can be used for simple numbering of paragraphs, sections, or ﬁgures.  In XSLT this provides an alternative to the use of  . There is much less ﬂexibility to control how the numbering is done than when using  , but the position   function has two important advantages:        It is generally faster. It numbers items in the order they are output, whereas   can only allocate a number based on the position of a node in the source document. This means   is of little use when a list has been sorted using  .  If you use position  , you can still exploit the formatting capabilities of   by writing, for example:     This determines the position of the node and formats the result according to the given format pattern; the resulting sequence will be « a », « b », « c », and so on.  Testing the Current Position It is possible to test the position of the current item either in a boolean expression in an   or   element, or in a predicate within a ﬁlter expression or pattern.  A common requirement is to treat the ﬁrst or last item in a list differently from the rest. For example, to insert a horizontal rule after every item except the last, the following logic might be used:         :                  Within a predicate in an expression or pattern, a numeric value represents an implicit test against the result of position  : for example, «item[1]» is equivalent to «item[position  =1]», and «item[last  ]» is equivalent to «item[position  =last  ]».  You can only use this shorthand in a predicate; that is, within square brackets. If you use a numeric value in other contexts where a Boolean is expected, the number is converted to a boolean on the basis that 0 is false; everything else is true. So   does not mean  ; it means the same as  .  856   preﬁx-from-QName  See Also last   on page 820   in Chapter 6 page 403  preﬁx-from-QName The prefix-from-QName   function extracts the preﬁx from an expanded QName. For example, «prefix-from-QName node-name @xml:space  » returns the string «xml».  Signature Argument value  Result  Type  xs:QName?  xs:NCName  Meaning The supplied QName  The preﬁx of the QName if there is one, or the empty sequence otherwise  Effect If the ﬁrst argument is an empty sequence, the function returns an empty sequence.  If the supplied QName includes a preﬁx, the preﬁx is returned as an instance of xs:NCName. This is derived from xs:string, so the value can be used anywhere that a string can be used. If the QName is unpreﬁxed, the function returns an empty sequence.  Usage In the XML Schema speciﬁcations, it is stated that the value space for the type xs:QName contains two parts: the local name and the namespace URI. The XPath data model  XDM , however, modiﬁes this to say that it also retains a third part, the namespace preﬁx. The main reason for this difference is to ensure that every value in XDM can be converted to a string; without this rule, a great number of special exceptions were needed to cater for the fact that not all values could be serialized successfully. Retaining the preﬁx also gives usability beneﬁts, because although in theory the choice of namespace preﬁxes is arbitrary, in practice choosing familiar preﬁxes greatly aids human readability of XML documents. There is also software around that attaches more signiﬁcance to namespace preﬁxes than it probably should — which is excusable, since the base XML speciﬁcation itself describes DTD-based validation in a way that treats namespace preﬁxes, rather than the associated URIs, as signiﬁcant.  13  T h e  F u n c t i o n  i  L b r a r y  QNames arise most often as the names of elements and attributes. If XDM documents are constructed in the normal way by parsing source XML  with or without schema validation , then the original preﬁxes from the source document will be retained in the tree, and will be accessible by calling «prefix-from-QName node-name $node  ». If there was no preﬁx, this returns an empty sequence. When nodes are constructed using instructions such as   and  , then the namespace preﬁxes are usually predictable from the rules for those instructions, and can be accessed in the same way. In unusual cases, however, where the same preﬁx is used for more than one purpose, the system may need to invent a different preﬁx from the one requested  this process is called namespace ﬁxup .  A QName can also arise as the typed value of a node  an example is the attribute «xsi:type= "xs:integer"», where both the name and the value of the attribute are QNames . In this case, assuming a schema-aware processor, the expression «prefix-from-QName @xsi:type » will return the string «xs».  Although this function makes the preﬁx of a QName available to applications, it should be used with care. It is good practice to allow document originators to choose arbitrary preﬁxes, and applications should attach signiﬁcance only to the namespace URI, not to the preﬁx.  857   The Function Library  Examples Consider this source document, validated using a schema-aware processor:    <my:doc xmlns:my="http:  mhk.me.uk some.uri" security="high"  xmlns:xsi="http:  www.w3.org 2001 XMLSchema-instance" xsi:type="my:dateType">2008-01-01   Expression  prefix-from-QName node-name my:doc    prefix-from-QName node-name my:doc @xsi:type    prefix-from-QName node-name my:doc @security    prefix-from-QName my:doc @xsi:type   prefix-from-QName node-name my:doc @missing    See Also local-name-from-QName   on page 826 namespace-uri-from-QName   on page 841  Result  "my"  "xsi"          "my"  QName The QName   function returns a value of type xs:QName, given a namespace URI and the lexical form of the name. For example, «QName "http:  www.w3.org 1999 xhtml", "html" » returns the name «html» in the XHTML namespace.  Signature Argument namespace  Type  xs:string?  lexical-qname  xs:string  Meaning The namespace URI part of the xs:QName. To construct a QName that is in no namespace, supply either a zero-length string or an empty sequence.  The lexical form of the QName, with or without a preﬁx. It must conform to the syntax of a QName as deﬁned in the XML Namespaces speciﬁcation  which is the same as the lexical space for an xs:QName deﬁned in XML Schema .  Result  xs:QName  The newly constructed xs:QName.  Effect A value of type xs:QName has two signiﬁcant parts  a namespace URI, and a local name , and it also retains information about the namespace preﬁx. This function constructs an xs:QName value from these components.  XPath uses the term lexical QName to refer to a QName in the form local-name or prefix:local-name, and expanded QName to refer to the underlying value of the QName, in which the preﬁx has been resolved to a namespace URI by reference to some set of namespace declarations. This function creates an  858   expanded QName directly, without going through the stage of resolving the preﬁx. The namespace URI of the QName is taken from the namespace argument. The local-name part is taken from the lexical- name after stripping off any preﬁx; and the preﬁx part is taken from the preﬁx in the lexical-name if there is one.  It’s an error to supply a preﬁx without also supplying a namespace URI.  QName  Examples Expression  QName "http:  www.w3.org XML 1998 namespace", "xml:space"   QName "http:  www.w3.org 2001 XMLSchema-instance", "xsi:type"   QName "", "html"   QName "http:  www.w3.org 1999 xhtml", "html"   Result The xs:QName usually written as «xml:space»  The xs:QName usually written as «xsi:type»  An xs:QName with local name «html» in no namespace  An xs:QName with local name «html» in the XHTML namespace, with no preﬁx  Usage The QName   function is useful when you want to compare node names against a speciﬁed name, especially one determined at runtime. This is done by using it in conjunction with the node-name   function.  For example, suppose that you are dealing with source documents for which several variants of the schema exist, all using different namespace URIs, and suppose that the actual namespace URI to be used in a particular run is passed in as a parameter. This makes it difﬁcult to use path expressions in the natural way, because path expressions can only refer to names that are fully known  that is, both the namespace URI and local name are known  at compile time.  13  T h e  F u n c t i o n  i  L b r a r y  You can deﬁne a set of global variables like this:       and so on.  It is then possible to use path expressions such as:  select="*[node-name  =$address] *[node-name  =$postalcode]"  to locate nodes.  See Also local-name-from-QName   on page 826 namespace-uri-from-QName   on page 841 node-name   on page 843  859   The Function Library  regex-group This function is available in XSLT only.  The regex-group   function returns a captured substring resulting from matching a regular expression using the   instruction.  Signature Argument group  Type  xs:integer  Meaning Identiﬁes the captured subgroup that is required. The nth captured subgroup provides the string that was matched by the part of the regular expression enclosed by the nth left parenthesis.  Result  xs:string  The string that was matched by the nth subexpression of the regular expression.  Effect When the   instruction is used to match a string against a regular expression  regex , its   child element is invoked once for each substring of the input string that matches the regular expression. The substring that matched the regex can be referred to within this element as «.», because it becomes the context item, and for consistency with other regex languages it is also available as the value of «regex-group 0 ». Sometimes, however, you need to know not only what the substring that matched the regex was, but which parts of that substring matched particular parts of the regex. The group of characters that matches a particular parenthesized subexpression within the regex is referred to as a captured group; and the captured group that matches the nth parenthesized subexpression is accessible as the value of «regex-group n ».  The substrings matched by   are available during the execution of the sequence constructor within the   element, including any templates called from instructions within this sequence constructor, that is, the scope is dynamic rather than static.  Note that it is only the   instruction that makes captured groups available. They are not made available by the regex functions matches  , replace  , and tokenize  .  Usage and Examples The regex-group   function is always used together with the   instruction, described in Chapter 6, page 230.  For example, suppose you are analyzing a comma-separated-values ﬁle containing lines like this.  423,"Barbara Smith","General Motors",1996-03-12  Given this line as the content of variable $in, you might analyze it using the code:                   860   remove        The regex here has two alternatives. The ﬁrst alternative, « " [^"]*? " », matches a string enclosed in quotes. The second alternative, « [^,]+? ,», matches a sequence of non-comma characters followed by a comma. If a string within quotes is matched, then the characters between the quotes are matched by the «[^"]*?» part of the regex. This appears after the second « » in the regex, so the string that it matches is available as «regex-group 2 ». If a nonquoted string is matched, it is matched by the «[^,]+?» part, which appears after the third « » in the regex, and is therefore available as «regex-group 3 ». Rather than work out whether group 2 or group 3 was matched, the XSLT code simply outputs both: the one that was not matched will be a zero-length string, so it is simpler to copy it to the output than to write the conditional code to ﬁnd out whether it was actually matched.  A full stylesheet containing this example is shown under the unparsed-text   function  page 907 .  See Also   on page 230 in Chapter 6  remove The remove   function returns a sequence that contains all the items in an input sequence except the one at a speciﬁed position.  Signature Argument sequence  position  Result  Type  item  *  item  *  Meaning The input sequence  xs:integer  The position of the item to be removed  A sequence containing all the items in the input sequence except the item at the speciﬁed position  13  T h e  F u n c t i o n  i  L b r a r y  Effect The effect is the same as the expression:  $sequence[position   ne $position]  This means that if the position parameter is less than one or greater than the number of items in the input sequence, the input sequence is returned unchanged.  Examples Expression  remove  1 to 5 , 4   remove  1 to 5 , 10   remove   , 1   Result  1, 2, 3, 5  1, 2, 3, 4, 5      861   The Function Library  Usage A common requirement, especially in recursive functions, is to get the tail of a sequence, that is, all items except the ﬁrst. There are several ways of doing this in XPath 2.0, all equivalent. Take your pick:           $sequence[position   ne 1]  subsequence $sequence, 2   remove $sequence, 1   See Also insert-before   on page 810 subsequence   on page 882  There’s no intrinsic reason why any of these should perform better or worse than the others — it all depends on the implementation. In Saxon, all three generate the same runtime code.  replace The replace   function constructs an output string from an input string by replacing all occurrences of substrings that match a supplied regular expression with a given replacement string. The replacement string may include references to captured groups within the input string.  Signature Argument input  Type xs:string? The input string. If an empty sequence is supplied, an empty  Meaning  sequence is returned.  regex  xs:string  The regular expression, written according to the rules given in Chapter 14.  replacement  xs:string  The replacement string.  ﬂags  optional   xs:string  One or more letters indicating options on how the matching is to be performed. If this argument is omitted, the effect is the same as supplying a zero-length string, which defaults all the option settings.  Result  xs:string? The string produced by replacing substrings of the input string that  match the regular expression.  Effect The rules for the syntax of regular expressions and for the ﬂags argument are given in Chapter 14.  The input string is processed from left to right, looking for substrings that match the regular expression supplied in the regex argument. Characters that don’t participate in a match are copied unchanged to the output string. When a substring is found that does match the regex, the substring is not copied to the output, but the replacement string is copied instead. The search then resumes at the character position following the matched substring. For example, the result of «replace "banana", "a", "A" » is «bAnAnA».  It can happen that two substrings starting at the same position both match the regex. There are two ways this situation can arise.  862   replace  Firstly, it happens when part of the regex is looking for repeated occurrences of a substring. For example, if the regex is « an *a» then immediately after the «b» of «banana», there are three possible matches, the matched substrings being «a», «ana», and «anana». The rule here is that «*» is a greedy quantiﬁer: it matches as long a substring as it can. So the result of the expression «replace "banana", " an *a", "" » is «b». If you want to match the shortest possible substring, add a «?» after the quantiﬁer to make it non-greedy: «replace "banana", " an +?a", "" » is «bna». Note that the ﬁnal three characters of «banana» don’t result in a replacement, because two matches never overlap: the middle «a» cannot participate in two different matching substrings.  Another situation that can cause two different substrings to match at the same position is where the regex contains two alternatives that both match. For example, the regex «aana» could match the sec- ond character of «banana», or it could match characters 2 to 4. The rule here is that the ﬁrst  leftmost  alternative wins. So the result of «replace "banana", "aana", "" » is «bnn», whereas the result of «replace "banana", "anaa", "" » is «bn».  The replacement string supplied in the replace argument can contain the variables «$1», «$2», ... to refer to parts of the input string that were matched by parts of the regular expression. If you want to include a «$» sign in the replacement string, you must write it as «\$», and if you want to include a «\» character, you must write it as «\\».  These rules might seem bizarre. But it was done this way for compatibility with other languages, and to allow other features to be added in the future.   The variable $N refers to the substring of the input that was matched by the Nth parenthesized subexpression of the regex. You can ﬁnd out which the Nth subexpression is by simply counting « » char- acters from the ﬁrst character of the regex. For example, in the regex « [0-9]+  [A-Z]+   [0-9]+ », $1 refers to the digits at the start of the string, $2 to the group of letters in the middle, and $3 to the digits at the end. So if you want to insert a hyphen between the groups of letters and digits, you can write:  replace $input, "^ [0-9]+  [A-Z]+  [0-9]+ $", "$1-$2-$3"   If you run this with the input string «23MAR2008», the result will be «23-MAR-2008».  Note the use of an anchored regex here to match and replace the entire string.   If the «$» sign is followed by more than one digit, for example « $823 », the system will try to locate the 823rd matching subexpression. If the regex doesn’t contain that many subexpressions, it will assume that the «3» is an ordinary character and will look for the 82nd subexpression. If that still fails, it will look for the 8th subexpression. If that fails yet again, it will replace the «$8» by a zero-length string, so the ﬁnal output will be « 23 ».  A «$0» in the replacement string refers to the entire matched string.  If the replacement string contains a variable that hasn’t been matched, perhaps because the relevant parenthesized subexpression was in a branch that wasn’t used, then a zero-length string is substituted for the variable. If the subexpression was matched more than once, then it’s the last one that is used.  If the regex does not match the input string, the replace   function will return the input string unchanged. If this is not the effect you are looking for, use the matches   function ﬁrst to see if there is a match.  If the regex is one that matches a zero-length string, that is, if «matches "", $regex » is true, the system reports an error. An example of such a regex is «a*». Although various interpretations of such a con- struct are possible, the Working Group decided that the results were too confusing and decided not to allow it.  863  13  T h e  F u n c t i o n  i  L b r a r y   The Function Library  Examples Expression  replace "banana", "a", "o"   replace "banana", " anana ", "[$1]"   replace "banana", " an +", "**"   replace "banana", " an +?", "**"   Result  "bonono"  "b[ana][na]"  "b**a"  "b****a"  replace "facetiously", "[aeiouy]", "[$0]"   "f[a]c[e]t[i][o][u]sl[y]"  Usage The replace   function provides a much-needed string replacement capability for XPath. In XPath 1.0 it was possible to do simple one-for-one character replacement using the translate   function, but anything more complex required the use of cumbersome recursive templates in XSLT.  One limitation of the replace   function, however, is that the result is always a string: this function cannot be used directly for so-called up-conversion applications where the aim is to generate markup within the string  a typical example of such a conversion is the requirement to replace newlines in a string by empty   elements . For such applications, the XSLT   instruction is more powerful.  See Also   in Chapter 6, page 230 matches   on page 828 tokenize   on page 894 translate   on page 897 Regular Expressions, Chapter 14  resolve-QName The resolve-QName   function returns a value of type xs:QName  that is, an expanded QName con- sisting of a namespace URI and a local name , taking as input a lexical QName  a string in the form «prefix:local-name» or simply «local-name» , by resolving the preﬁx used in the lexical QName against the in-scope namespaces of a given element node.  Signature Argument lexical-qname  Type  xs:string?  Meaning The lexical QName whose preﬁx is to be resolved. It must conform to the syntax of a QName as deﬁned in the XML Namespaces speciﬁcation  which is the same as the lexical space for an xs:QName deﬁned in XML Schema .  element  element    An element node whose in-scope namespaces are to be used to resolve the namespace preﬁx used in the lexical QName.  Result  xs:QName?  The expanded xs:QName, containing the namespace URI corresponding to the preﬁx supplied in the lexical QName.  864   resolve-QName  Effect If the ﬁrst argument is an empty sequence, the function returns an empty sequence.  The local-name part of the resulting xs:QName value will always be the same as the local-name part of the supplied lexical QName: that is, the part after the colon, if there is a colon, or the whole string otherwise. The constructed xs:QName will also retain any preﬁx that was present in the supplied lexical QName.  If the lexical QName has no preﬁx, then the default namespace for the given element will be used. More precisely, the system looks for an unnamed namespace node of the given element. If it ﬁnds one, then the namespace URI component of the result is taken from the string value of this namespace node. If there is no unnamed namespace node, then the namespace URI component of the resulting xs:QName value will be null.  If the lexical QName does have a preﬁx, then the system looks for a namespace node of the given element whose name matches this preﬁx. If it ﬁnds one, then the namespace URI component of the result is taken from the string value of this namespace node. If there is no matching namespace node, then the function reports an error.     Examples Consider the source document:   title      one:value   value         And suppose that the following variables are bound:  <xsl:variable name="doc" select=" top:doc"  xmlns:top=" http:  mhk.me.uk default.uri" >         Expression  resolve-QName $doc *[1], $doc   resolve-QName $chap @att-one, $chap   resolve-QName string $data1 , $data1   resolve-QName string $data2 , $data2   Result  in Clark notation  {http:  mhk.me.uk default.uri}title {}text {http:  mhk.me.uk one.uri} value {} value  In these examples I have shown the resulting URI in Clark notation, named after James Clark, the lead designer of XSLT 1.0 and XPath 1.0. This notation represents an expanded QName in the form «{namespace-uri}local-name». Note that all these examples resolve a lexical QName found in the content of the document against the element node that contains the value. This is the normal and probably the only sensible way to use this function, since the preﬁx of a QName only has meaning in the context of the element where it is used.  13  T h e  F u n c t i o n  i  L b r a r y  865   The Function Library  Usage The purpose of this function, as the examples show, is to resolve QName values found in the content of elements or attributes within a document.  It’s never necessary to use this function to resolve QNames used as element and attribute names, because the system does that for you.  It’s also unnecessary to use this function if you have a schema-aware processor, and a schema that declares the relevant elements and attributes as having type xs:QName. In this case the schema processor will do the work for you, and you can access the expanded QName as the typed value of the element or attribute, using the data   function.  The function is needed when you have lexical QNames in the document content and they aren’t declared as such in the schema. This can happen for a number of reasons:              You are using a processor that isn’t schema-aware, or a source document for which no schema has been written. The lexical QName doesn’t make up the whole of the element or attribute value, for example, it might be buried inside an XPath expression. The value of the attribute isn’t always a QName  an example is the default attribute of the   element in XML Schema itself, whose type depends on the type of the element being deﬁned . You don’t want to use the rules that XML Schema uses for handling the default namespace  an example is the name attribute of the   element in XSLT, where an unpreﬁxed name uses the null namespace rather than the default namespace .  Let’s look at this last example more closely. If your source documents are XSLT stylesheets  it is actually quite common to process stylesheets using XSLT , then there are many lexical QNames used within the content of the document  for example, in the name attribute of templates, keys, and functions, the mode attribute of  , and myriad other places . These aren’t declared as xs:QName values in the schema for XSLT, however. The reason is subtle: although an XML Schema would do the correct validation if these attributes had type xs:QName, it would not do the conversion from the lexical space to the value space correctly. This is because XSLT speciﬁes that when there is no preﬁx, these names are in the null namespace, regardless of any default namespace declaration, while XML Schema when it processes xs:QName values decides that the absence of a preﬁx implies use of the default namespace  I don’t think this rule is in the spec, but it seems to be the way that XML Schema processors are expected to behave .  This means that you can only use this function for names found in XSLT stylesheets if you handle the unpreﬁxed case yourself. Fortunately, this is easy enough:  if  contains @name, ’:’   then resolve-QName @name, .  else QName "", @name   Rather surprisingly, it’s also possible to come across QNames that aren’t declared as such when you run XPath expressions against an XML Schema document. This is because values of any type can appear in places such as the xs:enumeration facet of a simple type, or the default attribute of an element or attribute declaration. Because these constructs might contain values of any type, their declared type in the schema for schemas is simply xs:string. The only way you can work out that one of these strings needs to be treated as a QName is by rather complex analysis of the schema.  866   resolve-uri  See Also QName   on page 858 in-scope-prefixes   on page 808  resolve-uri The resolve-uri   function converts a URI reference into an absolute URI by resolving it against a speciﬁed base URI.  Signature Argument reference  base-uri  optional   Type  xs:string?  xs:string  Meaning The URI reference to be resolved. If this argument is an empty sequence, an empty sequence is returned.  The base URI against which the relative reference is to be resolved. If this argument is omitted, the base URI from the static context is used. This must be an absolute URI.  Result  xs:string  The resulting absolute URI.  13  T h e  F u n c t i o n  i  L b r a r y  Effect It’s worth starting by establishing the correct terminology. A URI Reference is either a URI or a relative reference. A URI is an absolute URI optionally followed by «fragment». An absolute URI starts with a scheme-name and a colon  for example «http:» .  A relative reference is often referred to as a relative URI. Technically, this is incorrect: if it’s not abso- lute, then it’s not a URI. But it’s common usage, and you’ll ﬁnd it elsewhere in this book.  The arguments are deﬁned as xs:string rather than xs:anyURI because this allows the supplied argu- ment to be either an xs:string or an xs:anyURI, under the XPath function calling rules.  If the value supplied as reference is a URI  as distinct from a relative reference  then no resolution is needed, and the value is returned unchanged. Otherwise, it must be a relative reference, and it will be resolved against the absolute URI supplied in the second argument, or against the base URI from the static context if the second argument is omitted.  The process of URI resolution takes a relative reference such as «details.html» and resolves it against an absolute URI such as «http:  example.com index.html» to produce an absolute URI such as «http:  example.com details.html». Note that this process is done purely by analyzing the two char- acter strings, it doesn’t require any access to the network to ﬁnd out whether these ﬁles actually exist. This means that it is quite legitimate to apply the operation to things like collation URIs that don’t necessarily represent real resources on the Web.  The actual algorithm for URI resolution is described in section 5 of Internet RFC 3986  http:  www.ietf .org rfc rfc3986.txt . In essence, the relative reference is appended after the last « » in the path component of the base URI, and some tidying up is then done to remove redundant « . » and « .. » components.The resolve-uri   speciﬁcation leaves some latitude for implementations in deciding how to handle edge cases. It says that the implementation must use ‘‘an algorithm such as the ones described in RFC 2396 or RFC 3986’’. There are several reasons for this apparent vagueness. Firstly, the working group wanted to allow implementors to take advantage of existing library code. Secondly, the RFCs  867   The Function Library  themselves leave some corner cases open; in particular, they aren’t very prescriptive about what happens when the input strings are not strictly valid according to the RFC rules. RFC 3986, for example, says that the base URI must be an absolute URI  which means it mustn’t contain a fragment identiﬁer , but it hints that you can turn it into an absolute URI by stripping off the fragment identiﬁer before you start. Another example: there’s a popular URI scheme used in the Java world for addressing ﬁles within a JAR archive. These URIs attach special meaning to «!» as a separator, and as such they don’t follow the syntax in the RFCs. It’s convenient for users if these almost-URIs can be resolved in the same way as true URIs, and the spec deliberately leaves enough wriggle-room to permit this.  If the second argument of resolve-uri   is omitted, the effect is the same as using the function call «resolve-uri $relative, static-base-uri   »: this means that the base URI is taken from the static context of the XPath expression. The way this is set up is  as the name implies  very context-dependent.        In the case of XPath expressions within an XSLT stylesheet the base URI is reasonably well- deﬁned: the base URI of the stylesheet module is used, unless the stylesheet contains xml:base attributes, or is split into multiple XML external entities. But the base URI of the stylesheet mod- ule may be unknown; this might happen if the XSLT code was read from a string constructed in memory rather than from a ﬁle. In the case of XPath expressions constructed programmatically, for example, by a Java or JavaScript application, all bets are off. Your XPath API may provide a way of setting the base URI, but it’s more likely in my experience that it won’t. In this situation relative URI references are rather meaningless, and it’s best to avoid them.  Examples Most of these examples are taken from Appendix C of RFC 2396, and assume a static base URI of «http:  a b c d;p?q». The RFC includes other more complex examples that are worth consulting.  Expression  resolve-uri "g"   resolve-uri ". g"   resolve-uri "g "   resolve-uri " g"   resolve-uri "?y"   resolve-uri "g?y"   resolve-uri ""   resolve-uri "s"   Result  "http:  a b c g"  "http:  a b c g"  "http:  a b c g "  "http:  a g"  "http:  a b c ?y"  "http:  a b c g?y"  resolve-uri ".. g"   "http:  a b g"  "http:  a b c d;p?q"  but see Note   "http:  a b c d;p"?qs"  but see Note   RFC 2396 is rather coy in its description of how a relative reference of ""  the zero-length string  is supposed to behave, giving a description that only really makes sense in the context of a web browser. RFC 3986 clears this up.  Usage The most likely place you will need to use the resolve-uri   function is in conjunction with the doc   function, described on page 750. By default, a relative reference passed to the doc   function is resolved  868   relative to the base URI from the static context of the XPath expression. If the relative URI was read from a source document, it makes much more sense to resolve it against the base URI of the node that contained it. The code usually looks something like this:  reverse  doc resolve-uri @href, base-uri .     See Also base-uri   on page 719 doc   on page 750 escape-uri   on page 811 static-base-uri   on page 876  reverse The reverse   function returns a sequence in reverse order. For example, «reverse 1 to 5 » returns the sequence «5, 4, 3, 2, 1».  Signature Argument sequence  Type  item  *  Meaning The input sequence  Result  item  *  A sequence containing the same items as the input sequence, but in reverse order  Effect The result of the function contains exactly the same items as the input sequence, but the order is reversed. The effect is the same as the expression:  for $i in 1 to count $sequence  return  $sequence[count $sequence  - $i + 1]  or if you prefer a recursive formulation:  if  empty $sequence    then    else  reverse remove $sequence, 1  , $sequence[1]   Examples Expression  reverse 1 to 5   reverse 1   reverse      reverse ancestor::*   See Also unordered   on page 901  Result  5, 4, 3, 2, 1  1      A list of ancestor elements, in reverse document order  that is, innermost ﬁrst   13  T h e  F u n c t i o n  i  L b r a r y  869   The Function Library  root The root   function returns the root node of the tree containing a speciﬁed start node, or the root of the tree containing the context node.  Signature Argument start-node  optional   Type  node  ?  Meaning A node in the tree whose root is required. If the argument is omitted, it defaults to the context node. It is then an error if the context item is not a node  for example, if it is an atomic value, or if it is undeﬁned .  Result  node  ?  The root of the tree containing the start node.  Effect If the start-node argument is supplied and its value is an empty sequence, then the result of the function is an empty sequence.  In other cases, the function returns the root node of the tree containing the start-node. The result is the same as the path expression « ancestor-or-self::node   [1]». This node is not necessarily a document node, since it is possible in the XPath 2.0 data model to have elements or other nodes that are parentless. The system follows the parent axis until it ﬁnds a node that has no parent, and then it returns that node. If the start node has no parent, then the start node itself is returned as the result of the function.  Examples Expression  root    root $x   $seq root    Result The root node of the tree containing the context node  The root node of the tree containing the node $x  A sequence containing the root nodes of all the trees containing nodes in $seq, in document order with duplicates removed  Usage The effect of the root   function, when called with no argument, is very similar to the effect of the expression « ». However, « » will return the root node of the tree containing the context node only if the root is a document node; in other cases, it reports a runtime error.  See Also The Root Expression « » on page 623 in Chapter 9.  round The round   function returns the closest integer to the numeric value of the argument, as an instance of the same type as the argument.  For example, the expression «round 4.6 » returns the xs:decimal value 5.0.  870   round  Changes in 2.0 The function has been generalized to accept arguments of any numeric type.  Signature Argument value  Result  Type  Numeric?  Numeric?  Meaning The input value. If an empty sequence is supplied, an empty sequence is returned.  The result of rounding the ﬁrst argument to the nearest integer, but expressed as a value of the same type as the input value.  Effect The XPath speciﬁcation is very precise about the results of round  . The rules are given in the tables below. The ﬁrst table applies regardless of the type:  Then the result is. . . N  If the argument is. . . Equal to an integer N Between N and N+ 0.5 Exactly N + 0.5 Between N + 0.5 and N + 1 Note that this rounds +3.5 to +4.0, but −3.5 to −3.0. For values of type xs:float and xs:double, there are additional rules to cover the special IEEE values. The concepts of positive and negative zero, positive and negative inﬁnity, and NaN are explained in the section on the xs:double type in Chapter 5, page 198.  N N + 1 N + 1  13  T h e  F u n c t i o n  i  L b r a r y  Then the result is. . . Negative zero  Positive zero  Negative zero  Positive inﬁnity  Negative inﬁnity  NaN  Result xs:decimal 3.2, displayed as "3.2"  xs:double 5.0e0, displayed as "5"  continued  871  If the argument is. . . Between −0.5 and zero Positive zero  Negative zero  Positive inﬁnity  Negative inﬁnity  NaN  not-a-number   Examples  Expression  round 3.2   round 4.6e0    The Function Library  Expression  round 7.5   round -7.5   round -0.0e0   Result xs:decimal 8.0, displayed as "8"  xs:decimal -7.0, displayed as "-7"  xs:double negative zero, displayed as "0"  Usage The round   function is useful when you want the nearest integer, for example, when calculating an average, or when deciding the geometric coordinates for an object to be displayed. If you want to convert the result to a value of type xs:integer, use the xs:integer   constructor function, or the construct «round $x  idiv 1».  See Also ceiling   on page 723 floor   on page 779 round-half-to-even   in the next entry «idiv» operator on page 574 in Chapter 8  round-half-to-even The round-half-to-even   function performs rounding to a speciﬁed number of decimal places. The rounding algorithm used is to round to the nearest value that has the required precision, choosing an even value if two values are equally close.  Signature Argument input  precision  optional   Type  Numeric?  xs:integer  Meaning The number to be rounded. If an empty sequence is supplied, an empty sequence is returned.  If positive, the number of signiﬁcant digits required after the decimal point. If negative, the number of zeroes required at the end of the integer part of the result. The default is zero.  Result  Numeric?  The rounded number. This will have the same type as the supplied number.  Effect The precision argument indicates the number of decimal digits required after the decimal point. More −p where p is the requested pre- generally, the function rounds the supplied number to a multiple of 10 cision. So if the requested precision is 2, the value is rounded to a multiple of 0.01; if it is zero, the value is rounded to a multiple of 1  in other words, to an integer , and if it is −2, the value is rounded to a multiple of 100.  If the precision argument is not supplied, the effect is the same as supplying the value zero, which means the value is rounded to an integer.  872   seconds-from-dateTime, seconds-from-time  The value is rounded up or down to whichever value is closest: for example, if the required precision is 2, then 0.123 is rounded to 0.12 and 0.567 is rounded to 0.57. If two values are equally close then the half-to-even rule comes into play: 0.125 is rounded to 0.12, while 0.875 is rounded to 0.88.  This function is designed primarily for rounding of xs:decimal values, but it is also available for other numeric types. For xs:integer, the behavior is exactly the same as if the value were an xs:decimal  which, in fact, it is . For xs:double and xs:float it may not work so well. The speciﬁcation states that the ﬂoating-point value is ﬁrst cast to an xs:decimal value; the rounding is then applied to this decimal number, and the result is then converted back to the original type. This process may introduce rounding errors, and may fail completely if the implemetation supports a range of values for xs:decimal which is less than the range allowed for xs:double.  Examples Expression  round-half-to-even 1.1742, 2   round-half-to-even 1.175, 2   round-half-to-even 2.5, 0   round-half-to-even 273, -1   round-half-to-even -8500, -3   Usage Most of us were probably taught at school that when numbers are rounded, 0.5 should be rounded upward. Professional accountants and statisticians, however, often prefer the ‘‘half-to-even’’ rule because it avoids creating bias: it means that on average, the total of a large set of numbers will remain roughly the same when all the numbers are rounded.  This function is useful when you want to display the results of a numerical calculation to a certain number of decimal places. Floating-point arithmetic often produces rounding errors because decimal values cannot be represented exactly in binary; for example, the result of «0.3e0 div 3» is «0.09999999999999999» rather than «0.1». Rounding the result say to six decimal places by writing «round-half-to-even 0.3e0 div 3,6 » corrects this error, and produces the result «0.1».  13  T h e  F u n c t i o n  i  L b r a r y  In XSLT, you can also achieve this rounding by using the format-number   function, described on page 788.  See Also ceiling   on page 723 floor   on page 779 format-number   on page 788 round   on page 870  seconds-from-dateTime, seconds-from-time The two functions seconds-from-dateTime   and seconds-from-time   extract the seconds component  including fractional seconds  from an xs:dateTime or xs:time value.  Result  1.17  1.18  2.0  270  -8000  873   The Function Library  Signature Argument input  Type xs:time? or xs:dateTime?  Meaning The value from which the seconds component is to be extracted. The type of the supplied argument must correspond to the type implied by the function name. If an empty sequence is supplied, an empty sequence is returned.  Result  xs:decimal?  The seconds component, in the range 0 to 59.999 . . .  Effect The function returns the seconds component of the supplied xs:time or xs:dateTime. The value is from the time as expressed in its local timezone  not normalized to UTC .  Examples Expression  seconds-from-time xs:time "12:35:03.142"    seconds-from-dateTime xs:dateTime "2008-02-28T13:55:30-01:00"    Result  3.142  30  See Also current-date  , -dateTime  , -time   on page 738 format-date  , -dateTime  , -time   on page 781 hours-from-dateTime  , -time   on page 800 minutes-from-dateTime  , -time   on page 832 timezone-from-dateTime  , -time   on page 893  seconds-from-duration This function extracts the value of the seconds component  including fractional seconds  from a normal- ized xs:duration value.  Signature Argument input  Type  xs:duration?  Meaning The value whose seconds component is to be extracted. If an empty sequence is supplied, an empty sequence is returned.  Result  xs:decimal?  The seconds component, including any fractional seconds.  Effect The function returns the seconds component of the supplied xs:duration. The duration value is ﬁrst normalized so that the number of hours is less than 24, the number of minutes is less than 60, and so on. However, months are never converted to days, or vice-versa. The result will be negative if the duration is negative. The result is therefore a decimal number in the range −60.0 to +60.0, exclusive. XPath processors are required to maintain duration values to a precision of three decimal places  one millisecond . Some processors may maintain a ﬁner precision than this, but it is optional.  874   Examples Expression  seconds-from-duration xs:dayTimeDuration "PT1 M30.5 S"    seconds-from-duration xs:duration "P1 MT150 S"    seconds-from-duration xs:dayTimeDuration "-PT0.0055 S"    seconds-from-duration xs:yearMonthDuration "P1 M"    See Also days-from-duration on page 745 hours-from-duration on page 801 minutes-from-duration on page 832  seconds-from-time see seconds-from-dateTime   on page 873  starts-with The starts-with   function tests whether one string starts with another string.  For example, the expression «starts-with ’$17.30’, ’$’ » returns true.  Changes in 2.0 An optional collation argument has been added.  Signature Argument input  test  collation  optional   Result  Type  xs:string?  Meaning The containing string  xs:string?  The test string  xs:string  A collation URI  starts-with  Result  30.5  30  -0.0055  0  13  T h e  F u n c t i o n  i  L b r a r y  xs:boolean  True if the containing string starts with the test string, otherwise false  Effect If there is no collation argument, then the system tests to see whether the ﬁrst N characters of the input string match the characters in the test string  where N is the length of the test string . If so, the result is true; otherwise, it is false. Characters match if they have the same Unicode value.  If the test string is empty, the result is always true. If the input string is empty, the result is true only if the test string is also empty. If the test string is longer than the input, the result is always false.  If either the input or the test argument is an empty sequence, it is treated in the same way as a zero-length string.  875   If a collation is speciﬁed, this collation is used to test whether the strings match. See the description of the contains   function on page 730 for an account of how substring matching works with a collation. If the collation argument is omitted, the function uses the default collation from the static context.  The Function Library  Examples Expression  starts-with "note", ""   starts-with "yes", "yes"   starts-with "YES", "yes"   starts-with "yes", ""   See Also contains   on page 730 ends-with   on page 773 matches   on page 808 string-length   on page 880  Result  true  true  false  true  Usage For more sophisticated string matching, use the matches   function, which provides the ability to match against a regular expression. However, the matches   function does not give the ability to use a collation.  static-base-uri The static-base-uri   function returns the base URI from the static context of the XPath expression. In XSLT this will be the base URI of the element in the stylesheet containing the expression.  Signature  Result  Type  xs:anyURI  Meaning The base URI from the static context of the XPath expression  Effect The function returns the base URI from the static context. This is determined by the host language in which the expression appears. For an XPath expression used in an XSLT stylesheet, the base URI is the URI of the stylesheet module, unless this is modiﬁed with an xml:base attribute.  The base URI is used when resolving a relative URI contained in the expression, for example as an argument of the doc  or document   function.  It is possible that the base URI is unknown. This can happen in XSLT if the stylesheet is supplied as a DOM, or as a character string or input stream with no associated URI. In this case this function returns an empty sequence.  Usage In XSLT 2.0 and XQuery 1.0 it is well deﬁned how the base URI in the static context is established. If you invoke XPath expressions via an API from a programming language  for example, a Java or  876   .NET API  then there may be no explicit way of setting the base URI, especially if the API was origi- nally designed for XPath 1.0. In this case the static-base-uri   function is deﬁned to return an empty sequence.  string  See Also base-uri   on page 719 doc   on page 750 document   on page 754 resolve-uri   on page 867  string The string   function converts its argument to a string. When the argument is a node, it extracts the string value of the node; when the argument is an atomic value, it converts the atomic value to a string in a similar way to the xs:string   constructor function.  For example, the expression «string 4.00 » returns the string "4".  Changes in 2.0 The function has been generalized to take a wider range of types as its input.  In XPath 1.0, when a sequence containing several nodes was supplied, the string   function returned the string value of the ﬁrst node, and ignored the rest. This behavior is retained in XPath 2.0 when running in 1.0 backward-compatibility mode; but in 2.0 mode, supplying more than one item in the argument is an error.  Signature Argument value  optional   Result  Type  item  ?  Meaning The value to be converted. If the argument is omitted, it defaults to the context item.  xs:string  The result of converting the argument to a string.  13  T h e  F u n c t i o n L b r a r y  i  Effect Values of most types can be converted to a string.  If the function is called with no arguments, the effect is the same as supplying «.»  the context item  as the ﬁrst argument.  If the supplied value is an empty sequence, the result is a zero-length string.  Don’t confuse supplying an argument whose value is «  » with not supplying an argument — the effect is different.   If the supplied value is a single node, the result is the string value of that node. The string value of a node is deﬁned as follows:           For a document node or element node, the string value is the concatenation of all the descendant text nodes. For an attribute, the string value is the attribute value. For a text node, the string value is the textual content.  877   The Function Library           For a comment, the string value is the text of the comment. For a processing instruction, the string value is the data part of the processing instruction, that is, the part after the name that forms the target of the processing instruction. For a namespace node, the string value is the namespace URI.  If the supplied value is a single atomic value the result is the same as the result of casting the atomic value to a string. Every atomic value can be cast to a string — the rules are given in Chapter 11.  Note that taking the string value of a node is not the same as taking the typed value and converting it to a string. For example, the typed value might be a sequence of integers, but no conversion is deﬁned from a sequence of integers to a string. In some cases a node has no typed value, notably in the case where the schema deﬁnes it as having element-only content  as distinct from mixed or empty content . Such an element has no typed value, but it still has a string value that is the concatenation of the desendant text nodes.  The type signature does not allow a sequence of more than one item to be supplied. However, if XPath 1.0 compatibility mode is enabled, any items in the sequence after the ﬁrst are ignored.  Examples Assume that the context node is the element:    17  blue    Expression  string    string first   string second   string @example   string +47.20   string 2=2   string *   Result  "17blue"  "17"  "blue"  "yes"  "47.2"  "true"  In 1.0 mode: "17" In 2.0 mode: error  Usage When converting atomic values to strings, there isn’t really anything to choose between using the string   function and using the xs:string   constructor function.  When the argument is a node, the two functions behave differently. The string   function extracts the string value of the node, while xs:string   extracts the typed value and converts it to a string. In the absence of a schema, they do exactly the same thing. But with a schema, here are two cases where they can give different results:    Where the node has a list-valued simple type  for example, a list of integers , string   will give the textual content of the node  a space-separated list of numbers , whereas xs:string   will fail if the list contains more than one item, or is empty.    Where the node is an element with an element-only content model, string   will give the con-  catenation of the descendant text nodes of the element, while xs:string   will fail.  878   string-join  See Also boolean   on page 721 number   on page 851 Converting Atomic Values on page 654 in Chapter 11  string-join The string-join   function returns a string constructed by concatenating all the strings in a supplied sequence, with an optional separator between adjacent strings.  For example, «string-join  "a","b","c" , "" » returns «abc».  Signature Argument sequence  Type  xs:string*  Meaning The supplied sequence of strings.  separator  xs:string  The separator to be used between adjacent strings. If no separator is required, supply a zero-length string for this argument.  Result  xs:string  The result of concatenating the supplied strings and inserting separators.  Effect Each of the strings in the supplied sequence is appended to the result string, retaining the order in which the strings appear in the sequence. Each string except the last is followed by the requested separator string.  If the supplied sequence is empty, the result is always a zero-length string.  Examples Expression  string-join  "a", "b", "c" , ", "   string-join  "A", "B", "C" , ""   string-join "Z", "+"  string-join   , "∼"   Usage The expression:  string-join ancestor-or-self::* name  , " "   will return a path such as:  book chapter section title  13  T h e  F u n c t i o n  i  L b r a r y  Result  "a, b, c"  "ABC"  "Z"  ""  Note that there is no implicit conversion of the items in the sequence to strings, even in XPath 1.0 com- patibility mode. If the items are not strings, you need to convert them explicitly. For example, given a sequence of numbers, you can write:  string-join $seq string  , ", "   879   See Also concat  on page 729  Changes in 2.0 None.  Signature Argument value  optional   Result  The Function Library  The string-join   function is often a handy alternative to concat  , because you can in effect give it a sequence of sequences to output. For example:  string-join  "debits:", $debits, "credits:", $credits , " "   might produce the string:  debits: 23.40 18.50 67.00 credits: 17.00 5.00 4.32  In XSLT, functionality very similar to the string-join   function is invoked implicitly by the   instruction, and also in attribute value templates. For example, the instruction   produces the result  . The   instruction has a separator attribute to allow user control over the choice of separator, while attribute value templates always use a single space.  string-length The string-length   function returns the number of characters in a string value.  For example, the expression «string-length ’Beethoven’ » returns 9.  Type xs:string?  Meaning The string whose length is required. If the argument is an empty sequence, the result of the function is 0  zero .  xs:integer  A number: the number of characters in the value of the argument.  Effect When the argument is omitted, the function gives the string length of the value obtained by applying the string   function to the context item. It’s an error if there is no context item.  Characters are counted as instances of the XML Char production. This means that a Unicode surrogate pair  a pair of 16-bit values used to represent a Unicode character in the range x10000 to x10FFFF  is treated as a single character.  It is the number of characters in the string that matters, not the way they are written in the source doc- ument. A character written using a character reference such as «&255;» or an entity reference such as «&amp;» is still one character.  Unicode combining and non-spacing characters are counted individually, unless the implementation has normalized them. The implementation is allowed to turn strings into normalized form, but is not required to do so. In normalized form NFC, accents and diacriticals will frequently be merged with the  880   string-to-codepoints  letter that they modify into a single character. To assure yourself of consistent answers in such cases, the normalize-unicode   function should be called to force the string into normalized form.  Examples These examples assume that the XPath expression is used in a host language that expands XML entity references and numeric character references; for example, XSLT or XQuery.  Expression  string-length "abc"   string-length "&lt;&gt;"   string-length """"   string-length ""   string-length ’&xFFFD;’   string-length ’&x20000;’   Result  3  2  1  0  1  1  Usage The string-length   function can be useful when deciding how to allocate space on the output medium. For example, if a list is displayed in multiple columns then the number of columns may be determined by some algorithm based on the maximum length of the strings to be displayed.  It is not necessary to call string-length   to determine whether a string is zero-length, because con- verting the string to an xs:boolean, either explicitly using the boolean   function, or implicitly by using it in a boolean context, returns true only if the string has a length of one or more. For the same reason, it is not usually necessary to call string-length   when processing the characters in a string using a recursive iteration, since the terminating condition when the string is empty can be tested by converting it to a boolean.  13  T h e  F u n c t i o n  i  L b r a r y  See Also normalize-unicode   on page 847 substring   on page 883  string-to-codepoints The string-to-codepoints   function returns a sequence of integers representing the Unicode code- points of the characters in a string. For example, «string-to-codepoints "A" » returns 65.  Signature Argument input  Result  Type  xs:string?  xs:integer*  Meaning The input string  The codepoints of the characters in the input string  Effect If an empty sequence or a zero-length string is supplied as the input, the result is an empty sequence.  881   The Function Library  In other cases, the result contains a sequence of integers, one for each character in the input string. Char- acters here are as deﬁned in Unicode and XML: a character above xFFFF that is represented as a surrogate pair counts as one character, not two. The integers that are returned will therefore be in the range 1 to x10FFFF  decimal 1114111 .  Examples Expression  string-to-codepoints "ASCII"   string-to-codepoints "&100000;"   string-to-codepoints ""   See Also codepoints-to-string   on page 725  65, 83, 67, 73, 73  Result  100000      subsequence The subsequence   function returns part of an input sequence, identiﬁed by the start position and length of the subsequence required.  For example the expression «subsequence  "a", "b", "c", "d" , 2, 2 » returns « "b", "c" ».  Signature Argument sequence  start  length  optional   Result  Meaning The input sequence.  Type  item  *  xs:double  xs:double  The position of the ﬁrst item to be included in the result.  The number of items to be included in the result. If this argument is omitted, all items after the start position are included.  xs:string  The sequence of items starting at the start position  Effect The two-argument version of the function is equivalent to:  $sequence[position  >= round $start ]  The three-argument version is equivalent to:  $sequence[position  >= round $start   and position   <  round $start  + round $length  ]  A consequence of these rules is that there is no error if the start or length arguments are out of range. Another consequence is that if the start or length arguments are NaN, the result is an empty sequence.  The arguments are deﬁned with type xs:double for symmetry with the substring   function, which itself uses xs:double arguments for backward compatibility with XPath 1.0, which did not support any numeric type other than double. If you supply an integer, it will automatically be converted to a double.  882   The fact that they are doubles rather than integers is occasionally convenient because the result of a calculation involving untyped values is a double. For example:  subsequence $seq, 1, @limit + 1   works even when the limit attribute is untyped, in which case the value of «@limit+1» is an xs:double.  substring  4, 5, 6, 7, 8, 9, 10  Result  7, 8      2, 3, 4, 5, 6  Examples Expression  subsequence 3 to 10, 2   subsequence 3 to 10, 5, 2   subsequence 1 to 5, 10   subsequence 1 to 10, 2.3, 4.6   See Also insert-before   on page 810 remove   on page 861 Filter Expressions on page 637 in Chapter 10  13  T h e  F u n c t i o n  i  L b r a r y  substring The substring   function returns part of a string value, determined by character positions within the string. Character positions are counted from one.  For example, the expression «substring ’Goldfarb’, 5, 3 » returns the string «far».  Changes in 2.0 None.  Signature Argument input  Type  xs:string?  Meaning The containing string. If an empty sequence is supplied, the result is a zero-length string.  start  xs:double  length  optional   xs:double  The position in the containing string of the ﬁrst character to be included in the result string.  The number of characters to be included in the result string. If the argument is omitted, characters are taken from the start position up to the end of the containing string.  Result  xs:string  The required substring of the containing string.  Effect Informally, the function returns a string consisting of the characters in the input string starting at position start; if a length is given, the returned string contains this many characters; otherwise, it contains all characters up to the end of the value.  883   The Function Library  Characters within a string are numbered 1, 2, 3. . . , n. This will be familiar to Visual Basic programmers but not to those accustomed to C or Java, where numbering starts at zero.  Characters are counted as instances of the XML Char production. This means that a Unicode surrogate pair  a pair of 16-bit values used to represent a Unicode character in the range x10000 to x10FFFF  is treated as a single character.  Combining and non-spacing characters are counted individually, unless the implementation has normal- ized them into a single combined character. The implementation is allowed to turn strings into Unicode normalized form, but is not required to do so. In normalized form NFC, accents and diacritics will typically be merged with the letter that they modify into a single character.  It is possible to deﬁne this function in terms of the subsequence   function. With two arguments, the function has the same result as:  codepoints-to-string   subsequence string-to-codepoints $input , $start     With three arguments, the deﬁnition becomes:  codepoints-to-string   subsequence string-to-codepoints $input , $start, $length     These rules cover conditions such as the start or length being negative, NaN, fractional, or inﬁnite. The comparisons and arithmetic are done using IEEE 754 arithmetic, which has some interesting conse- quences if values such as inﬁnity and NaN, or indeed any non-integer values are used. The rules for IEEE 754 arithmetic are summarized in Chapter 2.  The equivalence tells us that if the start argument is less than one, the result always starts at the ﬁrst character of the supplied string, while if it is greater than the length of the string, the result will always be an empty string. If the length argument is less than zero, it is treated as zero, and again an empty string is returned. If the length argument is greater than the number of available char- acters, and the start position is within the string, then characters will be returned up to the end of the containing string.  Result  "bcde"  "bc"  ""  "abcde"  Usage The substring   function is useful when processing a string character-by-character. One common usage is to determine the ﬁrst character of a string:  Examples Expression  substring "abcde", 2   substring "abcde", 2, 2   substring "abcde", 10, 2   substring "abcde", 1, 20   substring $filename, 1, 1   884   substring-after  Or when manipulating personal names in the conventional American format of ﬁrst name, middle initial, last name:  string-join  first-name, substring middle-name, 1, 1 , last-name , " "   The following example extracts the last four characters in a string:  substring $s, string-length $s -3   Using substring   as a Conditional Expression The technique outlined in this section is thankfully obsolete, now that XPath 2.0 offers «if» expressions, as described in Chapter 7. But you may encounter it in XSLT 1.0 stylesheets, and you may still have to use it if you write code that has to run under both XPath 1.0 and XPath 2.0, so it’s worth a mention here.  Suppose that $b is an xs:boolean value, and consider the following expression:  substring "xyz", 1, $b * string-length "xyz"    Under XPath 1.0 rules, the xs:boolean $b when used in an arithmetic expression is converted to a num- ber: 0 for false, 1 for true. So the value of the third argument is 0 if $b is false, 3 if $b is true. The ﬁnal result of the substring   function is therefore a zero-length string if $b is false, or the string "xyz" if $b is true. The expression is equivalent to «if  $b  then "xyz" else ""» in XPath 2.0.  In fact the third argument doesn’t need to be exactly equal to the string length for this to work, it can be any value greater than the string length. So you could equally well write:  substring "xyz", 1, $b *  1 div 0    exploiting the fact that «1 div 0» under XPath 1.0 is inﬁnity, and zero times inﬁnity is NaN. This obscure construct provided XPath 1.0 programmers with a substitute for a conditional expression.  If you try to run this code under XPath 2.0, it will fail: «1 div 0» is an xs:decimal division rather than an xs:double division, and the xs:decimal type has no inﬁnity value. If you need to rewrite this so that it works under both XPath 1.0 and XPath 2.0, the simplest way is to replace the «1 div 0» by a very large but ﬁnite number. In XSLT, you can deﬁne this as a global variable. Remember, though, that exponential notation for numbers is not available in XPath 1.0.  13  T h e  F u n c t i o n  i  L b r a r y  See Also substring-after   in the following section substring-before   on page 887 string-length   on page 880 contains   on page 730  substring-after The substring-after   function returns that part of a string value that occurs after the ﬁrst occurrence of some speciﬁed substring.  For example, the expression «substring-after ’print=yes’, ’=’ » returns «yes».  Changes in 2.0 An optional collation argument has been added.  885   The Function Library  Signature Argument value  test  collation  optional   Result  Type  xs:string?  xs:string?  xs:string  xs:string  Meaning The containing string  The test string  Identiﬁes the collation to be used for comparing strings.  A string containing those characters that follow the ﬁrst occurrence of the test substring within the containing string  Effect If the containing string  value  does not contain the test substring, the function returns a zero-length string. Note that this could also mean that the containing string ends with the test substring; the two cases can be distinguished by calling the ends-with   function.  If the value does contain the test substring, the function returns a string made up of all the characters that appear in value after the ﬁrst occurrence of the test substring.  If either of the ﬁrst two arguments is an empty sequence, it is treated as if it were a zero-length string.  If the test substring is zero-length, the function returns value.  If value is zero-length, the function returns a zero-length string.  If a collation is speciﬁed, this collation is used to test whether the strings match. See the description of the contains   function on page 730 for an account of how substring matching works with a collation. If the collation argument is omitted, the function uses the default collation.  Things get complicated if the collation classiﬁes characters such as space or hyphen as ignorable for sorting purposes. If hyphen is ignorable, then «substring-after "a-b-c", "b-" » returns «-c». That’s because the match chosen for «b-» is the minimal matching substring, which is «b».  Examples Expression  substring-after "my.xml", "."   substring-after "my.xml", "m"   substring-after "my.xml", "xml"   substring-after "my.xml", ""   substring-after "", ""   substring-after "my.xml", ""   Result  "xml"  "y.xml"  ""  ""  ""  "my.xml"  Usage The substring-after   function was often used in XPath 1.0 to analyze a string that contains delimiter characters. For example, when the string is a whitespace-separated list of tokens, the ﬁrst token can be obtained using:  substring-before $s, ’ ’   886   substring-before  and the rest of the string using  substring-after $s, ’ ’   With XPath 2.0, this can be done more robustly using the tokenize   function. However, there are still many cases where it is more convenient to use substring-after  . For example, to extract the local part of a lexical QName, you can write:  substring-after $qname, ’:’   XSLT Example The following example shows a recursive template that takes a whitespace-separated list as input, and outputs each token separated by an empty   element.       <xsl:variable name="nlist"  select="concat normalize-space $list ,’ ’ " >                            See Also contains   on page 730 substring   on page 883 substring-before   in the next section  substring-before The substring-before   function returns that part of a string value that occurs before the ﬁrst occur- rence of some speciﬁed substring.  For example, the value of «substring-before ’print=yes’, ’=’ » is the string «print».  Changes in 2.0 An optional collation argument has been added.  Signature  Argument value  test  Type  xs:string?  xs:string?  Meaning The containing string  The test string  13  T h e  F u n c t i o n  i  L b r a r y  continued  887   The Function Library  Argument collation  optional   Result  Type  xs:string  xs:string  Meaning Identiﬁes the collation to be used for comparing strings  A string containing those characters that precede the ﬁrst occurrence of the test substring within the containing string  Effect If the containing string  value  does not contain the test substring, the function returns a zero-length string. Note that this could also mean that the value starts with the test string; the two cases can be distinguished by calling the starts-with   function.  If the value does contain the test substring, the function returns a string made up of all the characters that appear in the value before the ﬁrst occurrence of the test substring.  If either of the strings is an empty sequence or a zero-length string, the function returns a zero-length string.  If a collation is speciﬁed, this collation is used to test whether the strings match. See the description of the contains   function on page 730 for an account of how substring matching works with a collation. If the collation argument is omitted, the function uses the default collation.  Things get complicated if the collation classiﬁes characters such as space or hyphen as ignorable for sorting purposes. If hyphen is ignorable, then «substring-before "a-b-c", "-b" » returns «a-». That’s because the match chosen for «-b» is the minimal matching substring, which is «b».  Examples Expression  substring-before "my.xml", "."   substring-before "my-xml.xml", "xml"   substring-before "my.xml", ""   substring-before "my.xml", ""   Result  "my"  "my-"  ""  ""  Usage and Examples An example of the use of substring-after   and substring-before   to process a whitespace-separated list of tokens is given under substring-after   on page 887.  If the only reason for using substring-before   is to test whether the string has a given preﬁx, use starts-with   instead. You could write:  if  substring-before $url, ’:’ =’https’  then ...  but the following is simpler:  if  starts-with $url, ’https:’   then ...  In XPath 1.0, the substring-before   and substring-after   functions were often used in conjunction to ﬁnd and replace portions of a string. In XPath 2.0, this kind of string manipulation is much easier using regular expressions, as offered by the replace   function.  888   sum  See Also contains   on page 730 replace   on page 862 starts-with   on page 875 substring   on page 883 substring-after   on page 885  sum The sum   function calculates the total of a sequence of numeric values or durations.  For example, if the context node is the element  , then the expression «sum @* » returns 50.  The expression «@*» is a sequence containing all the attributes of the context node.   Changes in 2.0 This function is generalized in XPath 2.0 so that it can sum over all the numeric types, and also over durations.  In XPath 1.0 the function returned NaN if the sequence contained a value that could not be converted to a number. In XPath 2.0  even under backward-compatibility mode  this situation causes a failure.  Signature Argument sequence  zero-value  optional   Result  Type  xs:anyAtomicType*  Meaning The set of items to be totaled  xs:anyAtomicType  The value to be returned when the sequence is empty  xs:anyAtomicType  The total of the values in the sequence  Effect Although the function signature states that the input sequence must consist of atomic values, the function calling rules ensure that the actual argument can be a sequence of nodes — the nodes in this sequence will be atomized, which extracts their typed values. If the source document has been validated using a schema, then the type of the resulting values depends on the schema, while if it has not been validated, the result of atomization will be untyped atomic values.  Any untyped atomic values in the sequence are converted to xs:double values. A runtime error is reported if this conversion fails. If the sequence contains any NaN  not-a-number  values, which might happen if you do the conversion yourself by calling the number   function, then the result of the function is NaN.  The values in the sequence are added using the «+» operator. An error is reported if there are values that cannot be added using the «+» operator. This will happen if the sequence contains values of types other than the numeric types, the duration types, and xs:untypedAtomic, or if it contains a mixture of durations and other types. If you are totaling durations, all the durations must either be of type xs:dayTimeDuration or they must all be of type xs:yearMonthDuration — you cannot mix the two, and you cannot use duration values unless they match one of these subtypes.  If the input sequence is empty, then the value returned is the value speciﬁed in the zero-value argu- ment. If this argument is omitted, the return value for an empty sequence is the xs:integer value 0.  889  13  T h e  F u n c t i o n  i  L b r a r y   The Function Library  Examples Expression  sum  1, 2, 3, 4    sum  1, 2, 3, 4.5    sum  1, 2, 3.5e0, 4.5    sum      sum   , 0.0e0   The purpose of this argument is to allow a return value to be speciﬁed that has the appropriate type, for example, an xs:double 0.0e0 for use when totaling doubles, or the value PT0 S when totaling xs:dayTimeDuration values. This is needed because there is no runtime type information associated with an empty sequence — an empty sequence of xs:double values does not look any different from an empty sequence of xs:dayTimeDuration values.  Result 10  xs:integer   10.5  xs:decimal   11.0e0  xs:double   0  xs:integer   0.0e0  xs:double   sum  xs:dayTimeDuration "P3D" , xs:dayTimeDuration "PT36H"     xs:dayTimeDuration "P4DT12H"   sum   , xs:dayTimeDuration "PT0 S"    xs:dayTimeDuration "PT0 S"   Usage The sum   function can be used to create totals and subtotals in a report. It is also useful for calculating geometric dimensions on the output page.  A problem that sometimes arises is how to get a total over a set of values that aren’t present directly in the source ﬁle, but are calculated from it. For example, if the source document contains   elements with attributes price and sales, how would you calculate the total sales revenue, which is obtained by multiplying price by sales for each book, and totaling the result over all books? Or, how would you total a set of numbers if each one has a leading «$» sign, which you need to strip off ﬁrst? In XPath 1.0 this was difﬁcult to achieve, but the solution in XPath 2.0 is simple:  sum   price number substring-after ., ’$’    In the ﬁrst case:  In the second case:  sum   book  price * sales    See Also avg   on page 718 count   on page 733  system-property This function is available in XSLT only.  The system-property   function returns information about the processing environment.  For example, with a processor that implements XSLT version 2.0, the expression «system-property  ’xsl:version’ » returns 2.0.  890   system-property  Changes in 2.0 Several new system properties have been deﬁned in XSLT 2.0.  The result of the function is now always a string. In XSLT 1.0  although the spec was not a hundred percent clear on the point  the «xsl:version» system property was returned as a number.  Signature Argument name  Type  xs:string  Meaning Speciﬁes the name of the system property required. The value of the string should be in the form of a lexical QName that identiﬁes a system property. If there is no system property with this name, the function returns a zero-length string.  Result  xs:string  The value of the requested system property.  Effect The supplied argument is converted into an expanded name using the namespace declarations in scope for the stylesheet element that contains the call on system-property  .  There are several system properties that every implementation must support. These are all in the XSLT namespace, and are listed as follows. The ﬁrst three were available in XSLT 1.0, the others are new in XSLT 2.0. System Property  xsl:version  xsl:vendor  xsl:vendor-url  xsl:product-name  xsl:product-version  xsl:is-schema-aware  13  T h e  F u n c t i o n  i  L b r a r y  Value A number giving the version of XSLT implemented by the processor. For conformant XSLT processors, this will be 1.0 or 2.0. For processors that provide a partial implementation, or an implementation of intermediate working drafts, other versions may be returned. It’s a good idea to write your stylesheet on the assumption that new XSLT versions may be introduced in the future.  A string identifying the vendor of the XSLT processor. In practice it will sometimes also identify the product name, but the actual value is implementation deﬁned. For Microsoft’s MSXML3 product, the value is simply «Microsoft».  A string: the URL of the vendor’s Web site. For example, MSXML3 returns «http:  www.microsoft.com».  This property is new in XSLT 2.0. It is intended to identify the product name of the XSLT processor; for example, «Xalan» or «Saxon».  This property is new in XSLT 2.0. It is intended to identify which version of the XSLT processor is being used; for example, «7.6.5». If there are several variants of a product  for example, Xalan-C and Xalan-J , it is up to the implementor whether the variant is returned as part of the product name or as part of the product version.  This property returns the string «yes» or «no», depending on whether the XSLT 2.0 processor is schema-aware or not.  continued  891   The Function Library  System Property  xsl:supports- serialization  xsl:supports-backwards- compatibility  xsl:supports- namespace-axis  Value This property returns the string «yes» or «no», depending on whether the XSLT 2.0 processor supports serialization or not.  This property returns the string «yes» or «no», depending on whether the XSLT 2.0 processor supports running in backward-compatibility mode. A processor that does not support this mode will report an error if «version="1.0"» is speciﬁed.  This property was introduced to the speciﬁcation by means of an erratum, so not all processors will support it. It returns «yes» if the implementation recognizes the namespace axis, or «no» if it does not. An implementation that has not been updated to recognize this property will return a zero-length string.  Any additional system properties returned by this function are implementation-deﬁned. Such properties should either be in a namespace speciﬁc to the vendor, or in no namespace. Some products provide access to environment variables or Java system properties using this mechanism; this can be particularly useful as a way of parameterizing the use-when construct.  Usage The system-property   function can be used to determine details about the processor running the stylesheet, either for display purposes  for example, to produce a comment in the generated output , or to apply conditional logic.  The function is especially useful when used in conjunction with the use-when attribute. For example, you can import a schema only if the processor is schema-aware by writing  <xsl:import-schema schema-location="..."  use-when="system-property ’xsl:is-schema-aware’  eq ’yes’" >  You can use the same approach on   and   to include entire stylesheet modules conditionally. If the processor allows you to access environment variables set from the operat- ing system shell, this provides a powerful way of maintaining different variants of your stylesheet for different processing scenarios, rather like ifdef directives in C.  Generally, it is best to avoid testing the system version to see whether particular features are available, unless there is no other way of doing so. The functions function-available   and element- available   and the   instruction often serve this need better, and the forward- com- patibility features described on page 130 in Chapter 3 can be used to ensure that a stylesheet can work with processors that implement an older dialect of XSLT.  However, there are some cases where testing «system-property ’xsl:version’ » is the only practical way of discovering whether a feature is available. For example, the XSLT 2.0 working draft introduces the ability to use a tree-valued variable  or a result tree fragment, as it is known in XSLT 1.0  as a document node, in contexts such as   and  . Since this feature does not introduce any new functions or XSLT elements, the only practical way to test whether it is available is to check the XSLT version supported.  Examples The following code outputs a documentary comment into the generated HTML.  892   timezone-from-date, timezone-from-dateTime, timezone-from-time  Generated with XSLT stylesheet   using   version             . . .  See Also element-available   page 764 function-available   on page 792   on page 316 in Chapter 6  timezone-from-date, timezone-from-dateTime, timezone-from-time These three functions extract the timezone component from an xs:date, xs:time, or xs:dateTime value. For example, for a user in California, «timezone-from-dateTime current-dateTime   » typically returns the dayTimeDuration «-PT8H».  Signature Argument input  Type xs:date?, xs:time?, or xs:dateTime?  Meaning The value from which the timezone component is to be extracted. The type of the supplied argument must correspond to the type implied by the function name.  Result  xs:dayTimeDuration?  The timezone, expressed as a duration.  Effect The function returns the timezone component of the supplied xs:date, xs:time, or xs:dateTime.  If the argument is an empty sequence, or if it is a date, time, or dateTime containing no timezone, then the result is an empty sequence. Otherwise, the function returns the timezone from the speciﬁed value. The timezone is returned in the form of an xs:dayTimeDuration value giving the offset from UTC  or Greenwich Mean Time, in common language .  If you want the timezone as a numeric value in hours, divide it by «xs:dayTimeDuration  "PT1H" ».  13  T h e  F u n c t i o n  i  L b r a r y  Examples Expression  timezone-from-date xs:date "2008-02-28"    timezone-from-dateTime xs:dateTime "2008-02-28T13:00:00-06:00"    timezone-from-time xs:time "13:00:00+01:00"    timezone-from-dateTime xs:dateTime "2008-07-31T23:00:00Z"    Result      -PT6H  PT1H  PT0 S  893   The Function Library  See Also adjust-date time-to-timezone on page 715 current-date  , -dateTime  , -time   on page 738 format-date  , -dateTime  , -time   on page 781 implicit-timezone   on page 806  tokenize The tokenize   function splits a string into a sequence of substrings, by looking for separators that match a given regular expression. For example, «tokenize "12, 16, 2", ",\s*" » returns the sequence « "12", "16", "2" ».  Signature Argument input  Type  xs:string?  Meaning The input string. If an empty sequence or zero-length string is supplied, the function returns an empty sequence.  regex  xs:string  The regular expression used to match separators, written according to the rules given in Chapter 14.  ﬂags  optional   xs:string  One or more letters indicating options on how the matching is to be performed. If this argument is omitted, the effect is the same as supplying a zero-length string, which defaults all the option settings.  Result  xs:string*  A sequence whose items are substrings of the input string.  Effect The rules for the syntax of regular expressions and the flags argument are given in Chapter 14.  The input string is processed from left to right, looking for substrings that match the regular expression supplied in the regex argument. A consecutive sequence of characters that doesn’t participate in a match is copied as a string to form one item in the output sequence. A sequence of characters that does match the regex is deemed to be a separator and is discarded. The search then resumes at the character position following the matched substring.  It can happen that two substrings starting at the same position both match the regex. There are two ways this situation can arise.  Firstly, it happens when part of the regex is looking for repeated occurrences of a substring. For example, suppose the regex is «\n+», indicating that any sequence of one or more consecutive newlines acts as a separator. Then clearly, if two adjacent newline characters are found, the regex could match on the ﬁrst one alone, or on the pair. The rule here is that «+» is a greedy quantiﬁer: it matches as long a substring as it can, in this case, both newline characters. In this example, this is what you want to happen. But if you were trying to remove comments in square brackets by using a regex such as «\[.*\]», this would have the wrong effect — given the input «Doolittle [1] and Dalley [2]», the ﬁrst separator identiﬁed would be «[1] and Dalley [2]». If you want to match the shortest possible substring, add a «?» after the quantiﬁer to make it non-greedy, thus: «\[.*?\]». Another situation that can cause two different substrings to match at the same position is where the regex contains two alternatives that both match. For example, when the regex «» is applied to a  894   tokenize  string that contains two consecutive «» characters, both branches will match. The rule here is that the ﬁrst  leftmost  alternative wins. In this case, this is almost certainly not what was intended: rewrite the expression as «», or as «?».  If the input string starts with a separator, then the output sequence will start with a zero-length string representing what was found before the ﬁrst separator. If the input string ends with a separator, there will similarly be a zero-length string at the end of the sequence. If there are two adjacent separa- tors in the middle of the string, you will get a zero-length string in the middle of the result sequence. In all cases the number of items in the result sequence is the number of separators in the input string plus one.  If the regex does not match the input string, the tokenize   function will return the input string unchanged, as a singleton sequence. If this is not the effect you are looking for, use the matches   func- tion ﬁrst to see if there is a match.  If the regex is one that matches a zero-length string, that is, if «matches "", $regex » is true, the system reports an error. An example of such a regex is «\s*». Although various interpretations of such a con- struct are possible, the Working Group decided that the results were too confusing and decided not to allow it.  Examples Expression tokenize "Go home, Jack!", "\W+"  tokenize "abc[NL]def[XY]", "\[.*?\]"   Result   "Go", "home", "Jack", ""    "abc", "def", ""   Usage A limitation of this function is that it is not possible to do anything with the separator substrings. This means, for example, that you can’t treat a number differently depending on whether it was separated from the next number by a comma or a semicolon. One solution to this problem is to process the string in two passes: ﬁrst, do a replace   call in which the separators «,» and «;» are replaced by  say  «,» and «;»; then use tokenize   to split the string at the «» characters, and the original «,» or «;» will be retained as the last character of each substring in the tokenized sequence. Another approach, if you are using XSLT, is to use the   instruction.  A similar technique is possible when there are no separators available. Suppose that the input is alphanu- meric, and you want to break it into a sequence of alternating alphabetic and numeric tokens, so that the input «W151TBH» is split into the three strings « "W", "151", "TBH" ». Here’s how to do this:  tokenize replace $input, " [0-9]+[A-Za-z]+ ", "$1" , "" [.]  The predicate «[.]» at the end of this expression causes zero-length strings in the result to be ﬁltered out  there will be a zero-length string at the end of the sequence .  13  T h e  F u n c t i o n  i  L b r a r y  See Also   in Chapter 6, page 230 matches   on page 828 replace   on page 862 Regular Expressions: Chapter 14  895   The Function Library  trace The trace   function is used to produce diagnostic output. The format and destination of the output is implementation-deﬁned.  Signature Argument value  message  Result  Type  item  *  xs:string  item  *  Meaning A value that is to be displayed in the diagnostic output  A message that is to be output along with the displayed value  The function returns the displayed value, unchanged  Effect The detailed effect of this instruction depends on the implementation; some implementations might ignore it entirely. The idea of the function is that when it is evaluated, a message should be produced to some diagnostic output stream  perhaps a log ﬁle or perhaps an interactive console  showing the message string and the contents of the supplied value. The function then returns this value, and execution continues normally.  Note that since the order of execution of different expressions is undeﬁned, the trace output will not necessarily be strictly sequential, and it may be difﬁcult to see what is going on when the same trace   expression is evaluated repeatedly. This problem can be reduced if the message, rather than being a simple literal string, is constructed from variables that provide some context.  The speciﬁcation doesn’t say whether the presence of the trace   function should or should not affect the optimizer’s evaluation strategy. Some implementors may decide that to make the trace output intelligible, certain optimizations should be suppressed; others may decide that the execution strategy with tracing should be as close as possible to the execution strategy without tracing, to reduce the risk of so-called Heisenbugs, in which the behavior of the expression changes when debugging is switched on.  Usage and Examples Suppose you are having problems understanding why the function call «sum   @price » is returning NaN. Try changing it to:  «sum   trace @price, "price value"  »  to see the price values that are being used in the computation.  In the Saxon implementation, when you trace a sequence, you get one message for each item in the sequence. Saxon pipelines the evaluation of sequences, and tracing doesn’t change the pipeline, so you might ﬁnd that the evaluation of different sequences is interleaved. This can be confusing, but it gives you a faithful picture of what is happening internally. Other implementations might give you one message for the entire sequence, and might break the evaluation pipeline in order to output the message.  Sometimes you might just want to output a value that is not actually used in the computation. In this case, you can usually use an empty sequence as the value, and put the required value into the message — just remember that the trace   function will then return an empty sequence. For example, you could write:  «sum    trace   ,concat "reading price for ", string @code  , @price  »  896   translate  In an XSLT environment, I usually ﬁnd that tracing is best performed using the   instruc- tion, and I typically use trace   only in XQuery. For detailed inspection of values as they are computed, there are a number of good XSLT debuggers available. But occasionally, trace   is a useful tool to take out of the kitbag.  See Also   in Chapter 6 on page 386  translate The translate   function substitutes characters in a supplied string with nominated replacement characters. It can also be used to remove nominated characters from a string.  For example, the result of «translate ’ABC-123’, ’-’, ’ ’ » is the string «ABC 123».  Changes in 2.0 An empty sequence is not accepted for the second and third arguments, except in backward- compatibility mode.  Signature Argument value  from  to  Result  Type  xs:string?  Meaning The supplied string  xs:string  The list of characters to be replaced, written as a string  xs:string  The list of replacement characters, written as a string  xs:string?  A string derived from the supplied string, but with those characters that appear in the second argument replaced by the corresponding characters from the third argument, or removed if there is no corresponding character  13  T h e  F u n c t i o n  i  L b r a r y  Effect For each character in the supplied string, one of three possible actions is taken:           If the character is not present in the list of characters to be replaced, the character is copied to the result string unchanged. If the character is present at position P in the list of characters to be replaced, and the list of replacement characters is of length P or greater, then the character at position P in the list of replacement characters is copied to the result string. If the character is present at position P in the list of characters to be replaced, and the list of replacement characters is shorter than P, then no character is copied to the result string.  Note that the third argument must be present, but it can be a zero-length string. In this case, any character present in the second argument is removed from the supplied string.  If a character appears more than once in the list of characters to be replaced, the second and subsequent occurrences are ignored, as are the characters in the corresponding position in the third argument.  If the third argument is longer than the second, excess characters are ignored.  897   The Function Library  In these rules a character means an XML character, not a 16-bit Unicode code. This means that a Unicode surrogate pair  a pair of 16-bit values used to represent a Unicode character in the range x10000 to x10FFFF  is treated as a single character, whichever of the three strings it appears in.  Examples Expression  translate "aba12", "abcd", "ABCD"   translate "aba121", "12", ""  translate "a\b\c.xml", "\", " "  translate "5,000.00", ".,", ",."   Result  "ABA12"  "aba"  "a b c.xml"  "5.000,00"  Usage and Examples Many of the XPath 1.0 use cases for the translate   function can now be achieved more conveniently in XPath 2.0 by other more powerful functions, such as matches   and replace  .  In an XSLT stylesheet you might see the translate   function being used to perform simple case conversion, for example:  translate $X,  ’abcdefghijklmnopqrstuvwxyz’, ’ABCDEFGHIJKLMNOPQRSTUVWXYZ’   This can now be done much better using the upper-case   and lower-case   functions.  The translate   function is useful to remove extraneous punctuation or whitespace; for example, to remove all whitespace, hyphens, and parentheses from a telephone number, write:  translate $X, ’&x20;&x9;&xA;&xD;  -’, ’’   Another use for translate   is to test for the presence of a particular character or range of characters. For example, to test whether a string contains a sequence of three or more ASCII digits, write:  contains translate $X, ’0123456789’, ’9999999999’ , ’999’   Of course, you could do this equally well using «matches $X, ’[0-9]{3}’ ». The translate   function can be surprisingly powerful. For example, to remove all characters other than digits from a string, you can write:  translate $X, translate $X, ’0123456789’, ’’ , ’’   The inner call on translate   strips the digits from $X, thus building a list of characters that appear in $X and are not digits. The outer call processes $X again, this time removing the non-digit characters.  See Also contains   on page 730 matches   on page 828  898   type-available  replace   on page 862 substring   on page 883 substring-after   on page 885 substring-before   on page 887  true This function returns the boolean value true.  Changes in 2.0 None.  Signature This function takes no arguments.  Result  Type  xs:boolean  Meaning The xs:boolean value true  Effect There are no boolean constants available in XPath expressions, so the functions true   and false   can be used where a constant boolean value is required.  Usage The most common occasion where constant boolean values are required is when supplying an argument to a function or to an XSLT template. See the example below.  XSLT Example The following code calls a named template, setting the parameter «verbose» to true:           13  T h e  F u n c t i o n  i  L b r a r y  See Also false   on page 779  type-available This function is available in XSLT only.  This function is used to test whether a particular schema type is available in the static context.  For example, the expression «type-available ’xs:integer’ » returns true.  899   The Function Library  Signature Argument name  Type  xs:string  Meaning The name of the type being tested. The string must take the form of a lexical QName.  Result  xs:boolean  true if the named type is available in the static context, false otherwise.                          Effect The ﬁrst argument must take the form of a lexical QName; that is, an XML name with an optional name- space preﬁx that corresponds to a namespace declaration that is in scope at the point in the stylesheet where the type-available   function is called. If the name is unpreﬁxed, then the default namespace from the stylesheet  deﬁned by «xmlns="some.uri"»  is assumed.  With a basic XSLT processor  the minimal conformance level , the function returns true if the name is one of the following:  One of the schema primitive types available in every XSLT processor: xs:string, xs:boolean, xs:decimal, xs:double, xs:float, xs:date, xs:time, xs:dateTime, xs:duration, xs:QName, xs:anyURI, xs:gDay, xs:gMonthDay, xs:gMonth, xs:gYearMonth, xs:gYear, xs:base64Binary, or xs:hexBinary One of the derived built-in types available in every XSLT processor: xs:integer, xs:yearMonth- Duration, xs:dayTimeDuration One of the special types xs:anyType, xs:anySimpleType, xs:anyAtomicType, xs:untyped, xs:untypedAtomic  With a schema-aware XSLT processor the function will also return true if the type is one of:  The abstract primitive type xs:NOTATION One of the derived built-in numeric types xs:nonPositiveInteger, xs:negativeInteger, xs:long, xs:int, xs:short, xs:byte, xs:nonNegativeInteger, xs:unsignedLong, xs:unsignedInt, xs:unsignedShort, xs:unsignedByte, xs:positiveInteger One of the derived built-in string types xs:normalizedString, xs:token, xs:language, xs:NMTOKEN, xs:Name, xs:NCName, xs:ID, xs:IDREF, xs:ENTITY One of the built-in list types xs:ENTITIES, xs:IDREFS, xs:NMTOKENS A user-deﬁned simple type or complex type deﬁned in a schema that has been imported using an   declaration  Vendors are allowed to deﬁne additional types in their own namespace, and type-available   can also be used to test for these types.  Usage The stated purpose of this function is to allow you to test whether a particular type is available for use, so that you can conditionally exclude code that refers to a type if it is not available. However, its practical usefuless is limited by the fact that types imported using   are not available in the static context for an [xsl:]use-when expression, which means that testing for the availability of a user-deﬁned type in [xsl:]use-when will always return false.  900   In practice, therefore, this function is only likely to be useful when testing for vendor-deﬁned types which might be imported implicitly.  unordered  See Also element-available   on page 764 function-available   on page 792 system-property   on page 890   in Chapter 6, page 316  unordered The formal deﬁnition of the unordered   function is that it returns a sequence that is an arbitrary reorder- ing of the sequence provided as its argument. In practice, this is really a pseudo-function — wrapping an expression in a call of unordered   tells the XPath processor that you don’t care what order the results of that expression are in, which means that the processor might be able to avoid the cost of sorting them into the right order.  For example, «unordered ancestor::* » returns the ancestor elements in whatever order the system ﬁnds most convenient.  In Saxon, it currently returns them in reverse document order, that is, innermost ancestor ﬁrst.   Signature Argument sequence  Result  Type  item  *  item  *  Meaning The supplied sequence  A sequence that contains the same items as the supplied sequence, but in an arbitrary order  Effect The ordering of the items in the result is arbitrary, which means the processor can choose any order it likes. This doesn’t mean it has to be a randomized order; on the contrary, the system might well choose to return the original order unchanged. In fact, it would be completely conformant with the speciﬁcation for this function to be implemented as a no-operation. It’s really best to think of it as an optimization hint.  Note that although the unordered   function allows the system to return the results of the argument expression in any order, it doesn’t absolve it from the need to eliminate duplicates. In practice this reduces the possibilities available to an optimizer considerably; for example, in forming a union between two sequences of nodes «$A$B», the system is required both to sort the result in document order and to remove duplicates. Writing it as «unordered $A$B » removes the requirement to sort the results, but not the requirement to eliminate duplicates. Since the system is very likely to eliminate duplicates as a by-product of sorting, this might not result in any changes to the execution strategy chosen by the optimizer.  Usage and Examples Because the XPath data model is deﬁned in terms of sequences rather than sets, the ordering of the results of an expression is usually well deﬁned. For example, the results of a path expression are always in document order, and the results of the index-of   function are deﬁned to be in ascending numeric order. By enclosing such expressions in a call of unordered  , you can tell the system that you don’t care  13  T h e  F u n c t i o n  i  L b r a r y  901   The Function Library  about the order. For example, «unordered preceding-sibling::* » returns the preceding siblings of the context node in an arbitrary order, rather than in document order as usual. In the current version of Saxon, the preceding siblings will be returned in reverse document order, because that is the fastest way of ﬁnding them, but you should not rely on this behavior as it may vary from one product to another and might depend on other circumstances.  Some functions take a sequence as an argument and produce a result that doesn’t depend on the order of the items in the sequence. Obvious examples are count   and sum  . In such cases, it’s reasonable to assume that the optimizer will insert a call on unordered   automatically, and that you don’t need to do it yourself: «count unordered X  » gives the same result as «count X », and removes the need to sort the items in X into the right order.  The place where the unordered   function really comes into its own is in handling joins, for example:    customer order[@prod-code =   product[supplier=$s] @code]  or equivalently:  return $o  for $o in   customer order,  $p in   product[supplier=$s][@code=$o @prod-code]  There are many different ways of writing join expressions in XPath, just as there are in SQL, and it’s often the case that you are only interested in knowing which elements are selected, not in getting them back in a particular order. If you make it clear that you don’t care about the order, by wrapping the join expression in a call on the unordered   function, then the system can select from a wider choice of possible access paths to retrieve the data. This is particularly true if there are indexes to the data, which is likely if it is stored in an XML database.  unparsed-entity-public-id, unparsed-entity-uri These two functions are available in XSLT only.  These functions give access to the public identiﬁer and system identiﬁer of unparsed entities declared in the DTD of the source document.  Changes in 2.0 The unparsed-entity-public-id   function is new in XSLT 2.0.  Signatures  The unparsed-entity-public-id   function Meaning Argument Speciﬁes the name of the unparsed entity required. The value of name the string should be an XML Name.  xs:string  Type  Result  xs:string  The public identiﬁer of the unparsed entity with the given name, if there is one. Otherwise, a zero-length string.  902   unparsed-entity-public-id, unparsed-entity-uri  The unparsed-entity-uri   function Argument name  xs:string  Type  Result  xs:anyURI  Meaning Speciﬁes the name of the unparsed entity required. The value of the string should be an XML Name.  The URI  system identiﬁer  of the unparsed entity with the given name, if there is one. Otherwise, a zero-length string.  Effect These two functions operate on the document containing the context node. An error is reported if the con- text item is undeﬁned, or if it is not a node, or if it is a node in a tree whose root is not a document node.  If the document containing the context node includes an unparsed entity whose name is equal to the supplied string, then the unparsed-entity-public-id   function will return the public identiﬁer of the entity if it has one  signaled by the PUBLIC keyword in XML , while the unparsed-entity-uri   function will return its system identiﬁer. In all other cases, the functions return a zero-length string.  If the system identiﬁer is given in the source XML as a relative URI reference, the XSLT processor should expand it into an absolute URI before returning it.  Usage An unparsed entity is an entity deﬁned in the DTD using a declaration of the form:     It’s the NDATA  meaning ‘‘not XML data’’  that makes it an unparsed entity; and because it is an unparsed entity, it can’t be referenced using a normal entity reference of the form «&weather-map;» but must instead be referenced by name in an attribute of type ENTITY or ENTITIES; for example, <forecast map="weather-map">.  If you’re using a schema-aware XSLT processor, and the document has been validated against a schema that deﬁnes the map attribute as being of type xs:ENTITY, then you can process the attribute using a rule such as:  13  T h e  F u n c t i o n  i  L b r a r y           Without a schema, you are simply expected to know that the map attribute is of type xs:ENTITY, and expected to pick up the attribute value in a call such as «unparsed-entity-uri @map ». This call returns the absolute URI of the actual resource, that is, something like «file:   c: documents  forecasts weather.jpeg».  Unparsed entities are one of the more rarely used features of XML; they derive from SGML, and this explains why people who use unparsed entities are also inclined to use public identiﬁers to refer to them. Public identiﬁers were designed to tackle the same problem as URNs, namely to provide a way of giving unique names to objects, without becoming locked in to the location where the object can be found. They are often used in conjunction with Oasis catalogs.  903   The Function Library  Note that it is the public and system identiﬁer of the unparsed entity that is returned, not the public and system identiﬁer of the notation named in its NDATA clause. XSLT provides no way of ﬁnding out the notation name  «JPEG» in our example  or the URI for the notation, so even if you have a schema that ﬂags the attribute as one that contains an unparsed entity reference, you still have to know what kind of reference you are expecting.  This is not exactly in the spirit of section 4.4.6 of the XML speciﬁcation, which states: ‘‘When the name of an unparsed entity appears as a token in an attribute of declared type ENTITY or ENTITIES, a validating processor must inform the application of the system and public  if any  identiﬁers for both the entity and its associated notation.’’ However, unparsed entities are hardly XML’s most widely used feature, so it is unsurprising that XSLT support for them should be incomplete.  The rules in the XSLT speciﬁcation don’t explicitly state this, but in practice, if you use a nonvalidating XML parser to process the source document, the parser isn’t obliged to pass information to the XSLT processor about unparsed entities declared in the external subset of the DTD, and the unparsed-entity- public-id   and unparsed-entity-uri   functions are therefore likely to return a zero-length string. If this happens, try using a validating XML parser — assuming of course that the source document is valid.  Examples If the DTD contains the declaration:  <!ENTITY weather-map SYSTEM "weather.jpeg"  PUBLIC "-  MEGACORP  WEATHER " NDATA JPEG>  then the expression «unparsed-entity-public-id ’weather-map’ » returns the public identiﬁer «-  MEGACORP  WEATHER ».  Given the entity deﬁnition:     and the entity reference:     the following code will insert an   element into the HTML output:           See Also Trees, Not Documents, in Chapter 2, page 42.  unparsed-text, unparsed-text-available These two functions are available in XSLT only.  The unparsed-text   function returns the content of an external ﬁle in the form of a string. Its compan- ion function, unparsed-text-available  , tests whether a call on unparsed-text   would succeed.  904   unparsed-text, unparsed-text-available  Signatures The unparsed-text   function Argument href  Type  xs:string?  Meaning The URI of the external text ﬁle to be loaded. If an empty sequence is supplied, the result is an empty sequence.  encoding  optional   Result  xs:string  The character encoding of the text in the ﬁle.  xs:string?  The textual content of the ﬁle.  The unparsed-text-available   function Argument href  xs:string?  Type  encoding  optional   xs:string?  Result  xs:boolean  Meaning The URI of the external text ﬁle to be loaded. If an empty sequence is supplied, the result is false.  The character encoding of the text in the ﬁle. If an empty sequence is supplied, the function behaves as if the argument were omitted.  True if a call on unparsed-text   with the same arguments would succeed; false if it would fail.  Effect This pair of functions is analogous to the doc   doc-available   pair described on page 750, except that the ﬁle referenced by the URI is treated as text rather than as XML. The ﬁle is located and its textual content is returned as the result of the unparsed-text   function, in the form of a string.  The value of the href argument is a URI. It mustn’t contain a fragment identiﬁer  the part marked with a «» sign . It may be an absolute URI or a relative URI reference; if it is relative, it is resolved against the base URI of the stylesheet. This is true even if the relative reference is contained in a node in a source document. In this situation it is a good idea to resolve the URI yourself before calling this function. For example, if the reference is in an attribute called src then the call might be «unparsed-text resolve- uri @src, base-uri @src   ». The resolve-uri   function is described on page 867; its ﬁrst argument is the relative reference, and the second argument is the base URI used to resolve it.  The optional encoding argument speciﬁes the character encoding of the ﬁle. This can be any character encoding supported by the implementation; the only encodings that an implementation must support are UTF-8 and UTF-16. The system will not necessarily use this encoding: the rules for deciding an encoding are as follows and are based on the rules given in the XLink recommendation:        First, the processor looks for so-called external encoding information. This typically means infor- mation supplied in an HTTP header, but the term is general and could apply to any metadata associated with the ﬁle, for example WebDAV properties. Next, it looks at the media type  MIME type , and if this identiﬁes the ﬁle as XML, then it deter- mines the encoding using the same rules as an XML parser  for example, it looks for an XML dec- laration, and if there is none, it looks for a byte order mark .  Why would you use this function, rather than doc  , to access an XML document? The thinking is that it is quite common for one XML document to act as an envelope for another XML document that  905  13  T h e  F u n c t i o n  i  L b r a r y   The Function Library  is carried transparently in a CDATA section, and if you want to create such a composite document, you will want to read the payload document without parsing it.        Next, it uses the encoding argument if this has been supplied. If there is no encoding argument, the XSLT processor can use ‘‘implementation-deﬁned heuristics’’ to guess the encoding; if that fails, then it tries to use UTF-8 encoding. The term ‘‘implementation-deﬁned heuristics’’ could cover a wide range of strategies, such as recogniz- ing known document types like HTML from the ﬁrst few bytes of the ﬁle, or treating the ﬁle as Windows codepage 1252 if it cannot be decoded as UTF-8.  Various errors can occur in this process, and they are generally fatal. This is why the auxiliary function unparsed-text-available   is provided: if any failure is going to occur when reading the ﬁle, then calling unparsed-text-available   will in effect catch the error before it occurs.  One limitation is that it is not possible to process a ﬁle if it contains characters that are invalid in XML  this applies to most control characters in the range x00 to x1F under XML 1.0, but only to the null character x00 under XML 1.1 .  Usage and Examples There are a number of ways this function can be used, and I will show three. These are as follows:           Up-conversion: that is, loading text that lacks markup in order to generate the XML markup XML envelope payload applications HTML boilerplate generation  Up-Conversion Up-conversion is the name often given to the process of analyzing input data for structure that is implicit in the textual content, and producing as output an XML document in which this structure is revealed by explicit markup. I have used this process, for example, to analyze HTML pages containing census data, in order to clean the data to make it suitable for adding to a structured genealogy database. It can also be used to process data that arrives in non-XML formats such as comma-separated values or EDI syntax.  The unparsed-text   function is not the only way of supplying non-XML data as input to a stylesheet; it can also be done simply by passing a string as the value of a stylesheet parameter. But the unparsed- text   function is particularly useful because the data is referenced by URI, and accessed under the control of the stylesheet.  XSLT 2.0 is much more suitable for use in up-conversion applications than XSLT 1.0. The most important tools are the   instruction, which enables the stylesheet to make use of structure that is implicit in the text, and the   instruction, which makes it much easier to analyze poorly structured markup. These can often be used in tandem: in the ﬁrst stage in processing,   is used to recognize patterns in the text and mark these patterns using ele- ments in a temporary tree, and in the second stage,   is used to turn ﬂat markup structures into hierarchic structures that reﬂect the true data model.  Here is an example of a stylesheet that reads a comma-separated-values ﬁle and turns it into structured markup.  906   unparsed-text, unparsed-text-available  Example: Processing a Comma-Separated-Values File  This example is a stylesheet that reads a comma-separated-values ﬁle, given the URI of the ﬁle as a stylesheet parameter. It outputs an XML representation of this ﬁle, placing the rows in a   element and each value in a   element. It does not attempt to process a header row containing ﬁeld names, but this would be a simple extension.  This stylesheet does not use any source XML document. Instead, it expects the URI of an ordinary text ﬁle to be supplied as a parameter to the stylesheet. This is what the input ﬁle names.csv looks like.  123,"Mary Jones","IBM","USA",1997-05-14 423,"Barbara Smith","General Motors","USA",1996-03-12 6721,"Martin McDougall","British Airways","UK",2001-01-15 830,"Jonathan Perkins","Springer Verlag","Germany",2000-11-17  Input  Stylesheet  This stylesheet analyze-names.xsl uses a named template main as its entry point: a new feature in XSLT 2.0. The command for running the stylesheet under Saxon 9.0 looks like this.  java -jar saxon9.jar -it:main -xsl:analyze-names.xsl input-uri=names.csv  The -it option here indicates that processing should start without an XML source document, at the named template main. The stylesheet ﬁrst reads the input ﬁle using the unparsed-text   function, and then uses two levels of processing using   to identify the structure. The ﬁrst level  using the regex «\n»  splits the input into lines. The second level is explained more fully under the description of the regex-group   function on page 860: it extracts either the contents of a quoted string, or any value terminated by a comma, and copies this to a   element.    <xsl:stylesheet xmlns:xsl="http:  www.w3.org 1999 XSL Transform"  13  T h e  F u n c t i o n  i  L b r a r y  xmlns:xs="http:  www.w3.org 2001 XMLSchema" version="2.0">         <xsl:variable name="in"          select="unparsed-text $input-uri, ’iso-8859-1’ " >  907   The Function Library                                               Output  The output is as follows:                     123   Mary Jones   IBM   USA    423   Barbara Smith   General Motors   USA    6721   Martin McDougall   British Airways   UK    830   Jonathan Perkins   Springer Verlag   Germany         908   unparsed-text, unparsed-text-available  XML Envelope Payload Applications It is not uncommon to ﬁnd structures in which one XML document is wrapped in a CDATA section inside another. For example:      ...             . . . ]]>  I don’t normally recommend this as a good way of designing nested structures. In general, it is usually better to nest the structure directly, without using CDATA. That is, to use:      ...             ...   But sometimes you don’t get to design the documents yourself; and there are some advantages for the CDATA approach, such as the ability for the payload document to include a DOCTYPE declaration.  Handling such structures in XSLT is not easy: the payload document is presented as a single text node, not as a tree of element nodes. However, the unparsed-text   function makes it much easier to output such structures. All you need to do is:          ...               HTML Boilerplate Generation Generally, it is best to think of HTML in terms of a tree of element and text nodes, and to manipulate it as such in the stylesheet. Occasionally, you may need to process HTML that is not well formed, and cannot easily be converted into a well-formed structure. For example, you may be dealing with a syndicated news feed that arrives in HTML, whose format is sufﬁciently unpredictable that you don’t want to rely on tools that automatically turn the HTML into structured XHTML. You might want to output the HTML news stories embedded in your own XSLT-generated pages.  An option in such cases is to treat the HTML as unparsed text rather than as a tree of nodes. You can read the HTML news feed using the unparsed-text   function, and you can output it to the serialized result, using the disable-output-escaping option, provided your processor supports this.  <xsl:value-of select="unparsed-text ’news.html’ "  disable-output-escaping="yes" >  13  T h e  F u n c t i o n  i  L b r a r y  909   The Function Library  Remember when you use disable-output-escaping that not all processors support the feature and that it works only if the output of the stylesheet is serialized. You can’t always tell whether the output is going to be serialized or not; for example, if you run a transformation in Internet Explorer, the output HTML is serialized and then reparsed before being displayed, but if you run the same transformation in the Firefox browser, the result tree is passed directly to the rendering engine, bypassing the serialization stage. This means that disable-output-escaping doesn’t work with a client-side transformation in Firefox.  See Also   on page 230 in Chapter 6  upper-case The upper-case   function converts lower-case characters in a string to upper case.  Signature Argument value  Result  Type  xs:string?  xs:string  Meaning The string to be converted  The string with lower-case letters converted to upper case  Effect See the entry for lower-case   on page 827 for a description of how this function is deﬁned in terms of Unicode case mappings.  The effect of the function is as follows:        If the input is an empty sequence, the result is the zero-length string. Otherwise, every character in the input string is replaced by its corresponding upper-case character  or sequence of characters  if there is one, or is included unchanged in the result string if not.  The function does not implement case mappings that Unicode deﬁnes as being locale-sensitive  such as the Turkish dotless I .  Result  "SUNDAY"  "2+2"  "C´ESAR"  "E  A "  Examples Expression  upper-case "Sunday"   upper-case "2+2"   upper-case "c´esar"   upper-case "ελλα "   Usage See lower-case   on page 827  910   years-from-duration  See Also lower-case   on page 827 translate   on page 897  Signature Argument input  Type xs:date? or xs:dateTime?  Result  xs:integer  year-from-date, year-from-dateTime These two functions extract the year component from an xs:date or xs:dateTime value. For example, «year-from-date current-date   » might return 2008.  Meaning The value from which the year component is to be extracted. The type of the supplied argument must correspond to the type implied by the function name. If an empty sequence is supplied, an empty sequence is returned.  The year. The range of values is implementation-deﬁned; negative years  representing BC dates  are allowed.  Effect The function returns the year component of the supplied xs:date or xs:dateTime. The value is used in its local timezone  not normalized to UTC .  Examples Expression  year-from-date xs:date "2008-02-28"    year-from-dateTime xs:dateTime "1969-07-20T16:17:00-04:00"    See Also current-date  , -dateTime  ,-time   on page 738 format-date  , -dateTime  , -time   on page 781 day-from-date  , -dateTime   on page 744 month-from-date  , -dateTime   on page 833  years-from-duration This function extracts the value of the years component from a normalized xs:duration value.  Signature Argument input  Result  Type  xs:duration  xs:integer  Meaning The value from which the component is to be extracted  The years component  13  T h e  F u n c t i o n  i  L b r a r y  Result  2008  1969  911   The Function Library  Effect The function returns the years component of the supplied xs:duration. The duration value is ﬁrst normalized so that the number of months is less than 12. The result will be negative if the duration is negative.  Examples Expression  years-from-duration xs:yearMonthDuration "P1200Y"    years-from-duration xs:duration "P18 M"    years-from-duration xs:duration "-P3Y6 M"    years-from-duration xs:dayTimeDuration ’P8000D’    See Also months-from-duration on page 834  Result  1200  1  0  -3  zero-or-one The zero-or-one   function returns its argument unchanged, provided that it is a sequence containing no more than one item. In other cases, it reports an error.  Signature Argument value  Type  item  *  Result  item    Meaning The input value. Although the function signature says that any sequence of items is allowed, a runtime error will occur if the number of items is not zero or one.  The same as the supplied value, after checking to ensure that it is either an empty sequence or contains a single item.  Effect The zero-or-one   function returns its argument unchanged, provided that it is a sequence containing no more than one item. In other cases, it reports an error.  This function is useful with XPath processors that perform static type-checking, as described in Chapter 5. Calling this function acts as a promise by the programmer that the argument will be a sequence that is either empty, or contains exactly one item. This allows the expression to be used in contexts that require an optional single value  for example, the argument of a function such as root    when the pro- cessor might otherwise have reported a static type error. The XPath expression is still type-safe, because the check that the sequence does indeed contain a single item will be done at runtime, just as it would with a processor that does not enforce static type checking.  Examples Assume the source document:     912   Summary  with a schema that deﬁnes the colors attribute with type xs:NMTOKENS  that is, it allows a list of colors to be speciﬁed, but our sample document only speciﬁes one .  Expression  string @colors   Result Succeeds unless the processor is doing static type checking, in which case it gives a compile-time error because the argument to string   must be a sequence of zero or one items  string  zero-or- one @colors    Succeeds whether the processor is doing static type checking or not, because the check that the typed value of @colors contains at most one item is deferred until runtime  Usage This function is never needed unless you are using a processor that does static type checking.  However, you may still ﬁnd it useful as a way of inserting runtime checks into your XPath expressions, and documenting the assumptions you are making about the input data.  See Also exactly-one   on page 777 one-or-more   on page 853  Summar y  Much of the power of any programming language comes from its function library, which is why this chapter explaining the function library is one of the longest in the book. The size of the function library has grown greatly since XSLT and XPath 1.0, largely because of the richer set of types supported.  The next chapter deﬁnes the syntax of the regular expressions accepted by the three functions matches  , replace  , and tokenize  , and by the XSLT instruction  .  13  T h e  F u n c t i o n  i  L b r a r y  913    Regular Expressions  This chapter deﬁnes the regular expression syntax accepted by the XPath functions matches  , replace  , and tokenize  , which were described in the previous chapter, as well as the   instruction described in Chapter 6.  This regular expression syntax is based on the deﬁnition in XML Schema, which in turn is based on the deﬁnition in the Perl language, which is generally taken as the deﬁnitive reference for regular expres- sions. However, all dialects of regular expression syntax have minor variations. Within Perl itself there are features that are deprecated, there are features that differ between Perl versions, and there are features that don’t apply when all characters are Unicode.  XML Schema deﬁnes a subset of the Perl regular expression syntax; it chose this subset based on the requirements of a language that only does validation  that is, testing whether or not a string matches the pattern  and that only deals with Unicode strings. The requirements of the matches   function in XPath are similar, but XPath also uses regular expressions for tokenizing strings and for replacing substrings. These are more complex requirements, so some of Perl’s regular expression constructs that XML Schema left out have been added back in for XPath.  In the grammar productions in this chapter, as elsewhere in the book, I generally enclose characters of the target language  that is, the regex language  in chevrons, for example «». I have avoided using the more concise notation «[abcd]» because I think it is confusing to use regular expressions when deﬁning regular expressions. If a character is not enclosed in chevrons, then it is either the name of another non-terminal symbol in the grammar, or a symbol that has a special meaning in the grammar.  The description of the syntax of regular expressions closely follows the description given in the XML Schema Recommendation. You can ﬁnd this in Appendix F of Schema Part 2. The second edition corrects numerous errors in the original. The latest version of the Recommendation can be found at http:  www.w3.org TR xmlschema-2.  Remember that the syntax rules given here apply to the regular expression after it has been preprocessed by the host language.     If a regular expression is used within an XML document  for example, an XSLT stylesheet , then special characters such as «&» must be escaped using XML entity or character references such as «&amp;». If it appears within an XSLT attribute value template  for example, in the regex attribute of   , then curly braces must be doubled. If it appears within an XPath string literal, then any apostrophe or quotation mark that matches the string delim- iters must be doubled.  14  R e g u a r  l  E x p r e s s o n s  i   Regular Expressions     On the other hand, if your XPath expression is written as a string literal within a host language such as Java or C, then a backslash will need to be written as «\\»  which means that a regular expression to match a single backslash character becomes «\\\\» .  Branches and Pieces  The top-level syntax of a regular expression  regex  is described by the following rules:  Construct  regex  branch  piece  Syntax  piece*  branch  «» branch  *  atom quantifier?  A regular expression consists of one or more branches, separated by «» characters. For example, «abcdef» matches either of the strings «abc» or «def». A regex matches a string if any of the branches matches the string. If more than one branch leads to a match, then the one that is chosen is the ﬁrst one that matches  starting from the left .  A branch consists of one or more pieces, concatenated together. A branch consisting of two pieces A and B matches a string if the string can be split into two substrings, with the ﬁrst substring matching A and the second matching B. For example, «def» is the concatenation of three pieces, «d», «e», and «f», and it matches a string consisting of a «d» followed by an «e» followed by an «f». The regex «[a-z][0-9]» consists of two pieces, «[a-z]» and «[0-9]», and it matches any string that consists of a letter in the range «[a-z]» followed by a digit in the range «[0-9]».  A piece is an atom, optionally followed by a quantiﬁer. Quantiﬁers are described in the next section.  Unlike content models in XML Schema, there are no rules preventing ambiguities or backtracking in a regular expression. It is perfectly legal to have a regex with two branches that both match the same string, or to have two branches that start with the same characters, for example «abcabd».  Quantiﬁers indicate whether, and how often, a construct may be repeated. The syntax is as follows:  Quantiﬁers  Construct  quantifier  indicator  quantity  quantRange  quantMin  quantExact  Digit  916  Syntax  indicator «?»? «?»  «*»  «+»    «{» quantity «}»   quantRange  quantMin  quantExact  quantExact «,» quantExact  quantExact «,»  Digit+  «0»«1»«2»«3»«4»«5»«6»«7»«8»«9»   Atoms  A quantifier is either one of the symbols «?», «*», or «+», or a quantity enclosed between curly braces. A quantiﬁer may be followed by «?» to indicate that it is a non-greedy quantiﬁer.  A quantity is either a number, or a number followed by a comma, or two numbers separated by a comma: number here means a sequence of one or more digits.  The piece «A?» matches a single «A» or a zero-length string; «A*» matches a sequence of zero or more «A»s, while «A+» matches a sequence of one or more «A»s. The piece «A{3}» matches a sequence of exactly three «A»s; «A{3,}» matches a sequence of three or more «A»s, and «A{3,5}» matches a sequence of at least three and at most ﬁve «A»s. By default, quantiﬁers are greedy — they match as many occurrences of the relevant characters as they can, subject to the regex as a whole succeeding. For example, given the input string «17 c  ii », the regular expression «\ .*\ $» will match the substring « c  ii ». Adding a «?» after the quantiﬁer makes it non-greedy, so the regex «\ .*?\ $» will match the substring « c ». This doesn’t affect the matches   function, which is only concerned with knowing whether or not there is a match, but it does affect replace   and tokenize  , and XSLT’s  , which also need to know which particular characters matched the regex.  Atoms  Atoms are the parts of a regular expression that match speciﬁed characters. The various options are deﬁned by the syntax below.  Construct  Syntax  atom  Char  charClass  charClassExpr  backReference  Char  charClass  backReference    « » regex « »   Any XML character except . \ ? * +  ^ $ { }     [ ] charClassEsc  charClassExpr  «.»  «^»  «$»  «[» charGroup «]» «\» [1-9] [0-9]*  An atom is either a normal character, a character class, a back-reference, or a regex enclosed in parentheses. A normal character  Char  is any character except «.», «\», «?», «*», «+», «», «^», «$», «{», «}», « », « », «[» and «]». A normal character matches itself, and if the «i» ﬂag is used, it also matches upper- and lower-case variants of itself  for a more precise deﬁnition see Flags on page 925 .  A character class  charClass  is either a character class escape or a character class expression, or one of the metacharacters «.», «^», or «$». We will see what a character class escape is later, on page 920.  The metacharacter «.» in a regex matches any single character except a newline character  x0A , except when the «s»  dot-all  ﬂag is set, in which case it matches any character including a newline.  The metacharacters «^» and «$» match the beginning and end of the input string, respectively, except when the «m»  multiline  ﬂag is set, in which case they match the beginning and end of each line.  14  R e g u a r  l  E x p r e s s o n s  i  917   Regular Expressions  The beginning of a line is either the start of the entire string or the position immediately after a newline  x0A  character; the end of a line is either the end of the entire string or the position imme- diately before a newline character. So  with multiline mode off  the regex «^The» matches a string that begins with the characters «The», while the regex «\.xml$» matches a string that ends with the characters «.xml».  A character class expression is a character group enclosed in square brackets, for example «[A-Z]». Character groups are described on page 919. A character group deﬁnes a set of permitted characters; it matches a single character from the input if the character is a member of this set.  Subexpressions  An atom written in the form of a regular expression within parentheses is referred to as a subexpression  or group . Subexpressions serve two main purposes:        They allow a sequence of characters to be deﬁned as repeated or optional. For example, the regex « [0-9], *[0-9]» matches strings such as «1,2,3» or «8,0». They allow the application to determine which parts of the input string were matched by particular parts of the regular expression. For example, when the string «12 September 2008» is matched by the regex « [0-9]+ \s [A-Za-z]+ \s [0-9]+ », three groups are captured, corresponding to the three parenthesized subexpressions: group 1 is the string «12», group 2 is the string «September», and group 3 is the string «2008». Note that when a parenthesized subexpression has a quantiﬁer, or when it is within an enclosing construct that allows repe- tition, it is the last matching substring that is accessible as the content of the corresponding group.  Subexpressions can be nested. They are numbered according to the position of the opening parenthesis, counting from the left. For example, when the string «12 September 2008» is matched by the regex « [0-9]+ \s  [A-Z]  [a-z]+  \s [0-9]* », group 2 will be «September», group 3 will be «S», and group 4 will be «eptember».  In the replace   function, groups can be referenced within the replacement string using a character sequence such as «$1» or «$2». For example, the result of «replace ‘12 September 2008’, ‘ [0-9]+ \s [A-Za-z]+ \s [0-9]+ ’, ‘$2 $1, $3’ » will be «September 12, 2008». Within the   instruction, the contents of matched groups of characters can be referenced using the regex-group   function, described on page 860 in Chapter 13.  Back-References  A back-reference can be used to refer to a captured group from within the regular expression itself. A back-reference is written as a backslash followed by a positive number. Back-references are often used to match opening and closing quotes; for example, the regex « [’"] .*\1» matches the strings «"Hello"» and «‘Hello’» but not «"Hello’». A single digit following a «\» is always recognized as part of the back-reference; subsequent digits are recognized as part of the back-reference only if there are sufﬁciently many parenthesized subexpressions earlier in the regex. For example, «\15» is recognized as a back-reference only if there are at least 15 parenthesized subexpressions preceding it in the regular expression; if this is not the case, then it is interpreted as a back-reference «\1» followed by the digit «5».  918   Character Ranges  Character Groups  A character group always appears within square brackets; it deﬁnes a set of permitted characters, and matches a single character from the input string if it is a member of that set. There are various ways the set of permitted characters can be deﬁned, using the following syntax: Construct  Syntax  charGroup  posCharGroup  negCharGroup  charClassSub  posCharGroup  negCharGroup  charClassSub    charRange  charClassEsc  +  «^» posCharGroup    posCharGroup  negCharGroup   «-» charClassExpr  A character group is either a positive group, a negative group, or a subtraction. Examples of the three kinds are «[a-z]», «[^0-9]», and «[a-z-[pqr]]».  A positive group  posCharGroup  consists of a sequence of one or more parts, each of which is either a character range or a character class escape. A positive group matches a character if any one of its parts matches the character. For example, «[a-zA-Z0-9%]» matches any character that falls in one of the ranges «a» to «z», «A» to «Z», or «0» to «9», as well as the «%» and «» characters.  A negative group  negCharGroup  consists of a circumﬂex «^» followed by a positive group. A negative group matches any character that is not matched by the corresponding positive group. For example, the negative group «[^abc]» matches any character except «a», «b», or «c».  A subtraction  charClassSub  consists of either a positive group or a negative group, followed by the «-» symbol, followed by a character class expression  which, as we saw earlier, is a character group enclosed in square brackets . A subtraction matches any character that matches the group preceding the «-» operator, provided it does not also match the character class expression following the «-» operator. For example, «[0-9-[5]]» matches any digit except «5».  Character Ranges  A character range  which is always part of a character group  deﬁnes a set of permitted characters that contains either a single character or a range of characters occupying adjacent Unicode codepoints.  If you are comparing these rules with the ones in XML Schema Part 2, be sure to look at the second edition; the original XML Schema Recommendation got this syntax badly wrong. In fact, there are still a couple of errors in the second edition.  14  R e g u a r  l  E x p r e s s o n s  i  codepointRange  charOrEsc «-» charOrEsc  Construct  charRange  charOrEsc  XmlChar  XmlCharIncDash  Syntax  codepointRange  XmlCharIncDash  XmlChar  SingleCharEsc Any XML character except «[» «]» «\» «-» Any XML character except «[» «]» «\»  919   Regular Expressions  A character range is either a codepoint range or a single character  XMLCharIncDash .  A codepoint range, for example, «a-z», consists of two characters, or single character escapes, separated by a «-» character. The Unicode codepoint for the second character must be greater than or equal to the codepoint for the ﬁrst. Specifying a codepoint range is equivalent to listing all the Unicode characters with codepoints in that range, for example «[0-9]» is equivalent to «[0123456789]».  A single character is any character permitted by the XML speciﬁcation, other than the three characters listed: «[», «]», and «\». There is an additional rule not shown in the grammar: if «^» appears at the start of a character group, then it is taken to indicate that the group is a negative character group. This means that it can’t appear at the start of a positive character group, except in the case where the positive character group is part of a negative character group.  You can’t have a double negative, so «[^^]» matches any character except a circumﬂex.   There has been a lot of confusion about whether and where hyphens are allowed within square brackets, other than their two special meanings to indicate a codepoint range such as [0-9] and a subtraction such as [A-Z-[IO]]. At one stage an erratum was issued making any usage such as [+-] invalid, but this was subsequently withdrawn. In the second edition of XML Schema Part 2, the grammar and the textual narrative are inconsistent. If you want to be safe, escape any hyphen that is intended to represent the hyphen character itself, for example [+\-].  Single character escapes are described in the following section.  Character Class Escapes  The next table describes various constructs introduced with a backslash  «\» . These constructs are known collectively as character class escapes  charClassEsc ; each character class escape deﬁnes a subset of the Unicode character set, and it can appear either at the top level of a regular expression  as an atom , or within square brackets. Within this category, a single character escape  SingleCharEsc  represents a single Unicode character; these can also appear as the start or end of a character range, as we saw in the previous section.  Construct  charClassEsc  SingleCharEsc  MultiCharEsc  catEsc  complEsc  charProp  Category  IsBlock  920  Syntax  SingleCharEsc  MultiCharEsc  catEsc  complEsc «\»   «n»«r»«t»«\»«»«.»«?» «*»«+»« »« »«{»«}»«-»«[»«]»«^»«$»  «\»  «s»«S»«i»«I»«c»«C»«d» «D»«w»«W»  «\p {» charProp «}» «\P {» charProp «}» Category  IsBlock  One of the two-character codes listed in the section Character Categories on page 924  «Is» BlockName  where BlockName is the name of one of the Unicode code blocks listed in the section Character Blocks on page 922   Character Class Escapes  A character class escape deﬁnes a set of characters, and matches any single character from this set.  There are four kinds of character class escapes: single character escapes, multicharacter escapes, category escapes, and complementary escapes.  The published XPath Functions and Operators Recommendation deﬁnes a back-reference as a ﬁfth kind of character class escape. This is incorrect, because a back-reference matches a sequence of characters rather than a single character, which means that it makes no sense within square brackets. This is ﬁxed by an erratum to the spec.  A single character escape  SingleCharEsc  consists of a backslash followed by one of the characters shown below. The single character escape matches a single character, as shown in the table.  newline  x0A   Matches  Single character escape «\n» «\r» «\t» «\\» «\» «\.» «\?» «\*» «\+» «\ » «\ » «\{» «\}» «\-» «\[» «\]» «\^» «\$» A multicharacter escape  MultiCharEsc  is a «\» followed by one of the characters shown below. Each multicharacter escape matches one of a number of different characters  but it only matches one character at a time .  The character following the backslash, for example, «\?» matches a question mark  carriage return  x0D   tab  x09   Multicharacter escape Matches «\s» «\i»  space  x20 , tab  x09 , newline  x0A , or carriage return  x0D   An initial name character: speciﬁcally, a character classiﬁed in the XML speciﬁcation as a Letter, or «:» or «_»  «\c»  «\d» «\w»  A name character, as deﬁned by the NameChar production in the XML speciﬁcation A decimal digit: anything that matches «\p{Nd}» A character considered to form part of a word, as distinct from a separator between words: speciﬁcally a character that does not match «\p{P}» or «\p{Z}» or «\p{C}» Any character that does not match «\s» Any character that does not match «\i» Any character that does not match «\c» Any character that does not match «\d» Any character that does not match «\w»  «\S» «\I» «\C» «\D» «\W» The two constructs «\i» and «\c» are deﬁned by reference to the XML speciﬁcation. The deﬁnitions in question have changed slightly between XML 1.0 and XML 1.1. The XPath speciﬁcation leaves it to the implementor to decide whether to use the XML 1.0 or XML 1.1 deﬁnitions. Some products  Saxon is an example  might give you the choice, as a conﬁguration option.  14  R e g u a r  l  E x p r e s s o n s  i  921   Regular Expressions  A category escape «\p{prop}» matches any character with the property prop, as deﬁned in the Unicode character database. A complementary escape «\P{prop}» matches any character that does not have the property prop. The prop may either represent the block of characters being matched or a character cate- gory. The next two sections deﬁne the character blocks and categories.  Character Blocks  Character blocks are simply names for ranges of characters in Unicode. For example, «\p{IsHebrew}» matches any character in the range x0590 to x05FF, while «\P{IsHebrew}» matches any character that is not in this range.  The names of the blocks are listed in the table below. The name of the block is preceded by «Is» in the regular expression, which then matches any character in the block. Note that some of the blocks  such as PrivateUse  map to several ranges of codes. Range x0000-x007F  Range x0D00-x0D7F Malayalam  Name BasicLatin  Name  x0080-x00FF  Latin-1Supplement  x0D80-x0DFF  Sinhala  x0100-x017F  LatinExtended-A  x0180-x024F  LatinExtended-B  x0E00-x0E7F  x0E80-x0EFF  Thai  Lao  x0250-x02AF  IPAExtensions  x0F00-x0FFF  Tibetan  x02B0-x02FF  SpacingModiﬁerLetters  x1000-x109F  Myanmar  x0300-x036F  CombiningDiacriticalMarks  x10A0-x10FF  Georgian  x0370-x03FF  x0400-x04FF  Greek  Cyrillic  x0530-x058F  Armenian  x0590-x05FF  Hebrew  x0600-x06FF  x0700-x074F  Arabic  Syriac  x0780-x07BF  Thaana  x0900-x097F  Devanagari  x0980-x09FF  Bengali  x0A00-x0A7F  Gurmukhi  x0A80-x0AFF  Gujarati  x0B00-x0B7F  x0B80-x0BFF  Oriya  Tamil  x0C00-x0C7F  Telugu  x0C80-x0CFF  Kannada  922  x1100-x11FF  HangulJamo  x1200-x137F  Ethiopic  x13A0-x13FF  Cherokee  x1400-x167F  UniﬁedCanadianAboriginal- Syllabics  x1680-x169F  Ogham  x16A0-x16FF  Runic  x1780-x17FF  Khmer  x1800-x18AF Mongolian  x1E00-x1EFF  LatinExtendedAdditional  x1F00-x1FFF  GreekExtended  x2000-x206F  GeneralPunctuation  x2070-x209F  SuperscriptsandSubscripts  x20A0-x20CF  CurrencySymbols  x20D0-x20FF  CombiningMarksforSymbols  x2100-x214F  LetterlikeSymbols  continued   Character Blocks  Range x2150-x218F  Name NumberForms  x2190-x21FF  Arrows  Range x3190-x319F  Name Kanbun  x31A0-x31BF  BopomofoExtended  x2200-x22FF MathematicalOperators  x3200-x32FF  x2300-x23FF MiscellaneousTechnical  x2400-x243F  ControlPictures  x3300-x33FF  x3400-x4 DB5  EnclosedCJKLettersand- Months  CJKCompatibility  CJKUniﬁedIdeographs- ExtensionA  x2440-x245F  OpticalCharacterRecognition  x4E00-x9FFF  CJKUniﬁedIdeographs  x2460-x24FF  EnclosedAlphanumerics  x2500-x257F  BoxDrawing  x2580-x259F  BlockElements  x25A0-x25FF  GeometricShapes  x2600-x26FF MiscellaneousSymbols  x2700-x27BF  Dingbats  x2E80-x2EFF  CJKRadicalsSupplement  x2F00-x2FDF  KangxiRadicals  x2FF0-x2FFF  IdeographicDescription- Characters  xA000-xA48F  xA490-xA4CF  YiSyllables  YiRadicals  xAC00-xD7A3  HangulSyllables  xE000-xF8FF  xF900-xFAFF  xFB00-xFB4F  xFE20-xFE2F  xFE30-xFE4F  xFE50-xFE6F  PrivateUse  CJKCompatibilityIdeographs  AlphabeticPresentationForms  CombiningHalfMarks  CJKCompatibilityForms  SmallFormVariants  x2800-x28FF  BraillePatterns  xFB50-xFDFF  ArabicPresentationForms-A  x3000-x303F  CJKSymbolsandPunctuation  xFE70-xFEFE  ArabicPresentationForms-B  x3040-x309F  Hiragana  x30A0-x30FF  Katakana  x3100-x312F  Bopomofo  x3130-x318F  HangulCompatibilityJamo  xFEFF-xFEFF  Specials  xFF00-xFFEF  HalfwidthandFullwidthForms  xFFF0-xFFFD  Specials  14  R e g u a r  l  E x p r e s s o n s  i  The list above corresponds to XML Schema 1.0 second edition. This removed some blocks that were deﬁned in the ﬁrst edition, notably for characters above xFFFF. XML Schema 1.1 reinstates most of these, sometimes under slightly different names, and also adds additional blocks corresponding to characters in more recent versions of Unicode. The blocks listed in the table should be supported by all XSLT 2.0 and XPath 2.0 processors; other blocks  such as x1D100-x1D1FF, MusicalSymbols  may be supported in some processors and not in others.  923   Regular Expressions  Character Categories  Characters in the Unicode character database are assigned to a category and subcategory. For example, category «L» denotes letters, and within this «Lu» denotes upper-case letters. Within a regular expression, «\p{L}» matches any letter, and «\p{Lu}» matches any upper-case letter. The complementary sets can also be selected: «\P{L}» matches any character that is not a letter, and «\P{Lu}» matches any character that is not an upper-case letter.  The list of categories, with a few examples of characters found in each, is listed in the table below.  Category L  Description Letters  Non-spacing  Combining acute accent  x0301   Upper case  Lower case  Title case  Modiﬁer  Other  Marks  Spacing  Enclosing  Numbers  Decimal digits  Numeric letters  Other  Punctuation  Connector  Dash  Open  Close  Initial quote  Final quote  Other  Separators  Space  Line  Examples  A, B,  cid:1 ,  cid:1   a, b, ¨o, λ  Dz  x01C5   Arabic TATWEEL  x0640   Hebrew ALEF  x05D0   Gujarati vowel sign AA  x0ABE   Combining enclosing circle  x20DD   1, 2, 3, 4,  Roman numeral ten thousand  x2182  Superscript 2 3  x00B2, x00B3   _  x005F   em dash  x2014    [ {   ]} «  x00AB   »  x00BB   ! ? ¿ x00BF   space  x0020 , non-breaking space  x00A0   line separator  x2028   continued  Lu  Ll  Lt  Lm  Lo  M  Mn  Mc  Me  N  Nd  Nl  No  P  Pc  Pd  Ps  Pe  Pi  Pf  Po  Z  Zs  Zl  924   Category Zp  S  Sm  Sc  Sk  So  C  Cc  Cf  Co  Cn  Flags  The «i» ﬂag  Flags  Examples paragraph separator  x2029   +  ∼ ¬ ± $ ¢ £ ¥ ¤ acute accent «´», cedilla «¸» §   ◦  tab  x0009 , newline  X000A   soft hyphen  x00AD   Description Paragraph  Symbols  Mathematical  Currency  Modiﬁer  Other  Others  Control  Format  Private use  Not assigned  The effect of a regular expression can be modiﬁed by setting one or more ﬂags. These are supplied in a separate argument of the XPath function matches  , replace  , or tokenize  , or in a separate attribute of the XSLT instruction  . The ﬂags are expressed as a string containing one or more of the four characters «i», «m», «s», and «x»  they can be written in any order, and no harm is done if a character is repeated . This section explains the meanings of the ﬂags.  This ﬂag causes the regular expression to use case-insensitive mode. In this mode, a letter used in the regular expression matches characters in the input string regardless of their case; for example, the regex «Monday» matches the strings «Monday» or «monday» or «MONDAY». Without this ﬂag, characters must match exactly. Note that collations are not used for regex comparisons.  Case-insensitive mode affects constructs in the regular expression as follows:    When a character is used as an atom it represents that character and all its case variants. For  example, the regex «abc» matches «abc» or «ABC» or «Abc», among others.    When a character is used as an XmlCharIncDash within square brackets, it represents that char- acter and all its case variants. For example, the regex «[ab]» matches «a», «A», «b», or «B». This applies even if the character appears as part of a negative character group or a subtraction; for example, «[^ab]» matches any character except «a», «A», «b», or «B», while [A-Z-[IO]] matches any upper- or lower-case ASCII alphabetic character except «i», «I», «o», or «O».    When a character range is used, the expression matches the characters in the range together with their case variants. For example, «[P-U]» has the same effect as «[PQRSTU]»: it matches all characters that are case variants of any of these six letters. As it happens, this includes the six letters «pqrstu» together with « »  x017F, long S, an archaic form of the letter «s» . Back-references are matched using case-blind comparison; for example, « [A-Z] .*\1» matches «Ohio» and «Atlanta» as well as «OHIO», «ohio», «ATLANTA», and «atlanta».     14  R e g u a r  l  E x p r e s s o n s  i  925   Regular Expressions  In most cases it’s fairly obvious what counts as a case variant of a character. Ofﬁcially it’s deﬁned in terms of the upper-case   and lower-case   functions described in Chapter 13: $C is a case variant of $D if upper-case $C  equals upper-case $D , or lower-case $C  equals lower-case $D , or both. Occasionally, this gives slightly unexpected results; for example, the letter «I» has four case variants: . I», and «ı». This oddity arises because some languages  English  drop the dot over the «i» «I», «i», « when translating from lower case to upper case, whereas other languages  Turkish  keep it.  The «i» ﬂag does not affect constructs other than those listed above. For example, it does not affect the meaning of «\p{Lu}», which matches upper-case letters only, whether or not the ﬂag is set.  The «m» ﬂag switches on multiline mode. In the default mode  called string mode  the meta-characters «^» and «$» match the beginning and end of the input string. In multiline mode, the input string is treated as a sequence of individual lines separated by a newline  x0A  character. The meta-characters «^» and «$» then match the beginning and end of any line.  The spec, as published, isn’t clear as to what happens when the last character of the string is a newline character. An erratum has been issued to make XPath behave in the same way as other languages that support multiline mode: there is no zero-length line at the end.  The «s» ﬂag switches on dot-all mode. By default, the meta-character «.» in a regular expression matches any character in the input except a newline  x0A  character. In dot-all mode, «.» matches any character, including a newline.  The «m» ﬂag  The «s» ﬂag  The «x» ﬂag  The «x» ﬂag causes whitespace in the regular expression to be ignored, except within square brackets. By default, whitespace characters in a regular expression represent themselves, for example, the regex «*» matches a sequence of zero or more spaces. If the «x» ﬂag is set, whitespace in the regex is ignored and can be used to make the layout more readable. Whitespace characters can always be matched using character escapes such as «\s» and «\n». In some other regular expression languages  for example, Perl , the «x» ﬂag also allows comments to be included in a regular expression, starting with «» and ending with a newline. This feature wasn’t included in the XPath dialect because newline is an inappropriate choice of delimiter, given that XML parsers are expected to replace newlines with spaces when processing an attribute value. If you want to include a comment in a regular expression within an XSLT stylesheet, use XML comments:           [0-9]+  \s+  [A-Za-z]+    \s+  [0-9]{4}             ...     926   Summary  Perl treats an escaped space  a space preceded by a backslash  as a signiﬁcant space, despite the presence of this ﬂag. The XPath rules don’t follow this precedent — spaces are ignored even if preceded by a backslash.  Disallowed Constructs  Finally, here are some examples of constructs that might be familiar from other regular expression dialects that have not been included in the XPath 2.0 deﬁnition. A conformant XPath 2.0 processor is expected to reject any attempt to use constructs that aren’t allowed by the grammar presented in this chapter. A few of these constructs are shown in the following table.  Disallowed Construct  [a-z&&[^oi]]  Meaning in other languages Intersection: any character in the range «a» to «z», except for «o» and «i»  [a-z[A-Z]] \0nn, \xnn, \unnnn  \a, \e, \f, \cN \p{Alpha}, \P{Alpha} \b, \B \A, \Z, \z \g, \G X*+   ?...   Summar y  Union: same as «[a-zA-Z]»  Character identiﬁed by Unicode codepoint in octal or hexadecimal  Various control characters not allowed in XML 1.0  Character classes deﬁned in POSIX  Word boundary  Beginning and end of input string  End of the previous match  Non-backtracking or possessive quantiﬁers  in Java, these force the matching engine down this path even if this results in the match as a whole failing   Expressions that set various special options; non-capturing subexpressions; comments  This chapter provided a rather technical deﬁnition of the regular expression syntax provided for use in the XPath functions matches  , replace  , and tokenize  , and in the XSLT   instruction.  Having given this very detailed deﬁnition of the regex grammar, it’s worth including a warning that some processors may cut corners by exposing whatever regex dialect is supported by their existing libraries. Microsoft’s XML Schema processor, for example, uses the .NET regex dialect rather than the one deﬁned by W3C.  Caveat emptor!  14  R e g u a r  l  E x p r e s s o n s  i  927    Serialization  Serialization in an XSLT context means the process of taking a result tree  the output of a transformation  and converting it into lexical XML, usually as a ﬁle in ﬁlestore. XSLT also allows serialization into other formats, including HTML and text ﬁles.  As mentioned in Chapter 2, although serialization is not part of the core function of an XSLT processor, the language provides constructs such as   that enable you to control the process from within a stylesheet. Many products may also allow you to invoke the serializer as a separate component. With XSLT 2.0, the speciﬁcation of serialization has been moved into a separate W3C Recommendation, to allow reuse of the facilities from within other XML processing languages such as XQuery and XProc. You can ﬁnd the W3C speciﬁcation at http:  www.w3.org TR xslt-xquery-serialization .  Serialization is controlled by a set of parameters, each of which has a name and a value. The most important parameter is «method», which takes one of the values «xml», «html», «xhtml», or «text». This determines which serialization method is used  user-deﬁned or vendor-deﬁned serialization methods are also allowed, but are outside the scope of this book . When serialization is invoked from XSLT, the serialization parameters are generally controlled using the attributes of the   or   instructions described in Chapter 6. It is often possible, however, to set further parameters from the invoking application, or as options on the command line.  15  S e r i a  l i z a t i o n  In this chapter, we will start by examining each of the four output methods in turn: XML, HTML, XHTML, and TEXT. Then we’ll look at other serialization capabilities in the XSLT speciﬁcation, notably character maps and disable-output-escaping.  Details of the syntax of elements such as  ,  , and   are found in the appropriate alphabetical sections in Chapter 6.  The XML Output Method  When the output method is «xml», the output ﬁle will usually be a well-formed XML document, but the actual requirement is that it should be either a well-formed XML external general parsed entity or a well-formed XML document entity, or both.   Serialization  An external general parsed entity is something that could be incorporated into an XML document by using an entity reference such as «&doc;». The following example shows a well-formed external general parsed entity that is not a well-formed document:  A  bold  and  emphatic  statement  An example of a well-formed document that is not a well-formed external general parsed entity  because it contains a standalone attribute  is:     A     and  emphatic  statement   The rules for document entities and external general parsed entities overlap, as shown in Figure 15-1.  XML Document Entity  External General Parsed Entity  Figure 15-1  Essentially, an XSLT stylesheet can output anything that ﬁts in either of the two shaded circles, which means anything that is a well-formed XML document entity, a well-formed external general parsed entity, or both.  Well, almost anything:           It must also conform to the XML Namespaces Recommendation. There is no explicit provision for generating an internal DTD subset, although it can be achieved, with difﬁculty, by using character maps. Similarly, there is no explicit provision for generating entity references, though this can also be achieved by means of character maps.  In the XML standard, the rules for an external parsed entity are given as:  extParsedEnt ➪ TextDecl? content  where content is a sequence of components including child elements, character data, entity references, CDATA sections, processing instructions, and comments, each of which may appear any number of times and in any order.  The corresponding rule for a document entity is effectively:  document ➪ XMLDecl? Misc* doctypedecl? Misc* element Misc*  where Misc permits whitespace, comments, and processing instructions.  930   The XML Output Method  So the principal differences between the two cases are:                       A TextDecl  text declaration  is not quite the same thing as an XMLDecl  XML declaration , as discussed below. A document may contain a doctypedecl  document type declaration , but an external parsed entity must not. A document type declaration is the   header identifying the DTD and possibly including an internal DTD subset. The body of a document is an element, while the body of an external parsed entity is content. Here content is effectively the contents of an element but without the start and end tags. In a document, any whitespace that immediately follows the XML declaration is insigniﬁcant. In an external general parsed entity, however, such whitespace is signiﬁcant. This means that the serializer cannot add whitespace here unless it is explicitly requested.  The TextDecl  text declaration  looks at ﬁrst sight very much like an XML declaration; for example,   could be used either as an XML declaration or as a text declaration. There are differences, however:  In an XML declaration, the version attribute is mandatory, but in a text declaration it is optional. In an XML declaration, the encoding attribute is optional, but in a text declaration it is mandatory. An XML declaration may include a standalone attribute, but a text declaration must not.  So the following are all examples of well-formed external general parsed entities:  1:  Hello!  2:  Hello!  Goodbye!  3: Hello! 4:  Hello!  The following is a well-formed XML document, but it is not a well-formed external general parsed entity, because of both the standalone attribute and the document type declaration. This is also legitimate output:  The following is neither a well-formed XML document nor a well-formed external general parsed entity.       Hello!        Hello!   Goodbye!   It cannot be an XML document because it has more than one top-level element, and it cannot be an exter- nal general parsed entity because it has a   declaration. A stylesheet attempting to produce this output is in error. The XSLT speciﬁcation also places two other constraints on the form of the output, although these are rules for the implementor to follow rather than rules that directly affect the stylesheet author. These rules are:     The output must conform to the rules of the XML Namespaces Recommendation. If the output is XML 1.0, then it must conform to XML Namespaces 1.0, and if it is XML 1.1, then it must conform to XML Namespaces 1.1.  15  S e r i a  l i z a t i o n  931   Serialization  If the output is an XML document, the meaning of this is clear enough, but if it is merely an exter- nal entity, some further explanation is needed. The standard provides this by saying that when the entity is pulled into a document by adding an element tag around its content, the resulting document must conform with the XML Namespaces rules. The output ﬁle must faithfully reﬂect the result tree. This requirement is easy to state informally, but the speciﬁcation includes a more formal statement of the requirement, which is surprisingly complex.     The rule is expressed by describing what may change when the data model is serialized to XML and then parsed again to create a new data model. Things that may change include the order of attributes and namespace nodes and the base URI. If the parsing stage does DTD or schema validation, then this may cause new attribute or element values to appear, as speciﬁed by the DTD or schema. Perhaps the most signiﬁcant change is that type annotations on element and attribute nodes will not be preserved. Any type annotations in the data model after such a round trip will be based on revalidation of the textual XML document; the type annotations in the original result tree are lost during serialization.  Serialization never adds attributes such as xml:base or xsi:type. If you want these present in the output, you must put them in the result tree, just like any other attribute.  Between XSLT 1.0 and XSLT 2.0, there is a change in the way the rules concerning namespace declarations are described. In XSLT 1.0, it was the job of the serializer to generate namespace declarations, not only for namespace nodes explicitly present on the result tree, but also for any namespaces used in the result document, but not represented by namespace nodes. This situation can happen because there is nothing in the rules for   and  , for example, that requires namespace nodes to be created for the namespace URI used in the names of these nodes. In XSLT 2.0, however, the speciﬁcation describes a process called namespace ﬁxup, which ensures that an element in a result tree always has a namespace node for every namespace that is used either in the element name or in the name of any of its attributes. This means that it is no longer the responsibility of the serializer to create these namespace declarations. The reason for this change is that with XSLT 2.0, the content of temporary trees  including their namespace nodes  becomes visible to the stylesheet, and the namespace nodes need to be present in the tree to make it usable for further processing. Namespace ﬁxup is described in Chapter 6 under   on page 306.  Although the output is required to be well-formed XML, it is not the job of the serializer to ensure that the XML is valid against either a DTD or a schema. Just because you generate a document type declaration that refers to a speciﬁc DTD, or a reference to a schema, don’t expect the XSLT processor to check that the output document actually conforms to that DTD or schema. Instead, XSLT 2.0 provides facilities to validate the result tree against a schema before it is serialized, by using the validation or type attribute on  .  With the «xml» output method, the other attributes of   or   are interpreted as follows. Attributes that are not applicable to this output method are not included in the table, and they are ignored if you specify them.  The W3C serialization speciﬁcation speaks of doctype-system, doctype-public and so on as serial- ization parameters. This is because the speciﬁcation is designed to be used independently of XSLT, and therefore abstracts away from the actual XSLT syntax used. In this book we’re concerned with how to control serialization from XSLT, so we’ll refer to these things as attributes, which is how they appear in XSLT’s concrete syntax.  932   doctype-system If this attribute is speciﬁed, the output ﬁle will include a document type declaration  Attribute cdata-section- elements  doctype-public  encoding  The XML Output Method  Interpretation This is a list of element names, each expressed as a lexical QName, separated by whitespace. Any preﬁx in a QName is treated as a reference to the corresponding namespace URI in the normal way, using the namespace declarations in effect on the actual   or   element where the cdata-section-elements attribute appears. Because these are element names, the default namespace is assumed where the name has no preﬁx. When a text node is output, if the parent element of the text node is identiﬁed by a name in this list, then the text node is output as a CDATA section. For example, the text value «James» is output as « », and the text value «AT&T» is output as « ». Otherwise, this value would probably be output as «AT&amp;T». The XSLT processor is free to choose other equivalent representations if it wishes, for example a character reference, but the standard says that it should not use CDATA unless it is explicitly requested.  The CDATA section may be split into parts if necessary, perhaps when the  terminator sequence «]]>» appears in the data, or when there is a character that can only be output using a character reference because it is not supported directly in the chosen encoding.   that is,    after the XML declaration and before the ﬁrst element start tag. The name of the document type will be the same as the name of the ﬁrst element. The value of this attribute will be used as the system identiﬁer in the document type declaration.  This attribute should not be used unless the output is a well-formed XML  document.  This attribute is ignored unless the doctype-system attribute is also speciﬁed. It deﬁnes the value of the public identiﬁer to go in the document type declaration. If no public identiﬁer is speciﬁed, none is included in the document type declaration.  This speciﬁes the preferred character encoding for the output document. All XSLT processors are required to support the values «UTF-8» and «UTF-16»  which are also the only values that XML parsers are required to support . This encoding name will be used in the encoding attribute of the XML or Text declaration at the start of the output ﬁle, and all characters in the ﬁle will be encoded using these conventions. The standard encoding names are not case-sensitive.  If the encoding is one that does not allow all XML characters to be represented  directly, for example «iso-8859-1», then characters outside this subset will be represented where possible using XML character references  such as «&x20A4;» . It is an error if such characters appear in contexts where character references are not recognized  for example within a processing instruction or comment, or in an element or attribute name .  If the result tree is serialized to a destination that expects a stream of Unicode characters rather than a stream of bytes, then the encoding attribute is ignored. This happens, for example, if you send the output to a Java Writer. It often causes confusion when you use the transformNode   method in Microsoft’s MSXML API, which returns the serialized result of the transformation as a string: This is a value of type BSTR, which is encoded in UTF-16 regardless of the encoding you requested in the stylesheet.  15  S e r i a  l i z a t i o n  continued  933   Serialization  Attribute indent  media-type  normalization- form  934  Interpretation If this attribute has the value «yes», the idea is that the XML output should be indented to show its hierarchic structure. The XSLT processor is not obliged to respect this request, and if it does so, the precise form of the output is not deﬁned.  There are some constraints on how indentation should be achieved. In effect, it  can only be done by adding whitespace-only text nodes to the tree, and these cannot be added adjacent to an existing non-whitespace text node. XSLT 2.0 has introduced a rule that the added text node must be adjacent to an element node, that is, immediately before a start tag or after an end tag  in 1.0, it could be added as a child of an empty element .  Note that even with these restrictions, adding whitespace nodes to the output may affect the way the recipient interprets it. This is particularly true with mixed content models, where an element can have both elements and text nodes as its children.  The serializer is not allowed to add whitespace text nodes to the content of an  element that has the attribute «xml:space="preserve"», and the spec advises against adding whitespace to an element that is known to have mixed content.  This parameter deﬁnes the media type of the output ﬁle  often referred to as its MIME type . The default value is «text xml». The speciﬁcation doesn’t say what use is made of this information: it doesn’t affect the contents of the output ﬁle, but it may affect the way it is named, stored, or transmitted, depending on the environment. For example, the information might ﬁnd its way into an HTTP protocol header.  One of the controversial features of Unicode has always been that it allows the same character to be represented in more than one way. For example, the letter «c¸»  lower-case «c» with cedilla  can be represented either as a single character  with codepoint xE7 , or as the two codepoints: «c»  x63  and «,»  xB8 . This fact causes considerable problems for software that performs comparison, search, and indexing operations on Unicode text. There have been long debates about whether XML should require such characters to be normalized  that is, to require one of these representations and disallow the other . The result of the debate is a compromise: XML 1.1 strongly encourages the use of normalized encodings. It encourages applications to output normalized text, and encourages parsers to provide an option that checks for normalized text, but it does not go so far as to say that non-normalized documents are not well formed.  XSLT 2.0 responds to this by providing an option to serialize the document in Unicode-normalized form. Specify «NFC» for composed normal form, «NFD» for decomposed normal form, any other supported normalization form, or «none»  the default  for no normalization.  An alternative approach is to make sure that individual text nodes, attribute nodes, and so on are already normalized in the result tree. You can do this by calling the normalize-unicode   function, described in Chapter 13, whenever you construct a character string that might not already be normalized.  continued   Attribute omit-xml- declaration  standalone  undeclare- preﬁxes  use-character- maps  version  The XML Output Method  Interpretation If this attribute has the value «yes», the serializer will not output an XML declaration  or, by implication, a text declaration; recall that XML declarations are used at the start of the document entity, and text declarations are used at the start of an external general parsed entity . If the attribute is omitted, or has the value «no», then a declaration will be output. The declaration will include both the version and encoding attributes  to ensure that it is valid both as an XML declaration and as a text declaration . It will include a standalone attribute only if standalone is set to «yes» or «no».  If you select an encoding such as «iso-8859-1» and omit the XML declaration,  the output may be unintelligible to an XML parser. Nevertheless, the speciﬁcation allows you to omit it, because there are sometimes alternative ways for an XML parser to determine the encoding.  Also, you might want to serialize several chunks of XML separately and then combine them using a text editor.   If this attribute is set to «yes», then the XML declaration will specify «standalone="yes"». If it is set to «no», then the XML declaration will specify «standalone="no"». If the attribute is omitted, or is set to the value «omit», then the XML declaration will not include a standalone attribute. This will make it a valid text declaration, enabling its use in an external general parsed entity. This attribute should not be used unless the output is a well-formed XML document.  This attribute only comes into effect when you specify «version="1.1"». XML Namespaces 1.1 introduces the ability to undeclare a namespace. It’s always been possible to undeclare the default namespace, using the syntax «xmlns=""», but now you can also undeclare a namespace with a speciﬁc preﬁx, using the syntax «xmlns:pfx=""».  The result tree created by an XSLT 2.0 processor may have a namespace  that is in scope for a particular element, but not in scope for its children. This is most likely to happen if you create the element using the option «inherit- namespaces="no"». The strict way to serialize such a tree is to generate namespace undeclarations on the child elements. However, the serializer does not do this by default, because these undeclarations may cause a lot of unwanted clutter in the output document. Instead, you have to request them explicitly by setting this attribute to «yes».  The value of this attribute is a list of character map names; these character maps must be deﬁned in the stylesheet. The serializer will use the named character maps to translate speciﬁc characters into the strings given in the character map. For further details, see page 941.  This attribute indicates the version of XML to be used in the output document. This can be «1.0» or «1.1». The XSLT speciﬁcation requires only one of these versions to be supported: The thinking was that early in the life of XSLT 2.0, many implementations would only support XML 1.0, but in ﬁve years’ time, there might be vendors who wanted only to support XML 1.1. As already mentioned, support for a particular version of XML also implies support for the corresponding version of XML Namespaces.  15  S e r i a  l i z a t i o n  continued  935   Serialization  Attribute  Interpretation The XPath data model, and therefore the result tree, is not tied to a particular version of XML. It supports the union of what can be represented in XML 1.0 and XML 1.1. This creates the possibility that the result tree uses features that cannot be represented faithfully  or at all  in XML 1.0. If such features are used, the serializer may need to fall back to a 1.0 representation, or if all else fails, report an error.  Do remember that the   element will only be effective if you actually use the XSLT pro- cessor to serialize the XML. If you write the output of the transformation to a DOM, and then use a serializer that comes with your DOM implementation  for example by using the save method or the xml property in the case of the Microsoft DOM implementation , then the   speciﬁcations will have no effect.  The HTML Output Method  When the method attribute is set to «html», or when it is defaulted and the result tree is recognized as representing HTML, the output will be an HTML ﬁle. By default, it will follow the rules of HTML 4.0.  Requesting HTML serialization gives no guarantee that the result will be valid HTML. You can use any elements and attributes you like in the result tree, and the serializer will output them, following the HTML conventions where appropriate, but without enforcing any rules as to which elements can be used where.  HTML is output in the same way as XML, except where speciﬁc differences are noted. These differences are:     Certain elements are recognized as empty elements. They are recognized in any combination of upper and lower case, but they must not be in a namespace. These elements are output with a start tag and no end tag. For HTML 4.0 these elements are:                                     The   and   elements  again in any combination of upper and lower case  do not require escaping of special characters. In the text content of these elements, a «<» character will be output as «<», not as «&lt;». HTML attributes whose value is a URI  for example, the href attribute of the   element, or the src attribute of the   element  are recognized, and special characters within the URI are escaped as deﬁned in the HTML speciﬁcation. Speciﬁcally, non-ASCII characters in the URI will be represented by converting each byte of the UTF-8 representation of the character to «%HH» where HH represents the byte value in hexadecimal. This feature may be suppressed by setting «escape-uri-attributes="no"».  936   The HTML Output Method              Special characters may be output using entity references such as «&eacute;» where these are deﬁned in the relevant version of HTML. This is at the discretion of the XSLT processor; it doesn’t have to use these entity names. Processing instructions are terminated with «>» rather than «?>». Processing instructions are not often used in HTML, but the HTML 4.0 standard recommends that any vendor extensions should be implemented this way, rather than by adding element tags to the language. So it is possible they will be seen more frequently in the future. Attributes that are conventionally written with a keyword only, and no value, will be recognized and output in this form. Common examples are   and <OPTION SELECTED>. This is shorthand, permitted in SGML but not in XML, for an attribute that has only one permitted value, which is the same as the attribute name. In XML, these tags must be written as   and  . The HTML output method will normally use the abbreviated form, as this is the only form that older HTML browsers will recognize. The special use of the ampersand character in dynamic HTML attributes is recognized. For example, the tag   is correct HTML, though it would not be correct in XML, because of the ampersand character. To produce this output from a literal result element, the tag in the stylesheet would need to be written as  : note the double curly braces, to prevent them being interpreted with their special meaning in attribute value templates.  A common source of anxiety with HTML output is the use of ampersands in URLs. For example, suppose you want to generate the output:    Spanish Widgets    However you try to produce this using standard XSLT, the ampersand will always come out as «&amp;». The reason for this is simple: «&», although commonly used and widely accepted, is not actually correct HTML, and according to the standard it must be escaped as «&amp;». All respectable browsers accept the correct escaped form, so the answer is: don’t worry about it.  Although the serializer won’t generally check that the result tree is valid HTML, there is one exception: it must not use characters that are allowed in XML but not in HTML, notably Unicode characters in the range x80 to x9F. If these characters appear in your XML, the chances are that they got there by accident. Microsoft’s cp1252 character set  sometimes called ANSI  is generally similar to iso-8859-1 but uses codes in this range to refer to special characters such as the Euro currency symbol, dagger, em-dash, middle dot, and the trademark sign. If a document that uses these characters is correctly labeled, then these characters will be translated into their Unicode equivalents  for example the Euro sign will become x20AC , and all will be well. If, however, the document is wrongly labeled with «encoding="iso-8859-1"», then these characters will be represented in the XML with codes in the range x80 to x9F, which will cause an error when you try to serialize as HTML, because HTML does not allow characters in that range. The remedy is to change the XML declaration of the source document from «encoding="iso-8859-1"» to «encoding="cp1252"».  The other serialization attributes are interpreted as follows when HTML output is selected. Attributes not listed are not applicable to HTML, and are ignored.  15  S e r i a  l i z a t i o n  937   escape-uri-attributes This attribute determines whether non-ASCII characters appearing in  Serialization  Attribute doctype-system  doctype-public  encoding  include-content- type  indent  938  Interpretation If this attribute is speciﬁed, the output ﬁle will include a document type declaration immediately before the ﬁrst element start tag. The name of the document type will be «HTML» or «html». The value of the parameter will be used as the system identiﬁer in the document type declaration.  If this attribute is speciﬁed, the output ﬁle will include a document type declaration immediately before the ﬁrst element start tag. The name of the document type will be «HTML» or «html». The value of the parameter will be used as the public identiﬁer in the document type declaration.  This speciﬁes the preferred character encoding for the output document. If the encoding is one that does not allow all XML characters to be represented directly, for example «iso-8859-1», then characters outside this subset will be represented where possible using either entity references or numeric character references. The processor is encouraged not to use such references for characters that are within the encoding, except in special cases such as the nonbreaking space character, which may be output either as itself  it looks just like an ordinary space  or as «&160;», «&a0;», or «&nbsp;». It is an error if characters that can’t be represented directly appear in contexts where character references are not recognized  for example within a script element, within a comment, or in an element or attribute name .  URI-valued attributes should be escaped using the %HH convention. The default is «yes». Although HTML requires URIs to be escaped in this way, there are several reasons why you might choose to suppress this. Firstly, the URIs might already be in escaped form: you can do the escaping from within the stylesheet, with much greater control, using the escape-html-uri   function described in Chapter 13. Secondly, browsers do not always handle escaped URIs correctly. This is especially true when the URI is handled on the client side; for example, when it invokes JavaScript functions, or when it contains a fragment identiﬁer.  If this attribute is set to «yes»  or if it is omitted , the serializer will add a   element as a child of the HTML   element, provided that the result tree contains a   element. This   element contains details of the media type and encoding of the document. Any existing   element containing this information will be replaced. You may want to suppress this by specifying the value «no», for example if the stylesheet is copying a document that already includes such an element.  If this attribute has the value  , the idea is that the HTML output should be indented to show its hierarchic structure. The XSLT processor is not obliged to respect this request, and if it does so, the precise form of the output is not deﬁned.  When producing indented output, the processor has much more freedom to  add or remove whitespace than in the XML case, because of the way whitespace is handled in HTML. The processor can add or remove whitespace anywhere it likes so long as it doesn’t change the way a browser would display the HTML.  continued   The XHTML Output Method  Attribute media-type  Interpretation This attribute deﬁnes the media type of the output ﬁle  often referred to as its MIME type . The default value is «text html». The speciﬁcation doesn’t say what use is made of this information; it doesn’t affect the contents of the output ﬁle, but it may affect the way it is named, stored, or transmitted, depending on the environment. For example, the information might ﬁnd its way into an HTTP protocol header.  normalization-form This attribute is used in the same way as for the XML output method, described  on page 934.  use-character-maps  This attribute is used in the same way as for the XML output method, described on page 935.  version  This attribute determines the version of HTML used in the output document. It is up to the implementation to decide which versions of HTML should be supported, though all implementations can be expected to support the default version, namely version 4.0.  The XHTML Output Method  An XHTML document is an XML document, so when you specify «method="XHTML"», most of the rules for the XML output method are inherited without change. However, there are special guidelines for serializing XHTML so that it is rendered correctly in browsers that were designed originally to handle HTML, and in addition some of the features of HTML serialization, such as URI escaping and addition of   elements, are also applicable to XHTML. So the XHTML output method is essentially a blend of features from the XML and HTML methods.  It’s worth asking yourself whether you really need to use this method. If the browser understands XHTML, then serializing the result tree as XML will work ﬁne. If the browser doesn’t understand XHTML, and is going to handle it as if it were HTML, then why not serialize the tree as HTML to start with?  15  S e r i a  l i z a t i o n  In fact, the XHTML output method works in the same way as the XML output method  and uses all the serialization parameters that control the XML method  with speciﬁc exceptions. These exceptions are:           The way that empty elements are output depends on the way the element is declared in the XHTML DTD. For an element whose content model is empty, such as   or   or  , the serializer should use an XML empty-element tag, taking care to include a space before the ﬁnal « >», so that the tag looks like   or  . For an element that is empty but allowed to have content, such as a   element, the serializer should use a start tag followed by an end tag, thus:   . The entity reference «&apos;» is not recognized by all browsers, so the serializer will probably use «&27;» instead. The serializer needs to take care with whitespace  for example newlines  appearing in attribute values. The speciﬁcation doesn’t say exactly how this should be handled, but it’s probably safest, if there is any whitespace other than a single space character, to represent it using numeric character references.  939   Serialization           The serializer must not output redundant namespace declarations, since these would violate the XHTML DTD.  At one time this rule was wider and encouraged the serializer to put XHTML elements in the default namespace. However, the serializer has no discretion in this area — namespace preﬁxes are chosen by the user, not by the serializer.  Because DTDs are not namespace-aware, it’s always the case that if you choose the wrong preﬁx, the result document of a transformation may be invalid against the DTD.  The XHTML output method also inherits two speciﬁc features of the HTML output method:  Non-ASCII characters in URI-valued attributes are escaped using the %HH convention, unless you suppress this by specifying «escape-uri-attributes="no"». A   element is added as the child of the   element, unless you suppress this using «include-content-type="no"».  You can control whether an XML declaration is output using the «omit-xml-declaration» attribute. The XHTML 1.0 speciﬁcation advises against using an XML declaration, but points out that under the XML rules, it may be omitted only if the encoding is UTF-8 or UTF-16.  The Text Output Method  When you specify «method="text"», the result tree is output as a plain text ﬁle. The values of the text nodes of the tree are copied to the output, and all other nodes are ignored. Within text nodes, all character values are output using the relevant encoding as determined by the encoding attribute; there are no special characters such as «&» to be escaped.  The way in which line endings are output  for example LF or CRLF  is not deﬁned; the implementation might choose to use the default line-ending conventions of the platform on which it is running.  The attributes that are relevant to text output are listed below. All other attributes are ignored.  Attribute encoding  media-type  Interpretation This speciﬁes the preferred character encoding for the output document. The default value is implementation-deﬁned, and may depend on the platform on which it is running.  If the encoding is one that does not allow all XML characters to be represented  directly, for example «iso-8859-1», then any character outside this subset will be reported as an error.  This parameter deﬁnes the media type of the output ﬁle  often referred to as its MIME type . The default value is «text plain». The speciﬁcation doesn’t say what use is made of this information: It doesn’t affect the contents of the output ﬁle, but it may affect the way it is named, stored, or transmitted, depending on the environment. For example, the information might ﬁnd its way into an HTTP protocol header.  Using the   declaration  The defaulting mechanisms ensure that it is usually not necessary to include an   element in the stylesheet. By default, the XML output method is used unless the ﬁrst thing output is an   element, in which case either the HTML or the XHTML output method is used, depending on the namespace.  940   Character Maps  The   element is concerned with how your result tree is turned into an output ﬁle. If the XSLT processor allows you to do something else with the result tree, for example passing it to the appli- cation as a DOM Document or as a stream of SAX events, then the   element is irrelevant.  The encoding attribute can be very useful to ensure that the output ﬁle can be easily viewed and edited. Unfortunately, though, the set of possible values varies from one XSLT implementation to another, and may also depend on the environment. For example, many XSLT processors are written in Java and use the Java facilities for encoding the output stream, but the set of encodings supported by each Java VM is different. However, support for iso-8859-1 encoding is fairly universal, so if you have trouble viewing the output ﬁle because it contains UTF-8 Unicode characters, setting the encoding to iso-8859-1 is often a good remedy, at least if your document is written in a Western European language.  If your stylesheet generates accented letters or other special characters, and it looks as if they have come out incorrectly in the output, chances are they are correctly represented in UTF-8, but you are looking at them with a text editor that doesn’t understand UTF-8. Either select a different output encoding  such as iso-8859-1 , or get a text editor such as jEdit  www.jedit.org  that can work with UTF-8. If the problem occurs when you view the ﬁle in a browser, the most likely explanation is that the   element gives the wrong charset.  The encoding attribute determines how the XSLT processor serializes the output as a stream of bytes, but it says nothing about what happens to the bytes later. If the processor writes to a ﬁle, the ﬁle will probably be written in the chosen encoding. But if the output is accessed as a character string through an API, or is written to a character ﬁeld in a database, the encoding of the characters may be changed before you get to see them. A classic example of this effect is the Microsoft transformNode   interface  see Appendix D , which returns the result of the transformation as a BSTR string. Because this is a BSTR, it will always be encoded in UTF-16, regardless of the encoding you request. The same thing will happen with the JAXP interface  see Appendix E ; if you supply a StreamResult based on a Writer, the encoding then depends on how the particular Writer encodes Unicode characters, and the XSLT processor has no control over the matter.  Character Maps  15  S e r i a  l i z a t i o n  A character map is used during serialization when it is named in the use-character-maps serialization attribute. This is a list of named character maps; these character maps are concatenated in the order that they are listed, and any conﬂicts are resolved by choosing the mapping for a character that is last in the list.  During serialization, character mapping is applied to characters appearing in the content of text nodes and attribute nodes. It is not applied to other content  such as comments and processing instructions , nor to element and attribute names. It is not applied to characters for which disable-output-escaping has been speciﬁed, nor to characters in CDATA sections  that is, characters in the content of elements listed in the cdata-section-elements serialization parameter . In the case of the HTML and XHTML output methods, character mapping is applied to characters in URI-valued attributes after they have been subjected to URI escaping under the rules of the HTML and XHTML output methods, and it is also applied to attributes in a generated   element.  If a character is included in the character map, this bypasses the normal XML HTML escaping, as well as Unicode normalization. For example, if a character map causes the character «∧» to be replaced by «&&», then it will be output as «&&», not as «&amp;&amp;», even though the result is invalid XML.  941   Serialization  Usage  The ﬁnal stage of serialization is character encoding  as determined by the encoding parameter . This converts logical Unicode characters into actual bytes or octets; for example, if the encoding is UTF-8 then the character «c¸» will be represented by the two octets «x3c xA7». You cannot use character maps to alter the effect of the character encoding process.  Character maps are useful in many situations where you need precise control over the serialization of the result tree.  In general, if you are producing XML output that is to be used by another application, or if you are producing HTML output that is destined to be displayed in a browser, then the standard serialized output should be perfectly adequate. The situations where you need a ﬁner level of control are typically:                    If the output is designed to be edited by humans rather than processed by a machine. In this case, you may want, for example, to control the use of entity references in the output. If you need XML output containing an internal DTD subset within the document. Generate the DTD as text, using characters such x2039 and x2040  left right-pointing angle bracket  as substitutes for « ». If the output format is not standard HTML or XML, but some proprietary extension with its own rules. Such dialects are commonly encountered with HTML, though fortunately they are very rare in the case of XML. A similar requirement arises where the required output format is SGML. If the application that processes the HTML or XML that you produce is buggy. You live in the real world and life isn’t perfect. For example, it is rumored that some very old browsers will not accept an «&» in a URL that has been escaped as «&amp;», even though the HTML standard requires the escaped form. If you encounter such bugs, you may need to work around them. If the required output format uses what I call double markup. By this I mean the use of XML tags in places where tags are not recognized by an XML parser, generally within CDATA sections or comments. I don’t think that this is a particularly good design pattern for XML, because it is not possible to model the structure correctly as a tree using the XPath data model, but doc- ument structures such as this exist and you may be obliged to produce them. You can solve this problem using character maps by choosing two characters to map to the CDATA start and end delimiters  « »  or the comment start and end delimiters  «<!--» and «-->» . An example is shown on page 943. Finally, there are some transformations where generating the correct result tree is really difﬁcult, or really slow. An example might be where the document structure uses interleaved markup. This is used where there are two parallel hierarchies running through the same document; for example, one for the chapter section paragraph structure and one for the paginated layout. An expert will know when it’s time to give up and cheat — which in this case means producing markup in the result document by direct intervention at the serialization stage, rather than gen- erating the correct result tree and having the markup produced automatically by the serializer. The problem, of course, is that beginners are inclined to give up and cheat far too soon, which leads to code that is difﬁcult to extend and maintain.  Choosing Characters to Map  Applications for character maps probably fall into two categories: those where you want to choose a nonstandard string representation of a character that occurs naturally in the data, and those where you want to choose some otherwise unused character to trigger some special effect in the output.  942   Character Maps  An example in the ﬁrst category would be the example shown earlier:           This forces the nonbreaking space character to be output as an entity reference. If the document is to be edited, many people will ﬁnd the entity reference easier to manipulate because it shows up as a visible character, whereas the nonbreaking space character itself appears on the screen just like an ordinary space.  An example in the second category is choosing two characters to represent the start and end of a com- ment. Suppose that the requirement is to transform an input document by ‘‘commenting out’’ any element that has the attribute «delete="yes"». By commenting out, I mean outputting something like:  <!--     This paragraph has been deleted     -->  This is tricky, because the result cannot be modeled naturally as a result tree — comment nodes cannot have element nodes as children. So we’ll choose instead to output the   element to the result tree unchanged, but preceded and followed by special characters, which we will map during serialization to comment start and end delimiters.  The best characters to choose for such purposes are the characters in the Unicode Private Use Area, for example the characters from xE000 to xF8FF. These characters have no deﬁned meaning in Unicode, and are intended to be used for communications where there is a private agreement between the sender and the recipient as to what they mean. In this case, the sender is the stylesheet and the recipient is the serializer.  If you assign private use characters in information that is passed between applications, especially appli- cations owned by different organizations, you should make sure that your use of the characters is well documented.  Here is a stylesheet that performs the required transformation:  Example: Using a Character Map to Comment-Out Elements  15  S e r i a  l i z a t i o n  This example copies the input unchanged to the output, except that any element in the input that has the attribute «delete="yes"» is output within a comment.  Stylesheet  The stylesheet is comment-out.xsl:    <!DOCTYPE xsl:stylesheet [       ]>  943   Serialization  <xsl:stylesheet version="2.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform">                                     &start-comment;     &end-comment;         Source  One of the paragraphs in the source ﬁle resume.xml is:   Aidan is also in demand as a consort singer, performing with groups including the Oxford Camerata and the Sarum Consort, with whom he has made several acclaimed recordings on the ASV label of motets by Bach and Peter Philips sung by solo voices.   Output  When the stylesheet is applied to the source ﬁle resume.xml, the above paragraph appears as:   Aidan is also in demand as a consort singer, performing with groups including the Oxford Camerata and the Sarum Consort, with whom he has made several acclaimed recordings on the ASV label of motets by Bach and Peter Philips sung by solo voices. -->  Limitations of Character Maps  A character map applies to a whole result document; you cannot switch character mapping on and off at will.  The character map must be ﬁxed at compile time. You cannot compute the output string at runtime, and there is no way the process can be parameterized.  You can, however, substitute a different character  944   Disable Output Escaping  map by having different deﬁnitions of the same character map in different stylesheet modules, and deciding which one to import using  .   Character mapping may impose a performance penalty, especially if a large number of characters are mapped.  Character mapping has no effect unless the result of the transformation is actually serialized. If the result tree is passed straight to another application that doesn’t understand the special characters, it is unlikely to have the desired effect.  Character mapping only affects the content of text and attribute nodes. It doesn’t affect characters in element and attribute names, or markup characters such as the quotes around an attribute value.  The character to be mapped, and all the characters in the replacement string, must be valid XML charac- ters. This is because there is no way of representing invalid characters in the   element in the stylesheet. This means that character maps cannot be used to generate text ﬁles containing characters not allowed in XML, such as the NUL character  x00 .  Disable Output Escaping  XSLT 1.0 provided an alternative way of getting ﬁne-grained control over the serializer, namely the disable-output-escaping attribute of the   and   instructions. This has been deprecated in XSLT 2.0, but it is still likely to be supported in many processors because it is so widely used  and abused  in XSLT 1.0 stylesheets.  Reasons to Disable Output Escaping  Normally, when you try to output a special character such as «<» or «&» in a text node, the special character will be escaped in the output ﬁle using the normal XML escaping mechanisms. The escaping is done by the serializer: the text node written in the result tree contains a «<» or «&» character, and the serializer translates this into «&lt;» or «&amp;». The serializer is free to represent the special characters any way it wants; for example, it can write « », because these are all equivalent according to the XML standard. The one thing it will not write is «<». So, it doesn’t matter how you write the «<» in your input: the serializer sees a «<» and escapes it in the output.  15  S e r i a  l i z a t i o n  There are several valid reasons why you might not want this behavior. For example:              The output is not XML or HTML at all; it is  say  a data ﬁle in comma-separated-values format. The output is HTML and you want to exploit one of the many HTML quirks where special char- acters are needed without escaping; for example, a «<» sign in a piece of client-side JavaScript on your HTML page. The output is XML and you want to achieve some special effect that the XSLT processor doesn’t allow; for example, outputting an entity reference such as «&current-date;» or an internal DTD subset containing an entity declaration. The output is some format that uses angle-bracket syntax but is not pure XML or HTML; for example, ASP.NET pages or Java Server Pages, which both use « » as delimiters, or XQuery, in which an unescaped «<» can be used as an operator symbol.  If you are generating Java Server Pages, note that these have an alternative syntax that is pure XML; however, this is not widely used.   945   Serialization  If the output is not XML or HTML at all, then rather than using disable-output-escaping, it is better to set «method="text"» on the   element. In this case, special characters will never be escaped  which also means that disabling output escaping has no effect .  Why disable-output-escaping Is Deprecated  The use of disable-output-escaping is often discouraged; indeed it is ofﬁcially deprecated in XSLT 2.0.  The ﬁrst reason for this is that it works only if the result tree is being serialized. If the result tree is fed directly into another application, then disable-output-escaping has no effect. This happens, for example, in the Firefox browser, where the HTML-structured result tree is used directly by the ren- dering engine, without ﬁrst serializing it as text and then re-parsing it. So a stylesheet that depends on disable-output-escaping won’t always work.  The second reason that the facility is discouraged is that it’s often a symptom of careless programming: Its use reveals that the stylesheet author is thinking too much in terms of creating tags in a serialized ﬁle, not in terms of creating nodes in a result tree.  Here’s an example of a misuse of disabling output escaping that you will often encounter  only in other people’s stylesheets, of course . The author wanted to get markup tags into the output document, and they couldn’t see how to achieve this with the regular facilities of   or literal result elements. For example, the author might have been thinking along these lines:                                 The intended effect here is to output a   tag if the preceding element is not a bullet element, and to output a   tag when the following element is not a bullet element. Of course, it doesn’t work, because the   and   tags are not properly nested; this template will be thrown out by the XML parser before the XSLT processor even gets to look at it.  So their next thought might be to write the tags as text, as follows:         &lt;ul&gt;              &lt;ul&gt;         946   Disable Output Escaping  You now have something that is legal XML and indeed legal XSLT, but it’s not guaranteed to work under all circumstances. And even if it does work, it’s badly written code, because it’s cutting against the grain of the language.  With a bit of thought you can usually ﬁnd a way to achieve the output you want without resorting to such devices.  The ﬁrst thing is to think in terms of outputting a result tree containing nodes, not a text ﬁle containing tags. Don’t try to generate the   start tag and the   end tag as two separate actions; try to generate a   element node as a single action, and then generate its children.  In fact, when you see this kind of logic, you can be pretty sure that the problem being tackled is a group- ing problem. The solution to a grouping problem always involves two nested loops: In this case, an outer loop to generate the   element and an inner loop to generate the   elements. The solution to this particular grouping problem is shown as the ﬁrst example of how to use the group-adjacent attribute of  , on page 335 in Chapter 6.  Using disable-output-escaping to Wrap HTML in CDATA  One technique used quite often is to wrap HTML inside an XML document, for example:         Dept 178   App 263        <![CDATA[       ]]>          An HTML page with unmatched tags    HTML authors are often lazy!    One way you can include the HTML within the XML message is to put it through a program such as Dave Raggett’s html tidy utility  available from http:  www.w3.org  , which converts it to well-formed XHTML. But you may not want to risk changing it, so using a CDATA section as shown here is the only alternative. When you do this, however, the « » characters are no longer treated as markup characters; they are now ordinary text. If you try to run an XSLT transformation that outputs the HTML enclosed in this message, these characters will therefore be escaped, typically by writing them as «&lt;» and «&gt;». This isn’t what you want; so you can solve the problem by writing:           But remember that this is likely to work only if the output is serialized by the XSLT processor; it won’t work if you write the result to a DOM.  15  S e r i a  l i z a t i o n  947   Serialization  Character Maps as a Substitute for disable-output-escaping  Character maps are less powerful than disable-output-escaping, because you can’t switch them on and off for different parts of the result tree. But this is also their strength. The problem with disable-output- escaping is that it requires some extra information to pass between the transformation engine and the serializer, in addition to the information that’s deﬁned in the data model.  As evidence for this, look at the clumsy way that disable-output-escaping requests are encoded in a SAXResult stream in the Java JAXP interface.  This information is generally lost if you want to pass the result tree to another application before serializing it. The problem gets worse in XSLT 2.0, which allows temporary trees and parentless text nodes to be created and processed within the course of a transformation. One of the difﬁculties in designing this feature was whether a request to disable output escaping should be meaningful when the data being written was not being passed straight to the serializer, but was being written to a temporary tree or a parentless text node.  Most of the things that can be done with disable-output-escaping, including the bad things, can also be done with character maps. The big advantage of character maps is that they don’t distort the data model, which means that they don’t impact your ability to use a stylesheet-based transformation as a component in an application with clean interfaces to other components.  If you want to convert code that was written to use disable-output-escaping to use character maps instead, the most direct approach is to deﬁne substitutes for the characters that are changed by XML escaping:    <!DOCTYPE xsl:stylesheet [             ]>  <xsl:stylesheet version="2.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" xmlns:doe="http:  www.wrox.com xslt ch15 doe">                           <xsl:sequence select="translate $in, ’&lt;&amp;&gt;&apos;&quot;’, ’&doe-lt;&doe-amp;&doe-gt;&doe-apos;&doe-quot;’ " >     948   Summary  Then, wherever the existing code uses <xsl:value-of select="XXX" disable-output-escaping ="yes" >, change it to say  . This will replace the characters that are normally escaped by their substitutes, and the substitutes will be turned back into the unescaped original characters during serialization, by virtue of the character map.  Although this mechanical replacement of disable-output-escaping by character maps will always work, there may often be better ways of doing it in particular circumstances.  Remember that if you expose the unserialized result tree to another application, it will see the private-use characters such as xE801 in text and attribute nodes.  Summar y  This chapter has described the four serialization methods XML, HTML, XHTML, and TEXT, which can be invoked to process the XSLT result tree. It also explained the new XSLT 2.0 facility of character maps, and the XSLT 1.0 disable-output-escaping capability which it replaces, both of which are there to get you out of sticky corners when the standard serialization mechanisms prove inadequate.  This provides a nice link into the next chapter, which describes the range of techniques that allow vendors and users to extend the capability of XSLT when there is a need to do things that are outside the scope of the standard.  15  S e r i a  l i z a t i o n  949    Part III  Exploitation  Chapter 16: Extensibility  Chapter 17: Stylesheet Design  Chapter 18: Case Study: XMLSpec  Chapter 19: Case Study: A Family Tree  Chapter 20: Case Study: Knight’s Tour    Extensibility  Previous chapters have discussed standard features of the XSLT language. This chapter discusses what happens when you need to stray beyond the XSLT 2.0 language speciﬁcation. It’s concerned with questions such as:    What extensions are vendors allowed to provide?    How much are implementations allowed to vary from each other? How can you write your own extensions? How can you write stylesheets that will run on more than one vendor’s XSLT processor?        There is some interesting history here. XSLT 1.0 allowed stylesheets to call user-written extension func- tions but provided no standard way of writing them. The draft XSLT 1.1 speciﬁcation deﬁned a general mechanism for creating extension functions written in any language and then deﬁned detailed interfaces for Java and JavaScript  or ECMAScript, to give it its vendor-neutral name . This speciﬁcation was pub- lished as a working draft but was subsequently withdrawn. There were a number of reasons for this, one of which was simply that events were overtaken by the more ambitious XSLT 2.0 initiative. But part of the reason was that the proposals for standardizing extension function interfaces attracted heavy pub- lic criticism  see http:  xml.coverpages.org withdraw-xslScript.html . It’s difﬁcult in retrospect to summarize the arguments that were waged against the idea, but they probably fell into three cate- gories: some people thought extension functions were a bad idea in principle and should not be encour- aged, some people disapproved of singling out two languages  Java and JavaScript  for special treatment, and some people felt that the W3C shouldn’t be putting language bindings into the core XSLT speciﬁca- tion, the job should be done in separate speciﬁcations preferably produced by a different organization.  16  E x t e n s b  i  i l i t y  The result of this minor furor is that there is no deﬁned interface for writing extension functions, either in XSLT 1.0 or in XSLT 2.0. However, conventions have emerged at least for XSLT 1.0  the draft 1.1 speciﬁcation was inﬂuenced by these conventions, and in turn exerted its own inﬂuence on the products, despite being abandoned , and it is worth giving these some space.  At the time of writing this edition, only a limited number of XSLT 2.0 processors are available, and it is difﬁcult to see trends emerging as to what capabilities vendors will choose to provide. However, there’s no reason to believe that this will be signiﬁcantly different from the capabilities often found in XSLT 1.0 processors. Some of the examples in this chapter therefore relate to XSLT 1.0 processors such as MSXML from Microsoft and Xalan-J from Apache.                  Extensibility  What Vendor Extensions Are Allowed?  The XSLT 2.0 language speciﬁcation makes no distinction between what vendors are allowed to do, and what users and third parties are allowed to do. For example, it says that the set of languages supported by the format-date   function is implementation-deﬁned. This can be interpreted in two ways:  Vendors can support as many or as few languages as they think their target market requires. Vendors are allowed  but not required  to provide localization mechanisms that enable users or third parties to extend the set of supported languages.  Nowhere in the XSLT speciﬁcation does it say that implementors must provide facilities for users to deﬁne their own extensions. Many implementations will choose to do so, but to ﬁnd out what extensi- bility is permitted by the language, we need to look at two things: ﬁrstly, the information that is deﬁned to be part of the context or environment, and secondly, the features of the language whose behavior is implementation-deﬁned. There are detailed lists of these features in the W3C speciﬁcation, but they fall into a few broad categories.  Some features of the language are optional, in the sense that conformant processors are not required to provide them. For example, a processor can choose not to implement schema-aware processing, and it can choose not to implement the disable-output-escaping attribute or the namespace axis. Interfaces between the XSLT processor and the outside world are generally implementation- deﬁned. This includes the mechanisms for invoking the XSLT processor and delivering its results, the mechanism for reporting errors, and the details of how URIs are interpreted in con- structs such as  ,  ,  , and the document   and doc   functions. The XSLT vocabulary is extensible in ﬁve key areas. In each of these cases, the vendor can extend the vocabulary and, if they wish, they can also enable users or third parties to extend it:    Extension functions: The set of functions that can be called from XPath expressions, and any mechanisms for adding additional functions, are implementation-deﬁned, as long as any functions outside the language-deﬁned core are in a separate namespace. Extension instructions: The set of instructions that can appear in a sequence constructor is extensible, as long as the namespace used for any extension instructions is declared in the stylesheet in an «extension-element-prefixes» attribute. Extension attributes: Additional attributes can be added to any XSLT element, as long as they are in a separate namespace. There are rules limiting the effect that such attributes may have: essentially, they must not change the result of the transformation except to the extent that the W3C speciﬁcation leaves the result explicitly implementation-deﬁned. Extension declarations: Additional top-level declarations can be deﬁned in the stylesheet, provided that the element name is in a separate namespace. These are subject to the same constraints as extension attributes. Extension types: Additional types can be made available. This feature is deﬁned primarily so that extension functions can return application-oriented objects  for example, a sql:connect   function might return an object of type sql:DatabaseConnection , but there are no limits on how the facility might be used.                 The set of collations that can be used for sorting and comparing strings is implementation-deﬁned.    Many localization attributes, for example those used to control the formatting of dates and  numbers, have an implementation-deﬁned range of possible values.  954   Extension Functions  When the speciﬁcation says that the behavior of a particular feature is implementation-deﬁned, this places an onus on the vendor of a conformant product to describe in the product documentation what choices they have made. There are also some features of the language that are implementation-dependent: the dif- ference here is that vendors are not expected to document the exact behavior of the product. An example of an implementation-dependent feature is the maximum depth of recursion that is permitted. This will depend on a great many factors outside the software vendor’s direct control, so it’s not reasonable to expect a deﬁnitive statement.  Extension Functions  Extending the library of functions that can be called from XPath expressions has proved to be by far the most important way in which vendors extend the capability of the language, and so we will concentrate most of our attention on this particular extensibility mechanism.  When Are Extension Functions Needed?  There are a number of reasons you might want to call an extension function from your stylesheet:                       You might want to get data held externally, perhaps in a database or in an application. You may need to access system services that are not directly available in XSLT or XPath. For example, you might want to use a random number generator, or append a record to a log ﬁle. You might want to perform a complex calculation that is cumbersome to express in XSLT, or that performs poorly. For example, if you are generating SVG graphics, you might need to use trigonometric functions such as sin   and cos  . This situation arises far less with XSLT 2.0 than it did in 1.0, because the core function library is so much richer, especially in its ability to do string manipulation and date time arithmetic. But if the function you need is out there in some Java library, it’s no crime to call it. A more questionable use of external functions is to get around the ‘‘no side effects’’ rule in XSLT, for example to update a counter. Avoid this if you can; if you need such facilities, then you haven’t yet learned to think about solving problems in the way that is natural for XSLT. More on this in the next chapter.  There are two ways of using extension functions in XSLT. You can write your own extension func- tions, or you can call extension functions that already exist. These functions might be provided by your XSLT vendor, or they might come from a third-party library such as:  Dimitre Novatchev’s FXSL library at http:  fxsl.sourceforge.net . This library concentrates on providing the primitives needed for higher-order programming, and uses them to provide a basic set of operations equivalent to those found in languages such as Haskell. There are some interesting demonstrations of how these can be used to solve practical programming problems. Priscilla Walmsley’s FunctX library at http:  www.xsltfunctions.com. This library, available in both XSLT and XQuery forms, provides a remarkably extensive collection of utility functions for manipulating strings, numbers, dates, node sequences, and more. The EXSLT library found at http:  www.exslt.org   many EXSLT functions provide capabili- ties that are no longer needed in 2.0, but some of them, such as the mathematical functions, are still very relevant .  Actually some of these libraries are implemented in XSLT, which means that the functions they contain are not, strictly speaking, extensions at all. But the way you write your code to call them is the same either way, so the distinction isn’t really important.  955  16  E x t e n s b  i  i l i t y   Extensibility  Many XSLT vendors designed their interfaces for Java and JavaScript so that the extensive class libraries available in both these languages would be directly accessible to the stylesheet, with no further cod- ing required. This is certainly true for mathematical functions, string manipulation, and date handling. Which language you choose to use to write extension functions is a matter of personal choice, though it will be heavily constrained by the XSLT processor you are using. With a Java-based processor such as Saxon or Xalan-J, the natural choice is to write extension functions in Java. With Microsoft processors, the natural choice is a .NET language such as C. If you are using the Gestalt processor, it is probably because your favorite language is Eiffel. Processors written in C or C++ tend to require a more complex procedure for linking extension functions, if they are supported at all.  When Are Extension Functions Not Needed?  There is probably a tendency for newcomers to XSLT to write extension functions simply because they haven’t worked out how to code the logic in an XSLT stylesheet function. Slipping back into a program- ming language you have used for years, rather than battling with an unfamiliar one, is always going to be tempting when you have deadlines to meet. It’s understandable, but it’s not the right thing to do.  There are other wrong reasons for using extension functions. These include:              Believing that an XSLT implementation of the logic is bound to be slower: Don’t believe this until you have proved it by measurement — and don’t let it inﬂuence you unless you need the extra performance. I did a quick test to compare the FXSL code for calculating square roots  to four decimal places  using pure XSLT with a call to Java. This is a worst-case scenario because it’s very computation-intensive. Using FXSL took around 1900µs per call, while calling Java took 12µs. So there’s a signiﬁcant difference, but the question is, does it matter? Is that 1900µs going to be noticeable on the bottom line, and is it worth the cost of making your stylesheet processor- dependent? Supplying external data to the stylesheet: The best way to supply information to the stylesheet is in the form of a stylesheet parameter. Another good way is to provide the data in the form of an XML document, in response to a call on the document   function  many processors allow you to write logic that intercepts the URI supplied to the document   function, or you could use a URI that invokes a servlet or a Web service . Achieving side effects: There are some side effects that are reasonably acceptable, for example writing messages to a log ﬁle — these are basically actions that do not affect the subsequent processing of the stylesheet, so the order of events is not critically important. But trying to get round the no-side-effects rule in other ways is nearly always the wrong thing to do, though it can be very tempting. Sooner or later, the optimizer will rearrange your code in a way that stops your extension function from working. Using XSLT as a job control language: I have seen stylesheets that consist entirely of calls to exter- nal services, effectively using XSLT as a scripting language to invoke a sequence of external tasks. XSLT wasn’t designed for this role, and the fact that order of execution in XSLT is unde- ﬁned makes it a poor choice of tool for this job. Use an XML pipeline processor  XProc , a shell script language, or the ant utility.  Calling Extension Functions  Extension functions are always called from within an XPath expression. A typical function call looks like this:  my:function $arg1, 23, string title    956   Extension Functions  The name of an extension function will always contain a namespace preﬁx and a colon. The preﬁx  «my» in this example  must be declared in a namespace declaration on some containing element in the stylesheet, in the usual way. The function may take any number of arguments  zero or more , and the parentheses are needed even if there are no arguments. The arguments can be any XPath expressions; in our example, the ﬁrst argument is a variable reference, the second is a number, and the third is a function call. The arguments are passed to the function by value, which means that the function can never modify the values of the arguments  though if you pass nodes, the function may be able to modify the contents of the nodes . The function always returns a result.  We’ll have more to say about the types of the arguments, and the type of the result, in due course.  What Language Is Best?  Many processors offer only one language for writing extension functions  if indeed they allow extension functions at all , so the choice may already be made for you. Some processors offer a choice; for example Xalan-J supports both Java and JavaScript. Microsoft’s MSXML supports any of the usual scripting lan- guages, for example JScript and VBScript, and the System.Xml.Xsl processor in .NET allows any .NET language  C, C++, ASP.NET, VB.NET, and so on . Generally, I’d suggest using the native language for your chosen processor; for example, Java for Oracle, Saxon on Java, and Xalan-J; JScript for MSXML; Python for 4XSLT; Eiffel for Gestalt; and C for Saxon on .NET. If you want to use your stylesheet with more than one processor, write one version of the extension function for each language.  Client-Side Script  If you are generating HTML pages, your stylesheet can put anything it likes in the HTML page that it is generating. This includes   elements containing JavaScript code to be executed when the HTML page is displayed.  Don’t get confused between script that you generate in the output HTML, and script that is executed in your stylesheet during the course of the transformation. It’s especially easy to get the two confused when the transformation itself is running within the browser. Remember that stylesheet extension functions are always called using function calls in XPath expressions, while you are generating the HTML to be displayed. HTML   is always called in response to browser events such as the user clicking on a button.  16  E x t e n s b  i  i l i t y  Binding Extension Functions  When you call «my:function  » from within an XPath expression, the XSLT processor needs to ﬁnd a suitable function to call. This process is called binding. The XSLT speciﬁcation does not deﬁne how the binding is done, and a variety of approaches can be found in popular products. In this section, I will present a selection of these, if only to illustrate the variety of approaches in use.  Binding in MSXML  MSXML uses a special top-level element   to deﬁne extension functions, which may be written in a variety of languages, though JavaScript is the most popular. The JavaScript code is written inline within the   element.  The Microsoft .NET processor  System.Xml.Xsl  also supports this mechanism, but its use is discour- aged, and can lead to problems with memory usage.  957   Extensibility  Here is an example stylesheet that uses an extension written in VBScript, just to be different. The imple- mentation of the function is written inline within the   element.  Example: Using VBScript in an MSXML3 Stylesheet  This example shows a stylesheet that converts dimensions in inches to the equivalent in millimeters.  The source ﬁle is inches.xml. Double-click on it in Windows Explorer to invoke the stylesheet.        The size of the picture is  5  by  12 .    Source  Stylesheet  The stylesheet is to-mm.xsl. It contains a simple VBScript function within an   element, and invokes this as an extension function from the template rule for the   element.  <xsl:stylesheet  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" version="1.0" xmlns:extra="urn:extra-functions"  > <msxsl:script xmlns:msxsl="urn:schemas-microsoft-com:xslt"  language="VBScript" implements-prefix="extra"  > Function ToMillimetres inches   ToMillimetres = inches * 25.4  End Function                         mm         958      <xsl:value-of select="format-number extra:ToMillimetres number .  ,  ’0.00’ " >   Extension Functions  Output  The following text is displayed in the browser:  The size of the picture is 127.00mm by 304.80mm.  Note that this doesn’t work in Firefox, which doesn’t recognize the   element.  These scripts can call COM objects located via the system registry in the usual way. However, if the stylesheet is running in the browser, the user’s security settings may prevent your script from instantiating a client-side object.  Of course, this example uses an extension function to do something that could be trivially done within an XSLT 2.0 stylesheet function.  JavaScript and VBScript are both dynamically typed languages, which made them a good ﬁt with XSLT 1.0 and XPath 1.0. However, it’s easy to get tripped up by the fact that the function calling conventions aren’t always what you expect. For example, both in XPath 1.0 and in 2.0, if a function in the core library such as starts-with   expects a string, then you can supply an attribute node, and the value of the attribute will be extracted automatically  in XPath 2.0 this process is called atomization . JavaScript doesn’t declare the types of function parameters, which means that no such conversion is possible: if you supply an attribute node, that’s what the JavaScript code will see, and if it was expecting a string, it will probably fail.  The Xalan-J product also supports JavaScript extension functions using a similar mechanism, but this time the binding element is  , where the «xalan» preﬁx represents the URI http:  xml .apache.org xslt. Several   elements can be grouped together in a   element. Note that this mechanism only works with the interpreted XSLT processor, not with the XSLTC compiler which is also part of the Xalan-J bundle.  There’s nothing to stop you having an   declaration and a   declaration in the same stylesheet. An XSLT processor is required to ignore top-level declarations in an unknown namespace, so each processor will ignore the declaration that’s intended for the other. This means you can have two implementations of the same extension function in your stylesheet, one for use when you’re running MSXML, another for use when running Xalan.  Binding by Namespace in Java Processors  Most of the Java XSLT processors  Saxon, Xalan, jd.xslt, Oracle, xt  support an implicit binding of exten- sion functions to Java methods, based on the idea that the namespace URI used in the function identiﬁes the Java class, and the local name of the function corresponds to the method name. Xalan-J  which refers to this approach as the ‘‘abbreviated syntax’’ for extension binding  also allows the namespace URI to represent a Java package, leaving the local name of the function to represent both the class name and the method name.  For example, the following stylesheet can be used in Saxon to calculate a square root.  16  E x t e n s b  i  i l i t y  Example: An Extension Function to Calculate a Square Root  This example shows a stylesheet that returns the square root of a number in the source document.  959   Extensibility  Source  The source document is sqrt.xml:   2.0   Stylesheet  The stylesheet is sqrt.xsl. This stylesheet calls an external function Math:sqrt  , where the namespace preﬁx «Math» is bound to the namespace URI «java:java.lang.Math». Saxon recognizes namespace URIs beginning with «java:» as special — the part of the URI after the «java:» is interpreted as a Java class name. The processor loads this Java class  which must be on the classpath  and looks to see whether it contains a static method called «sqrt» that can take an argument that is a double. It does, so this method is called, and the result is taken as the return value from the function call.  <xsl:transform  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" xmlns:xs="http:  www.w3.org 2001 XMLSchema" exclude-result-prefixes="xs" version="2.0">        <xsl:value-of select="Math:sqrt xs:double .  "  xmlns:Math="java:java.lang.Math" >          Output     1.4142135623730951   Although each of the Java XSLT processors supports implicit bindings of Java methods to extension functions in much this kind of way, the details vary from one processor to another, and it may be difﬁcult to write code that is completely portable across processors. In particular, processors are likely to vary in how they map between the XPath types and Java types. This is especially true if the Java class contains several methods of the same name, but with different argument types  method overloading . To ﬁnd out the detail of how each processor handles this, you will need to consult the documentation for your speciﬁc product.  Most of what I’ve said so far about extension functions applies equally to XSLT 1.0 and XSLT 2.0. In fact, most of the processors mentioned do not yet have an XSLT 2.0 version. So it remains to be seen how vendors will tackle the challenge of mapping the much richer type system in XSLT 2.0 to Java classes.  Most of these processors allow a call on a Java method to return a wrapped Java object, which can then be supplied as an argument to another extension function. For example, you might have a function sql:connect   that returns an object of type ‘‘SQL connection,’’ and another function sql:query   that  960   Extension Functions  accepts a SQL connection as its ﬁrst argument. In XSLT 1.0, with its limited type system, this object is generally modeled using a single extra type ‘‘external object.’’ With XSLT 2.0, it is possible to go further than this and implicitly import any number of user-deﬁned types into the stylesheet. Saxon takes this to its logical extreme, and implicitly imports the whole of the Java class hierarchy, mapping class names into the namespace http:  saxon.sf.net java-type. The result is that  assuming the preﬁx «class» is bound to this namespace  you can declare a variable such as:  <xsl:variable name="connection" as="class:java.sql.Connection"  select="sql:connect ... " >  This means that these external objects can be used with complete type safety, because the Java class hierarchy has been mapped to the XSLT XPath type hierarchy.  Generally, processors map the common types into their obvious equivalent in the external programming language. For example, in Java, an xs:double maps to a Java double, an xs:string to a String, an xs:boolean to a Java boolean, and so on. The xs:integer type is a little tricky because XML Schema doesn’t deﬁne its maximum range; Saxon maps it to a Java long, but other products may make a different choice; for example «java.math.BigInteger». Bindings for the more common types are deﬁned in the Java Architecture for XML Binding  JAXB, see http:  java.sun.com xml downloads jaxb.html . The same bindings are used in the draft XQuery API for Java  www.xquery.com tutorials xqj tutorial  , and it’s quite likely that they will also be adopted by XSLT vendors. The more complex date, time, and duration types, which have no direct equivalent in Java, have been mapped to new classes introduced in JDK 1.5 for the purpose: Duration and XMLGregorianCalendar, both in package javax.xml.datatypes.  With XSLT 1.0 most XSLT processors naturally followed the weak typing approach of implicitly convert- ing the supplied parameters in the XPath function call to the required type declared in the Java method. However, with XSLT 2.0 it is more logical to switch to a stricter model aligned with the XPath 2.0 func- tion calling rules, where only very limited conversions between the supplied value and the required type are supported. For backward-compatibility reasons, however, Saxon still supports many implicit conversions, for example allowing a boolean to be supplied where an integer is expected.  When the values passed to an extension function are nodes, rather than atomic values, the data mapping issues become more complicated. The accepted standard for manipulating XML trees in most languages is the DOM, and it’s likely that many processors will offer extension functions the ability to manipulate nodes using the DOM interface, even though the DOM does not match the XSLT XPath data model particularly well. This is discussed in the section XPath Trees and the DOM on page 963.  Binding Using External Objects in the Microsoft .NET Processor  With the Microsoft System.Xml.Xsl processor, extension function calls are treated as calls to methods on external objects, and the objects themselves must be supplied by the calling application. A detailed expla- nation of the mechanism is given at http:  support.microsoft.com kb 323370 EN-US . For example, suppose you want to call the method GetPrice   on an object of class Product in the .NET namespace Inventory. You need to choose a namespace URI to refer to this extension object, say urn:Product. Then in the calling application, before invoking the XSLT processor, you can do:  Inventory.Product product = catalog.GetProduct ’12345’ ; XsltArgumentList args = new XsltArgumentList  ; args.AddExtensionObject ’urn:Product’, product ;  The argument list is supplied as a parameter to the Transform method that runs the transformation:  xslt.Transform xmlDoc, args, Response.OutputStream ;  16  E x t e n s b  i  i l i t y  961   Extensibility  In the stylesheet you can then call methods on this object using a call of the form:     One beneﬁt of this design is that it does not depend on dynamic loading of classes, which means it is likely to be fairly efﬁcient.  Binding to Assemblies in Saxon on .NET  Saxon runs both on Java and on .NET. The .NET version of the product uses a similar approach to the Java product, where the namespace URI part of the extension function name is used to identify the class, and the local part is used to identify the method within that class. The namespace URI, however, is rather more elaborate than that used in the Java case, reﬂecting the complexity  and power  of the mechanisms for controlling dynamic loading of assemblies in .NET.  Extension functions can be written in any .NET language  C is most common . To call a method GetPrice   in class Product in namespace Inventory, the general format is:  <xsl:value-of select="product:GetPrice  "  xmlns:product="clitype:Inventory.Product" >  If the assembly containing the code is a system assembly, or if it has been preloaded by the application, this is all that is needed. If the assembly needs to be dynamically loaded then additional information can be supplied in the form of query parameters. For example, to load an assembly that is stored with a strong name in the global assembly cache, you can specify the assembly name, version, and public key token as follows:  <xsl:value-of select="product:GetPrice  " xmlns:product=  "clitype:Inventory.Product?asm=InvApp;ver=5.0.0.1;sn="b03e5f7e11c50a4b" >  Saxon on .NET allows both static and instance-level methods to be invoked, in the same way as the Java product, and with similar conventions for mapping the argument types. It also allows property values to be accessed as if the property were a zero-argument method  the name is used as is, no ‘‘Get’’ preﬁx is added.   Binding to Extension Functions in Gestalt  The Gestalt XSLT 2.0 processor written by Colin Adams illustrates yet another approach to extension function binding.  Extension functions must be written in Eiffel, and each extension function is implemented as a subclass of XM_XPATH_SYSTEM_FUNCTION. The class needs to implement as a minimum a method evaluate_item    for functions with singleton results  or create_iterator    if the result is a sequence , and methods that tell the system what the types of the arguments and result are. The class can also override other methods such as optimize   that are called at compile time. For example, this would allow a function that accepts a regular expression as an argument to do some preprocessing of the regular expression at compile time if it is supplied as a string literal.  You then need to create an object representing your library of extension functions as a subclass of XM_XPATH_FUNCTION_LIBRARY, and you must register this function library with the XSLT processor via an API call add_extension_function_library   before running a transformation.  This approach to binding of extension functions puts a lot more burden on the developer, but it also gives the ability for close integration and high performance. Essentially, it means that extension functions written by users have exactly the same status as functions built into the system by the vendor.  962   XPath Trees and the DOM  Extension Functions  We haven’t got space in this book for a detailed description of the DOM interface, but most readers will already have come across it in some form, and it is described in detail in most good books on XML. The DOM provides an object model  and therefore an API  for navigating and manipulating XML data in tree form. Many XSLT processors allow extension functions to access nodes by using the methods deﬁned in the DOM API.  If you want extension functions to access the XSLT source tree, or a secondary input tree that was loaded using the document   function, or even a temporary tree constructed during the course of the XSLT transformation, then you can generally do this by passing a node as one of the function arguments. The extension function can then manipulate this node, and other related nodes such as its children and parent, as objects in a DOM structure. It may also be possible for an extension function to construct a new tree, and return it  typically as a DOM Document object  to the calling XPath expression, where it can be manipulated as a secondary input tree in the same way as the result of the XSLT document   function. Some products may also allow a DOM that’s passed to an extension function to be modiﬁed in situ — this is deﬁnitely a dubious practice, because it creates a dependency on order of execution, but it’s not absolutely prohibited.  The only problem with using the DOM in this way is that there are many small but signiﬁcant dif- ferences between the tree model used by XSLT and XPath, and the tree model deﬁned in the DOM speciﬁcation. For example, the DOM exposes entity references and CDATA sections, the XPath model doesn’t.  This is exacerbated by the fact that there are two different implementation approaches adopted by XSLT vendors: both are perfectly valid and both need to be catered for. Some products, such as Microsoft MSXML3, are DOM-oriented. This processor uses a DOM as its internal tree model, and provides the XPath model as a virtual data structure  a view or wrapper  on top of this. This means, for example, that CDATA sections will be physically present on the tree, and XPath operations such as following-sibling::node   will dynamically merge the CDATA contents with the surrounding text nodes. When an extension function is called, such a product will present the native underlying DOM to the called function, CDATA nodes and all. Other products  Saxon is an example, as is the XSLT processor in Microsoft .NET  use an internal data structure that is closely aligned to the XPath model described in Chapter 2. This data structure will have discarded any information that is not needed for XPath process- ing, such as CDATA sections and entity references. When an external function is called, the situation is now reversed; such a product will provide the DOM interface as a wrapper on top of the native XPath model.  16  E x t e n s b  i  i l i t y  It’s impossible to hide all the differences between these two approaches. For example, where the XSLT speciﬁcations dictate that whitespace nodes must be stripped from the tree, a DOM-oriented prod- uct will probably not remove these nodes physically from the tree, but will simply hide them from XPath view. A product that uses a native XPath tree is likely to remove the unwanted whitespace nodes from the tree while building the tree. This means that with one approach, the stripped white- space nodes will be present in the DOM as seen by extension functions, and with the other, they will be absent.  Another difference is that with a native XPath tree, adjacent text nodes will be merged  or normalized  into a single node, whereas with a native DOM tree, they may be unnormalized.  Actually, MSXML3 doesn’t always normalize text nodes correctly even in the XPath tree view.   What all this means is that if you want your extension functions to be fully portable between different processors, you have to be aware of these possible differences, and work around them. The following table lists the areas of potential differences between the DOM view and the XPath view.  963   Extensibility  XPath Node DOM Node Correspondence Document  One to one.  Document  Element  Attribute  Attr  Element  One to one.  Text  Text  The XPath tree never represents namespace declarations as attributes named xmlns or xmlns:*. The DOM might or might not have such Attr nodes. If the source document used entity references within the attribute value, these might or might not be preserved in the DOM. The value of the getSpecified property in the DOM is unpredictable.  The DOM text nodes might or might not be normalized. If CDATA sections were used in the original document, CDATA nodes might or might not be present in the DOM. If the source document used entity references within the text value, these might or might not be preserved in the DOM. Whitespace nodes that have been stripped as far as XSLT processing is concerned might or might not be present as text nodes in the DOM.  Processing instruction  Comment  Processing instruction  One to one.  Comment  One to one.  Namespace  N A  N A  N A  CDATA section  Entity reference  There is no direct equivalent in the DOM to XPath’s namespace nodes. It is possible in a DOM for elements and attributes to use namespace URIs that are not declared anywhere on the tree.  CDATA section nodes may be present on the DOM tree if this is the native data structure used by the processor, but they are unlikely to be present if the processor constructs a DOM from the XPath tree.  Entity reference nodes may be present on the DOM tree if this is the native data structure used by the processor, but they are unlikely to be present if the processor constructs a DOM from the XPath tree.  When you call methods deﬁned in the DOM, the result will follow the DOM rules, not the XPath rules. For example, in XPath the string value of an element node is the concatenation of all the text content within that element; but in the DOM, the apparently similar nodeValue   method returns null.  It’s not a good idea to attempt to update a DOM that is passed to an extension function. Three things might happen, depending on the implementation:           The attempt to update the DOM may cause an exception. If the DOM was constructed as a copy of the XPath tree, the updates may succeed, but have no effect on the tree as seen subsequently within the stylesheet. If the DOM and the XPath tree are different views of the same data, then updates may affect the subsequent XSLT processing. This might cause subsequent failures, for example, if nodes have been deleted while the XSLT processor holds references to them.  Constructing a new tree, in the form of a DOM, and returning this to the stylesheet as the result of the extension function, is perfectly OK if the implementation allows it.  964   Extension Functions  These rules for the mapping of XPath trees probably seem rather complicated, and there are certainly lots of potential pitfalls. My own advice would be to steer clear of this area if you possibly can. Navigating around the tree is something you can do perfectly well within XSLT and XPath; you don’t need to escape into a different language for this. It’s simpler, and usually quite adequate, to pass simple strings and numbers to your extension functions.  If you want to write an extension function that constructs and returns a new tree, you might well ﬁnd that a simpler alternative is to call the document   function and implement a URIResolver  or in .NET, an XmlResolver  that takes the URI provided in this call, and returns the relevant data source. The JAXP URIResolver interface is described in Appendix E, and an overview of the .NET transformation API is provided in Appendix D.  Calling External Functions within a Loop  I wanted to show an example that includes a reasonably realistic stylesheet with multiple calls on exten- sion functions. It turns out that all the examples I used for this in XSLT 1.0 are things that can be done quite straightforwardly with standard facilities in XSLT 2.0. However, with this caveat, I’ve decided to retain this example to show the principles.  This example is speciﬁc to the Saxon processor. It can be made to work with any processor that supports Java extension functions, but it will need minor alterations.  Example: Calling External Functions within a Loop  In this example, we will use a Java BufferedReader object to read an external ﬁle, copying it to the output one line at a time, each line being followed by an empty   element.  The alternative way of doing this would be to read the ﬁle using the unparsed-text   function described in Chapter 13, and then to break it into its lines using  .   Source  This stylesheet doesn’t need a primary source document. The real input is a serial ﬁle, which can be any text ﬁle. For example, the following hiawatha.txt:  16  E x t e n s b  i  i l i t y  Take your bow, O Hiawatha, Take your arrows, jasper-headed, Take your war-club, Puggawaugun, And your mittens, Minjekahwan, And your birch-canoe for sailing, And the oil of Mishe-Nama.  Stylesheet  The stylesheet can be downloaded as reader.xsl. First, we declare the namespaces we will need. It’s often easiest to declare these namespaces on the   element itself. I shall stick to the convention of using the «java:*» URI to identify the name of the Java class, and I will also use the abbreviated class name as  965   Extensibility  the namespace preﬁx. You won’t usually want these namespaces appearing in the result document, so you can suppress them using exclude-result-prefixes.  <xsl:stylesheet  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" version="2.0" xmlns:xs="http:  www.w3.org 2001 XMLSchema" xmlns:FileReader="java:java.io.FileReader" xmlns:BufferedReader="java:java.io.BufferedReader" exclude-result-prefixes="FileReader BufferedReader">  The name of the ﬁle we want to read from will be supplied as a parameter to the stylesheet. We need to declare the type of the parameter, because the Java class has three constructors that take a single argument, and Saxon needs to know  at compile time  which of them to call.     When we are ready to read the ﬁle, we create the BufferedReader in a variable. Then we call a template to read the ﬁle, line by line.       <xsl:variable name="reader"          select="BufferedReader:new FileReader:new $filename  " >        The read-lines template reads and outputs the ﬁrst line of the ﬁle, and then calls itself recur- sively to process the remainder. The readLine   method of the BufferedReader class returns null to indicate that the end of ﬁle has been reached, and in Saxon, a Java null is translated to a return value of an empty sequence. So we test whether to continue the recursion using the test «exists $line », which returns false when the return value was null.       <xsl:variable name="line"  select="BufferedReader:readLine $reader " >                         Note that this template is tail-recursive: it does no further work after calling itself. This means that a processor that provides tail-call optimization should be able to handle arbitrary long  966   Extension Functions  input ﬁles. A processor without this feature may fail with a stack overﬂow, perhaps after reading 500 or 1000 lines of text.  Output  When you run this stylesheet, you need to supply a value for the ﬁlename parameter. For example:  java net.sf.saxon.Transform -it:main -xsl:reader.xsl filename=hiawatha.txt  This command line invokes Saxon without a source document, specifying «main» as the name of the ﬁrst template to be executed, and «hiawatha.txt» as the value of the «filename» parameter. The output looks like this, adding newlines for clarity.      Take your bow, O Hiawatha,  Take your arrows, jasper-headed,  Take your war-club, Puggawaugun,  And your mittens, Minjekahwan,  And your birch-canoe for sailing,  And the oil of Mishe-Nama.     In this example, the function call does have side effects, because the reader variable is an external Java object that holds information about the current position in the ﬁle being read, and advances this posi- tion each time a line is read from the ﬁle. In general, function calls with side effects are dangerous, because XSLT does not deﬁne the order in which statements are executed. But in this case, the logic of the stylesheet is such that an XSLT processor would have to be very devious indeed to execute the statements in any order other than the obvious one. The fact that the recursive call on the read-lines template is within an   instruction that tests the $line variable means that the processor is forced to read a line, test the result, and then, if necessary, make the recursive call to read further lines.  The next example uses side effects in a much less controlled way, and in this case causes results that will vary from one XSLT processor to another.  16  E x t e n s b  i  i l i t y  Functions with Uncontrolled Side Effects  Just to illustrate the dangers of using functions with side effects, we’ll include an example where the effects are not predictable.  Example: A Function with Uncontrolled Side Effects  This example shows how a processor can call extension functions in an unpredictable order, causing incorrect results if the functions have side effects. This can apply even when the extension function is apparently read-only.  967   Extensibility  Source  Like the previous example, this stylesheet doesn’t use a source document. In this example we’ll read an input ﬁle containing names and addresses; for example, addresses.txt. We’ll assume this ﬁle is created by a legacy application and consists of groups of ﬁve lines. Each group contains a customer number on the ﬁrst line, the customer’s name on the second, an address on lines three and four, and a telephone number on line ﬁve. Because that’s the way legacy data ﬁles often work, we’ll assume that the last line of the ﬁle contains the string «****».  15668 Mary Cousens 15 Birch Drive Wigan 01367-844355 17796 John Templeton 17 Spring Gardens Wolverhampton 01666-932865 19433 Jane Arbuthnot 92 Mountain Avenue Swansea 01775-952266 ****  Stylesheet  We might be tempted to write the stylesheet as follows  addresses.xsl , modifying the previous example:  <xsl:stylesheet  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" version="2.0" xmlns:xs="http:  www.w3.org 2001 XMLSchema" xmlns:FileReader="java:java.io.FileReader" xmlns:BufferedReader="java:java.io.BufferedReader" exclude-result-prefixes="FileReader BufferedReader">         <xsl:variable name="reader"  select="BufferedReader:new FileReader:new $filename  " >                  <xsl:variable name="line1"  select="BufferedReader:readLine  $reader " >  968   Extension Functions     <xsl:variable name="line2"  <xsl:variable name="line3"  <xsl:variable name="line4"  <xsl:variable name="line5"  select="BufferedReader:readLine $reader " >  select="BufferedReader:readLine $reader " >  select="BufferedReader:readLine $reader " >  select="BufferedReader:readLine $reader " >                  Attn:                        What’s the difference? This time we are making an assumption that the four variables $line2, $line3, line4, and $line5 will be evaluated in the order we’ve written them. There is no guarantee of this. The processor is quite at liberty not to evaluate a variable until it is used, and if this happens then $line3 will be evaluated before $line2, and worse still, $line5  because it is never used  might not be evaluated at all, meaning that instead of reading a group of ﬁve lines from the ﬁle, the template will only read four lines each time it is invoked.  Output  The result, in the case of Saxon, is a disaster.        15 Birch Drive Wigan     Attn: Mary Cousens     John Templeton 17 Spring Gardens     Attn: 17796    19433 Jane Arbuthnot     Attn: 01666-932865              16  E x t e n s b  i  i l i t y  969   Extensibility         01775-952266 ****     Attn: Swansea   Saxon doesn’t evaluate a variable until you refer to it, and it doesn’t evaluate the variable at all if you never refer to it. This becomes painfully visible in the output, which reveals that it’s simply not safe for an XSLT stylesheet to make assumptions about the order of execution of different instructions. This stylesheet might work on some XSLT processors, but it certainly won’t work on all. The correct way to tackle this stylesheet in XSLT 2.0 is to read the whole text using the unparsed-text   function, then to split it into lines using either   or the tokenize   function, and then to use grouping facilities to split it into groups of ﬁve lines each. There is no need for extension functions at all.  This example raises the question of whether there is any way you can write a call to an extension function and be sure that the call will actually be executed, given that the function is one that returns no result. It’s hard to give a categorical answer to this because there is no limit on the ingenuity of optimizers to avoid doing work that makes no contribution to the result tree. However, with Saxon today a function that returns no result is treated in the same way as one that returns null, which is interpreted in XPath as an empty sequence. So you can call a void method using:     and provided the   instruction itself is evaluated, the method will always be called.  Keeping Extensions Por table  As soon as your stylesheet uses extension functions, or other permitted extensions such as extension instructions or extension attributes, keeping it portable across different XSLT processors becomes a challenge. Fortunately, the design of the XSLT language anticipated this problem, and offers some help.  There are a number of interrogative functions that you can use to ﬁnd out about the environment that your stylesheet is running in. The most important are as follows:        The system-property   function, which allows you to determine the XSLT version supported and the name and version of the XSLT processor itself. The function-available   function, which allows you to determine whether a particular exten- sion function is available. This is particularly useful when you are using a third-party library such as EXSLT, where the same functions may be available under a number of different XSLT processors.  Use these functions to test whether particular vendor extensions are available before calling them. The best way to do this is using the new «use-when» attribute described in Chapter 3, which allows a section of the stylesheet  perhaps a whole template, perhaps a single   instruction  to be condi- tionally included or excluded from the stylesheet at compile time. For example, the following code sets a  970   Summary  variable to the result of the random:random-sequence   function  deﬁned in EXSLT  if it is available, or to the fractional seconds value from the current time if not.  <xsl:variable name="random-number"  select="seconds-from-time current-time    mod 1.0e0" use-when="not function-available ’random:random-sequence’, 2  " xmlns:random="http:  exslt.org random" >  <xsl:variable name="random-number"  select="random:random-sequence 1,    " use-when="function-available ’random:random-sequence’, 2 " xmlns:random="http:  exslt.org random" >   In fact, the «use-when» attribute on the ﬁrst   declaration is not strictly needed, assum- ing these are local variables. If the «use-when» attribute on the second variable evaluates to true, this variable will shadow the ﬁrst variable, and it does no harm for both variables to be present.   Note that the rules for the «use-when» attribute require it to be a condition that can be evaluated at com- pile time. It’s therefore not permitted in this expression to reference the values of variables or stylesheet parameters, or to access the contents of a source document.  You can use similar techniques to make a stylesheet portable between different XSLT versions. In this case there are additional facilities available, notably the [xsl:]version attribute, which can be attached to any element in the stylesheet. Version compatibility is fully discussed in Chapter 3, on page 128.  Summar y  Extension functions are useful to extend the capabilities of XSLT stylesheets. They allow stylesheets to access external system services and to perform calculations that are difﬁcult or inefﬁcient to achieve in ‘‘pure’’ XSLT and XPath.  There are other extensibility mechanisms in XSLT, including extension instructions, extension decla- rations, and extension attributes, but extension functions are by far the most widely used, so that’s what we concentrated on in this chapter.  In the next chapter, we move away from detailed speciﬁcations of interfaces and look at using the facilities of XSLT to create well-designed stylesheets.  16  E x t e n s b  i  i l i t y  971    Stylesheet Design Patterns  This chapter looks at four common design patterns for XSLT stylesheets.  The concept of design patterns was introduced by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides in their classic book Design Patterns: Elements of Reusable Object-Oriented Software  Addison-Wesley Publishing, 1995 . Their idea was that there was a repertoire of techniques that were useful again and again. They presented 23 different design patterns for object-oriented programming, claiming not that this was a complete list but that the vast majority of programs written by experienced designers fell into one or more of these patterns.  For XSLT stylesheets, the vast majority of stylesheets I have seen fall into one of four design patterns. These are as follows:              Fill-in-the-blanks stylesheets Navigational stylesheets Rule-based stylesheets Computational stylesheets  Again, this doesn’t mean that these are the only ways you can write stylesheets, nor does it mean that any stylesheet you write must follow one of these four patterns to the exclusion of the other three. It just means that a great many stylesheets actually written by experienced people follow one of these four patterns, and if you become familiar with these patterns, you will have a good repertoire of techniques that you can apply to solving any given problem.  I describe the ﬁrst three design patterns rather brieﬂy, because they are not really very difﬁcult. The fourth, the computational design pattern, is explored in much greater depth — not because it is encoun- tered more often, but because it requires a different way of thinking about algorithms than you use with conventional procedural programming languages.  Fill-in-the-Blanks Stylesheets  Many proprietary templating languages have been built up around HTML. The template looks largely like a standard HTML ﬁle but with the addition of extra tags used to retrieve variable data and insert it at a particular point in the HTML data page. The designers of XSLT took care to ensure that, in spite of the  17  S t y l e s h e e t  D e s g n  i  P a t t e r n s   Stylesheet Design Patterns  power of XSLT as a full transformation language, it would still be possible to use it in this simple way, bringing it within the reach of nonprogrammers with HTML authoring skills.  Example: A ‘‘Fill-in-the-Blanks’’ Stylesheet  Here’s an example of such a stylesheet. It uses the simpliﬁed stylesheet syntax, so the   element and the   element are implicit.  Input  This XML document, orgchart.xml, represents an organization chart showing the senior management of a certain company at a particular date. It is organized as a recursive structure that directly reﬂects the management hierarchy. You may recognize the names, but the roles are entirely ﬁctitious.          Tim Berners-Lee   Chief Executive Officer         Sharon Adler   Technical Director      Tim Bray   Chief Engineer            James Clark   Director of Research               Henry Thompson   Operations and Finance                   David Megginson   Human Resources    Steve Muench   Marketing   974   Fill-in-the-Blanks Stylesheets   Scott Boag   International            Stylesheet  There are many creative ways to display this data; for example, you could use SVG graphics, Explorer-style trees implemented in client-side JavaScript, or just indented lists. I’m not trying to teach you any clever HTML tricks, so in this stylesheet  orgchart.xsl  I’ll show the data instead, as a rather boring table, with one row per person and three columns for the person’s name, their title, and the name of their boss.  <html xmlns:xsl="http:  www.w3.org 1999 XSL Transform"  xsl:version="2.0">   Management Structure            Management Structure   The following responsibilities were announced on  <xsl:value-of select="format-date  orgchart @date,  ’[D1] [MNn] [Y1]’ " >:         Name  Role  Reporting to                                       The key to this design pattern is that the stylesheet has the same structure as the desired output. Fixed content is included directly in the stylesheet as text or as literal result elements, while variable content is included by means of   instructions that extract the relevant data from the source document. Repeated sections of output, typically rows in a table or items in a list, can be enclosed by  , and conditional sections by   or  .  Output  The output of this stylesheet is shown in Figure 17-1.  17  S t y l e s h e e t  D e s g n  i  P a t t e r n s  975   Stylesheet Design Patterns  Figure 17-1  This kind of stylesheet makes very limited use of XSLT’s power, but it is very similar to a wide variety of proprietary templating languages currently in use. Experience has shown that this kind of stylesheet is easy for experienced HTML authors to write, even if they have no programming training. This is an important consideration, because on many larger Web sites there is a constant need to introduce new page templates at very short notice, and this becomes much easier to achieve if content authors and editors can do the work themselves.  One restriction, of course, is that the input has to come from an XML document. This contrasts with most of the proprietary languages, where the input often comes directly from a relational database. Fortu- nately, all popular relational databases now provide convenient ways to extract data from a database in XML form. Ideally, this doesn’t even need to be a serial XML document that has to be re-parsed by the XSLT processor. It will often be possible to transfer the data directly from the database to the XSLT pro- cessor in a structured form; for example, as a DOM tree in memory or as a SAX event stream. The details of how to do this depend on the database product you are using and are beyond the scope of this book.  Another approach is to use the document  function  described in Chapter 13, page 754  with a URI that addresses a servlet with parameters to retrieve the required data.  Navigational Stylesheets  Navigational stylesheets are a natural progression from simple ﬁll-in-the-blanks stylesheets.  Like ﬁll-in-the-blanks stylesheets, a navigational stylesheet is still essentially output-oriented. However, it is now likely to use named templates or stylesheet functions as subroutines to perform commonly  976   Navigational Stylesheets  needed tasks; it may use variables to calculate values needed in more than one place, and it may use constructs such as keys, parameters, and sorting.  Whereas a ﬁll-in-the-blanks stylesheet looks like HTML sprinkled with a few extra control statements, a navigational stylesheet  once you look beyond the angle-bracket syntax  has a rather similar structure to a conventional procedural program with variables, conditional statements, for loops, and subroutine calls.  Navigational stylesheets are often used to produce reports on data-oriented XML documents, where the structure of the source document is regular and predictable.  Example: A Navigational Stylesheet  This example shows the use of a navigational stylesheet to produce a very simple sales report.  Input  Suppose the source document, booklist.xml, looks like this:           Angela’s Ashes   Frank McCourt   HarperCollins   0 00 649840 X   6.99   235         Sword of Honour   Evelyn Waugh   Penguin Books   0 14 018967 X   12.99   12         Stylesheet  The following navigational stylesheet  booksales.xsl  produces a report on the total num- ber of sales for each publisher.  <xsl:stylesheet xmlns:xsl="http:  www.w3.org 1999 XSL Transform"  xmlns:xs="http:  www.w3.org 2001 XMLSchema" exclude-result-prefixes="xs" version="2.0">     We need to declare a variable that refers to the input document, for later use in a named template that has no context node.  17  S t y l e s h e e t  D e s g n  i  P a t t e r n s  977   Stylesheet Design Patterns     The global variable «$publishers» is a sequence of strings containing one string for each distinct publisher found in the source ﬁle. This uses the new distinct-values   function introduced in XPath 2.0.  <xsl:variable name="publishers" as="xs:string*"  select="distinct-values  booklist book publisher " >  The main template iterates over the distinct publishers using  .               Sales volume by publisher    Sales volume by publisher        Publisher  Total Sales Value                                    Finally, a named template that calculates the total sales for the publisher. The name of the publisher is supplied as an implicit parameter in the context node; however, to make the template more reusable a parameter is declared with this as the default.               This stylesheet is not very far removed from the ﬁll-in-the-blanks example earlier in the chapter. But because it uses some top-level elements such as   and a named tem- plate, it now needs to use the full syntax with an   element.  Output  The output is shown in Figure 17-2.  978   Navigational Stylesheets  Figure 17-2  The obvious difference between a ﬁll-in-the-blanks stylesheet and this navigational stylesheet is that the   and   elements are now explicit, which makes it possible to introduce other top-level elements, such as   and global   elements. More subtly, the range of XSLT features used means that this stylesheet has crossed the boundary from being an HTML document with added control instructions, to being a real program. The boundary, though, is a rather fuzzy one, with no visa required to cross it, so many people who have learned to write sim- ple ﬁll-in-the-blanks stylesheets should be able, as they expand their knowledge, to progress to writing navigational stylesheets of this kind.  Although the use of ﬂow-of-control instructions like  ,  , and   gives such a stylesheet a procedural feel, it does not violate the original concept that XSLT should be a declarative language. This is because the instructions do not have to be executed in the order they are written — variables can’t be updated, so the result of one instruction can’t affect the next one. For example, it’s easy to think of the   instruction in this example processing the selected nodes in document order and adding them one by one to the result tree, but it would be equally valid for an XSLT processor to process them in reverse order, or in parallel, as long as the nodes are added to the result tree in the right place. That’s why I was careful to call this design pattern naviga- tional rather than procedural. It’s navigational in that you say exactly where to ﬁnd the nodes in the source tree that you want to visit, but it’s not procedural, because you don’t deﬁne the order in which you will visit them.  New features available in XSLT 2.0 and XPath 1.0 greatly increase the scope of what can be achieved with a navigational stylesheet. Many problems that in XSLT 1.0 required complex programming  using the computational design pattern described later in this chapter  can now be tacked within the navigational approach. Examples include grouping problems, and problems that require splitting up of text ﬁelds, using delimiters such as commas or newlines, as well as many arithmetic operations such as summing the total value of an invoice. The features that provide this capability include the following:     The availability of sequences in the data model, together with the «for» expression in XPath, to manipulate them.  17  S t y l e s h e e t  D e s g n  i  P a t t e r n s  979   Stylesheet Design Patterns           Grouping constructs, including the   instruction in XSLT 2.0 and the distinct-values   function in XPath 2.0.  Text manipulation facilities, notably the   instruction in XSLT 2.0 and the replace   and tokenize   functions in XPath 2.0.  Aggregation functions such as avg  , min  , and max  .  The ability to write chunks of reusable code in the form of stylesheet functions that can be invoked from XPath expressions, rather than only as templates to be called using XSLT instructions, also helps to make navigational stylesheets much easier to write.  You will often see this kind of code criticized by experts because it doesn’t take advantage of XSLT’s most powerful feature, the ability to write template rules. The criticism is justiﬁed when you use this design pattern inappropriately, in a situation where a rule-based stylesheet would be better. But there are many simple problems where, in my view, this pattern works perfectly well. It produces code that is readable and efﬁcient.  Rule-Based Stylesheets  A rule-based stylesheet consists primarily of rules describing how different features of the source docu- ment should be processed, such as ‘‘if you ﬁnd a   element, display it in italic.’’  Some would say that this rule-based approach is the essence of the XSLT language, the principal way that it is intended to be used. I would say that it’s one way of writing stylesheets, often the best way, but not the only way, and not necessarily the best answer in every situation. It’s often strongly recommended in books for beginners, but I think that the main reason for this is that for many beginners the navigational pattern is what comes naturally, because it has a very similar feel to programs written in procedural lan- guages. It’s important that every XSLT programmer be comfortable with writing rule-based stylesheets, so it makes sense to teach this approach early on.  Unlike navigational stylesheets, a rule-based stylesheet is not structured according to the desired output layout. In fact, it makes minimal assumptions about the structure of either the source document or the result document. Rather, the structure reads like an inventory of components that might be encountered in the source document, arranged in arbitrary order.  Rule-based stylesheets are therefore most useful when processing source documents whose structure is ﬂexible or unpredictable, or which may change a lot in the future. It is very useful when the same repertoire of elements can appear in many different document structures, so a rule like ‘‘display dates in the format 23 March 2008’’ can be reused in many different contexts.  Rule-based stylesheets are a natural evolution of CSS. In CSS, you can deﬁne rules of the form ‘‘for this class of elements, use this display rendition.’’ In XSLT, the rules become much more ﬂexible, in two directions: the pattern language for deﬁning which elements you are talking about is much richer, and the actions you can deﬁne when the rule is ﬁred are vastly more wide-ranging.  A simple rule-based stylesheet consists of one rule for each element name. The typical rule matches a particular element name, outputs an HTML tag to deﬁne the rendition of that element, and calls   to process the child nodes of the element. This causes text nodes within the  980   element to be copied to the output and nested child elements to be processed each according to its own template rule. In its simplest form, a rule-based stylesheet often contains many rules of the form:  Rule-Based Stylesheets             This simple rule does a direct replacement of   tags by   tags. Most real stylesheets do some- thing a bit more elaborate with some of the tags, but they may still contain many rules that are as simple as this one.  XSLT 2.0 introduces the ability to deﬁne rules that match elements and attributes by their type, as deﬁned in a schema, rather than simply by their name or context. This makes the technique even more powerful when handling document structures that are highly complex or extensible. For example, you can match all the elements in a particular substitution group with a single template rule, which means that the stylesheet doesn’t need to change when new elements are added to the substitution group later. Similarly, you can deﬁne a template rule that formats all elements containing part numbers or dates, irrespective of the element or attribute name.  Example: A Rule-Based Stylesheet  Rule-based stylesheets are often used to process narrative documents, where most of the processing consists in replacing XML tags by HTML tags. This example illustrates this by showing how a Shakespeare play can be rendered in HTML.  Input  The input scene2.xml is a scene from a play; Act I, Scene 2 of Shakespeare’s Othello. It starts like this:        SCENE II. Another street.   Enter OTHELLO, IAGO, and Attendants with  torches       IAGO   Though in the trade of war I have slain men,   Yet do I hold it very stuff o’ the conscience   To do no contrived murder: I lack iniquity   Sometimes to do me service: nine or ten times   I had thought to have yerk’d him here under the ribs.               OTHELLO   ’Tis better as it is.   There are some complications that aren’t shown in this sample, but which the stylesheet needs to take account of.  17  S t y l e s h e e t  D e s g n  i  P a t t e r n s  981   Stylesheet Design Patterns  The top-level element is not always a  ; it might also be a   or  . The   element  representing a stage direction  can appear at any level of nesting; for example, a stage directive can appear between two speeches, between two lines of a speech, or in the middle of a line. Several people can speak at the same time. In this case a single   element has more than one  . In general, a   consists of one or more   elements followed by any number of   and   elements in any order.  Stylesheet  The stylesheet scene.xsl consists of a number of template rules. It starts by declaring a global variable  used simply as a constant  and a rule for the document element.  <xsl:stylesheet  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" version="1.0">                    h1 {text-align:center} h2 {text-align:center; font-size:120%; margin-top:12; margin-bottom:12} body {background-color:  } div.speech {float:left; width:100%; padding:0; margin-top:6} div.speaker {float:left; width:160;} div.text {float:left}                     Note the use of CSS to achieve the detailed styling. There’s nothing inconsistent about using XSLT and CSS in combination in this way. You can also generate a reference to an external CSS stylesheet, but the advantage of generating it inline is that the content can be parameterized. The appearance of   is a rare departure from the purely rule-based pattern, just to prove that none of the patterns has to be used to the exclusion of the others. The template rule for the   element outputs the names of the speakers on the left, and the lines of the speech, plus any stage directives, on the right. Rather than using HTML tables, which is often discouraged for accessibility reasons, we use CSS classes for the actual positioning as follows:        982   Rule-Based Stylesheets                         The remaining template rules are straightforward. Each of them simply outputs the text of the element, using an appropriate HTML rendition. The only complication, which doesn’t actu- ally occur in this particular scene, is that for some elements    and    the HTML rendition is different, depending on the element’s context, and so there is more than one rule deﬁned for these elements.                                                                      [         ]                             17  S t y l e s h e e t  D e s g n  i  P a t t e r n s  983   Stylesheet Design Patterns               This particular stylesheet doesn’t use any XSLT 2.0 features, so I left the version number as «1.0».  Output  The output obtained is shown in Figure 17-3.  Figure 17-3  984  Most of the time, a rule-based stylesheet creates a result tree with a structure similar to the source tree — with most of the source text appearing in the same order in the result document, usually with different tags. The closer this describes the transformation you want to do, the closer your stylesheet will be to the example shown above. However, this doesn’t mean that the processing has to be purely sequential. You can process chunks of the tree more than once using modes, you can reorder the nodes of the tree, and you can grab data from ancestor nodes, all without deviating from the rule-based design pattern.   Computational Stylesheets  The characteristic feature of a rule-based stylesheet is that there is generally one template rule for each class of object found in the source document. I use the term class very loosely here: the ‘‘classes of object’’ might correspond to types in a schema, or to element names, or perhaps to element names qualiﬁed by their context or content.  Of course, it’s possible to mix design patterns, particularly if your source document contains a mix- ture of ‘‘data-oriented’’ and ‘‘text-oriented’’ structures  an example might be a job application form . Then it’s quite appropriate to use a navigational pattern for the regular structures and a rule-based pattern for the less regular. For example, I created a Web site that provides information about concert soloists. This contains a mixture of structured data  their name, instrument or voice, photo, and contact details , semi-structured data about the performances they have taken part in, and unstructured text. The stylesheet to display the data contains a corresponding mixture of coding styles. The larger and more complex your stylesheet, the more likely it is to contain examples of each of the design patterns.  Computational Stylesheets                 Computational stylesheets are the most complex of the four design patterns. They arise when there is a need to generate nodes in the result tree that do not correspond directly to nodes in the source tree. With XSLT 1.0, this happened most commonly when dealing with structure in the source document that is not explicit in its markup. For example:  A text ﬁeld in the source might consist of a comma-separated list of items that is to be displayed as a bulleted list in the output. There might be a need to generate   elements in the output where a section is not explicit in the source but is deﬁned as comprising an   element and all its following sibling elements up to the next   element.  With XSLT 2.0, many of these problems can be tackled using new facilities built into the language: the ﬁrst of these examples can be handled using  , and the second using <xsl:for- each-group>. However, sooner or later you will exhaust the capabilities of these constructs and need to write a stylesheet in the form of a general-purpose program. Examples of such problems include the following:  Starting a new page  or other unit  when a running total has reached some threshold value Analyzing a parts explosion to see if it contains any cycles Creating graphical representations of numeric data using the vector graphics standard SVG as the output format  When you write computational stylesheets, you invariably run up against the fact that XSLT does not have an assignment statement, and that it is therefore not possible to write loops in the way you are probably used to in other languages. So you need to understand some of the concepts of functional pro- gramming, which the following section tries to explain.  17  S t y l e s h e e t  D e s g n  i  P a t t e r n s  Programming without Assignment Statements  Back in 1968, the renowned computer scientist Edsger Dijkstra published a paper under the title GoTo Statement Considered Harmful. His thesis, suggesting that programs should be written without goto statements, shattered the world as most programmers saw it. Until then they had been familiar with early dialects of FORTRAN and COBOL in which the vast majority of decisions in a program were  985   Stylesheet Design Patterns  implemented by using a construct that mapped directly to the conditional jump instruction in the hard- ware: «if condition goto label». Even the design notation of the day, the ubiquitous ﬂowchart drawn in pencil using a clear plastic template, represented control ﬂow in this way.  Dijkstra argued that structured programs, written using if-then-else and while-do constructs instead of goto statements, were far less likely to contain bugs and were far more readable and therefore main- tainable. The ideas were ﬁercely controversial at the time, especially among practicing programmers, and for years afterwards the opponents of the idea would challenge the structured programming enthusiasts with arguments of the form, ‘‘OK, so how do you do this without a goto statement?’’  Today, however, the battle is won, and the goto statement has been consigned to history. Modern lan- guages like Java don’t provide a goto statement, and we no longer miss it.  But for just as long, there has been another group of enthusiasts telling us that assignment statements are considered harmful. Unlike Dijkstra, these evangelists have yet to convince a skeptical world that they are right, though there has always been a signiﬁcant band of disciples who have seen the beneﬁts of the approach.  This style of coding, without assignment statements, is called Functional Programming. The earliest and most famous functional programming language was Lisp  sometimes ridiculed as ‘‘Lots of Irritating Superﬂuous Parentheses’’ , while more modern examples include ML, Haskell, and Scheme.  See, for example, Simply Scheme: Introducing Computer Science by Brian Harvey and Matthew Wright, MIT Press, 1999.   XSLT is a language without assignment statements, and although its syntax is very different from these languages, its philosophy is based on the concepts of functional programming. It is not a full-ﬂedged functional programming language because you cannot manipulate functions in the same way as data, but in most other respects, it ﬁts into this category of language. If you want to do anything complicated, you must get used to programming without assignment statements. At ﬁrst, it probably won’t be easy: just as early FORTRAN and COBOL programmers instinctively reached for the goto statement as the solution to every problem, if your background is in languages like C or Visual Basic, or even Java, you will just as naturally cherish the assignment statement as your favorite all-purpose tool.  So what’s wrong with assignment statements, and why aren’t they available in XSLT?  The crux of the argument is that it’s the assignment statements that impose a particular order of execution on a program. Without assignment statements, we can do things in any order, because the result of one statement can no longer depend on what state the system was left in by the previous statement. Just as the goto statement mirrors the jump instruction in the hardware, so the assignment statement mirrors the store instruction, and the reason we have assignment statements in our programming languages today is that they were designed to take advantage of sequential von Neumann computers with jump and store instructions. If we want to free ourselves from sequential thinking modeled on sequential hardware architecture, we should ﬁnd a way of describing what effect we want to achieve, rather than saying what sequence of steps the machine should take in order to achieve it.  The idea of a functional program is to describe the output as a function of the input. XSLT is a transfor- mation language; it is designed to transform an input document into an output document. So, we can regard a stylesheet as a function that deﬁnes this transformation: a stylesheet is a function O=S I  where I is the input document, S is the stylesheet, and O is the output document. Recall the statement made by James Clark at the 1995 Paris workshop, which I quoted in Chapter 1, page 28:  A DSSSL stylesheet very precisely describes a function from SGML to a ﬂow object tree.  986   Computational Stylesheets  This concept clearly remained a key part of the XSLT vision throughout the development of the lan- guage.  And, indeed, the ﬂow objects of DSSSL [Document Style Semantics and Speciﬁcation Language] eventually became the Formatting Objects of XSL-FO.   We’re using the word function here in something close to its mathematical sense. Languages like FOR- TRAN and Visual Basic have borrowed the word to mean a subroutine that returns a result, but the mathematical concept of a function is not that of an algorithm or sequence of steps to be performed, rather it is a statement of a relationship. The square-root function deﬁnes a relationship between 3 and 9, namely 3=sqrt 9 . The essence of a function is that it is a ﬁxed, constant, reliable relationship, and eval- uating it doesn’t change the world. When you ask me ‘‘what’s the square root of 9 if you work it out?’’ I can honestly reply ‘‘exactly the same as if I don’t.’’ I can say this because square root is a pure function; it gives the same answer whoever calls it and however often they call it, and calling it once doesn’t change the answer it gives next time; in fact, it doesn’t change anything.  The nice property of pure functions is that they can be called any number of times, in any order, and produce the same result every time. If I want to calculate the square root of every integer between zero and a thousand, it doesn’t matter whether I start at zero and work up, or start at a thousand and work down, or whether I buy a thousand and one computers and do them all at the same time; I know I will get the same answer. Pure functions have no side effects.  An assignment statement isn’t like that. The effect of an assignment statement ‘‘if you work it out’’ is not the same as if you don’t. When you write «x=x+1;»  a construct, incidentally, which most of us found completely absurd when we were ﬁrst introduced to programming , the effect depends very much on how often the statement is executed. When you write several assignment statements, for example:  temp = x; x = y; y = temp;  then the effect depends on executing them in the right order.  This means, of course, that a pure function can’t update external variables. As soon as we allow assign- ment, we become dependent on doing things in sequence, one step at a time in the right order.  Don’t object-oriented languages achieve the same thing by preventing one object from updating data held in another? No, because although they prevent direct writing to private data, they allow the same effect to be achieved by get   and set   methods. An update to a variable achieved indirectly through a deﬁned interface creates exactly the same dependence on sequence of execution as an update done directly with an assignment statement. A pure function must have no side effects; its only output is the result it returns.  The main reason that functional languages are considered ideal for a stylesheet language  or a tree trans- formation language, if you prefer  is not so much the ability to do things in parallel or in any order, but rather the ability to do them incrementally. We want to get away from static pages; if you’re showing a map of the trafﬁc congestion hotspots in your area, then when the data for a particular road junc- tion changes, you want the map updated in real time, and it should be possible to do this without recalculating and redrawing the whole map. This is only possible if there’s a direct relationship — a function — between what’s shown at a particular place on the map display and a particular data item in the underlying database. So if we can decompose our top-level stylesheet function, O=S I , into a set of smaller, independent functions, each relating one piece of the output to one piece of the input, then we have the potential to do this on-the-ﬂy updating.  17  S t y l e s h e e t  D e s g n  i  P a t t e r n s  987   Stylesheet Design Patterns  Another beneﬁt of this incremental approach is that when a large page of XML is downloaded from the network, the browser can start displaying parts of the output as soon as the relevant parts of the input are available. Some XSLT processors already do this: Xalan, for example, runs the transformation in parallel with the XML parsing process. If the stylesheet were a conventional program with side effects, this wouldn’t be possible, because the last bit of input to arrive could change everything.  The actual ‘‘functions’’ in XSLT take several forms. The most obvious functions in XSLT 2.0 are the stylesheet functions written using an   element. However, templates  both named tem- plates and template rules  also act as functions: the only real difference between an   and an   is that the former is called from an XPath expression, and the latter from an XSLT instruction.  XSLT template rules and stylesheet functions act as small, independent functions relating one piece of the output to one piece of the input. Functions and template rules in XSLT have no side effects; their output is a pure function of their input. Stylesheet functions follow this model more strictly than templates, because the only input they have is the values of the parameters to the function  plus global variables and the results of functions such as document  , which access parts of the context that cannot vary from one function call to another within a given transformation . Templates are less pure, because they also take the current position in the input document, and other context information, as implicit input parameters. But the principle is the same.  Technically, functions in XSLT are not completely pure, because they can create nodes with distinct identity. If a function creates and returns a new node  , then calling the function twice with the same arguments produces two elements with the same content but with different identity, which means that the expression «f   is f   » will return false. Fortunately, it’s not too difﬁcult for an optimizer to detect when a function has this characteristic.  It doesn’t matter in what order the template rules are executed, so long as we assemble their individual outputs together in the right way to form the result tree. If part of the input changes, then we need to reevaluate only those template rules that depend on that part of the input, slotting their outputs into the appropriate place in the output tree. In practice, of course, it’s not as easy as that, and no one has yet implemented an incremental stylesheet processor that works like this. However, many XSLT processors do take advantage of the freedom to change the order of evaluation, by using a technique known as lazy evaluation.  Lazy evaluation means, in general, that expressions are not evaluated until their values are actually needed. This provides two beneﬁts: ﬁrstly, it avoids allocating memory to hold the results.  Although modern machines have vast amounts of memory, processing large XSLT documents can be very memory- intensive, and the overhead of allocating and deallocating memory dynamically accounts for a lot of the cost of XSLT processing.  Secondly, lazy evaluation sometimes means that an expression doesn’t need to be evaluated at all. To take a simple example, in a function call such as «string-join $sequence, $separator », there is no need to evaluate the second argument unless the ﬁrst argument is a sequence containing two or more items.  Meanwhile, while the researchers and product developers work out how to optimize XSLT execution using incremental and parallel evaluation, you, as a user, are left with a different problem: learning how to program without assignment statements. After this rather lengthy digression into computer science theory, in the next section I shall get my feet back on the ground and show you some examples of how to do this.  However, ﬁrst let’s try and separate this from another programming challenge that arose with XSLT 1.0, namely the limited number of types available. This restriction has been greatly eased in XSLT 2.0, now  988   Computational Stylesheets  that arbitrary sequences are available in the data model. In terms of language design principles, the lack of assignment statements and the absence of a rich type system are quite separate matters. With XSLT 1.0, you often hit the two issues together:        The only effect a template could have was via the output it produced  because of the ban on side effects . And the only output it could produce, if you wanted to process it further, was a character string  because of the limited range of types available .  However, in XSLT 2.0 it becomes possible for a template to construct an arbitrary sequence or a tree, which can be used as input to further stages of processing. It is also possible for a template to return ref- erences to existing nodes in the source tree, without making a new copy. The introduction of temporary trees and sequences in XSLT 2.0 greatly reduces the contortions that are necessary to implement complex algorithms in your transformations.  So Why Are They Called Variables?  XSLT, as we have seen, does have variables that can hold values. You can initialize a variable to a value, but what you can’t do is change the value of an existing variable once it has been initialized.  People sometimes ask, why call it a variable if you can’t vary it? The answer lies in the traditional math- ematical use of the word variable: a variable is a symbol that can be used to denote different values on different occasions. When I say ‘‘area = length × breadth,’’ then area, length, and breadth are names or symbols used to denote values: here, they denote properties of a rectangle. They are variables because these values are different every time I apply the formula, not because a given rectangle is changing size as I watch.  Avoiding Assignment Statements  In the following sections I’ll look at some of the common situations where assignment statements appear to be needed, and show how to achieve the required effect without them.  Conditional Initialization  This problem has an easy solution, so I shall get it out of the way quickly.  In conventional languages you might want to initialize a variable to zero in some circumstances and to a value of one in others. You might write:  int x; if  zeroBased  {  x=0;  } else {  x=1;  }  How can you do the equivalent in XSLT without an assignment statement? The answer is simple. Think of the equivalent:  int x =  zeroBased ? 0 : 1  ;  17  S t y l e s h e e t  D e s g n  i  P a t t e r n s  989   Stylesheet Design Patterns  which has its parallel in XSLT 2.0 as:     Another useful expression when initializing variables is:     which selects the value of the discount attribute if there is one, or zero otherwise.  Neither of these constructs was available in XSLT 1.0.  Avoid Doing Two Things at Once  Another common requirement for variables arises when you are trying to do two things at once. For example, you are trying to copy text to the output destination, and at the same time to keep a note of how much text you have copied. You might feel that the natural way of doing this is to keep the running total in a variable and update it as a side effect of the template that does the copying. Similarly, you might want to maintain a counter as you output nodes, so that you can start a new table row after every ten nodes.  Or perhaps you want to scan a set of numbers calculating both the minimum and the maximum value; or while outputting a list of employees, to set a ﬂag for later use if any salary greater than $100,000 was found.  You have to think differently about these problems in XSLT. Think about each part of the output you want to produce separately and write a function  or template rule  that generates this piece of the output from the input data it needs. Don’t think about calculating other things at the same time.  So you need to write one function to produce the output and another to calculate the total. Write one template to ﬁnd the minimum and another to ﬁnd the maximum.  This might mean writing a little more code, and it might take a little longer because work is being repeated — but it is usually the right approach. The problem of repeated processing can often be solved by using variables for the sequences used as input to both calculations: if you need to use a particular set of nodes as input to more than one process, save that sequence in a variable, which can then be supplied as a parameter to the two separate templates or functions.  One problem I encountered where multiple results were needed involved processing a tree, making small changes if particular situations were encountered. At the end I wanted both the new tree and a ﬂag telling me whether any changes had been made. It turned out that the best way to solve this was ﬁrst to search the tree looking for the nodes that needed to change and then to process it again, making the changes. Although this incurs an extra cost in processing the tree twice when changes are needed, it achieves a signiﬁcant saving when no changes are needed, because it avoids making an unnecessary copy of the tree.  An approach that may sometimes give better performance is to write a template or function that returns a composite result. With XSLT 2.0, it is possible to return a composite result structured either as a sequence or as a tree. The calling code is then able to access the individual items of this sequence, or the individ- ual nodes of the tree, using an XPath expression. For example, the following recursive template, when supplied with a sequence of nodes as a parameter, constructs a tree containing two elements,   and  , set to the minimum and maximum value of the nodes, respectively. A working stylesheet based on this example can be found in the download ﬁle as minimax.xsl; it can be used with a source document such as booklist.xml.  990   Computational Stylesheets                      <xsl:with-param name="min-so-far"  select="if  number $nodes[1]  lt $min-so-far   <xsl:with-param name="max-so-far"  select="if  number $nodes[1]  gt $max-so-far   then $nodes[1] else $min-so-far" >  then $nodes[1] else $max-so-far" >                                 When you call this template, you can let the second and third parameters take their default values:                Minimum price is:  . Maximum price is:  .  One particular situation where it is a good idea to save intermediate results in a variable, and then use them as input to more than one process, is where the intermediate results are sorted. If you’ve got a large set of nodes to sort, the last thing you want to do is to sort it more than once. The answer to this is to do the transformation in two passes: the ﬁrst pass creates a sorted sequence, and the second does a transformation on this sorted sequence. If the ﬁrst pass does nothing other than sorting, then the data passed between the two phases can simply be a sequence of nodes in sorted order. If it does other tasks as well as sorting  perhaps numbering or grouping , then it might be more appropriate for the ﬁrst phase to construct a temporary tree.  There are actually two ways you can achieve a multistage transformation in XSLT:        Create a temporary tree in which the nodes appear in sorted order. Then use   or   to process the nodes on this tree in their sorted order. This is similar to the min-and-max example above; it relies on having either XSLT 2.0 or an XSLT 1.0 processor with the exslt:node-set  extension function. Use a sequence of stylesheets  often called a pipeline : the ﬁrst stylesheet creates a document in which the nodes are sorted in the right order, and subsequent stylesheets take this document as  17  S t y l e s h e e t  D e s g n  i  P a t t e r n s  991   Stylesheet Design Patterns  their input. Such a chain of stylesheets can be conveniently constructed using an XProc pipeline processor  http:  www.w3.org XML Processing   or if you prefer to write your own Java code, by using the JAXP interface described in Appendix E. The advantage of this approach compared with a single stylesheet is that the individual stylesheets in the chain are easier to split apart and reuse in different combinations for different applications.  Note that neither of these techniques violates the XSLT design principle of ‘‘no side effects.’’  Don’t Iterate, Recurse  One of the most common uses of variables in conventional programming is to keep track of where you are in a loop. Whether this is done using an integer counter in a «for» loop, or using an Iterator object to process a list, the principle is the same: we have a variable that represents how far we have got and that tells us when we are ﬁnished.  In a functional program, you can’t do this, because you can’t update variables. So instead of writing a loop, you need to write a recursive function.  In a conventional program a common way to process a list of items is as follows:  There’s no assignment statement here  the «item» variable is declared repeatedly within the loop and never changes its value once initialized . However, the code relies on the iterator containing some sort of updateable variable that keeps track of where it is, and the «iterator.next  » call implicitly changes the state of this internal variable.  In a functional program we handle this by recursion rather than iteration. The pseudocode becomes:  iterator = list.iterator  ; while  iterator.hasNext    {  Item item = iterator.next  ; item.doSomething  ;  }  function process list  { if  !isEmpty list   {  doSomething getFirst list  ; process getRemainder list  ;  }  }  This function is called to process a list of objects. It does whatever is necessary with the ﬁrst object in the list, and then calls itself to handle the rest of the list.  I’m assuming that getFirst   gets the ﬁrst item in the list and getRemainder   gets a list containing all items except the ﬁrst . The list gets smaller each time the function is called, and when it ﬁnally becomes empty, the function exits, and unwinds through all the recursive calls.  It’s important to make sure there is a terminating condition such as the list becoming empty. Otherwise, the function will keep calling itself forever — the recursive equivalent of an inﬁnite loop.  So, the ﬁrst lesson in programming without variables is to use recursion rather than iteration to process a list. With XSLT, this technique isn’t necessary to handle every kind of loop, because XSLT and XPath collectively provide built-in facilities, such as   and   and the «for» expression, that process all the members of a sequence, as well as functions like sum   and count    992   Computational Stylesheets  to do some common operations on sequences; but whenever you need to process a set of things that can’t be handled with these constructs, you need to use recursion.  Is recursion expensive? The answer is, not necessarily. Generally, a recursive scan of a sequence using the head tail method illustrated above has O n  performance, which means that the time it takes is directly proportional to the size of the list — exactly the same as with a conventional loop. In fact, it’s quite pos- sible for a reasonably smart compiler to generate exactly the same code for a recursive procedure as for an iterative one. A common compilation technique with functional programming languages is that of tail call optimization, which recognizes that when a function calls itself as the last thing it does  as in the proforma code above  there’s no need to allocate a new stack frame or new variables; you can just loop back to the beginning.  Unfortunately, not all XSLT processors implement tail call optimization, which means that a recursive scan of a list can run out of memory, typically after processing 500 or 1000 items. Among the currently available XSLT 2.0 processors, Saxon and Gestalt implement tail call optimization, while Altova appar- ently does not. A programming technique that is often useful in such cases is called divide-and-conquer recursion. With head-tail recursion, the function processes one item, and then calls itself to process the rest of the sequence, which means that the maximum depth of recursive calls is equal to the number of items in the sequence. With divide-and-conquer recursion, by contrast, the function calls itself to process the ﬁrst half of the sequence, and then calls itself again to process the second half. Although the number of function calls is the same, the maximum depth of recursion is now the logarithm of the size of the sequence: for example, to process a sequence of 1000 items the maximum depth of recursion will be 10. With a little ingenuity, many recursive algorithms that process a sequence of items can be written using this divide-and-conquer approach.  Time for some coding: the next example shows head-tail recursion in practice.  Example: Aggregating a List of Numbers  The following example uses a recursive template to process a whitespace-separated list of numbers.  Input  Suppose you have a string that holds a white-space-separated list of numbers, for example  12, 34.5, 18.2, 5 , and you want to replace this with a cumulative sequence  12, 46.5, 64.7, 69.7  in which each number is the sum of the previous values. An example of an application that might need to do this is a billing application, where the input sequence contains the values of individual transactions, and the output sequence shows a running balance. This could be done with an XPath expression such as follows:  for $i in 1 to count $seq   return sum $seq[position   = 1 to $i]   However, this involves n2 2 additions, which gets more and more expensive as the size of the sequence increases. It’s reasonable to look for a solution that is more scalable than this.  17  S t y l e s h e e t  D e s g n  i  P a t t e r n s  993   Stylesheet Design Patterns  For the sake of an example, this is the entire content of the document, number-list.xml.   12 34.5 18.2 5   We’ll suppose that there is a schema that validates this as a sequence of xs:decimal values, so we don’t need to be concerned with the parsing of the string; we can simply access the typed value of the element as a sequence.  To make this work in AltovaXML 2008, we added an «xsi:noNamespaceSchemaLocation» attribute to the source ﬁle. Altova uses this as a signal that validation is required.  Schema  The schema used to validate this trivial source document is number-list.xsd.                   Stylesheet  Here’s the recursive stylesheet  in ﬁle number-total.xsl :  <xsl:stylesheet xmlns:xsl="http:  www.w3.org 1999 XSL Transform"  xmlns:xs="http:  www.w3.org 2001 XMLSchema" xmlns:f="local-functions.uri" exclude-result-prefixes="xs f" version="2.0">              <xsl:variable name="x" as="xs:decimal"  select="$input[1] + $total" >                        994   Computational Stylesheets  To run this, you need a schema-aware XSLT2.0 processor, such as Altova or Saxon-SA.  With Saxon-SA, remember to set -val:strict on the command line. With Altova, the source document needs to contain a reference to the schema.  Notice how closely the function f:total-numbers mirrors the pseudocode structure given earlier. If the supplied list is empty, the function returns nothing  an empty sequence . The ﬁrst time the function is called, it returns the value of the ﬁrst item in the sequence  obtained by adding the value of this item to the running total, which is initialized to zero . It then calls itself to process the rest of the list and returns the result of this processing. Each subsequent time the function is called, it processes the ﬁrst value in what’s left of the input sequence, adds this to the running total that was supplied as a parameter, outputs this value, and then calls itself to process the tail of the sequence. Eventually, the function will call itself with an empty sequence as the argument, at which point it returns, unwinding the entire stack of function calls.  At ﬁrst sight this function looks tail-recursive: the recursive call is the last thing it does. But this is a false impression; on return from the recursive call, it has to append the result of that call with the ﬁrst item in the sequence, to construct a new result. So tail-call optimization might not apply here. However, there are ways that a clever processor can get round this problem.  Output       Here’s another example, this time processing a sequence of nodes. XPath provides built-in functions for counting nodes and for totaling their values, but they aren’t always ﬂexible enough; sometimes you need to walk round the nodes yourself.  17  Example: Using Interleaved Structures  XML makes it very easy to represent hierarchic structures, such as the chapters, sections, and paragraphs of a book. But what do you do when there are structures that are nonhierarchic? An example is the text of a play: one way of splitting the text is according to who is speaking, and another way is to follow the meter of the verse. The problem is that lines of verse aren’t neatly nested inside speeches, and speeches aren’t nested inside lines of verse: the two struc- tures are interleaved. The usual solution to this problem is to use the hierarchic XML tagging to represent one of the structures  say the speeches  and to use empty element tags to mark the boundaries in the other structure.  Another design approach is referred to as standoff markup: the markup for either or both of the structures is held separately from the text itself, using XPointer references to identify  S t y l e s h e e t  D e s g n  i  P a t t e r n s  995   Stylesheet Design Patterns  the text to which it relates. Markup of parallel structures is a complicated subject, of great concern to linguistics scholars, and many academic papers are devoted to the topic.   Input  This example  scene4-3.xml  is an extract from Shakespeare’s Othello, Act IV, Scene 3. I have departed from Jon Bosak’s markup to show the line endings as they are given in the Arden Shakespeare edition.       Enter OTHELLO, LODOVICO, DESDEMONA, EMILIA and attendants      LODOVICO  I do beseech you, sir, trouble yourself no further.        OTHELLO  O, pardon me: ’twill do me good to walk.        LODOVICO  Madam, good night; I humbly thank your ladyship.        DESDEMONA  Your honour is most welcome.       OTHELLO  Will you walk, sir?  O, Desdemona, -       DESDEMONA  My lord?       OTHELLO  Get you to bed  on th’ instant; I will be returned forthwith  dismiss your attendant there: look’t be done.        DESDEMONA  I will, my lord.   996   Computational Stylesheets     Exeunt Othello, Lodovico, and attendants     Output  Typically, a printed edition of this play is formatted with the kind of layout shown in Figure 17-4, in which lines that are split across multiple speeches are indented to show their relationship.  Figure 17-4  Achieving this format is not easy  especially details such as the omission of a new line if the indented text ﬁts on the same line as the speaker’s name , and it certainly requires a com- putational stylesheet to achieve it. Rather than attempt this, I will tackle a simpler problem, which is to invert the structure so that the primary XML hierarchy shows the lines, and the start of each speech is tagged by an empty element.      SCENE III. Another room In the castle.   Enter OTHELLO, LODOVICO, DESDEMONA, EMILIA and attendants      I do beseech you, sir, trouble yourself no further.      O, pardon me: ’twill do me good to walk.      Madam, good night; I humbly thank your ladyship.      Your honour is most welcome.    Will you walk, sir?   O, Desdemona, -    My lord?  17  S t y l e s h e e t  D e s g n  i  P a t t e r n s  997   Stylesheet Design Patterns    Get you to bed   on th’ instant; I will be returned  forthwith    dismiss your attendant there: look’t be done.      I will, my lord.    Exeunt Othello, Lodovico, and attendants     Stylesheet  I tackle this by processing the text sequentially, using a recursive template. The structure I have followed below is a two-phase approach. The ﬁrst phase ﬂattens the structure so that both the speech boundaries and the line boundaries are represented by empty ele- ments, appearing as siblings of the text nodes. The result of the ﬁrst phase is held in the variable $flat. This variable holds a sequence of  parentless  element and text nodes. The second phase then adds the hierarchic structure of   elements containing the text and   nodes. Here is the top-level logic of the stylesheet invert.xsl. Note how the second phase starts by processing only the ﬁrst node in the sequence $flat. after the initial  .  <xsl:stylesheet  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" version="2.0">               <xsl:apply-templates select="$flat NL[following-sibling::node  ]"     mode="phase2" >  Now the template rules for the ﬁrst phase, the ﬂattening phase. This is handled by a single rule which processes a   by ﬁrst creating a   element containing the name of the speaker and then copying all the nodes from the original except for the   element. We are assuming here that each speech has only one speaker.               We now have a ﬂat structure containing   elements, empty   elements, text nodes, and   elements. Phase 2 is structured so a template rule is called once for each node in the sequence $flat. In each case, this template rule calls <xsl:apply- templates> to process the next node in the sequence  and thus, by implication, the rest of the sequence beyond . I refer to this style of processing as sibling recursion. When an    998   Computational Stylesheets  element is encountered, a new   element is written to the result tree, and the follow- ing elements generate children of this   element. When any other kind of node is encountered, it is simply copied to the result tree at the current level.        <xsl:apply-templates  select="following-sibling::node  [1][not self::NL ]" > mode="phase2" >               <xsl:apply-templates  select="following-sibling::node  [1][not self::NL ]" mode="phase2" >       The expression «following-sibling::node  [1][not self::NL ]» selects the next sibling node, provided it is not an   element; if the next sibling is an   element, it selects an empty sequence. There is very little that is speciﬁc to XSLT 2.0 in this stylesheet, with the exception of the sequence of nodes used as an intermediate variable. The second phase could have been writ- ten without explicit recursion, using  , but in my view the recursive solution in this case is not really any more difﬁcult. This stylesheet also demonstrates that recursive processing of a sequence can often be car- ried out very elegantly, using  . I ﬁnd that there is a tendency when writing recursive code to reach straight for    or, in XSLT 2.0,    when   can often do the job far better. Superﬁcially, the logic of this stylesheet doesn’t bear much resemblance to the prototypical head tail recursive structure described earlier. But in fact, this is precisely the underlying structure. The «match="SCENE"» template selects all the   elements, each one implicitly identifying a sequence that starts with that   and continues up to the next  . The processing of this sequence is split between the two «mode="phase2"» template rules, each of which has the structure ‘‘handle this node, then recursively process the next sibling’’. Processing the next sibling here is effectively processing the remainder of the list. The test for the terminating condition is implicit, because   does nothing when the selected node sequence is empty.  Recursion: Summary  By now the principle should be clear. Whenever you need to ﬁnd something out by processing a sequence of items, write a recursive template that is given the sequence as a parameter. If the sequence isn’t empty, deal with the ﬁrst item, and make a recursive call to deal with the rest of the sequence that follows the ﬁrst item.  17  S t y l e s h e e t  D e s g n  i  P a t t e r n s  999   Stylesheet Design Patterns  As I mentioned, with XSLT 1.0 there was another problem when doing this, which had nothing to do with the lack of an assignment statement, but was a consequence of the limited range of types available. The result of a template in XSLT 1.0 was always a temporary tree, and with XSLT 1.0  without the widely implemented exslt:node-set  extension  there were only two things you could do with the tree: you could copy it to the ﬁnal result tree, or you could convert it to a string.  With XSLT 2.0, this becomes much easier because a template  or a function  can return an arbitrary sequence, which you can manipulate in any way you like. You can also choose to construct a temporary tree, which can now be manipulated just like an original source document. Furthermore, you can take advantage of the fact that in XSLT 2.0 a template rule or function can return references to existing nodes, by using the   instruction, so constructing a new tree is often unnecessary.  For another example that takes advantage of this, see the Knight’s Tour in Chapter 20.  This chapter described four design patterns for writing XSLT stylesheets:  Summar y              Fill-in-the-blanks Navigational Rule-based Computational  The approach to problems in the computational stylesheets may seem unfamiliar, because XSLT is a pure functional programming language, with no assignment statements or other side effects that constrain the order of execution. The result of this is that many of the more complex algorithms need to be written using recursive functions or templates.  1000   Case Study: XMLSpec  This is the ﬁrst of a group of three chapters that aim to show how all the facilities of the XSLT language can work together to solve real XML processing problems of signiﬁcant complexity. Most of the code is presented in these chapters, but the complete stylesheets, and specimen data ﬁles, can be downloaded from the Wrox Web site at http:  www.wrox.com .  As I described in the previous chapter, XSLT has a broad range of applications, and in these three chapters I have tried to cover a representative selection of problems. The three examples I have chosen are as follows:           The ﬁrst example is a stylesheet for rendering sequential documents: speciﬁcally, the stylesheet used for rendering W3C speciﬁcations such as the XML and XSLT Recommendations. This is a classic example of the rule-based design pattern described on page 980 in Chapter 17. The second example, in Chapter 19, is concerned with presenting structured data. I chose a complex data structure with many cross-references to illustrate how a navigational stylesheet can ﬁnd its way around the source tree: the chosen example is a data ﬁle containing the fam- ily tree of the Kennedys. This example is particularly suitable for demonstrating how stylesheets and schemas can work together. The ﬁnal example stylesheet, in Chapter 20, is quite unrealistic but fun. It shows how XSLT can be used to calculate a knight’s tour of the chessboard, in which the knight visits every square without ever landing on the same square twice. This is not the sort of problem XSLT was designed to solve, but by showing that it can be done I hope it will convince you that XSLT has the computational power and ﬂexibility to deal with the many more modest algorithmic chal- lenges that arise in routine day-to-day formatting applications. New features in XSLT 2.0 make this kind of application much easier to write, which means that the stylesheet is almost a total rewrite of the XSLT 1.0 version.  The stylesheet presented in this chapter was written for a practical purpose, not to serve as an example of good programming practice. I wrote in an earlier edition of this book that the stylesheet was originally written by Eduardo Gutentag and subsequently modiﬁed by James Clark. The stylesheet at that time was around 750 lines long. The current version has grown to over 3000 lines in three different stylesheet modules, and claims as its authors Norman Walsh, Chris Maden, Ben Trafford, Eve Maler, and Henry S. Thompson. No doubt others have contributed too, and I am grateful to W3C and to these individuals for placing the stylesheet in the public domain. Because the stylesheet has grown so much, and because many of the template rules are quite repetitive, I have omitted much of the detail from this chapter,  18  C a s e S t u d y :  X M L S p e c   Case Study: XMLSpec  selecting only those rules where there is something useful to say. But I haven’t tried to polish the code for publication — I am presenting the stylesheet as it actually is, warts and all, because this provides many opportunities to discuss the realities of XSLT programming. It gives the opportunity to analyze the code as written and to consider possible ways in which it can be improved. To the individuals whose code I am criticizing, I apologize if this causes them any embarrassment. I do it because I know that all good software engineers value criticism, and these people are all top-class software engineers.  Before embarking on this chapter, I did wonder whether there was any value in presenting in a book about XSLT 2.0 a stylesheet that is written almost entirely using XSLT 1.0. As the chapter progressed, I found that it actually provided a good opportunity to identify those places where XSLT 2.0 can simplify the code that needs to be written. I hope that it will therefore serve not only as a case study in the use of XSLT 1.0 but also as an introduction to the opportunities offered by the new features in 2.0.  Formatting the XML Speciﬁcation  In this worked example, we’ll study the stylesheet used for formatting the XML speciﬁcations themselves. You may have noticed that on the W3C Web site, you can get the speciﬁcations for standards such as XML, XSLT, and XPath either in XML format or in HTML. We’ll look at a stylesheet for converting the XML Recommendation from its XML form to its HTML form, shown in Figure 18-1.  Figure 18-1  The DTDs and stylesheets used for the XSLT, XQuery, and XPath speciﬁcations are adapted from the version used for the XML speciﬁcation, and we’ll take a look at the adaptations too.  The download ﬁle for this chapter on http:  www.wrox.com  contains the versions of the stylesheet modules that were actually used to publish the ﬁnal XSLT 2.0 Recommendation on January 23, 2007. These may differ slightly from the version presented in the text.  This stylesheet is a classic example of the rule-based design pattern, which was introduced on page 980 in Chapter 17. It makes minimal assumptions about where all the different elements in the XML source  1002   Formatting the XML Speciﬁcation  document appear relative to each other, and it allows new rules to be added freely as the document structure evolves.  You’ll probably ﬁnd it helpful while reading this stylesheet to have the XML source document readily accessible. The ofﬁcial version of XML 1.0 Fourth Edition  the document shown above  is located on the Web at http:  www.w3.org TR REC-xml REC-xml-20060816.xml.  There is also a DTD called xmlspec.dtd. You can view the source either in a text editor or in an XML editor, such as XML Spy, or by using the default XML viewer in Internet Explorer or Firefox. Because there is an   reference to an XSLT stylesheet  speciﬁcally, the stylesheet presented in this chapter , the browser will automatically apply the stylesheet and show you the generated HTML.  You might imagine that XML parsers these days are pretty reliable, and that XML published by W3C is likely to be problem-free. However, I get an error trying to display this XML in Internet Explorer. It chokes on the DTD, with the message ‘‘The character ’>’ was expected. Error processing resource ’http:  www.w3.org TR REC-xml xmlspec.dtd’. Line 218, Position 53’’, showing a sample of text that suggests some kind of buffer corruption. The local copy of the document, which is included in the download ﬁle for this book, is supposedly identical, but displays in IE without problems. Well, almost without problems. On my conﬁguration, to get the non-ASCII characters to display correctly, I have to change the stylesheet to say  .  There’s another separate problem with the XML  also in the DTD  that causes the Microsoft .NET parser to reject it. You can see this problem if you try to apply the stylesheets using Saxon on .NET. This time the message is: ‘‘‘xlink’ is an undeclared namespace. Line 380, position 9.’’ The element in question is a   element, and there’s no sign of an xlink namespace anywhere nearby. The DTD, however, adds attributes in the XLink namespace to a number of elements, and also attempts to declare the namespace at the same time. Since the DTD in this area is littered with comments saying ’’compensate for IE bug’’, it looks as if the authors have stretched the use of advanced DTD features to the point where it breaks widely used XML parsers. The lesson seems to be: keep things simple.  If you want to avoid these problems, just delete the text «SYSTEM "xmlspec.dtd"» from the second line of the XML document.  As often happens in publishing organizations, the W3C has struggled with the problem of improving its processes while also retaining backwards compatibility and a recognizable house style. It also has the classic conﬂict between the desire of the organization to maintain consistency of approach and the desire of editors to experiment and innovate. The stylesheet we are looking at was used to produce the fourth edition of the XML 1.0 speciﬁcation, over 8 years after the original, and in that time it has been adapted to be able to handle many other speciﬁcations as well. Some of these changes have found their way into the original stylesheets, and some have resulted in ‘‘forking’’ of the code, as we will see when we look at the versions used to produce the XSLT speciﬁcation.  The stylesheet used to publish XML 1.0 Fourth Edition consists of three modules: REC-xml.xsl, which imports diffspec.xsl, which imports xmlspec.xsl., as shown in Figure 18-2. While the role of diffspec.xsl is clearly to enable highlighting of changes between document versions, the functional split between the ﬁrst and third of these modules is less clear. However, most of the work is done in xmlspec.xsl, and it is on this module that we shall focus our attention.  18  C a s e S t u d y :  X M L S p e c  REC-xml.xsl  diffspec.xsl  xmlspec.xsl  Figure 18-2  1003   Case Study: XMLSpec  Preface  Let’s start at the beginning:         The stylesheet is an XML document, so it starts with an XML declaration. There’s no encoding declara- tion; actually, all the characters are ASCII, which means that any XML parser should be able to load this document without difﬁculty.  The comment is rather interesting. Earlier versions of the spec were published in HTML, not in XHTML. It’s not easy to maintain two versions of a stylesheet, one to generate HTML and one for XHTML, because all the result elements are in different namespaces in the two cases. It seems that the production team solved this problem by writing a stylesheet that generated the XHTML stylesheet from the HTML ver- sion, by changing namespaces where necessary. As I have remarked elsewhere in this book, stylesheets that modify stylesheets seem to crop up very often in real-world XSLT-based applications.  The conversion means that the XHTML namespace is present on many elements in the stylesheet, but I’ve left it out in presenting the code because it adds a lot of clutter.  <xsl:transform xmlns:xsl="http:  www.w3.org 1999 XSL Transform"  xmlns:saxon="http:  icl.com saxon" exclude-result-prefixes="saxon" version="1.0">  Note that the   element  which is of course a synonym for    speciﬁes «version="1.0"». This doesn’t guarantee that the stylesheet makes no use of XSLT 2.0 fea- tures, but it’s a good clue: it means that when the stylesheet is run on an XSLT 2.0 processor, it will run in backward-compatibility mode, and when run on an XSLT 1.0 processor, errors will be reported at com- pile time if any XSLT 2.0 constructs are found. This stylesheet is widely used to produce a whole range of documents, and like most other organizations, W3C wouldn’t want its business-critical publishing operation to rely on software that isn’t yet widely implemented. So the main stylesheet does indeed stick to XSLT 1.0. As we’ll see later, some of the ‘‘overlays’’ to the stylesheet do take advantage of 2.0.  The reference to the Saxon namespace  in fact the old Saxon 6.5 namespace  in the header turns out to be a red herring. There is no use of this namespace within the body of the document, and the stylesheet has no dependencies on features speciﬁc to Saxon or any other XSLT processor. Someone put this in to do some experiments and forgot to take it out. It does no harm, apart from raising a false alarm about the portability of the stylesheet.    <!-- xmlspec.xsl: An HTML XSL[1] Stylesheet for XML Spec V2.1[2] markup  Version: $Id: xmlspec.xsl,v 1.1 2006 08 15 19:18:25 plehegar Exp $  URI:  http:  dev.w3.org cvsweb spec-prod html xmlspec.xsl  Authors: Norman Walsh  norman.walsh@sun.com   Chris Maden  crism@lexica.net   1004   Preface  Ben Trafford  ben@legendary.org  Eve Maler  eve.maler@sun.com  Henry S. Thompson  ht@cogsci.ed.ac.uk   Date:  Created 07 September 1999 Last updated $Date: 2006 08 15 19:18:25 $ by $Author: plehegar $  -->  A fairly standard control header. There’s then some legal stuff, without which we would not be able to reproduce the code in this book. There’s a lot of change history as well, which I’ll leave out.     <xsl:strip-space elements="  abstract arg attribute authlist author back bibref blist body case col colgroup component constant constraint constraintnote copyright def definitions descr div div1 div2 div3 div4 div5 ednote enum enumerator example exception footnote front gitem glist graphic group header htable htbody inform-div1 interface issue item itemizedlist langusage listitem member method module note notice ol olist orderedlist orglist param parameters prod prodgroup prodrecap proto pubdate pubstmt raises reference resolution returns revisiondesc scrap sequence slist sourcedesc spec specref status struct table tbody tfoot thead tr typedef ul ulist union vc vcnote wfc wfcnote" >  These two elements together indicate that boundary whitespace  whitespace that appears in whitespace- only text nodes  is to be retained for all elements except the long list of elements whose whitespace is to be stripped. The   element here is actually redundant, because the default is to preserve whitespace anyway. The elements listed for stripping are essentially those that do not allow mixed content in the DTD. It would be nice if there were an easier way of achieving this, but sadly there isn’t, not even in XSLT 2.0.  Some processors, notably those from Microsoft and Altova, strip whitespace text nodes unconditionally before XSLT processing starts. This stripping can cause problems when the source document contains nodes in which whitespace is signiﬁcant. You can see the consequence of this in Figure 18-3, which shows an extract from section 1.2 of the XML Recommendation, as rendered in Internet Explorer.  Figure 18-3  18  C a s e S t u d y :  X M L S p e c  1005   Case Study: XMLSpec  Note the absence of any space between the hyperlinked phrase ‘‘XML processor’’ and the word ‘‘MUST’’. In the XML source, the relevant markup is:   An error which a conforming <termref i def="dt-xml-proc">XML processor    MUST  detect and report to the application.  Between the   element and the   element there is whitespace  lots of it , which should be displayed in HTML as a single space; but the Microsoft XML parser has stripped the space, so the words run together on the screen. The only real way to avoid this, when transformations are invoked using the   processing instruction, is to add an «xml:space="preserve"» attribute to some containing element in the XML source.  Let’s move on. The next thing in the stylesheet is a set of parameter declarations:                   These global parameters allow the behavior of the stylesheet to be customized. Like many publishing organizations, W3C tries hard to maintain a consistent house style for its publications, and the use of a common DTD and stylesheet goes a long way toward achieving this. However, different publications do have different requirements, so there is a need to manage variety. Sometimes, the authors needed to introduce a new feature in the stylesheet but didn’t want to change the way existing documents were rendered, so they put in a parameter to control the new feature. Sometimes, the parameters reﬂect the needs of different stages in the publication cycle; for example, the parameter «show.ednotes» controls whether editorial notes should be displayed.  In a previous version of the stylesheet some of these parameters were declared using the syntax.   1   It’s good to see that this has been ﬁxed. Placing the value in the content of the element means that the value is not a simple number or string, but rather a temporary tree, which however much the XSLT processor optimizes it is likely to be a much more heavyweight data structure. The use of «0» and «1» as parameter values, rather than the more obvious true   and false  , can be justiﬁed by the fact that with many XSLT processors, there is no way of supplying boolean parameter values from the command line.  There are two ways these parameters can be set. Either the values can be supplied from the calling application  typically, from the command line  or the parameters can be overridden in an overlay stylesheet. An overlay stylesheet  we’ll see examples later  is a stylesheet that imports the main xmlspec.xsl stylesheet and makes modiﬁcations or extensions to it. If the parameters were designed to be set in this way only, they could have been deﬁned using   rather than  , but using   is more versatile because it allows either mechanism to be used.       1006   Preface  The stylesheet uses two key deﬁnitions. These are designed to make hyperlinks within the document easier to follow. The ﬁrst key matches any attribute named «id», on any element, making it easy to ﬁnd an element with a given «id» attribute. The DTD allows an «id» attribute on any element whatsoever. In fact, it deﬁnes the type of the attribute to be «ID», so these elements could also be located using the id   function.  Sorry for the overloading of this term!  In fact, the stylesheet avoids the use of the id   function altogether, probably because id   isn’t guaranteed to work correctly unless the document is processed using a validating parser.  The second key deﬁnition is a little surprising. A   is a cross-reference: it is used wherever the text says something like ‘‘See section 8.2.’’ I wouldn’t expect to see any code that needs to locate all the cross-references; a more natural usage would be to index the elements that act as the target of a cross-reference. But on examination, it turns out that this key deﬁnition is not used. No doubt it is the result of another experiment, and someone forgot to delete it. Again, it does no harm — the chances are that an XSLT processor will completely ignore a key deﬁnition if the key is never used.  <xsl:output method="xml"  encoding="UTF-8" doctype-public="-  W3C  DTD XHTML 1.0 Transitional  EN" indent="no" doctype-system="http:  www.w3.org TR xhtml1 DTD xhtml1-transitional.dtd" >  The   declaration indicates how the result tree should be serialized. Although the stylesheet is designed to generate XHTML, it uses the XML output method because the XHTML method was intro- duced only in XSLT 2.0. The main difference is that XHTML serialization is more careful to avoid XML constructs that older HTML browsers might not handle correctly; for example, an empty paragraph represented as   . Setting «indent="no"» is sensible on a production stylesheet, because the out- put is much smaller. The deﬁnitions can always be changed in an overlay stylesheet, or in some cases from the command line  with Saxon, for example, by specifying «!indent=yes» .           No template matches      .          &lt;     &gt;     &lt;      &gt;         This is a useful catchall template rule to make sure that the source document and the stylesheet are consistent with each other. In principle, validating the source document against a DTD should ensure that it contains no surprises. But in practice, DTDs change over time, and there’s no way to be sure which version of the DTD was used — indeed, there’s no way to be sure that the document was validated at all. So this template rule matches any element for which there is no other more speciﬁc template rule in the  18  C a s e S t u d y :  X M L S p e c  1007   Case Study: XMLSpec  stylesheet. It produces a message  typically on the console  to indicate that an unexpected element was encountered, and it then copies the offending data to the result document in such a way that the start and end tags will show up visibly in the HTML  in red . This is a good way of helping document authors to notice and correct the error.  The   element is deprecated in XHTML 1.0. Perhaps the stylesheet author used it deliberately so that it would not only show up visually but would also be ﬂagged by an XHTML validator, thus forcing the document author to ﬁx the problem before publication.    element could  go here, but that doesn’t feel right. -->            Manually and automatically numbered productions    cannot coexist.              I don’t know why the stylesheet author felt uneasy about including the code to generate the   element in this template rule. Perhaps it was because the template rule for a document node is invoked when processing the root of any document tree, not only the principal source document. If the logic for creating the skeleton of the output HTML goes in the template rule for the outermost element  which in this case is called   , then it’s less likely to be invoked by accident when temporary trees or secondary input documents are processed.  The   in this rule is an example of a common technique, using the stylesheet to detect validity problems in the source document that cannot be enforced by a schema or DTD. I don’t think there’s any harm in using XSLT to do such validation, but my inclination would be to put it in a separate processing stage from the HTML formatting. It’s best to write XML applications as a pipeline in which individual steps perform separate functions.  With XML Schema 1.1, it should become possible to enforce contraints like this one as assertions in the schema.   The remaining rules in the stylesheet are presented in alphabetical order, by element. This is a good way of making sure that any rule can be found quickly. Unfortunately, it also has a drawback, which is that rules that work closely together  for example, the rules for formatting the front matter, or the rules for outputting syntax productions  can be widely separated in the source ﬁle. For the purposes of exposition, I’ve therefore regrouped them according to their logical function. The ﬁrst group I will consider are the template rules that handle the general outline of the HTML output.  Creating the HTML Outline  The main template rule is evaluated when the   element in the source document is encountered. This is always the outermost element of the XML document. It’s fairly lengthy, so we’ll take it piece by piece.          1008   Creating the HTML Outline                 The code starts by generating the   element, giving it a «lang» attribute if and only if the source document deﬁnes its language in the form    . This is useful because W3C speciﬁcations are often translated into languages other than English. Documenting which language is used can help search engines and browsers designed to make web pages more acces- sible; for example, with audio rendition. Exceptionally, I have shown the XHTML namespace declaration on this occasion; it actually appears on the outermost literal result element in every template rule.                           --                 The next stage is to output the   element. Most of the above section is concerned with generating the document title  as it appears in the title bar of the browser window . This is a concatenation of the   and   elements in the source   element. Given that the HTML title can’t contain any markup, I would probably have kept this code simpler. In XSLT 2.0 it can be abbreviated to:  <xsl:value-of select="header title, header version,   ’--’, $additional.title [$additional.title]" >  Note the call on the named template «css», which we’ll look at in a moment:                      &10;                End Notes      18  C a s e S t u d y :  X M L S p e c  1009   Case Study: XMLSpec                       <xsl:apply-templates select="  footnote[not ancestor::table ]"  mode="notes" >  The main content of the document is produced by the   call that immediately follows the   start tag. This processes the children of the   element, using their respective template rules, and generates the output of each of these children independently. There are generally three children:  ,  , and  . The header contains front material such as the status section and abstract, the body contains the numbered sections of the document, and the   element contains the appendices.  I haven’t come across a W3C document that uses footnotes or endnotes, which is what the rest of this rule is dealing with. It displays all   elements, other than those found within a  , as endnotes at the end of the document. A couple of comments on this code:        The XPath expression «  footnote[not ancestor::table ]» is probably fairly expensive to evaluate, as it involves a scan of the whole document. Because the expression is used twice, it’s a natural candidate for a variable. It’s possible that the author imagined that  &10;  would cause the following text to be displayed on a new line. In fact, HTML browsers treat a newline character exactly the same as a space. Alternatively, it’s possible that the author simply wanted to cre- ate some breaks in the HTML to make it usable in a text editor, without having to switch to  . Either way, it does no harm.  Actually, I’ve shown the code from the original HTML stylesheet here. The conversion to XHTML has caused the numeric charac- ter reference «&10;» to be replaced by a real newline, which upsets the indentation, though it doesn’t change the meaning.   The named template css, which is called from the above template rule, looks like this:          code  { font-family: monospace; }  div.constraint, div.issue, div.note, div.notice  ol.enumar ol.enumla ol.enumlr ol.enumua ol.enumur     { margin-left: 2em; }  { list-style-type: decimal; } { list-style-type: lower-alpha; } { list-style-type: lower-roman; } { list-style-type: upper-alpha; } { list-style-type: upper-roman; }     1010   Creating the HTML Outline     div.exampleInner pre { margin-left: 1em;  div.exampleOuter {border: 4px double gray;  div.exampleInner { background-color: d5dee3;  margin: 0em; padding: 0em}  margin-top: 0em; margin-bottom: 0em}  border-top-width: 4px; border-top-style: double; border-top-color: d3d3d3; border-bottom-width: 4px; border-bottom-style: double; border-bottom-color: d3d3d3; padding: 4px; margin: 0em }  div.exampleWrapper div.exampleHeader { font-weight: bold;  { margin: 4px }  margin: 4px}                  http:  www.w3.org StyleSheets TR           base      W3C-WD   W3C-REC   W3C-PR   W3C-CR   W3C-NOTE   base            .css            This code generates two elements within the HTML   element: a   element and a   element. Together, these deﬁne the CSS stylesheet that is used by the browser to render the HTML. This combined use of XSLT and CSS is one that I would very much recommend. It means that the XSLT stylesheet can be concerned with getting the structure of the HTML correct and can leave the ﬁne detail of fonts and margins to the CSS stylesheet.  Why use both a   and a  ? The   contains a reference to a CSS stylesheet stored on the W3C Web server, while the   contains local modiﬁcations and additions. I suspect that the reason for the split is to do with change control. Changing a CSS stylesheet on the Web server, when there are many documents that refer to it, is a risky thing to do, especially when many of these documents are supposed to be stable speciﬁcations. Making minor improvements to the formatting is safer if the modiﬁcations affect only new documents, not old. This could be achieved, of course, by introducing a  18  C a s e S t u d y :  X M L S p e c  1011   Case Study: XMLSpec  new version of the CSS stylesheet on the server. Perhaps, W3C  like many organizations  has change control processes that made it easier for the XSLT stylesheet authors to introduce the changes locally.  Note how both the   and the   can be customized. The   generates a reference to a CSS stylesheet conditionally, depending on the type of document. The various CSS stylesheets are identical except for the choice of a background image: the stylesheet for Working Drafts, for example, speciﬁes:  background-image: url http:  www.w3.org StyleSheets TR logo-WD ;  while that for Recommendations has:  background-image: url http:  www.w3.org StyleSheets TR logo-REC ;  body {  }  }  body {  This image contains the vertical text shown on the top left-hand corner of the displayed page.  The CSS deﬁnitions generated within the   element include any deﬁnitions present in the content of the variable $additional.css. By default, this holds an empty string. However, the vari- able can be overridden in an overlay stylesheet to deﬁne additional CSS display classes, and this is commonly done; for example, the XSLT speciﬁcation uses extra classes for displaying proforma XSLT element deﬁnitions.  There’s a bit of redundant coding in this template: the   conditions in the inner   could simply be added to the outer  . But it’s not wrong. Formatting the Document Header  The stylesheet generates the title of the HTML document by accessing the   element within the   element of the source XML ﬁle. To understand such expressions, you need to take a look at the structure of the   element in the source document. The actual ﬁle contains a lot of material that isn’t actually rendered in the HTML; some of this is in the form of XML comments, some in a more structured   element. Earlier editions of the XML speciﬁcation contained fascinating snippets such as:   1997-03-21 : TB : massive changes on plane flight from Chicago to Vancouver   but sadly, these are no longer present.  They were fascinating for two reasons: ﬁrst, because I’m sure that Tim Bray would have written that comment differently if he was intending it for a wide audience; second, because it shows that even the authors of the XML speciﬁcation committed the faux pas of using a private microsyntax within the XML elements, rather than marking up the structure of the entry in the form of three subelements: date, author, and details. This is one of the reasons that regular expression handling in XSLT 2.0 is so valuable. Try sorting these comments ﬁrst by author, then by date, using XSLT 1.0 alone.   In abbreviated form, the structure of the XML speciﬁcation starts like this:         Extensible Markup Language  XML  1.0   1012   Formatting the Document Header   &versionOfXML;  Fourth Edition    &doc.ident;   W3C Recommendation      &draft.day;   &draft.month.name;   &draft.year;    url    XHTML ,  XML , . . .                         url    url       Tim Bray   Textuality and Netscape    tbray@textuality.com      more authors              The Extensible Markup Language  XML  is a subset of SGML  that is completely described in this document . . .           This section describes the status . . .    This document specifies a syntax. . . It is a product of the   XML Core Working Group .  <loc role="erratumref" href="http:  www.w3.org XML xml-19980210-errataE100">[E100]   A list of current W3C Recommendations . . . can be found at   url .    This specification uses the term URI, which is defined by  , a work in progress expected to update   and  .          18  C a s e S t u d y :  X M L S p e c  1013   Case Study: XMLSpec  main section of document          appendices        Note that some of the tags are structural elements with predictable nesting, while others such as   can appear in all sorts of places, including inline within the text.  The next few template rules are all concerned with processing this header:                      <img src="http:  www.w3.org Icons w3c_home"  alt="W3C" height="48" width="72" >             <img alt="Member Submission"  src="http:  www.w3.org Icons member_subm" >                                &10;                                 1014   Formatting the Document Header        &10;                          &10;                                         Editor’s Draft                                                         18  C a s e S t u d y :  X M L S p e c  1015   Case Study: XMLSpec                       Copyright       &xa0;&xa9;&xa0;     &xa0;      W3C      &xae;          MIT          ,      <acronym title="European Research Consortium     ,    Keio    , All Rights Reserved. W3C    for Informatics and Mathematics">ERCIM       ,      liability   trademark    ,      document use     and    software licensing        rules apply.                 1016   Formatting the Document Header              There’s a lot of code here, though nothing especially complicated. One general criticism is that this tem- plate rule has grown far too big, which makes it difﬁcult for overlay stylesheets to make modiﬁcations; it would be better restructured to use one named template for each of the main output elements. Note that the template rule controls the ordering of items in the result document  for example, the abstract will always precede the status section, regardless of which comes ﬁrst in the source XML . However, the formatting of each subsection is delegated to a template rule for that particular element. This is there- fore a blend of the navigational and rule-based design patterns. The generation of HTML anchors is also delegated, this time to a named template with parameters. The template looks like this:                                       which in turn calls:                                              The anchor template generates an element of the form  . Generating both attributes helps to ensure maximum portability across different browser versions. If the parameter $conditional is set to «1», the template does nothing  actually, it computes an ID value and then ignores  18  C a s e S t u d y :  X M L S p e c  1017   Case Study: XMLSpec  it: an example where lazy evaluation will produce performance savings . The actual ID value is taken either from the @id attribute of the node passed as a parameter  which defaults to the context node , or from the $default-id parameter. Surprisingly, the $default-id parameter overrides the @id attribute, provided that it is indeed a unique identiﬁer within the source document.  It’s instructive to see how much easier this would all be with XSLT 2.0. We could start by rewriting the object.id template as a function:         <xsl:sequence select="  if  $default.id != ’’ and not $node key ’ids’, $default.id    then $default.id  else if  $node @id  then $node @id" >  else generate-id $node " >     If you prefer, the conditional expression in   could be written more concisely as:  select=" $default.id[. != ’’ and not $node key ’ids’,.  ],  $node @id, generate-id $node  [1]"  The anchor template could also be turned into a function:                          and a call on this template, previously written as:               can now be rewritten as:     Apart from reducing the size of the two templates from 14 15 lines to 10 lines or less, the size of the call is reduced from 5 lines to 1, and because the anchor template is called 21 times in the stylesheet, this reduces the total size of the stylesheet by 94 lines.  I hope your productivity is not measured by the number of lines of XSLT code that you produce.  Some people argue that verbosity is not a problem in itself, but in my view, if you can see the whole of a template or function on the screen at one time, you are likely to understand its logic more quickly and to make fewer mistakes when you modify it.  1018   Creating the Table of Contents  The only thing you lose by doing this conversion is the ability of the templates to have default parameters. But I’m not entirely sure this is a great loss: certainly, it’s a feature that many languages don’t provide.  Creating the Table of Contents  Immediately after the header, the ﬁrst part of the body of the document is the table of contents. This is generated from within the template rule for the   element, and it is controlled by a parameter $toc.level that deﬁnes the number of levels in the table of contents; for example, if this is set to «2», then ﬁrst- and second-level headings will be listed. HTML cannot produce page numbers, so the table of contents instead contains hyperlinks to the headings of the actual sections.            &10;                Table of Contents                 &10;               1">     Appendi      ces         x               <xsl:apply-templates mode="toc"     select=".. back div1  .. back inform-div1" >                 End Notes      18  C a s e S t u d y :  X M L S p e c  1019   Case Study: XMLSpec                           The   template rule generates the table of contents, and then it uses   to process its own children. The table of contents is produced by applying templates to all the top-level     sections and appendices in a special mode «toc», and by generating the headings «Table of Contents», «Appendix» or «Appendices», and «End Notes», as required. There is also provision for referencing appendices that are automatically generated by the stylesheet, for example a glossary or index of error codes.  Nine lines of code to generate ‘‘Appendix’’ or ‘‘Appendices’’! In XSLT 2.0, that becomes  <xsl:value-of select="if  count .. back  div1inform-div1   = 1   then ’Appendix’ else ’Appendices’" >  Let’s see how the table of contents is produced. The structure of the   element, and also of  , consists of a sequence of   elements representing top-level sections, like this:      First-level heading   Some text      Second-level heading   Some more text      Third-level heading   Lots more text            Each   element contains a   element giving its section title, paragraphs of immediate content, and zero or more   elements containing level-2 subsections. The   elements similarly contain a   and zero or more   elements for level-3 subsections, and so on.  In the   section, a non-normative appendix is represented by an   element instead of the usual  , but otherwise the structure is the same.  Non-normative is jargon meaning ‘‘for information only, not ofﬁcially part of the speciﬁcation.’’  The template rule that generates an entry for a top-level section in the table of contents looks like this:            1020   Creating the Table of Contents                         &10;              This starts by applying templates to itself with mode divnum; this invokes a template to calculate the section number. We’ll take a look at this template rule shortly. The rule then generates an HTML   element to produce a hyperlink. The href attribute is generated by calling a named template href.target, with the current node  the   element  as a parameter. The content of the   element  the displayed text that the user clicks on  is produced by applying templates to the   element, with the special mode text. The stylesheet doesn’t actually contain a template rule for this mode; it is used simply to invoke the built-in template rule, which returns the textual content of the   element, minus any markup.  The «href.target» template looks like this:                                   To my mind this is crying out to be replaced by an XSLT 2.0 function, something like:             This would allow the code:                         18  C a s e S t u d y :  X M L S p e c  1021   Case Study: XMLSpec  to be rewritten as:           If the global parameter $toc.level is greater than one, then the   elements that are children of this   are processed in mode «toc» to generate another level in the table of contents.  The template rule for   elements in mode «toc» and the template rules for further levels, such as  , are very similar to the   rule. They differ only in that they apply templates to the next level down  the   template processes the   children, and so on  and in the amount of indentation added before the section number — this is added crudely in the form of four nonbreaking spaces per level, using the instruction:   &xa0;&xa0;&xa0;&xa0;   Hexadecimal «a0»  decimal 160  is the Unicode code for the nonbreaking space character, better known to HTML authors as the entity reference «&nbsp;». This is not available as a built-in entity in XML. It is possible to deﬁne it as an entity in the DTD, but the authors of this stylesheet chose to write it explicitly as a numeric character reference.  It wouldn’t be difﬁcult to write a parameterized template that handled all the   elements in one rule, but the alternative approach of writing ﬁve separate rules is perfectly defensible.  The templates to calculate section numbers have one variant for each level of heading, and also vary depending on whether the section is in the    a main section  or in the   matter  an appendix . Here are some of them:                                                    <xsl:number level="multiple"  count="div1  div2  div3  inform-div1" format="A.1.1 " >     1022   Creating Section Headers  All these templates work by calling   with appropriate parameters. The default «level="single"» is used for the top-level headings, and «level="multiple"» for all other levels, with a «count» attribute that matches that level and all ancestor levels. The format of the numbering is adjusted for appendices  sections with   as an ancestor  to use alphabetic identiﬁers  A, B, C, . . .   for the ﬁrst component of the number.  Giving a list of alternatives in the count attribute is a common way of doing multilevel numbering. It means, in effect, outputting a sequence number for each ancestor element that is either an   or a   or a   and so on. Like most template rules in a rule-based stylesheet, it doesn’t attempt to do any validation: if the input structure is wrong, it will produce some sort of out- put nevertheless, and it’s up to the document author to work out what the problem is. This raises an interesting question that you need to consider when designing your own stylesheets: Is it the job of the stylesheet to detect and report on errors in the source document?  The use of   as a separate tag for non-normative appendices was a pretty clumsy design decision, and the stylesheet author has to pay the price here. It would have been much cleaner to give the   element an attribute «normative="no"». Sadly, it is often the case that stylesheet authors have to cope with XML structures that could have been designed better. In XSLT 2.0, if this stylesheet were schema aware, it’s likely that   would be in the substitution group of  , and it would then be possible to replace all references to «div1» in these template rules by «schema- element div1 », which would pick up the   elements automatically.  It would again be possible to make these template rules generic across levels. In fact, the template rule shown above for   elements would produce exactly the right output if it were applied to a   or   element, because of the way that   is deﬁned. The «format» attribute of   can also be parameterized using an attribute value template: in XSLT 2.0 one could write:     <xsl:number level="multiple"  count="div1  div2  div3  inform-div1" format="{if  ancestor::back  then ’A.1.1’ else ’1.1.1’}" >     However, it does no harm for the stylesheet author to spell things out more explicitly.  The templates for producing section numbers in the table of contents are reused, of course, when produc- ing the section numbers in the body of the document. I’ll describe how this is done in the next section.  18  Creating Section Headers  We’ll now look at the template rules used to format the section headers. These all have the same structure, and they reuse components we have already seen: the named anchor template that generates the target of a hyperlink, and the divnum mode that produces the section number for any given section. Here are the ﬁrst two:                     C a s e S t u d y :  X M L S p e c  1023   Case Study: XMLSpec                                      It would be entirely possible to use a single generic template by replacing the literal result element   with the construct:     This uses the XPath 2.0 replace   function, but the same logic could be written almost as easily by using XPath 1.0 functions such as concat   and substring-after  . Another way to avoid repetition of code between these templates would be to write separate template rules at the top level and call a common component to produce the inner content:                                                     Yet another approach would be for the common template rule to be invoked using   rather than by using a separate mode.  Formatting the Text  The bulk of the stylesheet is taken up with template rules to process simple textual markup within the body of the document. Most of these are very straightforward, and to avoid tedious repetition I will show only a small sample of them.  1024   Probably the most common element is the   element, which marks a paragraph, as in HTML:  Formatting the Text                                                            are equivalent to the single line:     You’ve probably got the message by now that I don’t much like unnecessary verbosity. The ﬁrst thing I notice about this template rule is that the ﬁve lines:  The next is that   renames the «role» attribute as «class», so it’s less easy to simplify, though with XSLT 2.0 you can reduce it to:           But the essential structure of this template rule is typical of many others: it translates one element in the source document into one element in the result document, making minor adjustments to the attributes, and then calls   to process the content of the element. This is the typical style of a rule-based stylesheet. Here are some other simple examples of such rules:                                18  C a s e S t u d y :  X M L S p e c  1025   Case Study: XMLSpec                                             elements, but browser support is abysmal-->     "     "    ,                There are some elements in the XML that are not rendered in the HTML at all, for example:           I generally write empty template rules using the shorter style:     but one can’t criticize this writer for adding a comment to make the intention clear.  The XML speciﬁcation represents tables in exactly the same way as HTML, except that some additional attributes are permitted. So the template rule’s job is essentially to copy the element while adjusting those attributes:                             1026   Formatting the Text                                                                 I think I would have been inclined to handle these attributes using template rules, especially as we’ve already seen the same code to rename a role attribute as a class attribute, elsewhere in the stylesheet. Instead of   and the big   instruction, I would write  , with the three template rules:  In a previous version of the stylesheet, the above rule was also used to handle   and   elements. These have now been extracted into a separate rule:                                                 18  C a s e S t u d y :  X M L S p e c  1027   Case Study: XMLSpec           Careful inspection reveals that the only difference is the handling of the colspan and rowspan attributes; if the original template had been restructured to apply templates to the attributes, this modiﬁcation could have been handled without duplicating the logic by deﬁning a few new rules:           This is a good demonstration of how the ‘‘push’’ style of processing using   can give stylesheets greater potential for change than the ‘‘pull’’ style using  .  Producing Lists  The DTD for these documents provides a number of ways of deﬁning lists. For example, an ordered list looks like this:   The design goals for XML are:      XML shall be straightforwardly usable over the  Internet.      XML shall support a wide variety of applications.     XML shall be compatible with SGML.     It shall be easy to write programs which process XML  documents.      The number of optional features in XML is to be kept    XML documents should be human-legible and reasonably  to the absolute minimum, ideally zero.    clear.      The XML design should be prepared quickly.     The design of XML shall be formal and concise.     XML documents shall be easy to create.     Terseness in XML markup is of minimal importance.      The rule for ordered lists aims to decide automatically what kind of numbering to apply to nested levels of list: «1,2,3» for the outermost level, «a,b,c» for the second level, «i,ii,iii» for the third level, and so on.                           1028   Making Cross-References           ar   la   lr   ua   ur         Previous versions of the stylesheet used an incredibly verbose recursive template to achieve the same effect; it would be nice to think that my criticism in earlier editions of the book inﬂuenced the rewrite! It could still be made simpler in XSLT 2.0. Given that list.numeration is only called from one place, the template rule could be written as:         <xsl:variable name="numeration"  select=" ’ar’, ’la’, ’lr’, ’ua’, ’ur’ [$depth mod 5 + 1]" >              Making Cross-References  If you read W3C working drafts and recommendations online, you’ll notice that they are very heavily hyperlinked. Terms with special meanings are linked to their deﬁnitions; cross-references from one section of the speciﬁcation to another are represented by hyperlinks; references to other documents are represented ﬁrst by a link to the bibliography and then from the bibliography to the external document on the Web if it is available; there are references from a document to previous versions of the document, and so on. In the XML speciﬁcation, every use of a grammar symbol such as «elementdecl» is linked to the grammar rule where it is deﬁned. Similarly, in the XSLT speciﬁcation, every use of an XSLT element name such as «xsl:sequence» is linked to its deﬁnition. In this section, we will look at the rules that are used to create these links. There are many of these, and I’ll pick a selection that illustrates the techniques used.  Let’s take the linking of term references to term deﬁnitions. Here is an example of a term deﬁnition from the XML speciﬁcation that deﬁnes one term and contains two references to terms deﬁned elsewhere in the speciﬁcation:    A data object is an  XML document  if it is  well- formed , as defined in this specification. A well-formed XML document may in addition be  valid  if it meets certain further constraints.     A curious deﬁnition, because having said that all XML documents are well-formed, it seems rather odd to use the phrase well-formed XML document in the very next sentence, as if there were any other kind. But we are not here to criticize the prose.   18  C a s e S t u d y :  X M L S p e c  1029   Case Study: XMLSpec  The   element identiﬁes this as a term deﬁnition. The «id» attribute identiﬁes this term deﬁnition uniquely within the document. The «term» attribute is the term being deﬁned. This is also tagged using the   element where it appears in the text. This might appear redundant, but the DTD requires it. There are some cases where the two differ; for example, the XML speciﬁcation states:    There is exactly one element, called the  root , or document element, no part of which appears in the  content  of any other element.   I’m afraid I’ve never been sure as to whether the term being deﬁned here is root or root element.  The   element has a «def» attribute that must match the «id» attribute of some  . You ﬁnd that confusing? Well so do I.  The template rule for the   marks the deﬁnition as such, and generates an HTML anchor, like this:        [      Definition      :      ]      The «id» and «name» attributes of the HTML   element are both used  by various browsers  to identify the element, and the «title» attribute identiﬁes its role; it is not used by a conventional browser, but may be used, for example, by audio browsers.  The corresponding rule for the   element generates a link to this anchor:                                 This calls the named template «href.target» to produce the content of the «href» attribute. We’ve already seen this named template on page 1021. Note the use of the key   function to enable quick access to the target of the link: scanning the whole document, by using an expression such as «  termdef[@id= current   @def]», would be hopelessly slow unless you’re lucky enough to be using a processor that optimizes the construct.  The other rules that generate internal links are all very similar to this pair.  1030   Making Cross-References  The links to a section are a little more complex because they require the section number to be computed. In the source XML document, the links look like this:   Full definitions of the specific characters in each class are given in  .   Here, «CharClasses» must match the «id» attribute of an element such as  ,  , or  . Originally, quite a range of different elements could act as the target of a  , for example, an   or a  , but the code has been revised so that only   and   elements are still supported. The form of the link depends on the type of target, so the template rule contains an   instruction that handles all the possibilities. It reads as follows:                 specref to non-existent ID:           <xsl:when test="local-name $target =’issue’     or starts-with local-name $target , ’div’ ">     error case: see below                  This is another place where the code is substantially improved from earlier versions of the stylesheet. In previous versions, the   contained a long list of choices, with different formatting code for each kind of target element. This has now been properly moved into one template rule for each kind of element, using «mode="specref"». However, there’s still a strange omission. In principle, an overlay stylesheet ought to be able to add a new rule for references to another kind of element; for example, a reference to a function prototype in the XSLT speciﬁcation. But the rewrite hasn’t been done in a way that allows this — before calling  , it checks that the template is on the approved list. It would have been much better to put the error case in a fallback template rule deﬁned with  .  In fact, I wonder why there is no provision for a   containing a reference to an  , that is, to a non-normative appendix. The stylesheet actually contains template rules for  , and indeed for many other possible targets such as  ,  ,  , and  . This looks like unreachable code to me.   Here are the template rules that can be invoked:      [              18  C a s e S t u d y :  X M L S p e c  1031   Case Study: XMLSpec         Issue      :         ]                                     The «href» attribute is generated using the named template «href.target», as before. For a reference to an  , the text of the hyperlink contains the issue number and the title  the   element  of the issue. For references to  ,  , and so on, the text of the link contains the section number and section heading of the target section.  I left out the part of the «match="specref"» template that handles the error case. Generally, this stylesheet does not do much validation of this kind, and it would probably be a good thing if it did more. Many errors in source documents, if they pass the checks performed by the DTD, are detected only because the HTML that’s generated turns out to be invalid.   Unsupported specref to       [     ]      Contact stylesheet maintainer .                               ???                 1032   Setting Out the Production Rules  Setting Out the Production Rules  Now we get to a more interesting area. The XML Recommendation contains syntax production rules, and these are marked up in some detail. A sequence of production rules is contained within a   element, and each rule is a   element. Here is an example of a   that contains a single production rule:      Document      document      prolog   element   Misc *           This is of course the production rule for an XML document, which appears in the speciﬁcation as shown in Figure 18-4.  Figure 18-4  In some cases the production rules within a   are grouped into   elements, but this grouping is ignored in the output.  Here are the top-level template rules:      and handle children -->                  18  C a s e S t u d y :  X M L S p e c  1033   Case Study: XMLSpec    for each group -->                    --> <!-- has a weird content model; makes a table but there are no  explicit rules; many different things can start a new row -->  <!-- process the first child in each row, and it will process the  others -->        <xsl:apply-templates  select="lhs   rhs[preceding-sibling::*[1][name  !=’lhs’]]  com[preceding-sibling::*[1][name  !=’rhs’]]  constraint[preceding-sibling::*[1][name  !=’rhs’]]  vc[preceding-sibling::*[1][name  !=’rhs’]]  wfc[preceding-sibling::*[1][name  !=’rhs’]]" >           <xsl:apply-templates  select="lhs   rhs[preceding-sibling::*[1][name  !=’lhs’]]  com[preceding-sibling::*[1][name  !=’rhs’]]  constraint[preceding-sibling::*[1][name  !=’rhs’]]  vc[preceding-sibling::*[1][name  !=’rhs’]]  wfc[preceding-sibling::*[1][name  !=’rhs’]]" >     To understand this, let’s ﬁrst ignore the horrendous select expression that appears in the last two rules.           The rule for the   element processes the   element to produce a heading and then outputs an HTML table, whose contents are generated by processing all the   and   elements contained in the  . The rule also allows for a   to contain   elements. However, the document we’re working with doesn’t contain any, so we can ignore this. The rules are being rather pedantic by ensuring that the rows of the table are always contained in a   element. In practice, Web browsers don’t insist on a   being present, and many HTML authors don’t bother writing one, but technically the HTML speciﬁcation requires it, and the W3C takes great pains to make sure that the documents it publishes are valid HTML. This means that when there is a   present, the   is generated at the level of the  ; when there is a   that is not contained in a    that is, it is contained directly in the   , then the   is generated when processing the   element; but when a   is contained in a  , no additional   is produced.  1034   Setting Out the Production Rules  Now let’s look at the monster select expression. A production rule     has one left-hand side    , one or more right-hand sides    , and one or more annotations   ,  , or   . A   element is used to refer to a validation constraint, a   element to refer to a well- formedness constraint, and a   element to refer to a comment. The XML speciﬁcation does not use   elements, so we can ignore those.  A rule with one   element, two   elements, and three   annotations would be laid out in an HTML table like this:  [17]  lhs1  :: =  rhs1  rhs2  wfc1  wfc2  wfc3  As the comment says, the select expression is processing the children of the   element that start a new row: here, lhs1, rhs2, wfc2, and wfc3. More precisely, the selected elements include every   element, any   element that is not immediately preceded by an   element, and any  ,  , or   element that is not immediately preceded by an   element. So, this template selects the elements that will start a new row, and calls   to process them.  We’ll now look at the template rules that will match these elements. First, the  :                   diff-                     &xa0;&xa0;&xa0;                   diff-                     diff-     18  C a s e S t u d y :  X M L S p e c  1035   Case Study: XMLSpec        &xa0;&xa0;&xa0;::=&xa0;&xa0;&xa0;              There’s a great deal of clutter in this rule. The code outputs a table row  a   element  and the ﬁrst three cells in that table    elements .  For each   element, there is a six-line   instruction that is concerned solely with coloring change-marked sections in the code: changes from one version to the next are marked by the presence of a «diff» attribute on this or some ancestor element, and the coloring happens only if the stylesheet parameter $show.diff.markup is enabled. This clutter could be reduced dramatically by replacing the six lines with a call such as the following, to return the relevant attribute node when required, or an empty sequence otherwise:     The ﬁrst cell contains an optional hyperlink anchor and a sequence number. The call on   using «level="any"» is a good example of how to generate a sequence of numbers that runs through the document. It creates a sequential number for each   element, that is, for each production rule.  Unfortunately, it is actually commented out in the current version of the stylesheet, supposedly because of a bug in one particular XSLT processor, and a less convenient technique is used instead. I decided on this occasion to publish the code as the author would have wanted it to be.   In the second cell, the template calls   to process the contents of the   element, which will generally just be the name of the syntactic term being deﬁned. In the third cell it outputs the «::=» that separates the term from its deﬁnition. In various places it inserts nonbreaking space characters  «&xa0;»  to achieve visual separation between the parts of the rule.  After producing these three cells, the template calls:     This selects the immediately following sibling element, provided it is an   element, and applies the appropriate template rule. Actually, I think the   element is always followed immediately by an   element, so this could have been written rather more straightforwardly as:     As I mentioned before, I would normally write the predicate as «[self::rhs]» rather than «[name  = ’rhs’]» to avoid namespace problems, and more particularly, to allow the optimizer to use indexes if it can.  As we will see, this   causes the other two cells to be added to the table row.  So let’s look at the template rule for the   element. There are two cases to consider here: if the   immediately follows an   element, then it will appear in the same table row as the   element, but in all other cases, it will appear in a new row of its own, preceded by three empty table cells. I would probably have chosen to handle these two cases in two separate template rules, distinguishing  1036   Setting Out the Production Rules  the ﬁrst case using a match pattern such as «match="rhs[preceding-sibling::*[1][self::lhs]]"», but the writer of this stylesheet chose to handle both cases in a single rule, like this:    <!-- make a table cell; if it’s not the first after an LHS, make a  new row, too -->                    diff-                 <xsl:apply-templates  select="following-sibling::*[1][name  =’com’ or  name  =’constraint’ or name  =’vc’ or name  =’wfc’]" >                       diff-                 <xsl:apply-templates  select="following-sibling::*[1][name  =’com’ or  name  =’constraint’ or name  =’vc’ or name  =’wfc’]" >             What the code does is this:  Once again, the code is cluttered by the   instructions that generate change highlighting when required. It also contains a lot of repetition between the two branches of the  .     If the   is to appear on the same row as the  , it outputs a table cell    element , colored to reﬂect any change markings necessary, whose contents are produced by calling   to process the children of the   element. It then calls  18  C a s e S t u d y :  X M L S p e c  1037   Case Study: XMLSpec       to process the following sibling  ,  ,  , or   element if there is one. If the   is to appear on a new row, it creates a new table row    element , and within this row it ﬁrst outputs three blank table cells    elements . It then outputs a table cell rep- resenting the   element itself and calls   to process the following sibling element, as in the previous case.  Some people prefer to avoid empty table cells by writing « &nbsp; », but that’s really necessary only if the table has borders or a background color.  Finally, the last column contains the representation of a  ,  ,  , or   element if there is one. The rules for these elements are all very similar, and I will show only one of them. The structure is very similar to that for the   element:                      diff-                            [VC:      ]                              diff-                            1038   Setting Out the Production Rules   [VC:      ]                    After studying the previous rule, the basic structure should be familiar. But there is some extra code included in this rule, because the   element is represented as a hyperlink to the description of a validity constraint held outside the table itself. The link is represented in the XML by a def attribute, and this is used directly to construct the HTML internal hyperlink. The displayed text of the link is formed by retrieving the element whose ID is equal to this def attribute, and displaying its text.  So much for formatting the production rules! This is by far the most complicated part of this stylesheet; the rest should be plain sailing. But before we move on, we should ask whether all this logic could have been written in a more straightforward way in XSLT 2.0.  I see this problem as an example of a positional grouping problem. Grouping problems are all concerned with turning a one-dimensional sequence of elements into a hierarchy, and the problem of arranging data in a table can often be understood as a grouping problem in which the hierarchic levels are the table, the rows, and the individual cells.  All grouping problems can be solved by answering two questions:        How do you identify an element that can be used to represent the group as a whole  usually the ﬁrst element of the group ? How do you then identify the remaining members of the same group?  We already have answers to these questions in the existing stylesheet: the group is a row of the table, and we have an XPath expression that selects elements that will be the ﬁrst in a new row. The other elements in the row are then the following siblings, up to the next element that’s a ‘‘new row’’ element.  So here is my XSLT 2.0 solution to this problem. First, in the two template rules for «match="prod"» and «match="prodgroup prod"», we’ll replace the complicated   instruction with a simple call on the named template «show.prod», with no parameters. This template looks like this:     <xsl:for-each-group select="*" group-starting-with="  lhs  rhs[preceding-sibling::*[1][not self::lhs ]]  com[preceding-sibling::*[1][not self::rhs ]]  constraint[preceding-sibling::*[1][not self::rhs ]]  vc[preceding-sibling::*[1][not self::rhs ]  wfc[preceding-sibling::*[1][not self::rhs ]]">                   18  C a s e S t u d y :  X M L S p e c  1039   Case Study: XMLSpec  Now, we deﬁne a set of simple template rules to produce the empty cells in each row, depending on the type of the ﬁrst element in the row:                            And ﬁnally we provide one template rule for each kind of element, which simply outputs the content of the appropriate cells in the table. There is no longer any need for it to worry about what comes afterwards: that’s taken care of by the iteration in the master «show.prod» template.                     &xa0;&xa0;&xa0;             &xa0;&xa0;&xa0;::=&xa0;&xa0;&xa0;                                                                [VC:    1040   Overlay Stylesheets     ]            As before, I left out the logic for  ,  , and   elements, to avoid repetition. But I think you’ll agree that the   instruction, while still requiring some thought, makes this tricky problem a lot easier to tackle than it was in XSLT 1.0.  For completeness, here is the «show.diff» template:        <xsl:attribute name="class"  select="concat ’diff-’, ancestor-or-self::* @diff " >        Finally, there’s one other question that needs to be asked: Is it appropriate to be generating HTML   markup here at all? Good practice dictates that HTML tables should be used only for tabular information, and not to achieve manual control over the layout of the output page. I think one could argue this example either way. Certainly, use of CSS positioning would be an alternative worth considering.  Overlay Stylesheets  As I mentioned at the start, xmlspec.xsl is just one module in the stylesheet used to format the XML Recommendation. The xmlspec.xsl module is imported by diffspec.xsl, which in turn is imported by REC-xml.xsl. We will now take a look at these two ‘‘overlays’’, which modify the behavior of the base stylesheet.  diffspec.xsl  This stylesheet module is used to do change marking for documents such as the XML Recommendation. You can see an example of its output at http:  www.w3.org TR REC-xml REC-xml-20060816-review .html where it is used to show the changes between the third and fourth editions of the Recommendation.  For some of the W3C speciﬁcations, editors maintain change markup by hand as they make changes to documents. Typically, the markup looks like this:      Of strings or names:  Two strings or names being compared   MUST  be   are  identical. ...     In other cases, the change markup is generated automatically by running a comparison program  written in XSLT, naturally  against the two documents. I don’t know which approach was used for the XML Recommendation, but the markup is the same either way, so it doesn’t affect this stylesheet.  18  C a s e S t u d y :  X M L S p e c  1041   Case Study: XMLSpec  The way this module works is interesting. It contains template rules that override all other rules in the base stylesheet. For example, changes marked as additions  «@diff="add"»  are handled by this rule:              chg                      This matches every element with the attribute «diff="chg"», indicating that the content has changed. If the global parameter $show.diff.markup is set to 0, to disable change marking, the template calls  , which, like a call on super   in an object-oriented program, invokes the base template rule in the imported stylesheet  in this case xmlspec.xsl . Otherwise, it invokes a named template diff-markup., which we will now examine. The template reads:      off                                                                                    1042   Overlay Stylesheets                      This is pretty pragmatic code, and it almost certainly doesn’t handle all possible cases. In effect, it recog- nizes that the «diff» attribute can occur in three different contexts: contexts where a   element can be added to the HTML, contexts where a   element can be added to the HTML, and contexts where nothing can be done. In the ﬁrst two cases, the   or   element is added, with a «class» attribute that will invoke a CSS rule to cause the text to be displayed with a background color.  But the magic is in the   instruction, which says that having added a   or   element, the stylesheet should go on to process the element exactly as it would have done if the diffspec.xsl stylesheet module had not been invoked. The effect of this stylesheet module is thus entirely additive.  As well as the   rule, there are similar rules for «[@diff= "add"]» and «[@diff="del"]».  There are a few other points to note about this stylesheet module.  Firstly, it contains the declaration  . This points up a nice little problem: How would one maintain a diffspec.xsl module that could be used as an overlay over a vari- ety of different base stylesheets? To achieve this, the module could not import the underlying module, which means it could not use   to invoke the overridden template rules. An appar- ent solution would be to use a third module, xmlspec-diff.xsl, which imports both xmlspec.xsl and diffspec.xsl. Unfortunately, though, the rules for   don’t allow this: this instruc- tion will not consider all template rules of lower precedence, but only those in modules that have been directly imported. The new   instruction in XSLT 2.0 comes nicely to the rescue here.  Secondly, the stylesheet has a template rule, about 50 lines long, for  . This overrides the corresponding rule in the base stylesheet, and the only difference is that it outputs some text explaining the meaning of the change highlighting. Clearly duplicating so much code from the base stylesheet creates a problem in managing subsequent changes. There are a number of other ways to achieve the required effect. One way is to insert an   instruction to an empty template rule at the appropriate point in the base template; this can then be overridden in the overlay. If it is not possible to modify the base template, another solution is to write a template that invokes the base template by using  , capturing the results in a variable, and then perform a further transform on the contents of the variable. In this example, the XSLT 2.0 solution would look like this:                         The presentation of this document has been augmented to identify  changes from a previous version...   18  C a s e S t u d y :  X M L S p e c  1043        Case Study: XMLSpec           REC-xml.xsl  The third module in the stylesheet is called REC-xml.xsl. Compared with xmlspec.xsl, this module is rather poorly documented. The thinking is apparently that xmlspec.xsl should be a generic stylesheet that applies to all the W3C speciﬁcations  or at any rate, all those that are authored in XML , while REC-xml.xsl is a customization for the XML Recommendation in particular.  Looking through the contents of this stylesheet, most of it appears to be rather pragmatic. For example, it recognizes that an   element can have a role attribute with values such as "2e", "3e", and "4e", and thus allows the published output to distinguish between authors of each edition of the speciﬁcation. The role attribute is permitted on pretty well any element in the DTD, and has no deﬁned values; a comment in the DTD makes it fairly clear that it is intended as a general-purpose extensibility mechanism to allow document editors to add information that can’t otherwise be captured.  There’s another rule that causes production rules to be numbered manually  using an explicit num attribute in the source XML  rather than sequentially in order of appearance. This was done to allow pro- duction rules to have numbers such as [28a] and [28b] in revised editions of the speciﬁcation, allowing existing productions to retain their established numbers.  Such changes are defensible, and one can see why they were made in a overlay rather than in the base stylesheet. Nevertheless, the accumulation of such changes over time can cause a signiﬁcant change management problem. It doesn’t even necessarily prevent the base stylesheet being forked, as we will see in the next section.  Stylesheets for Other Speciﬁcations  The stylesheet just presented is used for the XML speciﬁcation. The stylesheets used for the XPath, XQuery, and XSLT speciﬁcations are slightly different, because these documents use additional ele- ment types beyond those used in the XML speciﬁcation. In each case, the XML source document has an internal DTD subset that supplements the base DTD with some additional element types. For example, the XPath Functions and Operators document uses special tags to mark up function signatures, and the XSLT document has special tags to mark up the proformas used to summarize the syntax of each XSLT element.  In fact, the XSLT 2.0 speciﬁcation is formatted using a stack of ﬁve stylesheet modules, as described in the following sections. This is a small subset of the total number of stylesheet modules used to produce the XSLT XQuery family of speciﬁcations, which contains no less than 57 separate stylesheet modules  and the number is growing, as the production of errata to the original specs gets under way . The relationship between the ﬁve modules used for the XSLT speciﬁcation is described by the import tree in Figure 18-5. The other modules, which we have no space to describe here, handle a wide variety of tasks:    Many of the documents in the suite have a stylesheet for local customizations. The entire suite  includes eight published Recommendations, a couple of speciﬁcations that are well advanced to becoming Recommendations, and numerous ancillary documents such as statements of requirements and use cases.  1044   Stylesheets for Other Speciﬁcations                 Formatting of the specialized mathematical notation used in the XQuery formal semantics. Extraction of the XPath and XQuery speciﬁcations from a common base document, which contains markup indicating which parts apply to which language. Construction of an index of term deﬁnitions and section headings across the whole family of documents, to allow cross-document references to be maintained easily. Stylesheets to automate the comparison of document versions to create change markup. Stylesheets to maintain a common bibliography across the full range of documents, which is subsetted to form the reference section in each separate speciﬁcation.  xsltdiff.xsl  xslt.xsl  xsl-query.xsl  funcproto.xsl  xmlspec.xsl  Figure 18-5  This collection of 57 modules doesn’t even include the complex suite of XSLT stylesheets used to maintain the XQuery grammar: an XML deﬁnition of this grammar is used both to generate the pro- duction rules that appear in the various speciﬁcations and to construct the W3C reference parser  see www.w3.org 2005 qt-applets xqueryApplet.html .  So, we will concentrate here on the production of the XSLT speciﬁcation.  xslt.xsl  I developed most of this stylesheet module myself in my role as editor of the XSLT 2.0 speciﬁcation  some parts were inherited from a similar stylesheet produced by James Clark . It reﬁnes the features available from the base stylesheet in three main ways:           It handles additional markup that is special to the XSLT speciﬁcation; for example, the proformas used for showing the structure of XSLT instructions, and the markup used for describing error conditions. It reﬁnes the presentation used for certain constructs, where the default presentation used in the base stylesheet didn’t work well for this document. For example, the number of cross-references to other sections of the speciﬁcation is so great that using a bold font for these became very dis- tracting for the reader, so they were changed to use a normal font. Clearly, such changes need to be made with great discretion, but this is not the right place to discuss typography or editorial policy issues. It automates certain things that were not automated by the base stylesheets. For example, it provides an automatically generated glossary, and indexes of error conditions and outstanding issues; it also automates some of the generation of front material and hyperlinks.  18  C a s e S t u d y :  X M L S p e c  In some cases, these changes have had cascading effects. For example, the fact that some sections of the speciﬁcation are automatically generated means that the stylesheet  in places  operates in two phases.  1045   Case Study: XMLSpec  The issues list that appears in earlier working drafts is generated as a temporary document using the markup from the xmlspec vocabulary, and this is then rendered into HTML by applying the stan- dard template rules. Unfortunately, certain things break when this is done; for example, the standard   template, shown earlier on page 1031, cannot handle a link from a   element in a temporary document to a target element in the main source document — the use of the key   function assumes that both source and target are in the same tree. So, the xslt.xsl stylesheet contains a copy of the entire   template rule with one line changed.  And inevitably, the structural improvements that have been made to the base template have not been migrated through to the copy.   This is far from ideal, of course. It is always better to get the base stylesheet changed rather than forking the code, but this always takes time and is not possible when timescales are tight. It can then easily hap- pen that differences between versions of the same template gradually accumulate, and it takes constant vigilance to prevent structural decay. This is not really any different, of course, from any other software endeavor.  The xslt.xsl stylesheet imports two other stylesheet modules, funcproto.xsl and xsl-query.xsl.  xsltdiff.xsl  This is a fork of the diffspec.xsl stylesheet described earlier in the chapter. It contains some reﬁnements that were necessary  such as importing xslt.xsl instead of xmlspec.xsl  and other changes that the editor  that’s me  found useful to give extra control, for example labeling of changes with the draft in which they were introduced, thus allowing any two versions of the spec to be differenced. It also handles change marking of some of the features that are unique to the XSLT speciﬁcation.  This is actually the only stylesheet module that uses XSLT 2.0 — a natural consequence of the fact that while the speciﬁcation was being drafted, the editor was one of the few people with access to an XSLT 2.0 processor. There are only a couple of XSLT 2.0 features used:        Successive drafts were labelled A, B, C, . . . Z, ZA, ZB, so that the change marking code could detect all changes made since a particular draft with a simple string comparison. String ordering comparisons are not possible in XSLT 1.0 except by the cumbersome device of sorting. Some of the template rules take advantage of the ability in XSLT 2.0 to refer to global variables within a match pattern. Because change marking may be switched on or off by setting a global parameter, a template rule can be made conditional by using a pattern such as <xsl:template match="*[@diff=’chg’ and $show.diff.markup=’1’]">, which means that when the parameter is unset, the template rule never ﬁres.  funcproto.xsl  This stylesheet module does a well-deﬁned job: it formats the function signatures used in the XPath Functions and Operators speciﬁcation and also in the XSLT speciﬁcation. As with the XML production rules, these function signatures use a highly structured form of markup that is completely independent of the ﬁnal presentation. For example, here is the function signature for the format-date   function:  <proto class="xslt" name="format-date" return-type="xs:string"  returnEmptyOk="yes">     1046   Summary              I would recommend taking a look at this stylesheet to see how it works  it’s available in the downloads for this chapter . There are some interesting features, such as the use of a heuristic calculation that attempts to decide whether to use a single-line format for the function signature, or a multiline format. But I won’t include any details here.  xsl-query.xsl  This stylesheet provides a customization of the xmlspec.xsl stylesheet that is used by all the speciﬁca- tions in the XSLT XPath XQuery family. It provides facilities to support ﬁne-grained cross- references between the different speciﬁcations in this family, and to generate appendices such as error listings and glossaries.  Some of these facilities were introduced ﬁrst in the XSLT speciﬁcation, and were then adapted for use in other speciﬁcations; in some cases, the XSLT speciﬁcation has changed to use the common capabilities, in other cases it has not. As with any sizable editorial operation, standards and processes are constantly in ﬂux, and at any given point in time, there will be inconsistencies and overlaps. The fact that these exist in this family of stylesheets should be taken as positive evidence that the modular structure of the XSLT language can actually support this kind of change, which can never be synchronized totally across the whole organization. Changes are inevitably piloted in one area, then adopted and adapted in another, and at any one time the overall picture may appear slightly chaotic.  In theory, the xmlspec.xsl stylesheet module used at the base of the import tree for formatting the XSLT speciﬁcation should be the same as the xmlspec.xsl described earlier in this chapter. Unfortu- nately, though, they aren’t quite the same. There’s no major difference — apart from the fact that XSLT is using the HTML version of the stylesheet rather than the XHTML version, the only differences are a few enhancements to the base stylesheet that haven’t yet been migrated across. But change management is an issue here just as with any other software; and in some ways it’s more difﬁcult to maintain change control, because the code is so easy to tweak.  xmlspec.xsl  Summar y  The case study presented in this chapter was of a real family of stylesheets, used for a real application, and not just developed for teaching purposes. It’s perhaps slightly atypical in that much of it was written by XML and XSLT experts who developed the languages while they used them. However, it shares with many other projects the fact that the stylesheets were developed over a period of time by different indi- viduals, that they were often working under time pressure, and that they had different coding styles. So, it’s probably not that dissimilar from many other stylesheets used in document-formatting applications.  The phrase ‘‘document formatting’’ is crucial. The main tasks performed in this stylesheet are applying HTML display styles to different elements, generating hyperlinks, and formatting tables. These are all tasks that lend themselves to using the rule-based design pattern.  18  C a s e S t u d y :  X M L S p e c  1047   Case Study: XMLSpec  I think there are three main messages to come out of this study:    Within an application that is doing very simple document formatting 90 percent of the time, it is possible to get beneﬁts by using structured data for small parts of the information that have rich semantics — in this case, examples are the markup used for syntax productions, function pro- totypes, issue tracking, and error listings. The availability of XSLT really does enable you to use XML to represent the semantics of the data, uninﬂuenced by the way it is to appear on screen. Although most of this can be done reasonably easily using XSLT 1.0 facilities, as soon as the data gets complex, XSLT 2.0 features start to make a big impact.       Within any complex publishing operation that’s producing a large suite of documents, the key to success is not so much the detail of how individual stylesheets are coded but rather the over- all structure of how many stylesheet modules there are, how they relate to each other, and how change is controlled.  The case study in the next chapter will be a very different kind of application — one that uses a highly structured data and displays it in a very different form from the way it arrives in the source document.  1048   Case Study: A Family Tree  This chapter presents our second case study. Whereas the XML in the previous example fell ﬁrmly into the category of narrative  or document-oriented  XML, this chapter deals largely with data. However, as with many data-oriented XML applications, it is not rigid tabular data; rather, it is data with a very ﬂex- ible structure with many complex linkages and with many ﬁelds allowed to repeat an arbitrary number of times. The data can also include structured text  document-oriented XML  in some of its elements.  The chosen application is to display a family tree, and the sample data we will use represents a small selection of information about the family of John F. Kennedy, president of the United States.  Because genealogy is for most people a hobby rather than a business, you may feel this example is a little frivolous. I think it would be a mistake to dismiss it that way, for several reasons:           Genealogy is one of the most popular ways of using the Web for millions of people. Collabo- rative Internet-based genealogy in particular is rapidly growing, as witness the popularity of software such as PhpGedView  phpgedview.net  and can be seen as a classic example of the phenomenon sometimes called ‘‘Web 2.0’’. Catering to the information needs of consumers is a very serious business indeed, and whether consumers are interested in playing games, watching sport, making travel plans, or researching their family trees, the Web is in the business of helping them to do so. Genealogy is also one of the few areas where Web sites have built ﬁnancial success by asking consumers to pay for content. Genealogical information presents some complex challenges in terms of managing richly struc- tured data, and these same problems arise in many other disciplines such as geographic informa- tion systems, criminal investigation, epidemiology, and molecular biology. Data that ﬁts neatly into rows and columns, to my mind, isn’t interesting enough to be worth studying, and what’s more, it’s likely that the only reason it ﬁts neatly into rows and columns is that a lot of important information has been thrown away in order to achieve that ﬁt. With XML, we can do better. To write the application shown in this chapter, we have to tackle the problems of converting from non-XML legacy data formats to XML formats, and from one XML data model to another, which are absolutely typical of the data conversion problems encountered in every real-world application.  19  C a s e S t u d y :  A  F a m  i l y  T r e e  I could have used an example with invoices and requisitions and purchase orders. I believe that the techniques used in this worked example are equally applicable to many practical commercial problems, but that you will ﬁnd a little excursion into the world of genealogy a pleasant relief from the day job.   Case Study: A Family Tree  Modeling a Family Tree  Genealogical data is complex for two main reasons:       We want to record all the facts that we know about our ancestors, and many of these facts will not ﬁt into a rigidly predeﬁned schema. For those facts that follow a regular pattern, however, we want to use a structured representation so that we can analyze the data. The information we have is never complete, and it is never 100% accurate. Genealogy is always work-in-progress, and the information we need to manage includes everything from original source documents and oral evidence to the conjectures of other genealogists  not to mention Aunt Maud  whom we may or may not trust. In this respect it is similar to other investigative applications like crime detection and medical diagnosis.  One caveat before we start. Throughout this book I have been talking about tree models of XML, and I have been using words like parent and child, ancestor and descendant, in the context of these data trees. Don’t imagine, though, that we can use this tree structure to represent a family tree directly. In fact, a family tree is not really a tree at all, because most children in real life have two parents, unlike XML elements where one parent is considered sufﬁcient.  The structure of the family tree is quite different from the document tree used to represent it. And in this chapter, words like parent and child have their everyday meaning!  The GEDCOM Data Model  The established standard for representing genealogical data is known as GEDCOM, and data in this format is routinely exchanged between software packages and posted on the Internet. I will show some examples of this format later in the chapter.  Adoption of XML in genealogy has been slow, despite the obvious potential. In earlier editions of this book, I devised my own XML representation. However, in December 2002 the LDS Church  which maintains the GEDCOM speciﬁcation  published a draft speciﬁcation of GEDCOM XML, version 6.0. Although this draft hasn’t been followed up by a ﬁnal speciﬁcation and is not yet widely supported by software products, it is this vocabulary that I shall use in this chapter. The speciﬁcation is available at http:  www.familysearch.org GEDCOM GedXML60.pdf. Further information about the use of XML in genealogy can be found on the XML Cover Pages at http:  xml.coverpages.org genealogy.html.  The GEDCOM XML spec includes a DTD rather than a schema. Several versions of this DTD are refer- enced from the XML Cover Pages; I have taken the one prepared by Lee Brown and have copied it for convenience as ﬁle gedXML.dtd in the download ﬁle for this chapter.  In deﬁning version 6 of GEDCOM, the designers decided to do two things at the same time: to change the syntax of the data representation, so that it used XML instead of GEDCOM’s earlier proprietary tagging syntax, and to change the data model, to ﬁx numerous problems that had inhibited accurate data exchange between different software packages for years.  The three main objects in the new model are individuals, events, andfamilies .  It might seem obvious what an individual is, but serious genealogists know that identifying individuals is actually one of the biggest problems: Is the Henry Kay who was born in Stannington in 1833 the same individual as the Henry Kay who married Emma Barber in Rotherham in 1855?  If you happen to know, please tell me.   1050   Modeling a Family Tree  For this reason, the data is actually centered around the concept of an event. The main events of interest are births, marriages, and deaths, but there are many others; for example, emigration, writing a will, and a mention in a published book can all be treated as events. In earlier times, births and deaths were not systematically recorded, but baptisms and burials were, so these events assume a special importance. Events have a number of attributes:              The date of the event: There are many complexities involved in recording historical dates, due to the use of different calendars, partial legibility, and varying precision. The place of the event: Again, this is not a simple data element. Places change their names over time, and place names are themselves structured information, with a structure that varies from one country to another.  Some software packages like to pretend that every event happens in a ‘‘city’’, but they are wrong. Even in the limited data used in this chapter, we have two deaths that occurred in the air, over international waters . The participants in the event: There may be any number of participants, and each has a role. For example, if the event is a marriage, then everyone who is known to have been present at the wed- ding can be regarded as a participant. Obvious roles include that of the bride, the groom, and the witnesses, but many records also provide the names of the father of the bride and the father of the groom, and this information has obvious genealogical signiﬁcance. Moreover, it’s important to record it even if it seems redundant, because it may help to resolve questions that are raised later when conﬂicting evidence emerges. Evidence for the event: This includes references to source information recording the event, and may include copies or transcripts of original documents.  Here is an example of an event from the Kennedy data set. I have included some additional information beyond that in the data we are using, to show some of the additional possibilities in the data model.        husband      wife                   best man      12 SEP 1953         USA   RI   Newport           This event is the marriage of John F. Kennedy to Jacqueline Lee Bouvier. Of course, the event information only makes sense by following the links to the participating individuals.  19  C a s e S t u d y :  A  F a m  i l y  T r e e  1051   Case Study: A Family Tree  The properties of an individual include:           Name  another potentially very complex data element, given the variety of conventions used in different places at different times . This element can be repeated, because a person can have different names at different times. Gender  male, female, or unknown; the model does not recognize this as an attribute that can change over time . Personal information: an open-ended set of information items about the person, each tagged with the type of information, optional date and place ﬁelds, and the actual information content. Certain types of personal information such as occupation, nationality, religion, and education are speciﬁcally recognized in the speciﬁcation, but the list is completely open-ended.  The third fundamental object in the GEDCOM model is the family. A family is deﬁned as a social group in which one individual takes the role of husband father, another takes the role of wife mother, and the others take the role of children. Any of the individuals may be absent or unknown, and the model is ﬂex- ible as to the exact nature of the relationships: the parents, for example, are not necessarily married, and the children are not necessarily the biological children of the parents. An individual may be a member of several families, either consecutively or concurrently  membership in a family is not governed by dates .  There are actually three ways of representing relationships in the model. One way is through families, as described above. The second is through events: a birth event may record the person being born, the mother, and the father as participants in the event with corresponding roles. For certain key events, there are ﬁxed roles with deﬁned names  principal, mother, andfather in this case . The third way is to use the properties of an individual: one can record as a property of an individual, for example, that his godfather was Winston Churchill. These variations are provided to reﬂect the variety of ways in which genealogical data becomes available. The genealogical research process starts by collecting raw data, which is usu- ally data either about events or about individuals, and gradually builds from this to draw inferences about the identity of individuals and the way in which they relate to each other in families. The model has the crucial property that it allows imprecise information to be captured; for example, you can record that A and B were cousins without knowing precisely how they were related, and you can record that someone was the second of ﬁve children without knowing who the other children were. The ability to record this kind of information makes XML ideally suited to genealogical data management.  Apart from individual, event, and family, there are ﬁve other top-level object types in the GEDCOM model, but we won’t be dealing with them in this chapter:                 A group is a collection of individuals related in some arbitrary way  for example, the individuals who were staying at a particular address on the night of a census . A contact is typically another genealogist, for example one who collaborates in the research on the individuals in this data set. A source is a document from which information has been obtained, such as a parish register or a will. It might also be a secondary source such as a published obituary. A repository is a place where source documents may be found, for example a library or a Web site, or the bottom drawer of your ﬁling cabinet. An LDS Ordinance is an event of speciﬁc interest to the Church of Jesus Christ of Latter-day Saints  often called the Mormons , which is the organization that created the GEDCOM standard.  1052   Modeling a Family Tree  I’m not going to spend time discussing whether this is the perfect way of representing genealogical information. Many people have criticized the data model, either on technical grounds or from the point of view of political correctness. The new model in version 6 corrects many of the faults of the established version, without departing from it as radically as some people would have liked.  I would have liked to see some further changes — for example, some explicit ability to associate personal names with events rather than with individuals  I have an ancestor who is named Ada on her birth certiﬁcate but who was baptized as Edith . But with luck, the amount of change in the GEDCOM model is enough to ﬁx the worst faults, but not so extensive that software products will need wholesale rewriting before they can support it.  Creating a Schema for GEDCOM 6.0  Because genealogical data is a perfect example of semi-structured data  it includes the full spectrum from raw images and sound recordings, through transcribed text, to fully structured and hyperlinked data  it is an ideal candidate for using an XML Schema to drive validation of the data and to produce XSLT stylesheets that are schema-aware. I have therefore produced a schema for GEDCOM 6.0, which I introduce in the next section.  My ﬁrst step was to load the DTD into Stylus Studio and convert it to a schema. You could equally well do this using other tools such as XML Spy or oXygen. In fact Stylus Studio offers a choice of two converters, one of which is native to Stylus, the other a packaging of James Clark’s trang program. I found that the native tool, with all options defaulted, did a very satisfactory job: the output is in the download directory as rawschema-stylus.xsd.  I then reﬁned this schema by hand. The changes fell into the following categories:           A number of the top-level elements have similar structure, in particular they all have children such as ExternalID, Submitter, Note, Evidence, Enrichment, and Changed. Because these com- mon ﬁelds appear at the end, it’s not possible to represent this in XML Schema by extending a common supertype, but the common data can be extracted into a named model group, which I called CommonFields. Similarly, complex types such as BasicLinkType and ParentType were created in cases where several elements have the same content model. Adding an import for the schema for the XML namespace, since the schema uses the xml:lang attribute. Adding simple type deﬁnitions for GeneralDate and StandardDate, as described below, and for other shared types such as TimeType.  An interesting feature of this data is that the schema is very permissive. For example, it speciﬁes a default format for dates in the form «DD MMM YYYY»  such as «18 APR 1924» , which has long been the convention used by genealogists. However, it doesn’t insist that the date of an event takes this form. It’s quite OK, for example, to replace the last digit of the year by a question mark, perhaps to reﬂect the fact that the digit is difﬁcult to decipher on an original manuscript. There are certain approved conventions such as preceding the date with «ABT» to indicate that the date is approximate, or «EST» to say that it is estimated, but there are no absolute rules. The golden rule in genealogy is that when you ﬁnd information in a source document, you should be able to transcribe it as faithfully to the original as you possibly can, and a schema that imposes restrictions on your ability to do this is considered a bad thing. If you ﬁnd an old church register in which a date of baptism is recorded as Septuagesima 1582, then you should be able to enter that in your database. I’ll come back to the modeling of dates in the schema on page 1057.  19  C a s e S t u d y :  A  F a m  i l y  T r e e  1053   Case Study: A Family Tree  In GEDCOM, there is no formal way of linking one ﬁle to another. XML, of course, creates wonderful opportunities to deﬁne how your family tree links to someone else’s. But the linking isn’t as easy as it sounds  nothing is, in genealogy  because of the problems of maintaining version integrity between two datasets that are changing independently. So I’ll avoid getting into that area and stick to the model that has the whole family tree in one XML document.  The GEDCOM 6.0 Schema  Let’s now take a quick look at some aspects of the XML Schema which I created for GEDCOM 6.0. In principle, because it’s converted from the DTD, it covers all aspects of the speciﬁcation; however, in improving the schema to describe the speciﬁcation more precisely and more usefully, I concen- trated on the parts that we are actually using in the application in this chapter: in particular, the three main object types individual, event, and family, and the three main properties, namely date, place, and personal name.  Individuals  Here is the element declaration for an  :                                     IndivName gives the name of the individual. Gender has the obvious meaning; DeathStatus is for record- ing information such as ‘‘died in infancy’’ when no speciﬁc death event is known. PersInfo allows recording of arbitrary personal information such as occupation and religion. AssocIndiv is for links to related individuals where the relationships cannot be expressed directly through Family objects  for example, links to godparents . DupIndiv is interesting: it allows an assertion that this IndividualRec refers to the same individual as another IndividualRec. This is very useful when combining data sets compiled by different genealogists; merging the two records into one can be very difﬁcult if there are inconsistencies in the data, and it can prove very difﬁcult to unmerge the data later if they are found to be different individuals after all. Within the CommonFields group, which is also present in other top-level elements, ExternalID is for reference numbers that identify the individual in external databases; Sub- mitter is the person who created this record; Note is for arbitrary comments; Evidence says where the information came from; Enrichment is for inline documentation such as photographs or transcripts of original documents, and Changed is for a change history of this record.  Most of these ﬁelds are optional and repeatable. Something I haven’t captured in this schema is that the GEDCOM spec also says the structure is extensible; arbitrary namespaced elements may be inserted at  1054   Modeling a Family Tree  any point in the structure. This is typically used to contain information speciﬁc to a particular product vendor, so that GEDCOM can be used to exchange data between users of that product with no loss of information. This can be handled in XML Schema by using wildcards, but only if they appear after other elements  this restriction disappears in XML Schema 1.1 .  The Stylus Studio converter makes IndividualRec and all other elements into top-level element dec- larations in the schema. This isn’t needed for validation, since in a GEDCOM ﬁle the IndividualRec will always be a child of the   element. However, it makes this element name available in stylesheets, which is a great convenience; for example, I can write a function whose parameter is declared as  .  Having made IndividualRec a top-level element declaration, there seems to be nothing that would be gained by naming its complex type as a top-level type deﬁnition. In general, the only types that are worth naming as top-level types are those that are used in more than one place, or at least look likely to be used in more than one place.  For the child elements of IndividualRec, the converter chose to use a global element declaration refer- ring to a local  anonymous  type. There’s nothing absolute about this; one could equally use a local element with a global type. As far as validation is concerned, you could also use a local element with an anonymous type, but this is not a good idea if you want to reference the schema from a stylesheet. When it comes to writing an XSLT stylesheet, it’s important that where a data element such as Date appears in several places, it should either use a global element declaration or a global type deﬁnition, so that you can reference one or the other when you declare variables and parameters, and when you write match patterns.  There are no substitution groups in this model. They aren’t needed, because the model has chosen to use generic elements like   rather than specialized types such as   and  . The need for substitution groups generally arises when there are many elements that are structurally interchangeable.  Events  An event record has this structure:                                     The Religion element, of course, has a special place because so many of the events affecting our forebears were recorded by the religious authorities.  19  C a s e S t u d y :  A  F a m  i l y  T r e e  1055   Case Study: A Family Tree  Families           The third object type we will look at is the family. Here is the deﬁnition:                        Again, many of the ﬁelds are common with the other two object types. The elements HusbFath, WifeMoth, and Child play a crucial role in linking the data, so we’d better open them up:                                                                                    1056   Modeling a Family Tree  A   element represents the participation of an individual in a family in the role of child. The   identiﬁes the individual concerned. The   represents the position of that child in the family  1 for the eldest child, and so on ; this allows for the fact that some of the children may be unknown.   and   elements allow for detail about the relationship of the child to the father and mother; for example, the child may be the natural child of one parent and the adopted child of the other.  The   element represents the participation of an individual in a family in the role of par- ent. The   element provides a sequence number; for example, it allows you to say that this family is the man’s second marriage, which is useful if the dates of the marriages are not known.  Now let’s look quickly at the three most common  and difﬁcult  datatypes used for properties of these objects: dates, places, and personal names.  Dates  As we’ve seen, GEDCOM allows any character string to be used as a date. However, much of the presen- tation of data depends on analyzing dates wherever possible. How is this dilemma resolved?  The Date element referenced from the Event record has a complex type, deﬁned like this:                       That is to say, it is a complex type with simple content: the content is a GeneralDate, and the optional attribute indicates which calendar is used. The GeneralDate can be any character string, but certain formats such as «DD MMM YYYY» are recommended.  As far as validation is concerned, there isn’t much point in deﬁning a schema type for the pattern «DD MMM YYYY». However, it turns out that it can be useful to deﬁne this type even if it isn’t used for validation. We can deﬁne the GEDCOM date format as a union type like this:                <xs:pattern value=  "[0-9]?[0-9]\s JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC \s[0-9]{4}" >        This type is meaningless from the point of view of validation — all strings will be considered valid. But the effect is that a date that conforms to the «DD MMM YYYY» pattern will be labeled as a StandardDate, while one that doesn’t will be labeled only as an xs:string. This will prove useful when we write our  19  C a s e S t u d y :  A  F a m  i l y  T r e e  1057   Case Study: A Family Tree  stylesheets, because it becomes very easy to separate standard dates from nonstandard dates when we want to perform operations like date formatting and sorting. In fact, I could have usefully split dates into three categories: simple exact dates like «4 MAR 1920»; inexact dates that conform to the GEDCOM syntax, such as «BEF JAN 1866»  meaning some time before January 1866 ; and arbitrary character strings whose interpretation is left purely to the reader.  Places  Place names have an internal structure, but the structure is highly variable. In many cases, components of the place name may be missing, and the part that is missing may be the major part rather than the minor part. For example, you might know that someone was born in Wolverton, England, without knowing which of the three towns of that name it refers to. The GEDCOM schema allows the place name to be entered as unstructured text but also allows individual components of the name to be marked up using a   element which can carry two attributes: Type, which can take values such as Country, City, or Parish to indicate what kind of place this is, and Level, which is a number that represents the relationship of this part of the place name to the other parts.  Personal Names  As with place names, personal names have a highly variable internal structure. The name can be written simply as a character string  within an    element, or the separate parts can be tagged using   elements. As with place names, these have a completely open-ended structure. The Type attribute can be used to identify the name part as, for example, a surname or generation sufﬁx, and the Level attribute can be used to indicate its relative importance, for example when used as a key for sorting and indexing.  Creating a Data File  Our next task is to create an XML ﬁle containing the Kennedy family tree in the appropriate format. I started by entering the data in a genealogy package, taking the information from public sources such as the Web site of the Kennedy museum. The package I use is called The Master Genealogist, and like all such software it is capable of outputting the data in GEDCOM 5.5 format. This is a ﬁle containing records that look something like this  it’s included in the downloads for this chapter as kennedy.ged :  0 @I1@ INDI 1 NAME John Fitzgerald Kennedy  1 SEX M 1 BIRT 2 DATE 29 MAY 1917 2 PLAC Brookline, MA, USA 1 DEAT 2 DATE 22 NOV 1963 2 PLAC Dallas, TX, USA 2 NOTE Assassinated by Lee Harvey Oswald. 1 NOTE Educated at Harvard University. 2 CONT Elected Congressman in 1945 2 CONT aged 29; served three terms in the House of Representatives. 2 CONT Elected Senator in 1952. Elected President in 1960, the 2 CONT youngest ever President of the United States. 1 FAMS @F1@ 1 FAMC @F2@  1058   This isn’t XML, of course, but it is a hierarchic data ﬁle containing tagged data, so it is a good candidate for converting into XML that looks like the document below. This doesn’t conform to the GEDCOM 6.0 data model or schema, but it’s a useful starting point.  Creating a Data File      John Fitzgerald Kennedy    M      29 MAY 1917   Brookline, MA, USA         22 NOV 1963   Dallas, TX, USA   Assassinated by Lee Harvey Oswald.       Educated at Harvard University.  Elected Congressman in 1945 aged 29; served three terms in the House of Representatives. Elected Senator in 1952. Elected President in 1960, the youngest ever President of the United States.            Each record in a GEDCOM ﬁle has a unique identiﬁer  in this case I1 – that’s letter I, digit one , which is used to construct cross-references between records. Most of the information in this record is self-explanatory, except the   and   ﬁelds:   is a reference to a   record representing a family in which this person is a parent, and   is a reference to a family in which this person is a child.  The ﬁrst stage in processing data is to do this conversion into XML, a process which we will examine in the next section.  Converting GEDCOM Files to XML  The main purpose of XSLT is to convert one XML document into another. But that’s not all it can do; it can also generate structured text as the output, and in XSLT 2.0, there are new facilities to accept structured text ﬁles as the input. That’s exactly what we need to do here.  We’ll do this in two stages  splitting a complex transformation into a series of simpler transformations arranged in a pipeline is always a good idea . Since GEDCOM 5.5 is a hierarchic format that uses level numbers to represent the nesting, we will start by converting this mechanically to an XML representation. Then in the second phase, we will convert this ﬁrst cut XML into XML that conforms to the GEDCOM 6.0 speciﬁcation.  The source document is thus a text ﬁle containing records like this:  0 @I1@ INDI 1 NAME John Fitzgerald Kennedy  1 SEX M 1 BIRT 2 DATE 29 MAY 1917 2 PLAC Brookline, MA, USA  19  C a s e S t u d y :  A  F a m  i l y  T r e e  1059   Case Study: A Family Tree  which needs to be converted into XML like this:      John Fitzgerald Kennedy    M      29 MAY 1917   Brookline, MA, USA         The stylesheet that does this  parse-gedcom.xsl  is in fact a micropipeline in its own right, written as a series of variable declarations each one computing a new value from the value of the previous variable. It starts the usual way, and declares a parameter to accept the name of the input text document:  <xsl:transform version="2.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" xmlns:xs="http:  www.w3.org 2001 XMLSchema" exclude-result-prefixes="xs">        The ﬁle identiﬁed by this parameter is then read using the XSLT 2.0 unparsed-text   function:  <xsl:variable name="input-text" as="xs:string"  select="unparsed-text $input, ’iso-8859-1’ " >  I’ve actually cheated here. GEDCOM requires ﬁles to be encoded in a character set called ANSEL, otherwise ANSI Z39.47-1985, which is used for almost no other purpose. If ANSEL were a mainstream character encoding, it could be speciﬁed in the second argument of the unparsed-text   function call. In practice, however, it is rather unlikely that any XSLT 2.0 processor would support this encoding natively. Therefore, the conversion from ANSEL to a mainstream character encoding needs some extra logic. If you use Saxon, you can write a custom UnparsedTextResolver in Java to take care of low-level interfacing issues like this. This class can invoke a custom character-code converter in the form of a Java Reader — an example called AnselInputReader is supplied in the downloads for this chapter.  For detailed instructions, see the Saxon documentation.   We can now split the input ﬁle into lines by using the XPath 2.0 tokenize   function. We use a separator that matches both Unix and Windows line endings:  <xsl:variable name="lines" as="xs:string*"  select="tokenize $input-text, ’\r?\n’ " >  The result is a sequence of strings  one for each line , and the next stage is to parse the individual lines. Each line in a GEDCOM ﬁle has up to ﬁve ﬁelds: a level number, an identiﬁer, a tag, a cross-reference, and a value. We will create an XML   element representing the contents of the line, using attributes to represent each of these ﬁve components:        <xsl:analyze-string select="." flags="x"  1060   Creating a Data File  regex="^ [0-9]+ \s*   @ [A-Za-z0-9]+ @ ?\s*  [A-Za-z]* ?\s*  @ [A-Za-z0-9]+ @ ?  .* $">     <line level="{regex-group 1 }"  ID="{regex-group 3 }" tag="{regex-group 4 }" REF="{regex-group 6 }" text="{regex-group 7 }" >                    Non-matching line " "   This code creates a   element for each line of the input ﬁle. The content of the elements is con- structed by analyzing the text of the input line using a regular expression, where the ﬁve lines of the regex correspond to the ﬁve ﬁelds that may be present. The attribute «flags="x"» means that whitespace in the pattern is ignored, which allows the regex to be split into multiple lines for readability.  I describe this usage of   as a ‘‘single-match’’ usage, because the idea is that the regular expression matches the entire input string exactly once, and the   instruction is used only to catch errors. Within the   instruction, the content of the line is taken apart using the regex-group   function, which returns the part of the matching substring that matched the nth parenthesized subexpression within the regex. If the relevant part of the regex wasn’t matched  for example, if the optional identiﬁer was absent , then this returns a zero-length string, and our XSLT code then creates a zero-length attribute.  So we now have a sequence of XML elements each representing one line of the GEDCOM ﬁle, each containing attributes to represent the contents of the ﬁve ﬁelds in the input. It’s useful when debugging to display the content of this intermediate variable, and I added a debugging template to the stylesheet     to enable this. If you run the stylesheet with this as the entry point, it displays the structure:                   The next stage is to convert this ﬂat sequence into a hierarchy, in which lines with «level="1"»  for example  turn into XML elements that contain the corresponding «level="2"» lines.  Any problem that involves adding hierarchic levels to the result tree can be regarded as a grouping prob- lem, and it should therefore be no surprise that we tackle it using the   instruction. A group in this case consists of a level N element together with the following elements up to the next one  19  C a s e S t u d y :  A  F a m  i l y  T r e e  1061   Case Study: A Family Tree  at level N. So this is a positional grouping rather than a value-based grouping. The option that we use to tackle this is the group-starting-with attribute, whose value is a match pattern that is used to recognize the ﬁrst element in each group.  A single application of   creates one extra level in the result tree. In this example, we have a variable number of levels, so we want to apply the instruction a variable number of times. First, we group the overall sequence of   elements so that each level 0 line starts a new group. Within this group, we perform a further grouping so that each level 1 line starts a new group, and so on up to the maximum depth of the hierarchy. As one might expect, the process is recursive: we write a recursive template that performs the grouping at level N, and that calls itself to perform the level N+1 grouping. This is what it looks like:         <xsl:for-each-group select="$population"  group-starting-with="*[xs:integer @level  eq $level]">            <xsl:with-param name="population"  select="current-group  [position   != 1]" >  <xsl:with-param name="level"  select="$level + 1" >              In the recursive call I originally set the population parameter to «current-group   except .». This ought to work, but it produces incorrect output in Altova. Altova also fails to indent the output — this is reasonable, since the speciﬁcation advises against indenting data that is known to contain mixed content.  When this is called to process all the   elements with the $level parameter set to zero, it forms one group for each line having the attribute «level="0"», containing that line and all the following lines up to the next one with «level="0"». It then processes each of these groups by creating an element to represent the level 0 line  the name of this element is taken from the GEDCOM tag, and its ID and REF attributes are copied unless they are empty , and constructs the content of this new element by means of a recursive call, processing all elements in the group except the ﬁrst, and looking this time for level 1 lines as the ones that start a new group. The process continues until there are no lines at the next level  the   instruction does nothing if the population to be grouped is empty .  The remaining code in the stylesheet simply invokes this recursive template to process all the lines at level 0:                   1062   Creating a Data File  This main template represents the entry point to the stylesheet. I added the attribute «match=" "» because at the time of writing, the Altova XSLT 2.0 processor requires a source document to be sup- plied, even though it is not used. In principle, however, XSLT 2.0 allows a transformation to be invoked with no source document, by naming a template where execution is to start. I use the name «main» as a matter of convention.  In the previous edition of this book, I presented a different way of doing the GEDCOM-to-XML conver- sion which may still be of interest, so the necessary ﬁles are included in the downloads for this chapter. Instead of coding the logic in XSLT, I wrote it in Java. The Java code implements the Java interface javax.xml.parsers.XMLReader, which makes it look just like an XML parser, enabling it to feed data into an XSLT stylesheet exactly in the same way that a real XML parser does. The SAX2 parser for GEDCOM 5.5 is supplied with the sample ﬁles for this chapter on the Wrox Web site; it is named GedcomParser, and you can use it to process the input for a transformation using the -x ﬂag on the Saxon command line. For completeness, to allow conversions in the reverse direction, I’ve also provided a SAX2 ContentHandler that accepts an XML result tree in the form of a sequence of SAX events, and serializes it in the GEDCOM notation. Along with these two classes are an AnselInputStreamReader and AnselOutputStreamWriter that handle the unusual character set used by GEDCOM.  Converting from GEDCOM 5.5 to 6.0  It’s now time to look at the second stylesheet in the pipeline, which converts the raw XML obtained by mechanical conversion of the GEDCOM format into XML that conforms to the target GEDCOM 6.0 XML Schema. The stylesheet ged55-to-6.xsl doesn’t handle the full job of GEDCOM conversion, but it does handle the subset that we’re using in this demonstration. It starts like this:  <xsl:transform  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" xmlns:xs="http:  www.w3.org 2001 XMLSchema" version="2.0"  >  <!-- This stylesheet converts from the XML representation GEDCOM 5.5  to the GEDCOM 6.0 XML beta specification -->             I’m going to use a schema-aware stylesheet to tackle this conversion. I won’t be using a schema for the input vocabulary  because I haven’t written one , but I will be using the schema for the result document. I will also be validating the result document against this schema. The most noticeable effect of this is that mistakes in the stylesheet that cause incorrect output to be generated are reported immediately, and pinpointed to the line in the stylesheet that caused the error. As I developed this stylesheet, this happened dozens of times before I got it right, and diagnosing the errors proved far easier than using the conventional approach of generating the output, inspecting it for obvious faults, and then running it through a separate validation phase. I’ll give some examples of this later on.  To run this example yourself, you will therefore need to install a schema-aware processor. At the time of writing, the the two candidates are Saxon-SA and the Altova XSLT 2.0 processor. Alternatively, because the only use of schema-aware processing is to validate the output, you can edit the stylesheet to remove the   declaration and the «validation="strict"» attribute on the  19  C a s e S t u d y :  A  F a m  i l y  T r e e  1063   Case Study: A Family Tree    instruction, and it will then work with a basic XSLT 2.0 processor. However, later stylesheets in this chapter make rather deeper use of schema-aware transformation.  There is no «namespace» attribute on the   declaration, because the schema has no target namespace.  Top-Level Processing  We can now get on with the top-level processing logic:                 <FileCreation        Date="{f:today  }" >                                 This template rule establishes the outline of the result tree. The containing   element will contain: a header record, which we generate here and now; then a set of family records, a set of individual records, and a set of events, which must appear in that order; and ﬁnally a contact record to indicate the originator of the data set, which must be present because the mandatory   element in the header refers to it. The name of the submitter is deﬁned by a stylesheet parameter, so you can set a different value if you use this stylesheet on your own data ﬁles.  The reason this ﬁeld is called «Submitter» is historic: the original purpose of GEDCOM was to allow members of the LDS church to submit details of their ancestors to the church authorities.   The instruction   causes the result tree to be vali- dated. The system will do this by looking in the imported schemas for an element declaration of the outermost element in the result tree  the   element  and then ensuring that the rest of the result tree conforms to this element declaration. In the case of Saxon, this validation is done on the ﬂy: each element is validated as soon as it is written to the result tree, which means that any validation errors can be reported in relation to the stylesheet instruction that wrote the incorrect data.  In the header I have generated only those ﬁelds that are mandatory. These include the ﬁle creation date, which must be in the format «DD MMM YYYY». I generated this using the user-deﬁned function:           1064   Creating Family Records  The   elements in the result document correspond one-to-one with the   elements in the input, except that the event information is not included  it is output separately in   elements, later . For example, the input element:  Creating a Data File               is translated to the output element                                 Here is the code to do this:                                                                       19  C a s e S t u d y :  A  F a m  i l y  T r e e  1065   Case Study: A Family Tree  One point worth noting here is the use of «select="HUSB, WIFE, CHIL"» to ensure that the elements of the family appear in the right order in the output. The GEDCOM 6.0 schema is very strict about the order of elements, whereas GEDCOM 5.5 was more liberal. This expression selects a sequence containing zero-or-one HUSB elements, zero-or-one WIFE elements, and zero-or-more CHIL elements, and processes them in that order.  If the input GEDCOM ﬁle is invalid, for example if a FAM contains more than one WIFE element, then the output ﬁle will also be invalid, and this will cause a validation error to be reported by the XSLT processor.  Creating Individual Records  The code for mapping   records in the source to   records in the result tree is similar in principle to the code for family records, though a little bit more complicated.                                                                         Note the code here for extracting the surname from the name using the   instruc- tion. In GEDCOM 5.5 the surname is tagged by enclosing it between « » characters; in 6.0, it is enclosed in a nested   element. The 6.0 speciﬁcation also allows tagging of other parts of the name, for example as a given name, a title, a generation sufﬁx  such as «Jr»  and so on, but as such ﬁelds aren’t marked up in our source data, we can’t generate them.                 1066   Creating a Data File                                       &x0a;        The rules for NOTE elements apply to such elements wherever they appear in a GEDCOM ﬁle, which is why the patterns specify «match="NOTE"» rather than «match="INDI NOTE"»; for other elements, the rules may be speciﬁc to their use within an   record.  In the original GEDCOM ﬁle a NOTE can contain multiple lines, which are arranged like this:  1 NOTE Educated at Harvard University. Elected Congressman in 1945 2 CONT aged 29; served three terms in the House of Representatives. 2 CONT Elected Senator in 1952. Elected President in 1960, the 2 CONT youngest ever President of the United States.  In the direct conversion to XML, the note appears like this  except that there is no newline before the ﬁrst   start tag :   Educated at Harvard University. Elected Congressman in 1945  aged 29; served three terms in the House of Representatives.   Elected Senator in 1952. Elected President in 1960, the   youngest ever President of the United States.     The GEDCOM 6.0 speciﬁcation allows only plain text in a   element  it provides other elements for more complex information, such as a transcript of a will . So the ged55-to-6 conversion stylesheet preserves the line endings by inserting a newline character wherever a   element appeared. The ﬁnal result is:   Educated at Harvard University. Elected Congressman in 1945  aged 29; served three terms in the House of Representatives. Elected Senator in 1952. Elected President in 1960, the youngest ever President of the United States.     The result isn’t always satisfactory, because different genealogy packages that produce GEDCOM 5.5 vary widely in how they handle newlines and whitespace, but it works in this case.  19  C a s e S t u d y :  A  F a m  i l y  T r e e  1067   Case Study: A Family Tree  A typical individual record after conversion looks like this:      Jaqueline Lee   Bouvier               Kennedy    Onassis      F          GEDCOM 6.0 allows all the parts of an individual’s name to be tagged indicating the type of the name, but it doesn’t require it, and in our source data, there isn’t enough information to achieve this. The   allows external reference numbers to be recorded; for example, it might be a stable ref- erence number used to identify this record in a particular database. As with names, there’s no limit on how many reference numbers can be stored — the idea is that the «Type» attribute distinguishes them.  Creating Event Records  The event records in the result tree correspond to events associated with individuals and families in the source data. As we’ve seen, the 6.0 data model treats events as ﬁrst-class objects, which are linked to the individuals who participated in the event.  Our sample data set only includes a few different kinds of event: birth, marriage, divorce, death, and burial, and in the stylesheet we’ll conﬁne ourselves to handling these ﬁve, plus the other common event of baptism. We also handle the general EVEN tag, which is used in GEDCOM 5.5 for miscellaneous events. It should be obvious how the code can be extended to handle other events.     <xsl:apply-templates mode="event"  select=" GED INDI  BIRTBAPMDEATBURI    GED FAM  MARRDIV "  >                 -                       1068   Creating a Data File                              -                     This code identiﬁes all the subelements of   and   that refer to events, and then processes these, creating one   in the output for each. The identiﬁer for the event is computed from the identiﬁer of the containing   or   element plus a sequence number, and the attributes of the event are obtained from a look-up table based on the original element name. In the 6.0 model, the type of event  for example death or burial  is indicated by the «Type» attribute, whose values are com- pletely open-ended. The optional «VitalType» attribute allows each event to be associated with one of the four key events of birth, death, marriage, and divorce: this means, for example, that the date of publication of an obituary can be used as an approximation for the date of death if no more accu- rate date is available, and that the announcement of banns can similarly be used to estimate the date of marriage.  The next two templates are used to generate the participants in an event. The ﬁrst handles events associ- ated with an individual, the second events associated with a couple  which come from the FAM record :        principal                                husband      wife   19  C a s e S t u d y :  A  F a m  i l y  T r e e  1069   Case Study: A Family Tree  This leaves the handling of the date and place of the event. Both are potentially very complex information items. Dates, however, have changed little between GEDCOM 5.5 and 6.0, so they can be carried over unchanged.             For place names, we can try to be a bit more clever. Many of the events in our data set occurred in the United States, and have a PLAC record of the form «somewhere, XX, USA», where XX is a two-letter code identifying a state. This format is predictable because The Master Genealogist captures place names in a structured way and generates this comma-separated format on output. We can recognize place names that follow this pattern, and use the regular-expression-handling capability of XSLT 2.0 to generate a more structured   attribute. This records the country as USA, and the state as the two-letter code preceding the country name; anything before the state abbreviation is tokenized using commas as the delimiter, and the sequence of tokens is output in reverse order — note the calls on reverse   and tokenize   — using individual   elements in the output.              <xsl:analyze-string select="."  regex="^ .* ,\s* [A-Z]{{2}} ,\s*USA\s*$">         USA                                  Error: string " "  does not match regex                               The effect of these rules is that we end up with event records of the form:           1070   Creating a Data File   principal      28 JUL 1929                 USA   NY   Long Island   Southampton   The names ‘‘Long Island’’ and ‘‘Southampton’’ are classiﬁed as levels 6 and 7 because we don’t know enough about them to classify them more accurately: levels up to 5 have reserved meanings, whereas 6 and above are available for arbitrary purposes. The ordering of levels is signiﬁcant: higher levels are intended to represent a ﬁner granularity of place name, which is why we have reversed the order of the original components of the name. Debugging the Stylesheet  This completes the presentation of the stylesheet used to convert the data from GEDCOM 5.5 to 6.0 format. I’d like to add some notes, however, from my experience of developing this stylesheet. The vast majority of my errors in coding this stylesheet, unless they were basic XSLT or XPath errors, were detected as a result of the on-the-ﬂy validation of the result document against its schema. These errors included:     Leaving out required attributes    Misspelling element names  for example, ExternalId for ExternalID     Generating elements in the wrong order Placing an element at the wrong level of nesting Generating an invalid value for an attribute        In the case of Saxon, a few of these errors are detected at stylesheet compile time, but most are reported while executing the stylesheet, and in nearly all cases the error message identiﬁes exactly where the stylesheet is wrong. For example, if the code in the initial template is changed to read:           then the transformation fails with the message:  Validation error on line 27 of ged55-to-6.xsl:  XTTE1510: Required attribute @Target is missing  See http:  www.w3.org TR xmlschema-1 cvc-complex-type clause 4   This process caught quite a few basic XSLT coding errors. For example, I originally wrote:                 19  C a s e S t u d y :  A  F a m  i l y  T r e e  1071   Case Study: A Family Tree  in which the curly braces around «@REF» have been omitted. This resulted in the error message:  Validation error on line 64 of ged55-to-6.xsl:  The value ’@REF’ is not a valid NCName  The error message arises because in the absence of curly braces, the system has tried to use «@REF» as the literal value of the «Ref» attribute, and this is not allowed because the attribute is deﬁned in the schema to have type IDREF, which is a subtype of NCName. An NCName cannot contain an «@» character.  Similarly, errors in the picture of the format-date   function call were picked up because they resulted in a string that did not match the picture deﬁned in the schema for the StandardDate type.  However, schema validation of the result tree will not pick up all errors. I had some trouble, for example, getting the regular expression for matching place names right, but the errors simply resulted in the output ﬁle containing an empty   element, which is allowed by the schema.  Displaying the Family Tree Data  What we want to do now is to write a stylesheet that displays the data in a GEDCOM ﬁle in HTML format. We want the display to look something like the following screenshot  see Figure 19-1 .  Figure 19-1  1072   Displaying the Family Tree Data  This shows all the details of one individual, with links to related individuals so that you can browse around the family tree. Of course one could attempt many more ambitious ways of displaying this data, and I would encourage you to do so: you can start with the small Kennedy data set included in the download for this book, and then continue with any other GEDCOM data set, perhaps one of your own family tree.  Because we will have one HTML page for each individual in the ﬁle, we have to think about how to create multiple HTML pages from a single XML input document. There are at least three ways of doing this:           A bulk publishing process, in which you convert the XML input document into a set of HTML pages, and then publish these as static pages on the Web server. This has the beneﬁt that you only incur the cost of transformation once. It minimizes your dependence on the facilities avail- able from your Internet service provider, and it will work with any browser. However, it can take a lot of space on the server, and it can take a long time to upload if you have a slow connection. Generating HTML pages on demand in the server, using Java servlets or ASP pages. Again this will work with any browser, but this time you need to ﬁnd an Internet service provider who allows you to run servlets or ASP pages. Downloading the entire XML ﬁle to the client, and generating the display there. This has the advantage that the data is only downloaded once, and the user can then browse it at leisure, with no further interaction with the server. Unfortunately, at the time of writing the two major browsers  Firefox and Internet Explorer  both support XSLT 1.0 transformations, but neither yet supports XSLT 2.0. To get around this prob- lem, I use a fallback stylesheet for this case that uses XSLT 1.0 only. Another disadvantage is security; you have no way of ﬁltering the data, for example to remove details of living persons, and you have no way to stop your entire XML ﬁle being copied by the user  for example, the user can View Source or can poke around in the browser cache .  The only real difference between the three cases, as far as the stylesheet is concerned, is that the hyper- links will be generated differently.  We’ll handle the differences by writing a generic stylesheet module containing all the common code for the three cases and then importing this into stylesheets that handle the variations. But we’ll start by writing a stylesheet that displays one individual on one HTML page, and then we’ll worry about the hyperlinks later.  The Stylesheet  We’re ready to write a stylesheet, person.xsl that generates an HTML page showing the information relevant to a particular individual. This stylesheet will need to accept the Id of the required individual as a stylesheet parameter. If no value is supplied, we’ll choose the ﬁrst   record in the ﬁle. Here’s how it starts:  <xsl:transform version="2.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" xmlns:xs="http:  www.w3.org 2001 XMLSchema" xmlns:ged="http:  www.wrox.com 569090 gedcom" xmlns="http:  www.w3.org 1999 xhtml" exclude-result-prefixes="xs ged">  19  C a s e S t u d y :  A  F a m  i l y  T r e e  1073   Case Study: A Family Tree           <xsl:import-schema namespace="http:  www.w3.org 1999 xhtml"  schema-location="http:  www.w3.org 2002 08 xhtml xhtml1-transitional.xsd" >    <!-- parameter to supply the Id of the person to be displayed.  Default value is the Id of the first person in the data set -->     The stylesheet deﬁnes four namespaces: the XSLT namespace, the schema namespace, a local namespace which is used only for the functions deﬁned in this stylesheet module, and the XHTML namespace for the result tree. The schema and ged namespaces aren’t needed in the output ﬁle, so the exclude-result- prefixes attribute is set to prevent them appearing.  I’ve chosen to generate the output in XHTML, so I’ve speciﬁed «method="xhtml"» in the   declaration, and I’ve imported the XHTML schema. This means that any attempt to generate incorrect XHTML can be reported immediately, while the stylesheet is running, and the offending instruction in the stylesheet can be pinpointed. I decided to use the transitional XHTML schema rather than the strict version of the schema, frankly out of laziness: the strict version is very strict indeed, and extra work would be needed on this stylesheet to make its output conform.  There’s now a fair bit of preamble before we do any useful work. This is all designed to make the subse- quent processing easier and faster. First we deﬁne some keys:                   <xsl:key name="families-of-parent" match="FamilyRec"  use="element *,ParentType  Link @Ref" >        The main purpose of the keys is to make navigation around the structure faster. For a data model like GEDCOM, with many cross-references from one record to another, this can make a big difference. The ﬁrst two keys allow records to be found given their unique identiﬁers  they are indexed on their Id attributes . The other three keys are there essentially to follow inverse relationships: a family contains links to the children in the family, and the ﬁrst key enables us quickly to ﬁnd the family with a link to  1074   Displaying the Family Tree Data  a given child  in our data there will never be more than one, though GEDCOM allows it; for example, a child may be linked both to her birth parents and to her adoptive parents .  Having deﬁned these keys, we now deﬁne some functions to make it easier to navigate around the data.                                      <xsl:sequence  select="if  $couple HusbFath and $couple WifeMoth   then  ged:events-for-person   $couple key ’indi’, $couple HusbFath Link @Ref    intersect  ged:events-for-person   $couple key ’indi’, $couple WifeMoth Link @Ref     else   " >     This checks that the family record does indeed identify a couple  both parents are present , and then ﬁnds all the events in which both parties participate — note the use of the intersect operator to ﬁnd the nodes that are present in two given node-sets.          <xsl:variable name="birth"  select="ged:events-for-person $person [@Type=’birth’]" >  <xsl:variable name="birth-vitals"  select="ged:events-for-person $person [@VitalType=’birth’]" >        This function is trying to accommodate some of the variety possible in the model. It ﬁrst ﬁnds the person’s birth event  there may be more than one if it has been recorded more than once . Then it selects the events whose VitalType is «birth»: this might include records such as baptism or the civil registration of birth  which careful genealogists will distinguish from the birth event itself . It returns the ﬁrst one of these events that has a date associated with it.  19  C a s e S t u d y :  A  F a m  i l y  T r e e  1075   Case Study: A Family Tree          <xsl:variable name=  "marriage-vitals" "schema-element EventRec *"  as= select= "ged:events-for-couple $couple [@VitalType=’marriage’]" >  <xsl:variable name=  "marriage" "schema-element EventRec *"  as= select= "$marriage-vitals[@Type=’marriage’]" >  <xsl:variable name=  "marriage-date" "element *, DateType ?"  as= select= " $marriage Date, $marriage-vitals Date [1]" >  <xsl:sequence select="if  $marriage-date  then $marriage-date else ged:sort-dates $couple Child Link @Ref key ’indi’,.    ged:birth-date .  [1]" >     This function attempts to determine when a couple  identiﬁed by a FamilyRec  were married. This is done solely so that an individual’s partners can be listed in the right order, so the date does not have to be precise. The logic looks complicated, but all it does is ﬁnd a dated marriage event if it can and otherwise to return the date of birth of the oldest child. The call on ged:sort-dates   is a forward reference to a function that we’ll see later.  The next group of functions are concerned with formatting and sorting of dates. First a function to convert a date from GEDCOM format into ISO format:             <xsl:analyze-string select="$date"  regex="\s* [0-9]+ \s+ [A-Z]+ \s+ [0-9]+ \s*$">        -  <xsl:number value="index-of  ’JAN’, ’FEB’, ’MAR’, ’APR’, ’MAY’, ’JUN’,  ’JUL’, ’AUG’, ’SEP’, ’OCT’, ’NOV’, ’DEC’ , regex-group 2  " format="01" >   -                   This function only works on a date in standard GEDCOM format «DD MMM YYYY». If you pass it a date in an extended form, such as «BEF 1870», the stylesheet will fail with a type error.  1076   Displaying the Family Tree Data  I’ve not attempted here to handle the problems of non-Gregorian calendars  which arise all the time with genealogical data . If the GEDCOM date represents a date in the Julian  or Old Style  calendar, then in theory it ought to be shifted by 10 or 11 days when converting it to an ISO date, because ISO dates are supposed always to be Gregorian.                 To format a date into the form «2 January 1931», we ﬁrst convert the date to standard ISO representation  the xs:date type  and then call XSLT’s format-date   function.  The next two functions are used for sorting dates:          <xsl:sequence select="  if  data $date  instance of StandardDate   then string ged:date-to-ISO $date   else substring $date, string-length $date -3   " >                         We want to be able to sort standard dates such as «2 JAN 1931» chronologically, but we also want to be able to ﬁt nonstandard dates such as «BEF 1870» into the sequence as best we can. To achieve this, I’ve chosen a sort key that uses the ISO conversion of the date in the case of standard dates  for example, «1931-01-02», and that uses the last four characters otherwise.  Sometimes we just want to display the year:                19  C a s e S t u d y :  A  F a m  i l y  T r e e  1077   Case Study: A Family Tree  Finally, there’s one more function we will be using, which converts a string so that the initial letter is a capital:          <xsl:sequence select="concat upper-case substring $input, 1, 1  ,  substring $input, 2  " >     And that’s the end of the preliminaries. Now we can get on with some actual template rules.         Input document is not a  validated GEDCOM 6.0 file                   The root template rule starts by testing to see if the outermost element of the source document is a GEDCOM element. It doesn’t just test the name of the element: the sequence type descriptor «schema- element GEDCOM » also checks that the type annotation is appropriate. If the user supplies a source document that hasn’t been validated, then this test will fail, even if the document is actually valid, and the stylesheet will proceed no further. If this check weren’t present here, some strange and difﬁcult-to- diagnose failures could occur later on, because we are relying on the type annotations being present in the input data.  The entire transformation is then wrapped inside an   instruction. This instruc- tion is usually used only when producing multiple result trees, but in this case we’re using it for the primary result tree, in order to request validation. It’s not actually specifying what the type of the result document must be, only that it must be what it says it is: «validation="strict"» will cause a failure if the outermost element in the result tree isn’t deﬁned in some imported schema, or if the result tree isn’t valid against that deﬁnition. In this case, the intent is to check that the result is valid XHTML.  The outline of the HTML page is produced when we process the selected   element, as one might expect:                                1078   Displaying the Family Tree Data                Also known as:         ,                                                                                     This template rule works through the process of generating the output page. Some observations:     The title in the HTML header is generated by ﬁrst creating a variable, and then copying the value of the variable to the   element. This is deliberate, it takes advantage of the standard tem- plate rules for generating a personal name, but the   instruction then removes the tags such as   that appear in the generated name, because these clutter the displayed title in some browsers.  19  C a s e S t u d y : A  F a m  i l y  T r e e  1079   Case Study: A Family Tree           The background color of the page depends on the value of the person’s Gender attribute. You might consider this to be an aesthetic abomination, in which case you are welcome to change it, but I left it in because it illustrates another XSLT technique. A more technical criticism is that strict XHTML doesn’t allow the   element to have a bgcolor attribute: this will be reported as an error if you try to import the strict XHTML schema instead of the transitional one. The main task of generating the content of the page is split up and delegated to separate named templates, simply for reasons of modularity. There is no attempt to display all the data that GEDCOM allows to be included in, or referenced from, an   record, for example citations of sources, multimedia objects such as photographs, and the like. If such data is present it will simply be skipped.  I’ve chosen to use an internal CSS stylesheet to deﬁne styling information such as font sizes, and the task of generating this is delegated to the template named css-style. This generates ﬁxed output, as follows:        H1 {  H2 {  H3 {  }  }  }  font-family: Verdana, Helvetica, sans-serif; font-size: 18pt; font-weight: bold; color: "FF0080"  font-family: Verdana, Helvetica, sans-serif; font-size: 14pt; font-weight: bold; color: black;  font-family: Lucida Sans, Helvetica, sans-serif; font-size: 11pt; font-weight: bold; color: black;  SPAN.label {  font-family: Lucida Sans, Helvetica, sans-serif; font-size: 10pt; font-weight: normal; font-style: italic; color: black;  }  P,LI,TD {  font-family: Lucida Sans, Helvetica, sans-serif; font-size: 10pt; font-weight: normal; color: black;  }  1080   Displaying the Family Tree Data  P.text {  font-family: Comic Sans MS, Helvetica, sans-serif; font-size: 10pt; font-weight: normal; color: black;  }        It would have been quite possible, of course, to attach these attributes to the various HTML elements individually, or to incorporate them using XSLT attribute sets, but this way seems cleaner, and shows how XSLT and CSS can complement each other. In fact, it might have been even better to use an external CSS stylesheet, since a user displaying many of these HTML pages would then get more beneﬁt from caching.  The next template displays the parents of the current individual, as hyperlinks:     <xsl:variable name=  "parental-family" "schema-element FamilyRec ?"  as= select= "key ’family-of-child’, @Id [1]" >  <xsl:variable name=  "father" "schema-element IndividualRec ?"  as= select= "key ’indi’, $parental-family HusbFath Link @Ref " >  <xsl:variable name=  "mother" "schema-element IndividualRec ?"  as= select= "key ’indi’, $parental-family WifeMoth Link @Ref " >                       Father:    &xa0;   Mother:    &xa0;  The template starts by locating the   element in which this person appears as a child. It does this using the «family-of-child» key deﬁned earlier. Then it selects the   records for the father and mother, these being the records pointed to by the   and   ﬁelds of the   record: this time the «indi» key is used.  If the data is not all present, for example if there is no   element, or if the   is missing a   and    no pedigree goes back to inﬁnity , then the «$father» and or «$mother» variables will simply identify an empty sequence. The subsequent   instructions ensure that when this happens, the relevant label is omitted from the output.  The actual hyperlinks are generated by using   with «mode="link"»: this gets reused for all the other links on the page, and we’ll see later how it works. The «&xa0;» character  19  C a s e S t u d y :  A  F a m  i l y  T r e e  1081   Case Study: A Family Tree  reference outputs a nonbreaking space. It’s actually simpler to do this than to output an ordinary space, which would require an   element. If you don’t like numeric character references you can deﬁne an entity called «nbsp» in the   declaration and then use «&nbsp;» in place of «&xa0;».  The next named template is used to display the list of events for an individual, such as birth, marriage and death.      "subject" "schema-element IndividualRec "  <xsl:variable name=  as= select= "." >                    :    <xsl:apply-templates select="Link @Ref key ’indi’,.  IndivName[1]"  mode="link" >                Date:        Place:                            The events are located using the ged:events-for-person   function, and they are presented in an attempt at date order, achieved by calling the ged:date-sort-key   function that we saw earlier.  For each event the template displays the name of the event  in title case, for example «Birth» , the list of participants other than the subject of this page, the date and place of the event, and any notes recorded about the event. In each case this is done by applying the appropriate template rules.  The only part of the HTML display that remains is the right-hand panel, where we show information about a person’s partner s  and children. If multiple partners are recorded for an individual, we use headings such as ‘‘Partner 1’’, ‘‘Partner 2’’; if there is only one, we omit the number.  1082   Displaying the Family Tree Data  The template looks like this:     <xsl:variable name=  "subject" "element IndividualRec "  as= select= "." >  <xsl:variable name=  "partnerships" "element FamilyRec *"  as= select= "ged:families-of-spouse . " >        <xsl:variable name=  "partner" "element IndividualRec ?"  as= select= "key ’indi’, element *, ParentType  Link @Ref   <xsl:variable name=  except $subject" >  "partner-seq" "xs:integer?"  as= select= "position  [count $partnerships  ne 1]" >      Partner                Children:          <xsl:sort select="ged:date-sort-key   Link @Ref key ’indi’,.  ged:birth-date .  " >  <xsl:variable name=  "child" "element IndividualRec "  as= select= "Link @Ref key ’indi’,. " >                           As before, we try to list the partners in chronological order, based on the year of marriage. If this isn’t known, there’s not much we can do about it  I could have tried to use the   ﬁeld, but it’s not present in the data we are using . For each partnership, we list the partner’s name, as a hyperlink, and then the children’s names, again as hyperlinks. The children are found from the   ﬁelds of the   record, and they are listed in order of year of birth where this is known.  19  C a s e S t u d y :  A  F a m  i l y  T r e e  1083   Case Study: A Family Tree  The expression «position  [count $partnerships  ne 1]» merits some explanation. It returns the value of position  , unless the number of partnerships is one, in which case it returns an empty se- quence. The effect is that when there is only one partner we don’t output ‘‘Partner 1’’  which is not only inelegant, but might be thought presumptive!   The next group of template rules is used to create the HTML hyperlinks:                                                     The «make-href» template is the only place where the form of a link is deﬁned: in this case it consists of a relative URL reference to another HTML ﬁle, with a ﬁlename based on the individual’s Id attribute, for example I27.html. This has been very deliberately isolated into a template all of its own, for reasons that will become clear later.  The stylesheet ends with the template rules for formatting dates, places, and notes:                         The above rule sorts the parts of a date by the value of their Level attribute, and then outputs them in a comma-separated list. Note that we no longer need to specify that this is a numeric sort, the system can work this out from the schema.                    1084   Displaying the Family Tree Data  The above two rules handle standard dates and nonstandard dates respectively. We rely on the type annotation to distinguish the two cases. Note the call on «data . »: we want to test the type of the simple content of the   element, not the type of the element itself. So we need to call the data   function to get the content.  The ﬁnal rule, below, is for text nodes within a   element. This uses the   instruction to replace newline characters by   elements, so that the line endings are preserved in the browser’s display.                                 Putting It Together  We now have a stylesheet that can generate an HTML page for a single chosen individual. We don’t yet have a working Web site!  As I suggested earlier, there are three ways you can work:           You can do a batch conversion of the entire data ﬁle into a collection of linked static HTML pages held on the Web server. You can generate each page on demand from the server. You can generate pages dynamically at the client.  I’ll show how to do all three; and in the second case, I’ll describe two different implementations of the architecture, one using Java servlets and one using Microsoft ASP pages. The main differences among the three cases are in the way hyperlinks are constructed, and we’ll achieve this by writing overlay stylesheets that change the relevant logic in the base stylesheet.  Publishing Static HTML  To generate HTML ﬁles for all the individuals in the data ﬁle, we need some kind of script that processes each individual in turn and produces a separate output ﬁle for each one. Here we can take advantage of the XSLT 2.0 capability to produce multiple output ﬁles from one input ﬁle. Many XSLT 1.0 products had a similar capability, but unfortunately each product used different syntax.  We’ll need a new template for processing the root element, and because this must override the template deﬁned in person.xsl, we’ll need to use   to give the new template higher precedence.  Here is the complete stylesheet, publish.xsl, to do the bulk conversion. As well as generating an HTML page for each individual, it also creates an index page listing all the individuals grouped ﬁrst by surname, then by the rest of the name.  19  C a s e S t u d y :  A  F a m  i l y  T r e e  1085   Case Study: A Family Tree  <xsl:transform  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" xmlns="http:  www.w3.org 1999 xhtml" version="2.0"  >                                           Index of names        Index of names  <xsl:for-each-group select=" * IndividualRec IndivName NamePart[@Level=1]"  group-by=".">           <xsl:apply-templates select="ancestor::IndividualRec IndivName[1]"  mode="link" >                       In principle you should be able to run this stylesheet using any XSLT 2.0 schema-aware processor. At the time of writing, however, it doesn’t work with Altova. It also hits a bug in regular expression handling when run using any version of Saxon-SA on .NET older than 9.0.0.2.  Assuming you have installed Saxon-SA and set up your classpath, and that you have downloaded the example ﬁles from the Wrox Web site, you should now create a new directory, copy the stylesheets and the XML data ﬁle into it, make this the current directory, and then run the command:  java com.saxonica.Transform -val:strict -t kennedy6.xml publish.xsl dir=d:\jfk  1086   Displaying the Family Tree Data  This assumes that the source ﬁles are in the current directory. The -val option is necessary to ensure that the source ﬁle is validated against its schema; the -t option is useful because it shows you exactly where the generated output ﬁles have been written. The dir=d:\jfk parameter gives the directory in which you want the HTML ﬁles to appear.  The speciﬁed directory should ﬁll with HTML ﬁles. Double-click on the index.html ﬁle, and you should see an index of names. Click on any of the names to see the screen shown on page 1072, in glorious color. Then browse the data by following the relationships.  Generating HTML Pages from a Servlet  An alternative to bulk-converting the XML data into static HTML pages is to generate each HTML page on request. This requires execution of a stylesheet on the server, which in principle can be controlled using any server-side technology that will host XSLT: PHP, ASP.NET, Java servlets, or even raw CGI programs. However, as many of the available XSLT processors are written in Java, it turns out to be convenient to use servlets.  There’s an element of wishful thinking here. If you’re an individual wanting to set up a personal Web site, Java hosting tends to be rather expensive, and PHP is probably a more practical choice. Unfortu- nately however, the only practical ways to run XSLT 2.0 on a Web server at the time of writing involve installing either Java or .NET.  If you aren’t familiar with servlet programming, it’s probably best to skip this section, because there isn’t space here to start from ﬁrst principles. There are plenty of good books on the subject.  All the Java XSLT 1.0 processors  there have been at least ﬁve, though some are now rarely used  imple- ment the JAXP API, which is described in Appendix E. This means you can write a servlet that works with any processor. Although the JAXP API currently only supports XSLT 1.0, there aren’t that many differences at the API level between a 1.0 processor and a 2.0 processor, so you can use this API with minor tweaks to run an XSLT 2.0 processor such as Saxon.  We would like to accept incoming requests from the browser in the form:  http:  www.myserver.com .... GedServlet?tree=kennedy6&id=I1  However, for links between pages we can generate a relative URL to make the code independent of where the servlet is actually installed. This will be in the form:  GedServlet?tree=kennedy6&id=I1  The parameters included in the URL are ﬁrstly, the name of the data set to use  we’d like the server to be able to handle several concurrently , and secondly, the identiﬁer of the individual to display.  So the ﬁrst thing that we need to do is to generate hyperlinks in this format. We can do this by writ- ing a new stylesheet module that imports person.xsl and overrides the template that generated the hyperlinks. We’ll call this ged-servlet.xsl.  The ged-servlet.xsl stylesheet module is as follows. It has an extra parameter, which is the name of the tree we are interested in, because the same servlet ought to be able to handle requests for data from  19  C a s e S t u d y :  A  F a m  i l y  T r e e  1087   Case Study: A Family Tree  different family trees. And it overrides the «make-href» template with one that generates hyperlinks in the required format:  <xsl:transform version="2.0"  xmlns:xsl="http:  www.w3.org 1999 XSL Transform">          separator="" >        <xsl:value-of select="’GedServlet?tree=’, $tree, ’&amp;id=’, .. @Id"  Note that in the XHTML document the ampersand in the URL will be represented as «&amp;». People sometimes get anxious about this, but it’s the correct representation and all browsers will accept it. Most will also accept an unescaped ampersand, which is what many HTML authors incorrectly write.  The stylesheet and the servlet interface could also be extended to generate an index of names, as in the previous example, but as that’s a simple task I’ll leave you to work that out for yourself.  The next task is to write the Java code of the servlet. The code below uses the JAXP interface with a minor extension to request the XSLT processor to perform validation of source documents.  import java.io.*; import javax.servlet.*; import javax.servlet.http.*;  import javax.xml.parsers.*; import javax.xml.transform.*; import javax.xml.transform.stream.*;  public class GedServlet extends HttpServlet {  The init   method of a servlet is called when the servlet is ﬁrst initialized. In this method we set a system property to ensure that the XSLT processor we use is the schema-aware version of Saxon. In a production environment, it would be appropriate to read the values of this system properties from the web.xml conﬁguration ﬁle.  public void init javax.servlet.ServletConfig conf   throws javax.servlet.ServletException {  super.init  conf ; System.setProperty "javax.xml.transform.TransformerFactory",  "com.saxonica.SchemaAwareTransformerFactory" ;  }  The service   method of the servlet responds to an individual request from a user browser. It sets a StreamSource to the ﬁle identiﬁed by the tree parameter in the URL. It looks in its local data to see if the compiled stylesheet is already there; if not, it creates it. It then creates a Transformer, sets a couple of stylesheet parameters, and calls the JAXP transform   method to run the transformation, sending the result to the servlet output destination  which of course causes the result to appear at the browser .  1088   Displaying the Family Tree Data   **  * Respond to an HTTP request *   public void service HttpServletRequest req, HttpServletResponse res   throws ServletException, IOException {  res.setContentType "text html" ;  try {  String clear = req.getParameter "clear" ; if  clear!=null && clear.equals "yes"   {  resetData  ;  } String family = req.getParameter "tree" ; Source source = new StreamSource   new File getServletContext  .getRealPath   " " + family + ".xml"   ;  Result result = new StreamResult res.getOutputStream   ;  Templates style = getStyleSheet  ; Transformer transformer = style.newTransformer  ; transformer.setParameter "id", req.getParameter "id"  ; transformer.setParameter "tree", family ; transformer.transform source, result ;  } catch  Exception err  {  PrintStream ps = new PrintStream res.getOutputStream   ; ps.println "Error applying stylesheet: " + err.getMessage   ; err.printStackTrace ps ;  }  }  When the stylesheet is ﬁrst invoked, it is prepared and stored in memory as a Templates object. This method causes Saxon to validate the source document by setting the SCHEMA_VALIDATION property in the TransformerFactory: this attribute is speciﬁc to Saxon.   ** * Get the prepared stylesheet from memory; prepare it if necessary *  private synchronized Templates getStyleSheet   throws TransformerConfigurationException {  if  stylesheet == null  {  File sheet = new File getServletContext  .getRealPath   " ged-servlet.xsl"  ;  TransformerFactory factory = TransformerFactory.newInstance  ; factory.setAttribute   "http:  saxon.sf.net feature schema-validation", new Integer 1  ;  stylesheet = factory.newTemplates new StreamSource sheet  ;  } return stylesheet;  }  19  C a s e S t u d y :  A  F a m  i l y  T r e e  1089   Case Study: A Family Tree  The «factory.setAttribute  » line is speciﬁc to Saxon, and indicates that source documents are to be schema-validated. If you want your code to be portable across different XSLT processors  which is the whole point of using the JAXP interface , then it would be best to catch the IllegalArgumentException that’s thrown when the processor doesn’t recognize this particular attribute.  The rest is straightforward:   ** * Reset data held in memory *   private synchronized void resetData   {  stylesheet = null;  private Templates stylesheet = null;  }  }  The XML ﬁle holding the family tree data must be in a ﬁle tree.xml where tree identiﬁes the speciﬁc family tree, in our case kennedy6.xml. This must be in the home directory for the Web application containing the servlet, as deﬁned by the conﬁguration parameters for your Web server. The two stylesheet modules person.xsl and ged-servlet.xsl , and the schema gedSchema.xsd, must also be in this directory.  The servlet keeps in memory a copy of the compiled stylesheet  the JAXP Templates object : it makes this copy the ﬁrst time it is needed.  It would also make sense to keep in memory a DOM Document object representing each family tree, to avoid overhead of parsing and validating the full XML document to display each individual. However, I haven’t attempted to do that in this demonstration.  Installing and Conﬁguring the Servlet  To run servlets you need to install a servlet container such as Tomcat, available from www.apache.org. For production use, Tomcat normally runs as an add-on to the Apache Web server, but for testing pur- poses, it also has an HTTP server of its own built in. There’s no space here to go into all the details of installing a servlet container like Tomcat, but for quick reference, this section shows where I put the application ﬁles to get this example working.  Figure 19-2 shows the directory structure after installing Tomcat 6  the details, of course, may vary .  Installing the software itself is very straightforward, but conﬁguring it can be a little tricky. You need to follow the steps below:  1.  2. 3.  4.  Choose a root directory for your application. If you’re just experimenting, it’s simplest to use the preconﬁgured examples directory. On my machine that’s in c: lib apache-tomcat-6.0.14  webapps examples. All the other ﬁle locations that follow are relative to this directory. Place the Saxon JAR ﬁles where Tomcat can ﬁnd them, typically in the WEB-INF lib directory. Place the Saxon-SA license key where Saxon will be able to ﬁnd it, typically in the directory WEB-INF classes. Place the servlet code, GedServlet.class, in WEB-INF classes, as shown in Figure 19-2.  1090   Displaying the Family Tree Data  Figure 19-2  5.  Edit the ﬁle WEB-INF web.xml to record details of the servlet. Search for the   entry for the HelloWorldExample, and add the entry.         GedServlet   GedServlet   Similarly, search for the   entry for HelloWorldExample, and add:         GedServlet    servlets servlet GedServlet   6.  Add ﬁve data ﬁles to the application root directory, as shown in Figure 19-3: speciﬁcally, the two stylesheet modules ged-servlet.xsl and person.xsl, the two schema modules gedSchema.xsd and xhtml1-transitional.xsd, and the data ﬁle kennedy6.xml.  To start Tomcat up, double-click on the startup.bat ﬁle in the bin directory. This brings up an old- fashioned console that displays progress messages. Then, assuming you have defaulted everything in your conﬁguration, open up your browser and enter the URL:  http:  localhost:8080   19  C a s e S t u d y :  A  F a m  i l y  T r e e  1091   Case Study: A Family Tree  Figure 19-3  This will display Tomcat’s home page: in the bottom-left corner is a link to Servlets Examples. Try one or two of the examples, for example Hello World, which should display «Hello World!» on your browser, to prove that Tomcat is working. If all is well, try:  http:  localhost:8080 servlets servlet GedServlet?tree=kennedy6&id=I1  If things fail  and they probably will — servlets can be delicate animals , then you will probably see a summary message on the browser window, but the detailed diagnostics will be on the Tomcat console, or in its log ﬁles. Good luck!  Generating HTML Using ASP.NET Pages  If you work in a Microsoft environment, an alternative to writing Java servlets to perform server-side transformation is to control the process using an ASP.NET program. In this case you have a choice: you can use Microsoft’s XSLT 1.0 processor, referred to by its assembly name System.Xml.Xsl, or you can use the Saxon processor in its .NET version. Microsoft have let it be known that they have an XSLT 2.0 processor under development, but it will be a while before it becomes publicly available.  When you can get by with XSLT 1.0, ASP.NET offers a handy   control that you can use to invoke a transformation. You can simply write a page  say transmog.aspx  that looks something like this:          1092   Displaying the Family Tree Data   Transmogrification   <asp:Xml id="output" runat="server"  DocumentSource="content.xml" TransformSource="stylesheet.xsl" >             There’s a lot more to the   control than this, of course, but because it doesn’t let you use XSLT 2.0, it’s out of scope for this book.  If you choose the Saxon route, you will have to write a little bit more code. The stylesheet is exactly the same as on the Java platform: the only thing that’s different is the controlling application. Saxon on the .NET platform has its own API, which was designed from ﬁrst principles, taking some good ideas from both the Java and .NET worlds, but not copying either. The API is documented at http:  www .saxonica.com documentation dotnetdoc . The key steps are:  Create a Saxon Processor.  Processor processor = new Processor;  Create an XSLT Compiler.  XsltCompiler compiler = processor.NewXsltCompiler  ;  Compile the stylesheet; the result is an XsltExecutable object. Keep this in an application-level cache:  XsltExecutable executable = compiler.Compile  ;  Build the source document:  DocumentBuilder builder = processor.NewDocumentBuilder  ; XdmDocument document = builder.Build inputStream ;  Create a serializer for the result of the transformation, connecting this to the response object that represents the HTTP response:  Serializer serializer = new Serializer  ; serializer.SetOutputWriter Response.Output ;  Run the transformation. Call the Load   method on the XsltExecutable to create an XsltTrans- former. Supply any parameters using the SetParameter   method on the XsltTransformer, then run the transformation using its Run   method.  XsltTransformer transformer = executable.Load  ; transformer.SetParameter .... ; transformer.Run serializer ;  1.  2.  3.  4.  5.  6.  Here’s a complete example  ged.aspx . I’ve added some basic diagnostics, because until everything is conﬁgured correctly, it can be very hard to see what’s going on. The «true» parameter to the Pro- cessor   call indicates that a schema-aware Saxon processor is required, and the code then checks for the failure that occurs when Saxon can’t ﬁnd the license ﬁle  don’t do this in production, it’s not very security-conscious! . I’ve also included code to display any XSLT compilation errors on the browser screen, because this is much more convenient than having them lost in a log ﬁle somewhere.  19  C a s e S t u d y :  A  F a m  i l y  T r e e  1093   Case Study: A Family Tree              void Page_Load Object sender, EventArgs e  {  Uri sourceUri = new Uri Server.MapPath Request.QueryString["tree"] + ".xml"  ; Uri xsltUri = new Uri Server.MapPath "ged-aspx.xsl"  ; Processor processor = new Processor true ; if  !processor.IsSchemaAware  {  Response.Output.WriteLine " Failed to load Saxon-SA  SAXON_HOME = " + Environment.GetEnvironmentVariable "SAXON_HOME"  + "  " ;  } DocumentBuilder builder = processor.NewDocumentBuilder  ; builder.SchemaValidationMode = SchemaValidationMode.Strict; XdmNode input = builder.Build sourceUri ; XsltCompiler compiler = processor.NewXsltCompiler  ; compiler.ErrorList = new ArrayList  ; XsltExecutable executable; try {  executable = compiler.Compile xsltUri ;  } catch  Exception err  {  Response.Output.WriteLine " Failed to compile stylesheet " ; foreach  StaticError error in compiler.ErrorList  {  Response.Output.WriteLine " At line " + error.LineNumber + ": "  + error.Message + " " ;  } return;  } XsltTransformer transformer = executable.Load  ; transformer.InitialContextNode = input; transformer.SetParameter new QName "", "id" ,  transformer.SetParameter new QName "", "tree" ,  new XdmAtomicValue Request.QueryString["id"]  ;  new XdmAtomicValue Request.QueryString["tree"]  ;  Serializer serializer = new Serializer  ; serializer.SetOutputWriter Response.Output ; transformer.Run serializer ;  }     This example makes no attempt to cache either the compiled stylesheet or the source document, which you would typically do by storing the input and or executable objects in Application State.  The stylesheet that this uses, ged-aspx.xsl, is yet another overlay on the basic person.xsl code. This time it creates the hyperlinks like this:  <xsl:value-of select="’ged.aspx?tree=’, $tree, ’&amp;id=’, .. @Id"        separator="" >  1094   Displaying the Family Tree Data  There’s no space here for a detailed tutorial on ASP.NET. However, it may be worth listing brieﬂy the steps I took to get this working, starting from scratch on a machine running Vista:  1.  2.  3. 4.  5.  6.  Activate IIS  Internet Information Server  — the software is already present on the machine, but it needs to be activated, which you can do via Control Panel ➪ Programs ➪ Turn Windows Fea- tures On and Off. Create a simple static Web site  a single index.html page will do  to make sure IIS is working.  Start IIS manager, ﬁnd the default Web site, and use Basic Settings to set the physical path to the directory holding the HTML ﬁles  say d: wwwroot . Then enter http:  localhost  in the browser.  Download and install Microsoft .NET framework version 1.1. Download and install Saxon-SA  version 9.0.0.2 or later , and obtain a free evaluation license from http:  www.saxonica.com . Install the Saxon DLL ﬁles in the Global Assembly Cache using the .NET framework administration tool in the Control Panel, and also copy them to  in our example  a directory d: wwwroot bin  . Place the saxon-license.xml ﬁle in the same  bin directory, and set the environment variable SAXON_HOME to "d: wwwroot". Copy the ﬁles kennedy6.xml, gedSchema.xsd, person.xsl, ged-aspx.xsl, xhtml1- transitional.xsd, and ged.aspx to d: wwwroot. All these ﬁles are in the download archive for this chapter. Enter http:  localhost ged.aspx?tree=kennedy6&id=I1 in the URL ﬁeld of your browser.  Needless to say, there are quite a few things that can go wrong along the way, but these are popular technologies so there are some good tutorials available.  Generating HTML in the Browser  Finally, let’s look at another way to display the family tree: namely, to download the whole XML ﬁle to the browser as a single chunk and then use client-side scripts to invoke stylesheet processing whenever the user clicks on a hyperlink.  The problem with this approach is that at the time of writing, there is no XSLT 2.0 processor available in either Internet Explorer or Firefox; both support XSLT 1.0 client-side transformation, but not yet 2.0. Hopefully, this situation will change in time, though there is always a drawback in running client-side applications because not all your users will be using the latest browser versions.  However, this book would not be complete if it didn’t show you how to run transformations client-side, and for that purpose I have written an XSLT 1.0 version of the stylesheet.  My ﬁrst attempt to do this was to produce the 1.0 version of the stylesheet as an overlay on the 2.0 version: that is, I wrote an XSLT 1.0 module in which every top-level declaration in the 2.0 stylesheet that contained constructs that would only run under XSLT 2.0 was replaced by a functionally equivalent 1.0 construct. My thinking was that the forward-compatibility rules in XSLT 1.0 would ensure that no errors were raised because of constructs in the unused part of the stylesheet. Unfortunately, it didn’t prove possible to do this. To see why, look at the rule:           19  C a s e S t u d y :  A  F a m  i l y  T r e e  1095   Case Study: A Family Tree  This uses XSLT 2.0 constructs  the data   function and the "instance of" operator  within the match pattern, and there is no way of overriding this with an XSLT 1.0 template rule in a way that an XSLT 1.0 processor will understand. Even the «use-when» attribute doesn’t help, because an XSLT 1.0 processor won’t understand it. So I simply copied the common code into the 1.0 module by cut-and-paste to create a freestanding XSLT 1.0 stylesheet, which is named person10.xsl. This stylesheet simply leaves out many of the more interesting aspects of the 2.0 version; for example, dates are output as they appear in the GEDCOM data, and no attempt is made to sort children or spouses in chronological order.  The next thing we need to do is to adapt the stylesheet to run in the browser. To do this, we need to write an HTML page containing JavaScript to invoke the transformation.  This particular example runs in Internet Explorer 6 or later. It won’t run on Firefox, because it uses the Microsoft API to invoke the XSLT transformations. If you want to write pages that run under several dif- ferent browsers, consider using the Sarissa package  http:  sarissa.sourceforge.net  which provides a cross-product API.  If the XML ﬁle is large  family trees produced by serious genealogists often run to several megabytes  then this approach means the user is going to have to wait rather longer to see the ﬁrst page of data. But the advantage is that once it’s downloaded, browsing around the ﬁle can be done ofﬂine: there is no need to go back to the server to follow each link from one individual to another. This gives the user a lightning-fast response to navigation requests, and reduces the processing load and the number of hits on the server. Another beneﬁt, given that many genealogists only have access to the limited Web space provided by a commercial ISP, is that no special code needs to be installed on the server.  This time, the transformation is controlled from JavaScript code on an HTML page famtree.html. The page itself reads as follows. The   elements contain client-side JavaScript code.        Family Tree      ... as before ...       var source = null; var style = null; var transformer = null;  function init   {  source = new ActiveXObject "MSXML2.DOMDocument" ; source.async = false; source.load ’kennedy.xml’ ;  style = new ActiveXObject "MSXML2.FreeThreadedDOMDocument" ; style.async = false; style.load ’ms-person.xsl’ ;  transformer = new ActiveXObject "MSXML2.XSLTemplate" ; transformer.stylesheet = style.documentElement; refresh "I1" ;  } function refresh indi  {  var xslproc = transformer.createProcessor  ;  1096   Displaying the Family Tree Data  xslproc.input = source; xslproc.addParameter "id", indi, "" ; xslproc.transform  ; displayarea.innerHTML = xslproc.output;  }        init  ;                   The CSS style deﬁnitions have moved from the XSLT stylesheet to the HTML page, but they are otherwise unchanged.  The init   function on this page is called when the page is loaded. It creates two DOM objects, one for the source XML and one for the stylesheet, and loads these using the relative URLs kennedy.xml and ms-person.xsl. It then compiles the stylesheet into an object which is rather confusingly called an XSLTemplate; this corresponds directly with the JAXP Templates object. Finally, it calls the refresh   function to display the individual with identiﬁer I1.  I’ve taken a bit of a short cut here. There’s no guarantee that a GEDCOM ﬁle will contain an individual with this identiﬁer. A more carefully constructed application would display the ﬁrst individual in the ﬁle, or an index of people.  The refresh   function creates an executable instance of the stylesheet by calling the createPro- cessor   method on the XSLTemplate object. It then sets the value of the global id parameter in the stylesheet, and applies the stylesheet to the source document by calling the transform   method. The HTML constructed by processing the stylesheet is then written to the contents of the <div id= "displayarea"> element in the body of the HTML page.  We can use the same stylesheet as before, again with modiﬁcations to the form of the hyperlinks. This time we want a hyperlink to another individual, I2 say, to take the form:   Jaqueline Lee Bouvier   When the user clicks on this hyperlink, the refresh   function is executed, which causes a new execu- tion of the compiled stylesheet, against the same source document, but with a different value for the id parameter. The effect is that the contents of the page switches to display a different individual.  The ms-person.xsl stylesheet is written by importing the person10.xsl stylesheet, which is the XSLT 1.0 version of the person.xsl stylesheet presented earlier in this chapter, and then overriding the aspects we want to change. This time there are two changes: we want to change the form of the hyperlink, and we want to leave out the generation of the CSS style, because the necessary deﬁnitions are already present on the HTML page. Here is the stylesheet:  <xsl:transform  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" version="1.0"  >  19  C a s e S t u d y :  A  F a m  i l y  T r e e  1097   Case Study: A Family Tree            ’  <xsl:value-of  select="concat ’Javascript:refresh ’, $apos, .. @Id, $apos, ’ ’ " >              One slight infelicity in the resulting stylesheet is that it generates a full HTML page, complete with  ,  , and   elements, and then inserts this as the content of a   element within an existing HTML page. Fortunately, Internet Explorer tolerates this abuse of the HTML speciﬁcation rather well.  Summar y  I hope this little excursion into the strange world of genealogical data models has given you some ﬂavor of the power of XSLT as a manipulation and reporting tool for complex structured data. We’ve covered a lot of ground:           Using XSLT to transform structured data that wasn’t originally in XML format How to navigate your way around complex linked data within an XML document Several different ways of generating an interactive view of a large XML data set:    Generating lots of static HTML pages in one go at publication time Generating HTML pages dynamically using either a Java servlet or a Microsoft ASP.NET page Generating HTML incrementally within the browser        The worked example in the next chapter will venture into even stranger territory, using XSLT to solve a chess problem. While genealogy has demonstrated how XSLT can be used to process complex data, the chess example will show something of the computational power of the language.  1098   Case Study: Knight’s Tour  This chapter contains the third  and last  of the XSLT case studies. It shows how XSLT can be used to calculate a knight’s tour of the chessboard, in which the knight visits every square without ever landing on the same square twice.  New features in XSLT 2.0 make this kind of application much easier to write, which means that the stylesheet is almost a total rewrite of the XSLT 1.0 version.  Readers of previous editions of this book have reacted differently to this case study. Some have suggested that I should be less frivolous, and stick to examples that involve the processing of invoices and purchase orders, and the formatting of product catalogs. Others have welcomed the example as light relief from the comparatively boring programming tasks they are asked to do in their day job. A third group has told me that this example is absolutely typical of the challenges they face in building real Web sites. The Web, after all, does not exist only  or even primarily  to oil the wheels of big business. It is also there to provide entertainment.  Whatever your feelings about the choice of problem, I hope that by showing that it can be done I will convince you that XSLT has the computational power and ﬂexibility to tackle any XML formatting and transformation challenge, and that as you study it, you will discover ideas that you can use a wide range of tasks that are more typical of your own programming assignments.  The Problem  The purpose of the stylesheet is to produce a knight’s tour of the chessboard, in which each square is visited exactly once, as shown in the illustration overleaf. A knight can move to any square that is at the opposite corner of a 3 × 2 rectangle  see Figure 20-1 . The only input to the stylesheet is an indication of the starting square: in modern chess notation, the columns are denoted by the letters a–h starting from the left, and the rows by the numbers 1–8, starting at the bottom. We’ll supply the starting square as a parameter to the stylesheet. The stylesheet doesn’t need to get anything from the source document. In fact, with XSLT 2.0, there doesn’t need to be a source document: the entry point to the stylesheet can be speciﬁed as a named template.  20  C a s e S t u d y :  i  K n g h t ’ s  T o u r   Case Study: Knight’s Tour  We’ll build up the stylesheet piece by piece: you can ﬁnd the complete stylesheet, tour.xsl, on the Wrox Web site.  Figure 20-1  The Algorithm  The inspiration for this stylesheet came from Oren Ben-Kiki, who published a stylesheet for solving the eight-queens problem. The concept here is very similar, though the details are quite different.  The strategy for getting the knight round the board is based on the observation that if a square hasn’t been visited yet, and if it isn’t the knight’s ﬁnal destination, then it had better have at least two unvisited squares that are a knight’s move away from it, because there needs to be a way of getting in and another way of getting out. That means that if we can get to a square that’s only got one exit left, we’d better go there now or we never will.  This suggests an approach where at each move, we look at all the squares we can jump to next, and choose the one that has fewest possible exits. It turns out that this strategy works, and always gets the knight round the board.  It’s possible that this could lead the knight into a blind alley, especially in the case where two of the pos- sible moves look equally good. In this case, the knight might need to retrace its steps and try a different route. In the version of the stylesheet that I published in the previous edition of this book, I included code to do this backtracking, but made the assertion that it was never actually used  though I couldn’t prove why . Recently, one of my readers reported that if the knight starts on square f8, it does indeed take a wrong turning at move 58, and needs to retrace its steps. Moreover, this appears to be the only case where this happens.  The place I usually start design is with the data structures. Here the main data structure we need is the board itself. We need to know which squares the knight has visited, and so that we can print out  1100   The Algorithm  the board at the end, we need to know the sequence in which they were visited. In XSLT 2.0 the obvious choice is to represent the board as a sequence of 64 integers: the value will be zero for a square that has not been visited, or a value in the range 1 to 64 representing the number of the move on which the knight arrived at this square.  In a conventional program this data structure would probably be held in a global variable and updated every time the knight moves. We can’t do this in XSLT, because variables can’t be updated. Instead, every time a function is called, it passes the current state of the board as a parameter, and when the knight moves, a new copy of the board is created, that differs from the previous one only in the details of one square.  It doesn’t really matter which way the squares are numbered, but for the sake of convention we’ll number them as shown in Figure 20-2.  0  8  1  9  2  3  4  5  6  7  10 11 12 13 14  15  16 17 18 19 20 21 22 23  24  25 26 27 28 29 30  31  32 33 34 35 36 37 38 39  40  41 42 43 44 45 46  47  48 49 50 51 52 53 54 55  56  57 58 59 60 61 62  63  Figure 20-2  So if we number the rows 0–7, and the columns 0–7, the square number is given as «row * 8 + column», and then we add one if indexing into the sequence representing the board.  Having decided on the principal data structure, we can decide the broad structure of the program. There are three stages:  Prepare the initial data structures  the empty board with a knight placed on it, somewhere . Calculate the tour. Display the ﬁnal state of the board.  Calculating the tour involves 63 steps, each one taking the form:  Find all the unvisited squares that the knight can move to from the current position. For each one of these, count the number of exits  that is, the number of unvisited squares that can be reached from there . Choose the square with the fewest exits, and move the knight there.  1. 2. 3.  1. 2.  3.  20  C a s e S t u d y :  i  K n g h t ’ s  T o u r  1101   Case Study: Knight’s Tour  We’re ready to start coding. The tricky bit, as you’ve probably already guessed, is that all the loops have to be coded using recursion. That takes a bit of getting used to at ﬁrst, but it quickly becomes a habit.  The Initial Template  Let’s start with the framework of top-level elements:  <xsl:transform  xmlns:xsl="http:  www.w3.org 1999 XSL Transform" xmlns:xs="http:  www.w3.org 2001 XMLSchema" xmlns:tour="http:  www.wrox.com 5067 tour" exclude-result-prefixes="xs tour" version="2.0"  >           <xsl:variable name="start-column"  select="number translate substring $start, 1, 1 ,  ’abcdefgh’, ’01234567’  " >     <xsl:variable name="start-row"  select="8 - number substring $start, 2, 1  " >  . . .     Some observations:  All I’m doing here is declaring the global parameter, start, which deﬁnes the starting square, and deriv- ing from it two global variables: a row number and column number.              The parameter start has the default value a1. As this is a string-value, it needs to be in quotes; these quotes are additional to the quotes that surround the XML attribute. If I had written «select="a1"», the default value would be the string-value of the   element child of the document root. The simplest way of converting the alphabetic column identiﬁer  a–h  into a number  0–7  is to use the translate   function, which is described in Chapter 13. The row number is subtracted from 8 so that the lowest-numbered row is at the top, and so that row numbers start from zero. Numbering from zero makes it easier to convert between row and column numbers and a number for each square on the board in the range 0–63. I haven’t yet checked that the supplied start square is valid. I’ll do that in the initial template.  Now we can move on to the initial template. In XSLT 2.0 I can deﬁne the initial template as a named tem- plate, so that it can be invoked directly from the command line, without specifying a source document.  1102   The Algorithm  However, just in case you’re using a processor that doesn’t support this capability, it does no harm to deﬁne the template with «match=" "» as well.  The root template deﬁnes the stages of processing, as follows:  1. 2. 3. 4.  Validate the supplied parameter. Set up the empty board and place the knight on it at the speciﬁed starting square. Compute the knight’s tour. Print out the tour in HTML format.  These tasks are all delegated to stylesheet functions or templates, so the root template itself is quite simple:     <!-- This template controls the processing.  It does not access the source document. -->        <xsl:message terminate="yes"  select="Invalid start parameter: try say ’a1’ or ’g6’" >        <xsl:variable name="empty-board" as="xs:integer*"  select="for $i in  1 to 64  return 0" >     <xsl:variable name="initial-board" as="xs:integer*"  select="tour:place-knight 1, $empty-board,  $start-row * 8 + $start-column " >     <xsl:variable name="final-board" as="xs:integer*"  select="tour:make-moves 2, $initial-board,  $start-row * 8 + $start-column " >                 Notice the style of coding here, which uses a sequence of variables, each one computed from the value of the previous variable. Each variable is used only once, which means the variables aren’t actually  20  C a s e S t u d y :  i  K n g h t ’ s  T o u r  1103   Case Study: Knight’s Tour  necessary: it would be possible to nest all the function calls inside each other, and express the whole calculation using one big XPath expression inside the call to the ﬁnal print-board template. But in my view, writing the processing logic like this as a sequence of steps makes it much easier to explain what’s going on. The «as» clauses, which deﬁne the type of each variable, also provide useful documentation.  I also found that while I was writing this code, the type checking provided by the «as» clauses caught many of my errors.   The code for validating the start parameter uses a simple regular expression. The symbols «^» and «$» match the start and end of the input string, and the body of the regular expression speciﬁes that the string must consist of a single letter in the range [a–h] followed by a single digit in the range [1–8]. If the parameter doesn’t match, the stylesheet outputs a message using   and terminates.  Several of the variables  empty-board, initial-board, and final-board  represent a chessboard con- taining all or part of a knight’s tour. Each of these variables is a sequence of 64 integers in the range 0 to 64. If the square has been visited, it contains a sequence number representing the order of visiting  1 for the start square, 2 for the next square visited, and so on . If the square has not been visited, the value is zero. The type «as="xs:integer*"» is actually much more liberal that this: it doesn’t constrain the sequence to be of length 64, and it doesn’t constrain the range of values to be 0 to 64. We could deﬁne a schema with a user-deﬁned atomic type that allows only integers in the range 0 to 64, but it would seem overkill to import a schema just for this purpose, quite apart from the fact that the stylesheet would then work only with a schema-aware XSLT processor. Even then, restricting the size of the sequence to 64 is not something that the type system can achieve. Although list types can be deﬁned in XML Schema to have a ﬁxed length, this constraint can only be exploited in XSLT when validating an element or attribute node against this list type. Freestanding sequences of atomic values, like the ones being used here, cannot refer to a list type deﬁned in the schema.  In parameters to function calls and in variables, squares on the board will always be represented by an integer in the range 0–63, which is calculated as $row * 8 +$column . When we use the square number to index the sequence that represents the board, we have to remember to add one.  The empty board is ﬁrst initialized to a sequence of 64 zeroes, and the knight is then placed on its starting square by calling the function place-knight. Let’s see how this function works.  Placing the Knight  This is a simple function:     <!-- This function places a knight on the board at a given square.  The returned value is the supplied board, modified to indicate that the knight reached a given square at a given move -->         <xsl:sequence select="  for $i in 1 to 64 return  if  $i = $square + 1  then $move else $board[$i]"  >     This function takes three parameters: the number of this move, the current state of the chessboard, and the square on which the knight is to be placed. When it’s called from the root template, the move  1104   Displaying the Final Board  number is always one, and the board is always empty, but I will use the same function again later with different arguments.  What the function does is to copy the whole supplied chessboard before and after the square where the knight is to be placed. This square itself is replaced by the move number. For example, if the tour starts at square a8  which translates to square zero , then the ﬁrst call on place-knight   will return a sequence containing a one followed by 63 zeroes.  I can’t, of course, modify the supplied chessboard in situ. All variables in XSLT are immutable. Instead I create a new board as a modiﬁed copy of the original. The result of the function is a sequence representing the new state of the chessboard after placing the knight.  There are various ways the actual calculation of the new board could have been written here. Another possibility would be:  <xsl:sequence select="$board[position   = 1 to $square],  $move, $board[position   = $square+2 to 64]" >  and a third option would be:  <xsl:sequence select="insert-before   remove $board, $square+1 ,  $square+1, $move  " >  Displaying the Final Board  I’ll skip the function that computes the knight’s tour for the moment, and describe the relatively easy task of outputting the ﬁnal result as HTML. Like the rest of the stylesheet, this logic is greatly simpliﬁed in XSLT 2.0:                 Knight’s tour          Knight’s tour starting at                    <xsl:variable name="color"  20  C a s e S t u d y :  i  K n g h t ’ s  T o u r  1105   select="if    $row + $column  mod 2 =1   then ’xffff44’ else ’white’" >        Case Study: Knight’s Tour                          The template contains a little bit of logic to achieve the traditional checkerboard coloring of the squares, using the «mod» operator to test whether the sum of the row number and the column number is a multiple of 2.  The actual content of each square is the move number, extracted from the relevant item in the sequence representing the board.  Finding the Route  So much for the input and output of the stylesheet, now for the substance: the algorithm to calculate the knight’s tour.  The basic algorithm we use is that at each move, we consider all the squares we could go to, and choose the one with the fewest exits. For example, if we are on c2 then we could move to a1, e1, a3, e3, b4, or d4, assuming they are all unvisited. Of these, the corner square a1 has only one exit, namely b3, and if we don’t visit the corner square now, then we’ll never get another chance later. It turns out that this strategy of always visiting the square with least exits nearly always succeeds in generating a complete knight’s tour, though in the rare cases where it doesn’t, the algorithm is resilient enough to backtrack and try a different route if the ﬁrst one fails.  The root template makes a call on the function named «make-moves». This function, starting from any given start position, works out all the moves needed to complete the knight’s tour. Of course, it does this by recursion, but unlike previous functions which called themselves directly, this one does so indirectly, via another function named «try-possible-moves».  The ﬁrst thing the «make-moves» function does is to call the function «list-possible-moves» to construct a list of moves that are legal in the current situation. The result of this function, a list of moves, uses a very similar data structure to that of the chessboard itself. The list is represented as a sequence, and each possible move is represented by an integer whose value is the number of the square to which the knight travels. So in Figure 20-3, after move 5 the set of possible moves is the list  3, 19, 28, 30, 23 . The list is in no particular order.  Having established the list of possible moves, the function then calls «try-possible-moves» to select one of these moves and execute it.  Here is the function. Its parameters are the number of this move  starting at move 2, because the knight’s initial position is numbered 1 , the state of the board before this move, and the number of the square on which the knight is currently sitting.  1106   Finding the Route  0  8  1  9  2  3  4  5  6  7 4  10 11 12 13 14  15  5  16 17 18 19 20 21 22 23  3  24  25 26 27 28 29 30  31  32 33 34 35 36 37 38 39  2  40  41 42 43 44 45 46  47  48 49 50 51 52 53 54 55  1  56  57 58 59 60 61 62  63  Figure 20-3     <!-- This function takes the board in a given state,  decides on the next move to make, and then calls itself recursively to make further moves, until the knight has completed his tour of the board. It returns the board in its final state. -->            <xsl:variable name="possible-move-list" as="xs:integer*"  select="tour:list-possible-moves $board, $square " >     <xsl:sequence  select="tour:try-possible-moves $move, $board, $square, $possible-move-list " >     Finding the Possible Moves  The next function to examine is «list-possible-moves». This takes as input the current state of the board and the position of the knight, and it produces a list of squares that the knight can move to. For a knight in the center of the board there are eight possible squares it can move to  as shown in Figure 20-4 : those squares that are either two columns and one row, or two rows and one column, removed from the current row.  20  C a s e S t u d y :  i  K n g h t ’ s  T o u r  1107   Case Study: Knight’s Tour  0  8  1  9  2  3  4  5  6  7  10 11 12 13 14  15  16 17 18 19 20 21 22 23  24  25 26 27 28 29 30  31  32 33 34 35 36 37 38 39  40  41 42 43 44 45 46  47  48 49 50 51 52 53 54 55  56  57 58 59 60 61 62  63  Figure 20-4  However, we have to consider the case where some of these squares are unavailable because they are off the edge of the board, and we also have to eliminate any squares that have already been visited. The logic I have used is simple, if verbose; it simply examines each of the eight candidate squares in turn:          <xsl:variable name="row" as="xs:integer"  select="$square idiv 8" >  <xsl:variable name="column" as="xs:integer"  select="$square mod 8" >  <xsl:sequence select="   if  $row &gt; 1 and $column &gt; 0 and $board[ $square - 17  + 1]=0   if  $row &gt; 1 and $column &lt; 7 and $board[ $square - 15  + 1]=0   if  $row &gt; 0 and $column &gt; 1 and $board[ $square - 10  + 1]=0   if  $row &gt; 0 and $column &lt; 6 and $board[ $square - 6  + 1]=0   if  $row &lt; 6 and $column &gt; 0 and $board[ $square + 15  + 1]=0   if  $row &lt; 6 and $column &lt; 7 and $board[ $square + 17  + 1]=0   then $square - 17 else   ,  then $square - 15 else   ,  then $square - 10 else   ,  then $square - 6 else   ,  then $square + 15 else   ,  then $square + 17 else   ,  then $square + 6 else   ,  if  $row &lt; 7 and $column &gt; 1 and $board[ $square + 6  + 1]=0   if  $row &lt; 7 and $column &lt; 6 and $board[ $square + 10  + 1]=0   then $square + 10 else     "   >     1108   Finding the Route  An observation: not everyone is happy with the idea of writing a single XPath expression that is 16 lines long in the middle of a stylesheet. Some would prefer to write this code using XSLT instructions, using  . I’m comfortable with the code as written, but you can express the same logic at the XSLT level if you prefer.  Another approach would be to try and capture all the logic in a single calculation, as follows:  for $r in  -2, -1, +1, +2 ,  $c in  - 3-abs $r  , + 3-abs $r     return    $row+$r *8 +  $column+$c  + 1   [ $row+$r = 0 to 7 and $column+$c = 0 to 7] [$board[ $row+$r *8 +  $column+$c  + 1] eq 0]  So having found the possible moves we can make, we need to select one of them and make it. This is the job of the try-possible-moves function.  Trying the Possible Moves  In essence, this function is quite simple. As input it gets the current state of the board, the current position of the knight, the current move, and the list of moves that the knight can make from its current position. If there is at least one move that it can make, then it makes the best move it can ﬁnd and returns the new state of the board; otherwise, it returns the special value «  » to indicate that it has failed, and that another path needs to be found.              <xsl:sequence  select="if  exists $possible-moves    then tour:make-best-move $move, $board, $square, $possible-moves   else   " >  <!-- if there is no possible move, we return the special value     as the final state of the board, to indicate to the caller that we got stuck -->     This depends, of course, on the function make-best-move  , which we will look at next. This function is a bit more complex, even though it delegates the task of ﬁnding the best move yet again, to another function called find-best-move  .  In fact, the ﬁrst thing that this function does is to call find-best-move   to decide which move to make. It then makes a note of all the other possible moves, just in case it needs to backtrack  lazy evaluation comes in handy here: the variable $other-possible-moves won’t be evaluated unless it’s actually needed .  20  C a s e S t u d y :  i  K n g h t ’ s  T o u r  1109   Case Study: Knight’s Tour  Then the function makes the selected move by placing the knight on the chosen square, using the place-knight   function that we saw earlier, and ﬁnally it makes a recursive call on make-moves  , which we’ve also seen earlier, to complete the rest of the tour from this new position.  If this ﬁnal call returns a normal board, then we’ve ﬁnished, and the function exits, unwinding the whole stack down to the initial template, which can now print the ﬁnal board and quit. However, if the ﬁnal board is the special value «  », then backtracking is needed. This is done by calling try- possible-moves   with a reduced list of possible moves, that excludes the move that we’ve found to be a cul-de-sac.                 <xsl:variable name="best-move"  select="tour:find-best-move $board, $possible-moves, 9, 999 " >     <xsl:variable name="other-possible-moves" as="xs:integer*"  select="$possible-moves[. != $best-move]" >     <xsl:variable name="next-board" as="xs:integer*"  select="tour:place-knight $move, $board, $best-move " >  <!-- now make further moves using a recursive call,  until the board is complete ->  <xsl:variable name="final-board" as="xs:integer*"  select = "if  exists $next-board[.=0]    then tour:make-moves $move+1, $next-board, $best-move  else $next-board" >  <!-- if the final board has the special value ’  ’, we got stuck,  and have to choose the next best of the possible moves. This is done by a recursive call. -->  <xsl:sequence select="  if  empty $final-board   then tour:try-possible-moves $move, $board, $square, $other-possible-moves   else $final-board" >     1110   Finding the Route  Selecting the Best Move  The one thing remaining is to look at the template «find-best-move», which from a set of possible moves chooses the best one, namely the move to the square with fewest exits.  As always, the logic is recursive. We keep track of the best move so far, and the number of exits that the best move so far possesses. If the ﬁrst move in the list  the trial move  is better than the best move so far, it replaces the previous best, and we then call the template to process the other moves in the list. The ﬁnal output is the best move after examining the whole list.  To ﬁnd the number of exits for a given move, we create a trial board, and make that move by calling the «place-knight» function described earlier. Using this board, we then call the «list-possible- moves» function, also described earlier, to see what moves would be available after the trial move. We aren’t interested in the details of these moves, only in how many there are, which we can ﬁnd out simply by examining the length of the list.  We can now calculate two variables: the best move so far and the least number of exits, based on whether the trial move is better than the previous best. If the move is the best one so far, it is output. Finally, the «find-best-move» function calls itself recursively to process the remaining moves in the list. On completion, the value returned by the function is the best move, that is, the square to which the knight should move next.     <!-- This function finds from among the possible moves,  the one with fewest exits. It calls itself recursively. -->           <!-- split the list of possible moves into the first move  and the rest of the moves -->  <xsl:variable name="trial-move" as="xs:integer"  select="$possible-moves[1]" >  <xsl:variable name="other-possible-moves" as="xs:integer*"  select="$possible-moves[position   gt 1]" >     <xsl:variable name="trial-board" as="xs:integer*"  select="tour:place-knight 99, $board, $trial-move " >     <xsl:variable name="trial-move-exit-list" as="xs:integer*"  select="tour:list-possible-moves $trial-board, $trial-move " >  <xsl:variable name="number-of-exits" as="xs:integer"  select="count $trial-move-exit-list " >  20  C a s e S t u d y :  i  K n g h t ’ s  T o u r  1111   Case Study: Knight’s Tour  <!-- determine whether this trial move has fewer exits than  those considered up till now -->  <xsl:variable name="minimum-exits" as="xs:integer"  select="min  $number-of-exits, $fewest-exits  " >  <!-- determine which is the best move  the one with fewest exits   so far -->  <xsl:variable name="new-best-so-far" as="xs:integer"  select="if  $number-of-exits lt $fewest-exits   then $trial-move else $best-so-far" >  <!-- if there are other possible moves, consider them too,  using a recursive call. Otherwise return the best move found. -->  <xsl:sequence  select="if  exists $other-possible-moves    then tour:find-best-move $board, $other-possible-moves,  $minimum-exits, $new-best-so-far   else $new-best-so-far" >     And that’s it.  Running the Stylesheet  To run the stylesheet, download it from wrox.com and execute it. No source document is needed. With Saxon, for example, try:  java -jar saxon9.jar -it:main -xsl:tour.xsl start=b6 >tour.html  The command line syntax shown here applies to Saxon 9.0 or later. However, if you want to run the stylesheet with an earlier version of Saxon you can do this simply by adapting the way the command line options are written.  The output of the stylesheet is written to the ﬁle tour.html, which you can then display in your browser.  Using the Altova XSLT 2.0 processor, the equivalent command line is:  altovaXML -xslt2 tour.xsl -in tour.xsl -out tour.html -param start=’b6’   At the time of writing, Altova does not provide any way of nominating an initial template as the entry point, so it is necessary to supply a dummy input document. The stylesheet is as good as any other.   Obser vations  The knight’s tour not a typical stylesheet, but it illustrates the computational power of the XSLT language, and in particular the essential part that recursion plays in any stylesheet that needs to do any non-trivial calculation or handle non-trivial data structures. And although you will probably never need to use XSLT to solve chess problems, you may just ﬁnd yourself doing complex calculations to work out where best to place a set of images on a page, or how many columns to use to display a list of telephone numbers, or  1112   Summary  which of today’s news stories should be featured most prominently given your knowledge of the user’s preferences.  So if you’re wondering why I selected this example, there are two answers: ﬁrstly, I enjoyed writing it, and secondly, I hope it persuaded you that there are no algorithms too complex to be written in XSLT.  The other thing that’s worth noting about this stylesheet is how much it beneﬁts from the new features in XSLT 2.0. In the ﬁrst edition of this book, I published a version of this stylesheet that was written in pure XSLT 1.0; it used formatted character strings to represent all the data structures. In the second edition, I published a revised version that used temporary trees  as promised in the later-abandoned XSLT 1.1 speciﬁcation  to hold the data structures. The following table shows the size of these three versions  in non-comment lines of code , revealing the extent to which the new language features con- tribute to making the stylesheet easier to write and easier to read. The table also shows the execution times in milliseconds of each version, using Saxon 9.0, which reveals that the XSLT 2.0 solution is also the fastest: Version 1.0  Data structure character strings  Execution time  Lines of code  276  75  1.1  2.0  temporary trees  sequences  267  59  220  37  In the previous edition of the book, the numbers reported in the last column  for Saxon 7.8 on a slower machine  were 580 ms, 1050 ms, and 900 ms, respectively. Repeating the measurements on my current machine with Saxon 7.8 gives ﬁgures of 180 ms, 360 ms, and 340 ms. At that stage in the development of Saxon, the native 2.0 constructs were signiﬁcantly slower than the traditional XSLT 1.0 way of doing things. The position is now reversed — instead of being half the speed, the 2.0 solution is now twice as fast as the 1.0 code.  The earlier versions of the stylesheet are included in the download ﬁle under the names tour10.xsl and tour11.xsl. The ﬁle ms-tour11.xsl is a variant of tour11.xsl designed to work with Microsoft’s MSXML3 and later processors.  Summar y  If you haven’t used functional programming languages before, then I hope that this chapter opened your eyes to a different way of programming. It’s an extreme example of how XSLT can be used as a completely general-purpose language; but I don’t think it’s an unrealistic example, because I see an increasing number of cases where XSLT is being used for general-purpose programming tasks. The thing that characterizes XSLT applications is that their inputs and outputs are XML documents, but there should be no limits on the processing that can be carried out to transform the input to the output, and I hope this example convinces you that there are none.  In these last three chapters, I’ve presented three complete stylesheets, or collections of stylesheets, all similar in complexity to many of those you will have to write for real applications. I tried to choose three that were very different in character, reﬂecting three of the design patterns introduced in Chapter 17, namely:     A rule-based stylesheet for converting a document containing semantic markup into HTML. In this stylesheet, most of the logic was concerned with generating the right HTML display style for each XML element, and with establishing tables of contents, section numbering, and internal hyperlinks, with some interesting logic for laying data out in a table.  20  C a s e S t u d y :  i  K n g h t ’ s  T o u r  1113   Case Study: Knight’s Tour        A navigational stylesheet for presenting selected information from a hierarchical data structure. This stylesheet was primarily concerned with following links with the XML data structure, and it was able to use the full power of XPath expression to achieve this. This stylesheet also gave us the opportunity to explore some of the systems issues surrounding XSLT: when and where to do the XML-to-HTML conversion, and how to handle data in non-XML legacy formats. A computational stylesheet for calculating the result of a moderately complex algorithm. This stylesheet demonstrated that even quite complex algorithms are quite possible to code in XSLT once you have mastered recursion. Such algorithms are much easier to implement in XSLT 2.0 than in XSLT 1.0, because of the ability to use sequences and temporary trees to hold working data.  1114   Part IV  Appendices  Appendix A: XPath 2.0 Syntax Summary  Appendix B: Error Code  Appendix C: Backward Compatiblity  Appendix D: Microsoft XSLT Processors  Appendix E: JAXP: The API for Transformation  Appendix F: Saxon  Appendix G: Altova  Appendix H: Glossary    A  X P a t h 2  .  0 S y n t a x S u m m a r y  XPath 2.0 Syntax Summar y  This appendix summarizes the entire XPath 2.0 grammar. The tables in this appendix also act as an index: they identify the page where each construct is deﬁned.  The way that the XPath grammar is presented in the W3C speciﬁcation is inﬂuenced by the need to support the much richer grammar of XQuery. In this book, I have tried to avoid these complications.  The grammar is presented here for the beneﬁt of users, not for implementors writing a parser  the W3C spec adopted the same approach in its ﬁnal drafts . So there is no attempt to write the syntax rules in such a way that expressions can be parsed without lookahead or backtracking.  An interesting feature of the XPath grammar is that there are no reserved words. Words that have a special meaning in the language, because they are used as keywords  «if», «for» , as operators  «and», «except» , or as function names  «not», «count»  can also be used as the name of an element in a path expression. This means that the interpretation of a name depends on its context. The language uses several techniques to distinguish different roles for the same name:                    Operators such as «and» are distinguished from names used as element names or function names in a path expression by virtue of the token that precedes the name. In essence, if a word follows a token that marks the end of an expression, then the word must be an operator; other- wise, it must be some other kind of name. As an exception to the ﬁrst rule, if a name follows « », it is taken as an element name, not as an operator. To write «  union  *», if you want the keyword treated as an operator, you must write the ﬁrst operand in parentheses: «    union  *». Alternatively, write « . union  *». Some operators such as «instance of» use a pair of keywords. This technique was adopted in XQuery for use at the start of a construct such as «declare function», but it’s not actually needed for inﬁx operators. Function names, together with the «if» keyword, are recognized by virtue of the following « » token. Axis names are recognized by the following «::» token. The keywords «for» «some» and «every» are recognized by the following «$» token.   XPath 2.0 Syntax Summary  Whitespace and Comments  I have organized the rules in the appendix to make a clear distinction between tokens, which cannot contain internal whitespace, and non-terminals, which can contain whitespace between their individual tokens. This separation is not quite so clear in the W3 C speciﬁcation, which is another result of the complications caused by XQuery.  XQuery uses element constructors that mimic XML syntax, so it does not have such a clear separation between the lexical level of the language and the syntactic level.   Whitespace is deﬁned here as any sequence of space, tab, linefeed, and carriage return characters, and comments.  A comment in XPath starts with « :» and ends with «: ». Comments may be nested, so any « :» within a comment must be matched by a closing «: ». Comments may appear anywhere that whitespace is allowed.  Whitespace is required between two tokens if the ﬁrst character of the second token could otherwise be construed as a continuation of the ﬁrst token. So «price - discount» is three tokens, the «-» being a minus operator, while «price-discount» is a single token, the «-» being a hyphen within the element name. There is also a requirement to write a space between a number and an adjacent word, for example «if  a  then 3 else 4», because the «e» of «else» could otherwise be taken as introducing an exponent in a double. For consistency, this rule is applied even if the word begins with a letter other than «e».  Tokens  The deﬁnition of a token that I am using here is: a symbol that cannot contain separating whitespace. This means that my classiﬁcation of which symbols are tokens is slightly different from the classiﬁcation that appears in the W3 C speciﬁcation.  Simple tokens such as «+» and «and» are not included in this table; they simply appear anonymously in the syntax productions.  Symbol  Syntax  IntegerLiteral  Digit+  DecimalLiteral    «.» Digit+      Digit+ «.» Digit*    DoubleLiteral     «.» Digit+      Digit+   «.» Digit*  ?    «e»  «E»    «+»  «-»  ? Digit+  Digit  [0-9]  StringLiteral   «"»  [^"] * «"» +   «’»  [^’] * «’» +  Wildcard  «*»  NCName«:*»  «*:»NCName  NCName  QName  Char  See XML Namespaces Recommendation  See XML Namespaces Recommendation  See XML Recommendation  Page page 530  page 530  page 530  page 530  page 532  page 614  page 534  page 534  page 534  1118   Syntax Productions  A  Syntax Productions  These rules mainly use familiar notations: «*» for repetition, parentheses for grouping, «?» to indicate that the preceding construct is optional, «» to separate alternatives. The rules are given in alphabetical order for ease of reference.  Simple tokens are represented using chevrons; for example, «@» in the ﬁrst rule represents a literal at-symbol.  X P a t h 2  .  0 S y n t a x S u m m a r y  Symbol  Syntax  AbbrevForwardStep  «@»? NodeTest  AbbrevReverseStep  «..»  AdditiveExpr  MultiplicativeExpr    «+»  «-»   MultiplicativeExpr  *  AndExpr  AnyKindTest  AtomicType  «node» « » « »  QName  ComparisonExpr   «and» ComparisonExpr  *  AttributeTest  BasicAttributeTest  SchemaAttributeTest  AxisStep   ForwardStep  ReverseStep  PredicateList  BasicAttributeTest  «attribute» « » NameOrWildcard  «,» TypeName ?  ? « »  BasicElementTest  «element» « » NameOrWildCard «,» TypeName «?»? ?  ? « »  CastableExpr  CastExpr   «castable» «as» SingleType  ?  CastExpr  CommentTest  ComparisonExpr  UnaryExpr   «cast» «as» SingleType  ?  «comment» « » « »  RangeExpr     ValueComp  GeneralComp  NodeComp   RangeExpr  ?  ContextItemExpr  «.»  DocumentTest  «document-node» « » ElementTest? « »  ElementTest  BasicElementTest  SchemaElementTest  Expr  ExprSingle  FilterExpr  ForExpr  ForwardAxis  ExprSingle  «,» ExprSingle *  ForExpr  QuantifiedExpr  IfExpr  OrExpr  PrimaryExpr PredicateList  «for» «$» VarName «in» ExprSingle  «,» «$» VarName «in» ExprSingle * «return» ExprSingle   «child»  «descendant»  «attribute»  «self»  «descendant-or-self»  «following-sibling»  «following»  «namespace»  «::»  Page page 621  page 621  page 572  page 594  page 616  page 655  page 672  page 606  page 672  page 672  page 655  page 655  page 616  page 582  page 543  page 616  page 672  page 524  page 524  page 638  page 640  page 607  continued  1119   XPath 2.0 Syntax Summary  Symbol  Syntax  ItemType  KindTest  NameTest  NodeComp  NodeTest  PathExpr  PITest  ForwardStep   ForwardAxis NodeTest   AbbrevForwardStep  FunctionCall  QName « »   ExprSingle  «,» ExprSingle  *  ? « »  GeneralComp  «=»  «!=»  « »  «>=»  IfExpr  «if» « » Expr « » «then» ExprSingle «else» ExprSingle  InstanceofExpr  TreatExpr   «instance» «of» SequenceType  ?  IntersectExceptExpr  InstanceOfExpr   «intersect»  «except»  InstanceOfExpr *  AtomicType  KindTest   «item» « » « »   DocumentTest  ElementTest  AttributeTest  PITest  CommentTest  TextTest  AnyKindTest  Literal  NumericLiteral  StringLiteral  Multiplicative Expr  UnionExpr    «*»  «div»  «idiv»  «mod»   UnionExpr  *  NameOrWildcard  QName  «*»  QName  Wildcard  «is»  « >»  KindTest  NameTest  NumericLiteral  IntegerLiteral  DecimalLiteral  DoubleLiteral  OccurrenceIndicator  «?»  «*»  «+»  OrExpr  AndExpr   «or» AndExpr  *  ParenthesizedExpr  « » Expr? « »   « » RelativePathExpr?   «  » RelativePathExpr  RelativePathExpr  «processing-instruction» « »  NCName  StringLiteral ? « »  Predicate  «[» Expr «]»  PredicateList  Predicate*  PrimaryExpr  QuantifiedExpr  Literal  VarRef  ParenthesizedExpr  ContextItemExpr  FunctionCall   «some» «every»  «$» VarName «in» ExprSingle  «,» «$» VarName «in» ExprSingle * «satisfies» ExprSingle  RangeExpr  AdditiveExpr   «to» AdditiveExpr  ?  RelativePathExpr  StepExpr   « »  «  »  StepExpr *  Page page 606  page 544  page 582  page 551  page 677  page 629  page 668  page 616  page 539  page 572  page 672  page 614  page 582  page 613  page 539  page 668  page 594  page 542  page 625  page 616  page 618  page 618  page 539  page 646  page 636  page 625  1120   Syntax Productions  A  Symbol  ReverseAxis  Syntax   «parent»  «ancestor»  «preceding-sibling»  «preceding»  «ancestor-or-self»  «::»  ReverseStep   ReverseAxis NodeTest   AbbrevReverseStep  SchemaAttributeTest  «schema-attribute» « » QName « »  SchemaElementTest  «schema-element» « » QName « »  SequenceType   ItemType OccurrenceIndicator?   «empty-sequence» « » « »   SingleType  AtomicType «?»?  StepExpr  TextTest  TreatExpr  TypeName  UnaryExpr  UnionExpr  ValueComp  VarRef  AxisStep  FilterExpr  «text» « » « »  QName    «+»  «-»  * PathExpr  CastableExpr   «treat» «as» SequenceType  ?  IntersectExceptExpr    «union»  «»   IntersectExceptExpr  *  «eq»  «ne»  «lt»  «le»  «gt»  «ge»  «$» QName  X P a t h 2  .  0 S y n t a x S u m m a r y  Page page 607  page 607  page 674  page 674  page 668  page 655  page 602  page 616  page 678  page 672  page 572  page 629  page 582  page 540  1121   XPath 2.0 Syntax Summary  Operator Precedence  The following table lists the precedence of the XPath operators. Operators lower down the table bind more tightly than operators further up the table. So «A or B and C» means «A or  B and C ».  Precedence 1  Operator  «,»  «for», «some», «every», «if»  «eq», «ne», «lt», «le», «gt», «ge»,«=», «!=», « », «>=», «is», « >»  «or»  «and»  «to»  inﬁx «+», inﬁx «-»  «*», «div», «idiv», «mod»  «union», «»  «intersect», «except»  «instance of»  «treat as»  «castable as»  «cast as»  unary «+», unary «-»  « », «  »  «[]»  If two operators appear in the same row, then they are evaluated from left to right. So «A - B + C» means « A - B  + C».  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  1122   B  E r r o r C o d e s  Error Codes  The XSLT and XPath speciﬁcations associate error codes with each error condition. There is an implicit assumption here that although the W3C speciﬁcation deﬁnes no API for invoking XPath expressions, there will be such APIs deﬁned elsewhere, and they will need some way of notifying the application what kind of error has occurred. The error codes may also appear in error messages output by an XSLT processor, though there is no guarantee of this.  Technically, error codes are QNames whose namespace is http:  www.w3.org 2005 xqt-errors. The 8-character code that you usually see, such as XPTY0004, is the local part of the QName. This mecha- nism allows additional error codes deﬁned by a product vendor or application writer to be allocated in a different namespace. If you detect an error at application level, you can call the error   function  see Chapter 13  to force an error to be raised, specifying the error code to be allocated.  There is no normative error message text associated with each error code, either in the speciﬁcation or in this appendix: hopefully, real products will give error messages that are much more helpful than those in the speciﬁcation, including an indication of where the error occurred. For each error, this appendix gives ﬁrst a short description, then an explanation of possible causes. For the errors deﬁned in the XPath and Functions and Operators speciﬁcations the short description is usually taken straight from the spec; for XSLT errors, the description in the spec is often quite long and technical, so the description given here is a gloss.  Experience with the XSLT and XQuery test suites suggests that different products will often report the same error in different ways, and for many error conditions there’s more than one code listed that could describe it. However, understanding error messages when things go wrong can be one of the most baf- ﬂing experiences while learning a new language, so I thought that listing the codes and trying to explain them would be a worthwhile use of the space.  Each error code has a two-letter type, a two-letter subtype, and a four-digit number. The types and subtypes are listed in the table below. Type FO  Meaning Functions and Operators: Arithmetic  Subtype AR  FO  FO  CA  CH  Functions and Operators: Casting  Functions and Operators: Character handling  continued   Error Codes  Type FO  Subtype DC  FO  FO  FO  FO  FO  FO  XP  XP  XP  XT  XT  XT  XT  XT  DT  ER  NS  RG  RX  TY  DY  ST  TY  DE  MM  RE  SE  TE  Meaning Functions and Operators: Documents  Functions and Operators: Dates and Times  Functions and Operators: Error Function  Functions and Operators: Namespaces  Functions and Operators: Arguments  Functions and Operators: Regular Expressions  Functions and Operators: Typed Value Determination  XPath: Dynamic Errors  XPath: Static Errors  XPath: Type Errors  XSLT: Dynamic Errors  XSLT:    XSLT: Static Errors  XSLT: Type Errors  XSLT: Recoverable Dynamic Errors  The error codes are listed in alphabetical order.  Functions and Operators  FO   FOAR0001 Division by zero  FOCA0002  Invalid lexical value  This error can occur when using any of the operators «div», «idiv», or «mod» with integer or decimal arith- metic. With ﬂoating point arithmetic, division by zero results in positive or negative inﬁnity.  FOAR0002 Numeric operation overﬂow underﬂow  With ﬂoating point arithmetic, overﬂow and under- ﬂow conditions generally produce inﬁnity or zero, but the implementation has the option of raising this error instead. With integer and decimal arithmetic, an imple- mentation must produce this error if the result is outside the range of values that can be represented. The capacity of a decimal or integer value is implementation-deﬁned, so an operation that succeeds with one implementation might raise this error with another.  FOCA0001  Input value too large for decimal  Used when casting to a decimal value from a ﬂoat or double that is outside the implementation-deﬁned limits supported by the xs:decimal data type.  Used when an invalid argument is passed to resolve-QName   or QName  , or when the ﬂoat or double value NaN, INF, or -INF is cast to xs:decimal.  FOCA0003  Input value too large for integer  Raised when casting from an xs:decimal, xs:float, or xs:double to an xs:integer, if the value is outside the implementation-deﬁned limits for the xs:integer data type.  FOCA0005 NaN supplied as ﬂoat double value  Used when multiplying or dividing a duration by a number, if the number supplied is NaN.  FOCA0006 String to be cast to decimal has too many digits of precision  Raised when casting from string to decimal if there are more digits than the system can represent accurately. The implementation has the option of raising this error or rounding the value.  1124   FOCH0001 Codepoint not valid  Raised by the codepoints-to-string   function if the sequence of integers supplied includes a value that does not represent a legal XML character.  FOCH0002 Unsupported collation  Raised if the value of a collation argument of any func- tion is not deﬁned in the static context or is not supported by the implementation.  FOCH0003 Unsupported normalization form  The normalization form requested in a call to the normalize-unicode   function is one that the imple- mentation does not support.  FOCH0004 Collation does not support collation units  Some collations can be used for comparing strings, but not for extracting substrings. This error is reported if the collation supplied to one of the functions contains  , starts-with  , ends-with  , substring-before  , or substring-after   is not able to split a string into substrings.  FODC0001 No context document  The functions id   and idref   operate within the document containing the context node. If there is no con- text item, or if the context item is not a node, or if the tree containing the context node is not rooted at a document node, then this error is raised.  FODC0002 Error retrieving resource  Indicates that a document requested using doc   or document   cannot be found or cannot be parsed as XML, or that collection   was called with no argu- ments when there is no default collection.  FODC0003 Function stability not deﬁned  Repeated calls on doc  , document  , or collec- tion   are required to return the same result each time unless the user explicitly waives this requirement. This error is raised if the implementation cannot return stable results perhaps because documents have been updated on disk.  FODC0004  Invalid argument to collection    This error means that the URI passed to the collection   function is not a valid URI, or does not correspond to the URI of any known collection.  FODC0005 doc-available    Invalid argument to doc   or  Raised if the string passed as an argument to the doc   or doc-available   function is not a valid URI. Also raised for doc   if no document can be located with the  B  E r r o r C o d e s  Functions and Operators  FO   speciﬁed URI, or if the resource found at that URI cannot be parsed as an XML document.  FODT0001 Overﬂow in date time arithmetic  Occurs when adding a duration to an xs:date or xs:dateTime value  or when subtracting , or when casting to a date time value, if the result of the operation is outside the range supported for dates.  FODT0002 Overﬂow underﬂow in duration arithmetic  Occurs when multiplying or dividing a duration by a number, or when casting to a duration, if the result is outside the range supported for the relevant duration data type.  FODT0003 Invalid timezone value  Indicates that the timezone supplied to adjust-X-to-timezone   is outside the range ±14 hours, or is not an integer number of minutes.  FOER0000 Unidentiﬁed error  Indicates that the error   function was called without supplying a more speciﬁc error code.  FONS0004 No namespace found for preﬁx  Raised by the QName   constructor and by the resolve-QName   function if the preﬁx in the sup- plied lexical QName cannot be resolved to a namespace URI.  FONS0005 Base URI not deﬁned in the static context  Raised by the single-argument form of the resolve-URI   function if no base URI has been estab- lished in the static context. In XSLT, the base URI is taken from the stylesheet module containing the XPath expres- sion, and this error suggests that the original location of this module is unknown.  FORG0001 Invalid value for cast constructor  Means that the value passed to a constructor function or «cast as» expression is not a legal value  and cannot be converted to a legal value  for the target data type.  FORG0002 Invalid argument to resolve-uri    This error occurs when either of the URIs passed to the resolve-URI   function is not a valid URI.  FORG0003 zero-or-one   called with a sequence con- taining more than one item  Calling the zero-or-one   function asserts that the argument is a sequence containing at most one item. If the assertion proves to be wrong, this error is raised.  FORG0004 one-or-more   called with a sequence containing no items  1125   Error Codes  Calling the one-or-more   function asserts that the argument is a sequence containing at least one item. If the assertion proves to be wrong, this error is raised. FORG0005 exactly-one   called with a sequence con- taining zero or more than one item  Calling the exactly-one   function asserts that the argument is a sequence containing exactly one item. If the assertion proves to be wrong, this error is raised.  FORG0006 Invalid argument type  Indicates that a value supplied to boolean  , avg  , min  , max  , or sum   is of a type that the function cannot handle, despite matching the function signature.  FORG0008 Both arguments to dateTime   have a speci- ﬁed timezone  If the two arguments of dateTime   both have a time- zone, then the timezones must match.  FORG0009 Error in resolving a relative URI against a base URI in resolve-uri    The second argument to resolve-uri  , if supplied, should be an absolute hierarchic URI.  FORX0001 Invalid regular expression ﬂags  The ﬂags supplied to matches  , replace  , and tokenize   must contain zero or more of the letters «s», «m», «i», and «x», in any order.  FORX0002 Invalid regular expression  Indicates that the regular expression passed to the func- tion matches  , replace  , or tokenize   is not valid according to the rules given in Chapter 14.  FORX0003 Regular expression matches zero-length string  The functions replace   and tokenize   dis- allow use of a regular expression that would match a  zero-length string. This rule exists because there is no obviously correct interpretation of what such a regular expression should mean.  FORX0004  Invalid replacement string  Indicates an error in the string supplied as the third argu- ment of the replace   function. If the string contains a «\» character, this must be followed by either «\» or «$», and if the string contains a «$» that is not preceded by a «$», then it must be followed by a digit.  FOTY0012 Argument node does not have a typed value  Raised when the data   function is called supplying an element which according to the schema has element-only content. Such an element has no typed value. The call on data   might be implicit in some other operation that atomizes its operands.  XPDY0002 Evaluation of an expression relies on some part of the dynamic context that has not been assigned a value  For example, within a stylesheet function there is no context item, so a reference to «.» or position   will cause this error.  XPDY0050 The dynamic type of the operand of a treat expression does not match the type speciﬁed by the treat expression  The «treat as» expression is an assertion: when you say «$x treat as xs:integer», you are assert- ing that at runtime, the variable «$x» will contain an xs:integer. If you get it wrong, and the variable con- tains some other value, this is the error that will be reported.  Because « » is deﬁned using «treat as», this error also occurs if you use « » when the context node is in a tree whose root is not a document node.  XPath Errors  XP   XPST0001 Analysis of an expression relies on some compo- nent of the static context that has not been assigned a value  For example, using an unpreﬁxed function name is an error if there is no default namespace for functions, and using the «=» operator is an error if there is no default collation.  XSLT deﬁnes default values for most components of the static context, making this error unlikely. But some aspects such as the static base URI need to be supplied by the user via the processor’s API.  As with the static context, it’s up to the host language to deﬁne whether the various parts of the dynamic context are given default values.  XPST0003 An expression is not a valid instance of the XPath grammar  This is an umbrella code that covers all XPath syntax errors.  XPST0005 The static type assigned to an expression other than the expression «  » is empty-sequence    1126   XSLT Errors  XT   B  E r r o r C o d e s  This error only occurs with static type checking, which makes it unlikely under XSLT. It is designed primar- ily to catch incorrect path expressions. For example, if the schema deﬁnition for element «para» does not allow it to contain element «head», then a processor that does static typing will reject the path expression «para head» as an error.  «mf:invoice» is either not deﬁned at all or is a complex type, a list type, or a union type.  Perhaps you meant to write «$x instance of element *, mf:invoice ».  XPST0080 The target type of a cast or castable expression is xs:NOTATION or xs:anyAtomicType  XPST0008 An expression refers to an element name, attribute name, schema type name, namespace preﬁx, or vari- able name that is not deﬁned in the static context  This is subtly different from XPST0051 because these two types are atomic. But they are abstract, so you cannot cast to them.  This means that you haven’t declared the object that is referenced in the expression. This might be because you misspelled the name, or it might be because you got the namespace preﬁx wrong — if the name has a preﬁx, check that it refers to the correct namespace URI, and if it doesn’t, check what the default namespace for that kind of name is.  XPST0010 An expression refers to an axis that the imple- mentation does not support  Under XSLT this can only be the namespace axis; proces- sors are not required to support this axis.  XPST0017 The expanded QName and number of arguments in a function call do not match the name and arity of a function signature in the static context  This error either means that the function you are calling has not been declared, or that you are calling it with the wrong number of arguments. Check the namespace.  XPST0021 sion cannot be cast to the required type  It is a dynamic error if a value in a cast expres-  Not all casts are allowed. For example, you cannot cast from an integer to a date. This error message means that you have attempted one of these disallowed casts. The casts that are allowed are described in Chapter 9 of this book.  XPST0051 A QName used as an AtomicType in a Sequence- Type is not deﬁned in the in-scope schema types as an atomic type  This means you have used an expression such as «$x instance of mf:invoice» where the type  XPST0081 A QName used in an expression contains a namespace preﬁx that cannot be expanded into a namespace URI using the statically known namespaces  In other words, you have used a namespace preﬁx with- out ﬁrst declaring it.  XPTY0004 The value of an expression has a type that is not appropriate for the context in which the expression occurs  A common error code. It will occur, for example, if you write «abs "a" », because the argument to abs   must be a number. Like other type errors, this may be detected either at compile time or at runtime.  XPTY0018 The last step in a path expression contains both nodes and atomic values  Any expression on the right-hand side of « » must return either nodes or atomic values, not a mixture.  XPTY0019 A step  other than the last step  in a path expres- sion contains an atomic value  Any expression on the left-hand side of « » must return nodes, not atomic values.  XPTY0020 In an axis step, the context item is not a node  When you use an expression such as «title» or «@code» or «..» or «ancestor::chap», you are selecting nodes relative to the context node. If the context item is an atomic value, then these expressions can’t be evaluated.  Note that even rooted path expressions  those starting with « »  require a context node, because they always select nodes within the same document that contains the context node.  XSLT Errors  XT   XTDE0030 The value of an attribute value template is invalid for that attribute For example, with <xsl:message terminate="$z" >, the value of $z was ”maybe.”  XTDE0040 When invoking a stylesheet by specifying an ini- tial template, the name must match that of a named template in the stylesheet  1127   Error Codes  XTDE0045 When invoking a stylesheet with an initial mode, the mode name must match the mode name of at least one xsl:template in the stylesheet  In the content of a new element node, there  XTDE0430 must not be two namespace nodes that bind the same preﬁx to different URIs  XTDE0047 When invoking a stylesheet, both an initial template and an initial mode were speciﬁed  An initial template means you want to start by calling a named template, so the initial mode wouldn’t be used.  XTDE0050 When invoking a stylesheet, a value must be provided for every stylesheet parameter that speciﬁes required="yes"  XTDE0060 When invoking a stylesheet by specifying an ini- tial template, the initial template must not have any required parameters  Any parameters you supply when starting the transfor- mation are matched against global stylesheet parameters, not against the local parameters of the ﬁrst template to be executed. These local parameters, if any, will always take their default values.  This will only happen if you create two conﬂicting namespaces deliberately. If there is an accidental clash, the system will sort it out by changing preﬁxes.  XTDE0440 In the content of a new element node with a null namespace URI, there must be no namespace node that deﬁnes a default namespace  This will only happen if you explicitly create or copy a namespace node equivalent to the declaration «xmlns="some-uri"». Perhaps you are doing this because you want the element to be in the «some-uri» namespace. The right way to put it in this namespace is at the time you create the element, typically by using the namespace attribute of  .  XTDE0560 When xsl:apply-imports or xsl:next- match is evaluated, the current template rule must not be null  XTDE0160 If the implementation does not support backward-compatible behavior, then instructions that invoke this behavior must not be evaluated  The current template rule is null while evaluating a global variable or a stylesheet function; it is also null inside an   iteration.  XSLT processors are not required to support 1.0 mode. If you request it by setting «version="1.0"», and then evaluate an instruction with this setting in scope, the processor must report a fatal error.  XTDE0610 When a template parameter is required because it has neither a select attribute nor content, but has an «as» attribute that does not allow the empty sequence, then the caller must supply a value  XTDE0290 Where the result of an XPath expression is required to be a lexical QName, the resulting name must have a preﬁx that is declared in the stylesheet  This applies for example to the ﬁrst argument of the key   function, or the third argument of format-number  . For some situations there is a more speciﬁc error code.  XTDE0410 In the content of a new element node, attributes and namespaces must come before other kinds of node  When you create a new element, you must write its attributes before you generate any child elements or text nodes. This rule is designed to allow streamed output: the processor knows when it sees the ﬁrst child of an element that it will not see any more attributes, so it can write the start tag to the serializer. This can potentially reduce the delay before the user sees the ﬁrst output emerging.  XTDE0420 In the content of a new document node, there must be no attributes or namespaces  Attributes and namespaces can be output to a result document only as part of the content of an element node.  If   has no «as» attribute, and no default is speciﬁed, then the default value is a zero-length string. If it has an «as» attribute, the ‘‘default default’’ is an empty sequence. But if the «as» attribute does not allow an empty sequence, for example «as="xs:date"», then the parameter is treated as a required parameter and it is an error to supply no value.  XTDE0640 A stylesheet must have no circularities  This describes a range of conditions, for example a global variable being deﬁned in terms of itself, a key being deﬁned in terms of itself, or a global variable being set by calling a function that references the global vari- able. XSLT processors must detect such errors, either at compile time or at runtime.  XTDE0700 When a template has a parameter that speciﬁes required="yes", the caller must supply a value  XTDE0820 The name attribute of xsl:element must evaluate to a valid lexical QName  In XSLT 1.0 processors were allowed to ignore this error and continue without creating the offending element. In 2.0 it is fatal and must be reported.  1128   XSLT Errors  XT   B  E r r o r C o d e s  XTDE0830 When xsl:element has no namespace attribute, the QName produced by evaluating the name attribute must use a preﬁx that has been declared in the stylesheet  This is true even if the name is computed at run- time. It’s safest to specify the namespace attribute on   to avoid this error occuring.  XTDE0835 The namespace attribute of xsl:element must evaluate to a valid xs:anyURI  This is a change from XSLT 1.0, which speciﬁcally allowed you to use any string as a namespace name. However, the rules for what is a valid xs:anyURI are fairly liberal.  XTDE0925 In the result of xsl:namespace, the pre- ﬁx «xml» can be used only with the XML namespace, and vice versa  The XML namespace is automatically in-scope on every element, so you never need to generate it.  XTDE0930 In the result of xsl:namespace, the name- space URI must not be a zero-length string  The instruction generates a namespace node, not a namespace declaration or undeclaration. To force a namespace undeclaration to appear, use «[xsl:]inherit-namespaces="no"» when creat- ing the element, with <xsl:output method="xml" version="1.1" >.  XTDE0850 The name attribute of xsl:attribute must evaluate to a valid lexical QName  XTDE0980 The value attribute of xsl:number must evaluate to a sequence of non-negative integers  See XTDE0820.  A single positive integer is the more usual case.  XTDE0855 The name attribute of xsl:attribute must not evaluate to xmlns.  XTDE1030 The values of sort keys computed for xsl:sort must be comparable using «lt»  You can’t use   to create name- space declarations. Usually, namespace declarations take care of themselves if you specify the right name- space when creating your elements. On the rare occasions that you need to generate namespaces by hand, use  .  XTDE0860 When xsl:attribute has no namespace attribute, the QName produced by evaluating the name attribute must use a preﬁx that has been declared  XTDE0865 The namespace attribute of xsl: attribute must evaluate to a valid xs:anyURI.  See XTDE0830.  See XTDE0835.  For example, they must not be xs:duration or xs:QName values, and they must not use a mixture of different types such as strings and integers  XTDE1035 The collation attribute of xsl:sort must be a collation recognized by the processor  The collation URIs that are recognized will vary from one product to another. If you want your stylesheet to be portable, it’s best to pass the collation URIs as the values of stylesheet parameters.  XTDE1110 The collation attribute of xsl:for-each-group must be a collation recognized by the processor  See XTDE1035.  XTDE0905 The name attribute of xsl: processing-instruction must evaluate to a valid processing instruction name  The name must be a valid NCName  no colon allowed , and it must not be «xml» in any combination of upper and lower case.  The XML declaration is not a pro- cessing instruction. To control the XML declaration in the result document, use the various attributes of  .   XTDE1140 The regex attribute of xsl:analyze- string must evaluate to a valid regular expression  Remember that the regex attribute is an attribute value template, so any curly braces need to be doubled.  XTDE1145 The flags attribute of xsl:analyze- string must evaluate to a valid set of ﬂags  The value must be a string containing one or more of «i», «m», «s», and «x».  XTDE0920 The name attribute of xsl:namespace must evaluate to either a zero-length string or a valid NCName other than «xmlns».  XTDE1150 The regex attribute of xsl:analyze- string must not evaluate to a regular expression that matches a zero-length string  To generate «xmlns="abc"», the name attribute should be a zero-length string; to generate «xmlns:pfx="abc"», it should be "pfx".  For example, «regex="[0-9]*"» matches the string ””, so it is invalid. If ”” is a legitimate input value, handle it separately.  1129   Error Codes  XTDE1170 The URI passed to unparsed-text   must contain no fragment identiﬁer and must identify a resource containing text  XTDE1350 The picture string used for format- date time   must not refer to components that are not available in the given type of value  This covers a wide range of things that can go wrong when trying to read an external ﬁle.  XTDE1190 The resource retrieved using unparsed-text   must be decodable using the speciﬁed encoding, and must decode to valid XML characters  This rules out reading a binary ﬁle, which might contain bytes such as x00 that are not valid in XML.  XTDE1200 If the second argument to unparsed-text   is omitted the processor must be able to infer the encoding, or the encoding must be UTF-8  If the processor can’t work out the encoding, then it will assume UTF-8, and if the ﬁle is not encoded in UTF-8 then it’s quite likely that decoding will fail with this error.  XTDE1260 The ﬁrst argument to key   must be a valid lexical QName whose preﬁx has been declared and which identiﬁes a key declaration in the stylesheet  The value  even if computed at runtime, which is rare  must either be unpreﬁxed or use a preﬁx that is declared at the point where the key   function is called, and it must match the name attribute of an   declaration.  XTDE1270 The node supplied in the third argument of key  , or the context node if omitted, must be a node in a tree that is rooted at a document node  To make life easier for implementors, key   can only be used to search within a complete document. You can search a subtree rooted at an element, as long as it is part of a complete document rooted at a document node.  XTDE1280 The third argument to format-number   must be a valid lexical QName whose preﬁx has been declared and which identiﬁes a decimal format declaration in the stylesheet  That is, it must match the name attribute of an   declaration.  XTDE1310 The second argument to format-number   must be a valid picture string  For the rules, see the description of format-number   in Chapter 13.  XTDE1340 The second argument to format-date time   must be a valid picture string  The rules are described under format-dateTime   in Chapter 13.  For example, you can’t use «[MNn]» with format- time  , because a time does not have a month compo- nent.  XTDE1360 The current   function must not be used within an expression that is evaluated when there is no context item  Since current   refers to the value of the context item at the outermost level of the XPath expression, it’s an error if there is no context item at that level.  XTDE1370 When unparsed-entity-uri   is evalu- ated there must be a context node, and it must be in a tree rooted at a document node  Unparsed entities can only occur in complete XML docu- ments; this function searches the document in which the context node is to be found.  XTDE1380 When unparsed-entity-public-id   is evaluated there must be a context node, and it must be in a tree rooted at a document node  See XTDE1370.  XTDE1390 The ﬁrst argument of system-property   must be a valid lexical QName and its preﬁx must be declared  The argument will usually be a string literal, and it will usually be a name in the XSLT namespace such as xsl:vendor. It doesn’t have to be a preﬁxed name; you may be able to use a plain name to access operating system environment variables.  XTDE1400 The ﬁrst argument of function- available   must be a valid lexical QName and its preﬁx must be declared  The name doesn’t have to be preﬁxed; if it isn’t, the default function namespace is assumed.  XTDE1425 When an extension function is called the sup- plied arguments must satisfy the rules for the extension function, the extension function must not report an error, and the result must be convertible to an XPath value  This is a catch-all for the things that can go wrong when you call an extension function.  XTDE1428 The ﬁrst argument of type-available   must be a valid lexical QName and its preﬁx must be declared  The name doesn’t have to be preﬁxed; in the absence of a preﬁx the value of xpath-default-namespace applies.  1130   XTDE1440 The ﬁrst argument of element- available   must be a valid lexical QName and its preﬁx must be declared  Typically, this will be a name either in the XSLT name- space, or in a namespace deﬁned by the vendor for extensions.  XTDE1450 An unrecognized extension instruction with no xsl:fallback children was encountered  The processor knows that it is an extension instruc- tion because its namespace was identiﬁed in [xsl:]extension-element-prefixes. But the pro- cessor doesn’t know how to evaluate the instruction, and there is no fallback implementation.  XTDE1460 The format attribute of xsl:result- document must evaluate to a valid lexical QName, its preﬁx must be declared, and it must match the name of an output deﬁnition in the stylesheet  That is, it must match the name attribute of an   declaration  comparing the names as QNames .  XTDE1480 The xsl:result-document instruction must not be evaluated in temporary output state  This typically means that you called   while evaluating a vari- able or a function. This isn’t allowed because producing a new output document is a kind of side effect.  XTDE1490 A transformation must not generate two result trees with the same URI  One output document would typically overwrite the other, and since order of execution is undeﬁned, it’s not clear which one would win. The processor might even try to write both at once, with fatal results.  XTDE1665 When a basic  non-schema-aware  pro- cessor is used, the input document must not contain a node with a type annotation other than xs:untyped or xs:untypedAtomic, or an atomic value of a type which basic XSLT does not allow  It’s very likely that if your processor isn’t schema-aware, then there’s no way to create typed  validated  input documents, so this error condition will never arise. But it’s there to cover the eventuality.  XTMM9000 The xsl:message instruction was evaluated with terminate=‘‘yes’’  This isn’t really an error, just a code that the system can use when the stylesheet terminates voluntarily.  XTRE0270 An xsl:strip-space and xsl:preserve-space declaration deﬁne conﬂicting rules for the same element  B  E r r o r C o d e s  XSLT Errors  XT   The processor can report this as an error, or can use whichever declaration comes last in the stylesheet.  XTRE0540 There must not be two template rules that match the same node with the same mode, import precedence, and priority  It’s best not to have two template rules that match the same node, but if it happens, the processor has a choice. It can report a fatal error, or it can choose the template that comes last in the stylesheet, either silently or with a warning. If you see this error, it’s best to make your intentions clear by setting the priority attribute on both templates to indicate which is preferred.  XTRE0795 If the name of a constructed attribute is xml:space then the value must be default or preserve.  The XML speciﬁcation says that a value for xml:space other than these two is ‘‘erroneous’’, but it’s not clear whether such a document is well formed or not; some XML parsers accept it and some don’t. XSLT processors are allowed to report an error if you try to write such a value, but they can ignore the error if they prefer.  XTRE1160 When a URI passed to document   contains a fragment identiﬁer, the fragment identiﬁer must be valid for the media type  which the processor must recognize  and must select a sequence of nodes  A fragment identiﬁer is the part of a URI after the «» sign. The interpretation of a fragment identiﬁer depends on the media type  =MIME type  of the resource. For «application xml», the fragment is typically the value of an ID attribute, but this is only recognized if  a  the media type is known  usually from HTTP headers , and  b  ID attributes are notiﬁed by the XML parser.  XTRE1495 A transformation must not generate two result trees with URIs that identify the same physical resource  See also XTDE1490. If you write to two differ- ent URIs that refer to the same ﬁle  for example, file: c: temp.xml and file: C: TEMP.XML  the system is allowed to report an error, but it’s likely that it won’t notice, and the effect is then undeﬁned.  XTRE1500 A transformation must not write to and read from the same resource, whether or not the same URI is used  This means you can’t write a document using   and then immediately read it using the doc   function. This would make your stylesheet dependent on the order of execution; it would also be a sneaky way of introducing side effects. How- ever, although this is deﬁned as an error, processors are not obliged to catch it, and if you use a slightly different URI when reading and writing  see XTRE1495 , you will probably get away with it.  1131   Error Codes  disable-output-escaping was XTRE1620 requested, but is not supported by the implementation  XTSE0130 The xsl:stylesheet element has a child element with a null namespace URI  This feature is deprecated in XSLT 2.0, and not all imple- mentations support it. Try to ﬁnd a cleaner design for the code. A processor that doesn’t support this attribute can report a fatal error or a warning if you use it, or can simply ignore it.  XTRE1630 when writing to a result tree that is not being serialized  disable-output-escapingwas requested  The disable-output-escaping attribute is a request to the serializer. So if you’re not serializing  for example, if you are writing the output to a DOM tree , then it can’t be acted upon, which might mean that your code doesn’t produce the desired effect. The processor can report the error or simply ignore the attribute.  XTSE0010 An XSLT-deﬁned element is used where it is not permitted, a required attribute is omitted, or the content of the element doesn’t correspond to the permitted content  This is a catch-all for structural errors in the stylesheet.  XTSE0020 An attribute contains a value that is not permit- ted for that attribute  Used when no more speciﬁc error is available.  XTSE0080 A reserved namespace is used in the name of a named template, mode, attribute set, key, decimal format, variable, parameter, stylesheet function, output deﬁnition, or character map  Reserved namespaces all start with http:   www.w3.org ; they are not available for user-deﬁned names.  XTSE00090 An element in the XSLT namespace has an attribute whose namespace is either null or the XSLT names- pace, other than the attributes deﬁned for this element  This probably means you misspelled an attribute name in the stylesheet or forgot the correct name. You are allowed attributes beyond those deﬁned in the spec if they are in your own  or the vendor’s  namespace.  XTSE0110 The value of the version attribute must be a valid xs:decimal  Normal values are «version="1.0"» and «version="2.0"».  XTSE0125 The [xsl:]default-collation attribute does not contain a URI that the implementation recognizes  You can specify a list of URIs, and the system must recognize at least one of them. To ensure this, include http:  www.w3.org 2005 xpath-functions  collation codepoint at the end of the list.  Top-level elements can be in the XSLT namespace or a user or vendor namespace, but not in no namespace.  XTSE0150 A literal result element used as the outermost element of a stylesheet has no xsl:version attribute  This refers to the simpliﬁed stylesheet syntax; the out- ermost element must have an xsl:version attribute. This error could arise because you misspelled the XSLT namespace URI, or because you supplied a document that isn’t a stylesheet at all.  XTSE0165 The processor cannot retrieve a resource refer- enced by xsl:include or xsl:import, or that resource is not a valid stylesheet module  A common reason for this is that you used a relative URI reference, and the base URI isn’t known. Check your processor API for how to supply the base URI.  XTSE0170 xsl:include must be a top-level element  If you want a ﬁner-grained inclusion mechanism, con- sider using XInclude, or external XML entities.  XTSE0180 A stylesheet module directly or indirectly includes itself  For example A includes B, B includes C, and C includes A. Just remove one of the includes.  XTSE0190 xsl:import must be a top-level element  XTSE0200 xsl:import must precede all other children of the xsl:stylesheet element  The reason for this is to ensure that imported declara- tions have lower import precedence than anything that comes after them.  XTSE0210 A stylesheet module directly or indirectly imports itself  For example A imports B, B includes C, and C includes A: there only needs to be one import in the cycle.  XTSE0215 An xsl:import-schema element that con- tains an xs:schema element has a schema-location attribute, or its namespace conﬂicts with the targetNames- pace of the contained schema  This refers to the ability to write an inline schema directly within the   element. In this case it’s simplest to have no attributes on the   element.  XTSE0220 The schema constructed to support xsl:import-schema is not a valid schema  This could be because you have imported a schema that isn’t valid in itself, or because you have imported two  1132   XSLT Errors  XT   B  E r r o r C o d e s  schemas that aren’t consistent with each other, if for example they contain duplicate deﬁnitions.  XTSE0580 Two parameters of a template or function have the same name  XTSE0260 An XSLT element that is required to be empty has child elements or text nodes  Examples of such elements are   and  .  XTSE0265 One stylesheet module sets input-type- annotations to strip, another to preserve.  This is a rare case where a stylesheet module must be consistent with the modules it imports.  XTSE0280 A preﬁx used in a QName in the stylesheet has not been declared  This might be a preﬁxed variable, template, or mode name. The preﬁx needs to be declared in a name- space declaration on a containing element in the same stylesheet module.  XTSE0340 The syntax of an XSLT pattern is incorrect  Catch-all for syntax errors in the pattern supplied in the match attribute of  , or various other places where match patterns are used.  XTSE0350 A left curly brace in an attribute value template has no matching right curly brace  In an AVT, paired curly braces are used around an XPath expression; for example, «name="chap{$ch}"». XTSE0370 An unescaped right curly brace appears in an attribute value template  If an attribute is deﬁned as an AVT, then any curly braces forming a literal part of the attribute value must be doubled; for example, «regex="{{1,2}}"». XTSE0500 An xsl:template element must have either a match attribute or a name attribute or both; if it has no match attribute, then mode and priority must be absent  This is stricter than XSLT 1.0, where the mode and priority were ignored if there was no match attribute.  XTSE0530 The priority attribute of xsl:template must be a valid xs:decimal.  You can set priority to «2.6» or «-100», but not to «1e6» or «3.1.5».  XTSE0550 The mode attribute of xsl:template is empty, contains duplicates, contains an invalid name, or contains all as well as other names  You can specify a list of valid modes, including default. If the attribute is present, it must not be empty, and if you specify all, then there must be no other mode-names present.  XTSE0620 An xsl:variable, xsl:param, or xsl:with-param element with a select attribute is not empty  You can provide a value using the select attribute or in a contained sequence constructor, but not both.  XTSE0630 Stylesheet contains two global variables with the same name  You can have two variables with the same name pro- vided that they have different import precedence. Consider changing xsl:include to xsl:import.  XTSE0650 The named template called by an xsl:call-template instruction has not been deﬁned  The QName appearing in the name attribute of xsl:call-template must match the name attribute of some xsl:template declaration in the stylesheet.  XTSE0660 Stylesheet contains two named templates with the same name  You can have two templates with the same name provided that they have different import precedence. Consider changing xsl:include to xsl:import.  XTSE0670 Two xsl:with-param elements within the same instruction have the same name  You can’t supply two values for the same parameter. This rule applies even if one is a tunnel parameter and the other is not.  XTSE0680 An xsl:call-template instruction supplies a non-tunnel parameter that is not declared in the template being called  This is a new rule in XSLT 2.0  in 1.0, the extra parameter was simply ignored .  XTSE0690 An xsl:call-template instruction supplies no value for a parameter declared with required="yes".  XTSE0710 An [xsl:]use-attribute-sets attribute is not a list of valid QNames, or contains a QName that doesn’t match the name of any attribute set  XTSE0720 An attribute set directly or indirectly references itself via use-attribute-sets.  For example, attribute set A has «use-attribute- sets="B"», and attribute set B has «use- attribute-sets=A».  XTSE0740 A stylesheet function has an unpreﬁxed name  1133   Error Codes  To distinguish user-deﬁned functions from those in the standard function library, user-deﬁned func- tions must always be in your own namespace, and must be declared using a preﬁx bound to that namespace. For example, <xsl:function name="my:function">, with the declaration «xmlns:my="http:  my.com functions"» on the   element.  XTSE0760 A parameter to a stylesheet function speciﬁes a default value  In a function call, all arguments must be supplied by the caller, so it makes no sense for the   deﬁnition to provide a default value for an argument. The error means that the   element either has a select attribute, or is non-empty.  XTSE0770 Stylesheet contains two functions with the same name and arity  You are allowed two functions with the same name if they have different numbers of arguments, or if they have different import precedence. When overriding a function, use xsl:import rather than xsl:include.  XTSE0805 An attribute on a literal result element is in the XSLT namespace but is not a permitted attribute  Certain attribute such as xsl:validation and xsl:type can appear on literal result elements. Other attributes in the XSLT namespace are not permitted.  XTSE0808 A namespace preﬁx used in exclude-result-prefixes has not been declared  You can’t exclude a namespace unless the namespace has been declared in the stylesheet.  XTSE0809 The value default is used in exclude-result-prefixes, but there is no default namespace  XTSE0810 Two xsl:namespace-alias declara- tions in the stylesheet specify the same namespace via their stylesheet-prefix attribute  XTSE0812 An xsl:namespace-alias declaration speciﬁes a preﬁx in stylesheet-prefix or result- prefix that has not been declared  XTSE0840 The select attribute of xsl:attribute must be absent if the instruction has content  In XSLT 2.0 you can specify the value of the new attribute using the select attribute, but the instruction must then be empty.  In XSLT 2.0 you can specify the value of the new text node in child instructions, but there must then be no select attribute.  XTSE0880 The select attribute of xsl:processing- instruction must be absent if the instruction has content  See XTSE0840.  XTSE0910 The select attribute of xsl:namespace must be present if the instruction is empty, and absent other- wise, not counting any xsl:fallback children  This is similar to other node-creating instructions, but because   is new in XSLT 2.0, it is allowed to have an   child which an XSLT 2.0 processor will ignore.  XTSE0940 The select attribute of xsl:comment must be absent if the instruction has content  See XTSE0840.  If the value attribute of xsl:number is XTSE0975 present, then the select, level, count, and from attributes must all be absent  Specifying the value attribute means you are using   only to format a number, not to get the section number of a node in the source document.  XTSE1015 The select attribute of xsl:sort must be absent if the instruction has content  In XSLT 2.0 you can compute the sort key using child instructions, but the select attribute must then be omitted.  XTSE1017 The stable attribute of xsl:sort is allowed only on the ﬁrst xsl:sort element  This attribute indicates that items with duplicate sort keys should retain their original order. It is a property of the sort as a whole, not of an individual sort key, and is placed on the ﬁrst   element for convenience.  XTSE1040 The select attribute of xsl:perform-sort must be absent if the instruction has content  other than xsl:sort and xsl:fallback   The sequence to be sorted can be computed either using the select attribute or using nested instructions, but not both.  XTSE1060 Call to current-group   appears within a pattern  XTSE1070 Call to current-grouping-key   appears within a pattern  XTSE0870 The select attribute of xsl:value-of must be present if the element is empty, and absent otherwise  XTSE1080 Exactly one of the four attributes group-by, group-adjacent,  1134   group-starting-with, and group-ending-with must be present on xsl:for-each-group.  XTSE1090 The collation attribute of xsl:for- each-group cannot be used unless group-by or group-adjacent is speciﬁed  For other cases, you can achieve the required effect using the default-collation attribute.  XTSE1130 An xsl:analyze-string instruction must contain either xsl:matching-substring or xsl:non-matching-substring or both  XTSE1205 An xsl:key declaration must have either a use attribute or content, but not both  In XSLT 2.0 you can compute the key value using nested instructions, but the use attribute must then be omitted.  XTSE1210 The collation attribute of xsl:key is not a recognized collation  XTSE1220 Several xsl:key declarations with the same name specify different collations  When you have several xsl:key declarations with the same name, they effectively deﬁne a single index, so the same collation must be used on all of them.  XTSE1290 A decimal format contains two conﬂicting deﬁ- nitions for the same attribute  This typically means that you have two <xsl: decimal-format> declarations with the same name  or both with no name  and they both deﬁne an attribute such as decimal-separator, but with different values.  XTSE1295 The zero-digit in a decimal format is not a Unicode digit or is a digit whose value is not zero  You can use non-ASCII digits, for example Indic, Tamil, or Thai digits, but the zero-digit symbol must be a char- acter deﬁned in the Unicode database to have a numeric value of zero.  XTSE1300 in the picture string must have distinct values  In a decimal format, the various characters used  For example, you can’t use «,» as the decimal separa- tor if it is also used as the grouping separator, either explicitly or by default.  In [xsl:]extension-element- XTSE1430 prefixes, a preﬁx is speciﬁed that has not been declared, or default is used when there is no default namespace  B  E r r o r C o d e s  XSLT Errors  XT   These attributes are mutually exclusive. If you know the type that you want to validate against, you don’t need [xsl:]validation.  XTSE1520 An [xsl:]type attribute is an invalid QName, uses an undeclared preﬁx, or does not match the name of any imported schema type  XTSE1530 The type attribute of xsl:attribute refers to a complex type  Attributes must always have simple types.  XTSE1560 An output deﬁnition speciﬁes two conﬂicting values for the same attribute  Typically, you have two xsl:output declarations that both specify the same name  or no name  and that have different values for some serialization property. If you want one to override the other, consider using xsl:import instead of xsl:include.  XTSE1570 The method attribute of xsl:output must either be a preﬁxed QName, or one of xml, html, xhtml, text.  If you want to use your own or a vendor-speciﬁc output method, then its name must be in a namespace.  XTSE1580 Stylesheet contains two character maps with the same name  If you want one to override the other, consider using xsl:import instead of xsl:include.  XTSE1590 A use-character-maps attribute contains a QName that is not the name of any character map  XTSE1600 A character map references itself directly or indirectly  For example, character map A has «use-character-maps="B"» while character map B has «use-character-maps="A"».  XTSE1650 When a basic  non-schema-aware  XSLT pro- cessor is used, there must be no xsl:import-schema declaration  This might be because you didn’t invoke the processor in the right way to get schema-aware functionality, or you might be using a third-party stylesheet that was written to require a schema-aware processor.  XTSE1660 When a basic  non-schema-aware  XSLT proces- sor is used, there must be no [xsl:]type attribute, and the only permitted value for [xsl:]validation is strip.  See XTSE1650.  1135  XTSE1505 The [xsl:]validation and [xsl:]type attributes must not be present on the same element  XTTE0505 The result of evaluating the content of xsl:template must match the required type   Error Codes  If you specify an «as» attribute on xsl:template, then evaluating the template must deliver a value of the right type. Remember that new elements will be untyped unless you explicitly validate them.  XTTE0510 When xsl:apply-templates has no select attribute, there must be a context node  The default is to process the children of the context node, which fails if there is no context node.  XTTE0520 The value of the select attribute of xsl:apply-templates must not contain atomic values  You can only apply templates to nodes.  XTTE0570 must match the declared type  In a variable declaration, the value of the variable  If you specify an «as» attribute on xsl:variable, then the value of the variable must match the speciﬁed type. Remember that this only declares the required type, it doesn’t invoke automatic casting or validation.  XTTE0590 The value supplied for a parameter of a template must match its declared type  See XTTE0570.  See XTTE0570.  See XTTE0505.  XTTE0600 The default value of a template parameter must match its declared type  XTTE0780 The value returned by a stylesheet function must match its declared type  XTTE0790 The value supplied for a parameter of a stylesheet function must match its declared type  The rules for calling a user-deﬁned function are the same as for a system function; the supplied arguments must match the declared types.  XTTE0950 An xsl:copy or xsl:copy-of instruc- tion is copying namespace-sensitive content using validation="preserve", without copying the necessary namespace nodes  When you specify copy-namespaces="no" and validation="preserve", the absence of name- spaces in the new copy could invalidate any QNames in the content of attributes or text nodes that have been copied.  XTTE0990 When xsl:number has no value or select attribute, there must be a context node  In the absence of these attributes, the default is «select="."», which requires a context node.  XTTE1000 The select attribute of xsl:number must evaluate to a single node  The message could mean that you have selected an atomic value, or a sequence of more than one node; more likely, you have selected an empty sequence.  XTTE1020 Except in backward-compatibility mode, the value of a sort key must not contain more than one item  XTTE1100 The group-adjacent attribute of xsl:for-each-group must evaluate to a single item  With group-by, a node can be assigned to multiple groups by calculating multiple grouping keys, but this isn’t allowed with group-adjacent.  XTTE1120 When xsl:for-each-group has a group-starting-with or group-ending-with attribute, the value of the select attribute must not contain atomic values  These attributes are patterns that only match nodes, so the input  the grouping population  must consist entirely of nodes.  XTTE1510 When [xsl:]validation="strict" is speciﬁed, the constructed content must be valid  This is a catch-all error code for schema validation errors. Hopefully, the processor will provide more detailed information as to why the constructed content was found to be invalid against the schema.  XTTE1512 When [xsl:]validation="strict" is speciﬁed, there must be a matching top-level element declara- tion in the schema  Validation was not possible because no element declara- tion could be found for the root element. Check that the namespace is correct.  XTTE1515 When [xsl:]validation="lax" is speci- ﬁed, the constructed content must have validity either ‘‘valid’’ or ‘‘unknown’’  This means that an element declaration was found  or perhaps there was an xsi:type attribute , so valida- tion took place, but the content was invalid against the schema. See XTTE1510.  XTTE1540 When [xsl:]type is speciﬁed, the created content must be valid against that type  See also XTTE1510. This code is reported when validation was invoked against a named type.  XTTE1545 An instruction with an [xsl:]type or [xsl:]validation attribute must not create a new attribute node with namespace-sensitive content  1136   XSLT Errors  XT   This happens when you do validation at the level of an individual attribute node. If the attribute type is QName or NOTATION, validation is not possible because the attribute is not connected to any element, so there are no namespaces to check against.  The XDM model allows document nodes with no children, multiple element children, or child text nodes, but such documents are never schema-valid.  XTTE1555 When validation is done at document level, ID IDREF constraints must be satisﬁed  XTTE1550 When validation is done at document level, the document node must contain exactly one element child and no text nodes  Speciﬁcally, ID values must be unique, and IDREF values must refer to an ID that exists within the document.  B  E r r o r C o d e s  1137    C  B a c k w a r d C o m p a t i b  i l i t y  Backward Compatibility  The designers of XSLT 2.0 and XPath 2.0 took a great deal of care to ensure that existing code should continue to work unchanged as far as possible, and in my experience, moving forward to 2.0 rarely causes any compatibility problems. However, because there are so many new features, and particularly because of the changes in the type system, a few incompatibilities were inevitable. This appendix summarizes the areas where you are most likely to encounter problems. It’s not a completely comprehensive list; for that, you should go to the relevant appendices of the W3 C speciﬁcations for XSLT 2.0, XPath 2.0, and Functions and Operators. However, many of the incompatibilities described in those appendices are such obscure edge cases that you are very unlikely to encounter them in practice.  You can think of the transition from XSLT 1.0 to XSLT 2.0 as happening in three stages, though you may choose to do all three at once:           The ﬁrst stage takes the stylesheet unchanged, still specifying «version="1.0"», and runs it under an XSLT 2.0 processor instead of an XSLT 1.0 processor. The next stage is to change the stylesheet to specify «version="2.0"». This has the effect of switching off backward-compatibility mode. The ﬁnal stage is to modify the stylesheet to take advantage of new facilities introduced in XSLT 2.0 and XPath 2.0; notably, the ability to validate the source documents against a schema.  There is potential for transition problems to occur at each of these three stages. The focus in this appendix, however, is on the ﬁrst two stages, because once you start changing your stylesheet or your application, it’s very much under your own control whether existing code keeps working.  In this appendix we’ll treat the XSLT changes and the XPath changes together.  It’s important to remember that we can only talk here about changes in the W3 C language speciﬁcation. The W3 C speciﬁcations leave many options open to implementors, so there may be incompatible changes to products that are not described here. Some of these may be triggered by the change in language speciﬁcation — for example, an API for passing parameters to a stylesheet may change to accommodate the larger number of data types allowed, or vendors may have dropped support for extension functions that duplicate XSLT 2.0 functionality. But that’s entirely a matter for product vendors to sort out.   Backward Compatibility  Stage 1: Backward-Compatibility Mode  This section describes the incompatibilities that can occur when you are running in backward- compatibilty mode enabled  that is, with a stylesheet that speciﬁes «version="1.0"» . It is important to remember that even in this mode, you are using the XPath 2.0 data model rather than the XPath 1.0 data model and that this causes some inevitable differences.  XSLT 2.0 processors are not required to support backward-compatibility mode. If you request it  by specifying «version="1.0"» , then such a processor must report a fatal error. Alternatively  and this is what XML Spy does , your development environment may use the version attribute to decide whether to launch a 1.0 or a 2.0 processor. Deprecated Facilities  The use of disable-output-escaping is now deprecated. It was always an optional feature in XSLT 1.0, and did not work in all environments  a notable example being the Firefox browser . The fact that it is deprecated in 2.0 means that more vendors may decide to drop support.  XPath 2.0 states that ‘‘the namespace axis is deprecated and need not be supported by a host language’’. XSLT, however, states that if backward-compatibility mode is in effect, then the namespace axis must be supported.  Error Handling  XSLT 1.0 described a large number of situations as ‘‘recoverable errors’’. Essentially this phrase means that if you  as the stylesheet author  do something questionable, the processor can either report an error or recover in a deﬁned way.  In XSLT 2.0 many of these errors have become non-recoverable, so an XSLT 2.0 processor will behave like a 1.0 processor that reported the error. For example, if you try to create an attribute with an invalid name, or if you try to create an attribute for an element after creating its text content, the processor will now report an error — in 1.0, it might have simply ignored the attempt to create the attribute. These changes can trip you up if you were previously using an XSLT 1.0 processor that was forgiving about such errors.  In a few cases, XSLT 2.0 has standardized on the recovery behavior instead. So if you try to create a comment containing two adjacent hyphens, the processor will now insert a space between the hyphens.  Some other errors remain recoverable at processor discretion: notable examples are having two template rules that match the same node and calling the document   function to retrieve a document that doesn’t exist. Different processors may behave differently in these situations.  There is one particular case where the behavior in 2.0  even in backward-compatibility mode  is different from both the error behavior and the recovery behavior in 1.0. This arises if you try to supply an element node when constructing the value of a new attribute node, for example:      23      1140  In 1.0 this either would cause an error or would give you an empty attribute. In 2.0, the new attribute is created, and its value is «23»  the result of atomizing the element .   Stage 1: Backward-Compatibility Mode  XSLT 2.0 is also stricter about error conditions that can be detected statically. For example, in XSLT 1.0 if an   instruction had a priority attribute and no match attribute, the priority attribute was simply ignored. In 2.0, it is reported as an error. This also applies to inconsistent combinations of attributes on  .  XSLT 1.0 explicitly said that it wasn’t an error to use an arbitrary string  for example «!*?$»  as a namespace — that is, there’s no requirement that it should be a valid URI. The 2.0 spec wriggles on this point. Element and attribute names are QNames, and QNames are deﬁned in XML Schema as con- taining an xs:anyURI and an xs:NCName, so it’s no longer possible to say there are no rules about what the namespace can be. However, both the XML Schema spec and the XSLT 2.0 spec leave implementa- tions latitude as to how much checking should be done. As it happens, XML Schema 1.1 is moving in the direction of allowing any string to be used as an xs:anyURI value.  C  B a c k w a r d C o m p a t i b  i l i t y  Comparing Strings  In XSLT 1.0 testing for equality between two strings performed a strict comparison of the codepoints of the characters in the two strings. There was no ﬂexibility to treat "XML" and "xml" as being equal. Sorting, however, was left very much up to the implementation: two different products would probably sort the same set of strings differently. There was no «<» operator to compare strings, and no min   or max   function.  This changes signiﬁcantly in XSLT 2.0 and XPath 2.0, though the amount of backward incompatibility depends to a considerable extent on choices made by the vendor. The «=» operator, when comparing two strings, now uses the default collation. How the default collation is deﬁned is up to the implementor, but it isn’t necessarily the Unicode codepoint collation. Nor is it necessarily the same collation as is used by default to support  .  Sort keys deﬁned using    in the absence of «data-type="text"»  are now compared using their actual data type, rather than being converted to strings. This will only affect you in the unlikely event that your stylesheet deﬁnes a numeric key  for example, «@length mod 100»  and you actually wanted it to be sorted as a string rather than a number.  Numeric Formats  XPath 2.0 has  in effect  four numeric data types: double, ﬂoat, decimal, and integer, whereas XPath 1.0 made do with one type, double. Literals that were interpreted as doubles in XPath 1.0  such as «3.5» or «17»  may be interpreted as decimals or integers in XPath 2.0. However, when backward-compatibility mode is selected, all arithmetic is still done in double-precision ﬂoating point.  Very large and very small ﬂoating point numbers are now output using scientiﬁc notation  or the pro- grammer’s variant of scientiﬁc notation ; for example, 1.5E-9. If this output format isn’t acceptable, you can use the format-number   function to control the format you want.  There are some changes to the speciﬁcation of format-number  . In most cases these are tightening up a speciﬁcation that was previously rather vague in certain areas, but the result of this is that a conformant XSLT 2.0 processor may do things differently from the way that your favorite 1.0 processor interpreted the speciﬁcation. These changes are caused by the fact that XSLT 1.0 deﬁned format-number   in terms of an old version of the Java DecimalFormat class, and this dependency has now been removed.  There are also changes to the rules for converting strings to numbers. Strings containing a leading plus sign are now recognized  previously they were treated as NaN , as are the strings «INF» and «-INF» for positive and negative inﬁnity, replacing «Infinity» and «-Infinity».  1141   Backward Compatibility  Other XPath Changes  Constructs such as «A = B = C», or «A < B < C» were allowed in XPath 1.0 but are disallowed in XPath 2.0. This is because their actual meaning was wildly different from their intuitive meaning, making them a probable cause of bugs. For example, in XPath 1.0 «1 = 2 = 0» is true, because « 1 = 2 » is false, and «false   = 0» is true.  The XPath 1.0 lexical rules allowed you to write «10div 3» with no space before the «div»; in 2.0, the space is required.  Using an empty sequence as input to an arithmetic operator in 2.0  in an expression such as «@x+1», where there is no «x» attribute  gives an empty sequence; in 1.0 it gave NaN.  Serialization Changes  The rules for the serializer have become stricter, which means that the format of the output produced by your chosen processor may need to change, or it might have to report errors where it didn’t do so in the past.  One particular rule, which caused a lot of controversy, is that an HTML serializer is now required to report an error if your result tree contains a character in the range 128–159. These characters essentially mean nothing in Unicode; they are permitted in XML, but not in HTML. In practice, if your output contains such a character, the chances are it was copied from the input; and the reason it appeared in the input was probably because Windows codepage 1251 uses characters in this range. If the XML document properly declares that it is using this codepage, then no problem arises, because these characters will be converted to their Unicode equivalents, but if it allows the XML parser to misinterpret the encoding as  say  ISO-8859-1, the conversion to Unicode is done incorrectly, and results in invalid HTML. Because browsers are rather tolerant of invalid HTML, it’s quite likely this has been going on for years without anyone noticing, but an XSLT 2.0 serializer will put a stop to it.  The 2.0 rules have also become stricter in regard to the interpretation of «indent="yes"». There are more rules now about where the processor is allowed to insert whitespace. The result may be that the pretty printing is not quite as pretty as it used to be.  Stage 2: Setting version=“2.0”  The next stage in your transition to XSLT 2.0 is to switch off backward-compatibility mode by setting the version attribute in the   element to «2.0». This section looks at what changes you should be prepared for when you do this. I’ll assume here that you have ﬁxed any problems that arose during stage 1.  The First Node Rule  The most common incompatibilities relate to the dropping of the rule that you can supply a node-set where a single value is expected, and the system will use the ﬁrst node in the node-set.  In XSLT this arises when a sequence containing more than one value is supplied to:        The select attribute of   The value of an attribute value template  1142   Stage 2: Setting version=‘‘2.0’’  C  B a c k w a r d C o m p a t i b  i l i t y        The value attribute of   The value of a sort key  In all these cases XSLT 1.0 discards any selected node after the ﬁrst. In the ﬁrst three cases, XSLT 2.0 outputs all the values, with an appropriate separator. In the ﬁnal case XSLT 2.0 reports an error.  In XPath 2.0, if a sequence containing more than one value is supplied in a context where a single value is expected  notably as an operand of an arithmetic expression or as an argument to a function where a singleton is expected , then an error  XPTY0004  is reported.  If your stylesheets fall foul of this change when you switch backward compatibility off, it’s easy to ﬁx. If the current code is, for example,  , change it to <xsl:value-of select="   item [1]" >. Remember to use parentheses where necessary.  Type Checking of Function Arguments  With a few exceptions such as the string  , number  , and concat   functions, XPath 2.0 will not implic- itly convert a supplied value to the required type. This means, for example, that you can no longer do «starts-with $x, ‘-’ » to test whether the number $x is negative: you must ﬁrst convert it to a string. The conversion still occurs, however, if the value is untypedAtomic.  This also applies to operators such as the arithmetic operators. The remedy is to do an explicit conversion to the required type using a constructor function or cast, as described in Chapter 11.  Comparison Operators  In XPath 1.0, the operands of « » were automatically converted to numbers, and a numeric comparison was performed. If either value could not be converted to a number, the result would be false. In XPath 2.0, this conversion no longer happens, unless one of the values is untypedAtomic and the other is a number. So the comparison «@price > 20» still does a numeric comparison, but assuming the document is untyped, «@price > @discount» now does a string comparison.  In XPath 1.0, if either of the operands of « », «=», or any of the other comparison operators was a boolean value, the other operand would be converted to a boolean value. This is no longer the case: instead, the comparison has the same existential semantics as usual. For example, «@married = true  » in XPath 1.0 would test if the attribute married exists; in 2.0 it tests whether the result of atomizing the attribute is equal to the value true  .  Arithmetic  Arithmetic operations in XPath 2.0 may be carried out using integer, decimal, or single- or double- precision ﬂoating point. This means the result may be slightly different from XPath 1.0, which always used double-precision ﬂoating point. XPath 2.0 in backward-compatibility mode also uses double- precision ﬂoating point for all arithmetic.  The Empty Sequence  In XPath 1.0, if an empty node-set was used as an operand to a function or operator that expected a string, it was automatically converted to the zero-length string. Similarly, if the operator or function expected a number, it was automatically converted to NaN  not a number .  1143   Backward Compatibility  In XPath 2.0 the functions in the core library that expect a string argument reproduce this behavior. This is not a built-in feature of the language, it is simply part of the way these particular functions are speciﬁed, but this is sufﬁcient to prevent compatibility problems.  However, the corresponding change for numeric operators and functions has not been made. For example, if the attribute A does not exist, then the expression «@A+1» returned NaN under XPath 1.0, but returns an empty sequence under XPath 2.0. If you output this value by converting it to a string, the result will be a zero-length string instead of the string «NaN».  Although the empty sequence plays a signiﬁcant role as a null value in XPath 2.0, most practical expres- sions are unaffected by the change.  Error Semantics for «and» and «or»  In XPath 1.0 it was deﬁned, in the case of an expression such as «A and B», that B would not be evaluated if A was false. Similarly, with «A or B», B would not be evaluated if A was true.  This meant that you could safely write an expression such as:   $cols = 0  or  $n div $cols > 100   XPath 2.0 no longer gives this guarantee. The operands of «and» and «or» can now be evaluated in either order, or in parallel. In the example above, this means that the division might be evaluated, and cause an error, in the case where $cols is zero.  To be sure of avoiding this failure, you need to rewrite the expression as:  if  $cols = 0  then true   else  $n div $cols > 100   The reason this change was made is that changing the order of evaluation of expressions within a predi- cate is a common technique used by database optimizers to take maximum advantage of indexes present in a database. The existing rule in XPath 1.0 prevented many such optimizations. This of course is more likely to affect XQuery than XPath implementations, but the rule was changed in both languages to keep them consistent. A vendor who wishes to offer the maximum level of backward compatibility can of course continue to implement boolean expressions in the same way as XPath 1.0.  I think it’s unlikely that many existing stylesheets or freestanding XPath expressions will be affected by this change, if only because runtime errors in XPath 1.0 are extremely rare: most programming mistakes in XPath 1.0 produce either a syntax error, or wrong answers, but not a runtime failure.  Other XSLT Differences  XSLT 2.0 reports a compile-time error if an   instruction supplies a value for a parameter that is not declared in the called template. XSLT 1.0 simply ignored the extra parameter.  With the key   function, XSLT 1.0 converted both the stored value and the supplied value to strings before comparison. XSLT 2.0 compares them without conversion. If they are of different types, they are regarded as not matching  and untypedAtomic is treated as string . So a call on «key ‘k’, 12 » will no longer match an unvalidated element such as  12 .  1144   Summary  C  B a c k w a r d C o m p a t i b  i l i t y  Stage 3: Adding a Schema  The output that an XSLT 2.0 stylesheet produces for a given source document can change if you validate the source document before transforming it. This section lists some of the changes that might occur:                    By default, when a source document is validated, whitespace text nodes will be stripped if they appear in elements with element-only content, that is, elements deﬁned in the schema as having a complex type without mixed content.  In fact, this is also likely to happen if the source doc- ument is validated against a DTD . In XSLT 1.0, in principle, all whitespace was retained. Some processors such as MSXML, however, were notable for breaking the rules. Processing a source document using a schema will cause attribute nodes with default values to be added to the tree, and will cause element nodes with default values to acquire a value. These extra nodes will be visible to the XSLT stylesheet. Because data is now typed rather than untyped, errors may be reported. For example, if an attribute birthDate is deﬁned in the schema to have type xs:date, then the expression «substring @birthDate, 1, 4 » will fail with a type error, because the substring   function can be applied only to a string. The remedy is to convert the value to a string explicitly, using the string   function or a cast. The results of comparisons may change. The most noticeable effect will be with list-valued ele- ments and attributes, where a comparison  using «=» or any of the other general comparison operators  now tests each item in the list of values independently, rather than testing the string value of the containing node as a whole. The results of sorting may change. For example, if the sort key has type «xs:dayTime Dura- tion», then the values will be compared as durations, not as strings. Atomizing an element with element-only content is an error. This error can only arise when you have a schema, because without a schema, all elements are considered to have mixed content. An example of an expression that does this is «contains invoice, "overdue" », which checks for the presence of the string «overdue» anywhere in the text of an invoice. To make this work after applying a schema, you need to extract the string value of the invoice explicitly, by writing «contains string invoice , "overdue" ».  Summar y  XSLT 2.0 is not 100% backward compatible with version 1.0. Most stylesheets will convert with no changes at all, but a few will need tweaking. Moving a large application from XSLT 1.0 to 2.0 is an exercise that needs to be carefully planned, with detailed regression testing carried out to catch any obscure corner cases that might not show up immediately with the ﬁrst few test runs.  1145    D  M i c r o s o f t  X S L T  P r o c e s s o r s  Microsoft XSLT Processors  This appendix contains summary information about Microsoft’s XSLT processors.  At the time of writing, Microsoft does not yet have an XSLT 2.0 processor, so the information in this appendix all relates to its XSLT 1.0 products. In view of this, I am not including a comprehensive speci- ﬁcation of Microsoft’s APIs, merely an outline of their structure. The reference information can be found in Microsoft’s own documentation, or in books that concentrate on XSLT 1.0 processing.  The best information available on Microsoft’s future plans comes in a blog posting released just after XSLT 2.0 was ﬁnalized, at http:  blogs.msdn.com xmlteam archive 2007 01 29 xslt-2-0.aspx. All this really does is to conﬁrm that Microsoft has a development team in place to work on an implemen- tation, but this represents a signiﬁcant turnaround given that two years earlier Microsoft was saying it thought XQuery would meet all the requirements, and more recently that the way forward was its pro- prietary Linq to XML language. It’s likely to be 2009 at the earliest before we see a full product release, though hopefully there will be previews earlier than this.  The announcement suggests Saxon on .NET as an interim solution. A recommendation from Microsoft is not something I would have dared to hope for when I started out on the project!  Microsoft offers two families of products, with completely different APIs. The XSLT processor in the MSXML family comes as standard with Internet Explorer, though it is also available as a freestanding component and is delivered as part of the Ofﬁce suite. In the current Microsoft jargon, this runs ‘‘on the native stack’’, that is, it is compiled into machine code and calls the Windows APIs, rather than relying on the .NET platform. More recently, the System.Xml.Xsl package has become available as part of the .NET framework. This appendix gives a brief outline of both these product families.  In the early days it was frequently reported that MSXML was faster than the .NET processor, and that it conformed more closely to the W3 C speciﬁcations. As far as I can tell, neither of these criticisms is now valid. Both processors offer excellent performance, and few serious conformance issues are reported for either product  the main one being MSMXL’s cavalier attitude toward whitespace .  MSXML  MSXML is a package that includes a number of core XML technologies: XML parsing with SAX and DOM interfaces, XSLT transformation, and XML Schema validation. Microsoft has released several versions of   Microsoft XSLT Processors  the product. The original beta version 1.0 was quickly superseded by version 2.0, which was supplied with the ﬁnal release of Internet Explorer 5.  MSXML3 became a production release in October 2000 and was included as a standard part of Internet Explorer 6. You will sometimes see it referred to as MSXSL, that being more accurately the name of a command line interface which is available as a free MSDN download.  MSXML4, 5, and 6 followed, with fairly minor enhancements as far as the XSLT part of the product was concerned. However, MSXML3 is still in use, partly because of the installed base of IE6 users, and partly because it was the last version that retained support for Microsoft’s obsolete WD-xsl dialect. WD-xsl was ﬁrst shipped in 1998 before XSLT 1.0 was ﬁnalized, and you still occasionally come across stylesheets written in this variant of the language: you can recognize them because they use the namespace URI http:  www.w3.org TR WD-xsl.  You can ﬁnd download links for MSXML by going to http:  msdn.microsoft.com xml. The current version of the Software Development Kit  SDK  includes support for MSXML versions 3, 4, 5, and 6, recognizing that many developers need to test with multiple versions of the runtime.  The objects, methods, properties, and events available with the MSXML3 parser are listed in the Help ﬁle that comes with the SDK. I have only included here the parts of the interface that are relevant to XSLT and XPath processing.  The objects of particular interest to XSLT and XPath processing are listed below: Object  Description The root of an XML document  Any node in the DOM  A collection of Node objects  Details of the last parse error that occurred  A selection of nodes  An execution of an XSLT stylesheet  A compiled XSLT stylesheet in memory  Objects  IXMLDOMDocument  IXMLDOMNode  IXMLDOMNodeList  IXMLDOMParseError  IXMLDOMSelection  IXSLProcessor  IXSLTemplate  These objects are described in the sections that follow.  IXMLDOMDocument and IXMLDOMDocument2  The IXMLDOMDocument class inherits all the properties and methods of IXMLDOMNode. IXMLDOMDocument2 is a later version of the interface, introducing a few extra properties and methods. This section lists the additional methods and properties of relevance to XSLT and XPath processing, in other words, all the methods and properties that are not also present on IXMLDOMNode, which is described on page 1150.  Additional Methods  1148  The methods particularly relevant to XPath and XSLT processing are described in detail below.  The validate  and setProperty  methods actually belong to the IXMLDOMDocument2 interface, which is an extension to IXMLDOMDocument introduced with MSXML version 2.6.   MSXML  Name  abort  Returns  Nothing   load  Boolean  loadXML  Boolean  save   Nothing   Description When a document is being loaded asynchronously, abort  can be called at any time to abandon the process.  Loads document from the speciﬁed XML source. The argument is nor- mally a string containing a URL. Clears out any existing content of the Document object, and replaces it with the result of parsing the XML source. Returns True if successful, False otherwise. Loads the document from a string containing the text of an XML doc- ument. Clears out any existing content of the Document object, and replaces it with the result of parsing the XML string. Returns True if successful, False otherwise. Saves the document to a speciﬁed destination. The destination is usually a ﬁlename, given as a string. The effect is to serialize the Document in XML format as a ﬁle. It is also possible to specify various other objects as a destination, for example, it can be another Document object, in which case the document is duplicated.  D  M i c r o s o f t  X S L T  P r o c e s s o r s  setProperty  Nothing   Sets various system properties. The most important properties are:        SelectionLanguage. This takes the value «XPath»  the MSXML4 default  or «XSLPattern»  the default for MSXML3 . This affects the syntax used in the expression passed to the selectNodes   andselectSingleNode   meth- ods. If you want to use XPath 1.0 syntax you must set this property to «XPath». The value «XSLPattern» refers to the old Microsoft-speciﬁc WD-xsl dialect. SelectionNamespaces. The value of this property should be a space-separated list of namespace declarations, for example: «xmlns:a="http:  a.com " xmlns:b="http:  b.com "» These deﬁne the namespace preﬁxes that can be used within any expression passed to the selectNodes   and selectSingleNode   methods.  validate   Nothing   Validates the document, using the current DTD or schema.  Additional Properties  Name  async  parseError  readyState  Type  Boolean  Long  validateOnParse  Boolean  IXMLDOMParseError  The last parser error.  Description True if the document is to be loaded asynchronously.  Current state of readiness for use. Used when loading asynchronously. The values are Uninitialized  0 , Loading  1 , Loaded  2 , Interactive  3 , and Completed  4 .  Requests validation of the document against its DTD or schema.  1149   Microsoft XSLT Processors  IXMLDOMNode  This object represents a node in the document tree. Note that the tree conforms to the DOM model, which is not always the same as the XPath model described in Chapter 2; for example, the way namespaces are modeled is different, and text nodes are not necessarily normalized.  There are subclasses of IXMLDOMNode for all the different kinds of node found in the tree. I have not included descriptions of all these, since they are not directly relevant to XSLT and XPath processing. The only subclass I have included is IXMLDOMDocument, which can be regarded as representing either the whole document or its root node, depending on your point of view.  Methods  The methods available on IXMLDOMNode that are relevant to XSLT and XPath processing are listed below. Most often, these methods will be applied to the root node  the DOM Document object , but they can be applied to any node. Name  Returns  selectNodes  IXMLDOMNodeList  selectSingleNode  IXMLDOMNode  transformNode  String  transformNodeToObject  Nothing   Description Executes an XPath expression and returns a list of matching nodes.  Executes an XPath expression and returns the ﬁrst matching node.  Applies a stylesheet to the subtree rooted at this node, returning the result as a string. The argument identiﬁes the XSLT stylesheet. This will usually be a Document, but it may be a Node representing an embedded stylesheet within a Document. The serialized result of the transformation is returned as a string of characters  the   encoding is ignored .  Applies a stylesheet to the subtree, placing the result into a supplied document or stream. The difference between this and transformNode   is that the destination of the transformation is supplied as a second argument. This will usually be a Document. It may also be a Stream.  Properties  1150  The most useful properties are listed below. Properties whose main purpose is to navigate through the document are not listed here, because navigation can be achieved more easily using XPath expressions. Name  Type  Description The local name of the node, excluding any namespace preﬁx.  baseName  String  namespaceURI  String  The namespace URI.  nodeName  String  The name of the node, including its namespace preﬁx if any. Note that unlike the XPath model, unnamed nodes are given conventional names such as "document", "text", and "comment".  continued   Name  Type  nodeTypeString  String  nodeValue  Variant  prefix  text  xml  String  String  String  IXMLDOMNodeList  MSXML  Description Returns the type of node in string form. For example, "element", "attribute", or "comment". The value stored in the node. This is not the same as the XPath string value; for elements, it is always null. The preﬁx for the namespace applying to the node. Text contained by this node  like the XPath string value . XML representation of the node and its descendants.  D  M i c r o s o f t  X S L T  P r o c e s s o r s  This object represents a list of nodes. For our present purposes, we are interested in this object because it is the result of the selectNodes  method.  An IXMLDOMNodeList is returned as a result of the selectNodes  method: it contains the list of nodes selected by the supplied XPath expression. You can process all the nodes in the list either by using the nextNode  method or by direct indexing using the item property.  Returns IXMLDOMNode  IXMLDOMNode   Nothing   Description item N  gets the node at position N. Gets the next node. Resets the current position.  Type Long  Description Identiﬁes the number of nodes in the collection.  IXMLDOMParseError  This object is accessible through the parseError property of the IXMLDOMDocument interface.  Type  Long  Long  Long  Long  String  Description The error code.  The character position of the error within the XML document.  The line number of the error.  The character position in the line containing the error.  Explanation of the error.  continued 1151  Methods  Name item  nextNode  reset  Properties  Name length  Properties  Name  errorCode  filepos  line  linepos  reason   Microsoft XSLT Processors  Name  Type  srcText  String  url  String  Description The XML text in error.  The URL of the offending document.  IXMLDOMSelection  This object represents a selection of nodes. It is returned as the result of the selectNodes   method when the target document implements the IXMLDOMDocument2 interface.  It’s simplest to think of this object as a stored expression that returns a list of nodes on demand. It’s rather like a relational view: You don’t need to know whether the results are actually stored, or whether they are obtained as required.  This interface extends the IXMLDOMNodeList interface.  Methods  Name  clone  Returns  IXMLDOMSelection  Description Produces a copy of this IXMLDOMSelection.  getProperty String  Returns the value of a named property such as SelectionLanguage.  item  IXMLDOMNode  item N  gets the node at position N.  matches  IXMLDOMNode  Tests whether the given node is a member of the set of nodes  returns null if no match; otherwise, the node from which the selection succeeds .  nextNode  IXMLDOMNode  Gets the next node.  reset   Nothing   Resets the current position.  Properties  Name  context  Description  Type IXMLDOMNode Establishes the context node for evaluating the expression. Changing the context node implicitly resets the current list of nodes, replacing it with a new list.  expr  String  The XPath expression that determines the nodes selected. This can be changed at any time; doing so implicitly resets the current list of nodes, replacing it with a new list.  length  Long  Identiﬁes the number of nodes in the collection.  An IXSLProcessor object represents a single execution of a stylesheet to transform a source document.  The object is normally created by calling the createProcessor   method of an IXSLTemplate object.  IXSLProcessor  1152   The transformation is achieved by calling the transform   method.  MSXML  Methods  Name  addParameter  Returns  Nothing   reset  setStartMode   Nothing    Nothing   transform  Boolean  Properties  Name  input  Type  Variant  output  Variant  Description Sets the value of a stylesheet parameter. The ﬁrst argument is the local name of the parameter, the second is the parameter value, and the third is the namespace URI  usually ”” . The value can be a boolean, a number, or a string, or a Node or NodeList.  Resets the state of the processor and aborts the current transform.  Sets the initial mode. There are two arguments, representing the local name and the namespace URI parts of the mode name.  Applies the stylesheet  from which this XSLProcessor was derived  to the source document identiﬁed in the input property. The result tree is accessible through the output property. If the source document is being loaded asynchronously, a return value of False means that the transformation needs to wait until more input is available. It can be resumed by calling transform   again later. The current state of the transformation can be determined from the readyState property.  D  M i c r o s o f t  X S L T  P r o c e s s o r s  Description XML source document to transform. This is normally supplied as a DOM Document, but it may also be a Node. The input can also be supplied as an IStream.  Output of the transformation. If you don’t supply an output object, the processor will create a String to hold the output, which you can read using this property. If you prefer, you can supply an object such as a DOM Document, a DOM Node, or an IStream to receive the output.  ownerTemplate  IXSLTemplate The XSLTemplate object used to create this processor object.  readyState  Long  The current state of the transformation. This will be READYSTATE_COMPLETE  3  when the transformation is ﬁnished.  startMode  String  Name of the initial mode. See setStartMode   method above.  startModeURI  String  Namespace of the initial mode. See setStartMode   method above.  stylesheet  IXMLDOMNode  The current stylesheet being used.  IXSLTemplate  An IXSLTemplate object represents a compiled stylesheet in memory. If you want to use the same stylesheet more than once, then creating an IXSLTemplate and using it repeatedly is more efﬁcient than using the raw stylesheet repeatedly using transformNode  .  1153   Microsoft XSLT Processors  Methods  Name createProcessor IXSLProcessor Creates an IXSLProcessor object.  Description  Returns  This method should only be called after the stylesheet property has been set to associate the IXSLTemplate object with a stylesheet. It creates an IXSLProcessor object, which can then be used to initiate a transformation of a given source document.  Properties  Name  Type  stylesheet  IXMLDOMNode  Description Identiﬁes the stylesheet from which this IXSLTemplate is derived.  Setting this property causes the speciﬁed stylesheet to be compiled; this IXSLTemplate object is the reusable representation of the compiled stylesheet.  The DOM Node representing the stylesheet will normally be a DOM Document object, but it may be an Element representing an embedded stylesheet.  The document identiﬁed by the stylesheet property must be a free-threaded document object.  Putting it Together  The example in this section shows one way of controlling a transformation using MSXML from within JavaScript on an HTML page.  Example: Using Client-Side JScript to Transform a Document  This example demonstrates the way that you can load, parse, and transform an XML docu- ment using client-side JScript in Internet Explorer. You can run this simply by loading the page default.html using the IE browser  version 5 or higher . When you ﬁrst load it, you may see a security warning, depending on your browser security settings. If this happens, right-click on the message and select ‘‘Allow blocked content’’. The example shows an HTML page with two buttons on it. The user can click on either of the buttons to select how the data should be displayed. The effect of clicking either button is to apply the corresponding stylesheet to the source XML document.  XML Source       1154  The XML source ﬁle for this example is tables_data.xml. It deﬁnes several tables  real tables, the kind you sit at to have your dinner , each looking like this:   Conference   4   Ash     Oblong   1485     . . .    Stylesheet  HTML page  There are two stylesheet ﬁles, tables_list.xsl and tables_catalog.xsl. Since this example is designed to show the JScript used to control the transformation rather than the XSLT transformation code itself, I won’t list them here.  The page default.htm contains some simple styling information for the HTML page, then the JScript code that loads the XML and XSL documents, checks for errors, and performs the transformation. Notice that the transformFiles function takes the name of a stylesheet as a parameter, which allows you to specify the stylesheet you want to use at runtime:  MSXML  D  M i c r o s o f t  X S L T  P r o c e s s o r s         body {font-family:Tahoma,Verdana,Arial,sans-serif;  font-size:14px}  head {font-family:Tahoma,Verdana,Arial,sans-serif;  font-size:18px; font-weight:bold}       function transformFiles strStylesheetName  {     get a reference to the results DIV element var objResults = document.all[’divResults’];     create two new document instances var objXML = new ActiveXObject ’MSXML2.DOMDocument.3.0’ ; var objXSL = new ActiveXObject ’MSXML2.DOMDocument.3.0’ ;     set the parser properties objXML.validateOnParse = true; objXSL.validateOnParse = true;     load the XML document and check for errors objXML.load ’tables_data.xml’ ; if  objXML.parseError.errorCode != 0  {     error found so show error message and stop objResults.innerHTML = showError objXML  return false;  }     load the XSL stylesheet and check for errors  objXSL.load strStylesheetName ;  1155   Microsoft XSLT Processors  if  objXSL.parseError.errorCode != 0  {     error found so show error message and stop  objResults.innerHTML = showError objXSL  return false;     all must be OK, so perform transformation strResult = objXML.transformNode objXSL ;     and display the results in the DIV element objResults.innerHTML = strResult; return true;  }  }  Provided that there are no errors, the function performs the transformation using the XML ﬁle tables_data.xml and the stylesheet whose name is speciﬁed as the strStylesheet Name parameter when the function is called. The result of the transformation is inserted into the   element that has the id attribute value «divResults». You’ll later see where this is deﬁned in the HTML. If either of the load calls fails, perhaps due to a badly formed document, a function named showError is called. This function takes a reference to the document where the error was found, and returns a string describing the nature of the error. This error message is then displayed on the page instead of the result of the transformation:  function showError objDocument      create the error message var strError = new String; strError = ’Invalid XML file ! ’  + ’File URL: ’ + objDocument.parseError.url + ’ ’ + ’Line No.: ’ + objDocument.parseError.line + ’ ’ + ’Character: ’ + objDocument.parseError.linepos + ’ ’ + ’File Position: ’ + objDocument.parseError.filepos + ’ ’ + ’Source Text: ’ + objDocument.parseError.srcText + ’ ’ + ’Error Code: ’ + objDocument.parseError.errorCode + ’ ’ + ’Description: ’ + objDocument.parseError.reason  return strError;  }    -->    The remainder of the ﬁle is the HTML that creates the visible part of the page. The opening   element speciﬁes an onload attribute that causes the transformFiles   function in our script section to run once the page has ﬁnished loading:  . . .       Transforming an XML Document using  the client-side code    . . .  1156   MSXML  Because it uses the value «tables_list.xsl» for the parameter to the function, this stylesheet is used for the initial display. This shows the data in tabular form. The next thing in the page is the code that creates the two HTML   elements, marked Catalog and Simple List. The onclick attributes of each one simply execute the transform- Files  function again, each time specifying the appropriate stylesheet name:  . . . View the tables as a &nbsp; <button onclick="transformFiles   ’tables_catalog.xsl’ ">Catalog   &nbsp; or as a &nbsp;  Simple List     Finally, at the end of the code, you can see the deﬁnition of the   element into which the function inserts the results of the transformation.  D  M i c r o s o f t  X S L T  P r o c e s s o r s             Output  When the page is ﬁrst displayed, it looks like Figure D-1.  Figure D-1  Click the Catalog button, and you will see an alternative graphical presentation of the same data, achieved by applying the other stylesheet.  1157   Microsoft XSLT Processors  Restrictions  Microsoft claims full compliance with XSLT 1.0 and XPath 1.0, although there are one or two gray areas where its interpretation of the speciﬁcation may cause stylesheets to be less than 100% portable. These include:           Handling of whitespace nodes. The normal way of supplying input to Microsoft’s XSLT pro- cessor is in the form of a DOM, and the default option in MSXML3 for building a DOM is to remove whitespace text nodes as the text is parsed. The result is that   in the stylesheet has no effect, because by the time the XSLT processor gets to see the data, there are no whitespace text nodes left to preserve. If you want conformant behavior in this area, set the preserveWhitespace property of the DOMDocument object to True, before loading the document. The same applies to the stylesheet; if you want to use   to control output of whites- pace, particularly when generating output in a space-sensitive format such as comma-separated values, then load the stylesheet with preserveWhitespace set to True. It’s not possible to pre- serve whitespace, unfortunately, when stylesheets are loaded into the browser using the   processing instruction. Normalization of text nodes. XSLT and XPath specify that adjacent text nodes in the tree are always merged into a single node. MSXML uses a DOM as its internal data structure, and the DOM does not impose the same rule. Although MSXML does a good job at creating a correct XPath view of the underlying DOM tree, this is one area where the mapping is incomplete. The two common cases where adjacent text nodes are not merged are ﬁrstly, when one of the text nodes represents the contents of a CDATA section in the source XML, and secondly, when one of them represents the expanded text of an entity reference  other than the built-in entity ref- erences such as «&lt;» . This makes it dangerous to use a construct such as <xsl:value-of select="text  " > because MSXML will return only the ﬁrst of the text nodes, that is, the text up to the start of an entity or CDATA boundary. It’s safer to output the value of an element by writing  . The   instruction has no effect when running a transformation in the browser, unless you specify «terminate="yes"».  System.Xml  XPathDocument  System.Xml is the XML infrastructure within Microsoft’s .NET framework. It provides support for XML 1.0, XML Namespaces 1.0, XSLT 1.0, XPath 1.0, DOM level 1 and level 2, and XML Schema. The API is completely different from the older MSXML products described in the earlier part of this appendix.  Within this framework, the .NET namespace System.Xml.Xsl provides the API for XSLT processing, while System.Xml.Xpath provides the XPath API.  This class represents a document optimized for XPath and XSLT processing. An instance of this class can be created by directly loading XML from a ﬁle:  XPathDocument doc = new XPathDocument "source.xml" ;  Other constructors are available, allowing the document to be constructed from a Stream, a TextReader, or an XmlReader. Some of the constructors have a second parameter allowing you to specify whether whitespace text nodes should be stripped or preserved.  1158   System.Xml  An XPathDocument implements the interface IXPathNavigable, described below.  XmlNode  This class represents a node in the .NET implementation of the DOM. Because it supports the DOM data model as well as the XPath data model, it is likely to be less efﬁcient for XPath and XSLT processing than the XPathDocument object.  There are subclasses of XmlNode for the different node kinds; for example, XmlElement, XmlAttribute, and so on.  This class, like XPathDocument, implements the IXPathNavigable interface. This means that any software written to use the IXPathNavigable interface can use either an XPathDocument or an XmlNode document as the data source.  One of the subclasses of XmlNode is System.Xml.XmlDataDocument, which supports an XML view of data in a relational database. This allows the XSLT processor to run directly against relational data.  D  M i c r o s o f t  X S L T  P r o c e s s o r s  IXPathNavigable  This is a very small but very signiﬁcant interface, with a single method, CreateNavigator. This method returns an XPathNavigator object that can be used to process the underlying data, treating it as an implementation of the XPath data model.  For example:  XPathDocument doc = new XPathDocument "source.xml" ; XPathNavigator nav = doc.CreateNavigator  ;  XPathNavigator  The XPathNavigator object holds a current position within a tree, and provides methods to extract properties of the node at that position and to move the current position to another related node. If the data source is implemented as an XPathDocument, there is actually no object representing the node itself, which makes the model very efﬁcient because small objects have a high overhead.  Because an XPathNavigator is capable of returning all the information in the XPath data model, it acts as an abstraction of a source document, and any object that implements the XPathNavigator interface can be used as a source document for an XSLT transformation.  XslTransform  The class System.Xml.Xsl.XslTransform is used to perform an XSLT transformation. The basic sequence of operations is:           Create an XslTransform object. Use the Load method to load  and compile  the stylesheet. Use the Transform method to perform the transformation.  1159   Microsoft XSLT Processors  There are different variants of the Load method that allow the stylesheet to be loaded by supplying a URL, by nominating an XmlReader to read the stylesheet and perform XML parsing, or by supplying an XPathNavigator or IXPathNavigable that locates the stylesheet within an existing document in memory.  If you want to go through all the stages of loading a stylesheet, you can write:  XPathDocument ss = new XPathDocument "stylesheet.xsl" ; XPathNavigator nav = doc.createNavigator  ; XslTransform trans = new XslTransform  ; trans.Load nav ;  The options to supply a URL or an XmlReader as input to the Load method can be seen as shortcuts to this process.  The Transform method has a very large number of different overloaded variants. Essentially it takes four arguments: the source document to be transformed, the values supplied for stylesheet parameters, the destination for the result document, and an XmlResolver that is used to resolve URI references supplied to the document  function. The number of variations of this method is due to the fact that both the source and the destination can be supplied in a number of different ways, and these are supported in all combinations.              The source document can be supplied by giving a URL, or in the form of an IXPathNavigable or XPathNavigator object. Stylesheet parameters are supplied in an XsltArgumentList object. This allows parameter val- ues to be added using an AddParam  method. Parameters of type boolean, number, and string can be supplied using the Boolean, Double, and String classes; a parameter of type node-set can be supplied in the form of an XPathNavigator. The output destination can be given as an XmlWriter, a TextWriter, or a Stream. Alternatively, instead of supplying the output destination as an argument, the Transform   method can return an XmlReader, which means that the calling application can use the transformation results in the same way as it would use the output of an XML parser. An XmlResolver can be supplied. Like the URIResolver in the JAXP interface, this object is used to fetch a document when supplied with a URI. This allows you to implement your own URI schemes or to use your own catalogs to ﬁnd a local copy of required documents such as stylesheet modules, schemas, or DTDs.  For example:     Load a stylesheet  XslTransform trans = new XslTransform  ; trans.Load "stylesheet.xsl" ;     Load a source document XPathDocument source = new XPathDocument "source.xml" ;     Set the current date and time as a stylesheet parameter XsltArgumentList args = new XsltArgumentList  ; DateTime now = DateTime.Now; args.AddParam "date", "", now.ToString   ;  1160      Create an XmlTextWriter for the output XmlTextWriter writer = new XmlTextWriter Console.Out ;     Perform the transformation  no XmlResolver is supplied  xslt.Transform source, args, writer, null ; writer.Close  ;  Summar y  This appendix summarized the application programming interfaces available for using Microsoft’s two XSLT product families: the MSXML product line, and the System.Xml framework classes for .NET. For full information about these APIs, you will need to go to Microsoft’s documentation, but the summary given here has hopefully given you a good introduction.  As you’ve seen, Microsoft has promised an XSLT 2.0 processor but it’s unlikely to be completed until 2009 at the earliest.  Summary  D  M i c r o s o f t  X S L T  P r o c e s s o r s  1161    E  J A X P :  T h e  J a v a  A P  I  f o r  T r a n s f o r m a t i o n  JAXP: The Java API for Transformation  JAXP is a Java API for controlling various aspects of XML processing, including parsing, validation, and XSLT transformation. This appendix concentrates on the transformation API. During its development this was known as TrAX  Transformation API for XML  — you will still see this term used occasionally.  JAXP is well supported by all the Java XML processors. The beneﬁt of JAXP is that it allows you to write Java applications that invoke XSLT transformations without committing your application to a particular XSLT processor. At one time, there were ﬁve different Java processors you could choose from  xt, Saxon, Xalan, Oracle, or jd.xslt  but for most people now the choice has whittled down to Xalan and Saxon  though both these products have a choice of processors within the same product family . JAXP works so well that I have come across users who were running Saxon when they thought they were using Xalan, or vice versa. It’s a good idea to include the following instruction in your initial template so that you avoid this mistake:        Created using    The version numbers for JAXP are irritatingly out of sync with those of the JDK. The following table shows the correspondence:  JAXP version  1.2  1.3  1.4  JDK version JDK 1.4  JDK 1.5  Java 5   JDK 1.6  Java 6   New Functionality XML Parsing  SAX and DOM  and Transformation  Schema processing; XPath processing; DOM level 3  Pull parsing  StAX   Generally, a new version of JAXP has also been made available as a freestanding component for use with the earlier version of the JDK, so for example you can install JAXP 1.3 on a JDK 1.4 system. But the installation process tends to be messy and error-prone, so it’s best avoided unless you have no choice.  JAXP as yet does not explicitly support XSLT 2.0 or XPath 2.0 processing; you have to make do with APIs that were designed for version 1.0 of these speciﬁcations. This means there are many aspects of XSLT   JAXP: The Java API for Transformation  processing that you cannot control directly; for example, you cannot run a transformation that starts at a named template and uses no source document, and there is no standard way to specify the new serialization options that are deﬁned in XSLT 2.0. As Appendix F explains, Saxon has deﬁned its own API extensions to get around these limitations.  The JAXP Parser API  JAXP 1.2 deﬁned two sets of interfaces: interfaces for XML parsing, in package javax.xml.parsers, and interfaces for XML transformation  that is, TrAX  in package javax.xml.transform and its subsidiary packages.  JAXP 1.3 adds interfaces for schema validation, for XPath processing, and more.  Although the parser APIs could be regarded as being out of scope for this book, applications will often use both together, so I shall start by quickly reviewing the two parser APIs, covering SAX parsing and DOM parsing. The StAX speciﬁcation for pull parsing included in JAXP 1.4 provides a third option, but this is currently of rather specialized interest, so I will say no more about it. You can ﬁnd an overview at http:  java.sun.com webservices docs 1.6 tutorial doc SJSXP2.html.  The JAXP interfaces do not supersede the SAX and DOM interfaces, which are described in many XML reference books. Rather, they supplement them with facilities that are  or were at one time  lacking in both SAX and DOM, namely the ability to select a SAX or DOM parser to do the processing, and to set options such as specifying whether you want a validating or non-validating parser, and whether you want namespace processing to be performed.  I’ll look at the two parts of the interface, SAX and DOM, separately.  JAXP Support for SAX  JAXP 1.2 supports SAX2, but remains backward compatible with earlier versions that supported SAX1. In the interests of brevity, I will leave out the features that are relevant only to SAX1.  javax.xml.parsers.SAXParserFactory  The ﬁrst thing an application must do is to obtain a SAXParserFactory, which it can do by calling the static method SAXParserFactory.newInstance  . Different vendors of SAX parsers will each implement their own subclass of SAXParserFactory, and this call determines which vendor’s parser your application will end up using. If there are several available, the one that is used is based on the following decision process:  1.  2.  3.  Use the value of the system property javax.xml.parsers.SAXParserFactory if it is available. You can typically set system properties using the -D option on the Java command line, or by calling System.setProperty   from your application. Look for a properties ﬁle $JAVA_HOME lib jaxp.properties, and within this ﬁle, for the property named javax.xml.parsers.SAXParserFactory. Use the services API, which is part of the JAR speciﬁcation. This effectively means that the parser that is used will be the ﬁrst one to be found on your classpath.  The theory is that when you install a particular SAX parser, it will contain a ﬁle within its .jar archive that causes that particular parser to be the default, so if you don’t do anything to select a speciﬁc parser, the one chosen will depend on the order of ﬁles and directories on your class path. In practice there can be a number of complications, which we’ll discuss later when talking about the analogous Transformer- Factory interface.  1164   The JAXP Parser API  E  J A X P :  T h e  J a v a  A P  I  f o r  T r a n s f o r m a t i o n  The default parser in Sun’s JDK 1.4 was the Crimson parser, but this changed in Java 5 to Xerces 2. There was a time when Java users split their loyalties between half a dozen decent parsers, but these days Xerces 2 has cornered the market, and there is very little reason to choose anything different.  Once you have obtained a SAXParserFactory, you can use a number of methods to conﬁgure it. Finally, you can call the newSAXParser   method to return a SAXParser. The methods available are as follows. I haven’t listed the exceptions that are thrown: you can get these from the JavaDoc.  Method  boolean getFeature String   boolean isNamespaceAware    boolean isValidating    static SAXParserFactory newInstance    SAXParser newSAXParser    Description Determines whether the parser factory is conﬁgured to support a particular feature. The names of features correspond to those deﬁned in SAX2 for the XMLReader class.  Determines whether parsers produced using this factory will be namespace-aware.  Determines whether parsers produced using this factory will perform XML validation.  Produces a SAXParserFactory for a speciﬁc vendor’s parser, decided according to the rules given above.  Returns a SAXParser that can be used to perform parsing. This is a wrapper around the SAX2 XMLReader object.  void setFeature String, boolean   Sets a particular feature on or off. The names of features correspond to those deﬁned in SAX2 for the XMLReader class.  void setNamespaceAware boolean   Indicates whether parsers produced using this factory are required to be namespace aware.  void setValidating boolean   Indicates whether parsers produced using this factory are required to perform XML validation.  The SAXParserFactory class was introduced in JAXP 1.0 because the SAX 1 speciﬁcation itself provided no means of requesting a parser. This was ﬁxed in SAX 2 with the introduction of the XMLReaderFactory class. So now you have a choice of two factories. Arguably the XMLReaderFactory does the job better. I wouldn’t put it quite as strongly as Elliotte Rusty Harold:  SAXParserFactory [is] a hideous, evil monstrosity of a class that should be hung, shot, beheaded, drawn and quartered, burned at the stake, buried in unconsecrated ground, dug up, cremated, and the ashes tossed in the Tiber while the complete cast of Wicked sings ‘‘Ding dong, the witch is dead.’’  But one thing that SAXParserFactory got badly wrong is that by default, the parser that is selected is not namespace-aware. Even if your particular document is not using namespaces, you should always set this property because almost all applications written to use SAX expect to receive events in the form that a namespace-aware parser supplies them.  javax.xml.parsers.SAXParser  A SAXParser is obtained using the newSAXParser   method of a SAXParserFactory. A SAXParser is a wrapper around a SAX2 XMLReader. You can use the getXMLReader   method to get the underlying XMLReader, but in simple cases you won’t need to, since you can perform a parse and nominate a handler for all the parsing events using this class alone.  1165   JAXP: The Java API for Transformation  The methods relevant to SAX2 parsers are:  Method  Object getProperty String   Description Gets the named property of the underlying SAX2 XMLReader.  XMLReader getXMLReader    Gets the underlying SAX2 XMLReader.  boolean isNamespaceAware    boolean isValidating    void parse File, DefaultHandler   void parse InputSource, DefaultHandler   void parse InputStream, DefaultHandler   void parse InputStream, DefaultHandler, String   void parse String, DefaultHandler   Determines whether the underlying SAX2 XMLReader is namespace-aware.  Determines whether the underlying SAX2 XMLReader performs XML validation.  Parses the contents of the speciﬁed ﬁle, passing all parsing events to the speciﬁed event handler. Normally, of course, this will not actually be a SAX2 DefaultHandler, but a user-deﬁned subclass of DefaultHandler written to process selected events.  Parses the contents of the speciﬁed SAX InputSource, passing all parsing events to the speciﬁed event handler.  Parses the contents of the speciﬁed InputStream, passing all parsing events to the speciﬁed event handler. The third argument contains a System ID that will be used for resolving relative URIs contained in the XML source.  Parses the contents of the speciﬁed InputStream, passing all parsing events to the speciﬁed event handler. Note that in this case the System ID of the input is unknown, so the parser has no way of resolving relative URIs.  Parses the XML document identiﬁed by the URI in the ﬁrst argument, passing all parsing events to the speciﬁed event handler.  void setProperty String, Object   Sets a property of the underlying SAX2 XMLReader.  JAXP Support for DOM  JAXP 1.2 was aligned with DOM level 2, while JAXP 1.3 introduced support for DOM level 3  for once, the numbers make sense . The main innovation in DOM level 2 was support for XML namespaces; DOM level 3 added many non-core features designed primarily for the browser world, but the main features of interest for XSLT users were the introduction of data typing for nodes, and tests on node identity.  Unfortunately Sun made an exception to their usual backward-compatibility policies when DOM level 3 was introduced, allowing a new version of the interface that invalidated existing implementations. This can cause no end of trouble in upgrading, especially in the case of a product like Saxon that tries to implement DOM interfaces while running on different JDK versions simultaneously.  The DOM interface itself deﬁnes methods for constructing a tree programmatically, and methods for navigating around a tree, but it does not deﬁne any way of constructing a DOM tree by parsing a source XML document. JAXP is designed to plug this gap.  1166   The JAXP Parser API  The architecture of the interface is very similar to the SAX case:  First, call the static method DocumentBuilderFactory.newInstance   to get a Document- BuilderFactory representing one particular vendor’s DOM implementation. Then use the newDocumentBuilder   method on this DocumentBuilderFactory to obtain a DocumentBuilder. Finally, call one of the various parse   methods on the DocumentBuilder to obtain a DOM Document object.  javax.xml.parsers.DocumentBuilderFactory  The ﬁrst thing an application must do is obtain a DocumentBuilderFactory, which it can do by calling the static method DocumentBuilderFactory.newInstance  . Different vendors of DOM implementations will each implement their own subclass of DocumentBuilderFactory, and this call determines which implementation your application will end up using. If there are several available, the one that is used is based on the following decision process:  Use the value of the system property javax.xml.parsers.DocumentBuilderFactory if it is available. You can typically set system properties using the --D option on the Java command line, or by calling System.setProperty   from your application. Look for a properties ﬁle $JAVA_HOME lib jaxp.properties, and within this ﬁle, for the property named:  javax.xml.parsers.DocumentBuilderFactory  Use the services API, which is part of the JAR speciﬁcation. In practice, this means that the DOM implementation used will be the ﬁrst one found on the classpath.  1.  2.  3.  1.  2.  3.  E  J A X P :  T h e  J a v a  A P  I  f o r  T r a n s f o r m a t i o n  It is likely that when you install a particular DOM implementation, it will contain a ﬁle in its .jar archive that makes that particular implementation the default, so if you don’t do anything to select a speciﬁc implementation, the one chosen will depend on the order of ﬁles and directories on your class path.  As with SAX, the default parser changed from Crimson to Xerces 2 with the introduction of Java 5.  Once you have a DocumentBuilderFactory, you can use a number of methods to conﬁgure it. Finally, you can call the newDocumentBuilder   method to return a DocumentBuilder. The methods available are: Method  Object getAttribute String   boolean isCoalescing    boolean isExpandEntityReferences    Description Gets information about the properties of the underlying implementation  Determines whether the resulting DocumentBuilder will merge CDATA nodes into their adjacent text nodes  Determines whether the resulting DocumentBuilder will expand entity references and merge their content into the adjacent text nodes  continued  1167   JAXP: The Java API for Transformation  Method  boolean isIgnoringComments    boolean isIgnoringElement ContentWhitespace    boolean isNamespaceAware    boolean isValidating    Description Determines whether the resulting DocumentBuilder will ignore comments in the source XML  Determines whether the resulting DocumentBuilder will ignore whitespace in element content  Determines whether the resulting DocumentBuilder is namespace aware  Determines whether the resulting DocumentBuilder will validate the XML source  DocumentBuilder newDocumentBuilder    Returns a new DocumentBuilder conﬁgured as speciﬁed by previous calls  static DocumentBuilderFactory newInstance    Returns a vendor-speciﬁc DocumentBuilderFactory selected according to the rules given above  setAttribute String, Object   void setCoalescing boolean   void setExpandEntityReferences  boolean   void setIgnoringComments  boolean   Sets vendor-speciﬁc properties on the underlying implementation  Determines whether the resulting DocumentBuilder will merge CDATA nodes into their adjacent text nodes  Determines whether the resulting DocumentBuilder will expand entity references and merge their content into the adjacent text nodes  Determines whether the resulting DocumentBuilder will ignore comments in the source XML  void setIgnoringElementContent Whitespace boolean   Determines whether the resulting DocumentBuilder will ignore whitespace in element content  void setNamespaceAware boolean   void setValidating boolean   Determines whether the resulting DocumentBuilder is namespace aware  Determines whether the resulting DocumentBuilder will validate the XML source  javax.xml.parsers.DocumentBuilder  A DocumentBuilder is always obtained by calling the newDocumentBuilder   method of a Document- BuilderFactory.  A DocumentBuilder performs the task of parsing a source XML document and returning the result- ing instance of org.w3.dom.Document, containing the root of a tree representation of the document in memory.  The source document is speciﬁed in similar ways to the input for a SAX parser. This doesn’t mean that a DocumentBuilder has to use a SAX parser to do the actual parsing: some will work this way and others won’t. It’s deﬁned this way to avoid unnecessary differences between the SAX and DOM approaches.  You might be aware that in the Microsoft DOM implementation, the Document class has a method load   that parses a source XML ﬁle and constructs a Document object. This is a Microsoft extension; there is no corresponding method in the W3 C DOM deﬁnition. This DocumentBuilder class ﬁlls the gap.  1168   boolean isValidating    Indicates whether the parser validates the XML source.  The methods available are:  Method  boolean isNamespaceAware    Document newDocument    Document parse File   Document parse InputSource   Document parse InputStream   Document parse InputStream, String   Document parse String   void setEntityResolver  EntityResolver   void setErrorHandler  Error Handler   The JAXP Transformation API  Description Indicates whether the parser understands XML namespaces.  Returns a new Document object with no content. The returned Document can be populated using DOM methods such as createElement  .  Parses the XML in the supplied ﬁle, and returns the resulting Document object.  Parses the XML in the supplied SAX InputSource, and returns the resulting Document object.  Parses the XML in the supplied InputStream, and returns the resulting Document object. Note that the System ID of the source document will be unknown, so it will not be possible to resolve any relative URIs contained in the document.  Parses the XML in the supplied InputStream, and returns the resulting Document object. The second argument supplies the System ID of the source document, which will be used to resolve any relative URIs contained in the document.  Parses the XML in the document identiﬁed by the supplied URI, and returns the resulting Document object.  Supplies a SAX EntityResolver to be used during the parsing.  Supplies a SAX ErrorHandler to be used during the parsing.  E  J A X P :  T h e  J a v a  A P  I  f o r  T r a n s f o r m a t i o n  The JAXP Transformation API  The previous sections provided a summary of the classes and methods deﬁned in JAXP to control XML parsing. This section covers the classes and methods used to control XSLT transformation.  These classes are designed so they could be used with transformation mechanisms other than XSLT; for example, they could in principle be used to invoke XQuery  however, a different API called XQJ is under development for XQuery, which has more in common with JDBC . But XSLT is the primary target and is the one we will concentrate on.  There is one other kind of transformation that’s worth mentioning, however, and this is an identity transformation in which the result represents a copy of the source. JAXP provides explicit support for identity transformations. These are more useful than they might appear, because JAXP deﬁnes three ways of supplying the source document  SAX, DOM, or lexical XML  and three ways of captur- ing the result document  SAX, DOM, or lexical XML , so an identity transformation can be used to convert any of these inputs to any of the outputs. For example, it can take SAX input and produce a lexical XML ﬁle as output, or it can take DOM input and produce a stream of SAX events as output. An implementation of JAXP can also support additional kinds of Source and Result objects if it chooses.  1169   JAXP: The Java API for Transformation  This allows the ‘‘unofﬁcial’’ document models such as JDOM, DOM4 J, and XOM to coexist within the JAXP framework.  JAXP is also designed to control a composite transformation consisting of a sequence of transformation steps, each deﬁned by an XSLT stylesheet in its own right. To do this, it builds on the SAX2 concept of an XMLFilter, which takes an input document as a stream of SAX events and produces its output as another stream of SAX events. Any number of such ﬁlters can be arranged end to end in a pipeline to deﬁne a composite transformation.  As with the JAXP SAXParser and DocumentBuilder interfaces, JAXP allows the speciﬁc XSLT implemen- tation to be selected using a TransformerFactory object. Typically, the XSLT vendors will each provide their own subclass of TransformerFactory.  For performance reasons, the API separates the process of compiling a stylesheet from the process of executing it. A stylesheet can be compiled once and executed many times against different source docu- ments, perhaps concurrently in different threads. The compiled stylesheet, following Microsoft’s MSXML nomenclature, is known as a Templates object. To keep simple things simple, however, there are also methods that combine the two processes of compilation and execution into a single call.  The classes deﬁned in the javax.xml.transform package fall into several categories: Class or interface Category Principal classes TransformerFactory  Description Selects and conﬁgures a vendor’s implementation  Templates  Transformer  Represents a compiled stylesheet in memory  Represents a single execution of a stylesheet to transform a source document into a result  SAXTransformerFactory  Allows a transformation to be packaged as a SAX XMLFilter  Source  Result  Represents the input to a transformation  Represents the output of a transformation  Source classes  SAXSource  Result classes  SAXResult  DOMSource  StreamSource  DOMResult  StreamResult  Helper classes  URIResolver  1170  Transformation input in the form of a SAX event stream  Transformation input in the form of a DOM Document  Transformation input in the form of a serial XML document  Transformation output in the form of a SAX event stream  Transformation output in the form of a DOM Document  Transformation output in the form of a serial XML document  or HTML, or a plain text ﬁle   User-supplied object that takes a URI contained in the stylesheet  for example, in the document   function  and fetches the relevant document as a Source object  continued   E  J A X P :  T h e  J a v a  A P  I  f o r  T r a n s f o r m a t i o n  Category  Class or interface  ErrorListener  SourceLocator  DOMLocator  OutputKeys  The JAXP Transformation API  Description User-supplied object that is notiﬁed of warnings and errors. The ErrorListener reports these conditions to the user and decides whether to continue processing.  Used primarily to identify where in the stylesheet an error occurred.  Subclass of SourceLocator, used when the source was a DOM.  A collection of constants deﬁning the names of properties for serial output ﬁles.  Error classes  Transformer ConfigurationException  Generally denotes an error in the stylesheet that is detected at compile time.  TransformerException  TransformerFactory ConfigurationError  A failure occurring in the course of executing a transformation.  A failure to conﬁgure the Transformer.  In the following sections I will describe each of these classes, in alphabetical order of the class name  ignoring the name of the package .  javax.xml.transform.dom.DOMLocator  A DOMLocator is used to identify the location of an error when the document is supplied in the form of a DOM. This object will normally be created by the processor when an error occurs, and can be accessed using the getLocator   method of the relevant Exception object. It specializes SourceLocator, providing one additional method:  Method  org.w3c.dom.Node getOriginatingNode    Description Returns the node at which the error or other event is located  javax.xml.transform.dom.DOMResult  Supplying a DOMResult as the result of a transformation indicates that the output is to be written to a DOM in memory. This object will normally be created by the application and supplied to the processor as the second argument of the Transformer.transform   method.  The DOMResult identiﬁes a Node  which will generally be a Document or an Element, or possibly a DocumentFragment  to hold the results of the transformation. The children of the root in the result tree will become children of this Node in the DOM. If no Node is supplied by the application, the system will create a Document node, which can be retrieved using getNode  .  Many XSLT processors will support DOM output, but it is not mandatory. If the processor does support it, then calling getFeature DOMResult.FEATURE  on the TransformerFactory will return true.  If the XSLT stylesheet outputs text using «disable-output-escaping="yes"», then this text will be preceded in the tree by a processing instruction named by the constant Result.PI_DISABLE_  1171   JAXP: The Java API for Transformation  OUTPUT_ESCAPING, and followed by another processing instruction named by the constant Result.PI_ ENABLE_OUTPUT_ESCAPING.  The class has ﬁve constructors allowing different combinations of the same three parameters:           node, the node that will become the parent of the new tree. This must be a Document, an Element, or a DocumentFragment. nextSibling  new in JDK 1.5 , indicating where in a sequence of existing nodes the new tree should be inserted. systemId, identifying the system identiﬁer of the document, which will typically be used as its base URI.  The methods on the class are simply getters and setters for the same three properties.  javax.xml.transform.dom.DOMSource  A DOMSource packages a DOM Document as a Source, so it can be supplied as input to a transformation.  The DOMSource object will normally be created by the application and supplied to the processor as the ﬁrst argument of the Transformer.transform   method. It can also be used to identify the stylesheet document, in which case it will be supplied as a parameter to TransformerFactory.newTemplates  .  It is a good idea to call setSystemId   to supply a base URI for the document, so that relative URIs  for example, those used in the document   function  can be resolved. The DOM itself does not hold this information, so it must be supplied extraneously.  The DOMSource can identify any node in the DOM; it does not have to be the Document node. For example, when you use a DOMSource to identify a stylesheet, this might be a stylesheet embedded within another document, in which case the DOMSource would identify the   element node. When you supply a node other than the Document node as input to the transform   method, the effect is not speciﬁed very clearly, but it is probably intended that it should behave like the transformNode   method in MSXML3. This means that the entire document containing the identiﬁed node forms the input to the transformation, but the transformation starts by looking for a template rule that matches the speciﬁed node, rather than the one that matches the root node.  Note that there are two different ways XSLT processors might handle the supplied document. They might create the XPath tree model as a view or wrapper around the DOM tree, or they might make a copy. The difference between these approaches will become apparent if the stylesheet makes calls to external Java functions that attempt to manipulate the tree as a DOM. It will also, of course, affect performance. Generally, it is best to supply input as a stream or SAX source if you can. Don’t construct a DOM specially in order to supply it as input to a transformation, as you might do if you are used to the Microsoft MSXML API. Most implementations will have an internal tree model that is designed to optimize transformation speed, and this will often run several times faster than the same transformation using the DOM.  Not every XSLT processor will support DOM input. If the processor does so, then calling getFeature DOMSource.FEATURE  on the TransformerFactory will return true.  The class has three constructors:  DOMSource   DOMSource Node  DOMSource Node, String   1172   The JAXP Transformation API  Its methods are listed below: Method  Node getNode    Description Gets the starting node of this DOMSource  String getSystemId    Gets the system identiﬁer  that is, base URI  for resolving relative URIs  void setNode Node   Sets the starting node of this DOMSource  setSystemId String   Gets the system identiﬁer  that is, base URI  for resolving relative URIs  javax.xml.transform.ErrorListener  ErrorListener is an interface; if you want to do your own error handling you can write a class that implements this interface and supply it to the setErrorListener   methods of the Transformer Factory or Transformer class. The ErrorListener will be notiﬁed of both compile-time and runtime errors.  The class is modeled on the SAX ErrorHandler interface, and recognizes three categories of errors: warn- ings, errors, and fatal errors. After a warning, the transformation can proceed to a successful conclusion; after an error, the processor can continue for the purpose of ﬁnding further errors, but in the end it will fail, and after a fatal error, it will stop immediately.  Each method can throw an exception to cause processing to stop immediately, even where the processor is prepared to continue.  Some processors  Xalan in particular  report the output of   to the ErrorListener. If «terminate="no"» is speciﬁed, the message is treated as a warning; if «terminate="yes"» is speciﬁed, it is treated as a fatal error. JAXP doesn’t dictate how   is handled, and other processors do it differently.  If no ErrorListener is supplied, errors will be reported on the standard System.err output stream.  The methods are listed below. Each method can throw a TransformerException, to terminate processing.  E  J A X P :  T h e  J a v a  A P  I  f o r  T r a n s f o r m a t i o n  Method  void error TransformerException   void fatalError TransformerException   void warning TransformerException   javax.xml.transform.OutputKeys  The names of these constants are:  CDATA_SECTION_ELEMENTS DOCTYPE_PUBLIC DOCTYPE_SYSTEM ENCODING  This class deﬁnes a set of constant strings used to represent the standard output properties deﬁned in the   element. This list hasn’t yet been updated to support the new properties found in XSLT 2.0.  If you’re using Saxon, the missing constants can be found in class net.sf.saxon.event .SaxonOutputKeys .  Description Handles an error  Handles a fatal error  Handles a warning  1173   JAXP: The Java API for Transformation  INDENT MEDIA_TYPE METHOD OMIT_XML_DECLARATION STANDALONE VERSION  They correspond in the obvious way to the attributes of the   element.  These constants are useful when you call methods such as getOutputProperty   and setOutputProperty   on the Transformer object.  javax.xml.transform.Result  Result is an interface; it exists as an abstraction of the three classes SAXResult, DOMResult, and StreamResult, which are different ways of representing an XML output destination. This allows any of these different kinds of destination to be supplied as the second argument to the Transformer .transform   method. Implementations can also deﬁne other kinds of Result objects if they wish.  This class deﬁnes the two static constants PI_DISABLE_OUTPUT_ESCAPING and PI_ENABLE OUTPUT_ ESCAPING which are the names of the processing instructions generated as a result of setting «disable- output-escaping="yes"» on the   or «xsl:value-of» instruction in the stylesheet.  The interface deﬁnes two methods, allowing any of the different types of Result to have a system identiﬁer  or base URI :  Method  String getSystemId    void setSystemId    Description Gets the system identiﬁer  Sets the system identiﬁer  javax.xml.transform.sax.SAXResult  Specifying a SAXResult as the output of the transformation causes the result tree produced by the trans- formation to be fed to a user-supplied SAX2 ContentHandler as a sequence of SAX events, just as if the events came from an XML parser. The SAXResult object holds a reference to this ContentHandler, and also to a String containing a system identiﬁer.  This system identiﬁer might be made available to the ContentHandler code as part of the Locator object, though the speciﬁcation doesn’t make it clear that this is what should happen.   Many XSLT processors will support SAX output, but it is not mandatory. If the processor does support it, then calling getFeature SAXResult.FEATURE  on the TransformerFactory will return true.  There are several potential difﬁculties with supplying XSLT output to a ContentHandler:    What happens about disable-output-escaping? The JAXP speciﬁcation solves this by saying  that any text output using disable-output-escaping="yes" will be preceded by a processing instruction named by the constant Result.PI_DISABLE_OUTPUT_ESCAPING, and followed by another processing instruction named by the constant Result.PI_ENABLE_ OUTPUT_ESCAPING.    What happens to comments in the result tree? JAXP solves this by allowing the SAXResult to hold a LexicalHandler as well as a ContentHandler. Comments can then be notiﬁed to the LexicalHandler.  1174   The JAXP Transformation API    What happens if the result tree is not a well-formed document? The SAX ContentHandler inter- face is designed to receive a stream of events representing a well-formed document, and many ContentHandlers will fail  gracefully or otherwise  if they are sent anything else. However, as you saw in Chapter 2, the output of an XSLT transformation needs only to be well balanced. Unfortunately, the JAXP speciﬁcation doesn’t answer this question.  Saxon allows any sequence of events to be sent to the ContentHandler, whether it represents a well-formed sequence or not, unless the additional attribute saxon:require-well-formed="yes" is present on the   declaration.   The class has two constructors:  SAXResult   SAXResult org.xml.sax.ContentHandler   and the following methods:  Method  org.xml.sax.ContentHandler getHandler    org.xml.sax.ext.LexicalHandler getLexicalHandler    Description Gets the ContentHandler  Gets the LexicalHandler  E  J A X P :  T h e  J a v a  A P  I  f o r  T r a n s f o r m a t i o n  String getSystemId    Gets the system identiﬁer  base URI   void setHandler  org.xml.sax.ContentHandler   Sets the ContentHandler that is to receive events representing the result tree  void setHandler  org.xml.sax.ext.LexicalHandler   Sets the LexicalHandler that is to receive lexical events  notably, comments  representing the result tree  void setSystemId    Sets the system identiﬁer  base URI   javax.xml.transform.sax.SAXSource  A SAXSource is a Source, so it is one of the possible inputs you can supply to the Transformer .transform   method  when it represents a source XML document  or to the TransformerFactory .newTemplates   method  when it represents a stylesheet .  Essentially, a SAXSource is the combination of a SAX parser  XMLReader  and a SAX InputSource, which can be a URI, a binary input stream, or a character input stream. A SAXSource delivers the source docu- ment in the form of a stream of SAX events. Usually it will achieve this by parsing XML held in a ﬁle or somewhere in memory, but by deﬁning your own implementations of XMLReader and or InputSource, you can supply the SAX events from anywhere; for example, you can generate them as the result of an SQL query or an LDAP directory search, or you could use an XMLFilter that modiﬁes the events coming through from a real XML parser before passing them on to the transformation.  If no XMLReader is supplied, the system will use a default one. It may do this using the rules for the javax.xml.parsers.SAXParserFactory class described earlier in this appendix, but this is not guaranteed.  Not every XSLT processor will support SAX input. If the processor does so, then calling getFeature  SAXSource.FEATURE  on the TransformerFactory will return true.  1175   JAXP: The Java API for Transformation  There are three constructors:  SAXSource   SAXSource InputSource  SAXSource XMLReader, InputSource   plus the following methods:  Method  InputSource getInputSource    String getSystemId    XMLReader getXMLReader    void setInputSource  org.xml.sax.InputSource   void setSystemId String   Description Gets the SAX InputSource.  Gets the System Identiﬁer used for resolving relative URIs.  Gets the XMLReader  the parser  if one has been set.  Sets the SAX InputSource.  Sets a System Identiﬁer that can be used to resolve relative URIs.  void setXMLReader XMLReader   Sets the XMLReader  the parser  to be used.  static org.xml.sax.InputSource sourceToInputSource Source source   This static method attempts to construct a SAX InputSource from any kind of Source object. It will return null if this isn’t possible.  javax.xml.transform.sax.SAXTransformerFactory  This class is a subclass of TransformerFactory that provides three additional facilities:  The ability to construct a SAX ContentHandler  called a TemplatesHandler , which will accept a stream of SAX events representing a stylesheet, and on completion return a Templates object for this stylesheet. The ability to construct a SAX ContentHandler  called a TransformerHandler  that will accept a stream of SAX events representing a source document, and on completion automatically apply a given stylesheet to that source document. The ability to construct a SAX XMLFilter based on a particular stylesheet: the XMLFilter per- forms the same SAX-to-SAX transformation as the equivalent Transformer would perform, but using the interfaces deﬁned for an XMLFilter. This makes it possible to insert this transformation ﬁlter into a pipeline of ﬁlters.  These facilities were made optional because it was assumed that not every JAXP processor will support them; in practice, all mainstream implementations do.  If getFeature SAXTransformerFactory.FEATURE  returns true, then the implementation’s TransformerFactory will be a SAXTransformerFactory. If getFeature SAXTransformerFactory.FEATURE_XMLFILTER  returns true, then the two newXMLFilter   methods can be used.  If a SAXTransformerFactory is available at all, then it will always be produced as a result of calling TransformerFactory.newInstance  .                 1176   The class has the following methods, in addition to those of TransformerFactory:  The JAXP Transformation API  Description Creates and returns a TemplatesHandler. The TemplatesHandler can be supplied with a stream of SAX events representing the contents of a stylesheet.  Creates and returns a TransformerHandler. The TransformerHandler will perform an identity transformation on the XML source document that is supplied to it in the form of a stream of SAX events.  Creates and returns a TransformerHandler. The Source identiﬁes a document containing a stylesheet. The TransformerHandler will perform the transformation deﬁned by this stylesheet, on the XML source document that is supplied to it in the form of a stream of SAX events.  Creates and returns a TransformerHandler. The Templates argument identiﬁes a compiled stylesheet. The TransformerHandler will perform the transformation deﬁned by this stylesheet, on the XML source document that is supplied to it in the form of a stream of SAX events.  Creates and returns an XMLFilter. The Source identiﬁes a document containing a stylesheet. The resulting XMLFilter will perform the transformation deﬁned by this stylesheet.  Creates and returns an XMLFilter. The Templates argument identiﬁes a compiled stylesheet. The resulting XMLFilter will perform the transformation deﬁned by this stylesheet.  E  J A X P :  T h e  J a v a  A P  I  f o r  T r a n s f o r m a t i o n  Method  TemplatesHandler newTemplatesHandler    TransformerHandler newTransformerHandler    TransformerHandler newTransformerHandler Source   TransformerHandler newTrans- formerHandler Templates   org.sax.xml.XMLFilter newXMLFilter Source   org.sax.xml.XMLFilter newXMLFilter Templates   javax.xml.transform.Source  Source is an interface; it exists as an abstraction of the three classes SAXSource, DOMSource, and StreamSource, which are different ways of representing an XML document. This allows any of these dif- ferent kinds of object to be supplied as the source document to the Transformer.transform   method, or as the stylesheet to the TransformerFactory.newTemplates   method.  The interface deﬁnes two methods, allowing any of the different types of Source to have a system iden- tiﬁer. Specifying a system identiﬁer on a Source object is important, because it will be used as the base URI when relative URIs within the Source are resolved. Method  String getSystemId    void setSystemId    javax.xml.transform.SourceLocator  Description Gets the system identiﬁer  Sets the system identiﬁer  SourceLocator is an interface modeled on the SAX Locator interface. A SourceLocator is used to indi- cate where in the stylesheet an error occurred. Normally, a SourceLocator will be produced by the XSLT processor, and the application will access it using the TransformerException.getLocator   method.  1177   JAXP: The Java API for Transformation  The methods available are: Method  int getColumnNumber    Description Returns the column number of the location if known, or -1 if not  int getLineNumber    Returns the line number of the location if known, or -1 if not  String getPublicId    Returns the public identiﬁer of the document, if available, or null if not  String getSystemId    Returns the system identiﬁer of the document, if available, or null if not  You can supply a StreamResult as the result of a transformation if you want the result tree to be serialized. The format of the resulting ﬁle will be XML, HTML, or plain text, depending on the out- put method deﬁned using   or the Transformer methods setOutputProperty   and setOutputProperties  . With an XSLT 2.0 engine, XHTML output will also be supported.  Note that if you supply a Writer  which represents a stream of characters rather than bytes , then the XSLT processor will ignore the encoding attribute speciﬁed on  . The way in which char- acters are translated to bytes in this situation depends on how the Writer is conﬁgured, and not on the XSLT serializer. One consequence of this is that because the Writer knows nothing about XML, it will not be able to replace characters that aren’t available in the chosen encoding by XML character references of the form «&x20AC;».  StreamResult is deﬁned analogously to StreamSource, which in turn is based on the SAX InputSource class. A StreamResult may be a ﬁle  represented by a URL or a Java File object , or a character stream  Writer , or a byte stream  OutputStream .  Most XSLT processors will support stream output, but it is not mandatory. If the processor does support it, then calling getFeature StreamResult.FEATURE  on the TransformerFactory will return true.  Although the output destination can be expressed as a URI, this must be a writable destination. In prac- tice, this usually means it should be a URI that uses the «file:» preﬁx, but it could potentially be an FTP or WebDAV destination. If you’re running the processor in an applet, writing the output to a ﬁle is probably not feasible. The speciﬁcation doesn’t say what happens if you supply a relative URI, but since relative URIs are not allowed in a SAX InputSource, on which this class is modeled, it’s best to avoid them. Some processors might interpret a relative URI as being relative to the current directory.  The class has constructors for each of the possible output destinations. The constructor for a String expects the string to contain a system identiﬁer  URL .  StreamResult   StreamResult File  StreamResult java.io.OutputStream  StreamResult String  StreamResult java.io.Writer   The methods are straightforward: Method  java.io.OutputStream getOutputStream    String getSystemId    Description Gets the binary output stream  Gets the system identiﬁer  1178  continued   The JAXP Transformation API  Method  java.io.Writer getWriter    void setOutputStream  java.io.OutputStream   void setSystemId java.io.File   Description Gets the Writer  character output stream   Sets the binary output stream  Sets output to go to the speciﬁed ﬁle, by setting the system identiﬁer to the URL of this ﬁle  void setSystemId String   Speciﬁes the system identiﬁer of the output, as a URL  void setWriter java.io.Writer   Speciﬁes the Writer  character output stream  to receive the output  javax.xml.transform.stream.StreamSource  A StreamSource represents XML input in the form of a character or byte stream. It is modeled on the SAX InputSource class; the only reason StreamSource is necessary is that InputSource does not implement the Source interface, so it cannot be supplied directly as the input to methods such as Transformer.transform Source, Result .  Most XSLT processors will support stream input, but it is not mandatory. If the processor does support it, then getFeature StreamSource.FEATURE  will return true.  If input is from a byte stream  InputStream  or character stream  Reader , it is a good idea to call setSystemId   to supply a URI for the document, so that relative URIs  for example, those used in the document   function  can be resolved. The stream itself does not hold this information, so it must be supplied extraneously.  E  J A X P :  T h e  J a v a  A P  I  f o r  T r a n s f o r m a t i o n  The constructors are as follows:  StreamSource   StreamSource java.io.File  StreamSource java.io.InputStream  StreamSource java.io.InputStream, String  StreamSource java.io.Reader  StreamSource java.io.Reader, String  StreamSource String   In each case, the effect is the same as using the default constructor followed by the relevant setXXX   method. The String argument is always a system identiﬁer for the document.  With earlier JAXP releases I advised against supplying a java.io.File object, because the conversion to a URI was buggy. This seems to have been ﬁxed in recent versions.  The methods are straightforward: Method  java.io.InputStream getInputStream    String getPublicId    Description Gets the supplied InputStream  Gets the supplied Public Identiﬁer  continued  1179   JAXP: The Java API for Transformation  Method  java.io.Reader getReader    String getSystemId    void setInput- Stream java.io.InputStream   Description Gets the supplied Reader  Gets the system identiﬁer  Supplies an InputStream  void setPublicId String   Supplies a Public Identiﬁer  void setReader java.io.Reader   Supplies a Reader  void setSystemId java.io.File   Supplies a File from which a system identiﬁer can be obtained  void setSystemId String   Supplies a system identiﬁer  a URL   javax.xml.transform.Templates  Templates is an interface representing a compiled stylesheet. Compiled stylesheets cannot be saved directly to disk  unless the processor provides extensions to enable this , but they are held in memory and can be used as often as required. To use a Templates object to perform a transformation, ﬁrst create a Transformer by calling its newTransformer   method, then conﬁgure the Transformer as required  for example, setting its parameters and output properties , and then run the transformation using the Transformer.transform   method.  The methods available on the Templates object are:  Method  java.util.Properties getOutputProperties    Description Returns a Properties object representing the names and values of the output properties deﬁned using   elements in the stylesheet. The keys of these properties will be strings deﬁned in the OutputKeys class; the values will be the values deﬁned in the stylesheet. Note that output properties that are determined dynamically will not be returned. For example, if the method attribute of   is defaulted, the system doesn’t know at compile time whether the output will be XML or HTML.  Transformer newTransformer    Creates a Transformer object, which can be used to effect the transformation deﬁned in this stylesheet.  javax.xml.transform.sax.TemplatesHandler  The TemplatesHandler interface represents a specialized SAX ContentHandler that treats the stream of SAX events supplied to it as the contents of a stylesheet. When the full document has been supplied, the stylesheet is compiled, and the compiled stylesheet can be retrieved using the getTemplates   method.  This provides an alternative to calling TransformerFactory.newTemplates   and supplying a SAXSource as the source of the stylesheet. The case for using a TemplatesHandler arises when the source of the SAX events is something other than a SAX XMLReader; for example, when the stylesheet is the output of another transformation, in which case the source of the SAX events is a JAXP Transformer. In this situation the TemplatesHandler can be wrapped into a SAXResult and used as the Result of the earlier transformation.  1180   E  J A X P :  T h e  J a v a  A P  I  f o r  T r a n s f o r m a t i o n  The JAXP Transformation API  A TemplatesHandler is always created using the newTemplatesHandler   method of a SAXTransformer- Factory. It provides the following methods in addition to those deﬁned in the SAX ContentHandler interface:  Method  String getSystemId    Templates getTemplates    void setSystemId String   Description Gets the system identiﬁer of the stylesheet.  Returns the Templates object created by compiling the supplied document as a stylesheet.  Sets the system identiﬁer of the stylesheet. A system identiﬁer is needed if relative URIs  for example in   or   elements  need to be resolved.  javax.xml.transform.Transformer  A Transformer represents the collection of resources needed to perform a transformation of a Source to a Result. This includes the compiled stylesheet, the parameter values, and the output properties, as well as details such as an ErrorListener and a URIResolver.  This interface is analogous to the IXSLProcessor class in Microsoft’s MSXML API.  A Transformer is always created by calling the newTransformer   method of either the Templates object, or the TransformerFactory object.  A transformer can be used to perform more than one transformation, but it is not thread-safe: You should not start one transformation until another has ﬁnished. If you want to perform several transformations in parallel, obtain several Transformers from the same Templates object.  The principal method is transform  , which takes two arguments, representing the Source and the Result. There are several different kinds of Source deﬁned, and several kinds of Result. These are described elsewhere in this appendix.  The full set of methods is as follows. Method  void clearParameters    ErrorListener getErrorListener    java.util.Properties getOutputProperties    String getOutputProperty String   Object getParameter String   Description Clears all parameters set using setParameter  .  Gets the ErrorListener for this transformation.  Gets the output properties deﬁned for this transformation. This will be a combination of those deﬁned in the stylesheet and those deﬁned using setOutputProperty   and setOutput Properties  .  Gets a speciﬁc output property deﬁned for this transformation. The argument should be one of the constants deﬁned in OutputKeys, or a vendor-speciﬁc property name.  Gets the value of a parameter deﬁned for this transformation.  continued  1181   JAXP: The Java API for Transformation  Method  URIResolver getURIResolver    Description Gets the URIResolver used for this transformation, or null if none has been supplied.  void setErrorListener  ErrorListener   Sets the ErrorListener to be used to handle errors reported during this transformation.  void setOutputProperties  java.util.Properties   void setOutputProperty  String, String   void setParameter String, Object   void setURIResolver  URIResolver   void transform Source, Result   Sets output properties for the result of this transformation. These properties override any values set using   in the stylesheet. The property names will normally be constants deﬁned in OutputKeys, or vendor-deﬁned properties, but they can also be user-deﬁned properties provided they are namespace-qualiﬁed. Names are namespace-qualiﬁed using the «{uri}localname» notation, in the same way as parameters. Sets the value of a speciﬁc output property for the result of this transformation.  Supplies a parameter for the transformation. The ﬁrst argument corresponds to the parameter name, as deﬁned in a global   element in the stylesheet; if this is namespace-qualiﬁed, it should be written in the form «urilocal-name». The second argument is the parameter value. It’s not deﬁned in the JAXP speciﬁcation what the mapping from Java objects to XPath data types is. Using a String, a Double, a Boolean, or a DOM Node is likely to work in most processors, but beyond this, it depends on the implementation.  Sets the URIResolver to be used to resolve all URIs encountered during this transformation, especially when evaluating the document   function.  Performs the transformation. Source and Result are interfaces, allowing a wide range of different types of Source and Result to be supplied.  javax.xml.transform.TransformerConﬁgurationException  This class deﬁnes a compile-time error, generally an error in the stylesheet. It is a subclass of TransformerException and has the same methods as its parent class, TransformerException.  There are several constructors deﬁned, but since this object will usually be created by the XSLT processor itself, I won’t list them here.  javax.xml.transform.TransformerException  A TransformerException represents an error that might be detected either at compile time or at runtime. The exception may contain any or all of the following:        A message explaining the error. A nested exception, generally containing additional information about this error.  Actually, despite the name getException  , this need not be an Exception object; it can be any Throwable, allowing an Error as well as an Exception.   1182   The JAXP Transformation API        A SourceLocator, indicating where in the stylesheet the error occurred. A cause. This is likely to be the same as the nested exception. Nested exceptions were intro- duced in JAXP before they became a standard Java feature in JDK 1.4, which is why there are two methods that appear to do the same thing.  There are several constructors deﬁned, but since this object will usually be created by the XSLT processor itself, I won’t list them here.  E  Description Gets the cause of the exception, if any  Throwable getException    Gets the nested exception, if any  The methods available are:  Method  Throwable getCause    String getLocationAsString    SourceLocator getLocator    Constructs a String representing the location of the error  Gets the SourceLocator, if any, that identiﬁes where the error occurred  String getMessageAndLocation    Constructs a String that combines information about the error and information about where it occurred  void initCause Throwable   Sets the cause of this exception  void setLocator  SourceLocator   Sets a SourceLocator identifying where the error occurred  J A X P :  T h e  J a v a  A P  I  f o r  T r a n s f o r m a t i o n  javax.xml.transform.TransformerFactory  Like the SAXParserFactory and DocumentBuilderFactory in the javax.xml.parsers package, described in the ﬁrst part of this appendix, this factory class enables you to select a speciﬁc vendor’s XSLT imple- mentation.  The ﬁrst thing an application must do is obtain a TransformerFactory, which it can do by calling the static method TransformerFactory.newInstance  . Different vendors of XSLT processors will each implement their own subclass of TransformerFactory, and this method call determines which vendor’s processor your application will end up using. If there are several available, the one that is used is based on the following decision process:  1.  2.  3.  Use the value of the system property javax.xml.transform.TransformerFactory if it is avail- able. You can set system properties using the -D option on the Java command line, or by calling System.setProperty   from your application. Look for a properties ﬁle $JAVA_HOME lib jaxp.properties, and within this ﬁle, for the property named javax.xml.parsers.TransformerFactory. Use the services API, which is part of the JAR speciﬁcation. This generally means that the ﬁrst processor found on the classpath will be used.  The theory is that when you install a particular XSLT processor, it will contain a ﬁle in its .jar archive that makes that particular processor the default, so if you don’t do anything to select a speciﬁc processor, the one chosen will depend on the order of ﬁles and directories on your class path. Unfortunately the  1183   JAXP: The Java API for Transformation  practice can be rather different, because you don’t always have control over the classpath, especially in a complex application server environment.  Relying on a search of the classpath has two other disadvantages. Firstly, it is expensive; if the transfor- mation is a short one then it can take longer to ﬁnd a transformer than to run it. Secondly, it is error-prone; it’s difﬁcult to be sure that your application will keep working when small and apparently unrelated con- ﬁguration changes are made. Although it’s a good thing to write your application in such a way that it will potentially work with any XSLT processor, it’s a bad thing to allow it to run with an XSLT processor that it hasn’t been tested with.  If you’re writing an application that’s designed to work only with Saxon, and you don’t mind hav- ing compile-time references to Saxon classes in your code, then I would recommend bypassing the call to TransformerFactory.newInstance  , and simply calling «new net.sf.saxon .TransformerFactoryImpl  » instead. Alternatively, call «System.setProperty "javax.xml .transform.TransformerFactory", "net.sf.saxon.TransformerFactoryImpl" ». But remember that this setting will affect everything running in the same Java VM.  For Saxon-SA, the name of the class is com.saxonica.SchemaAwareTransformerFactory.  The latest JAXP release, included in Java 6, provides a new version of the TransformerFactory .newInstance   method that allows you to specify the name of the implementation class as a parameter to the call. This avoids the side effects of setting the system property.  Java includes a copy of Xalan in its core libraries. This doesn’t stop you using any of the techniques above to load a different XSLT processor, such as Saxon. What can be slightly tricky, however, is to use a later version of Xalan than the one included with the JDK. The easiest way to achieve this is to copy xalan.jar into a specially recognized directory for endorsed code, such as j2sdk1.5.0 jre lib endorsed  xalan.jar.  Once you have got a TransformerFactory, you can use a number of methods to conﬁgure it. Finally, you can call the newTemplates   method to compile a stylesheet, or call the new Transformer   method to obtain a Transformer directly  if you only want to use the compiled stylesheet once .  Object getAttribute String   Gets a vendor-speciﬁc conﬁguration property.  The methods available are shown below. Method  Source getAssociatedStyleSheet Source doc, String media, String title, String charset   ErrorListener getErrorListener    boolean getFeature String   Description Within the XML source document identiﬁed by the Source argument, ﬁnds the   processing instruction corresponding to the media, title, and charset parameters  any of which may be null , and returns a Source representing this stylesheet.  Gets the default error listener that will be used for transformations. If none has been set, this will be a vendor-supplied ErrorListener.  Gets information about the features supported by this implementation. Features are deﬁned by constants within other classes; for example, getFeature SAXResult .FEATURE  returns true if the processor supports output to a SAX ContentHandler.  continued  1184   The JAXP Transformation API  Method  URIResolver getURIResolver    Description Gets the default URIResolver that will be used for transformations.  static TransformerFactory newInstance    Returns an instance of the vendor-speciﬁc Transformer- Factory, selected according to the rules given above.  Templates newTemplates Source   Transformer newTransformer    Transformer newTransformer Source   void setAttribute String, Object   void setErrorListener  ErrorListener   Compiles the stylesheet provided in the given Source, returning a Templates object as a representation of the compiled stylesheet.  Creates a Transformer that will perform an identity transformation.  A shortcut method equivalent to calling newTemplates  Source .newTransformer  .  Sets a vendor-speciﬁc conﬁguration property.  Deﬁnes the ErrorListener to be used for error handling.  E  J A X P :  T h e  J a v a  A P  I  f o r  T r a n s f o r m a t i o n  void setURIResolver URIResolver   Deﬁnes the URIResolver to be used for resolving URIs contained in the stylesheet or source document.  javax.xml.transform.TransformerFactoryConﬁgurationError  A TransformerFactoryConfigurationError  the speciﬁcation writers must be good typists  represents an error in conﬁguring the XSLT processor, as distinct from an error in the stylesheet itself.  Note that this is an Error rather than an Exception, which means that an application is not expected to take any recovery action.  The only methods available are:  Method  String getMessage    Description Gets the error message  Exception getException    Gets any nested exception  javax.xml.transform.sax.TransformerHandler  The TransformerHandler interface is a specialization of the SAX ContentHandler. It is an object that receives SAX events representing a source document and performs a transformation on this source doc- ument, writing the results of the transformation to a given Result object.  The TransformerHandler interface extends three SAX event-handling interfaces: the ContentHandler, the LexicalHandler, and the DTDHandler. It needs to act as a LexicalHandler so that it can handle comments in the source document, and it needs to act as a DTDHandler so that it can ignore comments in the DTD and ﬁnd out about unparsed entity declarations in the DTD.  Using a TransformerHandler is an alternative to creating a Transformer and using a SAXSource to deﬁne the input document. This alternative approach is particularly useful when the source of SAX events is something other than a SAX XMLReader. For example, the source of SAX events might be another JAXP 1185   JAXP: The Java API for Transformation  transformation, or it might be any other piece of software that allows a ContentHandler to be nominated to receive results.  A TransformerHandler is always created using the newTransformerHandler   method of a SAXTransformerFactory.  In addition to the methods deﬁned in the SAX ContentHandler, LexicalHandler, and DTDHandler interfaces, a TransformerHandler offers the following methods: Method  Description Gets the system identiﬁer deﬁned for the source document.  String getSystemId    Transformer getTransformer    Gets the underlying Transformer. This can be used to set parameters and output properties for the transformation.  void setResult Result   Sets the output destination for the transformation.  void setSystemId String   Sets the system identiﬁer for the source document. This will be used as a base URI to resolve any relative URIs contained in the document.  javax.xml.transform.URIResolver  URIResolver is an interface; you can write a class that implements this interface and supply it to the setURIResolver   method of the TransformerFactory or Transformer class. The URIResolver supplied to the TransformerFactory is used to handle a URI encountered at compile time in an   or   declaration, while the URIResolver supplied to the Transformer is used at runtime to handle the document   function. The URIResolver can treat the URI any way it likes, and it returns the required document as a Source object: typically a SAXSource, a DOMSource, or a StreamSource.  For example, if the stylesheet called «document ’db:employee=517541’ », your URIResolver could interpret this URI as a database query and return an XML document containing the results of the query.  Technically, this interface is rather poorly named. The Internet RFCs distinguish the process of resolving a relative URI against a base URI, which is essentially a syntactic operation on two character strings, from the process of dereferencing the resulting absolute URI, which typically sends a request over the wires to retrieve some resource. Although the URIResolver is passed the relative URI and base URI as separate arguments, it would be bad practice to resolve the relative URI in a nonstandard way. The real power of the URIResolver is its ability to control how the absolute URI is dereferenced.  The interface deﬁnes only one method: Method  Source resolve String, String   Description The ﬁrst argument is a relative URI, the second is the base URI against which it is resolved. The method returns a Source containing the requested document, or throws a Transformer- Exception if it cannot retrieve it. It may also return null, indicating that the default URIResolver should be used.  There is a practical problem that the JAXP interface does not address, namely the XSLT rule that if you call the document   function twice to fetch the same absolute URI, the same document should be returned each time. Since the URIResolver accepts the relative URI and base URI as separate argu- ments, but does not actually return an absolute URI, it’s not entirely clear whether it is the responsibility  1186   E  J A X P :  T h e  J a v a  A P  I  f o r  T r a n s f o r m a t i o n  Examples of JAXP Transformations  of the processor or the URIResolver to enforce this rule, especially when the URI is in a format that the XSLT processor itself does not recognize, as in the example above.  Note also that the arguments are supplied in the opposite order to those of the Java java.net.URI class.  Examples of JAXP Transformations  This section provides some simple examples of applications that use the JAXP API in different ways to control a transformation.  Example 1: Transformation Using Files  This example  FileTransform.java  performs a single transformation, reading the source document and stylesheet from ﬁles, and sending the XML output to another ﬁle.  import javax.xml.transform.*; import javax.xml.transform.stream.*; import java.io.File;  public class FileTransform {  public static void main String[] args  throws Exception {  StreamSource source = new StreamSource new File args[0]  ; StreamSource style = new StreamSource new File args[1]  ; StreamResult out = new StreamResult new File args[2]  ;  TransformerFactory factory = TransformerFactory.newInstance  ; Transformer t = factory.newTransformer style ; t.transform source, out ;  }  }  This is a minimal JAXP application.  At one time I was reluctant to supply File objects to the JAXP StreamSource and StreamResult constructors, because the ﬁlename-to-URI conversion was buggy. In recent releases the problems seem to have been ﬁxed.  Assuming you have installed the Sun Java JDK, you can compile this application by the command:  javac FileTransform.java  This assumes that the directory containing the Java source ﬁle is the current directory. Once you have compiled the code, you can run it from the command line, for example:  java FileTransform source.xml style.xsl out.html  Of course, this is not a very professionally written application. It will fall over with a stack trace if incorrect arguments are supplied, if either of the input ﬁles doesn’t exist, or if errors occur during the transformation; but it’s a start. My aim in these examples is to show how the main JAXP classes work, not to teach you professional Java programming.  Because some people like to type examples exactly as they are written in the book, the folder contain- ing the Java applications also contains specimen XML and XSL ﬁles called source.xml and style.xsl. 1187   JAXP: The Java API for Transformation  So if you make this folder your current directory, you should be able to type the command line above exactly as shown. But, of course, the Java application will handle any source ﬁle and any stylesheet. The stylesheet style.xsl uses the construct shown at the start of this chapter to place in the output ﬁle a com- ment identifying which XSLT processor was used. So by experimenting with different classpath settings you should be able to satisfy yourself that this code works with multiple XSLT processors.  Example 2: Supplying Parameters and Output Properties  This example, Parameters.java, enhances the previous example:           It allows a stylesheet parameter to be supplied from the command line. It modiﬁes the output properties deﬁned in the stylesheet. It directs the output to System.out instead of a ﬁle.  The main   method of the enhanced application looks like this:  public static void main String[] args  throws Exception {  StreamSource source = new StreamSource new File args[0]  ; StreamSource style = new StreamSource new File args[1]  ; String title = args[2];  TransformerFactory factory = TransformerFactory.newInstance  ; Transformer t = factory.newTransformer style ; t.setParameter "title", title ; t.setOutputProperty OutputKeys.INDENT, "no" ; t.transform source, new StreamResult System.out  ;  }  This version of the program can be run using a command such as the following. The third argument on the command line  written in quotes because it contains spaces  is now a parameter value for the stylesheet, instead of the output ﬁlename.  java Parameters source.xml style.xsl "New organization structure"  Comparing the output with that of the previous example, note that the HTML is no longer indented, and that the contents of the   and   elements have changed. And, of course, the output is written to the console this time.  Example 3: Holding Documents in Memory  In this example we will hold both the stylesheet and the source document in memory so that they can be used repeatedly. In principle, this would allow us to run different source documents past the same stylesheet, or to use different stylesheets to transform the same source document, but in practice, to keep the example simple, we’ll use the same source document and stylesheet repeatedly, changing only the parameters to the transformation. We’ll do one transformation using each of the parameters supplied on the command line.  To keep the source document in memory, create a DOM. One way of doing this would be to use the DocumentBuilder class deﬁned in the ﬁrst section of this appendix. But I’d prefer to stick to using the javax.xml.transform interfaces in these examples, so I’ll do it in a different way. JAXP makes it very easy to do an identity transform, and to build the DOM — all you need is an identity transform that takes the serial ﬁle as input and produces the DOM as output.  1188   E  J A X P :  T h e  J a v a  A P  I  f o r  T r a n s f o r m a t i o n  Examples of JAXP Transformations  You could also keep the stylesheet in memory as a DOM, but this would mean validating and compiling it each time it is used. It’s better to keep the compiled stylesheet, that is, the Templates object.  The main program of this example  Repeat.java  looks like this:  public static void main String[] args  throws Exception {  StreamSource source = new StreamSource new File args[0]  ; StreamSource style = new StreamSource new File args[1]  ;  TransformerFactory factory = TransformerFactory.newInstance  ;    Build a DOM using an identity transform Transformer builder = factory.newTransformer  ; DOMResult result = new DOMResult  ; builder.transform source, result ; Document doc =  Document result.getNode  ;     Compile the stylesheet Templates templates = factory.newTemplates style ;     do one transformation for each parameter supplied for  int i=2; i<args.length; i++  {  Transformer t = templates.newTransformer  ; System.out.println "======= TITLE = " + args[i] + "=======" ; t.setParameter "title", args[i] ; t.transform new StreamSource source , new StreamResult System.out  ;  }  }  You can run this application from the command line with a command such as:  java Repeat source.xml style.xsl one two three four  This will run the transformation four times, producing output HTML with the title set to «one», «two», «three», and «four» in turn.  This application is quite unrealistic, but the same principle of keeping source documents and stylesheets in memory can often be used to achieve signiﬁcant performance beneﬁts in a servlet environment, such as the application described in Chapter 19.  Example 4: Using the   Processing Instruction  The previous examples have all speciﬁed the source document and the stylesheet separately. However, as you saw in Chapter 3, it is possible for a source XML document to identify its preferred stylesheet using an   processing instruction at the start of the source XML. This example shows how to extract the relevant stylesheet using the JAXP API: speciﬁcally, the getAssociatedStyle sheet   method provided by the TransformerFactory object.  The main   method of this example  Associated.java  is:  public static void main String[] args  throws Exception {  StreamSource source = new StreamSource new File args[0]  ;  1189   JAXP: The Java API for Transformation  TransformerFactory factory = TransformerFactory.newInstance  ;     Get the associated stylesheet for the source document Source style = factory.getAssociatedStylesheet source, null, null, null ;     Use this to do the transformation  Transformer t = factory.newTransformer style ; t.transform source, new StreamResult System.out  ;  }  Specifying null values for the media, title, and charset arguments of getAssociatedStylesheet   selects the default stylesheet for the document. If the document has multiple   processing instructions, it is possible to use these parameters to choose more selectively.  You can run this example with the command:  java Associated source.xml  This example illustrates a difference between the Saxon and Xalan implementations of JAXP. If you run this example on a source document that has no   processing instruction, Saxon throws a TransformerConfigurationException, whereas Xalan returns null from the getAssociatedStylesheet   method. The JAXP speciﬁcation, as often happens, is silent on the question. In production code, it would be best to check for both conditions.  Example 5: A SAX Pipeline  It can often be useful to place an XSLT transformation within a SAX pipeline. A pipeline consists of a series of stages, each of which implements the SAX2 interface XMLFilter. The ﬁlters are connected together so that each ﬁlter looks like a SAX2 ContentHandler  a receiver of SAX events  to the previous stage in the pipeline, and looks like an XMLReader  a supplier of SAX events  to the following stage. Some of these ﬁlters might be XSLT ﬁlters, others might be written in Java or implemented using other tools.  In our example  Pipeline.java  we will use a pipeline that contains a source  the XML parser , three ﬁlters, and a sink  a serializer . The ﬁrst ﬁlter will be a Java-written XMLFilter whose job is to convert all the element names in the document to upper-case, recording the original name in an attribute. The second ﬁlter is an XSLT transformation that copies some elements through unchanged and removes others, based on the value of another attribute. The ﬁnal ﬁlter is another Java-written XMLFilter that restores the element names to their original form.  I’ve invented this example for the purpose of illustration, but there is some rationale behind it. In XML, upper-case and lower-case are distinct, so   and   are quite distinct element names. But the legacy of HTML means you may sometimes want to do a transformation in which   and   are handled in the same way. This isn’t easy to achieve in XSLT  it’s easier in XSLT 2.0, but still clumsy , so it makes sense to do the pre- and post-processing in Java.  Start with the two Java-written XMLFilter classes. These are written as subclasses of the SAX helper class XMLFilterImpl. You only need to implement the startElement   and endElement   methods; the other methods simply pass the events through unchanged.  The preﬁlter looks like this. It normalizes the name of the element to lower-case, and saves the supplied local name and QName as additional attributes.  1190   Examples of JAXP Transformations  private class PreFilter extends XMLFilterImpl {  public void startElement  String uri, String localName,  String qName, Attributes atts   throws SAXException {  String newLocalName = localName.toLowerCase  ; String newQName = qName.toUpperCase  ; AttributesImpl newAtts =   atts.getLength  >0 ?  new AttributesImpl atts  : new AttributesImpl   ;  newAtts.addAttribute "", "old-local-name",  "old-local-name", "CDATA", localName ;  newAtts.addAttribute "", "old-qname",  "old-qname", "CDATA", qName ;  super.startElement uri, newLocalName, newQName, newAtts ;  public void endElement  String uri, String localName,  String qName   throws SAXException {  String newLocalName = localName.toLowerCase  ; String newQName = qName.toUpperCase  ; super.endElement uri, newLocalName, newQName ;  E  J A X P :  T h e  J a v a  A P  I  f o r  T r a n s f o r m a t i o n  The postﬁlter is very similar; the only difference is that because the original element name is needed by the endElement   code as well as startElement  , the startElement   code  which gets the names from the attribute list  saves them on a stack where endElement can pick them up later.  public void startElement  String uri, String localName, String qName,  private class PostFilter extends XMLFilterImpl {  public Stack stack;  public void startDocument   throws SAXException {  stack = new Stack  ; super.startDocument  ;  throws SAXException {  Attributes atts   String originalLocalName = localName; String originalQName = qName; AttributesImpl newAtts = new AttributesImpl  ; for  int i=0; i<atts.getLength  ; i++  {  String name = atts.getQName i ; String val = atts.getValue i ; if  name.equals "old-local-name"   {  originalLocalName = val;  } else if  name.equals "old-qname"   {  originalQName = val;  } else {  1191  }  }  }  }   JAXP: The Java API for Transformation  newAtts.addAttribute   atts.getURI i , atts.getLocalName i , name, atts.getType i , val ;  }  } super.startElement uri, originalLocalName, originalQName, newAtts ; stack.push originalLocalName ; stack.push originalQName ;  public void endElement  String uri, String localName, String qName  throws SAXException {  String originalQName =  String stack.pop  ; String originalLocalName =  String stack.pop  ; super.endElement uri, originalLocalName, originalQName ;  Now you can build the pipeline, which actually has ﬁve components:  The XML parser itself, which you can get using the ParserFactory mechanism described at the start of this appendix. The preﬁlter. The XSLT transformation, constructed using the stylesheet held in filter.xsl. The postﬁlter. The serializer. The serializer is obtained from the TransformerFactory and is actually a TransformerHandler that performs an identity transformation with a StreamResult as its output.  As with any SAX2 pipeline, the ﬁrst stage is an XMLReader, the last is a ContentHandler, and each of the intermediate stages is an XMLFilter. Each stage is linked to the previous stage using setParent  , except that the ContentHandler at the end is linked in by calling setContentHandler   on the last XMLFilter. Finally, the pipeline is activated by calling the parse   method on the last XMLFilter, which in our case is the postﬁlter.  Here is the code that builds the pipeline and runs a supplied source ﬁle through it:  public void run String input  throws Exception {  StreamSource source = new StreamSource new File input  ; File style = new File "filter.xsl" ;  TransformerFactory factory = TransformerFactory.newInstance  ; if  !factory.getFeature SAXTransformerFactory.FEATURE_XMLFILTER   {  System.err.println "SAX Filters are not supported" ;  } else {  SAXParserFactory parserFactory = SAXParserFactory.newInstance  ; parserFactory.setNamespaceAware true ; XMLReader parser = parserFactory.newSAXParser  .getXMLReader  ;  }  }  }  1.  2. 3. 4. 5.  1192   SAXTransformerFactory saxFactory =  SAXTransformerFactory factory; XMLFilter pre = new PreFilter  ;     substitute your chosen SAX2 parser here, or use the    SAXParserFactory to get one pre.setParent parser ; XMLFilter filter = saxFactory.newXMLFilter new StreamSource style  ; filter.setParent pre ;  XMLFilter post = new PostFilter  ; post.setParent filter ;  TransformerHandler serializer = saxFactory.newTransformerHandler  ; serializer.setResult new StreamResult System.out  ; Transformer trans = serializer.getTransformer  ; trans.setOutputProperty OutputKeys.METHOD, "xml" ; trans.setOutputProperty OutputKeys.INDENT, "yes" ; post.setContentHandler serializer ; post.parse source.getSystemId   ;  Summary  E  J A X P :  T h e  J a v a  A P  I  f o r  T r a n s f o r m a t i o n  }  }  }  For the example I’ve given the class a trivial main program as follows:  public static void main String[] args  throws Exception {  new Pipeline  .run args[0] ;  And you can execute it as:  java Pipeline mixed-up.xml  The results are sent to standard output.  Summar y  In this appendix I have given an overview of the JAXP interfaces.  I started, for the sake of completeness, with a quick tour of the JAXP facilities for controlling SAX and DOM parsers, found in package javax.xml.parsers.  I then gave detailed descriptions of the classes and methods in the package javax.xml.transform and its subsidiary packages.  Finally, I showed some simple examples of JAXP in action. Although the applications chosen were very simple, they illustrate the range of possibilities for using Java and JAXP to integrate XSLT components into a powerful application architecture.  1193    F  S a x o n  Saxon  Saxon is an implementation of XSLT 2.0 produced by the author of this book, Michael Kay. Saxon also includes XQuery and XML Schema processors. The product runs on two platforms, Java and .NET, and it exists in two versions: an open source product Saxon-B, which implements the basic conformance level of the XSLT speciﬁcation, and a commercial product Saxon-SA, which adds schema-aware processing. All versions can be obtained by following links from http:  saxon.sf.net .  There is also an older version of Saxon available, version 6.5, which implements XSLT 1.0. This appendix is concerned only with the XSLT 2.0 processor.  The Java version of Saxon requires JDK 1.4 or a later Java release, and there are no other dependen- cies. The .NET version is produced by cross-compiling the Java code into the Intermediate Language  IL  used by the .NET platform, using the IKVMC cross-compiler produced by Jeroen Frijters  http:  www .ikvm.net . This runs on .NET version 1.1 or 2.0.  There are three ways of running Saxon:           You can run it from within a product that provides a graphical user interface. Saxon doesn’t come with its own GUI, but it is integrated into a number of development environments such as Stylus Studio  stylusstudio.com  and oXygen  oxygenxml.com , and it can be conﬁgured as an external processor for use within XML Spy  altova.com . If you just want to experiment with Saxon, the quickest way to get started is probably to download Kernow  kernowforsaxon .sf.net . As long as you have Java installed  J2SE 6 , you don’t need to install anything else — Saxon comes bundled with Kernow. You can run Saxon from the command line, either on Java or .NET. This is described in the next section. You can invoke Saxon from within your Java or .NET application. On Java, Saxon implements the standard JAXP interfaces described in Appendix E, though if you want to get the full bene- ﬁts of the product, then you’ll need to understand how Saxon extends these interfaces  JAXP in its current form was designed with XSLT 1.0 in mind . On the .NET platform, Saxon has its own API, which is outlined on page 1203.  Saxon doesn’t come with an installer, so whether you use the Java or .NET product, it’s essentially a question of unzipping the distributed ﬁles into a directory of your own choosing. For details, see the Getting Started documentation at http:  www.saxonica.com documentation.   Saxon  For Java, the most likely place to slip up is in setting the classpath. This is largely because Java doesn’t give you much help when you get it wrong. Either you can set the classpath using the -cp option on the command line when you run Saxon or you can set it in the CLASSPATH environment variable. To do this on Windows, go to Settings ➪ Control Panel ➪ System ➪ Advanced ➪ Environment Variables. If there is already an environment variable called CLASSPATH, click Edit to change its value, adding the new entries separated by semicolons from the existing entries. Otherwise, click New either under User Variables if you want to change the settings only for the current user, or under System Variables if you want to change settings for all users. Enter CLASSPATH as the name of the variable, and a list of directories and or .jar ﬁles, separated by semicolons, as the value.  For the .NET product, unless you’re just playing with Saxon very casually from the command line, you should install the DLL ﬁles in the General Assembly Cache. There’s a batch script provided to do this; you only need to run it once. On Vista it’s probably easier to do it using the .NET framework administra- tion tool which can be reached via the Control Panel.  If you’re using the schema-aware product Saxon-SA, then you’ll need to obtain a license key from Saxonica. It comes with instructions for how to install it.  Using Saxon from the Command Line  If you are using Saxon on a Windows platform  and even more so if you are running on a Mac , then you may not be accustomed to using the command line to run applications. You can do this from the standard MS-DOS console that comes with Windows, but I wouldn’t recommend it because it’s too difﬁcult to correct your typing mistakes and to stop output from scrolling off the screen. It is far better to install a text editor that includes a Windows-friendly command line capability. If you’re familiar with Unix tools, then you may want to install Cygwin  cygwin.com . I quite like the console plugin for the open-source jEdit editor  from jedit.org , mainly because it has good Unicode support, but for general editing I usually use UltraEdit  ultraedit.com  which has a basic-but-adequate capability for launching command line applications.  The command part causes the Saxon XSLT processor to be invoked, and the options are then passed to Saxon to control what the XSLT transformation actually does.  The command line can be considered in two halves:  command options  For Java, the simplest form of the command is:  java -jar saxon9.jar [options]  This works provided that java is on your PATH, and saxon9.jar is in the current directory. If either of these conditions isn’t true, you may need to add a full path so that the Java VM and or Saxon can be located.  Although the -jar form of the command is very convenient, it is also very restricted, because it does not allow code to be loaded from anywhere other than the speciﬁed JAR ﬁle. For anything more complicated  for example, a stylesheet that uses extension functions, or one that access DOM, JDOM, or XOM ﬁles, or one that uses schema-aware processing , you will need to use a form of command that uses the classpath. You can either set the classpath within the command line itself:  java -cp c:\saxon\saxon9.jar;c:\saxon\saxon9-dom.jar net.sf.saxon.Transform [options]  or you can set the CLASSPATH environment variable and omit the -cp option:  java net.sf.saxon.Transform [options]  1196   Using Saxon from the Command Line  Here net.sf.saxon.Transform is the entry point that tells Java to load the Saxon XSLT transformer. If you get a message indicating that this class wasn’t found, it means there is something wrong with your classpath.  For .NET the situation is somewhat simpler. Either make the directory containing the Saxon executables  including Transform.exe  the current directory, or add it to the system PATH variable. Then use the command:  Transform [options]  The options are the same whichever form of the command you use, and are described below. For a more detailed explanation, see the Saxon documentation. This table relates to Saxon 9.0 and later; earlier versions used a slightly different format.  F  S a x o n  -explain[:filename]  Option  -a  -c:filename  -cr:classname  -dtd:onoff  -expand:onoff  -ext:onoff  -im:modename  -it:template  -l:onoff  –m:classname  –o:filename  Description Use the   processing instruction in the source document to identify the stylesheet to be used. The stylesheet argument should then be omitted.  Requests use of a stylesheet that has been previously compiled using the net.sf.saxon.Compile command.  Sets a user-deﬁned resolver for collection URIs.  Sets DTD validation on or off.  The value off suppresses expansion of attribute defaults deﬁned in the DTD or schema.  Requests output showing how the code has been optimized. The output is sent to the console unless a ﬁlename is supplied.  The value off prevents calls on extension functions.  Starts execution in the named mode.  Speciﬁes the name of the initial template. The transformation will start by evaluating this named template.  Switches line numbering on  or off  for the source document. Line numbers are accessible through the extension function saxon:line-number  , or from a trace listener.  Speciﬁes the name of a Java class used to process the output of   instructions.  Deﬁnes a ﬁle to contain the primary output of the transformation. Filenames for secondary output ﬁles  created using    will be interpreted relative to the location of this primary output ﬁle.  -or:classname  Sets a user-deﬁned resolver for secondary output ﬁles.  -outval:recoverfatal  Indicates whether validation failures found when validating the result document should be treated as fatal or recoverable.  continued 1197   -s:filename  Speciﬁes the principal source document.  Saxon  Option  -p:onoff  -r:classname  -repeat:N  -strip: allnoneignorable  –T[:classname]  -sa  -t  –TJ  –u  –val:strictlax  -versmsg:onoff  -warnings: silentrecoverfatal  –x:classname  Description The value on means that query parameters such as «val=strict» are recognized in URIs passed to the doc   and document   functions.  Sets a JAXP URIResolver, used to resolve all URIs used in  ,  , or in the doc   and document   functions.  Runs the same transformation N times. Useful for performance measurement.  Requests schema-aware processing.  Requests stripping of all whitespace, or none, or ‘‘ignorable’’ whitespace  whitespace in elements deﬁned by the DTD or schema to have element-only content .  Displays information about the Saxon and Java versions in use, and progress messages indicating which ﬁles are being processed and how long the key stages of processing took.  Traces execution of the stylesheet. Each instruction is traced as it is executed, identifying the instruction and the current location in the source document by line number. If a classname is supplied, trace output is sent to a user-supplied TraceListener.  Traces the loading of Java extension functions. This is a useful debugging aid if you are having problems in this area.  Indicates that the names of the source document and stylesheet are URLs rather than ﬁlenames.  Requests strict or lax schema-based validation of all source documents. This option is available only with Saxon-SA.  Setting this to off suppresses the warning message that appears when running against a 1.0 stylesheet.  Indicates how XSLT-deﬁned recoverable errors are to be handled. Either recover silently; or output a warning message and continue; or treat the error as fatal.  Deﬁnes the XML parser to be used for the source document, and for any additional document loaded using the document   function.  –tree:tinylinked  Chooses the implementation of the XDM tree model.  -xi  Enable XInclude processing  if the XML parser supports it .  -xsl:filename  The stylesheet to be applied.  -xmlversion:1.01.1  –y:classname  Indicates whether the XML 1.0 or 1.1 rules for the syntax of names  etc  should be used.  Deﬁnes the XML parser to be used for processing stylesheet documents and schema documents.  1198   Using Saxon from a Java Application  You can specify values for global parameters deﬁned in the stylesheet using a keyword=value notation; for example:  Transform -s:source.xml -xsl:style.xsl param1=value1 param2=value2  If the parameter names have a non-null namespace, you can use Clark notation for expanded names; for example, «{namespace-uri}local-name». The parameter values are interpreted as strings. If the string contains a space, you should enclose it in quotes; for example, «param1="John Brown"». They are passed to the stylesheet as xs:untypedAtomic values, which means that if the   element declares a type such as xs:integer or xs:string, the value will be converted automatically to the required type, provided that the value is valid for that type.  If you want to pass an XML document as a parameter to the stylesheet, you can do this by preﬁxing the parameter name with «+» and supplying the name of the XML ﬁle as the parameter value. For example:  F  S a x o n  Transform -s:source.xml -xsl:style.xsl +lookup=lookup.xml  The XML contained in lookup.xml will be parsed, and the document node of the resulting tree will be passed to the stylesheet as the value of the stylesheet parameter named «lookup».  You can also override   attributes using a similar notation, but preﬁxing the keyword with «!». For example, to get indented output write:  Transform -s:source.xml -xsl:style.xsl !indent=yes  Using Saxon from a Java Application  When calling Saxon from Java, you have a choice between using the JAXP interface deﬁned in Appendix E, or one of Saxon’s native interfaces. Saxon 9.0 introduces a new Java interface called s9api  pronounced ‘‘snappy’’  that is designed to eliminate some of the limitations and inconsistencies of the JAXP interfaces, but JAXP is still available if you need to keep your application portable. Although Saxon itself works with JDK 1.4, to use the s9api interface you will need Java 5 or later, because it takes advantage of features like the generic collection classes.  I will ﬁrst describe how to use Saxon’s implementation of the JAXP interfaces, and then take a look at the s9api design.  Using Saxon via JAXP Interfaces  JAXP interfaces are summarized in Appendix E, and you can ﬁnd full speciﬁcations in the Sun Javadoc documentation: go to http:  java.sun.com j2se 1.5.0 docs api index.html, and look for the pack- ages javax.xml.transform, javax.xml.validation, and javax.xml.xpath. These three packages allow you to:           Compile an XSLT stylesheet and run a transformation Load a schema and validate a source document Compile and run XPath expressions  These are described brieﬂy in the following sections.  1199   Saxon  Running XSLT Transformations  The JAXP transformation API allows you to compile a stylesheet into a Templates object, which can then be used repeatedly  in series or in multiple threads  to process different source documents through the same stylesheet. This can greatly improve throughput on a Web server. Saxon supplies a sample application to achieve this, in the form of a Java servlet.  Saxon implements the whole of the javax.xml.transform package, including the dom, sax, and stream subpackages, both for input and output. It also implements the SAXTransformerFactory, which allows you to do the transformation as part of a SAX pipeline. If you want to use Saxon with the DOM you need to have saxon9-dom.jar on the classpath.  The implementation of TransformerFactory in Saxon-B is the class net.sf.saxon.TransformerFactory- Impl, and this is used in the examples below. The equivalent in Saxon-SA is com.saxonica.SchemaAware- TransformerFactory.  The saxon9.jar package includes a services ﬁle that has the effect of causing the JAXP Transformer- Factory to choose Saxon as the default XSLT processor. However, it can be tricky to ensure that Saxon is loaded, given that the JDK includes an XSLT implementation  Xalan  as a standard component. The best policy, if you require Saxon because your stylesheet is written in XSLT 2.0, is to select it explicitly. There are several ways this can be achieved:     If you don’t mind your code having a compile-time reference to Saxon classes, the simplest, fastest, and most robust approach is to replace the call:  factory = TransformerFactory.newInstance  ;  by:  factory = new net.sf.saxon.TransformerFactoryImpl  ;           You can choose Saxon by setting the Java system property named javax.xml.transform. TransformerFactory to the value net.sf.saxon.TransformerFactoryImpl. Use the -D option on the Java command when you invoke your application. Note that this goes before the name of the class to be executed:  java -Djavax.xml.transform.TransformerFactory=  net.sf.saxon.TransformerFactoryImpl com.my-com.appl.Program  This all goes on one line. In practice of course you won’t want to type this more than once, so cre- ate a batch ﬁle or shell script using your text editor, and invoke this instead.  Create a ﬁle called jaxp.properties within the directory $JAVA_HOME lib  where $JAVA_HOME is the directory containing your Java installation , and include in this ﬁle a line of the form key= value, where key is the property key javax.xml.transform .TransformerFactory and value is the Saxon class net.sf.saxon .TransformerFactoryImpl. Put the call:  System.setProperty  "javax.xml.transform.TransformerFactory",  "net.sf.saxon.TransformerFactoryImpl"   in your application, to be executed at runtime. This technique is useful if you want to run several different JAXP processors from the same application, perhaps in order to compare their results or to benchmark their performance.  1200   Using Saxon from a Java Application     In Java 6 you can call:  TransformerFactory.newInstance "net.sf.saxon.TransformerFactoryImpl", null   If you are still having trouble, try setting the Java system property jaxp.debug to «1». This gives diag- nostic information about the loading process.  The TransformerFactory interface in JAXP has a method setAttribute  , which allows processor- dependent conﬁguration options to be set. Saxon offers a large number of such options, corresponding to all the options on the command line and a few more. Details are in the Saxon Javadoc documentation at http:  www.saxonica.com documentation javadoc index.html. The names of the attributes and a description of their purpose can be found in the speciﬁcation of the class net.sf.saxon.FeatureKeys.  As well as accepting the standard three kinds of Source object deﬁned in JAXP, that is, StreamSource, SAXSource, and DOMSource, a Saxon transformation can also take other kinds of input. Saxon’s tree model uses an interface net.sf.saxon.om.NodeInfo to represent a node, and because this interface extends the JAXP Source interface, any NodeInfo can be used as the source of a transformation. If you want to use a document as input to several transformations, you can build the tree once using the factory method Configuration.buildDocument  , and then supply the returned NodeInfo to the Transformer’s transform   method. You can also construct a NodeInfo as a wrapper around a DOM, JDOM, DOM4 J, or XOM document, and supply this wrapper to the transformer in the same way. As well as supplying the primary input to the transformation, all these techniques can be used to supply additional docu- ments as the values of stylesheet parameters  just supply a Source as the argument to the Transformer’s setParameter   method , or documents read using the doc   or document   functions  you can return any kind of Source from the user-supplied URIResolver .  F  S a x o n  The Schema Validation API  Saxon-SA supports the schema validation API deﬁned in package javax.xml.validation. It provides an implementation of the SchemaFactory interface  com.saxonica.jaxp.SchemaValidatorImpl , which is currently in a separate package and JAR ﬁle for the beneﬁt of JDK 1.4 users — this part of the JAXP API appears ﬁrst in JDK 1.5. This allows you to load a schema, and to validate instance documents in either streaming  SAX  mode, or while building a DOM tree. Both these options are only really useful if you want to do freestanding validation.  Because the JAXP transformation API was designed for XSLT 1.0, it doesn’t provide any direct way to request validation of the source document for a transformation, so Saxon provides its own mechanism. In fact, it provides several. One approach is to set a system-wide switch indicating that all source documents should be validated strictly or laxly. This can be done by calling setAttribute FeatureKeys.SCHEMA_ VALIDATION, Validation.STRICT  on the TransformerFactory object. If you want to control valida- tion on a per-document basis, then you can create an AugmentedSource object with the appropriate options set. AugmentedSource is a JAXP Source object, so it can be used as input to a transformation, and as the name suggests it bundles together an underlying Source object with a number of parame- ters indicating how the source should be processed — one of these being an option to request schema validation.  Using XPath Expressions in Saxon  Another JAXP component introduced in JDK 1.5 is the interface for evaluating XPath expressions. Saxon implements this one too, allowing the source object to be either a native Saxon tree, or a DOM, JDOM, XOM, or DOM4 J tree wrapped in a Saxon NodeInfo wrapper.  1201   Saxon  Unfortunately the JAXP XPath API suffers a number of weaknesses. It is designed for XPath 1.0 rather than 2.0, which means it cannot handle the full range of data types that XPath 2.0 supports. I would therefore be strongly inclined to recommend using Saxon’s s9api interface instead, which is described in the next section. There is also a legacy API in package net.sf.saxon.sxpath which you can use if you need it to work on JDK 1.4. This is modeled on the JAXP API, but has many differences of detail.  The s9api Interface  Saxon’s s9api interface for Java was newly introduced in Saxon 9.0, strongly inﬂuenced by the success of the API provided on the .NET platform. The design aims were:           To provide a consistent approach to XSLT, XQuery, XPath, and XML Schema processing To avoid the clutter caused by conforming to a ragbag of legacy interfaces and by exposing implementation-level classes To provide a greater level of type safety, partly achieved by exploiting new Java 5 language fea- tures such as generics  The starting point for an application is to create an instance of Processor  all classes are in package net.sf.saxon.s9api . This provides a few system-wide conﬁguration options, acts as an owner of shared resources, and provides factory methods for other functionality.  Whether you are running XSLT, XQuery, or XPath, you follow the same sequence of steps:  1.  2.  3.  4.  5.  6.  Create a compiler for the appropriate language, using one of the three factory methods newXslt- Compiler  , newXQueryCompiler  , and newXPathCompiler   deﬁned on the Processor class. Set properties on the compiler deﬁning the static context for the compilation, and any other com- pile time options. For example, in the case of XPath this includes the base URI, the declared namespaces, and the external variables available to the XPath expression. Call the compile   method on the compiler. This creates a corresponding executable  Xslt Executable, XQueryExecutable, or XPathExecutable  which represents the compiled program or expression as an object in  potentially shared  memory. The principle in each case is that you only compile the object once, and you can run it as often as you like in the same thread or in different threads. Load the executable, by calling its load   method, which returns a runtime object called vari- ously the XsltTransformer, XQueryEvaluator, or XPathSelector. Conﬁgure the runtime object by setting options that affect a single evaluation  that is, the dynamic evaluation context . This typically includes the node to be used as the initial context node, the runtime values of variables parameters, and serialization options. Finally, run the transformation or query by calling one of the following methods:    transform   for XSLT evaluate  , iterator  , or run   for XQuery evaluate  , evaluateSingle  , or iterator   for XPath        The Processor also allows you to obtain a DocumentBuilder, which is used for building source docu- ments in tree form, and a SchemaManager, which can be used to load schema documents into a central pool of schema deﬁnitions, which are then shared by all operations running under the control of the same Processor.  1202   Using Saxon from a .NET Application  The s9api package includes a set of classes for representing objects deﬁned in the XDM data model, and reﬂecting the XDM type hierarchy:              XdmValue  a sequence of items  XdmItem  a node or atomic value  XdmNode  a node  XdmAtomicValue  an atomic value   and these classes provide methods for converting between the XDM objects and native Java objects.  The result of a query or XPath expression can be returned as an XdmValue; alternatively, the relevant run- time objects implement the Java Iterable  interface, so you can process the results like this:  F  S a x o n  XPathCompiler compiler = processor.newXPathCompiler  ; XPathSelector selector = compiler.compile "  book[price > 20]" .load  ; XDMNode doc = processor.newDocumentBuilder  .build new StreamSource "in.xml"   selector.setContextItem doc ; for  XdmItem item : selector  {  System.out.println " " + item + " " ;  }                    The result of performing a transformation  or a validation  can be sent to any kind of Destination object. This is analogous to the JAXP Result object, except that it is possible to implement your own kinds of Destination. The system allows you to choose a number of possible destinations:  To serialize the output, send it to a Serializer. To send it to a SAX ContentHandler, choose a SAXDestination. If you want the result tree as an XdmNode, choose an XdmDestination. If you want a DOM document node, use a DOMDestination. If you want to validate the output against a schema, send it to a SchemaValidator, which can be constructed from the SchemaManager. If you want to apply a further transformation, the XsltTransformer class is also an implementa- tion of XdmDestination.  Using Saxon from a .NET Application  There is no equivalent to the JAXP interface on .NET, so Saxon provides its own APIs.  It could have attempted to emulate the APIs in the System.Xml.Xsl namespace, but as these are concrete classes rather than interfaces, it would still be difﬁcult to write applications that work interchangeably with Saxon or with the native XSLT 1.0 processor in .NET. . Applications can of course be written in any .NET language, for example C or VB.NET.  The API follows a three-stage Compile Load Go model. If you read the previous section describing s9api, then this will already be familiar, because s9api was modeled on the .NET interface. The steps are as follows:  1. 2.  Create a Processor object. This contains global Saxon conﬁguration information. Create an XsltCompiler object. This contains compile-time options for processing a stylesheet.  1203   Saxon  3.  4.  Compile the stylesheet to create an XsltExecutable object. The XsltExecutable represents the compiled stylesheet, and can be used as often as you like, in multiple threads concurrently. Each time you want to run a transformation, load the stylesheet from the XsltExecutable to create an XsltTransformer. The XsltTransformer is generally used once only. You can set parameters that affect this transformation, and then call the Run   method to perform the transformation.  The source document is built by creating a DocumentBuilder and calling its Build   method: the input can come from a URI, a stream, an XmlNode, or an XmlReader. It is then supplied by setting the Initial ContextNode property of the XsltTransformer.  The result destination is supplied as an argument of the Run   method, and may be any XmlDesti- nation object. One kind of destination is a Serializer; you can create a Serializer and initialize it with settings of the various output properties such as indent and encoding, which override any values supplied in the stylesheet. Alternatively, you can supply a TextWriterDestination which bridges to the .NET world by feeding the output to a .NET TextWriter, or you can supply an XdmDestination to get the result in the form of a Saxon tree, or a DomDestination to get it in the form of a System.Xml DOM node.  Here is an example showing a simple transformation  the full code is in ShowAccount.cs :  public static void SimpleTransformation String sourceUri, String xsltUri  {     Create a Processor instance Processor processor = new Processor  ;     Load the source document XdmNode input = processor.NewDocumentBuilder  .Build new Uri sourceUri  ;     Create a transformer for the stylesheet XsltTransformer transformer =  processor.NewXsltCompiler  .Compile new Uri xsltUri  .Load  ;     Set the root node of the source document to be the initial context node transformer.InitialContextNode = input;     Set a parameter to the transformation transformer.SetParameter new QName "", "", "greeting" ,  new XdmAtomicValue "hello"  ;     Create a serializer Serializer serializer = new Serializer  ; serializer.SetOutputWriter Console.Out ; serializer.SetOutputProperty Serializer.INDENT, "yes" ;     Transform the source XML to Console.Out transformer.Run serializer ;  }  1204   Extensibility  The API also allows you to control schema validation of source documents, and to evaluate XPath and XQuery expressions. The APIs for XPath and XQuery use the same Compile Load Go metaphor, and the method names are chosen to be as consistent as possible.  Saxon Tree Models  F  S a x o n  Saxon deﬁnes an internal interface, the NodeInfo interface, to represent the XPath data model, and the product is capable of transforming any data source that supplies an implementation of this interface. There are several implementations of this interface available:              The default is the Tiny Tree, which as the name implies, is optimized for space, but also turns out to be the fastest implementation under many circumstances. The Linked Tree is a more conventional tree, which is sometimes faster to navigate than the Tiny Tree but takes longer to build and occupies more space. Saxon uses this model internally for stylesheets and schemas. There is an implementation of NodeInfo that wraps a standard level-3 DOM. There are further implementations of NodeInfo that wrap a JDOM tree, a XOM tree, or a DOM4 J tree.  If none of these is suitable, you can in principle write your own. For example, you could write an imple- mentation of NodeInfo that fetches the underlying data from a relational database.  Although Saxon allows an input document to be supplied as a DOM, processing a DOM is much slower than processing Saxon’s native tree implementations. Unless your input already exists in the form of a DOM, it’s better to supply a StreamSource or SAXSource and let Saxon build the tree itself. If you want to build the tree yourself so that it can be used more than once, Saxon supplies a method Configura- tion.buildDocument  . The Configuration is a Saxon object that underpins the TransformerFactory, and if you are running any kind of complex workload, you will probably want to manipulate it explicitly rather than via JAXP interfaces.  In the .NET API, nodes are represented by the .NET class XdmNode. This is a simple wrapper around the Java NodeInfo object.  Extensibility  In this section, I will describe the facilities Saxon provides for user-written extension functions, and also the way that Saxon handles collations. Following this, I’ll look at a few of the extension functions that come ready-supplied with the Saxon product.  For all these extensions, the namespace preﬁx «saxon» needs to be declared as «xmlns:saxon= "http:  saxon.sf.net "». Don’t forget the trailing « ».  Try to avoid using extension functions that have side effects: Saxon  especially Saxon-SA  has an aggres- sive optimizer that will often rearrange expressions into a very different form from the way they were originally written, and this can make side effects very unpredictable. The most common trap is to call  1205   Saxon  such a function in the select expression of  . Such a function will usually not be called until the variable is ﬁrst referenced, and if the variable is never referenced, the function will probably never be called at all.  Writing Extension Functions in Java  Saxon allows you to write extension functions in Java. The facilities can be extensively customized, but the simplest approach is to use a namespace URI in the function name that reﬂects the name of the Java class. For example:  <xsl:variable name="today"  select="Date:new  " xmlns:Date="java:java.util.Date" >  This returns an XPath value that is a wrapper for a Java object of class java.util.Date. Saxon maps Java classes into the XPath type hierarchy  as a new kind of atomic value , so you can declare the type of this value as:  <xsl:variable name="today"  select="Date:new  " xmlns:Date="java:java.util.Date" as="class:java.util.Date" xmlns:class="http:  saxon.sf.net java-type" >  Saxon looks for methods in the speciﬁed class that have the right name and the right number of argu- ments, and if there is more than one, it tries to ﬁnd the one that is the best ﬁt to the arguments supplied. For convenience, a hyphenated XPath name such as get-random-number   is mapped to the camelCased Java name getRandomNumber  .  The above example uses the function name new   to call a constructor on the speciﬁed class. It is also possible to call static methods in the same way, by using the actual method name. If you want to call an instance-level method  that is, a non-static method , you can do this by supplying the relevant object as an extra ﬁrst argument, thus:     where $today was deﬁned as in the previous example. Public ﬁelds in the instance can be accessed as if they were zero-argument methods.  If you have problems with Saxon being unable to locate the classes and methods you want to call, try the -TJ option on the command line, which gives you detailed diagnostics. Remember that Saxon will only look for classes that are on the classpath, and  a common pitfall  that the classpath is effectively empty if you invoke Java using the -jar option on the command line. Also remember that the class and method must both be public.  Writing Extension Functions under .NET  When you run Saxon under .NET, it is still possible to invoke external Java classes such as java.util.Date, provided they are in the standard system library. That’s because Saxon itself relies on having the full  1206   Extensibility  Java library available, cross-compiled into IL.  The version currently used is the GNU Classpath library, though this may move to OpenJDK in the future.   Loading your own Java code dynamically is a bit more tricky, and the best way is probably to use IKVMC to compile it to a .NET assembly, in which case you can load it in the same way as .NET code written in any other language.  Saxon uses the same basic technique to load a .NET assembly as it uses for Java code: the namespace URI in the function call, which should be preﬁxed «clitype:», is used to identify the assembly and class to be invoked, and the local part of the function name identiﬁes the method or property. Generally speaking, if the assembly has already been loaded by the application, then it’s sufﬁcient to supply the type name. For example, the following displays the name of the current user:     If it’s necessary to load the assembly dynamically, then more information is needed. This is supplied in the form of query parameters to the URI. To load a class Employee from the Payroll assembly held in the Global Assembly Cache with a particular version number and strong name, you might use a call such as:  F  S a x o n  <xsl:value-of select="emp:GetSalary $empnr " xmlns:emp= "clitype:Acme.Payroll.Employee?asm=payroll;version=5.0.0.1;sn=abcd0123cdef9876" >  Collations  One of the new features in XSLT 2.0 and XPath 2.0 is that all comparison and sorting of strings can be controlled using collations. This is because the rules for sorting and comparison vary from one language  and one application  to another. Collations are identiﬁed using a URI; like namespace URIs, these are not expected to identify real resources on the Web, but simply act as globally unique identiﬁers.  The speciﬁcations say nothing about how collation URIs are established or what they mean, so each product has to devise its own naming scheme. This section explains how it’s done in Saxon.  Both Java and .NET offer extensive support for deﬁning collations, so the approach that Saxon adopts is to provide a parameterized URI that identiﬁes the required properties of the collation, which are then used to obtain a collator object from the underlying platform to perform the string comparisons. The collation URI takes the general form:  http:  saxon.sf.net collation?keyword=value;keyword=value;...  The parameters you are most likely to use are lang, which deﬁnes the required language  for example, «lang=sv» selects Swedish , ignore-case  values «yes» and «no» , which deﬁnes whether the differ- ence between upper case and lower case is signiﬁcant, and ignore-modifiers  values «yes» and «no» , which deﬁnes whether accents should be ignored. Other options available include case-order  values «upper-first» and «lower-first» , which determines whether upper-case letters precede lower-case ones or vice versa, and alphanumeric  values «yes» and «no» , which if set causes any sequence of digits to be interpreted as a number, so for example «iso-10646» will sort after «iso-646».  Generally, if you are matching words in natural language text, you should ignore differences such as case and accents  a low-strength collation , while for sorting, a high-strength collation is appropriate: This will  1207   Saxon  ensure that words that differ only in their accents are sorted in the correct way, even though they might compare as equal in a search.  For other parameters that you can include in a Saxon collation URI, see the product documentation. If you want the ultimate in control, the collation URI can identify a user-written implementation of the «java.lang.Comparator» interface.  Because collation URIs are unlikely to be portable across implementations, it’s a good idea to deﬁne them as stylesheet parameters. For example, you can deﬁne a stylesheet parameter:  <xsl:param name="sorting-collation"  select="’http:  saxon.sf.net collation?lang=de;ignore-modifiers=yes’" >  and then use this in a sort, by specifying:     You could also deﬁne the collation using a conditional expression, using the system-property   function to determine which vendor’s XSLT processor is currently in use.  The «[xsl]:default-collation» attribute, which applies to everything in its scope except   elements, can specify a list of collation URIs, and a processor will use the ﬁrst one that it recognizes. You can specify http:  www.w3.org 2005 xpath-functions collation codepoint as the last item in the list to provide a fallback that every processor is obliged to recognize.  Extensions  The XSLT speciﬁcation provides a number of mechanisms allowing extensions to be implemented in a vendor namespace, and Saxon has exploited these to the full. As well as providing extensibility mechanisms allowing you to extend the capabilities of the product, Saxon includes quite a few built-in extensions. These fall into a number of categories, described in the following sections.  Serialization Extensions  Saxon provides a number of extra serialization properties, with names in the Saxon namespace, that you can use on the   declaration and the   instruction. The two most common options are shown below.  Property  saxon:indent-spaces  saxon:character- representation  Value and Meaning An integer, determines the level of indentation when «indent="yes"».  Indicates how non-ASCII characters should be represented. For «method="xml"», this only affects characters outside the chosen encoding, and the values are «hex» and «decimal». For HTML, two values are allowed; for example, «entity;hex», which indicates that non-ASCII characters within the encoding should use named entities if possible; those outside the encoding should use hex character references.  1208   Extensions  Extension Attributes  Extension attributes are attributes in the Saxon namespace that can be added to XSLT instructions. Processors other than Saxon will ignore these attributes. The table below gives examples.  Attribute  saxon:memo- function  saxon:explain  Value and Meaning When «saxon:memo-function="yes"» is present on an   element, Saxon remembers the result of evaluating the function, and uses the saved result if the function is called again with the same arguments.  When «saxon:explain="yes"» is present on an   or   element, Saxon outputs an XML representation of the compiled code showing what optimizations it has applied.  The same output is available for the entire stylesheet using the -explain option on the command line.   F  S a x o n  saxon:read-once This option is used to signal to Saxon that a document read using the  document   function will only be used once; this acts as a hint that streamed execution can be used, avoiding the need to build the tree representation of the document in memory.  Extension Instructions  Extension instructions are elements in the Saxon namespace that perform a similar role to XSLT instruc- tions. If you use any of these instructions, your stylesheet must contain the attribute «extension- element-prefixes="saxon"». You can use  elements to indicate how processors other than Saxon should behave when these instructions are encountered. Examples of extension instruc- tions are:  Instruction  saxon:assign  Meaning Modiﬁes the value of a variable. Not recommended, as the effect can be very unpredictable.  saxon:call-template  Same as   except that the template name can be computed at runtime.  saxon:doctype  Constructs a DTD to include in the output document.  saxon:entity-ref  Creates an entity reference in the serialized output.  Saxon also provides a set of extension instructions sql:connect, sql:query, sql:insert, sql:delete, and sql:update, allowing data to be read from and written to relational databases. These are in the namespace « net.sf.saxon.sql.SQLElementFactory» and are described at http:  www.saxonica .com documentation sql-extension intro.html.  Extension Functions  The largest category of extensions are additional functions provided in the Saxon namespace. Chapter 16 contains advice on how to call extension functions without sacriﬁcing portability of your stylesheet.  1209   Saxon  Examples of these functions are shown in the table below, grouped according to their intended purpose. Some of them are available only in Saxon-SA.  Functions  saxon:parse   saxon:serialize   saxon:compile-stylesheet   saxon:transform    saxon:analyze-string   saxon:for-each-group   saxon:format-date   saxon:format-number   saxon:generate-id   saxon:index   saxon:find   saxon:namespace-node   etc.  saxon:base64Binary-to-octets   saxon:base64Binary-to-string   saxon:hexBinary-to-octets   saxon:hexBinary-to-string    saxon:path   saxon:line-number   saxon:system-id   saxon:type-annotation    saxon:try    saxon:eval   saxon:evaluate   saxon:evaluate-node   saxon:expression    Purpose Allow parsing, serialization, and transformation of documents to be controlled from within a stylesheet. Useful when input or output documents contain nested documents within CDATA sections.  Provide equivalents of XSLT capabilities for the beneﬁt of XQuery users.  Allow manipulation of base64 binary values  found for example in LDAP directories  and hexBinary values.  Provide information about the current node in the source document, for use in diagnostics.  Allows dynamic errors to be caught.  Allow evaluation of XPath expressions constructed dynamically from strings or read from a source document. See next section for a use case.  The evaluate   Extension  Many of the new facilities included in XSLT 2.0, including multiple output ﬁles, grouping facilities, and stylesheet functions, were ﬁrst pioneered as Saxon extensions. Saxon also copied extensions that were ﬁrst introduced elsewhere: the ubiquitous node-set  extension function, for example, appeared ﬁrst in James Clark’s xt processor, as did extensions to ﬁnd the intersection or difference between two node-sets. Saxon went further than most XSLT processors in providing a wide range of extensions built in to the product. However, most of these have been superseded by standard features in XSLT 2.0.  The most important extension that remains, which has sadly not made it into XSLT 2.0 even though it has been copied by several other processors, is the ability to evaluate a dynamically constructed XPath expression. This extension has been adopted, in restricted form, as the dyn:evaluate   function within EXSLT  see www.exslt.org . Here I will describe the Saxon implementation of this functionality.  1210   The evaluate   Extension  F  S a x o n  In standard XSLT  even in 2.0 , there is no way of constructing an XPath expression at runtime from a string. This makes it difﬁcult to do things that are very familiar to SQL programmers; for example, building a query from the values of parameters read from a form, or sorting a table on a column selected by the user. It also makes it impossible to interpret XPath expressions held as part of the text of the source document, perhaps implementing a subset of the XPointer speciﬁcation for deﬁning links between documents. The Saxon stored expression concept ﬁlls this gap: you can use the saxon:expression   extension function to create a stored expression from a string, and saxon:eval   to evaluate the stored expression; or you can combine these two operations into one using the saxon:evaluate   function.  The table below describes these functions in more detail.  Function  expression  string   eval expression, variables...   Explanation This function constructs a stored expression from the XPath expression contained in the supplied string. The stored expression can be evaluated later using the saxon:eval   function.  If the XPath expression contains namespace preﬁxes, these are resolved at the time the stored expression is created, not at the time it is subsequently evaluated. They are always resolved relative to namespaces declared in the stylesheet.  The expression may contain references to the variables $p1 to $p9. The values of these variables are supplied when the expression is subsequently evaluated.  This function evaluates a stored expression supplied in the ﬁrst argument. The stored expression is constructed using the saxon:expression   function. The second and subsequent arguments  which are optional  provide values that will be bound to the variables $p1..$p9 used within the stored expression.  The context node, position, and size for evaluating the expression are those that apply to the stylesheet at the point where eval   is called.  evaluate string, variables...   This function combines the effect of saxon:expression   and saxon:eval   into a single call: That is, it prepares the expression and immediately evaluates it.  evaluate- node node   This function can be used when reading an XPath expression stored in a source XML document. It is similar to saxon:evaluate  , except that namespace bindings are taken from the node where the expression is written, rather than from the stylesheet; this node is also used as the context node. This version does not allow reference to parameters.  Allowing XPath queries to be constructed dynamically gives a number of beneﬁts:           You can construct a query such as «  book[author="Kay" and publisher="Wrox"]», from the values of stylesheet parameters supplied at runtime. You can easily change the sort order used in an   element based on parameters sup- plied at runtime. You can allow XPath expressions to be used within the source document, for example to deﬁne hyperlinks between documents, and you can write code in your stylesheet to follow these links.  1211   Saxon        You can implement higher-order functions in which an expression is passed as a parameter to a function. You can use XPath expressions to deﬁne business rules in a separate document.  The following example demonstrates the last of these techniques.  Example: Using saxon:evaluate   to Apply Business Rules  In this example, we imagine a call center that is charging customers for the calls they make. We want to prepare the account for a period, listing all the calls and calculating the total charge.  Source  The list of calls is in the ﬁle calls.xml, as follows:                     We want to put the business rules for calculating the charges in a separate document. Of course, these rules could go in the stylesheet, but this isn’t very good practice; mixing business rules and presentation rules in one place doesn’t give the right separation of respon- sibilities. Instead, we’ll put the relevant formula in a separate document tariff.xml, in the form of an XPath expression. This calculates the total charge, with different rates per minute during the working day and outside ofﬁce hours:  sum call[@time &gt;= 08.00 and @time &lt; 18.00] @duration  * 1.50 + sum call[@time &lt; 08.00 or @time &gt;= 18.00] @duration  * 2.50  Most of the stylesheet  account.xsl  is conventional, and is concerned with displaying the information. When it comes to calculating the total charges, however, the stylesheet reads the XPath expression containing the relevant formula from the tariff.xml document and evaluates it  using saxon:evaluate    in the context of the source document.        Stylesheet  1212   The evaluate   Extension    <xsl:stylesheet xmlns:xsl="http:  www.w3.org 1999 XSL Transform"  xmlns:saxon="http:  saxon.sf.net " version="1.0">      Account for period ending       Account for period ending         F  S a x o n                               Date   Time   Duration          <xsl:variable name="total"  select="saxon:evaluate document ’tariff.xml’  " >   Total charges for the period:                                       An observation on this stylesheet: This was ﬁrst written to work with XSLT 1.0. In principle, it could be rewritten to use the facilities for arithmetic on dates, times, and durations provided in XSLT 2.0. However, little would be gained by doing so. Converting the application to use these facilities would require times to be written as «xs:time ’08:00:00’ » rather than as «08.00», which would also create a dependency on the declaration of the namespace preﬁx «xs». Also, multiplying a duration by a number in XPath 2.0 returns a duration, not a cost. Just  1213   Saxon  because the facilities are provided doesn’t mean that you have to use them, and in this case, it seems simpler not to.  To run this stylesheet, make the directory containing the downloaded ﬁles for this chapter the current directory, and enter: java -jar c:\saxon\saxon9.jar -s:calls.xml -xsl:account.xsl -o:bill.html  Output  The output of this stylesheet  bill.html  appears in the browser as shown in Figure F-1.  Figure F-1  Summar y  This appendix describes how to install and use the Saxon product, and how to invoke it from a Java or .NET application. It also describes some of the facilities provided by Saxon that go beyond the XSLT 2.0 speciﬁcation itself.  1214   G  A l t o v a  Altova  Altova is the company that produces the popular XMLSpy toolkit. Among its many capabilities this includes an XSLT 2.0 processor, which can be used either as part of XMLSpy or on its own from the command line or via one of a number of application programming interfaces. XMLSpy is commercial software that can be purchased from www.altova.com.  Altova’s XSLT 2.0 processor is available as a free  but not open source  download from the same site — it is part of a package called AltovaXML that also includes an XML validating parser, an XML Schema processor, an XQuery engine, and an XSLT 1.0 processor. The XQuery and XSLT 2.0 processors are both schema-aware. Although the product is internally a COM component, APIs are offered for COM, Java, and .NET.  As well as the XSLT 2.0 processor itself, XMLSpy also includes an interactive XSLT debugger and a proﬁler for performance analysis.  Both products run on Windows only. The version described in this chapter is the 2008 edition.  Running from within XMLSpy  An example showing how to run a simple ‘‘Hello World’’ stylesheet from within XMLSpy was given in Chapter 1  see page 11 .  Remember that XMLSpy includes both an XSLT 1.0 and an XSLT 2.0 processor, and the one it uses depends on the «version» attribute in your   element. If you are writing an XSLT 2.0 stylesheet and you get error messages referring to unrecognized functions or instructions, check that you haven’t inadvertently speciﬁed «version="1.0"».  When you click F10  or the relevant icon or menu item  to ﬁre off a transformation, the only thing you are asked for is the ﬁlename of the source document to be transformed. If you want to supply parameters to the transformation, there is a separate dialog box for this: select the menu item XSL XQuery, then XSL Parameters XQuery Variables. The value of the parameter is interpreted as an XPath expression, so if you want to supply a simple string, then it has to be in quotes.  There’s no option to start the transformation without a source document, with a named template, or in a named mode; in fact, there are no other options at all. This also applies when the processor is launched from the command line or using the API. Instead, use the XSLT 1.0 technique of adding «match=" "» to   Altova  the entry template  remember that a template can have both a match attribute and a name attribute , and supply a dummy input document.  Using Tools ➪ Options ➪ XSL, you can conﬁgure XMLSpy to use a different transformation engine. You can either select MSXML  versions 3, 4, or 6 , or you can connect to an external processor  for example, Saxon  by giving a template for its command line interface. This can be useful if you want to check that your stylesheets work with more than one processor, or if you want a second opinion when you get an error message that you don’t understand. This feature also caters to people who want to use XMLSpy to develop stylesheets and then to use a different engine for live deployment.  Conformance  You may ﬁnd suggestions on the web that the Altova processor is less than fully conformant with the W3 C Recommendations. However, the level of conformance has been steadily improving with each successive release, and the 2008 release has very few restrictions that are likely to affect the typical user. Most of the gaps that were present in the 2007 version have been plugged, for example format-date   is now fully supported, and upper-case   and lower-case   now work with the full Unicode character set. We’ve tested most of the examples in this book against both Saxon and Altova, and where we found a problem, we’ve pointed it out.  Altova supports all of the optional features of the XSLT 2.0 speciﬁcation, including schema awareness, serialization, the namespace axis, disable-output-escaping, and backward compatibility.  Backward compatibility is not normally invoked when running inside XMLSpy, because XMLSpy chooses an XSLT 1.0 processor when you specify «version="1.0"». However, you can force the issue by importing an XSLT 1.0 stylesheet module into an XSLT 2.0 module, and it handles this correctly.   One remaining area where Altova warns you about signiﬁcant differences in behavior is in the area of whitespace handling. Like the Microsoft MSXML parser, the Altova XML parser strips whitespace text nodes from the source document before XSLT processing starts; unlike the Microsoft parser, there doesn’t appear to be anything you can do to prevent this.  There are two problems this can cause:        In the ﬁrst case, you aren’t actually interested in the boundary whitespace, so it doesn’t matter that it has been removed, except that your stylesheet was written on the assumption that it was there, so it stops working. The best answer here is to add the declaration <xsl:strip-space elements="*" > so that every processor strips the unwanted whitespace, and then make any necessary changes to your code. In many cases the only impact will be that the inter-element whitespace is no longer copied to the output, making the output less legible. You can ﬁx this by adding  . In other cases, the whitespace might really be meaningful. This happens most often with mixed content, that is, with narrative documents. If your document contains two adjacent bold words with a space between them, like this:   It was a  long   hard  winter   then you don’t want the space to disappear. Altova’s only suggestion for dealing with this prob- lem is to modify the source document, by moving the space character inside one of the two adjacent elements.  If you want to do this with XSLT, of course, you will need to use a processor that doesn’t strip whitespace . . . .   1216   The Command Line Interface  Extensions and Extensibility  As far as I have been able to determine, Altova includes no built-in extensions in its product, that is, no extra functions or top-level declarations in a vendor-deﬁned namespace.  There also appear to be no facilities for creating user-deﬁned extensions, that is, callouts to code written in languages such as Java and JavaScript.  The doc   and document   functions generally work as you would expect. Like many Microsoft prod- ucts  but unlike Saxon , they generally interpret ‘‘URI’’ in the speciﬁcations to mean ‘‘URI or Windows ﬁlename’’, so strings like «c:\temp\data.xml» are accepted in places where a URI is expected. There’s no ability to work with a user-supplied URI resolver or catalog to redirect URI references to local copies  if you need this, consider using the collection   function instead — see below .  If a schema can be found for the document, then the document is validated against it, but if no schema can be found, or if the document is not valid against the schema, then the call succeeds anyway and returns an untyped document. However, if no document can be found, or if the document is not well formed, then a fatal error is reported. As far as I can tell, the only reliable way of ensuring that a schema is found when validating input documents is to include a reference to the schema within the document itself, using an «xsi:schemaLocation» or «xsi:noNamespaceSchemaLocation» attribute. Importing a schema into the stylesheet isn’t enough. The same rules appear to apply to the principal input doc- ument to the transformation.  You might note the tentative prose in this paragraph — this area of the product is not well documented, and I had to do quite a few experiments to work out what it was doing.   G  A l t o v a  This means that if you want to force the input to be valid, you can use the instruction:     In this case, it seems that the schema must be imported into the stylesheet; identifying it within an «xsi:schemaLocation» attribute in the document that you are validating doesn’t work.  The collection   function in the 2008 release has been enhanced to provide facilities similar to the two ways of deﬁning a collection in Saxon. The collection URI can either identify an XML ﬁle used as a catalog to contain a list of the ﬁles in the collection, or you can specify a ﬁlename with wildcards; for example, «collection ’c: data *.xml’ » to process all the XML ﬁles in a directory. The default collection  the one you get when you call collection   with no arguments  is always empty.  AltovaXML only supports a single collating sequence, namely Unicode codepoint collation.  The Command Line Interface The command line interface to AltovaXML is very uncluttered. The product installs by default into the directory c:\Program Files\Altova\Altova\AltovaXML2008. It doesn’t add this directory to the PATH environment variable, so I will assume you have either done this by hand, or that you have made it your current directory. The command to transform a document is then:  AltovaXML -xslt2 style.xsl -in source.xml [-out output.html] [options]  1217   Altova  Apart from one option, -xslstack, which is used to control the amount of space allocated to variables on the stack, the options are used to provide parameters to the transformation  values for   declarations . The format is:  -param name=expression  where the -param keyword is repeated before each parameter. The value of the parameter is given in the form of an XPath expression, so for a boolean parameter you might write «-param debug=true  ». Unfortunately, this means you need to understand the way that the command line interpreter handles spaces and quotes. To supply a string value for a parameter, write it between single quotes; for example, «-param city=’Paris’». These quotes are the XPath quotes that surround a string literal. If the value contains a space, surround it with double quotes, for example «-param value="2 + 2"». These are directed at the command line interpreter. To supply a string value that contains a space, you need both sets of quotes, thus: «-param city=" ’Los Angeles’ "».  Using the API  AltovaXML offers three APIs, for COM, Java, and .NET applications. The underlying implementation is a COM object, and the Java and .NET interfaces are simply thin wrappers over the COM interface. The server is automatically registered as a COM object during product installation, but you can also register it  or unregister it  manually if you need to. See the reference manual for details. A single server supports concurrent clients, whether they are doing XML validation, XSLT processing, or XQuery processing.  The APIs are thoroughly documented in the reference manual that comes with the product. They are fairly straightforward. Generally, they take raw XML as input and produce raw XML as output; they don’t interface with other XML-related components such as the Microsoft or Java DOM. There is no attempt to conform to externally deﬁned API speciﬁcations such as JAXP in the Java world.  The COM API  A COM application starts by invoking:  Set altova = CreateObject "AltovaXML.Application"   This object contains four subsidiary objects available via its properties: their names are XMLValidator, XSLT1, XSLT2, and XQuery. Let’s look brieﬂy at the XMLValidator and XSLT2 objects.  XMLValidator  The XMLValidator is used to test whether an XML document is well formed, and whether it is valid against a schema and or DTD.  The source document can be loaded either by specifying a ﬁlename  or URI  or by supplying the XML content as a string, as shown in the following two examples:  Set altova = CreateObject "Altova.Application" ; altova.XMLValidator.InputXMLFileName = "c:\data\books.xml" altova.XMLValidator.InputXmlFromText = "   "  There are analogous properties to supply a DTD or a schema document either as a ﬁlename or as a string: DTDFileName, DTDFromText, SchemaFileName, SchemaFromText.  1218   Using the API  You can then test whether the document is well formed by using the IsWellFormed property, you can check it against a DTD or schema referenced from within the instance by using the IsValid property, and you can check it against an externally-supplied DTD or schema by using the property IsValidWith- ExternalSchemaOrDTD. I wasn’t able to ﬁnd in the documentation any way to return the document after validation  that is, with defaults expanded and with type annotations . There is a property, Last- ErrorMessage, which provides a rudimentary way of returning error information to the application.  XSLT2  The XSLT2 object similarly has properties to load the source document and stylesheet either by giving a ﬁlename  or URI  or by supplying the content as a string. These properties are InputXMLFileName, InputXMLFromText, XSLFileName, and XSLFromText.  You can specify the values of stylesheet parameters by calling the method AddExternalParameter. The value is supplied in the form of an XPath expression, which is evaluated with the input document as the context node. This means that if you want to supply a string as the value, you need to put it in quotes.  G  A l t o v a  There are two methods provided to run the transformation: Execute, which runs the stylesheet and serializes the result to a speciﬁed output ﬁle, and ExecuteAndGetResultAsString, which returns the serialized result as a string.  Putting this together, you can run a transformation like this:  Set altova = CreateObject "Altova.Application" ; altova.XSLT2.InputXMLFileName = "c:\data\books.xml" altova.XSLT2.XSLFileName = "c:\data\books.xsl" altova.XSLT2.AddExternalParameter "date" "current-date  " altova.XSLT2.Execute "c:\data\output.html"  The Java API  First step is:  The Java API is provided as a thin layer above the underlying COM engine. It makes no attempt to implement JAXP interfaces or to integrate with any other XML components in the Java environment: if you want to mix Altova processing with other components, the only way to interface them is via lexical XML  that is, XML stored as a ﬁle or as a string .  IAltovaXMLFactory factory = AltovaXMLFactory.getInstance  :  Following which you can get a validator or an XSLT 2.0 processor as follows:  XMLValidator validator =  XMLValidator factory.getXMLValidatorInstance  ; XSLT2 transformer =  XSLT2 factory.getXSLT2Instance  ;  The source document, schema, and stylesheet are supplied to these objects using methods that map directly onto the COM properties described earlier: setInputXMLFileName  , setInputXMLFromText  , setSchemaFileName  , setSchemaFromText  , setXSLTFileName  , setXSLTFromText  .  The schema validator supports the methods that map directly to the underlying COM object: isWell- Formed  , isValid  , isValidWithExternalSchemaOrDTD  , and getLastErrorMessage  .  Similarly the XSLT2 processor supports methods addExternalParameter  , execute  , executeAnd- GetResultAsString  , and getLastErrorMessage  .  1219   Altova  The .NET API  Summar y  One thing that requires a little care is the need to explicitly disconnect from the COM server when a task is ﬁnished. For this purpose, both the XMLValidator and the XSLT2 object provide a method release- Instance  . Unless you call this, the COM server will be left running. You can quickly ﬁnd yourself with multiple instances of this process tying up all your memory.  If the Java API is a thin layer over the COM interface, the .NET API is waif-like. In fact, when you get beyond the top-level marketing statements, there isn’t really a separate API at all; the way you call Altova from a .NET application is the same way that you invoke any other COM object, by making direct use of the .NET capabilities to call COM interfaces. Which, to be fair, is all that you need.  If you’re not familiar with how to import a COM object into a .NET application built using Visual Studio, the Altova documentation gives a helpful summary of the steps you need to take.  I’ve tried hard in this short appendix to stick to factual information about Altova’s product; it’s tempting at the end of the chapter to give a personal assessment, but it would inevitably be biased and I will resist the temptation. Try it out, and make your own judgment. Don’t make the mistake, however, of judging it solely from what people have said publicly about earlier releases: as I have stated, the level of conformance to the W3 C speciﬁcations has improved with each release and in the 2008 version looks quite solid.  At the time of writing, Altova, Gestalt, and Saxon are the only ﬁnished XSLT 2.0 processors on the market, so there’s no harm in trying all three and seeing how they compare against your particular requirements. They are very different products.  1220   H  l  G o s s a r y  Glossar y  This glossary gathers together some of the more common technical terms used in this book. Most of these terms are deﬁned in the XSLT or XPath speciﬁcations, but some of them are borrowed from XML or other standards in the XML family, and one or two have been invented for the purposes of this book. So for each deﬁnition, I also tell you where the term comes from.  The deﬁnitions in all cases are my own; in some cases, the original speciﬁcations have a much more formal deﬁnition, but in other cases they are surprisingly vague.  Where a deﬁnition contains references to other terms deﬁned in the glossary, these terms are written in italics.  Ancestor Axis  XPath  parent of the context node, its parent, and so on, up to and including the root node. This axis is a reverse axis.  The ancestor axis selects the  Attribute  XML  A name = value pair appear- ing in an element’s start tag; for example, «category="grocery"».  Ancestor-or-Self Axis  XPath  selects the context node followed by all the nodes on the ancestor axis. This axis is a reverse axis.  The ancestor-or-self axis  Attribute Axis  XPath  attributes of the context node. If the context node is not an element, the axis will be empty.  The attribute axis selects all the  The arity of a function is the number of Arity  XPath  parameters deﬁned in the function signature; for example, the arity of the function true   is zero, while the two versions of the contains   function have arity two and three, respectively.  Atomic Value  XPath  An atomic value is an item such as an integer, a string, a date, or a boolean. Speciﬁcally, it is an instance of the class xs:anyAtomicType, which includes all simple types  as deﬁned in XML Schema  that are not list types or union types.  Atomization  XPath  Atomization is a process that takes an arbitrary sequence, containing a mixture of nodes and atomic values, and creates a new sequence in which each of the nodes is replaced by its typed value. Atomic values appearing in the input sequence are retained in the result sequence unchanged.  Attribute Declaration  Schema  An attribute dec- laration is a schema component corresponding to an   element in a schema document: it deﬁnes constraints on the values of attributes having a particular name. It may be a global attribute declaration  if it is deﬁned at the top level of a schema  or a local attribute declaration  if deﬁned within the structure of a complex type .  Attribute Node  XPath  A node in a tree that repre- sents an attribute in an XML document. There will be an attribute node attached to an element node for each attribute deﬁned in the start tag of the corresponding element in the original XML document, other than an attribute act- ing as a namespace declaration. There will also be attribute nodes for attributes given a default value in the document type deﬁnition or schema. The string value of the node is the value of the attribute; its typed value is the result of   Glossary  validating the string value against the relevant type deﬁnition in a schema.  Attribute Set  XSLT  A named collection of   instructions, which when invoked using the use-attribute-sets attribute of   or  , or the xsl:use- attribute-sets attribute of a literal result element, generates a set of attribute nodes to be added to the result sequence.  Attribute Value Template  XSLT  An attribute value template is an attribute in the stylesheet that can con- tain both ﬁxed and variable parts. The ﬁxed parts are written as ordinary characters, while the variable parts are written between curly braces; for example, «file="{$dir}  {$fname}.html"» would evaluate to «file="out page.html"» if the variables $dir and $fname have the values «out» and «page», respectively. Attribute value templates can be used for any attribute of a literal result element, but on XSLT elements they can be used only for those attributes that explicitly allow them.  Axis  XPath  An axis is a direction of travel through the tree. Starting from a particular context node, an axis deﬁnes a list of nodes reached from that origin. For example, the ancestor axis returns the parent, grandparent, and so on up to the root of the tree, while the following sibling axis returns all the nodes that appear after the context node and share the same parent.  Every node has an associated base  Base URI  XPath  URI. For an element, this is the absolute URI of the XML external entity containing the element’s start and end tags  most often, of course, this will be the document entity . For other node types, it is deﬁned by reference to an asso- ciated element node, typically its parent. The base URI of an element can also be set explicitly by using the xml:base attribute. The base URI of a node is used when expanding a relative URI deﬁned in that node; for example, a relative URI in an href attribute is considered to be relative to the base URI of the parent element.  Every XPath expression also has a base URI deﬁned as part of its static context. For an XPath expression con- tained in a stylesheet, this is the base URI of the stylesheet element containing the XPath expression. In non-XSLT contexts, it’s up to the host environment to specify a base URI for the expression.  Boolean  XPath  One of the allowed data types for the value of an XPath expression. It takes the value true or false.  Built-In Template Rule  XSLT  A template rule that is not explicitly deﬁned in the stylesheet, but that is implicitly available to process a node if there is no explicit template rule that matches it.  The XML Schema speciﬁcation Built-In Type  Schema  deﬁnes a number of built-in simple types that are available for use, without any need to declare them in a schema. These include 19 primitive types  such as xs:string and xs:date , 20 built-in derived atomic types  includ- ing xs:integer and xs:ID , and 3 built-in list types  xs:NMTOKENS, xs:IDREFS, and xs:ENTITIES .  Cast  XPath  An expression that converts an atomic value of one type to an atomic value of a different type.  CDATA Section  XML  A sequence of characters in an XML document enclosed between the delimiters «![CDATA[» and «]]»; within a CDATA section all char- acters represent text content rather than markup, except for the sequence «]]».  Character Map  XSLT  A rule for translating characters in a result tree into different characters  or strings  in the serialized output.  Character Reference  XML  A representation of a char- acter using its decimal or hexadecimal Unicode value; for example, «&10;» or «&x21A4;». Normally used for characters that are difﬁcult or impossible to enter directly at the keyboard. Character references appear in lexical XML documents, but in the XDM data model, they are replaced by the characters that they represent.  The child axis selects all the imme-  Child Axis  XPath  diate children of the context node. These can include elements, text nodes, comments, and processing instruc- tions, but not attributes or namespace nodes. This is a forwards axis.  Codepoint  Unicode  A numeric value identifying a Unicode character.  Codepoint Collation  XPath  A collation that compares and sorts strings strictly according to the numeric values of the codepoints making up the characters of the string.  Collation  XPath  A set of rules for comparing strings. A collation can be used to decide whether two strings are equal, to decide how they should be ordered, and to decide whether one string is a substring of another. Different collations are needed to satisfy the needs of dif- ferent languages or different applications. In XPath and XSLT a collation is identiﬁed by a URI. Except for the codepoint collation, the URIs used to identify collations are deﬁned by the implementation.  Comment  XML  Markup in an XML document that is conventionally used to carry extraneous information that is not part of the document proper. Written between the delimiters « ».  Comment Node  XPath  A node in a tree representing an XML comment. The string value of the node is the text of the comment.  1222   Glossary  H  l  G o s s a r y  Complex Type  Schema  A schema type that describes the structure of elements that may have child elements or attributes. If the type permits attributes but not child elements, it is referred to as a complex type with simple content.  Constructor Function  XPath  A function that con- structs an atomic value of a particular type. The func- tion has the same name as the target atomic type, and always takes a single argument. A constructor function is created automatically for every atomic type, includ- ing user-deﬁned atomic types. An example of a call on a constructor function is «xs:date "2008-02-29" ». The semantics of constructor functions are deﬁned by reference to the rules for cast expressions.  The item currently being pro-  Context Item  XPath  cessed; part of the dynamic context. Certain XSLT instruc- tions and XPath expressions place a new context item on the stack, and revert to the previous context item when the instruction or expression has been evaluated. The XSLT instructions   and   change the context item, as do the XPath expressions «E1 E2» and «E1[E2]». The context item can be retrieved using the expression «.».  If the context item is a node, then Context Node  XPath  the context node is the same thing as the context item. If the context item is not a node, then the context node is undeﬁned.  Context Position  XPath  When a sequence of items is processed in an expression of the form «E1 E2» or «E1[E2]», or by an   or   instruction in XSLT, each item in the sequence in turn becomes the context item, and the context posi- tion identiﬁes the position of the context item in the sequence being processed. The context position determines the value of the position   function, and is also used in evaluating a numeric predicate such as «[1]».  Context Size  XPath  When a sequence of items is pro- cessed in an expression of the form «E1 E2» or «E1[E2]», or by an   or <xsl:apply- templates> instruction in XSLT, each item in the sequence in turn becomes the context item, and the con- text size identiﬁes the number of items in the sequence being processed. The context size determines the value of the last   function.  Current Mode  XSLT  When a template rule is invoked, the mode used in the   instruc- tion that invoked it is called the current mode. A further call of   within this template rule can specify «mode="current"» to continue pro- cessing in the current mode.  Current Template Rule  XSLT  When <xsl:apply- templates> selects a template rule to process a particu- lar node, that template rule becomes the current template rule. It remains the current template rule through calls of  , but not through calls of  . The current template rule is used only in deciding which template rule to invoke when   is called.  Data Model  XPath  The XDM data model is a descrip- tion of the kinds of objects that can be manipulated by XPath expressions, and their properties and relationships. Examples of such objects are sequences, items, atomic val- ues, nodes, and trees.  Sometimes the term data model is used loosely to refer to a speciﬁc object, such as the tree representation of a particular document .  Declaration  XSLT  A declaration is a top-level element in a stylesheet module  that is, a child element of the   element , other than a user-deﬁned data element, which is ignored by the XSLT processor.  This takes the Default Namespace Declaration  XML  form of an XML attribute xmlns="uri". It declares that within its scope, an element name with no explicit preﬁx will be associated with a particular namespace URI. The default namespace is used only for element names; other objects with no preﬁx  for example, attributes  have a null namespace URI.  The descendant axis selects Descendant Axis  XPath  all the children of the context node, their children, and so on, in document order. This is a forwards axis.  The descendant- Descendant-or-Self Axis  XPath  or-self axis selects the context node followed by all the nodes on the descendant axis. This is aforwards axis .  Document  XML  A parsed entity that conforms to the XML syntax for a Document is said to be a well-formed document; a document that also obeys the rules in its doc- ument type deﬁnition is said to be valid. In XSLT and XPath the term document is often used to refer to the tree repre- sentation of a document, that is, a document node together with all the nodes that have this document node as an ancestor.  The outermost element of Document Element  XML  a document, the one that contains all other elements. The XML standard also refers to this as the root element, but it must not be confused with the root node in the XPath tree model: the root node is usually the document node that is the parent of the document element, which represents the document itself.  Document Node  XDM  well-formed XML document, the root node will be a doc- ument node with exactly one element node as a child,  If the tree represents a  1223   Glossary  representing the document element, and no text nodes as children. In other cases, it may have zero or more element node children, and zero or more text node children: I refer to such a document as being well balanced. In both cases, the root node may also have comment nodes and processing instruction nodes as children.  The nodes in a sequence can  Document Order  XDM  always be sorted into document order. For elements from the same document, document order is the same as the order of the start tags in the original source. In terms of the tree structure, a node is ordered after its preceding sib- lings, and these are ordered after their parent node. The ordering of attribute and namespace nodes, and of nodes from different source documents, is only partially deﬁned.  The deﬁni- Document Type Deﬁnition  DTD   Xml  tion of the structure of an XML document, or a collection of XML documents. May be split into an external subset, held in a separate ﬁle, and an internal subset, embedded within the document itself.  The dynamic context of  Dynamic Context  XPath  an XPath expression is the total collection of information available to the XPath engine at evaluation time. This includes the context item, context position, and context size, the values of all variables, and the contents of all documents that can be accessed by their URI, using functions such as doc   and document  .  Dynamic Error  XPath  A dynamic error is an error detected during the evaluation phase, as distinct from a static error, which is detected at compile time. Technically, type errors  which may be detected either at compile time or at runtime  form a separate third category.  expanding any attribute value template; for example, given the instruction <xsl:message terminate="{$term}" >, the effective value of the «terminate» attribute is the value of the $term variable.  Element  XML  A logical unit within an XML doc- ument, delimited by start and end tags, for example  Wrox  ; an empty ele- ment may also be written in abbreviated form, for example  .  Element Declaration  Schema  An element decla- ration is a schema component that corresponds to an   element in a schema: it deﬁnes the struc- ture of elements having a particular name. It may be a global element declaration  if it is deﬁned at the top level of a schema  or a local element declaration  if deﬁned within the structure of a complex type .  Element Node  XDM  A node in a tree that represents an element in an XML document. The parent of the element node is either the containing element or the document node of the tree; its children are the element nodes, text nodes, comment nodes, andprocessing instruction nodes derived from the immediate content of the XML element.  Embedded Stylesheet Module  XSLT  A stylesheet module that does not constitute an entire XML doc- ument in its own right, but is embedded as an   element within some larger XML  or perhaps non-XML  document.  Empty Sequence  XDM  An empty sequence is a sequence containing no items. It can be written as «  » in XPath.  Dynamic errors deﬁned in XSLT are classiﬁed as being either recoverable or nonrecoverable. In the case of recov- erable errors, the processor is allowed either to report the error or to recover in a deﬁned way and continue processing, or both.  Entity Reference  XML  A reference to an internal or external entity, generally in the form «&name;». Note that numeric references of the form «&x20;» are cor- rectly referred to as character references rather than entity references.  The effective boolean Effective Boolean Value  XPath  value of an expression is used when the expression appears in a context where a choice needs to be made; for example, the condition in an XPath conditional expression or an XSLT   instruction. The effective boolean value of a sequence is false if the sequence is empty, or if it contains a singleton atomic value that is the boolean false, a zero-length string, a number equal to zero, or NaN; in most other cases, the effective boolean value is true. For some sequences  for example a sequence of more than one atomic value, or a single date , there is no effective boolean value, and using such an expression in a boolean context causes an error.  Effective Value  XSLT  an attribute in an XSLT stylesheet is the value after  The effective value of  Entity  XML  A physical unit of information that may be referenced within an XML document. Internal entities are embedded within the document in its Document Type Deﬁnition; external entities are generally held as a separate ﬁle. A parsed entity contains text with XML markup; an unparsed entity contains binary data. A general entity con- tains material for inclusion in the document; a parameter entity contains material for inclusion in the Document Type Deﬁnition.  The term QName is Expanded QName  XDM  sometimes used to mean a QName as written in source XML documents, that is a construct of the form «prefix:local-name», and it is sometimes used to mean the  namespace-uri, local-name  pair that this represents. Within the XSLT 2.0 and XPath 2.0  1224   Glossary  H  l  G o s s a r y  speciﬁcations the preferred usage is lexical QName for the ﬁrst construct, and expanded QName for the second. These terms are not consistent across the full range of XML speciﬁcations.  There is no standard convention for displaying an expanded QName, though in some interfaces such as JAXP, expanded QNames are written in the form «{namespace-uri}local-name». This is sometimes referred to as Clark notation.  Expression  XPath  An XPath construct that can be evaluated to yield a value, which will always be a sequence  of nodes and or atomic values . In XSLT, expres- sions are used in many contexts such as the select attribute of  ,  , and  , and the test attribute of   and  . Expressions are also used between curly braces in attribute value templates.  Extension Attribute  XSLT  An attribute in a vendor- or user-deﬁned namespace used on an XSLT element in the stylesheet. Such attributes may be used to control behavior that would otherwise be implementation deﬁned, or to provide extra control over serialization.  Extension Function  XSLT  A function deﬁned by a product vendor, a user, or a third party, which can be called from within an XPath expression. The XSLT speciﬁ- cation deﬁnes how extension functions are called but not how they are implemented.  Extension Instruction  XSLT  An element within a sequence constructor that is deﬁned by a product vendor, a user, or a third party but otherwise behaves like an XSLT instruction. The XSLT speciﬁcation deﬁnes how extension instructions are evaluated but not how they are imple- mented. In XSLT 1.0, extension instructions were referred to as extension elements.  Facet  Schema  A facet is a constraint placed on the values of a simple type in the schema. For example, the pattern facet  not to be confused with XSLT patterns  constrains the value to match a given regular expression, while the maxInclusive facet deﬁnes the largest per- mitted value.  Final Result Tree  XSLT  A tree that is constructed by a stylesheet and acts as an output of the transformation  as distinct from a temporary tree that can be further processed by the transformation .  Following Axis  XPath  the nodes that follow the context node in document order with the exception of attribute and namespace nodes, and the node’s own descendants. This is a forwards axis.  The following axis selects all  Following Sibling Axis  XPath  axis selects all the nodes that follow the context node in  The following sibling  document order and that share the same parent node. This is a forwards axis.  Forwards Axis  XPath  An axis containing a sequence of nodes that follow the context node in document order. Within a predicate of an axis step that uses a forwards axis  for example, «following-sibling::x[3]» , position numbers count the nodes in document order.  Function  XPath  A procedure that can be called from within an XPath expression; it takes arguments and returns a result. Functions cannot be deﬁned using XPath, only invoked from XPath. A function is either a core func- tion deﬁned in the XPath or XSLT recommendations, or a stylesheet function deﬁned using an   declaration in XSLT, or an extension function provided by the vendor or the user. Functions may also be deﬁned using XQuery. A function has a name  which is a QName , a signature deﬁning the types expected for its arguments and the return type, and an implementation.  Global Variable  XSLT  A variable deﬁned in a top-level   element. Global variables are available anywhere in thestylesheet  including in other stylesheet modules , unless masked by a local variable or range variable of the same name, or a global variable of the same name and higher import precedence.  ID  XML  An attribute of type ID has a value that is unique within the document  that is, different from any other ID attribute . It is an ID by virtue of being declared as such in the DTD or Schema, or by being named xml:id. It is guaranteed to be unique only if the document is valid  XSLT is not constrained to operate only on valid docu- ments . Elements can be accessed using their ID by means of the id   function.  Import Precedence  XSLT  A stylesheet module that is loaded using   has lower import prece- dence than the stylesheet module doing the importing. The import precedence affects all the top-level declara- tions in that stylesheet, and is used when deciding which top-level elements to use. For example, if two global vari- ables have the same name, the one with higher import precedence is used.  The ﬁrst template to be evalu- Initial Template  XSLT  ated when a stylesheet is activated. This may be deﬁned by nominating a named template from the invoking API, or it may be selected by applying template rules to an ini- tial node supplied in the API  typically, by default, the document node of the principal source document .  In-Scope Namespaces  XPath  Any element node has a set of namespace declarations that are in scope for the ele- ment: these are represented by the namespace nodes for that element. An XPath expression also has a set of in-scope namespaces in its static context. For XPath expressions  1225   Glossary  in an XSLT stylesheet module, the in-scope namespaces for the expression are the namespaces that are in-scope for the element in the stylesheet that contains the XPath expression, augmented with the namespace deﬁned in the [xsl:]xpath-default-namespace attribute if present. In non-XSLT contexts, it is up to the host envi- ronment to deﬁne how the static context for an XPath expression is established.  Instruction  XSLT  One of a number of XSLT ele- ments that is permitted to appear directly within a sequence constructor; for example,  ,  , and  . Not all XSLT elements are instructions; for example   and   are not; this is because these can appear in a deﬁned context only.  Item  XDM  An item is either an atomic value or a node.  Item Type  XPath  An item type describes the type allowed for items within a sequence. This is either item  , which allows any item; an atomic type; or a node type. Node types deﬁne the kind of node  for example element, attribute, or comment  plus, optionally, constraints on the name of the node and on its type annotation, which will always be a schema type.  Lexical QName  XPath  A QName written in its lexi- cal form: either a simple unpreﬁxed name or a construct of the form «prefix:local-name». See also expanded QName.  List Type  Schema  A simple type that allows a space-separated sequence of values to be written. For example, the type xs:NMTOKENS permits the value "red green blue". When an element or attribute is annotated with a list type, its typed value in XPath is a sequence con- taining the individual items.  Literal Result Element  XSLT  A literal result element is an element appearing within a sequence constructor in a stylesheet that is not an XSLT instruction or an extension instruction. When the sequence constructor is evaluated a new element node is added to the result sequence, and its content  which is also a sequence constructor  is evaluated to form the content of the newly constructed element.  Local Variable  XSLT  A variable deﬁned within a sequence constructor. A local variable is accessible only from the following siblings of the   ele- ment that deﬁnes the variable, and from their descendants. This is analogous to the normal rule in block-structured programming languages.  Mode  XSLT  Modes partition the set of template rules in a stylesheet, so that the same nodes can be processed more than once using different rules each time. The mode named on the call of    must match the mode named on the   element that is invoked.  Named Template  XSLT  An   ele- ment in the stylesheet with a name attribute. A named tem- plate may be invoked using an   instruction.  Namespace  XML Namespaces  A named collection of names. The namespace is named using a URI  or in the 1.1 speciﬁcation, an IRI , which is intended to be formed in such a way as to ensure global uniqueness, but which, in practice, may be almost any string. Within a particular region of a document, a namespace is also identiﬁed by a shorthand name called a preﬁx; different preﬁxes can be used to refer to the same namespace in different doc- uments or even within the same document. A name  of an element or attribute in XML, and of a variable, template, function, mode, and so on in XSLT  belongs to a speciﬁc namespace, and two names can be considered equivalent only if they belong to the same namespace.  The namespace axis selects Namespace Axis  XPath  all the namespace nodes belonging to the context node. If the context node is not an element node, the axis will be empty. For element nodes, there is one namespace node for every namespace that is in scope for the element, whether it relates to a namespace declaration that was deﬁned on this element or on a containing element. This is a for- wards axis. The namespace axis is retained in XPath 2.0, but it is deprecated: applications requiring namespace information should instead use the functions in-scope- prefixes   and namespace-for-prefix  .  Namespace Declaration  XML Namespaces  A con- struct in an XML document that declares that within a particular region of the document, a given namespace preﬁx will be used to refer to the namespace with a partic- ular URI. There are two forms of namespace declaration: xmlns="uri" to declare the default namespace  the one with a null preﬁx , and xmlns:prefix="uri" to declare a namespace with a non-null preﬁx. Both are written in the form of XML attributes and apply to the element they are on and all descendant elements, unless overridden.  Namespace Fixup  Xslt  Namespace ﬁxup is the pro- cess of adding namespace nodes to a newly constructed element node to ensure that all the namespaces actually used by the element are properly declared.  Namespace Node  XPath  A node in a tree that repre- sents the binding of a namespace preﬁx to a namespace URI. A namespace node belongs to an element called its parent: it applies only to that element and not to any descendant elements.  Namespace Preﬁx  Xml Namespaces  A short name used to identify a namespace within a particular region  1226   Glossary  H  l  G o s s a r y  of an XML document, so called because it is most often used as the preﬁx of a lexical QName  the part before the colon . Different preﬁxes can be used to identify the same namespace, and in different contexts the same preﬁx can be used to identify different namespaces.  Namespace URI  XML Namespaces  A URI used to identify a namespace. Namespace URIs are unusual in that there is no actual resource that can be obtained using the URI; the URI is simply a unique identiﬁer. In prac- tice, any string can be used as a namespace URI, though «http:  » URLs are often used to give some prospect of uniqueness. Technically, the XML Namespaces spec- iﬁcation refers to this concept as a namespace name, and in version 1.1 the namespace name can be an IRI, which unlike a URI allows non-ASCII characters. However, the term namespace URI is in widespread use despite the fact that practical products allow any string to be used.  NaN  XPath  Not a number. This is one of the possible values of a variable whose data type is ﬂoat or double. It results from an operation whose result is not numeric, for example «number ’apple’ ».  Node  XDM  An object forming part of a tree. There are seven kinds of node: attribute nodes, comment nodes, document nodes, element nodes, namespace nodes, processing instruction nodes, and text nodes. Nodes have properties including a name, a string value, a typed value, and a base URI. Every kind of node except a document node may have a parent node; document nodes and element nodes may have children; element nodes may have attributes and namespaces.  Node Kind  XDM  Nodes are classiﬁed into seven kinds: attribute nodes, comment nodes, document nodes, ele- ment nodes, namespace nodes, processing instruction nodes, and text nodes.  In XPath 2.0, the term number is used  Number  XDM  as a generic term for the three primitive types deci- mal, double, and float, and their subtypes  including integer .  Output Method  XSLT  XSLT 2.0 deﬁnes four out- put methods, xml, html, xhtml, and text. The output method controls the way in which the result tree is output  or serialized  as a stream of characters or bytes.  Parameter  XSLT  A variable whose value is sup- plied by the caller. A stylesheet parameter is a global variable whose value can be set  in a vendor-deﬁned way  when the stylesheet is executed. A template parameter is deﬁned within an   element, and its value can be set when the tem- plate is invoked using   or  . A function parameter is  deﬁned within an   element, and is set by evaluating the arguments in an XPath function call.  The parent axis selects the node Parent Axis  XPath  that is the parent of the context node, assuming it has a parent. Since this axis selects at most one node, it doesn’t matter whether it is considered as a forwards axis or as a reverse axis.  In the language of XML Schema, Particle  Schema  a particle is a component part of the deﬁnition of the structure of a complex type. A particle may be an ele- ment declaration, or a wildcard that allows elements from deﬁned namespaces, or a sequence or choice compositor with a deﬁned substructure.  Path Expression  XPath  A path expression is an expression that selects a sequence of nodes in a tree. It deﬁnes a sequence of steps that deﬁne navigation paths from the context node to further nodes. The ﬁnal result is the sequence of nodes reached by following each of the steps in turn. For example, the path expression «.. @code» has two steps: the ﬁrst step selects the parent of the context node, and the second step selects the «code» attribute of the selected parent. The nodes in the result of a path expression are always returned in document order, with duplicates removed.  Pattern  XSLT  A construct that deﬁnes a condition that a node either satisﬁes or does not satisfy. The syn- tax for a pattern is a subset of the syntax for an XPath expression. Patterns are used in only four XSLT elements:  ,  ,  , and  .  Precedence  XSLT   See Import Precedence.  The preceding axis selects all Preceding Axis  XPath  the nodes that precede the context node within the same tree, with the exception of attribute and namespace nodes, and the node’s own ancestors. This is a reverse axis.  The preceding sibling Preceding Sibling Axis  XPath  axis selects all the nodes that precede the context node and that share the same parent node. This is a reverse axis.  Predicate  XPath  An expression used to ﬁlter which nodes are selected by a particular step in a path expression or to select a subset of the items in a sequence. A boolean expression selects the items for which the predicate is true; a numeric expression selects the item at the position given by the value of the expression, for example «[1]» selects the ﬁrst item.  Preﬁx  XML Namespaces   See Namespace Preﬁx.  Primitive Type  Schema  iﬁcation deﬁnes 19 primitive types. In the XPath model these are deﬁned as subtypes of the abstract type xs:anyAtomicType, which contains all atomic  The XML Schema spec-  1227   Glossary  values. The 19 primitive types are boolean, string, decimal, double, float, QName, anyURI, hex- Binary, base64Binary, date, time, dateTime, gYear, gYearMonth, gMonth, gMonthDay, gDay, duration, and NOTATION. XPath in effect adds untypedAtomic to this list, representing values that have not been validated against any schema.  Every axis has a prin- Principal Node Kind  XPath  cipal node kind. For most axes, the principal node kind is elements. For the attribute axis, the principal node kind is attribute, and for the namespace axis, it is name- space. The principal node kind determines the kind of nodes selected by the node test «*»; for example, «following-siblings::*» selects elements, while «namespace::*» selects namespace nodes.  Every template rule has a priority.  Priority  XSLT  The priority is expressed as a number  which may be a decimal number such as «3.5» . The priority may be speciﬁed explicitly, using the priority attribute of the   element; if it is omitted a default pri- ority is allocated based on the pattern. The priority is used to decide which template rule to evaluate when several template rules match the same node: a rule with numer- ically higher priority is used in preference to one with lower priority.  Processing Instruction  XML  An item in an XML doc- ument that is conventionally used to carry instructions to the software that receives the document and processes it. Written between the delimiters «‹?» and «?›». Note that the XML declaration at the start of a document, and the text declaration at the start of an external parsed entity, are not processing instructions even though they use the same delimiters.  Processing Instruction Node  XDM  A node in a tree representing an XML processing instruction.  The type-checking rules for func-  Promotion  XPath  tion calling in XPath, and also for arithmetic operators and comparison operators, allow numeric values to be used where a different numeric type is expected. The operation of converting the supplied number to the required type  for example, integer to double  is known as promotion. Similarly, any URI values can be promoted to string values.  QName  XML Namespaces  A qualiﬁed name. It is either a simple name  an NCName  or a name preceded by a namespace preﬁx and a colon. See also lexical QName and expanded QName.  Range Variable  XPath  A variable declared in a «for», «some», or «every» expression, which is bound to each item in a sequence in turn; for example, the variable $i in «for $i in 1 to 5 return $i*$i».  Regular Expression  XPath  A regular expression is a pattern that strings may or may not match. Regular expressions can be used in the three functions matches  , replace  , and tokenize   deﬁned in XPath, and in the   instruction in XSLT. Regular expressions also appear in the pattern facet of simple type deﬁnitions in XML Schema.  The output of a stylesheet. A  Result Tree  XSLT  stylesheet deﬁnes a transformation from a source tree to a result tree. XSLT 2.0 allows multiple result trees to be created. The ﬁnal stage of processing is normally to serialize the result tree as a stream of characters or bytes; this is controlled by the selected output method.  Reverse Axis  XPath  An axis containing a sequence of nodes that precede the context node in document order. Within a predicate of an axis step that uses a reverse axis  for example, «preceding-sibling::x[position   = 1 to 3]» , position numbers count the nodes in reverse document order. However, as with any other axis step, the result of the expression is in forwards document order. So this expression returns the last three «x» nodes before the context node, in document order.  The topmost node in a tree; any node Root Node  XPath  that has no parent. In XPath 2.0, any kind of node may be a root node. A root node that represents a complete XML document is now referred to as a document node.  In this book the term schema, unless  Schema  Schema  otherwise speciﬁed, always means a schema deﬁned using the W3 C XML Schema language. A schema can be regarded as a collection of element declarations, attribute declarations, andtype deﬁnitions . A schema doc- ument, by contrast, is the XML document rooted at an   element  which one might regard as con- taining one module of a schema .  Schema Component  Schema  A generic term for ele- ment declarations, attribute declarations, and type deﬁnitions.  Schema Type  XDM  A type as deﬁned in XML Schema: either a complex type or a simple type. The type may be named, or it may be anonymous. The term includes both built-in types  such as xs:integer  and user-deﬁned types.  The self axis contains a single node,  Self Axis  XPath  the context node. It makes no difference whether it is regarded as a forwards axis or a reverse axis. The princi- pal node kind of the self axis is elements, which means that when the context node is an attribute, an axis step of the form «self::*» or «self::xyz» will not select that attribute.  Sequence  XPath  A sequence in the XPath data model is an ordered collection of items. The items may be atomic values or references to nodes in a tree. A sequence  1228   Glossary  H  l  G o s s a r y  containing no items is referred to as the empty sequence. Sequences have no identity of their own; two sequences containing the same items cannot be distinguished.  Sequence Constructor  XSLT  A sequence of XSLT instructions, extension instructions, literal result elements, and text nodes, forming the content of an   element or of various other ele- ments in the stylesheet. When the sequence constructor is evaluated, any instructions and extension instructions are evaluated according to the rules for each one, while any literal result elements and text nodes are copied to the result sequence. In most cases, the result sequence will be used to form the content of a new node in a result tree, but this depends on the instruction that contains the sequence constructor.  Sequence Type  XPath  A sequence type is a deﬁni- tion that constrains the permitted values of a sequence. It has two parts: an item type, which constrains the type of the items in the sequence, and a cardinality, which constrains the number of items in the sequence. The car- dinality may be zero-or-one, exactly-one, zero-or-more, or one-or-more.  Serialization is the reverse of  Serialization  XSLT  parsing: it takes a document represented as a tree in the XPath data model, and converts it into a lexical XML document.  Simple Type  Schema  A simple type in XML Schema describes values that can be written as text, with no embedded markup. Simple types divide into atomic types, list types, and union types. Attributes always have a simple type; the content of an element may be either a simple or a complex type. XML Schema deﬁnes a number of built-in simple types, but further simple types can be deﬁned in a user-written schema.  Simpliﬁed Stylesheet Module  XSLT  A simpliﬁed stylesheet module is a stylesheet module consisting solely of a literal result element which is evaluated using the root of the source document as the context node.  Source Document  XPath  ument is the XML document to which the stylesheet is being applied. Secondary source documents can be loaded using the document   function.  The principal source doc-  Every expression  and sub-  Static Type  XPath  expression  has a static type. This is a sequence type, representing the best possible inference that can be made about the dynamic type of the value that will be returned when the expression is evaluated. For example, the static type of the expression «@*» might be «attribute  *». In an XPath processor that implements strict static typing, a type error will be reported if the static type of an expres- sion is not a subtype of the type required by the context in which the expression is used.  Step  XPath  A step is used within a path expression to navigate from one node to a sequence of related nodes. The most common kind of step is an axis step, which is deﬁned by an axis, giving the direction of navigation; a node test, which deﬁnes constraints on the type of and names of the target nodes; and zero or more predicates, which deﬁne arbitrary constraints that the target nodes must satisfy.  String  XPath  One of the allowed data types for the value of an XPath expression. It is a sequence of zero or more Unicode characters  the same character set as is used in XML .  Every node has a string value. For  String Value  XDM  a text node the string value is the textual content; for an element it is the concatenation of the string values of its descendant text nodes  that is, the textual content of the element after stripping all markup . The string value of a node can be obtained using the string   function.  Stylesheet  XSLT  A stylesheet represents the contents of one or more stylesheet modules, consisting of a principal stylesheet module and other modules that are reachable from the principal module using   and   declarations.  Stylesheet Function  XSLT  A function deﬁned in a stylesheet using an   declaration. Like other functions, a stylesheet function is called using a func- tion call in an XPath expression.  Stylesheet Module  XSLT  A stylesheet mod- ule is deﬁned by a single   or   element, usually comprising the whole of an XML document, or it may be a simpliﬁed stylesheet whose root is a literal result element with an xsl:version attribute.  The static context of an XPath Static Context  XPath  expression is the total collection of information available to the XPath engine at compile time. This includes the namespace declarations that are in scope, the names and types of declared variables, the base URI of the expression, and the collations that are available.  Static Error  XPath  A static error is an error detected during the analysis phase, that is, at compile time.  Tag  XML  Often used incorrectly to mean element. An element  ...  has two tags, the start tag   and the end tag  . Empty elements may be written with a single tag  .  Template  XSLT  An   element in the stylesheet, together with its content. See also named template.  XSLT 1.0 had a different deﬁnition for this term, but XSLT 2.0 has bowed to popular usage.   1229   Glossary  Template Rule  XSLT  An   dec- laration in the stylesheet with a match attribute. A template rule may be invoked using the <xsl:apply- templates> instruction; for each selected node, the appropriate template rule is determined based on a number of criteria, including the match pattern and the template rule’s import precedence and priority.  Temporary Tree  XSLT  A tree constructed in the course of processing a stylesheet, by evaluating a nonempty   element. The value of the variable is the document node at the root of the temporary tree.  Text Node  XDM  A node in a tree representing char- acter data  called PCDATA in XML  within an XML document. Adjacent text nodes will always be merged into a single node. Character references and entity references occurring within the original text will have been replaced by their expansions.  Top-Level Element  XSLT  An element in a stylesheet that is an immediate child of the   element.  Tree  XDM  An abstract data structure representing the information content of an XML document. The tree always has a single root node  which contrary to the botanical analogy, is always depicted at the top . The structure of nodes in the tree need not follow the rules for a well-formed document in XML; for example, there may be several ele- ment nodes as children of the root. In XPath 2.0 the root of a tree need not be a document node. It is possible to have an element node as the root. It is also possible for any other kind of node  for example, an attribute node  to be par- entless, in which case it acts as the root of a tree in which it is the only node.  Tunnel Parameter  XSLT  A tunnel parameter is a parameter to an XSLT template that is passed transpar- ently via any called templates until eventually reaching the template that actually uses its value.  In the context of XPath values, the term Type  XPath  type means sequence type. In the context of nodes validated against a schema, it means schema type.  Every element node and  Type Annotation  XDM  attribute node has a type annotation. The type annota- tion identiﬁes a schema type, which may be a simple type or a complex type. Type annotations are added to nodes as a consequence of validation against a schema. An element node that has not been validated against any schema is annotated with the special type xs:untyped, while an attribute node that has not been validated is annotated as xs:untypedAtomic.  Type Deﬁnition  Schema  A type deﬁnition is a schema component that deﬁnes a simple type or a complex type.  The typed value of a node is Typed Value  XDM  in general a sequence of atomic values. It represents the result of analyzing the textual content of the node against the schema deﬁnition for that node, during the process of validation.  Type Error  XPath  A type error occurs when the value used as input to some operation is not of the type required by that operation; for example, when a string is used as an argument to an arithmetic operator. Type errors may be detected either at compile time or at runtime. A sys- tem that implements strict static type checking will report type errors at compile time pessimistically, that is, it will report an error if there is any possibility that the runtime value will have the wrong type.  Unparsed Entity  XML  An unparsed entity is an entity declared in the document type deﬁnition with an associ- ated notation. Such entities are unparsed because they generally contain binary data such as images, rather than XML. Two functions, unparsed-entity-uri   and unparsed-entity-public-id  , are available in XSLT to access the unparsed entities associated with a source document. However, it is not possible to create unparsed entities in a result document.  Union Type  Schema  A union type is a simple type that allows a choice of alternatives. For example, a union type might allow an attribute to contain either a decimal value, or the string "N A".  URI  RFC 3986  Uniform Resource Identiﬁer: a gener- alization of the URLs  Uniform Resource Locators  used to uniquely address resources such as Web pages on the Internet.  Validation  XSLT  Validation in XSLT 2.0 is the pro- cess of assessing a tree against a schema. If the tree is not valid against the schema, the transformation fails; if it is valid, then each element node and attribute node in the tree acquires a type annotation identifying the schema type against which it was found to be valid.  Variable  XPath  A named value. Variables in XPath and XSLT differ from variables in procedural program- ming language in that there is no assignment statement.  The declaration of a variable, Variable Binding  XSLT  in an   or   element, in conjunction with the current value of that variable.  Variable Reference  XPath  A reference to a variable within an expression, in the form $name.  Well-Balanced  XML Fragment Interchange  An XML fragment is well-balanced if there is an end tag that matches every start tag. This is a less strict constraint than being well formed: a well-balanced fragment does not have to have a single element that encloses all the others. XSLT  1230   Glossary  and XPath are deﬁned so that they will work on any trees representing a well-balanced XML fragment. The XML and XSLT standards don’t use this terminology; instead they refer to the rules for an external general parsed entity.  Well Formed  XML  A document is well formed if it follows the syntax rules in the XML speciﬁcation. These include the rule that there must be a single outermost ele- ment that encloses all others. The XML output of an XSLT stylesheet is not required to be well formed, only to be well balanced.  Whitespace  XML  Whitespace is any contiguous sequence of tab, carriage return, newline, and space char- acters. A whitespace node is a text node whose string value  consists solely of whitespace.  The XML speciﬁcation spells this as two words, white space, but I prefer a single word, because using white as a qualifying adjective sug- gests that white space is to be contrasted with red space and green space, which of course is not the case.   XDM The data model used by XSLT, XPath, and XQuery. Every value in XDM is a sequence of items; an item is either an atomic value or a node.  XPath 1.0 Compatibility Mode  XPath  A mode of exe- cuting XPath 2.0 expressions that attempts to provide the maximum possible level of backward compatibility with XPath 1.0. In XSLT, this mode is selected by specifying «version="1.0"» in the stylesheet.  H  l  G o s s a r y  1231    x e d n  I  Index  SYMBOLS  «{}»  curly brackets . See curly brackets «   ».  empty sequence . See empty sequence «[ ]»  square brackets . See square brackets « ». Seealso «\»  backslash  binary operator, 602–606  associativity of, 605–606 axis steps and, 603 context node and, 603 context position and, 603 context size and, 603, 821, 855 document nodes and, 617 effect of, 603–604 examples, 604–605 as higher-order operator, 603, 604 last   and, 605 position   and, 605 steps creating new nodes in, 605 type error and, 603 different roles of, 623 disambiguation of, 543 division and, 572 in expression context, 538, 621 operator, 57, 83, 538  deduplication and, 544 simple mapping expressions and, 599, 601, 644 sorting and, 544  in parentheses, 624 pattern, 692 patterns starting with, 689 as root expression. See root expressions as rooted path expression. See rooted path  expressions  simple mapping expressions and, 599, 601 syntactic ambiguities, 623–624  « ..», 623. Seealso empty sequence «  »  « descendant::» compared with, 628 examples, 627–628 expensiveness of, 627 inﬁx operator, 627 leading, 691 pseudo-operator, 602, 626–628  «.» and, 544 last   function and, 703 positional predicates and, 627  position   and, 703 rooted path expressions and, 625  XML databases and, 627  «\»  backslash , 920  character class escapes and, 920–922 in embedded XPath, 528 in regex, 916 in replace  , 863  «\C»  multicharacter escape , 233, 921 «\c»  multicharacter escape , 233, 237, 921 «\D»  multicharacter escape , 233, 921 «\d»  multicharacter escape , 233, 921 «\I»  multicharacter escape , 233, 921  XML 1.0  XML 1.1, 921  «\i»  multicharacter escape , 233, 237, 921  XML 1.0  XML 1.1, 921  «\S»  multicharacter escape , 233, 921 «\s»  multicharacter escape , 233, 921  matching with whitespace, 921  «\W»  multicharacter escape , 233, 921 «\w»  multicharacter escape , 233, 921 «\P{prop}»  complementary escape , 233, 922 «\p{prop}»  category escape , 233, 922 «&apos;»  entity reference , 528, 532, 533, 939 «&quot;»  entity reference , 528, 532, 533 «&x09;»  entity reference , 528 «$»  as regex metacharacter, 233, 926. Seealso  metacharacters  in replacement string, 863 in variable references, 429, 528, 540  «.» symbol  «  » and, 544 context item expression, 84, 269, 564, 620, 621 ContextItemExpr, 269, 528, 543–544 decimal point, 528, 789 different roles of, 528 function body and, 544 regex metacharacter. See metacharacters separator character, 528 as thousands separator, 301 undeﬁned, 544  «,» symbol  as decimal point, 301–302 as grouping-separator. See grouping-separator as operator. See comma operator   «?» symbol  «?» symbol  «cast as» and, 655 «castable as» and, 655 occurrence indicator, 163, 179, 547, 669  empty sequence and, 713 optional argument v. argument with, 713  quantiﬁer  regex , 917–918. Seealso quantiﬁers   regex   «*?« quantiﬁer  regex , 232. «+?» quantiﬁer  regex , 232. «»  xsi:nil and, 673  ‘‘or” as, 75 Pattern construct and, 690 union operator. See «union» operator  «*»  different roles of, 538 expression context, 538 multiplicative operator, 83, 133, 200, 538, 571  on durations, 579 precedence, 572  NameTest, 440, 696 NodeTest, 617 occurrence indicator, 163, 179, 547, 669 quantiﬁer  regex . See quantiﬁers  «*?» quantiﬁer  regex , 232. Seealso quantiﬁers   regex   «+»  additive operator, 83, 133, 216, 554, 571  binary, 572 date time plus duration, 578–579 precedence, 572 sum   and, 889 unary, 572, 639  character, 528 leading sign  number   and, 851  occurrence indicator, 505, 669 quantiﬁer  regex . See quantiﬁers   regex   «-»  additive operator, 200, 571  date time plus duration, 578–579 precedence, 572  hyphen. See hyphens minus operator  binary, 572 on date time values, 580 unary, 200, 530, 572  minus-sign. See minus-sign name character, 528 need for whitespace and, 538  «every» expression and, 649 existential properties of, 279  1234  «=» operator, 186, 200, 203, 538, 555, 571  GeneralComp, 582 not   and, 850–851 quantiﬁcation and, 648–649 «some» expression and, 649  «!=» operator, 200, 203, 538, 555, 571, 584  GeneralComp, 582 not   and, 850–851 usage avoidance of, 584, 591  «<», 200, 203, 204, 538, 555, 571  character, 527 escaped as «&lt;», 538, 588 GeneralComp, 582  «<=» operator, 200, 203, 538, 555, 571  GeneralComp, 582  «>», 200, 203, 204, 538, 555, 571  escaped as «&glt;», 538 GeneralComp, 582  «>=» operator, 200, 203, 538, 555, 571  GeneralComp, 582  «&gt;», 444, 538 «&lt;», 492, 493, 496, 527, 538  «<» escaped as, 538, 588 «<<» operator, 57, 571, 594  description of, 594 document order and, 593, 594 NodeComp, 582  «>>» operator, 57, 571, 594  description of, 594 document order and, 593, 594 NodeComp, 582  «@»  attribute axis , 83, 621, 622. Seealso attribute  axis  self axis and, 622  «@*», 622 «"»  attribute value , 64 « »  copyright symbol , 365 «..»  parent axis , 621, 623. Seealso parent axis  «ˆ»  regex metacharacter . See metacharacters «!»  separator in jar URI scheme , 868 «3 »  superscript three , 849 «2 »  superscript two , 849 «&nbsp;», 64, 281, 367, 938. Seealso nonbreaking  space characters  «&» ampersand, 425  curly braces and, 937 in URLs, 937  «'» attribute value, 64 «», fractional part of number and, 790 «::» separator, 83 « &x20;» character reference, 142, 143 24:00:00 time value, 743 «A», 782  «+?» quantiﬁer  regex , 232. Seealso quantiﬁers  XPath 1.0 and, 623   anyURI  x e d n  I  AltovaXML processor, 10, 15, 93, 143, 1215–1220.  Seealso examples, running; XMLSpy development environment  ˚Angstrom symbol v., 849 character normalization and, 848  «a»  Italian ordinal , 407 «α, β, γ , δ» Greek numbering sequence, 409  « ˚A»  A  AbbrevForwardStep construct, 621 abbreviated axis steps, 599, 621–625  root expressions v., 624. Seealso root expressions  abbreviated path expressions, 599 AbbrevReverseStep construct, 621 absence of preﬁx  QNames , 533, 766, 866 absence of timezone, 567 abs   function, 200, 714–715 absolute path expressions, 625. Seealso rooted path  expressions  absolute URIs, 58, 100, 193, 357, 373, 755  in href attribute, 100, 357 resolve-uri   and, 867–869 absolute value of number, 714 abstract types, 163 accents, 202, 462, 561, 731  and diacritics in NFC, 880, 884 Latin letters with, 534  accountancy  parentheses for negative numbers, 301, 790 rounding rules, 790, 873  actions from meeting, numbering of, 415 Adams, Colin, 962. Seealso Gestalt processor add_extension_function_library    Gestalt , 962 addition, of durations, 577, 579. Seealso totals,  numeric values durations  additive operators, 200. Seealso «+» AdditiveExpr construct, 525, 572 adjacent bullets, 335 adjacent elements, repeating groups of, 338–340 adjacent strings, separator between, 258 adjacent text nodes, 143, 258, 304, 309, 496 adjust-dateTime-to-timezone   function, 715–718 adjust-date-to-timezone   function, 715–718 adjusting timezone  xs:date xs:dateTime , 297 adjust-time-to-timezone   function, 205, 715–718 Adler, Sharon, 26 aggregate functions, 200, 332, 350. Seealso avg  ;  count  ; max  ; min  ; sum    aggregating list of numbers  example , 993–995 algorithm for URI resolution, 867 aliasing. Seealso xsl:namespace-alias  of namespace URIs, 396 for XML namespace, 397  all, 242, 485, 486 alphabet example, 122–123 alphanumeric  term , 407 alternate attribute    , 101  collection   and, 727, 1217 COM API, 1218–1219 command line interface, 1217–1218 conformance, 1216 control over doc   invoking validation, 671 extension instructions and, 476 extensions extensibility, 1217 input-type-annotations and, 478 Java API and, 1219–1220 MSXML and, 1216 .NET API and, 1220 validating source document on, 169, 1218 validation request, 166, 1218 whitespace and, 1216 XMLValidator, 1218–1219 xsi:schemaLocation attribute and, 671, 1217 XSLT2 object, 1219  A.M. or P.M. components, 782 ambiguities, of « », 623–624 Ambroziak, Jacek, 10 ampersand «&», 425  curly braces and, 937 in URLs, 937  ancestor axis  XPath , 83, 609, 1221  deﬁnition description, 1221  ancestor-or-self axis  XPath , 609, 610, 1221  deﬁnition description, 1221  ancestors  innermost, 542 of node  example , 325 outermost, 542 RelativePathPattern and, 693 anchored regex, 236, 829, 863 «and» expression, 186, 538, 552  boolean   and, 722 error semantics for, 1144 AndExpr construct, 525, 594 ˚Angstrom symbol, « ˚A» v., 849 annotatedwith  a schema type , 653, 742 annotations. Seealso type annotations  of attributes, 258–260 of elements, 312–315 input-type-annotations, 99 of source documents, 165  annual leave example, 347–348 anonymous atomic types, 669 anonymous types, 164, 313, 673 ANSI, 937 ant build tool, 67, 86 any level. See level attribute AnyKindTest construct, 616, 670, 698 anyURI. See xs:anyURI  1235   APIs  application programming interfaces   APIs  application programming interfaces , 90  AltovaXML processor  COM API, 1218–1219 Java API and, 1219–1220 .NET API and, 1220  Java. See JAXP JavaScript, 430 Microsoft, 100, 427 Saxon. See Saxon vendor-deﬁned, 427  apostrophes, quotation marks and, 533 appearance, order of, 248 application detects error, 774 application programming interfaces. See APIs application xslt+xml, 100, 470 apply operator  in functional programming languages ,  604  arguments, 545. Seealso arity  converting, 547–549  automatic, with number   function, 573  empty sequence as, 713 optional, 712, 713  arguments with «?» v., 713  required type of, 547, 713 type checking of, 1143  arithmetic operators, 197–198, 200, 454, 571–581.  Seealso «*»; «+»; «-»; «div»; «mod»; numeric functions  atomization of operands. See atomization changes in XPath 2.0, 573 date calculations, 571, 574, 577–581 decimal calculations, 575–576 duration calculations, 571, 577–581 integer calculations, 574–575 numeric calculations, 574–577 rules for, 573–574  backward compatibility and, 573, 574  syntax, 571–572 time calculations, 574, 577–581 type promotion, 572, 585 xs:decimal and, 571 xs:double and, 554–555, 571 xs:ﬂoat and, 571 xs:integer and, 571  arithmetic overﬂow, 719 arity, 345, 346, 361, 546, 559, 712, 792, 1221. See  also arguments  deﬁnition description, 1221  arranging data, in tables, 343–344 as attribute, 72, 82, 161, 243  occurrence indicators and, 179 QNames and, 536 required type of parameter and, 427–428 schema-aware processor and, 161 sequence type descriptors and, 162, 164, 668  1236  type attribute v., 178–179 type declarations and, 161, 514 value of variable and, 503, 504 of xsl:function, 346, 371 of xsl:param, 371, 425, 427–428 of xsl:template, 371, 487 of xsl:variable, 274, 371 of xsl:with-param, 371, 518  ascending order, 459 ASCII  copyright symbol and, 365 escaping non-, 776 UTF-8 as superset of, 365 UTF-8 encoding and, 365 xsl:output encoding, 424  ASP page, 430 ASP.NET  and C  examples , 1092–1094 pages, generating HTML with, 1092–1095  assertions, 568  «treat as» operator, 678  assignment statements, 506, 985–989  conditional initialization and, 989–990 order of execution and, 986  AssociatingStyleSheetswithXMLDocuments,444.  Seealso  processing instruction  associative access to nodes, 813 associative property  of binary « », 605–606 of concatenation, 635  atoms  regex construct , 917–918  as back-references, 917 character class escapes as, 920 as character classes, 917 «i» ﬂag and, 925 as normal characters, 917  atomic types, 53, 153, 163, 193–217. Seealso type s   anonymous, 669 built-in. See built-in atomic types derived numeric types. See derived numeric types derived string types. See derived string types major, 193–206 minimum set  XSLT 2.0  of, 669–670 minor, 193, 206–210 primitive. See primitive types as required item type, 506 SequenceType and, 371 simple types v., 191–192 sources of, 192 untyped atomic values, 193, 215–217 user-deﬁned. See user-deﬁned atomic types  atomic values, 52, 54, 71, 152, 153, 162, 163, 164,  178, 189–191, 506, 1221. Seealso booleans; xs:double; xs:integer; xs:string   booleans as, 189, 191 converting, 654–668 converting, to strings, 878–879. Seealso string   deﬁnition description, 1221 document   applied to, 760–761 ﬂoating-point numbers as, 189, 198 identity and, 190, 289 integers as, 189 matching, sequence type descriptors and, 669–670 properties of, 190 returning, 453, 455 sequences and, 187–188, 322, 351, 633 sets of, 631 simple mapping expressions and, 644–645 strings as, 189, 190 URIs as, 760 xs:integer, 191 xs:untypedAtomic, 191  AtomicType construct, 655, 668 atomization  XPath , 52, 81, 165, 190, 220, 258, 262,  427, 496, 506, 548, 1221 and arithmetic operators, 573 automatic, 743 «cast as» operator and, 655 «castable as» operator and, 655 conditional expressions and, 551 as conversion, 654 data   and, 741–742 deﬁnition description, 1221 of list-valued attribute, 353 of operands, 573, 586  empty sequence and, 573, 586 type error and, 573, 586 value comparisons, 586 xs:untypedAtomic and, 574, 586, 589  predicates with nodes and, 638 runtime error and, 499 schema validation and, 742  attribute  , 617, 698  KindTest, 617 matches any attribute node, 673 NodeTest, 162 schema-deﬁned types and, 617  attribute axis, 83, 609, 1221  «@» and, 83, 621, 622 NameTest and, 695 node tests and, 613 ordering of nodes on, 620 PatternAxis and, 695 in patterns, 683 positional predicates and, 702  attribute declarations  in schemas , 1221  global top-level. See global attribute declarations user-deﬁned, 369 attribute  N, T , 371  attribute sets  XSLT   x e d n  I  attribute names, 255–256. Seealso name  ;  node-name   changing, 391 decided at runtime, 255, 260, 264–266 duplicate, 268, 309 preﬁx of, 256 unpreﬁxed names and, 482, 837  attribute nodes, 49, 56, 1221–1222. Seealsospeciﬁc  attributes  atomization of list-valued, 353 calculation of value of, 260 copying, 260–261  all, 261, 296 unconditionally, 290  creating, 253. Seealso xsl:attribute attribute value template and, 260 different ways for, 260–261 string value in, 258 validating annotating in, 258–260 xsl:attribute and, 260 xsl:copy xsl:copy-of and, 260–261 xs:QName and, 261–263  declarations. See attribute declarations default, 65 deﬁnition description, 1221–1222 document order for, 610 generation of, before child elements, 117, 257 KindTests for, 699–700 of literal result elements, 112–114 local, 260 matching, 672–677 names. See attribute names namespace declarations and, 610 namespace preﬁxes in content of, 392 namespaces v., 256 normalization, 64, 142, 532 order of, 64, 241, 323 deep-equal   and, 747 undeﬁned, 316 parentless, 257  patterns and, 683, 684, 688–689  processing, 241 with QName-valued content, 261, 393 same name of, 257, 267 schema-deﬁned types of, 622 string value, 51 validation, 255 vendor-deﬁned, 134 on xsl:stylesheet, 98–99  361, 1222. Seealso xsl:attribute-set  cycles among, 352–353 deﬁnition description, 1222 duplicate, 268 for generated HTML table elements, 269  attribute sets  XSLT , 97, 105, 113, 117, 257, 261,  1237   attribute sets  XSLT    continued   attribute sets  XSLT    continued  literal result elements and, 117 merging, 267 for numbering, 270–271 parameterize attribute values in, 268 xsl:include with, 375–376  attribute value templates  XSLT , 90, 113, 117, 228,  255, 308, 410, 1222 backward-compatibility mode and, 122 curly brackets { }in, 113, 117 doubling of, 123 nesting and, 123 text between, 117 XPath expressions within, 117, 122, 123  deﬁnition description, 227, 1222 escaping of special characters in, 123 nonrecognition of, 124 places context for using, 123–124 restrictions on, 124–125 string-join   v., 880 xsl:attribute v., 122 in xsl:result-document, 448 in xsl:sort, 330 [xsl:]type attribute and, 124 AttributeName construct, 672 AttributeNameOrWildcard construct, 672 attribute-or-top axis, 689 AttributeTest construct, 616, 672, 697 automatic atomization, data    and, 743 automatic conversion, of arguments to numbers, 573 average of numbers durations, 718 avg   function, 200, 718–719  one-or-more   and, 854  axis name, defaulting of, 621–622 axis speciﬁer, 695 axis steps, 606–625  abbreviated. See abbreviated axis steps binary « » and, 603 document order duplicates and, 602 evaluation of, 607–608 examples of, 608–609 ﬁlter expressions v., 542 ﬁltering and, 606 node tests in, 606, 613–614 NodeTests and, 607 path expressions and, 599 predicates in, 542, 552, 606, 617  predicates in ﬁlter expressions v., 639–640  QNames in, 536 result of, 607 syntax, 606–607  speciﬁcaxes  ancestor, 83, 609, 1221 ancestor-or-self, 609, 610, 1221 attribute. See attribute axis  axis axes  XPath , 83, 606, 609–612, 1222. Seealso  1238  attribute-or-top, 689 child. See child axis child-or-top, 689 deﬁnitions descriptions of, 606, 609–612, 1222 descendant, 609, 610, 1223 descendant-or-self, 609, 611, 1223 direction of, 242, 323, 620 following, 609, 611, 1225 following-sibling, 83, 609, 611, 1225 forward, 607, 608, 620 list of, 609 namespace. See namespace axis parent, 609, 612, 621, 1227  «..» as, 621, 623  path expressions and, 599. Seealso path  expressions in patterns, 683 preceding, 609, 612, 1227 preceding-sibling, 83, 609, 612, 1227 reverse, 607, 608, 620, 1227, 1228 self, 609, 612, 622, 836, 1228  AxisStep  NameTests in, 482 primary expressions v., 540 zero or more predicates in, 620  B  back-references, 917, 918  atoms as, 917 captured groups and, 918 character class escape and, 921 «i» ﬂag and, 925  backslash  «$» , 920  character class escapes and, 920–922 in embedded XPath, 528 in regex, 916 in replace  , 863  backward-compatibility mode, 82, 90, 91, 113,  131–134, 377, 479, 496, 1139–1145  attribute value templates and, 122 automatic conversion of arguments to numbers and,  573  comparing strings and, 1141 deﬁnition of, 1231 disable-output-escaping and, 1140. Seealso  disable-output-escaping  effective boolean value and, 722 error handling and, 1140–1141 ‘ﬁrst item’ rule, 132, 133, 480, 498, 1142–1143 function conversion rules and, 549 function-available   and, 792 general comparisons and, 588, 589 HTML result tree and, 424 number   and, 852 numeric formats and, 1141   rules for arithmetic operators and, 573, 574 sequence numbers and, 405 serialization and, 1142 standard conversion rules and, 505, 714 static context, 554–555 string   and, 877 as transition aid, 554 type checking and, 549 value comparisons and, 586 version attribute, 479, 496  XSLT 2.0 rules for, 479  xsl:sort in, 459  xml:base attribute  base URIs, 84, 293, 357, 358, 373, 1222. Seealso  collection   function and, 562 of context node, 720 deep-equal   and, 747 deﬁnition description, 756, 1222 doc   function and, 562, 751 document   function and, 757, 760, 763 DOM and, 756, 876 nodes, 54–55 for output documents, 68 static context, 562, 868, 876 static-base-uri   function and, 562, 868, 876–877 of stylesheet, 720, 756, 905  base64Binary. See xs:base64Binary base-uri   function, 55, 719–720  doc   and, 750 resolve-uri   and, 720  basic XSLT processors, 151, 190. Seealso  schema-aware XSLT processors  built-in types in, 162, 190, 192 in-scope schema deﬁnitions and, 557 xsl:import-schema declarations and, 370  BasicAttributeTest construct, 672, 698 BasicElementTest construct, 672, 697 Berners-Lee, Tim, 26 binary « » operator. See « » binary operators, 602. Seealso «except»; «intersect»;  «union»  xs:hexBinary  binary types, 208. Seealso xs:base64Binary;  binding  extension functions , 957–962  external objects and, 961–962 in Gestalt, 962 in Java processors, 959–961 in MSXML, 957–959 in Saxon, 962, 1205–1207 in System.Xml.Xsl processor, 957, 961–962  block-structured languages, 502 BNF, extended, 522, 689 boilerplate generation, HTML, 909–910 book list  current   and, 736–738 document   and, 757–758  built-in atomic types  x e d n  I  look-up table in stylesheet example, 761–763  embedded stylesheet example, 102–104  simpliﬁed stylesheet and, 125–127  keys as cross-references, 814–816 nonunique keys example, 381–383  boolean constants, 779, 899. Seealso false  ; true   boolean grouping key, 338 boolean operators, 594–596. Seealso «and»; «or»  shortcut semantics, 595–596  boolean predicates, 618, 638  effective boolean value and, 638  boolean   function, 200, 354, 551, 552, 595, 619, 638,  721–722. Seealso effective boolean value  effective boolean value and, 721 [fn:] preﬁx and, 552 «if» expression and, 722, 771 «some», «every», «and», «or», expressions and, 722 xs:boolean   constructor function v., 552 xsl:if and, 722 xsl:when and, 722  booleans, 52, 184, 186, 187, 189, 191, 194–195,  1222  atomic values, 191 conversions to, 552 converting from decimal, 659 converting from double, 660 converting from ﬂoat, 661 converting from string, 552, 663 converting to other types, 657–658 deﬁnition description, 1222 effective value. See effective boolean value «eq» and, 583 false value, 189, 191, 194, 195 lexical representations of, 552 «lt», «le», «ge», «gt», and, 585 sequence of nodes compared to, 589 true value, 189, 191, 194, 195 xs:untypedAtomic value converted to, 552  Bosak, Jon, 247, 335, 996. Seealso Shakespeare plays bottom-up process, of tree construction, 73 Bouvier, Jacqueline Lee, 1051. Seealso family tree brackets. See curly brackets; square brackets branches  regex construct , 916 browsers, 100. Seealso Firefox; Internet Explorer;  Konqueror; Opera; Safari  different versions of XSLT and, 318 escaping URIs and, 776 generating HTML in, 1095–1098. Seealso family tree stylesheets running in, 430, 463, 957, 1154–1157 built-in atomic types, 163, 164, 192–193, 193–217.  Seealso derived numeric types; derived string types; primitive types  basic XSLT processor, 162, 190, 192 constructor functions for, 546 schema-aware XSLT processor, 190, 192  1239   built-in template rules  XSLT , 69, 73, 78–79, 238, 242,  built-in derived types  built-in derived types, 664, 665. Seealso  xs:dayTimeDuration; xs:integer; xs:yearMonthDuration  in basic XSLT processor, 192 conversion rules, 665 numeric, 192, 193, 210–213 string, 192, 193, 213–215  400, 486, 1222  for comment nodes, 700 deﬁnition description, 1222 node kind, 79  built-in types, 161, 259, 312, 371, 1222  deﬁnition description, 1222 in schema-aware processors, 190, 192,  557, 670  Bulgarian language, 409 bullets, adjacent, 335 byte-order-mark, 421, 422, 448, 905  C  C, 7, 8, 9, 192, 212, 532, 543, 546  ASP.NET examples, 1092–1094 extension functions in, 957 and Saxon on .NET, 957, 1093, 1203–1204 user-deﬁned functions in, 546  C++, 136 C programming language, 187, 502  include directive in, 374  cached schemas, 369  compiled, 370  calculations, numeric. See arithmetic operators;  numeric calculations; numeric functions  calculus, predicate, 641 calendar argument, 784–787 calendar component, 782 calendars, 784–787  Gregorian, 784, 785, 786 Islamic, 787 ISO, 785, 786 Julian, 786, 787 non-Gregorian, 786  call stack, 429. Seealso stack frame call-by-value parameters, 273 caller’s context, 349 calling. Seealso function calls  vendor-supplied functions for, 546 XSLT functions for, 546  calling conventions, function, 959 canonical form, 64–65  pattern facet and, 667 XML documents converted to, 64–65  Canonical XML, 64 captured groups, 234, 860, 862  back-references and, 918  captured substrings, 860 cardinal numbers, 409, 783 cardinality  required, 505, 547 in sequence types, 653  Carducci String Quartet examples, 488–491 carriage return  whitespace character , 440 carriage return, line feed  CR-LF , 64 Cascading Style Sheets. See CSS case mappings, 828, 910. Seealso lower-case  ;  upper-case    locale-sensitive, 828  case studies  family tree, 1049–1098 knight’s tour, 221–222, 224, 1099–1114 XML speciﬁcation, 1001–1048  case variants, 925, 926 lower-case   and, 926 upper-case   and, 926  case-insensitive comparison, 279, 828  collation and, 828 «i» ﬂag and, 828, 925 lower-case   and, 828 in regex, 828, 925  «i» ﬂag and, 925–926  case-insensitive mode  regex evaluation , 231, 925  case-order attribute, 456, 459, 460  upper-case lower-case letters and, 461  case-sensitive names, in XPath expressions, 535 «cast as» operator, 538, 560  atomization and, 655 constructor function and, 655 question mark and, 655 syntax, 655  «castable as» operator, 538  atomization and, 655 number   and, 853 question mark and, 655 syntax, 655  constructor functions for, 546 core function library for, 546 extension functions, 956–957 extension functions within loop  example , 965–967 functions for, 546 Java methods, 546, 959–961 Java methods from Saxon, 1206 user-deﬁned functions for, 546  CastableExpr construct, 526, 655 CastExpr construct, 526, 655 casting. See conversions casts  XPath , 1222. Seealso conversions catalogs, 369 categories, character. See character categories category escape, 922  1240   CDATA sections, 64, 67, 422, 440, 446, 909, 1222  character encoding, 447, 527, 905. Seealso Unicode  charset attribute      x e d n  I  character s , 62–63. Seealsospeciﬁccharacters  character maps  XSLT , 280, 287, 425, 941–945,  cdata-section-elements, 421, 422, 446, 448, 933  cdata-section-elements and, 933 character maps and, 941, 942 deﬁnition description, 1222 disable-output-escaping and, 947  CDATA section and, 933 XML output method and, 933 ceiling   function, 200, 723–724  negative zero and, 723  century, 783 changing  context item, 274, 323, 325–326, 543 element attribute name, 391 focus, 565 namespace URI, 296 preﬁxes, 310–311  ampersand. See ampersand categories. See character categories combining, 849, 880  normalization of, 880, 884 compatibility variants of, 849 control, 63 converting. See lower-case  ; upper-case   ﬁrst, of string, 884–885 ignored in collations, 886, 888 invalid, IDs and, 62 line ending. See line ending characters meta. See metacharacters newline. See newline characters private use area  Unicode , 287, 943 removal of, 897–898 replacement, 897. Seealso translate   special. See special characters in string value, 63, 884 substitution of, 897–898 surrogate pair. See surrogate pair Unicode. See Unicode unreserved, 772 whitespace. See whitespace  character attribute  xsl:output-character , 425 character blocks, 922–923   list , 922–923  character categories, 924   list , 924–925  character class escapes, 917, 920–922  as atoms, 920 back-reference and, 921 backslash «\» and, 920–922 in square brackets, 920  character class expression, 917 character classes, 917  atoms as, 917  ASCII  copyright symbol and, 365 US, 424 UTF-8 as superset of, 365  %HH, 422, 447, 771, 772, 776, 811, 936, 938, 940 iso-8859–1, 365, 424 UTF-8, 63, 64, 906 UTF-16, 63 in xsl:output, 422 in xsl:result-document, 447  character groups, 919  character ranges in, 919 negative group, 919 positive group, 919 square brackets and, 919 subtraction, 919  1222. Seealso xsl:character-map  CDATA sections and, 941, 942 ‘commenting out’ elements  example , 943–944 composite, 282 deﬁnition description, 1222 disable-output-escaping v., 948–949 entity references and, 942 internal DTD subset and, 942 limitations of, 944–945 merging, 282 name of, 281 no effect, 282 nonbreaking space character and, 943 serialization and, 280, 282, 941 SGML and, 942 use-character-maps and, 447, 935, 941 xsl:output-character and, 425  character maps and, 943 CharacterModelfortheWorldWideWeb1.0:  Normalization,848, 849  character normalization, 848–849  « ˚A» and, 848 normalize-unicode   and, 848–849  character ranges  regex , 919–920  in character groups, 919 as codepoint range, 920 hyphen and, 919 «i» ﬂag and, 925 names for, in Unicode. See character blocks positive groups and, 919 Unicode codepoints and, 919  character references  XML , 64, 142, 143, 367, 443, 444, 532, 880, 1222. Seealso entity references  deﬁnition description, 1222 encoding attribute and, 933 special characters converted to, 493  charset attribute    , 101  1241   charset attribute  HTML meta element   charset attribute  HTML meta element , 938, 939,  codepoints-to-string   function, 725–726. Seealso  chessboard, knight’s tour of  case study , 221–222,  string-to-codepoints    collapsing whitespace, 143, 214 collating sequences. See collations collation attribute, 329, 377, 456, 457, 460 collation units, 731  ignorable, 886, 888  collation URIs, 327, 378, 457, 460, 470  Saxon, 565, 1207–1208  collations  XPath , 103, 329, 456, 459–461, 461–462,  child axis  XPath , 83, 609, 610, 621, 1222  940, 941  224, 1099–1114  chevrons, 522, 689, 915  patterns and, 689 regex and, 915 XPath and, 522  deﬁnition description, 1222 KindTest and, 695 NameTest and, 695 node   and, 671 PatternAxis and, 695 in patterns, 683  child-or-top axis, 689 children, of nodes, 55  attributes generated before, 117, 257 parent relationship v., 55, 623  choosing. Seealso xsl:choose  preﬁxes, 262  prevention of conﬂicts and, 308  template rules, 242–245, 485–486 XPath-level work v. XSLT-level work, 455 circularity, 246, 267, 282, 378, 485, 501  patterns and, 378, 485, 683 variable references and, 683  circumﬂex, 920 cities grouped by country, 817–818 Clark, James, 25, 28, 59, 201, 550, 844, 865, 986.  Seealso xt processor  on DSSSL, 28, 986  Clark notation, 59, 844, 865  node-name   example, 844–845 resolve-QName   example, 865  class hierarchy  UML, 50, 56–57 xsl:import, 95  client side, 100. Seealso browsers  JavaScript, 286, 957 script, 957  extension functions and, 957  transformation   , 100  Unicode codepoint and, 920 codepoint-equal   function, 724 comparing strings and, 724 comparing URIs and, 724 xs:anyURI and, 724  character ranges and, 919 deﬁnition description, 1222 string-to-codepoints   and, 881–882  1242  closure  property of languages , 9, 42, 185 codepoint collation. See Unicode codepoint collation codepoint range, 920  1222. Seealso sorting  case-insensitive comparison and, 828 characters ignored in, 886, 888 codepoint. See Unicode codepoint collation decomposition and, 731 default. See default collation deﬁnition description, 1222 domain-speciﬁc collating rules in, 461 «eq» operator and, 459, 584 in Germany, 459 identiﬁed by URIs, 460, 561 implementation-deﬁned, 954 in Java, 561, 731–732 matching substrings with, 731–732, 876  minimal, 886, 888  ordering of strings by, 584 in Saxon, 1207–1208 sorting and, 106, 459 static context and, 561–562 strong, 378, 461, 462, 562, 584 substring matching with, 731–732 in Sweden, 459 UK phone book and, 462 URIs, 460, 560 URIs, in Saxon, 561 varying by country, 459 weak, 378, 461, 562, 584 in the XPath context, 84 XQuery and, 562  collection URIs, 727, 1197, 1217 collection   function, 44, 440, 477, 568, 726–727. See  also doc   function  AltovaXML and, 727, 1217 base URI and, 562 document collection and, 568 document-uri   and, 727, 764 dynamic context and, 567, 568, 726 Gestalt, 727 Saxon, 727  collections  of documents, 568, 726  dynamic context and, 567, 568 statically known, 562–563 XML databases and, 568, 726  codepoints  Unicode , 233, 535, 724, 725, 773, 1222  default, 726   concrete types  x e d n  I  CollectionURIResolver  Saxon , 727, 1197 color example, corporate, 363 COM API  AltovaXML, 1218–1219 MSXML, 1147–1153  combining character, 849, 880  normalization of, 880, 884  combining sets of nodes. See sets of nodes comma  as decimal point, 301–302 as grouping-separator. See grouping-separator  comma operator  «,» , 189, 261, 525, 537, 561, 633,  634–636  ExprSingle and, 634 function calls and, 525, 545 list construction with, 635 max   function and, 635, 831 no sorting into document order, 635 parentheses and, 525, 542 speciﬁed order and, 635 comma-separated lists, 189  values enclosed in parentheses, 189  comma-separated-values ﬁle, 44, 906, 907–908 comment  , 671, 698, 700  KindTest, 613  deep-equal   and, 745–748 general comparisons and, 588–592  single atomic values. See value comparisons strings, 84, 724, 727. Seealso codepoint-equal  ;  compare    backward-compatibility mode and, 1141 default collation and, 588, 724, 728, 731 incompatibility and, 588  substrings, 730–732. Seealso contains   URIs, 724  ComparisonExpr construct, 525, 582 comparisons. See existential comparison; general  comparisons; node comparisons; value comparisons  compatibility mode. See backward-compatibility mode;  forward-compatibility mode  compatibility variants, of characters, 849 compile time  conditional logic, 97–98 preﬁxes not known at, 263 schemas runtime schemas, 752 type errors at, 506 type information at, 590 URIs not known at, 263 use-when evaluation at, 478  «comment» keyword, 616 comment nodes, 49, 64, 285–287, 1222. Seealso  complementary escape, 922 complex types  in schema , 154–156, 163, 164, 313,  xsl:comment  comment   and, 671 debugging stylesheets and, 286 deep-equal   and, 746 default template rule for, 700 deﬁnition description, 1222 with hyphen, 285 with markup, 287 string value, 51, 285 string value of new, 285 in stylesheet, 287 writing to result sequence, 285  commented-out JavaScript, 286–287, 943 comments  regex   «x» ﬂag and, 926 comments  XPath   lexical rules and, 524 nested, 529 syntactic rules and, 524  CommentTest construct, 616, 670, 698 compare   function, 203, 584, 727–729. Seealso  collations; value comparisons  comparing. Seealso matching  «  » and « descendant::», 628 dates times, 580 node names, 859. Seealso node-name  ; QName   nodes. See node comparisons numeric values, 583, 585 sequences  371, 1223  deﬁnition description, 1223 with element-only content, 53, 142, 156–157  schema-aware processor and, 499  with mixed content, 155 schema types as, 653, 742 with simple content, 154–155 units of measure as, 213  component, schema, 557, 1228. Seealso attribute  declarations; element declarations; type deﬁnitions  component speciﬁer, 782 composability, 185. Seealso closure composite character maps, 282 composite grouping keys, 334 composite sequence numbers, 407, 419 computational power, of XSLT, 1099, 1112 computational stylesheets  design pattern , 985–1000,  1114. Seealso knight’s tour  case study   concatenation, 730  associative property of, 635 normalized strings and, 849 separator and, 879. Seealso string-join   of sequences, 261, 634. Seealsocomma operator  concat   function, 123, 204, 545, 729–730  keys and, 730 normalize-unicode   and, 849 string-join   v., 880 xsl:value-of v., 730  concrete types, 163  1243   conditional compilation, 97–98, 112, 127–128 conditional expressions  XPath , 283, 551–553. See  context item, 85, 125, 269, 322, 328, 329, 330,  conditional compilation  also if-then-else  atomization and, 551 errors and, 552 as sort key, 462 substring   as, 885 xsl:choose v., 552–553  conditional initialization, 989–990 Conﬁguration.buildDocument    Saxon , 1205 conﬂict resolution policy, 69, 73, 79–80, 686–688 conﬂicts, priority and, 440 consistency rules  constants, 506. Seealso global variables; literal  for schemas, 370 XDM, 310  constants  constraints  identity, 179 integrity, result document, 174  construction of lists, 635. Seealso comma operator constructor functions  XPath , 80, 82, 135, 371, 482,  506, 1223  atomic types and, 544, 546 for calling, 546 «cast as» expressions as, 655 default namespace for elements types and, 560 deﬁnition description, 1223 empty sequence and, 655 function-available   and, 793 in-scope functions as, 559 user-deﬁned type and, 482 xs:boolean  , 552 xs:integer  , 780 xsl:sort and, 459  contained sequence constructor, 503 contains   function, 204, 730–732  substring matching with collation, 731–732  content  element, 441 empty, 53, 742 mixed, 53, 146, 155–156, 441, 499 namespace-sensitive, 60–61, 260, 310, 311 PCDATA, 142 simple, 441  ContentHandler  SAX , 44, 1174, 1180 context  XPath , 83, 84–85, 125. Seealso evaluation  context  dynamic. See dynamic context importance of, 569 patterns and, 683 static. See static context use-when attribute, 478 validation, 298  1244  563–564, 1223  changing, 274, 323, 325–326, 543 copying, 287 current   and, 735–736 deﬁnition description, 1223 «every» expression and, 646 in «for» expression, 642–643 global variable and, 735 no  « » and, 624 rooted path expressions and, 625  path expressions and, 543, 644 predicates and, 543, 565, 620, 639 «some» expression and, 646 stylesheet functions, 350, 736 undeﬁned, 350, 544, 736 xsl:analyze-string and, 232, 736 xsl:apply-templates and, 543, 735 xsl:call-template and, 273 xsl:for-each and, 543, 735 xsl:for-each-group and, 736 xsl:function and, 346 xsl:sort and, 457  context item expressions, 543–544  «.» as, 84, 269, 564, 620, 621  ‘‘context item is not a node” error, 232, 624, 625  xsl:analyze-string and, 624 xsl:for-each and, 624  context node, 83, 241, 564, 1223  base URI of, 720 binary « » and, 603 deﬁnition description, 1223 «for» expression and, 642–643 position of, 241 predicates and, 608 xsl:template and, 486, 487  context position, 85, 125, 269, 328, 329, 330, 563,  1223. Seealso position   function  binary « » and, 603 deﬁnition description, 1223 in «for» expression, 644 position   function and, 564, 608, 620, 639,  854–856  predicates and, 608, 620, 639 xsl:apply-templates and, 564 xsl:for-each and, 564 xsl:function and, 346 xsl:sort and, 457 xsl:template and, 486, 487  Seealso last   function  binary « » and, 603, 821, 855 deﬁnition description, 1223 in «for» expression, 644  context size, 85, 125, 269, 328, 329, 330, 563, 1223.   CSS  Cascading Style Sheets   x e d n  I  last   function and, 564, 608, 620, 639, 820–824 predicates and, 608, 620, 639, 821 xsl:apply-templates and, 564, 821 xsl:for-each and, 564, 821 xsl:function and, 346 xsl:sort and, 457 xsl:template and, 486, 487  context variables, 510 ContextItemExpr «.», 269, 528, 543–544 context-sensitive values, 507–510  lower-case   and, 828 continuation marker, 330 control characters, 63 controlling  sequence of processing, 77 serialization, 67, 450 validation, 450  convenience variables, 507  global, 507 local, 507  rules  conversion rules, standard. See standard conversion  conversions, 82, 207, 244, 506, 653. Seealso type  expressions  of arguments, 547–549  automatic, with number   function, 573  of atomic values, 654–668 atomization as, 654 to boolean, 552 between derived types, 664–668 of durations into number of months days seconds,  581  failed, 654 function. See function conversion rules; standard  conversion rules  of IRIs to URIs, 811–812 of non-string values to derived types, 666–667 of numbers to strings, 531 of operands to strings, 586 between primitive types, 656–664  list of source result types, 656–657  to strings, 499 of strings to booleans, 552 strong. See strong conversions type, 377 type names in, 482 of upper-case characters to lower-case characters,  827–828  to user-deﬁned atomic type, 371 weak, 81–82, 220 from xs:date, 207 from xs:dateTime, 207 to xs:dayTimeDuration, 668 to xs:double, 454, 852  xs:untypedAtomic and, 574, 589  to xs:integer, 667–668 xsl:function and, 346 xsl:sort and, 459 of xs:string to derived types, 665–666 of xs:untypedAtomic, 427 of xs:untypedAtomic values to booleans, 552 to xs:yearMonthDuration, 668  copying copies. Seealso xsl:copy; xsl:copy-of  attributes, 260–261  all, 261, 296 unconditionally, 290  context item, 287 data to from temporary tree, 293 deep, 287, 292, 293, 296. Seealso xsl:copy-of  recursive, 290  exact, 296 namespace nodes, 296–297, 311 nodes, 57  validation of, 297  of parent element’s namespaces, 310 shallow, 287 source document to result, 293, 296  with few changes, 290  type annotations, 297–298  copy-namespaces, 289, 296, 392, 474 copy-namespaces = ‘‘no’’, 291 copyright symbol    , 365 core function library, 135, 709–913  for calling, 546 functions by category  list , 710–712 in-scope functions and, 559 minimum set of atomic types and, 669 standard conversion rules, 713–714. Seealso  standard conversion rules  corporate color example, 363 count attribute  xsl:number , 411–412 counter, 990 count   function, 146, 212, 350, 411, 733–734  last   v., 734 xsl:number v., 734  countries languages, xsl:decimal-format and, 301. See  also format-date   country argument, 787 cp1252, 937 create_iterator    Gestalt , 962 CR-LF. See carriage return, line feed cross references  in case study, 1007, 1029–1032 construction of, 412 keys as, 814–816  CSS  Cascading Style Sheets , 24, 444, 489  IdKeyPattern and, 705 rule-based stylesheets and, 980 XSLT vs.,24, 982  family tree case study, 1080, 1081  1245   curly brackets  {}   curly brackets  {}   ampersand and, 937 in attribute value templates, 113, 117  doubling of, 123, 915 nesting and, 123 text between, 117 XPath expressions within, 117, 122, 123  in regular expressions, 231, 915, 916  current, 240, 242, 485, 486 current date, 785 current group, 346, 739  stylesheet function and, 739 current grouping key, 346, 740 current mode  XSLT , 238, 242, 273, 346, 400, 485,  current template rule  XSLT , 238, 273, 346, 399–400,  486, 1223  deﬁnition description, 1223  1223  deﬁnition description, 1223 xsl:apply-imports and, 399 xsl:apply-templates and, 399 xsl:call-template and, 400 xsl:for-each and, 400 xsl:next-match and, 399–400 current-date   function, 738–739  dynamic context and, 566 implicit timezone and, 583  current-dateTime   function, 738–739  dynamic context and, 566  current   function, 85, 509, 734–738  context item and, 735–736 example, 736–738 patterns and, 683, 736  xsl:for-each-group  xsl:for-each-group and, 739 xsl:sort and, 739  Seealso xsl:for-each-group current-time   function, 738–739  dynamic context and, 566 GMT and, 717  customization layer, 368, 429 customizing  of presentation, 368 of stylesheet, 429  Othello example, 433–437  cycles, 251  among attribute sets, 352–353 in graphs  examples , 251–253, 352–353 xs:time and, 585  Cygwin, 1196 Cyrillic alphabet, 409  1246  current-group   function, 328, 331, 332, 739. Seealso  current-grouping-key   function, 328, 331, 740–741.  data   function, 52, 741–743. Seealso type matching  D  role of, 185  databases  data dictionaries, 369 data model, 42. Seealso XDM tree model  products, 67 relational, 8, 67. Seealso SQL Unicode, 233, 828, 922 XML, 568  «  » and, 627 collections and, 568, 726 unordered   and, 902  rules  atomization and, 741–742 test contents of node with, 552 typed values and, 741  data-oriented XML, 53, 977 data-type, 456, 458. Seealso xsl:sort dates, 195–197. Seealso format-date   function;  xs:date; xs:dateTime  arithmetic on, 571, 574, 577–581 current, 785. Seealso current-date  ;  current-dateTime    difference between two, 580 formatting, 195, 235, 738–739, 781. Seealso  format-date  ; format-dateTime    Gregorian, 196 ISO format, 785 language argument and, 784 negative, 196 partial date types, 207 partially ordered, 196, 585 starting instants of  simultaneous, 583 xs:date minus xs:date and, 580  subtracting, 348 with timezone, 583 value space of, 786  dates times, 577. Seealso xs:dateTime  comparing subtracting, 580 formatting. See formatting interval between two, 577 plus duration, 578–579 «+» and «-», 578–579 without timezone, 580  dateTime. See xs:dateTime date time functions, list of, 711 dateTime   function, 743–744 day component, 744, 745  from xs:date and xs:dateTime, 744 from xs:duration, 745  day, New Year’s, 787 day-from-date   function, 744–745   default namespaces  x e d n  I  days of week, 581, 782, 786. Seealso format-date    day-from-dateTime   function, 744–745 daylight savings time, 787 days of month, 744  picture argument and, 782 from xs:date, 744 from xs:dateTime, 744  language for, 784 numbering of, 785  days-from-duration   function, 745 debugging, 161, 388  extension-element-preﬁxes and, 477 stylesheet, 431  comments and, 286 decimal. See xs:decimal decimal arithmetic, 575 decimal digits, surplus, 531 decimal notation. See xs:decimal decimal places, 531  round-half-to-even   and, 872–873  decimal-format. Seealso format-number  ;  decimal point «.», 528, 789 «,» symbol as, 301–302 digits after, 790  xsl:decimal-format  default, 299, 789  examples, 791–792  name, 299, 789  DecimalLiteral symbol, 530 decimal-separator  comma as, 301–302 picture string, 300 xsl:decimal-format, 300  declaration, XML. See XML declaration declarations  in schemas   attribute. See attribute declarations element. See element declarations  declarations  in stylesheets , 89, 90, 94, 104, 149,  298, 318, 1223. Seealso namespace declarations; type declarations  deﬁnition description of, 1223 duplicate, 97, 374 implementor-deﬁned, 106–107 import precedence of, 357, 361–362 local. See local declarations multiple xsl:import-schema, 370 order of, 105, 360, 486 overriding, 364 xsl:attribute-set, 468 xsl:character-map, 468 xsl:decimal-format, 298, 468 xsl:function, 345, 469 xsl:import, 469 xsl:import-schema, 368, 469 xsl:include, 469  xsl:key, 376, 469 xsl:namespace-alias, 394, 469 xsl:output, 469 xsl:param, 469 xsl:preserve-space, 439, 469 xsl:strip-space, 465, 469 in xsl:stylesheet, 468–469 XSLT-deﬁned, list of, 105–106 xsl:template, 469 xsl:variable, 469, 500  declarations, text. See text declarations declarative language, XSLT as, 8, 40, 979 decomposition, 731 deduplication, 544. Seealso distinct-values  ; removal;  deep copy, 287, 292, 293, 296. Seealso xsl:copy-of  xsl:for-each-group  recursive, 290  deep-equal   function, 745–748. Seealso  saxon:deep-equal    base URI and, 747 comments and, 746 comparing sequences with, 745–746 «eq» operator and, 746 namespace nodes and, 746, 747 order of attributes and, 747 processing instructions and, 746 type annotations and, 747 whitespace text nodes and, 747  default, 242, 395, 485, 486 default attribute values, 65, 481  in DTD, 481  default collation, 377, 461, 467, 470, 561, 562  comparing strings and, 588, 724, 728, 731 «lt», «le», «ge», «gt», and, 584 for xsl:sort, 461  default-collation attribute, 99, 159, 467  effect usage, 470 on literal result elements, 468 [xsl:], 112, 470 xsl:for-each-group and, 470 xsl:key and, 470 xsl:sort and, 470  default-collation   function, 748 default collection of documents, 726 default decimal-format, 299, 789  examples, 791–792  default  unnamed  mode, 238, 242, 485, 486 default namespace declarations, 480–482, 536, 1223  as default attribute values in DTD, 481 deﬁnition description, 1223 xpath-default-namespace and, 480–482, 615  default namespaces, 58, 308, 534  for elements, 481, 556, 615  constructor functions and, 560  for functions, 135, 482, 545, 556, 560, 655, 793  1247   default namespaces  continued   default namespaces  continued   and QNames without preﬁxes, 536, 766, 866 static context, 556 for types, 556, 615  constructor functions and, 560  undeclaration, 58 XPath, 556, 696. Seealsoxpath-default-namespace  NameTest and, 696  default priorities, 250, 401, 484, 486  of patterns, 686–687, 691  default separator, 258, 497 default template rules. See built-in template rules default values  deﬁned in schema, 313 for elements and attributes, 313 as empty sequence, 504 of parameter, 244, 273, 427, 428–429, 487 xsl:param with, 432–433 as zero-length string, 503  defaulting, of axis name, 621–622 default-validation, 99, 297, 315, 467, 470–471  of disable-output-escaping, 280, 492, 493, 946–947 of namespace axis, 61, 601  literal result elements and, 470, 471 xsl:copy and, 471 xsl:copy-of and, 471 xsl:element and, 471 xsl:result-document and, 471  deferred evaluation, of variables, 388 deﬁnitions, type. See type deﬁnitions DeﬁnitiveXMLSchema  Walmsley , 151 delimiter, 532 delimiting quotation marks, 528  doubling of, 532  deprecation  depth, of nodes, 274 depth-ﬁrst traversal, 250 dereferenced URIs, 357, 373, 567, 755, 757 derived by restriction  types , 664 derived numeric types, 192, 193, 210–213 derived string types, 193, 213–215 derived types  in basic XSLT processor, 192 built-in, 664, 665  conversion rules, 665  conversions between, 664–668 converting non-string values to, 666–667 converting xs:string to, 665–666 numeric, 192, 193, 210–213  type hierarchy, 211  string, 192, 193, 213–215 user-deﬁned, 664  descending order, 459 design patterns  stylesheets   computational, 985–1000, 1114. Seealso knight’s  tour  case study   ﬁll-in-the-blanks, 38, 973–976 navigational, 976–980, 1114. Seealso family tree   case study   rule-based, 74, 246, 980–985, 1047, 1113. See  also XML speciﬁcation  case study   visitor, 250  development environment  Kernow, Saxon and, 10, 13–14, 1195 oXygen, 10, 12, 13, 1195 Stylus Studio, 10, 12, 13, 16–17, 1195 XMLSpy, 10, 12, 13, 15–16, 91, 479, 1195,  1215–1216  diacritics, 848  and accents in NFC, 880, 884  diagnostic functions. See error  ; trace   diagnostics, 107  trace   and, 896–897 xsl:message and, 388, 897 dialect of XSL, WD-xsl as, 467 dictionaries, data, 369 difference between two dates, 580 difference operator. See «except» operator diffspec.xsl overlay stylesheet, 1003, 1041–1044 digit placemarker, optional, 789 Digit symbol, 530  as regular expression, 530 square brackets for, 530  digital signatures, 396 digits. Seealso groups of digits  after decimal point, 790 decimal, 531 Indic Arabic, 302 in regular expressions, 233, 921 signiﬁcant, 790 Unicode, 408, 782 in xsl:decimal-format, 302 in xsl:number, 408–409 Dijkstra, Edsger, 985, 986 direction, of axis, 242, 323, 620 disable-output-escaping, 280, 909, 945–949  backward-compatibility mode and, 1140 CDATA sections and, 947 character maps v., 948–949 deprecation of, 280, 492, 493, 946–947, 1140 Firefox and, 946 grouping and, 947 xsl:text and, 492, 493, 945 xsl:value-of and, 496, 497, 945  « descendant::», «  » compared with, 628 descendant axis  XPath , 609, 610, 1223 descendant-or-self axis  XPath , 609, 611, 1223  disabling namespace inheritance, 312 disabling output escaping, 945–949 disambiguation of « », 543  1248   distinct-values   function, 249, 333, 435, 459,  document  ’’ , 321, 760 document   function, 44, 55, 68, 84, 85, 138, 321,  Document Object Model  x e d n  I  749–750  duplicate values and, 749–750 «eq» operator and, 749 hyperlink output and, 435 index-of   and, 750 transitivity and, 587 undeﬁned order of result, 640 XQuery and, 750 xsl:for-each-group v., 750  «div» operator, 200, 538, 554, 571  durations divided by durations, 580–581 durations divided by numbers, 579 exact division, 572 «mod» and, 572, 575 precedence, 572 precision of result, 575  divide-and-conquer recursion, 993 division  decimals and, 575 of durations, 577, 579, 580–581 by zero, 574, 575  division operators, 572. Seealso «div»; «idiv»  doc-available   function, 750–753 DocBook stylesheet suite, 433 doc   function, 44, 55, 85, 323, 440, 477, 568,  « » v., 572  750–753  base URI and, 562, 751 base-uri   and, 750 document-uri   and, 764 document   v., 750 dynamic context and, 567, 568, 751 evaluation context and, 751 implementation, 752 relative URI and, 751 resolve-uri   and, 750, 751, 868–869 schema validation and, 752 unparsed-text   and unparsed-text-available   v., 905 validation invoked by   AltovaXML  control over, 671  Saxon  control over, 671 Web documents and, 751 XQuery and, 751 xsi:schemaLocation and, 558, 671  DOCTYPE declaration, 67, 422, 446, 931  public identiﬁer in, 446 system identiﬁer in, 422, 447, 933, 938  doctype-public, 421, 422, 446, 448, 933  HTML output method and, 938 public identiﬁer and, 933, 938 XML output method and, 933  doctype-system, 421, 422, 447, 448, 933  HTML output method and, 938 XML output method and, 933  323, 373, 440, 477, 510, 568, 754–763  applied to atomic values, 760–761 applied to nodes, 757–758 base URIs and, 757, 760, 763 doc   v., 750 dynamic context and, 567, 568 «is» operator and, 756 modes and, 758 resolve-uri   and, 763 schema validation and, 757 stylesheet analysis with, 758–759 temporary trees and, 756 unparsed-text   and unparsed-text-available   v.,  905  document s , 1223. Seealso transformation process,  XSLT; XDM tree model  built in memory, 752 collection of, 568, 726. Seealso collection   function  default, 726  deﬁnition description, 1223 dynamic context and, 567, 568 input. See source documents locating text within, 413–415 mappings from URIs to, 568 multiple result. See multiple result documents multiple source. See multiple source documents nodes. See document nodes order. See document order output. See result documents parsing, 43, 752, 756–757 result. See result documents secondary, 510, 692, 761 source. See source documents statically known, 562–563 technical legal, sequence numbers for, 418 temporary. See temporary documents trivial, 514 well-formed. See well-formed documents  document element  XML , 48, 1223 document nodes, 47, 49, 289, 454, 1223–1224  binary « » and, 617 deﬁnition description, 1223–1224 document-node   and, 671 KindTests for, 700–701 process of forming content of, 304 root nodes other than, 624, 625, 688, 870 rooted expressions and, 623 string value, 51 trees with no, 624 trees with root other than, 624, 625, 688 value of parameter as, 306 in XDM data model, 304  Document Object Model. See DOM  1249   document order  document order, 57–58, 228, 241, 323, 378, 1224  « > » and, 593, 594 for attributes, 610 deﬁnition description, 228, 1224 duplicates and, 378, 601, 602  binary « » operator in, 602 node identity in, 602 path expressions and, 644  «for» expression and, 642 forward axes and, 608, 620 no sorting into  comma operator and, 635  of nodes, 57–58  on attribute axis, 620 on namespace axis, 620  594  path expressions and, 644 reordering sequences in, 602 reverse, 608, 620  operators for testing nodes before after in, 57, 593,  JAXP support for, 1166–1169 in MSXML, 1147–1152 node manipulation and, 961 result tree via, 420 Saxon and, 1200, 1205 tree, 44 XDM tree v., 42, 963–965  Domain Name System, 755 domain-speciﬁc collating rules, 461 DOMLocator  JAXP class , 1171–1172 DOMSource  JAXP class , 1172–1173 dot-all mode  regex evaluation , 231  «s» ﬂag and, 917, 926  dotless I  Turkish , 827, 910 double. See xs:double double markup, 942 double precision numbers, 198–201  values for, 198–199  double quotes, 64  string literals and, 532 DoubleLiteral symbol, 530 double-precision ﬂoating-point numbers, 198, 531, 576.  reverse axes and, 608, 620, 1228 sorting sequences into, 57, 241, 602 speciﬁed order, comma operator and, 635  Document Style Semantics and Speciﬁcation Language.  doubling  See DSSSL  ‘document type,’ 671 document type declaration, 933, 938. Seealso  DOCTYPE declaration  Document Type Deﬁnitions. See DTDs DocumentBuilder  JAXP class , 1168–1169 DocumentBuilderFactory  JAXP class , 1167–1168 document-formatting stylesheets, 1047. Seealso  Seealso xs:double  of curly brackets, 123, 915 of delimiting quotes, 532 of square brackets, 781  download example ﬁles, xxxiii-xxxiv DSSSL  Document Style Semantics and Speciﬁcation  Language   Clark on, 28, 986  DTDs  Document Type Deﬁnitions , 24, 27, 471, 1224  default attribute value in, 481  default namespace declaration as, 481  deﬁnition description, 1224 exclude-result-preﬁxes and, 471 internal subset, 930  character maps and, 942  type ID and, 803 unparsed entity declaration in. See unparsed entities validation with, 752, 755, 757, 805  ID attributes and, 62 namespace preﬁxes and, 857 preﬁx-from-QName and, 857  xs:NOTATION and, 209  groups grouping; xsl:for-each-group  attribute names, 268, 309 attribute set names, 268 declarations, in stylesheets, 97, 374 distinct-values   and, 749–750 document order and. See document order empty sequence with no, 607 grouping keys, 328–329 groups, removal of, 328  rule-based stylesheets  document-level integrity checks, 179 document-level validation, 293, 303 document-node  , 698  document nodes and, 671 KindTest, 617, 700 NodeTest, 162  DocumentTest construct, 616, 670, 697 document-uri   function, 764 collection   and, 727, 764 doc   and, 764 URIs and, 764  dollar sign  «$»   DOM  Document Object Model , 8, 11, 22, 963–965  metacharacters  in replacement string, 863 in variable references, 429, 528, 540  base URI and, 756, 876 Document, 359  stylesheet parameters in form of, 430  expressions in, 682 extension functions and, 963–965  1250  as regex metacharacter, 233, 926. Seealso  duplicate s . Seealso distinct-values  ;   IDs, 62 items, removal of, 333 namespace declarations, 119, 309, 473 nodes, 328  node identity and, 602, 629 removal of, 378, 544, 603  values  in group-by attribute, 328 removal of, 749–750  durations, 205–206. Seealso xs:dayTimeDuration;  xs:duration; xs:yearMonthDuration  add subtract, 577, 579 arithmetic operators and, 571, 574, 577–581 average of, 718 components of. See days-from-duration  ;  hours-from-duration  ; minutes-from-duration  ; months-from-duration  ; seconds-from-duration  ; years-from-duration    converted to number of months, days, or seconds,  581  divided by durations, 580–581 divided by numbers, 577, 579 equality of, 584 functions for  list , 711 multiplying, 577, 579 negative, 578, 580 normalized, 745 plus date time, 578–579 ratio between two, 577 totals of, 889–890. Seealso sum    1224. Seealso static context  collection   function and, 567, 568, 726 current-date   and, 566 current-dateTime   and, 566 current-time   and, 566 deﬁnition description, 1224 doc   function and, 567, 568, 751 document   function and, 567, 568 documents collections and, 567–568 focus. See focus function implementations and, 566 implicit-timezone   and, 567 static context v., 554 variable values, 566  dynamic errors, 80, 649, 1224 deﬁnition description, 1224 in «some» and «every» expressions, 649 Dynamic HTML, 286. Seealso JavaScript dynamic loading of assemblies, in .NET, 962 dynamic sort keys, 462–463 dynamic typing, 186, 187, 221–224, 559  «treat as» operator and, 679  element    x e d n  I  dynamically scoped variables, 429 dynamically typed languages, JavaScript VBScript as,  959  dyn:evaluate   function, 463  E  early normalization, 848 ECMAScript, 953 EDI message, 42, 906 effective boolean value, 283, 551, 555, 1224. Seealso  boolean   function  of «and» operands, 595 backward compatibility and, 722 boolean   and, 721 deﬁnition description, 1224 empty sequence and, 778 «if» expression and, 555 not   and, 850 numeric boolean predicates and, 638 of «or» operands, 595 predicates and, 619, 702 quantiﬁed expressions and, 646 rules for forming, 552, 722 «satisﬁes» expression and, 646 in use-when, 478 in xsl:if, 354 in xsl:when, 516  add_extension_function_library    Gestalt , 962 evaluate_item  , 962 extension functions in, 957, 962 Gestalt and, 957  element-available   function, 128, 131, 140, 141, 319,  764–770  extension elements and, 764–770 extension instructions and, 766 multiple result documents  example , 767–769 system-property   and, 892 use-when attribute and, 140–141, 478, 766 [xsl:]extension-element-preﬁxes and, 766 xsl:fallback and, 766 XSLT 1.0 processor and, 766 XSLT instructions and, 764–770 XSLT versions and, 766–769  element  , 698, 700, 713  KindTest, 617, 700 matches any element node, 673 NodeTest, 162, 164 schema-deﬁned types and, 617  1251  dynamic construction, of QNames, 535. Seealso  QName  ; xs:QName  dynamic context  XPath , 84, 85, 346, 553, 563–568,  deﬁnition description, 1224  effective version, 318 Eiffel, 10, 136  effective value  XSLT , 299, 378, 468, 587, 1224   element s , 227–519, 1224. Seealsospeciﬁcelements  element-only content model, 53, 142, 156–157, 506,  element s   annotation of, 312–315 creation of, 307–311. Seealso xsl:element default namespace for. See default namespace deﬁnition description, 1224 document, 48 empty  HTML output method and, 936 tags, 65 XHTML output method and, 939 encapsulating properties of, 348 grouping ordering of, 229 as IDs, 803 KindTests for, 698–699 literal result. See literal result elements matching, 672–677 names. See element names namespace preﬁxes in content of, 392 nillable, 183 nilled, 183 order of, 64 outermost, 48 parentless, 55, 87  patterns and, 683, 684, 688–689  QName-valued, 393 as root nodes, 688 string value, 51, 742 top-level. See top-level elements unrecognized, 318 validation of, 176–179, 289, 312–315  element  N, T , 371 element content, 441  schema types and, 742  element declarations  in schemas , 152, 156, 159,  164, 171, 173, 177, 314, 1224  deﬁnition description, 1224 global. See global element declarations top-level. See global element declarations user-deﬁned, 369  element names. Seealso name  ; node-name    changing, 391 decided at runtime, 308 local name, 308 namespace URI, 308 in path expressions, 482 in patterns, 482 preﬁx, 308 QNames as, 536 in SequenceType syntax, 482 in xsl:preserve-space, 440, 482 in xsl:strip-space, 465, 482  element nodes, 1224. Seealso element s  ElementName construct, 672 ElementNameOrWildcard construct, 672  1252  878  ElementTest construct, 616, 671, 672, 697 elimination. See removal embedded languages, 39  XPath as. Seealso evaluation context  in Java, 553 in Perl, 553 in XForms, 553, 709 in XML Schema, 553 in XPointer, 553, 682 in XSLT, 22, 39–40, 527, 553  embedded stylesheets  XSLT , 94, 102–104, 466, 1224  browser support, 102 deﬁnition description, 1224 example, in Firefox, 102–104 Internet Explorer and, 102 in   processing instruction, 469  empty sequence  «   » , 51, 53, 54, 57, 187, 459, 566,  empty content, 53, 742 empty elements  XML   HTML output method and, 936 tags, 65 XHTML output method and, 939  623, 1224  « ..» and, 623 as argument, 713 atomization of operands and, 573, 586 constructor functions and, 655 default value as, 504 deﬁnition description, 1224 effective boolean value and, 778 empty   and, 770 «every» expression and, 647 with no duplicates, 607 null value in SQL and, 586 one-or-more   and, 853 parentheses for, 542 result of axis step as, 607 setting of version = ‘‘2.0” and, 1143–1144 «some» expression and, 647 string functions and, 710 sum   and, 634, 889 type labels and, 634 zero-length strings and, 203  empty table cells, generation of, 344 empty template rule, 261 empty   function, 552, 648, 770–771  empty sequence and, 770 zero-length string and, 770 empty-sequence  , 653, 669 encapsulation  of properties of elements, 348 of relationships, 348  encoded characters. See character encoding   escape-uri-attributes  x e d n  I  encode-for-uri   function, 771–772  escape-html-uri   and, 772 iri-to-uri    and, 772 percent encoding in URIs and, 771–772 unreserved characters and, 772  equations, numbering of, 407, 415 era component, 782 error codes, 775   list , 1123–1138 user-deﬁned, 775  encoding attribute, 933. Seealso character encoding  error s   character references and, 933 HTML output method and, 938 JAXP and, 941 text output method and, 940 of XML declaration, 933 XML output method and, 933 of xsl:output, 421–422, 941 of xsl:result-document, 447–448 encoding information, external, 905 encoding, percent. See escaping special characters end tags, 49, 1229 end-of-line. See line ending; newline ends-with   function, 204, 773–774  matches   and, 774 replace   and, 774 substring matching with collation, 731–732 Unicode codepoint collation and, 773  entities  XML , 440, 1224  deﬁnition description, 1224 external parsed. See external parsed entities unparsed. See unparsed entities XML document. See well-formed documents  ENTITIES attribute, 903 ENTITY attribute, 903 entity boundaries, 64 entity references  XML , 143, 880, 903, 1224. Seealso  character references  character maps and, 942 deﬁnition description, 1224 external, 64, 720  URI of, 54 HTML, 281 predeﬁned, 444 special characters converted to, 493 XML output method and, 930  envelope payload, 909. Seealso unparsed-text   environment variables, 427  system-property   and, 892  «eq» operator, 329, 377, 378, 458, 538, 571, 581  collations and, 459, 584 deep-equal   and, 746 «ne» v., 584 operand types for, 583–584 transitivity and, 587 ValueComp, 582 equal sort keys, 324 equality. Seealso «eq» operator  of durations, 584 transitive, 587  « » root expression and, 624 application detects, 774 attribute namespace preceded by node, 309 circularity, 246, 267, 282, 378, 485, 501 conditional expressions and, 552 ‘‘context item is not a node,” 232, 624, 625 division by zero, 574, 575 dynamic, 80, 649, 1224 dynamic typing. See dynamic typing in «every» expression, 649–650 match attribute and, 485, 688 recoverable, 1140 reporting, xsl:message and, 388 rooted path expressions and, 625 rounding, 575, 576 runtime, atomization and, 499 in «some» expression, 649–650 static, 80, 1229 static typing. See static typing try catch mechanism and, 80, 752, 774 type. See type errors types and detection of, 53, 186, 221 vendor-deﬁned declarations and, 107 xsl:message and, 388, 775 XSLT, 80  dynamic, 80 static, 80  error   function, 774–775 xsl:message and, 775  error-handling scheme, 775  backward-compatibility mode and, 1140–1141  ErrorListener  JAXP interface , 1173 escaped spaces, «x» ﬂag and, 927 escape-html-uri   function, 775–777  encode-for-uri   and, 772 HTML XHTML serialization and, 776, 938 percent encoding in URIs and, 775–777 URI escaping conventions and, 775, 776, 938  escapes, character class. See character class escapes escape-uri-attributes, 421, 422, 447, 448. Seealso  encode-for-uri    HTML output method and, 938 JavaScript and, 938 percent encoding in, 422 serialization property, 776, 936 XHTML output method and, 940 in xsl:output, 422 in xsl:result-document, 447  1253   escaping special characters  escaping special characters. Seealso backslash;  character references; disable-output-escaping; entity references  date and time in, 286 with markup, 287 XSLT processor identiﬁcation in, 286  in attribute value templates, 123 non-ASCII, 776 in processing instructions, 445 in regex, 232, 915, 920–921, 927 in replacement string, 223 in string literals, 532 in URIs. See percent encoding in XML output, 493, 497 in XPath, 527  evaluate   extension function  dyn:, 463 saxon:, 135, 541, 546, 1210–1214  evaluate_item    Gestalt , 962 evaluating templates, 486–487. Seealso template s  evaluation context  XPath , 553–568, 639. Seealso  dynamic context; static context  doc   and, 751  even-numbered nodes, 241 «every» expression, 39, 540, 552, 646–650  «=» operator and, 648 boolean   and, 722 context item and, 646 empty sequence and, 647 errors in, 649–650  dynamic, 649  focus within, 565 range variables in, 646 semantics of, 647–648  exact copy, 296 exactly-one   function, 777–778 static type checking and, 777  example ﬁles, downloads, xxxiii-xxxiv examples  «  », 627–628 aggregating list of numbers, 993–995 alphabet, 122–123 ancestors of node, 325 attribute name at runtime, 264–266 attribute set  for generated HTML table elements, 269 for numbering, 270–271  axis steps, 608–609 binary « », 604–605 book list. See book list boolean operators, 596 calling extension functions within loop, 965–967 cities grouped by country, 817–818 comma, as decimal point, 301–302 comma operator, 635–636 comma-separated-values ﬁle, 907–908 comments  commented-out JavaScript, 286–287, 943  1254  context-sensitive values, 507–510 converting attributes to child elements, 315–316 current  , 736–738 cycles in graphs, 251–253, 352–353 default decimal-format, 791–792 embedded stylesheets, in Firefox, 102–104 envelope payload, 909 «every» expression, 648 extension functions  with uncontrolled side effects, 967–970 VBScript in MSXML stylesheet, 958–959  extension instruction, 139–141 family tree, 805 family tree  case study , 1049–1098 ﬁll in the blanks stylesheet, 974–976 ﬁlter expressions, 640 ﬂat XHTML documents, 340–342 formatting list of names, 356 forward compatibility, 319 function call, 550–551 general comparison, 592 group-adjacent, 335–340 grouping consecutive elements by name, 336–338 Hello world, 10–19 HTML [OPTION] element with SELECTED attribute,  263–264  HTML table, generation of, 116 import precedence  of global variables, 364–365 of template rules, 365–368  Indic Arabic, 302 «instance of» operator, 678 JAXP transformations, 1187–1193 key   pattern, 706–707 KindTests, 617 knight’s tour  case study , 221–222, 224,  1099–1114  locating text within document, 413–415 look-up table in stylesheet, 761–763 memory, 137 message, 388–389 localized, 389–390  modes, 247–251, 490–491 multilevel grouping, 333–335 multiphase transformation, 511–513 multiple result documents, 451–452, 767–769 music transformation, 5–7 namespace-uri-for-preﬁx  , 840–841 NameTests, 615–616 NaN and inﬁnity, 302 navigational stylesheet, 977–980 Naxos Breakfast Supplies, 380   expanded QNames  x e d n  I  node tests, 613–614 no-namespace, 372 nonunique keys, 381–383 numeric arithmetic, 576–577 path expressions, 600–601 PatternSteps, 703–704 period, as thousands separator, 301 picture argument, 787–788 poem  vendor portability, 319–320 Venn operators, 630 well-balanced XML fragment, 48 whitespace, 493–494 word count, 19–21 XML speciﬁcation  case study , 1001–1048 XML tree, 46–48  , 444–445  JAXP transformation, 1189–1190  attribute set for numbering in, 270–271 formatting of, 35–38 import precedence of template rules in, 365–368 multiple result documents, 451–452, 767–769 numbering lines of, 417–418 validation of ouput document, 171–174 validation of source document, 167–170  xsl:analyze-string  multiple-match, 236–237 single-match, 235–236  xsl:namespace-alias, 398–399 xx:node-set   extensions, 794–796  examples, running, 12–17  push processing, 74–76  controlling sequence of processing, 77 selecting nodes explicitly, 77–78  recursion  process sequence of nodes in, 275–278 process sequence of strings in, 278–280  rendering elements, 239 repeated output  with xsl:copy-of , 294–296 repeating groups, of adjacent elements, 338 resolveQName  , 865 rooted path expressions, 626 sales report, 977–980 schema for XSLT 2.0 stylesheets, 674–677 Shakespeare plays, 336–340 simpliﬁed stylesheet, 125–127 single-level grouping, 331–333 soccer, 294–296  multiphase transformation, 511–513  «some» expression, 648 sorting on result of calculation, 463 square root extension function, 959–961 states  U.S. , 284 static typing, 221–224 stripping whitespace-only text nodes, 442 stylesheet  xsl:import in, 95–98 xsl:include in, 91–95  stylesheet analysis with document  , 758–759 table  HTML , 116  arranging data in, 343–344 attribute set for, 269  template rules, 488–490 temporary document, 86 temporary trees, 320–321 «to» operator, 637 tunnel parameters, 433–437 Unicode normalization, 847–848 union type, 372 value comparison, 587  AltovaXML, 15, 169–170, 277, 347–348, 352–353,  382–383, 994–995, 1217–1218  browser, 13 Firefox, 102–104 Gestalt, 382–383 Java method, 796 Kernow, 13–14 Saxon, 139, 382–383, 398–399, 433–437, 476–477, 799, 959–961, 1087–1090, 1092–1095  Saxon on Java from command line, 14–15, 103 Saxon on .NET, 15 Saxon version 6, 767–769 saxon:evaluate  , 1212–1214 Saxon-SA, 169, 172–173, 769, 995, 1200–1201 Stylus Studio, 16–17 XMLSpy, 15–16, 1215–1216  Excel spreadsheets, up-conversion to XML from, 343 «except» operator, 57, 261, 353, 538, 628–631  «is» operator and, 593 path expressions and, 599, 628. Seealso path  expressions  XPath 1.0 and, 631  excess whitespace. See whitespace-only text nodes exclamation point «!»  in jar URI scheme , 868 exclude-result-preﬁxes, 104, 358, 374, 467, 471–475  DTDs and, 471 effect usage, 471–475 [xsl:], 112, 118, 119, 315, 358, 392  redundant namespace nodes and, 394  existential comparison, 279, 590–592. Seealso  general comparisons  existential quantiﬁers  logical , 646. Seealso «some»  expression  exists   function, 552, 622, 648, 778–779. Seealso  boolean  ; empty  ; not    expanded QNames, 50–51, 201, 1224–1225. Seealso  xs:QName  deﬁnition description, 1224–1225 local-name-from-QName   and, 826  1255   expanded QNames  continued   expanded QNames  continued   namespace URIs and, 50–51, 840–841 original preﬁx in, 58 preﬁxes from, 857–858 QName   and, 858–859  expected type, of parameter, 431 explicit priorities, 401 exponential notation  scientiﬁc notation , 190,  530, 531  for ﬂoating-point numbers, 198, 530 format-number   and, 660 number   and, 851  Expr construct, 525 expression language, XPath as, 185, 553 expressions  XPath , 8, 82–84, 228, 524–529, 1225.  Seealsospeciﬁcexpressions  arbitrary ordering of, 901–902. Seealso unordered   arithmetic, 454 conditional. See conditional expressions constructed at runtime, 541 context. See context conventional programming, 39 curly brackets and, 117, 122, 123 deﬁnition description, 228, 1225 in DOM, 682 extension functions and, 526 ﬁlter. See ﬁlter expressions names in. See name s  ordering results of, 901. Seealso unordered   parenthesized, 542–543 path. See path expressions patterns v., 681–682 primary. See primary expressions programmatical construction of, 396 quantiﬁed, 646 regular. See regular expressions root. See root expressions rooted path. See rooted path expressions in Saxon, 1201–1202 SELECT statement v., 568, 632 sequence. See sequence expressions sequence type descriptors in, 165 side effects and evaluation of, 526 simple mapping. See simple mapping expressions step, 57 stylesheet parameter in form of, 430 syntax. See syntax test, 283 type. See type expressions type-safe, 777 as Unicode characters, 527 unpreﬁxed names in, 481–482  xpath-default-namespace and, 481–482  for values of double-precision numbers, 199  1256  in XML Schema 1.1, 682 within XPointer, 553, 682  ExprSingle construct, 525, 545  «,» and, 634  EXSLT library, 135, 346, 463, 546, 631, 955 extended BNF, 522, 689 extensibility, XSLT, 134–141, 953–971. Seealso  extension functions; extension instructions  design principles, 134 extension functions, 953–971 in Gestalt, 962 in Java processors, 959–961 mechanisms for, 134 in MSXML, 957 portable extension functions, 970–971. Seealso  portable stylesheets  in Saxon, 959, 962, 1205–1208 in Saxon on .NET, 962 in System.Xml.Xsl, 961  Extensible Stylesheet Language. See XSL Extensible Stylesheet Language: Transformations. See  XSLT  extension s   portable, 970–971 proprietary, 319 Saxon, 1208–1210 user-deﬁned, 318 vendor-speciﬁc. See vendor-speciﬁc extensions  extension attributes, 954, 1225  Saxon, 1209 serialization and, 1225  extension declarations, 106–107, 954 extension elements, 317, 467, 475, 1225. Seealso  xsl:fallback  element-available   and, 764–770  extension functions, 106, 111, 134–138, 709,  953–971, 954, 1225  alternatives to, 138 binding, 957–962. Seealso binding in C, 957 calling, 956–957 calling, within loop, 965–967 client side script and, 957 deﬁnition description, 1225 DOM and, 963–965 in Eiffel, 957, 962 evaluate   extension function. See evaluate    extension function expressions and, 526 and external data to stylesheets, 956 function-available   and, 792, 793 in-scope functions as, 560 in Java JavaScript, 134–135, 137, 956  XSLT 1.1 and, 135  in JScript, 134, 709, 957   languages for writing, 957 linked to stylesheets Java and, 136–137 namespaces for, 471 in .NET languages, 957 node manipulation and, 961 performance and, 956 in Python, 957 random number generator and, 955 reasons for using, 955–956 Saxon, 959, 962, 1209–1210  saxon:evaluate  , 135, 541, 546, 1210–1214 side effects and, 138, 244, 549, 595, 955, 956  example, 967–970  square root calculation  example , 959–961 stylesheet parameters v., 430 trigonometric calculations and, 531, 955 user-written. See user-written extension functions in VBScript, 134, 957 and VBScript in MSXML stylesheet  example ,  958–959  wrong reasons for using, 956  extension instructions, 106, 111–112, 138–141, 228,  954, 1225  AltovaXML and, 476 deﬁnition description, 138, 228, 1225 element-available   and, 766 example, 139–141 extension-element-preﬁxes and, 475 implementation-deﬁned, 954 literal result element v., 766 portable stylesheets and, 138–141 Saxon, 139, 140, 475–476, 1209 Xalan and, 140 xsl:fallback and, 769 XSLT, 138–141  extension namespace, 138  instructions in, 317 extension types, 954 extension-element-preﬁxes, 98, 107, 138, 358, 374,  467, 475–477  debugging and, 477 effect usage, 475–477 extension instructions and, 475 Saxon and, 476–477 [xsl:], 111, 113, 118, 138, 317  element-available   and, 766  external data to stylesheet, extension functions and,  956  external encoding information, 905 external entity references, 64, 720  URI of, 54  external ﬁle, in form of string, 904. Seealso  unparsed-text    external functions. See extension functions  ﬁltering items in sequence  x e d n  I  external objects, 961  binding extension functions with, 961–962  external parsed entities, 48, 87, 929–930  rules for, 930 well-formed XML documents v., 930–931 XML output method and, 929–932  F  facet s , 1225  converting non-string values to derived types and, 666 converting xs:string to derived types and, 665, 666 deﬁnition description, 1225 pattern, 236, 665  canonical form and, 667 converting non-string values to derived types and,  667  regular expressions and, 667, 829  whiteSpace, 143, 214, 663, 665, 846  failed conversions, 654 failure, validation, 166, 259, 1230 fallback processing, 27, 80, 231. Seealso xsl:fallback  forward-compatibility mode and, 448 xsl:analyze-string and, 231, 317  false value  booleans and, 189, 191, 194, 195 false   function, 779. Seealso true    boolean constant and, 779  family tree  case study , 1049–1098  creating data ﬁle, 1058–1072 creating schema for GEDCOM 6.0, 1053–1054 displaying data of, 1072–1098 GEDCOM 6.0 schema, 1054–1058 GEDCOM data model, 1050–1054 generating HTML  with ASP.NET pages, 1092–1095 in browser, 1095–1098 from servlet, 1087–1092  model for, 1050 publishing static HTML, 1086–1087 stylesheet for, 1073–1085  family tree example, 805 ﬁgures, numbering sequences for, 415 ﬁll-in-the-blanks stylesheets  design pattern , 38,  973–976  ﬁlter expressions, 540, 638–640  axis steps v., 542 changing focus with, 565 last   and, 822 predicates in, 552, 637–638  FilterExpr construct, 539, 638 ﬁltering, axis steps and, 606 ﬁltering items in sequence  predicates and, 542  predicates in axis steps v., 639–640  1257   ﬁnal result trees, 74, 448, 1225. Seealso result trees  ﬁnal result trees  deﬁnition description, 1225 temporary tree v., 1225 URIs for identifying, 449  ﬁnding. See locating ﬁnite nonzero values, 198 Firefox, 42, 68, 100  disable-output-escaping and, 946 embedded stylesheets example, 102–104 HTML boilerplate generation and, 910   processing instruction, 101  ﬁrst character of string, 884–885 ’ﬁrst item’ rule, 132, 133, 480, 498, 1142–1143 ﬁrst or last item in list  position   , 856 ﬁrst-class objects, 251 ﬁrst-order operators, 537–538 ﬁxup, namespace. See namespace ﬁxup ﬂags, 230, 231, 829, 862, 894, 925–927. Seealso «i»  ﬂag; «m» ﬂag; «s» ﬂag; «x» ﬂag  nilled, 477 whitespace and, 231, 926  ﬂat XHTML documents example, 340–342 ﬂoat. See xs:ﬂoat ﬂoating-point arithmetic, 576  IEEE 754 standard, 198, 576  ﬂoating-point numbers, 189  as atomic values, 189, 198 double-precision, 198, 531, 576. Seealso xs:double exponential notation for, 198, 530 single-precision, 208. Seealsoxs:ﬂoat  ﬂoor   function, 200, 779–780  «idiv» and, 780 rounding and, 780 xs:integer   constructor function v., 780  ﬂow-of-control instructions, 979 FLWOR expression  XQuery 1.0 , 602, 647–648 [fn:] preﬁx, 545, 710. Seealsospeciﬁcunpreﬁxed  functionnames  boolean   function and, 552  focus, 85, 563–566, 821, 854–855. Seealso context  item; context position; context size  changing, 565 within «every» expression, 565 within «for» expression, 565, 855 host languages and, 564, 565 parts of, 821, 854 for predicate evaluation, 620 within «some» expression, 565  fold function, 251 following axis, 609, 611, 1225 following siblings, 116, 499, 501 following-sibling axis, 83, 609, 611, 1225 footnotes, numbering of, 407, 410, 415, 417 «for» expression, 21, 39, 540, 640–644  context item in, 642–643  1258  context node and, 642–643 context position in, 644 context size in, 644 document order and, 642 focus within, 565, 855 mapping sequences with, 641–642 multiple input sequences and, 643–644 path expressions v., 644 range variable in, 644 sequences and, 640  for loop, 274 ForExpr construct, 525, 640  keywords and, 525  format attribute  in xsl:number, 407 in xsl:result-document, 446, 448  format string, 407–408  xsl:number and, 405, 407–408  format-date   function, 93, 195, 235, 781–788  day of the week and, 581 year component, 782  format-dateTime   function, 781–788 format-number   function, 298, 531, 576, 788–792.  Seealso xsl:decimal-format; xsl:number  changes in speciﬁcation for, 1141 exponential notation and, 660 round-half-to-even   and, 873 xsl:decimal-format and, 789 xsl:number v., 403, 406, 791 format-time   function, 781–788 formatting  date and time. See format-date  ; format-dateTime  ;  format-time    format-number   and, 403 list of names, 356 numbers, 403, 408–410, 788–791. Seealso  numeric output, 531. Seealso format-number  ;  xsl:number  xsl:number  tables. See XML speciﬁcation  case study  xs:date, 781 xs:dateTime, 781 xs:decimal. See format-number   xs:double. See format-number   xs:ﬂoat. See format-number   xsl:decimal-format and, 403 zeros, 409  formatting tokens, 407, 782  «A» and, 782  forward axes, 607, 620, 1225  document order and, 608, 620  forward reference, to local variable, 502 forward-compatibility mode, 110, 113, 125, 130–131,  319, 321, 479  example, 319   function calls  x e d n  I  forward-compatibility mode  continued   fallback processing and, 448 function-available   and, 794 version attribute, 479  XSLT 1.0 rules for, 479 XSLT 2.0 rules for, 479  in XSLT 1.0, 130–131 xt and, 320  forward-compatibility problems, HTML, 766 4XSLT processor, 136, 957  Python and, 957  Fourthought, 66 fractional part of number, 790  «» and, 790  fractional seconds component, 782, 783 fragments  identiﬁer, 756, 868, 905 result tree, 87, 320, 454. Seealso document nodes well-balanced XML, 48, 1230–1231  free memory example, 137 French quotation marks, 522 Frijters, Jerome, 1195 from attribute  xsl:number , 412, 417 fully-normalized, 849 funcproto.xsl stylesheet module, 1046–1047 function s , 1225. Seealsospeciﬁcfunctions  aggregate, 200, 332, 350 arguments. See arguments arity of, 345, 346, 361, 546, 559, 712, 792, 1221 availability of, 792. Seealso function-available   for calling. See calling; function calls by category  list , 710–712 constructor. See constructor functions conversion rules. See function conversion rules;  standard conversion rules  core library. See core function library date time   list , 711  default namespace for. See default namespace deﬁned by host language, 546 deﬁnition description, 1225 diagnostic. See error  ; trace   duration, list of, 711 extension  external . See extension functions higher-order, 250–251, 272 implementations. See function implementations in-scope. See in-scope functions libraries. See function libraries local parameters to, 425, 427 for locating nodes   list , 711  mathematical, 135, 200 mathematical concept of, 987 names. See function names namespace. See function namespace, standard  returning information on XSLT environment, 546  nodes created by, 550  with distinct identity, 988  not in namespaces, 560 numeric, 32 list of, 710  overloading of, 546 parameters. See function parameters pure, 34, 566, 987 on QNames  list , 711  recursive, 347, 350–351, 862, 992 result of, 346 returning context information   list , 711   list , 712   list , 711  returning properties of nodes  with same name, 546, 559 in same namespace, 349 from Saxon, 135 on sequences, 72   list , 711  with side effects, 549–550 signature. See function signature square root, 346, 347  example, 959–961  stable, 726 standard. See core function library static type asserted by. See exactly-one  ;  one-or-more  ; zero-or-one    string. See string functions strings returned from, 497–498 stylesheet. See stylesheet functions system-deﬁned functions, 793–794 tail-recursive, 351, 353, 862, 966 templates as, 988 uniquely identiﬁed, 546, 559, 712 on URIs   list , 711  user-deﬁned. See user-deﬁned functions vendor-supplied. See vendor-supplied functions written in XPath, 546 XForms-speciﬁc, 544, 553, 709 XSLT, 546  list , 712 function body  «.» and, 544  function calling conventions, 959 function calls, 82, 220–221, 345, 427, 544–551  «,» operator and, 525, 545 arguments in, 545 converting arguments in, 547–549 core function library and, 546 example, 550–551  1259   function calls  continued   function calls  continued   identifying functions in, 545–546 IdKeyPattern and, 704  function conversion rules, 505, 548. Seealso standard  conversion rules  backward-compatibility mode and, 549 casting rules and, 548  function implementations, 566 function libraries, 135. Seealso core function library  constructor functions in, 559, 709. Seealso  G  constructor functions  EXSLT, 135, 346, 463, 546, 631, 955 FXSL, 251, 347, 546, 955 mathematical, 135, 200, 346 third-party, 546, 955 Walmsley’s  functx , 546, 955  function names, 135, 345. Seealso QNames default namespace URI for, 482, 545, 710 node tests and, 528 as QNames, 545 unique function identity and, 546, 559, 712 unpreﬁxed, 482, 710. Seealsospeciﬁcunpreﬁxed  functionnames  unpreﬁxed names not available as, 546  function namespace, standard, 135, 482, 545, 556,  560, 655, 793  default function namespace as, 482, 655, 793  function parameters, 82, 346, 425, 426  function signature and, 559  function signature, 220, 547, 559  core function library and, 712–713  functional programming languages, 250, 350, 429,  function-available   function, 128, 130, 131, 138, 478,  792–796. Seealso element-available    985–989  apply operator in, 604 dynamically scoped variables in, 429 knights tour  case study  and, 1113 Lisp, 429 map operator in, 604 Scheme, 28 side effects in, 449  backward compatibility mode and, 792 constructor functions and, 793 extension functions and, 792, 793 forward-compatibility mode and, 794 Java method and, 796 portable stylesheets and, 970 static context and, 793 stylesheet functions and, 792, 793 system-deﬁned functions and, 793–794 system-property   and, 892 use-when and, 478 vendor third-party extensions and, 794 xsl:function and, 793  1260  [xsl:]use-when and, 792 xx:node-set   extensions and, 794–796  FunctionCall construct, 544 functx, 546, 955 FXSL, 251, 347, 546, 955, 956  gDay. See xs:gDay «ge» operator, 538, 571, 581 default collation and, 584 NaN and, 586 ordered data types and, 584–586 ValueComp, 582  genealogy, 1049–1050  family tree case study, 1049–1098 GEDCOM. See family tree  case study   general comparisons, 588–592. Seealso «[»; «]»; «!=»  operator; «=» operator; «[=» operator; «]=» operator  backward-compatibility mode and, 588, 589 changes in XPath 2.0, 588–589 examples, 592 existential comparison in, 590–592 NaN and, 589 rules for, 589–590 untyped atomic values and, 588 value comparison operators v., 582, 588  GeneralComp construct, 582 general-purpose stylesheet module, 97 generate-id   function, 293, 450, 594, 797–800. See  geographical coordinate systems, Open GIS schema for,  also id  ; «is» operator; key    compare nodes by identity and, 797 hyperlinks and, 797 id   and, 800 «is» operator and, 797, 817  557  German language, 409  «B» in, 827  Germany, collations in, 459 Gestalt processor, 10, 136, 340, 359  add_extension_function_library  , 962 binding extension functions in, 962 collection   and, 727 create_iterator  , 962 Eiffel and, 957  extension functions in, 957  evaluate_item  , 962 extensibility in, 962 running example, 382–383 XM_XPATH_FUNCTION_LIBRARY, 962 XM_XPATH_SYSTEM_FUNCTION, 962  gHorribleKludgetypes, 207   global variables, 81, 108, 321, 362, 438, 506, 512,  of adjacent elements, 338–340  global attribute declarations, 179, 259, 371, 557  KindTests and, 699 schema for XSLT 2.0 stylesheets and, 676 sequence type descriptors and, 673–674 type annotations and, 673, 699  global element declarations, 371 schema-element and, 674, 699 sequence type descriptors and, 673–674 substitution group and, 674 type annotations and, 673, 699  global parameters, 68, 82  match attribute and, 485 xsl:param and, 425, 427  global tree-valued variable, 294 global type deﬁnition, 54, 315, 371  named, 313 simple, 259, 313  1225  context item and, 735 convenience, 507 deﬁnition description, 1225 import precedence of, 364–365, 502 match attribute and, 378, 485 principal source document and, 506, 626 scope of, 501 tunnel parameters v., 431 use attribute and, 378 xsl:apply-templates in, 245 xsl:perform-sort and, 438 xsl:variable and, 501  glossary terms, 1221–1231 gMonth. See xs:gMonth gMonthDay. See xs:gMonthDay GMT  Greenwich Mean Time , 717 Goldstein, Robert F., 27 goto statements, 986 grammar, XPath, 521 graphs  cycles in, 251–253, 352–353 navigating, 275  greedy quantiﬁers  regex , 232, 863, 894, 917 Greek language  «α, β, γ , δ» for numbering sequence, 409 character block, 922 polymorphic  many shapes  from, 186 « cid:5 »  sigma , 827 tunnel parameters and, 429 zero sign, 460  Greenwich Mean Time. See GMT Gregor XSLT processor, 10 Gregorian calendar, 784, 785, 786  Julian calendar and, 786  Gregorian dates, 196 group theory, 42  grouping-separator  x e d n  I  groups  regex . See captured groups; subexpressions groups  substitution . See substitution groups groups grouping, 327–331. Seealso xsl:for-each-group  of consecutive elements by name, 336–338 current, 346, 739. Seealso current-group   disable-output-escaping and, 947 initial item of each, 328, 330 multilevel, 333–335 multiple  items belonging to, 335  nested, 334 of nodes, key   and, 813 order of ﬁrst appearance, 328 with patterns, 740 population and, 327, 330, 739 processing order of, 328 repeating  single-level, 331–333 sorting, 330–331  grouping keys and, 330–331  sorting items in each, 331  groups of digits, 409  grouping-separator for, 409, 790 grouping-size for, 409 in xsl:decimal-format, 300, 790 in xsl:number, 409  group-adjacent attribute, 327, 328, 329, 740  examples, 335–340 group-by v., 329, 338 group-starting-with v., 340  group-by attribute, 327, 328–329, 740  duplicate values, 328 group-adjacent v., 329, 338 single-level grouping  example , 331–333  group-ending-with attribute, 3, 327, 330 arranging data in tables with, 343–344 pattern, 330 up-conversion to XML from Excel spreadsheets with,  343  usage, 342–344  grouping keys, 327, 328, 384–385, 816–817  boolean, 338 comparison of, based on type, 329 composite, 334 current, 346, 740 current-grouping-key   and, 740–741 duplicate, 328–329 example, 817–818 sorting groups and, 330–331 xsl:for-each-group and, 384, 816  grouping-separator, 409, 791  picture string, 300 thousands and, 791 xsl:decimal-format, 300  1261   grouping-separator   continued   grouping-separator   continued   in xsl:decimal-format, 300, 790 in xsl:number, 409  grouping-size, 409 group-starting-with attribute, 327, 329–330 ﬂat XHTML documents example, 340–342 group-adjacent v., 340 pattern, 329–330, 340  «gt» operator, 538, 571, 581 default collation and, 584 NaN and, 586 ordered data types and, 584–586 ValueComp, 582  guillemets, 522 gYear. See xs:gYear gYearMonth. See xs:gYearMonth  H  half-to-even rule, 873. Seealso round-half-to-even   hash joins, 643 hash table, xsl:key and, 379 head-tail recursion, 275, 993 Hebrew language, 410 Hebrew numbering, 410, 783 Hello world example, 10–19  explanation, 17–19 running from XMLSpy, 15–16, 1215–1216  hexadecimals, 725 hexBinary. See xs:hexBinary hierarchies. Seealso class hierarchy; type hierarchy  navigating, 275 node position in, 407 parallel  interleaved markup and, 942  of sequence numbers, 418 in XHTML, 340  higher-order functions, 250–251, 272 higher-order operators, 538–539, 603, 604  binary « » as, 603, 604  holiday resort example, 798–799 host languages, 190, 527, 528, 553  C, 543 escape conventions, 527 focus and, 564, 565 functions deﬁned by, 546 Java, 528, 543  hotel list example, 798–799 hour component   12 hours , 782  24 hours , 782 xs:dateTime, 800 xs:duration, 801 xs:time, 800  1262  hours-from-duration   function, 801  hours component  xs:duration  and, 801 hours-from-time   function, 717, 800–801 href attribute  in HTML, generating, 411, 412 of  , 100  Firefox and, 101 Internet Explorer and, 101  of xsl:import, 357 of xsl:include, 373 of xsl:result-document, 446  HTML. Seealso XHTML  4.0 speciﬁcation, 775, 776 attributes whose value is URI, 936 Dynamic, 286 empty elements, 936 entity reference, 281 evolution of, 26–27 forward-compatibility problems, 766 generating  family tree case study  with ASP.NET pages, 1092–1095 in browser, 1095–1098 from servlet, 1087–1092  generating href attribute in, 411, 412 meta element  charset attribute , 938, 939, 940, 941 [OPTION] element with SELECTED attribute, 263–264 output method. See HTML output method processing instructions in, 444 result tree, 423 selection box, 263 serialization. See HTML output method; serialization [table] elements, attribute sets for, 269 table example, 116 valid, HTML output method and, 936, 937 version, version attribute and, 939  HTML boilerplate generation, 909–910 HTML element, 940 HTML output method, 42, 43–44, 423, 444, 936–939.  Seealso serialization  empty elements and, 936 escape-html-uri   and, 775, 938 escape-uri-attributes and, 938 include-content-type and, 938 indent attribute and, 938 namespace declarations and, 932 output rules, 930–932  XML Namespaces 1.1 and, 931 XML Namespaces and, 931  script in stylesheet v. script in, 137 valid HTML and, 936, 937 XHTML output method v., 939 XML output method v., 936–937  htmltidy utility, 947 HTML XHTML serialization  hours-from-dateTime   function, 800–801  percent encoding in URIs and, 776, 937   HTTP header, 934  external encoding information in, 905 media-type and, 934, 939, 940  HTTP request, 430 hyperlinks  in case study. See XML speciﬁcation  case study  ID attribute values and, 800 output, 435, 450, 797. Seealso generate-id    hyphens. Seealso minus-sign  allowed with square brackets, 920 character range and, 919 comment nodes with, 285 ignored in collations  substring-after   and, 886 substring-before   and, 888  minus-sign v., 538, 572 subtraction  regex , 919 in XML names, 538  I  «i» ﬂag, 828, 925–926  atom and, 925 back-references and, 925 character range and, 925  IANA  Internet Assigned Numbers Authority , 460, 820 IBM mainframes, line ending characters on, 63 IBM XSLT processor, 10 id attribute, of  , 98, 469–470 identiﬁer, fragment, 756, 868, 905 identity, 593  atomic values and, 190, 289 new, 293 node  document order duplicates and, 602, 629 functions and, 988  node comparisons by, 591, 593, 797  «is» operator and, 591, 593  of sequences, 187, 633  identity constraints, 179 identity template, 290, 296  variant of, 290  identity transform  JAXP , 1169, 1177, 1185 id   function, 62, 379, 704, 802–804  generate-id   and, 800 ID attribute and, 802 key   v., 804 literal and, 704–705 variable reference and, 704 xs:IDREF and, 802 xs:IDREFS and, 802  «idiv», 538  ﬂoor   and, 780 integer division, 572, 573 «mod» and, 572, 575  implementation-deﬁned behavior  x e d n  I  numeric predicates and, 639 precedence, 572 xs:integer   constructor function and, 780, 872  IDKeyPattern construct, 704–705  CSS and, 705 function calls and, 704  IDREF attribute, 62. Seealso xs:IDREF  constraints, 251, 293, 297, 305 input-type-annotations and, 477 values, 179  idref   function, 62, 804–806  xs:IDREF and, 805 xs:IDREFS and, 805  IDREFS attribute, 62. Seealso xs:IDREFS IDs, 61–62, 179, 1225. Seealso xs:ID  candidate, 802 constraints, 251, 293, 297, 305 deﬁnition description, 1225 DTDs and, 62 duplicated, 62 elements as, 803 hyperlinks and, 800 id   and, 802 input-type-annotations and, 477 invalid characters, 62 keys v., 379 PathPattern and, 690, 691 validation and, 803, 805  XML, 379  whitespace-separated list of, 804 XML Schemas and, 61  IEEE 754 standard, 198, 576, 884 «if» expression, 278, 354, 521  boolean   and, 722, 771 effective boolean value and, 555 parentheses and, 528 substring   v., 885  IfExpr construct, 525, 551  keywords and, 525 if-then-else, 282, 283 ignorable characters, in collations, 886, 888 ignorable hyphens spaces  in collations   substring-after   and, 886 substring-before   and, 888 IKVMC cross-compiler, 1195 illustrations, numbering sequences for, 415 immutability of sequences, 633 implementation-deﬁned behavior, 954–955  collations. See collations extension attributes, 954 extension declarations, 106–107, 954 extension functions. See extension functions extension instructions. See extension instructions extension types, 954 localization attributes, 954  1263   implementation-dependent features  implementation-dependent features, 955 implicit timezone, 567, 580, 583, 585, 718, 738,  indeﬁnite precision, xs:decimal and, 575 indent attribute, 421, 422, 448, 934  806–807  current-date   and, 583  implicit-timezone   function, 716, 806–807  dynamic context and, 567  import precedence, 359–362, 1225. Seealso xsl:import  of declarations, 357, 361–362 deﬁnition description, 1225 determining, 359–361 effect of, 361–362 of global variables, 364–365, 502 for multiple xsl:import-schema declarations, 370 named templates, 485 priority and, 239, 243, 362, 400, 441, 484, 486 of template rules, 79, 94, 365–368, 484 xsl:apply-imports and, 239 xsl:attribute-set and, 267, 361 xsl:call-template and, 272 xsl:character-map and, 281, 361 xsl:decimal-format and, 299, 361 xsl:function and, 346, 361 xsl:import and, 94, 148, 357, 358, 362 xsl:import-schema and, 362, 370 xsl:include and, 148, 362 xsl:key and, 362 xsl:namespace-alias and, 362 xsl:output and, 362, 423 xsl:param and, 362 xsl:preserve-space and, 362 xsl:strip-space and, 362 xsl:template and, 243, 362 xsl:variable and, 362  import tree, 238 importing. Seealso xs:import; xsl:apply-imports;  xsl:import; xsl:import-schema schemas, 180–181, 368–372  with no target namespace, 482 XQuery and, 369  stylesheets, 237, 357–368 types from schema, 793  include-content-type  HTML output method and, 938 meta element and, 938, 940 XHTML output method and, 940 in xsl:output, 421, 422 in xsl:result-document, 447, 448  include directive, 374. Seealso xsl:include including stylesheets, conditionally at runtime, 374 incompatibility  comparing sequence of nodes to booleans, 589 comparing strings and, 588  incremental stylesheet processor, 988 increments other than one, for numbering sequences,  412  1264  in object-oriented languages, 363  inherit-namespaces, 289, 311. Seealso namespace  HTML output method and, 938 mixed content and, 934 XML output method and, 934 xml:space attribute and, 934  indentation, 147, 934 index, created using modes, 490 index, used by xsl:key, 379 index-of   function, 807–808 distinct-values   and, 750 items found in sequence with, 807  Indic Arabic digits, 302 «INF», 190, 576, 660 «-INF», 190, 576, 660 inﬁnity, 199  positive negative  «INF», «-INF», 199, 576, 660 xsl:decimal-format, 300, 302, 790  inﬁx operators, 526  «  » as, 627  information item, 62 Information Set, XML, 46, 62, 64, 65  W3C Recommendation, 62  inheritance, 393  inheritance  = ‘‘no’’, 291, 310 undeclare-preﬁxes and, 935 [xsl:], 113, 120, 310, 393  initial context item, 543 initial context node, 68 initial item, of each group, 328, 330 initial mode  template processing , 68 initial node, of each group, 330 initial sequence, in sorting process, 457 initial template, 68, 1225  deﬁnition description, 1225 in knight’s tour example, 1102–1104  initialization, conditional, 989–990 inline schema, 368  document, 175, 369  innermost ancestors, 542 input documents. See source documents input-type-annotations, 99, 467, 477–478  effect usage, 477–478 ID IDREF and, 477 Saxon and, 478  in-scope functions, 559–560  as constructor functions, 559 core library and, 559 as user-deﬁned functions, 560  in-scope namespaces, 555–556, 808, 864, 1225–1226  deﬁnition description, 1225–1226   in-scope schema deﬁnitions, 557–558  basic XSLT processors and, 557 xsl:import-schema and, 557  in-scope variables, 558–559 in-scope-preﬁxes   function, 61, 601, 808–809  namespace axis and, 808, 839. Seealso namespace  axis  namespace nodes and, 808–809 namespace undeclaration and, 809 namespace-uri-for-preﬁx   and, 809  insert-before   function, 212, 810 inserting items, 810 insigniﬁcant whitespace, 142, 465 instanceof  a sequence type , 653 «instance of» operator, 165, 217, 371, 538, 548, 654,  668, 677–678  sequence types and, 668  instance   function  XForms , 544 InstanceofExpr construct, 526, 677 instants in time, xs:dateTime and, 580 instructions, 69, 89, 90, 108–125, 1226. Seealso extension instructions; processing instructions; xsl:instruction  deﬁnition description, 317–318, 1226 in extension namespace, 317 ﬂow-of-control, 979 literal result elements v., 317 not recognized by XSLT processor, 318 in sequence constructors, 766 unknown, 318 as user-deﬁned extensions, 318 as vendor-speciﬁc extensions, 318 XSLT, 108–110, 764   full list , 109–110, 765 deﬁnition description, 766 element-available   and, 764–770  in XSLT namespace, 317, 765  IntegerLiteral symbol, 530 integers, 189. Seealso xs:integer  arithmetic operators and, 574–575 division, 572, 573. Seealso «idiv» maximum size, 574 overﬂow, 574 in reverse order, 637. Seealso reverse   function  integrity constraints, result document, 174 Intel XSLT processor, 9, 10 interleaved markup, 942, 995–996 Intermediate Language, 1195 intermediate results, in variables, 510 internal DTD subset, 930  character maps and, 942  International Resource Identiﬁers. See IRIs internationalization, 389 Internet Assigned Numbers Authority. See IANA Internet Explorer, 68  items  x e d n  I  embedded stylesheets and, 102 HTML boilerplate generation and, 910 WD-xsl and, 467   processing instruction, 101  interoperability, 460, 470, 567, 568 «intersect» operator, 57, 253, 353, 381, 538, 628–631  node is member of given set and, 630 path expressions and, 599, 628. Seealso path  expressions  XPath 1.0 and, 631  IntersectExceptExpr construct, 526, 629 intersection operator. See «intersect» operator interval between two dates times, 577 invented name  of namespace preﬁx, 256 as type annotation, 313, 314  IRIs  International Resource Identiﬁers , 23  converted to URIs, 811–812 URIs v., 812  iri-to-uri   function, 811–812. Seealso encode-for-uri  ;  escape-html-uri  ; escape-uri-attributes  encode-for-uri   and, 772 percent encoding in URIs and, 811–812 percent signs and, 812  «is» operator, 56, 538, 571, 593  deﬁnition description, 593 document   and, 756 «except» operator and, 593 generate-id   and, 797, 817 identical nodes and, 591, 593 NodeComp, 582 xsl:for-each-group and, 593  is-id property, 802 is-idref property, 805 Islamic calendar, 787 ISO 639, 819 ISO 3166, 819 ISO 8601 durations, format for, 236, 785 ISO, as calendar name, 785, 786 ISO format for dates and times, 785 ISO week numbers, 787 iso-8859–1, 365, 424 Italian language, 405  ordinals  «a», «o» , 407  item, context. See context item item types, 219, 1226  deﬁnition description, 1226 required, 505, 547 in sequence types, 653  item   item type, 653, 669, 713 items, 187–188, 189, 1226. Seealso atomic values;  ‘ﬁrst item’ rule; node s ; sequence s   inserting, 807  1265   ItemType construct  ItemType construct, 668 iteration  over sequence, 324 recursion v., 992–993  IXMLDOMDocument  MSXML interface , 1148–1149 IXMLDOMDocument2  MSXML interface , 1148–1149 IXMLDOMNode  MSXML interface , 1150–1151 IXMLDOMNodeList  MSXML interface , 1151 IXMLDOMParseError  MSXML interface , 1151–1152 IXMLDOMSelection  MSXML interface , 1152 IXPathNavigable  .NET interface , 1159 IXSLProcessor  MSXML interface , 1152–1153 IXSLTemplate  MSXML interface , 1153–1154  J  JAR archive, 868 Jasmine, 30 Java, 187, 502  APIs. See JAXP collation support, 731 collations in, 561 extension functions in, 134–135 linked to stylesheets, 136–137  host language, 528 mapping types to XPath, 961 processors  binding in, 959–961 extensibility in, 959–961  1196–1199  Standard Edition 6, 13 string comparisons in, 460 system properties, 139 user-deﬁned functions in, 546 Xalan-J and, 957 XPath within, 553 XQuery API for, 961  Saxon from command line on, 14–15, 103,  Java API, Altova and, 1219–1220 Java API for XML Processing. See JAXP Java Architecture for XML Binding. See JAXB Java methods  calling, 546, 959–961 calling from Saxon, 1206 function-available   and, 796  Java object, wrapped, 960 Java Server Page, 430 Java servlet, 430. Seealso servlets JavaScript, 107, 187, 502. Seealso Dynamic HTML;  ECMAScript; JScript  API, 430 client side, 286, 957 commented-out, 286–287, 943 as dynamically typed language, 959 escape-uri-attributes and, 938  1266  extension functions in, 134–135, 137 script and, 957 user-deﬁned functions in, 546 Xalan-J and, 957  java.text.Collator, 561 javax.xml.parsers  JAXP package , 1164–1166 javax.xml.transform  JAXP package , 1171–1186  Saxon and, 1199  javax.xml.validation  JAXP package , 1199 javax.xml.xpath  JAXP package , 1199 JAXB  Java Architecture for XML Binding , 961 JAXP  Java API for XML Processing , 68, 86, 100, 359,  427, 1163–1193  DOM and, 1166–1169 encoding attribute and, 941 identity transform, 1169, 1177, 1185 parser API, 1164–1169 pipelines in, 1190–1193 result trees and, 421 SAX and, 1164–1166 Saxon and, 1163 serialization attributes as output properties in,  1181–1182  transformation API, 1169–1186 Saxon and, 1163, 1199–1202  transformations  examples , 1183–1193  documents in memory, 1188–1189 SAX pipeline, 1190–1193 supplying parameters output properties, 1188 using ﬁles, 1187–1188   processing instruction,  1189–1190  URIResolver, 138, 567, 751, 755, 965, 1186 versions, 1163 Xalan and, 1163  JDK 1.1 speciﬁcation, 788, 790 jEdit, 1196  special characters and, 941  joins  hash, 644 with multiple range variables, 647 optimization of  with keys, 644 with Saxon-SA, 644  relational, 643 «some» expression and, 647 unordered   and, 902  JScript. Seealso ECMAScript; JavaScript extension functions in, 134, 709, 957 MSXML and, 957  transform document  example , 1154–1157  Julian calendar, 786, 787  Gregorian calendar and, 786   K  Kennedy family tree. See family tree  case study  Kennedy, John F., 1049, 1051 Kernow development environment, Saxon and, 10,  13–14, 1195  key deﬁnitions, 812, 813 key values, 813 key   function, 85, 325, 377, 384, 704, 812–818  associative access to nodes with, 813 grouping nodes and, 813 id   v., 804 literal and, 704–705 patterns in xsl:key and, 683 variable reference and, 704 xsl:key and, 812  key   pattern  example , 706–707 keys, 376. Seealso xsl:key  concat   function and, 730 as cross-references, 814–816 grouping. See grouping keys IDs v., 379 locating nodes by value with, 814 match attribute and, 377 multiple deﬁnitions for same, 383–384 multiple named, 383 multivalued, 381 name of, 377 node selection in any document with, 378 nodes with same, 378 optimization of joins with, 644 PathPattern and, 690 for same nodes, 383 simple, 379–380 sort. See sort key s  values of  use attribute and, 377  KindTests, 613, 616–617, 668, 670, 697–701  keywords  «comment», 616 ForExpr construct and, 525 IfExpr construct and, 525 «node», 617 «processing-instruction», 616 QuantiﬁedExpr construct and, 525 «text», 616  attribute  , 617 for attribute nodes, 699–700  simple type deﬁnition and, 700  child axis and, 695 comment  , 613, 700 for document nodes, 700 document-node  , 617, 700 element  , 617, 700 for element nodes, 698–699  languages  natural   x e d n  I  examples of, 617 global attribute declarations and, 699 matching nodes and, 670–672 node  , 613 node kind and, 697 NodeTests as, 613 PatternStep and, 697–701 processing-instruction  , 613, 616, 700 schema-deﬁned type and, 613, 698 schema-element  , 700 schema-element and, 699 substitution groups and, 701 syntax, 697–698 template rule priority and, 701 text  , 613, 700 type annotation and, 697 type hierarchy and, 701  Kleene operators, 669. Seealso «*»; «+»; «?» knight’s tour  case study , 221–222, 224, 1099–1114  algorithm, 1100–1104 displaying ﬁnal board, 1105–1106 ﬁnding possible moves, 1107–1109 ﬁnding the route, 1106–1107 initial template, 1202–1204 observations, 1112–1113 placing the knight, 1104–1105 running stylesheet, 1112 selecting best move, 1111–1112 trying possible moves, 1109–1110  Konqueror, 68  L  labels, type. See type labels lang attribute. Seealso xml:lang  of xsl:number, 409 of xsl:sort, 456, 460  lang   function, 819–820  xml:lang and, 819  language argument, 784 language code, 819 language-dependent numbering and sorting, 134 languages  natural   Bulgarian, 409 for days of week, 784 German, 409 «B» in, 827  Greek, 186, 429  «α, β, γ , δ» for numbering sequence, 409 character block, 922 polymorphic  many shapes  from, 186 « cid:5 »  sigma , 827 tunnel parameters and, 429 zero sign, 460  Hebrew, 410  1267   languages  natural    continued   languages  natural    continued   Italian, 405  ordinals  «a», «o» , 407  lang   and, 819–820 for months of year, 784 non-English, 409 Oriental, 827 preferred, 410 Russian, 409 Spanish, 731, 732, 781 Swedish, 561, 848 xsl:decimal-format and, 301 xsl:message and, 389 xsl:number and, 409 xsl:sort and, 456, 460  languages  programming , 546. Seealsospeciﬁc  programminglanguages  functional. See functional programming languages read-only, XPath as, 188, 526 templating, 973 for writing extension functions, 957  last or ﬁrst item in list  position   , 856 last speciﬁed template rule, 362 last   function, 85, 241, 323, 333, 820–824. Seealso  context size; count  ; position  ; xsl:number  «  » operator and, 703 binary « » and, 605 context size and, 564, 608, 620, 639, 820–824 count   v., 734 ﬁlter expressions and, 822 in patterns, 685, 823 positional predicates and, 702 within select expression of xsl:sort, 823 xsl:apply-templates and, 734, 821 xsl:for-each and, 734, 821 Latin letters, accented, 534 Latin scripts, non-, 491, 534 lax  validation = , 173, 259, 297, 305, 371  top-level schema declaration and, 314  layer, customization, 368, 429 layer, stylesheet, 360 lazy evaluation, 138, 487, 988  memory and, 637 «to» operator and, 637 LDAP directory, 42, 192 «le» operator, 538, 571, 581 default collation and, 584 NaN and, 586 ordered data types and, 584–586 ValueComp, 582  leading «  », 691 leading minus-sign, 530 leading whitespace, 142, 493  normalize-space   and, 493, 845–846  leading zeros, 300, 783, 790 leap seconds, 578  1268  least common type, 831 legal documents, sequence numbers for, 418 length, of strings, 880–881. Seealsozero-length strings level attribute  xsl:number , 404  level=any, 404, 415–417  numbering lines of poem  example , 417–418 rules, 407  level=multiple, 404, 418–419 recursive structures and, 419 rules, 407  level=single, 404  example, 413–415 rules, 406 usage, 411–412  lexical analysis, 528–529. Seealso tokenizing lexical constructs  XPath , 527–539. Seealso  comments; name s ; numeric literals; operators; string literals  lexical QNames, 50, 201, 228, 534, 1226. Seealso  xs:QName  deﬁnition description, 228, 1226 local part, 50 preﬁx, 50 QName   and, 858–859  lexical representations, of booleans, 552 lexical rules  XPath , 521, 524  comments and, 524 syntactic rules v., 524 whitespace and, 524  lexical tokens  whitespace between, 524  LF. See linefeed libraries. See function libraries libxslt processor, 10 line ending characters, 63, 142, 440, 939, 940. See  also newline characters  linefeed  LF , 64, 440 carriage-return, 64  linked tree  in Saxon , 1205 Lisp programming language, 429, 986 list s   comma-separated, 189  values enclosed in parentheses, 189  construction of, 635. Seealso comma operator ﬁrst or last item in, 856 of names, formatting, 356 of numbers, 407–408  aggregating  example , 993–995  whitespace-separated, 113  of IDs, 804 normalize-space   and, 846  list types, 53, 54, 163, 164, 1226  as content of node, 164 deﬁnition description, 1226 simple types as, 653, 670  list-valued attribute, atomization of, 353   A Manifesto for Adding SGML Intelligence to the World-Wide Web  x e d n  I  literal s , 530. Seealso numeric literals; string literals  id   function and, 704–705 key   function and, 704–705  literal constants  xs:decimal, 191, 530 xs:double, 191, 530 xs:integer, 191, 530 xs:string, 191. Seealso string literals  Literal construct, 539 literal result elements, 69, 73, 111–121, 176, 228,  260, 262, 476, 536, 1226 attributes on, 116–117, 255  xsl:attribute v., 255 xsl-preﬁxed, 112–114  content, 114 default-collation on, 468 default-validation and, 470, 471 deﬁnition description, 228, 1226 effect, 114 exclude-result-preﬁxes on, 468 extension instruction v., 766 extension-element-preﬁxes on, 468 format, 112 HTML table example, 116 instructions v., 317 named attribute set and, 117 namespace inheritance, 120 namespace nodes on, 118–119, 392, 394 notation for description of, 112 position, 112 usage, 114–116 use-attribute-sets attribute of, 268 use-when on, 468 validation, 176 version attribute on, 468 xpath-default-namespace on, 468 xsl:attribute and, 117 xsl:element v., 306, 308, 315 xsl:namespace and, 121 [xsl:]type attribute of, 370  literal string value, assigned to variable, 504 literal text, 492 local declarations, 298  of elements, 315  local name  of attribute, 260 of element, 308  local parameters  to functions, 425, 427 to templates, 425, 427  local part, of lexical QName, 50 local part, of name of node, 824 local type deﬁnition, 54, 315 local variables, 81, 487, 512, 1226  convenience, 507 deﬁnition description, 1226  forward reference to, 502 with same name, 502 scope of, 70, 501, 502 tunnel parameters v., 431 xsl:variable and, 501  Locale Data Markup Language, 392 locale-sensitive case mappings, 828 localization, 107, 301  attributes, implementation-deﬁned, 954 of messages, 389–390, 410 local-name, NameTests and, 615 local-name-from-QName   function, 202, 826–827  local-name   function, 51, 824–826. Seealso name  ;  xs:NCName and, 826 xs:QName and, 826  namespace-uri    LocalPart construct, 534 locating  items in sequence, 807–808 nodes  key   and, 814 list of functions for, 711  schemas, 314  catalog repository and, 314 xsi:schemaLocation and, 314  stylesheet module, 357–359 text within document  example , 413–415  look-up tables, 107, 321, 510, 753  messages as, 510 in stylesheet, 761–763  loops, nested, 643 lower-case   function, 21, 204, 827–828  case variants and, 926 case-insensitive comparison with, 828  attribute  «lt» operator, 458, 538, 571, 581  default collation and, 584 max  , min   and, 831 NaN and, 586 ordered data types and, 584–586 ValueComp, 582  lower-case upper-case letters, 461. Seealso case-order  M  «m» ﬂag, 926  «$» and, 926 «ˆ» and, 926 multiline mode and, 926 string mode and, 926  major atomic types, 193–206. Seealso atomic types major-to-minor order, 242, 324, 456. Seealso sort  key s   mandatory parameter, 428 ‘‘A Manifesto for Adding SGML Intelligence to the  World-Wide Web,” 27  1269   map operator  in functional programming languages   map operator  in functional programming  languages , 604  mapping Java to XPath types, 961 mapping sequences, 641–642 mappings, case, 827. Seealso lower-case  ;  upper-case    mappings, from URIs to documents, 568 markup  comments with, 287 double markup, 942 interleaved, 942, 995–996 parallel, 995–996 standoff, 995–996  match attribute  errors and, 485, 688 of xsl:key, 377 of xsl:template, 68, 484–485  errors and, 485 global parameters and, 485 global variables and, 378, 485 pattern, 484 template rules and, 487 xsl:apply-templates and, 484  match patterns. See patterns matches   function, 204, 234, 828–830  ends-with   and, 774 regex and, 828–830 regex syntax and, 915–927 replace   v., 898  matching. Seealso comparing  atomic values, 669–670 elements attributes, 672–677 newline characters in regex, 917, 926 nodes, 670–672 spaces, in regex, 921, 924 substrings with collations, 731–732, 876  minimal, 886, 888  by type, 219–221, 981 words, in regex, 921  matching document-node   function  well-formed document and, 671, 700 mathematical concept of function,987 mathematical concept of variable,989 mathematical function library, 135, 200, 346 math:sqrt   function, 346 max   function, 200, 275, 830–832  comma operator and, 635, 831 «lt» operator and, 831 one-or-more   and, 854  maximum size of integer, 574 maximum minimum values in sequence, 820–822 media attribute    , 101  Firefox and, 101 Internet Explorer and, 101  media-type, 934  1270  fragment identiﬁer and, 756 HTML output method and, 939 HTTP header and, 934, 939, 940 of stylesheet modules, 470 and unparsed-text  , 905 XHTML output method and, 940 XML output method and, 934 in xsl:output, 421, 422 in xsl:result-document, 447, 448 MEI. See Music Encoding Initiative memory  document built in, 752 free, 137 holding documents in  JAXP interface, 1188–1189  lazy evaluation and, 637 merging attribute sets, 267 merging character maps, 282 messages, 386–390. Seealso xsl:message  HTML  charset attribute , 938, 939, 940, 941 XHTML  charset attribute , 939, 940, 941  examples, 388–390 localized, 389–390, 410 as look-up data, 510 in native language, 389 order of, 388  meta element, 422, 447  metacharacters  regex   «$», 233  «m» ﬂag and, 926 «.», 232, 917, 926  «s» ﬂag and, 917, 926  «ˆ», 233, 920  «m» ﬂag and, 926   list , 232  meta-stylesheets, 393, 396 method  serialization parameter , 929 method attribute, 421, 446, 448 micropipeline, 88, 402 Microsoft  APIs, 100, 427 cp1252, 937 MSXML processor. See MSXML processor .NET framework, 9, 15 System.Xml.Xsl processor. See System.Xml.Xsl  processor  WD-xsl and, 467  midnight  time value , 743, 800 MIME type, 422, 447, 470, 756, 905, 934, 939, 940.  Seealso media-type  min   function, 200, 275, 830–832  «lt» operator and, 831 one-or-more   and, 854  minimal matching substring, 886, 888   minor atomic types, 193, 206–210. Seealso  atomic types  binary, 208 partial date, 207 single-precision ﬂoating point, 208 xs:duration, 205, 208–209 xs:NOTATION, 180, 190, 209–210  minumum maximum values in sequence, 830–832 minus-sign, 538. Seealso «-»; additive operators;  hyphens; unary minus operators  hyphen v., 538, 572 leading, 530 xsl:decimal-format, 300, 789, 790  minutes component  in format-time  , 782 from xs:date, 832 from xs:dateTime, 832 from xs:duration, 832–833  minutes-from-dateTime   function, 832 minutes-from-duration   function, 832–833 minutes-from-time   function, 832 mixed content, 53, 146, 155–156, 441, 499  indent attribute and, 934 schema types and, 742  «mod» operator, 200, 417, 538, 571  «div» and, 572, 575 «idiv» and, 572, 575 precedence, 572 remainder from integer division and, 572, 575  mode attribute, 242, 484, 486 modes  compatibility . See backward-compatibility  mode; forward-compatibility mode  modes  regex evaluation   case-insensitive, 231, 925  «i» ﬂag and, 925–926  dot-all, 231, 926  «s» ﬂag and, 917, 926  multiline, 231, 918 «m» ﬂag and, 926  string, 926  1226  current, 238, 242, 273, 346, 485, 486 default  unnamed , 238, 242, 485, 486 deﬁnition description, 1226 document   and, 758 examples, 247–251, 490–491 index creation with, 490 initial, 68 named, 249 not sticky, 242 sticky, 243 table of contents and, 490 template rules and, 242, 402 tunnel parameters and, 431  multiple source documents  x e d n  I  xsl:apply-templates and, 247–251, 484, 486 xsl:include and, 374  modular structure, of stylesheets, 90–98 modules, stylesheet. See stylesheet s  month component  in format-date  , 782 language for, 784  from xs:date, 833–834 from xs:dateTime, 833–834 from xs:duration, 834  month-from-date   function, 212, 833–834 month-from-dateTime   function, 833–834 months-from-duration   function, 834 MSXML processor  Microsoft , 9, 66, 137, 143, 567,  767, 1147–1158  AltovaXML and, 1216 binding extension functions in, 957–959 in browser  example , 1095–1098 COM API and, 1147–1153 DOM in, 1147–1152 extensibility in, 957 handling whitespace nodes, 567, 1158 JScript and, 957  transform document  example , 1154–1158  normalization of text nodes, 1158 objects in, 1148–1154 parser, 388, 440  xsl:message and, 388  restrictions, 1158 transformNode  , 941 VBScript and, 957 versions, 1148  msxml:node-set  , 321 msxsl:script, 107, 134, 137, 477 Muench, Steve, 816 Muenchian grouping method, 816 multicharacter escapes, 921 multilevel grouping  example , 333–335 multiline mode  regex evaluation , 231, 918  «m» ﬂag and, 926  991–992  example, 511–513 intermediate results of, 510 pipelines and, 991–992. Seealso pipelines  multiple input sequences, 643–644  «for» expression and, 643–644 multiple level. See level attribute multiple named keys, 383 multiple result documents, 44–45, 435, 445, 450  examples, 451–452, 767–769  element-available   and, 767–769  XSLT 1.0 processors and, 44–45, 319–320  multiple source documents, 44–45, 326, 482, 510, 692  « » pattern and, 692  1271  modes  template processing , 68, 78, 88, 242, 274,  multiphase transformations, 68, 87–88, 90, 402,   multiple xsl:import-schema declarations  multiple xsl:import-schema declarations, 370 multiplication of durations, 577, 579 multiplicative operators, 200. Seealso «*»; «div»; «idiv»;  «mod»  MultiplicativeExpr construct, 526, 572 multivalued keys, 381 Music Encoding Initiative  MEI , 6 music transformation, XSLT and, 5–7 musical symbols, 63 MusicXML, 6–7  N  name s   attribute. See attribute names; name attribute characters, matching in regex, 921 decimal-format, 299, 789 element. See element names function. See function names list of  formatting, 356  local. See local name of nodes, 46, 47, 50–51. Seealso local-name  ;  name  ; node-name    comparing, 859 local part of, 824 name   and, 835–837 of parameters, 428–429 same  with, 346 timezone, 787 type. See type names unpreﬁxed. See unpreﬁxed names of variables. See variables  user-deﬁned functions and vendor-supplied functions  name s   in XPath expressions , 534–537. Seealso  LocalPart; NCName; NCNameChar; Preﬁx; QNames  case-sensitive, 535  name attribute, 485  name of key and, 377 name of namespace node and, 390 xsl:call-template and, 124, 272, 485 named attribute sets. See attribute sets named decimal format, 299 named global types, 313 named modes, 249 named templates, 95, 107, 124, 362, 1226  deﬁnition description, 1226 evaluated at runtime, 272 import precedence, 485 invoking, 271 recursive, 350 stylesheet function as wrapper for, 349 stylesheet functions v., 347, 349–350 as wrapper for stylesheet function, 349  1272  name   function, 51, 835–837. Seealso local-name  ;  namespace-uri  ; node-name    namespace preﬁx and, 835 principal node kind and, 836 «self» axis and, 836  namespace s   .NET assembly   System.Xml, 138  namespace s   XML , 23–24, 1226. Seealso  Namespaces 1.1, XML  aliasing for, 397 attribute nodes v., 256 declarations. See namespace declarations default. See default namespaces deﬁnition description, 1226 extension, 138 for extension functions, 471 for functions, 547 functions in same, 349 in-scope. See in-scope namespaces null, 58, 866 starting with http:  www.w3.org, 345 target, 180, 370 undeclarations. See undeclarations, namespace in XDM tree model, 59–60 XML Schema, 99, 135  namespace alias, 121, 263. Seealso  xsl:namespace-alias  stylesheet generation and, 121 for xsi namespace, 183  namespace attribute xsl:attribute, 255 xsl:element, 308 xsl:import-schema, 180  namespace axis, 61, 601, 609, 611, 808, 1226. See  also in-scope-preﬁxes  ; namespace-uri-for-preﬁx    namespace declarations, 56, 58, 358, 472, 555, 1226  deﬁnition description, 1226 deprecation, 61, 601 in-scope-preﬁxes   and, 808, 839 namespace declarations and, 611 namespace nodes and, 611, 617  order of, 611  namespace-uri-for-preﬁx   and, 808, 839 node tests and, 613 ordering of nodes on, 620  attribute nodes and, 610 attribute value templates and, 124 default. See default namespace declarations deﬁnition description, 1226 duplicate, 119, 309, 473 generating, 256 namespace axis and, 611 namespace nodes v., 391, 932 with output document, 262 QNames and, 535   NameTests  x e d n  I  scope, 58 from serializer, 391 unwanted unnecessary, 471, 473–474, 475 WD-xsl and, 467 XML output method and, 932 XPointer, 556 XQuery, 556 xsl:attribute and, 391 on xsl:stylesheet, 99, 466–467 XSLT namespace, 466, 765  namespace ﬁxup, 256, 262, 289, 291, 296, 310–311,  391, 392, 474–475, 1226  deﬁnition description, 310–311, 1226 namespace nodes acquired with, 310–311, 392, 393 preﬁxes changed with, 310–311 preﬁxes in result document and, 397 preﬁx-from-QName   and, 857 schema validation and, 393 temporary trees and, 932 XML output method and, 932  namespace http:  www.w3.org 2001 XMLSchema  xs  namespace preﬁx , 135, 190  namespace inheritance, 120, 310, 311–312  namespace nodes, 49, 56, 59, 262, 289, 471, 1226  disable, 312  acquiring, 392–393  element as child of another element and, 392–393 literal result elements and, 392 with namespace ﬁxup, 310–311, 392, 393 xsl:copy and, 392 xsl:copy-of and, 392 xsl:namespace and, 393  adding, with namespace ﬁxup, 310–311 construction of  xsl:namespace and, 390  copied from source document, 474 copying, 296–297, 311 creation of, 60 deep-equal   and, 746, 747 deﬁnition description, 1226 getting rid of extraneous, 291 in-scope-preﬁxes   and, 808–809 on literal result elements, 118–119, 394 name attribute and, 390 namespace axis and, 611, 617 namespace declarations v., 391, 932 namespace-sensitive content and, 60–61 namespace-uri-for-preﬁx   and, 839–840 order of, 393 redundant, 394 string value, 51  select attribute and, 391  namespace preﬁxes, 58, 121, 1226–1227  in content of elements attributes, 392 deﬁnition description, 1226–1227  DTD-based validation and, 857 invention of, 256 name   and, 835 in names of variables, 541 namespace URI corresponding to given, 839 NameTests and, 615, 696, 697 QNames, 262, 535 in scope, 808–809 in xs:QName, 857  namespace URIs, 50–51, 58, 1227  aliasing of, 396 changing, 296 corresponding to given preﬁx, 839 default  for function names, 545  deﬁnition description, 1227 equality of, 58 expanded QNames and, 50–51, 840–841 http:  www.w3.org XML 1998 namespace  xml preﬁx mapped to, 311  as part of element name, 308 relative, 55 zero-length strings and, 391  namespace, XML, 472 namespace, XSLT, 466, 471, 475 Namespaces 1.1, XML, 23–24, 119, 443, 471  overview, 58–59 Recommendation, 24, 58, 474, 534 standard, 522 undeclarations. See undeclarations, namespace XML output method and, 930  namespace-sensitive content, 60–61, 260, 310, 311 namespace-uri-for-preﬁx   function, 61, 839–841. See  also in-scope-preﬁxes  ; resolve-QName    in-scope-preﬁxes   and, 809 namespace axis and, 839. Seealso namespace axis namespace nodes and, 839–840 namespace undeclaration and, 840–841  namespace-uri-from-QName   function, 202, 841–842.  Seealso local-name-from-QName  ; QName    namespace-uri   function, 51, 615, 837–839. Seealso  local-name  ; name    xs:anyURI and, 838  NameTests, 439, 613, 614–616, 696–697  «*», 440, 696 attribute axis and, 695 in AxisStep, 482 child axis and, 695 examples of, 615–616 forms of, 440 local-name and, 615 namespaces and, 615, 696, 697  variants of, 697 XHTML, 697  NCName as, 440  1273   NameTests  continued   NameTests  continued   no namespace preﬁx and, 615, 697 NodeTests as, 613 PatternStep and, 696–697 principal node kind and, 613, 614, 696 priority and, 440 RSS and, 697 schema-aware processor and, 696 XPath default namespace and, 696  deﬁnition description, 1227 «eq» and, 329 equal to itself, 459 general comparisons and, 589 «lt», «le», «ge», «gt», and, 586 number   function and, 573, 852 string converting from double and, 660 sum   and, 889 xs:double and, 586, 852 xs:ﬂoat and, 586 xsl:decimal-format, 300, 790  NaN  not-a-number , 80, 199, 302, 406, 454, 1226  narrative XML, 53 native language, messages in, 389. Seealso languages navigating  graphs, 275 hierarchies, 275 trees, 189  navigational stylesheets  design pattern , 976–980,  1114. Seealso family tree  case study   procedural v., 979  Naxos Breakfast Supplies example, 380 NCName, 534. Seealso xs:NCName  as NameTest, 440  NCNameChar, 534 NDATA  non-XML data , 209, 903, 906 «ne» operator, 538, 571, 581  «eq» v., 584 operand types for, 583–584 ValueComp, 582 negative dates, 196 negative durations, 578, 580 negative group  character group , 919 negative inﬁnity  «-INF», 199, 576, 660 xsl:decimal-format, 300, 302, 790  negative numbers, 199  parentheses for, 301, 790 sub picture for, 301  negative subpicture, 790 negative zero, 199, 576  ceiling   and, 723  nested comments, 529 nested groupings, 334 nested loops, 643 nested sequence constructors, 73–74  1274  nesting  curly brackets and, 123 sequences and, 188, 633  .NET framework  Altova and .NET API, 1220 dynamic loading of assemblies in, 962 languages, extension functions in, 957 Saxon on, 15 C and, 957  System.Xml namespace in, 138  System.Xml.Xsl processor. See System.Xml.Xsl  classes, 567  processor  XmlResolver, 138, 567, 751, 755, 965  network, of related objects, 351. Seealso graphs New Year’s day, 787 newline characters, 63, 532   x0A , 917, 926 line ending in XML, 63 matching in regex, 917, 926 serializing, 939, 940 in string literal, 532  NFC  normalization form C , 848  accents and diacritics in, 880, 884 normalize-unicode   and, 848, 881 nillability, 182–183. Seealso xsi:nil  nillable elements, 183 nilled elements, 183 nilled ﬂag, 477  nilled property, 843 nilled   function, 842–843  schema validation and, 842 xsi:nill and, 843  node  , 617, 685, 698, 713  child axis and, 671 KindTest, 613 NodeTest, 162  node s , 49–57, 1227  ancestors of. See ancestors associative access to, 813 attribute. See attribute nodes base URI, 54–55 children of. See children, of nodes classiﬁcation methods, 50 comment. See comment nodes comparisons. See node comparisons context. See context node copied, 57  validation of, 297  creation of  from functions, 550 XSLT instructions templates and, 550  deﬁnition description, 1227 depth of, 274 document. See document nodes   document order, 57–58 document   applied to, 757–758 duplicate, 328  removal of, 378, 544, 603  element. See element s  even-numbered, 241 extension functions and, 961 hierarchic position of, 407 identity  document order duplicates and, 602, 629 functions and, 988 keys for same, 383 kinds. See node kinds matching, sequence type descriptors and,  670–672  names of, 46, 47, 50–51. Seealso local-name  ;  name  ; node-name    comparing, 859 local part of, 824 name   and, 835–837  namespace. See namespace nodes numbering of, 403 odd-numbered, 241 parent. See parent nodes parentless. See parentless nodes peer, numbering of, 406 processing instruction. See processing instructions returning references to, 453, 455 root. See root nodes with same key, 378 in sequences, 187–188, 633. Seealsosequence s  sets of. See sets of nodes string value. See string value test contents of, 552 text. See text nodes type annotations of. See type annotations typed values of. See typed values UML class hierarchy, 50, 56–57 URIs held in, 757  changes in XPath 2.0, 594 by identity, 591, 797  node kinds, 46, 47, 49, 607, 1227  built-in template rule, 79 deﬁnition description, 1227 NameTest and, 697 PathPattern and, 690 PatternStep and, 694 principal, 613, 614  node tests, 528, 599, 613–614  attribute axis and, 613 in axis steps, 606 examples of, 613–614 function names and, 528 namespace axis and, 613  normalization  x e d n  I  NodeComp construct, 582 NodeInfo interface  in Saxon , 1205 NodeName construct, 698 node-name   function, 51, 843–845  expanded name of node and, 843–844 QName   and, 859 xs:QName and, 843–844  node-set   extension  example , 794–796 node-set   extension function, 87 node-sets, 32, 39, 186, 601, 629, 633. Seealso  sequence s   NodeTests «*», 617 attribute  , 162 axis steps and, 607 document-node  , 162 element  , 162, 164 as KindTests, 613 as NameTests, 613 node  , 162  no-namespace schema  example , 372 non-ASCII characters, 811, 812  escaping, 776  nonbreaking space characters, 38, 142, 148, 281, 367,  732, 880, 938  «&nbsp;», 64, 281, 367, 938 character maps and, 943 normalization of, 880  noncomparable types, 329 non-consecutive numbering sequences, 416 non-document tree, 626 nonempty node sequence, testing for, 276 non-greedy quantiﬁers  regex , 232, 863, 917 non-Gregorian calendar, 786 non-Latin scripts, 534  non-schema-aware processors. See basic XSLT  weights in, 491  processors  characters  nonunique keys  example , 381–383 non-validating XML parser, 803, 805, 904 non-XML data  NDATA , 209, 903, 906 normal characters  regex , 917  atoms as, 917  normalization  attribute value, 64, 142, 532 of combining character, 880, 884 duration value, 745 early, 848 forms, 847, 848 of nonspacing characters, 880 of strings, 849 term,144  1275  node comparisons, 593–594. Seealso «[[»; «]]»; «is»  nonspacing characters. See nonbreaking space   normalization  continued   normalization  continued   of Unicode characters, 422, 447, 561, 731, 847–849 whitespace, 528, 663, 665 normalization form C. See NFC normalization-form, 421, 422, 447, 448, 934  HTML output method and, 939 normalize-unicode   and, 934 XML output method and, 934  normalize-space   function, 144, 148, 204, 215, 665,  845–846. Seealso concat  ; substring-after  ; substring-before    leading trailing whitespace and, 493, 845–846 whitespace and, 493, 845–846 whitespace-separated list of values and, 846 xsl:strip-space v., 846 xs:normalizedString v., 144, 215, 846 xs:whiteSpace facet and, 846  normalize-unicode   function, 204, 847–849. Seealso  serialization  character normalization and, 848–849 concat   and, 849 NFC and, 848, 881 normalization-form and, 934 string-join   and, 849 string-length   and, 880–881  not sticky modes, 242 not-a-number. See NaN NOTATION. See xs:NOTATION notation, XPath, 522–523 not   function, 135, 552, 850–851. Seealso boolean  ;  false  ; true    «!=» operator and, 850–851 «=» operator and, 850–851 effective boolean value and, 850 Novatchev, Dimitre, 251, 347, 955  FXSL library of, 251, 347, 546, 955  null namespace  XML , 58, 866 null values, 57, 203  SQL concept of, 182  empty sequence and, 586  number s , 201. Seealso inﬁnity; NaN; xs:decimal;  xs:double; xs:ﬂoat; xs:integer; xsl:number; zero s   absolute value of, 714 arithmetic. See arithmetic operators average of. See avg   cardinal, 409, 783 comparing, 583, 585 promotion and, 585  constant. See literal constants converted to strings, 531 double precision. See double precision numbers formatting, 403, 408–410, 788–791 fractional part of, 790  «» and, 790  functions. See numeric functions  1276  Greek, 409 Hebrew, 410, 783 list of, 407–408 negative. See negative numbers ordinal, 409, 783  Italian  «a», «o» , 407  predicates as. See numeric predicates Roman numeral, 409, 410, 782 rounding. See rounding numbers section, 405 sequence. See sequence numbers term,1227 totals of, 889–890. Seealso sum   as words, 783  number of digits displayed, 300 number of items in sequence, 733 number types. See numeric types number   function, 200, 454, 458, 588, 851–853. See  arguments automatically converted to numbers with,  also string    573, 851  backward-compatibility mode and, 852 «castable as» operator and, 853 conversion to xs:double and, 852 exponential notation and, 851 leading «+» sign and, 851 NaN and, 573, 852 numeric comparison and, 588 predicates and, 853 xs:double and, 851  numbering  of days of week, 785 of equations, 407, 415 of weeks of year, 785 numbering schemes, 784 numbering sequences. Seealso sequence numbers  for actions from meeting, 415 for equations, 407, 415 for ﬁgures, 415 for footnotes, 407, 410, 415, 417 Greek, 409 Hebrew, 410, 783 for illustrations, 415 in increments other than one, 412 language-dependent, 134 for lines of poem, 417–418 for nodes, 403 non-consecutive, 416 for peer nodes, 406 Roman numeral, 409, 410, 782 for siblings, 406, 411–412 starting at one, 409 starting at value other than one, 412 for tables, 415 vendor-deﬁned, 134   numerals, Roman, 409, 410, 782 numeric calculations. Seealso arithmetic operators;  «o»  Italian ordinal , 407 object-oriented programming  O  as words, 409, 783 XSL Formatting and, 410  numeric functions  precision of, 531 «div» and, 575 indeﬁnite, 575 xs:decimal and, 575  operators  x e d n  I  inheritance in, 363. Seealso xsl:import super   in, 237, 400  occurrence indicators, 163, 179, 538, 547, 669, 713.  Seealso «*»; «+»; «?»  as attribute and, 179 SequenceType and, 505  OccurrenceIndicator construct, 668, 669 odd-numbered nodes, 241 ODF speciﬁcation, 4 omit-xml-declaration, 421, 422, 447, 448, 935  in XHTML output method, 940 XML declarations and, 421, 422, 447, 935, 940 in XML output method, 935 in xsl:output, 421, 422 in xsl:result-document, 447, 448  one-or-more   function, 853–854  avg   and, 854 empty sequence and, 853 max   and, 854 min   and, 854 static type checking and, 853 type errors and, 853 OOXML speciﬁcation, 4 OpenGIS schema, 557 Opera, 68, 100 opera example, 507–510 operand types for value comparisons, 582–586 operands  atomization of. See atomization conversion to strings, 586 as sequences, 588  operations, polymorphic, 186 operator precedence, 537–538  «[ ]» predicate operator and « » path operator, 618 parentheses and, 542 production rules and, 523  operator priority. See operator precedence operators, 537–539. Seealsospeciﬁcoperators  additive. See additive operators arithmetic. See arithmetic operators boolean. See boolean operators difference. See «except» operator ﬁrst-order, 537–538 general comparison. See general comparisons higher-order, 538–539 inﬁx, 526, 627 intersection. See «intersect» operator Kleene, 669 multiplicative, 200 node comparison. See node comparisons numeric comparison, 200  1277  numeric character references. See character references numeric comparison operators, 200 numeric equality, 200, 583 numeric formats, 1141. Seealso xs:decimal; xs:double;  xs:ﬂoat; xs:integer  backward-compatibility mode and, 1141  numeric functions. Seealsospeciﬁcnumericfunctions  abs  , 200, 714–715 avg  , 200, 718–719 ceiling  , 200, 723–724 ﬂoor  , 200, 779–780 format-number  , 298, 531, 576, 788–792 list of, 710 max  , 200, 275, 830–832 min  , 200, 275, 830–832 number  , 200, 454, 458, 588, 851–853 round  , 200, 870–872 round-half-to-even  , 200, 212, 531, 576, 872–873 sum  , 200, 889–890 numeric literals, 530–532  decimal places and, 531 XML Schema and, 531  numeric order, 585 numeric output, formatting, 531. Seealso  format-number  ; xsl:number  numeric overﬂow, 659, 661 numeric predicates, 608, 618, 619, 638  effective boolean value and, 638 «idiv» and, 639 number   and, 853 position   and, 619, 638  numeric ranges, 636–637. Seealso «to» operator numeric type promotion, 81, 427, 458, 506, 548, 713,  1228  arithmetic operators and, 572, 585 xs:decimal, 572, 585 xs:double, 572, 585 xs:ﬂoat, 572, 585 xs:integer, 572, 585  numeric types, 506, 549, 713. Seealso xs:decimal;  xs:double; xs:ﬂoat; xs:integer  derived, built-in, 192, 193, 210–213  numeric values. See numbers NumericLiteral construct, 539   optimization, 107. Seealsolazy evaluation; performance  operators  continued   operators  continued   numeric equality, 200 precedence of. See operator precedence predicate, 618 preﬁx, 526 priority of. See operator precedence pseudo-. See pseudo-operator reserved words and, 538 set, 629. Seealso Venn operators tokens as, 538 type, 538 unary minus, 200 union. See «union» operator value comparison. See value comparisons Venn. See Venn operators whitespace and, 538  of joins  with keys, 644 with Saxon-SA, 644 performance, 67, 350 tail-call, 487, 966, 993 types and, 186, 431  619, 643, 686 trace   and, 896  optional digit placemarker, 789 optional tunnel parameters, 430 «or» expression, 186, 537, 552  boolean   and, 722 error semantics for, 1144  Oracle XSLT processor, 9, 957  extension functions in Java, 957  order  of appearance, 248, 330 arbitrary, of expressions, 901–902 ascending, 459 of attributes, 64, 241, 323  deep-equal   and, 747 undeﬁned, 316  optimizers, 140, 177, 350, 351, 449, 497, 586, 618,  of data types, 584–586 of declarations  in stylesheets , 105, 360, 486 descending, 458, 459 document. See document order of elements, 64 of execution, 80, 323  assignment statements and, 986  of groups, 328 major-to-minor, 242, 324, 456 of messages, 388 of namespace nodes, 393 numeric, 585 population  grouping , 327, 330, 739 of results of expressions, 901. Seealso unordered   reverse, 324, 458. Seealso reverse    1278  speciﬁed, comma operator and, 635 of strings, 584 undeﬁned. See undeﬁned order  ordinal numbers, 409, 783  Italian  «a», 407 «o», 407  OrExpr construct, 525, 594 Oriental scripts, 827 Othello  Shakespeare play . Seealso Shakespeare plays  interleaved markup, 995–999 modes example, 247–251 rule-based stylesheet example, 981–985 tunnel parameters example, 433–437 word count example, 19–21  outermost ancestors, 542 outermost element, 48 output deﬁnition, 423 output documents. See result documents output methods, 1227. Seealso HTML output method;  serialization; text output method; XHTML output method; XML output method  output properties  JAXP , 1181, 1182. Seealso  serialization, attributes  OutputKeys  JAXP class , 1173–1174 outputs, 41  hyperlink, 435 numeric, 531 post-process, 235  OutputURIResolver  Saxon , 449, 1197 output-version, 447, 448 overﬂow, 575, 576 arithmetic, 719 integer, 574 numeric, 659, 661  overlay stylesheet modules, 320, 368  XML speciﬁcation case study, 1041–1044  diffspec.xsl, 1003, 1041–1044 REC-xml.xsl, 1003, 1044 overloading, of functions, 546 override attribute  xsl:function , 346–347 override overriding, 94, 136, 268  declarations, 364 template rules, 237 xsl:param, 431  oXygen development environment, 10, 12, 13, 1195  P  page footers, 293 page headers, 293 parallel hierarchies, interleaved markup and, 942 parallel markup, 995–996 parallel processing, 245, 309, 323, 330   PathExpr construct  x e d n  I  parameters, 68, 82, 1227. Seealso xsl:param  for attribute values in named attribute sets, 268 call-by-value, 273 declaration of, 82 default value of, 244, 273, 427, 428–429, 487 deﬁnition description, 1227 evaluation, 244 expected type of, 431 global. See global parameters lazy evaluation, 138, 487 local. See local parameters mandatory, 428 names, 428–430  scope of, 429 uniqueness of, 429 passing on, 243, 244 stylesheet. See stylesheet s  template. See template parameters tunnel. See tunnel parameters type declarations of, 161 type  required  of, 425, 427–428, 431, 487 values of  as document node, 306 xsl:with-param and, 517–518  xsl:apply-imports, 238 xsl:call-template, 272–273 parameters  serialization , 929  «method», 929  parent axis, 609, 612, 621, 1227  «..» as, 621, 623 deﬁnition description, 1227  parent nodes, 55, 623  children relationship v., 55, 623 RelativePathPattern and, 693  parentheses, 542–543  « » in, 624 «,» operator and, 525, 542 empty sequence and, 542 «if» expression and, 528 for negative numbers  accountancy , 301, 790 operator precedence and, 542 predicates and, 542 in regex, 234, 918  parenthesized subexpressions  regex , 234, 918 ParenthesizedExpr construct, 542–543 parentless nodes attributes, 257 elements, 55, 87 patterns and, 683, 684, 688–689 PatternStep and, 695  parsed entity references, 64  external, 48, 87  parsers  SAX, 8, 1164 XML, 8, 752  non-validating, 803, 805, 904 validating, 62, 752, 904  XML 1.1, 104, 440 XPath, 527  parsing documents, 43, 752, 756–757 part explosion, 251 partial date types, 207  xs:gDay, 207 xs:gMonth, 207 xs:gMonthDay, 207 xs:gYear, 207 xs:gYearMonth, 207  partially ordered dates, 196, 585 particles  in schemas , 1227. Seealso complex types;  element declarations  partitioning, 328 passing on parameters, 243, 244 path expressions, 39, 57, 83–84, 189, 322, 350,  599–632, 1227 «  » and. See «  » abbreviated. See abbreviated path expressions abbreviated axis steps and, 599 absolute, 625. Seealso rooted path expressions axes and, 599 axis steps and. See axis steps binary « » and. See « » changes in XPath 2.0, 601–602 changing focus with, 565 context item and, 543, 644 deﬁnition description, 1227 distinguish simple mapping expressions from, 645 document order and, 644 element names in, 482 examples of, 600–601 «except» operator and, 599, 628 «for» expressions v., 644  simple mapping expressions v., 645  «intersect» operator and, 599, 628 nodes in tree and, 599 predicates in, 639  predicates in ﬁlter expressions v., 639–640  rooted. See rooted path expressions SELECT statement v., 568, 632 sets of nodes and, 599 simple mapping. See simple mapping expressions steps and, 83, 599 syntax, 526 «union» operator and, 599, 628 variable reference as ﬁrst component in, 626 Venn operators and. See Venn operators  MSXML3, 388, 440. Seealso MSXML processor pull, 8  PathExpr construct, 526, 625  PathPattern in, 690  1279   PathPattern construct  PathPattern construct, 690–692  ID attribute and, 690, 691 key value and, 690, 691 kinds of, 691 node kind and, 690 in PathExpr, 690 Pattern and, 690 «» and, 690 PathPattern and, 690 UnionExpr and, 690 pattern facet, 236, 665  Pattern construct, 690  canonical form and, 667 converting non-string values to derived types and, 667 regular expressions and, 667, 829  PatternAxis construct, 695–696  attribute axis and, 695 child axis and, 695 PatternStep and, 695–696  pattern-matching processing, 78. Seealso push  processing technique  patterns  stylesheet design , 973–1000. Seealso  design patterns  patterns  XSLT , 68, 214, 228, 377, 483,  681–708, 1227  « », 692 algorithm for matching, 685 axes in, 683  attribute, 683 child, 683  changes in XSLT 2.0, 682–683 chevrons and, 689 circularity and, 378, 485, 683 conﬂict resolution, 69, 73, 79–80, 686–688 context and, 683 current   and, 683, 736 default priority of, 686–687, 691 deﬁnition  formal, 683–685 informal, 685–686  deﬁnition description, 228, 1227 element names in, 482 in elements, 681. Seealso xsl:for-each-group; xsl:key;  xsl:number; xsl:template  expressions v., 681–682 group-ending-with attribute, 330 grouping with, 740 group-starting-with attribute, 329–330, 340 key  , 706–707 last   function in, 685, 823 match attribute, 484 match nodes according to schema-deﬁned type, 683 match nodes by name, 696 parentless nodes and, 683, 684, 688–689 position   function and, 685  1280  predicates in, 683, 685  runtime errors and, 688  QNames as, 536 starting with « », 689 syntax of, 483, 689–707 template rules and, 681, 686, 696 union, 384, 400, 419, 686 unpreﬁxed names in  xpath-default-namespace and, 481–482  in XProc, 682 in xsl:for-each-group, 681 in xsl:key, 681  key   and, 683  in xsl:number, 681 in xsl:template, 483, 484, 681  pattern-separator  xsl:decimal-format , 789  picture string, 300  PatternStep construct, 694–704  examples, 703–704 KindTest and, 697–701 NameTest and, 696–697 node kind and, 694 node name and, 694 parentless nodes and, 695 PatternAxis and, 695–696 predicates and, 694, 696, 701–704  several, 703  schema type and, 694  PCDATA content, 142 PDF  Portable Document Format , 44 peer nodes, numbering of, 406 percent encoding  in URIs , 771, 772, 776, 811, 936,  938, 940  encode-for-uri   and, 771–772 escape-html-uri   and, 775–777 escape-uri-attributes. Seealso escape-uri-attributes  in xsl:output, 422 in xsl:result-document, 447  HTML XHTML serialization and, 776, 937 iri-to-uri   and, 811–812 in xs:anyURI type, 194 in xsl:result-document, 447  percent signs, iri-to-uri   and, 812 percent symbol  xsl:decimal-format , 300, 790  picture string, 300  %HH encoding. See percent encoding performance. Seealso lazy evaluation; optimization  period. See «.» Perl, 187, 204, 232, 829. Seealso regular expressions  extension functions and, 956 named modes and, 249–250 optimization, 67, 350  regex and, 829, 915 XML Schema and, 829, 915 XPath within, 553   predicates  x e d n  I  attribute axis and, 702 last   and, 702 position   and, 702  positional qualiﬁers, 242 position   function, 85, 146, 212, 241, 323, 333, 411,  416, 459, 564, 854–856. Seealso last  ; xsl:number  «  » operator and, 703 binary « » and, 605 context position and, 564, 608, 620, 639,  per-mille  xsl:decimal-format , 300, 790  picture string, 300 phone book, UK, 462 PHP, 430, 1087 picture argument  format-date   , 781–783  examples, 787–788 square brackets and, 781  picture string  xsl:decimal-format , 300, 789–791  negative subpicture, 790 subpicture, 789 symbols in, 300  pieces  regex construct , 916 pipelines, 67, 86, 448, 510  in JAXP, 1190–1193 micro, 88, 402 multiphase transformations and, 981–982 processor, 956. SeealsoXProc XProc, 992  PITarget, 49, 51, 443 PITest, 616, 670, 698 place marker, 405, 406–407 plus operator. See additive operators P.M. or A.M. components, 782 poem examples  attribute set for numbering in, 270–271 formatting of, 35–38 import precedence of template rules in, 365–368 multiple result documents, 451–452, 767–769 numbering lines of, 417–418 validation of result document, 171–174  in XHTML, 171–173  validation of source document, 167–170  polymorphic operations, 186, 221 population  grouping , 327, 330, 739 population order  grouping , 327, 330, 739 Portable Document Format. See PDF portable extensions, 970–971 portable stylesheets, 127–141, 970–971  conditional compilation, 127–128 extensibility, 134–141  extension functions, 134–138 extension instructions, 138–141  function-available   and, 970 system-property   and, 970 version compatibility, 128–134  backward-compatibility mode, 131–134 forward-compatibility mode, 130–131  whitespace nodes in, 146–147. Seealso whitespace  position. Seealso context position  of context node, 241 of node in hierarchy, 407 of node in source document, 406 in result document, 416  positional predicates, 607, 620, 702  «  » and, 627  854–856  current position and  displaying, 856 testing, 856  ﬁrst or last item in list and, 856 numbering and, 856 numeric predicates and, 619, 638 patterns and, 685 positional predicate and, 702 predicates and, 856 xsl:number v., 856 xsl:preserve-space and, 441  positive group  character group , 919  character range and, 919  positive inﬁnity  «INF», 199, 576, 660 xsl:decimal-format, 300, 302, 790  positive numbers, formatting, 789 positive zero, 198, 576 Post Schema Validation Infoset  PSVI , 46, 65 post-process output, 235 precedence. See import precedence; operator  precedence  preceding axis, 609, 612, 1227 preceding siblings, 242, 323, 324, 406 preceding-sibling axis, 83, 609, 612, 1227 precision argument, 872 precision of numeric calculations, 531  «div» and, 575 indeﬁnite, 575 xs:decimal and, 575  predeﬁned entity references, 444 predicate calculus, 641 Predicate construct, 618, 638 predicate logic, XPath syntax, 39 predicate operator «[ ]», 618 path operator « » and, 618  predicate«[last  ]», 639 PredicateList construct, 618 predicates, 83, 85, 599, 617–621, 1227  added to PrimaryExpr, 540 in axis steps, 542, 552, 606, 617  predicates in ﬁlter expressions v., 639–640  boolean. See boolean predicates context item and, 543, 565, 620, 639  1281   predicates  continued   predicates  continued   context node and, 608 context position and, 608, 620, 639 context size and, 608, 620, 639, 821 deﬁnition description, 1227 effective boolean value and, 619, 702 in ﬁlter expressions, 552, 638  predicates in axis steps v., 639–640  focus for evaluation of, 620 with nodes, atomization and, 638 numeric. See numeric predicates parentheses and, 542 patterns in. See patterns PatternStep and, 694, 701–704 PatternStep and several, 703 positional, 607, 620, 702 position   and, 856 self, 639 square brackets  [ ]  in, 84, 638, 701,  856  zero or more, 620  Preﬁx, 534 preﬁx es . Seealso unpreﬁxed names  absence of, in QNames, 533, 766, 866 of attribute name, 256 changing, 310–311 choosing, 262, 308 of element name, 308 from expanded QNames, 857–858 [fn:], 545, 710. Seealsospeciﬁcunpreﬁxedfunction  names  lexical QName, 50 namespace. See namespace preﬁxes not known at compile time, 263 reserved, 256 in result document, 397–398 namespace ﬁxup and, 397  xml, 256  mapped to namespace URI  http:  www.w3.org XML 1998 namespace, 190, 311, 345  preﬁx operators, 526 preﬁx-from-QName   function, 857–858. Seealso  local-name-from-QName  ; namespace-uri-from-QName   DTD-based validation and, 857 namespace ﬁxup and, 857 xs:NCName and, 857  primary expressions, 526, 539–551. Seealso context item expressions; function calls; numeric literals; parenthesized subexpressions; string literals; variable references  primitive types, 189–190, 1227–1228. Seealso built-in  AxisStep v., 540 primary weight, 461 PrimaryExpr construct, 539 predicates added to, 540  atomic types  converting between, 654–664 list of, 190, 1228  principal node kind, 613, 614, 1228  deﬁnition description, 1228 name   and, 836 NameTests and, 613, 614, 696  principal source document, 246, 477, 626  global variables and, 506, 626  principal stylesheet module, 90–91, 480 priority ies , 239, 243, 362, 1228  conﬂicts and, 440 default. See default priorities deﬁnition description, 1228 explicit, 401 import precedence and, 239, 243, 362, 400, 441,  484, 486  NameTests and, 440 operator. See operator precedence template rule, 79  KindTests and, 701  priority attribute, 79, 484, 485–486, 489 private use area, Unicode, 287, 943 procedural stylesheet, navigational stylesheet v., 979 procedure call  analogy with template call , 271 processContents, 314 processing  attribute nodes, 241 instruction nodes, 49  string value, 51  parallel, 245, 309, 323, 330 pattern-matching, 78 pull. See pull processing push. See push processing technique recursion and. See recursive recursion redundant, 313 rule-based, 487–488. Seealso template rules sequential, 245  processing environment, 456, 890 system-property   and, 890–893  presentation, customizing of, 368 presentation modiﬁer, 782 preserve  validation = , 173, 178, 260, 289, 293,  processing instructions, 49, 51, 289, 1228. Seealso    processing instruction; xsl:processing-instruction  297, 305  xs:anyType and, 313  preserving whitespace, 143, 214, 439–442  deep-equal   and, 746 deﬁnition description, 1228 escaping of special characters in, 445  1282   QNames  x e d n  I  in HTML, 444  terminator for, 444  name of, 443 nodes, 1228 selecting, 616 string value of, 51, 443  processing-instruction  , 616, 671, 698, 700  keyword, 616 KindTest, 613, 616, 700  processing model, XSLT, 41–88  error handling, 80 expressions, 82–84  dynamic context, 84, 85 static context, 84  multiple inputs outputs, 44–45 output formats, 43–44 parameters, 82 system overview, 41–45 temporary documents, 85–88 transformation process, 67–80  overview, 41–45 variables, 81–82 XDM tree model, 8, 42–43, 45–67  processor, incremental stylesheet, 988 processors, XSLT  AltovaXML. See AltovaXML processor basic. See basic XSLT processors 4XSLT, 136, 957 Gestalt. See Gestalt processor Gregor, 10 IBM, 10 Intel, 9, 10 Java, binding in, 959–961 libxslt, 10 MSXML. See MSXML processor .NET framework, 9 non-schema-aware. See basic XSLT processors Oracle, 9, 957 product name of, 891 running within Web servers, 430 Saxon. See Saxon schema-aware. See schema-aware XSLT processors System.Xml.Xsl. See System.Xml.Xsl processor Xalan-J. See Xalan-J processor xsl:is-schema-aware and, 478, 891 xsl:product-name and, 891 xsl:product-version and, 891 xsl:supports-backwards-compatibility and, 892 xsl:supports-namespace-axis and, 892 xsl:supports-serialization and, 892 XSLT 1.0. See XSLT 1.0 XSLT 2.0, 10 XSLTC, 10 xsl:vendor and, 478 xsl:vendor-url and, 891 xt, 319, 320, 550  product name, of XSLT processor, 891 production rules, 522–524  notation, 522–523 operator precedence and, 523 type checking and, 523  programmatical construction of XPath expression, 396 programming languages. See functional programming  languages; languages  programming   progressive rendering, 29, 35 promotion, 1228  numeric. See numeric type promotion of xs:anyURI to xs:string, 81, 427, 506, 548, 713,  ‘‘A Proposal for XSL,” 28–29 proprietary extensions, 319. Seealso vendor-speciﬁc  838  extensions  pseudo-attributes,  , 100–101, 444 pseudo-operator  «  » , 602, 626–628  «.» and, 544 examples, 627–628 positional predicates and, 627 rooted path expressions and, 625  PSVI. See Post Schema Validation Infoset public identiﬁers, 446, 902–904. Seealso  doctype-public; unparsed-entity-public-id    doctype-public and, 933, 938  pull parsers, 8 pull processing, 78, 246, 324, 490 punctuation tokens  xsl:number , 407 pure functions, 34, 566, 987 push processing technique, 74–78, 246, 324, 490  controlling the sequence of processing, 77 example, 74–76 selecting nodes explicitly, 77–78  Python, 136, 957  extension functions in, 957 4XSLT processor and, 957  Q  QName   function, 858–859. Seealso xs:QName  node-name   and, 859  QNames, 135, 440, 534, 1228. Seealso xs:QName  as attribute and, 536 in axis step, 536 dynamic construction, 535 as element names, 536 error codes as, 775 expanded. See expanded QNames function names as, 545 functions on  list , 711  lexical. See lexical QNames as literal result element name, 536 namespace declarations and, 535 namespace preﬁxes and, 262, 535  1283   default namespace and, 536, 766, 866  QNames  continued   QNames  continued   as patterns, 536 resolving, 864–866 in SequenceType, 536 stylesheet generation and, 261 type attribute and, 536 as type names, 536 unpreﬁxed, 536, 766, 866  xpath-default-namespace and, 536 xsl:preserve-space and, 536 xsl:strip-space and, 536 in XSLT stylesheets, 535  QName-valued attributes, 261, 393 QName-valued elements, 393 quantiﬁcation, «=» operator and, 649 quantiﬁed expression, 646 QuantiﬁedExpr construct, 525, 646  keywords and, 525  «some» expression  existential, 646 universal, 646  quantiﬁers  regex , 232, 916–917  «*?», 916–917 «*», 916–917 «+?», 916–917 «+», 916–917 «?», 916–917 curly brackets and, 917 greedy, 232, 863, 894, 917 non-greedy, 232, 863, 917  question mark «?»  quantiﬁers  logical . Seealso «every» expression;  «cast as» and, 655 «castable as» and, 655 occurrence indicator, 163, 179, 547, 669  empty sequence and, 713 optional argument v. argument with, 713  quantiﬁer  regex , 917–918. Seealso quantiﬁers  quotation marks, 533. Seealso double quotes;   regex   xsi:nil and, 673  single quotes  apostrophes and, 533 delimiting, 528 French, 522  R  Raggett, Dave, 947 random number generator, 955 range variables, 641, 1228  deﬁnition description, 1228 in «every» expression, 646 in «for» expression, 644  1284  joins with multiple, 647 in «some» expression, 646  RangeExpr construct, 525, 636 value comparisons and, 582  ranges, numeric, 633, 636–637. Seealso «to» operator ratio between two durations, 577 read-only language, XPath as, 188, 526 Recommendations  W3C   deﬁned, 30 serialization speciﬁcation, 44, 929 standards vs.,30 XML Information Set, 62 XML Namespaces 1.1, 24, 58, 474, 534   processing instruction, 99, 444 XPath 2.0, 82 XPath expressions, 8 XSLT 1.0, 28, 30, 479 XSLT 2.0, 5, 32–33, 479  recoverable errors, 1140 recursive recursion, 992–993. Seealso computational  stylesheets  deep copy, 290 divide-and-conquer, 993 functions, 347, 350–351, 862, 992 head-tail, 275, 993 iteration v., 992–993 level=multiple and, 419 processing  list of values, 274–275 sequence of nodes, 275–278 sequence of strings, 278–280  speed efﬁciency, 278 summary, 999–1000 tail-recursive functions, 351, 353, 862, 966 templates, 274–280, 350, 487 xsl:call-template and, 274–280  REC-xml.xsl overlay stylesheet, 1003, 1044 redundant namespace nodes, 394 redundant processing, 313 regex. See regular expressions regex construct, 916 regex-group   function, 234, 860–861. Seealso  xsl:analyze-string  xsl:analyze-string and, 860–861  regular expressions  regex , 21, 204, 351, 915–927,  1228. Seealso matches   function; replace   function; tokenize   function; xsl:analyze-string  anchored, 236, 829, 863 backslash in, 916 case-insensitive comparison in, 828, 925 chevrons and, 915 comments in, «x» ﬂag and, 926 constructs in, 233 curly brackets and, 231, 915, 916 deﬁnition description, 1228   result documents  x e d n  I  Digit as, 530 digits in, 233, 921 escaping special characters in, 232, 915, 920–921,  927  ﬂags. See ﬂags matches zero-length string, 863 matches   and, 828–830 metacharacters. See metacharacters parentheses in, 234, 918 parenthesized subexpressions, 234, 918 pattern facet and, 667, 829 Perl and, 829, 915 quantiﬁers. See quantiﬁers replace   and, 862–864 square brackets in, 919–920 syntax, 915–927  brief summary, 232–234 disallowed constructs, 927 XML Schema and, 829, 915  tokenize   and, 894–895 whitespace in, 926 words matching in, 921 in xsl:analyze-string, 123, 232–234 xsl:matching-substring and, 386 xsl:non-matching-substring and, 402 zero-length strings and, 231, 863  relational databases, 8, 67. Seealso SQL relational joins, 643 relationships, encapsulation of, 348 relative reference, 867–868  of  ‘‘’’ , 868 relative URI v., 867  relative URIs, 54, 100, 193, 293, 357  deﬁnition description, 756 doc   and, 751, 755 in href attribute, 100, 359, 373 as links between output documents, 449 as namespace URI, 55 relative reference v., 867 resolving, 720, 755  RelativePathExpr construct, 602, 625 RelativePathPattern construct, 693–694  ancestor node and, 693 attribute-or-top axis and, 689 child-or-top axis and, 689 parent node and, 693 steps and, 694  Relax NG, 25 remainder from integer division, 572, 575. Seealso  «mod» operator  removal  of characters, 897–898 of duplicate groups, 328 of duplicate items, 333 of duplicate nodes, 378, 544, 603  of duplicate values, 749–750 of whitespace-only text nodes, 143, 146, 441–442,  465, 493  remove   function, 212, 861–862  tail of sequence and, 861  rendering elements example, 239 reordering sequences in document order, 602 repeating groups, of adjacent elements, 338–340 replace   function, 204, 234, 862–864  backslash in, 863 ends-with   and, 774 regex syntax and, 915–927 translate   v., 864, 898 xsl:analyze-string v., 864  replacement characters, 897. Seealso translate    function  replacing all occurrences of substrings, 862 replacing whitespace, 143, 214 reporting errors, xsl:message and, 388 required attribute  xsl:param , 238, 244, 273, 428, 487 required cardinality, 505, 547 required item type, 505, 547  atomic type as, 506 as numeric type, 506  required tunnel parameters, 430 required type  of arguments, 547 of parameters, 425, 427–428, 487 standard conversion rules and, 505  requirements, for XSLT 2.0, 32 reserved for XQuery, typeswitch expression, 546, 669,  680  reserved preﬁx, 256 reserved words, 40, 528, 615  operators and, 538  resolve-QName   function, 864–866. Seealso  in-scope-preﬁxes  ; QName   resolvers for URIs, 369, 755–756  CollectionURIResolver  Saxon , 727, 1197 OutputURIResolver  Saxon , 449, 1197 URIResolver  JAXP , 138, 567, 751, 755, 965, 1186 XmlResolver  .NET , 138, 567, 751, 755, 965  resolve-uri   function, 867–869 absolute URIs and, 867–869 base-uri   and, 720 doc   and, 750, 751, 868–869 document   and, 763 static-base-uri   and, 868 resolving QNames, 864–866 resolving relative URIs, 720, 755 Result  JAXP interface , 1174 result documents. Seealso xsl:result-document  base URIs for, 68 integrity constraints, 174  1285   result documents  continued   result documents  continued  multiple, 44–45, 445, 450  XSLT 1.0 processors and, 319–320  with namespace declaration, 262 position in, 416 preﬁxes in, 397–398 relative URIs as links between, 449 in transformation process, 41–42 validation of, 170–174  XHTML, 170  well-formed, 174 xsi:noNamespaceSchemaLocation in, 174 xsi:schemaLocation in, 174 xsl:output and, 420 result sequence, 253 result trees, 1228  deﬁnition description, 1228 DOM, 420 ﬁnal, 74, 448  URIs for identifying, 449  fragments, 87, 320, 454. Seealso document nodes HTML, 423 JAXP and, 421 with same URI, 450 sequential building of, 257 serialization of. See serialization validation  with validation type attributes, 932  XHTML, 423–424 xsl:apply-templates and, 245 xsl:result-document and, 445  returning  any values, 453 atomic values, 453, 455 references to existing nodes, 453, 455  reusable components, 363. Seealso stylesheet s  revalidating copied subtree, 298 reverse axes, 607, 1227, 1228 deﬁnition description, 1228 reverse document order and, 608, 620, 1228  reverse document order, reverse axes and, 608, 620,  1228  reverse order  of integers, 637 of original sequence, 324, 458, 869  reverse   function, 324, 637, 869. Seealso unordered   RFC 2045, 208 RFC 2396, 867  relative reference of zero-length string, 868  rules  RFC 3986, 771, 811, 1230  algorithm for URI resolution in, 867 relative reference of zero-length string, 868  RFC 3987, 811 RFC 4790, 460 Rich Text Format. See RTF  1286  Roman numerals, 409, 410, 782 root expressions  « » , 623–625 abbreviated axis steps v., 624 document node and, 623 errors and, 624 no context item and, 624 root   v., 870 type of, 624  root nodes, 47, 624, 1228  deﬁnition description, 1228 element nodes as, 688 other than document node, 624, 625, 688, 870 root   and, 870  rooted path expressions, 542–543, 625–626  «  » and, 625 « » as, 542–543, 625–626  «[ ]» and, 618 errors and, 625 examples of, 626 no context item and, 625  root   function, 624, 870. Seealso root expressions  « » expression v., 870  round   function, 200, 870–872  xs:integer   constructor function and, 872  round-half-to-even   function, 200, 212, 531, 576,  872–873  format-number   and, 873 unwanted digits and, 660  rounding errors, 575, 576 rounding numbers, 723, 870–872. Seealso ceiling  ;  round    ﬂoor   and, 780 round-half-to-even   and, 872–873 signiﬁcant digits and, 790  rounding rules, 790, 893 RSS, NameTests and, 697 RTF  Rich Text Format , 44 Rubik’s cube, 42. Seealso transformation process,  rule-based processing, 487–488. Seealso template  XSLT  rules  rule-based structure, of XSLT, 35–38, 41 rule-based stylesheets  design pattern , 74, 246,  980–985, 1047, 1113. Seealso XML speciﬁcation  case study  CSS and, 980  rounding, 790, 873 standard conversion. See standard conversion rules  running examples. See examples, running running total, 900 runtime  attribute name decided at, 255, 260, 264–266 element name decided at, 308   schema s   x e d n  I  errors  atomization and, 499 predicates in patterns and, 688  schemas compile time schemas, 752 sort key as runtime parameter, 836 stylesheets included conditionally at, 374 template name evaluated at, 272 type errors at, 506 XPath expression constructed at, 541  Russian language, 409  S  « cid:5 »  sigma , 827 «s» ﬂag, 926  «.» and, 917, 926 dot-all mode and, 917, 926  s9api interface  Saxon , 1199, 1202–1203 Safari, 100 sales report example, 977–980 same keys  multiple deﬁnitions for, 383–384 nodes with, 378  same name  attributes with, 257, 267 functions with, 546, 559 local variables with, 502 user-deﬁned functions and vendor-supplied functions  with, 346  xsl:key declarations with, 383–384  same namespace, functions in, 349 same nodes, keys for, 383 same schema, different versions of, 370 same URI, result trees with, 450 Sarissa, 68 «satisﬁes» expression, 646 SAX  ContentHandler, 44, 1174, 1180 JAXP support for, 1164–1166 parsers, 8, 1164  Saxon, 9, 10, 30, 1195–1214. Seealso examples,  running  arbitrary length integers and, 212 -B, 10, 1195  Saxon-SA v., 644  calling Java methods from, 1206 collation URIs, 565, 1207–1208 collations, 561, 731, 1207–1208 collections, 727, 1197 command line interface, 1196–1199 control over doc   invoking validation, 671,  1198  DOM and, 1200, 1205 early versions, 30 extensibility, 959, 962, 1205–1208  extension attributes, 1209 extension functions, 959, 962, 1209–1210 extension instructions, 139, 140, 475–476, 1209 extension-element-preﬁxes and, 476–477 extensions, 1208–1210 functions from, 135 graphical user interfaces, 10 input-type-annotations and, 478 on Java, 1195  from command line, 14–15, 103, 1196–1199 extension functions and, 957  JAXP transformation API and, 1163, 1199–1202,  1200  Kernow and, 10, 13–14, 1195 linked tree, 1205 on .NET, 15, 1195, 1203–1205  binding in, 962 C and, 957, 1093, 1203–1204 extensibility, 962  NodeInfo interface, 1205 OutputURIResolver, 449, 1197 s9api interface, 1199, 1202–1203 -SA, 10, 1195  optimization of joins with, 644 Saxon-B v., 644 schema validation API, 1201 validating result document on, 172–173 validating source document on, 169  SQL extension, 111, 475, 476 substring matching using collation, 731–732 tiny tree, 1205 trace  , 896 TransformerFactory and, 1200–1201 tree models, 1205 unordered   and, 901, 902 validation request, 166, 671, 1197 version 6, 8, 319, 767, 809, 1195 on Xalan-J, 957  extension functions and, 957  XPath expressions in, 1201–1202  saxon:deep-equal   function, 748 saxon:doctype, 477 saxon:evaluate   function, 135, 541, 546, 1210–1214 saxon:group extension element, 111 Saxonica, 10, 30 saxon:while, 139 SAXParser  JAXP class , 1165–1166 SAXParserFactory  JAXP class , 1164–1165 SAXResult  JAXP class , 1174–1175 SAXSource  JAXP class , 1175–1176 SAXTransformerFactory  JAXP class , 1176–1177 Scalable Vector Graphics. See SVG schema s , 1228. Seealso XML Schema s   adding  transition from XSLT 1.0 to 2.0, 1145  1287   schema s    continued   schema s    continued   cached, 369  compiled, 370  compile time runtime, 752 components, 557, 1228. Seealso attribute  declarations; element declarations; type deﬁnitions  consistency rules for, 370 declarations in. See declarations deﬁnition description, 1228 deﬁnitions, 369 different versions of same, 370 importing, 180–181, 368–372. Seealso  xsl:import-schema  with no target namespace, 482 user-deﬁned derived types in, 664, 900 XQuery and, 369  information, 557 inline, 175, 368, 369 locating, 314 no-namespace, 372 OpenGIS, 557 stylesheets and, 151–183 type deﬁnitions in, 653. Seealso schema types types imported from, 793 XHTML, 172 for XSLT 2.0 stylesheets, 352  examples, 674–677 global attribute declarations and, 676  schema namespace, 475 schema processor, 143, 297  ID values and, 379 validation of XML document with, 752  schema types, 653, 1228, 1230. Seealso atomic  types; complex types; list types; simple types; union types  annotatedwith,653, 742 as complex types, 653, 742  with simple content, 742  deﬁnition description, 1228 element content and, 742 mixed content and, 742 PatternStep and, 694 sequence types v., 653–654 as simple types, 653, 742 in static context  type-available   and, 899–901  schema validation, 52, 65, 107, 165, 262, 303, 311  atomization and, 742 doc   and, 752 document   and, 757 namespace ﬁxup and, 393 nilled   and, 842 strings converted to other types and, 663 xs:untypedAtomic and, 670  schema-attribute  N , 371, 558, 622  1288  SchemaAttributeTest construct, 674, 698 schema-aware XSLT processors, 151, 190, 352, 471  as attribute and, 161 built-in types, 190, 192, 557, 670 complex element-only content and, 499 extension of type hierarchy in, 163–164  built-in atomic types and, 163, 164 user-deﬁned types in, 163, 164  NameTest and, 696 non-schema-aware and stylesheets for, 370  type validation attributes and, 258 validation annotation  of attributes, 255, 289 of elements, 307, 312–315  XPath, 54 xsl:import-schema in, 368  schema-deﬁned types, 219, 427, 601  of attribute nodes, 622 attribute   and, 617 AttributeTest and, 616 element   and, 617 ElementTest and, 616 KindTests and, 613, 698 type checking based on, 353  schema-element  global element declaration and, 674, 699  schema-element N , 371, 558, 674  KindTest, 700 type annotation and, 674  SchemaElementTest construct, 674, 697 schema-location attribute  xsl:import-schema , 181,  369  Schematron, 396 Scheme  programming language , 28 schemes  error-handling, 775 numbering, 784  scientiﬁc notation. See exponential notation scope  of namespace declarations, 58 namespace preﬁxes in, 808–809 of parameter names, 429 of variables, 81, 268  global, 501 local, 70, 501, 502  scoped variables, dynamically, 429 script  in HTML output page, 137 JavaScript and, 957 in stylesheet, 137  script element, 936 secondary documents, 510, 692, 761 secondary weight, 461   seconds component  in format-time  , 782 fractional, 782, 783 from xs:dateTime, 873–874 from xs:duration, 874–875 from xs:time, 873–874  seconds-from-dateTime   function, 873–874 seconds-from-duration   function, 874–875 seconds-from-time   function, 873–874 section headings, 78 section numbers, 405 select attribute, 230, 412  cross-reference construction with, 412 sequence constructor v., 457 string value of namespace node from, 391 value of variable and, 503 xsl:apply-templates and, 241 xsl:for-each and, 322–323 xsl:param and, 428 xsl:value-of and, 496 xsl:variable and, 501  Select Case construct, 283 SELECT statement  SQL , 8, 568  expressions v., 568, 632  selecting processing instructions, 616 self axis, 609, 612, 836, 1228  «@» and, 622 deﬁnition description, 1228 name   and, 836 self predicate, 639 semantics  existential, 590–592. Seealso general comparisons shortcut, 595–596. Seealso boolean operators  separator attribute, 254, 258, 495, 496 separator character «.», 528 separators, 285  between adjacent strings, 258, 879 default, 258, 497 spaces as, 266, 304, 309 tokenize   and, 894, 895  sequence s , 187–189, 351, 1228–1229. Seealso  atomic values; node s   atomic values and, 187–188, 322, 351, 633 collating. See collations concatenation, 261, 634. Seealso comma operator deﬁnition description, 1228–1229 empty. See empty sequence «for» expression and, 640. Seealso «for» expression functions on, 72   list , 711  identity and, 633 immutability of, 633 items in, 187–188, 189 iterate over, 324 locating items in, 807–808  sequence numbers  x e d n  I  manipulation of. See sequence expressions mapping, 641–642 mapsthe, 641 maximum minimum values in, 830–832 multiple input  «for» expression and, 643–644  and navigating trees, 189 nesting and, 188, 633 nodes in, 187–188, 633  booleans compared to, 589  number of items in, 733 numbering. See numbering sequences operands as, 588 reverse, of original order, 324, 458, 869 sets of nodes and, 629 sorting  into document order, 57 xsl:perform-sort and, 437, 438 of text nodes, type error and, 498 type labels and, 634 value as, 187 XPath operators on, 189  228, 1229  contained, 503 deﬁnition description, 228, 675, 1229 element nodes within. See instructions evaluation of, 309 instructions in, 766 nested, 73–74 result of function and, 346 scope of local variables and, 70 select attribute v., 457 templates as, 90 text nodes in, 72 xsl:document in, 303 in xsl:sort, 457 xsl:text in, 492 xsl:value-of and, 495 in xsl:variable, 501  sequence constructors, 69, 70–72, 89, 90, 108, 149,  sequence expressions, 633–651  comma operator. See comma operator «every» expression. See «every» expression ﬁlter expressions. See ﬁlter expressions «for» expression. See «for» expression simple mapping expressions. See simple mapping  expressions  «some» expression. See «some» expression «to» operator. See «to» operator  sequence numbers, 241. Seealso numbering sequences  backward-compatibility mode and, 405 composite, 407, 419 hierarchic, 418 xsl:number and, 405–407  1289   sequence-constructor,496 SequenceType construct, 228, 371, 426, 668. Seealso  27, 903  sequence type descriptors  sequence type descriptors, 221, 228  as attribute and, 162, 164, 668 deﬁned, 654 examples of, 162 global element declarations and, 673–674 local elements attributes in schema and, 677 matching atomic values, 669–670 matching elements attributes, 672–677 matching nodes, 670–672 within XPath expressions, 165, 668–677 XQuery and, 668 xs:anyType and, 670  sequence types, 653–654, 1229, 1230. Seealso item  types  cardinality in, 653 deﬁnition description, 1229 instanceof,653 «instance of» operator and, 668 item types in, 653 schema types v., 653–654 «treat as» operator and, 668  sequence type descriptors  atomic type and, 371 occurrence indicators and, 505 QNames in, 536 syntax. Seealso sequence type descriptors  element names in, 482 type names in, 482  type of variable and, 501 union types in, 372 xsl:template and, 484 xsl:variable and, 501  xsl:output  attributes  also known as parameters, 932 as attribute value templates, 448 HTML output method, 938–939 as JAXP output properties, 1181–1182 on Saxon command line, 1199 text output method, 940 XML output method, 932–936 in xsl:output, 421–422 in xsl:result-document, 446–447  backward-compatibility mode and, 1142 character attribute replacement during, 425 character maps and, 280, 282, 941. Seealso  character maps controlling, 67, 450 deﬁnition description, 1229 escape-uri-attributes and, 776, 936 extension attributes and, 1225  1290  href attribute and, 446, 448–449 method. See output methods namespace declarations from, 391, 473 of newline characters, 939, 940 parameters, 929  also known as attributes, 932  property, 776 W3C speciﬁcation, 44, 929  server-side transformation,  , 100,  319  servlets, 430   family tree case study   generating HTML from, 1087–1092 installing conﬁguring, 1090–1092  set operators, 629. Seealso Venn operators sets, attribute. See attribute sets sets of atomic values, 631 sets of nodes  combining, 599, 628–631 sequences and, 629  sets, XDM data model and, 629 SGML  Standard Generalized Markup Language ,  character maps and, 942  Shakespeare plays. Seealso Othello  formatting of, 335, 336, 337, 338, 433 grouping consecutive elements by name,  handling repeating groups of adjacent elements,  336–338  338–340  text of all, 335, 433  shallow copy, 287 shortcut semantics, boolean operators and, 595–596 siblings, 55. Seealso following siblings; preceding  calling extension functions within loop, 967 extension functions and, 138, 244, 549, 595,  955, 956  in functional languages, 449 functions with, 549–550 immutability and, 633 pure functions and, 34, 566, 987 tunnel parameters and, 431 without, 29, 34–35, 69–70, 350, 526  expression evaluation, 526 functions, 34  of xsl:result-document, 449  sigma  « cid:5 » , 827 signatures  digital, 396 function, 220  in static context, 547, 559  signiﬁcant digits, 790  rounding numbers with, 790  sequential building of result trees, 257 sequential processing, 245 serialization, 43, 44, 929–949, 1229. Seealso  siblings  numbering of, 406, 411–412  side effects, 34–35   space s   x e d n  I  signiﬁcant whitespace, 142 simple content, 154–155, 441  complex types with, 154–155  schema types as, 742  simple mapping expressions, 599, 601, 644–645  « » operator for, 599, 601, 644 atomic values and, 644–645 distinguish path expressions from, 645 path expressions v. «for» expressions v., 645  simple type deﬁnitions, 52, 152–153, 163  KindTest for attribute nodes and, 700 top-level, 371  simple types, 52, 152–153, 163, 191–192, 371, 1229.  Seealso atomic types; list types; union types  dynamic, 462–463 equal, 324 major-to-minor order, 242, 324, 456 meanings for, 457 supplied as runtime parameter, 836 xsl:sort and, 455  sort key components, 457, 462 sort key speciﬁcation, 457 sort key values, 457 sorted sequence, 457, 459 sorting, 242. Seealso collations; xsl:perform-sort;  simpliﬁed stylesheet modules, 89, 125–127, 263, 1229  as atomic types, 653 atomic types v., 191–192 deﬁnition description, 1229 global, 259 as list types, 653, 670 schema types as, 653, 742 as union types, 653, 670  deﬁnition description, 1229 syntax, 358, 374, 464, 466, 509 xsl:version and, 125  single character escapes, 920, 921 single level. See level attribute single quotes, 532  string literals and, 532  single-level grouping  example , 331–333 single-precision ﬂoating point, 190, 208, 576. Seealso  xs:ﬂoat  SingleType construct, 655 size  of integer, 574 of table, calculation of, 724 size, context. See context size SMDL. See Standard Music Description Language   SMDL  smileys, 529 SOAP envelope, 24, 120, 291, 297 soccer example, 294–296  multiphase transformation, 511–513  Software AG, 30 «some» expression, 39, 353, 540, 552, 646–650  «=» operator and, 649 boolean   and, 722 context item and, 646 empty sequence and, 647 errors in, 649–650  dynamic, 649  focus within, 565 range variables in, 646 semantics of, 647–648  sort key s , 324, 328. Seealso xsl:sort  conditional expression as, 462  xsl:sort  collations and, 106, 459 distinct values, XQuery and, 750 groups, 330–331  grouping keys and, 330–331  items within each group, 331 language-dependent, 134 process, 457–458  initial sequence in, 457 rules for, 458 sorted sequence in, 457  on result of calculation, 463 sequences  into document order, 57, 241, 602 with xsl:perform-sort, 437, 438  strings, 84 XPath and, 562 xsl:apply-templates and, 199, 241 xsl:for-each and, 199, 323–324  Source  JAXP interface , 1177 source documents, 41, 68, 1229  annotation of, 165 copying to result, 293, 296  with few changes, 290  deﬁnition of, 1229 multiple, 44–45, 326, 482, 510 namespace nodes copied from, 474 position of node in, 406 principal, 246, 477, 506, 626 in transformation process, 41–42 type annotations on, 467 as untyped, 477 validating, 165–170  on AltovaXML processor, 169, 1218 example, 167–170  whitespace in, 141  SourceLocator  JAXP interface , 1177–1179 space s   ignorable  substring-after   and, 886 substring-before   and, 888 matching, in regex, 921, 924 as separators, 266, 304, 309 as whitespace characters, 440 «x» ﬂag and, 926–927  1291   space characters, nonbreaking  space characters, nonbreaking, 38, 142, 148, 281,  standalone attribute, 421, 422, 447, 448, 935  367, 732, 880, 938  «&nbsp;», 64, 281, 367, 938 character maps and, 943 normalization of, 880  space, stack, 487 Spanish collating rules, 732 Spanish language, 731, 732, 781 special characters, 425  converted  to character reference, 493 to entity reference, 493  escaping. See escaping special characters jEdit and, 941 regex syntax and, 915  special-purpose rules, 239 special-purpose stylesheet module, 97 speciﬁcation  HTML 4.0, 775, 776 JDK 1.1, 788, 790 ODF, 4 OOXML, 4 serialization  W3C Recommendation , 44,  929  stylesheet modules, 90 XHTML, 481 XML, 534  case study, 1001–1048  XML Schema, 369 XPath, 522  Sperberg-McQueen, Michael, 27 splitting  large XML ﬁle into smaller XML ﬁles, 445 lines into words, 279  SQL. Seealso relational databases; SELECT statement  extension  Saxon , 111, 475, 476 null value in, 182. Seealso nillability  empty sequence and, 586  XSLT vs.,8–9  sql:query  Saxon extension , 111, 475, 476 square brackets  [ ]   for Digit symbol, 530 doubling of, 781 hyphens allowed with, 920 in picture argument  format-date  , format-dateTime  ,  format-time   , 781  in predicates, 84, 638, 701, 856 in regex, 919–920  square root function, 346, 347  extension function example, 959–961 math:sqrt  , 346  stable attribute  xsl:sort , 242, 324, 456, 457, 458 stable functions, 726 stack frame, 487 stack space, 487  1292  XML output method and, 935  standalone property, 67 standard conversion rules, 244, 346, 427, 504 backward-compatibility mode and, 505, 714 core function library and, 713–714  standard function library. See core function library standard function namespace, 135, 482, 545, 556,  560, 655, 793  Standard Generalized Markup Language. See SGML Standard Music Description Language  SMDL , 6 standard type conversions. See standard conversion  rules  standards, 30. Seealso Recommendations standoff markup, 995–996 start tags, 49, 1229 starting instants of dates  simultaneous, 583 xs:date minus xs:date and, 580  starting of numbering sequences  at one, 409 at value other than one, 412  starts-with   function, 204, 875–876. Seealso  contains  ; ends-with  ; matches  ; string-length    substring matching with collation, 731–732  states  U.S.  example, 284 static context, 84, 345, 545, 553, 554–563, 1229.  Seealso dynamic context  backward-compatibility mode, 544–545 base URI, 562, 868, 876 collations, 561–562 default namespaces, 556 deﬁnition description, 1229 dynamic context v., 554 function-available   and, 793 in-scope functions, 559–560 in-scope namespaces, 555–556 in-scope schema deﬁnitions, 557–558 in-scope variables, 558–559 schema types in  type-available   and, 899–901  signatures of functions in, 547, 559 statically known documents collections,  563–564  static errors, 80, 1229 static namespace context, 534 static type checking. See static typing static typing, 165, 186, 187, 221–224, 559, 563, 1229  exactly-one   and, 777 one-or-more   and, 853 «treat as» operator and, 679 XQuery and, 563, 680 zero-or-one   and, 912–913  statically known documents collections, 563–564   stylesheet s   x e d n  I  static-base-uri   function, 876–877. Seealso base-uri  ;  doc  ; document  ; resolve-uri    base URIs and, 562, 868, 876–877 resolve-uri   and, 868  step expressions, 57 StepExpr construct, 602 steps, 83, 599, 1229. Seealso axis steps; path  expressions  RelativePathPattern and, 694  sticky modes, 243  not, 242  StreamSource  JAXP class , 359, 1179–1180 strict  validation= , 173, 259, 297, 305, 371  element declaration and, 314 unnamed type deﬁnition and, 314  Strine types, 207 string s , 1229. Seealso format string; xs:string  as atomic values, 189, 190 comparing, 84, 724. Seealso codepoint-equal    backward-compatibility mode and, 1141 default collation and, 588 incompatibility and, 588 in Java, 460  conversion of operands to, 586 conversion of, to booleans, 552 converting atomic values to, 878 deﬁnition description, 1229 external ﬁle in form of, 904 ﬁrst character of, 884–885 length, 880–881. Seealso zero-length strings normalization, 849 numbers converted to, 531 ordering of, 584 replacement of. See replace   returned from functions, 497–498 separator between adjacent, 258, 879 sorting, 84 starts with another string, 875. Seealso starts-with   substrings in. See substring s  zero-length. See zero-length strings  string functions  empty sequence and, 711 list of, 710  string literals, 203, 528, 532–534  carriage return within, 532 double quotes and, 532 newline characters in, 532 single quotes and, 532 tab within, 532  string mode  regex evaluation , 926 String Quartet examples, 488–491 string types, 549  derived, 193, 213–215  string value, 46, 47, 51–52, 1229  attribute node, 51  characters in, 63, 884 comment node, 51, 285 deﬁnition description, 1229 document node, 51 element node, 51, 742 namespace node, 51 of new attribute node, 258 of nodes, 46, 47, 51–52, 496  deﬁned, 877–878  of processing instruction, 51, 443 text node, 51 typed value, type annotation, and, 54, 742  string-delimiter character, 533 string   function, 52, 143, 200, 877–878. Seealso  boolean  ; number    backward-compatibility mode and, 877  string-join   function, 204, 545, 879–880. Seealso  concat    attribute value templates v., 880 concat   v., 880 normalize-unicode   and, 849 xsl:value-of v., 880  normalize-unicode  ; substring   normalize-unicode   and, 880–881 zero-length strings and, 881  StringLiteral symbol, 532 whitespace within, 532  string-length   function, 63, 204, 880–881. Seealso  string-to-codepoints   function, 642, 881–882. Seealso  codepoints-to-string    strip  validation= , 173, 178, 297, 305  xs:untyped and, 314  stripped spaces, MSXML processor and, 567 stripping. Seealso removal  type annotations, 477 whitespace-only text nodes, 143, 146, 441–442,  465, 493, 757  strong collations, 378, 461, 462, 562, 584 strong conversions, 81–82. Seealso conversions strong typing, 187. Seealso static typing style element, 936 stylesheet s , 1229. Seealso portable stylesheets  base URI of, 720, 756, 905 changes, in XSLT 2.0, 90 comments in, 287 computational, 985–1000, 1114. Seealso knight’s  tour  case study   customization of, 429  Othello example, 433–437  debugging, 431  comments and, 286  declarations in. See declarations deﬁnition description, 228, 1229 design patterns, 973–1000 DocBook, 433  1293   stylesheet s    continued   stylesheet s    continued   document    and analysis of, 758–759 document-formatting, 1047. Seealso rule-based  stylesheets  embedded. See embedded stylesheets examples  funcproto.xsl, 1046–1047 xmlspec.xsl, 1047 xsl-query.xsl, 1047 xsltdiff.xsl, 1046 xslt.xsl, 1045–1046  for family tree case study, 1073–1085 ﬁll-in-the-blanks, 38, 973–976 as function, 986 functions. See stylesheet functions; xsl:function generating  namespace aliasing and, 121 through other stylesheets, 393, 396 QNames and, 261 xsl:namespace-alias and, 394  importing, 237, 357–368 included conditionally at runtime, 374 layer, 360 level, 238 look-up table in, 761–763 meta-, 393, 396 modular structure, 90–98 modules, 45, 88, 89, 90, 228, 357, 1229  deﬁnition description, 1229 general-purpose, 97 locating, 357–359 media-type of, 470 ofﬁcial speciﬁcation, 90 overlay. See overlay stylesheet modules principal, 90–91, 480 special-purpose, 97 xsl:include and, 372  multiple xsl:import-schema in, 370 navigational, 976–980, 1114. Seealso family tree   case study   parameters, 68, 82, 138, 425, 426, 427, 430–431.  Seealso xsl:param  environment variables and, 427 extension functions v., 430 in form of DOM Document object, 430 in form of XPath expression, 430  program, 90, 94 QNames in, 535 rule-based, 74, 246, 980–985, 1047, 1113. See  also XML speciﬁcation  case study   running in browser, 430, 463, 957, 1154–1157 for schema-aware and non-schema-aware  processors, 370  1294  schemas and, 151–183. Seealso XML Schema s  script in, 137  script in HTML output page v., 137  simpliﬁed. See simpliﬁed stylesheet modules structure, 89–149 terminating execution of, 386 top-level elements in, 90, 104 transformation process and, 41–42 tree, 360, 361 type declarations in, 161 in WD-xsl, 467 whitespace in, 146–147. Seealso whitespace XML Schemas and, 151–183 xml:space in, 147  stylesheet functions, 1229  context item and, 350, 736 current group and, 739 deﬁnition description, 1229 function-available   and, 792, 793 named templates as wrapper for, 349 named templates v., 347, 349–350 as wrapper for named templates, 349 with xsl:function, 106, 135, 136, 271, 344  Stylus Studio development environment, 10, 12, 13,  16–17, 1195  subexpressions  regex , 918  parentheses and, 234, 918  sublanguage, XPath as. See embedded languages subpicture, 789. Seealso picture string  negative, 790  subroutine call, 271 subsequence   function, 882–883 substitutability, 664 substitution groups, 158–161, 683, 696  content model restriction extension and, 701 global element declarations and, 674 KindTests and, 701 match by type in, 981  substitution, of characters, 897–898 substitution, textual, 541 substring s   captured, 860 comparing, 730–732. Seealso contains   matching with collation, 731–732, 876 minimal matching, 886, 888 replacing all occurrences of, 862 tokenize   and, 894–895  substring-after   function, 204, 885–887 substring-before   function, 204, 887–888 substring   function, 63, 204, 883–885  as conditional expression, 885 «if» expression v., 885  subtract-dates-yielding-yearMonthDuration  dropped  from ﬁnal speciﬁcation , 348   subtracting  dates, 348 durations, 577, 579  subtraction  character group , 919 subtypes, 701 sum   function, 200, 889–890. Seealso avg  ; count    «+» operator and, 889 empty sequence and, 634, 889 NaN and, 889 xs:dayTimeDuration and, 889 xs:yearMonthDuration and, 889  super   function  object-oriented programming , 237,  400. Seealso xsl:apply-imports  supplied value, 505 surrogate pair, 63, 203, 460, 725, 880, 882, 884, 898 SVG  Scalable Vector Graphics , 291, 531  trigonometric functions and, 955  Sweden, collations in, 459 Swedish language, 561, 848 switch construct, 282, 283 syntactic ambiguities, of « », 623–624 syntactic rules, XPath, 521, 524  comments and, 524 lexical rules v., 524 whitespace and, 524  syntax  arithmetic operators, 571–572 axis steps, 606–607 path expressions, 39, 83–84, 526 of patterns, 483, 689–707 regex, 232–234, 915–927 brief summary, 232–234 disallowed constructs, 927 matches   and, 915 replace   and, 915 special characters and, 915 tokenize   and, 915 XML Schema and, 829, 915 xsl:analyze-string and, 915  SequenceType  element names in, 482 type names in, 482  simpliﬁed stylesheet modules, 358, 374, 464, 466,  509  XML, XSLT and, 33–34 XPath expressions, 39–40, 82–83, 522, 1117–1122  conventional programming expressions, 39 notation, 522–523 predicate logic, 39  system clock, 738 system identiﬁer, 447, 902. Seealso base URIs;  doctype-system; unparsed-entity-uri    in DOCTYPE declaration, 422, 447, 933, 938  system properties, 891–892  xsl:is-schema-aware, 478, 891  Technical Report 21  Unicode   x e d n  I  xsl:product-name, 891 xsl:product-version, 891 xsl:supports-backwards-compatibility, 892 xsl:supports-namespace-axis, 892 xsl:supports-serialization, 892 XSLT 2.0   list , 891–892  xsl:vendor, 478 xsl:vendor-url, 891  system-deﬁned functions, 793–794 system-property   function, 128, 131, 134, 321, 467,  890–893  function-available   and, 892 portable stylesheets and, 970 system properties  list  and, 891–892 use-when and, 370, 478, 769, 892 xsl:fallback and, 892 xsl:import-schema and, 769  System.Xml namespace  .NET , 138  framework classes, 567  XmlResolver and, 138, 567  System.Xml.Xsl processor  Microsoft .NET , 9, 957,  1158–1161  binding in MSXML and, 957 binding, using external objects in, 961–962 extensibility in, 961 extension functions in .NET languages, 957  T  table s   tab  whitespace character , 440, 528  within string literal, 532  calculating size of, 724. Seealso ceiling   function formatting. See XML speciﬁcation  case study  look-up, 107, 321, 510, 753  in stylesheet, 761–763  numbering sequences for, 415  table  HTML  examples, 116  arranging data in, 343–344 attribute set for, 269 generate empty table cells in, 344  table of contents, 78, 247, 490 tags, 49, 1229 tail-call optimization, 487, 966, 993 tail-recursive function, 351, 353, 862, 966 Tamil digits, 408 target namespace, 180, 370  importing schemas with no, 482  tax rates. See look-up data technical documents, sequence numbers for, 418 Technical Report 15  Unicode , 848 Technical Report 21  Unicode , 827  1295   template s   template s , 90, 1229. Seealso attribute value  templates; named templates; sequence constructors; xsl:template  current. See current template rule deﬁnition description, 1229 evaluating, 486–487 as functions, 988 identity, 290 initial, 68, 1225  deﬁnition description, 1225 in knight’s tour example, 1102–1104  local parameters to, 425, 427 recursion and, 274–280 term,74  template call, recursive, 487 template parameters, 82, 425, 426, 427, 431  xsl:apply-imports and, 238, 431 xsl:apply-templates and, 243, 431 xsl:call-template and, 272, 431 xsl:next-match and, 400, 431 xsl:with-param and, 431, 517–518  template rules, 35–38, 73, 487–488, 1230  built-in. See built-in template rules choosing, 242–245, 485–486  import precedence, 486  contents of, 69–70 current. See current template rule default, for comment nodes, 700 deﬁnition of, 228, 1232 empty, 261 example, 488–490 import precedence of, 79, 94, 365–368, 484 last speciﬁed, 362 match attribute and, 487 modes and, 242, 402 overriding, 237 patterns and, 681, 686, 696 priority, 79  KindTests and, 701  sequence constructors, 70–72, 241  nested, 73–74  for xsl:apply-templates, 362 XSLT transformation process and, 68–74  Templates  JAXP interface , 1180 TemplatesHandler  JAXP interface , 1180–1181 templating languages, 973 temporary documents, 72, 85–88, 244, 274, 428, 503,  510  examples, 86 node selection in, 378 unnecessary, 514 validation of, 174–176  xsl:document and, 175  well-formed XML document and, 87 xpath-default-namespace and, 482  1296  temporary trees, 428, 1230 copying data to from, 293 deﬁnition description, 1230 document   and, 756 example, 320–321 ﬁnal result trees v., 1225 ID attributes in, 379 namespace ﬁxup and, 932 validation on  document-level, 303 element-level, 305 xsl:value-of and, 497 xsl:variable and, 619  terminate attribute  xsl:message , 386, 387 terminating execution, of stylesheets, 386 terminator for processing instruction, in HTML, 444 terms glossary, 1221–1231 tertiary weight, 461 test expression  xsl:when , 283 testing. Seealso KindTests; NameTests; NodeTests  name of nodes, 836 nodes before after in document order, 57, 593, 594 for nonempty node sequence, 276 for vendor extensions, 769–770. Seealso  element-available   function  text  , 671, 698, 700  KindTest, 613  text declarations, 935  encoding attribute of, 933 omit-xml-declaration and, 935 XML declaration v., 931  «text» keyword, 616 text nodes, 49, 1230  adjacent, 143, 258, 304, 309, 496 construction of, 495. Seealso xsl:text; xsl:value-of deﬁnition of, 1230 in sequence constructors, 72 sequence of, type error and, 498 string value, 51 stripped, 143 text   and, 671 whitespace-only. See whitespace-only text nodes zero-length, 258, 304, 496  text output method, 44, 423, 940. Seealsoserialization  encoding attribute and, 940 line endings and, 940  TextTest construct, 616, 670, 698 textual substitution, 541 text xsl, 100 Thai digits, 408 third-party extensions. See vendor-speciﬁc extensions third-party function libraries, 546, 955. Seealso EXSLT  library; functx; FXSL  thousands, grouping separator and, 791 «3 »  superscript three , 849   times. Seealso dates times; xs:dateTime; xs:time  arithmetic on, 574, 577–581 current. See current-dateTime  ; current-time   formatting, 738–739, 781. Seealso  format-dateTime  ; format-time    ISO format, 785  time-sequence data, 335 timezone s . Seealso dates; xs:dateTime  absence of, 567 dates with, 583 deﬁnition description, 806 implicit, 567, 580, 583, 585, 718, 738, 806–807  current-date   and, 583  names for, 787 part of value space, 195, 196, 197 xs:dayTimeDuration added to xs:dateTime in same,  578  timezone component, 782, 893  from xs:date, 893 from xs:dateTime, 893 from xs:time, 893  timezone-from-date   function, 893 timezone-from-dateTime   function, 893 timezone-from-time   function, 893 tiny tree  in Saxon , 1205 title attribute    , 101 title case, 783 «to» operator, 538, 633, 636–637  tokenize   function, 21, 204, 234, 278, 894–895  examples with, 637 lazy evaluation, 637 type error and, 636  regex and, 894–895 regex syntax and, 915–927 separators and, 894–895 substrings and, 894–895 xsl:analyze-string and, 895  lexical, 524 operators as, 538 xsl:number  formatting, 407 punctuation, 407  Tomcat, 1090, 1091, 1092 top-level attribute declarations. See global attribute  declarations  top-level declarations. See declarations top-level element declarations. See global element  declarations  top-level elements, 90, 1230  as declarations, 90, 104, 360. Seealso declarations deﬁnition of, 1230 as user-deﬁned elements, 104, 107–108  msxsl:script, 134  «treat as» operator  x e d n  I  xsl:import as, 357 xsl:include as, 372  top-level schema declaration, 314 top-level type deﬁnitions, 370, 557  complex, 557 simple, 371, 557  sum    totals, numeric values durations, 889–890. Seealso  trace   function, 550, 896–897. Seealso xsl:message  diagnostic output and, 896–897 optimizer and, 896 Saxon, 896 in XQuery, 897 xsl:message v., 897  traditional numbering, 783 trailing whitespace, 142, 493  normalize-space   and, 493, 845–846  trailing zeros, 300, 790 transformation process, XSLT, 67–80  error handling, 80 ﬁnal result tree of, 74 invoking transformation, 67–68 overview, 41–45 result documents in, 41–42 source documents in, 41–42 stylesheets in, 41–42 template rules, 68–74  phases of, 86 in two passes, 991 XML-to-XML, 290, 396  transformations. Seealso multiphase transformations  Transformer  JAXP class , 1181–1182 TransformerConﬁgurationExpression  JAXP class , 1182 TransformerException  JAXP class , 1182–1183 TransformerFactory  JAXP class , 1183–1185  Saxon and, 1200–1201  TransformerFactoryConﬁgurationError  JAXP class ,  TransformerHandler  JAXP class , 1185–1186 transformNode    MSXML , 941 transition aid, backward compatibility mode as, 554.  Seealso backward-compatibility mode  transitivity, 582, 586  distinct-values   and, 587 «eq» operator and, 587 xsl:for-each-group and, 587  translate   function, 63, 410, 897–898. Seealso contains  ; matches  ; replace  ; substring    TrAX, 68, 1163, 1164. Seealso JAXP «treat as» operator, 165, 371, 538, 624, 654, 668,  matches   v., 898 replace   v., 864, 898  678–680  as assertion, 678 dynamic typing and, 679  1297  tokenizing, 528–529 tokens, 528. Seealso name s ; number s ; operators  1185   «treat as» operator   continued   «treat as» operator   continued   sequence types and, 668 static typing and, 679  TreatExpr construct, 526, 678 tree s , 42, 1230. Seealsoresult trees; temporary trees  deﬁnition of, 1230 ﬁnal result, 74, 448 import, 238 linked  Saxon , 1205 with no document node, 624 non-document, 626 with root other than document node, 624, 625, 688 sequences and navigation of, 189 stylesheet, 360, 361 tiny  Saxon , 1205  tree model  family tree case study , 1050. Seealso  family tree  tree model, XDM. See XDM tree model tree models  in Saxon , 1205 tree-valued variables, 244 tree-walking, 250 trigonometrical calculations, 531, 955 trivial documents, 514 true value, booleans and, 189, 191, 194, 195 true   function, 899  boolean constant and, 779, 899 try catch mechanism, 80, 752, 774 tunnel parameters, 244, 272, 425, 429–430, 431,  1230  deﬁnition of, 1230 example, 433–437 global variables v., 431 local variables v., 431 modes and, 431 optional, 430 required, 430 side effects and, 431 «tunnel = »yes’’’’, 272 xsl:with-param and, 429, 518  tuples, 647 Turkish dotless I, 827, 910 24:00:00 time value, 743 «2 »  superscript two , 849 type s , 38–39, 185–224. Seealso type systems  abstract, 163 anonymous, 164, 313, 673 atomic. See atomic types built-in. See built-in types checking. See dynamic typing; static typing complex. See complex types concrete, 163 conversions. See type conversions default namespace for. See default namespace deﬁnition description, 185–186 derived. See derived types  1298  derived by restriction, 664 duration. See xs:dayTimeDuration; xs:duration;  xs:yearMonthDuration  element-only content, 53, 142, 156–157 error detection and, 53, 186, 221 errors. See type errors expressions and. See type expressions globally deﬁned, 315 imported from schema, 793 item types v. schema types, 219 least common, 831 list, 53, 54, 153, 163, 164 mapping Java to XPath, 961 mixed content. See mixed content names. See type names noncomparable, 329 numeric. See numeric types optimization and, 186, 431 parameter. See parameters primitive. See primitive types purpose of, 186, 219, 221 required. See required type of root expression, 624 schema. See schema types schema-deﬁned. See schema-deﬁned types sequence. See sequence types simple. See simple types simple content, 154–155, 441 union. See union types usefulness of, 186 user-deﬁned. See user-deﬁned types of variables, 501 XML Schemas, 38–39 XPath 1.0, 186–187 XPath 2.0, 186–187 XSLT 1.0, 39 XSLT 2.0, 39  of attribute as xs:QName, 393 copying, 297–298 deep-equal   and, 747 deﬁnition of, 1230 of element nodes, 307 global attribute declarations and, 673, 699 global element declarations and, 673, 699 invented name as, 313, 314 KindTest and, 697 schema-element  S  and, 674 on source documents, 467 string value, typed value, and, 54 stripping, 477 typed value of node and, 741 xs:untyped, 741 xs:untypedAtomic, 741  type annotations, 53–54, 165, 289, 293, 312, 1230   type attribute, 100, 176, 254, 293, 303, 305, 307,  type expressions, 653–680  typeswitch expression  XQuery   x e d n  I  type conversions, 81, 377. Seealso casts; conversions  312, 446  as attribute v., 178–179 default-validation and, 470 QNames and, 536 schema-aware XSLT processor and, 258 type names in, 482 validation of result document and, 173–174 [xsl:], 467 of xsl:attribute, 179, 370 of xsl:copy, 370 of xsl:copy-of, 370 of xsl:document, 370 of xsl:element, 370 of xsl:result-document, 173, 370  type checking, 273, 277, 504  backward-compatibility mode and, 549 based on schema-deﬁned types, 353 dynamic. See dynamic typing of function arguments, 1143 production rules and, 523 static. See static typing for value comparisons, 586–587  empty sequence and, 586  strong, 81–82 weak, 81–82, 220 type declarations, 303  as attribute and, 161, 514 beneﬁts of, 514 document. See DOCTYPE declaration of parameters, 161 purposes of, 161 in stylesheet, 161  type deﬁnitions, 259, 312, 1230. Seealso DTDs  anonymous, 164, 313 description of, 1230 global. See global type deﬁnition local, 315 in schemas, 653. Seealso schema types simple, 52, 152–153, 163 top-level. See top-level type deﬁnitions unnamed, 259, 314  type errors, 241, 346, 505, 1230  atomization of operands and, 573, 586 binary « » and, 603 comparison of operand types and, 582 at compile time, 506 deﬁnition of, 1230 one-or-more   and, 853 at runtime, 506 sequence of text nodes, 498 «to» operator and, 636 Venn operators and, 630  converting atomic values, 654–668 converting between derived types, 664–668 converting between primitive types, 656–664 «instance of» operator. See «instance of» operator sequence type descriptors. See sequence type  descriptors  «treat as» operator. See «treat as» operator  type hierarchy, 157–158, 162 derived numeric types, 211 derived string types, 213 extension of, in schema-aware processor,  163–164  KindTests and, 701 in XML Schema, 157–158, 162, 217–218, 219 in XPath, 218–219  type information, at compile time, 590 type labels, 664, 666  converting between derived types and, 664 empty sequence and, 634 sequences and, 634  type matching rules, 219–221, 981 type names  in cast expression, 482 QNames as, 536 in SequenceType syntax, 482 in type attribute, 482  type operators, 538 type promotion. See numeric type promotion type safety, 777 type systems, 185–186, 224. Seealso dynamic typing;  static typing; type s   item types v. schema types in, 219 purpose of, 186, 219 type expressions and, 653. Seealso schema types;  sequence types  type matching rules in, 219–221, 981 XML Schema, 38–39, 161–165, 217–218,  219, 506  XPath 1.0, 186–187, 224, 506 XPath 2.0, 186–187, 218–219, 224  type-available   function, 899–901  xsl:import-schema and, 900 [xsl:]use-when and, 900  typed values  of nodes , 52–53, 81, 165, 258, 496,  506, 548  atomization of operands and, 573, 586 data   and, 741 schema and, 741–742 string value, type annotation, and, 54 type annotation and, 741  TypeName construct, 672, 698 typeswitch expression  XQuery , 546, 669, 680  1299   typing  typing  U  dynamic. See dynamic typing static. See static typing strong, 187 weak, 39, 187, 961 XPath 1.0 and, 555  UCA. See Unicode Collation Algorithm UK phonebook, collations and, 462 UltraEdit, 1196 UML  Uniﬁed Model Language  diagram, 50  class hierarchy for nodes, 50, 56–57 sequences, items, atomic values, nodes, 188  unary minus operators, 200, 530, 572. Seealso «-» unary plus operator, 573. Seealso «+» UnaryExpr construct, 526, 572 undeclarations, namespace, 24, 58, 60, 104, 120, 391,  undeclare-preﬁxes, 120, 291, 312, 421, 422, 448, 935  935  default, 58 in-scope-preﬁxes   and, 809 namespace-uri-for-preﬁx   and, 840–841 undeclare-preﬁxes and, 447, 935  inherit-namespaces and, 935 namespace undeclarations and, 447, 935 XML 1.1 output and, 447 XML output method and, 935  undeﬁned context item, 350, 544, 736 undeﬁned order  of attributes, 316 of result of distinct-values  , 640  underﬂow, 575, 576 underscore, 534 Unicode. Seealso character encoding  4.0, 827 case mappings, 828, 910. Seealso lower-case  ;  upper-case    locale-sensitive, 828  characters, 63, 203, 281, 534  categories, 407 expressions as, 527 normalization of, 422, 447, 561, 731, 847–849 in range x80 to x9F, 937 XML 1.0, 527 XML 1.1, 527  codepoints. See codepoints consortium, 460 database, 233, 828, 922 digits, 408, 782 names for character ranges in. See character blocks private use area, 287, 943 surrogate pair, 63, 203, 460, 725, 880, 882,  884, 898  1300  Technical Report 15, 848 Technical Report 21, 827  Unicode codepoint collation, 377, 378, 460, 470, 561,  724, 731, 773, 1222  Unicode Collation Algorithm  UCA , 460, 461 Uniﬁed Model Language. See UML Uniform Resource Identiﬁers. See URIs Uniform Resource Locators. See URLs «union» operator  «» , 57, 523, 526, 538, 542, 573,  path expressions and, 599, 628. Seealso path  601, 628–631  expressions  Pattern and, 690 XQuery and, 602  union patterns, 384, 400, 419, 686 union types, 53, 54, 153, 163, 164, 1230  as content of node, 164 deﬁnition of, 1230 example, 372 in SequenceType, 372 simple types as, 653, 670 xsi:type and, 182  UnionExpr construct, 526, 629  Pattern and, 690  uniquely identiﬁed functions, 546, 559, 712 uniqueness, of parameter names, 429 United States  state example , 284 units of measure, as complex types, 213 universal quantiﬁers  logical , 646. Seealso «every»  expression  unknown instruction, 318 unnamed mode. See default mode unnamed type deﬁnition, 259  strict and, 314  unnecessary unwanted  digits, 660. Seealso round-half-to-even   function namespace declarations, 471, 473–474, 475 temporary documents, 514 whitespace-only text nodes, 143, 146, 441–442,  465, 493, 757  unordered   function, 901–902  joins and, 902 Saxon and, 901, 902 XML database and, 902  unparsed entities, 57, 902–904, 1230  deﬁnition of, 1230  unparsed-entity-public-id   function, 57, 902–904 unparsed-entity-uri   function, 57, 902–904 unparsed-text   function, 904–910. Seealso  xsl:analyze-string  comma-separated-values ﬁle, 906, 907–908 envelope payload and, 909 HTML boilerplate generation, 909–910 media-type and, 905   unpreﬁxed function names, 482, 710. Seealsospeciﬁc  resolvers  up-conversion, 906 xsl:analyze-string and, 906  unparsed-text-available   function, 904–910  doc   and document   v., 905 up-conversion, 906  unpreﬁxedfunctionnames  unpreﬁxed names  attribute, 482, 837 in expressions, 481–482 not available as function names, 546 in patterns, 481–482 xpath-default-namespace and, 481–482  unpreﬁxed QNames, 536, 766, 866 unrecognized elements, 318 unreserved characters, 772 untyped atomic values, 81–82. Seealso  xs:untypedAtomic  general comparisons and, 588 untyped source documents, 477 unwanted unnecessary. See unnecessary unwanted up-conversion, 864, 906 updateable variables, without, 274, 350 updating, variables and, 506 upper-case   function, 204, 910  case variants and, 926  upper-case lower-case letters, 461. Seealso case-order  attribute  URI Reference, 867 URI resolution, 867–869  algorithm for, 867  URI resolvers, 369, 755–756  CollectionURIResolver  Saxon , 727, 1197 OutputURIResolver  Saxon , 449, 1197 URIResolver  JAXP , 138, 567, 751, 755, 965, 1186 XmlResolver  .NET , 138, 567, 751, 755, 965  URIs  Uniform Resource Identiﬁers , 23, 755–756. See  also base URIs; collation URIs; collection URIs; namespace URIs; xs:anyURI  absolute, 58, 100, 193, 357, 373, 755 as atomic values, 760 collations identiﬁed by, 460, 561 comparing, 724 deﬁnition description, 755 dereferenced, 357, 373, 567, 755, 757 document-uri   and, 764 escape-uri-attributes. See escape-uri-attributes escaping special characters in. See percent encoding of external entity, 54 ﬁnal result trees identiﬁed by, 449 fragment identiﬁer and, 756, 905 functions on  list , 711  held in nodes, 757 IRIs converted to, 811–812  use-when attribute  x e d n  I  IRIs v., 812 mappings from, to documents, 568 not known at compile time, 263 relative. See relative URIs resolving, 867–869. Seealso resolve-uri  ; URI  result trees with same, 450 special characters in. See percent encoding URLs v., 755  URI-valued attributes, %HH encoding and, 422, 771,  772, 776, 811, 936, 938, 940  URLs  Uniform Resource Locators , 755  ampersands in, 937  URNs, 23, 903 use attribute  xsl:key , 376 global variables and, 378 values of key and, 377  use-attribute-sets attribute, 289, 352  of literal result elements, 268 of xsl:copy, 268 of xsl:elements, 268, 309  also xsl:character-map  character maps and, 447, 935, 941 HTML output method and, 939 XML output method and, 935 xsl:character-map and, 422, 447  user-deﬁned atomic types  constructor functions for, 371, 546 converting to, 371  use-character-maps attribute, 281, 421, 422, 448. See  user-deﬁned attribute declarations, 369 user-deﬁned element declarations, 369 user-deﬁned error codes, 775 user-deﬁned extensions, 318 user-deﬁned functions, 72, 346, 709. Seealso  extension functions  in C, 546 for calling, 546 in-scope functions as, 560 in Java, 546 in JavaScript, 546 same name for  vendor-supplied function, 346  user-deﬁned top-level elements, 104, 107–108 user-deﬁned types, 163, 164, 369 constructor functions and, 482 deﬁned in imported schema, 900 derived, 664, 900  user-written extension functions, 135, 953  Java JavaScript  XSLT 1.1 working draft and, 135, 953  use-when attribute, 90, 98, 112, 127, 140–141, 321,  357, 358, 467, 478–479  at compile time, 478 context, 478  1301   use-when attribute  continued   use-when attribute  continued  effective boolean value in, 478 effect usage, 478–479 element-available   and, 140–141, 478, 766 function-available   and, 478 portable extensions and, 970 system-property   function and, 370, 478, 769, 892 [xsl:], 130, 319, 468, 792, 900 xsl:import-schema and, 769 XSLT 1.0 processors and, 767  UTC, 717 UTF-8 encoding, 63, 64, 906  ASCII and, 365  UTF-16 encoding, 63  V  valid HTML, HTML output method and, 936 validating XML parsers, 62, 752, 904 validation, 113, 1230  of attributes, 179–180, 255, 258–260. Seealso  validation attribute  xs:NOTATION, 180 xs:QName, 180  context, 298 controlling, 450 of copied nodes, 297 default. See default-validation deﬁnition description of, 165, 1230 document-level, 293, 303, 305 DTD, 752, 755, 757, 805 element-level, of temporary tree, 305 of elements, 176–179, 289, 312–315 failure, 166, 259, 1230 IDs and, 803, 805  XML, 379  of literal result elements, 176 request, 166  AltovaXML, 166, 1218 Saxon, 166, 671, 1197  of result documents, 170–174, 932  example, 171–174 type attribute and, 173–174 validation attribute and, 173 XHTML, 170  schema. See schema validation of source documents, 165–170  on AltovaXML processor, 169, 1218  of temporary documents, 174–176 by XML parsers, 62, 752. Seealso DTDs  validation = lax, 173, 259, 297, 305, 371 validation = preserve, 173, 178, 260, 289, 293, 297,  305  xs:anyType and, 313  validation = strict, 173, 259, 297, 305, 371  1302  validation = strip, 173, 178, 297, 305  xs:untyped and, 314 xs:untypedAtomic and, 314  validation attribute, 173, 176, 254, 293, 297, 303,  305, 307, 313, 446  default-validation and, 470 schema-aware XSLT processor and, 258 validation of result document and, 173 values of, 173 [xsl:], 467  validation request  AltovaXML processor, 166, 1218 Saxon, 166, 671, 1197  value s . Seealso atomic values; sequence s   default. See default values of parameters. See parameters removal of duplicate, 749–750 returning any, 453 as sequences, 187 supplied, 505 term,187 of variables. See variables  value comparisons, 581–587. Seealso «eq»; «ge»; «gt»;  «le»; «lt»; «ne»  atomization and, 586 backward-compatibility rules and, 586 examples, 587 general comparison operators v., 582, 588 operand types for, 582–586 RangeExpr and, 582 type checking for, 586–587 empty sequence and, 586  XQuery and, 582 xs:untypedAtomic values and, 587  value space, 195 of dates, 786 timezone part of, 195, 196, 197  ValueComp construct, 582 van der Vlist, Eric, 151 variable binding  XSLT , 1230 variable references, 540–542, 1230  $ sign and, 540 circularity and, 683 deﬁnition of, 1230 as ﬁrst component in path expressions, 626 id   and, 704 key   and, 704 xsl:param and, 540 xsl:variable and, 540  VariableReference construct, 540 variables, 72, 81–82, 506–510, 1230. Seealso  xsl:variable  categories of, 507 context, 510 convenience, 507   deferred evaluation of, 388 deﬁnition of, 1230 dynamically scoped, 429 environment, 427 global. See global variables in-scope. See in-scope variables intermediate results in, 510 literal string value assigned to, 504 local. See local variables mathematical use of term, 989 names of, 501–502  $ sign and, 528 namespace preﬁxes in, 541  in namespaces, 559 no updateable, 274, 350 range. See range variables references to. See variable references scoping rules, 81, 268 tree-valued, 244  global, 294 type of, 501 updating and, 506 usage, 506–510 values of, 306, 503–505  as attribute and, 503, 504 dynamic context and, 566 expressions v., 604 select attribute and, 503  xsl:apply-templates and, 510 xsl:call-template and, 510 VarName construct, 640, 646 VBScript  as dynamically typed language, 959 extension functions in, 134, 957 MSXML and, 957  extension functions in, 957, 958–959  vendor portability example, 319–320 vendor-deﬁned APIs, 427 vendor-deﬁned attributes, 134 vendor-deﬁned numbering sequences, 134 vendor-deﬁned output methods, 423. Seealso  serialization  vendor-speciﬁc extensions, 107, 134, 318, 319,  954–955. Seealso extension functions  allowed, 954–955 context environment and, 954 function-available   and, 794 implementation-deﬁned XSLT language behavior and,  954–955  testing for, 769–770 variance in, 953  vendor-supplied functions, 709  for calling, 546 user-deﬁned function name and, 346  weeks of year  x e d n  I  Venn operators, 599, 629. Seealso «except»;  «intersect»; «union»  combining sets of nodes with, 628–631 examples of, 630 type errors and, 630  version = ‘‘1.0,” 480 version = ‘‘1.1’’, 291 version = ‘‘2.0,” setting of, 1142–1144  arithmetic operators and, 1143 comparison operators and, 1143 empty sequence and, 1143–1144 error semantics for «and» and «or», 1144 ﬁrst node rule, 1142–1143 type checking of function arguments, 1143  version attribute, 98, 318, 358, 374, 421, 422, 468,  479–480, 496, 935–936  effect usage, 479–480 forward backward compatibility modes, 479, 496  XSLT 1.0 processor, 479 XSLT 2.0 processor, 479  HTML version and, 939 XML version and, 935–936 XMLSpy and, 479 [xsl:], 318  version compatibility, 128–134. Seealso  backward-compatibility mode; forward-compatibility mode  versions  XSLT   browsers and different, 318 effective, 318 element-available   and, 766–769 future, 318 testing, 321  versions, of same schema, 370 vertical bar symbol. See «»; «union» operator visitor pattern, 250. Seealso patterns VoiceXML, 7  W  W3C  World Wide Web Consortium , 21, 25. Seealso  Recommendations  Walmsley, Priscilla, 151, 546  third-party function library, 546  WD-xsl, 467 weak collations, 378, 461, 562, 584 weak conversions, 81–82, 220 weak typing, 39, 187, 961. Seealso dynamic typing  XPath 1.0 and, 555  Web documents, doc   and, 751 Web servers, XSLT processors running within, 430 week numbers, ISO, 787 weeks of month, 782 weeks of year, 782 numbering, 785  1303   weights  weights  in non-Latin scripts, 461 primary, 461 secondary, 461 tertiary, 461  wellbalanced,48 well-balanced XML fragment, 48, 1230–1231 well-formed documents, 48, 174, 304, 305, 309, 671,  700, 929–930, 1231  deﬁnition of, 1231 external parsed entities v., 930–931 not required by XDM, 304, 309 prerequisite for validity, 174, 305 rules for, 930 temporary document and, 87 well-balanced fragment v., 48 XML output method and, 929–932  while loop, 274 whitespace, 72, 141–149, 241, 493–494, 1231. See  also line ending; newline; nonbreaking space; spaces  «-» and need for, 538 AltovaXML and, 1216 characters, 63, 440. Seealso carriage return;  349  349  X  linefeed; spaces; tab  collapse, 143, 214 deﬁnition of, 142, 845, 1231 facet, 143, 214, 663, 665, 846 insigniﬁcant, 142, 465 leading, 142, 493 lexical rules  XPath  and, 524 between lexical tokens, 524 matching with \s  regex , 921 normalization, 528, 663, 665 normalize-space   and, 493, 845–846 operators and, 538 preserving, 143, 214, 439–442 in regex, 926 replace, 143, 214 signiﬁcant, 142 in source document, 141 within StringLiteral, 532 in stylesheets, 146–147 syntactic rules  XPath  and, 524 too little, 148 too much, 147–148 trailing, 142, 493 «x» ﬂag and, 231, 926  whitespace-only text nodes, 66, 72, 141, 146–147,  439–440  deep-equal   and, 747 handling with MSXML, 567, 1158 stripping unwanted, 143, 146, 441–442, 465,  493, 757  xsl:preserve-space and, 757  1304  xsl:strip-space and, 439–440, 465, 493, 757 xsl:text and, 492–493  whitespace-separated lists, 113  of IDs, 804 of values  normalize-space   and, 846  width modiﬁer, 782, 783 Wildcard construct, 614 words  matching in regex, 921 as numbering sequences, 409, 783 reserved, 40, 528, 616 word count example, 19–21  World Wide Web Consortium. See W3C wrapped Java object, 960 wrapper for named template, stylesheet function as,  wrapper for stylesheet function, named template as,  «x» ﬂag, 926–927  comments in regex and, 926 spaces and, 926–927 whitespace and, 231, 926  Xalan-J processor, 9, 319  extension functions and, 957 extension instructions and, 140 Java JavaScript and, 957 JAXP and, 1163  XDM tree model, 8, 42–43, 45–67, 185, 471, 1223,  1231  bottom-up process of construction, 73 characters in, 62–63 consistency rules, 310 deﬁnition description, 1223 document node in, 304 DOM v., 42, 963–965 items left out of, 64–65, 66 namespaces in, 59–60 nodes in, 49–57 sets and, 629 well formed document not required, 304, 309 XQuery support and, 66–67 xs:QName and, 857  XForms, 544  functions speciﬁc to, 553, 709 instance   function, 544 XPath within, 553, 709  XHTML, 170  empty elements, 939 ﬂat documents example, 340–342 implicit hierarchies in, 340 meta element  charset attribute , 939, 940, 941   XML Schema s   x e d n  I  namespace, NameTest and, 697 output method. See XHTML output method poem example, 171–173 result tree, 423–424  backward compatibility mode and, 424  separating data from presentation, 4 transmitting data between applications, 4  version, 67  version attribute and, 935–936  well-formed document. See well-formed documents  schema, 172 serialization. See serialization; XHTML output method speciﬁcation, 481  xml  preﬁx , 256  mapped to namespace URI  http:  www.w3.org XML 1998 namespace, 311  XHTML output method, 43, 44, 421, 423, 776,  XML 1.0  939–940. Seealso serialization  empty elements and, 939 escape-uri-attributes and, 940 HTML XML output methods v., 939 include-content-type and, 940  XInclude, 66, 567, 720, 752, 755, 757 XML  Canonical, 64 converted to canonical form, 64–65 data  non-, 209, 903, 906 data model. See XDM databases, 568 «  » and, 627 collections and, 568, 726 unordered   and, 902  data-oriented, 53, 215, 977 declaration. See XML declaration editing tools, 64 entities, 440, 1224  deﬁnition description, 1224 external parsed. See external parsed entities unparsed. See unparsed entities XML document. See well-formed documents  entity references. See entity references escaping conventions of, 527 family, XSLT and, 21–26 formats for word processor documents, 4 fragment interchange proposal, 48 Information Set, 46, 62, 64, 65 narrative, 53 NDATA and, 209, 903, 906 output method. See XML output method parsers, 8, 752  validation by, 62  Schema. See XML Schema s  serialization. See serialization; XML output method speciﬁcation, 534 speciﬁcation  case study , 1001–1048 standards, 522 syntax usage, XSLT and, 33–34 tree, 45–46  example, 46–48  up-conversion to, from Excel spreadsheets, 343 uses beneﬁts, 3–4, 215 data handling, 53, 215  Unicode characters, 527  XML 1.1, 291  output  undeclare-preﬁxes and, 447  parser, 104, 440 Unicode characters, 527 XML declaration, 931, 935  encoding attribute of, 933 not a processing instruction, 49 omit-xml-declaration and, 421, 422, 447, 935, 940 standalone property, 67 text declaration v., 931 xsl:processing-instruction and, 443  «xml» namespace, 472, 473 XML Namespaces 1.1. See Namespaces 1.1, XML XML output method, 43, 423, 929–936. Seealso  serialization  entity references and, 930 external parsed entities and, 929–932 HTML output method v., 936–937 indent attribute and, 934 internal DTD subset and, 930 namespace ﬁxup and, 932 well-formed XML documents and, 929–932 XHTML output method v., 939 XML Namespaces and, 930  XML Query Working Group, 25, 31 XML Schema s , 24–25, 151–161  books on, 151 built-in types of, 557 complex type with simple content, 154–155 complications, 25 element-only content, 53, 142, 156–157, 506, 878 IDs and, 61 mixed content. See mixed content namespace, 99, 135 numeric literals and, 531 overview, 151–161 pattern facet. See pattern facet Perl and, 829, 915 regex syntax and, 829, 915. Seealso regular  expressions  Relax NG vs.,25 simple type deﬁnitions, 52, 152–153, 163 speciﬁcation, 369 stylesheets and, 151–183  1305   XML Schema s    continued   XML Schema s    continued   substitution groups, 158–161 type hierarchy, 157–158, 162, 217–218, 219 type system, 38–39, 161–165, 217–218,  219, 506  XPath within, 553 in XSLT 2.0, 24–25, 151, 183  optional feature, 151, 183  XMLSchema  van der Vlist , 151 XML Schema 1.1, 568 expressions in, 682  XML speciﬁcation  case study , 1001–1048  cross references, 1007, 1029–1032 document header, 1012–1019 formatting, 1002–1003 HTML outline, 1008–1012 hyperlinks  cross references and, 1029–1032 preface, 1007 section headers, 1023 table of contents, 1019, 1021, 1023  list production for, 1028–1029 overlay stylesheets, 1041–1044 diffspec.xsl, 1003, 1041–1044 REC-xml.xsl, 1003, 1044  xmlspec.xsl stylesheet module, 1047 XMLSpy development environment, 10, 12, 13, 15–16, 91, 479, 1195, 1215–1216. Seealso AltovaXML processor  version attribute and, 479    processing instruction, 67, 68, 89,  90, 99–101, 149  alternate attribute, 101 charset attribute, 101 client side transformation, 100 for controlling transformation, 100 embedded stylesheet in, 469 example, 444–445 Firefox and, 101 href attribute, 100 Firefox and, 101 Internet Explorer and, 101  id attribute, 98, 469–470 Internet Explorer and, 101 in JAXP, 1184, 1189–1190 pseudo-attributes, 100–101, 444 Recommendation, 99, 444 server-side transformation, 100, 319 title attribute, 101  preface, 1004–1008 production rules, 1033–1041 section headers, 1023–1024 stylesheets for other speciﬁcations, 1044–1047  XML-to-XML transformation, 290, 396 XMLValidator  Altova , 1218–1219 XM_XPATH_FUNCTION_LIBRARY  Gestalt , 962 XM_XPATH_SYSTEM_FUNCTION  Gestalt , 962 XPath  xml:base attribute, 54, 357, 373, 374, 720, 755, 756,  funcproto.xsl, 1046–1047 xmlspec.xsl, 1047 xsl-query.xsl, 1047 xsltdiff.xsl, 1046 xslt.xsl, 1045–1046  table of contents, 1019–1023 text formatting, 1024–1028  868. Seealso base URIs  attribute value templates and, 124  xml:id, 62, 803 xml:lang, 358, 374, 409, 461, 781  attribute value templates and, 124 lang   and, 819  XmlNode  .NET class , 1159 xmlns, 17, 256  attribute value templates and, 124  xmlns=‘‘”, 311, 475. Seealso undeclarations,  XmlResolver  .NET , 138, 567, 751, 755, 965 xml:space attribute, 72, 142, 146, 358, 374, 397,  namespace  441, 492  attribute value templates and, 124 indent attribute and, 934 in stylesheet, 147  1306  chevrons and, 522 collations in, 84 conditional expressions. See conditional expressions context. See context data model. See XDM default namespaces. See default namespaces;  xpath-default-namespace  as embedded language. See embedded languages evaluation context. See evaluation context as expression language, 185, 553 expressions. See expressions functions written in, 546 grammar, 521 lexical rules. See lexical rules operators. See operators parser, 527 processor, schema-aware, 54 production rules. See production rules read-only language, 188, 526 sorting and, 562 speciﬁcation document, 522 as sublanguage. See embedded languages syntactic rules, 521, 524 syntax. See syntax XSLT and, 22–23, 39–40   xs:date  x e d n  I  xpath-default-namespace attribute, 98–99, 349, 358,  xs:anyURI, 190, 193–194  XPath 1.0  «..» and, 623 compatibility mode. See backward-compatibility mode «except» operator and, 631 «intersect» operator and, 631 type system, 186–187, 224, 506 as weakly typed language, 555  changes in arithmetic operators, 573 changes in general comparison operators, 588–589,  XPath 2.0  1143  changes in node comparisons, 594 development, 32–33 history, 22–23 path expressions changes in, 601–602 Recommendation, 82 regular expressions. See regular expressions sequence manipulation, 633. Seealso sequence  expressions  syntax, 82–83, 1117–1122 type system, 186–187, 218–219, 224 types typing, 186–187  multiple approaches to, 187 static strong, 187  374, 468, 480–482  default namespace declarations and, 480–482, 615 effect usage, 480–482 on literal result elements, 468 QNames and, 536 temporary documents and, 482 unpreﬁxed names and, 481–482  in expressions, 481–482 in patterns, 481–482  [xsl:], 481, 556, 615  XPathDocument  .NET class , 1158 XPathNavigator  .NET class , 1159 XPointer, 22, 40  fragment identiﬁer, 756 namespace declarations, 556 XPath expressions within, 553, 682  XProc, 67, 86, 448, 956  patterns in, 682 pipelines and, 992  XQJ  XQuery API for Java , 961 XQuery 1.0, 26, 541  attributes with same name in, 257 collations and, 562 data model. See XDM distinct-values   and, 750 doc   and, 751 FLWOR expression in, 602, 647–648 and functions written in XPath, 546 importing schemas and, 369 namespace declarations, 556  sequence type descriptors and, 668 static typing and, 563, 680 steps creating new nodes, 605 trace   and, 897 typeswitch expression, 546, 669, 680 «union» operator and, 602 value comparisons and, 582 variables in namespace, 559 Working Group, 25, 31 workshop, 31 XDM and, 66–67 XSLT vs.,26, 31–32  XQuery API for Java  XQJ , 961 xs namespace preﬁx  namespace  http:  www.w3.org 2001 XMLSchema , 135, 190  xsi namespace, 167  namespace alias for, 183  xs:any, 314 xs:anyAtomicType, 162, 192, 713  matching atomic values and, 670  xs:anyType, 313  sequence type descriptors and, 670 xs:untyped v., 314  codepoint-equal   and, 724 converting from string, 663 converting to other types, 657 «eq» and, 583 «lt», «le», «ge», «gt», and, 584 namespace-uri   and, 838 percent encoding in, 194 promotion of, to xs:string, 81, 427, 506, 548, 713,  838  xs:base64Binary, 190, 203, 208 converting from hexBinary, 662 converting from string, 663 converting to other types, 657 «eq» and, 584 «lt», «le», «ge», «gt», and, 585  xs:boolean. See booleans xs:boolean   constructor function, 552, 722  boolean   function v., 552  xs:byte, 211, 212 xs:date, 162, 190, 195–196  adjusting timezone, 297 converting from, 207 converting from dateTime, 658 converting from string, 663 converting to other types, 658 current, 738 day component from, 744 day of the month from, 744 «eq» and, 583 formatting, 781  1307   xs:dateTime, 190, 196–197. Seealso dates times  xs:date  continued   xs:date  continued   «lt», «le», «ge», «gt», and, 585 minus xs:date, 580  starting instants of dates and, 580  month component from, 833 partially ordered dates and, 196, 585 timezone component from, 893 xs:dayTimeDuration added to, 578 xs:time added to, 743 xs:yearMonthDuration added to, 579 year component from, 911  adjusting timezone, 297 construction of, 743  dateTime  , 743  converting from, 207 converting from date, 658 converting from string, 663 converting to other types, 658–659 current, 738 day component from, 744 day of the month from, 744 «eq» and, 583 formatting, 781 hour component, 800 «lt», «le», «ge», «gt», and, 585 minus xs:dateTime, 580  instants in time and, 580  minutes component from, 832 month component from, 833–834 seconds component from, 873–874 timezone component from, 893 xs:dayTimeDuration added to, 578 xs:yearMonthDuration added to, 579 year component from, 911  xs:dayTimeDuration, 192, 205–206  added to xs:date, 578 added to xs:dateTime, 578 added to xs:time, 578 converting to, 668 divided by xs:dayTimeDuration, 580–581 «lt», «le», «ge», «gt», and, 585 plus add subtract  xs:dayTimeDuration, 579 sum   and, 889  xs:decimal, 190, 197–198. Seealso numeric  functions  arithmetic operators and, 571 comparison of numeric values and, 585 converting from boolean, 657 converting from double, 660 converting from ﬂoat, 661 numeric overﬂow in, 661 converting from string, 663 converting to other types, 659 formatting. See format-number    1308  literal constants, 191, 530 overﬂow, 575 precision in, 575 type promotion, 572, 585 underﬂow, 575  xs:double, 198–201. Seealso numeric functions  arithmetic operators and, 554–555, 571 comparison of numeric values and, 585 conversion to, 454, 852  number   and, 852 xs:untypedAtomic and, 574 converting from boolean, 658 converting from decimal, 659  numeric overﬂow in, 659 converting from ﬂoat, 661 converting from string, 663 converting to other types, 660 formatting. See format-number   literal constants, 191, 530 NaN value, 586, 852 number   and, 851 operators functions and, 200 ordered, 199 type promotion, 572, 585 unordered, 199 XPath expressions for, 199 on xsl:variable, 455  xs:duration, 190, 205, 208–209. Seealso  xs:dayTimeDuration; xs:yearMonthDuration  arithmetic and, 578 converting from string, 663 converting to other types, 660 day component from, 745 «eq» and, 584 hour component, 801 «lt», «le», «ge», «gt», and, 585 minutes component from, 832–833 month component from, 833 seconds component from, 874–875 year component from, 911–912  xs:ENTITIES, 670 xs:ENTITY, 213, 215, 217 xs:ﬂoat, 81, 190, 193, 198, 208. Seealso numeric  functions  arithmetic operators and, 571 comparison of numeric values and, 585 converting from boolean, 658 converting from decimal, 659 converting from double, 660 converting from string, 663 converting to other types, 661 formatting. See format-number   function NaN value, 586 single-precision, 576 type promotion, 572, 585   xs:gDay, 190, 207  converting from date, 658 converting from dateTime, 658 converting from string, 663 converting to other types, 661 «eq» and, 584 «lt», «le», «ge», «gt», and, 585  xs:gMonth, 190, 207  converting from date, 658 converting from dateTime, 659 converting from string, 663 converting to other types, 661 «eq» and, 584 «lt», «le», «ge», «gt», and, 585  xs:gMonthDay, 190, 207  converting from date, 658 converting from dateTime, 659 converting from string, 663 converting to other types, 662 «eq» and, 584 «lt», «le», «ge», «gt», and, 585  xs:gYear, 190, 207  converting from date, 658 converting from dateTime, 659 converting from string, 663 converting to other types, 662 «eq» and, 584 «lt», «le», «ge», «gt», and, 585  xs:gYearMonth, 190, 207  converting from date, 658 converting from dateTime, 659 converting from string, 663 converting to other types, 662 «eq» and, 584 «lt», «le», «ge», «gt», and, 585  xs:hexBinary, 190, 203, 208  converting from base64Binary, 657 converting from string, 663 converting to other types, 662 «eq» and, 584 «lt», «le», «ge», «gt», and, 585  xs:ID, 61, 213, 215, 305, 802 xs:IDREF, 213, 215, 305  id   and, 802 idref   and, 805 meaning, 215  xs:IDREFS, 217, 305, 670  id   and, 802 idref   and, 805  xs:import, 180  xsl:import-schema and, 180  xs:int, 211, 212 xs:integer, 162, 201  arithmetic operators and, 571 atomic values, 191  xs:schema  x e d n  I  comparison of numeric values and, 585 converting from string, 667 converting to, 667–668 literal constants, 191, 530 special status, 191, 201 type promotion, 572, 585  xs:integer   constructor function, 780. Seealso ﬂoor    function  «idiv» and, 780 round   and, 872  xs:key, 179 xs:keyref, 179 xs:language, 213, 215 xs:long, 211, 212 xs:Name, 213, 215 xs:NCName, 213, 215  local-name-from-QName   and, 826 preﬁx-from-QName and, 857  xs:negativeInteger, 211, 212 xs:NMTOKEN, 189, 213, 215, 217 xs:NMTOKENS, 670 xs:nonNegativeInteger, 211, 212 xs:normalizedString, 144, 213, 214  meaning, 214 normalize-space   function v., 144, 215, 846  xs:NOTATION, 180, 190, 209–210. Seealso unparsed  entities  converting from string  not allowed , 657, 663 converting from xs:NOTATION  not allowed , 663 converting to other types, 663 DTDs and, 209 «eq» and, 584 «lt», «le», «ge», «gt», and, 585 namespace-sensitive, 260 validation of, 180  xs:pattern, 214 xs:positiveInteger, 211, 212 xs:QName, 51, 60, 190, 201–202, 261, 393. Seealso  QNames  attribute creation and, 261–263 converting from string, 664 converting to other types, 663 «eq» and, 584 local-name-from-QName   and, 826 «lt», «le», «ge», «gt», and, 585 namespace preﬁx in, 857 namespace URI of, 50–51, 840–841 namespace-sensitive, 260 node-name   and, 843–844 parts of, 857 type annotation of attribute as, 393 validation, 180 XDM and, 857 xs:redeﬁne, 370 xs:schema, 368  1309   xs:short, 211, 212 xs:simpleType, 191–192, 654 xs:string, 52, 190, 202–204, 213, 214, 215. Seealso  xs:untypedAtomic, 52, 54, 259, 297, 305, 477, 506,  xs:short  string    converting from anyURI, 657 converting from base64binary, 657 converting from date, 658 converting from dateTime, 659 converting from decimal, 659 converting from double, 660  NaN and, 660  converting from duration, 660 zero-length duration in, 660  converting from ﬂoat, 661 converting from gDay, 661 converting from gMonth, 661 converting from gMonthDay, 662 converting from gYear, 662 converting from gYearMonth, 662 converting from hexBinary, 662 converting from NOTATION, 663 converting from QName, 663 converting from time, 664 converting from xs:integer, 667 converting to derived types, 665–666 converting to other types, 663–664 schema validation rules and, 663  «eq» and, 583 literal constants, 191 «lt», «le», «ge», «gt», and, 584 meaning, 214 promotion of xs:anyURI to, 81, 427, 506,  548, 713  xs:string   function, 52 xs:time, 190, 204–205  converting from dateTime, 659 converting from string, 663 converting to other types, 664 cyclic values and, 585 «eq» and, 583 hour component, 800 «lt», «le», «ge», «gt», and, 585 minus xs:time, 580 seconds component from, 873–874 timezone component from, 893 xs:date added to, 743 xs:dayTimeDuration added to, 578  xs:token, 213, 215 xs:unique, 179 xs:unsignedByte, 211, 212 xs:unsignedInt, 211, 212 xs:unsignedLong, 211, 212 xs:unsignedShort, 211, 212 xs:untyped, 54, 297, 305, 312, 477  strip and, 314  1310  type annotation, 741 xs:anyType v., 314  548  atomic values, 191  matching, 670  atomization of operands and, 574, 586, 589 conversions of, 427, 714 converting from anyURI, 657 converting from base64binary, 657 converting from boolean, 658 converting from date, 658 converting from dateTime, 659 converting from decimal, 659 converting from double, 660 converting from duration, 660 converting from ﬂoat, 661 converting from gDay, 661 converting from gMonth, 661 converting from gMonthDay, 662 converting from gYear, 662 converting from gYearMonth, 662 converting from hexBinary, 662 converting from NOTATION, 663 converting from QName, 663 converting from string, 664 converting from time, 664 converting to boolean, 552 converting to other types, 664 converting to xs:double, 574, 589 schema validation and, 670 strip and, 314 type annotation, 741 value comparisons and, 587  xs:whiteSpace facet, 143, 214, 663, 665. Seealso  whitespace  normalize-space   and, 846  xs:yearMonthDuration, 192, 205–206  added to xs:date, 579 added to xs:dateTime, 579 converting to, 668 divided by xs:yearMonthDuration, 580–581 «lt», «le», «ge», «gt», and, 585 multiplied divided by number, 579 plus add subtract  xs:yearMonthDuration, 579 sum   and, 889  xsi namespace  xsi:nil, 167, 182–183 xsi:noNamespaceSchemaLocation,  167, 174  xsi:schemaLocation, 167, 174 xsi:type, 167, 181–182  xsi:nil, 167, 182–183, 673, 699  nilled   and, 843 question mark and, 673   xsl:character-map  x e d n  I  xsl:apply-templates, 71, 73, 82, 85, 109, 146, 238,  xsi:noNamespaceSchemaLocation, 167  in result document, 174  xsi:schemaLocation, 167, 314, 478  AltovaXML and, 671, 1217 doc   function and, 558, 671 locating schemas and, 314 in result document, 174  xsi:type, 167, 181–182, 261, 263, 314, 392  union type and, 182  [xsl:]default-collation, 112, 470 [xsl:]exclude-result-preﬁxes, 112, 118, 119, 315,  redundant namespace nodes and, 394  [xsl:]extension-element-preﬁxes, 111, 113, 118,  358, 392  138, 317  element-available   and, 766  [xsl:]inherit-namespaces, 113, 120, 310, 393 [xsl:]type attribute, 113, 176, 467. Seealso xsi:type  attribute value templates and, 124 of literal result elements, 370 [xsl:]use-attribute-sets, 113, 117 [xsl:]use-when, 112, 127, 130, 319, 468, 478. Seealso  use-when attribute  function-available   and, 792 type-available   and, 900  [xsl:]validation, 113, 176, 467 [xsl:]version, 113, 496. Seealso version attribute  simpliﬁed stylesheet and, 125  [xsl:]version attribute, 318 [xsl:]xpath-default-namespace, 481, 556, 615. Seealso  xpath-default-namespace attribute  xsl:instruction, 675–676 xsl:is-schema-aware  system property , 478, 891 xsl:product-name  system property , 891 xsl:product-version  system property , 891 xsl:schema-aware, 370 xsl:supports-backwards-compatibility  system property ,  892  xsl:supports-namespace-axis  system property , 892 xsl:supports-serialization  system property , 892 xsl:vendor  system property , 478 xsl:vendor-url  system property , 891 xsl:version  system property , 891 simplifed stylesheets and, 125  xsl:analyze-string, 109, 230–237, 278  context item and, 232, 736 ‘‘context item is not a node” error, 624 regex attribute of, 123 regex in, 123, 232–234 regex syntax and, 915–927 regex-group   and, 860–861 replace   v., 864 tokenize   and, 895 unparsed-text   and, 906 xsl:fallback and, 231, 317  xsl:matching-substring within, 386 xsl:non-matching-substring within, 402  xsl:apply-imports, 109, 237–240, 360  current template rule and, 399 import precedence and, 239 parameters and, 238 template parameters and, 238, 431 xsl:next-match v., 399, 1043 xsl:with-param and, 238, 517  240–253, 274, 332  context items and, 543, 735 context position and, 564 context size and, 564, 821 current template rule and, 399 in global variables, 245 last   and, 734, 821 match attribute and, 484 modes and, 247–251, 484, 486 result, 245–246 sorting and, 199, 241 template parameters and, 243, 431 template rule for, 362 variables and, 510 xsl:for-each v., 246–247 xsl:preserve-space and, 441 xsl:sort and, 240, 455 xsl:sort in, 455 xsl:with-param and, 240, 517  xsl:attribute, 109, 254–266  attribute node created with, 255 attribute value templates v., 122 literal result elements and, 117 namespace attribute, 255 namespace declarations and, 391 type attribute of, 179, 370 validation attribute, 179  xsl:attribute-set, 97, 105, 117, 256, 257, 260,  266–271, 309  import precedence and, 267, 361 top-level declaration, 468  xsl:call-template, 82, 109, 238, 239, 271–280  context item and, 273 current template rule and, 400 import precedence and, 272 name attribute and, 124, 272, 485 recursive use of, 275–280 result of, 273–274 template parameters and, 272, 431 variables and, 510 xsl:with-param and, 272, 517  xsl:character-map, 105, 280–282  import precedence and, 281, 361 top-level declaration, 468  1311   xsl:character-map  continued   xsl:copy-of, 109, 110, 166, 261, 292–298, 332, 351  xsl:character-map  continued   use-character-maps and, 422, 447 xsl:output-character in, 424  xsl:choose, 109, 282–284  conditional expressions v., 552–553 evaluation of, 552 xsl:if v., 355 xsl:otherwise within, 420 xsl:when in, 515  xsl:comment, 109, 285–287 xsl:copy, 110, 287–291  acquiring namespace nodes with, 392 attribute creation and, 260–261 default-validation and, 471 identity template. See identity template type attribute of, 370 use-attribute-sets attribute of, 268 xsl:copy-of v., 179  attribute creation and, 260–261 default-validation and, 471 instruction, 292 type attribute of, 370 xsl:copy v., 179 xsl:value-of v., 499  xsl:decimal-format, 106, 298–302  countries languages and, 301 digits in, 302 format-number   and, 789 formatting and, 403 grouping-separator in, 300, 790 groups of digits in, 300, 790 import precedence and, 299, 361 inﬁnity in, 300, 302, 790 minus-sign, 300, 789, 790 NaN and, 300, 790 pattern-separator, 300, 789 percent symbol, 300, 790  picture string, 300 per-mille, 300, 790 picture string, 300  namespace attribute, 308 sequence constructor evaluation, 309 type attribute of, 370 use-attribute-sets attribute of, 268, 309 xsl:fallback, 110, 111, 140, 231, 316–321  different versions of XSLT and, 318 element-available   and, 766 extension elements and, 317 extension instructions and, 769 system-property   and, 892 xsl:analyze string and, 317 xsl:next-match and, 317, 399 in xsl:perform-sort, 438 xsl:result-document and, 317, 447 in xsl:sequence, 453 XSLT 1.0 processor and, 317  xsl:for-each, 85, 110, 238, 274, 322–326  context item and, 543, 735 ‘‘context item is not a node” error, 624 context position and, 564 context size and, 564, 821 current template rule and, 400 last   and, 734, 821 select attribute and, 322–323 sorting and, 199, 323–324 xsl:apply-templates v., 246–247 xsl:sort in, 323, 455  xsl:for-each-group, 110, 116, 249, 326–344  concat   and, 730 context item and, 736 current-group   and, 739 default-collation and, 470 distinct-values   v., 750 grouping keys and, 384, 816 grouping keys v., 816 «is» operator and, 593 patterns in, 681 transitivity and, 587 unparsed-text   and, 906 xsl:sort in, 330, 455  picture string, 300, 789–791  symbols in, 300  top-level declaration, 298, 468 zero-digit, 300, 789  xsl:document, 110, 303–306  type attribute of, 370 validation of temporary document and, 175 xsl:result-document v., 448  xsl:element, 110, 176, 306–316  converting attributes to child elements with, 315–316 default-validation and, 471 element created with, 307–310  content of, 307–310 name of, 307  literal result element v., 306, 308, 315  xsl:function, 82, 106, 135, 161, 252, 344–353  as attribute of, 346, 371 context item position size and, 346 conversions and, 346 declaration, 344 function-available   and, 793 import precedence and, 346, 361 override attribute, 346–347 stylesheet functions with, 106, 135, 136, 271, 344 top-level declaration, 345, 469 writing functions with, 136 xsl:param in, 425 xsl:sequence in, 453  xsl:if, 110, 353–356 boolean   and, 722 effective boolean value in, 354  1312   xsl:otherwise  x e d n  I  xsl:include, 45, 91, 94, 106, 358, 372–375  xsl:non-matching-substring, 231, 402–403  evaluation of, 552 xsl:choose v., 355  precedence  xsl:import, 45, 91, 94, 106, 357–368. Seealso import  class hierarchy, 95 customizing presentation with, 368 in example, 95–98 href attribute of, 357 import precedence and, 94, 148, 357, 358, 362 top-level declaration, 469 as top-level element, 357 xsl:include v., 94  xsl:import-schema, 106, 163, 180, 192, 259, 313,  368–372, 669  declarations  multiple, 370 non-schema-aware processor and, 370  import precedence and, 362, 370 in-scope schema deﬁnitions and, 557 namespace attribute, 180 not necessary to import every schema with, 370 schema-location attribute, 181, 369 system-property   and, 769 top-level declaration, 368, 469 type-available   and, 900 use-when and, 769 xs:import and, 180  example with, 91–95 href attribute of, 373 import precedence and, 148, 362 modes and, 374 with named attribute sets, 375–376 stylesheet modules and, 372 top-level declaration, 469 as top-level element, 372 xsl:import v., 94  xsl:key, 85, 106, 376–385  concat   and, 730 declarations with same name, 383–384 default-collation and, 470 faster access with, 378 import precedence and, 362 index hash table and, 379 key deﬁnitions in, 812 key   and, 812 match attribute of, 377 optimization of joins and, 644 patterns in, 681 top-level declaration, 376, 469 use attribute, 376  global variables and, 378 values of key and, 377  xsl:matching-substring, 231, 386  regex and, 386 within xsl:analyze-string, 386  xsl:message, 69–70, 110, 386–390 diagnostic output from, 388, 897 error conditions and, 388 error   and, 775 languages and, 389 MSXML parser and, 388 terminate attribute, 386, 387 trace   v., 897 xsl:result-document v., 387  xsl:namespace, 60, 110, 256, 262, 311, 390–393  literal result elements and, 121 namespace node construction with, 390 xsl:namespace-alias, 106, 121, 394–399  import precedence and, 362 stylesheet production and, 394 top-level declaration, 394, 469  xsl:next-match, 110, 238, 399–402  current template rule and, 399–400 instruction, 399 subtypes and, 701 template parameters and, 400, 431 template rules of lower precedence and,  1043  xsl:apply-imports v., 399, 1043 xsl:fallback and, 317, 399 xsl:with-param and, 400, 517  regex and, 402 within xsl:analyze-string, 402  xsl:number, 110, 146, 403–419. Seealso level  attribute  from attribute and, 412, 417 count attribute, 411–412 count   v., 734 digits in, 408–409 format attribute in, 407 format string and, 405, 407–408 format-number   v., 403, 406, 791 formatting numbers with, 403, 408–410 grouping-separator in, 409 groups of digits in, 409 lang attribute of, 409 languages and, 409 patterns in, 681 position   v., 856 punctuation tokens, 407 sequence number and, 405–407 tokens  formatting, 407 punctuation, 407  xsl:sort and, 856  xsl:otherwise, 109, 283, 420  within xsl:choose, 420 xsl:when and, 420, 516  1313   xsl:param, 68, 82, 106, 109, 161, 244, 272, 346, 362,  400, 425–437  as attribute of, 371, 425, 427–428 with default value  example , 432–433 global parameters and, 425, 427 import precedence and, 362 local parameters to templates functions and, 425,  xsl:sequence, 71, 110, 271, 351, 353, 452–455  xsl:sort, 109, 199, 240, 241, 242, 323, 328, 455–464  xsl:output  xsl:output, 43–44, 106, 280, 420–424. Seealso  serialization; xsl:character-map; xsl:result-document  character encoding in, 422 encoding attribute of, 421–422, 941 escape-uri-attributes in, 422 import precedence and, 362, 423 include-content-type in, 421, 422 media-type in, 421, 422 result document and, 420 Saxon extensions and, 1208 serialization and, 940–941 serialization attributes in, 421–422 top-level declaration, 469 XHTML and, 421 xsl:result-document and, 421  xsl:output-character, 281, 424–425  character attribute, 425 character maps and, 425 in xsl:character-map, 424  427  overriding, 431 required attribute, 238, 244, 273, 428, 487 select attribute and, 428 top-level declaration, 469 variable references and, 540 in xsl:function, 425 in xsl:template, 425, 484, 487 xsl:variable v., 429, 502  xsl:perform-sort, 71, 110, 331, 343, 437–438  global variables and, 438 sorting sequences with, 437, 438 whitespace-only text nodes and, 439–440 xsl:fallback in, 438 xsl:sort in, 438, 455  xsl:preserve-space, 106, 142, 439–442  element names in, 440, 482 import precedence and, 362 position   function and, 441 QNames and, 536 top-level declaration, 439, 469 whitespace-only text nodes and, 757 xsl:apply-templates and, 441 xsl:strip-space and, 439, 465  xsl:processing-instruction, 110, 442–445  XML declaration and, 443  xsl:result-document, 45, 68, 110, 445–452  attribute value templates in, 448  1314  character encoding in, 447 default-validation and, 471 encoding attribute of, 447–448 escape-uri-attributes in, 447 format attribute in, 446, 448 href attribute of, 446 include-content-type in, 447, 448 instruction, 446 media-type in, 447, 448 result trees and, 445  creation of, 445 serialization of, 107, 445  Saxon extensions and, 1208 serialization attributes in, 446–447 side effects, 449 type attribute of, 173, 370 validation attribute of, 173 xsl:document v., 448 xsl:fallback and, 317, 447 xsl:message v., 387 xsl:output and, 421  xsl:fallback in, 453 in xsl:function, 453 xsl:value-of v., 454  attributes as attribute value templates in, 330 in backward-compatibility mode, 459 concat   and, 730 constructor functions and, 459 context item, 457 context position, 457 context size, 457 conversions and, 459 current-group   and, 739 data-type and, 456, 458 default collation, 461 default-collation and, 470 lang attribute of, 456, 460 languages and, 456, 460 last   within select expression of, 823 sequence constructor in, 457 sort keys and, 455. Seealso sort key s  stable attribute, 242, 324, 456, 457, 458 xsl:apply-templates and, 240, 455 in xsl:for-each, 323, 455 in xsl:for-each-group, 330, 455 xsl:number and, 856 in xsl:perform-sort, 438, 455  xsl:strip-space, 46, 106, 142, 143, 148, 465  element names in, 465, 482 import precedence and, 362 normalize-space   v., 846 QNames and, 536 top-level declaration, 465, 469   XSLT  Extensible Stylesheet Language: Transformations   x e d n  I  whitespace-only text nodes and, 439–440, 465,  493, 757  xsl:preserve-space and, 439, 465  xsl:stylesheet, 89, 94, 98–99, 148, 318, 374,  465–482. Seealso xsl:transform  attributes on, 98–99 namespace declarations on, 99, 466–467 top-level declarations in, 468–469 xsl:transform v., 465, 495  xsl:template, 68, 70, 106, 161, 242, 272, 483–491  temporary tree and, 619 top-level declaration, 469, 500 variable references and, 540 xs:double on, 455 xsl:param v., 429, 502 xsl:when, 283, 515–516  boolean   and, 722 effective boolean value in, 516 test expression, 283 in xsl:choose, 515 xsl:otherwise and, 420, 516  as attribute of, 371, 487 evaluating templates, 486–487 import precedence and, 243, 362 match attribute of, 68, 484–485  errors and, 485 global parameters and, 485 global variables and, 378, 485 pattern, 484 template rules and, 487 xsl:apply-templates and, 484  patterns and, 483, 484, 681 priority attribute of, 79 SequenceType and, 484 top-level declaration, 469 xsl:param in, 425, 484, 487  xsl:text, 69, 110, 146, 148, 492–494  disable-output-escaping and, 492, 493, 945 literal text and, 492 in sequence constructor, 492 whitespace-only text nodes and, 492–493  xsl:transform, 89, 94, 98, 495. Seealso xsl:stylesheet  xsl:stylesheet v., 465, 495  xsl:value-of, 110, 351, 495–500  concat   v., 730 disable-output-escaping and, 496, 497, 945 instruction, 495 select attribute and, 496 sequence constructors and, 495 string-join   v., 880 strings returned from function and, 497–498 temporary trees and, 497 unexpected results from, 498–500 unthinking usage of, 497 value of node as string and, 496 xsl:copy-of v., 499 xsl:sequence v., 454  xsl:variable, 106, 110, 161, 500–515. Seealso  variables; xsl:param  as attribute of, 274, 371 global variables and, 501 import precedence and, 362 local variables and, 501 select attribute in, 501 sequence constructor in, 501 SequenceType and, 501  xsl:with-param, 82, 109, 238, 240, 272, 400, 487,  517–518  as attribute of, 371, 518 template parameters and, 431, 517–518 tunnel parameters and, 429, 518 value of parameter and, 517–518 xsl:apply-imports and, 238, 517 xsl:apply-templates and, 240, 517 xsl:call-template and, 272, 517 xsl:next-match and, 400, 517  XSL  Extensible Stylesheet Language , 22  ambiguity of term, 22 history, 26–33  ﬁrst proposal, 28–30 prehistory, 26–28  ‘‘A Proposal for XSL,” 28–29 purpose of, 28–29 WD-xsl and, 467 Working Group, 26, 30, 31  XSL Formatting Objects  XSL-FO , 22, 268, 410 XSL-FO. See XSL Formatting Objects xsl-query.xsl stylesheet module, 1045, 1046, 1047 XSLT  Extensible Stylesheet Language:  Transformations   CSS vs.,24, 982  family tree case study, 1080, 1081  as declarative language, 8, 40, 979 deﬁned, 3–5 design themes, 5 elements, 227–519 extensibility. See extensibility, XSLT formatting stage, 7 functions, 546   list , 712  instructions, 108–110, 764   full list , 109–110, 765 element-available   and, 764–770  language characteristics, 33–40  computational power, 1099, 1112 general-purpose programming, 1113 implementation-deﬁned, 954–955 manipulation reporting tool for complex structured  data, 1049, 1050, 1098  no side effects principle, 29, 34–35, 69–70, 350  1315   XSLT  Extensible Stylesheet Language: Transformations    continued   XSLT  Extensible Stylesheet Language:  type system based on XML Schema. See type  Transformations   continued  rule-based structure, 35–38, 41 types based on XML Schema, 38–39 XML syntax usage, 33–34 XPath as embedded language, 22, 39–40, 527,  553. Seealso embedded languages  for loop and, 274 namespace, 466, 471, 475 patterns. See patterns processing model. See processing model, XSLT processors. See processors, XSLT SQL vs.,8–9 structural transformation, 7 transformation task, 3 versions. See versions while loop and, 274 without updateable variables, 274, 350 XML family and, 21–26 XML namespaces and, 23–24 XPath and, 22–23, 39–40 XQuery vs.,26, 31–32 XSL-FO and, 22  XSLT 1.0  ’ﬁrst item’ rule, 132, 133, 480, 498, 1142–1143 forward compatibility in, 130–131, 479 processors, 9–10  element-available   and, 766 multiple result documents and, 44–45, 319–320 use-when attribute and, 767 version attribute and, 479 xsl:fallback and, 317  Recommendation, 28, 30, 479 transition stages to XSLT 2.0, 1139–1145 type system, 39 XSLT 2.0 vs.,5  XSLT 1.1 working draft, 30–31  extension functions in Java JavaScript and,  135, 953  XSLT 2.0  xsl:document in, 303. Seealso xsl:document  changes in patterns, 682–683 development, 5, 32–33 forward backward compatibility modes, 479 minimum set of atomic types, 669–670 Recommendation, 5, 32–33, 479 requirements, 32 schema for stylesheets, 352  examples, 674–677  schema processing in, 151, 183  optional, 151, 183  stylesheet changes in, 90 system properties  list , 891–892 transition stages from XSLT 1.0 to, 1139–1145  1316  systems  XML Schemas in, 24–25, 151, 183  optional feature, 151, 183  XSLT 1.0 vs.,5 XSLT 1.1 vs.,30–31 XSLT namespace, 765  instructions in, 317, 765 namespace declarations, 466, 765  XSLT2 object  Altova , 1219 XSLTC, 10 xsltdiff.xsl stylesheet module, 1046 XslTransform  .NET class , 1159–1160 xslt.xsl stylesheet module, 1045–1046 xt processor, 319, 320, 550. Seealso Clark, James  forward-compatible processing and, 320  year component  from xs:date, 911 from xs:dateTime, 911 from xs:duration, 911–912  year, negative, 196 year-from-date   function, 911 year-from-dateTime   function, 911 years-from-duration   function, 911–912  Y  Z  zero s   division by, 574, 575 ﬁnite nonzero values, 198 formatting, 409 leading, 300, 783, 790 or more predicates, 620 negative, 199, 576, 723 positive, 198, 576 trailing, 300, 790 zero sign, Greek, 460 zero-digit  xsl:decimal-format , 300, 789 zero-length duration, 660 zero-length strings, 203, 243, 308  default value as, 503 empty sequences and, 203 empty   and, 770 namespace URIs and, 391 regex and, 231, 863 relative reference of, 868 string-length   and, 881  zero-length text nodes, 258, 304, 496 zero-or-one   function, 912–913. Seealso exactly-one  ;  one-or-more    static type checking and, 912–913   Programmer to Programmer TM  Take your library  wherever you go.  Now you can access more than 200 complete Wrox books  online, wherever you happen to be! Every diagram, description,  screen capture, and code sample is available with your  subscription to the Wrox Reference Library. For answers when  and where you need them, go to wrox.books24x7.com and  subscribe today!  Find books on  cid:127  ASP.NET   cid:127  C C++   cid:127  Database   cid:127  General    cid:127  Java  cid:127  Mac  cid:127  Microsoft Office    cid:127  .NET   cid:127  Open Source   cid:127  PHP MySQL   cid:127  SQL Server   cid:127  Visual Basic   cid:127  Web  cid:127  XML   www.wrox.com   XSLT 2.0 and XPath 2.0 4th Edition  Programmer’s Reference  XSLT 2.0 and XPath 2.0  Programmer’s Reference 4th Edition 978-0-470-19274-0 Combining coverage of XSLT 2.0 and XPath 2.0 into one  book, this authoritative reference from author Michael Kay  is a detailed reference to the elements of the XSLT 2.0  language and the fundamentals of XPath, complete with  syntax, practical usage advice, and examples.  Professional XML 978-0-471-77777-9 From document type definitions and XQuery to Web  services and form development, this book takes readers  through all of the XML capabilities that companies want  to implement today. It not only covers the basics of XML  and the XML specification, but also shows readers the  XML-based applications that are driving the tech industry  forward, such as blogging and alerts.  Beginning XML, 4th Edition 978-0-470-11487-2 The perfect resource for beginning XML programmers, this  guidebook clearly shows readers what XML is, how to use it,  and what technologies surround it. The authors build on the strengths of previous editions while covering the latest changes in the XML landscape such as XQuery, RSS and Atom, and Ajax. The most recent specifications are  presented along with best practices to follow when  developing XML solutions.  Programmer’s Reference  Enhance Your Knowledge  Advance Your Career   XSLT 2.0 and XPath 2.0 4th Edition  Wrox Programmer to Programmer TM  Programmer’s Reference  Programmer’s Reference  Combining coverage of XSLT 2.0 and XPath 2.0 into one book, this  authoritative reference provides equal weight to the powerful new features  of XSLT 2.0 and XPath 2.0 and the established capabilities of the 1.0  versions. Author Michael Kay has created his own implementation of XSLT  2.0  Saxon , and he puts his unique knowledge to work in this detailed  reference to the elements of the XSLT 2.0 language and the fundamentals  of XPath, complete with syntax, practical usage advice, and examples. The book begins by teaching the essential concepts behind the  language, knowledge you need if you are going to write good code  rather than just working code. You will discover how XSLT and XPath  differ from other languages, and how you use them to create effective  web-based applications. The central chapters provide meticulous  coverage of the language features of XSLT 2.0 and XPath 2.0. You will  return to this reference whenever you encounter new programming  challenges. You finish with detailed case studies highlighting real  applications to give you insights you would otherwise gain only from  months of practical experience.  What you will learn from this book ●  All the XSLT elements you can use in a stylesheet and the detailed   rules for the syntax and semantics of each  ●  How Path expressions enable you to navigate around the structure of   an XML document  ●  How you can improve your stylesheets by taking advantage of the XML   Schema definitions of input and output documents  ●  How to take advantage of vendor extensions without losing portability ●  Techniques for taking advantage of XSLT to write real applications   Enhance Your Knowledge  Advance Your Career  Who this book is for This book is for experienced programmers who are looking to become proficient with XSLT 2.0. Previous experience with  XSLT or XPath is not necessary. However, a working knowledge of XML, HTML, and web architecture is beneficial.   Wrox Programmer’s References are designed to give the experienced developer straight facts on a new technology, without  hype or unnecessary explanations. They deliver hard information with plenty of practical examples to help you apply new  tools to your development projects today.   Recommended  Computer Book   Categories  Programming Languages  XML  www.wrox.com  ISBN: 978-0-470-19274-0  $59.99 USA $65.99 CAN

@highlight

This book is primarily a practical reference book for professional XSLT developers. It assumes no previous knowledge of the language, and many developers have used it as their first introduction to XSLT; however, it is not structured as a tutorial, and there are other books on XSLT that provide a gentler approach for beginners.The book does assume a basic knowledge of XML, HTML, and the architecture of the Web, and it is written for experienced programmers. There’s no assumption that you know any particular language such as Java or Visual Basic, just that you recognize the concepts that all programming languages have in common.The book is suitable both for XSLT 1.0 users upgrading to XSLT 2.0, and for newcomers to XSLT. The book is also equally suitable whether you work in the Java or .NET world.As befits a reference book, a key aim is that the coverage should be comprehensive and authoritative. It is designed to give you all the details, not just an overview of the 20 percent of the language that most people use 80 percent of the time. It’s designed so that you will keep coming back to the book whenever you encounter new and challenging programming tasks, not as a book that you skim quickly and then leave on the shelf. If you like detail, you will enjoy this book; if not, you probably won’t.But as well as giving the detail, this book aims to explain the concepts, in some depth. It’s therefore a book for people who not only want to use the language but who also want to understand it at a deep level.The book aims to tell you everything you need to know about the XSLT 2.0 language. It gives equal weight to the things that are new in XSLT 2.0 and the things that were already present in version 1.0. The book is about the language, not about specific products. However, there are appendices about Saxon (the author’s own implementation of XSLT 2.0), about the Altova XSLT 2.0 implementation, and about the Java and Microsoft APIs for controlling XSLT transformations, which will no doubt be upgraded to handle XSLT 2.0 as well as 1.0. A third XSLT 2.0 processor, Gestalt, was released shortly before the book went to press, too late to describe it in any detail. But the experience of XSLT 1.0 is that there has been a very high level of interoperability between different XSLT processors, and if you can use one of them, then you can use them all.In the previous edition we split XSLT 2.0 and XPath 2.0 into separate volumes. The idea was that some readers might be interested in XPath alone. However, many bought the XSLT 2.0 book without its XPath companion and were left confused as a result; so this time, the material is back together. The XPath reference information is in self-contained chapters, so it should still be accessible when you use XPath in contexts other than XSLT.The book does not cover XSL Formatting Objects, a big subject in its own right. Nor does it cover XML Schemas in any detail. If you want to use these important technologies in conjunction with XSLT, there are other books that do them justice.This book contains twenty chapters and eight appendixes (the last of which is a glossary) organized into four parts. The following section outlines what you can find in each part, chapter, and appendix.Part I: Foundations: The first part of the book covers essential concepts. You should read these before you start coding. If you ignore this advice, as most people do, then you read them when you get to that trough of despair when you find it impossible to make the language do anything but the most trivial tasks. XSLT is different from other languages, and to make it work for you, you need to understand how it was designed to be used.Chapter 1: XSLT in Context: This chapter explains how XSLT fits into the big picture: how the language came into being and how it sits alongside other technologies. It also has a few simple coding examples to keep you alert.Chapter 2: The XSLT Processing Model: This is about the architecture of an XSLT processor: the inputs, the outputs, and the data model. Understanding the data model is perhaps the most important thing that distinguishes an XSLT expert from an amateur; it may seem like information that you can’t use immediately, but it’s knowledge that will stop you making a lot of stupid mistakes.Chapter 3: Stylesheet Structure: XSLT development is about writing stylesheets, and this chapter takes a bird’s eye view of what stylesheets look like. It explains the key concepts of rule-based programming using templates, and explains how to undertake programming-in-the-large by structuring your application using modules and pipelines.Chapter 4: Stylesheets and Schemas: A key innovation in XSLT 2.0 is that stylesheets can take advantage of knowledge about the structure of your input and output documents, provided in the form of an XML Schema. This chapter provides a quick overview of XML Schema to describe its impact on XSLT development. Not everyone uses schemas, and you can skip this chapter if you fall into that category.Chapter 5: The Type System: XPath 2.0 and XSLT 2.0 offer strong typing as an alternative to the weak typing approach of the 1.0 languages. This means that you can declare the types of your variables, functions, and parameters, and use this information to get early warning of programming errors. This chapter explains the data types available and the mechanisms for creating user-defined types.Part II: XSLT and XPath Reference: This section of the book contains reference material, organized in the hope that you can easily find what you need when you need it. It’s not designed for sequential reading, though you might well want to leaf through the pages to discover what’s there.Chapter 6: XSLT Elements: This monster chapter lists all the XSLT elements you can use in a stylesheet, in alphabetical order, giving detailed rules for the syntax and semantics of each element, advice on usage, and examples. This is probably the part of the book you will use most frequently as you become an expert XSLT user. It’s a “no stone unturned” approach, based on the belief that as a professional developer you need to know what happens when the going gets tough, not just when the wind is in your direction.Chapter 7: XPath Fundamentals: This chapter explains the basics of XPath: the low-level constructs such as literals, variables, and function calls. It also explains the context rules, which describe how the evaluation of XPath expressions depends on the XSLT processing context in which they appear.Chapter 8: XPath: Operators on Items: XPath offers the usual range of operators for performing arithmetic, boolean comparison, and the like. However, these don’t always behave exactly as you would expect, so it’s worth reading this chapter to see what’s available and how it differs from the last language that you used.Chapter 9: XPath: Path Expressions: Path expressions are what make XPath special; they enable you to navigate around the structure of an XML document. This chapter explains the syntax of path expressions, the 13 axes that you can use to locate the nodes that you need, and associated operators such as union, intersection, and difference.Chapter 10: XPath: Sequence Expressions: Unlike XPath 1.0, in version 2.0 all values are sequences (singletons are just a special case). Some of the most important operators in XPath 2.0 are those that manipulate sequences, notably the «for» expression, which translates one sequence into another by applying a mapping.Chapter 11: XPath: Type Expressions: The type system was explained in Chapter 5; this chapter explains the operations that you can use to take advantage of types. This includes the «cast» operation which is used to convert values from one type to another.A big part of this chapter is devoted to the detailed rules for how these conversions are done.Chapter 12: XSLT Patterns: This chapter returns from XPath to a subject that’s specific to XSLT. Patterns are used to define template rules, the essence of XSLT’s rule-based programming approach. The reason for explaining them now is that the syntax and semantics of patterns depends strongly on the corresponding rules for XPath expressions.Chapter 13: The Function Library: XPath 2.0 includes a library of functions that can be called from any XPath expression; XSLT 2.0 extends this with some additional functions that are available only when XPath is used within XSLT. The library has grown immensely since XPath 1.0. This chapter provides a single alphabetical reference for all these functions.Chapter 14: Regular Expressions: Processing of text is an area where XSLT 2.0 and XPath 2.0 are much more powerful than version 1.0, and this is largely through the use of constructs that exploit regular expressions. If you’re familiar with regexes from languages such as Perl, this chapter tells you how XPath regular expressions differ. If you’re new to the subject, it explains it from first principles.Chapter 15: Serialization: Serialization in XSLT means the ability to generate a textual XML document from the tree structure that’s manipulated by a stylesheet. This isn’t part of XSLT processing proper, so (following W3C’s lead) it’s separated it into its own chapter. You can control serialization from the stylesheet using an declaration, but many products also allow you to control it directly via an API.Part III: Exploitation: The final section of the book is advice and guidance on how to take advantage of XSLT to write real applications. It’s intended to make you not just a competent XSLT coder, but a competent designer too.